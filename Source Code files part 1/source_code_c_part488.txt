;

    if(V_VT(&minBufferedMediaDur) == VT_NULL)
    {
        clearFlag = true;
    }
    else
    {
        hr = v.ChangeType(VT_BSTR, &minBufferedMediaDur);

        if (FAILED(hr))
        {
            goto done;
        }
    }

    if(!clearFlag)
    {
        //Set value
    }
    else
    {
        //Set value to default
    }

done:
    return S_OK;
}



STDMETHODIMP
CTIMEMediaElement::get_downloadTotal(VARIANT * downloadTotal)
{
    HRESULT hr;
    LONGLONG lldownloadTotal;
    
    if (downloadTotal == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (!m_Player)
    {
        hr = S_FALSE;
        goto done;
    }

    if (FAILED(THR(m_Player->GetDownloadTotal(lldownloadTotal))))
    {
        hr = S_FALSE;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(downloadTotal))))
    {
        hr = S_FALSE;
        goto done;
    }

    downloadTotal->vt = VT_R8;
    downloadTotal->dblVal = lldownloadTotal; //ISSUE use LONGLONG variants, not tolerated by script.

    hr = S_OK;
  done:
    return hr;
}

STDMETHODIMP
CTIMEMediaElement::get_downloadCurrent(VARIANT * downloadCurrent)
{
    HRESULT hr;
    LONGLONG lldownloadCurrent;
    
    if (downloadCurrent == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (!m_Player)
    {
        hr = S_FALSE;
        goto done;
    }

    if (FAILED(THR(m_Player->GetDownloadCurrent(lldownloadCurrent))))
    {
        hr = S_FALSE;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(downloadCurrent))))
    {
        hr = S_FALSE;
        goto done;
    }
    downloadCurrent->vt = VT_R8;
    downloadCurrent->dblVal = lldownloadCurrent; //ISSUE use LONGLONG variants, not tolerated by script.

    hr = S_OK;
  done:
    return hr;
}

STDMETHODIMP
CTIMEMediaElement::get_isStreamed(VARIANT_BOOL * isStreamed)
{
    HRESULT hr;
    bool fIsStreamed;
    
    if (isStreamed == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (!m_Player)
    {
        hr = S_FALSE;
        goto done;
    }

    if (FAILED(THR(m_Player->GetIsStreamed(fIsStreamed))))
    {
        hr = S_FALSE;
        goto done;
    }

    if(fIsStreamed)
    {
        *isStreamed = VARIANT_TRUE;
    }
    else
    {
        *isStreamed = VARIANT_FALSE;
    }

    hr = S_OK;
  done:
    return hr;
}

STDMETHODIMP
CTIMEMediaElement::get_bufferingProgress(VARIANT * bufferingProgress)
{
    HRESULT hr;
    double dblpctProgress = 0.0;
    
    if (bufferingProgress == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (!m_Player)
    {
        hr = S_FALSE;
        goto done;
    }

    if (FAILED(THR(m_Player->GetBufferingProgress(dblpctProgress))))
    {
        hr = S_FALSE;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(bufferingProgress))))
    {
        goto done;
    }
    bufferingProgress->vt = VT_R8;
    bufferingProgress->dblVal = dblpctProgress;

    hr = S_OK;
  done:
    return hr;
}


STDMETHODIMP
CTIMEMediaElement::get_hasDownloadProgress(VARIANT_BOOL * hasDownloadProgress)
{
    HRESULT hr;
    bool fhasDownloadProgress = true;
    
    if (hasDownloadProgress == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (!m_Player)
    {
        hr = S_FALSE;
        goto done;
    }

    if (FAILED(THR(m_Player->GetHasDownloadProgress(fhasDownloadProgress))))
    {
        hr = S_FALSE;
        goto done;
    }

    if (fhasDownloadProgress)
    {
        *hasDownloadProgress = VARIANT_TRUE;
    }
    else
    {
        *hasDownloadProgress = VARIANT_FALSE;
    }

    hr = S_OK;
  done:
    return hr;
}

STDMETHODIMP
CTIMEMediaElement::get_downloadProgress(VARIANT * downloadProgress)
{
    HRESULT hr;
    double dblpctProgress = 0.0;
    
    if (downloadProgress == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (!m_Player)
    {
        hr = S_FALSE;
        goto done;
    }

    if (FAILED(THR(m_Player->GetDownloadProgress(dblpctProgress))))
    {
        hr = S_FALSE;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(downloadProgress))))
    {
        goto done;
    }
    downloadProgress->vt = VT_R8;
    downloadProgress->dblVal = dblpctProgress;

    hr = S_OK;
  done:
    return hr;
}

STDMETHODIMP 
CTIMEMediaElement::get_mimeType(/*[out, retval]*/ BSTR *mimeType)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_SET_NULL(mimeType);

    if (!m_Player) 
    {
        goto done;
    }
    hr = m_Player->GetMimeType(mimeType);
done:
    if (FAILED(hr))
    {
        *mimeType = SysAllocString(L"");
    }
    return S_OK;
}

STDMETHODIMP
CTIMEMediaElement::seekToFrame(long lframe)
{
    HRESULT hr = S_OK;
    double dblMediaTime = 0.0;

    if(!m_Player)
    {
        hr = S_FALSE;
        goto done;
    }

    hr = m_Player->ConvertFrameToTime(lframe, dblMediaTime);
    if(FAILED(hr))
    {
        hr = S_FALSE;
        goto done;
    }

    hr = base_seekSegmentTime(dblMediaTime);
    if(FAILED(hr))
    {
        hr = S_FALSE;
    }

done:
    return hr;
}

STDMETHODIMP
CTIMEMediaElement::seekActiveTrack(double dblSeekTime)
{
    HRESULT hr = S_OK;
    double dblMediaTime = 0.0;
    CComPtr<ITIMEPlayList> spPlayList;
    CComPtr<ITIMEPlayItem> pItem;
    double dblTrackDur;

    if(!m_Player)
    {
        hr = S_FALSE;
        goto done;
    }

    hr = THR(m_Player->GetPlayList(&spPlayList));
    if (SUCCEEDED(hr))
    {

        hr = spPlayList->get_activeTrack(&pItem);
        if(FAILED(hr))
        {
            hr = S_FALSE;
            goto done;
        }

        hr = pItem->get_dur(&dblTrackDur);
        if(FAILED(hr))
        {
            hr = S_FALSE;
            goto done;
        }

        if(dblSeekTime > dblTrackDur)
        {
            goto done;
        }

        hr = m_Player->GetPlaybackOffset(dblMediaTime);
        if(FAILED(hr))
        {
            hr = S_FALSE;
            goto done;
        }
    }

    hr = base_seekSegmentTime(dblMediaTime + dblSeekTime);
    if(FAILED(hr))
    {
        hr = S_FALSE;
    }

done:
    return hr;
}

STDMETHODIMP
CTIMEMediaElement::get_activeTrackTime(double *dblActiveTrackTime)
{
    HRESULT hr = S_OK;
    double dblMediaTime = 0.0;
    CComPtr<ITIMEPlayList> spPlayList;
    CComPtr<ITIMEPlayItem> pItem;

    *dblActiveTrackTime = -1.0;

    if(!m_Player)
    {
        hr = S_FALSE;
        goto done;
    }

    hr = THR(m_Player->GetPlayList(&spPlayList));
    if (SUCCEEDED(hr))
    {
        hr = m_Player->GetEffectiveOffset(dblMediaTime);
        if(FAILED(hr))
        {
            hr = S_FALSE;
            goto done;
        }
    }
    else
    {
        hr = S_FALSE;
    }

    *dblActiveTrackTime = GetMMBvr().GetSimpleTime() - dblMediaTime;
done:
    return hr;
}

STDMETHODIMP
CTIMEMediaElement::get_currentFrame(long *currFrame)
{
    HRESULT hr = S_OK;
    LONGLONG lcurFrame = -1.0;

    if(!m_Player)
    {
        hr = S_FALSE;
        goto done;
    }

    hr = m_Player->GetCurrentFrame(lcurFrame);
    if(FAILED(hr))
    {
        hr = S_FALSE;
        *currFrame = -1;
        goto done;
    }

    *currFrame = lcurFrame;
done:
    return hr;
}


STDMETHODIMP
CTIMEMediaElement::decodeMimeType(TCHAR * header, long headerSize, BSTR * mimeType)
{
    HRESULT hr = S_OK;
    CTIMEParser pParser(header);
    TCHAR *localHeader = NULL;

    if(header == NULL || headerSize < 4)
    {
        *mimeType = SysAllocString(L"");
        goto done;
    }

    CHECK_RETURN_SET_NULL(mimeType);

    hr = pParser.ParsePlayList(NULL, true);

    if(SUCCEEDED(hr))
    {
        *mimeType = SysAllocString(L"asx");
    }
    else
    {
        *mimeType = SysAllocString(L"");
    }

done:
    return S_OK;
}

//*****************************************************************************

STDMETHODIMP
CTIMEMediaElement::InitTransitionSite (void)
{
    HRESULT hr = S_OK;

    TraceTag((tagMediaTransitionSite,
              "CTIMEMediaElement(%p)::InitTransitionSite()",
              this));

    
    if (m_Player)
    {
        hr = THR(m_Player->NotifyTransitionSite(true));
    }

done :
    RRETURN(hr);
}

//*****************************************************************************

STDMETHODIMP
CTIMEMediaElement::DetachTransitionSite (void)
{
    HRESULT hr = S_OK;

    TraceTag((tagMediaTransitionSite,
              "CTIMEMediaElement(%p)::DetachTransitionSite()",
              this));

    if (m_Player)
    {
        hr = THR(m_Player->NotifyTransitionSite(false));
    }

done :
    RRETURN(hr);
}

HRESULT 
CTIMEMediaElement::GetEventRelaySite (IUnknown **ppiEventRelaySite)
{
    HRESULT hr = S_OK;

    if (NULL == ppiEventRelaySite)
    {
        hr = E_POINTER;
        goto done;
    }

    if (!m_pBvrSite)
    {
        hr = E_POINTER;
        goto done;
    }

    hr = THR(m_pBvrSite->QueryInterface(IID_TO_PPV(IUnknown, ppiEventRelaySite)));
    if ( (FAILED(hr)) || (NULL == (*ppiEventRelaySite)) )
    {
        goto done;
    }

    hr = S_OK;
done :
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\imagedownload.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: src\time\src\imagedownload.h
//
//  Contents: classes for downloading images
//              CTableBuilder - a utility class to lazy load dlls
//              CImageDownload - Class to download Images
//              CImageDecodeEventSink - Class to recieve image download events
//
//------------------------------------------------------------------------------------
#pragma once

#ifndef _IMAGEDOWNLOAD_H
#define _IMAGEDOWNLOAD_H

#include <ocmm.h>
#include "stopstream.h"

class CImageDownload;

#include "playerimage.h"

#include "ddrawex.h"

#include "threadsafelist.h"

typedef HPALETTE (WINAPI *CREATESHPALPROC)(HDC);  
typedef HRESULT (WINAPI *GETINVCMSPPROC)(BYTE *, ULONG);
typedef HRESULT (WINAPI *CREATEURLMONPROC)(IMoniker*, LPWSTR, IMoniker**);
typedef HRESULT (WINAPI *DECODEIMGPROC)(IStream*, IMapMIMEToCLSID*, IImageDecodeEventSink*);
typedef BOOL (WINAPI * TRANSPARENTBLTPROC)(HDC hdcDesc, 
                                           int nXOriginDest, 
                                           int nYOriginDest,
                                           int nWidthDest,
                                           int nHeightDest,
                                           HDC hdcSrc,
                                           int nXOriginSrc,
                                           int nYOriginSrc,
                                           int nWidthSrc,
                                           int nHeightSrc,
                                           UINT crTransparent);

HRESULT
CreateMask(HDC hdcDest, 
           HDC hdcSrc, 
           LONG lWidthSrc, 
           LONG lHeightSrc, 
           COLORREF dwTransColor,
           HBITMAP * phbmpMask,
           bool bWin95Method = false);

HRESULT
MaskTransparentBlt(HDC hdcDest, 
                   LPRECT prcDest, 
                   HDC hdcSrc, 
                   LONG lWidthSrc, 
                   LONG lHeightSrc,
                   HBITMAP hbmpMask);
                                           
class CTableBuilder
{
  public:
    CTableBuilder();
    virtual ~CTableBuilder();

    HRESULT LoadShell8BitServices();
    HRESULT Create8BitPalette(IDirectDraw *pDirectDraw, IDirectDrawPalette **ppPalette);
    HRESULT CreateURLMoniker(IMoniker *pmkContext, LPWSTR szURL, IMoniker **ppmk);
    HRESULT ValidateImgUtil();
    HRESULT DecodeImage( IStream* pStream, IMapMIMEToCLSID* pMap, IImageDecodeEventSink* pEventSink);
    HRESULT GetTransparentBlt(TRANSPARENTBLTPROC * pProc);
    
  private:
    HINSTANCE           m_hinstSHLWAPI;
    HINSTANCE           m_hinstURLMON;
    HINSTANCE           m_hinstIMGUTIL;
    HINSTANCE           m_hinstMSIMG32;

    CREATESHPALPROC     m_SHCreateShellPalette;
    CREATEURLMONPROC    m_CreateURLMoniker;
    DECODEIMGPROC       m_DecodeImage;
    TRANSPARENTBLTPROC  m_TransparentBlt;
    
    CritSect            m_CriticalSection;
}; // CTableBuilder


class CImageDownload : 
    public ITIMEMediaDownloader,
    public ITIMEImageRender,
    public IBindStatusCallback
{
  public:
    CImageDownload(CAtomTable * pAtomTable);
    virtual ~CImageDownload();

    
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);
    STDMETHOD (QueryInterface)(REFIID refiid, void** ppunk);

    void CancelDownload();

    STDMETHOD( LoadImage )( const WCHAR * pszFileName,
                            IUnknown *punkDirectDraw,
                            IDirectDrawSurface ** ppDXSurface,
                            CAnimatedGif ** ppAnimatedGif,
                            DWORD *pdwWidth,
                            DWORD *pdwHeight);

    //
    // ITIMEImportMedia
    //
    STDMETHOD(CueMedia)();
    STDMETHOD(GetPriority)(double *);
    STDMETHOD(GetUniqueID)(long *);
    STDMETHOD(InitializeElementAfterDownload)();
    STDMETHOD(GetMediaDownloader)(ITIMEMediaDownloader ** ppImportMedia);
    STDMETHOD(PutMediaDownloader)(ITIMEMediaDownloader * pImportMedia);
    STDMETHOD(CanBeCued)(VARIANT_BOOL * pVB_CanCue);
    STDMETHOD(MediaDownloadError)();

    //
    // ITIMEMediaDownloader
    //
    STDMETHOD(Init)(long lSrc);
    STDMETHOD(AddImportMedia)(ITIMEImportMedia * pImportMedia);
    STDMETHOD(RemoveImportMedia)(ITIMEImportMedia * pImportMedia);

    //
    // ITIMEImageRender
    //
    STDMETHOD(PutDirectDraw)(IUnknown * punkDD);
    STDMETHOD(Render)(HDC hdc, LPRECT pRect, LONG lFrameNum);
    STDMETHOD(GetSize)(DWORD * pdwWidth, DWORD * pdwHeight);
    STDMETHOD(NeedNewFrame)(double dblNewTime, LONG lOldFrame, LONG * plNewFrame, VARIANT_BOOL * pvb, double dblClipBegin, double dblClipEnd);
    STDMETHOD(GetDuration)(double * pdblDuration);
    STDMETHOD(GetRepeatCount)(double * pdblRepeatCount);

    //
    // IBindStatusCallback
    //
    STDMETHOD(OnStartBinding)( 
            /* [in] */ DWORD dwReserved,
            /* [in] */ IBinding __RPC_FAR *pib);
        
    STDMETHOD(GetPriority)( 
            /* [out] */ LONG __RPC_FAR *pnPriority);
        
    STDMETHOD(OnLowResource)( 
            /* [in] */ DWORD reserved);
        
    STDMETHOD(OnProgress)( 
            /* [in] */ ULONG ulProgress,
            /* [in] */ ULONG ulProgressMax,
            /* [in] */ ULONG ulStatusCode,
            /* [in] */ LPCWSTR szStatusText);
        
    STDMETHOD(OnStopBinding)( 
            /* [in] */ HRESULT hresult,
            /* [unique][in] */ LPCWSTR szError);
        
    STDMETHOD(GetBindInfo)( 
            /* [out] */ DWORD __RPC_FAR *grfBINDF,
            /* [unique][out][in] */ BINDINFO __RPC_FAR *pbindinfo);
        
    STDMETHOD(OnDataAvailable)( 
            /* [in] */ DWORD grfBSCF,
            /* [in] */ DWORD dwSize,
            /* [in] */ FORMATETC __RPC_FAR *pformatetc,
            /* [in] */ STGMEDIUM __RPC_FAR *pstgmed);
        
    STDMETHOD(OnObjectAvailable)( 
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ IUnknown __RPC_FAR *punk);

  protected:
    CImageDownload();
    STDMETHOD( LoadImageFromStream )( IStream *pStream,
                                      IUnknown *punkDirectDraw,
                                      IDirectDrawSurface **ppDDSurface,
                                      DWORD *pdwWidth,
                                      DWORD *pdwHeight);

    STDMETHOD( LoadGif )( IStream * pStream,
                          IUnknown * punkDirectDraw,
                          CAnimatedGif ** ppAnimatedGif,
                          DWORD *pdwWidth,
                          DWORD *pdwHeight,
                          DDPIXELFORMAT * pddpf = NULL);
    STDMETHOD( LoadBMP )( LPWSTR pszBMPFilename,
                          IUnknown * punkDirectDraw,
                          IDirectDrawSurface **ppDDSurface,
                          DWORD * pdwWidth,
                          DWORD * pdwHeight);



  private:
    CStopableStream *   m_pStopableStream;
    LONG                m_cRef;

    long                m_lSrc;

    CThreadSafeList * m_pList;

    DWORD                       m_nativeImageWidth;
    DWORD                       m_nativeImageHeight;

    HBITMAP                     m_hbmpMask;
    CComPtr<IDirectDrawSurface> m_spDDSurface;
    CComPtr<IDirectDraw3>       m_spDD3;

    CAnimatedGif               *m_pAnimatedGif;
    bool                        m_fMediaDecoded;
    bool                        m_fRemovedFromImportManager;
    bool                        m_fMediaCued;
    bool                        m_fAbortDownload;
    
    CritSect                    m_CriticalSection;
    double                      m_dblPriority;

    CAtomTable * GetAtomTable() { return m_pAtomTable; }
    CAtomTable                 *m_pAtomTable;
}; // CImageDownload


class CImageDecodeEventSink : public IImageDecodeEventSink
{
  public:
    CImageDecodeEventSink(IDirectDraw *pDDraw);
    virtual ~CImageDecodeEventSink();

    //=== IUnknown ===============================================
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    STDMETHOD(QueryInterface)(REFIID iid, void** ppInterface);

    //=== IImageDecodeEventSink ==================================
    STDMETHOD(GetSurface)( LONG nWidth, LONG nHeight, REFGUID bfid, 
                           ULONG nPasses, DWORD dwHints, IUnknown** ppSurface);
    STDMETHOD(OnBeginDecode)(DWORD* pdwEvents, ULONG* pnFormats, GUID** ppFormats);
    STDMETHOD(OnBitsComplete)();
    STDMETHOD(OnDecodeComplete)(HRESULT hrStatus);
    STDMETHOD(OnPalette)();
    STDMETHOD(OnProgress)(RECT* pBounds, BOOL bFinal);

    IDirectDrawSurface * Surface() { return m_spDDSurface; }
    DWORD Width() { return m_dwWidth; }
    DWORD Height() { return m_dwHeight; }

  protected:
    CImageDecodeEventSink();

  private:
    long                        m_lRefCount;
    CComPtr<IDirectDraw>        m_spDirectDraw;
    CComPtr<IDirectDrawSurface> m_spDDSurface;
    DWORD                       m_dwHeight;
    DWORD                       m_dwWidth;
}; // CImageDecodeEventSink


#endif // _IMAGEDOWNLOAD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\loadgif.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: src\time\src\loadgif.cpp
//
//  Contents: gif decoder, copied from direct animation source: danim\src\appel\util\loadgif.cpp
//
//------------------------------------------------------------------------------------
#include "headers.h"

#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>

#include <vector>
#define vector std::vector

/*lint ++flb*/

DeclareTag(tagImageDecode, "Image Decode", "Image Decode Filters");

const long COLORKEY_NOT_SET = -1;

/*-- 
Structs from IE img.hxx 
--*/

enum
{
    gifNoneSpecified =  0, // no disposal method specified
    gifNoDispose =      1, // do not dispose, leave the bits there
    gifRestoreBkgnd =   2, // replace the image with the background color
    gifRestorePrev =    3  // replace the image with the previous pixels
};

typedef struct _GCEDATA // data from GIF Graphic control extension
{
    unsigned int uiDelayTime;           // frame duration, initialy 1/100ths seconds
                                    // converted to milliseconds
    unsigned int uiDisposalMethod;      // 0 - none specified.
                                    // 1 - do not dispose - leave bits in place.
                                    // 2 - replace with background color.
                                    // 3 - restore previous bits
                                    // >3 - not yet defined
    BOOL                  fTransparent;         // TRUE is ucTransIndex describes transparent color
    unsigned char ucTransIndex;         // transparent index

} GCEDATA; 

typedef struct _GIFFRAME
{
    struct _GIFFRAME    *pgfNext;
    GCEDATA                             gced;           // animation parameters for frame.
    int                                 top;            // bounds relative to the GIF logical screen 
    int                                 left;
    int                                 width;
    int                                 height;
    unsigned char               *ppixels;       // pointer to image pixel data
    int                                 cColors;        // number of entries in pcolors
    PALETTEENTRY                *pcolors;
    PBITMAPINFO                 pbmi;
    HRGN                                hrgnVis;                // region describing currently visible portion of the frame
    int                                 iRgnKind;               // region type for hrgnVis
} GIFFRAME, *PGIFFRAME;

typedef struct {
    BOOL        fAnimating;                 // TRUE if animation is (still) running
    DWORD       dwLoopIter;                 // current iteration of looped animation, not actually used for Netscape compliance reasons
    _GIFFRAME * pgfDraw;                    // last frame we need to draw
    DWORD       dwNextTimeMS;               // Time to display pgfDraw->pgfNext, or next iteration
} GIFANIMATIONSTATE, *PGIFANIMATIONSTATE;

#define dwGIFVerUnknown     ((DWORD)0)   // unknown version of GIF file
#define dwGIFVer87a         ((DWORD)87)  // GIF87a file format
#define dwGIFVer89a        ((DWORD)89)  // GIF89a file format.

typedef struct _GIFANIMDATA
{
    BOOL                        fAnimated;                      // TRUE if cFrames and pgf define a GIF animation
    BOOL                        fLooped;                        // TRUE if we've seen a Netscape loop block
    BOOL                        fHasTransparency;       // TRUE if a frame is transparent, or if a frame does
                                        // not cover the entire logical screen.
    BOOL            fNoBWMapping;       // TRUE if we saw more than two colors in anywhere in the file.
    DWORD           dwGIFVer;           // GIF Version <see defines above> we need to special case 87a backgrounds
    unsigned short      cLoops;                         // A la Netscape, we will treat this as 
                                        // "loop forever" if it is zero.
    PGIFFRAME           pgf;                            // animation frame entries
    PALETTEENTRY        *pcolorsGlobal;         // GIF global colors - NULL after GIF prepared for screen
    PGIFFRAME       pgfLastProg;        // remember the last frame to be drawn during decoding
    DWORD           dwLastProgTimeMS;   // time at which pgfLastProg was displayed.

} GIFANIMDATA, *PGIFANIMDATA;

/** End Structs **/
 
#define MAXCOLORMAPSIZE     256

#define TRUE    1
#define FALSE   0

#define CM_RED      0
#define CM_GREEN    1
#define CM_BLUE     2

#define MAX_LWZ_BITS        12

#define INTERLACE       0x40
#define LOCALCOLORMAP   0x80
#define BitSet(byte, bit)   (((byte) & (bit)) == (bit))

#define LM_to_uint(a,b)         ((((unsigned int) b)<<8)|((unsigned int)a))

#define dwIndefiniteGIFThreshold 300    // 300 seconds == 5 minutes
                                        // If the GIF runs longer than
                                        // this, we will assume the author
                                        // intended an indefinite run.
#define dwMaxGIFBits 13107200           // keep corrupted GIFs from causing
                                        // us to allocate _too_ big a buffer.
                                        // This one is 1280 X 1024 X 10.

typedef struct _GIFSCREEN
{
        unsigned long Width;
        unsigned long Height;
        unsigned char ColorMap[3][MAXCOLORMAPSIZE];
        unsigned long BitPixel;
        unsigned long ColorResolution;
        unsigned long Background;
        unsigned long AspectRatio;
}
GIFSCREEN;

typedef struct _GIF89
{
        long transparent;
        long delayTime;
        long inputFlag;
        long disposal;
}
GIF89;

#define MAX_STACK_SIZE  ((1 << (MAX_LWZ_BITS)) * 2)
#define MAX_TABLE_SIZE  (1 << MAX_LWZ_BITS)
typedef struct _GIFINFO
{
    IStream *stream;
    GIF89 Gif89;
    long lGifLoc;
    long ZeroDataBlock;

/*
 **  Pulled out of nextCode
 */
    long curbit, lastbit, get_done;
    long last_byte;
    long return_clear;
/*
 **  Out of nextLWZ
 */
    unsigned short *pstack, *sp;
    long stacksize;
    long code_size, set_code_size;
    long max_code, max_code_size;
    long clear_code, end_code;

/*
 *   Were statics in procedures
 */
    unsigned char buf[280];
    unsigned short *table[2];
    long tablesize;
    long firstcode, oldcode;

} GIFINFO,*PGIFINFO;

/*
 DirectAnimation wrapper class for GIF info
*/
class CImgGif
{
   // Class methods
   public:
      CImgGif();
      ~CImgGif();

      unsigned char * ReadGIFMaster();
      BOOL Read(unsigned char *buffer, long len);
      long ReadColorMap(long number, unsigned char buffer[3][MAXCOLORMAPSIZE]);
      long DoExtension(long label);
      long GetDataBlock(unsigned char *buf);
      unsigned char * ReadImage(long len, long height, BOOL fInterlace, BOOL fGIFFrame);
      long readLWZ();
      long nextLWZ();
      long nextCode(long code_size);
      BOOL initLWZ(long input_code_size);
      unsigned short *  growStack();
      BOOL growTables();
      BITMAPINFO * FinishDithering();

   // Data members
   public:
      LPCSTR              _szFileName;
      BOOL                _fInterleaved;
      BOOL                _fInvalidateAll;
      int                 _yLogRow;
      GIFINFO             _gifinfo;
      GIFANIMATIONSTATE   _gas;
      GIFANIMDATA         _gad;
      PALETTEENTRY        _ape[256];
      int                 _xWidth;
      int                 _yHeight;
      LONG                _lTrans;
      BYTE *              _pbBits;

} GIFIMAGE;


CImgGif::CImgGif() {
   _gifinfo.pstack = NULL;
   _gifinfo.table[0] = NULL;
   _gifinfo.table[1] = NULL;
}

CImgGif::~CImgGif() {
   MemFree(_gifinfo.pstack);
   MemFree(_gifinfo.table[0]);
   MemFree(_gifinfo.table[1]);
   PGIFFRAME nextPgf, curPgf;
   curPgf = _gad.pgf;
   while(curPgf != NULL) {
      nextPgf = curPgf->pgfNext;
      MemFree(curPgf->ppixels);
      MemFree(curPgf->pcolors);
      MemFree(curPgf->pbmi);
      MemFree(curPgf);
      curPgf = nextPgf;
   }
}

static int GetColorMode() { return 0; };

#ifndef DEBUG
#pragma optimize("t",on)
#endif

BOOL CImgGif::Read(unsigned char *buffer, long len)
{
   DWORD lenout = 0;
   /* read len characters into buffer */
   _gifinfo.stream->Read(buffer,len,&lenout);

   return (lenout == len);
}

long CImgGif::ReadColorMap(long number, unsigned char buffer[3][MAXCOLORMAPSIZE])
{
        long i;
        unsigned char rgb[3];

        for (i = 0; i < number; ++i)
        {
                if (!Read(rgb, sizeof(rgb)))
                {
                        TraceTag((tagImageDecode, "bad gif colormap."));
                        return (TRUE);
                }
                buffer[CM_RED][i] = rgb[0];
                buffer[CM_GREEN][i] = rgb[1];
                buffer[CM_BLUE][i] = rgb[2];
        }
        return FALSE;
}

long
CImgGif::GetDataBlock(unsigned char *buf)
{
   unsigned char count;

   count = 0;
   if (!Read(&count, 1))
   {
          return -1;
   }
   _gifinfo.ZeroDataBlock = count == 0;

   if ((count != 0) && (!Read(buf, count)))
   {
          return -1;
   }

   return ((long) count);
}

#define MIN_CODE_BITS 5
#define MIN_STACK_SIZE 64
#define MINIMUM_CODE_SIZE 2

BOOL CImgGif::initLWZ(long input_code_size)
{
   if((input_code_size < MINIMUM_CODE_SIZE) || (input_code_size > 29))
     return FALSE;

   _gifinfo.set_code_size = input_code_size;
   _gifinfo.code_size = _gifinfo.set_code_size + 1;
   _gifinfo.clear_code = 1 << _gifinfo.set_code_size;
   _gifinfo.end_code = _gifinfo.clear_code + 1;
   _gifinfo.max_code_size = 2 * _gifinfo.clear_code;
   _gifinfo.max_code = _gifinfo.clear_code + 2;

   _gifinfo.curbit = _gifinfo.lastbit = 0;
   _gifinfo.last_byte = 2;
   _gifinfo.get_done = FALSE;

   _gifinfo.return_clear = TRUE;
    
    if(input_code_size >= MIN_CODE_BITS)
        _gifinfo.stacksize = ((1 << (input_code_size)) * 2);
    else
        _gifinfo.stacksize = MIN_STACK_SIZE;

        if ( _gifinfo.pstack != NULL )
                MemFree( _gifinfo.pstack );
        if ( _gifinfo.table[0] != NULL  )
                MemFree( _gifinfo.table[0] );
        if ( _gifinfo.table[1] != NULL  )
                MemFree( _gifinfo.table[1] );

 
    _gifinfo.table[0] = 0;
    _gifinfo.table[1] = 0;
    _gifinfo.pstack = 0;

    _gifinfo.pstack = (unsigned short *) MemAlloc(Mt(Mem), (_gifinfo.stacksize)*sizeof(unsigned short));
    if(_gifinfo.pstack == 0){
        goto ErrorExit;
    }    
    _gifinfo.sp = _gifinfo.pstack;

    // Initialize the two tables.
    _gifinfo.tablesize = (_gifinfo.max_code_size);

    _gifinfo.table[0] = (unsigned short *) MemAlloc(Mt(Mem), (_gifinfo.tablesize)*sizeof(unsigned short));
    _gifinfo.table[1] = (unsigned short *) MemAlloc(Mt(Mem), (_gifinfo.tablesize)*sizeof(unsigned short));
    if((_gifinfo.table[0] == 0) || (_gifinfo.table[1] == 0)){
        goto ErrorExit;
    }

    return TRUE;

   ErrorExit:
    if(_gifinfo.pstack){
        MemFree(_gifinfo.pstack);
        _gifinfo.pstack = 0;
    }

    if(_gifinfo.table[0]){
        MemFree(_gifinfo.table[0]);
        _gifinfo.table[0] = 0;
    }

    if(_gifinfo.table[1]){
        MemFree(_gifinfo.table[1]);
        _gifinfo.table[1] = 0;
    }

    return FALSE;
}

long CImgGif::nextCode(long code_size)
{
   static const long maskTbl[16] =
   {
          0x0000, 0x0001, 0x0003, 0x0007,
          0x000f, 0x001f, 0x003f, 0x007f,
          0x00ff, 0x01ff, 0x03ff, 0x07ff,
          0x0fff, 0x1fff, 0x3fff, 0x7fff,
   };
   long i, j, ret, end;
   unsigned char *buf = &_gifinfo.buf[0];

   if (_gifinfo.return_clear)
   {
          _gifinfo.return_clear = FALSE;
          return _gifinfo.clear_code;
   }

   end = _gifinfo.curbit + code_size;

   if (end >= _gifinfo.lastbit)
   {
          long count;

          if (_gifinfo.get_done)
          {
                  return -1;
          }
          buf[0] = buf[_gifinfo.last_byte - 2];
          buf[1] = buf[_gifinfo.last_byte - 1];

          if ((count = GetDataBlock(&buf[2])) == 0)
                  _gifinfo.get_done = TRUE;
          if (count < 0)
          {
                  return -1;
          }
          _gifinfo.last_byte = 2 + count;
          _gifinfo.curbit = (_gifinfo.curbit - _gifinfo.lastbit) + 16;
          _gifinfo.lastbit = (2 + count) * 8;

          end = _gifinfo.curbit + code_size;

   // Okay, bug 30784 time. It's possible that we only got 1
   // measly byte in the last data block. Rare, but it does happen.
   // In that case, the additional byte may still not supply us with
   // enough bits for the next code, so, as Mars Needs Women, IE
   // Needs Data.
   if ( end >= _gifinfo.lastbit && !_gifinfo.get_done )
   {
      // protect ourselve from the ( theoretically impossible )
      // case where between the last data block, the 2 bytes from
      // the block preceding that, and the potential 0xFF bytes in
      // the next block, we overflow the buffer.
      // Since count should always be 1,
      Assert ( count == 1 );
      // there should be enough room in the buffer, so long as someone
      // doesn't shrink it.
      if ( count + 0x101 >= sizeof( _gifinfo.buf ) )
      {
          Assert ( FALSE ); // 
          return -1;
      }

              if ((count = GetDataBlock(&buf[2 + count])) == 0)
                      _gifinfo.get_done = TRUE;
              if (count < 0)
              {
                      return -1;
              }
              _gifinfo.last_byte += count;
              _gifinfo.lastbit = _gifinfo.last_byte * 8;

              end = _gifinfo.curbit + code_size;
   }
   }

   j = end / 8;
   i = _gifinfo.curbit / 8;

   if (i == j)
          ret = buf[i];
   else if (i + 1 == j)
          ret = buf[i] | (((long) buf[i + 1]) << 8);
   else
          ret = buf[i] | (((long) buf[i + 1]) << 8) | (((long) buf[i + 2]) << 16);

   ret = (ret >> (_gifinfo.curbit % 8)) & maskTbl[code_size];

   _gifinfo.curbit += code_size;

        return ret;
}

// Grows the stack and returns the top of the stack.
unsigned short *
CImgGif::growStack()
{
    HRESULT hr;
    long index;
    
    if (_gifinfo.stacksize >= MAX_STACK_SIZE) 
        return 0;

    index = (_gifinfo.sp - _gifinfo.pstack);
    hr = MemRealloc(Mt(Mem), (void**)&(_gifinfo.pstack), (_gifinfo.stacksize)*2*sizeof(unsigned short));
    if(hr)
        return 0;
        
    _gifinfo.sp = &(_gifinfo.pstack[index]);
    _gifinfo.stacksize = (_gifinfo.stacksize)*2;
    return &(_gifinfo.pstack[_gifinfo.stacksize]);
}

BOOL
CImgGif::growTables()
{
    HRESULT hr;

    hr = MemRealloc(Mt(Mem), (void**)&(_gifinfo.table[0]), (_gifinfo.max_code_size)*sizeof(unsigned short));
    if(hr){
        return FALSE; 
    }
    
    hr =  MemRealloc(Mt(Mem), (void**)&(_gifinfo.table[1]), (_gifinfo.max_code_size)*sizeof(unsigned short));
    if(hr){
        return FALSE; 
    }
 
    return TRUE;

}

inline
long CImgGif::readLWZ()
{
   return((_gifinfo.sp > _gifinfo.pstack) ? *--(_gifinfo.sp) : nextLWZ());
}

#define CODE_MASK 0xffff
long CImgGif::nextLWZ()
{
        long code, incode;
        unsigned short usi;
        unsigned short *table0 = _gifinfo.table[0];
        unsigned short *table1 = _gifinfo.table[1];
        unsigned short *pstacktop = &(_gifinfo.pstack[_gifinfo.stacksize]);

        while ((code = nextCode(_gifinfo.code_size)) >= 0)
        {
                if (code == _gifinfo.clear_code)
                {
                        /* corrupt GIFs can make this happen */
                        if (_gifinfo.clear_code >= (1 << MAX_LWZ_BITS))
                        {
                                return -2;
                        }

                
                        _gifinfo.code_size = _gifinfo.set_code_size + 1;
                        _gifinfo.max_code_size = 2 * _gifinfo.clear_code;
                        _gifinfo.max_code = _gifinfo.clear_code + 2;

            if(!growTables())
                return -2;
                        
            table0 = _gifinfo.table[0];
            table1 = _gifinfo.table[1];

                        _gifinfo.tablesize = _gifinfo.max_code_size;


                        for (usi = 0; usi < _gifinfo.clear_code; ++usi)
                        {
                                table1[usi] = usi;
                        }
                        memset(table0,0,sizeof(unsigned short )*(_gifinfo.tablesize));
                        memset(&table1[_gifinfo.clear_code],0,sizeof(unsigned short)*((_gifinfo.tablesize)-_gifinfo.clear_code));
                        _gifinfo.sp = _gifinfo.pstack;
                        do
                        {
                                _gifinfo.firstcode = _gifinfo.oldcode = nextCode(_gifinfo.code_size);
                        }
                        while (_gifinfo.firstcode == _gifinfo.clear_code);

                        return _gifinfo.firstcode;
                }
                if (code == _gifinfo.end_code)
                {
                        long count;
                        unsigned char buf[260];

                        if (_gifinfo.ZeroDataBlock)
                        {
                                return -2;
                        }

                        while ((count = GetDataBlock(buf)) > 0)
                                ;

                        if (count != 0)
                        return -2;
                }

                incode = code;

                if (code >= _gifinfo.max_code)
                {
            if (_gifinfo.sp >= pstacktop){
                pstacktop = growStack();
                if(pstacktop == 0)
                    return -2;
                        }
                        *(_gifinfo.sp)++ = (unsigned short)((CODE_MASK ) & (_gifinfo.firstcode));
                        code = _gifinfo.oldcode;
                }

#if FEATURE_FAST
                // (andyp) easy speedup here for ie3.1 (too late for ie3.0):
                //
                // 1. move growStack code out of loop (use max 12-bit/4k slop).
                // 2. do "sp = _gifinfo.sp" so it will get enreg'ed.
                // 3. un-inline growStack (and growTables).
                // 4. change short's to int's (benefits win32) (esp. table1 & table2)
                // (n.b. int not long, so we'll keep win3.1 perf)
                // 5. change long's to int's (benefits win16) (esp. code).
                //
                // together these will make the loop very tight w/ everything kept
                // enregistered and no 66 overrides.
                //
                // one caveat is that on average this loop iterates 4x so it's
                // not clear how much the speedup will really gain us until we
                // look at the outer loop as well.
#endif
                while (code >= _gifinfo.clear_code)
                {
                        if (_gifinfo.sp >= pstacktop){
                pstacktop = growStack();
                if(pstacktop == 0)
                    return -2;
                        }
                        *(_gifinfo.sp)++ = table1[code];
                        if (code == (long)(table0[code]))
                        {
                                return (code);
                        }
                        code = (long)(table0[code]);
                }

        if (_gifinfo.sp >= pstacktop){
            pstacktop = growStack();
            if(pstacktop == 0)
                return -2;
        }
                _gifinfo.firstcode = (long)table1[code];
        *(_gifinfo.sp)++ = table1[code];

                if ((code = _gifinfo.max_code) < (1 << MAX_LWZ_BITS))
                {
                        table0[code] = (_gifinfo.oldcode) & CODE_MASK;
                        table1[code] = (_gifinfo.firstcode) & CODE_MASK;
                        ++_gifinfo.max_code;
                        if ((_gifinfo.max_code >= _gifinfo.max_code_size) && (_gifinfo.max_code_size < ((1 << MAX_LWZ_BITS))))
                        {
                                _gifinfo.max_code_size *= 2;
                                ++_gifinfo.code_size;
                                if(!growTables())
                                    return -2;
       
                table0 = _gifinfo.table[0];
                table1 = _gifinfo.table[1];

                // Tables have been reallocated to the correct size but initialization
                // still remains to be done. This initialization is different from
                // the first time initialization of these tables.
                memset(&(table0[_gifinfo.tablesize]),0,
                        sizeof(unsigned short )*(_gifinfo.max_code_size - _gifinfo.tablesize));

                memset(&(table1[_gifinfo.tablesize]),0,
                        sizeof(unsigned short )*(_gifinfo.max_code_size - _gifinfo.tablesize));

                _gifinfo.tablesize = (_gifinfo.max_code_size);


                        }
                }

                _gifinfo.oldcode = incode;

                if (_gifinfo.sp > _gifinfo.pstack)
                        return ((long)(*--(_gifinfo.sp)));
        }
        return code;
}

#ifndef DEBUG
// Return to default optimization flags
#pragma optimize("",on)
#endif

unsigned char *
CImgGif::ReadImage(long len, long height, BOOL fInterlace, BOOL fGIFFrame)
{
    unsigned char *dp, c;
    long v;
    long xpos = 0, ypos = 0, pass = 0;
    unsigned char *image;
    long padlen = ((len + 3) / 4) * 4;
    DWORD cbImage = 0;
    char buf[256]; // need a buffer to read trailing blocks ( up to terminator ) into
    //ULONG ulCoversImg = IMGBITS_PARTIAL;

    /*
       **  Initialize the Compression routines
     */
    if (!Read(&c, 1))
    {
        return NULL;
    }

    /*
       **  If this is an "uninteresting picture" ignore it.
     */

    cbImage = padlen * height * sizeof(char);

    if ((cbImage > dwMaxGIFBits) ||
        (image = (unsigned char *) MemAllocClear(Mt(Mem), cbImage)) == NULL)
    {
        TraceTag((tagImageDecode, "Cannot allocate space for gif image data\n"));
        return NULL;
    }

    if (c == 1)
    {
        // Netscape seems to field these bogus GIFs by filling treating them
        // as transparent. While not the optimal way to simulate this effect,
        // we'll fake it by pushing the initial code size up to a safe value,
        // consuming the input, and returning a buffer full of the transparent
        // color or zero, if no transparency is indicated.
        if (initLWZ(MINIMUM_CODE_SIZE))
            while (readLWZ() >= 0);
        else
        {
            if (image)
                MemFree(image);

            TraceTag((tagImageDecode, "GIF: failed LZW decode.\n"));
            return NULL;
        }

        if (_gifinfo.Gif89.transparent != -1)
            FillMemory(image, cbImage, _gifinfo.Gif89.transparent);
        else // fall back on the background color 
            FillMemory(image, cbImage, 0);

        return image;
    }
    else if (initLWZ(c) == FALSE)
    {
        MemFree(image);
        TraceTag((tagImageDecode, "GIF: failed LZW decode.\n"));
        return NULL;
    }

    if (!fGIFFrame)
        _pbBits = image;

    if (fInterlace)
    {
        long i;
        long pass = 0, step = 8;

        if (!fGIFFrame && (height > 4))
            _fInterleaved = TRUE;

        for (i = 0; i < height; i++)
        {
            // message("readimage, logical=%d, offset=%d\n", i, padlen * ((height-1) - ypos));
            dp = &image[padlen * ((height-1) - ypos)];
            for (xpos = 0; xpos < len; xpos++)
            {
                if ((v = readLWZ()) < 0)
                {
                    if (image)
                        MemFree(image);
                    goto abort;
                }

                *dp++ = (unsigned char) v;
            }
            ypos += step;
            while (ypos >= height)
            {
                if (pass++ > 0)
                    step /= 2;
                ypos = step / 2;
                /*if (!fGIFFrame && pass == 1)
                {
                    ulCoversImg = IMGBITS_TOTAL;
                }*/
            }
            if (!fGIFFrame)
            {
                _yLogRow = i;

                /*if ((i & PROG_INTERVAL) == 0)
                {
                    // Post ProgDraw (IE code has delay-logic)
                    OnProg(FALSE, ulCoversImg);
                }*/
            }
        }

        /*if (!fGIFFrame)
        {
            OnProg(TRUE, ulCoversImg);
        }*/

        if (!fGIFFrame && height <= 4)
        {
            _yLogRow = height-1;
        }
    }
    else
    {

        if (!fGIFFrame) 
            _yLogRow = -1;

        for (ypos = height-1; ypos >= 0; ypos--)
        {
            dp = &image[padlen * ypos];
            for (xpos = 0; xpos < len; xpos++)
            {
                if ((v = readLWZ()) < 0)
                {
                    if (image)
                        MemFree(image);
                    goto abort;
                }

                *dp++ = (unsigned char) v;
            }
            if (!fGIFFrame)
            {
                _yLogRow++;
                // message("readimage, logical=%d, offset=%d\n", _yLogRow, padlen * ypos);
                /*if ((_yLogRow & PROG_INTERVAL) == 0)
                {
                    // Post ProgDraw (IE code has delay-logic)
                    OnProg(FALSE, ulCoversImg);
                }*/
            }
        }

        /*if (!fGIFFrame)
        {
            OnProg(TRUE, ulCoversImg);
        }*/
    }

    // consume blocks up to image block terminator so we can proceed to the next image
    while (GetDataBlock((unsigned char *) buf) > 0);

    return image;

abort:
    /*if (!fGIFFrame)
        OnProg(TRUE, ulCoversImg);*/
    return NULL;
}

long CImgGif::DoExtension(long label)
{
    unsigned char buf[256];
    int count;

    switch (label)
    {
        case 0x01:              /* Plain Text Extension */
            break;
        case 0xff:              /* Application Extension */
            // Is it the Netscape looping extension
            count = GetDataBlock((unsigned char *) buf);
            if (count >= 11)
            {
                char *szNSExt = "NETSCAPE2.0";

                if ( memcmp( buf, szNSExt, strlen( szNSExt ) ) == 0 )
                { // if it has their signature, get the data subblock with the iter count
                    count = GetDataBlock((unsigned char *) buf);
                    if ( count >= 3 )
                    {
                        _gad.fLooped = TRUE;
                        _gad.cLoops = (buf[2] << 8) | buf[1];
                    }
                }
            }
            while (GetDataBlock((unsigned char *) buf) > 0)
                ;
            return FALSE;
            break;
        case 0xfe:              /* Comment Extension */
            while (GetDataBlock((unsigned char *) buf) > 0)
            {
                TraceTag((tagImageDecode, "GIF comment: %s\n", buf));                
            }
            return FALSE;
        case 0xf9:              /* Graphic Control Extension */
            count = GetDataBlock((unsigned char *) buf);
            if (count >= 3)
            {
                _gifinfo.Gif89.disposal = (buf[0] >> 2) & 0x7;
                _gifinfo.Gif89.inputFlag = (buf[0] >> 1) & 0x1;
                _gifinfo.Gif89.delayTime = LM_to_uint(buf[1], buf[2]);
                if ((buf[0] & 0x1) != 0)
                    _gifinfo.Gif89.transparent = buf[3];
                else
                    _gifinfo.Gif89.transparent = -1;
            }
            while (GetDataBlock((unsigned char *) buf) > 0)
                ;
            return FALSE;
        default:
            break;
    }

    while (GetDataBlock((unsigned char *) buf) > 0)
        ;

    return FALSE;
}

BOOL IsGifHdr(BYTE * pb)
{
    return(pb[0] == 'G' && pb[1] == 'I' && pb[2] == 'F'
        && pb[3] == '8' && (pb[4] == '7' || pb[4] == '9') && pb[5] == 'a');
}


PBITMAPINFO x_8BPIBitmap(int xsize, int ysize)
{
        PBITMAPINFO pbmi;

        if (GetColorMode() == 8)
        {
                pbmi = (PBITMAPINFO) MemAllocClear(Mt(Mem), sizeof(BITMAPINFOHEADER) + 256 * sizeof(WORD));
                if (!pbmi)
                {
                        return NULL;
                }
                pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
                pbmi->bmiHeader.biWidth = xsize;
                pbmi->bmiHeader.biHeight = ysize;
                pbmi->bmiHeader.biPlanes = 1;
                pbmi->bmiHeader.biBitCount = 8;
                pbmi->bmiHeader.biCompression = BI_RGB;         /* no compression */
                pbmi->bmiHeader.biSizeImage = 0;                        /* not needed when not compressed */
                pbmi->bmiHeader.biXPelsPerMeter = 0;
                pbmi->bmiHeader.biYPelsPerMeter = 0;
                pbmi->bmiHeader.biClrUsed = 256;
                pbmi->bmiHeader.biClrImportant = 0;
        }
        else
        {
                pbmi = (PBITMAPINFO) MemAllocClear(Mt(Mem), sizeof(BITMAPINFOHEADER) + 256 * sizeof(RGBQUAD));
                if (!pbmi)
                {
                        return NULL;
                }
                pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
                pbmi->bmiHeader.biWidth = xsize;
                pbmi->bmiHeader.biHeight = ysize;
                pbmi->bmiHeader.biPlanes = 1;
                pbmi->bmiHeader.biBitCount = 8;
                pbmi->bmiHeader.biCompression = BI_RGB;         /* no compression */
                pbmi->bmiHeader.biSizeImage = 0;                        /* not needed when not compressed */
                pbmi->bmiHeader.biXPelsPerMeter = 0;
                pbmi->bmiHeader.biYPelsPerMeter = 0;
                pbmi->bmiHeader.biClrUsed = 256;
                pbmi->bmiHeader.biClrImportant = 0;
        }
        return pbmi;
}

/*
    For color images.
        This routine should only be used when drawing to an 8 bit palette screen.
        It always creates a DIB in DIB_PAL_COLORS format.
*/
PBITMAPINFO BIT_Make_DIB_PAL_Header(int xsize, int ysize)
{
        int i;
        PBITMAPINFO pbmi;
        WORD *pw;

        pbmi = x_8BPIBitmap(xsize, ysize);
        if (!pbmi)
        {
                return NULL;
        }

        pw = (WORD *) pbmi->bmiColors;

        for (i = 0; i < 256; i++)
        {
                pw[i] = (WORD)i;
        }

        return pbmi;
}

/*
    For color images.
        This routine is used when drawing to the nonpalette screens.  It always creates
        DIBs in DIB_RGB_COLORS format.
        If there is a transparent color, it is modified in the palette to be the
        background color for the window.
*/
PBITMAPINFO BIT_Make_DIB_RGB_Header_Screen(int xsize, int ysize,
                                           int cEntries, PALETTEENTRY * rgpe, int transparent)
{
        int i;
        PBITMAPINFO pbmi;

        pbmi = x_8BPIBitmap(xsize, ysize);
        if (!pbmi)
        {
                return NULL;
        }

        for (i = 0; i < cEntries; i++)
        {
                pbmi->bmiColors[i].rgbRed = rgpe[i].peRed;
                pbmi->bmiColors[i].rgbGreen = rgpe[i].peGreen;
                pbmi->bmiColors[i].rgbBlue = rgpe[i].peBlue;
                pbmi->bmiColors[i].rgbReserved = 0;
        }

/*
        if (transparent != -1)
        {
                COLORREF color;

                color = PREF_GetBackgroundColor();
                pbmi->bmiColors[transparent].rgbRed     = GetRValue(color);
                pbmi->bmiColors[transparent].rgbGreen   = GetGValue(color);
                pbmi->bmiColors[transparent].rgbBlue    = GetBValue(color);
        }
*/
        return pbmi;
}

unsigned char *
CImgGif::ReadGIFMaster()
{
    HRESULT hr = S_OK;
    unsigned char buf[16];
    unsigned char c;
    unsigned char localColorMap[3][MAXCOLORMAPSIZE];
    long useGlobalColormap;
    long imageCount = 0;
    long imageNumber = 1;
    unsigned char *image = NULL;
    unsigned long i;
    GIFSCREEN GifScreen;
    long bitPixel;
    PGIFFRAME pgfLast = NULL;
    PGIFFRAME pgfNew;
    
    _gifinfo.ZeroDataBlock = 0;
    
    /*
    * Initialize GIF89 extensions
    */
    _gifinfo.Gif89.transparent = -1;
    _gifinfo.Gif89.delayTime = 5;
    _gifinfo.Gif89.inputFlag = -1;
    _gifinfo.Gif89.disposal = 0;
    _gifinfo.lGifLoc = 0;
    
    // initialize our animation fields
    _gad.fAnimated = FALSE;          // set to TRUE if we see more than one image
    _gad.fLooped = FALSE;                    // TRUE if we've seen a Netscape loop block
    _gad.fHasTransparency = FALSE; // until proven otherwise
    _gad.fNoBWMapping = FALSE;
    _gad.dwGIFVer = dwGIFVerUnknown;
    _gad.cLoops = 0;                
    _gad.pgf = NULL;
    _gad.pcolorsGlobal = NULL;
    
    if (!Read(buf, 6))
    {
        TraceTag((tagImageDecode, "GIF: error reading magic number\n"));
        hr = E_FAIL;
        goto done;  
    }
    
    if (!IsGifHdr(buf)) {
        TraceTag((tagImageDecode, "GIF: Malformed header\n"));
        hr = E_FAIL;
        goto done;
    }
    
    _gad.dwGIFVer = (buf[4] == '7') ? dwGIFVer87a : dwGIFVer89a;
    
    if (!Read(buf, 7))
    {
        TraceTag((tagImageDecode, "GIF: failed to read screen descriptor\n"));
        hr = E_FAIL;
        goto done;
    }
    
    GifScreen.Width = LM_to_uint(buf[0], buf[1]);
    GifScreen.Height = LM_to_uint(buf[2], buf[3]);
    GifScreen.BitPixel = 2 << (buf[4] & 0x07);
    GifScreen.ColorResolution = (((buf[4] & 0x70) >> 3) + 1);
    GifScreen.Background = buf[5];
    GifScreen.AspectRatio = buf[6];
    
    if (BitSet(buf[4], LOCALCOLORMAP))
    {                                                       /* Global Colormap */
        int scale = 65536 / MAXCOLORMAPSIZE;
        
        if (ReadColorMap(GifScreen.BitPixel, GifScreen.ColorMap))
        {
            TraceTag((tagImageDecode, "error reading global colormap\n"));
            hr = E_FAIL;
            goto done;
        }
        for (i = 0; i < GifScreen.BitPixel; i++)
        {
            int tmp;
            
            tmp = (BYTE) (GifScreen.ColorMap[0][i]);
            _ape[i].peRed = (BYTE) (GifScreen.ColorMap[0][i]);
            _ape[i].peGreen = (BYTE) (GifScreen.ColorMap[1][i]);
            _ape[i].peBlue = (BYTE) (GifScreen.ColorMap[2][i]);
            _ape[i].peFlags = (BYTE) 0;
        }
        for (i = GifScreen.BitPixel; i < MAXCOLORMAPSIZE; i++)
        {
            _ape[i].peRed = (BYTE) 0;
            _ape[i].peGreen = (BYTE) 0;
            _ape[i].peBlue = (BYTE) 0;
            _ape[i].peFlags = (BYTE) 0;
        }
    }
    
    if (GifScreen.AspectRatio != 0 && GifScreen.AspectRatio != 49)
    {
        float r;
        r = ((float) (GifScreen.AspectRatio) + (float) 15.0) / (float) 64.0;
        TraceTag((tagImageDecode, "Warning: non-square pixels!\n"));
    }
    
    for (;; ) // our appetite now knows no bounds save termination or error
    {
        if (!Read(&c, 1))
        {
            TraceTag((tagImageDecode, "EOF / read error on image data\n"));
            hr = E_FAIL;
            goto done;
        }
        
        if (c == ';')
        {                                               /* GIF terminator */
            if (imageCount < imageNumber)
            {
                TraceTag((tagImageDecode, "No images found in file\n"));
                hr = E_FAIL;
                goto done;
            }
            break;
        }
        
        if (c == '!')
        {                                               /* Extension */
            if (!Read(&c, 1))
            {
                TraceTag((tagImageDecode, "EOF / read error on extension function code\n"));
                hr = E_FAIL;
                goto done;
            }
            DoExtension(c);
            continue;
        }
        
        if (c != ',')
        {                                               /* Not a valid start character */
            break;
        }
        
        ++imageCount;
        
        if (!Read(buf, 9))
        {
            TraceTag((tagImageDecode, "couldn't read left/top/width/height\n"));
            hr = E_FAIL;
            goto done;
        }
        
        useGlobalColormap = !BitSet(buf[8], LOCALCOLORMAP);
        
        bitPixel = 1 << ((buf[8] & 0x07) + 1);
        
        /*
        * We only want to set width and height for the imageNumber
        * we are requesting.
        */
        if (imageCount == imageNumber)
        {
            // Replicate some of Netscape's special cases:
            // Don't use the logical screen if it's a GIF87a and the topLeft of the first image is at the origin.
            // Don't use the logical screen if the first image spills out of the logical screen.
            // These are artifacts of primitive authoring tools falling into the hands of hapless users.
            RECT    rectImage;  // rect defining bounds of GIF
            RECT    rectLS;     // rect defining bounds of GIF logical screen.
            RECT    rectSect;   // intersection of image an logical screen
            BOOL    fNoSpill;   // True if the image doesn't spill out of the logical screen
            BOOL    fGoofy87a;  // TRUE if its one of the 87a pathologies that Netscape special cases
            
            rectImage.left = LM_to_uint(buf[0], buf[1]);
            rectImage.top = LM_to_uint(buf[2], buf[3]);
            rectImage.right = rectImage.left + LM_to_uint(buf[4], buf[5]);
            rectImage.bottom = rectImage.top + LM_to_uint(buf[6], buf[7]);
            rectLS.left = rectLS.top = 0;
            rectLS.right = GifScreen.Width;
            rectLS.bottom = GifScreen.Height;
            IntersectRect( &rectSect, &rectImage, &rectLS );
            fNoSpill = EqualRect( &rectImage, &rectSect );
            fGoofy87a = FALSE;
            if (_gad.dwGIFVer == dwGIFVer87a)
            {
                // netscape ignores the logical screen if the image is flush against
                // either the upper left or lower right corner
                fGoofy87a = (rectImage.top == 0 && rectImage.left == 0) ||
                    (rectImage.bottom == rectLS.bottom &&
                    rectImage.right == rectLS.right);
            }   
            
            if (!fGoofy87a && fNoSpill)
            {
                _xWidth = GifScreen.Width;  
                _yHeight = GifScreen.Height;
            }
            else
            {
                // Something is amiss. Fall back to the image's dimensions.
                
                // If the sizes match, but the image is offset, or we're ignoring
                // the logical screen cuz it's a goofy 87a, then pull it back to 
                // to the origin
                if ((LM_to_uint(buf[4], buf[5]) == GifScreen.Width &&
                    LM_to_uint(buf[6], buf[7]) == GifScreen.Height) ||
                    fGoofy87a)
                {
                    buf[0] = buf[1] = 0; // left corner to zero
                    buf[2] = buf[3] = 0; // top to zero.
                }
                
                _xWidth = LM_to_uint(buf[4], buf[5]);
                _yHeight = LM_to_uint(buf[6], buf[7]);
            }
            
            _lTrans = _gifinfo.Gif89.transparent;
            
            // Post WHKNOWN
            //OnSize(_xWidth, _yHeight, _lTrans);
        }
        
        if (!useGlobalColormap)
        {
            if (ReadColorMap(bitPixel, localColorMap))
            {
                TraceTag((tagImageDecode, "error reading local colormap\n"));
                hr = E_FAIL;
                goto done;
            }
        }
        
        // We allocate a frame record for each imag in the GIF stream, including
        // the first/primary image.
        pgfNew = (PGIFFRAME) MemAllocClear(Mt(Mem), sizeof(GIFFRAME));        
        if ( pgfNew == NULL )
        {
            TraceTag((tagImageDecode, "not enough memory for GIF frame\n"));
            hr = E_FAIL;
            goto done;
        }
        
        if ( _gifinfo.Gif89.delayTime != -1 )
        {
            // we have a fresh control extension for this block
            
            // convert to milliseconds
            pgfNew->gced.uiDelayTime = _gifinfo.Gif89.delayTime * 10;
            
            
            //REVIEW(seanf): workaround to cope with 'degenerate animations' whose timing is set to some
            //                               small value becaue of the delays imposed by Netscape's animation process
            if ( pgfNew->gced.uiDelayTime <= 50 ) // assume these small values imply Netscape encoding delay
                pgfNew->gced.uiDelayTime = 100;   // pick a larger value s.t. the frame will be visible
            pgfNew->gced.uiDisposalMethod =  _gifinfo.Gif89.disposal;
            pgfNew->gced.fTransparent = _gifinfo.Gif89.transparent != -1;
            pgfNew->gced.ucTransIndex = (unsigned char)_gifinfo.Gif89.transparent;
            
        }
        else
        {   // fake one up s.t. GIFs that rely solely on Netscape's delay to time their animations will play
            // The spec says that the scope of one of these blocks is the image after the block.
            // Netscape says 'until further notice'. So we play it their way up to a point. We
            // propagate the disposal method and transparency. Since Netscape doesn't honor the timing
            // we use our default timing for these images.
            pgfNew->gced.uiDelayTime = 100;
            pgfNew->gced.uiDisposalMethod =  _gifinfo.Gif89.disposal;
            pgfNew->gced.fTransparent = _gifinfo.Gif89.transparent != -1;
            pgfNew->gced.ucTransIndex = (unsigned char)_gifinfo.Gif89.transparent;
        }
        
        pgfNew->top = LM_to_uint(buf[2], buf[3]);               // bounds relative to the GIF logical screen 
        pgfNew->left = LM_to_uint(buf[0], buf[1]);
        pgfNew->width = LM_to_uint(buf[4], buf[5]);
        pgfNew->height = LM_to_uint(buf[6], buf[7]);
        
        // Images that are offset, or do not cover the full logical screen are 'transparent' in the
        // sense that they require us to matte the frame onto the background.
        
        if (!_gad.fHasTransparency && (pgfNew->gced.fTransparent ||
            pgfNew->top != 0 ||
            pgfNew->left != 0 ||
            (UINT)pgfNew->width != (UINT)GifScreen.Width ||
            (UINT)pgfNew->height != (UINT)GifScreen.Height))
        {
            _gad.fHasTransparency = TRUE;
            //if (_lTrans == -1)
            //    OnTrans(0);
        }
        
        // We don't need to allocate a handle for the simple region case.
        // FrancisH says Windows is too much of a cheapskate to allow us the simplicity
        // of allocating the region once and modifying as needed. Well, okay, he didn't
        // put it that way...
        pgfNew->hrgnVis = NULL;
        pgfNew->iRgnKind = NULLREGION;
        
        if (!useGlobalColormap)
        {
            // remember that we saw a local color table and only map two-color images
            // if we have a homogenous color environment
            _gad.fNoBWMapping = _gad.fNoBWMapping || bitPixel > 2;
            
            // MemAllocClear will set unused colors to <0,0,0,0>
            pgfNew->pcolors = (PALETTEENTRY *) MemAllocClear(Mt(Mem), MAXCOLORMAPSIZE * sizeof(PALETTEENTRY));
            if ( pgfNew->pcolors == NULL )
            {
                DeleteRgn( pgfNew->hrgnVis );
                MemFree( pgfNew );
                
                TraceTag((tagImageDecode, "not enough memory for GIF frame colors\n"));
                hr = E_FAIL;
                goto done;
            }
            else
            {
                for (i = 0; i < (ULONG)bitPixel; ++i)
                {
                    pgfNew->pcolors[i].peRed = localColorMap[CM_RED][i];
                    pgfNew->pcolors[i].peGreen = localColorMap[CM_GREEN][i];
                    pgfNew->pcolors[i].peBlue = localColorMap[CM_BLUE][i];
                }
                pgfNew->cColors = bitPixel;
            }
        }
        else
        {
            if ( _gad.pcolorsGlobal == NULL )
            { // Whoa! Somebody's interested in the global color table
                // MemAllocClear will set unused colors to <0,0,0,0>
                _gad.pcolorsGlobal = (PALETTEENTRY *) MemAllocClear(Mt(Mem), MAXCOLORMAPSIZE * sizeof(PALETTEENTRY));
                _gad.fNoBWMapping = _gad.fNoBWMapping || GifScreen.BitPixel > 2;
                if ( _gad.pcolorsGlobal != NULL )
                {
                    CopyMemory(_gad.pcolorsGlobal, _ape,
                        GifScreen.BitPixel * sizeof(PALETTEENTRY) );
                }
                else
                {
                    DeleteRgn( pgfNew->hrgnVis );
                    MemFree( pgfNew );
                    TraceTag((tagImageDecode, "not enough memory for GIF frame colors\n"));
                    hr = E_FAIL;
                    goto done;  
                }
            }
            pgfNew->cColors = GifScreen.BitPixel;
            pgfNew->pcolors = _gad.pcolorsGlobal;
        }
        
        // Get this in here so that GifStrectchDIBits can use it during progressive
        // rendering.
        if ( _gad.pgf == NULL )
            _gad.pgf = pgfNew;
        
        pgfNew->ppixels = ReadImage(LM_to_uint(buf[4], buf[5]), // width
            LM_to_uint(buf[6], buf[7]), // height
            BitSet(buf[8], INTERLACE),
            imageCount != imageNumber);
        
        if ( pgfNew->ppixels != NULL )
        {
            // Oh JOY of JOYS! We got the pixels!
            if (pgfLast != NULL)
            {
                int transparent = (pgfNew->gced.fTransparent) ? (int) pgfNew->gced.ucTransIndex : -1;
                
                _gad.fAnimated = TRUE; // say multi-image == animated
                
                if (GetColorMode() == 8) // palettized, use DIB_PAL_COLORS
                {   // This will also dither the bits to the screen palette
                    
                    pgfNew->pbmi = BIT_Make_DIB_PAL_Header(pgfNew->width, pgfNew->height);
                    //if (x_Dither(pgfNew->ppixels, pgfNew->pcolors, pgfNew->width, pgfNew->height, transparent))
                    //    goto exitPoint;
                }
                else // give it an RGB header
                {
                    pgfNew->pbmi = BIT_Make_DIB_RGB_Header_Screen(
                        pgfNew->width,
                        pgfNew->height,
                        pgfNew->cColors, pgfNew->pcolors,
                        transparent);
                }
                
                // Okay, so we've done any mapping on the GIFFRAME, so there's
                // no need to keep the pcolors around.  Let's go can clear out
                // the pcolors.
                // REVIEW(seanf): This assumes a common palette is used by all
                // clients of the image
                if ( pgfNew->pcolors != NULL && pgfNew->pcolors != _gad.pcolorsGlobal )
                    MemFree( pgfNew->pcolors );
                pgfNew->pcolors = NULL;
                
                pgfLast->pgfNext = pgfNew;
                
                // Do something to here to get the new frame on the screen.
                
                _fInvalidateAll = TRUE;
                //super::OnProg(FALSE, IMGBITS_TOTAL);
            }
            else
            { // first frame
                _gad.pgf = pgfNew;
                
                _gad.pgfLastProg = pgfNew;
                _gad.dwLastProgTimeMS = 0;
                // set up a temporary animation state for use in progressive draw
                _gas.fAnimating = TRUE; 
                _gas.dwLoopIter = 0;
                _gas.pgfDraw = pgfNew;
                
                if ( imageCount == imageNumber )
                    image = pgfNew->ppixels;
            }
            pgfLast = pgfNew;
        }
        
        // make the _gifinfo.Gif89.delayTime stale, so we know if we got a new
        // GCE for the next image
        _gifinfo.Gif89.delayTime = -1;
        
        }
        
        if ( imageCount > imageNumber )
            _gad.fAnimated = TRUE; // say multi-image == animated
        
#ifdef FEATURE_GIF_ANIMATION_LONG_LOOP_GOES_INFINITE
        // RAID #23709 - If an animation is sufficiently long, we treat it as indefinite...
        // Indefinite stays indefinite.
        // 5/29/96 - JCordell sez we shouldn't introduce this gratuitous NS incompatibility.
        //           We'll keep it around inside this ifdef in case we decide we want it.
        if ( _gad.fLooped &&
            (_gad.dwLoopDurMS * _gad.cLoops) / 1000 > dwIndefiniteGIFThreshold ) // if longer than five minutes
            _gad.cLoops = 0; // set to indefinite looping.
#endif // FEATURE_GIF_ANIMATION_LONG_LOOP_GOES_INFINITE
        
done:
        return image;
}

BITMAPINFO *
CImgGif::FinishDithering()
{
    BITMAPINFO * pbmi;
    
    if (GetColorMode() == 8)
    {
        pbmi = BIT_Make_DIB_PAL_Header(_gad.pgf->width, _gad.pgf->height);
    }
    else
    {
        pbmi = BIT_Make_DIB_RGB_Header_Screen(_gad.pgf->width, _gad.pgf->height,
            _gad.pgf->cColors, _gad.pgf->pcolors, _lTrans);
    }
    
    return pbmi;
}


//+-----------------------------------------------------------------------
//
//  Member:    LoadGifImage
//
//  Overview:  Given an IStream, decode an image into an array of bitmaps
//
//  Arguments: pStream      data source
//             colorKeys    pointer to where to store colorKey data
//             numBitmaps   where to store number of bitmaps
//             delays       where to store delay array
//             loop         where to store number of times to loop
//             ppBitMaps    where to store bitmaps
//
//  Returns:   S_OK on success otherwise error code
//
//------------------------------------------------------------------------
HRESULT
LoadGifImage(IStream *stream,                       
             COLORREF **colorKeys,
             int *numBitmaps,
             int **delays,
             double *loop,
             HBITMAP **ppBitMaps)
{
    HRESULT hr = S_OK;
   /* 
      The odd approach here lets us keep the original IE GIF code unchanged while removing
      DA specific inserts (except error reporting). The progressive rendering and palette 
      dithering found in the IE code is also not supported yet.
   */
   CImgGif gifimage;
   gifimage._szFileName = NULL;
   gifimage._gifinfo.stream = stream;
   BYTE *pbBits = gifimage.ReadGIFMaster();

   if (pbBits) {
      gifimage._pbBits = pbBits;
      gifimage._gad.pgf->pbmi = gifimage.FinishDithering(); 
   }

   /*
      Extract information from GIF decoder, and format it into an array of bitmaps.
   */
   *delays = NULL;
   vector<HBITMAP> vhbmp;
   vector<COLORREF> vcolorKey;
   vector<int> vdelay;
   LPVOID  image = NULL;
   LPVOID  lastBits = pbBits;
   LPVOID  bitsBeforeLastBits = NULL;
   HBITMAP *hImage = NULL;
   PBITMAPINFO pbmi = NULL;
   HBITMAP hbm;
   PGIFFRAME pgf = gifimage._gad.pgf;
   PGIFFRAME pgfOld = NULL;
   bool fUseOffset = false; 
   bool fFirstFrame = true;
   long pgfWidth,pgfHeight,     // animation frame dims
        fullWidth,fullHeight,   // main frame dims
        fullPad, pgfPad,        // row padding vals
        fullSize, pgfSize;
   unsigned int disp = 0;
    int i = 0;

   // TODO: Dither global palette to display palette

   fullWidth = gifimage._xWidth;
   fullHeight = gifimage._yHeight;
   fullPad = (((fullWidth + 3) / 4) * 4) - fullWidth;  
   fullSize = (fullPad+fullWidth)*fullHeight; 
    
   if (NULL == pgf)
   {
       hr = E_FAIL;
       goto done;
   }

   while(1) 
   {     
      Assert(pgf);      
      pbmi = pgf->pbmi;
      if (pbmi == NULL)
      {
          hr = E_FAIL;
          goto done;
      }

      // TODO: It would be nice to pass local palettes up so they could
      // be mapped to system palettes.       

      // Check to see if frame is offset from logical frame      
      if(pgf->top != 0 ||
         pgf->left != 0 || 
         pgf->width != fullWidth ||
         pgf->height != fullHeight) 
      {
         fUseOffset = true;    
         pgfWidth = pbmi->bmiHeader.biWidth;    
         pgfHeight = pbmi->bmiHeader.biHeight;  
         pbmi->bmiHeader.biWidth = fullWidth;      
         pbmi->bmiHeader.biHeight = fullHeight; 
         pgfPad = (((pgfWidth + 3) / 4) * 4) - pgfWidth; 
         pgfSize = (pgfPad+pgfWidth)*pgfHeight;
      }

      hbm = CreateDIBSection(NULL, pbmi, DIB_RGB_COLORS, (LPVOID *) &image, NULL, 0);        
      if(!hbm) 
      {
          hr = E_OUTOFMEMORY;
          goto done;
      }

      // Correctly composite bitmaps based on disposal method specified        
      disp = pgf->gced.uiDisposalMethod;
      // If the frame is offset, fill it with          
      if( (disp == gifRestorePrev) && (bitsBeforeLastBits != NULL) )
         memcpy(image, bitsBeforeLastBits, fullSize);
      else if( (disp == gifRestoreBkgnd) || (disp == gifRestorePrev) || fFirstFrame ) // fill with bgColor      
         memset(image, pgf->gced.ucTransIndex, fullSize);           
      else // fill with last frames data                                              
         memcpy(image, lastBits, fullSize);      
         
      
      // For offset gifs allocate an image the size of the first frame 
      // and then fill in the bits at the offset location.        
      if(fUseOffset) {         
         for(i=0; i<pgfHeight; i++) {               
            BYTE *dst, *src;                     
            // the destination is the address of the image data plus the frame and row offset. 
            int topOffset = fullHeight - pgfHeight - pgf->top;
            dst = (BYTE*)image +                                  
                  ( ((topOffset + i) *(fullPad+fullWidth)) + pgf->left );
            // copy from the frame's nth row
            src = pgf->ppixels + i*(pgfPad+pgfWidth);                
            for(int j=0; j<pgfWidth; j++) {     
                // copy the frame row data, excluding transparent bytes    
                if(src[j] != pgf->gced.ucTransIndex)
                    dst[j] = src[j];
            }
         }
      }     
      else {
         // Overwritten accumulated bits with current bits. If the 
         // new image contains transparency we need to take it into 
         // account. Since this is slower, special case it.
         if(pgf->gced.fTransparent) {            
            for(i=0; i<((fullPad+fullWidth)*fullHeight); i++) {        
                if(pgf->ppixels[i] != pgf->gced.ucTransIndex)
                    ((BYTE*)image)[i] = ((BYTE*)pgf->ppixels)[i];
            }
         }
         else // Otherwise, just copy over the offset window's bytes
            memcpy(image, pgf->ppixels, (fullPad+fullWidth)*fullHeight);  
      }

      /* 
          If we got a transparent color extension, convert it to a COLORREF
      */
      COLORREF colorKey = COLORKEY_NOT_SET;
      if (pgf->gced.fTransparent) {      
          int transparent = pgf->gced.ucTransIndex;
          colorKey = RGB(pgf->pbmi->bmiColors[transparent].rgbRed,
                         pgf->pbmi->bmiColors[transparent].rgbGreen,
                         pgf->pbmi->bmiColors[transparent].rgbBlue);
      }

      vcolorKey.push_back(colorKey);
      vhbmp.push_back(hbm);
      
      /* 
         The delay times are frame specific and can be different, these
         should be propagated as an array to the sampling code.  
      */      
      vdelay.push_back(pgf->gced.uiDelayTime);      

      bitsBeforeLastBits = lastBits;        
      lastBits = image;
      fUseOffset = false;
      if(pgf->pgfNext == NULL) 
          break;
      pgfOld = pgf;
      pgf = pgf->pgfNext;
      fFirstFrame = FALSE;      
   } 
 
   
   // The number of times to loop are also propagated.  Note we add one because 
   // all other GIF decoders appear to treat the loop as the number of times to 
   // loop AFTER the first run through the frames.
   if (gifimage._gad.cLoops == 0 && gifimage._gad.fLooped != 0)
   {
        *loop = HUGE_VAL;
   }
   else
   {
        *loop = gifimage._gad.cLoops;
   }
   
   *numBitmaps = vhbmp.size();

   // Since the vector will go out of scope, move contents over to heap
   hImage  = (HBITMAP *)MemAlloc(Mt(Mem), vhbmp.size() * sizeof(HBITMAP)); 
   if (NULL == hImage)
   {
       hr = E_OUTOFMEMORY;
       goto done;
   }

   *delays = (int*)MemAlloc(Mt(Mem), vhbmp.size() * sizeof(int)); 
   if (NULL == *delays)
   {
       hr = E_OUTOFMEMORY;
       goto done;
   }

   *colorKeys = (COLORREF*)MemAlloc(Mt(Mem), sizeof(COLORREF) * vcolorKey.size() ); 
   if (NULL == *colorKeys)
   {
       hr = E_OUTOFMEMORY;
       goto done;
   }

   for(i=0; i < vhbmp.size(); i++) {
      hImage[i] = vhbmp[i];
      (*colorKeys)[i] = vcolorKey[i];
      (*delays)[i] = vdelay[i];
   }

   *ppBitMaps = hImage;

   hr = S_OK;
done:
   if (FAILED(hr))
   {
       MemFree(hImage);
       MemFree(*delays);
       MemFree(*colorKeys);
   }
   return hr;
}

/*lint --flb*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\mediaelm.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1998
//
//  File: src\time\src\mediaelm.h
//
//  Contents: TIME media behavior
//
//------------------------------------------------------------------------------------

#pragma once

#ifndef _MEDIAELM_H
#define _MEDIAELM_H


#include "timeelmimpl.h"
#include "playerbase.h"
#include "playlistdelegator.h"
#include "mediaprivate.h"
#include "transsite.h"

interface ITransitionElement;
interface ITIMETransitionSite;

interface ITIMEPlayerSite
{
    //when players know their native size they call NegotiateSize. This allows the media
    //element to properly determine it's size.
    virtual void FireMediaEvent(PLAYER_EVENT plEvent) = 0;
    virtual HRESULT GetPropBag(IPropertyBag2 ** ppPropBag, IErrorLog ** ppErrorLog) = 0;
    virtual HRESULT NegotiateSize(RECT &nativeSize, RECT &finalSize, bool &fIsNative, bool fResetRs) = 0;
    virtual void InvalidateElement(LPCRECT lprect) = 0;
    virtual HRESULT PutNaturalRepeatCount(double dblRepeatCount) = 0;

    virtual HRESULT PutNaturalDuration(double dblNatDur) = 0;
    virtual HRESULT ClearNaturalDuration() = 0;
    virtual void ReadRegistryMediaSettings(bool & fPlayVideo, bool & fShowImages, bool & fPlayAudio, bool & fPlayAnimations) = 0;

    virtual bool isNaturalDuration() = 0;
    virtual void clearNaturalDuration() = 0;
    virtual void setNaturalDuration() = 0;
};


//+-------------------------------------------------------------------------------------
//
// CTIMEMediaElement
//
//--------------------------------------------------------------------------------------

class
ATL_NO_VTABLE
__declspec(uuid("efbad7f8-3f94-11d2-b948-00c04fa32195")) 
CTIMEMediaElement :
    public CTIMEElementImpl<ITIMEMediaElement2, &IID_ITIMEMediaElement2>,
    public CComCoClass<CTIMEMediaElement, &__uuidof(CTIMEMediaElement)>,
    public ISupportErrorInfoImpl<&IID_ITIMEMediaElement>,
    public IConnectionPointContainerImpl<CTIMEMediaElement>,
    public IPersistPropertyBag2,
    public IPropertyNotifySinkCP<CTIMEMediaElement>,
    public IPropertyNotifySink,
    public ITIMEPlayerSite,
    public IElementBehaviorRender,
    public IHTMLPainter,
    public IHTMLPainterOverlay,
    public ITIMETransitionSite,
    public ITIMEMediaNative,
    public ITIMEContentPlayerSite
{

  public:

    //+--------------------------------------------------------------------------------
    //
    // Public Methods
    //
    //---------------------------------------------------------------------------------

    CTIMEMediaElement();
    virtual ~CTIMEMediaElement();

#if DBG
    const _TCHAR * GetName() { return __T("CTIMEMediaElement"); }
#endif

    //
    // QI Map
    //

    BEGIN_COM_MAP(CTIMEMediaElement)
        COM_INTERFACE_ENTRY(ITIMEMediaElement)
        COM_INTERFACE_ENTRY(ITIMEMediaElement2)
        COM_INTERFACE_ENTRY(ITIMEMediaNative)
        COM_INTERFACE_ENTRY(ITIMEContentPlayerSite)
        COM_INTERFACE_ENTRY(ITIMEElement)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
        COM_INTERFACE_ENTRY(IPersistPropertyBag2)
        COM_INTERFACE_ENTRY_CHAIN(CBaseBvr)
        COM_INTERFACE_ENTRY(IPropertyNotifySink)
        COM_INTERFACE_ENTRY(IElementBehaviorRender)
        COM_INTERFACE_ENTRY(IHTMLPainter)
        COM_INTERFACE_ENTRY(IHTMLPainterOverlay)
        COM_INTERFACE_ENTRY(ITIMETransitionSite)
    END_COM_MAP();

#ifndef END_COM_MAP_ADDREF

    //
    // IUnknown
    //

    STDMETHOD_(ULONG,AddRef)(void) = 0;
    STDMETHOD_(ULONG,Release)(void) = 0;
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) = 0;
#endif

    //
    // IElementBehavior
    //

    STDMETHOD(Init)(IElementBehaviorSite * pBvrSite);
    STDMETHOD(Notify)(LONG event, VARIANT * pVar);
    STDMETHOD(Detach)();

    //
    // IElementBehaviorRender
    //

    STDMETHOD(Draw)(HDC hdc, LONG dwLayer, LPRECT prc, IUnknown * pParams);
    STDMETHOD(GetRenderInfo)(LONG *pdwRenderInfo);
    STDMETHOD(HitTestPoint)(LPPOINT point,
                            IUnknown *pReserved,
                            BOOL *hit);

    virtual void InvalidateRenderInfo();

    //
    // IHTMLPainter
    //
    STDMETHOD(Draw)(RECT rcBounds, RECT rcUpdate, LONG lDrawFlags, HDC hdc, LPVOID pvDrawObject);
    STDMETHOD(GetPainterInfo)(HTML_PAINTER_INFO* pInfo);
    STDMETHOD(HitTestPoint)(POINT pt, BOOL* pbHit, LONG *plPartID);
    STDMETHOD(OnResize)(SIZE size);


    //
    // IHTMLPainterOverlay

    STDMETHOD(OnMove)(RECT rcDevice);
    
    //
    // ITIMEMediaElement
    //

    // XML Attributes

    STDMETHOD(get_clipBegin)(VARIANT * pvar);
    STDMETHOD(put_clipBegin)(VARIANT var);

    STDMETHOD(get_clipEnd)(VARIANT * pvar);
    STDMETHOD(put_clipEnd)(VARIANT var);

    STDMETHOD(get_player)(VARIANT * clsid);
    STDMETHOD(put_player)(VARIANT clsid);
    
    STDMETHOD(get_src)(VARIANT * url);
    STDMETHOD(put_src)(VARIANT url);

    STDMETHOD(get_type)(VARIANT * type);
    STDMETHOD(put_type)(VARIANT type);
    
    // Properties

    STDMETHOD(get_abstract)(BSTR *abstract);

    STDMETHOD(get_author)(BSTR *auth);

    STDMETHOD(get_copyright)(BSTR *cpyrght);

    STDMETHOD(get_hasAudio)(VARIANT_BOOL * pvbVal);

    STDMETHOD(get_hasVisual)(VARIANT_BOOL * pvbVal);

    STDMETHOD(get_mediaDur)(double * dur);
    
    STDMETHOD(get_mediaHeight)(long *height);

    STDMETHOD(get_mediaWidth)(long *width);

    STDMETHOD(get_playerObject)(IDispatch **ppDisp);

    STDMETHOD(get_playList)(ITIMEPlayList** ppPlayList);

    STDMETHOD(get_rating)(BSTR *rate);

    STDMETHOD(get_title)(BSTR *title);

    STDMETHOD(get_hasPlayList)(VARIANT_BOOL * pvbVal);

    // Media Caps

    STDMETHOD(get_canSeek)(/*[out, retval]*/ VARIANT_BOOL * pvbVal);

    STDMETHOD(get_canPause)(/*[out, retval]*/ VARIANT_BOOL * pvbVal);
    
    STDMETHOD(get_earliestMediaTime)(VARIANT * earliestMediaTime);
    STDMETHOD(get_latestMediaTime)(VARIANT * latestMediaTime);
    STDMETHOD(put_minBufferedMediaDur)(VARIANT minBufferedMediaDur);
    STDMETHOD(get_minBufferedMediaDur)(VARIANT * minBufferedMediaDur);
    STDMETHOD(get_downloadTotal)(VARIANT * earliestMediaTime);
    STDMETHOD(get_downloadCurrent)(VARIANT * latestMediaTime);
    STDMETHOD(get_isStreamed)(VARIANT_BOOL * isStreamed);
    STDMETHOD(get_bufferingProgress)(VARIANT * bufferingProgress);
    STDMETHOD(get_hasDownloadProgress)(VARIANT_BOOL * hasDownloadProgress);
    STDMETHOD(get_mimeType)(BSTR *mimeType);
    STDMETHOD(seekToFrame)(long);
    STDMETHOD(decodeMimeType)(TCHAR * header, long headerSize, BSTR * mimeType);
    STDMETHOD(get_currentFrame)(long *currFrame);
    STDMETHOD(get_downloadProgress)(VARIANT * downloadProgress);

    //
    // ITIMETransitionSite
    //
    STDMETHOD(InitTransitionSite) (void);
    STDMETHOD(DetachTransitionSite) (void);
    STDMETHOD_(void, SetDrawFlag)(VARIANT_BOOL b)
    { return CTIMEElementBase::SetDrawFlag(b); }
    STDMETHOD(get_node)(ITIMENode ** ppNode)
    { return CTIMEElementBase::get_node(ppNode); }
    STDMETHOD(get_timeParentNode)(ITIMENode  ** ppNode)
    { return CTIMEElementBase::get_timeParentNode(ppNode); }
    STDMETHOD(FireTransitionEvent)(TIME_EVENT event)
    { return CTIMEElementBase::FireTransitionEvent(event); }

    //
    // ITIMEMediaNative
    //
    STDMETHOD(seekActiveTrack)(double dblSeekTime);
    STDMETHOD(get_activeTrackTime)(double *dblActiveTrackTime);

    //
    // ITIMEContentPlayerSite
    //
    STDMETHOD(GetEventRelaySite)(IUnknown **ppiEventRelaySite);

    //
    // IPersistPropertyBag2
    // 

    STDMETHOD(GetClassID)(CLSID* pclsid) { return CTIMEElementBase::GetClassID(pclsid); }
    STDMETHOD(InitNew)(void) { return CTIMEElementBase::InitNew(); }
    STDMETHOD(IsDirty)(void) { return S_OK; }
    STDMETHOD(Load)(IPropertyBag2 *pPropBag, IErrorLog *pErrorLog);
    STDMETHOD(Save)(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

    //
    // IPropertyNotifySink methods
    //

    STDMETHOD(OnChanged)(DISPID dispID);
    STDMETHOD(OnRequestEdit)(DISPID dispID);
    STDMETHODIMP Invoke(DISPID id,
                        REFIID riid,
                        LCID lcid,
                        WORD wFlags,
                        DISPPARAMS *pDispParams,
                        VARIANT *pvarResult,
                        EXCEPINFO *pExcepInfo,
                        UINT *puArgErr);

    //
    // overridden member of CTIMEEventSite
    //

    STDMETHOD(onPauseEvent)(float time, float fOffset);

    //
    // Event Handlers
    //

    virtual void OnLoad();
    virtual void OnBegin(double dblLocalTime, DWORD flags);
    virtual void OnEnd(double dblLocalTime);
    virtual void OnReset(double dblLocalTime, DWORD flags);
    virtual void OnUpdate(double dblLocalTime, DWORD flags);
    virtual void OnPause(double dblLocalTime);
    virtual void OnResume(double dblLocalTime);
    virtual void OnRepeat(double dblLocalTime);
    virtual void OnUnload();
    virtual void OnSeek(double dblLocalTime);
    virtual void OnTEPropChange(DWORD tePropType);
    virtual void UpdateSync();
    HRESULT PauseTimeSubTree();


    //TimeAction methods

    virtual bool ToggleTimeAction(bool on);

    //
    // Connection Point to allow IPropertyNotifySink
    //

    BEGIN_CONNECTION_POINT_MAP(CTIMEMediaElement)
        CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
    END_CONNECTION_POINT_MAP();

    //
    // This must be in the derived class and not the base class since
    // the typecast down to the base class messes things up
    //

    static inline HRESULT WINAPI
        InternalQueryInterface(CTIMEMediaElement* pThis,
                               const _ATL_INTMAP_ENTRY* pEntries,
                               REFIID iid,
                               void** ppvObject);

    //
    // Needed by CBvrBase
    //

    void * GetInstance() { return (ITIMEMediaElement *) this; }
    HRESULT GetTypeInfo(ITypeInfo ** ppInfo) { return GetTI(GetUserDefaultLCID(), ppInfo); }

    // Sizing flag

    //
    // Persistence helpers
    //

    STDMETHOD(OnPropertiesLoaded)(void);

    //
    // Misc. methods
    //
    virtual HRESULT StartRootTime(MMTimeline * tl);
    virtual void    StopRootTime(MMTimeline * tl);

    bool                IsFilterAttached();
    virtual bool        IsMedia() const          { return true; }
    virtual TimeState   GetTimeState();
    virtual HRESULT     GetSyncMaster(double & dblNewSegmentTime,
                                      LONG & lNewRepeatCount,
                                      bool & bCueing);
    virtual HRESULT     GetSize(RECT *prcPos);
    virtual HRESULT     SetSize(const RECT *prcPos);
    STDMETHOD           (CascadedPropertyChanged)(bool fNotifyChildren);

    // Player Site methods.

    bool                isNaturalDuration()     { return m_fDurationIsNatural; }
    void                clearNaturalDuration()  { m_fDurationIsNatural = false; }
    void                setNaturalDuration()    { m_fDurationIsNatural = true; }
    virtual bool        ContainsMediaElement()  { return true; }

    HRESULT             GetPropBag(IPropertyBag2 ** ppPropBag, IErrorLog ** ppErrorLog);
    HRESULT             NegotiateSize(RECT &nativeSize, RECT &finalSize, bool &fIsNative, bool fResetRs = false);
    virtual void        InvalidateElement(LPCRECT lprect);
    virtual void        UpdatePlayerAudioProperties();
    void                NotifyTrackChange();
    void                FireTrackChangeEvent();
    void                FireMediaEvent(PLAYER_EVENT plEvent);
    HRESULT             PutNaturalRepeatCount(double dblRepeatCount);
    HRESULT             PutNaturalDuration(double dblNatDur);
    HRESULT             ClearNaturalDuration();
    void                ReadRegistryMediaSettings(bool & fPlayVideo, bool & fShowImages, bool & fPlayAudio, bool &fPlayAnimations);
    LPOLESTR            GetBaseHREF() { return m_baseHREF;}
    virtual HRESULT InitPlayer(CTIMEMediaElement *pelem, 
                        LPOLESTR base, 
                        LPOLESTR src, 
                        LPOLESTR lpMimeType);

    //
    // GetXXXAttr Accessors
    //

    CAttr<LPWSTR> & GetSrcAttr()        { return m_SASrc; } 
    CAttr<LPWSTR> & GetTypeAttr()       { return m_SASrcType; } 
    CAttr<LPWSTR> & GetPlayerAttr()     { return m_SAPlayer; } 
    CAttr<float>  & GetClipBeginAttr()  { return m_FAClipBegin; } 
    CAttr<float>  & GetClipEndAttr()    { return m_FAClipEnd; } 
    CAttr<LPWSTR> & GettransInAttr()    { return m_SAtransIn; }
    CAttr<LPWSTR> & GettransOutAttr()   { return m_SAtransOut; }

    //
    // Notification Helpers
    //

    void NotifyPropertyChanged(DISPID dispid);

    //+--------------------------------------------------------------------------------
    //
    // Public Data
    //
    //---------------------------------------------------------------------------------

  protected:

    //+--------------------------------------------------------------------------------
    //
    // Protected Methods
    //
    //---------------------------------------------------------------------------------

    BEGIN_TIME_EVENTMAP() 
        TEM_INIT_EVENTMANAGER_SITE() 
        TEM_REGISTER_EVENT(TE_ONBEGIN)
        TEM_REGISTER_EVENT(TE_ONPAUSE)
        TEM_REGISTER_EVENT(TE_ONRESUME)
        TEM_REGISTER_EVENT(TE_ONEND)
        TEM_REGISTER_EVENT(TE_ONRESYNC)
        TEM_REGISTER_EVENT(TE_ONREPEAT)
        TEM_REGISTER_EVENT(TE_ONREVERSE)
        TEM_REGISTER_EVENT(TE_ONMEDIACOMPLETE)
        TEM_REGISTER_EVENT(TE_ONOUTOFSYNC)
        TEM_REGISTER_EVENT(TE_ONSYNCRESTORED)
        TEM_REGISTER_EVENT(TE_ONMEDIAERROR)
        TEM_REGISTER_EVENT(TE_ONCODECERROR)
        TEM_REGISTER_EVENT(TE_ONRESET)
        TEM_REGISTER_EVENT(TE_ONSCRIPTCOMMAND)
        TEM_REGISTER_EVENT(TE_ONMEDIABARTARGET)
        TEM_REGISTER_EVENT(TE_ONURLFLIP)
        TEM_REGISTER_EVENT(TE_ONTRACKCHANGE)
        TEM_REGISTER_EVENT(TE_ONSEEK)
        TEM_REGISTER_EVENT(TE_ONTIMEERROR)
        TEM_REGISTER_EVENT(TE_ONMEDIAINSERTED)
        TEM_REGISTER_EVENT(TE_ONMEDIAREMOVED)

        TEM_REGISTER_EVENT_NOTIFICATION(TEN_LOAD)
        TEM_REGISTER_EVENT_NOTIFICATION(TEN_UNLOAD)
        TEM_REGISTER_EVENT_NOTIFICATION(TEN_READYSTATECHANGE)
        TEM_REGISTER_EVENT_NOTIFICATION(TEN_STOP)
    END_TIME_EVENTMAP()

    //
    // Persistence and Notification helpers
    //

    virtual HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP);
    HRESULT GetNotifyConnection(IConnectionPoint **ppConnection);
    HRESULT InitPropertySink();
    HRESULT UnInitPropertySink();
    void UpdateClipTimes();
    HRESULT AllowCreateControl(BOOL *fAllowed, REFCLSID clsid);
    HRESULT AllowMixedContent(BOOL *fAllowed);
    void InitOnLoad();
    bool IsNativeSize();
    bool NeedSizeChange();

    //
    // Misc. methods
    //

    HRESULT Error();
    
    //+--------------------------------------------------------------------------------
    //
    // Protected Data
    //
    //---------------------------------------------------------------------------------

    static DWORD            ms_dwNumTimeMediaElems;

  private:

    //+--------------------------------------------------------------------------------
    //
    // Private methods
    //
    //---------------------------------------------------------------------------------

    HRESULT CreatePlayer(TOKEN playerToken);
    void RemovePlayer();

    void    GetBASEHREF();

    static HRESULT CreateExternalPlayer(CLSID clsid,
                                        ITIMEBasePlayer ** ppPlayer);
    
    //+--------------------------------------------------------------------------------
    //
    // Private Data
    //
    //---------------------------------------------------------------------------------
 
    // Attributes
    CAttr<LPWSTR>               m_SASrc;
    CAttr<LPWSTR>               m_SASrcType;
    CAttr<LPWSTR>               m_SAPlayer;     // Place holder for player attribute
    CAttr<float>                m_FAClipBegin;
    CAttr<float>                m_FAClipEnd;
    CAttr<long>                 m_LAClipBegin;
    CAttr<long>                 m_LAClipEnd;


    // Internal variables
    LPOLESTR                    m_baseHREF;
    DAComPtr<IServiceProvider>  m_sp;
    CLSID                       m_playerCLSID;

    DAComPtr<ITIMEBasePlayer>   m_Player;

    bool                        m_fLoading; // are we in Load persistence?

    bool                        m_fLoaded;
    bool                        m_fExternalPlayer;
    bool                        m_fHaveCLSID;
    bool                        m_fCreatePlayerError;
    DWORD                       m_mediaElementPropertyAccesFlags;
    RECT                        m_rcOrigSize;
    RECT                        m_rcMediaSize;
    bool                        m_fMediaSizeSet;
    DWORD                       m_dwAdviseCookie;
    bool                        m_fInOnChangedFlag;
    bool                        m_fDurationIsNatural;
    bool                        m_fLoadError;
    bool                        m_fEditModeFlag;  //cache of edit mode because it is expensive to query.
    bool                        m_fInPropLoad;
    TOKEN                       m_playerToken;
    bool                        m_fDetached;
    bool                        m_fNativeSize;
    bool                        m_fNativeSizeComputed;

    CComPtr<IHTMLPaintSite>     m_spPaintSite;
    CComPtr<IElementBehaviorSiteRender>    m_pBvrSiteRender;

    static TIME_PERSISTENCE_MAP PersistenceMap[];

    // for player persistance
    CComPtr<IPropertyBag2>      m_spPropBag;
    CComPtr<IErrorLog>          m_spErrorLog;

    // for sync
    CComPtr<ITIMEElement>       m_pSyncNode;
    CTIMEElementBase            *m_pSyncElem;
    bool                        m_fWaitForSync;
    bool                        m_fPauseForSync;
    bool                        m_fFirstPause;
    bool                        m_fIgnoreStyleChange;

    // playlist
    CPlayListDelegator * m_pPlayListDelegator;

}; // CTIMEMediaElement

//+---------------------------------------------------------------------------------
//  CTIMEMediaElement inline methods
//
//  (Note: as a general guideline, single line functions belong in the class declaration)
//
//----------------------------------------------------------------------------------

inline 
HRESULT WINAPI
CTIMEMediaElement::InternalQueryInterface(CTIMEMediaElement* pThis,
                                          const _ATL_INTMAP_ENTRY* pEntries,
                                          REFIID iid,
                                          void** ppvObject)
{ 
    return BaseInternalQueryInterface(pThis,
                                      (void *) pThis,
                                      pEntries,
                                      iid,
                                      ppvObject); 
}


#endif /* _MEDIAELM_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\imagedownload.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: src\time\src\imagedownload.h
//
//  Contents: 
//
//------------------------------------------------------------------------------------

#include "headers.h"

#include "imagedownload.h"
#include "playerimage.h"
#include "importman.h"

#include "loader.h"


CTableBuilder g_TableBuilder;

static const TCHAR IMGUTIL_DLL[] = _T("IMGUTIL.DLL");
static const TCHAR SHLWAPI_DLL[] = _T("SHLWAPI.DLL");
static const TCHAR URLMON_DLL[] = _T("URLMON.DLL");
static const TCHAR MSIMG32_DLL[] = _T("MSIMG32.DLL");

static const char DECODEIMAGE[] = "DecodeImage";
static const char SHCREATESHELLPALETTE[] = "SHCreateShellPalette";
static const char CREATEURLMONIKER[] = "CreateURLMoniker";
static const char TRANSPARENTBLT[] = "TransparentBlt";

static const unsigned int NUM_NONPALETTIZED_FORMATS = 3;
static const unsigned int NUM_PALETTIZED_FORMATS = 3;

extern HRESULT
LoadGifImage(IStream *stream,                       
             COLORREF **colorKeys,
             int *numBitmaps,
             int **delays,
             double *loop,
             HBITMAP **ppBitMaps);

//+-----------------------------------------------------------------------
//
//  Member:    CTableBuilder
//
//  Overview:  Constructor
//
//  Arguments: void
//
//  Returns:   void
//
//------------------------------------------------------------------------
CTableBuilder::CTableBuilder() :
    m_hinstSHLWAPI(NULL),
    m_hinstURLMON(NULL),
    m_hinstIMGUTIL(NULL),
    m_SHCreateShellPalette(NULL),
    m_CreateURLMoniker(NULL),
    m_DecodeImage(NULL), 
    m_hinstMSIMG32(NULL), 
    m_TransparentBlt(NULL)
{
}

//+-----------------------------------------------------------------------
//
//  Member:    ~CTableBuilder
//
//  Overview:  Destructor
//
//  Arguments: void
//
//  Returns:   void
//
//------------------------------------------------------------------------
CTableBuilder::~CTableBuilder()
{
    if (m_hinstSHLWAPI)
    {
        FreeLibrary(m_hinstSHLWAPI);
        m_hinstSHLWAPI = NULL;
    }
    if (m_hinstURLMON)
    {
        FreeLibrary(m_hinstURLMON);
        m_hinstURLMON = NULL;
    }
    if (m_hinstIMGUTIL)
    {
        FreeLibrary(m_hinstIMGUTIL);
        m_hinstIMGUTIL = NULL;
    }
    if (m_hinstMSIMG32)
    {
        FreeLibrary(m_hinstMSIMG32);
        m_hinstMSIMG32 = NULL;
    }

    m_SHCreateShellPalette = NULL;
    m_CreateURLMoniker = NULL;
    m_DecodeImage = NULL;
    m_TransparentBlt = NULL;
}

//+-----------------------------------------------------------------------
//
//  Member:    LoadShell8BitServices
//
//  Overview:  Load shlwapi.dll, save a function pointer to SHCreateShellPalette
//              call SHGetInverseCMAP
//
//  Arguments: void
//
//  Returns:   S_OK on success, otherwise error code
//
//------------------------------------------------------------------------
HRESULT 
CTableBuilder::LoadShell8BitServices()
{
    CritSectGrabber cs(m_CriticalSection);
    HRESULT hr = S_OK;

    if (m_hinstSHLWAPI != NULL)
    {
        hr = S_OK;
        goto done;
    }

    m_hinstSHLWAPI = LoadLibrary(SHLWAPI_DLL);  
    if (NULL == m_hinstSHLWAPI)
    {
        hr = E_FAIL;
        goto done;
    }

    m_SHCreateShellPalette = (CREATESHPALPROC)GetProcAddress(m_hinstSHLWAPI, SHCREATESHELLPALETTE);  
    if (NULL == m_SHCreateShellPalette)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = S_OK;
done:
    if (FAILED(hr))
    {
        FreeLibrary(m_hinstSHLWAPI);
        m_hinstSHLWAPI = NULL;
        m_SHCreateShellPalette = NULL;
    }

    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    Create8BitPalette
//
//  Overview:  Create a direct draw palette from SHCreateShellPalette
//
//  Arguments: pDirectDraw  pointer to direct draw
//             ppPalette    where to store the new palette
//
//  Returns:   S_OK on succees, otherwise error code
//
//------------------------------------------------------------------------
HRESULT 
CTableBuilder::Create8BitPalette(IDirectDraw *pDirectDraw, IDirectDrawPalette **ppPalette)
{
    CritSectGrabber cs(m_CriticalSection);
    HRESULT hr = S_OK;

    PALETTEENTRY palentry[256];
    UINT iRetVal = NULL;;
    HPALETTE hpal = NULL;

    if (NULL == m_SHCreateShellPalette)
    {
        Assert(NULL != m_SHCreateShellPalette);
        hr = E_UNEXPECTED;
        goto done;
    }

    hpal = m_SHCreateShellPalette(NULL);
    if (NULL == hpal)
    {
        hr = E_UNEXPECTED;
        goto done;
    }
    
    iRetVal = GetPaletteEntries(hpal, 0, 256, palentry);
    if (NULL == iRetVal)
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    hr = pDirectDraw->CreatePalette(DDPCAPS_ALLOW256 | DDPCAPS_8BIT, palentry, ppPalette, NULL); //lint !e620
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    if (NULL != hpal)
    {
        DeleteObject(hpal);
    }

    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    CreateURLMoniker
//
//  Overview:  Load librarys URLMON, and calls CreateURLMoniker
//
//  Arguments: pmkContext   pointer to base context moniker
//             szURL        name to be parsed
//             ppmk         the IMoniker interface pointer
//
//  Returns:   S_OK on success otherwise error code
//
//------------------------------------------------------------------------
HRESULT 
CTableBuilder::CreateURLMoniker(IMoniker *pmkContext, LPWSTR szURL, IMoniker **ppmk)
{
    CritSectGrabber cs(m_CriticalSection);
    HRESULT hr = S_OK;

    if (m_hinstURLMON == NULL)
    {
        m_hinstURLMON = LoadLibrary(URLMON_DLL);  
        if (NULL == m_hinstURLMON)
        {
            hr = E_FAIL;
            goto done;
        }
    }

    m_CreateURLMoniker = (CREATEURLMONPROC) ::GetProcAddress(m_hinstURLMON, CREATEURLMONIKER);
    if (NULL == m_CreateURLMoniker )
    {
        hr = E_FAIL;
        goto done;
    }

    hr = (*m_CreateURLMoniker)( pmkContext, szURL, ppmk );
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    GetTransparentBlt
//
//  Overview:  Load librarys MSIMG32 and gets the TransparentBlt function
//
//  Arguments: pProc - where to store the function pointer
//
//  Returns:   S_OK on success otherwise error code
//
//------------------------------------------------------------------------
HRESULT 
CTableBuilder::GetTransparentBlt( TRANSPARENTBLTPROC * pProc )
{
    CritSectGrabber cs(m_CriticalSection);
    HRESULT hr = S_OK;

    if (m_hinstMSIMG32 == NULL)
    {
        m_hinstMSIMG32 = LoadLibrary(MSIMG32_DLL);  
        if (NULL == m_hinstMSIMG32)
        {
            hr = E_FAIL;
            goto done;
        }
    }

    if (NULL == m_TransparentBlt)
    {
        m_TransparentBlt = (TRANSPARENTBLTPROC) ::GetProcAddress(m_hinstMSIMG32, TRANSPARENTBLT);
        if (NULL == m_TransparentBlt )
        {
            hr = E_FAIL;
            goto done;
        }
    }
    
    if (pProc)
    {
        *pProc = m_TransparentBlt;
    }

    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    ValidateImgUtil
//
//  Overview:  calls loadlibary on IMGUTIL.DLL
//
//  Arguments: void
//
//  Returns:   S_OK on success, otherwise error code
//
//------------------------------------------------------------------------
// Need to make sure imgutil.dll is available for LoadImage to work. This function was added
// because of a problem with earlier versions (pre IE4) of urlmon.dll.
HRESULT 
CTableBuilder::ValidateImgUtil()
{
    CritSectGrabber cs(m_CriticalSection);
    HRESULT hr = S_OK;
    
    if (m_hinstIMGUTIL != NULL)
    {
        goto done;
    }

    m_hinstIMGUTIL = LoadLibrary(IMGUTIL_DLL);  
    if (NULL == m_hinstIMGUTIL)
    {
        hr = E_FAIL;
        goto done;
    }

    m_DecodeImage = (DECODEIMGPROC) ::GetProcAddress(m_hinstIMGUTIL, DECODEIMAGE);
    if(NULL == m_DecodeImage)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = S_OK;
done:
    if (FAILED(hr))
    {
        if (NULL != m_hinstIMGUTIL)
        {
            FreeLibrary(m_hinstIMGUTIL);
            m_hinstIMGUTIL = NULL;
        }
        m_DecodeImage = NULL;
    }

    return hr;
}


//+-----------------------------------------------------------------------
//
//  Member:    DecodeImage
//
//  Overview:  Calls IMGUTIL::DecodeImage to decode an image from a stream.
//
//  Arguments: pStream  stream to decode from
//             pMap     optional map from MIME to classid
//             pEventSink   object to recieve decode process
//
//  Returns:   S_OK on success otherwise error code
//
//------------------------------------------------------------------------
HRESULT 
CTableBuilder::DecodeImage( IStream* pStream, IMapMIMEToCLSID* pMap, IImageDecodeEventSink* pEventSink )
{
    HRESULT hr = S_OK;

    if (m_hinstIMGUTIL == NULL)
    {
        Assert(NULL != m_hinstIMGUTIL);
        hr = E_UNEXPECTED;
        goto done;
    }

    hr = (*m_DecodeImage)( pStream, pMap, pEventSink );
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    CImageDownload
//
//  Overview:  Constructor
//
//  Arguments: void
//
//  Returns:   void
//
//------------------------------------------------------------------------
CImageDownload::CImageDownload(CAtomTable * pAtomTable) :
  m_pStopableStream(NULL),
  m_cRef(0),
  m_lSrc(ATOM_TABLE_VALUE_UNITIALIZED),
  m_pAnimatedGif(NULL),
  m_fMediaDecoded(false),
  m_fMediaCued(false),
  m_fRemovedFromImportManager(false),
  m_pList(NULL),
  m_dblPriority(INFINITE),
  m_nativeImageWidth(0),
  m_nativeImageHeight(0),
  m_pAtomTable(NULL),
  m_hbmpMask(NULL),
  m_fAbortDownload(false)
{
    if (NULL != pAtomTable)
    {
        m_pAtomTable = pAtomTable;
        m_pAtomTable->AddRef();
    }
}

//+-----------------------------------------------------------------------
//
//  Member:    ~CImageDownload
//
//  Overview:  Destructor
//
//  Arguments: void
//
//  Returns:   void
//
//------------------------------------------------------------------------
CImageDownload::~CImageDownload()
{
    if (NULL != m_pStopableStream)
    {
        delete m_pStopableStream;
        m_pStopableStream = NULL;
    }

    if (NULL != m_pAnimatedGif)
    {
        m_pAnimatedGif->Release();
        m_pAnimatedGif = NULL;
    }
    
    if (NULL != m_pList)
    {
        IGNORE_HR(m_pList->Detach());
        m_pList->Release();
        m_pList = NULL;
    }
    
    if (NULL != m_pAtomTable)
    {
        m_pAtomTable->Release();
        m_pAtomTable = NULL;
    }

    if (m_hbmpMask)
    {
        DeleteObject(m_hbmpMask);
    }
}

STDMETHODIMP_(ULONG)
CImageDownload::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
} // AddRef


STDMETHODIMP_(ULONG)
CImageDownload::Release(void)
{
    LONG l = InterlockedDecrement(&m_cRef);

    if (0 == l)
    {
        delete this;
    }
    return l;
} // Release

STDMETHODIMP
CImageDownload::QueryInterface(REFIID riid, void **ppv)
{
    if (NULL == ppv)
    {
        return E_POINTER;
    }

    *ppv = NULL;

    if ( IsEqualGUID(riid, IID_IUnknown) )
    {
        *ppv = static_cast<ITIMEMediaDownloader*>(this);
    }
    else if ( IsEqualGUID(riid, IID_ITIMEImportMedia) )
    {
        *ppv = static_cast<ITIMEImportMedia*>(this);
    }
    else if ( IsEqualGUID(riid, IID_ITIMEMediaDownloader) )
    {
        *ppv = static_cast<ITIMEMediaDownloader*>(this);
    }
    else if ( IsEqualGUID(riid, IID_ITIMEImageRender) )
    {
        *ppv = static_cast<ITIMEImageRender*>(this);
    }
    else if (IsEqualGUID(riid, IID_IBindStatusCallback))
    {
        *ppv = static_cast<IBindStatusCallback*>(this);
    }

    if ( NULL != *ppv )
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }
    return E_NOINTERFACE;
}

STDMETHODIMP
CImageDownload::Init(long lSrc)
{
    HRESULT hr = S_OK;

    Assert(NULL == m_pStopableStream);
    
    m_pStopableStream = new CStopableStream();
    if (NULL == m_pStopableStream)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    m_pList = new CThreadSafeList;
    if (NULL == m_pList)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    m_pList->AddRef();

    hr = m_pList->Init();
    if (FAILED(hr))
    {
        goto done;
    }

    m_lSrc = lSrc;

    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP
CImageDownload::GetPriority(double * dblPriority)
{
    HRESULT hr = S_OK;

    Assert(NULL != dblPriority);

    *dblPriority = m_dblPriority;

    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP
CImageDownload::GetUniqueID(long * plID)
{
    HRESULT hr = S_OK;

    Assert(NULL != plID);

    *plID = m_lSrc;

    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP
CImageDownload::InitializeElementAfterDownload()
{
    HRESULT hr = S_OK;

    hr = E_NOTIMPL;
done:
    return hr;
}

STDMETHODIMP
CImageDownload::GetMediaDownloader(ITIMEMediaDownloader ** ppImportMedia)
{
    HRESULT hr = S_OK;

    hr = E_NOTIMPL;
done:
    return hr;
}

STDMETHODIMP
CImageDownload::PutMediaDownloader(ITIMEMediaDownloader * pImportMedia)
{
    HRESULT hr = S_OK;

    hr = E_NOTIMPL;
done:
    return hr;
}

STDMETHODIMP
CImageDownload::AddImportMedia(ITIMEImportMedia * pImportMedia)
{
    HRESULT hr = S_OK;

    Assert(NULL != pImportMedia);

    CritSectGrabber cs(m_CriticalSection);

    m_fAbortDownload = false;
    
    if ( m_fMediaDecoded )
    {
        IGNORE_HR(pImportMedia->CueMedia());
    }
    else 
    {
        double dblPriority;
        hr = pImportMedia->GetPriority(&dblPriority);
        if (FAILED(hr))
        {
            goto done;
        }
        
        if (dblPriority < m_dblPriority)
        {
            m_dblPriority = dblPriority;
            hr = GetImportManager()->RePrioritize(this);
            if (FAILED(hr))
            {
                goto done;
            }
        }

        hr = m_pList->Add(pImportMedia);
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP
CImageDownload::RemoveImportMedia(ITIMEImportMedia * pImportMedia)
{
    HRESULT hr = E_FAIL;

    Assert(NULL != pImportMedia);

    hr = m_pList->Remove(pImportMedia);
    if (FAILED(hr))
    {
        goto done;
    }

    if (!m_fRemovedFromImportManager && 0 == m_pList->Size())
    {
        Assert(NULL != GetImportManager());
        
        CancelDownload();

        hr = GetImportManager()->Remove(this);
        if (FAILED(hr))
        {
            goto done;
        }

        m_fRemovedFromImportManager = true;
    }


done:
    return hr;
}

STDMETHODIMP
CImageDownload::CanBeCued(VARIANT_BOOL * pVB_CanCue)
{
    HRESULT hr = S_OK;

    if (NULL == pVB_CanCue)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    *pVB_CanCue = VARIANT_TRUE;
    
    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP
CImageDownload::CueMedia()
{
    HRESULT hr = S_OK;
    CComPtr<ITIMEImportMedia> spImportMedia;

    const WCHAR * cpchSrc = NULL;
    hr = GetAtomTable()->GetNameFromAtom(m_lSrc, &cpchSrc);
    if (FAILED(hr))
    {
        goto done;
    }

    // populate the image data
    hr = THR(LoadImage(cpchSrc, m_spDD3, &m_spDDSurface, &m_pAnimatedGif, &m_nativeImageWidth, &m_nativeImageHeight));

    {
        CritSectGrabber cs(m_CriticalSection);        
        m_fMediaDecoded = true;
    }

    while (S_OK == m_pList->GetNextElement(&spImportMedia, false))
    {
        if (spImportMedia != NULL)
        {
            if (FAILED(hr))
            {
                IGNORE_HR(spImportMedia->MediaDownloadError());
            }
            IGNORE_HR(spImportMedia->CueMedia());
        }

        hr = m_pList->ReturnElement(spImportMedia);
        if (FAILED(hr))
        {
            goto done;
        }

        spImportMedia.Release();
    }

    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP
CImageDownload::MediaDownloadError()
{
    return S_OK;
}


STDMETHODIMP
CImageDownload::PutDirectDraw(IUnknown * punkDirectDraw)
{
    HRESULT hr = S_OK;
    Assert(m_spDD3 == NULL);

    hr = punkDirectDraw->QueryInterface(IID_TO_PPV(IDirectDraw3, &m_spDD3));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP
CImageDownload::GetSize(DWORD * pdwWidth, DWORD * pdwHeight)
{
    HRESULT hr = S_OK;
    if (NULL == pdwWidth || NULL == pdwHeight)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    *pdwWidth = m_nativeImageWidth;
    *pdwHeight = m_nativeImageHeight;

    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP
CImageDownload::Render(HDC hdc, LPRECT prc, LONG lFrameNum)
{
    HRESULT hr = S_OK;
    HDC hdcSrc = NULL;

    if ( m_spDDSurface )
    {
        hr = THR(m_spDDSurface->GetDC(&hdcSrc));
        if (FAILED(hr))
        {
            goto done;
        }

        if (NULL == m_hbmpMask)
        {            
            DDCOLORKEY ddColorKey;
            COLORREF rgbTransColor;

            hr = THR(m_spDDSurface->GetColorKey(DDCKEY_SRCBLT, &ddColorKey)); //lint !e620
            if (SUCCEEDED(hr) && ddColorKey.dwColorSpaceLowValue != -1 )
            {
                DDPIXELFORMAT ddpf;
                ZeroMemory(&ddpf, sizeof(ddpf));
                ddpf.dwSize = sizeof(ddpf);
                
                hr = THR(m_spDDSurface->GetPixelFormat(&ddpf));
                if (FAILED(hr))
                {
                    goto done;
                }
                
                if (8 == ddpf.dwRGBBitCount)
                {
                    CComPtr<IDirectDrawPalette> spDDPalette;
                    PALETTEENTRY pal;
                    
                    hr = THR(m_spDDSurface->GetPalette(&spDDPalette));
                    if (FAILED(hr))
                    {
                        goto done;
                    }

                    hr = THR(spDDPalette->GetEntries(0, ddColorKey.dwColorSpaceLowValue, 1, &pal));
                    if (FAILED(hr))
                    {
                        goto done;
                    }
                    rgbTransColor = RGB(pal.peRed, pal.peGreen, pal.peBlue);
                }
                else
                {
                    rgbTransColor = ddColorKey.dwColorSpaceLowValue;
                }
                
                hr = THR(CreateMask(hdc, 
                    hdcSrc, 
                    m_nativeImageWidth, 
                    m_nativeImageHeight, 
                    rgbTransColor, 
                    &m_hbmpMask,
                    true));
                if (FAILED(hr))
                {
                    goto done;
                }
            }
        }
        
        hr = THR(MaskTransparentBlt(hdc, 
                                    prc, 
                                    hdcSrc, 
                                    m_nativeImageWidth, 
                                    m_nativeImageHeight, 
                                    m_hbmpMask));
                            
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else if ( m_pAnimatedGif )
    {
        hr = THR(m_pAnimatedGif->Render(hdc, prc, lFrameNum));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    GetDuration
//
//  Overview:  If an animated gif is present, returns the duration of frames
//
//  Arguments: pdblDuration     where to store the time, in seconds
//
//  Returns:   S_OK on success otherwise error code
//
//------------------------------------------------------------------------
STDMETHODIMP
CImageDownload::GetDuration(double * pdblDuration)
{
    HRESULT hr = S_OK;

    if (NULL == pdblDuration)
    {
        hr = E_INVALIDARG;
        goto done;
    }
   
    if (m_pAnimatedGif)
    {
        double dblDuration;
        dblDuration = m_pAnimatedGif->CalcDuration();
        dblDuration /= 1000.0;
        *pdblDuration = dblDuration;
    }
    
    hr = S_OK;
done:
    RRETURN(hr);
}

//+-----------------------------------------------------------------------
//
//  Member:    GetRepeatCount
//
//  Overview:  if an animated gif is present, returns the number of times to loop
//
//  Arguments: pdblRepeatCount      where to store the repeat count
//
//  Returns:   S_OK on success otherwise error code
//
//------------------------------------------------------------------------
STDMETHODIMP
CImageDownload::GetRepeatCount(double * pdblRepeatCount)
{
    HRESULT hr = S_OK;

    if (NULL == pdblRepeatCount)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    if (m_pAnimatedGif)
    {
        *pdblRepeatCount = m_pAnimatedGif->GetLoop();
    }
    
    hr = S_OK;
done:
    RRETURN(hr);
}

void
CImageDownload::CancelDownload()
{
    m_fAbortDownload = true;
    if (NULL != m_pStopableStream)
    {
        m_pStopableStream->SetCancelled();
    }

    return;
}

STDMETHODIMP
CImageDownload::NeedNewFrame(double dblCurrentTime, LONG lOldFrame, LONG * plNewFrame, VARIANT_BOOL * pvb, double dblClipBegin, double dblClipEnd)
{
    HRESULT hr = S_OK;
    
    if (NULL == plNewFrame)
    {
        hr = E_INVALIDARG;
        goto done;
    }
    if (NULL == pvb)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    *pvb = VARIANT_FALSE;

    if (NULL != m_pAnimatedGif)
    {
        if (m_pAnimatedGif->NeedNewFrame(dblCurrentTime, lOldFrame, plNewFrame, dblClipBegin, dblClipEnd))
        {
            *pvb = VARIANT_TRUE;
        }
        else
        {
            *pvb = VARIANT_FALSE;
        }
    }

    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
// Function:   DownloadFile
//
// Overview:   Begins a blocking URLMON download for the given file name,
//             data downloaded is stored in an IStream
//
// Arguments:  pszFileName  URL for file to download
//             ppStream     Where to store the stream interface used to get the data
//
// Returns:    S_OK on download success, 
//
//------------------------------------------------------------------------
HRESULT
DownloadFile(const WCHAR * pszFileName, 
             IStream ** ppStream, 
             LPWSTR* ppszCacheFileName,
             IBindStatusCallback * pBSC)
{
    HRESULT hr = S_OK;
    LPWSTR pszTrimmedName = NULL;
    TCHAR szCacheFileName[MAX_PATH+1];
    CFileStream *pStream = NULL;
    
    if (!pszFileName || !ppStream)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    *ppStream = NULL;
    
    pszTrimmedName = TrimCopyString(pszFileName);
    if (NULL == pszTrimmedName)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    
    hr = URLDownloadToCacheFileW(NULL, 
                                 pszTrimmedName, 
                                 szCacheFileName, 
                                 MAX_PATH, 
                                 0, 
                                 pBSC);
    if (FAILED(hr))
    {
        goto done;
    }

    pStream= new CFileStream ( NULL );
    if (NULL == pStream)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    
    hr = pStream->Open(szCacheFileName, GENERIC_READ);
    if (FAILED(hr))
    {
        goto done;
    }

    if (ppszCacheFileName)
    {
        *ppszCacheFileName = CopyString(szCacheFileName);
        if (NULL == *ppszCacheFileName)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }

    *ppStream = pStream;
    (*ppStream)->AddRef();

    hr = S_OK;
done:
    if (NULL != pszTrimmedName)
    {
        delete[] pszTrimmedName;
    }

    ReleaseInterface(pStream);
    
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    LoadImage
//
//  Overview:  Loads an image into a direct draw surface OR CAnimatedGif
//
//  Arguments: pszFileName      path to image sources
//             pDirectDraw      pointer to direct draw object
//             ppDDSurface      where to store the decoded image
//             ppAnimatedGif    where to store decoded gif image
//             pdwWidth         where to store decoded image width
//             pdwHegiht        where to store decoded image height
//
//  Returns:   S_OK on success, otherwise error code
//
//------------------------------------------------------------------------
STDMETHODIMP CImageDownload::LoadImage(const WCHAR * pszFileName,
                                             IUnknown *pDirectDraw,
                                             IDirectDrawSurface ** ppDDSurface, 
                                             CAnimatedGif ** ppAnimatedGif,
                                             DWORD * pdwWidth, DWORD *pdwHeight)
{
    HRESULT hr = S_OK;
    CComPtr<IStream> spStream;
    
    LPWSTR pszTrimmedName = NULL;
    LPWSTR pszCacheFileName = NULL;
    
    if (!pszFileName || !ppDDSurface)
    {
        hr = E_POINTER;
        goto done;
    }
    
    pszTrimmedName = TrimCopyString(pszFileName);
    if (NULL == pszTrimmedName)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = ::DownloadFile(pszTrimmedName, &spStream, &pszCacheFileName, this);
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(m_pStopableStream != NULL);
    m_pStopableStream->SetStream(spStream);

    hr = g_TableBuilder.ValidateImgUtil();
    if (FAILED(hr))
    {
        goto done;
    }
    
    if (StringEndsIn(pszTrimmedName, L".gif"))
    {
        hr = LoadGif(m_pStopableStream, pDirectDraw, ppAnimatedGif, pdwWidth, pdwHeight);
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else if (StringEndsIn(pszTrimmedName, L".bmp"))
    {
        hr = LoadBMP(pszCacheFileName, pDirectDraw, ppDDSurface, pdwWidth, pdwHeight);
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else
    {
        hr = LoadImageFromStream(m_pStopableStream, pDirectDraw, ppDDSurface, pdwWidth, pdwHeight);
        if (FAILED(hr))
        {
            goto done;
        }
    }
    
    hr = S_OK;
done:
    delete[] pszTrimmedName;    
    delete[] pszCacheFileName;

    return hr;
} 

HRESULT
CreateSurfacesFromBitmaps(IUnknown * punkDirectDraw, 
                          HBITMAP * phBMPs, 
                          int numGifs, 
                          LONG lWidth, 
                          LONG lHeight, 
                          IDirectDrawSurface** ppDDSurfaces,
                          DDPIXELFORMAT * pddpf)
{
    HRESULT hr = S_OK;

    Assert(punkDirectDraw);
    Assert(phBMPs);
    Assert(ppDDSurfaces);

    CComPtr<IDirectDrawSurface> spDDSurface;
    HDC hdcSurface = NULL;

    CComPtr<IDirectDraw> spDirectDraw;
    int i = 0;
    
    hr = THR(punkDirectDraw->QueryInterface(IID_TO_PPV(IDirectDraw, &spDirectDraw)));
    if (FAILED(hr))
    {
        goto done;
    }

    for (i = 0; i < numGifs; i++)
    {
        BOOL bSucceeded = FALSE;
        HGDIOBJ hOldObj = NULL;
        HDC hdcBMP = NULL;

        hr = THR(CreateOffscreenSurface(spDirectDraw, &spDDSurface, pddpf, false, lWidth, lHeight));
        if (FAILED(hr))
        {
            goto done;
        }
        
        hr = THR(spDDSurface->GetDC(&hdcSurface));
        if (FAILED(hr))
        {
            goto done;
        }

        hdcBMP = CreateCompatibleDC(hdcSurface);
        if (NULL == hdcBMP)
        {
            hr = E_FAIL;
            goto done;
        }

        hOldObj = SelectObject(hdcBMP, phBMPs[i]);
        if (NULL == hOldObj)
        {
            hr = E_FAIL;
            DeleteDC(hdcBMP);
            goto done;
        }

        bSucceeded = BitBlt(hdcSurface, 0, 0, lWidth, lHeight, hdcBMP, 0, 0, SRCCOPY);
        if (FALSE == bSucceeded)
        {
            hr = E_FAIL;
            SelectObject(hdcBMP, hOldObj);
            DeleteDC(hdcBMP);
            goto done;
        }

        ppDDSurfaces[i] = spDDSurface;
        ppDDSurfaces[i]->AddRef();

        SelectObject(hdcBMP, hOldObj);
        DeleteDC(hdcBMP);

        hr = THR(spDDSurface->ReleaseDC(hdcSurface));
        if (FAILED(hr))
        {
            goto done;
        }

        spDDSurface.Release();
        hdcSurface = NULL;

#ifdef NEVER
        // debugging -- blt to the screen. jeffwall 8/30/99
        {
            HDC nulldc = GetDC(NULL);
            HDC surfacedc;
            hr = spDDSurface->GetDC(&surfacedc);
            BitBlt(nulldc, 0, 0, lWidth, lHeight, surfacedc, 0, 0, SRCCOPY);
            hr = spDDSurface->ReleaseDC(surfacedc);
            DeleteDC(nulldc);
        }
#endif
    }


    hr = S_OK;
done:
    if ( spDDSurface != NULL && hdcSurface != NULL)
    {
        THR(spDDSurface->ReleaseDC(hdcSurface));
    }

    return hr;
}

STDMETHODIMP
CImageDownload::LoadBMP(LPWSTR pszBMPFilename,
                        IUnknown * punkDirectDraw,
                        IDirectDrawSurface **ppDDSurface,
                        DWORD * pdwWidth,
                        DWORD * pdwHeight)
{
    HRESULT hr = S_OK;
    CComPtr<IDirectDraw> spDD;
    CComPtr<IDirectDrawSurface> spDDSurface;
    BITMAP bmpSrc;
    HBITMAP hbmpSrc = NULL;
    HGDIOBJ hbmpOld = NULL;
    HDC hdcDest = NULL;
    HDC hdcSrc = NULL;
    BOOL bRet;
    int iRet;

    hbmpSrc = (HBITMAP)::LoadImage(NULL, pszBMPFilename, IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION | LR_LOADFROMFILE);
    if (NULL == hbmpSrc)
    {
        hr = E_FAIL;
        goto done;
    }
    
    ZeroMemory(&bmpSrc, sizeof(bmpSrc));    
    iRet = GetObject(hbmpSrc, sizeof(bmpSrc), &bmpSrc);
    if (0 == iRet)
    {
        hr = E_FAIL;
        goto done;
    }

    hdcSrc = CreateCompatibleDC(NULL);
    if (NULL == hdcSrc)
    {
        hr = E_FAIL;
        goto done;
    }

    hbmpOld = SelectObject(hdcSrc, hbmpSrc);
    if (NULL == hbmpOld)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(punkDirectDraw->QueryInterface(IID_TO_PPV(IDirectDraw, &spDD)));
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = THR(CreateOffscreenSurface(spDD, &spDDSurface, NULL, false, bmpSrc.bmWidth, bmpSrc.bmHeight));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(spDDSurface->GetDC(&hdcDest));
    if (FAILED(hr))
    {
        goto done;
    }
    
    bRet = BitBlt(hdcDest, 0, 0, bmpSrc.bmWidth, bmpSrc.bmHeight, hdcSrc, 0, 0, SRCCOPY);
    if (FALSE == bRet)
    {
        hr = E_FAIL;
        goto done;
    }

    // everything worked
    *pdwWidth = bmpSrc.bmWidth;
    *pdwHeight = bmpSrc.bmHeight;
    *ppDDSurface = spDDSurface;
    (*ppDDSurface)->AddRef();

    hr = S_OK;
done:
    if (hdcDest)
    {
        IGNORE_HR(spDDSurface->ReleaseDC(hdcDest));
    }
    if (hbmpOld)
    {
        SelectObject(hdcSrc, hbmpOld);
    }
    if (hdcSrc)
    {
        DeleteDC(hdcSrc);
    }
    if (hbmpSrc)
    {
        DeleteObject(hbmpSrc);
    }

    RRETURN(hr);
}

//+-----------------------------------------------------------------------
//
//  Member:    LoadGif
//
//  Overview:  Given an IStream, decode a gif into an allocated CAnimatedGif
//
//  Arguments: pStream      data source
//             ppAnimatedGif    where to store allocated CAnimatedGif
//             pdwWidth     where to store image width
//             pdwHeight    where to store image height
//
//  Returns:   S_OK on success otherwise error code
//
//------------------------------------------------------------------------
STDMETHODIMP
CImageDownload::LoadGif(IStream * pStream,
                          IUnknown * punkDirectDraw,
                          CAnimatedGif ** ppAnimatedGif,
                          DWORD *pdwWidth,
                          DWORD *pdwHeight,
                          DDPIXELFORMAT * pddpf /* = NULL */)
{
    HRESULT hr = S_OK;

    CAnimatedGif * pAnimatedGif = NULL;

    HBITMAP * phBMPs = NULL;
    int numGifs = 0;
    double loop = 0;
    int * pDelays = NULL;
    COLORREF * pColorKeys = NULL;
    IDirectDrawSurface ** ppDDSurfaces = NULL;
    int i = 0;

    if (NULL == ppAnimatedGif)
    {
        hr = E_POINTER;
        goto done;
    }
    if (NULL == pdwWidth || NULL == pdwHeight)
    {
        hr = E_POINTER;
        goto done;
    }

    pAnimatedGif = new CAnimatedGif;
    if (NULL == pAnimatedGif)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    // self managed object, does its own deletion.
    pAnimatedGif->AddRef();
    hr = THR(pAnimatedGif->Init(punkDirectDraw));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = LoadGifImage(pStream,
                      &pColorKeys,
                      &numGifs,
                      &pDelays,
                      &loop, 
                      &phBMPs);
    if (FAILED(hr))
    {
        goto done;
    }

    pAnimatedGif->PutNumGifs(numGifs);
    pAnimatedGif->PutDelays(pDelays);
    pAnimatedGif->PutLoop(loop);

    ppDDSurfaces = (IDirectDrawSurface**)MemAllocClear(Mt(Mem), numGifs*sizeof(IDirectDrawSurface*));
    if (NULL == ppDDSurfaces)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    pAnimatedGif->PutDDSurfaces(ppDDSurfaces);

    BITMAP bmpData;
    i = GetObject(phBMPs[0], sizeof(bmpData), &bmpData);
    if (0 == i)
    {
        hr = E_FAIL;
        goto done;
    }

    pAnimatedGif->PutWidth(bmpData.bmWidth);
    pAnimatedGif->PutHeight(bmpData.bmHeight);
    pAnimatedGif->PutColorKeys(pColorKeys);
    
    *pdwWidth = bmpData.bmWidth;
    *pdwHeight = bmpData.bmHeight;

    hr = THR(CreateSurfacesFromBitmaps(punkDirectDraw, phBMPs, numGifs, bmpData.bmWidth, bmpData.bmHeight, ppDDSurfaces, pddpf));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pAnimatedGif->CreateMasks();
    if (FAILED(hr))
    {
        goto done;
    }
    
#ifdef NEVER
    // debugging -- blt to screen. jeffwall 9/7/99
    for (i = 0; i < numGifs; i++)
    {
        // debugging -- blt to the screen. jeffwall 8/30/99
        HDC nulldc = GetDC(NULL);
        hr = GetLastError();
        HDC hdcFoo = CreateCompatibleDC(nulldc);
        hr = GetLastError();

        HGDIOBJ hOldObj = SelectObject(hdcFoo, phBMPs[i]);

        BitBlt(nulldc, 0, 0, bmpData.bmWidth, bmpData.bmHeight, hdcFoo, 0, 0, SRCCOPY);
        Sleep(pDelays[i]);

        SelectObject(hdcFoo, hOldObj);

        DeleteDC(hdcFoo);
        DeleteDC(nulldc);

    }
#endif

    *ppAnimatedGif = pAnimatedGif;

    hr = S_OK;
done:
    if (NULL != phBMPs)
    {
        for (i = 0; i < numGifs; i++)
        {
            if (NULL != phBMPs[i])
            {
                BOOL bSucceeded;
                bSucceeded = DeleteObject(phBMPs[i]);
                if (FALSE == bSucceeded)
                {
                    Assert(false && "A bitmap was still selected into a DC");
                }
            }
        }
        MemFree(phBMPs);
    }
    if (FAILED(hr))
    {
        if (NULL != pAnimatedGif)
        {
            pAnimatedGif->Release();
        }
    }
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    LoadImageFromStream
//
//  Overview:  Given an IStream, decode an image into a direct draw surface
//
//  Arguments: pStream      data source
//             pDirectDraw  pointer to direct draw
//             ppDDSurface  where to store the decoded image
//             pdwWidth     where to store image width
//             pdwHeight    where to store image height
//
//  Returns:   S_OK on success otherwise error code
//
//------------------------------------------------------------------------
STDMETHODIMP CImageDownload::LoadImageFromStream(IStream *pStream,
                                                       IUnknown *pDirectDraw,
                                                       IDirectDrawSurface **ppDDSurface, 
                                                       DWORD *pdwWidth, DWORD *pdwHeight)
{
    HRESULT hr = S_OK;
    CComPtr <IDirectDraw> spDDraw;
    CImageDecodeEventSink * pImageEventSink = NULL;

    hr = g_TableBuilder.ValidateImgUtil();
    if (FAILED(hr)) 
    {
        goto done;
    }

    // validate arguments
    if (NULL == pStream)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    if (NULL == ppDDSurface)
    {
        hr = E_POINTER;
        goto done;
    }

    if (NULL == pDirectDraw)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    hr = pDirectDraw->QueryInterface(IID_TO_PPV(IDirectDraw, &spDDraw));
    if (FAILED(hr))
    {
        goto done;
    }

    pImageEventSink = new CImageDecodeEventSink(spDDraw);
    if (NULL == pImageEventSink)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    pImageEventSink->AddRef();

    //--- Using g_TableBuilder as it's a static class that performs lazy
    // loading of dlls.  Here we're loading ImgUtil.dll.
    hr = g_TableBuilder.DecodeImage(pStream, NULL, pImageEventSink);
    if (FAILED(hr))
    {
        goto done;
    }

    // it is possible for the previous call to succeed, but not to return a surface
    *ppDDSurface = pImageEventSink->Surface();
    if (NULL == (*ppDDSurface))
    {
        hr = E_FAIL;
        goto done;
    }

    (*ppDDSurface)->AddRef();

    *pdwWidth = pImageEventSink->Width();
    *pdwHeight = pImageEventSink->Height();

    hr = S_OK;
done:
    ReleaseInterface(pImageEventSink);
    return hr;
} 

STDMETHODIMP
CImageDownload::OnStartBinding( 
                                  /* [in] */ DWORD dwReserved,
                                  /* [in] */ IBinding __RPC_FAR *pib)
{
    HRESULT hr = S_OK;
    
    hr = S_OK;
done:
    RRETURN(hr);
}

STDMETHODIMP
CImageDownload::GetPriority( 
                               /* [out] */ LONG __RPC_FAR *pnPriority)
{
    HRESULT hr = S_OK;
    
    hr = S_OK;
done:
    RRETURN(hr);
}

STDMETHODIMP
CImageDownload::OnLowResource( 
                                 /* [in] */ DWORD reserved)
{
    HRESULT hr = S_OK;
    
    hr = S_OK;
done:
    RRETURN(hr);
}

STDMETHODIMP
CImageDownload::OnProgress( 
                              /* [in] */ ULONG ulProgress,
                              /* [in] */ ULONG ulProgressMax,
                              /* [in] */ ULONG ulStatusCode,
                              /* [in] */ LPCWSTR szStatusText)
{
    HRESULT hr = S_OK;
    
    if (m_fAbortDownload)
    {
        hr = E_ABORT;
        goto done;
    }

    hr = S_OK;
done:
    RRETURN1(hr, E_ABORT);
}

STDMETHODIMP
CImageDownload::OnStopBinding( 
                                 /* [in] */ HRESULT hresult,
                                 /* [unique][in] */ LPCWSTR szError)
{
    HRESULT hr = S_OK;
    
    hr = S_OK;
done:
    RRETURN(hr);
}

STDMETHODIMP
CImageDownload::GetBindInfo( 
                               /* [out] */ DWORD __RPC_FAR *grfBINDF,
                               /* [unique][out][in] */ BINDINFO __RPC_FAR *pbindinfo)
{
    HRESULT hr = S_OK;
    
    hr = S_OK;
done:
    RRETURN(hr);
}

STDMETHODIMP
CImageDownload::OnDataAvailable( 
                                   /* [in] */ DWORD grfBSCF,
                                   /* [in] */ DWORD dwSize,
                                   /* [in] */ FORMATETC __RPC_FAR *pformatetc,
                                   /* [in] */ STGMEDIUM __RPC_FAR *pstgmed)
{
    HRESULT hr = S_OK;
    
    hr = S_OK;
done:
    RRETURN(hr);
}

STDMETHODIMP
CImageDownload::OnObjectAvailable( 
                                     /* [in] */ REFIID riid,
                                     /* [iid_is][in] */ IUnknown __RPC_FAR *punk)
{
    HRESULT hr = S_OK;
    
    hr = S_OK;
done:
    RRETURN(hr);
}


//+-----------------------------------------------------------------------
//
//  Member:    CImageDecodeEventSink
//
//  Overview:  constructor
//
//  Arguments: pDDraw   pointer to direct draw object
//
//  Returns:   void
//
//------------------------------------------------------------------------
CImageDecodeEventSink::CImageDecodeEventSink(IDirectDraw *pDDraw) :
    m_lRefCount(0),
    m_spDirectDraw(pDDraw),
    m_spDDSurface(NULL),
    m_dwWidth(0),
    m_dwHeight(0)
{
    ;
}

//+-----------------------------------------------------------------------
//
//  Member:    ~CImageDecodeEventSink
//
//  Overview:  destructor
//
//  Arguments: void
//
//  Returns:   void
//
//------------------------------------------------------------------------
CImageDecodeEventSink::~CImageDecodeEventSink()
{
    ;
}

//+-----------------------------------------------------------------------
//
//  Member:    QueryInterface
//
//  Overview:  COM casting method
//
//  Arguments: riid     interface requested
//             ppv      where to store interface
//
//  Returns:   S_OK if interface is supported, otherwise E_NOINTERFACE
//
//------------------------------------------------------------------------
STDMETHODIMP
CImageDecodeEventSink::QueryInterface(REFIID riid, void ** ppv)
{
    if (NULL == ppv)
    {
        return E_POINTER;
    }

    *ppv = NULL;

    if (IsEqualGUID(riid, IID_IUnknown))
    {
        *ppv = static_cast<IUnknown*>(this);
    }
    else if (IsEqualGUID(riid, IID_IImageDecodeEventSink))
    {
        *ppv = static_cast<IImageDecodeEventSink*>(this);
    }
    
    if (NULL != *ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }
    return E_NOINTERFACE;

}

//+-----------------------------------------------------------------------
//
//  Member:    AddRef
//
//  Overview:  Increments object reference count
//
//  Arguments: void
//
//  Returns:   new reference count
//
//------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CImageDecodeEventSink::AddRef()
{
    return InterlockedIncrement(&m_lRefCount);
}

//+-----------------------------------------------------------------------
//
//  Member:    Release
//
//  Overview:  Decrements object reference count.  Deletes object when =0
//
//  Arguments: void
//
//  Returns:   new reference count
//
//------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CImageDecodeEventSink::Release()
{
    ULONG l = InterlockedDecrement(&m_lRefCount);
    if (l == 0)
        delete this;
    return l;
}

//+-----------------------------------------------------------------------
//
//  Member:    GetSurface
//
//  Overview:  
//
//  Arguments: nWidth   image width
//             nHeight  image height
//             bfid     format for surface
//             nPasses  number of passes required, unused
//             dwHints  hints, unused
//             ppSurface    where to store created surface
//
//  Returns:   S_OK on success, otherwise error code
//
//------------------------------------------------------------------------
STDMETHODIMP
CImageDecodeEventSink::GetSurface(LONG nWidth, LONG nHeight, REFGUID bfid, ULONG nPasses, DWORD dwHints, IUnknown ** ppSurface)
{
    HRESULT hr = S_OK;

    if (NULL == ppSurface)
    {
        hr = E_INVALIDARG;
        goto done;
    }
    *ppSurface = NULL;

    m_dwWidth = nWidth;
    m_dwHeight = nHeight;

    DDPIXELFORMAT ddpf;
    ZeroMemory(&ddpf, sizeof(ddpf));
    ddpf.dwSize = sizeof(ddpf);

    if (IsEqualGUID(bfid, BFID_INDEXED_RGB_8))
    {
        ddpf.dwRGBBitCount = 8;
        ddpf.dwFlags |= DDPF_RGB;                   //lint !e620
        ddpf.dwFlags |= DDPF_PALETTEINDEXED8 ;      //lint !e620
    }
    else if (IsEqualGUID(bfid, BFID_RGB_24))
    {
        ddpf.dwFlags = DDPF_RGB;                    //lint !e620
        ddpf.dwRGBBitCount = 24;
        ddpf.dwBBitMask = 0x000000FF;
        ddpf.dwGBitMask = 0x0000FF00;
        ddpf.dwRBitMask = 0x00FF0000;
        ddpf.dwRGBAlphaBitMask = 0;
    }
    else if (IsEqualGUID(bfid, BFID_RGB_32))
    {
        ddpf.dwFlags = DDPF_RGB;                    //lint !e620
        ddpf.dwRGBBitCount = 32;
        ddpf.dwBBitMask = 0x000000FF;
        ddpf.dwGBitMask = 0x0000FF00;
        ddpf.dwRBitMask = 0x00FF0000;
        ddpf.dwRGBAlphaBitMask = 0;
    }
    else
    {
        hr = E_NOINTERFACE;
        goto done;
    }

    hr = CreateOffscreenSurface(m_spDirectDraw, &m_spDDSurface, &ddpf, false, nWidth, nHeight);
    if (FAILED(hr))
    {
        goto done;
    }
    
    if (8 == ddpf.dwRGBBitCount)
    {
        CComPtr<IDirectDrawPalette> spDDPal;

        hr = g_TableBuilder.LoadShell8BitServices();
        if (FAILED(hr))
        {
            goto done;
        }

        hr = g_TableBuilder.Create8BitPalette(m_spDirectDraw, &spDDPal);
        if (FAILED(hr))
        {
            goto done;
        }

        hr = m_spDDSurface->SetPalette(spDDPal);
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = m_spDDSurface->QueryInterface(IID_TO_PPV(IUnknown, ppSurface));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    OnBeginDecode
//
//  Overview:  Determine which image formats are supported
//
//  Arguments: pdwEvents    which events this is interested in receiving
//             pnFormats    where to store number of formats supported
//             ppFormats    where to store GUIDs for supported formats (allocated here)
//
//  Returns:   S_OK or error code
//
//------------------------------------------------------------------------
STDMETHODIMP
CImageDecodeEventSink::OnBeginDecode(DWORD * pdwEvents, ULONG * pnFormats, GUID ** ppFormats)
{
    HRESULT hr = S_OK;
    GUID *pFormats = NULL;

    if (pdwEvents == NULL)
    {
        hr = E_POINTER;
        goto done;
    }
    if (pnFormats == NULL)
    {
        hr = E_POINTER;
        goto done;
    }
    if (ppFormats == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    *pdwEvents = 0;
    *pnFormats = 0;
    *ppFormats = NULL;
    
    
    if (IsPalettizedDisplay())
    {
        pFormats = (GUID*)CoTaskMemAlloc(NUM_PALETTIZED_FORMATS * sizeof(GUID));
    }
    else
    {
        pFormats = (GUID*)CoTaskMemAlloc(NUM_NONPALETTIZED_FORMATS * sizeof(GUID));
    }
    if(pFormats == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    

    if (IsPalettizedDisplay())
    {
        pFormats[0] = BFID_INDEXED_RGB_8;
        pFormats[1] = BFID_RGB_24;
        pFormats[2] = BFID_RGB_32;
        *pnFormats = NUM_PALETTIZED_FORMATS;
    }
    else
    {
        pFormats[0] = BFID_RGB_32;
        pFormats[1] = BFID_RGB_24;
        pFormats[2] = BFID_INDEXED_RGB_8;
        *pnFormats = NUM_NONPALETTIZED_FORMATS;
    }
    
    *ppFormats = pFormats;
    *pdwEvents = IMGDECODE_EVENT_PALETTE|IMGDECODE_EVENT_BITSCOMPLETE
                |IMGDECODE_EVENT_PROGRESS|IMGDECODE_EVENT_USEDDRAW;

    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    OnBitsComplete
//
//  Overview:  when image bits are downloaded, called by filter
//
//  Arguments: void
//
//  Returns:   S_OK
//
//------------------------------------------------------------------------
STDMETHODIMP
CImageDecodeEventSink::OnBitsComplete()
{
    HRESULT hr = S_OK;

    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    OnDecodeComplete
//
//  Overview:  when image is decoded, called by filter
//
//  Arguments: hrStatus     unused
//
//  Returns:   S_OK
//
//------------------------------------------------------------------------
STDMETHODIMP
CImageDecodeEventSink::OnDecodeComplete(HRESULT hrStatus)
{
    HRESULT hr = S_OK;

    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    OnPalette
//
//  Overview:  when palette associated with surface changes, called by filter
//
//  Arguments: void
//
//  Returns:   S_OK
//
//------------------------------------------------------------------------
STDMETHODIMP
CImageDecodeEventSink::OnPalette()
{
    HRESULT hr = S_OK;

    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    OnProgress
//
//  Overview:  when incremental progress is made on decode, called by filter
//
//  Arguments: pBounds      rectangle where progress was made
//             bFinal       If this is the final pass for this rectangle
//
//  Returns:   S_OK
//
//------------------------------------------------------------------------
STDMETHODIMP
CImageDecodeEventSink::OnProgress(RECT *pBounds, BOOL bFinal)
{
    HRESULT hr = S_OK;

    hr = S_OK;
done:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\mediaattr.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: mediaattr.cpp
//
//  Contents: ITIMEMediaElement attributes
//
//------------------------------------------------------------------------------------

#include "headers.h"
#include "mediaelm.h"
#include "tokens.h"
#include "attr.h"

//+-----------------------------------------------------------------------------------
//
// Static functions for persistence (used by the TIME_PERSISTENCE_MAP below)
//
//------------------------------------------------------------------------------------

#define TME CTIMEMediaElement

                // Function Name // Class // Attr Accessor    // COM put_ fn  // COM get_ fn  // IDL Arg type
TIME_PERSIST_FN(TME_Src,          TME,    GetSrcAttr,         put_src,        get_src,        VARIANT);
TIME_PERSIST_FN(TME_Type,         TME,    GetTypeAttr,        put_type,       get_type,       VARIANT);
TIME_PERSIST_FN(TME_ClipBegin,    TME,    GetClipBeginAttr,   put_clipBegin,  get_clipBegin,  VARIANT);
TIME_PERSIST_FN(TME_ClipEnd,      TME,    GetClipEndAttr,     put_clipEnd,    get_clipEnd,    VARIANT);
TIME_PERSIST_FN(TME_Player,       TME,    GetPlayerAttr,      put_player,     get_player,     VARIANT);

//+-----------------------------------------------------------------------------------
//
//  Declare TIME_PERSISTENCE_MAP
//
//------------------------------------------------------------------------------------

BEGIN_TIME_PERSISTENCE_MAP(CTIMEMediaElement)
                           // Attr Name     // Function Name
    PERSISTENCE_MAP_ENTRY( WZ_SRC,          TME_Src )
    PERSISTENCE_MAP_ENTRY( WZ_TYPE,         TME_Type )
    PERSISTENCE_MAP_ENTRY( WZ_CLIPBEGIN,    TME_ClipBegin )
    PERSISTENCE_MAP_ENTRY( WZ_CLIPEND,      TME_ClipEnd )
    PERSISTENCE_MAP_ENTRY( WZ_PLAYER,       TME_Player )

END_TIME_PERSISTENCE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\mpctnsite.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: mpctnsite.cpp
//
//  Contents: 
//
//------------------------------------------------------------------------------------



#include "headers.h"
#include "mpctnsite.h"
#include "containerobj.h"

DeclareTag(tagMPContainerSite, "TIME: Players", "CMPContainerSite methods");

//DEFINE_GUID(DIID__MediaPlayerEvents,0x2D3A4C40,0xE711,0x11d0,0x94,0xAB,0x00,0x80,0xC7,0x4C,0x7E,0x95);

CMPContainerSite::CMPContainerSite()
: m_dwEventsCookie(0),
  m_fAutosize(false),
  m_lNaturalHeight(0),
  m_lNaturalWidth(0),
  m_fSized(false),
  m_pMPHost(NULL)
{
}

CMPContainerSite::~CMPContainerSite()
{
    CMPContainerSite::Detach();
}

HRESULT
CMPContainerSite::Init(CMPContainerSiteHost &pHost,
                       IUnknown * pCtl,
                       IPropertyBag2 *pPropBag,
                       IErrorLog *pErrorLog,
                       bool bSyncEvents)
{
    HRESULT hr;

    hr = THR(CContainerSite::Init(pHost,
                                  pCtl,
                                  pPropBag,
                                  pErrorLog));
    if (FAILED(hr))
    {
        goto done;
    }

    m_pMPHost = &pHost;

    if (bSyncEvents)
    {
        DAComPtr<IConnectionPointContainer> pcpc;
        // establish ConnectionPoint for Events
        hr = THR(m_pIOleObject->QueryInterface(IID_TO_PPV(IConnectionPointContainer, &pcpc)));
        if (FAILED(hr))
        {
            goto done;
        }
    

        hr = THR(pcpc->FindConnectionPoint(DIID_TIMEMediaPlayerEvents, &m_pcpEvents));
        if (FAILED(hr))
        {
            goto done;
        }

        Assert(m_pcpEvents);

        hr = THR(m_pcpEvents->Advise((IUnknown *)(IDispatch*)this, &m_dwEventsCookie));
        if (FAILED(hr))
        {
            m_pcpEvents.Release();
            m_dwEventsCookie = 0;
            goto done;
        }

        Assert(m_dwEventsCookie != 0);

        hr = THR(pcpc->FindConnectionPoint(DIID__MediaPlayerEvents, &m_pcpMediaEvents));
        if (FAILED(hr))
        {
            hr = S_OK;
            goto done;
        }

        hr = THR(m_pcpMediaEvents->Advise((IUnknown *)(IDispatch*)this, &m_dwMediaEventsCookie));
        if (FAILED(hr))
        {
            hr = S_OK;
            m_pcpMediaEvents.Release();
            m_dwMediaEventsCookie = 0;
            goto done;
        }

    }

    hr = S_OK;
  done:
    if (FAILED(hr))
    {
        Detach();
    }

    RRETURN(hr);
}

void
CMPContainerSite::Detach()
{
    // disconnect events
    if ((m_pcpEvents) && (m_dwEventsCookie != 0))
    {
        m_pcpEvents->Unadvise(m_dwEventsCookie);
        m_pcpEvents.Release();
        m_dwEventsCookie = 0;
    }
    if ((m_pcpMediaEvents) && (m_dwMediaEventsCookie != 0))
    {
        m_pcpMediaEvents->Unadvise(m_dwMediaEventsCookie);
        m_pcpMediaEvents.Release();
        m_dwMediaEventsCookie = 0;
    }

    CContainerSite::Detach();

    m_pMPHost = NULL;
}

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetTypeInfoCount, IDispatch
// Abstract:        Returns the number of tyep information 
//                  (ITypeInfo) interfaces that the object 
//                  provides (0 or 1).
//************************************************************

STDMETHODIMP
CMPContainerSite::GetTypeInfoCount(UINT *pctInfo) 
{
    TraceTag((tagMPContainerSite, "CMPContainerSite::GetTypeInfoCount"));
    return E_NOTIMPL;
} // GetTypeInfoCount

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetTypeInfo, IDispatch
// Abstract:        Retrieves type information for the 
//                  automation interface. 
//************************************************************

STDMETHODIMP
CMPContainerSite::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptInfo) 
{ 
    TraceTag((tagMPContainerSite, "CMPContainerSite::GetTypeInfo"));
    return E_NOTIMPL;
} // GetTypeInfo

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetIDsOfNames, IDispatch
// Abstract:        constructor
//************************************************************

STDMETHODIMP
CMPContainerSite::GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispID)
{
    TraceTag((tagMPContainerSite, "CMPContainerSite::GetIDsOfNames"));
    return E_NOTIMPL;
} // GetIDsOfNames

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        Invoke, IDispatch
// Abstract:        get entry point given ID
//************************************************************

STDMETHODIMP
CMPContainerSite::Invoke(DISPID dispIDMember, REFIID riid, LCID lcid, unsigned short wFlags, 
                         DISPPARAMS *pDispParams, VARIANT *pVarResult,
                         EXCEPINFO *pExcepInfo, UINT *puArgErr) 
{ 
    TraceTag((tagMPContainerSite, "CMPContainerSite::Invoke(%08X, %04X)", dispIDMember, wFlags));
    HRESULT hr;

    hr = ProcessEvent(dispIDMember,
                      pDispParams->cArgs, 
                      pDispParams->rgvarg);

    if (FAILED(hr))
    {
        hr = CContainerSite::Invoke(dispIDMember,
                                    riid,
                                    lcid,
                                    wFlags,
                                    pDispParams,
                                    pVarResult,
                                    pExcepInfo,
                                    puArgErr);
    }
    
    return hr;
} // Invoke

//************************************************************
// Author:          twillie
// Created:         11/06/98
// Abstract:        
//************************************************************

STDMETHODIMP
CMPContainerSite::EnumConnectionPoints(IEnumConnectionPoints ** ppEnum)
{
    TraceTag((tagMPContainerSite, "CMPContainerSite::EnumConnectionPoints"));

    if (ppEnum == NULL)
    {
        TraceTag((tagError, "CMPContainerSite::EnumConnectionPoints - invalid arg"));
        return E_POINTER;
    }

    return E_NOTIMPL;
}

//************************************************************
// Author:          twillie
// Created:         11/06/98
// Abstract:        Finds a connection point with a particular IID.
//************************************************************

STDMETHODIMP
CMPContainerSite::FindConnectionPoint(REFIID iid, IConnectionPoint **ppCP)
{
    TraceTag((tagMPContainerSite, "CMPContainerSite::FindConnectionPoint"));

    if (ppCP == NULL)
    {
        TraceTag((tagError, "CMPContainerSite::FindConnectionPoint - invalid arg"));
        return E_POINTER;
    }

    return E_NOTIMPL;
}

//************************************************************
// Author:          twillie
// Created:         11/12/98
// Abstract:        
//************************************************************
void 
CMPContainerSite::onbegin()
{
    TraceTag((tagMPContainerSite, "CMPContainerSite::onbegin"));
    THR(ProcessEvent(DISPID_TIMEMEDIAPLAYEREVENTS_ONBEGIN));
}

//************************************************************
// Author:          twillie
// Created:         11/12/98
// Abstract:        
//************************************************************
void 
CMPContainerSite::onend()
{
    TraceTag((tagMPContainerSite, "CMPContainerSite::onend"));
    THR(ProcessEvent(DISPID_TIMEMEDIAPLAYEREVENTS_ONEND));
}

//************************************************************
// Author:          twillie
// Created:         11/12/98
// Abstract:        
//************************************************************
void 
CMPContainerSite::onresume()
{
    TraceTag((tagMPContainerSite, "CMPContainerSite::onresume"));
    THR(ProcessEvent(DISPID_TIMEMEDIAPLAYEREVENTS_ONRESUME));
}

//************************************************************
// Author:          twillie
// Created:         11/12/98
// Abstract:        
//************************************************************
void 
CMPContainerSite::onpause()
{
    TraceTag((tagMPContainerSite, "CMPContainerSite::onpause"));
    THR(ProcessEvent(DISPID_TIMEMEDIAPLAYEREVENTS_ONPAUSE));
}

//************************************************************
// Author:          twillie
// Created:         11/12/98
// Abstract:        
//************************************************************
void 
CMPContainerSite::onmediaready()
{
    TraceTag((tagMPContainerSite, "CMPContainerSite::onmediaready"));
    THR(ProcessEvent(DISPID_TIMEMEDIAPLAYEREVENTS_ONMEDIAREADY));
}

//************************************************************
// Author:          twillie
// Created:         11/12/98
// Abstract:        
//************************************************************
void 
CMPContainerSite::onmedialoadfailed()
{
    TraceTag((tagMPContainerSite, "CMPContainerSite::onmedialoadfailed"));
    THR(ProcessEvent(DISPID_TIMEMEDIAPLAYEREVENTS_ONMEDIALOADFAILED));
}

HRESULT
CMPContainerSite::_OnPosRectChange(const RECT *prcPos)
{
    HRESULT hr;
    RECT nativeSize, elementSize;
    RECT rcPos;
    long lNaturalHeight, lNaturalWidth;

    CopyRect(&rcPos, prcPos);
    
    if (/*m_fSized == true ||*/
        m_pMPHost == NULL)
    {
        hr = S_FALSE;
        goto done;
    }
    
    //determine the natural size
    lNaturalHeight = rcPos.bottom - rcPos.top;
    lNaturalWidth = rcPos.right - rcPos.left;

    nativeSize.left = nativeSize.top = 0;
    nativeSize.right = lNaturalWidth;
    nativeSize.bottom = lNaturalHeight;
    m_lNaturalWidth = lNaturalWidth;
    m_lNaturalHeight = lNaturalHeight;

    if(m_lNaturalWidth == 0 || m_lNaturalHeight == 0)
    {
        m_lNaturalWidth = m_lNaturalHeight = 0;
    }

    hr = THR(m_pMPHost->NegotiateSize(nativeSize, elementSize, m_fAutosize));
    
    if(lNaturalWidth == 0 || lNaturalHeight == 0)
    {
        hr = S_FALSE;
        goto done;
    }

    m_fSized = true;
    
    if (!m_fAutosize)
    {
        hr = THR(m_pHost->GetContainerSize(&rcPos));
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else
    {
        hr = THR(m_pHost->SetContainerSize(&rcPos));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = THR(m_pInPlaceObject->SetObjectRects(&rcPos, &rcPos));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
} // OnPosRectChange

HRESULT
CMPContainerSite::ProcessEvent(DISPID dispid,
                               long lCount, 
                               VARIANT varParams[])
{
    TraceTag((tagMPContainerSite, "CMPContainerSite::ProcessEvent(%lx)",this));

    HRESULT hr = S_OK;

    if (!m_pHost)
    {
        hr = S_OK;
        goto done;
    }
    
    hr = THR(m_pHost->ProcessEvent(dispid,
                                   lCount,
                                   varParams));
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
  done:

    return hr;
}

HRESULT
CreateMPContainerSite(CMPContainerSiteHost &pHost,
                      IUnknown * pCtl,
                      IPropertyBag2 *pPropBag,
                      IErrorLog *pError,
                      bool bSyncEvents,
                      CMPContainerSite ** ppSite)
{
    CHECK_RETURN_SET_NULL(ppSite);
    
    HRESULT hr;
    CComObject<CMPContainerSite> *pNew;
    CComObject<CMPContainerSite>::CreateInstance(&pNew);

    if (!pNew)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = THR(pNew->Init(pHost,
                            pCtl,
                            pPropBag,
                            pError,
                            bSyncEvents));
        if (SUCCEEDED(hr))
        {
            pNew->AddRef();
            *ppSite = pNew;
        }
    }

    if (FAILED(hr))
    {
        delete pNew;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\mpctnsite.h ===
//+___________________________________________________________________________________
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: mpctnsite.h
//
//  Contents: 
//
//____________________________________________________________________________________



#ifndef _MPCTNSITE_H
#define _MPCTNSITE_H

#include "containersite.h"
#include "mediaprivate.h"

#define TIMEMEDIAPLAYEREVENTS_OFFSET                            0x0900
#define DISPID_TIMEMEDIAPLAYEREVENTS_BASE                       (TIMEMEDIAPLAYEREVENTS_OFFSET)
//
// ITIMEMediaPlayerEvents
//
#define DISPID_TIMEMEDIAPLAYEREVENTS_ONBEGIN                    (DISPID_TIMEMEDIAPLAYEREVENTS_BASE + 0x01)
#define DISPID_TIMEMEDIAPLAYEREVENTS_ONEND                      (DISPID_TIMEMEDIAPLAYEREVENTS_BASE + 0x02)
#define DISPID_TIMEMEDIAPLAYEREVENTS_ONRESUME                   (DISPID_TIMEMEDIAPLAYEREVENTS_BASE + 0x03)
#define DISPID_TIMEMEDIAPLAYEREVENTS_ONPAUSE                    (DISPID_TIMEMEDIAPLAYEREVENTS_BASE + 0x04)
#define DISPID_TIMEMEDIAPLAYEREVENTS_ONMEDIAREADY               (DISPID_TIMEMEDIAPLAYEREVENTS_BASE + 0x05)
#define DISPID_TIMEMEDIAPLAYEREVENTS_ONMEDIALOADFAILED          (DISPID_TIMEMEDIAPLAYEREVENTS_BASE + 0x07)

class
ATL_NO_VTABLE
CMPContainerSiteHost
: public CContainerSiteHost
{
  public:
    virtual HRESULT NegotiateSize(RECT &nativeSize,
                                  RECT &finalSize,
                                  bool &fIsNative) = 0;
};

class CContainerSite;

class
__declspec(uuid("afe601dd-ecd1-450e-9b90-d48b56153b82"))
ATL_NO_VTABLE
CMPContainerSite :
    public CComCoClass<CMPContainerSite, &__uuidof(CMPContainerSite)>,
    public CContainerSite,
    public IConnectionPointContainer
{
  public:
    CMPContainerSite();
    virtual ~CMPContainerSite();

    HRESULT Init(CMPContainerSiteHost &pHost,
                 IUnknown * pCtl,
                 IPropertyBag2 *pPropBag,
                 IErrorLog *pErrorLog,
                 bool bSyncEvents);
    virtual void Detach();

    BEGIN_COM_MAP(CMPContainerSite)
        COM_INTERFACE_ENTRY(IConnectionPointContainer)
        COM_INTERFACE_ENTRY_IID(DIID_TIMEMediaPlayerEvents, IDispatch)
        COM_INTERFACE_ENTRY_IID(DIID__MediaPlayerEvents, IDispatch)
        COM_INTERFACE_ENTRY_CHAIN(CContainerSite)
    END_COM_MAP();

#ifndef END_COM_MAP_ADDREF
    //
    // IUnknown Methods
    //
    STDMETHOD_(ULONG,AddRef)(void) = 0;
    STDMETHOD_(ULONG,Release)(void) = 0;
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) = 0;
#endif

    // IConnectionPointContainer methods
    STDMETHOD(EnumConnectionPoints)(IEnumConnectionPoints **ppEnum);
    STDMETHOD(FindConnectionPoint)(REFIID riid, IConnectionPoint **ppCP);

    // IDispatch Methods
    STDMETHODIMP GetTypeInfoCount(UINT *pctInfo);
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptInfo);
    STDMETHODIMP GetIDsOfNames(REFIID  riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispID);
    STDMETHODIMP Invoke(DISPID disIDMember,
                        REFIID riid,
                        LCID lcid,
                        unsigned short wFlags,
                        DISPPARAMS *pDispParams,
                        VARIANT *pVarResult,
                        EXCEPINFO *pExcepInfo,
                        UINT *puArgErr);

    // event methods that can be fired on the container
    void onbegin();
    void onend();
    void onresume();
    void onpause();
    void onmediaready();
    void onmedialoadfailed();

    void ClearAutosizeFlag() { m_fAutosize = false; }
    void ClearSizeFlag() { m_fSized = false; }
    long GetNaturalHeight() const { return m_lNaturalHeight; }
    long GetNaturalWidth() const { return m_lNaturalWidth; }

  protected:
    HRESULT _OnPosRectChange(const RECT * prc);
    HRESULT ProcessEvent(DISPID dispid,
                         long lCount = 0, 
                         VARIANT varParams[] = NULL);

  protected:
    CMPContainerSiteHost            *m_pMPHost;
    DWORD                            m_dwEventsCookie;
    DWORD                            m_dwMediaEventsCookie;
    DAComPtr<IConnectionPoint>       m_pcpEvents;
    DAComPtr<IConnectionPoint>       m_pcpMediaEvents;
    long                             m_lNaturalHeight;
    long                             m_lNaturalWidth;
    bool                             m_fSized;
    bool                             m_fAutosize;
};

HRESULT
CreateMPContainerSite(CMPContainerSiteHost &pHost,
                      IUnknown * pCtl,
                      IPropertyBag2 *pPropBag,
                      IErrorLog *pError,
                      bool bSyncEvents,
                      CMPContainerSite ** ppSite);


#endif /* _MPCTNSITE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\player2.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: player2.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/
#pragma once

#ifndef _PLAYER2_H
#define _PLAYER2_H

#include "playerbase.h"
#include "mpctnsite.h"

class CTIMEMediaElement;
class CMPContainerSite;

/////////////////////////////////////////////////////////////////////////////
// CTTIMEPlayer

class
ATL_NO_VTABLE
CTIMEPlayer2 :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CTIMEBasePlayer,
    public ITIMEMediaPlayerSite,
    public CMPContainerSiteHost,
    public IServiceProvider,
    public IPropertyNotifySink
{
  public:
    CTIMEPlayer2();
    virtual ~CTIMEPlayer2();

    HRESULT InitPlayer2(CLSID clsid,
                        IUnknown * pObj);
    
    virtual HRESULT Init(CTIMEMediaElement *pelem,
                         LPOLESTR base,
                         LPOLESTR src,
                         LPOLESTR lpMimeType,
                         double dblClipBegin,
                         double dblClipEnd); //lint !e1735
    virtual HRESULT DetachFromHostElement (void);
    
    BEGIN_COM_MAP(CTIMEPlayer2)
        COM_INTERFACE_ENTRY(ITIMEMediaPlayerSite)
        COM_INTERFACE_ENTRY(IServiceProvider)
        COM_INTERFACE_ENTRY(IPropertyNotifySink)
    END_COM_MAP();

#ifndef END_COM_MAP_ADDREF
                     
    STDMETHOD_(ULONG,AddRef)(void) = 0;
    STDMETHOD_(ULONG,Release)(void) = 0;
#endif

    // CContainerSiteHost
    virtual IHTMLElement * GetElement();
    virtual IServiceProvider * GetServiceProvider();

    virtual HRESULT Invalidate(LPCRECT prc);

    virtual HRESULT GetContainerSize(LPRECT prcPos);
    virtual HRESULT SetContainerSize(LPCRECT prcPos);
    
    virtual HRESULT ProcessEvent(DISPID dispid,
                                 long lCount, 
                                 VARIANT varParams[]);

    virtual HRESULT GetExtendedControl(IDispatch **ppDisp);

    // CMPContainerSiteHost
    virtual HRESULT NegotiateSize(RECT &nativeSize,
                                  RECT &finalSize,
                                  bool &fIsNative);

    // ITIMEMediaPlayerSite
    STDMETHOD(get_timeElement)(ITIMEElement ** ppElm);
    STDMETHOD(get_timeState)(ITIMEState ** ppState);
    STDMETHOD(reportError)(HRESULT errorhr,
                           BSTR errorStr);

    // IServiceProvider
    STDMETHOD(QueryService)(REFGUID guidService,
                            REFIID riid,
                            void** ppv);

    //
    // IPropertyNotifySink methods
    //
    STDMETHOD(OnChanged)(DISPID dispID);
    STDMETHOD(OnRequestEdit)(DISPID dispID);

    static bool CheckObject(IUnknown * pObj);
    
    virtual HRESULT GetExternalPlayerDispatch(IDispatch **ppDisp);

    virtual void Start();
    virtual void Stop();
    virtual void Pause();
    virtual void Resume();
    virtual void Repeat();
    virtual HRESULT Seek(double dblTime);

    virtual HRESULT HasMedia(bool &fHasMedia);
    virtual HRESULT HasVisual(bool &fHasVideo);
    virtual HRESULT HasAudio(bool &fHasAudio);
    virtual HRESULT CanSeek(bool &fcanSeek);
    virtual HRESULT CanPause(bool &fcanPause);
    virtual HRESULT IsBroadcast(bool &bisBroad);

    virtual HRESULT Reset();
    virtual PlayerState GetState();
    virtual void PropChangeNotify(DWORD tePropType);
    virtual void ReadyStateNotify(LPWSTR szReadyState);
    virtual bool UpdateSync();

    virtual HRESULT Render(HDC hdc, LPRECT prc);
    virtual HRESULT GetNaturalHeight(long *height);
    virtual HRESULT GetNaturalWidth(long *width);
    virtual HRESULT SetSize(RECT *prect);

    virtual HRESULT GetMediaLength(double &dblLength);
    virtual HRESULT GetEffectiveLength(double &dblLength);
    virtual void SetClipBegin(double dblClipBegin);
    virtual void SetClipEnd(double dblClipEnd);
    virtual double GetCurrentTime();
    virtual HRESULT GetCurrentSyncTime(double & dblSyncTime);

    virtual HRESULT SetSrc(LPOLESTR base, LPOLESTR src);
    virtual HRESULT SetVolume(float flVolume);
    virtual HRESULT SetMute(VARIANT_BOOL varMute);

    virtual HRESULT GetAuthor(BSTR *pAuthor);
    virtual HRESULT GetTitle(BSTR *pTitle);
    virtual HRESULT GetCopyright(BSTR *pCopyright);
    virtual HRESULT GetAbstract(BSTR *pAbstract);
    virtual HRESULT GetRating(BSTR *pRating) ;

    virtual HRESULT GetPlayList(ITIMEPlayList **ppPlayList);
    virtual HRESULT GetPlaybackOffset(double &dblOffset);
    virtual HRESULT GetEffectiveOffset(double &dblOffset);
    virtual HRESULT HasPlayList(bool &fhasPlayList);

    virtual HRESULT GetIsStreamed(bool &bIsStreamed);
    virtual HRESULT GetBufferingProgress(double &dblProgress);
    virtual HRESULT GetHasDownloadProgress(bool &bHasDownloadProgress);
    virtual HRESULT GetDownloadProgress(double &dblProgress);

  protected:
    HRESULT CreateContainer();
    HRESULT InitPropSink();
    void DeinitPropSink();
    double GetPlayerTime();
    void UpdateNaturalDur();
    
  protected:
    LONG m_cRef;
    DAComPtr<ITIMEMediaPlayer> m_spPlayer;
    DAComPtr<CMPContainerSite> m_pSite;
    DWORD m_dwPropCookie;

    bool m_fActive;
    bool m_fRunning;
    bool m_fIsOutOfSync;
    double m_dblSyncTime;
    SYNC_TYPE_ENUM m_syncType;
};

inline IHTMLElement *
CTIMEPlayer2::GetElement()
{
    return CTIMEBasePlayer::GetElement();
}

inline IServiceProvider *
CTIMEPlayer2::GetServiceProvider()
{
    return CTIMEBasePlayer::GetServiceProvider();
}

inline HRESULT
CTIMEPlayer2::Invalidate(LPCRECT prc)
{
    InvalidateElement(prc);
    return S_OK;
} 

HRESULT
CreateTIMEPlayer2(CLSID clsid,
                  IUnknown * pObj,
                  CTIMEPlayer2 ** ppPlayer2);

#endif /* _PLAYERBASE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\player.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: player.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/
#pragma once

#ifndef _PLAYER_H
#define _PLAYER_H

#include "containerobj.h"
#include "playerbase.h"


class
__declspec(uuid("22d6f312-b0f6-11d0-94ab-0080c74c7e95"))
MediaPlayerCLSID {};

#define MP_INFINITY -1  //lint !e760

class CPlayList;
enum TIME_EVENT;

/////////////////////////////////////////////////////////////////////////////
// CTTIMEPlayer

class CTIMEPlayer :
    public CTIMEBasePlayer
{
  public:
    CTIMEPlayer(CLSID clsid);
    ~CTIMEPlayer();

    HRESULT Init(CTIMEMediaElement *pelem, 
                 LPOLESTR base, 
                 LPOLESTR src, 
                 LPOLESTR lpMimeType, 
                 double dblClipBegin = -1.0, 
                 double dblClipEnd = -1.0); //lint !e1735
    HRESULT DetachFromHostElement (void);

    static bool CheckObject(IUnknown * pObj);

    // IUnknown Methods
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);

    virtual void OnTick(double dblSegmentTime,
                        LONG lCurrRepeatCount);

    void Start();
    void Stop();
    void Pause();
    void Resume();
    void Repeat();

    virtual void PropChangeNotify(DWORD tePropType);
    virtual bool UpdateSync();
    HRESULT Reset();
    HRESULT Render(HDC hdc, LPRECT prc);

    HRESULT GetExternalPlayerDispatch(IDispatch **ppDisp);

    void GetClipBegin(double &pvar);
    void SetClipBegin(double var);
    void GetClipEnd(double &pvar);
    void SetClipEnd(double var);
    HRESULT SetSrc(LPOLESTR base, LPOLESTR src);


    bool SetSyncMaster(bool fSyncMaster);
    HRESULT SetSize(RECT *prect);

    double GetCurrentTime();
    HRESULT GetCurrentSyncTime(double & dblSyncTime);
    HRESULT Seek(double dblTime);
    HRESULT GetMediaLength(double &dblLength);
    HRESULT GetEffectiveLength(double &dblLength);
    HRESULT CanSeek(bool &fcanSeek);
    PlayerState GetState();
    HRESULT CanSeekToMarkers(bool &fcanSeek);
    HRESULT IsBroadcast(bool &fisBroadcast);
    virtual HRESULT HasPlayList(bool &fhasPlayList);
    virtual HRESULT GetIsStreamed(bool &fIsStreamed);
    virtual HRESULT GetBufferingProgress(double &dblBufferingProgress);

    CContainerObj* GetContainerObj() { return m_pContainer; }
    HRESULT GetNaturalHeight(long *height);
    HRESULT GetNaturalWidth(long *width);


    HRESULT GetTitle(BSTR *pTitle);
    HRESULT GetAuthor(BSTR *pAuthor);
    HRESULT GetCopyright(BSTR *pCopyright);
    HRESULT GetAbstract(BSTR *pAbstract);
    HRESULT GetRating(BSTR *pAbstract);

    HRESULT GetRate(double &pdblRate);
    HRESULT SetRate(double dblRate);
    HRESULT GetVolume(float *pflVolume);
    HRESULT SetVolume(float flVolume);
#ifdef NEVER //dorinung 03-16-2000 bug 106458
    HRESULT GetBalance(float *pflBalance);
    HRESULT SetBalance(float flBalance);
#endif
    HRESULT GetMute(VARIANT_BOOL *pvarMute);
    HRESULT SetMute(VARIANT_BOOL varMute);
    virtual HRESULT HasMedia(bool &fHasMedia);
    virtual HRESULT HasVisual(bool &fHasVideo);
    virtual HRESULT HasAudio(bool &fHasAudio);
    virtual HRESULT GetMimeType(BSTR *pMime);

    virtual HRESULT CueMedia() { return E_NOTIMPL; }

    HRESULT FireEvents(TIME_EVENT TimeEvent, 
                       long lCount, 
                       LPWSTR szParamNames[], 
                       VARIANT varParams[]);
    HRESULT FireEventNoErrorState(TIME_EVENT TimeEvent, 
                       long lCount, 
                       LPWSTR szParamNames[], 
                       VARIANT varParams[]);
    void FireMediaEvent(PLAYER_EVENT plEvent);

    CPlayList * GetPlayList() { return m_playList; } //lint !e1411

    virtual HRESULT GetPlayList(ITIMEPlayList **ppPlayList);
    HRESULT GetPlayListInfo(long EntryNum, LPWSTR bstrParamName, LPWSTR *pbstrValue);

    HRESULT InitElementSize();

    virtual void ReadyStateNotify(LPWSTR szReadyState);
    //
    // persistance methods
    //
    virtual HRESULT Save(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

    //Helper method. Sould only used by CContainerObj::ProcessEvent();
    void SetHoldingFlag(void);
    void ClearHoldingFlag(void);

    HRESULT GetPlayerSize(RECT *prcPos);
    HRESULT SetPlayerSize(const RECT *prcPos);
    HRESULT NegotiateSize(RECT &nativeSize, RECT &finalSize, bool &fIsNative, bool fResetRs = false);
  protected:
    void InternalStart();
    HRESULT GetMediaPlayerInfo(LPWSTR *pwstr, int mpInfoToReceive);
    
    void FillPlayList(CPlayList *pPlayList);

    HRESULT SetActiveTrack(long index);
    HRESULT GetActiveTrack(long *index);

    HRESULT CreatePlayList();

    LONG m_cRef;
    CLSID               m_playerCLSID;
    DAComPtr<CContainerObj>      m_pContainer;
    bool                m_fExternalPlayer;
    DAComPtr<CPlayList> m_playList;   
    VARIANT             m_varClipBegin;
    VARIANT             m_varClipEnd;
    bool                m_fSyncMaster;
    bool                m_fRunning;
    bool                m_fHolding;
    double              m_dblStart;
    bool                m_fLoadError;
    bool                m_fActive;
    bool                m_fNoPlaylist;
    bool                m_fPlayListLoaded;
    bool                m_fIsOutOfSync;
    SYNC_TYPE_ENUM      m_syncType;
    double              m_dblSyncTime;
    bool                m_fHasSrc;
    bool                m_fMediaComplete;
    bool                m_fSpeedIsNegative;
    bool                m_fIsStreamed;
};

inline void
CTIMEPlayer::SetHoldingFlag()
{
    m_fHolding = true;
};
inline void
CTIMEPlayer::ClearHoldingFlag()
{
    m_fHolding = false;
};
#endif /* _PLAYER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\player2.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: player.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "player2.h"
#include "mediaelm.h"
#include "containerobj.h"

DeclareTag(tagPlayer2, "API", "CTIMEPlayer2 methods");
DeclareTag(tagPlayer2sync, "sync", "CTIMEPlayer2 sync methods");

CTIMEPlayer2::CTIMEPlayer2()
: m_cRef(0),
  m_dwPropCookie(0),
  m_fActive(false),
  m_fRunning(false),
  m_fIsOutOfSync(false),
  m_dblSyncTime(0.0),
  m_syncType(sync_none)

{
    TraceTag((tagPlayer2,
              "CTIMEPlayer2(%p)::CTIMEPlayer2()",
              this));
}

CTIMEPlayer2::~CTIMEPlayer2()
{
    TraceTag((tagPlayer2,
              "CTIMEPlayer2(%p)::~CTIMEPlayer2()",
              this));

    CTIMEPlayer2::DetachFromHostElement();
}

STDMETHODIMP_(ULONG)
CTIMEPlayer2::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG)
CTIMEPlayer2::Release(void)
{
    LONG l = InterlockedDecrement(&m_cRef);

    if (0 == l)
    {
        delete this;
    }

    return l;
}

bool
CTIMEPlayer2::CheckObject(IUnknown * pObj)
{
    HRESULT hr;
    bool bRet = false;
    
    CComPtr<ITIMEMediaPlayer> p;
            
    hr = THR(pObj->QueryInterface(IID_TO_PPV(ITIMEMediaPlayer, &p)));
    if (SUCCEEDED(hr))
    {
        bRet = true;
        goto done;
    }

  done:
    return bRet;
}

HRESULT
CTIMEPlayer2::InitPlayer2(CLSID clsid, IUnknown * pObj)
{
    HRESULT hr;

    Assert(!m_spPlayer);
    
    if (pObj)
    {
        hr = THR(pObj->QueryInterface(IID_ITIMEMediaPlayer,
                                      (void **) &m_spPlayer));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
CTIMEPlayer2::Init(CTIMEMediaElement *pelem,
                   LPOLESTR base,
                   LPOLESTR src,
                   LPOLESTR lpMimeType,
                   double dblClipBegin,
                   double dblClipEnd)
{
    TraceTag((tagPlayer2,
              "CTIMEPlayer2(%p)::Init)",
              this));
    
    HRESULT hr;

    if (!m_spPlayer)
    {
        hr = E_INVALIDARG;
        goto done;
    }
    
    hr = THR(CTIMEBasePlayer::Init(pelem,
                                   base,
                                   src,
                                   lpMimeType,
                                   dblClipBegin,
                                   dblClipEnd));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_spPlayer->Init(this));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(CreateContainer());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(InitPropSink());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(SetSrc(base, src));
    if (FAILED(hr))
    {
        goto done;
    }

    SetClipBegin(dblClipBegin);
    SetClipEnd(dblClipEnd);

    UpdateNaturalDur();
    
    hr = S_OK;
  done:
    if (FAILED(hr))
    {
        DetachFromHostElement();
    }
    
    RRETURN(hr);
}

HRESULT
CTIMEPlayer2::DetachFromHostElement (void)
{
    HRESULT hr = S_OK;

    TraceTag((tagPlayer2,
              "CTIMEPlayer2(%p)::DetachFromHostElement)",
              this));

    DeinitPropSink();
    
    if (m_spPlayer)
    {
        m_spPlayer->Detach();
        m_spPlayer.Release();
    }

    if(m_pSite)
    {
        m_pSite->Detach();
        m_pSite.Release();
    }
    
    return hr;
}

HRESULT
CTIMEPlayer2::CreateContainer()
{
    HRESULT hr;

    IPropertyBag2 * pPropBag = NULL;
    IErrorLog * pErrorLog = NULL;
    DAComPtr<ITIMEMediaPlayerControl> spMPCtl;
    DAComPtr<IUnknown> spCtl;
        
    Assert(m_spPlayer);
    
    hr = THR(m_spPlayer->QueryInterface(IID_ITIMEMediaPlayerControl,
                                        (void **) &spMPCtl));
    if (FAILED(hr))
    {
        if (hr == E_NOINTERFACE)
        {
            hr = S_OK;
        }
        
        goto done;
    }

    hr = THR(spMPCtl->getControl(&spCtl));
    if (FAILED(hr) || !spCtl)
    {
        if (hr == E_NOTIMPL)
        {
            hr = S_OK;
        }
        
        goto done;
    }
    
    hr = THR(m_pTIMEElementBase->GetPropBag(&pPropBag, &pErrorLog));
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = THR(CreateMPContainerSite(*this,
                                   spCtl,
                                   pPropBag,
                                   pErrorLog,
                                   false,
                                   &m_pSite));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
CTIMEPlayer2::InitPropSink()
{
    HRESULT hr;
    DAComPtr<IConnectionPoint> spCP;
    DAComPtr<IConnectionPointContainer> spCPC;
    
    Assert(m_spPlayer);
    
    hr = THR(m_spPlayer->QueryInterface(IID_IConnectionPointContainer,
                                        (void **) &spCPC));
    if (FAILED(hr))
    {
        hr = S_OK;
        goto done;
    }

    // Find the IPropertyNotifySink connection
    hr = spCPC->FindConnectionPoint(IID_IPropertyNotifySink,
                                    &spCP);
    if (FAILED(hr))
    {
        hr = S_OK;
        goto done;
    }

    hr = THR(spCP->Advise(GetUnknown(), &m_dwPropCookie));
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

void
CTIMEPlayer2::DeinitPropSink()
{
    HRESULT hr;
    DAComPtr<IConnectionPoint> spCP;
    DAComPtr<IConnectionPointContainer> spCPC;
    
    if (!m_spPlayer || !m_dwPropCookie)
    {
        goto done;
    }
    
    hr = THR(m_spPlayer->QueryInterface(IID_IConnectionPointContainer,
                                        (void **) &spCPC));
    if (FAILED(hr))
    {
        goto done;
    }

    // Find the IPropertyNotifySink connection
    hr = spCPC->FindConnectionPoint(IID_IPropertyNotifySink,
                                    &spCP);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(spCP->Unadvise(m_dwPropCookie));
    if (FAILED(hr))
    {
        goto done;
    }
    
  done:
    // Always clear the cookie
    m_dwPropCookie = 0;
    return;
}

STDMETHODIMP
CTIMEPlayer2::get_timeElement(ITIMEElement ** ppElm)
{
    HRESULT hr;

    CHECK_RETURN_SET_NULL(ppElm);

    if (!m_pTIMEElementBase)
    {
        hr = E_FAIL;
        goto done;
    }
    
    hr = THR(m_pTIMEElementBase->QueryInterface(IID_ITIMEElement,
                                                (void **) ppElm));
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMEPlayer2::get_timeState(ITIMEState ** ppState)
{
    HRESULT hr;

    CHECK_RETURN_SET_NULL(ppState);

    if (!m_pTIMEElementBase)
    {
        hr = E_FAIL;
        goto done;
    }
    
    hr = THR(m_pTIMEElementBase->base_get_currTimeState(ppState));
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMEPlayer2::reportError(HRESULT errorhr,
                          BSTR errorStr)
{
    HRESULT hr = S_OK;

    TraceTag((tagError,
              "CTIMEPlayer2(%p)::reportError(%hr, %ls)",
              errorhr,
              errorStr));

    if (!m_pTIMEElementBase)
    {
        goto done;
    }
    
    m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAPLAYERSITE_REPORTERROR);

done:
    return hr;

}

void
CTIMEPlayer2::Start()
{
    HRESULT hr;

    if (!m_spPlayer)
    {
        hr = S_OK;
        goto done;
    }
    
    if (m_pSite)
    {
        hr = THR(m_pSite->Activate());
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = THR(m_spPlayer->begin());
    if (FAILED(hr))
    {
        goto done;
    }
    m_fActive = true;
    m_fRunning = true;

    hr = S_OK;
  done:
    if (FAILED(hr))
    {
        // Indicate failure
    }
}

void
CTIMEPlayer2::Stop()
{
    if (m_spPlayer)
    {
        IGNORE_HR(m_spPlayer->end());
    }

    if (m_pSite)
    {
        IGNORE_HR(m_pSite->Deactivate());
    }
    m_fActive = false;
    m_fRunning = false;
}

void
CTIMEPlayer2::Pause()
{
    if (m_spPlayer)
    {
        IGNORE_HR(m_spPlayer->pause());
    }
    m_fRunning = false;
}

void
CTIMEPlayer2::Resume()
{
    bool bIsActive = m_pTIMEElementBase->IsActive();
    bool bIsCurrPaused = m_pTIMEElementBase->IsCurrPaused();

    if (m_spPlayer && bIsActive && !bIsCurrPaused)
    {
        IGNORE_HR(m_spPlayer->resume());
    }
    m_fRunning = true;
}

void
CTIMEPlayer2::Repeat()
{
    if (m_spPlayer)
    {
        IGNORE_HR(m_spPlayer->repeat());
    }
}

HRESULT
CTIMEPlayer2::Reset()
{
    HRESULT hr = S_OK;

    if (m_pSite)
    {
        hr = THR(m_pSite->Activate());
        if (FAILED(hr))
        {
            goto done;
        }
    }

    m_dblSyncTime = GetCurrentTime();
    if (m_spPlayer)
    {
        hr = m_spPlayer->reset();
    }
done:
    return hr;
}

HRESULT
CTIMEPlayer2::Seek(double dblTime)
{
    HRESULT hr = S_OK;

    if (m_spPlayer)
    {
        hr = m_spPlayer->seek(dblTime);
    }
    
    return hr;
}

//
//
//

void
CTIMEPlayer2::SetClipBegin(double dblClipBegin)
{
    CTIMEBasePlayer::SetClipBegin(dblClipBegin);

    if (m_spPlayer)
    {
        CComVariant v(dblClipBegin);
    
        m_spPlayer->put_clipBegin(v);
    }
} // putClipBegin

void 
CTIMEPlayer2::SetClipEnd(double dblClipEnd)
{
    CTIMEBasePlayer::SetClipEnd(dblClipEnd);

    if (m_spPlayer)
    {
        CComVariant v(dblClipEnd);
    
        m_spPlayer->put_clipEnd(v);
    }
} // putClipEnd

HRESULT
CTIMEPlayer2::SetSrc(LPOLESTR base, LPOLESTR src)
{
    HRESULT hr = S_OK;
    LPOLESTR szSrc = NULL;

    hr = THR(::TIMECombineURL(base, src, &szSrc));
    if (FAILED(hr))
    {
        goto done;
    }

    if (m_spPlayer)
    {
        hr = m_spPlayer->put_src(szSrc);
    }

done:
    delete[] szSrc;
    return hr;
}

HRESULT
CTIMEPlayer2::SetVolume(float flVolume)
{
    HRESULT hr = S_OK;
    DAComPtr<ITIMEMediaPlayerAudio> spMPAudio;

    if (m_spPlayer)
    {
        hr = THR(m_spPlayer->QueryInterface(IID_ITIMEMediaPlayerAudio,
                                            (void **) &spMPAudio));
        if (FAILED(hr))
        {
            goto done;
        }

        hr = spMPAudio->put_volume(flVolume);
    }

done:
    return hr;
}

HRESULT
CTIMEPlayer2::SetMute(VARIANT_BOOL varMute)
{
    HRESULT hr = S_OK;
    DAComPtr<ITIMEMediaPlayerAudio> spMPAudio;

    if (m_spPlayer)
    {
        hr = THR(m_spPlayer->QueryInterface(IID_ITIMEMediaPlayerAudio,
                                            (void **) &spMPAudio));
        if (FAILED(hr))
        {
            goto done;
        }

        hr = spMPAudio->put_mute(varMute);
    }

done:
    return hr;
}

//
//
//

HRESULT
CTIMEPlayer2::GetAbstract(BSTR *pAbstract)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_SET_NULL(pAbstract);
    
    if (m_spPlayer)
    {
        hr = m_spPlayer->get_abstract(pAbstract);
    }

    return hr;
}

HRESULT
CTIMEPlayer2::GetAuthor(BSTR *pAuthor)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_SET_NULL(pAuthor);
    
    if (m_spPlayer)
    {
        hr = m_spPlayer->get_author(pAuthor);
    }

    return hr;
}

HRESULT
CTIMEPlayer2::CanPause(bool &fcanPause)
{
    HRESULT hr = S_OK;
    VARIANT_BOOL v = VARIANT_FALSE;
    
    if (m_spPlayer)
    {
        hr = m_spPlayer->get_canPause(&v);
    }

    fcanPause = (v != VARIANT_FALSE);

    return hr;
}

HRESULT
CTIMEPlayer2::CanSeek(bool &fcanSeek)
{
    HRESULT hr = S_OK;
    VARIANT_BOOL v = VARIANT_FALSE;
    
    if (m_spPlayer)
    {
        hr = m_spPlayer->get_canSeek(&v);
    }

    fcanSeek = (v != VARIANT_FALSE);

    return hr;
}

HRESULT
CTIMEPlayer2::GetEffectiveLength(double &dblLength)
{
    HRESULT hr = S_OK;
    
    dblLength = TIME_INFINITE;
    
    if (m_spPlayer)
    {
        hr = m_spPlayer->get_clipDur(&dblLength);
    }

    return hr;
}

HRESULT
CTIMEPlayer2::GetCopyright(BSTR *pCopyright)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_SET_NULL(pCopyright);
    
    if (m_spPlayer)
    {
        hr = m_spPlayer->get_copyright(pCopyright);
    }

    return hr;
}

double
CTIMEPlayer2::GetCurrentTime()
{
    double dblCurrTime = GetPlayerTime();

    if (dblCurrTime == -1)
    {
        dblCurrTime = 0.0;
    }

    return dblCurrTime;
}

HRESULT
CTIMEPlayer2::GetExternalPlayerDispatch(IDispatch **ppDisp)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_SET_NULL(ppDisp);
    
    if (m_spPlayer)
    {
        hr = m_spPlayer->get_customObject(ppDisp);
    }

    return hr;
}

HRESULT
CTIMEPlayer2::HasMedia(bool &hasMedia)
{
    HRESULT hr = S_OK;
    VARIANT_BOOL v = VARIANT_FALSE;
    
    if (m_spPlayer)
    {
        hr = m_spPlayer->get_hasVisual(&v);
        if (SUCCEEDED(hr) && v == VARIANT_FALSE)
        {
            hr = m_spPlayer->get_hasAudio(&v);
        }
    }

    hasMedia = (v != VARIANT_FALSE);

    return hr;
}

HRESULT
CTIMEPlayer2::HasVisual(bool &hasVisual)
{
    HRESULT hr = S_OK;
    VARIANT_BOOL v = VARIANT_FALSE;
    
    if (m_spPlayer)
    {
        hr = m_spPlayer->get_hasVisual(&v);
    }

    hasVisual = (v != VARIANT_FALSE);

    return hr;
}

HRESULT
CTIMEPlayer2::HasAudio(bool &hasAudio)
{
    HRESULT hr = S_OK;
    VARIANT_BOOL v = VARIANT_FALSE;
    
    if (m_spPlayer)
    {
        hr = m_spPlayer->get_hasAudio(&v);
    }

    hasAudio = (v != VARIANT_FALSE);

    return hr;
}

HRESULT
CTIMEPlayer2::GetMediaLength(double &dblLength)
{
    HRESULT hr = S_OK;
    
    dblLength = TIME_INFINITE;
    
    if (m_spPlayer)
    {
        hr = m_spPlayer->get_mediaDur(&dblLength);
    }

    return hr;
}

HRESULT
CTIMEPlayer2::GetNaturalHeight(long *height)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_SET_NULL(height);
    *height = -1;
    
    if (m_spPlayer)
    {
        hr = m_spPlayer->get_mediaHeight(height);
    }

    return hr;
}

HRESULT
CTIMEPlayer2::GetNaturalWidth(long *width)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_SET_NULL(width);
    *width = -1;
    
    if (m_spPlayer)
    {
        hr = m_spPlayer->get_mediaWidth(width);
    }

    return hr;
}

HRESULT
CTIMEPlayer2::GetPlayList(ITIMEPlayList **ppPlayList)
{
    HRESULT hr = S_OK;
    
    CHECK_RETURN_SET_NULL(ppPlayList);
    
    if (m_spPlayer)
    {
        hr = m_spPlayer->get_playList(ppPlayList);
    }

    return hr;
}

HRESULT
CTIMEPlayer2::GetRating(BSTR *pRating)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_SET_NULL(pRating);
    
    if (m_spPlayer)
    {
        hr = m_spPlayer->get_rating(pRating);
    }

    return hr;
}

HRESULT
CTIMEPlayer2::GetPlaybackOffset(double &dblOffset)
{
    HRESULT hr = S_OK;
    dblOffset = 0.0;

    return hr;
}

HRESULT
CTIMEPlayer2::GetEffectiveOffset(double &dblOffset)
{
    HRESULT hr = S_OK;
    double dblPosition;

    if (m_spPlayer)
    {
        m_spPlayer->get_currTime(&dblPosition);
        dblOffset = m_pTIMEElementBase->GetMMBvr().GetSimpleTime() - dblPosition;
    }

done:
    return hr;
}

PlayerState
CTIMEPlayer2::GetState()
{
    PlayerState ps = PLAYER_STATE_INACTIVE;
    
    if (m_spPlayer)
    {
        HRESULT hr;
        TimeState ts;
    
        hr = m_spPlayer->get_state(&ts);
        if (SUCCEEDED(hr))
        {
            switch(ts)
            {
              case TS_Inactive:
                ps = PLAYER_STATE_INACTIVE;
                break;
              case TS_Active:
                ps = PLAYER_STATE_ACTIVE;
                break;
              case TS_Cueing:
                ps = PLAYER_STATE_CUEING;
                break;
              case TS_Holding:
                ps = PLAYER_STATE_HOLDING;
                break;
              case TS_Seeking:
                ps = PLAYER_STATE_SEEKING;
                break;
            }
        }
    }

    return ps;
}

HRESULT
CTIMEPlayer2::GetTitle(BSTR *pTitle)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_SET_NULL(pTitle);
    
    if (m_spPlayer)
    {
        hr = m_spPlayer->get_title(pTitle);
    }

    return hr;
}

HRESULT 
CTIMEPlayer2::GetIsStreamed(bool &bIsStreamed)
{
    HRESULT hr = S_OK;
    VARIANT_BOOL vbStreamed;
    DAComPtr<ITIMEMediaPlayerNetwork> spMPNetwork;

    if (m_spPlayer)
    {
        hr = THR(m_spPlayer->QueryInterface(IID_ITIMEMediaPlayerNetwork,
                                            (void **) &spMPNetwork));
        if (FAILED(hr))
        {
            goto done;
        }
        hr = spMPNetwork->get_isBuffered(&vbStreamed);
    }

    bIsStreamed = (vbStreamed == VARIANT_TRUE ? true : false);

done:
    return hr;
}

HRESULT 
CTIMEPlayer2::GetBufferingProgress(double &dblProgress)
{
    HRESULT hr = S_OK;
    long lProgress;
    DAComPtr<ITIMEMediaPlayerNetwork> spMPNetwork;
    
    if (m_spPlayer)
    {
        hr = THR(m_spPlayer->QueryInterface(IID_ITIMEMediaPlayerNetwork,
                                            (void **) &spMPNetwork));
        if (FAILED(hr))
        {
            goto done;
        }
        hr = spMPNetwork->get_bufferingProgress(&lProgress);
    }

    dblProgress = (double)lProgress;

done:
    return hr;
}

HRESULT
CTIMEPlayer2::GetHasDownloadProgress(bool &bHasDownloadProgress)
{
    HRESULT hr = S_OK;
    VARIANT_BOOL vbProgress;
    DAComPtr<ITIMEMediaPlayerNetwork> spMPNetwork;
    
    if (m_spPlayer)
    {
        hr = THR(m_spPlayer->QueryInterface(IID_ITIMEMediaPlayerNetwork,
                                            (void **) &spMPNetwork));
        if (FAILED(hr))
        {
            goto done;
        }
        hr = spMPNetwork->get_hasDownloadProgress(&vbProgress);
    }

    bHasDownloadProgress = (vbProgress == VARIANT_TRUE ? true : false);

done:
    return hr;
}

HRESULT 
CTIMEPlayer2::GetDownloadProgress(double &dblProgress)
{
    HRESULT hr = S_OK;
    long lProgress;
    DAComPtr<ITIMEMediaPlayerNetwork> spMPNetwork;
    
    if (m_spPlayer)
    {
        hr = THR(m_spPlayer->QueryInterface(IID_ITIMEMediaPlayerNetwork,
                                            (void **) &spMPNetwork));
        if (FAILED(hr))
        {
            goto done;
        }
        hr = spMPNetwork->get_downloadProgress(&lProgress);
    }

    dblProgress = (double)lProgress;

done:
    return hr;
}

//
//
//

double
CTIMEPlayer2::GetPlayerTime()
{
    double dblCurrTime;

    if (m_spPlayer)
    {
        HRESULT hr;
        
        hr = THR(m_spPlayer->get_currTime(&dblCurrTime));
        if (hr != S_OK)
        {
            dblCurrTime = -1;
        }
    }
    else
    {
        dblCurrTime = -1;
    }
    
    return dblCurrTime;
}

HRESULT
CTIMEPlayer2::GetCurrentSyncTime(double & dblSyncTime)
{
    HRESULT hr;
    double dblTime = GetPlayerTime();
    float flTeSpeed = 0.0;
    bool fHaveTESpeed;

    if (!m_spPlayer)
    {
        hr = S_FALSE;
        goto done;
    }

    fHaveTESpeed = m_pTIMEElementBase->GetTESpeed(flTeSpeed);
    if(fHaveTESpeed)
    {
        if(flTeSpeed < 0.0)
        {
            hr = S_FALSE;
            goto done;
        }
    }
    
    if (!m_fActive)
    {
        dblSyncTime = m_dblSyncTime;
        hr = S_OK;
        goto done;
    }

    if (dblTime == -1)
    {
        hr = S_FALSE;
        goto done;
    }
    
    dblSyncTime = dblTime;

    hr = S_OK;
  done:
    RRETURN1(hr, S_FALSE);
}

HRESULT
CTIMEPlayer2::Render(HDC hdc, LPRECT prc)
{
    TraceTag((tagPlayer2,
              "CTIMEPlayer2(%lx)::Render()",
              this));

    HRESULT hr = S_OK;
    int iPrevMode = 0;
    bool bIsOn = m_pTIMEElementBase->IsOn();
    bool bHasVisual = true;
    
    hr = THR(HasVisual(bHasVisual));
    if (SUCCEEDED(hr) && !bHasVisual)
    {
        hr = S_OK;
        goto done;
    }
    
    if (!bIsOn)
    {
        hr = S_OK;
        goto done;
    }
    
    if (!m_pSite)
    {
        hr = S_OK;
        goto done;
    }
    
    iPrevMode = SetStretchBltMode(hdc, COLORONCOLOR);
    if (0 == iPrevMode)
    {
        hr = E_FAIL;
        goto done;
    }


    hr = THR(m_pSite->Draw(hdc, prc));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    if (0 != iPrevMode)
    {
        SetStretchBltMode(hdc, iPrevMode);
    }
    
    return hr;
}

HRESULT 
CTIMEPlayer2::SetSize(RECT *prect)
{
    HRESULT hr;
    
    if (!m_pSite)
    {
        hr = S_OK;
        goto done;
    }
    
    m_pSite->SetSize(prect);

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
CTIMEPlayer2::IsBroadcast(bool &bisBroad)
{
    HRESULT hr = S_OK;

    hr = CanPause(bisBroad);
    if (FAILED(hr))
    {
        goto done;
    }

    bisBroad = !bisBroad;

done:
    return hr;
}

void
CTIMEPlayer2::PropChangeNotify(DWORD tePropType)
{
    HRESULT hr = S_OK;
    double dblSyncTime;
    double dblSyncTol;
    bool bIsActive;
    double dblSimpleTime;

    if (!m_pTIMEElementBase)
    {
        goto done;
    }

    dblSyncTol = m_pTIMEElementBase->GetRealSyncTolerance();
    bIsActive = m_pTIMEElementBase->IsActive();
    dblSimpleTime = m_pTIMEElementBase->GetMMBvr().GetSimpleTime();

    CTIMEBasePlayer::PropChangeNotify(tePropType);
    
    if ((tePropType & TE_PROPERTY_TIME) != 0)
    {
        if (bIsActive && !m_fIsOutOfSync)
        {   
            if(m_spPlayer)
            {
                hr = m_spPlayer->get_currTime(&dblSyncTime);
                if(FAILED(hr))
                {
                    goto done;
                }
                TraceTag((tagPlayer2,
                          "CTIMEPlayer2(%lx)::PropChangeNotify(%g - %g):TE_PROPERTY_TIME",
                          this, dblSimpleTime, dblSyncTime));
                if (dblSyncTime != TIME_INFINITE)
                {
                    dblSyncTime -= m_dblClipStart;
                    if(fabs(dblSyncTime - dblSimpleTime) > dblSyncTol)
                    {
                        if(dblSyncTime < dblSimpleTime)
                        {
                            if(!m_fIsOutOfSync && m_fRunning)
                            {
                                m_fIsOutOfSync = true;
                                m_pTIMEElementBase->FireMediaEvent(PE_ONMEDIASLIPSLOW);
                                m_syncType = sync_slow;
                            }
                        }
                        else
                        {
                            if(!m_fIsOutOfSync)
                            {
                                m_fIsOutOfSync = true;
                                m_pTIMEElementBase->FireMediaEvent(PE_ONMEDIASLIPFAST);
                                m_syncType = sync_fast;
                            }
                        }
                    }
                    else
                    {
                        if(m_fIsOutOfSync)
                        {
                            m_fIsOutOfSync = false;
                            m_syncType = sync_none;

                        }
                    }
                }
            }
        }

    }
done:
    return;
}

void 
CTIMEPlayer2::ReadyStateNotify(LPWSTR szReadyState)
{
    // TODO: Need to fill this in
    return;
}

HRESULT
CTIMEPlayer2::HasPlayList(bool &fhasPlayList)
{
    HRESULT hr = S_OK;
    CComPtr<ITIMEPlayList> spPlayList;

    fhasPlayList = false;

    if (m_spPlayer)
    {
        hr = m_spPlayer->get_playList(&spPlayList);
        if (SUCCEEDED(hr) && spPlayList.p)
        {
            fhasPlayList = TRUE;
        }
    }

    return hr;
}


bool 
CTIMEPlayer2::UpdateSync()
{
    HRESULT hr = S_OK;
    double dblSyncTime;
    double dblSyncTol = m_pTIMEElementBase->GetRealSyncTolerance();
    bool bIsActive = m_pTIMEElementBase->IsActive();
    double dblSimpleTime = m_pTIMEElementBase->GetMMBvr().GetSimpleTime();
    bool fRet = true;
    TraceTag((tagPlayer2,
              "CTIMEPlayer(%lx)::UpdateSync()",
              this));

    if(!m_spPlayer)
    {
        goto done;
    }

    hr = m_spPlayer->get_currTime(&dblSyncTime);
    if(FAILED(hr))
    {
        goto done;
    }

    if (dblSyncTime == TIME_INFINITE)
    {
        goto done;
    }
    
    dblSyncTime -= m_dblClipStart;
    switch(m_syncType)
    {
        case sync_slow:
            TraceTag((tagPlayer2,
                      "CTIMEPlayer2(%lx)::UpdateSync()slow",
                      this));
            if(!bIsActive)
            {
                m_fIsOutOfSync = false;
                fRet = true;
            }
            else if(fabs(dblSyncTime - dblSimpleTime) <= dblSyncTol / 2.0 || (dblSyncTime > dblSimpleTime + dblSyncTol / 2.0))
            {
                m_fIsOutOfSync = false;
                fRet = true;
            }
            else
            {
                fRet = false;
            }
            break;
        case sync_fast:
            if(!bIsActive)
            {
                m_fIsOutOfSync = false;
                fRet = true;
            }
            else if((fabs(dblSyncTime - dblSimpleTime) <= dblSyncTol / 2.0) || (dblSimpleTime > dblSyncTime + dblSyncTol / 2.0))
            {
                m_fIsOutOfSync = false;
                fRet = true;
            }
            else
            {
                fRet = false;
            }
            break;
        default:
            break;
    }
done:
    return fRet;
}

//
// CContainerSiteHost
//

HRESULT
CTIMEPlayer2::GetContainerSize(LPRECT prcPos)
{
    HRESULT hr = S_OK;

    if (m_pTIMEElementBase)
    {
        hr = THR(m_pTIMEElementBase->GetSize(prcPos));
    }

    return hr;
}

HRESULT
CTIMEPlayer2::SetContainerSize(LPCRECT prcPos)
{
    HRESULT hr = S_OK;

    if (m_pTIMEElementBase)
    {
        hr = THR(m_pTIMEElementBase->SetSize(prcPos));
    }

    return hr;
}

HRESULT
CTIMEPlayer2::ProcessEvent(DISPID dispid,
                            long lCount, 
                            VARIANT varParams[])
{
    TraceTag((tagPlayer2, "CTIMEPlayer2::ProcessEvent(%lx)",this));

    HRESULT hr = S_OK;
#if 0
    if (NULL == m_pPlayer)
    {
        hr = E_NOTIMPL;
        goto done;
    }
    
    switch (dispid)
    {
      case DISPID_TIMEMEDIAPLAYEREVENTS_ONMEDIALOADFAILED:
        m_pPlayer->FireMediaEvent(PE_ONMEDIAERROR);
        break;

      case DISPID_TIMEMEDIAPLAYEREVENTS_ONMEDIAREADY:

        SetMediaReadyFlag();
        ClearAutosizeFlag();
                
        //make the element visible here.
        if (m_setVisible)
        {
            SetVisibility(true);
        }

        if (m_bFirstOnMediaReady)
        {
            m_bFirstOnMediaReady = false;
                
            // This must happen before we set natural duration
            // since we detect playlist during this call
            m_pPlayer->FireMediaEvent(PE_ONMEDIACOMPLETE);
                    
            m_pPlayer->ClearNaturalDuration();

            UpdateNaturalDur(false);

            // if this is not a playlist, attempt to set the natural duration

            if (m_lActiveLoadedTrack != NOTRACKSELECTED)
            {
                if (m_pPlayer->GetPlayList())
                {
                    CComVariant vIndex(m_lActiveLoadedTrack);
                        
                    IGNORE_HR(m_pPlayer->GetPlayList()->put_activeTrack(vIndex));
                }

                m_lActiveLoadedTrack = NOTRACKSELECTED;
            }

            if (m_bStartOnLoad)
            {
                m_bStartOnLoad = false;
                Start();
            }

            if (m_bEndOnPlay)
            {
                Stop();
                m_bEndOnPlay = false;
            }
            if (m_bPauseOnPlay)
            {
                THR(m_pProxyPlayer->pause());
                m_bPauseOnPlay = false;
            }

            if (m_bSeekOnPlay)
            {
                IGNORE_HR(Seek(m_dblSeekTime));
                m_pPlayer->InvalidateElement(NULL);
                m_bSeekOnPlay = false;
            }

        }
        else
        {
            CPlayItem *pPlayItem = NULL;
                
            if (m_bPauseOnPlay)
            {
                hr = THR(m_pProxyPlayer->pause());
                if (FAILED(hr))
                {
                    TraceTag((tagError, "Pause failed"));
                }
                m_bPauseOnPlay = false;
            }

            if (m_pPlayer->GetPlayList())
            {
                //load the current info into the selected playitem.
                pPlayItem = m_pPlayer->GetPlayList()->GetActiveTrack();
                SetMediaInfo(pPlayItem);
            }

            //need notification here.
            m_pPlayer->FireMediaEvent(PE_ONMEDIATRACKCHANGED);
        }

        SetDuration();
        break;

      case DISPID_TIMEMEDIAPLAYEREVENTS_ONBEGIN:
        m_bActive = true;
        break;

      case DISPID_TIMEMEDIAPLAYEREVENTS_ONEND:
        m_bActive = false;

        //need notification here.
        m_pPlayer->FireMediaEvent(PE_ONMEDIATRACKCHANGED);

        if (m_bFirstOnMediaReady || UsingPlaylist())
        {
            UpdateNaturalDur(true);
        }
            
        if(m_pPlayer != NULL)
        {
            m_pPlayer->SetHoldingFlag();
        }

        break;

#define DISPID_SCRIPTCOMMAND 3001
      case DISPID_SCRIPTCOMMAND:
        // HACKHACK
        // Pick off the script command from WMP and repackage the event as our own.
        // This allows triggers to work.  The real fix is to add another event on
        // TIMEMediaPlayerEvents.
        if (m_fUsingWMP && lCount == 2) 
        {
            static LPWSTR pNames[] = {L"Param", L"scType"};
            hr = m_pPlayer->FireEvents(TE_ONSCRIPTCOMMAND, 
                                       lCount, 
                                       pNames, 
                                       varParams);
        }
        break;
      default:
        hr = E_NOTIMPL;
        goto done;
    }
#endif
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
CTIMEPlayer2::GetExtendedControl(IDispatch **ppDisp)
{
    CHECK_RETURN_SET_NULL(ppDisp);

    return E_NOTIMPL;
}

HRESULT
CTIMEPlayer2::NegotiateSize(RECT &nativeSize,
                            RECT &finalSize,
                            bool &fIsNative)
{
    HRESULT hr = S_OK;
    CComPtr<ITIMEPlayList> spPlayList;
    bool fResetSize = false;

    if (m_spPlayer)
    {
        hr = m_spPlayer->get_playList(&spPlayList);
        if (SUCCEEDED(hr))
        {
            if (spPlayList != NULL)
            {
                fResetSize = true;
            }
        }
    }

    if (m_pTIMEElementBase)
    {
        hr = THR(m_pTIMEElementBase->NegotiateSize(nativeSize,
                                                   finalSize,
                                                   fIsNative, fResetSize));
    }

    return hr;
}

//
// IServiceProvider interfaces
//
STDMETHODIMP
CTIMEPlayer2::QueryService(REFGUID guidService,
                           REFIID riid,
                           void** ppv)
{
    CHECK_RETURN_SET_NULL(ppv);
    
    // Just delegate to our service provider
    HRESULT hr;
    IServiceProvider * sp = GetServiceProvider();

    if (!sp)
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    hr = THR(sp->QueryService(guidService,
                              riid,
                              ppv));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

//
// IPropertyNotifySink methods
//

STDMETHODIMP
CTIMEPlayer2::OnRequestEdit(DISPID dispID)
{
    return S_OK;
}

STDMETHODIMP
CTIMEPlayer2::OnChanged(DISPID dispID)
{
    if (!m_pTIMEElementBase)
    {
        goto done;
    }
    
    switch(dispID)
    {
      case DISPID_TIMEMEDIAPLAYER_ABSTRACT:
        m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_ABSTRACT);
        break;
      case DISPID_TIMEMEDIAPLAYER_AUTHOR:
        m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_AUTHOR);
        break;
      case DISPID_TIMEMEDIAPLAYER_CANPAUSE:
        m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_CANPAUSE);
        break;
      case DISPID_TIMEMEDIAPLAYER_CANSEEK:
        m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_CANSEEK);
        break;
      case DISPID_TIMEMEDIAPLAYER_CLIPDUR:
        UpdateNaturalDur();
        break;
      case DISPID_TIMEMEDIAPLAYER_COPYRIGHT:
        m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_COPYRIGHT);
        break;
      case DISPID_TIMEMEDIAPLAYER_CURRTIME:
        // m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_CURRTIME);
        break;
      case DISPID_TIMEMEDIAPLAYER_CUSTOM_OBJECT:
        m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_PLAYEROBJECT);
        break;
      case DISPID_TIMEMEDIAPLAYER_HASAUDIO:
        m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_HASAUDIO);
        break;
      case DISPID_TIMEMEDIAPLAYER_HASVISUAL:
        m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_HASVISUAL);
        break;
      case DISPID_TIMEMEDIAPLAYER_MEDIADUR:
        UpdateNaturalDur();
        m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_MEDIADUR);
        break;
      case DISPID_TIMEMEDIAPLAYER_MEDIAHEIGHT:
        m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_MEDIAHEIGHT);
        break;
      case DISPID_TIMEMEDIAPLAYER_MEDIAWIDTH:
        m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_MEDIAWIDTH);
        break;
      case DISPID_TIMEMEDIAPLAYER_PLAYLIST:
        m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_PLAYLIST);
        break;
      case DISPID_TIMEMEDIAPLAYER_RATING:
        m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_RATING);
        break;
      case DISPID_TIMEMEDIAPLAYER_SRC:
        m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAPLAYER_SRC);
        break;
      case DISPID_TIMEMEDIAPLAYER_STATE:
        m_pTIMEElementBase->NotifyTimeStateChange(DISPID_TIMESTATE_STATE);
        m_pTIMEElementBase->NotifyTimeStateChange(DISPID_TIMESTATE_STATESTRING);
        break;
      case DISPID_TIMEMEDIAPLAYER_TITLE:
        m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_TITLE);
        break;
      case DISPID_TIMEPLAYLIST_ACTIVETRACK:
        m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEPLAYLIST_ACTIVETRACK);
        break;
      case DISPID_TIMEMEDIAPLAYERSITE_REPORTERROR:
        reportError(S_FALSE, L"Media Load Failed");
        break;
    }

  done:
    return S_OK;
}

void
CTIMEPlayer2::UpdateNaturalDur()
{
    HRESULT hr;
    double dblMediaLength = TIME_INFINITE;
    
    if (!m_pTIMEElementBase)
    {
        goto done;
    }
    
    m_pTIMEElementBase->ClearNaturalDuration();
    
    if (m_spPlayer)
    {
        hr = m_spPlayer->get_clipDur(&dblMediaLength);
        if (FAILED(hr))
        {
            goto done;
        }
    }

    if (dblMediaLength <= 0.0 || dblMediaLength == TIME_INFINITE)
    {
        goto done;
    }
    
    IGNORE_HR(m_pTIMEElementBase->PutNaturalDuration(dblMediaLength));

  done:
    return;
}

HRESULT
CreateTIMEPlayer2(CLSID clsid,
                  IUnknown * pObj,
                  CTIMEPlayer2 ** ppPlayer2)
{
    CHECK_RETURN_SET_NULL(ppPlayer2);
    
    HRESULT hr;
    CComObject<CTIMEPlayer2> *pNew;
    CComObject<CTIMEPlayer2>::CreateInstance(&pNew);

    if (!pNew)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = THR(pNew->InitPlayer2(clsid, pObj));
        if (SUCCEEDED(hr))
        {
            pNew->AddRef();
            *ppPlayer2 = pNew;
        }
    }

    if (FAILED(hr))
    {
        delete pNew;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\playercd.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: player.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _PLAYERDSHOWCD_H
#define _PLAYERDSHOWCD_H

#include "playerdshowbase.h"
#include "mixerocx.h"
#include <strmif.h>
#include <control.h>
#include <inc\qnetwork.h>
#include "dshowcdproxy.h"

#include "importman.h"

#define MP_INFINITY -1

/////////////////////////////////////////////////////////////////////////////
// CTTIMEPlayer

class CTIMEDshowCDPlayer :
    public CTIMEDshowBasePlayer,
    public ITIMEImportMedia,
    public ITIMEInternalEventSink,
    public IMixerOCXNotify
{
  public:
    CTIMEDshowCDPlayer(CTIMEDshowCDPlayerProxy * pProxy);
    virtual ~CTIMEDshowCDPlayer();

    HRESULT Init(CTIMEMediaElement *pelem,
                 LPOLESTR base,
                 LPOLESTR src,
                 LPOLESTR lpMimeType = NULL,
                 double dblClipBegin = -1.0,
                 double dblClipEnd = -1.0);//lint !e1735

  protected:
    HRESULT InitDshow();
    HRESULT InitElementSize();
    void DeinitDshow();
    HRESULT BuildGraph();
    HRESULT GetSpecificInterfaces();
    void ReleaseSpecificInterfaces();
    void FreeSpecificData();

    HRESULT BeginDownload();
    HRESULT GraphFinish();

    HRESULT ReadContentProperty(IGraphBuilder *pGraph, LPCWSTR lpcwstrTag, BSTR *pbstr);

    virtual void Block();
    virtual void UnBlock();
    virtual bool CanCallThrough();
    virtual bool FireProxyEvent(PLAYER_EVENT plEvent);

  public:
    HRESULT DetachFromHostElement (void);

    // IUnknown Methods
    STDMETHOD (QueryInterface)(REFIID refiid, void** ppunk)
        {   return _InternalQueryInterface(refiid, ppunk); };
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);

    virtual void OnTick(double dblSegmentTime,
                        LONG lCurrRepeatCount);

    HRESULT Reset();
    HRESULT Render(HDC hdc, LPRECT prc);

    HRESULT SetSrc(LPOLESTR base, LPOLESTR src);

    HRESULT SetSize(RECT *prect);

    HRESULT GetMediaLength(double &dblLength);
    HRESULT CanSeek(bool &fcanSeek);
    virtual PlayerState GetState();
    virtual HRESULT CanSeekToMarkers(bool &bacnSeekToM);
    virtual HRESULT IsBroadcast(bool &bisBroad);
    virtual HRESULT SetRate(double dblRate);
    virtual HRESULT GetRate(double &dblRate);
    virtual HRESULT HasMedia(bool &fHasMedia);
    virtual HRESULT HasVisual(bool &fHasVideo);
    virtual HRESULT HasAudio(bool &fHasAudio);

    HRESULT GetNaturalHeight(long *height);
    HRESULT GetNaturalWidth(long *width);

    virtual HRESULT GetAuthor(BSTR *pAuthor);
    virtual HRESULT GetTitle(BSTR *pTitle);
    virtual HRESULT GetCopyright(BSTR *pCopyright);
    virtual HRESULT GetAbstract(BSTR *pAbstract);
    virtual HRESULT GetRating(BSTR *pAbstract);

    virtual HRESULT GetIsStreamed(bool &fIsStreamed);
    virtual HRESULT GetBufferingProgress(double &dblBufferingProgress);
    virtual HRESULT GetHasDownloadProgress(bool &fHasDownloadProgress);
    virtual HRESULT GetMimeType(BSTR *pMime);

    BEGIN_COM_MAP(CTIMEDshowCDPlayer)
        COM_INTERFACE_ENTRY(ITIMEImportMedia)
        COM_INTERFACE_ENTRY_CHAIN(CTIMEDshowBasePlayer)
    END_COM_MAP_X();

    //
    // ITIMEImportMedia methods
    //
    STDMETHOD(CueMedia)();
    STDMETHOD(GetPriority)(double *);
    STDMETHOD(GetUniqueID)(long *);
    STDMETHOD(InitializeElementAfterDownload)();
    STDMETHOD(GetMediaDownloader)(ITIMEMediaDownloader ** ppImportMedia);
    STDMETHOD(PutMediaDownloader)(ITIMEMediaDownloader * pImportMedia);
    STDMETHOD(CanBeCued)(VARIANT_BOOL * pVB_CanCue);
    STDMETHOD(MediaDownloadError)();

    //
    // ITIMEInternalEventSink
    //
    STDMETHOD(InternalEvent)();
    
  protected:
    long    m_lSrc;
    bool m_fHasVideo;
    bool m_fDoneSetup;
    double m_dblSeekAtStart;
    bool m_fLoadError;
    bool m_fHasMedia;
    bool m_fRemoved;
    double m_dblMediaDur;

  private:

    // IMixerOCXNotify methods
    STDMETHOD(OnInvalidateRect)(LPCRECT lpcRect);
    STDMETHOD(OnStatusChange)(ULONG ulStatusFlags);
    STDMETHOD(OnDataChange)(ULONG ulDataFlags);

    void GraphStart(void);

    bool IsOvMConnected(IBaseFilter *pOvM);

    void SetStreamFlags(LPOLESTR src);
    HRESULT DisableAudioVideo();

    CComPtr<IBaseFilter> m_pCD;

    LPSTREAM                    m_pTIMEMediaPlayerStream;

    bool m_fUsingInterfaces;
    bool m_fNeedToDeleteInterfaces;

    bool m_fCanCueNow;
    
    bool m_fHavePriority;
    double m_dblPriority;
    HRESULT m_hrRenderFileReturn;

    CTIMEDshowCDPlayerProxy * m_pProxy;
    CritSect                m_CriticalSection;


    
  private:
    CTIMEDshowCDPlayer();
};

#endif /* _PLAYERDSHOW_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\playerbase.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: player.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "playerbase.h"
#include "decibels.h"
#include "mediaelm.h"


CTIMEBasePlayer::CTIMEBasePlayer() :
    m_pTIMEElementBase(NULL),
    m_dblPriority(INFINITE),
    m_fHavePriority(false),
    m_dblClipStart(valueNotSet),
    m_dblClipEnd(valueNotSet),
    m_lClipStartFrame(valueNotSet),
    m_lClipEndFrame(valueNotSet),
    m_pAtomTable(NULL),
    m_pPlaybackSite(NULL)
{
    ;
}

CTIMEBasePlayer::~CTIMEBasePlayer()
{
    if (m_pAtomTable)
    {
        ReleaseInterface(m_pAtomTable);
    }
    m_pTIMEElementBase = NULL;
}

HRESULT
CTIMEBasePlayer::Init(CTIMEMediaElement *pelem,
                      LPOLESTR base,
                      LPOLESTR src,
                      LPOLESTR lpMimeType,
                      double dblClipBegin,
                      double dblClipEnd)
{
    HRESULT hr = S_OK;

    m_pTIMEElementBase = pelem;

    if (pelem)
    {
        Assert(NULL == m_pAtomTable);
        m_pAtomTable = pelem->GetAtomTable();
        if (m_pAtomTable)
        {
            m_pAtomTable->AddRef();
        }
    }

    hr = S_OK;
done:
    return hr;
}

HRESULT
CTIMEBasePlayer::GetAuthor(BSTR *pAuthor)
{
    pAuthor = NULL;
    return S_OK;
} //lint !e550

HRESULT
CTIMEBasePlayer::GetTitle(BSTR *pTitle)
{
    pTitle = NULL;
    return S_OK;
} //lint !e550

HRESULT
CTIMEBasePlayer::GetCopyright(BSTR *pCopyright)
{
    pCopyright = NULL;
    return S_OK;
} //lint !e550

HRESULT
CTIMEBasePlayer::GetAbstract(BSTR *pAbstract)
{
    pAbstract = NULL;
    return S_OK;
} //lint !e550

HRESULT
CTIMEBasePlayer::GetRating(BSTR *pRating)
{
    pRating = NULL;
    return S_OK;
} //lint !e550

HRESULT
CTIMEBasePlayer::GetVolume(float *flVolume)
{
    return E_NOTIMPL;
}

HRESULT
CTIMEBasePlayer::SetVolume(float flVolume)
{
    return E_NOTIMPL;
}

#ifdef NEVER //dorinung 03-16-2000 bug 106458
HRESULT
CTIMEBasePlayer::GetBalance(float *flBal)
{
    return E_NOTIMPL;
}

HRESULT
CTIMEBasePlayer::SetBalance(float flBal)
{
    return E_NOTIMPL;
}
#endif

HRESULT
CTIMEBasePlayer::GetMute(VARIANT_BOOL *varMute)
{
    return E_NOTIMPL;
}

HRESULT
CTIMEBasePlayer::SetMute(VARIANT_BOOL varMute)
{
    return E_NOTIMPL;
}

HRESULT
CTIMEBasePlayer::GetPlayList(ITIMEPlayList **ppPlayList)
{
    return E_NOTIMPL;
}

HRESULT 
CTIMEBasePlayer::SetActiveTrack(long index)
{
    return E_NOTIMPL;
}

HRESULT 
CTIMEBasePlayer::GetActiveTrack(long *index)
{
    return E_NOTIMPL;
}

HRESULT 
CTIMEBasePlayer::GetNaturalHeight(long *height)
{
    return E_NOTIMPL;
}

HRESULT 
CTIMEBasePlayer::GetNaturalWidth(long *width)
{
    return E_NOTIMPL;
}


HRESULT 
CTIMEBasePlayer::onMouseDown(long x, long y)
{
    return E_NOTIMPL;
}

HRESULT 
CTIMEBasePlayer::onMouseMove(long x, long y)
{
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CppDsPlay
//
//
// BalanceLogToLin
//
// Balance has the same range as the volume but is signed (ie range is twice
// as big). In our conversions we can use the VolumeLogToLin/LinToLog methods
// but need to scale the returned values by half.
//
float
CTIMEBasePlayer::BalanceLogToLin(long LogValue)
{
    float LinKnobValue;

    if (LogValue > 0 )
    {
        //
        // - need to invert the LogValue for VolumeLogToLin
        // - scale the value by 1/2 because of doubly sized range
        // - offset the value at the middle MIN_VOLUME_RANGE to MAX_VOLUME_RANGE
        //
        LinKnobValue = MAX_VOLUME_RANGE - (VolumeLogToLin(-LogValue) - MIN_VOLUME_RANGE) / 2.0 + MIN_VOLUME_RANGE;
    }
    else
    {
        LinKnobValue = (VolumeLogToLin(LogValue) - MIN_VOLUME_RANGE) / 2.0 + MIN_VOLUME_RANGE;
    }
    return LinKnobValue;
}

/////////////////////////////////////////////////////////////////////////////
// CppDsPlay
//
// BalanceLinToLog
//
long
CTIMEBasePlayer::BalanceLinToLog(float LinKnobValue)
{
    long LogValue;

    // In which half is the value?
    if (LinKnobValue > (MIN_VOLUME_RANGE + MAX_VOLUME_RANGE) / 2)
    {
        // upper half
        //
        // - invert LogValue for VolumeLinToLog
        // - remove offset (which is at middle of knob range) and scale by 2
        // - add MIN_VOLUME_RANGE offset
        LogValue = - VolumeLinToLog(
            ((MAX_VOLUME_RANGE - MIN_VOLUME_RANGE) -
            (LinKnobValue - (MIN_VOLUME_RANGE + MAX_VOLUME_RANGE) / 2) * 2 +
            MIN_VOLUME_RANGE)); //lint !e736 !e747
    }
    else
    {
        // lower half
        LogValue = VolumeLinToLog(
            ((LinKnobValue - MIN_VOLUME_RANGE) * 2 + MIN_VOLUME_RANGE)); //lint !e736 !e747
    }

    return LogValue;
}
//
// VolumeLinToLog
//
// Map linear value (MIN_VOLUME_RANGE - MAX_VOLUME_RANGE) to
// logarithmic values (AX_MIN_VOLUME - AX_MAX_VOLUME)
long
CTIMEBasePlayer::VolumeLinToLog(float LinKnobValue)
{
    long lLinMin = DBToAmpFactor(AX_MIN_VOLUME);
    long lLinMax = DBToAmpFactor(AX_MAX_VOLUME);

    long lLinTemp = (LinKnobValue - MIN_VOLUME_RANGE) * (lLinMax - lLinMin)
        / (MAX_VOLUME_RANGE - MIN_VOLUME_RANGE) + lLinMin; //lint !e524

    long LogValue = AmpFactorToDB(lLinTemp );
    return LogValue;
}

//
// VolumeLogToLin
//
// Map logarithmic values (AX_MIN_VOLUME - AX_MAX_VOLUME) to
// linear value (MIN_VOLUME_RANGE - MAX_VOLUME_RANGE)
//
float
CTIMEBasePlayer::VolumeLogToLin(long LogValue)
{
    long lLinMin = DBToAmpFactor(AX_MIN_VOLUME);
    long lLinMax = DBToAmpFactor(AX_MAX_VOLUME);

    float LinKnobValue = (((LONG) DBToAmpFactor(LogValue) - lLinMin) *
        (MAX_VOLUME_RANGE - MIN_VOLUME_RANGE) / (lLinMax - lLinMin) + MIN_VOLUME_RANGE); //lint !e736

    return LinKnobValue;
}

PlayerState
CTIMEBasePlayer::GetState()
{
    return PLAYER_STATE_UNKNOWN;
}

HRESULT
CTIMEBasePlayer::Reset()
{
    HRESULT hr = S_OK;
    return hr;
}

bool
CTIMEBasePlayer::UpdateSync()
{
    return true;
}

void
CTIMEBasePlayer::Tick()
{
    return;
}

HRESULT
CTIMEBasePlayer::InitElementSize()
{
    return S_OK;
}

HRESULT
CTIMEBasePlayer::CanSeekToMarkers(bool &bcanSeekToM)
{
    bcanSeekToM = false;
    return S_OK;
}


HRESULT
CTIMEBasePlayer::CanPause(bool &bcanPause)
{
    bcanPause = true;
    return S_OK;
}

HRESULT
CTIMEBasePlayer::HasPlayList(bool &fhasPlayList)
{
    fhasPlayList = false;
    return S_OK;
}

HRESULT
CTIMEBasePlayer::IsBroadcast(bool &bisBroad)
{
    bisBroad = false;
    return S_OK;
}

HRESULT
CTIMEBasePlayer::HasMedia(bool &bHasMedia)
{
    bHasMedia = false;
    return S_FALSE;
}

HRESULT
CTIMEBasePlayer::HasVisual(bool &bHasVideo)
{
    bHasVideo = false;
    return S_FALSE;
}

HRESULT
CTIMEBasePlayer::HasAudio(bool &bHasAudio)
{
    bHasAudio = false;
    return S_FALSE;
}

double
CTIMEBasePlayer::GetClipBegin()
{
    double dblClipBegin;

    if(m_dblClipStart != valueNotSet)
    {
        dblClipBegin = m_dblClipStart;
    }
    else
    {
        dblClipBegin = 0.0;
    }

    return dblClipBegin;
}

void 
CTIMEBasePlayer::GetClipBegin(double &dblClipBegin)
{

    if(m_dblClipStart != valueNotSet)
    {
        dblClipBegin = m_dblClipStart;
    }
    else
    {
        dblClipBegin = 0.0;
    }

} // getClipBegin

void
CTIMEBasePlayer::SetClipBegin(double dblClipBegin)
{
    if (dblClipBegin < 0.0)
    {
        dblClipBegin = 0.0;
    }
    
    m_dblClipStart = dblClipBegin;
} // putClipBegin

void
CTIMEBasePlayer::GetClipEnd(double &dblClipEnd)
{
    dblClipEnd = m_dblClipEnd;

} // getClipEnd

void 
CTIMEBasePlayer::SetClipEnd(double dblClipEnd)
{
    if (dblClipEnd < 0.0)
    {
        dblClipEnd = -1;
    }
    
    m_dblClipEnd = dblClipEnd;

    return;
} // putClipEnd

void 
CTIMEBasePlayer::GetClipBeginFrame(long &lClipBegin)
{

    lClipBegin = m_lClipStartFrame;

} // getClipBegin

void
CTIMEBasePlayer::SetClipBeginFrame(long lClipBegin)
{
    if (lClipBegin < 0)
    {
        lClipBegin = 0.0;
    }
    
    m_lClipStartFrame = lClipBegin;
} // putClipBegin

void
CTIMEBasePlayer::GetClipEndFrame(long &lClipEnd)
{
    lClipEnd = m_lClipEndFrame;

} // getClipEnd

void 
CTIMEBasePlayer::SetClipEndFrame(long lClipEnd)
{
    if (lClipEnd < 0.0)
    {
        lClipEnd = -1;
    }
    
    m_lClipEndFrame = lClipEnd;

    return;
} // putClipEnd

HRESULT
CTIMEBasePlayer::GetRate(double &dblRate)
{
    HRESULT hr = E_NOTIMPL;

    dblRate = -1.0;
    return hr;
}


HRESULT
CTIMEBasePlayer::SetRate(double dblRate)
{
    HRESULT hr = E_NOTIMPL;
    return hr;
}

HRESULT
CTIMEBasePlayer::Save(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    HRESULT hr = S_OK;
    return hr;
}

void
CTIMEBasePlayer::PropChangeNotify(DWORD tePropType)
{
    if (m_pTIMEElementBase == NULL)
    {
        goto done;
    }

    if ((tePropType & TE_PROPERTY_ISON) != 0)
    {
        m_pTIMEElementBase->InvalidateElement(NULL);
    }

  done:
    return;
}

void 
CTIMEBasePlayer::ReadyStateNotify(LPWSTR szReadyState)
{
    return; //E_NOTIMPL;
}


HRESULT
CTIMEBasePlayer::GetEffectiveLength(double &dblLength)
{
    HRESULT hr;

    hr = GetMediaLength(dblLength);
    if(FAILED(hr))
    {
        goto done;
    }

    if(m_dblClipEnd != valueNotSet)
    {
        dblLength = m_dblClipEnd;
    }
    if(m_dblClipStart != valueNotSet)
    {
        dblLength -= m_dblClipStart;
    }
    
done:
    return hr;
}

bool
CTIMEBasePlayer::IsActive() const
{
    bool bRet = false;

    if (m_pTIMEElementBase)
    {
        bRet = m_pTIMEElementBase->IsActive();
    }

    return bRet;
}


bool
CTIMEBasePlayer::IsPaused() const
{
    bool bRet = false;

    if (m_pTIMEElementBase)
    {
        bRet = m_pTIMEElementBase->IsPaused();
    }

    return bRet;
}

bool
CTIMEBasePlayer::IsParentPaused() const
{
    bool bRet = false;

    if (m_pTIMEElementBase && m_pTIMEElementBase->GetParent())
    {
        bRet = m_pTIMEElementBase->GetParent()->IsPaused();
    }

    return bRet;
}

IHTMLElement *
CTIMEBasePlayer::GetElement()
{
    IHTMLElement * pRet = NULL;

    if (m_pTIMEElementBase)
    {
        pRet = m_pTIMEElementBase->GetElement();
    }

    return pRet;
}

IServiceProvider *
CTIMEBasePlayer::GetServiceProvider()
{
    IServiceProvider * pRet = NULL;

    if (m_pTIMEElementBase)
    {
        pRet = m_pTIMEElementBase->GetServiceProvider();
    }

    return pRet;
}

void
CTIMEBasePlayer::InvalidateElement(LPCRECT lprect)
{
    if (m_pTIMEElementBase)
    {
        m_pTIMEElementBase->InvalidateElement(lprect);
    }
}

void
CTIMEBasePlayer::PutNaturalDuration(double dblNatDur)
{
    if (m_pTIMEElementBase)
    {
        m_pTIMEElementBase->PutNaturalDuration(dblNatDur);
    }
}

void
CTIMEBasePlayer::ClearNaturalDuration()
{
    if (m_pTIMEElementBase)
    {
        m_pTIMEElementBase->ClearNaturalDuration();
    }
}

void
CTIMEBasePlayer::LoadFailNotify(PLAYER_EVENT reason)
{
    return;
}
double
CTIMEBasePlayer::GetElapsedTime() const
{
    double dblRet = 0.0;

    if (m_pTIMEElementBase)
    {
        dblRet = m_pTIMEElementBase->GetTESimpleTime();
    }

    return dblRet;
}

HRESULT
CTIMEBasePlayer::GetEarliestMediaTime(double &dblEarliestMediaTime)
{
    HRESULT hr = E_NOTIMPL;

    dblEarliestMediaTime = -1.0;
    return hr;
}


HRESULT
CTIMEBasePlayer::GetLatestMediaTime(double &dblLatestMediaTime)
{
    HRESULT hr = E_NOTIMPL;

    dblLatestMediaTime = -1.0;
    return hr;
}


HRESULT
CTIMEBasePlayer::GetMinBufferedMediaDur(double &dblMinBufferedMediaDur)
{
    HRESULT hr = E_NOTIMPL;

    dblMinBufferedMediaDur = -1.0;
    return hr;
}


HRESULT
CTIMEBasePlayer::SetMinBufferedMediaDur(double dblMinBufferedMediaDur)
{
    HRESULT hr = E_NOTIMPL;
    return hr;
}

HRESULT
CTIMEBasePlayer::GetDownloadTotal(LONGLONG &lldlTotal)
{
    HRESULT hr = E_NOTIMPL;
    return hr;
}

HRESULT
CTIMEBasePlayer::GetDownloadCurrent(LONGLONG &lldlCurrent)
{
    HRESULT hr = E_NOTIMPL;
    return hr;
}

HRESULT
CTIMEBasePlayer::GetIsStreamed(bool &fIsStreamed)
{
    HRESULT hr = S_OK;
    fIsStreamed = false;
    return hr;
}

HRESULT
CTIMEBasePlayer::GetBufferingProgress(double &dblBufferingProgress)
{
    HRESULT hr = S_OK;
    dblBufferingProgress = 0.0;
    return hr;
}

HRESULT
CTIMEBasePlayer::GetHasDownloadProgress(bool &fHasDownloadProgress)
{
    HRESULT hr = S_OK;
    fHasDownloadProgress = false;
    return hr;
}

HRESULT 
CTIMEBasePlayer::GetDownloadProgress(double &dblDownloadProgress)
{
    HRESULT hr = S_OK;
    dblDownloadProgress = 0.0;
    return hr;
}

HRESULT
CTIMEBasePlayer::GetMimeType(BSTR *pMime)
{
    HRESULT hr = E_NOTIMPL;
    pMime = NULL;
    return hr;
}

HRESULT
CTIMEBasePlayer::GetCurrentFrame(LONGLONG &lFrameNr)
{
    HRESULT hr = E_NOTIMPL;
    lFrameNr = -1;
    return hr;
}

HRESULT
CTIMEBasePlayer::ConvertFrameToTime(LONGLONG iFrame, double &dblTime)
{
    HRESULT hr = E_NOTIMPL;
    return hr;
}

void
CTIMEBasePlayer::SetPlaybackSite(CTIMEBasePlayer *pSite)
{
    m_pPlaybackSite = pSite;
}

void 
CTIMEBasePlayer::FireMediaEvent(PLAYER_EVENT plEvent, ITIMEBasePlayer *pBasePlayer)
{
}

HRESULT
CTIMEBasePlayer::GetPlaybackOffset(double &dblOffset)
{
    HRESULT hr = E_NOTIMPL;
    dblOffset = 0.0;

    return hr;
}


HRESULT
CTIMEBasePlayer::GetEffectiveOffset(double &dblOffset)
{
    HRESULT hr = E_NOTIMPL;
    dblOffset = 0.0;

    return hr;
}

HRESULT 
CTIMEBasePlayer::NotifyTransitionSite (bool fTransitionToggle)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\playercd.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: player.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "playercd.h"
#include "mediaelm.h"
#include <wininet.h>
#include <inc\evcode.h>
#include "tags\bodyelm.h"

#define SecsToNanoSecs 10000000

#define OVLMixer L"Overlay Mixer"
#define CDFilter L"WMP CD Filter"

#define SOUND_OF_SILENCE -10000
// Suppress new warning about NEW without corresponding DELETE 
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )  

DeclareTag(tagDshowCDTimePlayer, "TIME: Players", "CTIMEDshowCDPlayer methods");
DeclareTag(tagDshowCDSyncTimePlayer, "TIME: Players", "CTIMEDshowCDPlayer sync methods");

EXTERN_GUID( CLSID_WMPCDFilter, 0xCA9067FF, 0x777D, 0x4B65, 0xAA, 0x5F, 0xC0, 0xB2, 0x7E, 0x3E, 0xC7, 0x5D );


CTIMEDshowCDPlayer::CTIMEDshowCDPlayer(CTIMEDshowCDPlayerProxy * pProxy) :
    m_fHasVideo(false),
    m_fDoneSetup(false),
    m_dblSeekAtStart(0.0),
    m_lSrc(ATOM_TABLE_VALUE_UNITIALIZED),
    m_pTIMEMediaPlayerStream(NULL),
    m_fRemoved(false),
    m_fNeedToDeleteInterfaces(false),
    m_fUsingInterfaces(false),
    m_fLoadError(false),
    m_fHasMedia(false),
    m_dblPriority(INFINITE),
    m_fCanCueNow(false),
    m_fHavePriority(false),
    m_hrRenderFileReturn(S_OK),
    m_dblMediaDur(-1.0),
    m_pProxy(pProxy)
{
    TraceTag((tagDshowCDTimePlayer,
              "CTIMEDshowCDPlayer(%p)::CTIMEDshowCDPlayer()",
              this));


}


CTIMEDshowCDPlayer::~CTIMEDshowCDPlayer()
{
    TraceTag((tagDshowCDTimePlayer,
              "CTIMEDshowCDPlayer(%p)::~CTIMEDshowCDPlayer()",
              this));

    m_pMediaContent = NULL;

    ReleaseGenericInterfaces();

    ReleaseInterface(m_pTIMEMediaPlayerStream);

    delete m_pProxy;
}

STDMETHODIMP_(ULONG)
CTIMEDshowCDPlayer::AddRef(void)
{
    return CTIMEDshowBasePlayer::AddRef();
}


STDMETHODIMP_(ULONG)
CTIMEDshowCDPlayer::Release(void)
{
    return CTIMEDshowBasePlayer::Release();
}


STDMETHODIMP
CTIMEDshowCDPlayer::OnInvalidateRect(LPCRECT lpcRect)
{

    TraceTag((tagDshowCDTimePlayer, "CTIMEDshowCDPlayer(%p)::OnInvalidateRect(%x)", this, lpcRect));

    ::PostMessage(m_pwndMsgWindow, WM_INVALIDATE, NULL, NULL);

    return S_OK;
}

STDMETHODIMP
CTIMEDshowCDPlayer::OnStatusChange(ULONG ulStatusFlags)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CTIMEDshowCDPlayer::OnDataChange(ULONG ulDataFlags)
{
    return E_NOTIMPL;
}



HRESULT
CTIMEDshowCDPlayer::Init(CTIMEMediaElement *pelem, LPOLESTR base, LPOLESTR src, LPOLESTR lpMimeType, double dblClipBegin, double dblClipEnd)
{
    TraceTag((tagDshowCDTimePlayer,
              "CTIMEDshowCDPlayer(%p)::Init)",
              this));
    HRESULT hr = S_OK;
    LPOLESTR szSrc = NULL;

    if (m_pTIMEElementBase != NULL) //this only happens in the case of reentrancy
    {
        hr = S_OK;
        goto done;
    }

    hr = CTIMEDshowBasePlayer::Init(pelem, base, src, lpMimeType, dblClipBegin, dblClipEnd);
    if (FAILED(hr))
    {
        goto done;
    }

    m_pTIMEElementBase = pelem;

    hr = GetAtomTable()->AddNameToAtomTable(src, &m_lSrc);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = InitDshow();
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = GraphFinish();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = InitElementDuration();
    if (FAILED(hr))
    {
        goto done;
    }
    hr = InitElementSize();
    if (FAILED(hr))
    {
        goto done;
    }

    
    ClearNaturalDuration();

    if( dblClipBegin != -1.0)
    {
        m_dblClipStart = dblClipBegin;
    }

    if( dblClipEnd != -1.0)
    {
        m_dblClipEnd = dblClipEnd;
    }

    Assert(NULL != m_pTIMEElementBase->GetBody());
    
    hr = S_OK;
done:
    delete[] szSrc;
    return hr;
}

HRESULT
CTIMEDshowCDPlayer::DetachFromHostElement (void)
{
    HRESULT hr = S_OK;

    TraceTag((tagDshowCDTimePlayer,
              "CTIMEDshowCDPlayer(%p)::DetachFromHostElement)",
              this));

    m_fRemoved = true;

    Assert(NULL != GetImportManager());

    IGNORE_HR(GetImportManager()->Remove(this));

    CTIMEDshowBasePlayer::DetachFromHostElement();

    {
        CritSectGrabber cs(m_CriticalSection);
        
        if (false == m_fUsingInterfaces)
        {
            DeinitDshow();
        }
        else
        {
            m_fNeedToDeleteInterfaces = true;
        }
    }
    
    if (NULL != m_pTIMEElementBase->GetBody())
    {
        IGNORE_HR(m_pTIMEElementBase->GetBody()->RemoveInternalEventSink(this));
    }
    
    m_pTIMEElementBase = NULL;

    return hr;
}

void
CTIMEDshowCDPlayer::ReleaseSpecificInterfaces()
{
    m_pMediaContent = NULL;
    m_pCD = NULL;
}

void
CTIMEDshowCDPlayer::FreeSpecificData()
{

}

void
CTIMEDshowCDPlayer::DeinitDshow()
{
    CTIMEDshowBasePlayer::DeinitDshow();
}

HRESULT
CTIMEDshowCDPlayer::BuildGraph()
{
    HRESULT hr = S_OK;
    CComPtr<IFileSourceFilter> spSourceFilter;
    CComPtr<IEnumPins> spEnumPins;
    CComPtr<IPin> spPin;
    AM_MEDIA_TYPE mt;
    PIN_DIRECTION pinDir;
    ULONG ul;
    bool fFound = false;
    const WCHAR * cpchSrc = NULL;

    hr = GetAtomTable()->GetNameFromAtom(m_lSrc, &cpchSrc);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = CreateMessageWindow();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = CoCreateInstance(CLSID_FilterGraphNoThread,
                          NULL,
                          CLSCTX_INPROC_SERVER, //lint !e655
                          IID_IGraphBuilder,
                          (void **)&m_pGB);
                          
    if (FAILED(hr))
    {
        goto done;
    }

    hr = CoCreateInstance(CLSID_WMPCDFilter, NULL, CLSCTX_INPROC, IID_IBaseFilter, (LPVOID *)&m_pCD) ; //lint !e655
    if (FAILED(hr))
    {
        goto done;
    }
    hr = m_pGB->AddFilter(m_pCD, CDFilter);
    if (FAILED(hr))
    {
        goto done;
    }

	hr = m_pCD->QueryInterface(IID_IFileSourceFilter, (LPVOID *) &spSourceFilter);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = spSourceFilter->Load(cpchSrc, &mt);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = m_pCD->EnumPins(&spEnumPins);
    if (FAILED(hr))
    {
        goto done;
    }

    while ((S_OK == spEnumPins->Next(1, &spPin, &ul)))
    {
        hr = spPin->QueryDirection(&pinDir);
        if(FAILED(hr))
        {
            goto done;
        }
        if(pinDir == PINDIR_OUTPUT)
        {
            fFound = true;
            break;
        }
        spPin.Release();
    }
    if(fFound == false)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = m_pGB->Render(spPin);

done:
    return hr;
}

HRESULT
CTIMEDshowCDPlayer::GetSpecificInterfaces()
{
    HRESULT hr = S_OK;

    m_fMediaComplete = false;
done:
    return hr;
}


HRESULT
CTIMEDshowCDPlayer::InitDshow()
{
    HRESULT hr = S_OK;

    hr = CTIMEDshowBasePlayer::InitDshow();
    return hr;
}

class CSimplePB : public IMediaPropertyBag
{
    STDMETHOD(QueryInterface) (THIS_ REFIID, LPVOID *) { return E_NOINTERFACE; }
    STDMETHOD_(ULONG, AddRef)(THIS) { return 0; }
    STDMETHOD_(ULONG, Release)(THIS) { return 0; }
        
    STDMETHOD(Read)(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog) { return E_NOTIMPL; }
    STDMETHOD(EnumProperty) (ULONG iProperty, VARIANT *pvarName, VARIANT *pvarVal) { return E_NOTIMPL; } 
        
    LPCOLESTR m_pLookFor;
    BSTR *m_pbstrOut;

    STDMETHOD(Write) (LPCOLESTR pszPropName, VARIANT *pVar)
    {
        if (0 == wcscmp(m_pLookFor, pszPropName))
        {
            if (pVar->vt != VT_BSTR)
            {
                return E_NOTIMPL;
            }

            *m_pbstrOut = SysAllocString(pVar->bstrVal);
            if (NULL == m_pbstrOut)
            {
                return E_FAIL;
            }
        }

        return S_OK;
    }

    public:    
    CSimplePB() :
        m_pbstrOut(NULL), m_pLookFor(NULL) {}
    CSimplePB(LPCOLESTR pLookFor, BSTR *pbstrOut) :
        m_pbstrOut(pbstrOut), m_pLookFor(pLookFor) {}
};



HRESULT
CTIMEDshowCDPlayer::ReadContentProperty(IGraphBuilder *pGraph, LPCWSTR lpcwstrTag, BSTR * pbstr)
{
    IPersistMediaPropertyBag *pPMPB = NULL;
    if (S_OK == FindInterfaceOnGraph(pGraph, IID_IPersistMediaPropertyBag,
                                     (void **) &pPMPB))
    {
        CSimplePB pb(lpcwstrTag, pbstr);

        pPMPB->Save(&pb, FALSE, FALSE);

        pPMPB->Release();
    }

    return *pbstr ? S_OK : E_FAIL;
}

HRESULT
CTIMEDshowCDPlayer::InitElementSize()
{
    HRESULT hr;
    RECT nativeSize, elementSize;
    bool fisNative;

    if (NULL == m_pTIMEElementBase)
    {
        hr = S_OK;
        goto done;
    }

    if (m_bIsHTMLSrc)
    {
        hr = S_OK;
        goto done;
    }

    nativeSize.left = nativeSize.top = 0;
    nativeSize.right = 0;
    nativeSize.bottom = 0;
    
    hr = m_pTIMEElementBase->NegotiateSize( nativeSize, elementSize, fisNative);
    
    hr = S_OK;
done:
    return hr;
}

HRESULT
CTIMEDshowCDPlayer::SetSrc(LPOLESTR base, LPOLESTR src)
{   
    TraceTag((tagDshowCDTimePlayer,
              "CTIMEDshowCDPlayer(%p)::SetSrc()\n",
              this));
    
    return S_OK;

}

STDMETHODIMP
CTIMEDshowCDPlayer::CanBeCued(VARIANT_BOOL * pVB_CanCue)
{
    HRESULT hr = S_OK;

    if (NULL == pVB_CanCue)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    // ISSUE : do we need this for cd's?
    *pVB_CanCue = m_fCanCueNow ? VARIANT_TRUE : VARIANT_FALSE;
    
    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP
CTIMEDshowCDPlayer::CueMedia()
{
    TraceTag((tagDshowCDTimePlayer,
              "CTIMEDshowCDPlayer(%p)::CueMedia()",
              this));
    HRESULT hr = S_OK;

    return hr;
}

STDMETHODIMP
CTIMEDshowCDPlayer::MediaDownloadError()
{
    return S_OK;
}

HRESULT
CTIMEDshowCDPlayer::BeginDownload()
{
    TraceTag((tagDshowCDTimePlayer,
              "CTIMEDshowCDPlayer(%p::GraphFinish()",
              this));
    HRESULT hr = S_OK;
    RRETURN(hr);
}

HRESULT
CTIMEDshowCDPlayer::GraphFinish()
{
    TraceTag((tagDshowCDTimePlayer,
              "CTIMEDshowCDPlayer(%p::GraphFinish()",
              this));
    HRESULT hr = S_OK;
    
    CComPtr<IHTMLElement2> spElement2;

    if (FAILED(m_hrRenderFileReturn))     
    {
        FireMediaEvent(PE_ONMEDIAERROR);
        hr = m_hrRenderFileReturn;
        goto done;
    }

    if (m_fNeedToDeleteInterfaces)
    {
        goto done;
    }

    hr = FindInterfaceOnGraph(m_pGB, IID_IAMMediaContent, (void **)&m_pMediaContent);
    if (FAILED(hr))
    {
        m_pMediaContent = NULL;
    }
    hr = FindInterfaceOnGraph(m_pGB, IID_IBasicAudio, (void **)&m_pBasicAudio);
    if (FAILED(hr))
    {
        m_pBasicAudio = NULL;
    }
     //can be used m_pIAMNetShowConfig->put_BufferingTime(1.0);
    hr = FindInterfaceOnGraph(m_pGB, IID_IAMNetShowConfig,  (void **) &m_pIAMNetShowConfig);
    if (FAILED(hr))
    {
        m_pIAMNetShowConfig = NULL;
    }
    hr = FindInterfaceOnGraph(m_pGB, IID_IAMExtendedSeeking, (void **) &m_pExSeeking);
    if (FAILED(hr))
    {
        m_pExSeeking = NULL;
    } 
    hr = FindInterfaceOnGraph(m_pGB, IID_IAMNetworkStatus, (void **) &m_pIAMNetStat);
    if (FAILED(hr))
    {
        m_pExSeeking = NULL;
    } 
    
    hr = GraphCue();
    if (FAILED(hr))
    {
        goto done;
    }
    hr = THR(m_pMC->Run());
    if (FAILED(hr))
    {
        goto done;
    }

    if (m_pTIMEElementBase)
    {
        hr = m_pTIMEElementBase->GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &spElement2));
        if (FAILED(hr))
        {
            // IE4 path
            CComPtr<IElementBehaviorSite> spElementBehaviorSite;
            spElementBehaviorSite = m_pTIMEElementBase->GetBvrSite();
            
            CComPtr<IObjectWithSite> spSite;
            // see if we are running on IE4, and try to get spSite to be a CElementBehaviorSite*
            hr = spElementBehaviorSite->QueryInterface(IID_TO_PPV(IObjectWithSite, &spSite));
            if (FAILED(hr))
            {
                goto done;
            }
            
            CComPtr<IOleWindow> spOleWindow;
            // ask for the site (through CElementBehaviorSite to CVideoHost, to ATL::IObjectWIthSiteImpl
            hr = spSite->GetSite(IID_IOleWindow, (void**) &spOleWindow);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CTIMEDshowCDPlayer::Init - IE4 failure! unable to QI for IOleWindow on hosting Document"));
                goto done;
            }
        }
    }
    m_fMediaComplete = true;

    IGNORE_HR(this->InitElementDuration());
    
    m_pTIMEElementBase->InvalidateElement(NULL);
    FireMediaEvent(PE_ONMEDIACOMPLETE);

    InternalReset(true);

done:
    return hr;
}

//
// CTIMEDshowCDPlayer::IsOvMConnected(): Private method to detect if the video stream 
// is passing through the Overlay Mixer (i.e, is it connected?).
//
bool
CTIMEDshowCDPlayer::IsOvMConnected(IBaseFilter *pOvM)
{    
    IEnumPins   *pEnumPins;
    IPin        *pPin;
    IPin        *pPin2;
    ULONG        ul;
    HRESULT      hr;
    bool         bConnected = false;

    pOvM->EnumPins(&pEnumPins);
    while (S_OK == pEnumPins->Next(1, &pPin, &ul) && 1 == ul && bConnected == false)
    {
        hr = pPin->ConnectedTo(&pPin2);
        if (SUCCEEDED(hr) && pPin2)
        {
            bConnected = true;
            pPin2->Release();
        }
        pPin->Release();
    }
    pEnumPins->Release();
    
    return bConnected;
}

void
CTIMEDshowCDPlayer::OnTick(double dblSegmentTime,
                         LONG lCurrRepeatCount)
{
    TraceTag((tagDshowCDTimePlayer,
              "CTIMEDshowCDPlayer(%p)::OnTick(%g, %d)",
              this,
              dblSegmentTime,
              lCurrRepeatCount));
}

void
CTIMEDshowCDPlayer::GraphStart(void)
{
    HRESULT hr = S_OK;
    TraceTag((tagDshowCDTimePlayer,
              "CTIMEDshowCDPlayer(%p)::GraphStart()",
              this));

    m_fLoadError = false;

    if (m_fMediaComplete == false)
    {
        goto done;
    }

    hr = THR(m_pMC->Run());
    if (FAILED(hr))
    {
        m_fLoadError = true;
    }

  done: 

    return;
}
    
HRESULT
CTIMEDshowCDPlayer::Render(HDC hdc, LPRECT prc)
{
    TraceTag((tagDshowCDTimePlayer,
              "CTIMEDshowCDPlayer(%p)::Render(%d-%d)",
              this,
              prc->right - prc->left,
              prc->bottom - prc->top));
    HRESULT hr = S_OK;
    
done:
    return hr;
}


HRESULT
CTIMEDshowCDPlayer::SetSize(RECT *prect)
{
    HRESULT hr = S_OK;

    Assert(prect != NULL);
    return hr;
}

HRESULT
CTIMEDshowCDPlayer::GetMediaLength(double &dblLength)
{
    HRESULT hr = S_OK;
    const GUID mediaTimeFormat = TIME_FORMAT_MEDIA_TIME;
    LONGLONG mediaDur;
    dblLength = 0.0;

    if (m_pMC == NULL || m_pMP == NULL || m_pMS == NULL)
    {
        return E_FAIL;
    }

    if(m_dblMediaDur == -1.0)
    {
        hr = m_pMP->get_Duration(&dblLength);
        m_dblMediaDur = dblLength;
    }
    else
    {
        dblLength = m_dblMediaDur;
    }
done:
    return hr;
}


HRESULT
CTIMEDshowCDPlayer::CanSeek(bool &fcanSeek)
{
    HRESULT hr = S_OK;
    LONG canSeek;
    long seekFlags = 0;

    if (m_pIAMNetStat != NULL) //never seek asf's.
    {
        fcanSeek = false;
        goto done;
    }

    if (m_pExSeeking == NULL)
    {
        if (!m_pMP)
        {
            fcanSeek = false;
            goto done;
        }
        hr = m_pMP->CanSeekBackward(&canSeek);
        if (FAILED(hr))
        {
            fcanSeek = false;
            goto done;
        }
        if (canSeek == 0)
        {
            fcanSeek = false;
            goto done;
        }
        hr = m_pMP->CanSeekForward(&canSeek);
        if (FAILED(hr))
        {
            fcanSeek = false;
            goto done;
        }
        if (canSeek == 0)
        {
            fcanSeek = false;
            goto done;
        }
        fcanSeek = true;
    }
    else
    {
        hr = m_pExSeeking->get_ExSeekCapabilities( &seekFlags);
        if (SUCCEEDED(hr)) 
        {
            if( seekFlags & AM_EXSEEK_CANSEEK)
            {
                fcanSeek = true;
                goto done;
            }
        }
        hr = S_OK;
        fcanSeek = false;
    }

done:
    return hr;
}


HRESULT
CTIMEDshowCDPlayer::GetAuthor(BSTR *pAuthor)
{
    HRESULT hr = S_OK;

    if (NULL != pAuthor)
    {
        if (m_pMediaContent != NULL)
        {
            hr = m_pMediaContent->get_AuthorName(pAuthor);
            if (FAILED(hr))
            {
                *pAuthor = NULL;
            }
        }

        if (FAILED(hr) || m_pMediaContent == NULL)
        {
            hr = ReadContentProperty(m_pGB, L"INFO/IART", pAuthor);
            if (FAILED(hr))
            {
                *pAuthor = NULL;
            }
        }
    }
    return hr;
}

HRESULT
CTIMEDshowCDPlayer::GetTitle(BSTR *pTitle)
{
    HRESULT hr = S_OK;

    if (NULL != pTitle)
    {
        if (m_pMediaContent != NULL)
        {
            hr = m_pMediaContent->get_Title(pTitle);
            if (FAILED(hr))
            {
                *pTitle = NULL;
            }
        }

        if (FAILED(hr) || m_pMediaContent == NULL)
        {
            hr = ReadContentProperty(m_pGB, L"INFO/INAM", pTitle);
            if (FAILED(hr))
            {
                hr = ReadContentProperty(m_pGB, L"INFO/ISBJ", pTitle);
                if (FAILED(hr))
                {
                    *pTitle = NULL;
                }
            }
        }
    }
    return hr;
}

HRESULT
CTIMEDshowCDPlayer::GetCopyright(BSTR *pCopyright)
{
    HRESULT hr = S_OK;

    if (NULL != pCopyright)
    {
        if (m_pMediaContent != NULL)
        {
            hr = m_pMediaContent->get_Copyright(pCopyright);
            if (FAILED(hr))
            {
                *pCopyright = NULL;
            }
        }

        if (FAILED(hr) || m_pMediaContent == NULL)
        {
            // ISSUE : REfactor this down to dshow base class
            hr = ReadContentProperty(m_pGB, L"INFO/ICOP", pCopyright);
            if (FAILED(hr))
            {
                *pCopyright = NULL;
            }
        }
    }
    return hr;
}


HRESULT
CTIMEDshowCDPlayer::GetAbstract(BSTR *pBstrAbstract)
{
    HRESULT hr = S_OK;

    if (NULL != pBstrAbstract)
    {
        if (m_pMediaContent != NULL)
        {
            hr = m_pMediaContent->get_Description(pBstrAbstract);
            if (FAILED(hr))
            {
                *pBstrAbstract = NULL;
            }
        }
        else
        {
            *pBstrAbstract = NULL;
        }
    }
    return hr;
}


HRESULT
CTIMEDshowCDPlayer::GetRating(BSTR *pBstrRating)
{
    HRESULT hr = S_OK;

    if (NULL != pBstrRating)
    {
        if (m_pMediaContent != NULL)
        {
            hr = m_pMediaContent->get_Rating(pBstrRating);
            if (FAILED(hr))
            {
                *pBstrRating = NULL;
            }
        }
        else
        {
            *pBstrRating = NULL;
        }
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////
// This should take the lpszExtra info parameter from a URL_COMPONENTS structure.  In this
// field, the #html or #sami should be the first 5 characters in the string.
//////////////////////////////////////////////////////////////////////////////////////////////
void  
CTIMEDshowCDPlayer::SetStreamFlags(LPOLESTR src)
{
    long len = 0;
    OLECHAR stream[HTMLSTREAMSRCLEN + 1] = {0};
    
    m_bIsSAMISrc = false;
    m_bIsHTMLSrc = false;

    len = lstrlenW(src);
    if (len >= HTMLSTREAMSRCLEN)
    {
        memcpy((void *)stream, (void *)src, HTMLSTREAMSRCLEN * sizeof(OLECHAR));
    
        if (StrCmpIW(stream, HTMLSTREAMSRC) == 0)
        {
            m_bIsHTMLSrc = true;
        }
        if (StrCmpIW(stream, SAMISTREAMSRC) == 0)
        {
            m_bIsSAMISrc = true;
        }
    
    }
}

HRESULT
CTIMEDshowCDPlayer::DisableAudioVideo()
{
    HRESULT hr = E_FAIL;

    CComPtr<IBaseFilter> pMediaFilter;
    CComPtr<IPin> pPin;
    CComPtr<IEnumPins> pMediaPinEnum;
    
    //disconnect the video
    if (m_pMediaContent == NULL)
    {
        hr = E_FAIL;
        goto done;
    }
    hr = m_pMediaContent->QueryInterface(IID_IBaseFilter, (void **)&pMediaFilter);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pMediaFilter->EnumPins(&pMediaPinEnum);
    if (!pMediaPinEnum)
    {
        goto done;
    }
    while(pMediaPinEnum->Next(1, &pPin, NULL) == S_OK)
    {
        if (pPin != NULL)
        {
            IGNORE_HR(pPin->Disconnect());
        }
    }
    
    //silence the audio
    if (m_pBasicAudio != NULL)
    {
        hr = THR(m_pBasicAudio->put_Volume(SOUND_OF_SILENCE));
        if (FAILED(hr))
        {
            goto done;
        }
    }
    hr = S_OK;

done:
    return hr;
}


STDMETHODIMP
CTIMEDshowCDPlayer::InitializeElementAfterDownload()
{
    HRESULT hr = S_OK;
    TraceTag((tagDshowCDTimePlayer, "CTIMEDshowCDPlayer(%p)::InitializeElementAfterDownload",this));

    return hr;
}

STDMETHODIMP
CTIMEDshowCDPlayer::GetUniqueID(long * plID)
{
    HRESULT hr = S_OK;

    return hr;
}

STDMETHODIMP
CTIMEDshowCDPlayer::GetPriority(double * pdblPriority)
{
    HRESULT hr = S_OK;
    return hr;
}

HRESULT 
CTIMEDshowCDPlayer::GetNaturalHeight(long *height)
{
    *height = (long)0;
    
    return S_OK;
}

HRESULT 
CTIMEDshowCDPlayer::GetNaturalWidth(long *width)
{
    *width = (long)0;

    return S_OK;
}

PlayerState
CTIMEDshowCDPlayer::GetState()
{
    PlayerState state;
    
    if (!m_bActive)
    {
        if (!m_fMediaComplete)
        {
            state = PLAYER_STATE_CUEING;
        }
        else
        {
            state = PLAYER_STATE_INACTIVE;
        }
    }
    else
    {
        if(!m_bMediaDone)
        {
            state = PLAYER_STATE_ACTIVE;
        }
        else
        {
            state = PLAYER_STATE_HOLDING;
        }
    }

    return state;
}

STDMETHODIMP
CTIMEDshowCDPlayer::GetMediaDownloader(ITIMEMediaDownloader ** ppImportMedia)
{
    HRESULT hr = S_OK;

    Assert(NULL != ppImportMedia);

    *ppImportMedia = NULL;

    hr = S_FALSE;
done:
    return hr;
}

STDMETHODIMP
CTIMEDshowCDPlayer::PutMediaDownloader(ITIMEMediaDownloader * pImportMedia)
{
    HRESULT hr = S_OK;
    
    hr = E_NOTIMPL;
done:
    return hr;
}

HRESULT
CTIMEDshowCDPlayer::Reset()
{
    return InternalReset(true);
}


HRESULT
CTIMEDshowCDPlayer::CanSeekToMarkers(bool &bcanSeekToM)
{
    HRESULT hr = S_OK;
    long lseekFlags;

    // ISSUE : Does this type of content have markers?
    if( m_pExSeeking == NULL)
    {
        bcanSeekToM = false;
        goto done;
    }

    hr = m_pExSeeking->get_ExSeekCapabilities(&lseekFlags);
    if(FAILED(hr))
    {
        bcanSeekToM = false;
        goto done;
    }
    if(lseekFlags & AM_EXSEEK_MARKERSEEK)
    {
        bcanSeekToM = true;
    }
    else
    {
        bcanSeekToM = false;
    }
    hr = S_OK;

done:
    return hr;
}

HRESULT
CTIMEDshowCDPlayer::IsBroadcast(bool &fIsBroad)
{
    HRESULT hr = S_OK;

    fIsBroad = false;
    hr = S_OK;

done:
    return hr;
}

HRESULT
CTIMEDshowCDPlayer::HasMedia(bool &bHasMedia)
{
    bHasMedia = m_fMediaComplete;

    return S_OK;
}

HRESULT
CTIMEDshowCDPlayer::HasVisual(bool &bHasVideo)
{
    bHasVideo = m_fHasVideo;
    return S_OK;
}

HRESULT
CTIMEDshowCDPlayer::HasAudio(bool &bHasAudio)
{

    if(m_pBasicAudio != NULL)
    {
        bHasAudio = true;
    }
    else
    {
        bHasAudio = false;
    }
    return S_OK;
}

HRESULT
CTIMEDshowCDPlayer::GetRate(double &dblRate)
{
    HRESULT hr = S_OK;

    if(m_pMS != NULL)
    {
        hr = m_pMS->GetRate(&dblRate);
    }

    return hr;
}


HRESULT
CTIMEDshowCDPlayer::SetRate(double dblRate)
{
    HRESULT hr = S_OK;

    if((m_pMS != NULL) && (m_pIAMNetStat == NULL))
    {
        hr = m_pMS->SetRate(dblRate);
    }

    return hr;
}

STDMETHODIMP
CTIMEDshowCDPlayer::InternalEvent()
{
    m_fCanCueNow = true;

    Assert (NULL != GetImportManager());

    IGNORE_HR(GetImportManager()->DataAvailable());
    
    return S_OK;
}

HRESULT
CTIMEDshowCDPlayer::GetIsStreamed(bool &fIsStreamed)
{
    HRESULT hr = S_OK;

    fIsStreamed = false;

done:
    return hr;
}

HRESULT
CTIMEDshowCDPlayer::GetBufferingProgress(double &dblBufferingProgress)
{
    HRESULT hr = S_OK;

    dblBufferingProgress = 0.0;
    hr = S_OK;

done:
    return hr;
}

HRESULT
CTIMEDshowCDPlayer::GetHasDownloadProgress(bool &fHasDownloadProgress)
{
    HRESULT hr = S_OK;

    fHasDownloadProgress = false;
    hr = S_OK;
done:
    return hr;
}

void
CTIMEDshowCDPlayer::Block()
{
    if(m_pProxy)
    {
        m_pProxy->Block();
    }
}

void
CTIMEDshowCDPlayer::UnBlock()
{
    if(m_pProxy)
    {
        m_pProxy->UnBlock();
    }
}

bool
CTIMEDshowCDPlayer::CanCallThrough()
{
    if(m_pProxy)
    {
        return m_pProxy->CanCallThrough();
    }
    else
    {
        return true;
    }
}


bool
CTIMEDshowCDPlayer::FireProxyEvent(PLAYER_EVENT plEvent)
{
    bool fRet = false;
    CTIMEPlayerNative *pNativePlayer;

    if(m_pPlaybackSite == NULL)
    {
       goto done;
    }

    if(m_pProxy)
    {
        m_pProxy->FireMediaEvent(plEvent, NULL);
        fRet = true;
    }
    else if(m_pPlaybackSite && (pNativePlayer = m_pPlaybackSite->GetNativePlayer()) != NULL)
    {
        pNativePlayer->FireMediaEvent(plEvent, NULL);
        fRet = true;
    }

done:
    return fRet;
}


HRESULT
CTIMEDshowCDPlayer::GetMimeType(BSTR *pMime)
{
    HRESULT hr = S_OK;
    
    *pMime = SysAllocString(L"audio/CD");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\player.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: player.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "player.h"
#include "mediaelm.h"
#include "playlist.h"
#include "timeparser.h"
#include "mediaprivate.h"

DeclareTag(tagMediaTimePlayer, "TIME: Players", "CTIMEPlayer methods")

CTIMEPlayer::CTIMEPlayer(CLSID clsid):
  m_cRef(0),
  m_fExternalPlayer(false),
  m_fSyncMaster(false),
  m_fRunning(false),
  m_fHolding(false),
  m_fActive(false),
  m_dblStart(0.0),
  m_playerCLSID(clsid),
  m_fLoadError(false),
  m_fNoPlaylist(true),
  m_fIsOutOfSync(false),
  m_fPlayListLoaded(false),
  m_syncType(sync_none),
  m_dblSyncTime(0.0),
  m_fHasSrc(false),
  m_fMediaComplete(false),
  m_fSpeedIsNegative(false),
  m_fIsStreamed(false)
{
    TraceTag((tagMediaTimePlayer,
              "CTIMEPlayer(%lx)::CTIMEPlayer()",
              this));

    VariantInit(&m_varClipBegin);
    V_VT(&m_varClipBegin) = VT_R8;
    V_R8(&m_varClipBegin) = 0.0;

    VariantInit(&m_varClipEnd);
    V_VT(&m_varClipEnd) = VT_R8;
    V_R8(&m_varClipEnd) = -1.0;
}


CTIMEPlayer::~CTIMEPlayer()
{
    TraceTag((tagMediaTimePlayer,
              "CTIMEPlayer(%lx)::~CTIMEPlayer()",
              this));

    // No functions are virtual in destructors so make it explicit
    // here.  All derived classes should do the same.
    
    CTIMEPlayer::DetachFromHostElement();

    VariantClear(&m_varClipBegin);
    VariantClear(&m_varClipEnd);
}

STDMETHODIMP_(ULONG)
CTIMEPlayer::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG)
CTIMEPlayer::Release(void)
{
    LONG l = InterlockedDecrement(&m_cRef);

    if (0 == l)
    {
        delete this;
    }

    return l;
}

bool
CTIMEPlayer::CheckObject(IUnknown * pObj)
{
    HRESULT hr;
    bool bRet = false;
    
    CComPtr<ITIMEMediaPlayerOld> p;
            
    hr = THR(pObj->QueryInterface(IID_TO_PPV(ITIMEMediaPlayerOld, &p)));
    if (SUCCEEDED(hr))
    {
        bRet = true;
        goto done;
    }

  done:
    return bRet;
}

HRESULT
CTIMEPlayer::Init(CTIMEMediaElement *pelem,
                  LPOLESTR base,
                  LPOLESTR src,
                  LPOLESTR lpMimeType,
                  double dblClipBegin,
                  double dblClipEnd)
{
    TraceTag((tagMediaTimePlayer,
              "CTIMEPlayer(%lx)::Init)",
              this));
    
    HRESULT hr;
    IPropertyBag2 * pPropBag = NULL;
    IErrorLog * pErrorLog = NULL;
    LPOLESTR szSrc = NULL;

    hr = THR(::TIMECombineURL(base, src, &szSrc));
    if (!szSrc)
    {
        hr = E_FAIL;
        goto done;
    }
    if (FAILED(hr))
    {
        goto done;
    }

    m_fHasSrc = (src != NULL);
    
    hr = CTIMEBasePlayer::Init(pelem, base, src, lpMimeType, dblClipBegin, dblClipEnd);
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(!m_pContainer);
    m_pContainer = NEW CContainerObj();
    if (!m_pContainer)
    {
        TraceTag((tagError,
                  "CTIMEPlayer::Init - unable to alloc mem for container services!!!"));
        hr = E_OUTOFMEMORY;
        goto done;
    }

    if (m_pTIMEElementBase)
    {
        hr = THR(m_pTIMEElementBase->GetPropBag(&pPropBag, &pErrorLog));
        if (FAILED(hr))
        {
            goto done;
        }
    }
    
    hr = THR(m_pContainer->Init(m_playerCLSID, this, pPropBag, pErrorLog));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_pContainer->SetMediaSrc(szSrc));
    if (FAILED(hr))
    {
        goto done;
    }

    SetClipBegin(dblClipBegin);
    SetClipEnd(dblClipEnd);

    hr = THR(CreatePlayList());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
    
  done:
    if (FAILED(hr))
    {
        DetachFromHostElement();
    }

    delete[] szSrc;

    return S_OK;
}

HRESULT
CTIMEPlayer::DetachFromHostElement (void)
{
    HRESULT hr = S_OK;

    TraceTag((tagMediaTimePlayer,
              "CTIMEPlayer(%lx)::DetachFromHostElement)",
              this));   

    if (m_pContainer)
    {
        // Propogating this error wouldn't mean much 
        // to the caller since it is shutting down.
        IGNORE_HR(m_pContainer->Stop());
        IGNORE_HR(m_pContainer->DetachFromHostElement());
        m_pContainer.Release();
    }

    if (m_playList)
    {
        m_playList->Deinit();
        m_playList.Release();
    }

    return hr;
}

HRESULT
CTIMEPlayer::InitElementSize()
{
    HRESULT hr = S_OK;
    RECT rc;
    // add a method to get native video size.
    if (m_pTIMEElementBase)
    {
        hr = m_pTIMEElementBase->GetSize(&rc);
        if (FAILED(hr))
        {
            goto done;
        }

        if (m_pContainer)
        {
            m_pContainer->SetSize(&rc);
        }
    }

  done:
    return hr;
}

void
CTIMEPlayer::OnTick(double dblSegmentTime,
                    LONG lCurrRepeatCount)
{
    TraceTag((tagMediaTimePlayer,
              "CTIMEPlayer(%lx)::OnTick(%g, %d)",
              this,
              dblSegmentTime,
              lCurrRepeatCount));
}

#ifdef NEW_TIMING_ENGINE
void
CTIMEPlayer::OnSync(double dbllastTime, double & dblnewTime)
{
    TraceTag((tagMediaTimePlayer,
              "CTIMEPlayer(%lx)::OnSync(%g, %g)",
              this,
              dbllastTime,
              dblnewTime));
    
    if (!m_pTIMEElementBase)
    {
        goto done;
    }

    // if we are not the external player and not running, go away

    if (m_fRunning)
    {
        // get current time from player and
        // sync to this time
        double dblCurrentTime;
        dblCurrentTime = m_pContainer->GetCurrentTime();

        TraceTag((tagMediaTimePlayer,
                  "CTIMEPlayer(%lx)::OnSync - player returned %g",
                  this,
                  dblCurrentTime));
    
        // If the current time is -1 then the player is not ready and we
        // should sync to the last time.  We also should not respect the
        // tolerance since the behavior has not started.
    
        if (dblCurrentTime < 0)
        {
            TraceTag((tagMediaTimePlayer,
                      "CTIMEPlayer(%lx)::OnSync - player returned -1 - setting to dbllastTime (%g)",
                      this,
                      dbllastTime));
    
            dblCurrentTime = 0;
            // When we want this to actually hold at the begin value then enable
            // this code
            // dblCurrentTime = -HUGE_VAL;
        }
        else if (dblnewTime == HUGE_VAL)
        {
            if (dblCurrentTime >= (m_pTIMEElementBase->GetRealRepeatTime() - m_pTIMEElementBase->GetRealSyncTolerance()))
            {
                TraceTag((tagMediaTimePlayer,
                          "CTIMEPlayer(%lx)::OnSync - new time is ended and player w/i sync tolerance of end",
                          this));
    
                goto done;
            }
        }
        else if (fabs(dblnewTime - dblCurrentTime) <= m_pTIMEElementBase->GetRealSyncTolerance())
        {
            TraceTag((tagMediaTimePlayer,
                      "CTIMEPlayer(%lx)::OnSync - player w/i sync tolerance (new:%g, curr:%g, diff:%g, tol:%g)",
                      this,
                      dblnewTime,
                      dblCurrentTime,
                      fabs(dblnewTime - dblCurrentTime),
                      m_pTIMEElementBase->GetRealSyncTolerance()));
    
            goto done;
        }
        
        if (m_fSyncMaster && m_fLoadError == false)
        {
            dblnewTime = dblCurrentTime;
        }
    }
    else if (!m_fRunning && m_pTIMEElementBase->IsDocumentInEditMode()) //lint !e774
    {
        // if we are paused and in edit mode, make sure
        // WMP has the latest time.
        double dblMediaLen = 0.0f;
        TraceTag((tagMediaTimePlayer,
                "CTIMEPlayer(%lx)::OnSync(SeekTo=%g m_fRunning=%d)",
                this,
                dbllastTime, m_fRunning));
        // GetMediaLength fails if duration is indefinite (e.g. live stream).
        if (FAILED(m_pContainer->GetMediaLength(dblMediaLen)))
        {
            goto done;
        }

        // Don't seek beyond duration of media clip. 
        if (dbllastTime > dblMediaLen)
        {
            goto done;
        }

        if (m_pContainer)
        {
            THR(m_pContainer->Seek(dbllastTime));
        }
    }
  done:
    return ;
}    
#endif

void
CTIMEPlayer::Start()
{
    TraceTag((tagMediaTimePlayer,
              "CTIMEDshowPlayer(%lx)::Start()",
              this));

    IGNORE_HR(Reset());

done:
    return;
}

void
CTIMEPlayer::InternalStart()
{
    TraceTag((tagMediaTimePlayer,
              "CTIMEPlayer(%lx)::InternalStart()",
              this));

    HRESULT hr = S_OK;
    m_dblStart = 0.0;

    if(m_pContainer)
    {
        hr = m_pContainer->Start();
        TIMESetLastError(hr, NULL);
        m_fLoadError = false;
        if (FAILED(hr))
        {
            m_fLoadError = true;
        }
    }

    if (!m_fLoadError)
    {
        m_fRunning = true;
        m_fActive = true;
    }
    
}

void
CTIMEPlayer::Repeat()
{
    TraceTag((tagMediaTimePlayer,
              "CTIMEPlayer(%lx)::Repeat()",
              this));
    InternalStart(); //consider doing update state.
}

void
CTIMEPlayer::Stop()
{
    TraceTag((tagMediaTimePlayer,
              "CTIMEPlayer(%lx)::Stop()",
              this));

    m_fRunning = false;
    m_fActive = false;
    m_dblStart = 0.0;
    
    if(m_pContainer)
    {
        m_pContainer->Stop();
    }
}

void
CTIMEPlayer::Pause()
{
    TraceTag((tagMediaTimePlayer,
              "CTIMEPlayer(%lx)::Pause()",
              this));

    if(m_fHolding)
    {
        return;
    }

    m_fRunning = false;

    if(m_pContainer)
    {
        m_pContainer->Pause();
    }
}

void
CTIMEPlayer::Resume()
{
    TraceTag((tagMediaTimePlayer,
              "CTIMEPlayer(%lx)::Resume()",
              this));

    if (!m_pTIMEElementBase)
    {
        goto done;
    }

    bool bIsActive = m_pTIMEElementBase->IsActive();
    bool bIsCurrPaused = m_pTIMEElementBase->IsCurrPaused();
    float flTeSpeed = 0.0;
    bool fHaveTESpeed = m_pTIMEElementBase->GetTESpeed(flTeSpeed);

    if(m_fHolding)
    {
        goto done;
    }

    if(fHaveTESpeed && flTeSpeed < 0.0)
    {
        goto done;
    }

    if(m_pContainer && bIsActive && !bIsCurrPaused)
    {
        m_pContainer->Resume();
    }

    m_fRunning = true;

done:
    return;
}
    
HRESULT
CTIMEPlayer::Render(HDC hdc, LPRECT prc)
{
    TraceTag((tagMediaTimePlayer,
              "CTIMEPlayer(%lx)::Render()",
              this));
    HRESULT hr = S_OK;
    int iPrevMode = 0;

    if (!m_pTIMEElementBase)
    {
        goto done;
    }

    bool bIsOn = m_pTIMEElementBase->IsOn();
    bool bHasVisual = true;
    
    hr = THR(HasVisual(bHasVisual));
    if (SUCCEEDED(hr) && !bHasVisual)
    {
        hr = S_OK;
        goto done;
    }
    
    if (!m_pContainer)
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    iPrevMode = SetStretchBltMode(hdc, COLORONCOLOR);
    if (0 == iPrevMode)
    {
        hr = E_FAIL;
        goto done;
    }

    if(bIsOn)
    {
        hr = THR(m_pContainer->Render(hdc, prc));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done:
    if (0 != iPrevMode)
    {
        SetStretchBltMode(hdc, iPrevMode);
    }
    return hr;
}

HRESULT
CTIMEPlayer::GetExternalPlayerDispatch(IDispatch **ppDisp)
{
    // check to see if player is being used
    if (!m_pContainer)
    {
        return E_UNEXPECTED;
    }

    return m_pContainer->GetControlDispatch(ppDisp);
}

void 
CTIMEPlayer::GetClipBegin(double &pvar)
{
    HRESULT hr = S_OK;

    pvar = 0.0;
 
    if (m_varClipBegin.vt != VT_R4)
    {
        hr = VariantChangeTypeEx(&m_varClipBegin, &m_varClipBegin, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_R4);
        if (FAILED(hr))
        {
            goto done;
        }
    }

    pvar = m_varClipBegin.fltVal;

done:
    return;
}

void 
CTIMEPlayer::SetClipBegin(double var)
{
    CTIMEBasePlayer::SetClipBegin(var);
    
    VariantClear(&m_varClipBegin);
    V_VT(&m_varClipBegin) = VT_R8;
    V_R8(&m_varClipBegin) = var;
    
    if (m_pContainer)
    {
        IGNORE_HR(m_pContainer->clipBegin(m_varClipBegin));
    }

    Reset();

done:

    return;

}

void 
CTIMEPlayer::GetClipEnd(double &pvar)
{
    HRESULT hr = S_OK;

    pvar = -1.0;
    
    if (m_varClipBegin.vt != VT_R4)
    {
        hr = VariantChangeTypeEx(&m_varClipEnd, &m_varClipEnd, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_R4);
        if (FAILED(hr))
        {
            goto done;
        }
    }

    pvar = m_varClipEnd.fltVal;

done:
    return;

}

void 
CTIMEPlayer::SetClipEnd(double var)
{
    CTIMEBasePlayer::SetClipEnd(var);
    
    VariantClear(&m_varClipEnd);
    V_VT(&m_varClipEnd) = VT_R8;
    V_R8(&m_varClipEnd) = var;
    if (m_pContainer)
    {
        IGNORE_HR(m_pContainer->clipEnd(m_varClipEnd));
    }

done:

    return;
    
}

double 
CTIMEPlayer::GetCurrentTime()
{
    double dblCurrentTime = 0;
    
    if (m_pContainer)
    {
        dblCurrentTime = m_pContainer->GetCurrentTime();
    }
    
    return dblCurrentTime;
}

HRESULT
CTIMEPlayer::GetCurrentSyncTime(double & dblSyncTime)
{
    HRESULT hr;
    float flTeSpeed = 0.0;
    bool fHaveTESpeed;

    if (!m_pContainer || m_fLoadError || m_fHolding)
    {
        hr = S_FALSE;
        goto done;
    }

    if(m_pTIMEElementBase == NULL)
    {
        hr = S_FALSE;
        goto done;
    }

    if(!m_fNoPlaylist)
    {
        hr = S_FALSE;
        goto done;
    }

    fHaveTESpeed = m_pTIMEElementBase->GetTESpeed(flTeSpeed);
    if(fHaveTESpeed)
    {
        if(flTeSpeed < 0.0)
        {
            hr = S_FALSE;
            goto done;
        }
    }
    
    if (!m_fActive)
    {
        dblSyncTime = m_dblSyncTime;
        hr = S_OK;
        goto done;
    }
    
    dblSyncTime = m_pContainer->GetCurrentTime();

    hr = S_OK;
  done:
    RRETURN1(hr, S_FALSE);
}

HRESULT
CTIMEPlayer::Seek(double dblTime)
{
    HRESULT hr = S_FALSE;

    if (m_pContainer)
    {
        hr = m_pContainer->Seek(dblTime);
    }

    return hr;
}

HRESULT
CTIMEPlayer::SetSize(RECT *prect)
{
    if(!m_pContainer) return E_FAIL;
    return m_pContainer -> SetSize(prect);
}


HRESULT
CTIMEPlayer::GetMediaLength(double &dblLength)
{
    HRESULT hr;

    if (!m_pContainer)
    {
        return E_FAIL;
    }

    hr = m_pContainer -> GetMediaLength( dblLength);
    return hr;
}

HRESULT
CTIMEPlayer::GetEffectiveLength(double &dblLength)
{
    HRESULT hr;
    double dblClipEnd, dblClipBegin;

    if (!m_pContainer)
    {
        return E_FAIL;
    }

    hr = m_pContainer -> GetMediaLength( dblLength);
    if(FAILED(hr))
    {
        goto done;
    }

    GetClipEnd( dblClipEnd);
    if( dblClipEnd != -1.0)
    {
        dblLength = dblClipEnd;
    }
    GetClipBegin(dblClipBegin);
    dblLength -= dblClipBegin;

done:
    return hr;
}

HRESULT
CTIMEPlayer::CanSeek(bool &fcanSeek)
{
    HRESULT hr;

    if (!m_pContainer)
    {
        return E_FAIL;
    }

    hr = m_pContainer -> CanSeek( fcanSeek);
    if(FAILED(hr))
    {
        fcanSeek = false;
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}


HRESULT
CTIMEPlayer::CanSeekToMarkers(bool &fcanSeek)
{
    HRESULT hr;

    if (!m_pContainer)
    {
        fcanSeek = false;
        return E_FAIL;
    }
    hr = m_pContainer -> CanSeekToMarkers( fcanSeek);
    if(FAILED(hr))
    {
        fcanSeek = false;
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}

HRESULT
CTIMEPlayer::IsBroadcast(bool &fisBroadcast)
{
    HRESULT hr;

    if (!m_pContainer || m_fLoadError)
    {
        fisBroadcast = false;
        goto done;
    }

    hr = m_pContainer->IsBroadcast(fisBroadcast);
    if(FAILED(hr))
    {
        fisBroadcast = false;
        goto done;
    }

  done:
    return S_OK;
}

HRESULT
CTIMEPlayer::HasPlayList(bool &fHasPlayList)
{
    fHasPlayList = !m_fNoPlaylist;
    return S_OK;
}


HRESULT
CTIMEPlayer::SetSrc(LPOLESTR base, LPOLESTR src)
{
    HRESULT hr = S_OK;
    TraceTag((tagError,
              "CTIMEPlayer(%lx)::SetSrc()\n",
              this));
    LPOLESTR szSrc = NULL;

    hr = THR(::TIMECombineURL(base, src, &szSrc));
    if (!szSrc)
    {
        hr = E_FAIL;
        goto done;
    }
    if (FAILED(hr))
    {
        goto done;
    }

    m_fHasSrc = (src != NULL);
    m_fMediaComplete = false;

    if (!m_pContainer)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = m_pContainer->SetMediaSrc(szSrc);
    if (FAILED(hr))
    {
        goto done;
    }

    if(m_fRunning == true)
    {
        Resume();
    }
    else if (m_fActive == true)
    {
        Resume();
        Pause();
    }
  done:
    delete[] szSrc;
    return hr;

}

HRESULT
CTIMEPlayer::GetTitle(BSTR *pTitle)
{
    HRESULT hr;
    
    CHECK_RETURN_SET_NULL(pTitle);
    
    if (!m_pContainer)
    {
        hr = E_FAIL;
        goto done;
    }

    if (m_pContainer->UsingWMP())
    {
        LPWSTR str;
        
        hr = THR(GetMediaPlayerInfo(&str, mpClipTitle));
        if (hr == S_OK)
        {
            *pTitle = SysAllocString(str);
            delete [] str;
        }
    }
    else
    {
        *pTitle = NULL;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
} 


HRESULT
CTIMEPlayer::GetAuthor(BSTR *pAuthor)
{
    HRESULT hr;

    CHECK_RETURN_SET_NULL(pAuthor);
    
    if (!m_pContainer)
    {
        hr = E_FAIL;
        goto done;
    }

    if (m_pContainer->UsingWMP())
    {
        LPWSTR str;
        
        hr = THR(GetMediaPlayerInfo(&str, mpClipAuthor));
        if (hr == S_OK)
        {
            *pAuthor = SysAllocString(str);
            delete [] str;
        }
    }
    else
    {
        *pAuthor = NULL;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
CTIMEPlayer::GetCopyright(BSTR *pCopyright)
{
    HRESULT hr;

    CHECK_RETURN_SET_NULL(pCopyright);
    
    if (!m_pContainer)
    {
        hr = E_FAIL;
        goto done;
    }

    if (m_pContainer->UsingWMP())
    {
        LPWSTR str;
        
        hr = THR(GetMediaPlayerInfo(&str, mpClipCopyright));
        if (hr == S_OK)
        {
            *pCopyright = SysAllocString(str);
            delete [] str;
        }
    }
    else
    {
        *pCopyright = NULL;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
} 

HRESULT
CTIMEPlayer::GetAbstract(BSTR *pBstrAbstract)
{
    HRESULT hr;

    CHECK_RETURN_SET_NULL(pBstrAbstract);
    
    if (!m_pContainer)
    {
        hr = E_FAIL;
        goto done;
    }

    if (m_pContainer->UsingWMP())
    {
        LPWSTR str;
        
        hr = THR(GetMediaPlayerInfo(&str, mpClipDescription));
        if (hr == S_OK)
        {
            *pBstrAbstract = SysAllocString(str);
            delete [] str;
        }
    }
    else
    {
        *pBstrAbstract = NULL;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
} 


HRESULT
CTIMEPlayer::GetRating(BSTR *pBstrRating)
{
    HRESULT hr;

    CHECK_RETURN_SET_NULL(pBstrRating);
    
    if (!m_pContainer)
    {
        hr = E_FAIL;
        goto done;
    }

    if (m_pContainer->UsingWMP())
    {
        LPWSTR str;
        
        hr = THR(GetMediaPlayerInfo(&str, mpClipRating));
        if (hr == S_OK)
        {
            *pBstrRating = SysAllocString(str);
            delete [] str;
        }
    }
    else
    {
        *pBstrRating = NULL;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
} 

HRESULT
CTIMEPlayer::SetMute(VARIANT_BOOL varMute)
{
    HRESULT             hr         = E_FAIL;
    CComPtr<IDispatch>  pdisp;
    DISPID              dispid;
    DISPID              pputDispid = DISPID_PROPERTYPUT;
    OLECHAR           * wsName     = L"Mute";
    CComVariant         varResult;

    hr = GetExternalPlayerDispatch(&pdisp);
    if (FAILED(hr))
    {
        goto done;
    }
  
    hr = pdisp->GetIDsOfNames(IID_NULL, &wsName, 1, LCID_SCRIPTING, &dispid);
    if (FAILED(hr))
    {
        goto done;
    }

    VARIANT rgvarg[1];
    rgvarg[0].vt      = VT_BOOL;
    rgvarg[0].boolVal = varMute;

    DISPPARAMS dp;
    dp.cNamedArgs        = 1;
    dp.rgdispidNamedArgs = &pputDispid;
    dp.cArgs             = 1;
    dp.rgvarg            = rgvarg;


    hr = pdisp->Invoke(dispid, 
                           IID_NULL, 
                           LCID_SCRIPTING, 
                           DISPATCH_METHOD | DISPATCH_PROPERTYPUT,
                           &dp, 
                           &varResult, 
                           NULL, 
                           NULL);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}


HRESULT
CTIMEPlayer::GetMute(VARIANT_BOOL *varMute)
{
    HRESULT             hr      = E_FAIL;
    CComPtr<IDispatch>  pdisp;
    DISPID              dispid;
    OLECHAR           * wsName  = L"Mute";
    CComVariant         varResult;
    DISPPARAMS          dp      = {NULL, NULL, 0, 0};
 
    hr = GetExternalPlayerDispatch(&pdisp);
    if (FAILED(hr))
    {
        goto done;
    }  
  
    hr = pdisp->GetIDsOfNames(IID_NULL, &wsName, 1, LCID_SCRIPTING, &dispid);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pdisp->Invoke(dispid, 
                           IID_NULL, 
                           LCID_SCRIPTING, 
                           DISPATCH_PROPERTYGET,
                           &dp, 
                           &varResult, 
                           NULL, 
                           NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = varResult.ChangeType(VT_BOOL, NULL);
    if (FAILED(hr))
    {
        goto done;
    }
    *varMute = varResult.boolVal;

done:
    return hr;
}

HRESULT
CTIMEPlayer::SetVolume(float flVolume)
{
    HRESULT             hr         = E_FAIL;
    CComPtr<IDispatch>  pdisp;
    DISPID              dispid;
    DISPID              pputDispid = DISPID_PROPERTYPUT;
    OLECHAR           * wsName     = L"Volume";
    CComVariant         varResult;
   
    hr = GetExternalPlayerDispatch(&pdisp);
    if (FAILED(hr))
    {
        goto done;
    }

    VARIANT rgvarg[1];
    rgvarg[0].vt     = VT_R4;
    rgvarg[0].fltVal = VolumeLinToLog(flVolume);

    DISPPARAMS dp;
    dp.cNamedArgs        = 1;
    dp.rgdispidNamedArgs = &pputDispid;
    dp.cArgs             = 1;
    dp.rgvarg            = rgvarg;

    
    hr = pdisp->GetIDsOfNames(IID_NULL, &wsName, 1, LCID_SCRIPTING, &dispid);
    if (FAILED(hr))
    {
        goto done;
    }

 
    hr = pdisp->Invoke(dispid, 
                           IID_NULL, 
                           LCID_SCRIPTING, 
                           DISPATCH_PROPERTYPUT,
                           &dp, 
                           &varResult, 
                           NULL, 
                           NULL);

    if (FAILED(hr))
    {
        goto done;
    }

done:
    return hr;
}

HRESULT
CTIMEPlayer::GetVolume(float *flVolume)
{
    HRESULT             hr      = E_FAIL;
    CComPtr<IDispatch>  pdisp;
    DISPID              dispid;
    OLECHAR           * wsName  = L"Volume";
    CComVariant         varResult;
    DISPPARAMS          dp      = {NULL, NULL, 0, 0};
 
   
    hr = GetExternalPlayerDispatch(&pdisp);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pdisp->GetIDsOfNames(IID_NULL, &wsName, 1, LCID_SCRIPTING, &dispid);
    if (FAILED(hr))
    {
        goto done;
    }
 
    hr = pdisp->Invoke(dispid, 
                           IID_NULL, 
                           LCID_SCRIPTING, 
                           DISPATCH_PROPERTYGET,
                           &dp, 
                           &varResult, 
                           NULL, 
                           NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = varResult.ChangeType(VT_R4, NULL);
    if (FAILED(hr))
    {
        goto done;
    }
    *flVolume = VolumeLogToLin(static_cast<long>(varResult.fltVal));

done:
    return hr;
}


HRESULT
CTIMEPlayer::SetRate(double dblRate)
{
    HRESULT             hr         = E_FAIL;
    CComPtr<IDispatch>  pdisp;
    DISPID              dispid;
    DISPID              pputDispid = DISPID_PROPERTYPUT;
    OLECHAR           * wsName     = L"Rate";
    CComVariant         varResult;
   
    hr = GetExternalPlayerDispatch(&pdisp);
    if (FAILED(hr))
    {
        goto done;
    }

    VARIANT rgvarg[1];
    rgvarg[0].vt     = VT_R4;
    rgvarg[0].fltVal = (float)dblRate;

    DISPPARAMS dp;
    dp.cNamedArgs        = 1;
    dp.rgdispidNamedArgs = &pputDispid;
    dp.cArgs             = 1;
    dp.rgvarg            = rgvarg;

    
    hr = pdisp->GetIDsOfNames(IID_NULL, &wsName, 1, LCID_SCRIPTING, &dispid);
    if (FAILED(hr))
    {
        goto done;
    }

 
    hr = pdisp->Invoke(dispid, 
                           IID_NULL, 
                           LCID_SCRIPTING, 
                           DISPATCH_PROPERTYPUT,
                           &dp, 
                           &varResult, 
                           NULL, 
                           NULL);

    if (FAILED(hr))
    {
        goto done;
    }

done:
    return hr;
}

HRESULT
CTIMEPlayer::GetRate(double &dblRate)
{
    HRESULT             hr      = E_FAIL;
    CComPtr<IDispatch>  pdisp;
    DISPID              dispid;
    OLECHAR           * wsName  = L"Rate";
    CComVariant         varResult;
    DISPPARAMS          dp      = {NULL, NULL, 0, 0};
 
   
    hr = GetExternalPlayerDispatch(&pdisp);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pdisp->GetIDsOfNames(IID_NULL, &wsName, 1, LCID_SCRIPTING, &dispid);
    if (FAILED(hr))
    {
        goto done;
    }
 
    hr = pdisp->Invoke(dispid, 
                           IID_NULL, 
                           LCID_SCRIPTING, 
                           DISPATCH_PROPERTYGET,
                           &dp, 
                           &varResult, 
                           NULL, 
                           NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = varResult.ChangeType(VT_R4, NULL);
    if (FAILED(hr))
    {
        goto done;
    }
    dblRate = varResult.fltVal;
done:
    return hr;
}

#ifdef NEVER //dorinung 03-16-2000 bug 106458

HRESULT
CTIMEPlayer::GetBalance(float *flBal)
{
    HRESULT             hr      = E_FAIL;
    CComPtr<IDispatch>  pdisp; 
    DISPID              dispid;
    OLECHAR           * wsName  = L"Balance";
    CComVariant         varResult;
    DISPPARAMS          dp      = {NULL, NULL, 0, 0};
   
    hr = GetExternalPlayerDispatch(&pdisp);
    if (FAILED(hr))
    {
        goto done;
    }
  
    hr = pdisp->GetIDsOfNames(IID_NULL, &wsName, 1, LCID_SCRIPTING, &dispid);
    if (FAILED(hr))
    {
        goto done;
    }

 
    hr = pdisp->Invoke(dispid, 
                           IID_NULL, 
                           LCID_SCRIPTING, 
                           DISPATCH_PROPERTYGET,
                           &dp, 
                           &varResult, 
                           NULL, 
                           NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = varResult.ChangeType(VT_R4, NULL);
    if (FAILED(hr))
    {
        goto done;
    }
    *flBal = BalanceLogToLin(static_cast<long>(varResult.fltVal));
done:
    return hr;
}


HRESULT
CTIMEPlayer::SetBalance(float flBal)
{
    HRESULT             hr         = E_FAIL;
    CComPtr<IDispatch>  pdisp;
    DISPID              dispid;
    DISPID              pputDispid = DISPID_PROPERTYPUT;
    OLECHAR           * wsName     = L"Balance";
    CComVariant         varResult;
    

    VARIANT rgvarg[1];
    rgvarg[0].vt     = VT_R4;
    rgvarg[0].fltVal = BalanceLinToLog(fabs(flBal));

    DISPPARAMS dp;
    dp.cNamedArgs        = 1;
    dp.rgdispidNamedArgs = &pputDispid;
    dp.cArgs             = 1;
    dp.rgvarg            = rgvarg;

    hr = GetExternalPlayerDispatch(&pdisp);
    if (FAILED(hr))
    {
        goto done;
    }    
  
    hr = pdisp->GetIDsOfNames(IID_NULL, &wsName, 1, LCID_SCRIPTING, &dispid);
    if (FAILED(hr))
    {
        goto done;
    }
 
    hr = pdisp->Invoke(dispid, 
                           IID_NULL, 
                           LCID_SCRIPTING, 
                           DISPATCH_PROPERTYPUT,
                           &dp, 
                           &varResult, 
                           NULL, 
                           NULL);

    if (FAILED(hr))
    {
        goto done;
    }

done:
    return hr;
}
#endif

HRESULT
CTIMEPlayer::HasMedia(bool &bHasMedia)
{
    HRESULT hr;
    
    if(!m_pContainer || m_fLoadError)
    {
        bHasMedia = false;
        goto done;
    }

    hr = m_pContainer->HasMedia(bHasMedia);
    if(FAILED(hr))
    {
        bHasMedia = true;
        goto done;
    }

  done:
    return S_OK;
}

HRESULT
CTIMEPlayer::HasVisual(bool &bHasVideo)
{
    long height, width;

    GetNaturalHeight(&height);
    GetNaturalWidth(&width);

    if((height != -1) && (width != -1))
    {
        bHasVideo = true;
    }
    else
    {
        bHasVideo = false;
    }

  done:
    return S_OK;
}

HRESULT
CTIMEPlayer::GetMimeType(BSTR *pMime)
{
    HRESULT hr = S_OK;

    bool fHasMedia = false;
    bool fHasVisual = true;

    hr = HasMedia(fHasMedia);
    if(FAILED(hr))
    {
        pMime = NULL;
        goto done;
    }

    hr = HasVisual(fHasVisual);
    if(FAILED(hr))
    {
        pMime = NULL;
        goto done;
    }

    if(fHasVisual)
    { 
        *pMime = SysAllocString(L"video/unknown");
    }
    else
    {
        *pMime = SysAllocString(L"audio/unknown");
    }

done:
    return hr;
}

HRESULT
CTIMEPlayer::HasAudio(bool &bHasAudio)
{
    if (m_fLoadError == true || m_fHasSrc == false)
    {
        bHasAudio = false;
        goto done;
    }

    bHasAudio = true;

  done:
    return S_OK;
}

HRESULT
CTIMEPlayer::GetMediaPlayerInfo(LPWSTR *pwstr,  int mpInfoToReceive)
{
    HRESULT             hr = E_FAIL;
    CComPtr<IDispatch>  pdisp;
    DISPID              dispid;
    OLECHAR           * wsName = L"GetMediaInfoString";
    CComVariant         varResult;

    *pwstr = NULL;
    
    hr = GetExternalPlayerDispatch(&pdisp);
    if (FAILED(hr))
    {
        goto done;
    }
  
    hr = pdisp->GetIDsOfNames(IID_NULL, &wsName, 1, LCID_SCRIPTING, &dispid);
    if (FAILED(hr))
    {
        goto done;
    }

    VARIANT rgvarg[1];
    rgvarg[0].vt    = VT_I4;
    rgvarg[0].lVal  = mpInfoToReceive;

    DISPPARAMS dp;
    dp.cNamedArgs        = 0;
    dp.rgdispidNamedArgs = 0;
    dp.cArgs             = 1;
    dp.rgvarg            = rgvarg;

    hr = pdisp->Invoke(dispid, 
                           IID_NULL, 
                           LCID_SCRIPTING, 
                           DISPATCH_METHOD | DISPATCH_PROPERTYGET,
                           &dp, 
                           &varResult, 
                           NULL, 
                           NULL);
    if (FAILED(hr))
    {
        goto done;
    }

    if((*varResult.bstrVal) != NULL)
    {
        *pwstr = CopyString(V_BSTR(&varResult));
    }
    
    hr = S_OK;
  done:
    return hr;
} 

HRESULT 
CTIMEPlayer::CreatePlayList()
{
   TraceTag((tagMediaTimePlayer,
             "CTIMEPlayer(%lx)::CreatePlayList()",
             this));
   
    HRESULT hr;
    
    if (!m_playList)
    {
        CComObject<CPlayList> * pPlayList;

        hr = THR(CComObject<CPlayList>::CreateInstance(&pPlayList));
        if (hr != S_OK)
        {
            goto done;
        }

        // Init the object
        hr = THR(pPlayList->Init(*this));
        if (FAILED(hr))
        {
            delete pPlayList;
            goto done;
        }

        // cache a pointer to the object
        m_playList = static_cast<CPlayList*>(pPlayList);
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

void
CTIMEPlayer::FillPlayList(CPlayList *pPlayList)
{
    HRESULT hr = S_OK;
    CComPtr <IDispatch> pDisp;
    VARIANT vCount;
    DISPPARAMS dispparams = { NULL, NULL, 0, 0 };
    DISPID dispid;
    LPOLESTR szCount = L"EntryCount";
    int i;

    VariantInit(&vCount);

    if (!m_pContainer)
    {
        hr = E_FAIL;
        goto done;
    }
    
    //currently this is only allowed using the WMP.
    if (m_pContainer->UsingWMP() == false)
    {
        hr = E_NOTIMPL;
        goto done;
    }

    hr = THR(m_pContainer->GetControlDispatch(&pDisp));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pDisp->GetIDsOfNames(IID_NULL, &szCount, 1, LOCALE_SYSTEM_DEFAULT, &dispid));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pDisp->Invoke(dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT, DISPATCH_PROPERTYGET, &dispparams, &vCount, NULL, NULL));
    if (FAILED(hr))
    {
        goto done;
    }
    if (vCount.vt != VT_I4)
    {
        hr = E_FAIL;
        goto done;
    }
    
    if (vCount.lVal > 0)
    {
        m_fNoPlaylist = false;  //there is a playlist
        for (i = 1; i <= vCount.lVal; i++)
        {
            CComPtr<CPlayItem> pPlayItem;
            LPWSTR pwzStr;

            //create the playitem
            hr = THR(pPlayList->CreatePlayItem(&pPlayItem));
            if (FAILED(hr))
            {
                goto done; //can't create playitems.
            }
            
            //get the various parameters from the playlist to put in the playitem.

            //get the src
            hr = THR(GetPlayListInfo(i, L"HREF", &pwzStr));
            if (hr == S_OK)
            {
                pPlayItem->PutSrc(pwzStr);
                delete [] pwzStr;
            }
            //get the title
            hr = THR(GetPlayListInfo(i, L"title", &pwzStr));
            if (hr == S_OK)
            {
                pPlayItem->PutTitle(pwzStr);
                delete [] pwzStr;
            }
            //get the author
            hr = THR(GetPlayListInfo(i, L"author", &pwzStr));
            if (hr == S_OK)
            {
                pPlayItem->PutAuthor(pwzStr);
                delete [] pwzStr;
            }
            //get the copyright
            hr = THR(GetPlayListInfo(i, L"copyright", &pwzStr));
            if (hr == S_OK)
            {
                pPlayItem->PutCopyright(pwzStr);
                delete [] pwzStr;
            }
            //get the abstract
            hr = THR(GetPlayListInfo(i, L"abstract", &pwzStr));
            if (hr == S_OK)
            {
                pPlayItem->PutAbstract(pwzStr);
                delete [] pwzStr;
            }
            //get the rating
            hr = THR(GetPlayListInfo(i, L"rating", &pwzStr));
            if (hr == S_OK)
            {
                pPlayItem->PutRating(pwzStr);
                delete [] pwzStr;
            }

            //add the playitem to the playlist.
            IGNORE_HR(pPlayList->Add(pPlayItem, -1));
        }
    }
    else
    {
        m_fNoPlaylist = true;
    }

    VariantClear (&vCount);   
    m_fPlayListLoaded = true;

  done:
    return;
}

HRESULT 
CTIMEPlayer::GetPlayListInfo(long EntryNum, LPWSTR bstrParamName, LPWSTR *pwzValue)
{
    CComPtr<IDispatch>  pdisp;
    DISPID              dispid;
    OLECHAR           * wsName = L"GetMediaParameter";
    CComVariant         varResult;
    HRESULT hr = S_OK;
    VARIANT rgvarg[2];
        
    *pwzValue = NULL;
    
    VariantInit(&rgvarg[0]);
    VariantInit(&rgvarg[1]);

    hr = GetExternalPlayerDispatch(&pdisp);
    if (FAILED(hr))
    {
        goto done;
    }
  
    hr = pdisp->GetIDsOfNames(IID_NULL, &wsName, 1, LCID_SCRIPTING, &dispid);
    if (FAILED(hr))
    {
        goto done;
    }

    rgvarg[1].vt    = VT_I4;
    rgvarg[1].lVal  = EntryNum;
    rgvarg[0].vt    = VT_BSTR;
    rgvarg[0].bstrVal  = SysAllocString(bstrParamName);


    DISPPARAMS dp;
    dp.cNamedArgs        = 0;
    dp.rgdispidNamedArgs = 0;
    dp.cArgs             = 2;
    dp.rgvarg            = rgvarg;

    hr = pdisp->Invoke(dispid, 
                       IID_NULL, 
                       LCID_SCRIPTING, 
                       DISPATCH_METHOD | DISPATCH_PROPERTYGET,
                       &dp, 
                       &varResult, 
                       NULL, 
                       NULL);
    if (FAILED(hr))
    {
        goto done;
    }

    if (varResult.vt != VT_BSTR)
    {
        hr = S_FALSE;
        goto done;
    }

    *pwzValue = CopyString(varResult.bstrVal);

    if (*pwzValue == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;
  done:

    VariantClear(&rgvarg[0]);
    VariantClear(&rgvarg[1]);

    return hr;

}

HRESULT
CTIMEPlayer::GetPlayList(ITIMEPlayList **ppPlayList)
{
    HRESULT hr = E_FAIL;
    
    CHECK_RETURN_SET_NULL(ppPlayList);

    hr = THR(CreatePlayList());
    if (FAILED(hr))
    {
        goto done;
    }

    if (!m_playList)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(m_playList->QueryInterface(IID_ITIMEPlayList, (void**)ppPlayList));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT 
CTIMEPlayer::GetActiveTrack(long *index)
{
    HRESULT hr = S_OK;
    CComPtr <IDispatch> pDisp;
    LPOLESTR wsName = L"GetCurrentEntry";
    DISPID dispid;
    DISPPARAMS dp;
    VARIANT vRetVal;

    if (m_fNoPlaylist == true)
    {
        *index = -1;
        goto done;
    }

    hr = THR(GetExternalPlayerDispatch(&pDisp));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = pDisp->GetIDsOfNames(IID_NULL, &wsName, 1, LCID_SCRIPTING, &dispid);
    if (FAILED(hr))
    {
        goto done;
    }


    dp.cNamedArgs        = 0;
    dp.rgdispidNamedArgs = NULL;
    dp.cArgs             = 0;
    dp.rgvarg            = NULL;

    hr = pDisp->Invoke(dispid, 
                       IID_NULL, 
                       LCID_SCRIPTING, 
                       DISPATCH_METHOD,
                       &dp, 
                       &vRetVal, 
                       NULL, 
                       NULL);
    if (FAILED(hr))
    {
        goto done;
    }
    
    if (vRetVal.vt != VT_I4)
    {
        hr = E_FAIL;
        goto done;
    }

    *index = vRetVal.lVal - 1; //change the index from 1-based to 0-based

  done:

    return hr;

}


HRESULT 
CTIMEPlayer::SetActiveTrack(long index)
{
    HRESULT hr = S_OK;
    CComPtr <IDispatch> pDisp;
    LPOLESTR wsEntry = L"SetCurrentEntry";

    DISPID dispid;
    DISPPARAMS dp;
    DISPPARAMS dispparams = { NULL, NULL, 0, 0 };
    VARIANT rgvarg[1];
    VARIANT vCount;

    VariantInit(&vCount);

    LPOLESTR szCount = L"EntryCount";

    if (!m_pContainer)
    {
        hr = E_FAIL;
        goto done;
    }

    if (!m_pContainer->UsingWMP())
    {
        goto done;
    }

    hr = THR(GetExternalPlayerDispatch(&pDisp));

    if (FAILED(hr))
    {
        goto done;
    }

    if (m_fPlayListLoaded == false)
    {
        m_pContainer->setActiveTrackOnLoad (index);
        goto done;
    }
    if (m_fNoPlaylist == false)
    {
        //this increment is applied because the media player uses a 1-based playlist and the
        //MSTIME playlist is a 0-based collection.
        index += 1;

        hr = THR(pDisp->GetIDsOfNames(IID_NULL, &szCount, 1, LOCALE_SYSTEM_DEFAULT, &dispid));
        if (FAILED(hr))
        {
            goto done;
        }

        hr = THR(pDisp->Invoke(dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT, DISPATCH_PROPERTYGET, &dispparams, &vCount, NULL, NULL));
        if (FAILED(hr))
        {
            goto done;
        }
        if (vCount.vt != VT_I4)
        {
            hr = E_FAIL;
            goto done;
        }

        if (vCount.lVal == 0) //this is the case of the media not being loaded yet
        {
            m_pContainer->setActiveTrackOnLoad (index-1);
            goto done;
        }

        if (vCount.lVal < index || index < 1)
        {
            //this is advancing past the end of the track, or trying to load a track that is past the beginning.
            hr =
                THR(m_pContainer->ProcessEvent(DISPID_TIMEMEDIAPLAYEREVENTS_ONEND, 0, NULL));
            VariantClear (&vCount);
            goto done;
        }
        VariantClear (&vCount);
        hr = pDisp->GetIDsOfNames(IID_NULL, &wsEntry, 1, LCID_SCRIPTING, &dispid);
        if (FAILED(hr))
        {
            goto done;
        }

        rgvarg[0].vt = VT_I4;
        rgvarg[0].lVal = index;

        dp.cNamedArgs        = 0;
        dp.rgdispidNamedArgs = NULL;
        dp.cArgs             = 1;
        dp.rgvarg            = rgvarg;

        hr = pDisp->Invoke(dispid, 
                           IID_NULL, 
                           LCID_SCRIPTING, 
                           DISPATCH_METHOD,
                           &dp, 
                           NULL, 
                           NULL, 
                           NULL);
        VariantClear(&rgvarg[0]);
        if (FAILED(hr))
        {
            goto done;
        }

        if (!m_fRunning)
        {
            m_pContainer->Pause();
        }
    }
    else
    {
        if (index == 0)
        {
            //need to start the element if it is currently stopped
            if (!m_fActive)
            {
                if (m_pTIMEElementBase)
                {
                    m_pTIMEElementBase->BeginElement(0.0);         
                }
            }
            else
            {
                //rewind to the beginning of the track
                Seek(0.0);
            }
        }
        else
        {
            hr = THR(m_pContainer->ProcessEvent(DISPID_TIMEMEDIAPLAYEREVENTS_ONEND,
                                                0,
                                                NULL));
            //this is advancing off the track need to end.
        }
    }
    
    //need to start the element if it is currently stopped
    if (!m_fActive && m_pTIMEElementBase)
    {
        m_pTIMEElementBase->BeginElement(0.0);         
    }

    //
    // fire notification on playlist that active track has changed
    //

    hr = THR(CreatePlayList());
    if (SUCCEEDED(hr))
    {
        IGNORE_HR(m_playList->NotifyPropertyChanged(DISPID_TIMEPLAYLIST_ACTIVETRACK));
    }
    
    hr = S_OK;
  done:
    return hr;
}

HRESULT 
CTIMEPlayer::GetNaturalHeight(long *height)
{
    HRESULT hr = S_OK;

    if (height == NULL)
    {
        hr = E_POINTER;
        goto done;
    }
    *height = -1;
    if (!m_pContainer)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(m_pContainer->GetNaturalHeight(height));
    if (FAILED(hr))
    {
        goto done;
    }
  done:
    return hr;
}

HRESULT 
CTIMEPlayer::GetNaturalWidth(long *width)
{

    HRESULT hr = S_OK;

    if (width == NULL)
    {
        hr = E_POINTER;
        goto done;
    }
    *width = -1;
    if (!m_pContainer)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(m_pContainer->GetNaturalWidth(width));
    if (FAILED(hr))
    {
        goto done;
    }
  done:
    return hr;
}


HRESULT
CTIMEPlayer::Reset()
{
    HRESULT hr = S_OK;
    bool bNeedActive;
    bool bNeedPause;
    double dblSegTime = 0.0, dblPlayerRate = 0.0;
    float flTeSpeed = 0.0;
    bool fHaveTESpeed;

    if(m_pTIMEElementBase == NULL)
    {
        goto done;
    }

    bNeedActive = m_pTIMEElementBase->IsActive();
    bNeedPause = m_pTIMEElementBase->IsCurrPaused();
    fHaveTESpeed = m_pTIMEElementBase->GetTESpeed(flTeSpeed);

    if( !bNeedActive) // see if we need to stop the media.
    {
        if( m_fActive && m_fRunning)
        {
            Stop();
        }
        m_dblSyncTime = 0.0;
        goto done;

    }
    m_dblSyncTime = GetCurrentTime();

    hr = GetRate(dblPlayerRate);
    if(SUCCEEDED(hr) && fHaveTESpeed)
    {
        if (flTeSpeed <= 0.0)
        {
            hr = S_OK;
            Pause();
            goto done;
        }
        if (dblPlayerRate != flTeSpeed)
        {
            IGNORE_HR(SetRate((double)flTeSpeed));
        }
    }

    dblSegTime = m_pTIMEElementBase->GetMMBvr().GetSimpleTime();

    if (m_pContainer)
    {
        if( !m_fActive)
        {
            InternalStart(); // add a seek after this

            IGNORE_HR(Seek(dblSegTime));
        }
        else
        {
            //we need to be active so we also seek the media to it's correct position
            IGNORE_HR(Seek(dblSegTime));
        }
    }

    //Now see if we need to change the pause state.

    if( bNeedPause || m_fHolding)
    {
        if(!m_fIsOutOfSync)
        {
            if( m_fRunning)
            {
                Pause();
            }
        }
    }
    else
    {
        Resume();
    }
done:
    return hr;
}


void 
CTIMEPlayer::FireMediaEvent(PLAYER_EVENT plEvent)
{
    switch(plEvent)
    {
        case PE_ONMEDIACOMPLETE:
            ClearNaturalDuration();

            if (m_playList)
            {
                m_playList->Clear();
                m_playList->SetLoaded(false);

                FillPlayList(m_playList);

                m_playList->SetLoaded(true);
            }

            if (m_pTIMEElementBase)
            {
                m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_ABSTRACT);
                m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_AUTHOR);
                m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_COPYRIGHT);
                m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_MEDIAHEIGHT);
                m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_MEDIAWIDTH);
                m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_RATING);
                m_pTIMEElementBase->NotifyTimeStateChange(DISPID_TIMESTATE_STATE);
                m_pTIMEElementBase->NotifyTimeStateChange(DISPID_TIMESTATE_STATESTRING);
                m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_TITLE);
            }
            m_fLoadError = false;
            m_fMediaComplete = true;

        break;
        case PE_ONMEDIAERROR:
            m_fLoadError = true;
        break;
    }


    if (m_pTIMEElementBase)
    {
        m_pTIMEElementBase->FireMediaEvent(plEvent);
    }
}

void
CTIMEPlayer::PropChangeNotify(DWORD tePropType)
{
    double dblPlayerRate = 0.0;
    float flTeSpeed = 0.0;
    bool fHaveTESpeed;
    HRESULT hr = S_OK;
    double dblSyncTime;
    double dblSyncTol;
    bool bIsActive;
    double dblSimpleTime;

    if (!m_pTIMEElementBase)
    {
        goto done;
    }

    dblSyncTol = m_pTIMEElementBase->GetRealSyncTolerance();
    bIsActive = m_pTIMEElementBase->IsActive();
    dblSimpleTime = m_pTIMEElementBase->GetMMBvr().GetSimpleTime();

    CTIMEBasePlayer::PropChangeNotify(tePropType);
    
    if ((tePropType & TE_PROPERTY_TIME) != 0)
    {
        TraceTag((tagMediaTimePlayer,
                  "CTIMEPlayer(%lx)::PropChangeNotify(%#x):TE_PROPERTY_TIME",
                  this));
        if (bIsActive && !m_fIsOutOfSync && m_fMediaComplete)
        {   
            if(m_pContainer)
            {
                dblSyncTime = m_pContainer->GetCurrentTime();
                if (dblSyncTime != TIME_INFINITE)
                {
                    dblSyncTime -= m_dblClipStart;
                    if(fabs(dblSyncTime - dblSimpleTime) > dblSyncTol)
                    {
                        if(dblSyncTime < dblSimpleTime)
                        {
                            if(m_fRunning)
                            {
                                m_fIsOutOfSync = true;
                                m_pTIMEElementBase->FireMediaEvent(PE_ONMEDIASLIPSLOW);
                                m_syncType = sync_slow;
                            }
                        }
                        else
                        {
                            m_fIsOutOfSync = true;
                            m_pTIMEElementBase->FireMediaEvent(PE_ONMEDIASLIPFAST);
                            m_syncType = sync_fast;
                        }
                    }
                }
            }
        }

    }
    if ((tePropType & TE_PROPERTY_SPEED) != 0)
    {
        TraceTag((tagMediaTimePlayer,
                  "CTIMEPlayer(%lx)::PropChangeNotify(%#x):TE_PROPERTY_SPEED",
                  this));
        fHaveTESpeed = m_pTIMEElementBase->GetTESpeed(flTeSpeed);
        hr = GetRate(dblPlayerRate);
        if(SUCCEEDED(hr) && fHaveTESpeed)
        {
            if (flTeSpeed <= 0.0)
            {
                Pause();
                goto done;
            } else if(!(m_pTIMEElementBase->IsCurrPaused()) && !m_fRunning && m_fSpeedIsNegative)
            {
                IGNORE_HR(THR(Seek(dblSimpleTime)));
                if(m_pContainer)
                {
                    m_pContainer->Resume();
                }
                m_fSpeedIsNegative = false;
            }

            if (dblPlayerRate != flTeSpeed)
            {
                IGNORE_HR(SetRate((double)flTeSpeed));
            }
        }
    }
  done:
    return;
}



bool
CTIMEPlayer::UpdateSync()
{
    TraceTag((tagMediaTimePlayer,
              "CTIMEPlayer(%lx)::UpdateSync()",
              this));

    bool fRet = true;

    if (!m_pTIMEElementBase)
    {
        goto done;
    }

    double dblSyncTime;
    double dblSyncTol = m_pTIMEElementBase->GetRealSyncTolerance();
    bool bIsActive = m_pTIMEElementBase->IsActive();
    double dblSimpleTime = m_pTIMEElementBase->GetMMBvr().GetSimpleTime();

    if(!m_pContainer)
    {
        goto done;
    }

    dblSyncTime = m_pContainer->GetCurrentTime();

    if (dblSyncTime == TIME_INFINITE)
    {
        goto done;
    }
    
    dblSyncTime -= m_dblClipStart;
    switch(m_syncType)
    {
        case sync_slow:
            TraceTag((tagMediaTimePlayer,
                      "CTIMEPlayer(%lx)::UpdateSync()slow",
                      this));
            if(!bIsActive || m_fHolding)
            {
                m_fIsOutOfSync = false;
                fRet = true;
            }
            else if(fabs(dblSyncTime - dblSimpleTime) <= dblSyncTol / 2.0 || (dblSyncTime > dblSimpleTime + dblSyncTol / 2.0))
            {
                m_fIsOutOfSync = false;
                fRet = true;
            }
            else
            {
                fRet = false;
            }
            break;
        case sync_fast:
            if(!bIsActive || m_fHolding)
            {
                m_fIsOutOfSync = false;
                fRet = true;
            }
            else if((fabs(dblSyncTime - dblSimpleTime) <= dblSyncTol / 2.0) || (dblSimpleTime > dblSyncTime + dblSyncTol / 2.0))
            {
                m_fIsOutOfSync = false;
                fRet = true;
            }
            else
            {
                fRet = false;
            }
            break;
        default:
            break;
    }
done:
    return fRet;
}


HRESULT
CTIMEPlayer::Save(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    HRESULT hr = S_OK;
    if (m_pContainer)
    {
        m_pContainer->Save(pPropBag, fClearDirty, fSaveAllProperties);
    }
    return hr;
}

void 
CTIMEPlayer::ReadyStateNotify(LPWSTR szReadyState)
{
    if (m_pContainer)
    {
        m_pContainer->ReadyStateNotify(szReadyState);
    }
    return;
}

HRESULT
CTIMEPlayer::GetPlayerSize(RECT *prcPos)
{
    HRESULT hr = S_OK;

    if (m_pTIMEElementBase)
    {
        hr = THR(m_pTIMEElementBase->GetSize(prcPos));
    }

    return hr;
}

HRESULT
CTIMEPlayer::SetPlayerSize(const RECT *prcPos)
{
    HRESULT hr = S_OK;

    if (m_pTIMEElementBase)
    {
        hr = THR(m_pTIMEElementBase->SetSize(prcPos));
    }

    return hr;
}

HRESULT
CTIMEPlayer::NegotiateSize(RECT &nativeSize,
                           RECT &finalSize,
                           bool &fIsNative,
                           bool fResetRs)
{
    HRESULT hr = S_OK;

    if (m_pTIMEElementBase)
    {
        m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_MEDIAHEIGHT);
        m_pTIMEElementBase->NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_MEDIAWIDTH);

        hr = THR(m_pTIMEElementBase->NegotiateSize(nativeSize,
                                                   finalSize,
                                                   fIsNative,
                                                   fResetRs));
    }

    return hr;
}

HRESULT
CTIMEPlayer::FireEvents(TIME_EVENT TimeEvent, 
                        long lCount, 
                        LPWSTR szParamNames[], 
                        VARIANT varParams[])
{
    HRESULT hr = S_OK;

    if (m_pTIMEElementBase)
    {
        hr = THR(m_pTIMEElementBase->FireEvents(TimeEvent,
                                                lCount, 
                                                szParamNames, 
                                                varParams));
    }
    if (TimeEvent == TE_ONMEDIAERROR)
    {
        m_fLoadError = true;
    }

    return hr;
}

HRESULT
CTIMEPlayer::FireEventNoErrorState(TIME_EVENT TimeEvent, 
                        long lCount, 
                        LPWSTR szParamNames[], 
                        VARIANT varParams[])
{
    HRESULT hr = S_OK;

    if (m_pTIMEElementBase)
    {
        hr = THR(m_pTIMEElementBase->FireEvents(TimeEvent,
                                                lCount, 
                                                szParamNames, 
                                                varParams));
    }

    return hr;
}

PlayerState
CTIMEPlayer::GetState()
{
    PlayerState state = PLAYER_STATE_INACTIVE;
    
    if (m_pContainer)
    {
        state = m_pContainer->GetState();

        if (state == PLAYER_STATE_ACTIVE &&
            m_fHolding)
        {
            state = PLAYER_STATE_HOLDING;
        }
    }

    return state;
}


HRESULT
CTIMEPlayer::GetIsStreamed(bool &fIsStreamed)
{
    HRESULT hr;
    long lbufCount;

    fIsStreamed = false;

    if (!m_pContainer || m_fLoadError)
    {
        fIsStreamed = false;
        goto done;
    }

    if(m_fIsStreamed)
    {
        fIsStreamed = true;
        goto done;
    }


    hr = m_pContainer->BufferingCount(lbufCount);
    if(FAILED(hr))
    {
        fIsStreamed = false;
        goto done;
    }

    if(lbufCount > 0)
    {
        fIsStreamed = true;
        m_fIsStreamed = true;
    }

  done:
    return S_OK;
}



HRESULT
CTIMEPlayer::GetBufferingProgress(double &dblBufferingProgress)
{
    HRESULT hr;
    double dblBuffeTime;

    if (!m_pContainer || m_fLoadError)
    {
        dblBufferingProgress = 0.0;
        goto done;
    }

    hr = m_pContainer->BufferingProgress(dblBufferingProgress);
    if(FAILED(hr))
    {
        dblBufferingProgress = 0.0;
        goto done;
    }

  done:
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\playerdmusic.cpp ===
// player.cpp : Implementation of CTIMEPlayerDMusic

#include "headers.h"
#include <math.h>
#include "playerdmusic.h"
#include "decibels.h"
#include "importman.h"

DeclareTag(tagPlayerDMusic, "TIME: Players", "CTIMEPlayerDMusic methods");
DeclareTag(tagDMusicStaticHolder, "TIME: DMusicPlayer Static class", "CTIMEPlaerDMusicStaticHolder details");
DeclareTag(tagPlayerSyncDMusic, "TIME: Players", "CTIMEPlayerDMusic sync times");

//////////////////////////////////////////////////////////////////////
// declare DirectMusic IIDs so ATL CComPtrs can CoCreate/QI them

interface DECLSPEC_NOVTABLE __declspec(uuid("07d43d03-6523-11d2-871d-00600893b1bd")) IDirectMusicPerformance;
interface DECLSPEC_NOVTABLE __declspec(uuid("d2ac28bf-b39b-11d1-8704-00600893b1bd")) IDirectMusicComposer;


//////////////////////////////////////////////////////////////////////
// Global Constants

const double g_dblRefPerSec = 10000000;

static WCHAR g_motifName[] = L"motifName";

//////////////////////////////
// segmentType data: begin
static WCHAR g_segmentType[] = L"segmentType";
struct segmentTypeMapEntrie
{
    LPWSTR pstrName;    // Attribute Name
    SEG_TYPE_ENUM enumVal;
};
const segmentTypeMapEntrie segmentTypeMap[] =
{
    L"primary", seg_primary,
    L"secondary", seg_secondary,
    L"control", seg_control,
    L"MAX", seg_max
};
// segmentType data: end
//////////////////////////////

//////////////////////////////
// boundary data: begin
static WCHAR g_boundary[] = L"boundary";
struct boundaryMapEntrie
{
    LPWSTR pstrName;    // Attribute Name
    BOUNDARY_ENUM enumVal;
};
const boundaryMapEntrie boundaryMap[] =
{
    L"default", bound_default,
    L"immediate", bound_immediate,
    L"grid", bound_grid,
    L"beat", bound_beat,
    L"measure", bound_measure,
    L"MAX", bound_max
};
// boundary data: end
//////////////////////////////

//////////////////////////////
// boundary transitionType: begin
static WCHAR g_transitionType[] = L"transitionType";
struct transitionTypeMapEntrie
{
    LPWSTR pstrName;    // Attribute Name
    TRANS_TYPE_ENUM enumVal;
};
const transitionTypeMapEntrie transitionTypeMap[] =
{
    L"endandintro", trans_endandintro,
    L"intro", trans_intro,
    L"end", trans_end,
    L"break", trans_break,
    L"fill", trans_fill,
    L"regular", trans_regular,
    L"none", trans_none,
    L"MAX", trans_max
};
// boundary transitionType: end
//////////////////////////////

static WCHAR g_wszModulate[] = L"modulate";
static WCHAR g_wszLong[] = L"long";
static WCHAR g_wszImmediateEnd[] = L"immediateEnd";

/////////////////////////////////////////////////////////////////////////////
// CTIMEPlayerDMusic

CTIMEDMusicStaticHolder CTIMEPlayerDMusic::m_staticHolder;

#ifdef DBG
static LONG g_lDmusicObjects = 0;
#endif

CComPtr<IBindStatusCallback> g_spLoaderBindStatusCallback;

CTIMEPlayerDMusic::CTIMEPlayerDMusic(CTIMEPlayerDMusicProxy * pProxy) :
    m_rtStart(0),
    m_ePlaybackState(playback_stopped),
    m_eSegmentType(seg_primary),
    m_eBoundary(bound_default),
    m_eTransitionType(trans_endandintro),
    m_fTransModulate(false),
    m_fTransLong(false),
    m_fImmediateEnd(false),
    m_cRef(0),
    m_pTIMEMediaElement(NULL),
    m_bActive(false),
    m_fRunning(false),
    m_fAudioMute(false),
    m_rtPause(0),
    m_flVolumeSave(0.0),
    m_fLoadError(false),
    m_pwszMotif(NULL),
    m_fSegmentTypeSet(false),
    m_lSrc(0),
    m_lBase(0),
    m_pTIMEMediaPlayerStream(NULL),
    m_fRemoved(false),
    m_fHavePriority(false),
    m_dblPriority(0),
    m_fUsingInterfaces(false),
    m_fNeedToReleaseInterfaces(false),
    m_fHaveCalledStaticInit(false),
    m_fAbortDownload(false),
    m_hrSetSrcReturn(S_OK),
    m_pProxy(pProxy),
    m_fHasSrc(false),
    m_fMediaComplete(false),
    m_dblPlayerRate(1.0),
    m_dblSpeedChangeTime(0.0),
    m_dblSyncTime(0.0),
    m_fSpeedIsNegative(false)
{
#ifdef DBG
    InterlockedIncrement(&g_lDmusicObjects);
#endif
}

CTIMEPlayerDMusic::~CTIMEPlayerDMusic()
{
    ReleaseInterfaces();
     
    m_pTIMEMediaElement = NULL;

    ReleaseInterface(m_pTIMEMediaPlayerStream);
    delete m_pProxy;
    delete [] m_pwszMotif;
#ifdef DBG
    InterlockedDecrement(&g_lDmusicObjects);
#endif
}

//////////////////////////////////////////////////////////////////////
// ITIMEMediaPlayer

HRESULT
CTIMEPlayerDMusic::Init(CTIMEMediaElement *pelem, LPOLESTR base, LPOLESTR src, LPOLESTR lpMimeType, double dblClipBegin, double dblClipEnd)
{
    TraceTag((tagPlayerDMusic,
              "CTIMEPlayerDMusic(%p)::Init",
              this));

    HRESULT hr = E_FAIL;
    
    
    if (m_pTIMEElementBase != NULL) //this only happens in the case of reentrancy
    {
        hr = S_OK;
        goto done;
    }

    hr = CTIMEBasePlayer::Init(pelem, base, src, lpMimeType, dblClipBegin, dblClipEnd);
    if (FAILED(hr))
    {
        goto done;
    }

    m_fHasSrc = (src != NULL);
    m_pTIMEMediaElement = pelem;

    // If DirectMusic is not installed, all operations silently succeed.
    if (!m_staticHolder.HasDM())
    {
        hr = S_OK;
        goto done;
    }

    // initialize performer and composer interfaces

    m_fHaveCalledStaticInit = true;
    hr = m_staticHolder.Init();
    if (FAILED(hr))
    {
        goto done;
    }

    if( dblClipBegin != -1.0)
    {
        m_dblClipStart = dblClipBegin;
    }

    if( dblClipEnd != -1.0)
    {
        m_dblClipEnd = dblClipEnd;
    }

    hr = THR(CoMarshalInterThreadInterfaceInStream(IID_ITIMEImportMedia, static_cast<ITIMEImportMedia*>(this), &m_pTIMEMediaPlayerStream));
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(GetAtomTable());

    hr = GetAtomTable()->AddNameToAtomTable(src, &m_lSrc);
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = GetAtomTable()->AddNameToAtomTable(base, &m_lBase);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = ReadAttributes();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetImportManager()->Add(this);
    if (FAILED(hr))
    {
        goto done;
    }
    
    m_fLoadError = false;
    hr = S_OK;
    
done:
    RRETURN( hr );
}

HRESULT
CTIMEPlayerDMusic::clipBegin(VARIANT varClipBegin)
{
    return E_NOTIMPL;
}

HRESULT
CTIMEPlayerDMusic::clipEnd(VARIANT varClipEnd)
{
    return E_NOTIMPL;
}

void
CTIMEPlayerDMusic::Start()
{
    TraceTag((tagPlayerDMusic,
              "CTIMEDshowPlayer(%lx)::Start()",
              this));

    IGNORE_HR(Reset());

done:
    return;
}

void
CTIMEPlayerDMusic::InternalStart()
{
    HRESULT hr = S_OK;
    bool fTransition = false;
    // If DirectMusic is not installed, all operations silently succeed.
    if (!m_staticHolder.HasDM())
    {
        goto done;
    }

    if(m_pTIMEElementBase && m_pTIMEElementBase->IsThumbnail())
    {
        goto done;
    }

    if(!m_fMediaComplete)
    {
        goto done;
    }
    
    if (!m_staticHolder.GetPerformance() || !m_comIDMSegment || !m_staticHolder.GetComposer())
    {
        goto done;
    }
    
    // Release anything that was already playing, but don't stop it.
    // Primary segments will stop automatically when the new one plays.
    // Secondary segments should just continue even though they are about to be played again.
    if (m_comIDMSegmentState)
    {
        m_comIDMSegmentState.Release();
    }
    if (m_comIDMSegmentStateTransition)
    {
        m_comIDMSegmentStateTransition.Release();
    }
    
    // If we have been paused, the start point may be part way through but we want to start from the beginning.
    hr = m_comIDMSegment->SetStartPoint(0);
    if (FAILED(hr))
    {
        goto done;
    }
    fTransition = m_eSegmentType == seg_primary && m_eTransitionType != trans_none && SafeToTransition();
    if (fTransition)
    {
        // try and transition to new primary segment
        
        DWORD dwFlags = 0;
        switch (m_eBoundary)
        {
        case bound_default:             dwFlags = 0;                                            break;
        case bound_immediate:           dwFlags = DMUS_COMPOSEF_IMMEDIATE;      break;
        case bound_grid:                dwFlags = DMUS_COMPOSEF_GRID;           break;
        case bound_beat:                dwFlags = DMUS_COMPOSEF_BEAT;           break;
        case bound_measure:             dwFlags = DMUS_COMPOSEF_MEASURE;        break;
        }; //lint !e787
        
        WORD wCommand = 0;
        switch (m_eTransitionType)
        {
        case trans_endandintro:                 wCommand = DMUS_COMMANDT_ENDANDINTRO;           break;
        case trans_intro:                       wCommand = DMUS_COMMANDT_INTRO;                 break;
        case trans_end:                         wCommand = DMUS_COMMANDT_END;                   break;
        case trans_break:                       wCommand = DMUS_COMMANDT_BREAK;                 break;
        case trans_fill:                        wCommand = DMUS_COMMANDT_FILL;                  break;
        case trans_regular:                     wCommand = DMUS_COMMANDT_GROOVE;                break;
        }; //lint !e787
        
        if (m_fTransModulate)
        {
            dwFlags |= DMUS_COMPOSEF_MODULATE;
        }
        if (m_fTransLong)
        {
            dwFlags |= DMUS_COMPOSEF_LONG;
        }
        
        // If DirectX8 version, check to see if the segment is using an embedded audiopath
        if (m_staticHolder.GetHasVersion8DM())
        {
            if (m_eTransitionType == trans_intro)
            {
                // Check new segment

                // If the segment is set to play on its embedded audiopath, set DMUS_COMPOSEF_USE_AUDIOPATH
                DWORD dwDefault = 0;
                hr = m_comIDMSegment->GetDefaultResolution(&dwDefault);
                if (SUCCEEDED(hr) && (dwDefault & DMUS_SEGF_USE_AUDIOPATH) )
                {
                    dwFlags |= DMUS_COMPOSEF_USE_AUDIOPATH;
                }
            }
            else
            {
                // Check old segment

                // Get current time
                MUSIC_TIME mtNow;
                hr = m_staticHolder.GetPerformance()->GetTime( NULL, &mtNow );

                // Get segment state at the current time
                CComPtr<IDirectMusicSegmentState> comIDMSegmentStateNow;
                if (SUCCEEDED(hr))
                {
                    hr = m_staticHolder.GetPerformance()->GetSegmentState( &comIDMSegmentStateNow, mtNow );
                }

                // Get segment from that segment state
                CComPtr<IDirectMusicSegment> comIDMSegmentNow;
                if (SUCCEEDED(hr) && comIDMSegmentStateNow)
                {
                    hr = comIDMSegmentStateNow->GetSegment( &comIDMSegmentNow );
                }

                // Get the segment's default flags
                DWORD dwDefault = 0;
                if (SUCCEEDED(hr) && comIDMSegmentNow )
                {
                    hr = comIDMSegmentNow->GetDefaultResolution(&dwDefault);
                }

                // If the segment was set to play on its embedded audiopath, set DMUS_COMPOSEF_USE_AUDIOPATH
                if (SUCCEEDED(hr) && (dwDefault & DMUS_SEGF_USE_AUDIOPATH) )
                {
                    dwFlags |= DMUS_COMPOSEF_USE_AUDIOPATH;
                }

                if (comIDMSegmentNow)
                {
                    comIDMSegmentNow.Release();
                }

                if (comIDMSegmentStateNow)
                {
                    comIDMSegmentStateNow.Release();
                }
            }
        }
        hr = m_staticHolder.GetComposer()->AutoTransition(m_staticHolder.GetPerformance(), m_comIDMSegment, wCommand, dwFlags, NULL, NULL, &m_comIDMSegmentState, &m_comIDMSegmentStateTransition);
    }
    
    if (!fTransition || FAILED(hr))
    {
        // no transition - just play it
        
        DWORD dwFlags = 0;
        switch (m_eSegmentType)
        {
        case seg_primary:               dwFlags = 0;                                    break;
        case seg_secondary:             dwFlags = DMUS_SEGF_SECONDARY;  break;
        case seg_control:               dwFlags = DMUS_SEGF_CONTROL;    break;
        };  //lint !e787
        
        switch (m_eBoundary)
        {
        case bound_default:             dwFlags |= DMUS_SEGF_DEFAULT;   break;
        case bound_immediate:           dwFlags |= 0;                                   break;
        case bound_grid:                dwFlags |= DMUS_SEGF_GRID;              break;
        case bound_beat:                dwFlags |= DMUS_SEGF_BEAT;              break;
        case bound_measure:             dwFlags |= DMUS_SEGF_MEASURE;   break;
        };  //lint !e787

        // If DirectX8 version, check to see if the segment is using an embedded audiopath
        if (m_staticHolder.GetHasVersion8DM())
        {
            // If the segment is set to play on its embedded audiopath, set DMUS_SEGF_USE_AUDIOPATH
            DWORD dwDefault = 0;
            hr = m_comIDMSegment->GetDefaultResolution(&dwDefault);
            if (SUCCEEDED(hr) && (dwDefault & DMUS_SEGF_USE_AUDIOPATH) )
            {
                dwFlags |= DMUS_SEGF_USE_AUDIOPATH;
            }
        }
        
        hr = m_staticHolder.GetPerformance()->PlaySegment(m_comIDMSegment, dwFlags, 0, &m_comIDMSegmentState); //lint !e747
    }
    
    if (SUCCEEDED(hr))
    {
        hr = m_staticHolder.GetPerformance()->GetTime(&m_rtStart, NULL);
        m_ePlaybackState = playback_playing;
    }
    
    m_bActive = true;
    m_fLoadError = false;
    
done:
    
    return;
}

void
CTIMEPlayerDMusic::Repeat()
{

    if(!m_fMediaComplete)
    {
        goto done;
    }
    InternalStart();
done:
    return;
}

void
CTIMEPlayerDMusic::Stop(void)
{
    HRESULT hr = S_OK;
    // If DirectMusic is not installed, all operations silently succeed.
    if (!m_staticHolder.HasDM())
    {
        goto done;
    }

    if(!m_fMediaComplete)
    {
        goto done;
    }
    
    m_ePlaybackState = playback_stopped;
    
    if (m_staticHolder.GetPerformance())
    {
        bool fPlayingEndTransition = false;
        if (m_comIDMSegmentState)
        {
            bool fEnding = m_eSegmentType == seg_primary && m_eTransitionType != trans_none && !m_fImmediateEnd && SafeToTransition();

            // Only play an ending if either the transition segment or the main segment are playing
            if( m_comIDMSegmentStateTransition )
            {
                // If we played a transition segment, check if either the main segment state or the transition segment state are playing
                fEnding = fEnding && ((S_OK == m_staticHolder.GetPerformance()->IsPlaying(NULL, m_comIDMSegmentState)) ||
                                      (S_OK == m_staticHolder.GetPerformance()->IsPlaying(NULL, m_comIDMSegmentStateTransition)));
            }
            else
            {
                // Otherwise, just check if the main segment state is playing
                fEnding = fEnding && (S_OK == m_staticHolder.GetPerformance()->IsPlaying(NULL, m_comIDMSegmentState));
            }

            if (fEnding)
            {
                // try and play an ending
                hr = m_staticHolder.GetComposer()->AutoTransition(m_staticHolder.GetPerformance(), NULL, DMUS_COMMANDT_END, m_fTransLong ? DMUS_COMPOSEF_LONG : 0, NULL, NULL, NULL, NULL);

                if (SUCCEEDED(hr))
                {
                    fPlayingEndTransition = true;
                }
            }
            
            if (!fEnding || FAILED(hr))
            {
                DWORD dwFlags = 0;
                if (!m_fImmediateEnd)
                {
                    switch (m_eBoundary)
                    {
                    case bound_default:             dwFlags = DMUS_SEGF_MEASURE;            break;
                    case bound_immediate:           dwFlags = 0;                            break;
                    case bound_grid:                dwFlags = DMUS_SEGF_GRID;               break;
                    case bound_beat:                dwFlags = DMUS_SEGF_BEAT;               break;
                    case bound_measure:             dwFlags = DMUS_SEGF_MEASURE;            break;
                    }; //lint !e787
                }

                // stop immediately
                hr = m_staticHolder.GetPerformance()->Stop(NULL, m_comIDMSegmentState, 0, dwFlags);
            }
            
            m_comIDMSegmentState.Release();
        }
        
        if (m_comIDMSegmentStateTransition)
        {
            if (!fPlayingEndTransition)
            {
                hr = m_staticHolder.GetPerformance()->Stop(NULL, m_comIDMSegmentStateTransition, 0, 0);
            }

            m_comIDMSegmentStateTransition.Release();
        }
    }
    
    m_bActive = false;
    
done:
    return;
}

PlayerState 
CTIMEPlayerDMusic::GetState()
{
    PlayerState state;
    if (!m_bActive)
    {
        if (!m_fMediaComplete)
        {
            state = PLAYER_STATE_CUEING;
        }
        else
        {
            state = PLAYER_STATE_INACTIVE;
        }
    }
    else
    {
        state = PLAYER_STATE_ACTIVE;
        goto done;
    }
    
    //state = PLAYER_STATE_HOLDING;
    
done:
    
    return state;
}

void
CTIMEPlayerDMusic::Resume(void)
{
    float flTeSpeed = 0.0;
    bool fHaveTESpeed;

    if(!m_pTIMEElementBase)
    {
        goto done;
    }

    if(m_fSpeedIsNegative)
    {
        goto done;
    }
        
    fHaveTESpeed = m_pTIMEElementBase->GetTESpeed(flTeSpeed);

    if(fHaveTESpeed && flTeSpeed < 0.0)
    {
        goto done;
    }

    // If DirectMusic is not installed, all operations silently succeed.
    if (!m_staticHolder.HasDM())
    {
        goto done;
    }

    if(!m_fMediaComplete)
    {
        goto done;
    }
            
    ResumeDmusic();

    m_fRunning = false;
    
done:
    return;
}

void
CTIMEPlayerDMusic::ResumeDmusic(void)
{
    HRESULT hr = S_OK;

    if (m_ePlaybackState == playback_paused)
    {
        REFERENCE_TIME rtElapsedBeforePause = m_rtPause - m_rtStart;
        
        // Resume the segment with the correct type.
        // Ignore all the other flags about transitions and playing on measure/beat boundaries because resume is an instantaneous sort of thing.
        DWORD dwFlags = 0;
        switch (m_eSegmentType)
        {
        case seg_primary:               dwFlags = 0;                    break;
        case seg_secondary:             dwFlags = DMUS_SEGF_SECONDARY;  break;
        case seg_control:               dwFlags = DMUS_SEGF_CONTROL;    break;
        };  //lint !e787
        hr = m_staticHolder.GetPerformance()->PlaySegment(m_comIDMSegment, dwFlags, 0, &m_comIDMSegmentState); //lint !e747
        if (FAILED(hr))
        {
            goto done;
        }
        hr = m_staticHolder.GetPerformance()->GetTime(&m_rtStart, NULL);
        if (FAILED(hr))
        {
            goto done;
        }
        m_rtStart -= rtElapsedBeforePause; // so time will continue counting from point where we left off
        
        m_ePlaybackState = playback_playing;
    }
done:
    return;
}

void
CTIMEPlayerDMusic::Pause(void)
{
    HRESULT hr = S_OK;
    bool fPausedDuringTransition = false;
    // If DirectMusic is not installed, all operations silently succeed.
    if (!m_staticHolder.HasDM())
    {
        goto done;
    }

    if(!m_fMediaComplete)
    {
        goto done;
    }
    
    if (m_comIDMSegmentStateTransition)
    {
        // If pause happens while we were transitioning, then we'll stop playing and resume will start
        // playing the segment at its beginning.  (We aren't going to try and pick up where you left off
        // in the transition.)
        
        hr = m_staticHolder.GetPerformance()->IsPlaying(NULL, m_comIDMSegmentStateTransition);
        if (FAILED(hr))
        {
            goto done;
        }
        
        if (hr == S_OK)
        {
            fPausedDuringTransition = true;
            hr = m_staticHolder.GetPerformance()->Stop(NULL, m_comIDMSegmentStateTransition, 0, 0);
            if (FAILED(hr))
            {
                goto done;
            }
        }
        m_comIDMSegmentStateTransition.Release();
    }
    
    if (m_comIDMSegmentState)
    {
        MUSIC_TIME mtStartTime = 0;
        MUSIC_TIME mtStartPoint = 0;
        if (!fPausedDuringTransition)
        {
            hr = m_comIDMSegmentState->GetStartTime(&mtStartTime);
            if (FAILED(hr))
            {
                goto done;
            }
            
            hr = m_comIDMSegmentState->GetStartPoint(&mtStartPoint);
            if (FAILED(hr))
            {
                goto done;
            }
        }
        
        hr = m_staticHolder.GetPerformance()->Stop(NULL, m_comIDMSegmentState, 0, 0);
        if (FAILED(hr))
        {
            goto done;
        }
        
        MUSIC_TIME mtNow = 0;
        hr = m_staticHolder.GetPerformance()->GetTime(&m_rtPause, &mtNow);
        if (FAILED(hr))
        {
            goto done;
        }
        
        m_comIDMSegmentState.Release();
        hr = m_comIDMSegment->SetStartPoint(fPausedDuringTransition ? 0 : mtNow - mtStartTime + mtStartPoint);
        if (FAILED(hr))
        {
            goto done;
        }
    }
    
    m_ePlaybackState = playback_paused;
    m_fRunning = false;
    
done:
    
    return;
}

void
CTIMEPlayerDMusic::OnTick(double dblSegmentTime, LONG lCurrRepeatCount)
{
    return;
}

STDMETHODIMP
CTIMEPlayerDMusic::put_CurrentTime(double   dblCurrentTime)
{
    return S_OK;
}

STDMETHODIMP
CTIMEPlayerDMusic::get_CurrentTime(double* pdblCurrentTime)
{
#ifdef OUTTIME
    OutputDebugString("@ get_CurrentTime\n"); // 
#endif
    HRESULT hr = S_OK;
    
    if (IsBadWritePtr(pdblCurrentTime, sizeof(double)))
        return E_POINTER;
    
    // If DirectMusic is not installed, all operations silently succeed.
    if (!m_staticHolder.HasDM())
    {
        // Pretend we're already done playing. This way the page will count for us.
        *pdblCurrentTime = HUGE_VAL;
        hr = S_OK;
        goto done;
    }

    if(!m_fMediaComplete)
    {
        *pdblCurrentTime = HUGE_VAL;
        hr = S_OK;
        goto done;
    }
    
    if (m_ePlaybackState == playback_playing)
    {
        if (!m_comIDMSegmentState)
            return E_FAIL;
        
        hr = m_staticHolder.GetPerformance()->IsPlaying(NULL, m_comIDMSegmentState);
        if (hr == S_OK)
        {
            REFERENCE_TIME rtNow = 0;
            hr = m_staticHolder.GetPerformance()->GetTime(&rtNow, 0);
            if (FAILED(hr))
                return hr;
            *pdblCurrentTime = (rtNow - m_rtStart) / g_dblRefPerSec;
        }
        else
        {
            *pdblCurrentTime = HUGE_VAL;
        }
    }
    else
    {
        if (m_ePlaybackState == playback_paused)
        {
            *pdblCurrentTime = (m_rtPause - m_rtStart) / g_dblRefPerSec;
        }
        else
        {
            *pdblCurrentTime = -HUGE_VAL;
        }
    }
    
#ifdef OUTTIME
    char msg[512] = "";
    sprintf(msg, "  reported time %f\n", *pdblCurrentTime);
    OutputDebugString(msg);
#endif
done:
    return hr;
}


STDMETHODIMP_(ULONG)
CTIMEPlayerDMusic::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG)
CTIMEPlayerDMusic::Release(void)
{
    LONG l = InterlockedDecrement(&m_cRef);

    if (0 == l)
    {
        delete this;
    }

    return l;
}

HRESULT
CTIMEPlayerDMusic::Render(HDC hdc, LPRECT prc)
{
    //E_NOTIMPL
    return S_OK;
}

HRESULT 
CTIMEPlayerDMusic::SetSize(RECT *prect)
{
    //E_NOTIMPL
    return S_OK;
}

HRESULT 
CTIMEPlayerDMusic::DetachFromHostElement (void)
{
    m_fAbortDownload = true;
    m_fRemoved = true;

    Assert(GetImportManager());

    IGNORE_HR(GetImportManager()->Remove(this));

    {
        CritSectGrabber cs(m_CriticalSection);
    
        if (m_fUsingInterfaces)
        {
            m_fNeedToReleaseInterfaces = true;
        }
        else
        {
            ReleaseInterfaces();
        }
    }

    if (m_fHaveCalledStaticInit)
    {
        m_staticHolder.ReleaseInterfaces();
    }
    else
    {
        m_fHaveCalledStaticInit = false;  // no-op for breakpoints
    }
    
done:
    return S_OK;
}

HRESULT
CTIMEPlayerDMusic::ReleaseInterfaces()
{
    // Stop and release everything associated with this segment
    if (m_comIDMSegmentState)
    {
        m_staticHolder.GetPerformance()->Stop(NULL, m_comIDMSegmentState, 0, 0);
        m_comIDMSegmentState.Release();
    }
    if (m_comIDMSegmentStateTransition)
    {
        m_staticHolder.GetPerformance()->Stop(NULL, m_comIDMSegmentStateTransition, 0, 0);
        m_comIDMSegmentStateTransition.Release();
    }
    if (m_comIDMSegment)
    {
        m_comIDMSegment.Release();
    }
    
    RRETURN( S_OK );
}

HRESULT 
CTIMEPlayerDMusic::InitElementSize()
{
    //E_NOTIMPL
    return S_OK;
}


HRESULT
CTIMEPlayerDMusic::ReadAttributes()
{
    HRESULT hr = S_OK;

    VARIANT var;
    VARIANT varMotif;
    int i;

    VariantInit(&varMotif);

    VariantInit(&var);
    hr = ::GetHTMLAttribute(GetElement(), g_motifName, &var);
    if (SUCCEEDED(hr))
    {
        hr = THR(VariantChangeTypeEx(&var, &var, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR));
        if (SUCCEEDED(hr))
        {
            VariantCopy(&varMotif, &var);
            m_pwszMotif = CopyString(varMotif.bstrVal);
        }
        VariantClear(&var);
    }
    
    VariantInit(&var);
    hr = ::GetHTMLAttribute(GetElement(), g_segmentType, &var);
    if (SUCCEEDED(hr))
    {
        hr = THR(VariantChangeTypeEx(&var, &var, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR));
        if (SUCCEEDED(hr))
        {
            for(i = 0; i < (int)seg_max - (int)seg_primary; i++)
            {
                if(StrCmpIW(segmentTypeMap[i].pstrName, var.bstrVal) == 0)
                {
                    m_eSegmentType = segmentTypeMap[i].enumVal;
                    m_fSegmentTypeSet = true;
                    break;
                }
            }
        }
        VariantClear(&var);
    }
    
    VariantInit(&var);
    hr = ::GetHTMLAttribute(GetElement(), g_boundary, &var);
    if (SUCCEEDED(hr))
    {
        hr = THR(VariantChangeTypeEx(&var, &var, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR));
        if (SUCCEEDED(hr))
        {
            for(i = 0; i < (int)bound_max - (int)bound_default; i++)
            {
                if(StrCmpIW(boundaryMap[i].pstrName, var.bstrVal) == 0)
                {
                    m_eBoundary = boundaryMap[i].enumVal;
                    break;
                }
            }
        }
        VariantClear(&var);
    }
    
    VariantInit(&var);
    hr = ::GetHTMLAttribute(GetElement(), g_transitionType, &var);
    if (SUCCEEDED(hr))
    {
        hr = THR(VariantChangeTypeEx(&var, &var, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR));
        if (SUCCEEDED(hr))
        {
            for(i = 0; i < (int)trans_max - (int)trans_endandintro; i++)
            {
                if(StrCmpIW(transitionTypeMap[i].pstrName, var.bstrVal) == 0)
                {
                    m_eTransitionType = transitionTypeMap[i].enumVal;
                    break;
                }
            }
        }
        VariantClear(&var);
    }
    
    VariantInit(&var);
    hr = ::GetHTMLAttribute(GetElement(), g_wszModulate, &var);
    if (SUCCEEDED(hr))
    {
        hr = THR(VariantChangeTypeEx(&var, &var, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR));
        if (SUCCEEDED(hr))
        {
            if(StrCmpIW(L"true", var.bstrVal) == 0)
            {
                m_fTransModulate = true;
            }
            else if(StrCmpIW(L"false", var.bstrVal) == 0)
            {
                m_fTransModulate = false;
            }
        }
        VariantClear(&var);
    }
    
    VariantInit(&var);
    hr = ::GetHTMLAttribute(GetElement(), g_wszLong, &var);
    if (SUCCEEDED(hr))
    {
        hr = THR(VariantChangeTypeEx(&var, &var, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR));
        if (SUCCEEDED(hr))
        {
            if(StrCmpIW(L"true", var.bstrVal) == 0)
            {
                m_fTransLong = true;
            }
            else if(StrCmpIW(L"false", var.bstrVal) == 0)
            {
                m_fTransLong = false;
            }
        }
        VariantClear(&var);
    }
    
    VariantInit(&var);
    hr = ::GetHTMLAttribute(GetElement(), g_wszImmediateEnd, &var);
    if (SUCCEEDED(hr))
    {
        hr = THR(VariantChangeTypeEx(&var, &var, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR));
        if (SUCCEEDED(hr))
        {
            if(StrCmpIW(L"true", var.bstrVal) == 0)
            {
                m_fImmediateEnd = true;
            }
            else if(StrCmpIW(L"false", var.bstrVal) == 0)
            {
                m_fImmediateEnd = false;
            }
        }
        VariantClear(&var);
    }

    VariantClear(&varMotif);
    return S_OK;
}

HRESULT
CTIMEPlayerDMusic::SetSrc(LPOLESTR base, LPOLESTR src)
{
    TraceTag((tagPlayerDMusic,
              "CTIMEPlayerDMusic(%lx)::SetSrc()\n",
              this));

    HRESULT hr = S_OK;
    int trackNr = 0;
    
    BSTR bstrSrc = NULL;
    
    LPWSTR szSrc = NULL;
    
    m_fHasSrc = (src != NULL);
    hr = THR(::TIMECombineURL(base, src, &szSrc));
    if (!szSrc)
    {
        hr = E_FAIL;
        goto done;
    }
    if (FAILED(hr))
    {
        goto done;
    }
    
    // If DirectMusic is not installed, all operations silently succeed.
    if (!m_staticHolder.HasDM())
    {
        goto done;
    }
    
    Stop();
    
    if (!m_staticHolder.GetLoader() || !m_staticHolder.GetPerformance())
    {
        hr = E_UNEXPECTED;
        goto done;
    }
    
    if (m_comIDMSegment)
    {
        // unload the previous segment's sounds
        
        // with DX8 components, the third parameter should be DMUS_SEG_ALLTRACKS // 
        for(trackNr = 0,hr = S_OK; SUCCEEDED(hr); trackNr++)
        {
            hr = m_comIDMSegment->SetParam(GUID_Unload, 0xFFFFFFFF, trackNr, 0, m_staticHolder.GetPerformance());
        }
        if( hr == DMUS_E_TRACK_NOT_FOUND)
        {
            hr = S_OK;
        }
        if (FAILED(hr))
        {
            goto done;
        }
        m_comIDMSegment.Release();
    }

    
    // Use a special interface on our loader that gets the segment and uses its URL as the base for
    // for resolving relative filenames that it in turn loads.
    bstrSrc = SysAllocString(szSrc);
    if (bstrSrc == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }   
    
    hr = m_staticHolder.GetLoader()->GetSegment(bstrSrc, &m_comIDMSegment);
    SysFreeString(bstrSrc);
    if (FAILED(hr))
    {
        goto done;
    }
    
    // If there's a reference to a motif, try and get it
    if (m_pwszMotif)
    {
        // get the current style
        IDirectMusicStyle *pStyle = NULL;
        hr = m_comIDMSegment->GetParam(GUID_IDirectMusicStyle, 0xFFFFFFFF, 0, 0, NULL, &pStyle);
        m_comIDMSegment.Release(); // This segment is no longer of interest. We just want the motif segment inside its style.
        if (FAILED(hr))
        {
            goto done;
        }
        

        hr = pStyle->GetMotif(m_pwszMotif, &m_comIDMSegment);
        pStyle->Release();
        pStyle = NULL;
        if (hr == S_FALSE)
        {
            hr = E_FAIL; // S_FALSE indicates the motif wan't found.  We'll treat that as a failure.
        }
        if (FAILED(hr))
        {
            m_comIDMSegment.Release();
            goto done;
        }
        
        // motifs play as secondary segments by default
        if (!m_fSegmentTypeSet)
        {
            m_eSegmentType = seg_secondary;
        }
    }
    
    // Download its DLS data
    // with DX8 components, the third parameter should be DMUS_SEG_ALLTRACKS // 
    for(trackNr = 0,hr = S_OK; SUCCEEDED(hr); trackNr++)
    {
        hr = m_comIDMSegment->SetParam(GUID_Download, 0xFFFFFFFF, trackNr, 0, m_staticHolder.GetPerformance()); // load the segment's sounds
    }
    if (hr == DMUS_E_TRACK_NOT_FOUND)
    {
        hr = S_OK; // it's OK if the track doesn't have bands of its own to download
    }
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
    TraceTag((tagPlayerDMusic,
              "CTIMEPlayerDMusic(%lx)::SetSrc() done\n",
              this));
    
done:
    if (FAILED(hr))
    {
        m_hrSetSrcReturn = hr;

        m_fLoadError = true;
    }

    delete[] szSrc;
    
    return hr;
}

STDMETHODIMP
CTIMEPlayerDMusic::put_repeat(long lTime)
{
    // Set the segment's repeat count.  This seems to be called when the repeat property of
    // the player object is set.  Note that this repeats based on the segment's internal loop
    // points -- not based on the repeat attribute on the media tag which is based on end/dur
    // attribute in the tag.
    
    // If DirectMusic is not installed, all operations silently succeed.
    if (!m_staticHolder.HasDM())
        return S_OK;
    if(!m_fMediaComplete)
    {
        return S_OK;
    }
    
    if (!m_comIDMSegment)
        return E_UNEXPECTED;
    
    return m_comIDMSegment->SetRepeats(lTime);
}

STDMETHODIMP
CTIMEPlayerDMusic::get_repeat(long* plTime)
{
    // Get the segment's repeat count.  This seems to be called when the repeat property of
    // the player object is read.  Note that this repeats based on the segment's internal loop
    // points -- not based on the repeat attribute on the media tag which is based on end/dur
    // attribute in the tag.
    
    if (IsBadWritePtr(plTime, sizeof(long*)))
        return E_POINTER;
    
    // If DirectMusic is not installed, all operations silently succeed.
    if (!m_staticHolder.HasDM())
    {
        *plTime = 1;
        return S_OK;
    }
    
    DWORD dwRepeats;
    HRESULT hr = m_comIDMSegment->GetRepeats(&dwRepeats);
    if (FAILED(hr))
        return hr;
    
    *plTime = dwRepeats;
    return S_OK;
}

STDMETHODIMP
CTIMEPlayerDMusic::cue(void)
{
    return E_NOTIMPL;
}

//
// IDirectMusicPlayer
//

bool
CTIMEPlayerDMusic::SafeToTransition()
{
    // In DirectX 6.1, there is a bug (Windows NT Bugs 265900) where AutoTransition will GPF if
    // the currently-playing segment does not contain a chord track.  We need to detect this and
    // avoid trying to transition.

    if (m_staticHolder.GetVersionDM() == dmv_70orlater)
        return true; // bug is fixed

    MUSIC_TIME mtNow = 0;
    HRESULT hr = m_staticHolder.GetPerformance()->GetTime(NULL, &mtNow);
    if (FAILED(hr))
        return false;

    CComPtr<IDirectMusicSegmentState> comIDMSegmentStateCurrent;
    hr = m_staticHolder.GetPerformance()->GetSegmentState(&comIDMSegmentStateCurrent, mtNow);
    if (FAILED(hr) || !comIDMSegmentStateCurrent)
        return false;

    CComPtr<IDirectMusicSegment> comIDMSegmentCurrent;
    hr = comIDMSegmentStateCurrent->GetSegment(&comIDMSegmentCurrent);
    if (FAILED(hr) || !comIDMSegmentCurrent)
        return false;

    CComPtr<IDirectMusicTrack> comIDMTrackCurrentChords;
    hr = comIDMSegmentCurrent->GetTrack(CLSID_DirectMusicChordTrack, 0xFFFFFFFF, 0, &comIDMTrackCurrentChords);
    if (FAILED(hr) || !comIDMTrackCurrentChords)
        return false;

    // Whew!
    // We have a chord track so it is OK to do the transition.
    return true;
}

STDMETHODIMP
CTIMEPlayerDMusic::get_isDirectMusicInstalled(VARIANT_BOOL *pfInstalled)
{
    bool bIsInstalled = false;
    if (IsBadWritePtr(pfInstalled, sizeof(BOOL)))
        return E_POINTER;
    
    bIsInstalled = m_staticHolder.HasDM();

    if(bIsInstalled)
    {
        *pfInstalled = VARIANT_TRUE;
    }
    else
    {
        *pfInstalled = VARIANT_FALSE;
    }
    return S_OK;
}

double 
CTIMEPlayerDMusic::GetCurrentTime()
{
    HRESULT hr = S_OK;
    double dblCurrentTime = 0.0;

    if (!m_staticHolder.HasDM() || m_fMediaComplete == false)
    {
        dblCurrentTime = 0.0;
        goto done;
    }

    if (m_ePlaybackState == playback_playing)
    {
        if (!m_comIDMSegmentState)
        {
            dblCurrentTime = 0.0;
            goto done;
        }

        hr = m_staticHolder.GetPerformance()->IsPlaying(NULL, m_comIDMSegmentState);
        if (hr == S_OK)
        {
            REFERENCE_TIME rtNow = 0;
            hr = m_staticHolder.GetPerformance()->GetTime(&rtNow, 0);
            if (FAILED(hr))
            {
                dblCurrentTime = 0.0;
                goto done;
            }

            dblCurrentTime = ((rtNow - m_rtStart) / g_dblRefPerSec) * m_dblPlayerRate + m_dblSpeedChangeTime;
            TraceTag((tagPlayerSyncDMusic,
                      "CTIMEDshowPlayer(%lx)::SyncTime(%f)(%f)",
                      this, dblCurrentTime, m_dblSpeedChangeTime));

        }
        else
        {
            dblCurrentTime = 0.0;
            goto done;
        }
    }
    else
    {
        if (m_ePlaybackState == playback_paused)
        {
            dblCurrentTime = ((m_rtPause - m_rtStart) / g_dblRefPerSec) * m_dblPlayerRate + m_dblSpeedChangeTime;
        }
        else
        {
            dblCurrentTime = 0.0;
            goto done;
        }
    }

    hr = S_OK;

done:
    return dblCurrentTime;
}

HRESULT 
CTIMEPlayerDMusic::GetCurrentSyncTime(double & dblCurrentTime)
{
    HRESULT hr;
    float flTeSpeed = 0.0;
    bool fHaveTESpeed;

    if(m_pTIMEElementBase == NULL)
    {
        hr = S_FALSE;
        goto done;
    }

    if (!m_staticHolder.HasDM() || m_fLoadError)
    {
        hr = S_FALSE;
        goto done;
    }

    fHaveTESpeed = m_pTIMEElementBase->GetTESpeed(flTeSpeed);
    if(fHaveTESpeed)
    {
        if(flTeSpeed < 0.0)
        {
            hr = S_FALSE;
            goto done;
        }
    }

    if(!m_bActive)
    {
        dblCurrentTime = m_dblSyncTime;
        hr = S_OK;
        goto done;
    }

    dblCurrentTime = GetCurrentTime();

    hr = S_OK;
  done:
    RRETURN1(hr, S_FALSE);
}

HRESULT 
CTIMEPlayerDMusic::Seek(double dblTime)
{
    return E_NOTIMPL;
}

HRESULT 
CTIMEPlayerDMusic::GetMediaLength(double &dblLength)
{
    return E_NOTIMPL;
}

HRESULT 
CTIMEPlayerDMusic::CanSeek(bool &fcanSeek)
{
    fcanSeek = false;
    return S_OK;
}

HRESULT 
CTIMEPlayerDMusic::Reset()
{
    HRESULT hr = S_OK;
    bool bNeedActive;
    bool bNeedPause;
    double dblSegTime;

    if(m_pTIMEMediaElement == NULL)
    {
        goto done;
    }

    bNeedActive = m_pTIMEMediaElement->IsActive();
    bNeedPause = m_pTIMEMediaElement->IsCurrPaused();
    
    if( !bNeedActive) // see if we need to stop the media.
    {
        Stop();
        m_dblSyncTime = 0.0;
        goto done;        
    }
    dblSegTime = m_pTIMEMediaElement->GetMMBvr().GetSimpleTime();
    m_dblSyncTime = GetCurrentTime();
    
    if( !m_bActive)
    {
        InternalStart();
    }
    else
    {
        //we need to be active so we also seek the media to it's correct position
        if(dblSegTime == 0.0)
        {
            // Fix "IEv60: 31873: DMusic HTC: There is a double start when playback is in OnMediaComplete script"
            // by commenting out the below line:
            //InternalStart();
        }
        else
        {
            IGNORE_HR(Seek(dblSegTime));
        }
    }
    
    //Now see if we need to change the pause state.
    
    if( bNeedPause)
    {
        Pause();
    }
    else
    {
        Resume();
    }
done:
    return hr;
}

bool 
CTIMEPlayerDMusic::SetSyncMaster(bool fSyncMaster)
{
    return false;
}

HRESULT 
CTIMEPlayerDMusic::GetExternalPlayerDispatch(IDispatch** ppDisp)
{
    HRESULT hr = E_POINTER;
    
    //
    // TODO: add disp interface for access to extra properties/methods
    //
    
    if (!IsBadWritePtr(*ppDisp, sizeof(IDispatch*)))
    {
        *ppDisp = NULL;
        hr      = E_FAIL;
    }
    
    hr = this->QueryInterface(IID_IDispatch, (void **)ppDisp);

done:
    return hr;
}
HRESULT
CTIMEPlayerDMusic::GetVolume(float *pflVolume)
{
    HRESULT hr = S_OK;
    long lVolume = -10000;

    if (NULL == pflVolume)
    {
        hr = E_POINTER;
        goto done;
    }

    if (m_staticHolder.GetPerformance() != NULL)
    {
        if (m_fAudioMute == true)
        {
            *pflVolume = m_flVolumeSave;
            goto done;
        }

        hr = m_staticHolder.GetPerformance()->GetGlobalParam(GUID_PerfMasterVolume, (void *)&lVolume, sizeof(long));
        *pflVolume = VolumeLogToLin(lVolume);   
    }
    else
    {
        hr = S_FALSE;
    }
done:
    return hr;
}


HRESULT
CTIMEPlayerDMusic::SetRate(double dblRate)
{
    HRESULT hr = S_OK;
    float flRate = (float)dblRate;

    if((dblRate < 0.25) || (dblRate > 2.0))
    {
        hr = E_FAIL;
        goto done;
    }

    if (m_staticHolder.GetPerformance() != NULL)
    {
        hr = m_staticHolder.GetPerformance()->SetGlobalParam(GUID_PerfMasterTempo, (void *)&flRate, sizeof(float));
        if(SUCCEEDED(hr))
        {
            if(!m_fSpeedIsNegative)
            {
                m_dblSpeedChangeTime = GetCurrentTime();
            }
            TraceTag((tagPlayerSyncDMusic,
                      "CTIMEDshowPlayer(%lx)::SetRate(%f)(%f)",
                      this, flRate, m_dblSpeedChangeTime));
            m_dblPlayerRate = flRate;
            hr = m_staticHolder.GetPerformance()->GetTime(&m_rtStart, NULL);
        }
    }
    else
    {
        hr = E_FAIL;
    }

done:
    return hr;
}

HRESULT
CTIMEPlayerDMusic::SetVolume(float flVolume)
{
    HRESULT hr = S_OK;
    long lVolume;

    if (flVolume < 0.0 || flVolume > 1.0)
    {
        hr = E_FAIL;
        goto done;
    }

    // if muted, overwrite saved volume and exit
    if (m_fAudioMute)
    {
        m_flVolumeSave = flVolume;
        goto done;
    }
    
    lVolume = VolumeLinToLog(flVolume);

    if (m_staticHolder.GetPerformance() != NULL)
    {
        hr = m_staticHolder.GetPerformance()->SetGlobalParam(GUID_PerfMasterVolume, (void *)&lVolume, sizeof(long));
    }
    else
    {
        hr = E_FAIL;
    }
done:
    return hr;
}

HRESULT
CTIMEPlayerDMusic::GetMute(VARIANT_BOOL *pVarMute)
{
    HRESULT hr = S_OK;

    if (NULL == pVarMute)
    {
        hr = E_POINTER;
        goto done;
    }


    *pVarMute = m_fAudioMute?VARIANT_TRUE:VARIANT_FALSE;
done:
    return hr;
}

HRESULT
CTIMEPlayerDMusic::SetMute(VARIANT_BOOL varMute)
{
    HRESULT hr = S_OK;
    bool fMute = varMute?true:false;
    long lVolume;

    if (fMute == m_fAudioMute)
    {
        hr = S_OK;
        goto done;
    }

    if (fMute == true)
    {
        hr = GetVolume(&m_flVolumeSave);
        if (FAILED(hr))
        {
            goto done;
        }
        hr = SetVolume(MIN_VOLUME_RANGE); //lint !e747
    }
    else
    {
        //
        // cannot use SetVolume here because it depends on mute state
        //

        if (m_staticHolder.GetPerformance() == NULL)
        {
            hr = E_FAIL;
            goto done;
        }

        lVolume = VolumeLinToLog(m_flVolumeSave);

        THR(hr = m_staticHolder.GetPerformance()->SetGlobalParam(GUID_PerfMasterVolume, (void *)&lVolume, sizeof(long)));
    }

    // update state
    m_fAudioMute = fMute;

done:
    return hr;
}


HRESULT
CTIMEPlayerDMusic::HasVisual(bool &bHasVisual)
{
    bHasVisual = false;
    return S_OK;
}

HRESULT
CTIMEPlayerDMusic::HasAudio(bool &bHasAudio)
{
    if (m_staticHolder.HasDM() && (m_fLoadError == false) && (m_fHasSrc == true))
    {
        bHasAudio = true;
    }
    else
    {
        bHasAudio = false;
    }

    return S_OK;
}


STDMETHODIMP
CTIMEPlayerDMusic::CueMedia()
{
    HRESULT hr = S_OK;

    TraceTag((tagPlayerDMusic, "CTIMEPlayerDMusic::CueMedia(%p)", this));

    // we don't own the de / allocation for these pointers
    const WCHAR* wszSrc = NULL;
    const WCHAR* wszBase = NULL;

    TraceTag((tagPlayerDMusic, "CTIMEPlayerDMusic(%p)::CueMedia()", this));

    CComPtr<ITIMEImportMedia> spTIMEMediaPlayer;

    hr = THR(CoGetInterfaceAndReleaseStream(m_pTIMEMediaPlayerStream, IID_TO_PPV(ITIMEImportMedia, &spTIMEMediaPlayer)));
    m_pTIMEMediaPlayerStream = NULL; // no need to release, the previous call released the reference
    if (FAILED(hr))
    {
        goto done;
    }
    
    Assert(GetAtomTable());

    hr = GetAtomTable()->GetNameFromAtom(m_lSrc, &wszSrc);
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = GetAtomTable()->GetNameFromAtom(m_lBase, &wszBase);
    if (FAILED(hr))
    {
        goto done;
    }

    m_pProxy->Block();

    {
        CritSectGrabber cs(m_CriticalSection);
    
        m_fUsingInterfaces = true;

        if (m_fRemoved || m_fNeedToReleaseInterfaces)
        {
            TraceTag((tagPlayerDMusic, "CTIMEPlayerDMusic::CueMedia(%p) should tear down", this));
            ReleaseInterfaces();
            m_pProxy->UnBlock();
            hr = S_OK;
            goto done;
        }
    }

    {
        CritSectGrabber cs(m_staticHolder.GetCueMediaCriticalSection());
        g_spLoaderBindStatusCallback = this;
        IGNORE_HR(SetSrc((WCHAR*)wszBase, (WCHAR*)wszSrc));
        g_spLoaderBindStatusCallback = NULL;
    }
    
    {
        CritSectGrabber cs(m_CriticalSection);

        m_fUsingInterfaces = false;

        if (m_fNeedToReleaseInterfaces)
        {
            ReleaseInterfaces();
            m_pProxy->UnBlock();
            hr = S_OK;
            goto done;
        }
    }

    m_pProxy->UnBlock();

    // this call is marshalled back to a time thread
    hr = THR(spTIMEMediaPlayer->InitializeElementAfterDownload());

    hr = S_OK;
done:
    TraceTag((tagPlayerDMusic, "CTIMEPlayerDMusic::CueMedia(%p) done", this));

    RRETURN( hr );
}

STDMETHODIMP
CTIMEPlayerDMusic::MediaDownloadError()
{
    return S_OK;
}

STDMETHODIMP
CTIMEPlayerDMusic::InitializeElementAfterDownload()
{
    HRESULT hr = S_OK;

    TraceTag((tagPlayerDMusic, "CTIMEPlayerDMusic::InitializeElementAfterDownload(%p)", this));

    if (m_fRemoved)
    {
        TraceTag((tagPlayerDMusic, "CTIMEPlayerDMusic::InitializeElementAfterDownload(%p) exiting early", this));
        hr = E_FAIL;
        goto done;
    }

    if (FAILED(m_hrSetSrcReturn))
    {
        if (m_pTIMEMediaElement)
        {
            m_pTIMEMediaElement->FireMediaEvent(PE_ONMEDIAERROR);
        }
    }
    else
    {
        m_fMediaComplete = true;
        if (m_pTIMEMediaElement)
        {
           m_pTIMEMediaElement->FireMediaEvent(PE_ONMEDIACOMPLETE);
        }
        Reset();
    }
    
    hr = S_OK;
done:

    TraceTag((tagPlayerDMusic, "CTIMEPlayerDMusic::InitializeElementAfterDownload(%p) done", this));

    RRETURN( hr );
}

STDMETHODIMP
CTIMEPlayerDMusic::GetPriority(double * pdblPriority)
{
    HRESULT hr = S_OK;

    if (NULL == pdblPriority)
    {
        return E_POINTER;
    }

    if (m_fHavePriority)
    {
        *pdblPriority = m_dblPriority;
    }
    
    Assert(m_pTIMEElementBase != NULL);
    Assert(NULL != m_pTIMEElementBase->GetElement());

    *pdblPriority = INFINITE;

    CComVariant varAttribute;
    
    hr = m_pTIMEElementBase->base_get_begin(&varAttribute);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = VariantChangeType(&varAttribute, &varAttribute, 0, VT_R8);
    if (FAILED(hr))
    {
        if ( DISP_E_TYPEMISMATCH == hr)
        {
            hr = S_OK;
        }
        goto done;
    }
    
    // either they set a priority or a begin time!
    *pdblPriority = varAttribute.dblVal;

    m_dblPriority = *pdblPriority;
    m_fHavePriority = true;
    

    hr = S_OK;
done:
    RRETURN( hr );
}

STDMETHODIMP
CTIMEPlayerDMusic::GetUniqueID(long * plID)
{
    HRESULT hr = S_OK;

    Assert(NULL != plID);

    *plID = m_lSrc;

    hr = S_OK;
done:
    RRETURN( hr );
}

STDMETHODIMP
CTIMEPlayerDMusic::GetMediaDownloader(ITIMEMediaDownloader ** ppMediaDownloader)
{
    HRESULT hr = S_OK;

    Assert(NULL != ppMediaDownloader);

    *ppMediaDownloader = NULL;

    hr = S_FALSE;
done:
    RRETURN1( hr, S_FALSE );
}

STDMETHODIMP
CTIMEPlayerDMusic::PutMediaDownloader(ITIMEMediaDownloader * pMediaDownloader)
{
    HRESULT hr = S_OK;

    hr = E_NOTIMPL;
done:
    RRETURN( hr );
}

STDMETHODIMP
CTIMEPlayerDMusic::CanBeCued(VARIANT_BOOL * pVB_CanCue)
{
    HRESULT hr = S_OK;
    
    if (NULL == pVB_CanCue)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    *pVB_CanCue = VARIANT_TRUE;

    hr = S_OK;
done:
    RRETURN( hr );
}


void
CTIMEPlayerDMusic::PropChangeNotify(DWORD tePropType)
{
    float flTeSpeed = 0.0;
    bool fHaveTESpeed;

    if (!m_pTIMEElementBase)
    {
        goto done;
    }

    if ((tePropType & TE_PROPERTY_SPEED) != 0)
    {
        TraceTag((tagPlayerDMusic,
                  "CTIMEDshowPlayer(%lx)::PropChangeNotify(%#x):TE_PROPERTY_SPEED",
                  this));
        fHaveTESpeed = m_pTIMEElementBase->GetTESpeed(flTeSpeed);
        if(fHaveTESpeed)
        {
            if (flTeSpeed <= 0.0)
            {
                m_fSpeedIsNegative = true;
                m_dblSpeedChangeTime = GetCurrentTime();
                Pause();
                goto done;
            }
            IGNORE_HR(SetRate((double)flTeSpeed)); //this has to be called before clearing 
                                                   //m_fSpeedIsNegative
            
            if(!(m_pTIMEElementBase->IsCurrPaused()) && m_fSpeedIsNegative)
            {
                m_fSpeedIsNegative = false;
                ResumeDmusic();
            }
        }
    }
done:
    return;
}


HRESULT
CTIMEPlayerDMusic::GetMimeType(BSTR *pmime)
{
    HRESULT hr = S_OK;

    *pmime = SysAllocString(L"audio/dmusic");
    return hr;
}


STDMETHODIMP
CTIMEPlayerDMusic::OnStartBinding( 
                                  /* [in] */ DWORD dwReserved,
                                  /* [in] */ IBinding __RPC_FAR *pib)
{
    HRESULT hr = S_OK;
    
    hr = S_OK;
done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMEPlayerDMusic::GetPriority( 
                               /* [out] */ LONG __RPC_FAR *pnPriority)
{
    HRESULT hr = S_OK;
    
    hr = S_OK;
done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMEPlayerDMusic::OnLowResource( 
                                 /* [in] */ DWORD reserved)
{
    HRESULT hr = S_OK;
    
    hr = S_OK;
done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMEPlayerDMusic::OnProgress( 
                              /* [in] */ ULONG ulProgress,
                              /* [in] */ ULONG ulProgressMax,
                              /* [in] */ ULONG ulStatusCode,
                              /* [in] */ LPCWSTR szStatusText)
{
    HRESULT hr = S_OK;
    
    if (m_fAbortDownload)
    {
        hr = E_ABORT;
        goto done;
    }

    hr = S_OK;
done:
    RRETURN1(hr, E_ABORT);
}

STDMETHODIMP
CTIMEPlayerDMusic::OnStopBinding( 
                                 /* [in] */ HRESULT hresult,
                                 /* [unique][in] */ LPCWSTR szError)
{
    HRESULT hr = S_OK;
    
    hr = S_OK;
done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMEPlayerDMusic::GetBindInfo( 
                               /* [out] */ DWORD __RPC_FAR *grfBINDF,
                               /* [unique][out][in] */ BINDINFO __RPC_FAR *pbindinfo)
{
    HRESULT hr = S_OK;
    
    hr = S_OK;
done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMEPlayerDMusic::OnDataAvailable( 
                                   /* [in] */ DWORD grfBSCF,
                                   /* [in] */ DWORD dwSize,
                                   /* [in] */ FORMATETC __RPC_FAR *pformatetc,
                                   /* [in] */ STGMEDIUM __RPC_FAR *pstgmed)
{
    HRESULT hr = S_OK;
    
    hr = S_OK;
done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMEPlayerDMusic::OnObjectAvailable( 
                                     /* [in] */ REFIID riid,
                                     /* [iid_is][in] */ IUnknown __RPC_FAR *punk)
{
    HRESULT hr = S_OK;
    
    hr = S_OK;
done:
    RRETURN(hr);
}


CTIMEDMusicStaticHolder::CTIMEDMusicStaticHolder()
{
    InitialState();
}

CTIMEDMusicStaticHolder::~CTIMEDMusicStaticHolder()
{
    TraceTag((tagPlayerDMusic,
              "CTIMEPlayerDMusic(%lx)::DetachFromHostElement() -- closing performance\n",
              this));

    LONG oldRef = 0;

    oldRef = InterlockedExchange(&m_lRef, 1); // we really want to release this time
    if (0 != oldRef)
    {
        Assert(0 == oldRef);
    }

    Assert(NULL == m_pLoader);
    Assert(m_comIDMusic == NULL);
    Assert(m_comIDMPerformance == NULL);
    Assert(m_comIDMComposer == NULL);

    ReleaseInterfaces();
}

void
CTIMEDMusicStaticHolder::InitialState()
{
    m_comIDMusic = NULL;
    m_comIDMPerformance = NULL;
    m_comIDMComposer = NULL;
    
    m_eVersionDM = dmv_61; // set to dmv_70orlater if certain interfaces are detected when DirectMusic is initialized
    m_fHaveInitialized = false;
    m_eHasDM = dm_unknown;
    m_fHasVersion8DM = false;
    m_pLoader = NULL;

    LONG oldRef = InterlockedExchange(&m_lRef, 0);
    if (0 != oldRef)
    {
        Assert(0 == oldRef);
    }
}

void
CTIMEDMusicStaticHolder::ReleaseInterfaces()
{    
    LONG l = InterlockedDecrement(&m_lRef);
    if (l > 0)
    {
        return;
    }
    Assert(l >= 0);

    TraceTag((tagDMusicStaticHolder, "Entering CueMediaCriticalSection"));

    CritSectGrabber cs2(m_CueMediaCriticalSection);
    CritSectGrabber cs(m_CriticalSection);

    TraceTag((tagDMusicStaticHolder, "entering release"));
    // Close loader
    if (m_pLoader)
    {
        TraceTag((tagDMusicStaticHolder, "loader"));
        m_pLoader->ClearCache(GUID_DirectMusicAllTypes);
        TraceTag((tagDMusicStaticHolder, "loader2"));
        m_pLoader->Release();
        TraceTag((tagDMusicStaticHolder, "loader3"));

        m_pLoader = NULL;
        TraceTag((tagDMusicStaticHolder, "loader done"));
    }

    // Release the ports
    if (m_comIDMusic)
    {
        m_comIDMusic->Activate(FALSE);
    }

    // Close performance
    if (m_comIDMPerformance)
    {
        // Stop everything that's playing.  Even though the individual segments
        // were stopped--meaning they won't play new notes--they may have played notes
        // previously that are still being held.  This cuts everything off.
        m_comIDMPerformance->Stop(NULL, NULL, 0, 0);
        
        m_comIDMPerformance->CloseDown();
    }

    // Composer and Performance are released automatically
    m_comIDMusic = NULL;
    m_comIDMPerformance = NULL;
    m_comIDMComposer = NULL;
        
    // make sure all the state is reset
    InitialState();
    TraceTag((tagDMusicStaticHolder, "Out of release"));
}

// Test whether DirectMusic is installed by attempting to open the registry key for CLSID_DirectMusicPerformance.
bool 
CTIMEDMusicStaticHolder::HasDM()
{
    CritSectGrabber cs(m_CriticalSection); 

    if (m_eHasDM == dm_unknown)
    {
        HKEY hkey = NULL;
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, _T("CLSID\\{D2AC2881-B39B-11D1-8704-00600893B1BD}"), 0, KEY_EXECUTE, &hkey))
        {
            RegCloseKey(hkey);
            m_eHasDM = dm_yes;
        }
        else
        {
            m_eHasDM = dm_no;
        }
    }
    
    return m_eHasDM == dm_yes;
}

HRESULT
CTIMEDMusicStaticHolder::Init()
{
    HRESULT hr = S_OK;

    CritSectGrabber cs(m_CriticalSection);

    InterlockedIncrement(&m_lRef);

    if (m_fHaveInitialized)
    {
        RRETURN(S_OK);
    }
    {
        // another thread may have initialized while this one was waiting
        if (m_fHaveInitialized)
        {
            hr = S_OK;
            goto done;
        }

        // do work
            
        // Create and init loader
        if (!m_pLoader)
        {
            m_pLoader = new CLoader();
            if (!m_pLoader)
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }
            hr = m_pLoader->Init();
            if (FAILED(hr))
            {
                delete m_pLoader;
                m_pLoader = NULL;
                goto done;
            }
        }
        
        // Create and init performance
        if (!m_comIDMPerformance)
        {
            hr = CoCreateInstance(CLSID_DirectMusicPerformance,
                NULL,
                CLSCTX_INPROC, //lint !e655
                IID_IDirectMusicPerformance,
                (void **)&m_comIDMPerformance);
            if (FAILED(hr))
            {
                goto done;
            }
            
            // QI to see if DirectX 8.0 is present.
            m_fHasVersion8DM = false;
            CComPtr<IDirectMusicPerformance8> comIDMusicPerformance8;
            hr = m_comIDMPerformance->QueryInterface(IID_IDirectMusicPerformance8, reinterpret_cast<void**>(&comIDMusicPerformance8));
            if (SUCCEEDED(hr))
            {
                // Try and initialize the DirectX 8.0 performance, and use a Stereo (no reverb) audiopath with 80 PChannels
                hr = comIDMusicPerformance8->InitAudio(&m_comIDMusic, NULL, NULL, DMUS_APATH_DYNAMIC_STEREO, 80, DMUS_AUDIOF_ALL, NULL); 
                if (SUCCEEDED(hr))
                {
                    m_eVersionDM = dmv_70orlater;
                    m_fHasVersion8DM = true;
                }
            }

            if( !m_fHasVersion8DM )
            {
                hr = m_comIDMPerformance->Init(&m_comIDMusic, NULL, NULL);
                if (FAILED(hr))
                {
                    goto done;
                }
            
                // QI to see if DirectX 7.0 is present.
                // This is a bit bizarre as far as COM goes.  IID_IDirectMusic2 and IID_IDirectMusicPerformance2 are special IID's that
                //    are supported only by DirectX 7.0.  These don't return a different interface.  However, the mere act of doing the
                //    QI has the side effect of placing DirectMusic in a special mode that fixes certain DLS bugs that were present in
                //    DirectX 6.1.
                // So we are doing two things here.
                // - Determining if DirectX 7.0 or later is present.
                // - Placing DirectMusic in a mode that fixes certain bugs.  We aren't going to obsess over strict DirectX 6.1
                //   compatibility because an increasing majority of people will have DirectX 7.0 or later.
                CComPtr<IDirectMusic> comIDMusic2;
                hr = m_comIDMusic->QueryInterface(IID_IDirectMusic2, reinterpret_cast<void**>(&comIDMusic2));
                if (SUCCEEDED(hr))
                {
                    CComPtr<IDirectMusicPerformance> comIDMPerformance2;
                    hr = m_comIDMPerformance->QueryInterface(IID_IDirectMusicPerformance2, reinterpret_cast<void**>(&comIDMPerformance2));
                    if (SUCCEEDED(hr))
                        m_eVersionDM = dmv_70orlater;
                }

                // Create the software synth port.
                CComPtr<IDirectMusicPort> comIDMPort;
                DMUS_PORTPARAMS dmos;
                ZeroMemory(&dmos, sizeof(DMUS_PORTPARAMS));
                dmos.dwSize = sizeof(DMUS_PORTPARAMS);
                dmos.dwChannelGroups = 5; // create 5 channel groups on the port
                dmos.dwEffectFlags = 0;
                dmos.dwValidParams = DMUS_PORTPARAMS_CHANNELGROUPS | DMUS_PORTPARAMS_EFFECTS;
                hr = m_comIDMusic->CreatePort(CLSID_DirectMusicSynth, &dmos, &comIDMPort, NULL);
                if (FAILED(hr))
                {
                    goto done;
                }
                // Succeeded in creating the port.  Activate it and add it to the performance.
                hr = m_comIDMusic->Activate(TRUE);
                if (FAILED(hr))
                {
                    goto done;
                }
            
                hr = m_comIDMPerformance->AddPort(comIDMPort);
                if (FAILED(hr))
                {
                    goto done;
                }
            
                // Assign a block of 16 PChannels to this port.
                // Block 0, port pPort, and group 1 means to assign
                // PChannels 0-15 to group 1 on port pPort.
                // PChannels 0-15 correspond to the standard 16
                // MIDI channels.
                hr = m_comIDMPerformance->AssignPChannelBlock( 0, comIDMPort, 1 );
                if (FAILED(hr))
                {
                    goto done;
                }
            
                // asign the other 4 groups
                hr = m_comIDMPerformance->AssignPChannelBlock( 1, comIDMPort, 2 );
                if (FAILED(hr))
                {
                    goto done;
                }
                hr = m_comIDMPerformance->AssignPChannelBlock( 2, comIDMPort, 3 );
                if (FAILED(hr))
                {
                    goto done;
                }
                hr = m_comIDMPerformance->AssignPChannelBlock( 3, comIDMPort, 4 );
                if (FAILED(hr))
                {
                    goto done;
                }
                hr = m_comIDMPerformance->AssignPChannelBlock( 4, comIDMPort, 5 );
                if (FAILED(hr))
                {
                    goto done;
                }
            }
        }
        
        // Create the composer
        if (!m_comIDMComposer)
        {
            hr = CoCreateInstance(CLSID_DirectMusicComposer,
                NULL,
                CLSCTX_INPROC, //lint !e655
                IID_IDirectMusicComposer,
                (void **)&m_comIDMComposer);
            if (FAILED(hr))
            {
                goto done;
            }
        }

        m_fHaveInitialized = true;
    }        
            
    hr = S_OK;
done:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\playerdshow.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: player.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _PLAYERDSHOW_H
#define _PLAYERDSHOW_H

#include "playerdshowbase.h"
#include "mixerocx.h"
#include <strmif.h>
#include <control.h>
#include <inc\qnetwork.h>
#include "dshowproxy.h"

#include "importman.h"

#define MP_INFINITY -1

/////////////////////////////////////////////////////////////////////////////
// CTTIMEPlayer

class CTIMEDshowPlayer :
    public CTIMEDshowBasePlayer,
    public ITIMEImportMedia,
    public ITIMEInternalEventSink,
    public IMixerOCXNotify
{
  public:
    CTIMEDshowPlayer(CTIMEDshowPlayerProxy * pProxy);
    virtual ~CTIMEDshowPlayer();

    HRESULT Init(CTIMEMediaElement *pelem,
                 LPOLESTR base,
                 LPOLESTR src,
                 LPOLESTR lpMimeType = NULL,
                 double dblClipBegin = -1.0,
                 double dblClipEnd = -1.0);//lint !e1735

  protected:
    HRESULT InitDshow();
    HRESULT InitElementSize();
    void DeinitDshow();
    HRESULT BuildGraph();
    HRESULT GetSpecificInterfaces();
    void ReleaseSpecificInterfaces();
    void FreeSpecificData();

    HRESULT BeginDownload();
    HRESULT GraphFinish();

    HRESULT ReadContentProperty(IGraphBuilder *pGraph, LPCWSTR lpcwstrTag, BSTR *pbstr);

    virtual void Block();
    virtual void UnBlock();
    virtual bool CanCallThrough();
    virtual bool FireProxyEvent(PLAYER_EVENT plEvent);

  public:
    HRESULT DetachFromHostElement (void);

    // IUnknown Methods
    STDMETHOD (QueryInterface)(REFIID refiid, void** ppunk)
        {   return _InternalQueryInterface(refiid, ppunk); };
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);

    virtual void OnTick(double dblSegmentTime,
                        LONG lCurrRepeatCount);

    HRESULT Reset();
    HRESULT Render(HDC hdc, LPRECT prc);

    HRESULT SetSrc(LPOLESTR base, LPOLESTR src);

    HRESULT SetSize(RECT *prect);

    HRESULT GetMediaLength(double &dblLength);
    HRESULT CanSeek(bool &fcanSeek);
    virtual PlayerState GetState();
    virtual HRESULT CanSeekToMarkers(bool &bacnSeekToM);
    virtual HRESULT IsBroadcast(bool &bisBroad);
    virtual HRESULT SetRate(double dblRate);
    virtual HRESULT GetRate(double &dblRate);
    virtual HRESULT HasMedia(bool &fHasMedia);
    virtual HRESULT HasVisual(bool &fHasVideo);
    virtual HRESULT HasAudio(bool &fHasAudio);

    HRESULT GetNaturalHeight(long *height);
    HRESULT GetNaturalWidth(long *width);

    virtual HRESULT GetAuthor(BSTR *pAuthor);
    virtual HRESULT GetTitle(BSTR *pTitle);
    virtual HRESULT GetCopyright(BSTR *pCopyright);
    virtual HRESULT GetAbstract(BSTR *pAbstract);
    virtual HRESULT GetRating(BSTR *pAbstract);

    virtual HRESULT GetIsStreamed(bool &fIsStreamed);
    virtual HRESULT GetBufferingProgress(double &dblBufferingProgress);
    virtual HRESULT GetHasDownloadProgress(bool &fHasDownloadProgress);

    BEGIN_COM_MAP(CTIMEDshowPlayer)
        COM_INTERFACE_ENTRY(ITIMEImportMedia)
        COM_INTERFACE_ENTRY_CHAIN(CTIMEDshowBasePlayer)
    END_COM_MAP_X();

    //
    // ITIMEImportMedia methods
    //
    STDMETHOD(CueMedia)();
    STDMETHOD(GetPriority)(double *);
    STDMETHOD(GetUniqueID)(long *);
    STDMETHOD(InitializeElementAfterDownload)();
    STDMETHOD(GetMediaDownloader)(ITIMEMediaDownloader ** ppImportMedia);
    STDMETHOD(PutMediaDownloader)(ITIMEMediaDownloader * pImportMedia);
    STDMETHOD(CanBeCued)(VARIANT_BOOL * pVB_CanCue);
    STDMETHOD(MediaDownloadError)();

    //
    // ITIMEInternalEventSink
    //
    STDMETHOD(InternalEvent)();
    
  protected:
    long    m_lSrc;
    bool m_fHasVideo;
    bool m_fDoneSetup;
    double m_dblSeekAtStart;
    bool m_fLoadError;
    bool m_fHasMedia;
    bool m_fRemoved;

  private:

    // IMixerOCXNotify methods
    STDMETHOD(OnInvalidateRect)(LPCRECT lpcRect);
    STDMETHOD(OnStatusChange)(ULONG ulStatusFlags);
    STDMETHOD(OnDataChange)(ULONG ulDataFlags);

    HRESULT SetMixerSize(RECT *prect);
    HRESULT SetUpHdc();

    void GraphStart(void);

    bool IsOvMConnected(IBaseFilter *pOvM);

    void SetStreamFlags(LPOLESTR src);
    HRESULT DisableAudioVideo();

    IMixerOCX *m_pIMixerOCX;
    DWORD m_nativeVideoWidth;
    DWORD m_nativeVideoHeight;
    DWORD m_displayVideoWidth;
    DWORD m_displayVideoHeight;

    LPSTREAM                    m_pTIMEMediaPlayerStream;

    bool m_fUsingInterfaces;
    bool m_fNeedToDeleteInterfaces;

    bool m_fCanCueNow;
    
    bool m_fHavePriority;
    double m_dblPriority;
    HRESULT m_hrRenderFileReturn;

    CTIMEDshowPlayerProxy * m_pProxy;
    CritSect                m_CriticalSection;
    
  private:
    CTIMEDshowPlayer();
};

#endif /* _PLAYERDSHOW_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\playerdshow.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: player.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "playerdshow.h"
#include "mediaelm.h"
#include <wininet.h>
#include <inc\evcode.h>
#include "tags\bodyelm.h"

class
__declspec(uuid("22d6f312-b0f6-11d0-94ab-0080c74c7e95"))
MediaPlayerCLSID {};

#define SecsToNanoSecs 10000000

#define OVLMixer L"Overlay Mixer"

#define SOUND_OF_SILENCE -10000
// Suppress new warning about NEW without corresponding DELETE 
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )  

DeclareTag(tagDshowTimePlayer, "TIME: Players", "CTIMEDshowPlayer methods");
DeclareTag(tagDshowSyncTimePlayer, "TIME: Players", "CTIMEDshowPlayer sync methods");

CTIMEDshowPlayer::CTIMEDshowPlayer(CTIMEDshowPlayerProxy * pProxy) :
    m_fHasVideo(false),
    m_fDoneSetup(false),
    m_pIMixerOCX(NULL),
    m_dblSeekAtStart(0.0),
    m_nativeVideoWidth(0),
    m_nativeVideoHeight(0),
    m_displayVideoWidth(0),
    m_displayVideoHeight(0),
    m_lSrc(ATOM_TABLE_VALUE_UNITIALIZED),
    m_pTIMEMediaPlayerStream(NULL),
    m_fRemoved(false),
    m_fNeedToDeleteInterfaces(false),
    m_fUsingInterfaces(false),
    m_fLoadError(false),
    m_fHasMedia(false),
    m_dblPriority(INFINITE),
    m_fCanCueNow(false),
    m_fHavePriority(false),
    m_hrRenderFileReturn(S_OK),
    m_pProxy(pProxy)
{
    TraceTag((tagDshowTimePlayer,
              "CTIMEDshowPlayer(%lx)::CTIMEDshowPlayer()",
              this));


}


CTIMEDshowPlayer::~CTIMEDshowPlayer()
{
    TraceTag((tagDshowTimePlayer,
              "CTIMEDshowPlayer(%lx)::~CTIMEDshowPlayer()",
              this));

    m_pMediaContent = NULL;
    if (m_pIMixerOCX != NULL)
    {
        m_pIMixerOCX->UnAdvise();
    }
    m_pIMixerOCX = NULL;

    ReleaseGenericInterfaces();

    ReleaseInterface(m_pTIMEMediaPlayerStream);

    m_pOvM = NULL;

    delete m_pProxy;
}

STDMETHODIMP_(ULONG)
CTIMEDshowPlayer::AddRef(void)
{
    return CTIMEDshowBasePlayer::AddRef();
}


STDMETHODIMP_(ULONG)
CTIMEDshowPlayer::Release(void)
{
    return CTIMEDshowBasePlayer::Release();
}


STDMETHODIMP
CTIMEDshowPlayer::OnInvalidateRect(LPCRECT lpcRect)
{

    TraceTag((tagDshowTimePlayer, "CTIMEDshowPlayer(%lx)::OnInvalidateRect(%x)", this, lpcRect));

    ::PostMessage(m_pwndMsgWindow, WM_INVALIDATE, NULL, NULL);

    return S_OK;
}

STDMETHODIMP
CTIMEDshowPlayer::OnStatusChange(ULONG ulStatusFlags)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CTIMEDshowPlayer::OnDataChange(ULONG ulDataFlags)
{
    return E_NOTIMPL;
}

HRESULT
CTIMEDshowPlayer::Init(CTIMEMediaElement *pelem, LPOLESTR base, LPOLESTR src, LPOLESTR lpMimeType, double dblClipBegin, double dblClipEnd)
{
    TraceTag((tagDshowTimePlayer,
              "CTIMEDshowPlayer(%lx)::Init)",
              this));
    HRESULT hr = S_OK;
    LPOLESTR szSrc = NULL;

    if (m_pTIMEElementBase != NULL) //this only happens in the case of reentrancy
    {
        hr = S_OK;
        goto done;
    }

    hr = CTIMEDshowBasePlayer::Init(pelem, base, src, lpMimeType, dblClipBegin, dblClipEnd);
    if (FAILED(hr))
    {
        goto done;
    }
    
    m_pTIMEElementBase = pelem;
    
    hr = THR(CoMarshalInterThreadInterfaceInStream(IID_ITIMEImportMedia, static_cast<ITIMEImportMedia*>(this), &m_pTIMEMediaPlayerStream));
    if (FAILED(hr))
    {
        goto done;
    }
    if (src == NULL)
    {
        hr = S_OK;
        goto done;
    }

    hr = THR(::TIMECombineURL(base, src, &szSrc));
    if (!szSrc)
    {
        hr = E_FAIL;
        goto done;
    }
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetAtomTable()->AddNameToAtomTable(szSrc, &m_lSrc);
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = InitDshow();
    if (FAILED(hr))
    {
        goto done;
    }
    
    Assert(NULL != GetImportManager());

    hr = GetImportManager()->Add(this);
    if (FAILED(hr))
    {
        goto done;
    }

    ClearNaturalDuration();

    if( dblClipBegin != -1.0)
    {
        m_dblClipStart = dblClipBegin;
    }

    if( dblClipEnd != -1.0)
    {
        m_dblClipEnd = dblClipEnd;
    }

    Assert(NULL != m_pTIMEElementBase->GetBody());
    hr = m_pTIMEElementBase->GetBody()->AddInternalEventSink(this, 0.0);
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
done:
    delete[] szSrc;
    return hr;
}

HRESULT
CTIMEDshowPlayer::DetachFromHostElement (void)
{
    HRESULT hr = S_OK;

    TraceTag((tagDshowTimePlayer,
              "CTIMEDshowPlayer(%lx)::DetachFromHostElement)",
              this));

    if(m_fDetached)
    {
        goto done;
    }

    m_fRemoved = true;
    m_fDetached = true;

    if (m_spOpenProgress)
    {
        m_spOpenProgress->AbortOperation();
        m_spOpenProgress = NULL;
    }

    Assert(NULL != GetImportManager());

    IGNORE_HR(GetImportManager()->Remove(this));

    CTIMEDshowBasePlayer::DetachFromHostElement();

    {
        CritSectGrabber cs(m_CriticalSection);
        
        if (false == m_fUsingInterfaces)
        {
            DeinitDshow();
        }
        else
        {
            m_fNeedToDeleteInterfaces = true;
        }
    }
    
    if (NULL != m_pTIMEElementBase->GetBody())
    {
        IGNORE_HR(m_pTIMEElementBase->GetBody()->RemoveInternalEventSink(this));
    }
    
    m_pTIMEElementBase = NULL;
    NullAtomTable();

done:
    return hr;
}

void
CTIMEDshowPlayer::ReleaseSpecificInterfaces()
{
    m_pMediaContent = NULL;
    if (m_pIMixerOCX != NULL)
    {
        m_pIMixerOCX->UnAdvise();
        m_pIMixerOCX->Release();
        m_pIMixerOCX = NULL;
    }
}

void
CTIMEDshowPlayer::FreeSpecificData()
{

}

void
CTIMEDshowPlayer::DeinitDshow()
{
    CTIMEDshowBasePlayer::DeinitDshow();
}

HRESULT
CTIMEDshowPlayer::BuildGraph()
{
    HRESULT hr = S_OK;

    hr = CreateMessageWindow();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = CoCreateInstance(CLSID_FilterGraphNoThread,
                          NULL,
                          CLSCTX_INPROC_SERVER, //lint !e655
                          IID_IGraphBuilder,
                          (void **)&m_pGB);
    // dshow not installed
    if (hr == REGDB_E_CLASSNOTREG)
    {
        CComPtr<IUnknown> pObj;
        hr = THR(CreateObject(__uuidof(MediaPlayerCLSID),
                              IID_IUnknown,
                              (void **)&pObj));
        if (FAILED(hr))
        {
            goto done;
        }

        hr = CoCreateInstance(CLSID_FilterGraphNoThread,
                              NULL,
                              CLSCTX_INPROC_SERVER, //lint !e655
                              IID_IGraphBuilder,
                              (void **)&m_pGB);
    }
    if (FAILED(hr))
    {
        goto done;
    }

    // If we need to teardown while in RenderFile, use this interface:
    IGNORE_HR(m_pGB->QueryInterface(IID_TO_PPV(IAMOpenProgress, &m_spOpenProgress)));

done:
    return hr;
}

HRESULT
CTIMEDshowPlayer::GetSpecificInterfaces()
{
    HRESULT hr = S_OK;

    if (m_pOvM == NULL)
    {
        hr = CoCreateInstance(CLSID_OverlayMixer, NULL, CLSCTX_INPROC, IID_IBaseFilter, (LPVOID *)&m_pOvM) ; //lint !e655
        // dshow not installed
        if (hr == REGDB_E_CLASSNOTREG)
        {
            CComPtr<IUnknown> pObj;
            hr = THR(CreateObject(__uuidof(MediaPlayerCLSID),
                                  IID_IUnknown,
                                  (void **)&pObj));
            if (FAILED(hr))
            {
                goto done;
            }
            hr = CoCreateInstance(CLSID_OverlayMixer, NULL, CLSCTX_INPROC, IID_IBaseFilter, (LPVOID *)&m_pOvM) ; //lint !e655
        }
        if (FAILED(hr) || m_pOvM == NULL)
        {
            goto done;
        }
    }

    hr = m_pOvM->QueryInterface(IID_IMixerOCX,(void **)&m_pIMixerOCX);
    if (hr == E_NOINTERFACE)
    {
        // dshow dll is there, but its not properly registered
        CComPtr<IUnknown> pObj;
        hr = THR(CreateObject(__uuidof(MediaPlayerCLSID),
                              IID_IUnknown,
                              (void **)&pObj));
        if (FAILED(hr))
        {
            m_pOvM.Release();
            goto done;
        }

        hr = m_pOvM->QueryInterface(IID_IMixerOCX,(void **)&m_pIMixerOCX);
    }
    if (FAILED(hr) || m_pIMixerOCX == NULL)
    {
        m_pOvM.Release();
        goto done;
    }
    hr = m_pIMixerOCX->Advise(SAFECAST(this, IMixerOCXNotify*));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = m_pGB->AddFilter(m_pOvM, OVLMixer);
    if (FAILED(hr))
    {
        goto done;
    }

    m_fMediaComplete = false;
done:
    return hr;
}


HRESULT
CTIMEDshowPlayer::InitDshow()
{
    HRESULT hr = S_OK;

    hr = CTIMEDshowBasePlayer::InitDshow();
    return hr;
}

class CSimplePB : public IMediaPropertyBag
{
    STDMETHOD(QueryInterface) (THIS_ REFIID, LPVOID *) { return E_NOINTERFACE; }
    STDMETHOD_(ULONG, AddRef)(THIS) { return 0; }
    STDMETHOD_(ULONG, Release)(THIS) { return 0; }
        
    STDMETHOD(Read)(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog) { return E_NOTIMPL; }
    STDMETHOD(EnumProperty) (ULONG iProperty, VARIANT *pvarName, VARIANT *pvarVal) { return E_NOTIMPL; } 
        
    LPCOLESTR m_pLookFor;
    BSTR *m_pbstrOut;

    STDMETHOD(Write) (LPCOLESTR pszPropName, VARIANT *pVar)
    {
        if (0 == wcscmp(m_pLookFor, pszPropName))
        {
            if (pVar->vt != VT_BSTR)
            {
                return E_NOTIMPL;
            }

            *m_pbstrOut = SysAllocString(pVar->bstrVal);
            if (NULL == m_pbstrOut)
            {
                return E_FAIL;
            }
        }

        return S_OK;
    }

    public:    
    CSimplePB() :
        m_pbstrOut(NULL), m_pLookFor(NULL) {}
    CSimplePB(LPCOLESTR pLookFor, BSTR *pbstrOut) :
        m_pbstrOut(pbstrOut), m_pLookFor(pLookFor) {}
};



HRESULT
CTIMEDshowPlayer::ReadContentProperty(IGraphBuilder *pGraph, LPCWSTR lpcwstrTag, BSTR * pbstr)
{
    IPersistMediaPropertyBag *pPMPB = NULL;
    if (S_OK == FindInterfaceOnGraph(pGraph, IID_IPersistMediaPropertyBag,
                                     (void **) &pPMPB))
    {
        CSimplePB pb(lpcwstrTag, pbstr);

        pPMPB->Save(&pb, FALSE, FALSE);

        pPMPB->Release();
    }

    return *pbstr ? S_OK : E_FAIL;
}

HRESULT
CTIMEDshowPlayer::SetUpHdc()
{
    HRESULT hr = S_OK;

    if (IsOvMConnected(m_pOvM)) // if we have video get the native size
    {
        hr = m_pIMixerOCX->GetVideoSize(&m_nativeVideoWidth, &m_nativeVideoHeight);
        if (FAILED(hr))
        {
            goto done;
        }

        m_fHasVideo = true;
    }
    else //if we only have audio: native size is 0 0
    {
        m_nativeVideoWidth = 0;
        m_nativeVideoHeight = 0;
    }
    m_fDoneSetup = true;
done:

    return hr;
}

HRESULT
CTIMEDshowPlayer::InitElementSize()
{
    HRESULT hr;
    RECT nativeSize, elementSize;
    bool fisNative;
    bool fResetRs = false;

    if (NULL == m_pTIMEElementBase)
    {
        hr = S_OK;
        goto done;
    }

    if (m_bIsHTMLSrc)
    {
        hr = S_OK;
        goto done;
    }

    if(m_pPlaybackSite && (m_pPlaybackSite->GetNativePlayer() != NULL))
    {
        fResetRs = true;
    }

    nativeSize.left = nativeSize.top = 0;
    nativeSize.right = m_nativeVideoWidth;
    nativeSize.bottom = m_nativeVideoHeight;
    IGNORE_HR(SetMixerSize( &nativeSize));
    
    hr = m_pTIMEElementBase->NegotiateSize( nativeSize, elementSize, fisNative, fResetRs);
    m_displayVideoHeight = m_nativeVideoHeight;
    m_displayVideoWidth = m_nativeVideoWidth;
    
    hr = S_OK;
done:
    return hr;
}

HRESULT
CTIMEDshowPlayer::SetSrc(LPOLESTR base, LPOLESTR src)
{   
    TraceTag((tagDshowTimePlayer,
              "CTIMEDshowPlayer(%lx)::SetSrc()\n",
              this));
    
    LPOLESTR szSrc = NULL;
    HRESULT hr = S_OK;

    //create and initialize the URL_COMPONENTS structure
    URL_COMPONENTSW URLComp;
    ZeroMemory(&URLComp, sizeof(URL_COMPONENTS));
    URLComp.dwStructSize = sizeof(URL_COMPONENTS);
    URLComp.dwUrlPathLength = INTERNET_MAX_URL_LENGTH;
    URLComp.dwExtraInfoLength = INTERNET_MAX_URL_LENGTH;

    DeinitDshow();
    m_fLoadError = false;
    if (src == NULL)
    {
        goto done;
    }

    hr = THR(::TIMECombineURL(base, src, &szSrc));
    if (!szSrc)
    {
        hr = E_FAIL;
        goto done;
    }
    if (FAILED(hr))
    {
        goto done;
    }


    if (!InternetCrackUrlW(szSrc, lstrlenW(szSrc), 0, &URLComp))
    {
        hr = E_INVALIDARG;
        goto done;
    }

    hr = InitDshow();
    if (FAILED(hr))
    {
        goto done;
    }

    if (IsHTMLSrc(URLComp.lpszExtraInfo))
    {
        LPOLESTR lpszPath = NULL;
        SetStreamFlags(URLComp.lpszExtraInfo);

        lpszPath = NEW OLECHAR [URLComp.dwUrlPathLength + 1];
        if (lpszPath == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
        StrCpyNW(lpszPath, URLComp.lpszUrlPath, URLComp.dwUrlPathLength + 1);            
        lpszPath[URLComp.dwUrlPathLength] = 0;

        hr = THR(m_pGB->RenderFile(lpszPath, NULL));
        delete [] lpszPath;
        lpszPath = NULL;
    }
    else
    {
        hr = THR(m_pGB->RenderFile(szSrc, NULL));
    }
    if (FAILED(hr)) // this fall through catches media load failed errors from either call to RenderFile above.
    {
        m_pTIMEElementBase->FireMediaEvent(PE_ONMEDIAERROR);
        goto done;
    }


    hr = FindInterfaceOnGraph(m_pGB, IID_IAMMediaContent, (void **)&m_pMediaContent);
    if (FAILED(hr))
    {
        m_pMediaContent = NULL;
    }
    hr = FindInterfaceOnGraph(m_pGB, IID_IBasicAudio, (void **)&m_pBasicAudio);
    if (FAILED(hr))
    {
        m_pBasicAudio = NULL;
    }
    hr = SetUpHdc();
    if (FAILED(hr))
    {
        goto done;
    }

    if (IsHTMLSrc(URLComp.lpszExtraInfo))
    {
        hr = THR(DisableAudioVideo());
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else
    {
        hr = InitElementSize();
        if (FAILED(hr))
        {
            goto done;
        }
    }


    //InitElementDuration();
    hr = m_pMC->Run();
    if (FAILED(hr))
    {
        goto done;
    } 

    if (m_fRunning == false)
    {
        Pause();
    }
    else
    {
        Resume();
    }

    ClearNaturalDuration();

    hr = S_OK;
done:
    if (FAILED(hr))
    {
        m_fLoadError = true;
    }
    delete[] szSrc;
    
    return hr;

}

STDMETHODIMP
CTIMEDshowPlayer::CanBeCued(VARIANT_BOOL * pVB_CanCue)
{
    HRESULT hr = S_OK;

    if (NULL == pVB_CanCue)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    *pVB_CanCue = m_fCanCueNow ? VARIANT_TRUE : VARIANT_FALSE;
    
    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP
CTIMEDshowPlayer::CueMedia()
{
    TraceTag((tagDshowTimePlayer,
              "CTIMEDshowPlayer(%lx)::CueMedia()",
              this));
    HRESULT hr = S_OK;

    CComPtr<ITIMEImportMedia> spTIMEMediaPlayer;
    CComPtr<IStream> spStream;
    
    hr = THR(CoGetInterfaceAndReleaseStream(m_pTIMEMediaPlayerStream, IID_TO_PPV(ITIMEImportMedia, &spTIMEMediaPlayer)));
    m_pTIMEMediaPlayerStream = NULL; // no need to release, the previous call released the reference
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(NULL != m_pProxy);

    {   
        // Mark the dshow interfaces in use in order to 
        // prevent us from releasing via a callback from
        // dshow from reentering with a DetachFromHostElement
        // call.
        //
        CritSectGrabber cs(m_CriticalSection);

        m_fUsingInterfaces = true;
    }
    
    Block();

    IGNORE_HR(BeginDownload());

    UnBlock();
    
    hr = spTIMEMediaPlayer->InitializeElementAfterDownload();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    {
        // Relinquish our hold on the dshow-related interfaces.
        // This is to prevent reentrancy from dshow back into
        // DetachFromHostElement.
        CritSectGrabber cs(m_CriticalSection);

        if (m_fNeedToDeleteInterfaces)
        {
            DeinitDshow();
            m_fNeedToDeleteInterfaces = false;
        }
    
        m_fUsingInterfaces = false;
    }
    
    return hr;
}

STDMETHODIMP
CTIMEDshowPlayer::MediaDownloadError()
{
    return S_OK;
}

HRESULT
CTIMEDshowPlayer::BeginDownload()
{
    TraceTag((tagDshowTimePlayer,
              "CTIMEDshowPlayer(%lx::GraphFinish()",
              this));
    HRESULT hr = S_OK;
    CComPtr<IHTMLElement2> spElement2;

    const WCHAR * cpchSrc = NULL;
    WCHAR * beckified = NULL;
    
    //create and initailzie the URL_COMPONENTS structure
    URL_COMPONENTSW URLComp;
    ZeroMemory(&URLComp, sizeof(URL_COMPONENTS));
    URLComp.dwStructSize = sizeof(URL_COMPONENTS);
    URLComp.dwUrlPathLength = INTERNET_MAX_URL_LENGTH;
    URLComp.dwExtraInfoLength = INTERNET_MAX_URL_LENGTH;

    if(GetAtomTable() == NULL)
    {
        hr = E_FAIL;
        goto done;
    }

    if(m_pGB == NULL)
    {
        hr = E_UNEXPECTED;
        goto done;
    }
    
    hr = GetAtomTable()->GetNameFromAtom(m_lSrc, &cpchSrc);
    if (FAILED(hr))
    {
        goto done;
    }

    if (!InternetCrackUrlW(cpchSrc, lstrlenW(cpchSrc), 0, &URLComp))
    {
        hr = E_INVALIDARG;
        goto done;
    }

    if (IsHTMLSrc(URLComp.lpszExtraInfo))
    {
        LPOLESTR lpszPath = NULL;
        long l = 0;
        lpszPath = NEW OLECHAR [lstrlenW(cpchSrc) + 1];
        if (lpszPath == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }   
        l = lstrlenW(cpchSrc);
        StrCpyNW(lpszPath, cpchSrc, l - URLComp.dwExtraInfoLength + 1);            
        lpszPath[l - URLComp.dwExtraInfoLength + 1] = 0;
        //StrCpyNW(lpszPath, URLComp.lpszUrlPath, lstrlenW(cpchSrc) - URLComp.dwExtraInfoLength);            
        //lpszPath[lstrlenW(cpchSrc) - URLComp.dwExtraInfoLength] = 0;

// This used to convert URL's to a netshow extension.
// The call HRESULT CdxmPlay::InternalOpen( COpenRequest *pRequest) in
// in WMP 6.4 source code shows the issue.
        beckified = BeckifyURL(lpszPath);

        if(beckified != NULL)
        {
            hr = THR(m_pGB->RenderFile(beckified, NULL));
        }
        else
        {
            hr = THR(m_pGB->RenderFile(lpszPath, NULL));
        }
        delete [] lpszPath;
        lpszPath = NULL;

        SetStreamFlags(URLComp.lpszExtraInfo);
    }
    else
    {
        if (m_pGB == NULL)
        {
            hr = E_FAIL;
            goto done;
        }
// This used to convert URL's to a netshow extension.
// The call HRESULT CdxmPlay::InternalOpen( COpenRequest *pRequest) in
// in WMP 6.4 source code shows the issue.
        beckified = BeckifyURL((WCHAR *)cpchSrc);

        if(beckified != NULL)
        {
            hr = THR(m_pGB->RenderFile(beckified, NULL));
        }
        else
        {
            hr = THR(m_pGB->RenderFile(cpchSrc, NULL));
        }
    }

    if (FAILED(hr))
    {
        // this fall through catches media load 
        // failed errors from either call to RenderFile above.
        m_hrRenderFileReturn = hr;
    }

    hr = S_OK;
done:

    delete[] beckified;
    RRETURN(hr);
}

HRESULT
CTIMEDshowPlayer::GraphFinish()
{
    TraceTag((tagDshowTimePlayer,
              "CTIMEDshowPlayer(%lx::GraphFinish()",
              this));
    HRESULT hr = S_OK;
    
    CComPtr<IHTMLElement2> spElement2;

    if (FAILED(m_hrRenderFileReturn))     
    {
        FireMediaEvent(PE_ONMEDIAERROR);
        hr = m_hrRenderFileReturn;
        goto done;
    }

    if (m_fNeedToDeleteInterfaces)
    {
        goto done;
    }

    if (!IsOvMConnected(m_pOvM)) // if we have video get the native size
    {
        hr = m_pGB->RemoveFilter(m_pOvM);
    }

    hr = FindInterfaceOnGraph(m_pGB, IID_IAMMediaContent, (void **)&m_pMediaContent);
    if (FAILED(hr))
    {
        m_pMediaContent = NULL;
    }
    hr = FindInterfaceOnGraph(m_pGB, IID_IBasicAudio, (void **)&m_pBasicAudio);
    if (FAILED(hr))
    {
        m_pBasicAudio = NULL;
    }
     //can be used m_pIAMNetShowConfig->put_BufferingTime(1.0);
    hr = FindInterfaceOnGraph(m_pGB, IID_IAMNetShowConfig,  (void **) &m_pIAMNetShowConfig);
    if (FAILED(hr))
    {
        m_pIAMNetShowConfig = NULL;
    }
    hr = FindInterfaceOnGraph(m_pGB, IID_IAMExtendedSeeking, (void **) &m_pExSeeking);
    if (FAILED(hr))
    {
        m_pExSeeking = NULL;
    } 
    hr = FindInterfaceOnGraph(m_pGB, IID_IAMNetworkStatus, (void **) &m_pIAMNetStat);
    if (FAILED(hr))
    {
        m_pExSeeking = NULL;
    } 
    
    hr = SetUpHdc();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GraphCue();
    if (FAILED(hr))
    {
        goto done;
    }

    if (m_pTIMEElementBase)
    {
        hr = m_pTIMEElementBase->GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &spElement2));
        if (FAILED(hr))
        {
            // IE4 path
            CComPtr<IElementBehaviorSite> spElementBehaviorSite;
            spElementBehaviorSite = m_pTIMEElementBase->GetBvrSite();
            
            CComPtr<IObjectWithSite> spSite;
            // see if we are running on IE4, and try to get spSite to be a CElementBehaviorSite*
            hr = spElementBehaviorSite->QueryInterface(IID_TO_PPV(IObjectWithSite, &spSite));
            if (FAILED(hr))
            {
                goto done;
            }
            
            CComPtr<IOleWindow> spOleWindow;
            // ask for the site (through CElementBehaviorSite to CVideoHost, to ATL::IObjectWIthSiteImpl
            hr = spSite->GetSite(IID_IOleWindow, (void**) &spOleWindow);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CTIMEDshowPlayer::Init - IE4 failure! unable to QI for IOleWindow on hosting Document"));
                goto done;
            }
        }
    }

done:
    return hr;
}

//
// CTIMEDshowPlayer::IsOvMConnected(): Private method to detect if the video stream 
// is passing through the Overlay Mixer (i.e, is it connected?).
//
bool
CTIMEDshowPlayer::IsOvMConnected(IBaseFilter *pOvM)
{    
    IEnumPins   *pEnumPins;
    IPin        *pPin;
    IPin        *pPin2;
    ULONG        ul;
    HRESULT      hr;
    bool         bConnected = false;

    pOvM->EnumPins(&pEnumPins);
    while (S_OK == pEnumPins->Next(1, &pPin, &ul) && 1 == ul && bConnected == false)
    {
        hr = pPin->ConnectedTo(&pPin2);
        if (SUCCEEDED(hr) && pPin2)
        {
            bConnected = true;
            pPin2->Release();
        }
        pPin->Release();
    }
    pEnumPins->Release();
    
    return bConnected;
}

void
CTIMEDshowPlayer::OnTick(double dblSegmentTime,
                         LONG lCurrRepeatCount)
{
    TraceTag((tagDshowTimePlayer,
              "CTIMEDshowPlayer(%lx)::OnTick(%g, %d)",
              this,
              dblSegmentTime,
              lCurrRepeatCount));
}

void
CTIMEDshowPlayer::GraphStart(void)
{
    HRESULT hr = S_OK;
    TraceTag((tagDshowTimePlayer,
              "CTIMEDshowPlayer(%lx)::GraphStart()",
              this));

    m_fLoadError = false;

    if (m_fMediaComplete == false)
    {
        goto done;
    }

    hr = THR(m_pMC->Run());
    if (FAILED(hr))
    {
        m_fLoadError = true;
    }

  done: 

    return;
}
    
HRESULT
CTIMEDshowPlayer::Render(HDC hdc, LPRECT prc)
{
    TraceTag((tagDshowTimePlayer,
              "CTIMEDshowPlayer(%lx)::Render(%d-%d)",
              this,
              prc->right - prc->left,
              prc->bottom - prc->top));
    HRESULT hr = S_OK;
    int iOrigBltMode;
    bool bIsOn;

    if(m_pTIMEElementBase == NULL)
    {
        goto done;
    }
        
    bIsOn = m_pTIMEElementBase->IsOn();

    // Protect against render calls before the player is ready to render.
    // Not oding this causes a BVT failure.
    if(!m_fDoneSetup)
    {
        goto done;
    }

    iOrigBltMode = SetStretchBltMode(hdc, COLORONCOLOR);
    if (0 == iOrigBltMode)
    {
        hr = E_FAIL;
        goto done;
    }

    if(m_fHasVideo && bIsOn)
    {
        m_pIMixerOCX->OnDraw(hdc, prc);
    }

    SetStretchBltMode(hdc, iOrigBltMode);
    
done:
    return hr;
}


// Helper functions..

HRESULT
CTIMEDshowPlayer::SetMixerSize(RECT *prect)
{
    HRESULT hr = S_OK;
    POINT pt;

    if (m_pIMixerOCX == NULL)
    {
        return S_OK;
    }
    pt.x = pt.y = 0;
    hr = m_pIMixerOCX->SetDrawRegion(&pt, prect, prect);

    return hr;
}

HRESULT
CTIMEDshowPlayer::SetSize(RECT *prect)
{
    HRESULT hr = S_OK;

    Assert(prect != NULL);
    return hr;
}

HRESULT
CTIMEDshowPlayer::GetMediaLength(double &dblLength)
{
    HRESULT hr;

    if (m_pMC == NULL || m_pMP == NULL)
    {
        return E_FAIL;
    }

    hr = m_pMP->get_Duration(&dblLength);
    return hr;
}


HRESULT
CTIMEDshowPlayer::CanSeek(bool &fcanSeek)
{
    HRESULT hr = S_OK;
    LONG canSeek;
    long seekFlags = 0;

    if (m_pExSeeking == NULL)
    {
        if (!m_pMP)
        {
            fcanSeek = false;
            goto done;
        }
        hr = m_pMP->CanSeekBackward(&canSeek);
        if (FAILED(hr))
        {
            fcanSeek = false;
            goto done;
        }
        if (canSeek == 0)
        {
            fcanSeek = false;
            goto done;
        }
        hr = m_pMP->CanSeekForward(&canSeek);
        if (FAILED(hr))
        {
            fcanSeek = false;
            goto done;
        }
        if (canSeek == 0)
        {
            fcanSeek = false;
            goto done;
        }
        fcanSeek = true;
    }
    else
    {
        hr = m_pExSeeking->get_ExSeekCapabilities( &seekFlags);
        if (SUCCEEDED(hr)) 
        {
            if( seekFlags & AM_EXSEEK_CANSEEK)
            {
                fcanSeek = true;
                goto done;
            }
        }
        hr = S_OK;
        fcanSeek = false;
    }

done:
    return hr;
}


HRESULT
CTIMEDshowPlayer::GetAuthor(BSTR *pAuthor)
{
    HRESULT hr = S_OK;

    if (NULL != pAuthor)
    {
        if (m_pMediaContent != NULL)
        {
            hr = m_pMediaContent->get_AuthorName(pAuthor);
            if (FAILED(hr))
            {
                *pAuthor = NULL;
            }
        }

        if (FAILED(hr) || m_pMediaContent == NULL)
        {
            hr = ReadContentProperty(m_pGB, L"INFO/IART", pAuthor);
            if (FAILED(hr))
            {
                *pAuthor = NULL;
            }
        }
    }
    return hr;
}

HRESULT
CTIMEDshowPlayer::GetTitle(BSTR *pTitle)
{
    HRESULT hr = S_OK;

    if (NULL != pTitle)
    {
        if (m_pMediaContent != NULL)
        {
            hr = m_pMediaContent->get_Title(pTitle);
            if (FAILED(hr))
            {
                *pTitle = NULL;
            }
        }

        if (FAILED(hr) || m_pMediaContent == NULL)
        {
            hr = ReadContentProperty(m_pGB, L"INFO/INAM", pTitle);
            if (FAILED(hr))
            {
                hr = ReadContentProperty(m_pGB, L"INFO/ISBJ", pTitle);
                if (FAILED(hr))
                {
                    *pTitle = NULL;
                }
            }
        }
    }
    return hr;
}

HRESULT
CTIMEDshowPlayer::GetCopyright(BSTR *pCopyright)
{
    HRESULT hr = S_OK;

    if (NULL != pCopyright)
    {
        if (m_pMediaContent != NULL)
        {
            hr = m_pMediaContent->get_Copyright(pCopyright);
            if (FAILED(hr))
            {
                *pCopyright = NULL;
            }
        }

        if (FAILED(hr) || m_pMediaContent == NULL)
        {
            hr = ReadContentProperty(m_pGB, L"INFO/ICOP", pCopyright);
            if (FAILED(hr))
            {
                *pCopyright = NULL;
            }
        }
    }
    return hr;
}


HRESULT
CTIMEDshowPlayer::GetAbstract(BSTR *pBstrAbstract)
{
    HRESULT hr = S_OK;

    if (NULL != pBstrAbstract)
    {
        if (m_pMediaContent != NULL)
        {
            hr = m_pMediaContent->get_Description(pBstrAbstract);
            if (FAILED(hr))
            {
                *pBstrAbstract = NULL;
            }
        }
        else
        {
            *pBstrAbstract = NULL;
        }
    }
    return hr;
}


HRESULT
CTIMEDshowPlayer::GetRating(BSTR *pBstrRating)
{
    HRESULT hr = S_OK;

    if (NULL != pBstrRating)
    {
        if (m_pMediaContent != NULL)
        {
            hr = m_pMediaContent->get_Rating(pBstrRating);
            if (FAILED(hr))
            {
                *pBstrRating = NULL;
            }
        }
        else
        {
            *pBstrRating = NULL;
        }
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////
// This should take the lpszExtra info parameter from a URL_COMPONENTS structure.  In this
// field, the #html or #sami should be the first 5 characters in the string.
//////////////////////////////////////////////////////////////////////////////////////////////
void  
CTIMEDshowPlayer::SetStreamFlags(LPOLESTR src)
{
    long len = 0;
    OLECHAR stream[HTMLSTREAMSRCLEN + 1] = {0};
    
    m_bIsSAMISrc = false;
    m_bIsHTMLSrc = false;

    len = lstrlenW(src);
    if (len >= HTMLSTREAMSRCLEN)
    {
        memcpy((void *)stream, (void *)src, HTMLSTREAMSRCLEN * sizeof(OLECHAR));
    
        if (StrCmpIW(stream, HTMLSTREAMSRC) == 0)
        {
            m_bIsHTMLSrc = true;
        }
        if (StrCmpIW(stream, SAMISTREAMSRC) == 0)
        {
            m_bIsSAMISrc = true;
        }
    
    }
}

HRESULT
CTIMEDshowPlayer::DisableAudioVideo()
{
    HRESULT hr = E_FAIL;

    CComPtr<IBaseFilter> pMediaFilter;
    CComPtr<IPin> pPin;
    CComPtr<IEnumPins> pMediaPinEnum;
    
    //disconnect the video
    if (m_pMediaContent == NULL)
    {
        hr = E_FAIL;
        goto done;
    }
    hr = m_pMediaContent->QueryInterface(IID_IBaseFilter, (void **)&pMediaFilter);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pMediaFilter->EnumPins(&pMediaPinEnum);
    if (!pMediaPinEnum)
    {
        goto done;
    }
    while(pMediaPinEnum->Next(1, &pPin, NULL) == S_OK)
    {
        if (pPin != NULL)
        {
            IGNORE_HR(pPin->Disconnect());
        }
    }
    
    //silence the audio
    if (m_pBasicAudio != NULL)
    {
        hr = THR(m_pBasicAudio->put_Volume(SOUND_OF_SILENCE));
        if (FAILED(hr))
        {
            goto done;
        }
    }
    hr = S_OK;

done:
    return hr;
}


STDMETHODIMP
CTIMEDshowPlayer::InitializeElementAfterDownload()
{
    HRESULT hr = S_OK;
    TraceTag((tagDshowTimePlayer, "CTIMEDshowPlayer(%lx)(%x)::InitializeElementAfterDownload",this));

    const WCHAR * cpchSrc = NULL;
    
    //create and initailzie the URL_COMPONENTS structure
    URL_COMPONENTSW URLComp;

    ZeroMemory(&URLComp, sizeof(URL_COMPONENTS));
    URLComp.dwStructSize = sizeof(URL_COMPONENTS);
    URLComp.dwUrlPathLength = INTERNET_MAX_URL_LENGTH;
    URLComp.dwExtraInfoLength = INTERNET_MAX_URL_LENGTH;

    if (m_fRemoved)
    {
        hr = E_FAIL;
        m_pMC->Stop();
        goto done;
    }

    hr = this->GraphFinish();
    if (FAILED(hr))
    {
        goto done;
    }

    if (m_fNeedToDeleteInterfaces)
    {
        goto done;
    }

    m_fMediaComplete = true;

    FireMediaEvent(PE_ONMEDIACOMPLETE);
    
    IGNORE_HR(this->InitElementDuration());
    
    m_pTIMEElementBase->InvalidateElement(NULL);

    InternalReset(true);
    
    hr = GetAtomTable()->GetNameFromAtom(m_lSrc, &cpchSrc);
    if (FAILED(hr))
    {
        goto done;
    }
    
    if (!InternetCrackUrlW(cpchSrc, lstrlenW(cpchSrc), 0, &URLComp))
    {
        hr = E_INVALIDARG;
        goto done;
    }
    
    if (IsHTMLSrc(URLComp.lpszExtraInfo))
    {
        hr = THR(DisableAudioVideo());
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else
    {
        hr = InitElementSize();
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done:

    return hr;
}

STDMETHODIMP
CTIMEDshowPlayer::GetUniqueID(long * plID)
{
    HRESULT hr = S_OK;

    Assert(NULL != plID);

    *plID = m_lSrc;

    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP
CTIMEDshowPlayer::GetPriority(double * pdblPriority)
{
    HRESULT hr = S_OK;
    if (NULL == pdblPriority)
    {
        return E_POINTER;
    }

    if (m_fHavePriority)
    {
        *pdblPriority = m_dblPriority;
    }
    
    Assert(m_pTIMEElementBase != NULL);
    Assert(NULL != m_pTIMEElementBase->GetElement());

    *pdblPriority = INFINITE;

    CComVariant varAttribute;
    
    hr = m_pTIMEElementBase->base_get_begin(&varAttribute);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = VariantChangeType(&varAttribute, &varAttribute, 0, VT_R8);
    if (FAILED(hr))
    {
        if ( DISP_E_TYPEMISMATCH == hr)
        {
            hr = S_OK;
        }
        goto done;
    }
    
    // either they set a priority or a begin time!
    *pdblPriority = varAttribute.dblVal;

    m_dblPriority = *pdblPriority;
    m_fHavePriority = true;
    
    hr = S_OK;
done:
    return hr;
}

HRESULT 
CTIMEDshowPlayer::GetNaturalHeight(long *height)
{
    if (m_nativeVideoHeight == 0)
    {
        *height = -1;
    }
    else
    {
        *height = (long)m_nativeVideoHeight;
    }
    
    return S_OK;
}

HRESULT 
CTIMEDshowPlayer::GetNaturalWidth(long *width)
{
    if (m_nativeVideoWidth == 0)
    {
        *width  = -1;
    }
    else
    {
        *width = (long)m_nativeVideoWidth;
    }

    return S_OK;
}

PlayerState
CTIMEDshowPlayer::GetState()
{
    PlayerState state;
    
    if (!m_bActive)
    {
        if (!m_fMediaComplete)
        {
            state = PLAYER_STATE_CUEING;
        }
        else
        {
            state = PLAYER_STATE_INACTIVE;
        }
    }
    else
    {
        if(!m_bMediaDone)
        {
            state = PLAYER_STATE_ACTIVE;
        }
        else
        {
            state = PLAYER_STATE_HOLDING;
        }
    }

    return state;
}

STDMETHODIMP
CTIMEDshowPlayer::GetMediaDownloader(ITIMEMediaDownloader ** ppImportMedia)
{
    HRESULT hr = S_OK;

    Assert(NULL != ppImportMedia);

    *ppImportMedia = NULL;

    hr = S_FALSE;
done:
    return hr;
}

STDMETHODIMP
CTIMEDshowPlayer::PutMediaDownloader(ITIMEMediaDownloader * pImportMedia)
{
    HRESULT hr = S_OK;
    
    hr = E_NOTIMPL;
done:
    return hr;
}

HRESULT
CTIMEDshowPlayer::Reset()
{
    return InternalReset(true);
}


HRESULT
CTIMEDshowPlayer::CanSeekToMarkers(bool &bcanSeekToM)
{
    HRESULT hr = S_OK;
    long lseekFlags;

    if( m_pExSeeking == NULL)
    {
        bcanSeekToM = false;
        goto done;
    }

    hr = m_pExSeeking->get_ExSeekCapabilities(&lseekFlags);
    if(FAILED(hr))
    {
        bcanSeekToM = false;
        goto done;
    }
    if(lseekFlags & AM_EXSEEK_MARKERSEEK)
    {
        bcanSeekToM = true;
    }
    else
    {
        bcanSeekToM = false;
    }
    hr = S_OK;

done:
    return hr;
}

HRESULT
CTIMEDshowPlayer::IsBroadcast(bool &bisBroad)
{
    HRESULT hr = S_OK;
    VARIANT_BOOL vbVal;

    if(m_fMediaComplete == false)
    {
        bisBroad = false;
        goto done;
    }

    if( m_pIAMNetStat == NULL)
    {
        bisBroad = false;
        goto done;
    }

    hr = m_pIAMNetStat->get_IsBroadcast(&vbVal);
    if(FAILED(hr))
    {
        bisBroad = false;
        goto done;
    }
    if(vbVal)
    {
        bisBroad = true;
    }
    else
    {
        bisBroad = false;
    }
    hr = S_OK;

done:
    return hr;
}

HRESULT
CTIMEDshowPlayer::HasMedia(bool &bHasMedia)
{
    bHasMedia = m_fMediaComplete;

    return S_OK;
}

HRESULT
CTIMEDshowPlayer::HasVisual(bool &bHasVideo)
{
    bHasVideo = m_fHasVideo;
    return S_OK;
}

HRESULT
CTIMEDshowPlayer::HasAudio(bool &bHasAudio)
{

    if(m_pBasicAudio != NULL)
    {
        bHasAudio = true;
    }
    else
    {
        bHasAudio = false;
    }
    return S_OK;
}

HRESULT
CTIMEDshowPlayer::GetRate(double &dblRate)
{
    HRESULT hr = S_OK;

    if(m_pMS != NULL)
    {
        hr = m_pMS->GetRate(&dblRate);
    }

    return hr;
}


HRESULT
CTIMEDshowPlayer::SetRate(double dblRate)
{
    HRESULT hr = S_OK;

    if((m_pMS != NULL) && (m_pIAMNetStat == NULL))
    {
        hr = m_pMS->SetRate(dblRate);
    }

    return hr;
}

STDMETHODIMP
CTIMEDshowPlayer::InternalEvent()
{
    m_fCanCueNow = true;

    Assert (NULL != GetImportManager());

    IGNORE_HR(GetImportManager()->DataAvailable());
    
    return S_OK;
}

HRESULT
CTIMEDshowPlayer::GetIsStreamed(bool &fIsStreamed)
{
    HRESULT hr = S_OK;

    if (m_pIAMNetStat)
    {
        fIsStreamed = true;
    }
    else
    {
        fIsStreamed = false;
    }

done:
    return hr;
}

HRESULT
CTIMEDshowPlayer::GetBufferingProgress(double &dblBufferingProgress)
{
    HRESULT hr = S_OK;
    long lbProg;

    if (!m_pIAMNetStat)
    {
        dblBufferingProgress = 0.0;
        goto done;
    }

    if (FAILED(m_pIAMNetStat->get_BufferingProgress( &lbProg)))
    {
        dblBufferingProgress = 0.0;
        goto done;
    }

    dblBufferingProgress = (double )lbProg;

    hr = S_OK;
done:
    return hr;
}

HRESULT
CTIMEDshowPlayer::GetHasDownloadProgress(bool &fHasDownloadProgress)
{
    HRESULT hr = S_OK;
    bool fIsStreamed;

    if(FAILED(hr = GetIsStreamed(fIsStreamed)))
    {
        goto done;
    }

    if (fIsStreamed)
    {
        fHasDownloadProgress = false;
    }
    else
    {
        fHasDownloadProgress = true;
    }

    hr = S_OK;
done:
    return hr;
}

void
CTIMEDshowPlayer::Block()
{
    if(m_pProxy)
    {
        m_pProxy->Block();
    }
}

void
CTIMEDshowPlayer::UnBlock()
{
    if(m_pProxy)
    {
        m_pProxy->UnBlock();
    }
}

bool
CTIMEDshowPlayer::CanCallThrough()
{
    if(m_pProxy)
    {
        return m_pProxy->CanCallThrough();
    }
    else
    {
        return true;
    }
}

bool
CTIMEDshowPlayer::FireProxyEvent(PLAYER_EVENT plEvent)
{
    bool fRet = false;
    CTIMEPlayerNative *pNativePlayer;

    if(m_pPlaybackSite == NULL)
    {
       goto done;
    }

    if(m_pProxy)
    {
        m_pProxy->FireMediaEvent(plEvent, NULL);
        fRet = true;
    }
    else if(m_pPlaybackSite && (pNativePlayer = m_pPlaybackSite->GetNativePlayer()) != NULL)
    {
        pNativePlayer->FireMediaEvent(plEvent, NULL);
        fRet = true;
    }

done:
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\playerdshowtest.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: player.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#if DBG == 1

#include "playerdshowtest.h"
#include "mediaelm.h"

// Suppress new warning about NEW without corresponding DELETE 
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )  

DeclareTag(tagDshowTestTimePlayer, "TIME: Players", "CTIMEDshowTestPlayer methods");

CTIMEDshowTestPlayer::CTIMEDshowTestPlayer() :
    CTIMEDshowPlayer(NULL)
{
}

CTIMEDshowTestPlayer::~CTIMEDshowTestPlayer()
{
    TraceTag((tagDshowTestTimePlayer,
              "CTIMEDshowTestPlayer(%lx)::~CTIMEDshowTestPlayer()",
              this));

}


STDMETHODIMP
CTIMEDshowTestPlayer::CueMedia()
{
    TraceTag((tagDshowTestTimePlayer,
              "CTIMEDshowPlayer(%lx)::CueMedia()",
              this));
    HRESULT hr = S_OK;


    hr = S_OK;
done:
    return hr;
}

HRESULT
CTIMEDshowTestPlayer::Init(CTIMEMediaElement *pelem, LPOLESTR base, LPOLESTR src, LPOLESTR lpMimeType, double dblClipBegin, double dblClipEnd)
{
    TraceTag((tagDshowTestTimePlayer,
              "CTIMEDshowPlayer(%lx)::Init)",
              this));   
    HRESULT hr = S_OK;
    LPOLESTR szSrc = NULL;

    hr = CTIMEDshowBasePlayer::Init(pelem, base, src, lpMimeType, dblClipBegin, dblClipEnd);
    if (FAILED(hr))
    {
        goto done;
    }
    
    m_pTIMEElementBase = pelem;
    if( dblClipBegin != -1.0)
    {
        m_dblClipStart = dblClipBegin;
    }

    if( dblClipEnd != -1.0)
    {
        m_dblClipEnd = dblClipEnd;
    }

    if (src == NULL)
    {
        hr = S_OK;
        goto done;
    }

    hr = THR(::TIMECombineURL(base, src, &szSrc));
    if (!szSrc)
    {
        hr = E_FAIL;
        goto done;
    }
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetAtomTable()->AddNameToAtomTable(szSrc, &m_lSrc);
    if (FAILED(hr))
    {
        goto done;
    }


    hr = InitDshow();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = BeginDownload();
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = GraphFinish();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = InitElementDuration();
    if (FAILED(hr))
    {
        goto done;
    }
    hr = InitElementSize();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:

    delete[] szSrc;
    return hr;
}

HRESULT
CTIMEDshowTestPlayer::GetExternalPlayerDispatch(IDispatch **ppDisp)
{
    HRESULT hr = S_OK;
    hr = this->QueryInterface(IID_IDispatch, (void **)ppDisp);
    *ppDisp = static_cast<IDispatch*>(this);
    // ISSUE (mikhaill) -- the double definition of *ppDisp
    // + compiler warning (bug 104324)

    return hr;
}

STDMETHODIMP
CTIMEDshowTestPlayer::get_mediaTime(double *time)
{
    HRESULT hr = S_OK;
    double filterTime;

    hr = getFilterTime(filterTime);
    if(FAILED(hr))
    {
        hr = S_FALSE;
        *time = -1.0;
    }
    else
    {
        *time = filterTime;
    }
    return hr;
}


STDMETHODIMP
CTIMEDshowTestPlayer::get_mediaState(int *state)
{
    HRESULT hr = S_OK;

    getFilterState(*state);
    if(FAILED(hr))
    {
        hr = S_FALSE;
    }
    return hr;
}

STDMETHODIMP
CTIMEDshowTestPlayer::pause()
{
    HRESULT hr = S_OK;
    if (m_pMC == NULL || m_pMP == NULL)
    {
        return hr;
    }

    if (m_fMediaComplete == true)
    {
        m_pMC->Pause();
    }
    return hr;
}


STDMETHODIMP
CTIMEDshowTestPlayer::resume()
{
    HRESULT hr = S_OK;
    Resume();
    return hr;
}

STDMETHODIMP
CTIMEDshowTestPlayer::get_mediaRate(double *dblRate)
{
    HRESULT hr = S_OK;

    hr = GetRate(*dblRate);
    if(FAILED(hr))
    {
        hr = S_FALSE;
        *dblRate = -1.0;
    }

    return hr;
}

STDMETHODIMP
CTIMEDshowTestPlayer::put_mediaRate(double dblRate)
{
    HRESULT hr = S_OK;

    hr = SetRate(dblRate);
    if(FAILED(hr))
    {
        hr = S_FALSE;
    }

    return hr;
}



void
CTIMEDshowTestPlayer::Resume()
{

    if (m_pMC == NULL || m_pMP == NULL)
    {
        return;
    }

    bool bIsActive = m_pTIMEElementBase->IsActive();
    bool bIsCurrPaused = m_pTIMEElementBase->IsCurrPaused();
    float flTeSpeed = 0.0;
    bool fHaveTESpeed = m_pTIMEElementBase->GetTESpeed(flTeSpeed);

    if(fHaveTESpeed && flTeSpeed < 0.0)
    {
        goto done;
    }

    if( (bIsActive && !bIsCurrPaused) || m_fIsOutOfSync)
    {
        if (m_fMediaComplete == true)
        {
            m_pMC->Run();
        }
        m_fRunning = true;
    }

done:
    return;
}


STDMETHODIMP
CTIMEDshowTestPlayer::get_peerSyncFlag(VARIANT_BOOL *flag)
{
    HRESULT hr = S_OK;
    bool fsync;

    if(m_pTIMEElementBase == NULL)
    {
        *flag = VARIANT_FALSE;
        goto done;
    }

    fsync = m_pTIMEElementBase->IsSyncMaster();
    if(fsync)
    {
        *flag = VARIANT_TRUE;
    }
    else
    {
        *flag = VARIANT_FALSE;
    }

done:
    return hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\playerdmusic.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: player.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/
#pragma once

#ifndef _DMUSICPLAYER_H
#define _DMUSICPLAYER_H

#include "playerbase.h"
#include "mstimep.h"
#include "dmusici.h"
#include "loader.h"
#include "mediaelm.h"
#include "dmusicproxy.h"

class CTIMEMediaElement;

typedef enum SEG_TYPE_ENUM
{
    seg_primary,
    seg_secondary,
    seg_control,
    seg_max
}; //lint !e612

typedef enum BOUNDARY_ENUM 
{
    bound_default,
    bound_immediate,
    bound_grid,
    bound_beat,
    bound_measure,
    bound_queue,
    bound_max
}; //lint !e612

typedef enum TRANS_TYPE_ENUM
{
    trans_endandintro,
    trans_intro,
    trans_end,
    trans_break,
    trans_fill,
    trans_regular,
    trans_none,
    trans_max
}; //lint !e612

class CTIMEDMusicStaticHolder;
enum enumHasDM { dm_unknown, dm_yes, dm_no };
enum enumVersionDM { dmv_61, dmv_70orlater };

/////////////////////////////////////////////////////////////////////////////
// CTIMEPlayerDMusic

class
__declspec(uuid("efbad7f8-3f94-11d2-b948-00c04fa32195"))
CTIMEPlayerDMusic :
    public CTIMEBasePlayer,
    public CComObjectRootEx<CComSingleThreadModel>,
    public ITIMEDispatchImpl<ITIMEDMusicPlayerObject, &IID_ITIMEDMusicPlayerObject>,
    public ITIMEImportMedia,
    public IBindStatusCallback
{
  public:
    CTIMEPlayerDMusic(CTIMEPlayerDMusicProxy * pProxy);
    virtual ~CTIMEPlayerDMusic();

    HRESULT GetExternalPlayerDispatch(IDispatch **ppDisp);

    BEGIN_COM_MAP(CTIMEPlayerDMusic)        
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ITIMEImportMedia)
        COM_INTERFACE_ENTRY(IBindStatusCallback)
    END_COM_MAP_X();

    // IUnknown Methods
    STDMETHOD (QueryInterface)(REFIID refiid, void** ppunk)
        {   return _InternalQueryInterface(refiid, ppunk); };


    HRESULT Init(CTIMEMediaElement *pelem, LPOLESTR base, LPOLESTR src, LPOLESTR lpMimeType, double dblClipBegin = -1.0, double dblClipEnd = -1.0); //lint !e1735
    HRESULT DetachFromHostElement (void);
    HRESULT InitElementSize();
    HRESULT SetSize(RECT *prect);
    HRESULT Render(HDC hdc, LPRECT prc);

    HRESULT clipBegin(VARIANT varClipBegin);
    HRESULT clipEnd(VARIANT varClipEnd);

    
    void OnTick(double dblSegmentTime,
                LONG lCurrRepeatCount);

    void Start();
    void Stop();
    void Pause();
    void Resume();
    void Repeat();

    HRESULT Reset();
    void PropChangeNotify(DWORD tePropType);

    bool SetSyncMaster(bool fSyncMaster);

    HRESULT SetRate(double dblRate);
    HRESULT GetVolume(float *pflVolume);
    HRESULT SetVolume(float flVolume);
    HRESULT GetMute(VARIANT_BOOL *pvarMute);
    HRESULT SetMute(VARIANT_BOOL varMute);
    HRESULT HasVisual(bool &fHasVideo);
    HRESULT HasAudio(bool &fHasAudio);
    HRESULT GetMimeType(BSTR *pMime);
    
    double GetCurrentTime();
    HRESULT GetCurrentSyncTime(double & dblSyncTime);
    HRESULT Seek(double dblTime);
    HRESULT GetMediaLength(double &dblLength);
    HRESULT CanSeek(bool &fcanSeek);
    PlayerState GetState();

    STDMETHOD(put_CurrentTime)(double   dblCurrentTime);
    STDMETHOD(get_CurrentTime)(double* pdblCurrentTime);
    HRESULT SetSrc(LPOLESTR base, LPOLESTR src);
    STDMETHOD(put_repeat)(long   lTime);
    STDMETHOD(get_repeat)(long* plTime);
    STDMETHOD(cue)(void);
        
    // IUnknown Methods
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);


    //
    // IDirectMusicPlayer
    //
    STDMETHOD(get_isDirectMusicInstalled)(VARIANT_BOOL *pfInstalled);

    //
    // ITIMEImportMedia methods
    //
    STDMETHOD(CueMedia)();
    STDMETHOD(GetPriority)(double *);
    STDMETHOD(GetUniqueID)(long *);
    STDMETHOD(InitializeElementAfterDownload)();
    STDMETHOD(GetMediaDownloader)(ITIMEMediaDownloader ** ppMediaDownloader);
    STDMETHOD(PutMediaDownloader)(ITIMEMediaDownloader * pMediaDownloader);
    STDMETHOD(CanBeCued)(VARIANT_BOOL * pVB_CanCue);
    STDMETHOD(MediaDownloadError)();

    //
    // IBindStatusCallback methods
    //
    STDMETHOD(OnStartBinding)( 
            /* [in] */ DWORD dwReserved,
            /* [in] */ IBinding __RPC_FAR *pib);
        
    STDMETHOD(GetPriority)( 
            /* [out] */ LONG __RPC_FAR *pnPriority);
        
    STDMETHOD(OnLowResource)( 
            /* [in] */ DWORD reserved);
        
    STDMETHOD(OnProgress)( 
            /* [in] */ ULONG ulProgress,
            /* [in] */ ULONG ulProgressMax,
            /* [in] */ ULONG ulStatusCode,
            /* [in] */ LPCWSTR szStatusText);
        
    STDMETHOD(OnStopBinding)( 
            /* [in] */ HRESULT hresult,
            /* [unique][in] */ LPCWSTR szError);
        
    STDMETHOD(GetBindInfo)( 
            /* [out] */ DWORD __RPC_FAR *grfBINDF,
            /* [unique][out][in] */ BINDINFO __RPC_FAR *pbindinfo);
        
    STDMETHOD(OnDataAvailable)( 
            /* [in] */ DWORD grfBSCF,
            /* [in] */ DWORD dwSize,
            /* [in] */ FORMATETC __RPC_FAR *pformatetc,
            /* [in] */ STGMEDIUM __RPC_FAR *pstgmed);
        
    STDMETHOD(OnObjectAvailable)( 
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ IUnknown __RPC_FAR *punk);
    
  protected:
    bool SafeToTransition();
    void InternalStart();
    void ResumeDmusic();

    // playback settings
    SEG_TYPE_ENUM m_eSegmentType;
    BOUNDARY_ENUM m_eBoundary;
    TRANS_TYPE_ENUM m_eTransitionType;
    bool m_fTransModulate;
    bool m_fTransLong;
    bool m_fImmediateEnd;

    // segment to play
    CComPtr<IDirectMusicSegment> m_comIDMSegment;

    // current playback state
    enum { playback_stopped, playback_paused, playback_playing } m_ePlaybackState;
    CComPtr<IDirectMusicSegmentState> m_comIDMSegmentState; // segment state of segment if it has been played
    CComPtr<IDirectMusicSegmentState> m_comIDMSegmentStateTransition; // segment state of a transition to the segment if it has been played
    REFERENCE_TIME m_rtStart; // time at which segment was played
    REFERENCE_TIME m_rtPause; // time at which playback was paused

  private:
    static CTIMEDMusicStaticHolder m_staticHolder;

    HRESULT ReadAttributes();
    HRESULT ReleaseInterfaces();
    CTIMEPlayerDMusic();
    
    LONG                   m_cRef;
    CTIMEMediaElement      *m_pTIMEMediaElement;
    bool                    m_bActive;
    bool                    m_fRunning;
    bool                    m_fAudioMute;
    float                   m_flVolumeSave;
    bool                    m_fLoadError;
    bool                    m_fMediaComplete;
    bool                    m_fHaveCalledStaticInit;
    bool                    m_fAbortDownload;

    long                    m_lSrc;
    long                    m_lBase;
    IStream                *m_pTIMEMediaPlayerStream;

    bool                    m_fRemoved;
    bool                    m_fHavePriority;
    double                  m_dblPriority;
    double                  m_dblPlayerRate;
    double                  m_dblSpeedChangeTime;
    double                  m_dblSyncTime;
    bool                    m_fSpeedIsNegative;


    bool                    m_fUsingInterfaces;
    bool                    m_fNeedToReleaseInterfaces;
    HRESULT                 m_hrSetSrcReturn;
    
    CritSect                m_CriticalSection;

    WCHAR                  *m_pwszMotif;
    bool                    m_fHasSrc;

    // used later if it's a motif in order to set secondary by default
    bool                    m_fSegmentTypeSet;

    CTIMEPlayerDMusicProxy *m_pProxy;
};

class CTIMEDMusicStaticHolder
{
  public:
    CTIMEDMusicStaticHolder();
    virtual ~CTIMEDMusicStaticHolder();

    HRESULT Init();
    
    IDirectMusicPerformance * GetPerformance() { CritSectGrabber cs(m_CriticalSection); return m_comIDMPerformance; }
    IDirectMusicComposer * GetComposer() { CritSectGrabber cs(m_CriticalSection); return m_comIDMComposer; }
    CLoader * GetLoader() { CritSectGrabber cs(m_CriticalSection); return m_pLoader; }
    enumVersionDM GetVersionDM() { CritSectGrabber cs(m_CriticalSection); return m_eVersionDM; }
    bool GetHasVersion8DM() { CritSectGrabber cs(m_CriticalSection); return m_fHasVersion8DM; }
    
    bool HasDM();
    
    void ReleaseInterfaces();

    CritSect&   GetCueMediaCriticalSection() { return m_CueMediaCriticalSection; }
    
  private:
    CritSect                            m_CriticalSection;
    CritSect                            m_CueMediaCriticalSection;
    
    bool                                m_fHaveInitialized;

    CComPtr<IDirectMusic>               m_comIDMusic;
    CComPtr<IDirectMusicPerformance>    m_comIDMPerformance;
    CComPtr<IDirectMusicComposer>       m_comIDMComposer;
    CLoader                            *m_pLoader;

    enumVersionDM                       m_eVersionDM;
    bool                                m_fHasVersion8DM;
    enumHasDM                           m_eHasDM;

    LONG                                m_lRef;

    void InitialState();
};

#endif /* _DMUSICPLAYER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\playerdshowtest.h ===
#if DBG == 1
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: player.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/
#pragma once

#ifndef _PLAYERDSHOWTEST_H
#define _PLAYERDSHOWTEST_H

#include "playerdshow.h"
#include "TimeEng.h"
#include "MediaPrivate.h"

/////////////////////////////////////////////////////////////////////////////
// CTTIMEPlayer

__declspec(selectany) extern const TCHAR ResourceString[] = _T("2");
// This is needed for the template ITIMEDispatchImpl

class
ATL_NO_VTABLE
__declspec(uuid("efbad7f8-3f94-11d2-b948-00c04fa32195")) 
CTIMEDshowTestPlayer :
    public CTIMEDshowPlayer,
    public ITIMEDispatchImpl<ITIMEDshowTestPlayerObject, &IID_ITIMEDshowTestPlayerObject, ResourceString>
{
  public:
    CTIMEDshowTestPlayer();
    virtual ~CTIMEDshowTestPlayer();

    // IUnknown Methods
    STDMETHOD (QueryInterface)(REFIID refiid, void** ppunk)
        {   return _InternalQueryInterface(refiid, ppunk); };
    HRESULT GetExternalPlayerDispatch(IDispatch **ppDisp);


    BEGIN_COM_MAP(CTIMEDshowTestPlayer)
        COM_INTERFACE_ENTRY(ITIMEDshowTestPlayerObject)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_CHAIN(CTIMEDshowBasePlayer)
    END_COM_MAP();

    HRESULT Init(CTIMEMediaElement *pelem, LPOLESTR base, LPOLESTR src, LPOLESTR lpMimeType, double dblClipBegin, double dblClipEnd);
    STDMETHOD(CueMedia)();

    STDMETHOD(get_mediaTime)(double *time);
    STDMETHOD(get_mediaState)(int *state);
    STDMETHOD(pause)();
    STDMETHOD(resume)();
    STDMETHOD(get_mediaRate)(double *dblRate);
    STDMETHOD(put_mediaRate)(double dblRate);
    STDMETHOD(get_peerSyncFlag)(VARIANT_BOOL *flag);

    void Resume();
};

#endif /* _PLAYERDSHOWTEST_H */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\playerdshowbase.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: player.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _PLAYERDSHOWBASE_H
#define _PLAYERDSHOWBASE_H

#include "playerbase.h"
#include "playernative.h"
#include <strmif.h>
#include <uuids.h>
#include <control.h>
#include <strmif.h>
#include <inc\qnetwork.h>

#define WM_INVALIDATE (WM_USER + 0)
#define WM_GRAPHNOTIFY (WM_USER + 1)
#define WM_CODECERROR (WM_USER + 2)

class CTIMEMediaElement;

/////////////////////////////////////////////////////////////////////////////
// CTTIMEPlayer
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
//EXTERN_GUID(IID_IAMFilterGraphCallback,0x56a868fd,0x0ad4,0x11ce,0xb0,0xa3,0x0,0x20,0xaf,0x0b,0xa7,0x70);

//interface IAMFilterGraphCallback : public IUnknown
//{
    // S_OK means rendering complete, S_FALSE means "retry now".
//    virtual HRESULT UnableToRender(IPin *pPin) = 0;

    // other methods?
//};

class CTIMEDshowBasePlayer :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CTIMEBasePlayer,
    public IAMFilterGraphCallback,
    public IServiceProvider
{
  public:
    CTIMEDshowBasePlayer();
    virtual ~CTIMEDshowBasePlayer();
    HRESULT Init(CTIMEMediaElement *pelem,
                 LPOLESTR base,
                 LPOLESTR src,
                 LPOLESTR lpMimeType,
                 double dblClipBegin,
                 double dblClipEnd);

    virtual void SetClipBeginFrame(long lClipBeginFrame);
    virtual void SetClipEndFrame(long lClipEndFrame);
    virtual void SetClipBegin(double dblClipBegin);
    virtual void SetClipEnd(double dblClipEnd);

  protected:
    HRESULT InitDshow();
    void DeinitDshow();
    virtual HRESULT BuildGraph() = 0;
    virtual HRESULT GetSpecificInterfaces() = 0;
    virtual void ReleaseSpecificInterfaces() = 0;
    virtual void FreeSpecificData() = 0;
    HRESULT GetGenericInterfaces();
    HRESULT ReleaseGenericInterfaces();

    HRESULT FindInterfaceOnGraph(IUnknown * pUnkGraph, REFIID riid, void **ppInterface);
    HRESULT GetMimeTypeFromGraph(BSTR *pvarMime);
    void SetNaturalDuration(double dblMediaLength);
    void ClearNaturalDuration();
    HRESULT InitElementDuration();
    void FireMediaEvent(PLAYER_EVENT plEvent);
    virtual bool FireProxyEvent(PLAYER_EVENT plEvent) = 0;

    virtual void Block() = 0;
    virtual void UnBlock() = 0;
    virtual bool CanCallThrough() = 0;

    HRESULT InternalReset(bool bSeek);
    virtual void GraphStart(void) = 0;
    void InternalStart();
    HRESULT ForceSeek(double dblTime);

  public:
    HRESULT DetachFromHostElement (void);

    // IUnknown Methods
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);
    STDMETHOD (QueryInterface)(REFIID refiid, void** ppunk)=0;
    
    virtual HRESULT GetVolume(float *pflVolume);
    virtual HRESULT SetVolume(float flVolume, bool bMute /*= false*/);
    virtual HRESULT SetVolume(float flVolume);
#ifdef NEVER //dorinung 03-16-2000 bug 106458
    virtual HRESULT GetBalance(float *pflBalance);
    virtual HRESULT SetBalance(float flBalance);
#endif
    virtual HRESULT GetMute(VARIANT_BOOL *pvarMute);
    virtual HRESULT SetMute(VARIANT_BOOL varMute);
    virtual HRESULT GetEarliestMediaTime(double &dblEarliestMediaTime);
    virtual HRESULT GetLatestMediaTime(double &dblLatestMediaTime);
    virtual HRESULT SetMinBufferedMediaDur(double MinBufferedMediaDur);
    virtual HRESULT GetMinBufferedMediaDur(double &MinBufferedMediaDur);
    virtual HRESULT GetDownloadTotal(LONGLONG &lldlTotal);
    virtual HRESULT GetDownloadCurrent(LONGLONG &lldlCurrent);
    virtual HRESULT GetMimeType(BSTR *pMime);
    virtual HRESULT ConvertFrameToTime(LONGLONG iFrame, double &dblTime);
    virtual HRESULT GetCurrentFrame(LONGLONG &lFrameNr);

    virtual HRESULT GetAvailableTime(double &dblEarliest, double &dblLatest);

    BEGIN_COM_MAP(CTIMEDshowBasePlayer)
        COM_INTERFACE_ENTRY(IAMFilterGraphCallback)
        COM_INTERFACE_ENTRY(IServiceProvider)
        //COM_INTERFACE_ENTRY_CHAIN(CTIMEBasePlayer)
    END_COM_MAP_X();

    STDMETHOD(InternalEvent)();

    void Start();
    void Stop();
    void Pause();
    void Resume();
    void Repeat();

    double GetCurrentTime();
    HRESULT GetCurrentSyncTime(double & dblSyncTime);
    HRESULT Seek(double dblTime);

    void PropChangeNotify(DWORD tePropType);
    bool UpdateSync();

    void SetNativePlayer(CTIMEPlayerNative *pNativePlayer)
    { m_pNativePlayer = pNativePlayer;}

  protected:
    HRESULT CreateMessageWindow();
    static LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual void ProcessGraphEvents();

    // IAMFilterGraphCallback
    HRESULT UnableToRender(IPin *pPin);

    // IServiceProvider
    STDMETHOD(QueryService)(REFGUID guidService,
                            REFIID riid,
                            void** ppv);

#if DBG == 1
    HRESULT getFilterTime(double &time);
    HRESULT getFilterState(int &state);
#endif

    HRESULT DownloadCodec(IPin * pPin);

    HRESULT GraphCue(void);

    LONG m_cRef;
    bool m_fAudioMute;
    float m_flVolumeSave;
    bool m_bIsHTMLSrc;
    bool m_bIsSAMISrc;

    bool m_fRunning;
    bool m_bActive;
    bool m_bMediaDone;
    bool m_fIsOutOfSync;
    SYNC_TYPE_ENUM m_syncType;

    //generic graph interfaces
    CComPtr<IGraphBuilder> m_pGB;
    CComPtr<IMediaControl> m_pMC;
    CComPtr<IMediaEventEx> m_pMEx;
    CComPtr<IMediaEvent> m_pME;
    CComPtr<IMediaPosition> m_pMP;
    CComPtr<IMediaSeeking> m_pMS;
    CComPtr<IAMOpenProgress> m_pOP;
    CComPtr<IBasicAudio> m_pBasicAudio;

    CComPtr<IAMMediaContent> m_pMediaContent;;
    CComPtr<IBaseFilter> m_pOvM;
    CComPtr<IAMNetShowConfig> m_pIAMNetShowConfig;
    CComPtr<IAMExtendedSeeking> m_pExSeeking;
    CComPtr<IAMNetworkStatus> m_pIAMNetStat;
    CComPtr<IAMOpenProgress> m_spOpenProgress;

    HWND m_pwndMsgWindow;
    CLSID m_clsidDownloaded;
    HWND m_hwndDocument;
    bool m_fMediaComplete;
    bool m_fFiredComplete;
    double m_dblSyncTime;
    bool m_fSpeedIsNegative;
    bool m_fDetached;

    CTIMEPlayerNative *m_pNativePlayer;

};


#endif /* _PLAYERDSHOW_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\playerdvd.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: player.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "playerdvd.h"
#include "mediaelm.h"
#include <inc\evcode.h>
#include <inc\dvdevcod.h>
#include <inc\mpconfig.h>
#include "decibels.h"

#include "ddrawex.h"

#define SecsToNanoSecs 10000000

#define OVLMixer L"Overlay Mixer"

LONG CTIMEDVDPlayer::m_fDVDPlayer = 0;

// Suppress new warning about NEW without corresponding DELETE
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )

GUID IID_IDDrawNonExclModeVideo = {
            0xec70205c,0x45a3,0x4400,{0xa3,0x65,0xc4,0x47,0x65,0x78,0x45,0xc7}};

DeclareTag(tagDVDTimePlayer, "TIME: Players", "CTIMEDVDPlayer methods");

CTIMEDVDPlayer::CTIMEDVDPlayer() :
    m_pDvdGB(NULL),
    m_pVW(NULL),
    m_pDvdI(NULL),
    m_pDvdC(NULL),
    m_pDDEX(NULL),
    m_pDDS(NULL),
    m_pDD(NULL),
    m_fHasVideo(false),
    m_fLoaded(false),
    m_dblSeekAtStart(0.0),
    m_nativeVideoWidth(0),
    m_nativeVideoHeight(0),
    m_fAudioMute(false),
    m_flVolumeSave(0.0),
    m_hWnd(0),
    m_lPixelPosLeft(0),
    m_lPixelPosTop(0),
    m_lscrollOffsetx(0),
    m_lscrollOffsety(0)

{
    TraceTag((tagDVDTimePlayer,
              "CTIMEDVDPlayer(%lx)::CTIMEDVDPlayer()",
              this));

    m_clrKey = RGB(0x10, 0x00, 0x10);
    m_elementSize.bottom = 0;
    m_elementSize.left = 0;
    m_elementSize.top = 0;
    m_elementSize.right = 0;
    m_deskRect.bottom = 0;
    m_deskRect.left = 0;
    m_deskRect.top = 0;
    m_deskRect.right = 0;

}


CTIMEDVDPlayer::~CTIMEDVDPlayer()
{
    TraceTag((tagDVDTimePlayer,
              "CTIMEDVDPlayer(%lx)::~CTIMEDVDPlayer()",
              this));
    //dvd specific interfaces
    m_pDvdC = NULL;
    m_pDvdI = NULL;
    m_pDDEX = NULL;
    m_pVW = NULL;

    ReleaseGenericInterfaces();

    m_pDvdGB = NULL;

    if (m_pDDS != NULL)
    {
        m_pDDS->Release();
        m_pDDS = NULL;
    }

    if (m_pDD != NULL)
    {
        m_pDD->Release();
        m_pDD = NULL;
    }

    m_hWnd = 0;
}

STDMETHODIMP_(ULONG)
CTIMEDVDPlayer::AddRef(void)
{
    return CTIMEDshowBasePlayer::AddRef();
}


STDMETHODIMP_(ULONG)
CTIMEDVDPlayer::Release(void)
{
    return CTIMEDshowBasePlayer::Release();
}


HRESULT
CTIMEDVDPlayer::Init(CTIMEMediaElement *pelem, LPOLESTR base, LPOLESTR src, LPOLESTR lpMimeType, double dblClipBegin, double dblClipEnd)
{
    TraceTag((tagDVDTimePlayer,
              "CTIMEDVDPlayer(%lx)::Init)",
              this));
    HRESULT hr = S_OK;
    AM_DVD_RENDERSTATUS Status;
    IMixerPinConfig  *pMPC = NULL;
    LONG llock;

    m_pTIMEElementBase = pelem;

    CComPtr<IHTMLElement2> spElement2;

    if (m_fLoaded)
    {
        return hr;
    }
    llock = InterlockedExchange(&m_fDVDPlayer , 1);
    if(llock == 1)
    {
        hr = E_FAIL;
        goto done;
    }


    hr = InitDshow();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = SetUpDDraw();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = m_pDvdGB->RenderDvdVideoVolume(NULL, AM_DVD_HWDEC_PREFER, &Status);
    if (FAILED(hr))
    {
        goto done;
    }

    //hr = SetUpWindow();
    //if (FAILED(hr))
    //{
     //   goto done;
    //}
    hr = m_pDvdGB->GetDvdInterface(IID_IMixerPinConfig, (LPVOID *) &pMPC);

    if (SUCCEEDED(hr))
    {

        COLORKEY clr;
        clr.KeyType = CK_RGB ;
        clr.LowColorValue = m_clrKey;
        clr.HighColorValue = m_clrKey;

        hr = pMPC->SetColorKey(&clr);

        pMPC->Release() ;
    }

    hr = m_pDvdGB->GetDvdInterface(IID_IBasicAudio, (LPVOID *)&m_pBasicAudio);
    if (FAILED(hr))
    {
        m_pBasicAudio = NULL;
    }
    hr = m_pDvdGB->GetDvdInterface(IID_IDvdControl, (LPVOID *)&m_pDvdC) ;
    if (FAILED(hr))
    {
        goto done;
    }
    hr = m_pDvdGB->GetDvdInterface(IID_IDvdInfo, (LPVOID *)&m_pDvdI) ;
    if (FAILED(hr))
    {
        goto done;
    }

    // tell OM layer to set volume and mute

    hr = m_pTIMEElementBase->GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &spElement2));
    if (FAILED(hr))
    {
        // IE4 path
        CComPtr<IElementBehaviorSite> spElementBehaviorSite;
        spElementBehaviorSite = m_pTIMEElementBase->GetBvrSite();

        CComPtr<IObjectWithSite> spSite;
        // see if we are running on IE4, and try to get spSite to be a CElementBehaviorSite*
        hr = spElementBehaviorSite->QueryInterface(IID_TO_PPV(IObjectWithSite, &spSite));
        if (FAILED(hr))
        {
            goto done;
        }

        CComPtr<IOleWindow> spOleWindow;
        // ask for the site (through CElementBehaviorSite to CVideoHost, to ATL::IObjectWIthSiteImpl
        hr = spSite->GetSite(IID_IOleWindow, (void**) &spOleWindow);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CTIMEDVDPlayer::OnLoad - IE4 failure! unable to QI for IOleWindow on hosting Document"));
            goto done;
        }
    }

    if( dblClipBegin != -1.0)
    {
        m_dblClipStart = dblClipBegin;
    }

    if( dblClipEnd != -1.0)
    {
        m_dblClipEnd = dblClipEnd;
    }

    hr = THR(m_pMC->Run());
    if (FAILED(hr))
    {
        goto done;
    }
    m_fMediaComplete = true;

    IGNORE_HR(this->InitElementDuration());

    m_pTIMEElementBase->InvalidateElement(NULL);
    FireMediaEvent(PE_ONMEDIACOMPLETE);

    InternalReset(true);

    hr = InitElementSize();
    if (FAILED(hr))
    {
        goto done;
    }
    m_fLoaded = true;

done:
    if (FAILED(hr))
    {
        if (m_pTIMEElementBase)
        {
            FireMediaEvent(PE_ONMEDIAERROR);;
        }
    }
    return hr;
}

HRESULT
CTIMEDVDPlayer::DetachFromHostElement (void)
{
    HRESULT hr = S_OK;

    TraceTag((tagDVDTimePlayer,
              "CTIMEDVDPlayer(%lx)::DetachFromHostElement)",
              this));

    InterlockedExchange(&m_fDVDPlayer , 0);

    DeinitDshow();

    return hr;
}

void
CTIMEDVDPlayer::ReleaseSpecificInterfaces()
{
    m_pDvdC = NULL;
    m_pDvdI = NULL;
    m_pDDEX = NULL;
    m_pVW = NULL;
}

void
CTIMEDVDPlayer::FreeSpecificData()
{
    m_pDvdGB = NULL;

    if (m_pDDS != NULL)
    {
        m_pDDS->Release();
        m_pDDS = NULL;
    }

    if (m_pDD != NULL)
    {
        m_pDD->Release();
        m_pDD = NULL;
    }
}

void
CTIMEDVDPlayer::DeinitDshow()
{
    CTIMEDshowBasePlayer::DeinitDshow();
}

HRESULT
CTIMEDVDPlayer::SetUpMainWindow()
{
    CComPtr<IHTMLElement> pHTMLElem = m_pTIMEElementBase->GetElement();
    CComPtr<IHTMLDocument2> pHTMLDoc;
    CComPtr<IDispatch> pDisp;
    CComPtr<IOleWindow> pOleWindow;
    HRESULT hr = S_OK;

    hr = pHTMLElem->get_document(&pDisp);
    if (FAILED(hr))
    {
        goto done;
    }
    hr = pDisp->QueryInterface(IID_TO_PPV(IHTMLDocument2, &pHTMLDoc));
    if (FAILED(hr))
    {
        goto done;
    }
    hr = pHTMLDoc->QueryInterface(IID_TO_PPV(IOleWindow, &pOleWindow));
    if (FAILED(hr))
    {
        goto done;
    }
    hr = pOleWindow->GetWindow(&m_hWnd);
    if (FAILED(hr))
    {
        goto done;
    }

done:
    return hr;
}

HRESULT
CTIMEDVDPlayer::BuildGraph()
{
    HRESULT hr = S_OK;

    hr = CreateMessageWindow();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = CoCreateInstance(CLSID_DvdGraphBuilder, NULL, CLSCTX_INPROC,
        IID_IDvdGraphBuilder, (LPVOID *)&m_pDvdGB);
    if (FAILED(hr))
    {
        goto done;
    }
    hr = m_pDvdGB->GetFiltergraph(&m_pGB);
    if (FAILED(hr))
    {
        goto done;
    }
    hr = SetUpMainWindow();
    if (FAILED(hr))
    {
        goto done;
    }
done:
    return hr;
}

HRESULT
CTIMEDVDPlayer::GetSpecificInterfaces()
{
    HRESULT hr = S_OK;
done:
    return hr;
}


HRESULT
CTIMEDVDPlayer::InitDshow()
{
    HRESULT hr = S_OK;

    hr = CTIMEDshowBasePlayer::InitDshow();
    return hr;
}

HRESULT
CTIMEDVDPlayer::InitElementSize()
{
    DWORD aspectX, aspectY;
    HRESULT hr;
    RECT nativeSize, elementSize;
    bool fisNative;

    if (NULL == m_pTIMEElementBase)
    {
        hr = S_OK;
        goto done;
    }

    if( m_pDDEX == NULL)
    {
        hr = S_OK;
        goto done;
    }

    m_pDDEX->GetNativeVideoProps(&m_nativeVideoWidth, &m_nativeVideoHeight, &aspectX, &aspectY);

    if (m_nativeVideoWidth != 0 || m_nativeVideoHeight != 0)
    {
        m_fHasVideo = true;
    }

    nativeSize.left = nativeSize.top = 0;
    nativeSize.right = m_nativeVideoWidth;
    nativeSize.bottom = m_nativeVideoHeight;

    hr = m_pTIMEElementBase->NegotiateSize( nativeSize, elementSize, fisNative);

    m_elementSize.right = elementSize.right;
    m_elementSize.bottom = elementSize.bottom;

    PropagateOffsets();

done:
    return hr;
}

HRESULT
CTIMEDVDPlayer::InitElementDuration()
{
    HRESULT hr = S_OK;
    double mediaLength;

    hr = THR(GetMediaLength( mediaLength));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_pTIMEElementBase->GetMMBvr().PutNaturalDur(mediaLength));
    if (FAILED(hr))
    {
        goto done;
    }

    m_pTIMEElementBase->setNaturalDuration();
done:
    return hr;
}

HRESULT
CTIMEDVDPlayer::SetSrc(LPOLESTR base, LPOLESTR src)
{
    HRESULT hr = S_OK;

    return hr;
}


HRESULT
CTIMEDVDPlayer::SetUpWindow()
{
    HRESULT hr = S_OK;

    hr = m_pMC->QueryInterface(IID_IVideoWindow, (void **)&m_pVW);
    if (FAILED(hr))
    {
        goto done;
    }
    hr = m_pVW->put_Owner((OAHWND)m_hWnd);
    if (FAILED(hr))
    {
        goto done;
    }
    m_pVW->put_WindowStyle(WS_CHILD);
    if (FAILED(hr))
    {
        goto done;
    }
done:
    return hr;
}

HRESULT
CTIMEDVDPlayer::SetUpDDraw()
{

    HRESULT hr = E_UNEXPECTED;

    if (m_pDD != NULL)
    {
        // see if we went through this already
        return(hr);
    }

    hr = DirectDrawCreate(NULL, &m_pDD, NULL);
    //hr = m_pTIMEElementBase->GetServiceProvider()->QueryService(SID_SDirectDraw3, IID_TO_PPV(IDirectDraw, &m_pDD));
    if (FAILED(hr))
    {
        goto done;
    }

    if (FAILED(hr))
    {

        return(hr);
    }

    hr = m_pDD->SetCooperativeLevel(m_hWnd, DDSCL_NORMAL); //lint !e620

    if (FAILED(hr))
    {

        if (m_pDD != NULL)
        {
            m_pDD->Release();
            m_pDD = NULL;
        }

        return(hr);
    }

    DDSURFACEDESC ddsd;
    ::ZeroMemory(&ddsd, sizeof(ddsd));
    ddsd.dwSize = sizeof(ddsd);

    ddsd.dwFlags = DDSD_CAPS; //lint !e620
    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE; //lint !e620

    hr = m_pDD->CreateSurface(&ddsd, &m_pDDS, NULL);

    if (FAILED(hr))
    {

        if (m_pDD != NULL)
        {
            m_pDD->Release();
            m_pDD = NULL;
        }

        return(hr);
    }

    LPDIRECTDRAWCLIPPER pClipper; // clipper for our ddraw object

    hr = m_pDD->CreateClipper(0, &pClipper, NULL);

    if (FAILED(hr))
    {

        if (m_pDDS != NULL)
        {
            m_pDDS->Release();
            m_pDDS = NULL;
        }/* end of if statement */

        if (m_pDD != NULL)
        {
            m_pDD->Release();
            m_pDD = NULL;
        }

        return(hr);
    }

    hr = pClipper->SetHWnd(0, m_hWnd);

    if (FAILED(hr))
    {

        if (m_pDDS != NULL)
        {
            m_pDDS->Release();
            m_pDDS = NULL;
        }

        if (m_pDD != NULL)
        {
            m_pDD->Release();
            m_pDD = NULL;
        }


        if (pClipper != NULL)
        {
            pClipper->Release();
            pClipper = NULL;
        }

        return(hr);
    }


    hr = m_pDDS->SetClipper(pClipper);

    if (FAILED(hr))
    {
        if (m_pDDS != NULL)
        {
            m_pDDS->Release();
            m_pDDS = NULL;
        }

        if (m_pDD != NULL)
        {
            m_pDD->Release();
            m_pDD = NULL;
        }

        if (pClipper != NULL)
        {
            pClipper->Release();
            pClipper = NULL;
        }

        return(hr);
        }

    pClipper->Release();
    hr = m_pDvdGB->GetDvdInterface(IID_IDDrawExclModeVideo, (LPVOID *)&m_pDDEX);
    if (FAILED(hr))
    {
        goto done;
    }
    hr = m_pDDEX->SetDDrawObject(m_pDD);
    if (FAILED(hr))
    {
        goto done;
    }
    hr = m_pDDEX->SetDDrawSurface(m_pDDS);
    if (FAILED(hr))
    {
        goto done;
    }

done:
    return(hr);
}/* end of function SetupDDraw */

void
CTIMEDVDPlayer::OnTick(double dblSegmentTime,
                       LONG lCurrRepeatCount)
{
    TraceTag((tagDVDTimePlayer,
              "CTIMEDVDPlayer(%lx)::OnTick(%g, %d)",
              this,
              dblSegmentTime,
              lCurrRepeatCount));
}

void
CTIMEDVDPlayer::SetCLSID(REFCLSID clsid)
{
}

void
CTIMEDVDPlayer::GraphStart(void)
{
    HRESULT hr = S_OK;

    if(m_pMC == NULL)
    {
        goto done;
    }

    hr = m_pMC->Run();
    if (FAILED(hr))
    {
        if (m_pTIMEElementBase)
        {
            FireMediaEvent(PE_ONMEDIAERROR);
        }
    }
done:
    return;
}

HRESULT
CTIMEDVDPlayer::SetUpVideoOffsets()
{
    CComPtr<IDispatch> pDisp;
    CComPtr<IHTMLDocument2> pDoc;
    CComPtr<IHTMLElement> pBody;
    CComPtr<IHTMLElement> pElem;
    CComPtr<IHTMLElement2> pElem2;
    CComPtr<IHTMLWindow2> pWin2;
    CComPtr<IHTMLWindow4> pWin4;
    CComPtr<IHTMLFrameBase> pFrameBase;
    CComPtr<IHTMLElement> pFrameElem;
    long lscrollOffsetyc = 0, lscrollOffsetxc = 0, lPixelPosTopc = 0, lPixelPosLeftc = 0;

    HRESULT hr = S_OK;

    if(m_pTIMEElementBase == NULL)
    {
        hr = E_FAIL;
        goto done;
    }

    m_lscrollOffsety = m_lscrollOffsetx = m_lPixelPosTop = m_lPixelPosLeft = 0;

    hr = THR(m_pTIMEElementBase->GetElement()->get_document(&pDisp));
    if (FAILED(hr))
    {
        goto done;
    }
    hr = THR(pDisp->QueryInterface(IID_IHTMLDocument2, (void **)&pDoc));
    if (FAILED(hr))
    {
        goto done;
    }
    hr = pDoc->get_body(&pBody);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_pTIMEElementBase->GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElem2)));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pElem2->get_clientWidth(&(m_elementSize.right));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pElem2->get_clientHeight(&(m_elementSize.bottom));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = WalkUpTree(m_pTIMEElementBase->GetElement(), lscrollOffsetyc, lscrollOffsetxc, lPixelPosTopc, lPixelPosLeftc);
    if(FAILED(hr))
    {
        goto done;
    }

    hr = pDoc->get_parentWindow(&pWin2);
    if(FAILED(hr))
    {
        goto done;
    }
    hr = THR(pWin2->QueryInterface(IID_IHTMLWindow4, (void **)&pWin4));
    if (FAILED(hr) || pWin4 == NULL)
    {
        hr = S_OK;
        goto done;
    }

    hr = pWin4->get_frameElement(&pFrameBase);
    if (FAILED(hr) || pFrameBase == NULL)
    {
        goto done;
    }

    hr = THR(pFrameBase->QueryInterface(IID_IHTMLElement, (void **)&pFrameElem));
    if (FAILED(hr))
    {
        goto done;
    }

    IGNORE_HR(WalkUpTree(pFrameElem, lscrollOffsetyc, lscrollOffsetxc, lPixelPosTopc, lPixelPosLeftc));

done:
    m_lscrollOffsety = lscrollOffsetyc;
    m_lscrollOffsetx = lscrollOffsetxc;
    m_lPixelPosTop = lPixelPosTopc;
    m_lPixelPosLeft = lPixelPosLeftc;

    return hr;
}

void
CTIMEDVDPlayer::PropagateOffsets()
{
    RECT localRect;
    RECT videoRect;
    HRESULT hr;

    videoRect.top = 0;
    videoRect.left = 0;
    videoRect.right = 10000;
    videoRect.bottom = 10000;

    if(m_pDDEX == NULL)
    {
        hr = S_OK;
        goto done;
    }

    hr = SetUpVideoOffsets();
    if (FAILED(hr))
    {
        goto done;
    }

    localRect.top = m_lPixelPosTop - m_lscrollOffsety;
    localRect.left = m_lPixelPosLeft - m_lscrollOffsetx;
    localRect.bottom = localRect.top + m_elementSize.bottom;
    localRect.right = localRect.left + m_elementSize.right;
    ::MapWindowPoints(m_hWnd, HWND_DESKTOP, (POINT *)&localRect, 2);

    if((localRect.bottom == m_deskRect.bottom) &&
        (localRect.top == m_deskRect.top) &&
        (localRect.left == m_deskRect.left) &&
        (localRect.right == m_deskRect.right))
    {
        goto done;
    }

    GetRelativeVideoClipBox(localRect, m_elementSize, videoRect, 10000);

    m_deskRect = localRect;

    THR(m_pDDEX->SetDrawParameters(&videoRect, &localRect));
done:
    return;
}


void
CTIMEDVDPlayer::Tick()
{
    bool bIsOn = false;

    if(m_pTIMEElementBase == NULL)
    {
        goto done;
    }

    bIsOn = m_pTIMEElementBase->IsOn();

    if(!bIsOn || !m_fMediaComplete)
    {
        goto done;
    }

    TraceTag((tagDVDTimePlayer, "CTIMEDVDPlayer(%lx)(%x)::Tick",this));
    PropagateOffsets();

done:
    return;
}


HRESULT
CTIMEDVDPlayer::Render(HDC hdc, LPRECT prc)
{
    HBRUSH hbr = ::CreateSolidBrush(m_clrKey);

    bool bIsOn = false;

    if(m_pTIMEElementBase == NULL)
    {
        goto done;
    }

    bIsOn = m_pTIMEElementBase->IsOn();
    if(!bIsOn || !m_fMediaComplete)
    {
        goto done;
    }

    if(m_pDDEX == NULL)
    {
        goto done;
    }

    if (hbr && bIsOn)
    {
        ::FillRect(hdc, prc, hbr);
    }

done:
    if(hbr != NULL)
    {
        ::DeleteObject(hbr);
    }
    return S_OK;
}


// Helper functions..

double
CTIMEDVDPlayer::GetChapterTime()
{
    double dblCurrentTime = 0;
    HRESULT hr = S_OK;
    DVD_PLAYBACK_LOCATION pDVDLocation;
    DVD_TIMECODE *pDVDTime;

    hr = m_pDvdI->GetCurrentLocation(&pDVDLocation);
    if (FAILED(hr))
    {
        goto done;
    }

    pDVDTime = (DVD_TIMECODE *)(&pDVDLocation.TimeCode);
    dblCurrentTime = pDVDTime->Seconds1 + 10 * pDVDTime->Seconds10;
    dblCurrentTime += 60 * pDVDTime->Minutes1 + 600 * pDVDTime->Minutes10;
    dblCurrentTime += 3600 * pDVDTime->Hours1 + 36000 * pDVDTime->Hours10;
done:
    return dblCurrentTime;
}

HRESULT
CTIMEDVDPlayer::SetSize(RECT *prect)
{
    HRESULT hr = S_OK;
    RECT rc;
    RECT videoRect;

    if(m_pDDEX == NULL)
    {
        goto done;
    }

    Assert(prect != NULL);

    m_elementSize.right = prect->right;
    m_elementSize.bottom = prect->bottom;
    hr = SetUpVideoOffsets();
    if (FAILED(hr))
    {
        goto done;
    }

    rc.top = m_lPixelPosTop - m_lscrollOffsety;
    rc.left = m_lPixelPosLeft - m_lscrollOffsetx;
    rc.bottom = rc.top + prect->bottom;
    rc.right = rc.left + prect->right;

    ::MapWindowPoints(m_hWnd, HWND_DESKTOP, (POINT *)&rc, 2);

    GetRelativeVideoClipBox(rc, m_elementSize, videoRect, 10000);

    hr = m_pDDEX->SetDrawParameters(&videoRect, &rc);

done:
    return hr;
}

HRESULT
CTIMEDVDPlayer::GetMediaLength(double &dblLength)
{
    HRESULT hr;

    if (m_pMC == NULL || m_pMP == NULL)
    {
        return E_FAIL;
    }

    hr = m_pMP->get_Duration(&dblLength);
    return hr;
}


HRESULT
CTIMEDVDPlayer::CanSeek(bool &fcanSeek)
{
    LONG canSeek;
    HRESULT hr = S_OK;

    if(m_pMP == NULL)
    {
        fcanSeek = false;
        goto done;
    }

    hr = m_pMP->CanSeekBackward(&canSeek);
    if (FAILED(hr))
    {
        fcanSeek = false;
        goto done;
    }
    if (canSeek == 0)
    {
        fcanSeek = false;
        goto done;
    }
    hr = m_pMP->CanSeekForward(&canSeek);
    if (FAILED(hr))
    {
        fcanSeek = false;
        goto done;
    }
    if (canSeek == 0)
    {
        fcanSeek = false;
        goto done;
    }
    fcanSeek = true;
done:
    return hr;
}

HRESULT
CTIMEDVDPlayer::GetAuthor(BSTR *pAuthor)
{
    HRESULT hr = S_OK;


    return hr;
}

HRESULT
CTIMEDVDPlayer::GetTitle(BSTR *pTitle)
{
    HRESULT hr = S_OK;


    return hr;
}

HRESULT
CTIMEDVDPlayer::GetCopyright(BSTR *pCopyright)
{
    HRESULT hr = S_OK;

    return hr;
}

HRESULT
CTIMEDVDPlayer::GetVolume(float *pflVolume)
{
    HRESULT hr = S_OK;
    long lVolume;

    if (NULL == pflVolume)
    {
        hr = E_POINTER;
        goto done;
    }

    if (m_pBasicAudio == NULL)
    {
        if(m_pDvdGB != NULL)
        {
            hr = m_pDvdGB->GetDvdInterface(IID_IBasicAudio, (LPVOID *)&m_pBasicAudio);
            if (FAILED(hr))
            {
                m_pBasicAudio = NULL;
            }
        }
    }
    if (m_pBasicAudio != NULL)
    {
        if (m_fAudioMute == true)
        {
            *pflVolume = m_flVolumeSave;
            goto done;
        }

        hr = m_pBasicAudio->get_Volume(&lVolume);
        if (FAILED(hr))
        {
            goto done;
        }
        *pflVolume = VolumeLogToLin(lVolume);

    }
    else
    {
        hr = S_FALSE;
    }
done:
    return hr;
}


HRESULT
CTIMEDVDPlayer::SetVolume(float flVolume)
{
    HRESULT hr = S_OK;
    long lVolume = -10000;

    if (flVolume < 0.0 || flVolume > 1.0)
    {
        hr = E_FAIL;
        goto done;
    }
    lVolume = VolumeLinToLog(flVolume);

    if (m_pBasicAudio != NULL)
    {
        THR(hr = m_pBasicAudio->put_Volume(lVolume));
    }
    else
    {
        hr = E_FAIL;
    }
done:
    return hr;
}

#ifdef NEVER //dorinung 03-16-2000 bug 106458
HRESULT
CTIMEDVDPlayer::GetBalance(float *pflBal)
{
    HRESULT hr = S_OK;
    long lBal;

    if (NULL == pflBal)
    {
        hr = E_POINTER;
        goto done;
    }

    if (m_pBasicAudio == NULL)
    {
        hr = m_pDvdGB->GetDvdInterface(IID_IBasicAudio, (LPVOID *)&m_pBasicAudio);
        if (FAILED(hr))
        {
            m_pBasicAudio = NULL;
        }
    }

    if (m_pBasicAudio != NULL)
    {
        hr = m_pBasicAudio->get_Balance(&lBal);
        if (FAILED(hr))
        {
            goto done;
        }
        *pflBal = BalanceLogToLin(lBal);

    }
    else
    {
        hr = S_FALSE;
    }
done:
    return hr;
}

HRESULT
CTIMEDVDPlayer::SetBalance(float flBal)
{
    HRESULT hr = S_OK;
    long lBal = 0;

    if (flBal < 0.0 || flBal > 1.0)
    {
        hr = E_FAIL;
        goto done;
    }
    lBal = BalanceLinToLog(fabs(flBal));

    if (m_pBasicAudio != NULL)
    {
        THR(hr = m_pBasicAudio->put_Balance(lBal));
    }
    else
    {
        hr = E_FAIL;
    }
done:
    return hr;
}
#endif

HRESULT
CTIMEDVDPlayer::GetMute(VARIANT_BOOL *pVarMute)
{
    HRESULT hr = S_OK;

    if (NULL == pVarMute)
    {
        hr = E_POINTER;
        goto done;
    }


    *pVarMute = m_fAudioMute?VARIANT_TRUE:VARIANT_FALSE;
done:
    return hr;
}

HRESULT
CTIMEDVDPlayer::SetMute(VARIANT_BOOL varMute)
{
    HRESULT hr = S_OK;
    bool fMute = varMute?true:false;

    if (fMute == m_fAudioMute)
    {
        hr = S_OK;
        goto done;
    }

    if (fMute == true)
    {
        hr = GetVolume(&m_flVolumeSave);
        if (FAILED(hr))
        {
            goto done;
        }
        hr = SetVolume(MIN_VOLUME_RANGE); //lint !e747
    }
    else
    {
        hr = SetVolume(m_flVolumeSave);
    }
    m_fAudioMute = fMute;
done:
    return hr;
}

STDMETHODIMP
CTIMEDVDPlayer::upperButtonSelect()
{
    HRESULT hr = S_OK;
    TraceTag((tagDVDTimePlayer, "CTIMEDVDPlayer::upperButton"));

    if(m_pDvdC == NULL)
    {
        goto done;
    }
    hr = m_pDvdC->UpperButtonSelect();
    if (FAILED(hr))
    {
        TraceTag((tagError, "CTIMEDVDPlayer::upperButton::failed"));
        hr = S_FALSE;
    }
done:
    return hr;
}

STDMETHODIMP
CTIMEDVDPlayer::lowerButtonSelect()
{
    HRESULT hr = S_OK;
    TraceTag((tagDVDTimePlayer, "CTIMEDVDPlayer::lowerButton"));

    if(m_pDvdC == NULL)
    {
        goto done;
    }
    hr = m_pDvdC->LowerButtonSelect();
    if (FAILED(hr))
    {
        TraceTag((tagError, "CTIMEDVDPlayer::upperButton::failed"));
        hr = S_FALSE;
    }
done:
    return hr;
}

STDMETHODIMP
CTIMEDVDPlayer::leftButtonSelect()
{
    HRESULT hr = S_OK;
    TraceTag((tagDVDTimePlayer, "CTIMEDVDPlayer::leftButton"));

    if(m_pDvdC == NULL)
    {
        goto done;
    }
    hr = m_pDvdC->LeftButtonSelect();
    if (FAILED(hr))
    {
        TraceTag((tagError, "CTIMEDVDPlayer::upperButton::failed"));
        hr = S_FALSE;
    }
done:
    return hr;
}

STDMETHODIMP
CTIMEDVDPlayer::rightButtonSelect()
{
    HRESULT hr = S_OK;
    TraceTag((tagDVDTimePlayer, "CTIMEDVDPlayer::rightButton"));

    if(m_pDvdC == NULL)
    {
        goto done;
    }
    hr = m_pDvdC->RightButtonSelect();
    if (FAILED(hr))
    {
        TraceTag((tagError, "CTIMEDVDPlayer::upperButton::failed"));
        hr = S_FALSE;
    }
done:
    return hr;
}

STDMETHODIMP
CTIMEDVDPlayer::buttonActivate()
{
    HRESULT hr = S_OK;
    TraceTag((tagDVDTimePlayer, "CTIMEDVDPlayer::activateButton"));

    if(m_pDvdC == NULL)
    {
        goto done;
    }
    hr = m_pDvdC->ButtonActivate();
    if (FAILED(hr))
    {
        TraceTag((tagError, "CTIMEDVDPlayer::upperButton::failed"));
        hr = S_FALSE;
    }
done:
    return hr;
}

STDMETHODIMP
CTIMEDVDPlayer::gotoMenu()
{
    HRESULT hr = S_OK;
    TraceTag((tagDVDTimePlayer, "CTIMEDVDPlayer::gotoMenu"));

    if(m_pDvdC == NULL)
    {
        goto done;
    }
    hr = m_pDvdC->MenuCall(DVD_MENU_Root);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CTIMEDVDPlayer::gotoMenu::failed"));
        hr = S_FALSE;
    }
done:
    return hr;
}

HRESULT
CTIMEDVDPlayer::GetExternalPlayerDispatch(IDispatch **ppDisp)
{
    HRESULT hr = S_OK;
    hr = this->QueryInterface(IID_IDispatch, (void **)ppDisp);

    return hr;
}

HRESULT
CTIMEDVDPlayer::Reset()
{
    HRESULT hr = S_OK;
    bool bNeedActive;
    bool bNeedPause;


    if(m_pTIMEElementBase == NULL)
    {
        goto done;
    }

    bNeedActive = m_pTIMEElementBase->IsActive();
    bNeedPause = m_pTIMEElementBase->IsCurrPaused();

    if( !bNeedActive) // see if we need to stop the media.
    {
        Stop();
        goto done;

    }

    if( !m_bActive)
    {
        InternalStart();
    }

    //Now see if we need to change the pause state.

    if( bNeedPause)
    {
        if(!m_fIsOutOfSync)
        {
            Pause();
        }
    }
    else
    {
        if( !m_fRunning)
        {
            Resume();
        }
    }
done:
    return hr;
}

HRESULT
CTIMEDVDPlayer::HasMedia(bool &bHasMedia)
{
    bHasMedia = m_fMediaComplete;

    return S_OK;
}

HRESULT
CTIMEDVDPlayer::HasVisual(bool &bHasVideo)
{
    bHasVideo = m_fHasVideo;
    return S_OK;
}

HRESULT
CTIMEDVDPlayer::HasAudio(bool &bHasAudio)
{

    bHasAudio = true; // ISSUE DSHOW because audio interface not present for DVD always return true.
    return S_OK;
}

HRESULT
CTIMEDVDPlayer::GetNaturalHeight(long *height)
{
    if (m_nativeVideoHeight == 0)
    {
        *height = -1;
    }
    else
    {
        *height = (long)m_nativeVideoHeight;
    }

    return S_OK;
}

HRESULT
CTIMEDVDPlayer::GetNaturalWidth(long *width)
{
    if (m_nativeVideoWidth == 0)
    {
        *width  = -1;
    }
    else
    {
        *width = (long)m_nativeVideoWidth;
    }

    return S_OK;
}

void
CTIMEDVDPlayer::Block()
{
    return;
}

void
CTIMEDVDPlayer::UnBlock()
{
    return;
}

bool
CTIMEDVDPlayer::CanCallThrough()
{
    return true;
}


bool
CTIMEDVDPlayer::FireProxyEvent(PLAYER_EVENT plEvent)
{
    return false;
}


HRESULT
CTIMEDVDPlayer::GetMimeType(BSTR *pMime)
{
    HRESULT hr = S_OK;

    *pMime = SysAllocString(L"video/DVD");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\playerdshowbase.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: player.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "playerdshowbase.h"
#include "mediaelm.h"
#include "decibels.h"
#include <mmreg.h>
#include "codec.h"
#include <inc\evcode.h>

DeclareTag(tagDshowBaseTimePlayer, "TIME: Media", "CTIMEDshowBasePlayer methods");
DeclareTag(tagDownloadCodec, "TIME: Media", "Download Codec");

#define SecsToNanoSecs 10000000

CTIMEDshowBasePlayer::CTIMEDshowBasePlayer() :
    m_fRunning(false),
    m_bActive(false),
    m_bMediaDone(false),
    m_fIsOutOfSync(false),
    m_pOvM(NULL),
    m_pMediaContent(NULL),
    m_cRef(0),
    m_pMC(NULL),
    m_pGB(NULL),
    m_pME(NULL),
    m_pMEx(NULL),
    m_pMP(NULL),
    m_pMS(NULL),
    m_pBasicAudio(NULL),
    m_fAudioMute(false),
    m_flVolumeSave(0.0),
    m_pwndMsgWindow(NULL),
    m_clsidDownloaded(GUID_NULL),
    m_hwndDocument(NULL),
    m_bIsHTMLSrc(false),
    m_bIsSAMISrc(false),
    m_fMediaComplete(false),
    m_fFiredComplete(false),
    m_dblSyncTime(0.0),
    m_syncType(sync_none),
    m_fSpeedIsNegative(false),
    m_pNativePlayer(NULL),
    m_fDetached(false)

{
    TraceTag((tagDshowBaseTimePlayer,
              "CTIMEDshowBasePlayer(%lx)::CTIMEDshowBasePlayer()",
              this));


}

CTIMEDshowBasePlayer::~CTIMEDshowBasePlayer()
{
    TraceTag((tagDshowBaseTimePlayer,
              "CTIMEDshowBasePlayer(%lx)::~CTIMEDshowBasePlayer()",
              this));
    m_pwndMsgWindow = NULL;
    m_hwndDocument = NULL;
}


STDMETHODIMP_(ULONG)
CTIMEDshowBasePlayer::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG)
CTIMEDshowBasePlayer::Release(void)
{
    LONG l = InterlockedDecrement(&m_cRef);

    if (0 == l)
    {
        delete this;
    }
    return l;
}

HRESULT
CTIMEDshowBasePlayer::Init(CTIMEMediaElement *pelem, LPOLESTR base, LPOLESTR src, LPOLESTR lpMimeType, double dblClipBegin, double dblClipEnd)
{
    TraceTag((tagDshowBaseTimePlayer,
              "CTIMEDshowBasePlayer(%lx)::Init)",
              this));   
    HRESULT hr = S_OK;

    if (m_pTIMEElementBase != NULL) //this only happens in the case of reentrancy
    {
        hr = S_OK;
        goto done;
    }

    hr = CTIMEBasePlayer::Init(pelem, base, src, lpMimeType, dblClipBegin, dblClipEnd);
    if (FAILED(hr))
    {
        goto done;
    }

    // Cache here since we cannot call it back during codec download
    m_hwndDocument = GetDocumentHwnd(pelem->GetDocument());

    hr = S_OK;
done:
    return hr;
}

HRESULT
CTIMEDshowBasePlayer::DetachFromHostElement (void)
{
    HRESULT hr = S_OK;

    TraceTag((tagDshowBaseTimePlayer,
              "CTIMEDshowBasePlayer(%lx)::DetachFromHostElement)",
              this));

    m_hwndDocument = NULL;
    
    return hr;
}

void
CTIMEDshowBasePlayer::DeinitDshow()
{
    (void)::SetWindowLongPtr(m_pwndMsgWindow, GWLP_USERDATA, (LONG_PTR)NULL);
    (void)::PostMessage(m_pwndMsgWindow, WM_CLOSE, NULL, NULL);

    ReleaseSpecificInterfaces();
    ReleaseGenericInterfaces();
    FreeSpecificData();

}

HRESULT
CTIMEDshowBasePlayer::InitDshow()
{
    HRESULT hr = S_OK;

    hr = BuildGraph();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetGenericInterfaces();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetSpecificInterfaces();
    if (FAILED(hr))
    {
        goto done;
    }


done:
    return hr;
}


HRESULT
CTIMEDshowBasePlayer::GetGenericInterfaces()
{
    TraceTag((tagDshowBaseTimePlayer,
              "CTIMEDshowBasePlayer(%lx)::GetGenericInterfaces()",
              this));
    HRESULT hr = S_OK;
    CComPtr<IObjectWithSite> spSite;
    IUnknown *pSite;

    hr = m_pGB->QueryInterface(IID_IMediaControl, (void **)&m_pMC);
    if (FAILED(hr))
    {
        goto done;
    }
    hr = m_pMC->QueryInterface(IID_IMediaEvent, (void **)&m_pME);
    if (FAILED(hr))
    {
        goto done;
    }
    hr = m_pMC->QueryInterface(IID_IAMOpenProgress, (void **)&m_pOP);
    if (FAILED(hr))
    {
        goto done;
    }
    hr = m_pMC->QueryInterface(IID_IMediaEventEx, (void **)&m_pMEx);
    if (FAILED(hr))
    {
        goto done;
    }
    hr = m_pMC->QueryInterface(IID_IMediaPosition, (void **)&m_pMP);
    if (FAILED(hr))
    {
        goto done;
    }
    hr = m_pMC->QueryInterface(IID_IMediaSeeking, (void **)&m_pMS);
    if (FAILED(hr))
    {
        goto done;
    }
    if ( m_pMEx != NULL)
    {
        THR(m_pMEx -> SetNotifyWindow((OAHWND)m_pwndMsgWindow, WM_GRAPHNOTIFY, NULL));
    }

    hr = m_pGB->QueryInterface(IID_IObjectWithSite, (void **)&spSite);
    if (FAILED(hr))
    {
        goto done;
    }
    hr = QueryInterface(IID_IUnknown, (void **)&pSite);
    if (FAILED(hr))
    {
        goto done;
    }

    if(pSite)
    {
        hr = spSite->SetSite(pSite);
        pSite->Release();
    }


done:
    return hr;
}

HRESULT
CTIMEDshowBasePlayer::ReleaseGenericInterfaces()
{
    m_pBasicAudio = NULL;
    m_pMP = NULL;
    m_pMS = NULL;
    m_pOP = NULL;
    m_pMEx = NULL;
    m_pME = NULL;
    m_pGB = NULL;
    m_pMC = NULL;

    return S_OK;
}


HRESULT
CTIMEDshowBasePlayer::FindInterfaceOnGraph(IUnknown *pUnkGraph, REFIID riid, void **ppInterface)
{
    HRESULT hr = E_NOINTERFACE;

    CComPtr<IBaseFilter> pFilter;
    CComPtr<IEnumFilters> pEnum;
    CComPtr<IFilterGraph> pFilterGraph;

    if (!ppInterface)
    {
        hr = E_FAIL;
        goto done;
    }
    *ppInterface= NULL;

    if (!pUnkGraph)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = pUnkGraph->QueryInterface(IID_IFilterGraph, (void **)&pFilterGraph);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pFilterGraph->EnumFilters(&pEnum);
    if (!pEnum)
    {
        goto done;
    }

    hr = E_NOINTERFACE;
    
    // find the first filter in the graph that supports riid interface
    while(!*ppInterface && pEnum->Next(1, &pFilter, NULL) == S_OK)
    {
        hr = pFilter->QueryInterface(riid, ppInterface);
        pFilter.Release();
    }
done:
    return hr;
}

HRESULT
CTIMEDshowBasePlayer::GetVolume(float *pflVolume)
{
    HRESULT hr = S_OK;
    long lVolume;

    if (NULL == pflVolume)
    {
        hr = E_POINTER;
        goto done;
    }

    if (m_pBasicAudio != NULL)
    {
        if (m_fAudioMute == true)
        {
            *pflVolume = m_flVolumeSave;
            goto done;
        }

        hr = m_pBasicAudio->get_Volume(&lVolume);
        if (FAILED(hr))
        {
            goto done;
        }
        *pflVolume = VolumeLogToLin(lVolume);
        
    }
    else
    {
        hr = S_FALSE;
    }
done:
    return hr;
}


HRESULT
CTIMEDshowBasePlayer::SetVolume(float flVolume, bool bMute /*=false*/)
{
    HRESULT hr = S_OK;
    long lVolume;

    if (flVolume < 0.0 || flVolume > 1.0)
    {
        hr = E_FAIL;
        goto done;
    }

    // if muted, overwrite saved volume and exit
    if ((m_fAudioMute || m_bIsHTMLSrc || m_bIsSAMISrc) && !bMute) //if bMute == true then set the volume
    {
        m_flVolumeSave = flVolume;
        goto done;
    }
    
    lVolume = VolumeLinToLog(flVolume);

    if (m_pBasicAudio != NULL)
    {
        THR(hr = m_pBasicAudio->put_Volume(lVolume));
    }
    else
    {
        hr = E_FAIL;
    }
done:
    return hr;
}

HRESULT
CTIMEDshowBasePlayer::SetVolume(float flVolume)
{
    return SetVolume(flVolume, false);
}

#ifdef NEVER //dorinung 03-16-2000 bug 106458
HRESULT
CTIMEDshowBasePlayer::GetBalance(float *pflBal)
{
    HRESULT hr = S_OK;
    long lBal;

    if (NULL == pflBal)
    {
        hr = E_POINTER;
        goto done;
    }


    if (m_pBasicAudio != NULL)
    {
        hr = m_pBasicAudio->get_Balance(&lBal);
        if (FAILED(hr))
        {
            goto done;
        }
        *pflBal = BalanceLogToLin(lBal);
        
    }
    else
    {
        hr = S_FALSE;
    }
done:
    return hr;
}

HRESULT
CTIMEDshowBasePlayer::SetBalance(float flBal)
{
    HRESULT hr = S_OK;
    long lBal = 0;

    if (flBal < 0.0 || flBal > 1.0)
    {
        hr = E_FAIL;
        goto done;
    }
    lBal = BalanceLinToLog(fabs(flBal));

    if (m_pBasicAudio != NULL)
    {
        THR(hr = m_pBasicAudio->put_Balance(lBal));
    }
    else
    {
        hr = E_FAIL;
    }
done:
    return hr;
}
#endif

HRESULT
CTIMEDshowBasePlayer::GetMute(VARIANT_BOOL *pVarMute)
{
    HRESULT hr = S_OK;

    if (NULL == pVarMute)
    {
        hr = E_POINTER;
        goto done;
    }


    *pVarMute = m_fAudioMute?VARIANT_TRUE:VARIANT_FALSE;
done:
    return hr;
}

HRESULT
CTIMEDshowBasePlayer::SetMute(VARIANT_BOOL varMute)
{
    HRESULT hr = S_OK;
    bool fMute = varMute?true:false;
    long lVolume;

    if (fMute == m_fAudioMute)
    {
        //need to call SetVolume again without caching the old volume
        //this is a fix for bug #6605.
        if (fMute == true)
        {
            hr = SetVolume(MIN_VOLUME_RANGE, true); 
        }
        goto done;
    }

    if (fMute == true)
    {
        hr = GetVolume(&m_flVolumeSave);
        if (FAILED(hr))
        {
            goto done;
        }
        hr = SetVolume(MIN_VOLUME_RANGE, false); //lint !e747
    }
    else
    {
        //
        // cannot use SetVolume here because it depends on mute state
        //

        if (m_pBasicAudio == NULL)
        {
            hr = E_FAIL;
            goto done;
        }

        lVolume = VolumeLinToLog(m_flVolumeSave);

        THR(hr = m_pBasicAudio->put_Volume(lVolume));
    }

    // update state
    m_fAudioMute = fMute;

done:
    return hr;
}

#if DBG == 1
HRESULT
CTIMEDshowBasePlayer::getFilterTime(double &time)
{
    HRESULT hr = S_OK;
    REFTIME reftime;

    if (m_pMP != NULL)
    {
        hr = m_pMP->get_CurrentPosition(&reftime);
        time = reftime;
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    return hr;
}

HRESULT
CTIMEDshowBasePlayer::getFilterState(int &state)
{
    HRESULT hr = S_OK;
    OAFilterState filtState;

    if (m_pMC != NULL)
    {
        hr = m_pMC->GetState(10, &filtState);
        if(FAILED(hr))
        {
            state = -1;
            goto done;
        }
        switch(filtState)
        {
            case State_Stopped:
                state = 0;
                break;
            case State_Running:
                state = 1;
                break;
            case State_Paused:
                state = 2;
                break;
            default:
                state = -1;
                break;
        }
    }
    else
    {

        hr = E_UNEXPECTED;
        state = -1;
    }

done:
    return hr;
}
#endif

HRESULT
CTIMEDshowBasePlayer::CreateMessageWindow()
{
    static const TCHAR szClassName[] = TEXT("CTIMEDshowBasePlayerWindow");
    HRESULT hr = S_OK;

    WNDCLASSEX wc;

    wc.cbSize = sizeof(WNDCLASSEX);



    ZeroMemory(&wc, sizeof(wc));
    wc.cbSize = sizeof(WNDCLASSEX);
    wc.lpszClassName = szClassName;
    wc.lpfnWndProc = WindowProc;
    wc.hInstance = _Module.GetModuleInstance();

    (void)::RegisterClassEx(&wc);

    m_pwndMsgWindow = CreateWindow(
    szClassName,
    _T("VRCtlWindow"),
    0, 0, 0, 0, 0,
    (HWND)NULL, (HMENU)NULL,
    _Module.GetModuleInstance(),
    this);
    if ( m_pwndMsgWindow == NULL)
    {
        hr = E_FAIL;
    }

    return hr;
}

LRESULT CALLBACK
CTIMEDshowBasePlayer::WindowProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CTIMEDshowBasePlayer *lpThis;

    switch(uMsg)
    {
    case WM_CREATE:
        {
            TraceTag((tagDshowBaseTimePlayer, "CTIMEDshowBasePlayer::OVMixerWindowProc::WM_CREATE"));
            LPCREATESTRUCT lpcs = (LPCREATESTRUCT)lParam;
            ::SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)lpcs->lpCreateParams);
            return 0;
        }
    case WM_INVALIDATE:
        {
            //check GetWindowLongPtr for 64 bit comp.
            lpThis = (CTIMEDshowBasePlayer *)::GetWindowLongPtr(hwnd, GWLP_USERDATA);
            TraceTag((tagDshowBaseTimePlayer, "CTIMEDshowBasePlayer(%lx)::OVMixerWindowProc::WM_INVALIDATE", lpThis));
            if (lpThis != NULL)
            {
                if (NULL != lpThis->m_pTIMEElementBase)
                {
                    lpThis->m_pTIMEElementBase->InvalidateElement(NULL);
                }
            }
            return 0;
        }
    case WM_GRAPHNOTIFY:
        {
            lpThis = (CTIMEDshowBasePlayer *)::GetWindowLongPtr(hwnd, GWLP_USERDATA);
            if (lpThis != NULL)
            {
                if (NULL != lpThis->m_pTIMEElementBase)
                {
                    lpThis->ProcessGraphEvents();
                }
            }
            return 0;
        }
    case WM_CODECERROR:
        {
            lpThis = (CTIMEDshowBasePlayer *)::GetWindowLongPtr(hwnd, GWLP_USERDATA);
            if (lpThis)
            {
                if (lpThis->m_pTIMEElementBase)
                {
                    lpThis->m_pTIMEElementBase->FireMediaEvent(PE_ONCODECERROR);
                }
            }
        }
    default:
        return ::DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
}

HRESULT
CTIMEDshowBasePlayer::UnableToRender(IPin *pPin)
{
    HRESULT hr;

    hr = THR(DownloadCodec(pPin));
    if (S_OK != hr)
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

//
// IServiceProvider interfaces
//
STDMETHODIMP
CTIMEDshowBasePlayer::QueryService(REFGUID guidService,
                                   REFIID riid,
                                   void** ppv)
{
    return E_NOINTERFACE;
}

//========================================================================
//
// GetAMediaType
//
// Enumerate the media types of *ppin.  If they all have the same majortype
// then set MajorType to that, else set it to CLSID_NULL.  If they all have
// the same subtype then set SubType to that, else set it to CLSID_NULL.
// If something goes wrong, set both to CLSID_NULL and return the error.
//========================================================================
HRESULT GetAMediaType( IPin * ppin, CLSID & MajorType, CLSID & SubType)
{

    HRESULT hr;
    IEnumMediaTypes *pEnumMediaTypes;

    /* Set defaults */
    MajorType = CLSID_NULL;
    SubType = CLSID_NULL;

    hr = ppin->EnumMediaTypes(&pEnumMediaTypes);

    if (FAILED(hr)) {
        return hr;    // Dumb or broken filters don't get connected.
    }

    _ASSERTE (pEnumMediaTypes!=NULL);

    /* Put the first major type and sub type we see into the structure.
       Thereafter if we see a different major type or subtype then set
       the major type or sub type to CLSID_NULL, meaning "dunno".
       If we get so that both are dunno, then we might as well return (NYI).
    */

    BOOL bFirst = TRUE;

    for ( ; ; ) {

        AM_MEDIA_TYPE *pMediaType = NULL;
        ULONG ulMediaCount = 0;

        /* Retrieve the next media type
           Need to delete it when we've done.
        */
        hr = pEnumMediaTypes->Next(1, &pMediaType, &ulMediaCount);
        _ASSERTE(SUCCEEDED(hr));
        if (FAILED(hr)) {
            MajorType = CLSID_NULL;
            SubType = CLSID_NULL;
            pEnumMediaTypes->Release();
            return NOERROR;    // we can still plough on
        }

        if (ulMediaCount==0) {
            pEnumMediaTypes->Release();
            return NOERROR;       // normal return
        }

        if (bFirst) {
            MajorType = pMediaType[0].majortype;
            SubType = pMediaType[0].subtype;
            bFirst = FALSE;
        } else {
            if (SubType != pMediaType[0].subtype) {
                SubType = CLSID_NULL;
            }
            if (MajorType != pMediaType[0].majortype) {
                MajorType = CLSID_NULL;
            }
        }
        
        if (pMediaType->cbFormat != 0) {
            CoTaskMemFree(pMediaType->pbFormat);
        }
        CoTaskMemFree(pMediaType);

        // stop if we have a type
        if (SubType != CLSID_NULL) {
            pEnumMediaTypes->Release();
            return NOERROR;
        }
    }

    // NOTREACHED
    
} // GetAMediaType


// {6B6D0800-9ADA-11d0-A520-00A0D10129C0}
EXTERN_GUID(CLSID_NetShowSource, 
0x6b6d0800, 0x9ada, 0x11d0, 0xa5, 0x20, 0x0, 0xa0, 0xd1, 0x1, 0x29, 0xc0);

EXTERN_GUID(CLSID_SourceStub, 
0x6b6d0803, 0x9ada, 0x11d0, 0xa5, 0x20, 0x0, 0xa0, 0xd1, 0x1, 0x29, 0xc0);

HRESULT
CTIMEDshowBasePlayer::DownloadCodec(IPin * pPin)
{
    TraceTag((tagDownloadCodec,
              "CTIMEDshowBasePlayer(%p)::DownloadCodec()",
              pPin));

    HRESULT hr;
    DWORD dwVerLS = 0, dwVerMS = 0;
    CLSID clsidWanted;
    DAComPtr<IBindCtx> spBindCtx;
    DAComPtr<IBaseFilter> spFilter;
    DAComPtr<CDownloadCallback> spCallback;

    // Should we check a registry key to see if we are allowed to do this?
#if 0
    // Check registry setting to see if codec download is enabled
    CRegKey RegKey;
    DWORD dwNoCodecDwnL = 0;

    DWORD dwResult = RegKey.Open( HKEY_CURRENT_USER, gszPoliciesWMPPath, KEY_READ );
    if ( dwResult == ERROR_SUCCESS )
    {
        dwResult = RegKey.QueryValue( dwNoCodecDwnL, _T( "NoCodecDownload" ));
        if( dwResult == ERROR_SUCCESS )
        {
            if (dwNoCodecDwnL == 1)
            {
                RegKey.Close();
                return E_FAIL; // Don't download anything
            }
        }
        RegKey.Close();
    }
#endif
    
    {
        CLSID clsidMajor;
        // get the first media type from this pin....
        hr = THR(GetAMediaType(pPin, clsidMajor, clsidWanted));
        if (FAILED(hr))
        {
            goto codec_error;
        }
        
        if (clsidMajor == MEDIATYPE_LMRT)
        {
            TraceTag((tagDownloadCodec,
                      "CTIMEDshowBasePlayer(%p)::DownloadCodec(): auto-downloading known major type(LMRT)",
                      pPin));
            clsidWanted = clsidMajor;
        }
        else if (clsidMajor == CLSID_NetShowSource)
        {
            TraceTag((tagDownloadCodec,
                      "CTIMEDshowBasePlayer(%p)::DownloadCodec(): auto-downloading known major type(NetShowSource)",
                      pPin));
            clsidWanted = clsidMajor;
        }
        else if (clsidMajor != MEDIATYPE_Video &&
                 clsidMajor != MEDIATYPE_Audio &&
                 clsidMajor != CLSID_SourceStub) {
            TraceTag((tagDownloadCodec,
                      "CTIMEDshowBasePlayer(%p)::DownloadCodec(): auto-downloading only supported for audio and video",
                      pPin));
            hr = E_FAIL;
            goto codec_error;
        }
    }

    if (clsidWanted == MEDIASUBTYPE_MPEG1AudioPayload)
    {
        TraceTag((tagDownloadCodec,
                  "CTIMEDshowBasePlayer(%p)::DownloadCodec(): Hack: we know we don't want to download MPEG-1 audio, try layer 3",
                  pPin));
        
        clsidWanted.Data1 = WAVE_FORMAT_MPEGLAYER3;
    }

    if (clsidWanted == CLSID_NULL)
    {
        TraceTag((tagDownloadCodec,
                  "CTIMEDshowBasePlayer(%p)::DownloadCodec(): Couldn't guess a CLSID to try to download",
                  pPin));
        hr = E_FAIL;
        goto codec_error;
    }

    // !!! perhaps keep track of last codec we tried to download and
    // don't try again immediately, to prevent ugly looping?
    if (clsidWanted == m_clsidDownloaded)
    {
        TraceTag((tagDownloadCodec,
                  "CTIMEDshowBasePlayer(%p)::DownloadCodec(): Already thought we downloaded this codec!",
                  pPin));

#if 0
        // fire an ERRORABORTEX here that we downloaded a codec, but it didn't do
        // any good?
        BSTR bstrError = FormatBSTR(IDS_ERR_BROKEN_CODEC, NULL);

        if (bstrError) {
            // !!! hack, should we really NotifyEvent through the graph?
            ProcessEvent(EC_ERRORABORTEX, VFW_E_INVALIDMEDIATYPE, (LONG_PTR) bstrError, FALSE);
        }
#endif
        
        hr = E_FAIL;
        goto codec_error;
    }
    
    {
        WCHAR guidstr[50];
        StringFromGUID2(clsidWanted, guidstr, 50);
        
        TCHAR szKeyName[60];
        
        wsprintf(szKeyName, TEXT("CLSID\\%ls"), guidstr);
        CRegKey crk;
        
        LONG    lr;
        lr = crk.Open(HKEY_CLASSES_ROOT, szKeyName, KEY_READ);
        if(ERROR_SUCCESS == lr)
        {
            crk.QueryValue(dwVerMS, _T("VerMS"));
            crk.QueryValue(dwVerLS, _T("VerLS"));
            
            // ask for a version just past what we have already....
            ++dwVerLS;
            
            crk.Close();
        }
    
        TraceTag((tagDownloadCodec,
                  "CTIMEDshowBasePlayer(%p)::DownloadCodec(): Trying to download GUID %ls",
                  pPin,
                  guidstr));
    }

#if 0
    SetStatusMessage(NULL, IDS_DOWNLOADINGCODEC);
#endif

    //  This API is our friend....
    //  STDAPI CoGetClassObjectFromURL( REFCLSID rCLASSID,
    //        LPCWSTR szCODE, DWORD dwFileVersionMS, 
    //        DWORD dwFileVersionLS, LPCWSTR szTYPE,
    //        LPBINDCTX pBindCtx, DWORD dwClsContext,
    //        LPVOID pvReserved, REFIID riid, LPVOID * ppv);

    // issue: is this CLASSID just the same as the minor type?

    {
        CComObject<CDownloadCallback> * pCallback;
        hr = THR(CComObject<CDownloadCallback>::CreateInstance(&pCallback));
        if (FAILED(hr))
        {
            goto done;
        }

        // This gives us a reference
        spCallback = pCallback;
    }
    
    spCallback->m_hwnd = m_hwndDocument;
    
    // which of these should we use?  Depends whether a BindCtx is passed in...
    // STDAPI CreateAsyncBindCtx(DWORD reserved, IBindStatusCallback *pBSCb,                       
    //                            IEnumFORMATETC *pEFetc, IBindCtx **ppBC);                   
    // STDAPI CreateAsyncBindCtxEx(IBindCtx *pbc, DWORD dwOptions, IBindStatusCallback *pBSCb, IEnumFORMATETC *pEnum,   
    //                            IBindCtx **ppBC, DWORD reserved);                                                     

    hr = THR(CreateAsyncBindCtx(0, spCallback, NULL, &spBindCtx));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(CoGetClassObjectFromURL(clsidWanted, NULL, dwVerMS, dwVerLS, NULL,
                                     spBindCtx, CLSCTX_INPROC, NULL, IID_IBaseFilter,
                                     (void **) &spFilter));

    TraceTag((tagDownloadCodec,
              "CTIMEDshowBasePlayer(%p)::DownloadCodec(): CoGetClassObjectFromURL returned %hr",
              pPin,
              hr));

    if (hr == S_ASYNCHRONOUS)
    {
        TraceTag((tagDownloadCodec,
                  "CTIMEDshowBasePlayer(%p)::DownloadCodec(): asynchronous download - wait for completion",
                  pPin));

        // !!! wait here until it finishes?
        for (;;)
        {
            HANDLE ev = spCallback->m_evFinished;

            if (ev == NULL)
            {
                hr = E_FAIL;
                goto done;
            }
            
            DWORD dwResult = MsgWaitForMultipleObjects(1,
                                                       &ev,
                                                       FALSE,
                                                       INFINITE,
                                                       QS_ALLINPUT);
            if (dwResult == WAIT_OBJECT_0)
            {
                break;
            }
            
            Assert(dwResult == WAIT_OBJECT_0 + 1);
            //  Eat messages and go round again
            MSG Message;
            while (PeekMessage(&Message,NULL,0,0,PM_REMOVE))
            {
                if (Message.message == WM_QUIT)
                {
                    break;
                }
                
                TranslateMessage(&Message);
                DispatchMessage(&Message);
            }
        }
        
        TraceTag((tagDownloadCodec,
                  "CTIMEDshowBasePlayer(%p)::DownloadCodec(): Finished waiting.... m_pUnk is %x, hr = %hr",
                  pPin,
                  spCallback->m_pUnk,
                  spCallback->m_hrBinding));

        hr = spCallback->m_hrBinding;
        if (SUCCEEDED(hr))
        {
            spFilter.Release();
            hr = spCallback->m_pUnk->QueryInterface(IID_IBaseFilter, (void **) &spFilter);
        }
    }
    
    spCallback.Release();
    spBindCtx.Release();

    if (SUCCEEDED(hr))
    {
        spFilter.Release();     // graph will re-instantiate the filter, we hope
    }
    else
    {
        // oh well, we didn't get one.
    }

    if (REGDB_E_CLASSNOTREG == hr)
    {
        TraceTag((tagDownloadCodec,
                  "CTIMEDshowBasePlayer(%p)::DownloadCodec(): Hack: treating ClassNotReg as success, and hoping....",
                  pPin));
        hr = S_OK;
    }

    if (FAILED(hr))
    {
#if 0
        // fire an ERRORABORTEX here that we downloaded a codec, but it didn't do
        // any good?
        BSTR bstrError = NULL;
        
        if( FACILITY_CERT == HRESULT_FACILITY( hr ) )
        {
            bstrError = FormatBSTR( IDS_ERR_CODEC_NOT_TRUSTED, NULL );
        }
        else
        {
            bstrError = FormatBSTR(IDS_ERR_NO_CODEC, NULL);
        }

        if (bstrError)
        {
            // !!! hack, should we really NotifyEvent through the graph?
            ProcessEvent(EC_ERRORABORTEX, VFW_E_INVALIDMEDIATYPE, (LONG_PTR) bstrError, FALSE);
        }
#endif

        goto done;
    }
    
    m_clsidDownloaded = clsidWanted; // avoid infinite loop

    hr = S_OK;
    goto done;

codec_error:
    ::PostMessage(m_pwndMsgWindow, WM_CODECERROR, NULL, NULL);

  done:
    RRETURN(hr);
}


HRESULT
CTIMEDshowBasePlayer::GetAvailableTime(double &dblEarliest, double &dblLatest)
{
    HRESULT hr = S_OK;

    LONGLONG learliest, llatest;

    if( m_pMS == NULL)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = m_pMS->GetAvailable( &learliest, &llatest);
    if( FAILED(hr))
    {
        goto done;
    }

    dblEarliest = ((double )learliest) / SecsToNanoSecs;
    dblLatest = ((double) llatest) / SecsToNanoSecs;

done:
        return hr;
}


HRESULT
CTIMEDshowBasePlayer::GetEarliestMediaTime(double &dblEarliestMediaTime)
{
    HRESULT hr = S_OK;

    double dblLatest;

    hr = GetAvailableTime( dblEarliestMediaTime, dblLatest);

    if(FAILED(hr))
    {
        dblEarliestMediaTime = -1.0;
        goto done;
    }

done:
    return hr;
}


HRESULT
CTIMEDshowBasePlayer::GetLatestMediaTime(double &dblLatestMediaTime)
{
    HRESULT hr = S_OK;

    double dblEarliest;

    hr = GetAvailableTime( dblEarliest, dblLatestMediaTime);

    if(FAILED(hr))
    {
        dblLatestMediaTime = -1.0;
        goto done;
    }

done:
    return hr;
}


HRESULT
CTIMEDshowBasePlayer::GetMinBufferedMediaDur(double &dblMinBufferedMediaDur)
{
    HRESULT hr = E_NOTIMPL;

    dblMinBufferedMediaDur = -1.0;
    return hr;
}


HRESULT
CTIMEDshowBasePlayer::SetMinBufferedMediaDur(double dblMinBufferedMediaDur)
{
    HRESULT hr = E_NOTIMPL;
    return hr;
}


HRESULT
CTIMEDshowBasePlayer::GetDownloadTotal(LONGLONG &lldlTotal)
{
    HRESULT hr = S_OK;
    LONGLONG lldlCurrent;

    if(m_pOP == NULL)
    {
        hr = E_FAIL;
        goto done;
    }

    if (FAILED(m_pOP->QueryProgress(&lldlTotal, &lldlCurrent)))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}

HRESULT
CTIMEDshowBasePlayer::GetDownloadCurrent(LONGLONG &lldlCurrent)
{
    HRESULT hr = S_OK;
    LONGLONG lldlTotal;

    if(m_pOP == NULL)
    {
        hr = E_FAIL;
        goto done;
    }

    if (FAILED(m_pOP->QueryProgress(&lldlTotal, &lldlCurrent)))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}

HRESULT
CTIMEDshowBasePlayer::GetMimeTypeFromGraph(BSTR *pmime)
{
    HRESULT hr = S_OK;
    CComPtr<IFileSourceFilter> spSourceFilter;
    LPOLESTR pFileName;
    AM_MEDIA_TYPE mediaType;
    bool fIsStreamed;
    bool fHasVideo;

    if(m_pGB == NULL)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = FindInterfaceOnGraph(m_pGB, IID_IFileSourceFilter, (void **)&spSourceFilter);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = spSourceFilter->GetCurFile (&pFileName, &mediaType);
    if (FAILED(hr))
    {
        goto done;
    }

    if (mediaType.subtype == MEDIATYPE_Midi)
    {
        // This is a MIDI format.
        *pmime = SysAllocString(L"audio/midi");
        hr = S_OK;
        goto done;
    }

    if(mediaType.majortype != MEDIATYPE_Stream)
    {
        // If not stream do not know
        // ISSIUE: asf source filters do not return the correct mediaType,
        // so we test for the asf filter by checking for streamed media.
        hr = GetIsStreamed(fIsStreamed);
        if(FAILED(hr))
        {
            hr = E_FAIL;
            goto done;
        }
        hr = HasVisual(fHasVideo);
        if(FAILED(hr))
        {
            hr = E_FAIL;
            goto done;
        }

        if(fIsStreamed)
        {
            //We have asf, now check for video or audio only.

            if (fHasVideo)
            {
                *pmime = SysAllocString(L"video/x-ms-asf");
            }
            else
            {
                *pmime = SysAllocString(L"audio/x-ms-asf");
            }

            goto done;
        }

        if (fHasVideo)
        {
            *pmime = SysAllocString(L"video/unknown");
        }
        else
        {
            *pmime = SysAllocString(L"audio/unknown");
        }

        hr = S_OK;
        goto done;
    }

    // majortype is stream, use subtypes to figure out MIME type.

    if (IsEqualGUID(mediaType.subtype, MEDIASUBTYPE_AIFF))
    {
        // set mime
        *pmime = SysAllocString(L"audio/aiff");
        hr = S_OK;
        goto done;
    }
    if (IsEqualGUID(mediaType.subtype, MEDIASUBTYPE_Avi))
    {
        // set mime
        *pmime = SysAllocString(L"video/avi");
        hr = S_OK;
        goto done;
    }
    if (IsEqualGUID(mediaType.subtype, MEDIASUBTYPE_Asf))
    {
        // set mime
        // ISSUE discriminate video and audio
        *pmime = SysAllocString(L"video/x-ms-asf");
        hr = S_OK;
        goto done;
    }
    if (IsEqualGUID(mediaType.subtype, MEDIASUBTYPE_AU))
    {
        // set mime
        *pmime = SysAllocString(L"audio/au");
        hr = S_OK;
        goto done;
    }
    if (IsEqualGUID(mediaType.subtype, MEDIASUBTYPE_DssAudio))
    {
        // set mime
        *pmime = SysAllocString(L"audio/dss");
        hr = S_OK;
        goto done;
    }
    if (IsEqualGUID(mediaType.subtype, MEDIASUBTYPE_DssVideo))
    {
        // set mime
        *pmime = SysAllocString(L"video/dss");
        hr = S_OK;
        goto done;
    }
    if (IsEqualGUID(mediaType.subtype, MEDIASUBTYPE_MPEG1Audio))
    {
        // set mime
        *pmime = SysAllocString(L"audio/mpeg");
        hr = S_OK;
        goto done;
    }
    if (IsEqualGUID(mediaType.subtype, MEDIASUBTYPE_MPEG1System))
    {
        // set mime
        *pmime = SysAllocString(L"video/mpeg");
        hr = S_OK;
        goto done;
    }
    if (IsEqualGUID(mediaType.subtype, MEDIASUBTYPE_MPEG1Video))
    {
        // set mime
        *pmime = SysAllocString(L"video/mpeg");
        hr = S_OK;
        goto done;
    }
    if (IsEqualGUID(mediaType.subtype, MEDIASUBTYPE_MPEG1VideoCD))
    {
        // set mime
        *pmime = SysAllocString(L"video/dat");
        hr = S_OK;
        goto done;
    }
    if (IsEqualGUID(mediaType.subtype, MEDIASUBTYPE_WAVE))
    {
        // set mime
        *pmime = SysAllocString(L"audio/wav");
        hr = S_OK;
        goto done;
    }
    if (IsEqualGUID(mediaType.subtype, MEDIASUBTYPE_QTMovie))
    {
        // set mime
        *pmime = SysAllocString(L"video/quicktime");
        hr = S_OK;
        goto done;
    }

    hr = HasVisual(fHasVideo);
    if(FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    if (fHasVideo)
    {
        *pmime = SysAllocString(L"video/unknown");
    }
    else
    {
        *pmime = SysAllocString(L"audio/unknown");
    }

    hr = S_OK;

done:
    return hr;
}

HRESULT
CTIMEDshowBasePlayer::InitElementDuration()
{
    HRESULT hr = S_OK;
    double mediaLength;

    if (NULL == m_pTIMEElementBase)
    {
        hr = S_OK;
        goto done;
    }
    if(m_pPlaybackSite)
    {
        // ISSUE this test is to check if we are a playitem. Need to 
        // refine the test.
        hr = S_OK;
        goto done;
    }

    hr = GetMediaLength( mediaLength);
    if (FAILED(hr))
    {
        goto done;
    }

    if (m_dblClipEnd != valueNotSet)
    {
        if (m_dblClipEnd - GetClipBegin() == 0)
        {
            SetNaturalDuration(0.0);
        }
        else
        {
            SetNaturalDuration(m_dblClipEnd - GetClipBegin());
        }
    }
    else 
    {
        SetNaturalDuration(mediaLength - GetClipBegin());
    }

done:

    return hr;
}


HRESULT
CTIMEDshowBasePlayer::InternalReset(bool bSeek)
{
    HRESULT hr = S_OK;
    bool bNeedActive;
    bool bNeedPause;
    double dblSegTime = 0.0, dblPlayerRate = 0.0;
    float flTeSpeed = 0.0;
    bool fHaveTESpeed;
    double dblMediaTime = 0.0;
    CTIMEPlayerNative *pNativePlayer;
    double dblOffset = 0.0;

    if(!CanCallThrough())
    {
        goto done;
    }

    if(m_fDetached)
    {
        goto done;
    }

    if(m_pTIMEElementBase == NULL)
    {
        goto done;
    }

    if(m_pPlaybackSite)
    {
        if((pNativePlayer = m_pPlaybackSite->GetNativePlayer()) != NULL)
        {
            hr = pNativePlayer->GetPlayItemOffset(dblOffset);
            if(FAILED(hr))
            {
                dblOffset = 0.0;
            }
        }
    }


    bNeedActive = m_pTIMEElementBase->IsActive();
    bNeedPause = m_pTIMEElementBase->IsCurrPaused();
    //bIsLocked = m_pTIMEElementBase->IsLocked();
    fHaveTESpeed = m_pTIMEElementBase->GetTESpeed(flTeSpeed);

    if(!m_fMediaComplete)
    {
        TraceTag((tagError, "CTIMEDshowHWPlayer(%lx)(%x)::Reset",this));
        goto done;
    }

    TraceTag((tagDshowBaseTimePlayer, "CTIMEDshowHWPlayer(%lx)(%x)::Reset",this));
    dblSegTime = m_pTIMEElementBase->GetMMBvr().GetSimpleTime();
    IGNORE_HR(m_pMP->get_CurrentPosition(&dblMediaTime));

    // make sure that this media can cue now
    IGNORE_HR(InternalEvent());
    
    if( !bNeedActive) // see if we need to stop the media.
    {
        // removed pause here
        m_dblSyncTime = 0.0;
        Pause();
        goto done;

    }
    m_dblSyncTime = GetCurrentTime();

    hr = GetRate(dblPlayerRate);
    if(SUCCEEDED(hr) && fHaveTESpeed)
    {
        if (flTeSpeed <= 0.0)
        {
            hr = S_OK;
            Pause();
            goto done;
        }
        if (dblPlayerRate != flTeSpeed)
        {
            IGNORE_HR(SetRate((double)flTeSpeed));
        }
    }

    dblSegTime = m_pTIMEElementBase->GetMMBvr().GetSimpleTime() - dblOffset;

    if( !m_bActive)
    {
        if (m_pIAMNetStat != NULL) //euristic to get asf's to start correctly.
        {
            Stop();
            IGNORE_HR(m_pMP->put_CurrentPosition( 0.0));
        }
        else if(dblMediaTime != dblSegTime && bSeek)
        {
            IGNORE_HR(THR(ForceSeek(dblSegTime))); //this does not seek asf's
        }
        InternalStart();
    }
    else
    {
        //we need to be active so we also seek the media to it's correct position
        if(dblMediaTime != dblSegTime && bSeek)
        {
            IGNORE_HR(THR(Seek(dblSegTime))); //this does not seek asf's
        }
    }

    //Now see if we need to change the pause state.

    if( bNeedPause)
    {
        if(!m_fIsOutOfSync)
        {
            Pause();
        }
    }
    else
    {
        if( !m_fRunning)
        {
            Resume();
        }
    }
done:
    return hr;
}


void
CTIMEDshowBasePlayer::InternalStart()
{
    TraceTag((tagDshowBaseTimePlayer,
              "CTIMEDshowHWPlayer(%lx)::InternalStart()",
              this));

    if (m_pMC == NULL || m_pMP == NULL)
    {
        goto done;
    }

    GraphStart();
    
    m_fRunning = true;
    m_bActive = true;
    m_bMediaDone = false;
done:
    return;
}


HRESULT
CTIMEDshowBasePlayer::Seek(double dblTime)
{
    HRESULT hr = S_OK;
    double dblMediaLength = 0;
    double dblClipStart;

    if (m_pMP == NULL)
    {
        return E_FAIL;
    }

    hr = THR(GetEffectiveLength(dblMediaLength));
    if (FAILED(hr))
    {
        // if the media is not yet loaded or is infinite, we don't know the duration, so set the length forward enough.
        dblMediaLength = HUGE_VAL;
    }

    dblClipStart = GetClipBegin();
    //dblClipStart = 0;

    if (dblMediaLength > dblTime)
    {
        hr = m_pMP->put_CurrentPosition( dblTime + dblClipStart);
    }
    else
    {
        hr = THR(m_pMP->put_CurrentPosition(dblMediaLength - 0.33));
        m_bMediaDone = true;
    }

done:
    return hr;
}

HRESULT
CTIMEDshowBasePlayer::ForceSeek(double dblTime)
{
    HRESULT hr = S_OK;
    double dblMediaLength = 0;
    double dblClipStart;

    if (m_pMP == NULL)
    {
        return E_FAIL;
    }
    if (m_pIAMNetStat != NULL) //never seek asf's.
    {
        if(dblTime != 0.0)
        {
            hr = S_OK;
            goto done;
        }
        Stop();
        IGNORE_HR(m_pMP->put_CurrentPosition( 0.0));
        InternalStart();
        hr = S_OK;
        goto done;
    }

    hr = THR(GetEffectiveLength(dblMediaLength));
    if (FAILED(hr))
    {
        // if the media is not yet loaded or is infinite, we don't know the duration, so set the length forward enough.
        dblMediaLength = HUGE_VAL;
    }

    dblClipStart = GetClipBegin();
    //dblClipStart = 0;

    if (dblMediaLength > dblTime)
    {
        hr = m_pMP->put_CurrentPosition( dblTime + dblClipStart);
    }
    else
    {
        hr = THR(m_pMP->put_CurrentPosition(dblMediaLength - 0.33));
        m_bMediaDone = true;
    }

done:
    return hr;
}

void
CTIMEDshowBasePlayer::Start()
{
    TraceTag((tagDshowBaseTimePlayer,
              "CTIMEDshowPlayer(%lx)::Start()",
              this));

    m_pTIMEElementBase->InvalidateElement(NULL);
    IGNORE_HR(Reset());

done:
    return;
}

void
CTIMEDshowBasePlayer::Stop()
{
    TraceTag((tagDshowBaseTimePlayer,
              "CTIMEDshowHWPlayer(%lx)::Stop()",
              this));

    if (m_pMC == NULL || m_pMP == NULL)
    {
        return;
    }

    if ((m_fMediaComplete == true) && !m_bMediaDone)
    {
        m_pMC->Stop();
    }

    m_fRunning = false;
    m_bActive = false;
    m_pTIMEElementBase->InvalidateElement(NULL);
}

void
CTIMEDshowBasePlayer::Pause()
{
    TraceTag((tagDshowBaseTimePlayer,
              "CTIMEDshowHWPlayer(%lx)::Pause()",
              this));

    if (m_pMC == NULL || m_pMP == NULL)
    {
        return;
    }

    if ((m_fMediaComplete == true) && !m_bMediaDone)
    {
        m_pMC->Pause();
    }
    m_fRunning = false;
}

void
CTIMEDshowBasePlayer::Resume()
{
    TraceTag((tagDshowBaseTimePlayer,
              "CTIMEDshowHWPlayer(%lx)::Resume()",
              this));

    if (m_pMC == NULL || m_pMP == NULL)
    {
        return;
    }

    bool bIsActive = m_pTIMEElementBase->IsActive();
    bool bIsCurrPaused = m_pTIMEElementBase->IsCurrPaused();
    float flTeSpeed = 0.0;
    bool fHaveTESpeed = m_pTIMEElementBase->GetTESpeed(flTeSpeed);

    if(m_fIsOutOfSync && m_syncType == sync_fast)
    {
        goto done;
    }

    if(fHaveTESpeed && flTeSpeed < 0.0)
    {
        goto done;
    }

    m_pTIMEElementBase->InvalidateElement(NULL);
    if( bIsActive && !bIsCurrPaused)
    {
        if ((m_fMediaComplete == true) && !m_bMediaDone)
        {
            m_pMC->Run();
        }
        m_fRunning = true;
        m_bActive = true;
    }

done:
    return;
}

void
CTIMEDshowBasePlayer::Repeat()
{
    TraceTag((tagDshowBaseTimePlayer,
              "CTIMEDshowHWPlayer(%lx)::Resume()",
              this));

    if (m_pMC == NULL || m_pMP == NULL)
    {
        return;
    }
    if (m_pIAMNetStat != NULL) //euristic to get asf's to repeat.
    {
        Stop();
        IGNORE_HR(m_pMP->put_CurrentPosition( 0.0));
        InternalStart();
    }
    else
    {
        Stop();
        IGNORE_HR(m_pMP->put_CurrentPosition( GetClipBegin()));
        InternalStart();
    }

}


double 
CTIMEDshowBasePlayer::GetCurrentTime()
{
    double dblCurrentTime = 0;

    if (m_pMP == NULL)
    {
        return dblCurrentTime;
    }
    m_pMP -> get_CurrentPosition( &dblCurrentTime);
    dblCurrentTime -= GetClipBegin();
       
    return dblCurrentTime;
}

HRESULT
CTIMEDshowBasePlayer::GetCurrentSyncTime(double & dblSyncTime)
{
    HRESULT hr;
    float flTeSpeed = 0.0;
    bool fHaveTESpeed;

    if (m_bMediaDone)
    {
        hr = S_FALSE;
        goto done;
    }

    if(m_pTIMEElementBase == NULL)
    {
        hr = S_FALSE;
        goto done;
    }

    fHaveTESpeed = m_pTIMEElementBase->GetTESpeed(flTeSpeed);
    if(fHaveTESpeed)
    {
        if(flTeSpeed < 0.0)
        {
            hr = S_FALSE;
            goto done;
        }
    }

    if(!m_bActive || ((!CanCallThrough())))
    {
        TraceTag((tagDshowBaseTimePlayer, "CTIMEDshowPlayer(%lx)::GetCurrentSyncTime::Not active(%f)",
            this,
            m_dblSyncTime));
        dblSyncTime = m_dblSyncTime;
        hr = S_OK;
        goto done;
    }

    if(m_pMP != NULL)
    {
        m_pMP -> get_CurrentPosition( &dblSyncTime);
        dblSyncTime -= GetClipBegin();
    }
    else
    {
        hr = S_FALSE;
        goto done;
    }
    TraceTag((tagDshowBaseTimePlayer, "CTIMEDshowPlayer(%lx)::GetCurrentSyncTime::Is active(%f)",
        this,
        dblSyncTime));

    hr = S_OK;
  done:
    RRETURN1(hr, S_FALSE);
}

STDMETHODIMP
CTIMEDshowBasePlayer::InternalEvent()
{
    return S_OK;
}

#define EC_FILE_CLOSED			    0x44

void
CTIMEDshowBasePlayer::ProcessGraphEvents()
{
    long lEventCode;
    LONG_PTR lParam1, lParam2;
    const GUID mediaTimeFormat = TIME_FORMAT_MEDIA_TIME;
    const GUID frameFormat= TIME_FORMAT_FRAME;

    if (NULL == m_pTIMEElementBase)
    {
        goto done;
    }

    while((m_pME != NULL) && (SUCCEEDED(m_pME->GetEvent(&lEventCode, &lParam1, &lParam2, 0) )))
    {
        TraceTag((tagDshowBaseTimePlayer, "CTIMEDshowHWPlayer(%lx)(%x)::OVMixerWindowProc::WM_GRAPHNOTIFY",
            this, lEventCode));
        switch(lEventCode)
        {
        case EC_COMPLETE:
            {
                TraceTag((tagDshowBaseTimePlayer, " CTIMEDshowHWPlayer::OVMixerWindowProc::WM_EC_COMPLETE"));
                m_fRunning = false;
                m_bMediaDone = true;
                m_pTIMEElementBase->InvalidateElement(NULL);
                FireMediaEvent(PE_ONMEDIAEND);
                break;
            }
        case EC_PAUSED:
            {
                TraceTag((tagDshowBaseTimePlayer, " CTIMEDshowHWPlayer::OVMixerWindowProc::WM_EC_PAUSED"));
                if (m_fFiredComplete == true)
                {
                    break;
                }
                m_fFiredComplete = true;
                if(m_pMS)
                {
                    THR(m_pMS->SetTimeFormat(&frameFormat));
                }

                break;
            }
        case EC_OLE_EVENT:
            {

                TraceTag((tagDshowBaseTimePlayer, " CTIMEDshowHWPlayer::OVMixerWindowProc::WM_EC_OLE_EVENT:(%Ls)"));
                                
                if (StrCmpIW(L"sami", (BSTR)lParam1) == 0)
                {
                    if (m_bIsSAMISrc == true)
                    {
                        CComPtr <IHTMLElement> pEle = m_pTIMEElementBase->GetElement();
                        if (pEle != NULL)
                        {
                            IGNORE_HR(pEle->put_innerText((BSTR)lParam2));
                        }
                    }

                }
                else if (StrCmpIW(L"MediaBarTarget", (BSTR)lParam1) == 0)
                {
                    static LPWSTR pNames[] = {L"URL"};
                    VARIANTARG pvars[1];
                    pvars[0].vt = VT_BSTR;
                    pvars[0].bstrVal = (BSTR)lParam2;
                    IGNORE_HR(m_pTIMEElementBase->FireEvents(TE_ONMEDIABARTARGET, 
                                                             1, 
                                                             pNames, 
                                                             pvars));
                }
                else if (StrCmpIW(L"URL", (BSTR)lParam1) == 0)
                {
                    static LPWSTR pNames[] = {L"URL"};
                    VARIANTARG pvars[1];
                    pvars[0].vt = VT_BSTR;
                    pvars[0].bstrVal = (BSTR)lParam2;
                    IGNORE_HR(m_pTIMEElementBase->FireEvents(TE_ONURLFLIP, 
                                                             1, 
                                                             pNames, 
                                                             pvars));
                }
                else
                {
                    //TODO:  it looks like our existing content is not valid, how do we correct the content?
                    // currently if it isn't something else that is valid, it will be treated as an event.
                    static LPWSTR pNames[] = {L"Param", L"scType"};
                    VARIANTARG pvars[2];
                    pvars[1].vt = VT_BSTR;
                    pvars[1].bstrVal = (BSTR)lParam1;
                    pvars[0].vt = VT_BSTR;
                    pvars[0].bstrVal = (BSTR)lParam2;
                    IGNORE_HR(m_pTIMEElementBase->FireEvents(TE_ONSCRIPTCOMMAND, 
                                                        2, 
                                                        pNames, 
                                                        pvars));

                }


                break;
            }
        case EC_BUFFERING_DATA:
            {
                TraceTag((tagDshowBaseTimePlayer, " CTIMEDshowHWPlayer::OVMixerWindowProc::WM_EC_BUFFERING_DATA"));
                break;
            }
        case EC_FILE_CLOSED:
                m_fRunning = false;
                m_bMediaDone = true;
                FireMediaEvent(PE_ONMEDIAEND);
            break;
        default:
            TraceTag((tagDshowBaseTimePlayer, " CTIMEDshowHWPlayer::OVMixerWindowProc::WM_EC_OTHER:(%x)", lEventCode));
            break;
        }
        if(m_pME != NULL)
        {
            m_pME->FreeEventParams(lEventCode, lParam1, lParam2);
        }
    }
done:
    return;
}

bool
CTIMEDshowBasePlayer::UpdateSync()
{
    double dblSyncTime;
    double dblSyncTol = m_pTIMEElementBase->GetRealSyncTolerance();
    bool bIsActive = m_pTIMEElementBase->IsActive();
    double dblSimpleTime = m_pTIMEElementBase->GetMMBvr().GetSimpleTime();
    bool fRet = true;
    TraceTag((tagDshowBaseTimePlayer,
              "CTIMEDshowPlayer(%lx)::UpdateSync()",
              this));

    if(m_pMP == NULL)
    {
        goto done;
    }

    m_pMP -> get_CurrentPosition( &dblSyncTime);
    dblSyncTime -= GetClipBegin();
    switch(m_syncType)
    {
        case sync_slow:
            TraceTag((tagDshowBaseTimePlayer,
                      "CTIMEDshowPlayer(%lx)::UpdateSync()slow",
                      this));
            if(!bIsActive || m_bMediaDone)
            {
                m_fIsOutOfSync = false;
                fRet = true;
            }
            else if(fabs(dblSyncTime - dblSimpleTime) <= dblSyncTol / 2.0 || (dblSyncTime > dblSimpleTime + dblSyncTol / 2.0))
            {
                m_fIsOutOfSync = false;
                fRet = true;
            }
            else
            {
                fRet = false;
            }
            break;
        case sync_fast:
            if(!bIsActive || m_bMediaDone)
            {
                m_fIsOutOfSync = false;
                fRet = true;
            }
            else if((fabs(dblSyncTime - dblSimpleTime) <= dblSyncTol / 2.0) || (dblSimpleTime > dblSyncTime + dblSyncTol / 2.0))
            {
                m_fIsOutOfSync = false;
                fRet = true;
            }
            else
            {
                fRet = false;
            }
            break;
        default:
            break;
    }
done:
    return fRet;
}

void
CTIMEDshowBasePlayer::PropChangeNotify(DWORD tePropType)
{
    double dblPlayerRate = 0.0;
    float flTeSpeed = 0.0;
    bool fHaveTESpeed;
    HRESULT hr = S_OK;
    double dblSyncTime;
    double dblSyncTol;
    bool bIsActive;
    double dblSimpleTime;

    if (!m_pTIMEElementBase)
    {
        goto done;
    }

    dblSyncTol = m_pTIMEElementBase->GetRealSyncTolerance();
    bIsActive = m_pTIMEElementBase->IsActive();
    dblSimpleTime = m_pTIMEElementBase->GetMMBvr().GetSimpleTime();

    if ((tePropType & TE_PROPERTY_TIME) != 0)
    {
        TraceTag((tagDshowBaseTimePlayer,
                  "CTIMEDshowPlayer(%lx)::PropChangeNotify(%d):TE_PROPERTY_TIME",
                  this, m_fIsOutOfSync));
        if(m_pPlaybackSite)
        {
            // ISSUE this test is to check if we are a playitem. Need to 
            // refine the test.
            goto done;
        }

        if (!m_bMediaDone && bIsActive && !m_fIsOutOfSync && m_fMediaComplete)
        {   
            if(m_pMP != NULL)
            {
                m_pMP -> get_CurrentPosition( &dblSyncTime);
                dblSyncTime -= GetClipBegin();
                if(fabs(dblSyncTime - dblSimpleTime) > dblSyncTol)
                {
                    if(dblSyncTime < dblSimpleTime)
                    {
                        if(m_fRunning)
                        {
                            m_fIsOutOfSync = true;
                            FireMediaEvent(PE_ONMEDIASLIPSLOW);
                            m_syncType = sync_slow;
                        }
                    }
                    else
                    {
                        m_fIsOutOfSync = true;
                        FireMediaEvent(PE_ONMEDIASLIPFAST);
                        m_syncType = sync_fast;
                    }
                }
            }
        }

    }
    if ((tePropType & TE_PROPERTY_SPEED) != 0)
    {
        TraceTag((tagDshowBaseTimePlayer,
                  "CTIMEDshowPlayer(%lx)::PropChangeNotify(%#x):TE_PROPERTY_SPEED",
                  this));
        fHaveTESpeed = m_pTIMEElementBase->GetTESpeed(flTeSpeed);
        hr = GetRate(dblPlayerRate);
        if(SUCCEEDED(hr) && fHaveTESpeed)
        {
            if (flTeSpeed <= 0.0)
            {
                Pause();
                m_fSpeedIsNegative = true;
                goto done;
            } else if(!(m_pTIMEElementBase->IsCurrPaused()) && !m_fRunning && m_fSpeedIsNegative)
            {
                IGNORE_HR(THR(ForceSeek(dblSimpleTime)));
                if(m_pMC != NULL)
                {
                    m_pMC->Run();
                }
                m_fSpeedIsNegative = false;
            }

            if (dblPlayerRate != flTeSpeed)
            {
                IGNORE_HR(SetRate((double)flTeSpeed));
            }
        }
    }
  done:
    return;
}

void 
CTIMEDshowBasePlayer::FireMediaEvent(PLAYER_EVENT plEvent)
{
    CTIMEPlayerNative *pNativePlayer;

    if(!FireProxyEvent(plEvent))
    {
        m_pTIMEElementBase->FireMediaEvent(plEvent);
    }
}

void
CTIMEDshowBasePlayer::SetNaturalDuration(double dblMediaLength)
{
    CTIMEPlayerNative *pNativePlayer;

    if(m_pPlaybackSite)
    {
        if((pNativePlayer = m_pPlaybackSite->GetNativePlayer()) != NULL)
        {
            pNativePlayer->SetNaturalDuration(dblMediaLength);
        }
        else
        {
            m_pTIMEElementBase->GetMMBvr().PutNaturalDur(dblMediaLength);
            m_pTIMEElementBase->setNaturalDuration();
        }
    }
    else
    {
            m_pTIMEElementBase->GetMMBvr().PutNaturalDur(dblMediaLength);
            m_pTIMEElementBase->setNaturalDuration();
    }
}

void
CTIMEDshowBasePlayer::ClearNaturalDuration()
{
    CTIMEPlayerNative *pNativePlayer;

    if(m_pPlaybackSite)
    {
        if((pNativePlayer = m_pPlaybackSite->GetNativePlayer()) != NULL)
        {
            pNativePlayer->ClearNaturalDuration();
        }
        else
        {
        m_pTIMEElementBase->GetMMBvr().PutNaturalDur((double)TE_UNDEFINED_VALUE);
        m_pTIMEElementBase->clearNaturalDuration();
        }
    }
    else
    {
        m_pTIMEElementBase->GetMMBvr().PutNaturalDur((double)TE_UNDEFINED_VALUE);
        m_pTIMEElementBase->clearNaturalDuration();
    }
}

HRESULT
CTIMEDshowBasePlayer::GetMimeType(BSTR *pMime)
{
    HRESULT hr = S_OK;
    
    hr = GetMimeTypeFromGraph(pMime);
    return hr;
}


HRESULT
CTIMEDshowBasePlayer::ConvertFrameToTime(LONGLONG iFrame, double &dblTime)
{
    HRESULT hr = S_OK;
    LONGLONG lTime;
    bool fHasVisual;
    LONGLONG ltBase = GetClipBegin() * SecsToNanoSecs;
    LONGLONG lfBase;

    const GUID mediaTimeFormat = TIME_FORMAT_MEDIA_TIME;
    const GUID frameFormat= TIME_FORMAT_FRAME;

    if(FAILED(HasVisual(fHasVisual)))
    {
        hr = E_FAIL;
        goto done;
    }

    if(!fHasVisual)
    {
        hr = E_FAIL;
        goto done;
    }

    if(m_pMS == NULL)
    {
        hr = E_FAIL;
        goto done;
    }
    THR(hr = m_pMS->SetTimeFormat(&frameFormat));

    hr = m_pMS->ConvertTimeFormat(&lfBase, &frameFormat, ltBase, &mediaTimeFormat);
    if(FAILED(hr))
    {
        goto done;
    }

    hr = m_pMS->ConvertTimeFormat(&lTime, &mediaTimeFormat, lfBase + iFrame, &frameFormat);
    if(FAILED(hr))
    {
        goto done;
    }

    dblTime = ((double )lTime) / SecsToNanoSecs;
    dblTime -= GetClipBegin();
    Assert(dblTime > 0);

done:
    return hr;
}

HRESULT
CTIMEDshowBasePlayer::GraphCue(void)
{
    LONGLONG startTime = 0;
    DWORD startFlags = AM_SEEKING_NoPositioning;
    LONGLONG endTime = 0;
    DWORD endFlags = AM_SEEKING_NoPositioning;
    LONGLONG startFrame = m_lClipStartFrame;
    LONGLONG endFrame = m_lClipEndFrame;
    HRESULT hr = S_OK;
    TraceTag((tagDshowBaseTimePlayer,
              "CTIMEDshowPlayer(%lx)::GraphCue()",
              this));
    const GUID mediaTimeFormat = TIME_FORMAT_MEDIA_TIME;
    const GUID frameFormat= TIME_FORMAT_FRAME;

    if (m_dblClipEnd != valueNotSet)
    {
        endTime = (LONGLONG)(m_dblClipEnd * SecsToNanoSecs);
        endFlags = AM_SEEKING_AbsolutePositioning;
        m_lClipEndFrame = valueNotSet;
    }
    else if(m_lClipEndFrame != valueNotSet)
    {
        THR(hr = m_pMS->SetTimeFormat(&frameFormat));
        hr = m_pMS->ConvertTimeFormat(&endTime, &mediaTimeFormat, endFrame, &frameFormat);
        if(SUCCEEDED(hr))
        {
            endFlags = AM_SEEKING_AbsolutePositioning;
            m_dblClipEnd = ((double )endTime) / SecsToNanoSecs;
        }
        else
        {
            m_dblClipEnd = valueNotSet;
        }
    }

    if (m_pIAMNetStat == NULL)
    {
        if (m_dblClipStart != valueNotSet)
        {
            startTime = (LONGLONG)(m_dblClipStart * SecsToNanoSecs);
            startFlags = AM_SEEKING_AbsolutePositioning;
            m_lClipStartFrame = valueNotSet;
        }
        else if(m_lClipStartFrame != valueNotSet)
        {
            THR(hr = m_pMS->SetTimeFormat(&frameFormat));
            hr = m_pMS->ConvertTimeFormat(&startTime, &mediaTimeFormat, startFrame, &frameFormat);
            if(SUCCEEDED(hr))
            {
                startFlags = AM_SEEKING_AbsolutePositioning;
                m_dblClipStart = ((double )startTime) / SecsToNanoSecs;
            }
            else
            {
                m_dblClipStart = valueNotSet;
            }
        }
    }

    THR(hr = m_pMS->SetTimeFormat(&mediaTimeFormat));
    if ( startFlags != AM_SEEKING_NoPositioning || endFlags != AM_SEEKING_NoPositioning)
    {
        THR(hr = m_pMS->SetPositions(&startTime, startFlags, &endTime, endFlags));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    //removed run call here.

    hr = S_OK;
done:
    return hr;
}


void
CTIMEDshowBasePlayer::SetClipBeginFrame(long lClipBegin)
{
    LONGLONG startTime = 0;
    LONGLONG startFrame = 0;
    DWORD startFlags = AM_SEEKING_AbsolutePositioning;
    LONGLONG endTime = 0;
    DWORD endFlags = AM_SEEKING_NoPositioning;
    const GUID mediaTimeFormat = TIME_FORMAT_MEDIA_TIME;
    const GUID frameFormat= TIME_FORMAT_FRAME;
    HRESULT hr = S_OK;
    TraceTag((tagDshowBaseTimePlayer,
              "CTIMEDshowPlayer(%lx)::SetClipBegin()",
              this));

    m_lClipStartFrame = lClipBegin;
    m_dblClipStart = valueNotSet;

    if(m_pMS == NULL)
    {
        goto done;
    }

    if(!m_fMediaComplete)
    {
        goto done;
    }

    startFrame = m_lClipStartFrame;
    THR(hr = m_pMS->SetTimeFormat(&frameFormat));
    hr = m_pMS->ConvertTimeFormat(&startTime, &mediaTimeFormat, startFrame, &frameFormat);

    if (m_pIAMNetStat != NULL)
    {
        goto done;
    }

    m_dblClipStart = ((double )startTime) / SecsToNanoSecs;
    THR(hr = m_pMS->SetTimeFormat(&mediaTimeFormat));
    IGNORE_HR(m_pMS->SetPositions(&startTime, startFlags, &endTime, endFlags));
    THR(hr = m_pMS->SetTimeFormat(&frameFormat));
    Reset();

done:
    return;
} // putClipBegin

void 
CTIMEDshowBasePlayer::SetClipEndFrame(long lClipEnd)
{
    LONGLONG startTime = 0;
    DWORD startFlags = AM_SEEKING_NoPositioning;
    LONGLONG endTime = 0;
    LONGLONG endFrame = m_lClipEndFrame;
    DWORD endFlags = AM_SEEKING_AbsolutePositioning;
    const GUID mediaTimeFormat = TIME_FORMAT_MEDIA_TIME;
    const GUID frameFormat= TIME_FORMAT_FRAME;
    HRESULT hr = S_OK;
    TraceTag((tagDshowBaseTimePlayer,
              "CTIMEDshowPlayer(%lx)::SetClipEnd()",
              this));

    m_lClipEndFrame = lClipEnd;
    m_dblClipEnd = valueNotSet;

    if(m_pMS == NULL)
    {
        goto done;
    }

    if(!m_fMediaComplete)
    {
        goto done;
    }

    endFrame = m_lClipEndFrame;
    THR(hr = m_pMS->SetTimeFormat(&frameFormat));
    hr = m_pMS->ConvertTimeFormat(&endTime, &mediaTimeFormat, endFrame, &frameFormat);

    m_dblClipEnd = ((double )endTime) / SecsToNanoSecs;
    THR(hr = m_pMS->SetTimeFormat(&mediaTimeFormat));
    IGNORE_HR(m_pMS->SetPositions(&startTime, startFlags, &endTime, endFlags));
    THR(hr = m_pMS->SetTimeFormat(&frameFormat));
    Reset();
done:
    return;
} // putClipEnd


void
CTIMEDshowBasePlayer::SetClipBegin(double dblClipBegin)
{
    LONGLONG startTime = 0;
    DWORD startFlags = AM_SEEKING_AbsolutePositioning;
    LONGLONG endTime = 0;
    DWORD endFlags = AM_SEEKING_NoPositioning;
    const GUID mediaTimeFormat = TIME_FORMAT_MEDIA_TIME;
    const GUID frameFormat= TIME_FORMAT_FRAME;
    HRESULT hr = S_OK;
    TraceTag((tagDshowBaseTimePlayer,
              "CTIMEDshowPlayer(%lx)::SetClipBegin()",
              this));

    m_dblClipStart = dblClipBegin;
    m_lClipStartFrame = valueNotSet;

    if(m_pMS == NULL)
    {
        goto done;
    }

    if(!m_fMediaComplete)
    {
        goto done;
    }

    if (m_pIAMNetStat == NULL)
    {
        startTime = (LONGLONG)(m_dblClipStart * SecsToNanoSecs);
    }
    else
    {
        goto done;
    }
    THR(hr = m_pMS->SetTimeFormat(&mediaTimeFormat));
    IGNORE_HR(m_pMS->SetPositions(&startTime, startFlags, &endTime, endFlags));
    THR(hr = m_pMS->SetTimeFormat(&frameFormat));
    Reset();

done:
    return;
} // putClipBegin

void 
CTIMEDshowBasePlayer::SetClipEnd(double dblClipEnd)
{
    LONGLONG startTime = 0;
    DWORD startFlags = AM_SEEKING_NoPositioning;
    LONGLONG endTime = 0;
    DWORD endFlags = AM_SEEKING_AbsolutePositioning;
    const GUID mediaTimeFormat = TIME_FORMAT_MEDIA_TIME;
    const GUID frameFormat= TIME_FORMAT_FRAME;
    HRESULT hr = S_OK;
    TraceTag((tagDshowBaseTimePlayer,
              "CTIMEDshowPlayer(%lx)::SetClipEnd()",
              this));

    m_dblClipEnd = dblClipEnd;
    m_lClipEndFrame = valueNotSet;

    if(m_pMS == NULL)
    {
        goto done;
    }

    if(!m_fMediaComplete)
    {
        goto done;
    }

    endTime = (LONGLONG)(m_dblClipEnd * SecsToNanoSecs);
    THR(hr = m_pMS->SetTimeFormat(&mediaTimeFormat));
    IGNORE_HR(m_pMS->SetPositions(&startTime, startFlags, &endTime, endFlags));
    THR(hr = m_pMS->SetTimeFormat(&frameFormat));
    Reset();
done:
    return;
} // putClipEnd

HRESULT
CTIMEDshowBasePlayer::GetCurrentFrame(LONGLONG &lFrameNr)
{
    HRESULT hr = S_OK;
    bool fHasVisual;
    LONGLONG lmediaTime;

    lFrameNr = -1;

    const GUID mediaTimeFormat = TIME_FORMAT_MEDIA_TIME;
    const GUID frameFormat= TIME_FORMAT_FRAME;

    if(FAILED(HasVisual(fHasVisual)))
    {
        hr = E_FAIL;
        goto done;
    }

    if(!fHasVisual)
    {
        hr = E_FAIL;
        goto done;
    }

    if(m_pMS == NULL)
    {
        hr = E_FAIL;
        goto done;
    }

    if(!m_fMediaComplete)
    {
        lFrameNr = -1;
        goto done;
    }


    hr = m_pMS->GetCurrentPosition(&lFrameNr);
    if(FAILED(hr))
    {
        lFrameNr = -1;
    }

done:

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\playerhwdshow.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: player.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#include "headers.h"
#include "playerhwdshow.h"
#include "mediaelm.h"
#include <wininet.h>
#include <inc\evcode.h>
#include "tags\bodyelm.h"
#include <inc\mpconfig.h>
#include <ddraw.h>
#include <ddrawex.h>

class
__declspec(uuid("22d6f312-b0f6-11d0-94ab-0080c74c7e95"))
MediaPlayerCLSID {};

#define SecsToNanoSecs 10000000
#define UnitOverlayStretchRatio 1000

#define OVLMixer L"Overlay Mixer"

#define SOUND_OF_SILENCE -10000
// Suppress new warning about NEW without corresponding DELETE 
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )  

DeclareTag(tagDshowTimeHWPlayer, "TIME: Players", "CTIMEDshowHWPlayer methods");

CTIMEDshowHWPlayer::CTIMEDshowHWPlayer(CTIMEDshowHWPlayerProxy * pProxy) :
  m_fHasVideo(false),
  m_fDoneSetup(false),
  m_pIMixerOCX(NULL),
  m_dblSeekAtStart(0.0),
  m_nativeVideoWidth(0),
  m_nativeVideoHeight(0),
  m_displayVideoWidth(0),
  m_displayVideoHeight(0),
  m_lSrc(ATOM_TABLE_VALUE_UNITIALIZED),
  m_pTIMEMediaPlayerStream(NULL),
  m_fRemoved(false),
  m_fNeedToDeleteInterfaces(false),
  m_fUsingInterfaces(false),
  m_fLoadError(false),
  m_fHasMedia(false),
  m_dblPriority(INFINITE),
  m_fCanCueNow(false),
  m_fHavePriority(false),
  m_lPixelPosLeft(0),
  m_lPixelPosTop(0),
  m_lscrollOffsetx(0),
  m_lscrollOffsety(0),
  m_hrRenderFileReturn(S_OK),
  m_pProxy(pProxy),
  m_pDD(NULL),
  m_pDDS(NULL),
  m_pClipper(NULL),
  m_hWnd(NULL),
  m_bIsHTMLSrc(false),
  m_bIsSAMISrc(false)
{
    TraceTag((tagDshowTimeHWPlayer,
              "CTIMEDshowHWPlayer(%lx)::CTIMEDshowHWPlayer()",
              this));

    if (IsPalettizedDisplay())
    {
        m_clrKey = RGB(0xff, 0x00, 0xff);
    }
    else
    {
        m_clrKey = RGB(0x10, 0x00, 0x10);
    }
    m_elementSize.bottom = 0;
    m_elementSize.left = 0;
    m_elementSize.top = 0;
    m_elementSize.right = 0;
    m_deskRect.bottom = 0;
    m_deskRect.left = 0;
    m_deskRect.top = 0;
    m_deskRect.right = 0;

}


CTIMEDshowHWPlayer::~CTIMEDshowHWPlayer()
{
    TraceTag((tagDshowTimeHWPlayer,
              "CTIMEDshowHWPlayer(%lx)::~CTIMEDshowHWPlayer()",
              this));

    if(m_pClipper != NULL)
    {
        m_pClipper->SetClipList(NULL, 0);
        m_pClipper->Release();
        m_pClipper = NULL;
    }

    if (m_pDDS != NULL)
    {
        m_pDDS->SetClipper(NULL);
        m_pDDS->Release();
        m_pDDS = NULL;
    }

    if (m_pDD != NULL)
    {
        m_pDD->Release();
        m_pDD = NULL;
    }

    m_pMediaContent = NULL;
    m_pIMixerOCX = NULL;
    m_pOvM = NULL;

    ReleaseGenericInterfaces();

    ReleaseInterface(m_pTIMEMediaPlayerStream);

    delete m_pProxy;
}

STDMETHODIMP_(ULONG)
CTIMEDshowHWPlayer::AddRef(void)
{
    return CTIMEDshowBasePlayer::AddRef();
}


STDMETHODIMP_(ULONG)
CTIMEDshowHWPlayer::Release(void)
{
    return CTIMEDshowBasePlayer::Release();
}

HRESULT
CTIMEDshowHWPlayer::Init(CTIMEMediaElement *pelem, LPOLESTR base, LPOLESTR src, LPOLESTR lpMimeType, double dblClipBegin, double dblClipEnd)
{
    TraceTag((tagDshowTimeHWPlayer,
              "CTIMEDshowHWPlayer(%lx)::Init)",
              this));
    HRESULT hr = S_OK;
    LPOLESTR szSrc = NULL;
    CComPtr<IUnknown> spDirectDraw;
    CComPtr<IDirectDraw> spDD;
    DDCAPS ddCaps;

    if (m_pTIMEElementBase != NULL) //this only happens in the case of reentrancy
    {
        hr = S_OK;
        goto done;
    }

    ZeroMemory(&ddCaps, sizeof(DDCAPS));
    ddCaps.dwSize = sizeof(DDCAPS);

    hr = CTIMEDshowBasePlayer::Init(pelem, base, src, lpMimeType, dblClipBegin, dblClipEnd);
    if (FAILED(hr))
    {
        goto done;
    }
    
    m_pTIMEElementBase = pelem;


    hr = m_pTIMEElementBase->GetServiceProvider()->QueryService(SID_SDirectDraw3, IID_TO_PPV(IUnknown, &spDirectDraw));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = spDirectDraw->QueryInterface(IID_IDirectDraw, (void**)&spDD);
    if (SUCCEEDED(hr))
    {
        hr = spDD->GetCaps(&ddCaps, NULL);
        if(SUCCEEDED(hr))
        {
            if (!(ddCaps.dwCaps & DDCAPS_OVERLAY)) //lint !e620
            {
                hr = E_FAIL;
                goto done;
            }

            if (!(ddCaps.dwFXCaps & DDFXCAPS_OVERLAYSHRINKX)) //lint !e620
            {
                hr = E_FAIL;
                goto done;
            }

            if (!(ddCaps.dwFXCaps & DDFXCAPS_OVERLAYSHRINKY)) //lint !e620
            {
                hr = E_FAIL;
                goto done;
            }

            if (!(ddCaps.dwFXCaps & DDFXCAPS_OVERLAYSTRETCHX)) //lint !e620
            {
                hr = E_FAIL;
                goto done;
            }

            if (!(ddCaps.dwFXCaps & DDFXCAPS_OVERLAYSTRETCHY)) //lint !e620
            {
                hr = E_FAIL;
                goto done;
            }

            if(ddCaps.dwMinOverlayStretch > 0)
            {
                hr = E_FAIL;
                goto done;
            }

        }
    }
    
    hr = InitDshow();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(CoMarshalInterThreadInterfaceInStream(IID_ITIMEImportMedia, static_cast<ITIMEImportMedia*>(this), &m_pTIMEMediaPlayerStream));
    if (FAILED(hr))
    {
        goto done;
    }
    if (src == NULL)
    {
        hr = S_OK;
        goto done;
    }

    hr = THR(::TIMECombineURL(base, src, &szSrc));
    if (!szSrc)
    {
        hr = E_FAIL;
        goto done;
    }
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetAtomTable()->AddNameToAtomTable(szSrc, &m_lSrc);
    if (FAILED(hr))
    {
        goto done;
    }
    
    Assert(NULL != GetImportManager());

    hr = GetImportManager()->Add(this);
    if (FAILED(hr))
    {
        goto done;
    }

    ClearNaturalDuration();

    if( dblClipBegin != -1.0)
    {
        m_dblClipStart = dblClipBegin;
    }

    if( dblClipEnd != -1.0)
    {
        m_dblClipEnd = dblClipEnd;
    }

    Assert(NULL != m_pTIMEElementBase->GetBody());
    hr = m_pTIMEElementBase->GetBody()->AddInternalEventSink(this, 0.0);
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
done:
        delete[] szSrc;
    return hr;
}

HRESULT
CTIMEDshowHWPlayer::DetachFromHostElement (void)
{
    HRESULT hr = S_OK;

    TraceTag((tagDshowTimeHWPlayer,
              "CTIMEDshowHWPlayer(%lx)::DetachFromHostElement)",
              this));

    if(m_fDetached)
    {
        goto done;
    }

    m_fRemoved = true;
    m_fDetached = true;

    if  (m_spOpenProgress)
    {
        m_spOpenProgress->AbortOperation();
        m_spOpenProgress = NULL;
    }

    Assert(NULL != GetImportManager());

    IGNORE_HR(GetImportManager()->Remove(this));

    CTIMEDshowBasePlayer::DetachFromHostElement();

    {
        CritSectGrabber cs(m_CriticalSection);
        if (false == m_fUsingInterfaces)
        {
            DeinitDshow();
        }
        else
        {
            m_fNeedToDeleteInterfaces = true;
        }
    }
    
    if (NULL != m_pTIMEElementBase->GetBody())
    {
        IGNORE_HR(m_pTIMEElementBase->GetBody()->RemoveInternalEventSink(this));
    }
    
    m_pTIMEElementBase = NULL;
    NullAtomTable();
done:
    return hr;
}

void
CTIMEDshowHWPlayer::ReleaseSpecificInterfaces()
{
    m_pMediaContent = NULL;
    if (m_pIMixerOCX != NULL)
    {
        // why not release here?
        // m_pIMixerOCX.Release();
        m_pIMixerOCX = NULL;
    }

    if(m_pDDEX != NULL)
    {
        IGNORE_HR(m_pDDEX->SetDDrawObject(NULL));
        IGNORE_HR(m_pDDEX->SetDDrawSurface(NULL));   
        m_pDDEX.Release();
        m_pDDEX = NULL;
    }

    if(m_pClipper != NULL)
    {
        m_pClipper->SetClipList(NULL, 0);
        IGNORE_HR(m_pClipper->SetHWnd(0, NULL));
        m_pClipper->Release();
        m_pClipper = NULL;
    }

    if (m_pDDS != NULL)
    {
        m_pDDS->SetClipper(NULL);
        m_pDDS->Release();
        m_pDDS = NULL;
    }

    if (m_pDD != NULL)
    {
        m_pDD->Release();
        m_pDD = NULL;
    }
}

void
CTIMEDshowHWPlayer::FreeSpecificData()
{

}

void
CTIMEDshowHWPlayer::DeinitDshow()
{
    CTIMEDshowBasePlayer::DeinitDshow();
}

HRESULT
CTIMEDshowHWPlayer::BuildGraph()
{
    HRESULT hr = S_OK;

    hr = CreateMessageWindow();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = CoCreateInstance(CLSID_FilterGraphNoThread,
                          NULL,
                          CLSCTX_INPROC_SERVER, //lint !e655
                          IID_IGraphBuilder,
                          (void **)&m_pGB);
    // dshow not installed
    if (hr == REGDB_E_CLASSNOTREG)
    {
        CComPtr<IUnknown> pObj;
        hr = THR(CreateObject(__uuidof(MediaPlayerCLSID),
                              IID_IUnknown,
                              (void **)&pObj));
        if (FAILED(hr))
        {
            goto done;
        }

        hr = CoCreateInstance(CLSID_FilterGraphNoThread,
                              NULL,
                              CLSCTX_INPROC_SERVER, //lint !e655
                              IID_IGraphBuilder,
                              (void **)&m_pGB);
    }
    if (FAILED(hr))
    {
        goto done;
    }
    hr = SetUpMainWindow();
    if (FAILED(hr))
    {
        goto done;
    }

    IGNORE_HR(m_pGB->QueryInterface(IID_TO_PPV(IAMOpenProgress, &m_spOpenProgress)));
    
done:
    return hr;
}

HRESULT
CTIMEDshowHWPlayer::GetSpecificInterfaces()
{
    HRESULT hr = S_OK;
    if (m_pOvM == NULL)
    {
        hr = CoCreateInstance(CLSID_OverlayMixer, NULL, CLSCTX_INPROC, IID_IBaseFilter, (LPVOID *)&m_pOvM) ; //lint !e655
        // dshow not installed
        if (hr == REGDB_E_CLASSNOTREG)
        {
            CComPtr<IUnknown> pObj;
            hr = THR(CreateObject(__uuidof(MediaPlayerCLSID),
                                  IID_IUnknown,
                                  (void **)&pObj));
            if (FAILED(hr))
            {
                goto done;
            }
            hr = CoCreateInstance(CLSID_OverlayMixer, NULL, CLSCTX_INPROC, IID_IBaseFilter, (LPVOID *)&m_pOvM) ; //lint !e655
        }
        if (FAILED(hr) || m_pOvM == NULL)
        {
            goto done;
        }
    }

    hr = m_pOvM->QueryInterface(IID_IMixerOCX,(void **)&m_pIMixerOCX);
    if (hr == E_NOINTERFACE)
    {
        // dshow dll is there, but its not properly registered
        CComPtr<IUnknown> pObj;
        hr = THR(CreateObject(__uuidof(MediaPlayerCLSID),
                              IID_IUnknown,
                              (void **)&pObj));
        if (FAILED(hr))
        {
            m_pOvM.Release();
            goto done;
        }

        hr = m_pOvM->QueryInterface(IID_IMixerOCX,(void **)&m_pIMixerOCX);
    }
    if (FAILED(hr) || m_pIMixerOCX == NULL)
    {
        m_pOvM.Release();
        goto done;
    }

    hr = m_pGB->AddFilter(m_pOvM, OVLMixer);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = SetUpDDraw(m_pIMixerOCX);
    if (FAILED(hr))
    {
        goto done;
    }

    m_fMediaComplete = false;
done:
    return hr;
}


HRESULT
CTIMEDshowHWPlayer::InitDshow()
{
    HRESULT hr = S_OK;

    hr = CTIMEDshowBasePlayer::InitDshow();
    return hr;
}

class CSimplePB : public IMediaPropertyBag
{
    STDMETHOD(QueryInterface) (THIS_ REFIID, LPVOID *) { return E_NOINTERFACE; }
    STDMETHOD_(ULONG, AddRef)(THIS) { return 0; }
    STDMETHOD_(ULONG, Release)(THIS) { return 0; }
        
    STDMETHOD(Read)(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog) { return E_NOTIMPL; }
    STDMETHOD(EnumProperty) (ULONG iProperty, VARIANT *pvarName, VARIANT *pvarVal) { return E_NOTIMPL; } 
        
    LPCOLESTR m_pLookFor;
    BSTR *m_pbstrOut;

    STDMETHOD(Write) (LPCOLESTR pszPropName, VARIANT *pVar)
    {
        if (0 == wcscmp(m_pLookFor, pszPropName))
        {
            if (pVar->vt != VT_BSTR)
            {
                return E_NOTIMPL;
            }

            *m_pbstrOut = SysAllocString(pVar->bstrVal);
            if (NULL == m_pbstrOut)
            {
                return E_FAIL;
            }
        }

        return S_OK;
    }

    public:    
    CSimplePB() :
        m_pbstrOut(NULL), m_pLookFor(NULL) {}
    CSimplePB(LPCOLESTR pLookFor, BSTR *pbstrOut) :
        m_pbstrOut(pbstrOut), m_pLookFor(pLookFor) {}
};



HRESULT
CTIMEDshowHWPlayer::ReadContentProperty(IGraphBuilder *pGraph, LPCWSTR lpcwstrTag, BSTR * pbstr)
{
    IPersistMediaPropertyBag *pPMPB = NULL;
    if (S_OK == FindInterfaceOnGraph(pGraph, IID_IPersistMediaPropertyBag,
                                     (void **) &pPMPB))
    {
        CSimplePB pb(lpcwstrTag, pbstr);

        pPMPB->Save(&pb, FALSE, FALSE);

        pPMPB->Release();
    }

    return *pbstr ? S_OK : E_FAIL;
}

HRESULT
CTIMEDshowHWPlayer::SetUpHdc()
{
    HRESULT hr = S_OK;

    if (IsOvMConnected(m_pOvM)) // if we have video get the native size
    {
        hr = m_pIMixerOCX->GetVideoSize(&m_nativeVideoWidth, &m_nativeVideoHeight);
        if (FAILED(hr))
        {
            goto done;
        }

        m_fHasVideo = true;
    }
    else //if we only have audio: native size is 0 0
    {
        m_nativeVideoWidth = 0;
        m_nativeVideoHeight = 0;
    }
    m_fDoneSetup = true;
done:

    return hr;
}

HRESULT
CTIMEDshowHWPlayer::InitElementSize()
{
    DWORD aspectX, aspectY;
    HRESULT hr;
    RECT nativeSize, elementSize;
    bool fisNative;

    if (NULL == m_pTIMEElementBase)
    {
        hr = S_OK;
        goto done;
    }
    
    if( m_pDDEX == NULL)
    {
        hr = S_OK;
        goto done;
    }

    m_pDDEX->GetNativeVideoProps(&m_nativeVideoWidth, &m_nativeVideoHeight, &aspectX, &aspectY);

    nativeSize.left = nativeSize.top = 0;
    nativeSize.right = m_nativeVideoWidth;
    nativeSize.bottom = m_nativeVideoHeight;
    
    hr = m_pTIMEElementBase->NegotiateSize( nativeSize, elementSize, fisNative);

    m_elementSize.right = elementSize.right;
    m_elementSize.bottom = elementSize.bottom;

    PropagateOffsets();

done:
    return hr;
}

HRESULT
CTIMEDshowHWPlayer::SetSrc(LPOLESTR base, LPOLESTR src)
{   
    TraceTag((tagDshowTimeHWPlayer,
              "CTIMEDshowHWPlayer(%lx)::SetSrc()\n",
              this));
    
    LPOLESTR szSrc = NULL;
    HRESULT hr = S_OK;

    //create and initialize the URL_COMPONENTS structure
    URL_COMPONENTSW URLComp;
    ZeroMemory(&URLComp, sizeof(URL_COMPONENTS));
    URLComp.dwStructSize = sizeof(URL_COMPONENTS);
    URLComp.dwUrlPathLength = INTERNET_MAX_URL_LENGTH;
    URLComp.dwExtraInfoLength = INTERNET_MAX_URL_LENGTH;

    DeinitDshow();
    m_fLoadError = false;
    if (src == NULL)
    {
        goto done;
    }

    hr = THR(::TIMECombineURL(base, src, &szSrc));
    if (!szSrc)
    {
        hr = E_FAIL;
        goto done;
    }
    if (FAILED(hr))
    {
        goto done;
    }


    if (!InternetCrackUrlW(szSrc, lstrlenW(szSrc), 0, &URLComp))
    {
        hr = E_INVALIDARG;
        goto done;
    }

    hr = InitDshow();
    if (FAILED(hr))
    {
        goto done;
    }

    if (IsHTMLSrc(URLComp.lpszExtraInfo))
    {
        LPOLESTR lpszPath = NULL;
        SetStreamFlags(URLComp.lpszExtraInfo);

        lpszPath = NEW OLECHAR [URLComp.dwUrlPathLength + 1];
        if (lpszPath == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
        StrCpyNW(lpszPath, URLComp.lpszUrlPath, URLComp.dwUrlPathLength + 1);
        lpszPath[URLComp.dwUrlPathLength] = 0;

        hr = THR(m_pGB->RenderFile(lpszPath, NULL));
        delete [] lpszPath;
        lpszPath = NULL;
    }
    else
    {
        hr = THR(m_pGB->RenderFile(szSrc, NULL));
    }
    if (FAILED(hr)) // this fall through catches media load failed errors from either call to RenderFile above.
    {
        FireMediaEvent(PE_ONMEDIAERROR);
        goto done;
    }


    hr = FindInterfaceOnGraph(m_pGB, IID_IAMMediaContent, (void **)&m_pMediaContent);
    if (FAILED(hr))
    {
        m_pMediaContent = NULL;
    }
    hr = FindInterfaceOnGraph(m_pGB, IID_IBasicAudio, (void **)&m_pBasicAudio);
    if (FAILED(hr))
    {
        m_pBasicAudio = NULL;
    }
    hr = SetUpHdc();
    if (FAILED(hr))
    {
        goto done;
    }

    if (IsHTMLSrc(URLComp.lpszExtraInfo))
    {
        hr = THR(DisableAudioVideo());
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else
    {
        hr = InitElementSize();
        if (FAILED(hr))
        {
            goto done;
        }
    }


    //InitElementDuration();
    hr = m_pMC->Run();
    if (FAILED(hr))
    {
        goto done;
    } 

    if (m_fRunning == false)
    {
        Pause();
    }
    else
    {
        Resume();
    }

    ClearNaturalDuration();

    hr = S_OK;
done:
    if (FAILED(hr))
    {
        m_fLoadError = true;
    }
    delete[] szSrc;
    
    return hr;

}

STDMETHODIMP
CTIMEDshowHWPlayer::CanBeCued(VARIANT_BOOL * pVB_CanCue)
{
    HRESULT hr = S_OK;

    if (NULL == pVB_CanCue)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    *pVB_CanCue = m_fCanCueNow ? VARIANT_TRUE : VARIANT_FALSE;
    
    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP
CTIMEDshowHWPlayer::CueMedia()
{
    TraceTag((tagDshowTimeHWPlayer,
              "CTIMEDshowHWPlayer(%lx)::CueMedia()",
              this));
    HRESULT hr = S_OK;

    CComPtr<ITIMEImportMedia> spTIMEMediaPlayer;
    CComPtr<IStream> spStream;
    
    hr = THR(CoGetInterfaceAndReleaseStream(m_pTIMEMediaPlayerStream, IID_TO_PPV(ITIMEImportMedia, &spTIMEMediaPlayer)));
    m_pTIMEMediaPlayerStream = NULL; // no need to release, the previous call released the reference
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(NULL != m_pProxy);

    {
        CritSectGrabber cs(m_CriticalSection);

        m_fUsingInterfaces = true;
    }

    Block();
    
    IGNORE_HR(BeginDownload());

    UnBlock();
    
    hr = spTIMEMediaPlayer->InitializeElementAfterDownload();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    {
        CritSectGrabber cs(m_CriticalSection);

        if (m_fNeedToDeleteInterfaces)
        {
            DeinitDshow();
            m_fNeedToDeleteInterfaces = false;
        }

        m_fUsingInterfaces = false;
    }
    return hr;
}


STDMETHODIMP
CTIMEDshowHWPlayer::MediaDownloadError()
{
    return S_OK;
}

HRESULT
CTIMEDshowHWPlayer::BeginDownload()
{
    HRESULT hr = S_OK;

    const WCHAR * cpchSrc = NULL;
    WCHAR * beckified = NULL;
    
    //create and initailzie the URL_COMPONENTS structure
    URL_COMPONENTSW URLComp;
    ZeroMemory(&URLComp, sizeof(URL_COMPONENTS));
    URLComp.dwStructSize = sizeof(URL_COMPONENTS);
    URLComp.dwUrlPathLength = INTERNET_MAX_URL_LENGTH;
    URLComp.dwExtraInfoLength = INTERNET_MAX_URL_LENGTH;

    if(GetAtomTable() == NULL)
    {
        hr = E_FAIL;
        goto done;
    }

    if(m_pGB == NULL)
    {
        hr = E_UNEXPECTED;
        goto done;
    }
    
    hr = GetAtomTable()->GetNameFromAtom(m_lSrc, &cpchSrc);
    if (FAILED(hr))
    {
        goto done;
    }

    if (!InternetCrackUrlW(cpchSrc, lstrlenW(cpchSrc), 0, &URLComp))
    {
        hr = E_INVALIDARG;
        goto done;
    }

    if (IsHTMLSrc(URLComp.lpszExtraInfo))
    {
        LPOLESTR lpszPath = NULL;
        long l = 0;
        lpszPath = NEW OLECHAR [lstrlenW(cpchSrc) + 1];
        if (lpszPath == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }   
        l = lstrlenW(cpchSrc);
        StrCpyNW(lpszPath, cpchSrc, l - URLComp.dwExtraInfoLength + 1);            
        lpszPath[l - URLComp.dwExtraInfoLength + 1] = 0;
        //StrCpyNW(lpszPath, URLComp.lpszUrlPath, lstrlenW(cpchSrc) - URLComp.dwExtraInfoLength);            
        //lpszPath[lstrlenW(cpchSrc) - URLComp.dwExtraInfoLength] = 0;

        if (m_pGB == NULL)
        {
            hr = E_FAIL;
            goto done;
        }
// This used to convert URL's to a netshow extension.
// The call HRESULT CdxmPlay::InternalOpen( COpenRequest *pRequest) in
// in WMP 6.4 source code shows the issue.
        beckified = BeckifyURL(lpszPath);

        if(beckified != NULL)
        {
            hr = THR(m_pGB->RenderFile(beckified, NULL));
        }
        else
        {
            hr = THR(m_pGB->RenderFile(lpszPath, NULL));
        }
        delete [] lpszPath;
        lpszPath = NULL;

        SetStreamFlags(URLComp.lpszExtraInfo);
    }
    else
    {
        if (m_pGB == NULL)
        {
            hr = E_FAIL;
            goto done;
        }
// This used to convert URL's to a netshow extension.
// The call HRESULT CdxmPlay::InternalOpen( COpenRequest *pRequest) in
// in WMP 6.4 source code shows the issue.
        beckified = BeckifyURL((WCHAR *)cpchSrc);

        if(beckified != NULL)
        {
            hr = THR(m_pGB->RenderFile(beckified, NULL));
        }
        else
        {
            hr = THR(m_pGB->RenderFile(cpchSrc, NULL));
        }
    }

    if (FAILED(hr))
    {
        // this fall through catches media load 
        // failed errors from either call to RenderFile above.
        m_hrRenderFileReturn = hr;
    }

    hr = S_OK;
done:

    delete[] beckified;
    RRETURN(hr);
}

HRESULT
CTIMEDshowHWPlayer::GraphFinish()
{
    TraceTag((tagDshowTimeHWPlayer,
              "CTIMEDshowHWPlayer(%lx::GraphFinish()",
              this));

    HRESULT hr = S_OK;
    
    CComPtr<IHTMLElement2> spElement2;
    CComPtr<IMixerPinConfig> pMPC;
    CComPtr<IPin> pPin;
    CComPtr<IFilterGraph> spFG;
    CComPtr<IBaseFilter> spBF;

    if (FAILED(m_hrRenderFileReturn))     
    {
        FireMediaEvent(PE_ONMEDIAERROR);
        hr = m_hrRenderFileReturn;
        goto done;
    }

    if (m_fNeedToDeleteInterfaces)
    {
        goto done;
    }

    hr = m_pOvM->FindPin(L"Input0", &pPin);
    if (SUCCEEDED(hr))
    {
        pPin->QueryInterface(IID_IMixerPinConfig, (LPVOID *) &pMPC);
        if (SUCCEEDED(hr))
        {
            COLORKEY clr;
            clr.KeyType = CK_RGB ;
            clr.LowColorValue = m_clrKey;
            clr.HighColorValue = m_clrKey;

            hr = pMPC->SetColorKey(&clr);
            if(FAILED(hr))
            {
                FireMediaEvent(PE_ONMEDIAERRORCOLORKEY);
                goto done;
            }
            hr = pMPC->SetAspectRatioMode(AM_ARMODE_STRETCHED);
        }
    }


    hr = m_pGB->QueryInterface(IID_IFilterGraph, (void **)&spFG);
    if(SUCCEEDED(hr))
    {
        hr = spFG->FindFilterByName(L"Video Renderer", &spBF);
        if(SUCCEEDED(hr))
        {
            FireMediaEvent(PE_ONMEDIAERRORCOLORKEY);
            goto done;
        }

    }

    if (!IsOvMConnected(m_pOvM)) // if we have video get the native size
    {
        hr = m_pGB->RemoveFilter(m_pOvM);
    }

    hr = FindInterfaceOnGraph(m_pGB, IID_IAMMediaContent, (void **)&m_pMediaContent);
    if (FAILED(hr))
    {
        m_pMediaContent = NULL;
    }
    hr = FindInterfaceOnGraph(m_pGB, IID_IBasicAudio, (void **)&m_pBasicAudio);
    if (FAILED(hr))
    {
        m_pBasicAudio = NULL;
    }
     //can be used m_pIAMNetShowConfig->put_BufferingTime(1.0);
    hr = FindInterfaceOnGraph(m_pGB, IID_IAMNetShowConfig,  (void **) &m_pIAMNetShowConfig);
    if (FAILED(hr))
    {
        m_pIAMNetShowConfig = NULL;
    }
    hr = FindInterfaceOnGraph(m_pGB, IID_IAMExtendedSeeking, (void **) &m_pExSeeking);
    if (FAILED(hr))
    {
        m_pExSeeking = NULL;
    } 
    hr = FindInterfaceOnGraph(m_pGB, IID_IAMNetworkStatus, (void **) &m_pIAMNetStat);
    if (FAILED(hr))
    {
        m_pExSeeking = NULL;
    } 
    
    hr = SetUpHdc();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GraphCue();
    if (FAILED(hr))
    {
        goto done;
    }

    if (m_pTIMEElementBase)
    {
        hr = m_pTIMEElementBase->GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &spElement2));
        if (FAILED(hr))
        {
            // IE4 path
            CComPtr<IElementBehaviorSite> spElementBehaviorSite;
            spElementBehaviorSite = m_pTIMEElementBase->GetBvrSite();
            
            CComPtr<IObjectWithSite> spSite;
            // see if we are running on IE4, and try to get spSite to be a CElementBehaviorSite*
            hr = spElementBehaviorSite->QueryInterface(IID_TO_PPV(IObjectWithSite, &spSite));
            if (FAILED(hr))
            {
                goto done;
            }
            
            CComPtr<IOleWindow> spOleWindow;
            // ask for the site (through CElementBehaviorSite to CVideoHost, to ATL::IObjectWIthSiteImpl
            hr = spSite->GetSite(IID_IOleWindow, (void**) &spOleWindow);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CTIMEDshowHWPlayer::Init - IE4 failure! unable to QI for IOleWindow on hosting Document"));
                goto done;
            }
        }
    }

done:
    return hr;
}

//
// CTIMEDshowHWPlayer::IsOvMConnected(): Private method to detect if the video stream 
// is passing through the Overlay Mixer (i.e, is it connected?).
//
bool
CTIMEDshowHWPlayer::IsOvMConnected(IBaseFilter *pOvM)
{    
    IEnumPins   *pEnumPins;
    IPin        *pPin;
    IPin        *pPin2;
    ULONG        ul;
    HRESULT      hr;
    bool         bConnected = false;

    pOvM->EnumPins(&pEnumPins);
    while (S_OK == pEnumPins->Next(1, &pPin, &ul) && 1 == ul && bConnected == false)
    {
        hr = pPin->ConnectedTo(&pPin2);
        if (SUCCEEDED(hr) && pPin2)
        {
            bConnected = true;
            pPin2->Release();
        }
        pPin->Release();
    }
    pEnumPins->Release();
    
    return bConnected;
}

void
CTIMEDshowHWPlayer::OnTick(double dblSegmentTime,
                         LONG lCurrRepeatCount)
{
    TraceTag((tagDshowTimeHWPlayer,
              "CTIMEDshowHWPlayer(%lx)::OnTick(%g, %d)",
              this,
              dblSegmentTime,
              lCurrRepeatCount));
}


void
CTIMEDshowHWPlayer::SetCLSID(REFCLSID clsid) 
{
}

void
CTIMEDshowHWPlayer::GraphStart(void)
{
    HRESULT hr = S_OK;
    TraceTag((tagDshowTimeHWPlayer,
              "CTIMEDshowHWPlayer(%lx)::GraphStart()",
              this));

    m_fLoadError = false;

    if (m_fMediaComplete == false)
    {
        goto done;
    }

    hr = THR(m_pMC->Run());
    if (FAILED(hr))
    {
        FireMediaEvent(PE_ONMEDIAERRORCOLORKEY);
        goto done;
    }

  done: 

    return;
}
    
HRESULT
CTIMEDshowHWPlayer::Render(HDC hdc, LPRECT prc)
{
    HBRUSH hbr = ::CreateSolidBrush(m_clrKey);

    bool bIsOn;

    if(m_pTIMEElementBase == NULL)
    {
        goto done;
    }
        
    bIsOn = m_pTIMEElementBase->IsOn();

    if(!bIsOn || !m_fMediaComplete)
    {
        goto done;
    }

    if(m_pDDEX == NULL)
    {
        goto done;
    }

    if (hbr)
    {
        ::FillRect(hdc, prc, hbr);
    }

done:
    if(hbr != NULL)
    {
        ::DeleteObject(hbr);
    }
    return S_OK;
}


// Helper functions..


HRESULT
CTIMEDshowHWPlayer::SetMixerSize(RECT *prect)
{
    HRESULT hr = S_OK;
    POINT pt;

    if (m_pIMixerOCX == NULL)
    {
        return S_OK;
    }
    pt.x = pt.y = 0;
    hr = m_pIMixerOCX->SetDrawRegion(&pt, prect, prect);

    return hr;
}

HRESULT
CTIMEDshowHWPlayer::SetSize(RECT *prect)
{
    HRESULT hr = S_OK;
    RECT rc;
    RECT videoRect;

    if(m_pDDEX == NULL)
    {
        goto done;
    }

    Assert(prect != NULL);

    m_elementSize.right = prect->right;
    m_elementSize.bottom = prect->bottom;
    hr = SetUpVideoOffsets();
    if (FAILED(hr))
    {
        goto done;
    }

    rc.top = m_lPixelPosTop - m_lscrollOffsety;
    rc.left = m_lPixelPosLeft - m_lscrollOffsetx;
    rc.bottom = rc.top + prect->bottom;
    rc.right = rc.left + prect->right;

    ::MapWindowPoints(m_hWnd, HWND_DESKTOP, (POINT *)&rc, 2);

    GetRelativeVideoClipBox(rc, m_elementSize, videoRect, 10000);

    hr = m_pDDEX->SetDrawParameters(&videoRect, &rc);

done:
    return hr;
}

HRESULT
CTIMEDshowHWPlayer::GetMediaLength(double &dblLength)
{
    HRESULT hr;

    if (m_pMC == NULL || m_pMP == NULL)
    {
        return E_FAIL;
    }

    hr = m_pMP->get_Duration(&dblLength);
    return hr;
}


HRESULT
CTIMEDshowHWPlayer::CanSeek(bool &fcanSeek)
{
    HRESULT hr = S_OK;
    LONG canSeek;
    long seekFlags = 0;

    if (m_pExSeeking == NULL)
    {
        if (!m_pMP)
        {
            fcanSeek = false;
            goto done;
        }
        hr = m_pMP->CanSeekBackward(&canSeek);
        if (FAILED(hr))
        {
            fcanSeek = false;
            goto done;
        }
        if (canSeek == 0)
        {
            fcanSeek = false;
            goto done;
        }
        hr = m_pMP->CanSeekForward(&canSeek);
        if (FAILED(hr))
        {
            fcanSeek = false;
            goto done;
        }
        if (canSeek == 0)
        {
            fcanSeek = false;
            goto done;
        }
        fcanSeek = true;
    }
    else
    {
        hr = m_pExSeeking->get_ExSeekCapabilities( &seekFlags);
        if (SUCCEEDED(hr)) 
        {
            if( seekFlags & AM_EXSEEK_CANSEEK)
            {
                fcanSeek = true;
                goto done;
            }
        }
        hr = S_OK;
        fcanSeek = false;
    }

done:
    return hr;
}


HRESULT
CTIMEDshowHWPlayer::GetAuthor(BSTR *pAuthor)
{
    HRESULT hr = S_OK;

    if (NULL != pAuthor)
    {
        if (m_pMediaContent != NULL)
        {
            hr = m_pMediaContent->get_AuthorName(pAuthor);
            if (FAILED(hr))
            {
                *pAuthor = NULL;
            }
        }

        if (FAILED(hr) || m_pMediaContent == NULL)
        {
            hr = ReadContentProperty(m_pGB, L"INFO/IART", pAuthor);
            if (FAILED(hr))
            {
                *pAuthor = NULL;
            }
        }
    }
    return hr;
}

HRESULT
CTIMEDshowHWPlayer::GetTitle(BSTR *pTitle)
{
    HRESULT hr = S_OK;

    if (NULL != pTitle)
    {
        if (m_pMediaContent != NULL)
        {
            hr = m_pMediaContent->get_Title(pTitle);
            if (FAILED(hr))
            {
                *pTitle = NULL;
            }
        }

        if (FAILED(hr) || m_pMediaContent == NULL)
        {
            hr = ReadContentProperty(m_pGB, L"INFO/INAM", pTitle);
            if (FAILED(hr))
            {
                hr = ReadContentProperty(m_pGB, L"INFO/ISBJ", pTitle);
                if (FAILED(hr))
                {
                    *pTitle = NULL;
                }
            }
        }
    }
    return hr;
}

HRESULT
CTIMEDshowHWPlayer::GetCopyright(BSTR *pCopyright)
{
    HRESULT hr = S_OK;

    if (NULL != pCopyright)
    {
        if (m_pMediaContent != NULL)
        {
            hr = m_pMediaContent->get_Copyright(pCopyright);
            if (FAILED(hr))
            {
                *pCopyright = NULL;
            }
        }

        if (FAILED(hr) || m_pMediaContent == NULL)
        {
            hr = ReadContentProperty(m_pGB, L"INFO/ICOP", pCopyright);
            if (FAILED(hr))
            {
                *pCopyright = NULL;
            }
        }
    }
    return hr;
}


HRESULT
CTIMEDshowHWPlayer::GetAbstract(BSTR *pBstrAbstract)
{
    HRESULT hr = S_OK;

    if (NULL != pBstrAbstract)
    {
        if (m_pMediaContent != NULL)
        {
            hr = m_pMediaContent->get_Description(pBstrAbstract);
            if (FAILED(hr))
            {
                *pBstrAbstract = NULL;
            }
        }
        else
        {
            *pBstrAbstract = NULL;
        }
    }
    return hr;
}


HRESULT
CTIMEDshowHWPlayer::GetRating(BSTR *pBstrRating)
{
    HRESULT hr = S_OK;

    if (NULL != pBstrRating)
    {
        if (m_pMediaContent != NULL)
        {
            hr = m_pMediaContent->get_Rating(pBstrRating);
            if (FAILED(hr))
            {
                *pBstrRating = NULL;
            }
        }
        else
        {
            *pBstrRating = NULL;
        }
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////
// This should take the lpszExtra info parameter from a URL_COMPONENTS structure.  In this
// field, the #html or #sami should be the first 5 characters in the string.
//////////////////////////////////////////////////////////////////////////////////////////////
void  
CTIMEDshowHWPlayer::SetStreamFlags(LPOLESTR src)
{
    long len = 0;
    OLECHAR stream[HTMLSTREAMSRCLEN + 1] = {0};
    
    m_bIsSAMISrc = false;
    m_bIsHTMLSrc = false;

    len = lstrlenW(src);
    if (len >= HTMLSTREAMSRCLEN)
    {
        memcpy((void *)stream, (void *)src, HTMLSTREAMSRCLEN * sizeof(OLECHAR));
    
        if (StrCmpIW(stream, HTMLSTREAMSRC) == 0)
        {
            m_bIsHTMLSrc = true;
        }
        if (StrCmpIW(stream, SAMISTREAMSRC) == 0)
        {
            m_bIsSAMISrc = true;
        }
    
    }
}

HRESULT
CTIMEDshowHWPlayer::DisableAudioVideo()
{
    HRESULT hr = E_FAIL;

    CComPtr<IBaseFilter> pMediaFilter;
    CComPtr<IPin> pPin;
    CComPtr<IEnumPins> pMediaPinEnum;
    
    //disconnect the video
    if (m_pMediaContent == NULL)
    {
        hr = E_FAIL;
        goto done;
    }
    hr = m_pMediaContent->QueryInterface(IID_IBaseFilter, (void **)&pMediaFilter);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pMediaFilter->EnumPins(&pMediaPinEnum);
    if (!pMediaPinEnum)
    {
        goto done;
    }
    while(pMediaPinEnum->Next(1, &pPin, NULL) == S_OK)
    {
        if (pPin != NULL)
        {
            IGNORE_HR(pPin->Disconnect());
        }
    }
    
    //silence the audio
    if (m_pBasicAudio != NULL)
    {
        hr = THR(m_pBasicAudio->put_Volume(SOUND_OF_SILENCE));
        if (FAILED(hr))
        {
            goto done;
        }
    }
    hr = S_OK;

done:
    return hr;
}


STDMETHODIMP
CTIMEDshowHWPlayer::InitializeElementAfterDownload()
{
    HRESULT hr = S_OK;
    TraceTag((tagDshowTimeHWPlayer, "CTIMEDshowHWPlayer(%lx)(%x)::InitializeElementAfterDownload",this));

    const WCHAR * cpchSrc = NULL;
    
    //create and initailzie the URL_COMPONENTS structure
    URL_COMPONENTSW URLComp;
    ZeroMemory(&URLComp, sizeof(URL_COMPONENTS));
    URLComp.dwStructSize = sizeof(URL_COMPONENTS);
    URLComp.dwUrlPathLength = INTERNET_MAX_URL_LENGTH;
    URLComp.dwExtraInfoLength = INTERNET_MAX_URL_LENGTH;

    if (m_fRemoved)
    {
        hr = E_FAIL;
        m_pMC->Stop();
        goto done;
    }
    
    hr = this->GraphFinish();
    if (FAILED(hr))
    {
        goto done;
    }
    
    if (m_fNeedToDeleteInterfaces)
    {
        goto done;
    }

    m_fMediaComplete = true;

    FireMediaEvent(PE_ONMEDIACOMPLETE);
    
    IGNORE_HR(this->InitElementDuration());
    
    m_pTIMEElementBase->InvalidateElement(NULL);

    InternalReset(true);

    hr = GetAtomTable()->GetNameFromAtom(m_lSrc, &cpchSrc);
    if (FAILED(hr))
    {
        goto done;
    }
    
    if (!InternetCrackUrlW(cpchSrc, lstrlenW(cpchSrc), 0, &URLComp))
    {
        hr = E_INVALIDARG;
        goto done;
    }
    
    if (IsHTMLSrc(URLComp.lpszExtraInfo))
    {
        hr = THR(DisableAudioVideo());
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else
    {
        hr = InitElementSize();
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done:

    return hr;
}

STDMETHODIMP
CTIMEDshowHWPlayer::GetUniqueID(long * plID)
{
    HRESULT hr = S_OK;

    Assert(NULL != plID);

    *plID = m_lSrc;

    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP
CTIMEDshowHWPlayer::GetPriority(double * pdblPriority)
{
    HRESULT hr = S_OK;
    if (NULL == pdblPriority)
    {
        return E_POINTER;
    }

    if (m_fHavePriority)
    {
        *pdblPriority = m_dblPriority;
    }
    
    Assert(m_pTIMEElementBase != NULL);
    Assert(NULL != m_pTIMEElementBase->GetElement());

    *pdblPriority = INFINITE;

    CComVariant varAttribute;
    
    hr = m_pTIMEElementBase->base_get_begin(&varAttribute);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = VariantChangeType(&varAttribute, &varAttribute, 0, VT_R8);
    if (FAILED(hr))
    {
        if ( DISP_E_TYPEMISMATCH == hr)
        {
            hr = S_OK;
        }
        goto done;
    }
    
    // either they set a priority or a begin time!
    *pdblPriority = varAttribute.dblVal;

    m_dblPriority = *pdblPriority;
    m_fHavePriority = true;
    
    hr = S_OK;
done:
    return hr;
}

HRESULT 
CTIMEDshowHWPlayer::GetNaturalHeight(long *height)
{
    if (m_nativeVideoHeight == 0)
    {
        *height = -1;
    }
    else
    {
        *height = (long)m_nativeVideoHeight;
    }
    
    return S_OK;
}

HRESULT 
CTIMEDshowHWPlayer::GetNaturalWidth(long *width)
{
    if (m_nativeVideoWidth == 0)
    {
        *width  = -1;
    }
    else
    {
        *width = (long)m_nativeVideoWidth;
    }

    return S_OK;
}

PlayerState
CTIMEDshowHWPlayer::GetState()
{
    PlayerState state;
    
    if (!m_bActive)
    {
        if (!m_fMediaComplete)
        {
            state = PLAYER_STATE_CUEING;
        }
        else
        {
            state = PLAYER_STATE_INACTIVE;
        }
    }
    else
    {
        if(!m_bMediaDone)
        {
            state = PLAYER_STATE_ACTIVE;
        }
        else
        {
            state = PLAYER_STATE_HOLDING;
        }
    }

    return state;
}

STDMETHODIMP
CTIMEDshowHWPlayer::GetMediaDownloader(ITIMEMediaDownloader ** ppImportMedia)
{
    HRESULT hr = S_OK;

    Assert(NULL != ppImportMedia);

    *ppImportMedia = NULL;

    hr = S_FALSE;
done:
    return hr;
}

STDMETHODIMP
CTIMEDshowHWPlayer::PutMediaDownloader(ITIMEMediaDownloader * pImportMedia)
{
    HRESULT hr = S_OK;
    
    hr = E_NOTIMPL;
done:
    return hr;
}

HRESULT
CTIMEDshowHWPlayer::Reset()
{
    return InternalReset(true);
}

HRESULT
CTIMEDshowHWPlayer::CanSeekToMarkers(bool &bcanSeekToM)
{
    HRESULT hr = S_OK;
    long lseekFlags;

    if( m_pExSeeking == NULL)
    {
        bcanSeekToM = false;
        goto done;
    }

    hr = m_pExSeeking->get_ExSeekCapabilities(&lseekFlags);
    if(FAILED(hr))
    {
        bcanSeekToM = false;
        goto done;
    }
    if(lseekFlags & AM_EXSEEK_MARKERSEEK)
    {
        bcanSeekToM = true;
    }
    else
    {
        bcanSeekToM = false;
    }
    hr = S_OK;

done:
    return hr;
}

HRESULT
CTIMEDshowHWPlayer::IsBroadcast(bool &bisBroad)
{
    HRESULT hr = S_OK;
    VARIANT_BOOL vbVal;

    if(m_fMediaComplete == false)
    {
        bisBroad = false;
        goto done;
    }

    if( m_pIAMNetStat == NULL)
    {
        bisBroad = false;
        goto done;
    }

    hr = m_pIAMNetStat->get_IsBroadcast(&vbVal);
    if(FAILED(hr))
    {
        bisBroad = false;
        goto done;
    }
    if(vbVal)
    {
        bisBroad = true;
    }
    else
    {
        bisBroad = false;
    }
    hr = S_OK;

done:
    return hr;
}

HRESULT
CTIMEDshowHWPlayer::HasMedia(bool &bHasMedia)
{
    bHasMedia = m_fMediaComplete;

    return S_OK;
}

HRESULT
CTIMEDshowHWPlayer::HasVisual(bool &bHasVideo)
{
    bHasVideo = m_fHasVideo;
    return S_OK;
}

HRESULT
CTIMEDshowHWPlayer::HasAudio(bool &bHasAudio)
{

    if(m_pBasicAudio != NULL)
    {
        bHasAudio = true;
    }
    else
    {
        bHasAudio = false;
    }
    return S_OK;
}

HRESULT
CTIMEDshowHWPlayer::GetRate(double &dblRate)
{
    HRESULT hr = S_OK;

    if(m_pMS != NULL)
    {
        hr = m_pMS->GetRate(&dblRate);
    }

    return hr;
}


HRESULT
CTIMEDshowHWPlayer::SetRate(double dblRate)
{
    HRESULT hr = S_OK;

    if((m_pMS != NULL) && (m_pIAMNetStat == NULL))
    {
        hr = m_pMS->SetRate(dblRate);
    }

    return hr;
}

STDMETHODIMP
CTIMEDshowHWPlayer::InternalEvent()
{
    m_fCanCueNow = true;

    Assert (NULL != GetImportManager());

    IGNORE_HR(GetImportManager()->DataAvailable());
    
    return S_OK;
}


HRESULT
CTIMEDshowHWPlayer::SetUpMainWindow()
{
    CComPtr<IHTMLElement> pHTMLElem = m_pTIMEElementBase->GetElement();
    CComPtr<IHTMLDocument2> pHTMLDoc;
    CComPtr<IDispatch> pDisp;
    CComPtr<IOleWindow> pOleWindow;
    HRESULT hr = S_OK;

    hr = pHTMLElem->get_document(&pDisp);
    if (FAILED(hr))
    {
        goto done;
    }
    hr = pDisp->QueryInterface(IID_TO_PPV(IHTMLDocument2, &pHTMLDoc));
    if (FAILED(hr))
    {
        goto done;
    }
    hr = pHTMLDoc->QueryInterface(IID_TO_PPV(IOleWindow, &pOleWindow));
    if (FAILED(hr))
    {
        goto done;
    }
    hr = pOleWindow->GetWindow(&m_hWnd);
    if (FAILED(hr))
    {
        goto done;
    }

done:
    return hr;
}


HRESULT
CTIMEDshowHWPlayer::SetUpDDraw(IMixerOCX *pIMixerOCX)
{

    HRESULT hr = E_UNEXPECTED;
    
    if (m_pDD != NULL)
    {
        // see if we went through this already
        return(hr); 
    }

    hr = DirectDrawCreate(NULL, &m_pDD, NULL);
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = m_pDD->SetCooperativeLevel(m_hWnd, DDSCL_NORMAL); //lint !e620

    if (FAILED(hr))
    {

        if (m_pDD != NULL)
        {
            m_pDD->Release();
            m_pDD = NULL;
        }

        return(hr);
    }

    DDSURFACEDESC ddsd;
    ::ZeroMemory(&ddsd, sizeof(ddsd));
    ddsd.dwSize = sizeof(ddsd);

    ddsd.dwFlags = DDSD_CAPS; //lint !e620
    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE; //lint !e620

    hr = m_pDD->CreateSurface(&ddsd, &m_pDDS, NULL);

    if (FAILED(hr))
    {

        if (m_pDD != NULL)
        {
            m_pDD->Release();
            m_pDD = NULL;
        }

        return(hr);
    }


    hr = m_pDD->CreateClipper(0, &m_pClipper, NULL);

    if (FAILED(hr))
    {

        if (m_pDDS != NULL)
        {
            m_pDDS->Release();
            m_pDDS = NULL;
        }/* end of if statement */

        if (m_pDD != NULL)
        {
            m_pDD->Release();
            m_pDD = NULL;
        }

        return(hr);
    }

    hr = m_pClipper->SetHWnd(0, m_hWnd);

    if (FAILED(hr))
    {
        if(m_pClipper != NULL)
        {
            m_pClipper->SetClipList(NULL, 0);
            m_pClipper->Release();
            m_pClipper = NULL;
        }

        if (m_pDDS != NULL)
        {
            m_pDDS->SetClipper(NULL);
            m_pDDS->Release();
            m_pDDS = NULL;
        }

        if (m_pDD != NULL)
        {
            m_pDD->Release();
            m_pDD = NULL;
        }

        return(hr);
    }


    hr = m_pDDS->SetClipper(m_pClipper);

    if (FAILED(hr))
    {
        if (m_pDDS != NULL)
        {
            m_pDDS->Release();
            m_pDDS = NULL;
        }

        if (m_pDD != NULL)
        {
            m_pDD->Release();
            m_pDD = NULL;
        }

        if (m_pClipper != NULL)
        {
            m_pClipper->Release();
            m_pClipper = NULL;
        }

        return(hr);
    }


    hr = pIMixerOCX->QueryInterface(IID_IDDrawExclModeVideo, (LPVOID *)&m_pDDEX);
    if (FAILED(hr))
    {
        goto done;
    }
    hr = m_pDDEX->SetDDrawObject(m_pDD);
    if (FAILED(hr))
    {
        goto done;
    }
    hr = m_pDDEX->SetDDrawSurface(m_pDDS);
    if (FAILED(hr))
    {
        goto done;
    }

done:
    return(hr);
}/* end of function SetupDDraw */


HRESULT
CTIMEDshowHWPlayer::SetUpVideoOffsets()
{
    CComPtr<IDispatch> pDisp;
    CComPtr<IHTMLDocument2> pDoc;
    CComPtr<IHTMLElement> pBody;
    CComPtr<IHTMLElement> pElem;
    CComPtr<IHTMLElement2> pElem2;
    CComPtr<IHTMLWindow2> pWin2;
    CComPtr<IHTMLWindow4> pWin4;
    CComPtr<IHTMLFrameBase> pFrameBase;
    CComPtr<IHTMLElement> pFrameElem;
    long lscrollOffsetyc = 0, lscrollOffsetxc = 0, lPixelPosTopc = 0, lPixelPosLeftc = 0;

    HRESULT hr = S_OK;
    m_lscrollOffsety = m_lscrollOffsetx = m_lPixelPosTop = m_lPixelPosLeft = 0;

    hr = THR(m_pTIMEElementBase->GetElement()->get_document(&pDisp));
    if (FAILED(hr))
    {
        goto done;
    }
    hr = THR(pDisp->QueryInterface(IID_IHTMLDocument2, (void **)&pDoc));
    if (FAILED(hr))
    {
        goto done;
    }
    hr = pDoc->get_body(&pBody);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_pTIMEElementBase->GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElem2)));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pElem2->get_clientWidth(&(m_elementSize.right));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pElem2->get_clientHeight(&(m_elementSize.bottom));
    if (FAILED(hr))
    {
        goto done;
    }


    hr = WalkUpTree(m_pTIMEElementBase->GetElement(), lscrollOffsetyc, lscrollOffsetxc, lPixelPosTopc, lPixelPosLeftc);
    if(FAILED(hr))
    {
        goto done;
    }

    hr = pDoc->get_parentWindow(&pWin2);
    if(FAILED(hr))
    {
        goto done;
    }
    hr = THR(pWin2->QueryInterface(IID_IHTMLWindow4, (void **)&pWin4));
    if (FAILED(hr) || pWin4 == NULL)
    {
        hr = S_OK;
        goto done;
    }

    hr = pWin4->get_frameElement(&pFrameBase);
    if (FAILED(hr) || pFrameBase == NULL)
    {
        goto done;
    }

    hr = THR(pFrameBase->QueryInterface(IID_IHTMLElement, (void **)&pFrameElem));
    if (FAILED(hr))
    {
        goto done;
    }

    IGNORE_HR(WalkUpTree(pFrameElem, lscrollOffsetyc, lscrollOffsetxc, lPixelPosTopc, lPixelPosLeftc));

done:
    m_lscrollOffsety = lscrollOffsetyc;
    m_lscrollOffsetx = lscrollOffsetxc;
    m_lPixelPosTop = lPixelPosTopc;
    m_lPixelPosLeft = lPixelPosLeftc;

    return hr;
}

void
CTIMEDshowHWPlayer::PropagateOffsets()
{
    RECT localRect;
    RECT videoRect;
    HRESULT hr;

    videoRect.top = 0;
    videoRect.left = 0;
    videoRect.right = 10000;
    videoRect.bottom = 10000;

    if(m_pDDEX == NULL)
    {
        hr = S_OK;
        goto done;
    }

    hr = SetUpVideoOffsets();
    if (FAILED(hr))
    {
        goto done;
    }

    localRect.top = m_lPixelPosTop - m_lscrollOffsety;
    localRect.left = m_lPixelPosLeft - m_lscrollOffsetx;
    localRect.bottom = localRect.top + m_elementSize.bottom;
    localRect.right = localRect.left + m_elementSize.right;
    ::MapWindowPoints(m_hWnd, HWND_DESKTOP, (POINT *)&localRect, 2);

    if((localRect.bottom == m_deskRect.bottom) &&
        (localRect.top == m_deskRect.top) &&
        (localRect.left == m_deskRect.left) &&
        (localRect.right == m_deskRect.right))
    {
        goto done;
    }

    GetRelativeVideoClipBox(localRect, m_elementSize, videoRect, 10000);

    m_deskRect = localRect;

    THR(m_pDDEX->SetDrawParameters(&videoRect, &localRect));
done:
    return;
}


void
CTIMEDshowHWPlayer::Tick()
{
    bool bIsOn = m_pTIMEElementBase->IsOn();

    if(!bIsOn || !m_fMediaComplete)
    {
        goto done;
    }

    TraceTag((tagDshowTimeHWPlayer, "CTIMEDshowHWPlayer(%lx)(%x)::Tick",this));
    PropagateOffsets();

done:
    return;
}


HRESULT
CTIMEDshowHWPlayer::GetIsStreamed(bool &fIsStreamed)
{
    HRESULT hr = S_OK;

    if (m_pIAMNetStat)
    {
        fIsStreamed = true;
    }
    else
    {
        fIsStreamed = false;
    }

done:
    return hr;
}

HRESULT
CTIMEDshowHWPlayer::GetBufferingProgress(double &dblBufferingProgress)
{
    HRESULT hr = S_OK;
    long lbProg;

    if (!m_pIAMNetStat)
    {
        hr = E_FAIL;
        dblBufferingProgress = 0.0;
        goto done;
    }

    if (FAILED(m_pIAMNetStat->get_BufferingProgress( &lbProg)))
    {
        dblBufferingProgress = 0.0;
        goto done;
    }

    dblBufferingProgress = (double )lbProg;

    hr = S_OK;
done:
    return hr;
}

HRESULT
CTIMEDshowHWPlayer::GetHasDownloadProgress(bool &fHasDownloadProgress)
{
    HRESULT hr = S_OK;
    bool fIsStreamed;

    if(FAILED(hr = GetIsStreamed(fIsStreamed)))
    {
        goto done;
    }

    if (fIsStreamed)
    {
        fHasDownloadProgress = false;
    }
    else
    {
        fHasDownloadProgress = true;
    }

    hr = S_OK;
done:
    return hr;
}

void
CTIMEDshowHWPlayer::Block()
{
    if(m_pProxy)
    {
        m_pProxy->Block();
    }
}

void
CTIMEDshowHWPlayer::UnBlock()
{
    if(m_pProxy)
    {
        m_pProxy->UnBlock();
    }
}

bool
CTIMEDshowHWPlayer::CanCallThrough()
{
    if(m_pProxy)
    {
        return m_pProxy->CanCallThrough();
    }
    else
    {
        return false;
    }
}

bool
CTIMEDshowHWPlayer::FireProxyEvent(PLAYER_EVENT plEvent)
{
    bool fRet = false;
    CTIMEPlayerNative *pNativePlayer;

    if(m_pPlaybackSite == NULL)
    {
       goto done;
    }
    
    if(m_pProxy)
    {
        m_pProxy->FireMediaEvent(plEvent, NULL);
        fRet = true;
    }
    else if(m_pPlaybackSite && (pNativePlayer = m_pPlaybackSite->GetNativePlayer()) != NULL)
    {
        pNativePlayer->FireMediaEvent(plEvent, NULL);
        fRet = true;
    }

done:
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\playerimage.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1998-1999
//
//  File: src\time\media\playerimage.cpp
//
//  Contents: implementation of CTIMEImagePlayer and CAnimatedGif
//
//------------------------------------------------------------------------------------


#include "headers.h"
#include "playerimage.h"
#include "mediaelm.h"

#include "importman.h"

extern const long COLORKEY_NOT_SET = -1;

DeclareTag(tagImageTimePlayer, "TIME: Players", "CTIMEImagePlayer methods")

CTIMEImagePlayer::CTIMEImagePlayer() :
    m_cRef(0),
    m_nativeImageWidth(0),
    m_nativeImageHeight(0),
    m_lSrc(ATOM_TABLE_VALUE_UNITIALIZED),
    m_pTIMEMediaPlayerStream(NULL),
    m_fRemoved(false),
    m_lFrameNum(0),
    m_dblCurrentTime(0),
    m_dblPriority(INFINITE),
    m_fHavePriority(false),
    m_fLoadError(false)
{
    TraceTag((tagImageTimePlayer,
              "CTIMEImagePlayer(%lx)::CTIMEImagePlayer()",
              this));

    m_elemRect.top = m_elemRect.left = m_elemRect.right = m_elemRect.bottom = 0;

}

CTIMEImagePlayer::~CTIMEImagePlayer()
{
    TraceTag((tagImageTimePlayer,
              "CTIMEImagePlayer(%lx)::~CTIMEImagePlayer()",
              this));
    m_pTIMEElementBase = NULL;

    ReleaseInterface(m_pTIMEMediaPlayerStream);
}


STDMETHODIMP_(ULONG)
CTIMEImagePlayer::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
} // AddRef


STDMETHODIMP_(ULONG)
CTIMEImagePlayer::Release(void)
{
    LONG l = InterlockedDecrement(&m_cRef);

    if (0 == l)
    {
        delete this;
    }

    return l;
} // Release

STDMETHODIMP
CTIMEImagePlayer::QueryInterface(REFIID riid, void **ppv)
{
    if (NULL == ppv)
    {
        return E_POINTER;
    }

    *ppv = NULL;

    if ( IsEqualGUID(riid, IID_IUnknown) )
    {
        *ppv = static_cast<ITIMEImportMedia*>(this);
    }
    if ( IsEqualGUID(riid, IID_ITIMEImportMedia) )
    {
        *ppv = static_cast<ITIMEImportMedia*>(this);
    }

    if ( NULL != *ppv )
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }
    return E_NOINTERFACE;
}

HRESULT
CTIMEImagePlayer::Init(CTIMEMediaElement *pelem, LPOLESTR base, LPOLESTR src, LPOLESTR lpMimeType, double dblClipBegin, double dblClipEnd)
{
    TraceTag((tagImageTimePlayer,
              "CTIMEImagePlayer(%lx)::Init)",
              this));   
    HRESULT hr = S_OK;
    LPOLESTR szSrc = NULL;

    if (m_pTIMEElementBase != NULL) //this only happens in the case of reentrancy
    {
        hr = S_OK;
        goto done;
    }

    hr = CTIMEBasePlayer::Init(pelem, base, src, lpMimeType, dblClipBegin, dblClipEnd);
    if (FAILED(hr))
    {
        goto done;
    }
    
    m_pTIMEElementBase = pelem;

    hr = THR(CoMarshalInterThreadInterfaceInStream(IID_ITIMEImportMedia, static_cast<ITIMEImportMedia*>(this), &m_pTIMEMediaPlayerStream));
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(NULL != GetAtomTable());
    Assert(NULL != GetImportManager());
    Assert(NULL != m_pTIMEMediaPlayerStream);

    hr = THR(::TIMECombineURL(base, src, &szSrc));
    if (!szSrc)
    {
        hr = E_FAIL;
        goto done;
    }
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetAtomTable()->AddNameToAtomTable(szSrc, &m_lSrc);
    if (FAILED(hr))
    {
        goto done;
    }

    if( dblClipBegin != -1.0)
    {
        m_dblClipStart = dblClipBegin;
    }

    if( dblClipEnd != -1.0)
    {
        m_dblClipEnd = dblClipEnd;
    }

    // to prevent race condition, this should go 
    // after clipbegin and end have been set (105345)
    hr = GetImportManager()->Add(this);
    if (FAILED(hr))
    {
        goto done;
    }
      
    hr = S_OK;
done:
    delete[] szSrc;
    return hr;
}

HRESULT
CTIMEImagePlayer::DetachFromHostElement (void)
{
    HRESULT hr = S_OK;

    TraceTag((tagImageTimePlayer,
              "CTIMEImagePlayer(%lx)::DetachFromHostElement",
              this));

    m_fRemoved = true;

    // remove this from m_spMediaDownloader
    if (m_spMediaDownloader != NULL)
    {
        IGNORE_HR(m_spMediaDownloader->RemoveImportMedia(this));
    }

    m_spMediaDownloader.Release();

    m_spImageRender.Release();
    
    m_pTIMEElementBase = NULL;
    NullAtomTable();

    hr = S_OK;
done:
    return hr;
}

HRESULT
CTIMEImagePlayer::InitElementSize()
{
    HRESULT hr;
    RECT nativeSize, elementSize;
    bool fisNative;

    if (NULL == m_pTIMEElementBase)
    {
        hr = S_OK;
        goto done;
    }

    nativeSize.left = nativeSize.top = 0;
    nativeSize.right = m_nativeImageWidth;
    nativeSize.bottom = m_nativeImageHeight;

    hr = m_pTIMEElementBase->NegotiateSize( nativeSize, elementSize, fisNative);
    
    hr = S_OK;
done:
    return hr;
}


HRESULT 
CTIMEImagePlayer::GetNaturalHeight(long *height)
{
    if (m_nativeImageHeight == 0)
    {
        *height = -1;
    }
    else
    {
        *height = (long)m_nativeImageHeight;
    }
    
    return S_OK;
}

HRESULT 
CTIMEImagePlayer::GetNaturalWidth(long *width)
{
    if (m_nativeImageWidth == 0)
    {
        *width  = -1;
    }
    else
    {
        *width = (long)m_nativeImageWidth;
    }

    return S_OK;
}


HRESULT
CTIMEImagePlayer::SetSrc(LPOLESTR base, LPOLESTR src)
{
    HRESULT hr = S_OK;
    TraceTag((tagImageTimePlayer,
              "CTIMEImagePlayer(%lx)::SetSrc()\n",
              this));

    return hr;

}

STDMETHODIMP
CTIMEImagePlayer::CanBeCued(VARIANT_BOOL * pVB_CanCue)
{
    HRESULT hr = S_OK;

    if (NULL == pVB_CanCue)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    *pVB_CanCue = VARIANT_TRUE;
    
    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP
CTIMEImagePlayer::CueMedia()
{
    HRESULT hr = S_OK;

    TraceTag((tagImageTimePlayer, "CTIMEImagePlayer(%lx)::CueMedia()", this));

    CComPtr<ITIMEImportMedia> spTIMEMediaPlayer;

    hr = THR(CoGetInterfaceAndReleaseStream(m_pTIMEMediaPlayerStream, IID_TO_PPV(ITIMEImportMedia, &spTIMEMediaPlayer)));
    m_pTIMEMediaPlayerStream = NULL; // no need to release, the previous call released the reference
    if (FAILED(hr))
    {
        goto done;
    }

    // this call is marshalled back to a time thread
    hr = THR(spTIMEMediaPlayer->InitializeElementAfterDownload());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP
CTIMEImagePlayer::MediaDownloadError()
{
    m_fLoadError = true;
    return S_OK;
}

STDMETHODIMP
CTIMEImagePlayer::InitializeElementAfterDownload()
{
    TraceTag((tagImageTimePlayer,
              "CTIMEImagePlayer(%lx)::InitializeElementAfterDownload()",
              this));

    HRESULT hr = S_OK;

    double dblDuration = 0.0;  // in seconds
    double dblRepeatCount = 0;

    if (m_fLoadError == true)
    {        
        if (m_pTIMEElementBase != NULL)
        {
            m_pTIMEElementBase->FireMediaEvent(PE_ONMEDIAERROR);
        }
        hr = E_FAIL;
        goto done;
    }

    if (m_fRemoved)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = m_spImageRender->GetRepeatCount(&dblRepeatCount);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = m_spImageRender->GetDuration(&dblDuration);
    if (FAILED(hr))
    {
        goto done;
    }
        
    m_pTIMEElementBase->FireMediaEvent(PE_ONMEDIACOMPLETE);

    {
        dblDuration = dblDuration * (dblRepeatCount + 1); //the gif's use a 0-based repeat count, so need to add one for correct duration.
        
        if (valueNotSet != m_dblClipEnd)
        {
            dblDuration = m_dblClipEnd;
        }
        dblDuration -= GetClipBegin();

        m_pTIMEElementBase->GetMMBvr().PutNaturalDur(dblDuration);
        m_pTIMEElementBase->setNaturalDuration();                        
    }
    
    hr = m_spImageRender->GetSize(&m_nativeImageWidth, &m_nativeImageHeight);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = InitElementSize();
    if (FAILED(hr))
    {
        goto done;
    }

    m_pTIMEElementBase->InvalidateElement(NULL);

    hr = S_OK;
done:
    return hr;
}

void
CTIMEImagePlayer::OnTick(double dblSegmentTime,
                         LONG lCurrRepeatCount)
{
    TraceTag((tagImageTimePlayer,
              "CTIMEImagePlayer(%lx)::OnTick(%g, %d)",
              this,
              dblSegmentTime,
              lCurrRepeatCount));

    HRESULT hr = S_OK;
    VARIANT_BOOL vb = VARIANT_FALSE;

    bool bIsOn = m_pTIMEElementBase->IsOn();

    if (m_spImageRender != NULL && bIsOn)
    {
        m_dblCurrentTime = dblSegmentTime;
        
        hr = m_spImageRender->NeedNewFrame(m_dblCurrentTime, m_lFrameNum, &m_lFrameNum, &vb, GetClipBegin(), m_dblClipEnd);
        if (FAILED(hr))
        {
            goto done;
        }
        
        if (VARIANT_FALSE != vb)
        {
            m_pTIMEElementBase->InvalidateElement(NULL);
        }
    } 

    hr = S_OK;
done:
    return;    
}

void
CTIMEImagePlayer::Start()
{
    TraceTag((tagImageTimePlayer,
              "CTIMEDshowPlayer(%lx)::Start()",
              this));

    IGNORE_HR(Reset());

done:
    return;
}

void
CTIMEImagePlayer::InternalStart()
{
    TraceTag((tagImageTimePlayer,
              "CTIMEImagePlayer(%lx)::Start()",
              this));

    HRESULT hr = S_OK;

    hr = m_pTIMEElementBase->GetSize(&m_elemRect);
    if (FAILED(hr))
    {
        goto done;
    }    

    m_pTIMEElementBase->InvalidateElement(NULL);

done:
    return;
}

void
CTIMEImagePlayer::Stop()
{
    TraceTag((tagImageTimePlayer,
              "CTIMEImagePlayer(%lx)::Stop()",
              this));
}

void
CTIMEImagePlayer::Pause()
{
    TraceTag((tagImageTimePlayer,
              "CTIMEImagePlayer(%lx)::Pause()",
              this));
}

void
CTIMEImagePlayer::Resume()
{
    TraceTag((tagImageTimePlayer,
              "CTIMEImagePlayer(%lx)::Resume()",
              this));
}
    
void
CTIMEImagePlayer::Repeat()
{
    TraceTag((tagImageTimePlayer,
              "CTIMEImagePlayer(%lx)::Repeat()",
              this));
    Start();
}
    
HRESULT
CTIMEImagePlayer::Render(HDC hdc, LPRECT prc)
{
    HRESULT hr = S_OK;
    TraceTag((tagImageTimePlayer,
              "CTIMEImagePlayer(%lx)::Render()",
              this));
    bool bIsOn = m_pTIMEElementBase->IsOn();

    if (m_spImageRender != NULL && bIsOn)
    {
        hr = THR(m_spImageRender->Render(hdc, prc, m_lFrameNum));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done:
    return hr;
}


// Helper functions..

double 
CTIMEImagePlayer::GetCurrentTime()
{
    double dblCurrentTime = 0;
       
    return dblCurrentTime;
}

HRESULT
CTIMEImagePlayer::GetCurrentSyncTime(double & dblSyncTime)
{
    HRESULT hr;

    hr = S_FALSE;
  done:
    RRETURN1(hr, S_FALSE);
}

HRESULT
CTIMEImagePlayer::Seek(double dblTime)
{
    HRESULT hr = S_OK;

    return hr;
}

HRESULT
CTIMEImagePlayer::SetSize(RECT *prect)
{
    HRESULT hr = S_OK;

    m_elemRect.bottom = prect->bottom;
    m_elemRect.left = prect->left;
    m_elemRect.right = prect->right;
    m_elemRect.top = prect->top;

    m_pTIMEElementBase->InvalidateElement(NULL);

    return hr;
}

HRESULT
CTIMEImagePlayer::CanSeek(bool &fcanSeek)
{
    HRESULT hr = S_OK;

    fcanSeek = true;

    return hr;
}


HRESULT
CTIMEImagePlayer::GetMediaLength(double &dblLength)
{
    HRESULT hr = S_OK;
    double dblDuration = 0.0;
    double dblRepeatCount = 1;

    if (m_spImageRender)
    {
        hr = m_spImageRender->GetRepeatCount(&dblRepeatCount);
        if (FAILED(hr))
        {
            goto done;
        }

        hr = m_spImageRender->GetDuration(&dblDuration);
        if (FAILED(hr))
        {
            dblDuration = HUGE_VAL;
            goto done;
        }
    }
    
    
  done:

    dblLength = dblDuration;
    if (dblRepeatCount > 0.0 && dblLength != HUGE_VAL)
    {
        dblLength *= (dblRepeatCount + 1); //animate GIF's use a zero base repeat count.  Need to add one to get the correct duration
    }

    return S_OK;
}


STDMETHODIMP
CTIMEImagePlayer::GetUniqueID(long * plID)
{
    HRESULT hr = S_OK;

    if (NULL == plID)
    {
        hr = E_POINTER;
        goto done;
    }

    *plID = m_lSrc;

    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP
CTIMEImagePlayer::GetPriority(double * pdblPriority)
{
    HRESULT hr = S_OK;
    if (NULL == pdblPriority)
    {
        return E_POINTER;
    }

    if (m_fHavePriority)
    {
        *pdblPriority = m_dblPriority;
    }
    
    Assert(m_pTIMEElementBase != NULL);
    Assert(NULL != m_pTIMEElementBase->GetElement());

    *pdblPriority = INFINITE;

    CComVariant varAttribute;
    
    hr = m_pTIMEElementBase->base_get_begin(&varAttribute);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = VariantChangeType(&varAttribute, &varAttribute, 0, VT_R8);
    if (FAILED(hr))
    {
        if ( DISP_E_TYPEMISMATCH == hr)
        {
            hr = S_OK;
        }
        goto done;
    }
    
    // either they set a priority or a begin time!
    *pdblPriority = varAttribute.dblVal;

    m_dblPriority = *pdblPriority;
    m_fHavePriority = true;
    
    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP
CTIMEImagePlayer::GetMediaDownloader(ITIMEMediaDownloader ** ppMediaDownloader)
{
    HRESULT hr = S_OK;

    Assert(m_spMediaDownloader == NULL);

    CComPtr<IUnknown> spDirectDraw;
    CImageDownload * pImageDownload = NULL;

    if ( m_spMediaDownloader )
    {
        hr = E_FAIL;
        goto done;
    }

    pImageDownload = new CImageDownload(GetAtomTable());
    if (pImageDownload == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }   

    pImageDownload->AddRef();

    hr = pImageDownload->Init(m_lSrc);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pImageDownload->QueryInterface(IID_TO_PPV(ITIMEMediaDownloader, &m_spMediaDownloader));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = m_spMediaDownloader->QueryInterface(IID_TO_PPV(ITIMEImageRender, &m_spImageRender));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = m_pTIMEElementBase->GetServiceProvider()->QueryService(SID_SDirectDraw3, IID_TO_PPV(IUnknown, &spDirectDraw));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = m_spImageRender->PutDirectDraw(spDirectDraw);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = m_spMediaDownloader->AddImportMedia(this);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = m_spMediaDownloader->QueryInterface(IID_TO_PPV(ITIMEMediaDownloader, ppMediaDownloader));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    ReleaseInterface(pImageDownload);
    return hr;
}

STDMETHODIMP
CTIMEImagePlayer::PutMediaDownloader(ITIMEMediaDownloader * pMediaDownloader)
{
    HRESULT hr = S_OK;

    Assert(m_spMediaDownloader == NULL);
    if (NULL == pMediaDownloader)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    m_spMediaDownloader = pMediaDownloader;

    hr = m_spMediaDownloader->QueryInterface(IID_TO_PPV(ITIMEImageRender, &m_spImageRender));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}


void
CTIMEImagePlayer::PropChangeNotify(DWORD tePropType)
{
    double dblSegTime = 0.0;
    LONG lcurrRepCount = 0;

    CTIMEBasePlayer::PropChangeNotify(tePropType);

    if ((tePropType & TE_PROPERTY_TIME) != 0)
    {
        TraceTag((tagImageTimePlayer,
                  "CTIMEImagePlayer(%lx)::PropChangeNotify(%#x):TE_PROPERTY_TIME",
                  this));
        if (m_pTIMEElementBase)
        {
            dblSegTime = m_pTIMEElementBase->GetMMBvr().GetSimpleTime();
            lcurrRepCount = m_pTIMEElementBase->GetMMBvr().GetCurrentRepeatCount();
        }

        OnTick(dblSegTime, lcurrRepCount);
    }
done:
    return;
}


HRESULT
CTIMEImagePlayer::HasVisual(bool &bHasVisual)
{
    bHasVisual = true;
    return S_OK;
}

HRESULT
CTIMEImagePlayer::HasAudio(bool &bHasAudio)
{

    bHasAudio = false;

    return S_OK;
}

HRESULT
CTIMEImagePlayer::GetMimeType(BSTR *pmime)
{
    HRESULT hr = S_OK;

    *pmime = SysAllocString(L"image/unknown");
    return hr;
}


static const int ANIMATED_GIF_DUR_NOT_SET = -1;

//+-----------------------------------------------------------------------
//
//  Member:    CAnimatedGif
//
//  Overview:  Constructor
//
//  Arguments: void
//
//  Returns:   void
//
//------------------------------------------------------------------------
CAnimatedGif::CAnimatedGif() :
    m_cRef(0),
    m_ppDDSurfaces(NULL),
    m_phbmpMasks(NULL),
    m_numGifs(0),
    m_pDelays(NULL),
    m_loop(0),
    m_pColorKeys(NULL),
    m_dblTotalDur(ANIMATED_GIF_DUR_NOT_SET),
    m_lHeight(0),
    m_lWidth(0)
{
    ;
}

//+-----------------------------------------------------------------------
//
//  Member:    CAnimatedGif
//
//  Overview:  destructor
//
//  Arguments: void
//
//  Returns:   void
//
//------------------------------------------------------------------------
CAnimatedGif::~CAnimatedGif()
{
    Assert(0 == m_cRef);

    int i;
    
    if (NULL != m_ppDDSurfaces)
    {
        for (i = 0; i < m_numGifs; i++)
        {
            if (m_ppDDSurfaces[i] != NULL)
            {
                m_ppDDSurfaces[i]->Release();
            }
        }
    }

    if (NULL != m_ppDDSurfaces)
    {
        MemFree(m_ppDDSurfaces);
    }
    if (NULL != m_pDelays)
    {
        MemFree(m_pDelays);
    }
    if (NULL != m_pColorKeys)
    {
        MemFree(m_pColorKeys);
    }
    if (NULL != m_phbmpMasks)
    {
        for (i = 0; i < m_numGifs; i++)
        {
            if (NULL != m_phbmpMasks[i])
            {
                BOOL bSucceeded;
                bSucceeded = DeleteObject(m_phbmpMasks[i]);
                if (FALSE == bSucceeded)
                {
                    Assert(false && "A mask bitmap was still selected into a DC");
                }
            }
        }
        MemFree(m_phbmpMasks);
    }

}

HRESULT
CAnimatedGif::Init(IUnknown * punkDirectDraw)
{
    HRESULT hr = S_OK;

    hr = punkDirectDraw->QueryInterface(IID_TO_PPV(IDirectDraw3, &m_spDD3));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    AddRef
//
//  Overview:  Increment reference count
//
//  Arguments: void
//
//  Returns:   new reference count
//
//------------------------------------------------------------------------
ULONG
CAnimatedGif::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//+-----------------------------------------------------------------------
//
//  Member:    Release
//
//  Overview:  Decrement reference count, delete this when 0
//
//  Arguments: void
//
//  Returns:   new reference count
//
//------------------------------------------------------------------------
ULONG
CAnimatedGif::Release()
{
    ULONG l = InterlockedDecrement(&m_cRef);

    if (0 == l)
        delete this;

    return l;
}


//+-----------------------------------------------------------------------
//
//  Member:    NeedNewFrame
//
//  Overview:  Decide if a new frame is needed for this image at this time
//
//  Arguments: dblNewTime   time to decide if new frame is needed for
//             iOldFrame    old frame number
//             piNewFrame   where to store new frame number
//             dblClipBegin Clip start time
//             dblClipEnd   Clip end time
//
//  Returns:   true if new frame is needed, otherwise false
//
//------------------------------------------------------------------------
bool
CAnimatedGif::NeedNewFrame(double dblNewTime, LONG lOldFrame, LONG * plNewFrame, double dblClipBegin, double dblClipEnd)
{
    Assert(NULL != plNewFrame);
    if (HUGE_VAL == dblNewTime)
    {
        return false;
    }
    if (dblNewTime < 0)
    {
        return false;
    }

    *plNewFrame = lOldFrame;

    CalcDuration();

    dblNewTime *= 1000; // milliseconds used here
    
    Assert (0.0 != m_dblTotalDur);

    long lReps = static_cast<long>((dblNewTime - 1) / m_dblTotalDur);

    if (lReps >= 1)
    {
        dblNewTime -= lReps * m_dblTotalDur;
    }

    // add in any clip begin time
    dblNewTime += dblClipBegin * 1000;  //dblClipBegin is expressed in seconds

    if (dblNewTime > m_dblTotalDur)
    {
        // the addition of the clipBegin pushed us over the strip duration.
        dblNewTime -= m_dblTotalDur;
    }

    return CalculateFrame(dblNewTime, lOldFrame, plNewFrame);
}

//+-----------------------------------------------------------------------
//
//  Member:    CalculateFrame
//
//  Overview:  Walk the frame times to determine frame number
//
//  Arguments: dblNewTime   time to decide if new frame is needed for
//             iOldFrame    old frame number
//             piNewFrame   where to store new frame number
//
//  Returns:   true if new frame is needed, otherwise false
//
//------------------------------------------------------------------------
bool
CAnimatedGif::CalculateFrame(double dblTime, LONG lOldFrame, LONG * plNewFrame)
{
    LONG i = 0;
    if ((dblTime < 0.0) || (dblTime > m_dblTotalDur))
    {
        return false;
    }
    
    if (dblTime == m_dblTotalDur)
    {
        i = m_numGifs - 1;
        goto done;
    }
    
    while (dblTime >= 0)
    {
        dblTime -= m_pDelays[i];
        i++;
        Assert(i <= m_numGifs);
    }
    i--; // go back to the previous frame (the one we are currently in)

    Assert(i < m_numGifs);
    Assert(i >= 0);
    
    if (lOldFrame == i)
    {
        return false; // we are still on the current frame
    }
  done:
    *plNewFrame = i;
    return true;
}

//+-----------------------------------------------------------------------
//
//  Member:    CalcDuration
//
//  Overview:  Sum the array of delays into member variable first time
//             following times, just return member variable
//
//  Arguments: void
//
//  Returns:   total time for 1 repitition of gif in milliseconds
//
//------------------------------------------------------------------------
double
CAnimatedGif::CalcDuration()
{
    int i = 0;

    if (NULL == m_pDelays)
    {
        return INFINITE;
    }

    if (ANIMATED_GIF_DUR_NOT_SET == m_dblTotalDur)
    {
        m_dblTotalDur = 0;
        for (i = 0; i < m_numGifs; i++)
        {
            m_dblTotalDur += m_pDelays[i];
        }
    }
    return m_dblTotalDur;
}

//+-----------------------------------------------------------------------
//
//  Member:    Render
//
//  Overview:  Render the given frame of the image
//
//  Arguments: hdc  where to render too
//             prc  bounding rectangle
//             lFrameNum    Which frame to render
//
//  Returns:   S_OK on Success, otherwise error code
//             S_FALSE if surfaces should be recreated
//
//------------------------------------------------------------------------
HRESULT
CAnimatedGif::Render(HDC hdc, LPRECT prc, LONG lFrameNum)
{
    HRESULT hr = S_OK;
    HDC hdcSrc;
    
    if (lFrameNum < 0 || lFrameNum >= m_numGifs)
    {
        hr = E_INVALIDARG;
        goto done;
    }
    if (NULL == prc)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    if (NULL == m_phbmpMasks)
    {
        hr = CreateMasks();
        if (FAILED(hr))
        {
            goto done;
        }
    }

    Assert(m_ppDDSurfaces);
    Assert(m_phbmpMasks);

    hr = THR(m_ppDDSurfaces[lFrameNum]->GetDC(&hdcSrc));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(MaskTransparentBlt(hdc, prc, hdcSrc, m_lWidth, m_lHeight, m_phbmpMasks[lFrameNum]));

    IGNORE_HR(m_ppDDSurfaces[lFrameNum]->ReleaseDC(hdcSrc));

    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
done:
    RRETURN(hr);
}

HRESULT
CAnimatedGif::CreateMasks()
{
    HRESULT hr = E_FAIL;

    int i = 0;
    HDC hdcSrc = NULL;

    Assert(NULL != m_pColorKeys);
    Assert(0 < m_numGifs);

    if (m_phbmpMasks)
    {
        hr = S_OK;
        goto done;
    }

    Assert(NULL == m_phbmpMasks);

    m_phbmpMasks = (HBITMAP*)MemAllocClear(Mt(Mem), m_numGifs * sizeof(HBITMAP));
    if (NULL == m_phbmpMasks)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    for (i = 0; i < m_numGifs; i++)
    {
        hr = THR(m_ppDDSurfaces[i]->GetDC(&hdcSrc));
        if (FAILED(hr))
        {
            goto done;
        }
        
        hr = CreateMask(NULL, hdcSrc, m_lWidth, m_lHeight, m_pColorKeys[i], &(m_phbmpMasks[i]));
        
        IGNORE_HR(m_ppDDSurfaces[i]->ReleaseDC(hdcSrc));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done:
    return hr;
}

HRESULT
CreateMask(HDC hdcDest, 
           HDC hdcSrc, 
           LONG lWidthSrc, 
           LONG lHeightSrc, 
           COLORREF rgbTransparent,
           HBITMAP * phbmpMask,
           bool bWin95Method /* = false */)
{
    HRESULT hr = S_OK;
    
    HDC hdcMask = NULL;
    HBITMAP hbmpMask = NULL;
    HGDIOBJ hbmpOrig = NULL;
    COLORREF prevBkColorSrc = CLR_INVALID;
    
    if (NULL == phbmpMask || NULL == hdcSrc)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    *phbmpMask = NULL;
    
    if (COLORKEY_NOT_SET == rgbTransparent)
    {
        hr = S_OK;
        goto done;
    }

    prevBkColorSrc = SetBkColor(hdcSrc, rgbTransparent);
    if (CLR_INVALID == prevBkColorSrc)
    {
        hr = E_FAIL;
        goto done;
    }
    
    // create the DC for the mask
    hdcMask = CreateCompatibleDC(hdcDest);
    if (NULL == hdcMask)
    {
        hr = E_FAIL;
        goto done;
    }
    hbmpMask = CreateCompatibleBitmap(hdcMask, lWidthSrc, lHeightSrc);
    if (NULL == hbmpMask)
    {
        hr = E_FAIL;
        goto done;
    }

    hbmpOrig = SelectObject(hdcMask, hbmpMask);

    if (TIMEIsWin95() || bWin95Method)
    {
        COLORREF rgbWhite = RGB(255, 255, 255);
        COLORREF rgbBlack = RGB(0, 0, 0);
        COLORREF rgbColor;

        for (int j = 0; j < lHeightSrc; j++)
        {
            for (int i = 0; i < lWidthSrc; i++)
            {
                rgbColor = GetPixel(hdcSrc, i, j);
                if (rgbColor == rgbTransparent)
                {
                    SetPixel(hdcMask, i, j, rgbWhite);
                }
                else
                {
                    SetPixel(hdcMask, i, j, rgbBlack);
                }
            }
        }
    }
    else
    {
        // Create the mask
        BitBlt(hdcMask, 0, 0, lWidthSrc, lHeightSrc, hdcSrc, 0, 0, SRCCOPY);
    }

#ifdef NEVER
    // jeffwall 04/03/00 debugging blt to screen
    {
        HDC nullDC = GetDC(NULL);

        BitBlt(nullDC, 0, 0, lWidthSrc, lHeightSrc, hdcMask, 0, 0, SRCCOPY);

        DeleteDC(nullDC);
    }
#endif

    hr = S_OK;
done:
    if (CLR_INVALID != prevBkColorSrc)
        SetBkColor(hdcSrc, prevBkColorSrc);

    if (hbmpOrig)
        SelectObject(hdcMask, hbmpOrig);
    if (hdcMask)
        DeleteDC(hdcMask);

    if (S_OK == hr && phbmpMask)
        *phbmpMask = hbmpMask;
    else if (NULL != hbmpMask)
        DeleteObject(hbmpMask);
        
    RRETURN(hr);
}
           
                          
HRESULT
MaskTransparentBlt(HDC hdcDest, 
                   LPRECT prcDest, 
                   HDC hdcSrc, 
                   LONG lWidthSrc, 
                   LONG lHeightSrc,
                   HBITMAP hbmpMask)
{
    HRESULT hr = S_OK;

    HDC hdcMask = NULL;
    HGDIOBJ hbmpOrig = NULL;

    COLORREF prevBkColorDest = CLR_INVALID;
    COLORREF prevTextColorDest = CLR_INVALID;

    int iOrigBltMode = 0;

    int top, left, width, height;

    if (NULL == prcDest || NULL == hdcDest || NULL == hdcSrc)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    top = prcDest->top;
    left = prcDest->left;
    width = prcDest->right - prcDest->left;
    height = prcDest->bottom - prcDest->top;
    
    iOrigBltMode = SetStretchBltMode(hdcDest, COLORONCOLOR);
    if (0 == iOrigBltMode)
    {
        hr = E_FAIL;
        goto done;
    }

    if (NULL == hbmpMask)
    {
        StretchBlt(hdcDest, left, top, width, height,
                   hdcSrc, 0, 0, lWidthSrc, lHeightSrc, SRCCOPY);
        hr = S_OK;
        goto done;
    }
    
    prevBkColorDest = SetBkColor(hdcDest, RGB(255, 255, 255));
    if (CLR_INVALID == prevBkColorDest)
    {
        hr = E_FAIL;
        goto done;
    }
    prevTextColorDest = SetTextColor(hdcDest, RGB(0, 0, 0));
    if (CLR_INVALID == prevTextColorDest)
    {
        hr = E_FAIL;
        goto done;
    }

    // create the DC for the mask
    hdcMask = CreateCompatibleDC(hdcDest);
    if (NULL == hdcMask)
    {
        hr = E_FAIL;
        goto done;
    }

    hbmpOrig = SelectObject(hdcMask, hbmpMask);
    if (NULL == hbmpOrig)
    {
        hr = E_FAIL;
        goto done;
    }

#ifdef NEVER
    // jeffwall 03/20/00 - debugging blt to screen
    {
        HDC nullDC = GetDC(NULL);
        
        // transparentblt to the screen
        BitBlt(nullDC, 0, 0, lWidthSrc, lHeightSrc,
               hdcSrc, 0, 0, SRCINVERT);
        
        BitBlt(nullDC, 0, 0, lWidthSrc, lHeightSrc,
               hdcMask, 0, 0, SRCAND);
        
        BitBlt(nullDC, 0, 0, lWidthSrc, lHeightSrc,
               hdcSrc, 0, 0, SRCINVERT);
    
        DeleteDC(nullDC);
    }
#endif

    StretchBlt(hdcDest, left, top, width, height,
               hdcSrc, 0, 0, lWidthSrc, lHeightSrc, SRCINVERT);

    StretchBlt(hdcDest, left, top, width, height,
               hdcMask, 0, 0, lWidthSrc, lHeightSrc, SRCAND);

    StretchBlt(hdcDest, left, top, width, height,
               hdcSrc, 0, 0, lWidthSrc, lHeightSrc, SRCINVERT);

    hr = S_OK;
done:
    if (hbmpOrig)
    {
        SelectObject(hdcMask, hbmpOrig);
    }
    if (hdcMask)
    {
        DeleteDC(hdcMask);
    }

    if (CLR_INVALID != prevBkColorDest)
    {
        SetBkColor(hdcDest, prevBkColorDest);
    }
    if (CLR_INVALID != prevTextColorDest)
    {
        SetTextColor(hdcDest, prevTextColorDest);
    }

    if (0 != iOrigBltMode)
    {
        SetStretchBltMode(hdcDest, iOrigBltMode);
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\playerimage.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: player.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/
#pragma once

#ifndef _PLAYERIMAGE_H
#define _PLAYERIMAGE_H

#include "playerbase.h"
#include "mstimep.h"

class CAnimatedGif;

#include "imagedownload.h"

#include "ddrawex.h"

/////////////////////////////////////////////////////////////////////////////
// CAnimatedGif
class CAnimatedGif
{
  public:
    CAnimatedGif();
    virtual ~CAnimatedGif();
    
    HRESULT Init(IUnknown * punkDirectDraw);

    ULONG AddRef();
    ULONG Release();

    HRESULT     Render(HDC hdc, LPRECT prc, LONG lFrameNum);

    bool        NeedNewFrame(double dblCurrentTime, LONG lOldFrame, LONG * plNewFrame, double dblClipBegin, double dblClipEnd);

    IDirectDrawSurface **  GetDDSurfaces() { return m_ppDDSurfaces; }
    void        PutDDSurfaces(IDirectDrawSurface ** ppDDSurfaces) { Assert(NULL == m_ppDDSurfaces); if (NULL != m_ppDDSurfaces) return; m_ppDDSurfaces = ppDDSurfaces; }    
    
    int         GetNumGifs() { return m_numGifs; }
    void        PutNumGifs(int numGifs) { Assert(0 == m_numGifs); if (0 != m_numGifs) return; m_numGifs = numGifs; }
    
    int      *  GetDelays() { return m_pDelays; }
    void        PutDelays(int * pDelays) { Assert(NULL == m_pDelays); if (NULL != m_pDelays) return; m_pDelays = pDelays; }

    double      GetLoop() { return m_loop; }
    void        PutLoop(double loop) { Assert(0 == m_loop); if (0 != m_loop) return; m_loop = loop; }

    void        PutWidth(LONG lWidth) { m_lWidth = lWidth; }
    void        PutHeight(LONG lHeight) { m_lHeight = lHeight; }

    double      CalcDuration();

    void        PutColorKeys(COLORREF * pColorKeys) { Assert(0 == m_pColorKeys); if (0 != m_pColorKeys) return; m_pColorKeys = pColorKeys; }
    COLORREF *  GetColorKeys() { return m_pColorKeys; }    

    HRESULT     CreateMasks();

  protected:
    bool        ClippedNeedNewFrame(double dblCurrentTime, LONG lOldFrame, LONG * plNewFrame, double dblClipBegin, double dblClipEnd);
    bool        CalculateFrame(double dblTime, LONG lOldFrame, LONG * plNewFrame);
    
  private:
    IDirectDrawSurface ** m_ppDDSurfaces;

    HBITMAP     *m_phbmpMasks;

    COLORREF    *m_pColorKeys;
    int          m_numGifs;
    int         *m_pDelays;
    double       m_loop;

    LONG         m_lHeight;
    LONG         m_lWidth;

    CComPtr<IDirectDraw3> m_spDD3;
    double       m_dblTotalDur;

    LONG m_cRef;
};

/////////////////////////////////////////////////////////////////////////////
// CTIMEImagePlayer

class CTIMEImagePlayer :
    public CTIMEBasePlayer,
    public ITIMEImportMedia
{
  public:
    CTIMEImagePlayer();
    ~CTIMEImagePlayer();
  public:

    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);
    STDMETHOD (QueryInterface)(REFIID refiid, void** ppunk);

    HRESULT Init(CTIMEMediaElement *pelem, LPOLESTR base, LPOLESTR src, LPOLESTR lpMimeType, double dblClipBegin = -1.0, double dblClipEnd = -1.0); //lint !e1735
    HRESULT DetachFromHostElement(void);
    HRESULT InitElementSize();
    
    virtual void OnTick(double dblSegmentTime,
                        LONG lCurrRepeatCount);

    void Start();
    void Stop();
    void Pause();
    void Resume();
    void Repeat();

    virtual void PropChangeNotify(DWORD tePropType);

    
    HRESULT Render(HDC hdc, LPRECT prc);

    HRESULT SetSrc(LPOLESTR base, LPOLESTR src);

    HRESULT SetSize(RECT *prect);

    double GetCurrentTime();
    HRESULT GetCurrentSyncTime(double & dblSyncTime);
    HRESULT Seek(double dblTime);
    HRESULT GetMediaLength(double &dblLength);
    HRESULT CanSeek(bool &fcanSeek);
    HRESULT HasVisual(bool &fHasVideo);
    HRESULT HasAudio(bool &fHasAudio);
    HRESULT GetNaturalHeight(long *height);
    HRESULT GetNaturalWidth(long *width);
    HRESULT GetMimeType(BSTR *pMime);

    //
    // ITIMEImportMedia methods
    //
    STDMETHOD(CueMedia)();
    STDMETHOD(GetPriority)(double *);
    STDMETHOD(GetUniqueID)(long *);
    STDMETHOD(InitializeElementAfterDownload)();
    STDMETHOD(GetMediaDownloader)(ITIMEMediaDownloader ** ppMediaDownloader);
    STDMETHOD(PutMediaDownloader)(ITIMEMediaDownloader * pMediaDownloader);
    STDMETHOD(CanBeCued)(VARIANT_BOOL * pVB_CanCue);
    STDMETHOD(MediaDownloadError)();

  protected:
    void InternalStart();

    
  private:

    DWORD                       m_nativeImageWidth;
    DWORD                       m_nativeImageHeight;

    long                        m_lSrc;

    CComPtr<ITIMEMediaDownloader>   m_spMediaDownloader;
    CComPtr<ITIMEImageRender>   m_spImageRender;
    LPSTREAM                    m_pTIMEMediaPlayerStream;

    RECT                        m_elemRect;
    double                      m_dblCurrentTime;

    bool                        m_fRemoved;
    LONG                        m_lFrameNum;
    bool                        m_fLoadError;

    bool m_fHavePriority;
    double m_dblPriority;
    LONG m_cRef;
};


#endif /* _PLAYERIMAGE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\playerdvd.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: player.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _PLAYERDVD_H
#define _PLAYERDVD_H

#include "playerdshowbase.h"
#include "mixerocx.h"
#include <strmif.h>
#include <control.h>
#include <inc\qnetwork.h>



#define WM_DVDGRAPHNOTIFY (WM_USER + 1)

/////////////////////////////////////////////////////////////////////////////
// CTTIMEPlayer

class
__declspec(uuid("efbad7f8-3f94-11d2-b948-00c04fa32195")) 
CTIMEDVDPlayer :
    public CTIMEDshowBasePlayer,
    public ITIMEDispatchImpl<ITIMEDVDPlayerObject, &IID_ITIMEDVDPlayerObject>

{
  public:
    CTIMEDVDPlayer();
    virtual ~CTIMEDVDPlayer();

    HRESULT Init(CTIMEMediaElement *pelem, LPOLESTR base, LPOLESTR src, LPOLESTR lpMimeType, double dblClipBegin = -1.0, double dblClipEnd = -1.0); //lint !e1735
  protected:
    HRESULT InitDshow();
    HRESULT InitElementSize();
    HRESULT InitElementDuration();
    void DeinitDshow();
    HRESULT BuildGraph();
    HRESULT GetSpecificInterfaces();
    void ReleaseSpecificInterfaces();
    void FreeSpecificData();

    virtual void Block();
    virtual void UnBlock();
    virtual bool CanCallThrough();
    virtual bool FireProxyEvent(PLAYER_EVENT plEvent);

  public:
    HRESULT DetachFromHostElement (void);

    // IUnknown Methods
    STDMETHOD (QueryInterface)(REFIID refiid, void** ppunk)
        {   return _InternalQueryInterface(refiid, ppunk); };
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);

    HRESULT GetExternalPlayerDispatch(IDispatch **ppDisp);


    STDMETHOD(upperButtonSelect)();
    STDMETHOD(lowerButtonSelect)();
    STDMETHOD(leftButtonSelect)();
    STDMETHOD(rightButtonSelect)();
    STDMETHOD(buttonActivate)();
    STDMETHOD(gotoMenu)();

    
    virtual void OnTick(double dblSegmentTime,
                        LONG lCurrRepeatCount);
    void SetCLSID(REFCLSID clsid);


    HRESULT Render(HDC hdc, LPRECT prc);
    HRESULT Reset();
    virtual void Tick();

    HRESULT SetSrc(LPOLESTR base, LPOLESTR src);

    HRESULT SetSize(RECT *prect);

    double GetChapterTime();
    HRESULT GetMediaLength(double &dblLength);
    HRESULT CanSeek(bool &fcanSeek);
    virtual HRESULT HasMedia(bool &fHasMedia);
    virtual HRESULT HasVisual(bool &fHasVideo);
    virtual HRESULT HasAudio(bool &fHasAudio);

    virtual HRESULT GetAuthor(BSTR *pAuthor);
    virtual HRESULT GetTitle(BSTR *pTitle);
    virtual HRESULT GetCopyright(BSTR *pCopyright);

    virtual HRESULT GetVolume(float *pflVolume);
    virtual HRESULT SetVolume(float flVolume);
#ifdef NEVER //dorinung 03-16-2000 bug 106458
    virtual HRESULT GetBalance(float *pflBalance);
    virtual HRESULT SetBalance(float flBalance);
#endif
    virtual HRESULT GetMute(VARIANT_BOOL *pvarMute);
    virtual HRESULT SetMute(VARIANT_BOOL varMute);

    HRESULT GetNaturalHeight(long *height);
    HRESULT GetNaturalWidth(long *width);
    virtual HRESULT GetMimeType(BSTR *pMime);

    virtual HRESULT CueMedia() { return E_NOTIMPL; }

    BEGIN_COM_MAP(CTIMEDVDPlayer)
        COM_INTERFACE_ENTRY(ITIMEDVDPlayerObject)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_CHAIN(CTIMEDshowBasePlayer)
    END_COM_MAP_X();


  private:
    HRESULT SetUpDDraw();
    HRESULT SetUpWindow();
    HRESULT SetUpMainWindow();
    HRESULT SetUpVideoOffsets();
    void PropagateOffsets();

    void GraphStart(void);

    //dvd specific graph interfaces
    CComPtr<IDvdInfo> m_pDvdI;
    CComPtr<IDvdControl> m_pDvdC;
    CComPtr<IDvdGraphBuilder> m_pDvdGB;
    CComPtr<IDDrawExclModeVideo> m_pDDEX;

    CComPtr<IVideoWindow> m_pVW;
    HWND m_hWnd;
    LPDIRECTDRAW m_pDD; // ddraw object
    LPDIRECTDRAWSURFACE m_pDDS; // primary ddraw surface
    COLORREF m_clrKey;     // color key

    static LONG m_fDVDPlayer;

    RECT m_elementSize;
    long m_lPixelPosLeft;
    long m_lPixelPosTop;
    bool m_fHasVideo;
    bool m_fLoaded;
    double m_dblSeekAtStart;
    bool m_fAudioMute;
    float m_flVolumeSave;

    DWORD m_nativeVideoWidth;
    DWORD m_nativeVideoHeight;
    long m_lscrollOffsetx;
    long m_lscrollOffsety;
    RECT m_deskRect;
};

#endif /* _PLAYERDSHOW_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\playerhwdshow.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: player.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _PLAYERHWDSHOW_H
#define _PLAYERHWDSHOW_H

#include "playerdshowbase.h"
#include "mixerocx.h"
#include <strmif.h>
#include <control.h>
#include <inc\qnetwork.h>
#include "hwproxy.h"

#include "importman.h"

#define MP_INFINITY -1

/////////////////////////////////////////////////////////////////////////////
// CTTIMEPlayer

class CTIMEDshowHWPlayer :
    public CTIMEDshowBasePlayer,
    public ITIMEImportMedia,
    public ITIMEInternalEventSink
{
  public:
    CTIMEDshowHWPlayer(CTIMEDshowHWPlayerProxy * pProxy);
    virtual ~CTIMEDshowHWPlayer();

    HRESULT Init(CTIMEMediaElement *pelem, LPOLESTR base, LPOLESTR src, LPOLESTR lpMimeType = NULL, double dblClipBegin = -1.0, double dblClipEnd = -1.0);//lint !e1735

  protected:
    HRESULT InitDshow();
    HRESULT InitElementSize();
    void DeinitDshow();
    HRESULT BuildGraph();
    HRESULT GetSpecificInterfaces();
    void ReleaseSpecificInterfaces();
    void FreeSpecificData();
    HRESULT BeginDownload();
    HRESULT GraphFinish();

    HRESULT ReadContentProperty(IGraphBuilder *pGraph, LPCWSTR lpcwstrTag, BSTR *pbstr);

    virtual void Block();
    virtual void UnBlock();
    virtual bool CanCallThrough();
    virtual bool FireProxyEvent(PLAYER_EVENT plEvent);

  public:
    HRESULT DetachFromHostElement (void);

    // IUnknown Methods
    STDMETHOD (QueryInterface)(REFIID refiid, void** ppunk)
        {   return _InternalQueryInterface(refiid, ppunk); };
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);
    
    virtual void OnTick(double dblSegmentTime,
                        LONG lCurrRepeatCount);
    void SetCLSID(REFCLSID clsid);

    HRESULT Reset();
    virtual void Tick();
    HRESULT Render(HDC hdc, LPRECT prc);

    HRESULT SetSrc(LPOLESTR base, LPOLESTR src);

    HRESULT SetSize(RECT *prect);

    HRESULT GetMediaLength(double &dblLength);
    HRESULT CanSeek(bool &fcanSeek);
    virtual PlayerState GetState();
    virtual HRESULT CanSeekToMarkers(bool &bacnSeekToM);
    virtual HRESULT IsBroadcast(bool &bisBroad);
    virtual HRESULT SetRate(double dblRate);
    virtual HRESULT GetRate(double &dblRate);
    virtual HRESULT HasMedia(bool &fHasMedia);
    virtual HRESULT HasVisual(bool &fHasVideo);
    virtual HRESULT HasAudio(bool &fHasAudio);

    HRESULT GetNaturalHeight(long *height);
    HRESULT GetNaturalWidth(long *width);

    virtual HRESULT GetAuthor(BSTR *pAuthor);
    virtual HRESULT GetTitle(BSTR *pTitle);
    virtual HRESULT GetCopyright(BSTR *pCopyright);
    virtual HRESULT GetAbstract(BSTR *pAbstract);
    virtual HRESULT GetRating(BSTR *pAbstract);

    virtual HRESULT GetIsStreamed(bool &fIsStreamed);
    virtual HRESULT GetBufferingProgress(double &dblBufferingProgress);
    virtual HRESULT GetHasDownloadProgress(bool &fHasDownloadProgress);

    BEGIN_COM_MAP(CTIMEDshowHWPlayer)
        COM_INTERFACE_ENTRY(ITIMEImportMedia)
        COM_INTERFACE_ENTRY_CHAIN(CTIMEDshowBasePlayer)
    END_COM_MAP_X();

    //
    // ITIMEImportMedia methods
    //
    STDMETHOD(CueMedia)();
    STDMETHOD(GetPriority)(double *);
    STDMETHOD(GetUniqueID)(long *);
    STDMETHOD(InitializeElementAfterDownload)();
    STDMETHOD(GetMediaDownloader)(ITIMEMediaDownloader ** ppImportMedia);
    STDMETHOD(PutMediaDownloader)(ITIMEMediaDownloader * pImportMedia);
    STDMETHOD(CanBeCued)(VARIANT_BOOL * pVB_CanCue);
    STDMETHOD(MediaDownloadError)();

    //
    // ITIMEInternalEventSink
    //
    STDMETHOD(InternalEvent)();

  protected:
    HRESULT SetUpMainWindow();
    HRESULT SetUpDDraw(IMixerOCX *pIMixerOCX); 
    HRESULT SetUpVideoOffsets();
    void PropagateOffsets();
  protected:
    long    m_lSrc;
    bool m_fHasVideo;
    bool m_fDoneSetup;
    double m_dblSeekAtStart;
    bool m_fLoadError;
    bool m_fHasMedia;
    bool m_fRemoved;

  private:

    CTIMEDshowHWPlayer();
    
    HRESULT SetMixerSize(RECT *prect);
    HRESULT SetUpHdc();

    void GraphStart(void);

    bool IsOvMConnected(IBaseFilter *pOvM);

    void SetStreamFlags(LPOLESTR src);
    HRESULT DisableAudioVideo();

    bool m_bIsHTMLSrc;
    bool m_bIsSAMISrc;

    CComPtr<IMixerOCX> m_pIMixerOCX;
    DWORD m_nativeVideoWidth;
    DWORD m_nativeVideoHeight;
    DWORD m_displayVideoWidth;
    DWORD m_displayVideoHeight;

    LPSTREAM                    m_pTIMEMediaPlayerStream;

    bool m_fUsingInterfaces;
    bool m_fNeedToDeleteInterfaces;

    bool m_fCanCueNow;
    
    bool m_fHavePriority;
    double m_dblPriority;

    CComPtr<IDDrawExclModeVideo> m_pDDEX;

    HWND m_hWnd;
    LPDIRECTDRAW m_pDD; // ddraw object
    LPDIRECTDRAWSURFACE m_pDDS; // primary ddraw surface
    LPDIRECTDRAWCLIPPER m_pClipper; // clipper for our ddraw object
    COLORREF m_clrKey;     // color key

    RECT m_elementSize;
    long m_lPixelPosLeft;
    long m_lPixelPosTop;
    long m_lscrollOffsetx;
    long m_lscrollOffsety;
    RECT m_deskRect;

    HRESULT m_hrRenderFileReturn;
    
    CTIMEDshowHWPlayerProxy * m_pProxy;
    CritSect                m_CriticalSection;

};

#endif /* _PLAYERDSHOW_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\playermc.cpp ===
//+-----------------------------------------------------------------------
//
//  Microsoft
//  Copyright (C) Microsoft Corporation, 1999
//
//  File:      src\time\src\playermc.cpp
//
//  Contents:  The music center player.
//
//------------------------------------------------------------------------
#include "headers.h"
#include "playermc.h"
#include "externuuids.h"
#include "mediaelm.h"
#include "playlist.h"

///// uncomment-out this line to turn on Debug spew for this player
//DeclareTag(tagMCPlayer, "Debug", "General debug output");   //lint !e19
DeclareTag(tagMCPlayer, "TIME: Players", "Music Center player");      //lint !e19

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::~CTIMEMCPlayer
//
//  Overview:  destructor
//
//  Arguments: none
//
//  Returns:   
//
//------------------------------------------------------------------------
CTIMEMCPlayer::~CTIMEMCPlayer()
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::~CTIMEMCPlayer"));
    // These should have been NULL'd in DetachFromHostElement.  If they were not, something 
    // went wrong above us.
    Assert(NULL == m_pcTIMEElem);
    Assert(NULL == m_spMCManager.p);
    Assert(NULL == m_spMCPlayer.p);
    m_pcTIMEElem = NULL;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::CTIMEMCPlayer
//
//  Overview:  constructor
//
//  Arguments: pTIMEElem    pointer to our TIME element
//
//  Returns:   
//
//------------------------------------------------------------------------
CTIMEMCPlayer::CTIMEMCPlayer() :
    m_cRef(0),
    m_spMCManager(),
    m_spMCPlayer(),
    m_fInitialized(false),
    m_dblLocalTime(0.0),
    m_pcTIMEElem(NULL)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::CTIMEMCPlayer"));
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::GetExternalPlayerDispatch, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: ppDisp
//
//  Returns:   
//
//------------------------------------------------------------------------
HRESULT 
CTIMEMCPlayer::GetExternalPlayerDispatch(IDispatch** ppDisp)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::GetExternalPlayerDispatch"));
    
    HRESULT hr = E_POINTER;

    //
    // TODO: add disp interface for access to extra properties/methods
    //

    if (!IsBadWritePtr(ppDisp, sizeof(IDispatch*)))
    {
        *ppDisp = NULL;
        hr      = E_FAIL;
    }

done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::AddRef, IUnknown
//
//  Overview:  standard non-thread-safe AddRef
//
//  Arguments: 
//
//  Returns:   
//
//------------------------------------------------------------------------
ULONG STDMETHODCALLTYPE 
CTIMEMCPlayer::AddRef(void)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::AddRef"));
    return ++m_cRef;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::Release, IUnknown
//
//  Overview:  standard non-thread-safe Release
//
//  Arguments: 
//
//  Returns:   
//
//------------------------------------------------------------------------
ULONG STDMETHODCALLTYPE 
CTIMEMCPlayer::Release(void)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::Release"));

    Assert(m_cRef > 0);  // very rare case

    if (0 != --m_cRef)
    {
        return m_cRef;
    }

    TraceTag((tagMCPlayer, "CTIMEMCPlayer::Release --> deleting object"));
    delete this;
    return 0;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::QueryInterface, IUnknown
//
//  Overview:  
//
//  Arguments: refiid   IID of requested interface
//             ppunk    out param for resulting interface pointer
//
//  Returns:   
//
//------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE 
CTIMEMCPlayer::QueryInterface(REFIID refiid, void** ppv)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::QueryInterface"));
    if ( NULL == ppv )
    {
        Assert(false);
        return E_POINTER;
    }

    if (IsEqualIID(refiid, IID_IUnknown))
    {
        // SAFECAST macro doesn't work with IUnknown
        *ppv = this;
        return S_OK;
    }
    *ppv = NULL;
    return E_NOINTERFACE;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::Init, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: 
//
//  Returns:   
//
//------------------------------------------------------------------------
HRESULT 
CTIMEMCPlayer::Init(CTIMEMediaElement *pelem, LPOLESTR base, LPOLESTR src, LPOLESTR lpMimeType, double dblClipBegin, double dblClipEnd)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::Init"));
    HRESULT hr = E_FAIL;

    if (m_fInitialized)
    {
        hr = S_OK;
        goto done;
    }

    m_pcTIMEElem = pelem;

    hr = THR(CoCreateInstance(CLSID_MCMANAGER, NULL, CLSCTX_INPROC_SERVER, IID_IMCManager, 
            reinterpret_cast<void**>(&m_spMCManager)));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(CoCreateInstance(CLSID_DLXPLAY, NULL, CLSCTX_INPROC_SERVER, IID_IDLXPLAY,
            reinterpret_cast<void**>(&m_spMCPlayer)));

    if (FAILED(hr))
    {
        m_spMCManager = NULL;
        goto done;
    }

    hr = THR(m_spMCPlayer->Initialize(m_spMCManager, static_cast<IDLXPlayEventSink*>(this)));
    if (FAILED(hr))
    {
        m_spMCPlayer  = NULL;
        m_spMCManager = NULL;
        goto done;
    }

    m_fInitialized = true;

    // The media is always ready.
    if (NULL != m_pcTIMEElem)
    {
        m_pcTIMEElem->FireMediaEvent(PE_ONMEDIACOMPLETE);
    }

    if( dblClipBegin != -1.0)
    {
        m_dblClipStart = dblClipBegin;
    }

    if( dblClipEnd != -1.0)
    {
        m_dblClipEnd = dblClipEnd;
    }

    hr = S_OK;

done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::DetachFromHostElement, CTIMEBasePlayer
//
//  Overview:  called when detaching our behavior from the DOM
//
//  Arguments: 
//
//  Returns:   
//
//------------------------------------------------------------------------
HRESULT 
CTIMEMCPlayer::DetachFromHostElement(void)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::DetachFromHostElement()"));
    HRESULT hr = S_OK;

    m_fInitialized  = false;
    m_spMCManager   = NULL;
    m_spMCPlayer    = NULL;

    // The reference back to the element is a weak one.
    m_pcTIMEElem = NULL;

done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::OnTick, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: dblSegmentTime
//             lCurrRepeatCount
//
//  Returns:   
//
//------------------------------------------------------------------------
void
CTIMEMCPlayer::OnTick(double dblSegmentTime,
                      LONG lCurrRepeatCount)
{
    TraceTag((tagMCPlayer,
              "CTIMEMCPlayer(%lx)::OnTick(%g, %d)",
              this,
              dblSegmentTime,
              lCurrRepeatCount));
    //
    // cache dbllastTime for return in GetCurrentTime
    //

    m_dblLocalTime = dblSegmentTime;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::OnSync, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: dbllastTime
//             dblnewTime
//
//  Returns:   
//
//------------------------------------------------------------------------
#ifdef NEW_TIMING_ENGINE
void 
CTIMEMCPlayer::OnSync(double dbllastTime, double& dblnewTime)
{
    // we don't really want to know every time OnSync is called
//    TraceTag((tagMCPlayer, "CTIMEMCPlayer::OnSync"));

    //
    // cache dbllastTime for return in GetCurrentTime
    //

    m_dblLocalTime = dbllastTime;
}
#endif


HRESULT 
CTIMEMCPlayer::Reset()
{
    HRESULT hr = S_OK;
    bool bNeedActive = m_pcTIMEElem->IsActive();
    bool bNeedPause = m_pcTIMEElem->IsCurrPaused();

    if(!bNeedActive) // see if we need to stop the media.
    {
        Stop();
        goto done;
    }
    Start();

    if (bNeedPause)
    {
        Pause();
    }
    
done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::Start, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: dblLocalTime
//
//  Returns:   
//
//------------------------------------------------------------------------
void 
CTIMEMCPlayer::Start()
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::Start()"));

    if (m_fInitialized)
    {
        THR(m_spMCPlayer->Play());
    }
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::Stop, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: 
//
//  Returns:   
//
//------------------------------------------------------------------------
void 
CTIMEMCPlayer::Stop(void)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::Stop()"));

    if (m_fInitialized)
    {
        THR(m_spMCPlayer->Stop());
    }
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::Pause, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: 
//
//  Returns:   
//
//------------------------------------------------------------------------
void 
CTIMEMCPlayer::Pause(void)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::Pause"));

    if (m_fInitialized)
    {
        THR(m_spMCPlayer->Pause());
    }
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::Resume, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: 
//
//  Returns:   
//
//------------------------------------------------------------------------
void 
CTIMEMCPlayer::Resume(void)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::Resume"));

    if (m_fInitialized)
    {
        THR(m_spMCPlayer->Play());
    }
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::Resume, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: 
//
//  Returns:   
//
//------------------------------------------------------------------------
void 
CTIMEMCPlayer::Repeat(void)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::Repeat"));

    Start();
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::Render, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: 
//
//  Returns:   
//
//------------------------------------------------------------------------
HRESULT 
CTIMEMCPlayer::Render(HDC hdc, LPRECT prc)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::Render"));
    HRESULT hr = E_NOTIMPL;

done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::put_src, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: src
//
//  Returns:   
//
//------------------------------------------------------------------------
HRESULT 
CTIMEMCPlayer::SetSrc(LPOLESTR base, LPOLESTR src)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::SetSrc"));
    HRESULT hr = E_NOTIMPL;

done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::SetSize, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: prect
//
//  Returns:   
//
//------------------------------------------------------------------------
HRESULT 
CTIMEMCPlayer::SetSize(RECT *prect)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::SetSize"));
    HRESULT hr = E_NOTIMPL;

done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::GetCurrentTime, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: 
//
//  Returns:   
//
//------------------------------------------------------------------------
double  
CTIMEMCPlayer::GetCurrentTime()
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::GetCurrentTime"));

    //
    // TODO: return a meaningful time
    //
    
    return m_dblLocalTime;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::GetCurrentSyncTime, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: 
//
//  Returns:   
//
//------------------------------------------------------------------------
HRESULT
CTIMEMCPlayer::GetCurrentSyncTime(double & dblSyncTime)
{
    HRESULT hr;

    hr = S_FALSE;
  done:
    RRETURN1(hr, S_FALSE);
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::Seek, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: dblTime
//
//  Returns:   
//
//------------------------------------------------------------------------
HRESULT 
CTIMEMCPlayer::Seek(double dblTime)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::Seek()"));
    HRESULT hr = E_NOTIMPL;

    //
    // TODO: add seek support
    //

done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::GetMediaLength, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: rdblLength
//
//  Returns:   
//
//------------------------------------------------------------------------
HRESULT 
CTIMEMCPlayer::GetMediaLength(double& rdblLength)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::GetMediaLength()"));
    HRESULT hr = S_OK;

    //
    // TODO: return a meaningful media length
    //
    rdblLength  = HUGE_VAL;

done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::CanSeek, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: rfcanSeek
//
//  Returns:   
//
//------------------------------------------------------------------------
HRESULT 
CTIMEMCPlayer::CanSeek(bool& rfcanSeek)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::CanSeek"));
    HRESULT hr = S_OK;

    //
    // TODO: add seek support
    //
    rfcanSeek = false;

done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Method:    EnsureStringInVariant
//
//  Overview:  Tells us whether we have or can make a string out of this variant
//
//  Arguments: in/out variant
//
//  Returns:   bool
//
//------------------------------------------------------------------------
static bool 
EnsureStringInVariant (CComVariant *pvarParam)
{
    bool bRet = true;

    if (VT_BSTR != V_VT(pvarParam))
    {
        if (FAILED(THR(pvarParam->ChangeType(VT_BSTR))))
        {
            bRet = false;
            goto done;
        }
    }

done :
    return bRet;
} // EnsureStringInVariant

//+-----------------------------------------------------------------------
//
//  Method:    MakeEmptyStringInVariant
//
//  Overview:  Put an empty string into this variant
//
//  Arguments: in/out variant
//
//  Returns:   S_OK, E_OUTOFMEMORY
//
//------------------------------------------------------------------------
static HRESULT
MakeEmptyStringInVariant (CComVariant *pvarParam)
{
    HRESULT hr;

    pvarParam->Clear();

    V_BSTR(pvarParam) = ::SysAllocString(L"");
    if (NULL == V_BSTR(pvarParam))
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    V_VT(pvarParam) = VT_BSTR;

    hr = S_OK;
done :
    RRETURN1(hr,E_OUTOFMEMORY);
} // EnsureStringInVariant

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::GetPropertyFromDevicePlaylist
//
//  Overview:  
//
//  Arguments: pbstrParam
//
//  Returns:   S_OK, E_ACCESSDENIED, E_OUTOFMEMORY, E_POINTER
//
//------------------------------------------------------------------------
HRESULT
CTIMEMCPlayer::GetPropertyFromDevicePlaylist (LPOLESTR wzPropertyName, BSTR *pbstrOut)
{
    HRESULT hr;
    CComPtr<IMCPList> spimcPlaylist;
    CComVariant varParam;

    if (NULL == pbstrOut)
    {
        hr = E_POINTER;
        goto done;
    }

    hr = THR(m_spMCPlayer->get_GetCurrentPlaylist(&spimcPlaylist));
    if (FAILED(hr))
    {
        // @@ Need to define the proper error mapping.
        hr = E_ACCESSDENIED;
        goto done;
    }

    hr = THR(spimcPlaylist->get_GetProperty(wzPropertyName, &varParam));
    if (FAILED(hr))
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    // Make sure we pass a string back, even if it is an empty one.
    if (EnsureStringInVariant(&varParam))
    {
        *pbstrOut = ::SysAllocString(V_BSTR(&varParam));
    }
    else
    {
        hr = MakeEmptyStringInVariant(&varParam);
        if (FAILED(hr))
        {
            goto done;
        }
        *pbstrOut = ::SysAllocString(V_BSTR(&varParam));
    }

    if (NULL == (*pbstrOut))
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;
done:
    RRETURN3(hr, E_ACCESSDENIED, E_OUTOFMEMORY, E_POINTER);
} // CTIMEMCPlayer::GetPropertyFromDevicePlaylist

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::getAuthor, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: pbstrAuthor
//
//  Returns:   S_OK, S_FALSE, E_ACCESSDENIED, E_OUTOFMEMORY
//
//------------------------------------------------------------------------
HRESULT 
CTIMEMCPlayer::GetAuthor(BSTR* pbstrAuthor)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::getAuthor"));
   
    return GetPropertyFromDevicePlaylist(MCPLAYLIST_PROPERTY_ARTIST, pbstrAuthor);
} // CTIMEMCPlayer::getAuthor

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::getTitle, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: pbstrTitle
//
//  Returns:   S_OK, S_FALSE, E_ACCESSDENIED, E_OUTOFMEMORY
//
//------------------------------------------------------------------------
HRESULT 
CTIMEMCPlayer::GetTitle(BSTR* pbstrTitle)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::GetTitle"));
    return GetPropertyFromDevicePlaylist(MCPLAYLIST_PROPERTY_TITLE, pbstrTitle);
} // CTIMEMCPlayer::getTitle

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::getCopyright, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: pbstrCopyright
//
//  Returns:   
//
//------------------------------------------------------------------------
HRESULT 
CTIMEMCPlayer::GetCopyright(BSTR* pbstrCopyright)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::GetCopyright"));
    return GetPropertyFromDevicePlaylist(MCPLAYLIST_PROPERTY_COPYRIGHT, pbstrCopyright);
} // CTIMEMCPlayer::getCopyright

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::getVolume, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: pflVolume
//
//  Returns:   
//
//------------------------------------------------------------------------
HRESULT 
CTIMEMCPlayer::GetVolume(float* pflVolume)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::GetVolume"));
    HRESULT hr = E_UNEXPECTED;

    if (IsBadWritePtr(pflVolume, sizeof(float)))
    {
        hr = E_POINTER;
        goto done;
    }

    if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    //
    // TODO: volume support won't work until we give the MC stuff an HWND 
    //
    hr = THR(m_spMCPlayer->get_Volume(pflVolume));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::SetVolume, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: flVolume
//
//  Returns:   
//
//------------------------------------------------------------------------
HRESULT 
CTIMEMCPlayer::SetVolume(float flVolume)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::SetVolume"));
    HRESULT hr = E_UNEXPECTED;

    if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    //
    // TODO: volume support won't work until we give the MC stuff an HWND 
    //
    hr = THR(m_spMCPlayer->put_Volume(flVolume));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::GetBalance, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: pflBalance
//
//  Returns:   
//
//------------------------------------------------------------------------
HRESULT 
CTIMEMCPlayer::GetBalance(float* pflBalance)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::GetBalance"));
    HRESULT hr = E_NOTIMPL;

done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::SetBalance, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: flBalance
//
//  Returns:   
//
//------------------------------------------------------------------------
HRESULT 
CTIMEMCPlayer::SetBalance(float flBalance)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::SetBalance"));
    HRESULT hr = E_NOTIMPL;

done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::GetMute, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: pvarMute
//
//  Returns:   
//
//------------------------------------------------------------------------
HRESULT 
CTIMEMCPlayer::GetMute(VARIANT_BOOL* pvarMute)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::GetMute"));
    HRESULT hr      = E_UNEXPECTED;
    BOOL    bMute   = FALSE;

    if (IsBadWritePtr(pvarMute, sizeof(VARIANT_BOOL)))
    {
        hr = E_POINTER;
        goto done;
    }

    if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    hr = THR(m_spMCPlayer->get_Mute(&bMute));
    if (FAILED(hr))
    {
        goto done;
    }

    if (bMute)
    {
        *pvarMute = VARIANT_TRUE;
    }
    else
    {
        *pvarMute = VARIANT_FALSE;
    }

    hr = S_OK;

done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::SetMute, CTIMEBasePlayer
//
//  Overview:  
//
//  Arguments: varMute
//
//  Returns:   
//
//------------------------------------------------------------------------
HRESULT 
CTIMEMCPlayer::SetMute(VARIANT_BOOL varMute)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::SetMute"));
    HRESULT hr = E_UNEXPECTED;

    if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    if (VARIANT_TRUE == varMute)
    {
        m_spMCPlayer->put_Mute(TRUE);
    }
    else
    {
        m_spMCPlayer->put_Mute(FALSE);
    }

done:
    return hr;
}

//
// Playlist methods
//

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::fillPlayList, CTIMEBasePlayer
//
//  Overview:  Translate IMCPList entries into ITIMEPlayItem entries
//
//  Arguments: Number of tracks, incoming music center playlist, outgoing ITIMEPlaylist interface
//
//  Returns:   S_OK, E_OUTOFMEMORY
//
//------------------------------------------------------------------------
HRESULT
CTIMEMCPlayer::TranslateMCPlaylist (short siNumTracks, IMCPList *pimcPlayList,
                                    CPlayList *pitimePlayList)
{
    HRESULT hr;
    
    for (short si = 0; si < siNumTracks; si++)
    {
        CComPtr <CPlayItem> pPlayItem;
        CComVariant varParam;

        //create the playitem
        hr = THR(pitimePlayList->CreatePlayItem(&pPlayItem));
        if (hr != S_OK)
        {
            goto done; //can't create playitems.
        }
        
        // get the various parameters from the playlist to put in the playitem.
        // We do not require any of the items to be correctly translated from
        // the native playlist format.  They are not always present.

        // Track title
        hr = THR(pimcPlayList->get_GetTrackProperty(si, MCPLAYLIST_TRACKPROPERTY_TITLE, &varParam));
        if (FAILED(hr))
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
        
        if (EnsureStringInVariant(&varParam))
        {
            hr = THR(pPlayItem->PutTitle(V_BSTR(&varParam)));
            if (FAILED(hr))
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }
        }

        varParam.Clear();

        // Track artist
        hr = THR(pimcPlayList->get_GetTrackProperty(si, MCPLAYLIST_TRACKPROPERTY_ARTIST, &varParam));
        if (FAILED(hr))
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
        
        if (EnsureStringInVariant(&varParam))
        {
            hr = THR(pPlayItem->PutAuthor(V_BSTR(&varParam)));
            if (FAILED(hr))
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }
        }

        varParam.Clear();

        // Track filename into the src field
        hr = THR(pimcPlayList->get_GetTrackProperty(si, MCPLAYLIST_TRACKPROPERTY_FILENAME, &varParam));
        if (FAILED(hr))
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
        
        if (EnsureStringInVariant(&varParam))
        {
            hr = THR(pPlayItem->PutSrc(V_BSTR(&varParam)));
            if (FAILED(hr))
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }
        }

        varParam.Clear();

        // Track copyright 
        hr = THR(pimcPlayList->get_GetTrackProperty(si, MCPLAYLIST_TRACKPROPERTY_COPYRIGHT, &varParam));
        if (FAILED(hr))
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
        
        if (EnsureStringInVariant(&varParam))
        {
            hr = THR(pPlayItem->PutCopyright(V_BSTR(&varParam)));
            if (FAILED(hr))
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }
        }

        varParam.Clear();

        // Track rating 
        hr = THR(pimcPlayList->get_GetTrackProperty(si, MCPLAYLIST_TRACKPROPERTY_RATING, &varParam));
        if (FAILED(hr))
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
        
        if (EnsureStringInVariant(&varParam))
        {
            hr = THR(pPlayItem->PutRating(V_BSTR(&varParam)));
            if (FAILED(hr))
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }
        }

        varParam.Clear();

        pitimePlayList->Add(pPlayItem, -1);
    }

    hr = S_OK;
done :
    RRETURN1(hr, E_OUTOFMEMORY);
} // CTIMEMCPlayer::TranslatePlaylist

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::fillPlayList, CTIMEBasePlayer
//
//  Overview:  Fill the ITIMEPlayList from the music center's playlist service.
//
//  Arguments: outgoing ITIMEPlaylist interface
//
//  Returns:   S_OK, E_ACCESSDENIED, E_OUTOFMEMORY
//
//------------------------------------------------------------------------
HRESULT 
CTIMEMCPlayer::FillPlayList(CPlayList *pPlayList)
{
    HRESULT hr;

    // If we're not yet initialized, just eat the request.
    if (m_fInitialized)
    {
        short siNumTracks = 0;
        CComPtr<IMCPList> spimcPlaylist;

        Assert(NULL != m_spMCPlayer.p);
        hr = THR(m_spMCPlayer->get_Tracks(&siNumTracks));
        if (FAILED(hr))
        {
            // @@ Need to define the proper error mapping.
            hr = E_ACCESSDENIED;
            goto done;
        }
        
        hr = THR(m_spMCPlayer->get_GetCurrentPlaylist(&spimcPlaylist));
        if (FAILED(hr))
        {
            // @@ Need to define the proper error mapping.
            hr = E_ACCESSDENIED;
            goto done;
        }

        hr = TranslateMCPlaylist(siNumTracks, spimcPlaylist, pPlayList);
    }

    hr = S_OK;
done :
    RRETURN2(hr, E_ACCESSDENIED, E_OUTOFMEMORY);
} // CTIMEMCPlayer::fillPlayList


//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::setActiveTrack, CTIMEBasePlayer
//
//  Overview:  Change the active track on the device.
//
//  Arguments: track index
//
//  Returns:   S_OK, E_ACCESSDENIED
//
//------------------------------------------------------------------------
HRESULT 
CTIMEMCPlayer::SetActiveTrack (long index)
{
    HRESULT hr;

    // If we're not yet initialized, just eat the request.
    if (m_fInitialized)
    {
        Assert(NULL != m_spMCPlayer.p);
        // @@ Force a bad index into here.
        hr = THR(m_spMCPlayer->put_CurrentTrack(index));
        if (FAILED(hr))
        {
            // @@ Need to define the proper error mapping.
            hr = E_ACCESSDENIED;
            goto done;
        }
    }

    hr = S_OK;
done :
    RRETURN1(hr, E_ACCESSDENIED);
} // CTIMEMCPlayer::setActiveTrack

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::getActiveTrack, CTIMEBasePlayer
//
//  Overview:  Query the active track on the device.
//
//  Arguments: Pointer to track index VARIANT
//
//  Returns:   S_OK, E_POINTER, E_INVALIDARG, E_ACCESSDENIED
//
//------------------------------------------------------------------------
HRESULT 
CTIMEMCPlayer::GetActiveTrack (long *pvarIndex)
{
    HRESULT hr;

    *pvarIndex = -1;
    
    // If we're not yet initialized, just eat the request.
    if (m_fInitialized)
    {
        int iCurrentTrack = 0;

        Assert(NULL != m_spMCPlayer.p);
        hr = THR(m_spMCPlayer->get_CurrentTrack(&iCurrentTrack));
        if (FAILED(hr))
        {
            // @@ Need to define the proper error mapping.
            hr = E_ACCESSDENIED;
            goto done;
        }

        *pvarIndex = iCurrentTrack;
    }

    hr = S_OK;
done :
    RRETURN3(hr, E_ACCESSDENIED, E_INVALIDARG, E_POINTER);
} // CTIMEMCPlayer::getActiveTrack


//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::OnDiscInserted, IDLXPlayEventSink
//
//  Overview:  
//
//  Arguments: CDID
//
//  Returns:   
//
//------------------------------------------------------------------------
STDMETHODIMP
CTIMEMCPlayer::OnDiscInserted(long CDID)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::OnDiscInserted"));
    HRESULT hr = S_OK;

    if (NULL != m_pcTIMEElem)
    {
        m_pcTIMEElem->FireMediaEvent(PE_ONMEDIACOMPLETE);
        m_pcTIMEElem->FireMediaEvent(PE_ONMEDIAINSERTED);
    }

done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::OnDiscRemoved, IDLXPlayEventSink
//
//  Overview:  
//
//  Arguments: CDID
//
//  Returns:   
//
//------------------------------------------------------------------------
STDMETHODIMP
CTIMEMCPlayer::OnDiscRemoved(long CDID)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::OnDiscRemoved"));
    HRESULT hr = S_OK;

    // When the disc is removed, we need to tell the playlist to update.
    if (NULL != m_pcTIMEElem)
    {
        m_pcTIMEElem->FireMediaEvent(PE_ONMEDIACOMPLETE);
        m_pcTIMEElem->FireMediaEvent(PE_ONMEDIAREMOVED);
        //IGNORE_HR(m_pcTIMEElem->FireEvents(TE_ONMEDIAREMOVED, 0, NULL, NULL));
    }

done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::OnPause, IDLXPlayEventSink
//
//  Overview:  
//
//  Arguments: 
//
//  Returns:   
//
//------------------------------------------------------------------------
STDMETHODIMP
CTIMEMCPlayer::OnPause(void)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::OnPause"));
    HRESULT hr = S_OK;

done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::OnStop, IDLXPlayEventSink
//
//  Overview:  
//
//  Arguments: 
//
//  Returns:   
//
//------------------------------------------------------------------------
STDMETHODIMP
CTIMEMCPlayer::OnStop(void)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::OnStop"));
    HRESULT hr = S_OK;

done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::OnPlay, IDLXPlayEventSink
//
//  Overview:  
//
//  Arguments: 
//
//  Returns:   
//
//------------------------------------------------------------------------
STDMETHODIMP
CTIMEMCPlayer::OnPlay(void)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::OnPlay"));
    HRESULT hr = S_OK;

done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::OnTrackChanged, IDLXPlayEventSink
//
//  Overview:  
//
//  Arguments: NewTrack
//
//  Returns:   
//
//------------------------------------------------------------------------
STDMETHODIMP
CTIMEMCPlayer::OnTrackChanged(short NewTrack)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::OnTrackChanged"));
    HRESULT hr = S_OK;

    if (NULL != m_pcTIMEElem)
    {
        m_pcTIMEElem->FireMediaEvent(PE_ONMEDIATRACKCHANGED);
    }

done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::OnCacheProgress, IDLXPlayEventSink
//
//  Overview:  
//
//  Arguments: CD               
//             Track            
//             PercentComplete  
//
//  Returns:   
//
//------------------------------------------------------------------------
STDMETHODIMP
CTIMEMCPlayer::OnCacheProgress(short CD, short Track, short PercentCompleted)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::OnCacheProgress"));
    HRESULT hr = S_OK;

done:
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    CTIMEMCPlayer::OnCacheComplete, IDLXPlayEventSink
//
//  Overview:  
//
//  Arguments: CD       
//             Track    
//             Status   
//
//  Returns:   
//
//------------------------------------------------------------------------
STDMETHODIMP
CTIMEMCPlayer::OnCacheComplete(short CD, short Track, short Status)
{
    TraceTag((tagMCPlayer, "CTIMEMCPlayer::OnCacheComplete"));
    HRESULT hr = S_OK;

done:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\playernative.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: player.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "playernative.h"
#include "playerimage.h"
#include "playerdshow.h"
#include "playerhwdshow.h"
#include "player.h"
#include "playerdvd.h"
#include "playercd.h"
#include "playerdshowtest.h"
#include "mediaelm.h"
#include "dshowproxy.h"
#include "dshowcdproxy.h"
#include "hwproxy.h"
#include "msxml.h"
#include "dmusicproxy.h"

#include "bindstatuscallback.h"


static WCHAR g_wszHardware[] = L"hardware";

static const TCHAR WMPCD_DLL[] = _T("WMPCD.DLL");
static const char WMPGETCDDEVICELIST[] = "WMPGetCDDeviceList";
static WCHAR g_urlAddress[] = L"http://windowsmedia.com/redir/QueryTOC.asp?cd=";

DeclareTag(tagPlayerNative, "TIME: Players", "CTIMEPlayerNative methods");
DeclareTag(tagPlayerNativeEffDur, "TIME: Players", "CTIMEPlayerNative effective dur methods");
DeclareTag(tagPlayerNativeEffSync, "TIME: Players", "CTIMEPlayerNative effective sync methods");


LONG CTIMEPlayerNative::m_fHPlayer = 0;
LONG CTIMEPlayerNative::m_fHaveCD = 0;

CTIMEPlayerNative::CTIMEPlayerNative(PlayerType playerType) :
    m_cRef(0),
    m_fCanChangeSrc(false),
    m_playerType(playerType),
    m_fHardware(true),
    m_lpsrc(NULL),
    m_lpbase(NULL),
    m_lpmimetype(NULL),
    m_dblClipBegin(0.0),
    m_dblClipEnd(-1.0),
    m_fAbortDownload(false),
    m_iCurrentPlayItem(-1),
    m_fFiredMediaComplete(false),
    m_iChangeUp(1),
    m_fNoNaturalDur(false),
    m_hinstWMPCD(NULL),
    m_WMPGetCDDeviceList(NULL),
    m_lSrc(ATOM_TABLE_VALUE_UNITIALIZED),
    m_pTIMEMediaPlayerStream(NULL),
    m_dblPriority(INFINITE),
    m_fHavePriority(false),
    m_fHandlingEvent(false),
    m_eAsynchronousType(ASYNC_NONE),
    m_fDownloadError(false),
    m_fRemoved(false),
    m_pszDiscoveredMimeType(NULL)
{
    TraceTag((tagPlayerNative,
              "CTIMEPlayerNative(%lx)::CTIMEPlayerNative()",
              this));

    //
    // CD Player disabled
    // bug 18665
    // 
    // NOTE: technically we should be ok here since Init is called and we
    // dont let a PLAYER_CD be set inside Init (through GetPlayerType).
    // but just to be safe...
    //
    if (m_playerType == PLAYER_CD)
    {
        m_playerType = PLAYER_NONE;
    }

}

CTIMEPlayerNative::~CTIMEPlayerNative()
{
    TraceTag((tagPlayerNative,
              "CTIMEPlayerNative(%lx)::~CTIMEPlayerNative()",
              this));

    m_lpsrc = NULL;
    m_lpbase = NULL;
    m_lpmimetype = NULL;

    delete [] m_pszDiscoveredMimeType;
    m_pszDiscoveredMimeType = NULL;

    ReleaseInterface(m_pTIMEMediaPlayerStream);
}


HRESULT
CTIMEPlayerNative::GetExternalPlayerDispatch(IDispatch **ppDisp)
{
    HRESULT hr = S_OK;

    if(m_pPlayer)
    {
        hr = m_pPlayer->GetExternalPlayerDispatch(ppDisp);
    }

    return hr;
}

void
CTIMEPlayerNative::RemovePlayList()
{
    PlayerList::iterator iPlayer;

    if (m_playList)
    {
        m_playList->Deinit();
        m_playList.Release();

        for(iPlayer = playerList.begin(); iPlayer != playerList.end(); iPlayer++)
        {
            if((*iPlayer) == NULL)
            {
                continue;
            }
            (*iPlayer)->Stop();
            if((*iPlayer) != m_pPlayer)
            {
                THR((*iPlayer)->DetachFromHostElement());
            }
            (*iPlayer)->Release();
        }
    }
}

void
CTIMEPlayerNative::RemovePlayer()
{
    if (m_pPlayer)
    {
        m_pPlayer->Stop();
        THR(m_pPlayer->DetachFromHostElement());
        m_pPlayer.Release();
        if(m_fHardware)
        {
            InterlockedExchange(&m_fHPlayer , 0);
        }
        if(m_fHaveCD)
        {
            InterlockedExchange(&m_fHaveCD , 0);
        }

    }
}

void
CTIMEPlayerNative::BuildPlayer(PlayerType playerType)
{
    LONG llock;
    bool fHasDvd;
    HRESULT hr = S_OK;

    RemovePlayer();

    switch(playerType)
    {
    case PLAYER_IMAGE:
        m_pPlayer = NEW CTIMEImagePlayer();
        m_fHardware = false;
        break;
    case PLAYER_DMUSIC:
        m_pPlayer = CTIMEPlayerDMusicProxy::CreateDMusicProxy();
        m_fHardware = false;
        break;
    case PLAYER_DVD:
        m_pPlayer = NEW CTIMEDVDPlayer();
        m_fHardware = false;
        break;
    case PLAYER_CD:
        m_pPlayer = CTIMEDshowCDPlayerProxy::CreateDshowCDPlayerProxy();
        m_fHardware = false;
        break;
#if DBG == 1
    case PLAYER_DSHOWTEST:
        CComObject<CTIMEDshowTestPlayer> * pTestPlayer;

        hr = THR(CComObject<CTIMEDshowTestPlayer>::CreateInstance(&pTestPlayer));
        if (hr != S_OK)
        {
            break;
        }

        m_pPlayer = (CTIMEBasePlayer *)pTestPlayer;
        m_fHardware = false;
        break;
#endif
    case PLAYER_WMP:
        m_pPlayer = NEW CTIMEPlayer(__uuidof(MediaPlayerCLSID));
        m_fCanChangeSrc = true;
        m_fHardware = false;
        break;
    case PLAYER_DSHOW:
        fHasDvd = FindDVDPlayer();
        if(m_fHardware && !fHasDvd)
        {
            llock = InterlockedExchange(&m_fHPlayer , 1);
            if(llock == 0)
            {
                m_pPlayer = CTIMEDshowHWPlayerProxy::CreateDshowHWPlayerProxy();
            }
            else
            {
                m_fHardware = false;
                m_pPlayer = CTIMEDshowPlayerProxy::CreateDshowPlayerProxy();
            }
        }
        else
        {
            m_pPlayer = CTIMEDshowPlayerProxy::CreateDshowPlayerProxy();
        }
        break;
    default:
        break;
    }
}

HRESULT
DiscoverMimeType(LPWSTR pszBase, LPWSTR pszSrc, LPWSTR * ppszDiscoveredMimeType)
{
    HRESULT     hr = S_OK;
    LPOLESTR    pszUrl = NULL;

    LPOLESTR    lpszPath = NULL;
    URL_COMPONENTSW URLComp;
    LPOLESTR    MimeType = NULL;

    Assert(ppszDiscoveredMimeType);
    *ppszDiscoveredMimeType = NULL;


    hr = THR(::TIMECombineURL(pszBase, pszSrc, &pszUrl));
    if (!pszUrl)
    {
        hr = E_FAIL;
        goto done;
    }
    if (FAILED(hr))
    {
        goto done;
    }
    
    ZeroMemory(&URLComp, sizeof(URL_COMPONENTS));
    URLComp.dwStructSize = sizeof(URL_COMPONENTS);
    URLComp.dwUrlPathLength = INTERNET_MAX_URL_LENGTH;
    URLComp.dwExtraInfoLength = INTERNET_MAX_URL_LENGTH;
    
    if (!InternetCrackUrlW(pszUrl, lstrlenW(pszUrl), 0, &URLComp))
    {
        hr = S_FALSE;
        goto done;
    }
    lpszPath = NEW OLECHAR [URLComp.dwUrlPathLength + 1];
    if (lpszPath == NULL)
    {
        hr = S_FALSE;
        goto done;
    }
    StrCpyNW(lpszPath, URLComp.lpszUrlPath, URLComp.dwUrlPathLength + 1);            
    lpszPath[URLComp.dwUrlPathLength] = 0;
    
    
    // Try to discover 
    hr = THR(::TIMEFindMimeFromData(NULL, lpszPath, NULL, NULL, NULL, 0, &MimeType, 0));
    if (SUCCEEDED(hr))
    {
        (*ppszDiscoveredMimeType) = ::CopyString(MimeType);
        
        if (NULL == (*ppszDiscoveredMimeType))
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    if (FAILED(hr))
    {
        // could not discover mime type from extension.  return NULL mime type and S_OK
        (*ppszDiscoveredMimeType) = NULL;
        hr = S_OK;
        goto done;
    }
    
    hr = S_OK;
done:
    if (NULL != MimeType)
    {
        CoTaskMemFree(MimeType);
        MimeType = NULL;
    }
    delete [] pszUrl;
    delete [] lpszPath;
    RRETURN1(hr, S_FALSE);
}


PlayerType
CTIMEPlayerNative::GetPlayerType(LPOLESTR lpBase, LPOLESTR src, LPOLESTR lpMimeType)
{
    PlayerType foundPlayer = PLAYER_NONE;

    LPOLESTR pEntryRef = NULL;
    HRESULT hr = S_OK;
    LONG lHaveCD;
    LPWSTR pszDiscoveredMimeType = NULL;

    //
    // CD Player disabled
    // bug 18665
    // 
    if (m_playerType != PLAYER_NONE)
    {
        if (m_playerType == PLAYER_CD)
        {
            goto done;
        }
        foundPlayer = m_playerType;
        goto done;
    }


#if 0 // remove this to enable CD Player
    if(m_playerType != PLAYER_NONE)
    {
        if((m_playerType == PLAYER_CD) && (src == NULL))
        {
            lHaveCD = InterlockedExchange(&m_fHaveCD , 1);

            if(lHaveCD == 1)
            {
                hr = E_FAIL;
                goto done;
            }

            hr = CreateCDPlayList();
            if(FAILED(hr))
            {
                goto done;
            }
        }

        foundPlayer = m_playerType;
        goto done;
    }
#endif // remove this to enable CD Player

    if(lpMimeType == NULL)
    {
        hr = THR(DiscoverMimeType(lpBase, src, &pszDiscoveredMimeType));
        if (S_FALSE == hr)
        {
            foundPlayer = PLAYER_WMP;
            hr = S_OK;
            goto done;
        }
        else if ((S_OK == hr) && 
                 ((NULL == pszDiscoveredMimeType) || (0 == StrCmpIW(pszDiscoveredMimeType, L"text/asp"))))
        {
            // could not discover mime type from extension alone.  Need to start a download.
        
            LPOLESTR szSrc = NULL;

            hr = THR(::TIMECombineURL(lpBase, src, &szSrc));
            if (!szSrc)
            {
                hr = E_FAIL;
                goto done;
            }
            if (FAILED(hr))
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }
        
            StartFileDownload(szSrc, MIMEDISCOVERY_ASYNCH);
        
            foundPlayer = PLAYER_DSHOW;

            delete [] szSrc;
            goto done;
        }
        if (FAILED(hr))
        {
            goto done;
        }
        hr = THR(PlayerTypeFromMimeType(pszDiscoveredMimeType, lpBase, src, lpMimeType, &foundPlayer));
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else
    {
        hr = THR(PlayerTypeFromMimeType(lpMimeType, lpBase, src, lpMimeType, &foundPlayer));
        if (FAILED(hr))
        {
            goto done;
        }
    }


    hr = S_OK;
done:
    delete [] pszDiscoveredMimeType;

    return foundPlayer;
}

HRESULT
CTIMEPlayerNative::PlayerTypeFromMimeType(LPWSTR pszMimeType, LPOLESTR lpBase, LPOLESTR src, LPOLESTR lpMimeType, PlayerType * pType)
{   
    HRESULT hr = S_OK;

    PlayerType foundPlayer = PLAYER_NONE;

    bool fPlayVideo = true;
    bool fShowImages = true;
    bool fPlayAudio = true;
    bool fPlayAnimations = true;

    Assert(pType);
    *pType = PLAYER_NONE;

    m_pTIMEElementBase->ReadRegistryMediaSettings(fPlayVideo, fShowImages, fPlayAudio, fPlayAnimations);

    if (NULL == pszMimeType)
    {
        if (fPlayVideo)
        {
            foundPlayer = PLAYER_DSHOW;
        }
        // else PLAYER_NONE, set above
        goto done;
    }


    // The cheezy WMF test is necessary because urlmon does not consider
    // wmf files to have 'image' mimetypes.
    if (   (StrCmpNW(L"image", pszMimeType , 5) == 0)
        || (IsWMFSrc(src, pszMimeType, lpMimeType)))
    {
        if (fShowImages)
        {
            foundPlayer = PLAYER_IMAGE;
        }
    }
    else if (   IsASXSrc(src, pszMimeType, lpMimeType)
             || IsM3USrc(src, pszMimeType, lpMimeType)
             || IsWAXSrc(src, pszMimeType, lpMimeType)
             || IsWVXSrc(src, pszMimeType, lpMimeType)
             || IsWMXSrc(src, pszMimeType, lpMimeType)
             || IsLSXSrc(src, pszMimeType, lpMimeType))
    {
        if (IsASXSrc(src, pszMimeType, lpMimeType) ||
            IsLSXSrc(src, pszMimeType, lpMimeType) ||
            IsWMXSrc(src, pszMimeType, lpMimeType))
        {
            LPOLESTR szSrc = NULL;

            hr = THR(::TIMECombineURL(lpBase, src, &szSrc));
            if (!szSrc)
            {
                hr = E_FAIL;
                goto done;
            }
            if (FAILED(hr))
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }

            StartFileDownload(szSrc, PLAYLIST_ASX);

            foundPlayer = PLAYER_DSHOW;
            delete[] szSrc;
        }
        else if (fPlayVideo)
        {
            foundPlayer = PLAYER_WMP;
        }
    }
    else if (fPlayVideo)
    {
        foundPlayer = PLAYER_DSHOW;
    }

    hr = S_OK;
done:
    if (S_OK == hr)
    {
        *pType = foundPlayer;
    }

    RRETURN(hr);
}

HRESULT
CTIMEPlayerNative::Init(CTIMEMediaElement *pelem, LPOLESTR base, LPOLESTR src, LPOLESTR lpMimeType, double dblClipBegin, double dblClipEnd)
{
    TraceTag((tagPlayerNative,
              "CTIMEPlayerNative(%lx)::Init)",
              this));   
    HRESULT hr = S_OK;
    CComPtr <IHTMLElement> pEle;
    LPOLESTR pSrc = NULL;
    PlayerList::iterator iPlayer;
    int size;

    if (m_pTIMEElementBase != NULL) //this only happens in the case of reentrancy
    {
        hr = S_OK;
        goto done;
    }

    hr = THR(CTIMEBasePlayer::Init(pelem,
                                   base,
                                   src,
                                   lpMimeType,
                                   dblClipBegin,
                                   dblClipEnd));
    if (FAILED(hr))
    {
        goto done;
    }

    m_fHardware = true;
    
    pEle = m_pTIMEElementBase->GetElement();
    if (pEle != NULL)
    {
        CComBSTR bstrHardware = g_wszHardware;
        VARIANT vHardware;
        VariantInit(&vHardware);
        hr = pEle->getAttribute(bstrHardware, 0, &vHardware);
        if (SUCCEEDED(hr))
        {
            if (vHardware.vt != VT_BSTR)
            {
                hr = VariantChangeType(&vHardware, &vHardware, 0, VT_BSTR);
            }
            if (SUCCEEDED(hr))
            {
                if (StrCmpIW(vHardware.bstrVal, L"false") == 0)
                {
                    m_fHardware = false;
                }
            }
        }
        VariantClear(&vHardware);
    }

    if(m_fHardware)
    {
        if(m_pTIMEElementBase->IsDocumentInEditMode())
        {
            m_fHardware = false;
        }
    }

    if(base != NULL)
    {
        delete [] m_lpbase;
        m_lpbase = CopyString(base);
    }
    if(src != NULL)
    {
        delete [] m_lpsrc;
        m_lpsrc = CopyString(src);
    }
    if(lpMimeType != NULL)
    {
        delete [] m_lpmimetype;
        m_lpmimetype = CopyString(lpMimeType);
    }

    m_playerType = GetPlayerType(base, src, lpMimeType);

    if(m_eAsynchronousType == ASYNC_NONE)
    {
        BuildPlayer(m_playerType);
        if (m_pPlayer)
        {
            hr = m_pPlayer->Init(pelem, base, src, NULL, dblClipBegin, dblClipEnd);
            if(FAILED(hr))
            {
                if(m_fHardware == true)
                {
                    RemovePlayer();
                    m_fHardware = false;
                    m_pPlayer = CTIMEDshowPlayerProxy::CreateDshowPlayerProxy();
                    hr = m_pPlayer->Init(pelem, base, src, NULL, dblClipBegin, dblClipEnd);
                    if(FAILED(hr))
                    {
                        goto done;
                    }
                }
                else
                {
                    goto done;
                }
            }

            m_dblClipEnd = dblClipEnd;
            m_dblClipBegin = dblClipBegin;
        }

    }
    else if(m_playerType == PLAYER_CD)
    {
        BuildPlayer(m_playerType);

        if(m_playList && m_pPlayer)
        {
            CPlayItem * pItem = m_playList->GetItem(0);
            if (pItem == NULL)
            {
                hr = E_FAIL;
                goto done;
            }
        
            pSrc = (LPOLESTR)(pItem->GetSrc());
            if(pSrc == NULL)
            {
                hr = E_FAIL;
                goto done;
            }
            m_fHardware = false;

            playerList.resize(m_playList->GetLength(), NULL);
            m_durList.resize(m_playList->GetLength(), -1.0);
            m_effectiveDurList.resize(m_playList->GetLength(), 0.0);
            m_validList.resize(m_playList->GetLength(), true);
            m_playedList.resize(m_playList->GetLength(), false);
            m_pPlayer->SetPlaybackSite(this);

            iPlayer = playerList.begin();
            (*iPlayer) = m_pPlayer;
            m_pPlayer.p->AddRef();
            m_pTIMEElementBase -> FireMediaEvent(PE_ONMEDIATRACKCHANGED);
            dblClipBegin = valueNotSet;
            dblClipEnd = valueNotSet;

            hr = m_pPlayer->Init(m_pTIMEElementBase, NULL, src, NULL, dblClipBegin, dblClipEnd);

            delete [] m_lpbase;
            delete [] m_lpmimetype;
            delete [] m_lpsrc;
            m_lpbase = NULL;
            m_lpsrc = CopyString(pSrc);
            m_lpmimetype = NULL;
            m_dblClipEnd = dblClipEnd;
            m_dblClipBegin = dblClipBegin;
            m_iCurrentPlayItem = 0;
        }

    }    

    m_dblClipEnd = dblClipEnd;
    m_dblClipBegin = dblClipBegin;

    hr = S_OK;
  done:
    if (FAILED(hr))
    {
        DetachFromHostElement();
    }

    RRETURN(hr);
}

HRESULT
CTIMEPlayerNative::DetachFromHostElement (void)
{
    HRESULT hr = S_OK;

    TraceTag((tagPlayerNative,
              "CTIMEPlayerNative(%lx)::DetachFromHostElement)",
              this));

    m_fRemoved = true;

    RemovePlayList();
    RemovePlayer();

    delete[] m_lpbase;
    m_lpbase = NULL;
    delete[] m_lpsrc;
    m_lpsrc = NULL;
    delete[] m_lpmimetype;
    m_lpmimetype = NULL;

    if(m_hinstWMPCD)
    {
        FreeLibrary(m_hinstWMPCD);
        m_hinstWMPCD = NULL;
    }
    m_WMPGetCDDeviceList = NULL;

    return hr;
}

void
CTIMEPlayerNative::Start()
{
    if(m_playList)
    {
        InternalSetActiveTrack(0, false);
        /////////////////////////////////////////////////////////////////////////////////////
        //need to reset the effect dur list after setting the active track because
        //setting the active track will cause the last element that played to set an 
        //effect dur into the effective dur list.
        /////////////////////////////////////////////////////////////////////////////////////
        ResetEffectiveDur();
        Reset();
    }
    else if(m_pPlayer)
    {
        m_pPlayer->Start();
    }
}

void
CTIMEPlayerNative::Stop()
{
    if(m_playList)
    {
        if(m_iCurrentPlayItem < m_playList->GetLength())
        {
            if(m_pPlayer)
            {
                m_pPlayer->Pause();
            }
        }
    }
    else if(m_pPlayer)
    {
        m_pPlayer->Stop();
    }
}

void
CTIMEPlayerNative::Pause()
{
    if(m_pPlayer)
    {
        m_pPlayer->Pause();
    }
}

void
CTIMEPlayerNative::Resume()
{
    if(m_pPlayer)
    {
        m_pPlayer->Resume();
    }
}

void
CTIMEPlayerNative::Repeat()
{
    if(m_playList)
    {
        ResetEffectiveDur();
        InternalSetActiveTrack(0, false);
    }
    else if(m_pPlayer)
    {
        m_pPlayer->Repeat();
    }
}

HRESULT
CTIMEPlayerNative::Reset()
{
    HRESULT hr = S_OK;
    double dblSegTime = 0.0;
    int iPlayerNr;
    int i = 0;
    PlayerList::iterator iPlayer;
    ValidList::iterator iValid;
    CPlayItem * pItem;
    LPOLESTR psrc = NULL;
    DurList::iterator iEfDur;
    DurList::iterator iDur;
    ValidList::iterator iPlayed;


    if(m_playList && m_pPlayer)
    {
        if(m_pTIMEElementBase == NULL)
        {
            goto done;
        }

        if(m_iCurrentPlayItem >= m_playList->GetLength())
        {
            goto done;
        }

        for(iEfDur = m_effectiveDurList.begin(), iDur = m_durList.begin(), i = 0, iPlayed = m_playedList.begin();
            iEfDur != m_effectiveDurList.end(); iEfDur++, iDur++, i++, iPlayed++)
        {
            if(i < m_iCurrentPlayItem)
            {
                (*iEfDur) = (*iDur);
                (*iPlayed) = true;
            }
            else
            {
                (*iPlayed) = false;
                (*iEfDur) = 0.0;
            }
        }

        dblSegTime = m_pTIMEElementBase->GetMMBvr().GetSimpleTime();
        GetPlayerNumber(dblSegTime, iPlayerNr);

        if((iPlayerNr == m_iCurrentPlayItem) && (iPlayerNr != -1))
        {
            hr = m_pPlayer->Reset();
            goto done;
        }

        if(m_iCurrentPlayItem >= 0)
        {
            iPlayer = playerList.begin();
            iValid = m_validList.begin();
            for(i = m_iCurrentPlayItem; i > 0; i--)
            {
                iPlayer++;
                iValid++;
            }

            if((*iValid))
            {
                (*iPlayer)->Stop();
                THR((*iPlayer)->DetachFromHostElement());
                (*iPlayer)->Release();
                (*iPlayer) = NULL;
                m_pPlayer = NULL;
                m_iCurrentPlayItem = -1;
            }
        }

        if(iPlayerNr == -1)
        {
            goto done;
        }

        m_iCurrentPlayItem = iPlayerNr;

        iPlayer = playerList.begin();
        for(i = m_iCurrentPlayItem; i > 0; i--)
        {
            iPlayer++;
        }

        for(iEfDur = m_effectiveDurList.begin(), iDur = m_durList.begin(), i = 0, iPlayed = m_playedList.begin();
            iEfDur != m_effectiveDurList.end(); iEfDur++, iDur++, i++, iPlayed++)
        {
            if(i < m_iCurrentPlayItem)
            {
                (*iEfDur) = (*iDur);
                (*iPlayed) = true;
            }
            else
            {
                (*iPlayed) = false;
                (*iEfDur) = 0.0;
            }
        }

        pItem = m_playList->GetItem(m_iCurrentPlayItem);
        if(pItem)
        {
            psrc = (LPOLESTR)pItem->GetSrc();
        }
        switch(m_playerType)
        {
            case PLAYER_CD:
                m_pPlayer = CTIMEDshowCDPlayerProxy::CreateDshowCDPlayerProxy();
                m_fHardware = false;
                break;
            case PLAYER_DSHOW:
                m_pPlayer = CTIMEDshowPlayerProxy::CreateDshowPlayerProxy();
                m_fHardware = false;
                break;
        }
        m_pPlayer->SetPlaybackSite(this);
        hr = m_pPlayer->Init(m_pTIMEElementBase, m_pTIMEElementBase->GetBaseHREF(), psrc, NULL, valueNotSet, valueNotSet);
        (*iPlayer) = m_pPlayer;
        m_pPlayer.p->AddRef();
        m_pTIMEElementBase -> FireMediaEvent(PE_ONMEDIATRACKCHANGED);

    }
    else if(m_pPlayer)
    {
        hr = m_pPlayer->Reset();
    }
done:
    return hr;
}

bool
CTIMEPlayerNative::SetSyncMaster(bool fSyncMaster)
{
    return true;
}

double
CTIMEPlayerNative::GetCurrentTime()
{
    double dblCurrTime = 0.0;
    double dblOffset = 0.0;
    HRESULT hr = S_OK;

    if(m_playList)
    {
        dblCurrTime = m_pPlayer->GetCurrentTime();
        hr = GetPlayItemOffset(dblOffset);
        if(FAILED(hr))
        {
            goto done;
        }

        dblCurrTime += dblOffset;
    }
    else if(m_pPlayer)
    {
        dblCurrTime = m_pPlayer->GetCurrentTime();
    }
done:
    return dblCurrTime;
}

void
CTIMEPlayerNative::GetPlayerNumber(double dblSeekTime, int &iPlNr)
{
    iPlNr = -1;
    DurList::iterator iDur;
    int i = 0;

    if(dblSeekTime == 0.0)
    {
        iPlNr = 0;
        goto done;
    }

    for(iDur = m_durList.begin(), i = 0; iDur != m_durList.end(); iDur++, i++)
    {
        if((*iDur) == -1.0)
        {
            break;
        }

        if(dblSeekTime < (*iDur))
        {
            iPlNr = i;
            break;
        }

        dblSeekTime -= (*iDur);
    }
done:
    return;
}

HRESULT
CTIMEPlayerNative::GetPlayItemOffset(double &dblOffset)
{
    HRESULT hr = S_OK;
    DurList::iterator iEfDur;
    int i;

    dblOffset = 0.0;

    if(!m_playList)
    {
        goto done;
    }

    if((m_iCurrentPlayItem == -1) || (m_iCurrentPlayItem >= m_playList->GetLength()))
    {
        hr = E_FAIL;
        goto done;
    }

    for(iEfDur = m_effectiveDurList.begin(), i = 0;
        iEfDur != m_effectiveDurList.end(); iEfDur++, i++)
    {
        dblOffset += (*iEfDur);
    }

done:
    return hr;
}

HRESULT
CTIMEPlayerNative::GetPlayItemSeekOffset(double &dblOffset)
{
    HRESULT hr = S_OK;
    DurList::iterator iDur;
    DurList::iterator iEfDur;
    int i;

    dblOffset = 0.0;

    if(!m_playList)
    {
        goto done;
    }

    if((m_iCurrentPlayItem == -1) || (m_iCurrentPlayItem >= m_playList->GetLength()))
    {
        hr = E_FAIL;
        goto done;
    }

    for(iDur = m_durList.begin(), i = 0;
        iDur != m_durList.end(), i < m_iCurrentPlayItem; iDur++, i++)
    {
        dblOffset += (*iDur);
    }

done:
    return hr;
}

HRESULT
CTIMEPlayerNative::GetPlaybackOffset(double &dblOffset)
{
    HRESULT hr = S_OK;

    hr = GetPlayItemSeekOffset(dblOffset);

    return hr;
}


HRESULT
CTIMEPlayerNative::GetEffectiveOffset(double &dblOffset)
{
    HRESULT hr = S_OK;

    hr = GetPlayItemOffset(dblOffset);

    return hr;
}

HRESULT
CTIMEPlayerNative::GetCurrentSyncTime(double & dblSyncTime)
{
    HRESULT hr = S_OK;
    double dblOffset = 0.0;
    dblSyncTime = 0.0;

    if(m_playList)
    {
        if((m_iCurrentPlayItem == -1) || (m_pPlayer == NULL))
        {
            hr = S_FALSE;
            goto done;
        }

        hr = m_pPlayer->GetCurrentSyncTime(dblSyncTime);
        if(S_OK != hr)
        {
            TraceTag((tagPlayerNativeEffSync,
                      "CTIMEPlayerNative(%lx)::CTIMEPlayerNative::sync()-failes player(%d)",
                      this, m_iCurrentPlayItem));
            hr = S_FALSE;
            goto done;
        }

        hr = GetPlayItemOffset(dblOffset);
        if(FAILED(hr))
        {
            hr = S_FALSE;
            goto done;
        }

        TraceTag((tagPlayerNativeEffSync,
                  "CTIMEPlayerNative(%lx)::CTIMEPlayerNative::sync()-unadjusted(%d - %g)",
                  this, m_iCurrentPlayItem, dblSyncTime));
        dblSyncTime += dblOffset;
        TraceTag((tagPlayerNativeEffSync,
                  "CTIMEPlayerNative(%lx)::CTIMEPlayerNative::sync()-adjusted(%d - %g)",
                  this, m_iCurrentPlayItem, dblSyncTime));

    }
    else if(m_pPlayer)
    {
        hr = m_pPlayer->GetCurrentSyncTime(dblSyncTime);
    }
    else
    {
        hr = S_OK;
    }

done:
    return hr;
}

HRESULT
CTIMEPlayerNative::Seek(double dblTime)
{
    HRESULT hr = S_OK;

    if(m_pPlayer)
    {
        hr = m_pPlayer->Seek(dblTime);
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::GetMediaLength(double &dblLength)
{
    HRESULT hr = S_OK;
    DurList::iterator iDur;

    dblLength = 0.0;   
    if(m_playList)
    {
        for(iDur = m_durList.begin(); iDur != m_durList.end(); iDur++)
        {
            if((*iDur) == -1.0)
            {
                dblLength = HUGE_VAL;
                break;
            }
            dblLength += (*iDur);
        }      
    }
    else if(m_pPlayer)
    {
        hr = m_pPlayer->GetMediaLength(dblLength);
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::CanSeek(bool &fcanSeek)
{
    HRESULT hr = S_OK;

    if(m_pPlayer)
    {
        hr = m_pPlayer->CanSeek(fcanSeek);
    }
    return hr;
}

PlayerState
CTIMEPlayerNative::GetState()
{
    if (m_pPlayer)
    {
        return m_pPlayer->GetState();
    }

    return CTIMEBasePlayer::GetState();
}

HRESULT
CTIMEPlayerNative::HasMedia(bool &hasMedia)
{
    HRESULT hr = S_OK;

    if(m_pPlayer)
    {
        hr = m_pPlayer->HasMedia(hasMedia);
    }
    else
    {
        hasMedia = false;
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::HasVisual(bool &hasVisual)
{
    HRESULT hr = S_OK;

    if(m_pPlayer)
    {
        hr = m_pPlayer->HasVisual(hasVisual);
    }
    else
    {
        hasVisual = false;
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::HasAudio(bool &hasAudio)
{
    HRESULT hr = S_OK;

    if(m_pPlayer)
    {
        hr = m_pPlayer->HasAudio(hasAudio);
    }
    else
    {
        hasAudio = false;
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::Render(HDC hdc, LPRECT prc)
{
    HRESULT hr = S_OK;

    if(m_pPlayer)
    {
        hr = m_pPlayer->Render(hdc, prc);
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::SetSrc(LPOLESTR base, LPOLESTR src)
{
    HRESULT hr = S_OK;

    if(m_pPlayer)
    {
        if(m_fCanChangeSrc)
        {
            hr = m_pPlayer->SetSrc(base, src);
            goto done;
        }
        RemovePlayer();
    }

    BuildPlayer(m_playerType);
    if( m_pPlayer)
    {
        hr = m_pPlayer->Init(m_pTIMEElementBase, base, src, NULL, m_dblClipStart, m_dblClipEnd);
    }

done:
    return hr;
}

HRESULT 
CTIMEPlayerNative::SetSize(RECT *prect)
{
    HRESULT hr = S_OK;

    if(m_pPlayer)
    {
        hr = m_pPlayer->SetSize(prect);
    }
    return hr;
}


STDMETHODIMP_(ULONG)
CTIMEPlayerNative::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG)
CTIMEPlayerNative::Release(void)
{
    LONG l = InterlockedDecrement(&m_cRef);

    if (0 == l)
    {
        delete this;
    }

    return l;
}

HRESULT
CTIMEPlayerNative::IsBroadcast(bool &bisBroad)
{
    HRESULT hr = S_OK;

    if(m_pPlayer)
    {
        hr = m_pPlayer->IsBroadcast(bisBroad);
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::SetRate(double dblRate)
{
    HRESULT hr = S_OK;

    if(m_pPlayer)
    {
        hr = m_pPlayer->SetRate(dblRate);
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::GetRate(double &dblRate)
{
    HRESULT hr = S_OK;

    if(m_pPlayer)
    {
        hr = m_pPlayer->GetRate(dblRate);
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::GetNaturalHeight(long *height)
{
    HRESULT hr = S_OK;
    *height = -1;
    if(m_pPlayer)
    {
        hr = m_pPlayer->GetNaturalHeight(height);
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::GetNaturalWidth(long *width)
{
    HRESULT hr = S_OK;
    *width = -1;
    if(m_pPlayer)
    {
        hr = m_pPlayer->GetNaturalWidth(width);
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::GetAuthor(BSTR *pAuthor)
{
    HRESULT hr = S_OK;
    CPlayItem *pPlayItem;
    long index;
    LPCWSTR pcString;

    Assert(pAuthor);

    GetActiveTrack(&index);

    if (m_playList && m_pPlayer)
    {
        pPlayItem = m_playList->GetItem(index);
        if(pPlayItem)
        {
            pcString = pPlayItem->GetAuthor();
            if(pcString != NULL)
            {
                *pAuthor = SysAllocString(pcString);
            }
            else
            {
                hr = m_pPlayer->GetAuthor(pAuthor);
            }
        }
    }
    else if(m_pPlayer)
    {
        hr = m_pPlayer->GetAuthor(pAuthor);
    }
    else
    {
        hr = E_FAIL;
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::GetTitle(BSTR *pTitle)
{
    HRESULT hr = S_OK;
    CPlayItem *pPlayItem;
    long index;
    LPCWSTR pcTitle;

    Assert(pTitle);

    GetActiveTrack(&index);

    if (m_playList && m_pPlayer)
    {
        pPlayItem = m_playList->GetItem(index);
        if(pPlayItem)
        {
            pcTitle = pPlayItem->GetTitle();
            if(pcTitle != NULL)
            {
                *pTitle = SysAllocString(pcTitle);
            }
            else
            {
                hr = m_pPlayer->GetTitle(pTitle);
            }
        }
    }
    else if(m_pPlayer)
    {
        hr = m_pPlayer->GetTitle(pTitle);
    }
    else
    {
        hr = E_FAIL;
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::GetCopyright(BSTR *pCopyright)
{
    HRESULT hr = S_OK;
    CPlayItem *pPlayItem;
    long index;
    LPCWSTR pcString;

    Assert(pCopyright);

    GetActiveTrack(&index);

    if (m_playList && m_pPlayer)
    {
        pPlayItem = m_playList->GetItem(index);
        if(pPlayItem)
        {
            pcString = pPlayItem->GetCopyright();
            if(pcString != NULL)
            {
                *pCopyright = SysAllocString(pcString);
            }
            else
            {
                hr = m_pPlayer->GetCopyright(pCopyright);
            }
        }
    }
    else if(m_pPlayer)
    {
        hr = m_pPlayer->GetCopyright(pCopyright);
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

HRESULT
CTIMEPlayerNative::GetAbstract(BSTR *pAbstract)
{
    HRESULT hr = S_OK;
    CPlayItem *pPlayItem;
    long index;
    LPCWSTR pcString;

    Assert(pAbstract);

    GetActiveTrack(&index);

    if (m_playList && m_pPlayer)
    {
        pPlayItem = m_playList->GetItem(index);
        if(pPlayItem)
        {
            pcString = pPlayItem->GetAbstract();
            if(pcString != NULL)
            {
                *pAbstract = SysAllocString(pcString);
            }
            else
            {
                hr = m_pPlayer->GetAbstract(pAbstract);
            }
        }
    }
    else if(m_pPlayer)
    {
        hr = m_pPlayer->GetAbstract(pAbstract);
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

HRESULT
CTIMEPlayerNative::GetRating(BSTR *pRating)
{
    HRESULT hr = S_OK;
    CPlayItem *pPlayItem;
    long index;
    LPCWSTR pcString;

    Assert(pRating);

    GetActiveTrack(&index);

    if (m_playList && m_pPlayer)
    {
        pPlayItem = m_playList->GetItem(index);
        if(pPlayItem)
        {
            pcString = pPlayItem->GetRating();
            if(pcString != NULL)
            {
                *pRating = SysAllocString(pcString);
            }
            else
            {
                hr = m_pPlayer->GetRating(pRating);
            }
        }
    }
    else if(m_pPlayer)
    {
        hr = m_pPlayer->GetRating(pRating);
    }
    else
    {
        hr = E_FAIL;
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::GetVolume(float *pflVolume)
{
    HRESULT hr = S_OK;

    if(m_pPlayer)
    {
        hr = m_pPlayer->GetVolume(pflVolume);
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::SetVolume(float flVolume)
{
    HRESULT hr = S_OK;

    if(m_pPlayer)
    {
        hr = m_pPlayer->SetVolume(flVolume);
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::GetMute(VARIANT_BOOL *pvarMute)
{
    HRESULT hr = S_OK;

    if(m_pPlayer)
    {
        hr = m_pPlayer->GetMute(pvarMute);
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::SetMute(VARIANT_BOOL varMute)
{
    HRESULT hr = S_OK;

    if(m_pPlayer)
    {
        hr = m_pPlayer->SetMute(varMute);
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::GetPlayList(ITIMEPlayList **ppPlayList)
{
    HRESULT hr = S_OK;
    
    if (m_playList)
    {
        hr = THR(m_playList->QueryInterface(IID_ITIMEPlayList, (void**)ppPlayList));
    }
    else if(m_pPlayer)
    {
        hr = m_pPlayer->GetPlayList(ppPlayList);
    }
    else
    {
        hr = E_FAIL;
    }

done:
    return hr;
}

HRESULT 
CTIMEPlayerNative::SetActiveTrack(long index)
{
    return InternalSetActiveTrack(index);
}

HRESULT 
CTIMEPlayerNative::InternalSetActiveTrack(long index, bool fCheckSkip)
{
    CPlayItem * pItem;
    LPOLESTR psrc = NULL;
    PlayerList::iterator iPlayer;
    ValidList::iterator iValid;
    bool fDone = false;
    int iOrigTrack = m_iCurrentPlayItem;
    bool fOk = false;
    HRESULT hr = S_OK;
    int i;

    if(!m_playList)
    {
        hr = E_FAIL;
        goto done;
    }

    if(index >= m_playList->GetLength())
    {
        hr = E_FAIL;
        goto done;
    }

    if((m_iCurrentPlayItem >= 0) && fCheckSkip)
    {
        pItem = m_playList->GetItem(m_iCurrentPlayItem);
        if(pItem)
        {
            if(!pItem->GetCanSkip())
            {
                hr = S_OK;
                goto done;
            }
        }
    }

    SetEffectiveDur(false);
    //TryNaturalDur();

    if((index == m_iCurrentPlayItem) || (m_iCurrentPlayItem == -1))
    {
        if(m_iCurrentPlayItem == -1)
        {
            m_iCurrentPlayItem = index;
        }
        if(m_pPlayer)
        {
            m_pPlayer->Repeat();
        }
        else
        {
            iPlayer = playerList.begin();
            for(i = m_iCurrentPlayItem; i > 0; i--)
            {
                iPlayer++;
            }
            pItem = m_playList->GetItem(m_iCurrentPlayItem);
            if(pItem)
            {
                psrc = (LPOLESTR)pItem->GetSrc();
            }
            switch(m_playerType)
            {
                case PLAYER_CD:
                    m_pPlayer = CTIMEDshowCDPlayerProxy::CreateDshowCDPlayerProxy();
                    m_fHardware = false;
                    break;
                case PLAYER_DSHOW:
                    m_pPlayer = CTIMEDshowPlayerProxy::CreateDshowPlayerProxy();
                    m_fHardware = false;
                    break;
            }
            m_pPlayer->SetPlaybackSite(this);
            (*iPlayer) = m_pPlayer;
            hr = m_pPlayer->Init(m_pTIMEElementBase, m_pTIMEElementBase->GetBaseHREF(), psrc, NULL, valueNotSet, valueNotSet);
            m_pPlayer.p->AddRef();
        }
        hr = S_OK;
        goto done;
    }
    if(index > m_iCurrentPlayItem)
    {
        m_iChangeUp = 1;
    }
    else
    {
        m_iChangeUp = -1;
    }

    //need to check that track changing is possible
    iValid = m_validList.begin();
    for(i = m_iCurrentPlayItem; i > 0; i--)
    {
        iValid++;
    }
    if(m_iChangeUp == 1)
    {
        if(m_iCurrentPlayItem == (m_playList->GetLength() - 1))
        {
            hr = S_OK;
            goto done;
        }
        for(i = m_iCurrentPlayItem + 1; i < m_playList->GetLength(); i++)
        {
            iValid++;
            if((*iValid) == true)
            {
                fOk = true;
                break;
            }
        }
    }
    else
    {
        if(m_iCurrentPlayItem == 0)
        {
            hr = S_OK;
            goto done;
        }

        for(i = m_iCurrentPlayItem - 1; i >= 0; i--)
        {
            iValid--;
            if((*iValid) == true)
            {
                fOk = true;
                break;
            }
        }

    }

    if(!fOk)
    {
        hr = S_OK;
        goto done;
    }

    i = m_iCurrentPlayItem = index;

    iPlayer = playerList.begin();
    iValid = m_validList.begin();

    for(i = m_iCurrentPlayItem; i > 0; i--)
    {
        iPlayer++;
        iValid++;
    }
    if(m_pPlayer)
    {
        m_pPlayer->Stop();
        m_pPlayer->DetachFromHostElement();
    }

    while(!fDone)
    {
        if((*iPlayer) != NULL)
        {
            if((*iValid) == false)
            {
                m_iCurrentPlayItem += m_iChangeUp;
                if(m_iChangeUp == 1)
                {
                    if(m_iCurrentPlayItem == m_playList->GetLength())
                    {
                        m_iCurrentPlayItem = iOrigTrack;
                        fDone = true;
                        continue;
                    }
                    iValid++;
                    iPlayer++;
                }
                else
                {
                    if(m_iCurrentPlayItem < 0)
                    {
                        m_iCurrentPlayItem = iOrigTrack;
                        fDone = true;
                        continue;
                    }
                    iValid--;
                    iPlayer--;
                }
                continue;
            }
            //m_pPlayer = (*iPlayer); // Replace player

            (*iPlayer)->Stop();
            THR((*iPlayer)->DetachFromHostElement());
            (*iPlayer)->Release();
            (*iPlayer) = NULL;
            pItem = m_playList->GetItem(m_iCurrentPlayItem);
            if(pItem)
            {
                psrc = (LPOLESTR)pItem->GetSrc();
            }
            switch(m_playerType)
            {
                case PLAYER_CD:
                    m_pPlayer = CTIMEDshowCDPlayerProxy::CreateDshowCDPlayerProxy();
                    m_fHardware = false;
                    break;
                case PLAYER_DSHOW:
                    m_pPlayer = CTIMEDshowPlayerProxy::CreateDshowPlayerProxy();
                    m_fHardware = false;
                    break;
            }
            m_pPlayer->SetPlaybackSite(this);
            hr = m_pPlayer->Init(m_pTIMEElementBase, m_pTIMEElementBase->GetBaseHREF(), psrc, NULL, valueNotSet, valueNotSet);
            (*iPlayer) = m_pPlayer;
            m_pPlayer.p->AddRef();

            fDone = true;
        }
        else
        {
            pItem = m_playList->GetItem(m_iCurrentPlayItem);
            if(pItem)
            {
                psrc = (LPOLESTR)pItem->GetSrc();
            }
            switch(m_playerType)
            {
                case PLAYER_CD:
                    m_pPlayer = CTIMEDshowCDPlayerProxy::CreateDshowCDPlayerProxy();
                    m_fHardware = false;
                    break;
                case PLAYER_DSHOW:
                    m_pPlayer = CTIMEDshowPlayerProxy::CreateDshowPlayerProxy();
                    m_fHardware = false;
                    break;
            }
            m_pPlayer->SetPlaybackSite(this);
            hr = m_pPlayer->Init(m_pTIMEElementBase, m_pTIMEElementBase->GetBaseHREF(), psrc, NULL, valueNotSet, valueNotSet);
            (*iPlayer) = m_pPlayer;
            m_pPlayer.p->AddRef();
            fDone = true;
        }
    }
    //m_pPlayer->Repeat();
    m_pTIMEElementBase -> FireMediaEvent(PE_ONMEDIATRACKCHANGED);

done:
    return S_OK;
}


HRESULT 
CTIMEPlayerNative::GetActiveTrack(long *index)
{
    *index = m_iCurrentPlayItem;
    return S_OK;
}


HRESULT
CTIMEPlayerNative::onMouseMove(long x, long y)
{
    HRESULT hr = S_OK;

    if(m_pPlayer)
    {
        hr = m_pPlayer->onMouseMove(x, y);
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::onMouseDown(long x, long y)
{
    HRESULT hr = S_OK;

    if(m_pPlayer)
    {
        hr = m_pPlayer->onMouseDown(x, y);
    }
    return hr;
}


void
CTIMEPlayerNative::PropChangeNotify(DWORD tePropType)
{
    if(m_pPlayer)
    {
        m_pPlayer->PropChangeNotify(tePropType);
    }
    return;
}

void 
CTIMEPlayerNative::ReadyStateNotify(LPWSTR szReadyState)
{
    //
    // Disable h/w rendering if filters attached. Filters can be queried only after onload
    //

    if (0 == StrCmpIW(szReadyState, L"onload"))
    {
        if (m_pTIMEElementBase == NULL)
        {
            goto done;
        }

        Assert(m_pTIMEElementBase);

        if (m_fHardware && m_pTIMEElementBase->IsFilterAttached())
        {
            RemovePlayer();
            m_fHardware = false;
            m_pPlayer = CTIMEDshowPlayerProxy::CreateDshowPlayerProxy();
            if(m_pPlayer)
            {
                IGNORE_HR(m_pPlayer->Init(m_pTIMEElementBase, m_lpbase, m_lpsrc, NULL, m_dblClipBegin, m_dblClipEnd));
            }
        }
    }

    if(m_pPlayer)
    {
        m_pPlayer->ReadyStateNotify(szReadyState);
    }
  done:
    return;
}


bool 
CTIMEPlayerNative::UpdateSync()
{
    if(m_pPlayer)
    {
        return m_pPlayer->UpdateSync();
    }
    return true;
}

void
CTIMEPlayerNative::Tick()
{
    if(m_pPlayer)
    {
        m_pPlayer->Tick();
    }
    return;
}

void
CTIMEPlayerNative::SetClipBegin(double dblClipBegin)
{
    CTIMEBasePlayer::SetClipBegin(dblClipBegin);

    if(m_pPlayer && !m_playList)
    {
        m_pPlayer->SetClipBegin(dblClipBegin);
    }
} // putClipBegin

void 
CTIMEPlayerNative::SetClipEnd(double dblClipEnd)
{
    CTIMEBasePlayer::SetClipEnd(dblClipEnd);

    if(m_pPlayer && !m_playList)
    {
        m_pPlayer->SetClipEnd(dblClipEnd);
    }
} // putClipEnd

void
CTIMEPlayerNative::SetClipBeginFrame(long lClipBegin)
{
    CTIMEBasePlayer::SetClipBeginFrame(lClipBegin);

    if(m_pPlayer && !m_playList)
    {
        m_pPlayer->SetClipBeginFrame(lClipBegin);
    }
} // putClipBegin

void 
CTIMEPlayerNative::SetClipEndFrame(long lClipEnd)
{
    CTIMEBasePlayer::SetClipEnd(lClipEnd);

    if(m_pPlayer && !m_playList)
    {
        m_pPlayer->SetClipEndFrame(lClipEnd);
    }
} // putClipEnd

void
CTIMEPlayerNative::LoadFailNotify(PLAYER_EVENT reason)
{

    switch(reason)
    {
    case PE_ONMEDIAERRORCOLORKEY:
        if (m_fHardware)
        {
            RemovePlayer();
            m_fHardware = false;
            m_pPlayer = CTIMEDshowPlayerProxy::CreateDshowPlayerProxy();
            if (m_pPlayer)
            {
                IGNORE_HR(m_pPlayer->Init(m_pTIMEElementBase, m_lpbase, m_lpsrc, NULL, m_dblClipBegin, m_dblClipEnd));
            }
        }
        break;
    }
    return;
}

/////////////////////////////////////////////////////////////////////////
//
// NotifyTransitionSite : from ITIMEPlayerIntegration
//
// Tells us that we need to teardown and rebuild
// if this playback site is to be filtered.
//
/////////////////////////////////////////////////////////////////////////
HRESULT 
CTIMEPlayerNative::NotifyTransitionSite (bool fTransitionToggle)
{
    // @@ ISSUE - does it make sense to force a 
    // teardown and rebuild when we might be able to use
    // hardware again?  If so, we'd need a way to do that.
    if (fTransitionToggle)
    {
        // Overloading the colorkey error method to effect
        // teardown and rebuild h/w to s/w.
        LoadFailNotify(PE_ONMEDIAERRORCOLORKEY);
    }

    return S_OK;
} // NotifyTransitionSite

bool
CTIMEPlayerNative::FindDVDPlayer()
{
    int i;
    bool fFound = false;
    CTIMEElementBase *pElm = (CTIMEElementBase *)(m_pTIMEElementBase->GetBody());
    CTIMEElementBase *pcElm = NULL;
    std::list<CTIMEElementBase*> nodeList;
    CComPtr <IHTMLElement> pEle;
    VARIANT vHardware;
    HRESULT hr = S_OK;

    VariantInit(&vHardware);

    nodeList.push_back(pElm);

    while( nodeList.size() > 0)
    {
        pElm = nodeList.front();
        if(pElm == NULL)
        {
            break;
        }
        nodeList.pop_front();
        pEle = pElm->GetElement();
        if(pEle == NULL)
        {
            break;
        }

        hr = pEle->getAttribute(L"player", 0, &vHardware);
        if (SUCCEEDED(hr))
        {
            if (vHardware.vt != VT_BSTR)
            {
                hr = VariantChangeType(&vHardware, &vHardware, 0, VT_BSTR);
            }
            if (SUCCEEDED(hr))
            {
                if (StrCmpIW(vHardware.bstrVal, L"DVD") == 0)
                {
                    fFound = true;
                    break;
                }
            }
        }
        VariantClear(&vHardware);

        for(i = 0; i < pElm->GetImmediateChildCount(); i++)
        {
            pcElm = pElm->GetChild(i);
            nodeList.push_back(pcElm);
        }
        pElm = NULL;
        pEle = NULL;
    }

    VariantClear(&vHardware);

    return fFound;
}


HRESULT
CTIMEPlayerNative::GetEarliestMediaTime(double &dblEarliestMediaTime)
{
    HRESULT hr = S_OK;
    dblEarliestMediaTime = 0;

    if(m_pPlayer)
    {
        hr = m_pPlayer->GetEarliestMediaTime(dblEarliestMediaTime);
    }
done:
    return hr;
}


HRESULT
CTIMEPlayerNative::GetLatestMediaTime(double &dblLatestMediaTime)
{
    HRESULT hr = S_OK;
    dblLatestMediaTime = 0;

    if(m_pPlayer)
    {
        hr = m_pPlayer->GetLatestMediaTime(dblLatestMediaTime);
    }
done:
    return hr;
}


HRESULT
CTIMEPlayerNative::GetMinBufferedMediaDur(double &dblMinBufferedMediaDur)
{
    HRESULT hr = S_OK;

    if(m_pPlayer)
    {
        hr = m_pPlayer->GetMinBufferedMediaDur(dblMinBufferedMediaDur);
    }
    return hr;
}


HRESULT
CTIMEPlayerNative::SetMinBufferedMediaDur(double dblMinBufferedMediaDur)
{
    HRESULT hr = S_OK;

    if(m_pPlayer)
    {
        hr = m_pPlayer->SetMinBufferedMediaDur(dblMinBufferedMediaDur);
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::GetDownloadTotal(LONGLONG &lldlTotal)
{
    HRESULT hr = S_OK;
    lldlTotal = 0;

    if(m_pPlayer)
    {
        hr = m_pPlayer->GetDownloadTotal(lldlTotal);
    }
    return hr;
}


HRESULT
CTIMEPlayerNative::GetDownloadCurrent(LONGLONG &lldlCurrent)
{
    HRESULT hr = S_OK;
    lldlCurrent = 0;

    if(m_pPlayer)
    {
        hr = m_pPlayer->GetDownloadCurrent(lldlCurrent);
    }
    return hr;
}


HRESULT
CTIMEPlayerNative::GetIsStreamed(bool &fIsStreamed)
{
    HRESULT hr = S_OK;
    fIsStreamed = false;

    if(m_pPlayer)
    {
        hr = m_pPlayer->GetIsStreamed(fIsStreamed);
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::GetBufferingProgress(double &dblBufferingProgress)
{
    HRESULT hr = S_OK;

    if(m_pPlayer)
    {
        hr = m_pPlayer->GetBufferingProgress(dblBufferingProgress);
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::GetHasDownloadProgress(bool &fHasDownloadProgress)
{
    HRESULT hr = S_OK;
    fHasDownloadProgress = false;

    if(m_pPlayer)
    {
        hr = m_pPlayer->GetHasDownloadProgress(fHasDownloadProgress);
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::GetMimeType(BSTR *pMime)
{
    HRESULT hr = S_OK;

    if(m_pPlayer)
    {
        hr = m_pPlayer->GetMimeType(pMime);
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::ConvertFrameToTime(LONGLONG iFrame, double &dblTime)
{
    HRESULT hr = S_OK;

    if(m_pPlayer)
    {
        hr = m_pPlayer->ConvertFrameToTime(iFrame, dblTime);
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::GetCurrentFrame(LONGLONG &lFrameNr)
{
    HRESULT hr = S_OK;

    if(m_pPlayer)
    {
        hr = m_pPlayer->GetCurrentFrame(lFrameNr);
    }
    return hr;
}

HRESULT
CTIMEPlayerNative::HasPlayList(bool &fhasPlayList)
{
    fhasPlayList = false;
    
    if (m_playList)
    {
        fhasPlayList = true;
    }
    else if(m_pPlayer)
    {
        m_pPlayer->HasPlayList(fhasPlayList);
    }

    return S_OK;
}

HRESULT
CTIMEPlayerNative::LoadAsx(WCHAR * pszFileName, WCHAR **ppwFileContent)
{
    HRESULT hr = S_OK;
    LPWSTR pszTrimmedName = NULL;
    TCHAR szCacheFileName[MAX_PATH+1];
    TCHAR *pwFileContent = NULL;
    OFSTRUCT fileStruct;
    BOOL fReadOk;
    char *pcFileContent = NULL;
    DWORD iFileLen, iHigh, iRead;
    HANDLE hFile;

    if (!pszFileName)
    {
        hr = E_INVALIDARG;
        goto done;
    }
    
    pszTrimmedName = TrimCopyString(pszFileName);
    if (NULL == pszTrimmedName)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    
    hr = URLDownloadToCacheFileW(NULL, 
                                 pszTrimmedName, 
                                 szCacheFileName, 
                                 MAX_PATH, 
                                 0, 
                                 this);
    if (FAILED(hr))
    {
        goto done;
    }

    //fileNameLen = wcslen(szCacheFileName);
    //pcFileName = new char( fileNameLen + 1);
    //WideCharToMultiByte(CP_ACP, 0, szCacheFileName, -1, pcFileName, fileNameLen, NULL, NULL);


    hFile = CreateFileW(szCacheFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if(hFile == INVALID_HANDLE_VALUE)
    {
        DWORD errorRes = GetLastError();
        hr = E_FAIL;
        goto done;
    }

    iFileLen = GetFileSize(hFile, NULL);

    pcFileContent = new char[iFileLen + 1];

    //Windows 656588 Prefix fix. a-thkesa // check for the return value.
    //new may return NULL.
    if(pcFileContent)
    {
        fReadOk = ReadFile(hFile, pcFileContent, iFileLen, &iRead, NULL);
        *(pcFileContent + iRead) = 0;

        pwFileContent = new TCHAR[iRead + 1];
        if(pwFileContent)
        {
             MultiByteToWideChar(CP_ACP, 0, pcFileContent, -1, pwFileContent, iRead);
             *(pwFileContent + iRead) = 0;
        }
        else
        {
             hr = E_OUTOFMEMORY;
        }
        delete[] pcFileContent;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }// End Fix

    CloseHandle(hFile);

    *ppwFileContent = pwFileContent;

done:
    delete [] pszTrimmedName;
    return hr;
}

HRESULT
CTIMEPlayerNative::AddToPlayList(CPlayList *pPlayList, WCHAR *pwFileContent, std::list<LPOLESTR> &asxList)
{
    HRESULT hr = S_OK;
    CTIMEParser pParser(pwFileContent);

    pParser.ParsePlayList(m_playList, false, &asxList);


#if DBG == 1
    for(long i = 0; i < m_playList->GetLength(); i++)
    {
        CPlayItem * pItem = m_playList->GetItem(i);
        if (pItem != NULL)
        {
            LPCWSTR lpwStr;
            
            TraceTag((tagError, "<Entry>"));
            lpwStr = pItem->GetTitle();
            if(lpwStr != NULL)
            {
                TraceTag((tagError, "  Title:<%S>", lpwStr));
            }
            lpwStr = pItem->GetAuthor();
            if(lpwStr != NULL)
            {
                TraceTag((tagError, "  Author:<%S>", lpwStr));
            }
            lpwStr = pItem->GetAbstract();
            if(lpwStr != NULL)
            {
                TraceTag((tagError, "  Abstract:<%S>", lpwStr));
            }
            lpwStr = pItem->GetSrc();
            if(lpwStr != NULL)
            {
                TraceTag((tagError, "  HREF:<%S>", lpwStr));
            }
            TraceTag((tagError, "</Entry>"));
        }
    }
#endif

    return hr;
}

HRESULT
CTIMEPlayerNative::CreatePlayList(WCHAR *pwFileContent, std::list<LPOLESTR> &asxList)
{
    CTIMEParser pParser(pwFileContent);
    HRESULT hr;
    
    if (!m_playList)
    {
        CComObject<CPlayList> * pPlayList;

        hr = THR(CComObject<CPlayList>::CreateInstance(&pPlayList));
        if (hr != S_OK)
        {
            goto done;
        }

        // Init the object
        hr = THR(pPlayList->Init(*this));
        if (FAILED(hr))
        {
            delete pPlayList;
            goto done;
        }

        // cache a pointer to the object
        m_playList = static_cast<CPlayList*>(pPlayList);
    }

    hr = pParser.ParsePlayList(m_playList, false, &asxList);

#if DBG == 1

    if (m_playList)
    {
        for(long i = 0; i < m_playList->GetLength(); i++)
        {
            CPlayItem * pItem = m_playList->GetItem(i);
            if (pItem != NULL)
            {
                LPCWSTR lpwStr;
                
                TraceTag((tagError, "<Entry>"));
                lpwStr = pItem->GetTitle();
                if(lpwStr != NULL)
                {
                    TraceTag((tagError, "  Title:<%S>", lpwStr));
                }
                lpwStr = pItem->GetAuthor();
                if(lpwStr != NULL)
                {
                    TraceTag((tagError, "  Author:<%S>", lpwStr));
                }
                lpwStr = pItem->GetAbstract();
                if(lpwStr != NULL)
                {
                    TraceTag((tagError, "  Abstract:<%S>", lpwStr));
                }
                lpwStr = pItem->GetSrc();
                if(lpwStr != NULL)
                {
                    TraceTag((tagError, "  HREF:<%S>", lpwStr));
                }
                TraceTag((tagError, "</Entry>"));
            }
        }
    }
#endif

done:
    return hr;
}

HRESULT
CTIMEPlayerNative::CreateCDPlayList()
{
    HRESULT hr;
    CComPtr<IWMPCDDeviceList>   spList;
    CComPtr<IWMPCDDevice>       spDevice;
    CComPtr<IWMPCDMediaInfo>    spMediaInfo;
    DWORD trackCount;
    CComPtr<CPlayItem> pPlayItem;
    int i;
    TCHAR *pSrc, pSrcNr[ 10];
    TCHAR *pTitle, *pMetaAddress = NULL;
    CComBSTR bstrCdIdentifier;
    int iLen;


    m_hinstWMPCD = LoadLibrary(WMPCD_DLL);
    if(m_hinstWMPCD)
    {
        m_WMPGetCDDeviceList = (WMPGETCDDEVICELISTP)GetProcAddress(m_hinstWMPCD, WMPGETCDDEVICELIST);
        if(m_WMPGetCDDeviceList)
        {
            hr = m_WMPGetCDDeviceList( &spList );
            if(FAILED(hr))
            {
                goto done;
            }
            hr = spList->GetDevice( 0, &spDevice );
            if(FAILED(hr))
            {
                goto done;
            }

            //  This call simply forces the device info block to be initialized.
            //
            hr = spDevice->GetMediaInfo( &spMediaInfo );
            if(FAILED(hr))
            {
                goto done;
            }

            hr = spMediaInfo->GetTrackCount(&trackCount);
            if(FAILED(hr))
            {
                goto done;
            }

            hr = spMediaInfo->GetDiscIdentifier( &bstrCdIdentifier);
            if(SUCCEEDED(hr))
            {
                iLen = lstrlenW(g_urlAddress) + lstrlenW(bstrCdIdentifier);
                pMetaAddress = new TCHAR[iLen + 1];
                StrCpyW(pMetaAddress, g_urlAddress);
                StrCatW(pMetaAddress, bstrCdIdentifier);
            }

        }
    }
	else
	{
		hr = E_FAIL;
		goto done;
	}
    
    if (!m_playList)
    {
        CComObject<CPlayList> * pPlayList;

        hr = THR(CComObject<CPlayList>::CreateInstance(&pPlayList));
        if (hr != S_OK)
        {
            goto done;
        }

        // Init the object
        hr = THR(pPlayList->Init(*this));
        if (FAILED(hr))
        {
            delete pPlayList;
            goto done;
        }

        // cache a pointer to the object
        m_playList = static_cast<CPlayList*>(pPlayList);
    }

    for( i = 0; i < trackCount; i++)
    {
        hr = THR(m_playList->CreatePlayItem(&pPlayItem));
        if (FAILED(hr))
        {
            goto done; //can't create playitems.
        }
        IGNORE_HR(m_playList->Add(pPlayItem, -1));

        _itow(i + 1, pSrcNr, 10);

        pSrc = new TCHAR[lstrlenW(L"wmpcd://0/") + lstrlenW( pSrcNr) + 1];
        StrCpyW(pSrc, L"wmpcd://0/");
        StrCatW(pSrc, pSrcNr);
        pPlayItem->PutSrc(pSrc);
        delete [] pSrc;

        pTitle = new TCHAR[lstrlenW(L"Title:") + lstrlenW( pSrcNr) + 1];
        StrCpyW(pTitle, L"Title:");
        StrCatW(pTitle, pSrcNr);
        pPlayItem->PutTitle(pTitle);
        pPlayItem.Release();
        delete [] pTitle;
    }

    if(pMetaAddress)
    {
        StartFileDownload(pMetaAddress, PLAYLIST_CD);
        delete [] pMetaAddress;
    }

#if DBG == 1
    for(long i = 0; i < m_playList->GetLength(); i++)
    {
        CPlayItem * pItem = m_playList->GetItem(i);
        if (pItem != NULL)
        {
            LPCWSTR lpwStr;
            
            TraceTag((tagError, "<Entry>"));
            lpwStr = pItem->GetTitle();
            if(lpwStr != NULL)
            {
                TraceTag((tagError, "  Title:<%S>", lpwStr));
            }
            lpwStr = pItem->GetAuthor();
            if(lpwStr != NULL)
            {
                TraceTag((tagError, "  Author:<%S>", lpwStr));
            }
            lpwStr = pItem->GetAbstract();
            if(lpwStr != NULL)
            {
                TraceTag((tagError, "  Abstract:<%S>", lpwStr));
            }
            lpwStr = pItem->GetSrc();
            if(lpwStr != NULL)
            {
                TraceTag((tagError, "  HREF:<%S>", lpwStr));
            }
            TraceTag((tagError, "</Entry>"));
        }
    }
#endif

done:

    if(FAILED(hr))
    {
        m_pTIMEElementBase -> FireMediaEvent(PE_ONMEDIAERROR);
    }

    return hr;
}

void 
CTIMEPlayerNative::FireMediaEvent(PLAYER_EVENT plEvent, ITIMEBasePlayer *pBasePlayer)
{
    CPlayItem * pItem = NULL;
    LPOLESTR psrc = NULL;
    HRESULT hr = S_OK;
    PlayerList::iterator iPlayer;
    ValidList::iterator iValid;
    DurList::iterator iDur;
    DurList::iterator iEfDur;
    ValidList::iterator iPlayed;
    int i;
    bool fDone = false;
    double dblMediaDur = 0.0;
    m_fHandlingEvent = true;
    bool fDonePlayList = false;
    RECT rctNativeSize;
    RECT rctFinalSize;
    bool fnativeSize;
    LPCWSTR pcTitle;
    BSTR pTitle = NULL;

    if(m_pPlayer == NULL)
    {
        goto done;
    }

    if(m_pPlayer != pBasePlayer)
    {
        goto done;
    }

    switch(plEvent)
    {
        case PE_ONMEDIAEND:
            if(!m_playList)
            {
                break;
            }

            SetEffectiveDur(true);

            m_iChangeUp = 1;
            m_iCurrentPlayItem++;
            if(m_iCurrentPlayItem >= m_playList->GetLength())
            {
                //end off play list
                TryNaturalDur();
                break;
            }

            iPlayer = playerList.begin();
            iValid = m_validList.begin();
            iPlayed = m_playedList.begin();
            iDur = m_durList.begin();
            iEfDur = m_effectiveDurList.begin();
            for(i = m_iCurrentPlayItem; i > 0; i--)
            {
                iPlayer++;
                iValid++;
                iPlayed++;
                iDur++;
                iEfDur++;
            }
            if((*iPlayer) == NULL)
            {
                pItem = m_playList->GetItem(m_iCurrentPlayItem);
                if(pItem)
                {
                    psrc = (LPOLESTR)pItem->GetSrc();
                }
                switch(m_playerType)
                {
                    case PLAYER_CD:
                        m_pPlayer = CTIMEDshowCDPlayerProxy::CreateDshowCDPlayerProxy();
                        m_fHardware = false;
                        break;
                    case PLAYER_DSHOW:
                        m_pPlayer = CTIMEDshowPlayerProxy::CreateDshowPlayerProxy();
                        m_fHardware = false;
                        break;
                }
                m_pPlayer->SetPlaybackSite(this);
                hr = m_pPlayer->Init(m_pTIMEElementBase, m_pTIMEElementBase->GetBaseHREF(), psrc, NULL, valueNotSet, valueNotSet);
                (*iPlayer) = m_pPlayer;
                m_pPlayer.p->AddRef();
                m_pTIMEElementBase -> FireMediaEvent(PE_ONMEDIATRACKCHANGED);
                fDone = true;
            }
            else
            {
                if((*iValid))
                {
                    (*iPlayer)->Stop(); //Replace player
                    THR((*iPlayer)->DetachFromHostElement());
                    (*iPlayer)->Release();
                    (*iPlayer) = NULL;
                    pItem = m_playList->GetItem(m_iCurrentPlayItem);
                    if(pItem)
                    {
                        psrc = (LPOLESTR)pItem->GetSrc();
                    }
                    switch(m_playerType)
                    {
                        case PLAYER_CD:
                            m_pPlayer = CTIMEDshowCDPlayerProxy::CreateDshowCDPlayerProxy();
                            m_fHardware = false;
                            break;
                        case PLAYER_DSHOW:
                            m_pPlayer = CTIMEDshowPlayerProxy::CreateDshowPlayerProxy();
                            m_fHardware = false;
                            break;
                    }
                    m_pPlayer->SetPlaybackSite(this);
                    hr = m_pPlayer->Init(m_pTIMEElementBase, m_pTIMEElementBase->GetBaseHREF(), psrc, NULL, valueNotSet, valueNotSet);
                    (*iPlayer) = m_pPlayer;
                    m_pPlayer.p->AddRef();


                    m_pTIMEElementBase -> FireMediaEvent(PE_ONMEDIATRACKCHANGED);

                    rctNativeSize.top = rctNativeSize.left = 0;
                    rctNativeSize.right = rctNativeSize.bottom = -1;
                    m_pTIMEElementBase->NegotiateSize(rctNativeSize, rctFinalSize, fnativeSize, true);
                }
                else
                {
                    (*iValid) = false;
                    (*iDur) = 0.0;
                    (*iEfDur) = 0.0;
                    (*iPlayed) = true;

                    if(m_iCurrentPlayItem == (m_playList->GetLength() - 1))
                    {
                        //end off play list
                        m_iCurrentPlayItem++;
                        TryNaturalDur();
                        break;
                    }
                    InternalSetActiveTrack(m_iCurrentPlayItem + 1, false);
                }
            }

            break;
        case PE_ONMEDIACOMPLETE:
            if(!m_fFiredMediaComplete)
            {
                m_fFiredMediaComplete = true;
                m_pTIMEElementBase -> FireMediaEvent(plEvent);
            }
            if(!m_playList)
            {
                break;
            }

            m_pTIMEElementBase -> FireMediaEvent(PE_ONTRACKCOMPLETE);
            m_playList->SetLoadedFlag(true);
            iPlayer = playerList.begin();
            iValid = m_validList.begin();
            iDur = m_durList.begin();
            for(i = m_iCurrentPlayItem; i > 0; i--)
            {
                iValid++;
                iDur++;
                iPlayer++;
            }
            (*iValid) = true;
            pItem = m_playList->GetItem(m_iCurrentPlayItem);

            hr = m_pPlayer->GetEffectiveLength(dblMediaDur);
            if(FAILED(hr))
            {
                m_fNoNaturalDur = true;
            }
            else
            {
                (*iDur) = dblMediaDur;
                if(pItem)
                {
                    pItem->PutDur(dblMediaDur);
                }
            }

            if(pItem)
            {
                pcTitle = pItem->GetTitle();
                if(pcTitle == NULL)
                {
                    hr = m_pPlayer->GetTitle(&pTitle);
                    if(SUCCEEDED(hr))
                    {
                        if(pTitle == NULL)
                        {
                            break;
                        }
                        IGNORE_HR(pItem->PutTitle(pTitle));
                    }
                }
            }


            //TryNaturalDur();

            break;
        case PE_ONMEDIAERROR:
            if(!m_playList)
            {
                m_pTIMEElementBase -> FireMediaEvent(plEvent);
                break;
            }
            iValid = m_validList.begin();
            iDur = m_durList.begin();
            iEfDur = m_effectiveDurList.begin();
            iPlayed = m_playedList.begin();
            for(i = m_iCurrentPlayItem; i > 0; i--)
            {
                iValid++;
                iDur++;
                iPlayed++;
                iEfDur++;
            }
            (*iValid) = false;
            (*iDur) = 0.0;
            (*iEfDur) = 0.0;
            (*iPlayed) = true;

            if(m_iCurrentPlayItem == (m_playList->GetLength() - 1))
            {
                //end off play list
                m_iCurrentPlayItem++;
                TryNaturalDur();
                break;
            }
            InternalSetActiveTrack(m_iCurrentPlayItem + m_iChangeUp, false);
            break;
        default:
            m_pTIMEElementBase -> FireMediaEvent(plEvent);
            break;
    }
done:
    m_fHandlingEvent = false;
    return;
}

void
CTIMEPlayerNative::SetEffectiveDur(bool finished)
{
    DurList::iterator iEfDur;
    ValidList::iterator iValid;
    ValidList::iterator iPlayed;
    int i;
    double dblEffDur = 0.0;
    HRESULT hr = S_OK;
    double dblMediaDur = 0.0;

    if(!m_pPlayer)
    {
        goto done;
    }

    if(m_iCurrentPlayItem == -1)
    {
        goto done;
    }

    iEfDur = m_effectiveDurList.begin();
    iValid = m_validList.begin();
    iPlayed = m_playedList.begin();
    for(i = m_iCurrentPlayItem; i > 0; i--)
    {
        iValid++;
        iEfDur++;
        iPlayed++;
    }

    if(*iValid != true)
    {
        goto done;
    }

    (*iPlayed) = true;

    hr = m_pPlayer->GetEffectiveLength(dblMediaDur);
    if(FAILED(hr))
    {
        dblMediaDur = 0.0;
    }

    if(finished)
    {
        *iEfDur += dblMediaDur;
        dblEffDur = *iEfDur;
        TraceTag((tagPlayerNativeEffDur,
                  "CTIMEPlayerNative(%lx)::CTIMEPlayerNative()-finished item(%d - %g)",
                  this, m_iCurrentPlayItem, dblEffDur));

    }
    else
    {
        *iEfDur += m_pPlayer->GetCurrentTime();
        dblEffDur = *iEfDur;
        TraceTag((tagPlayerNativeEffDur,
                  "CTIMEPlayerNative(%lx)::CTIMEPlayerNative()-notfinished item(%d - %g)",
                  this, m_iCurrentPlayItem, dblEffDur));
    }

done:
    return;
}

void
CTIMEPlayerNative::ResetEffectiveDur()
{
    DurList::iterator iEfDur;
    ValidList::iterator iPlayed;

    m_pTIMEElementBase->GetMMBvr().PutNaturalDur((double)TE_UNDEFINED_VALUE);
    m_pTIMEElementBase->clearNaturalDuration();
    for(iEfDur = m_effectiveDurList.begin(), iPlayed = m_playedList.begin();
        iEfDur != m_effectiveDurList.end(); iEfDur++, iPlayed++)
    {
        (*iEfDur) = 0.0;
        (*iPlayed) = false;
    }
}

void
CTIMEPlayerNative::TryNaturalDur()
{
    DurList::iterator iEfDur;
    ValidList::iterator iPlayed;
    double dblTotalDur = 0.0;
    bool fSetNaturalDur = true;

    if(m_fNoNaturalDur)
    {
        goto done;
    }

    for(iEfDur = m_effectiveDurList.begin(), iPlayed = m_playedList.begin();
        iEfDur != m_effectiveDurList.end(); iEfDur++, iPlayed++)
    {
        if((*iPlayed) == false)
        {
            fSetNaturalDur = false;
            break;
        }
        dblTotalDur += (*iEfDur);
    }

    if(fSetNaturalDur)
    {
        m_pTIMEElementBase->GetMMBvr().PutNaturalDur(dblTotalDur);
        m_pTIMEElementBase->setNaturalDuration();
    }

done:
    return;
}

void
CTIMEPlayerNative::SetNaturalDuration(double dblMediaLength)
{
    if(!m_playList)
    {
        m_pTIMEElementBase->GetMMBvr().PutNaturalDur(dblMediaLength);
        m_pTIMEElementBase->setNaturalDuration();
    }
}

void
CTIMEPlayerNative::ClearNaturalDuration()
{
    if(!m_playList)
    {
        m_pTIMEElementBase->GetMMBvr().PutNaturalDur((double)TE_UNDEFINED_VALUE);
        m_pTIMEElementBase->clearNaturalDuration();
    }
}


CTIMEPlayerNative *
CTIMEPlayerNative::GetNativePlayer()
{
    return this;
}


STDMETHODIMP
CTIMEPlayerNative::OnStartBinding( 
                                  /* [in] */ DWORD dwReserved,
                                  /* [in] */ IBinding __RPC_FAR *pib)
{
    HRESULT hr = S_OK;
    
    hr = S_OK;
done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMEPlayerNative::GetPriority( 
                               /* [out] */ LONG __RPC_FAR *pnPriority)
{
    HRESULT hr = S_OK;
    
    hr = S_OK;
done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMEPlayerNative::OnLowResource( 
                                 /* [in] */ DWORD reserved)
{
    HRESULT hr = S_OK;
    
    hr = S_OK;
done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMEPlayerNative::OnProgress( 
                              /* [in] */ ULONG ulProgress,
                              /* [in] */ ULONG ulProgressMax,
                              /* [in] */ ULONG ulStatusCode,
                              /* [in] */ LPCWSTR szStatusText)
{
    HRESULT hr = S_OK;
    
    if (m_fAbortDownload)
    {
        hr = E_ABORT;
        goto done;
    }

    hr = S_OK;
done:
    RRETURN1(hr, E_ABORT);
}

STDMETHODIMP
CTIMEPlayerNative::OnStopBinding( 
                                 /* [in] */ HRESULT hresult,
                                 /* [unique][in] */ LPCWSTR szError)
{
    HRESULT hr = S_OK;
    
    hr = S_OK;
done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMEPlayerNative::GetBindInfo( 
                               /* [out] */ DWORD __RPC_FAR *grfBINDF,
                               /* [unique][out][in] */ BINDINFO __RPC_FAR *pbindinfo)
{
    HRESULT hr = S_OK;
    
    hr = S_OK;
done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMEPlayerNative::OnDataAvailable( 
                                   /* [in] */ DWORD grfBSCF,
                                   /* [in] */ DWORD dwSize,
                                   /* [in] */ FORMATETC __RPC_FAR *pformatetc,
                                   /* [in] */ STGMEDIUM __RPC_FAR *pstgmed)
{
    HRESULT hr = S_OK;
    
    hr = S_OK;
done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMEPlayerNative::OnObjectAvailable( 
                                     /* [in] */ REFIID riid,
                                     /* [iid_is][in] */ IUnknown __RPC_FAR *punk)
{
    HRESULT hr = S_OK;
    
    hr = S_OK;
done:
    RRETURN(hr);
}


STDMETHODIMP
CTIMEPlayerNative::CueMedia()
{
    TraceTag((tagPlayerNative,
              "CTIMEDshowPlayer(%lx)::CueMedia()",
              this));
    const WCHAR * cpchSrc = NULL;
    HRESULT hr = S_OK;
    TCHAR szCacheFileName[MAX_PATH+1];
    BOOL fReadOk;
    VARIANT_BOOL bXmlFlag;
    VARIANT fileName;
    LPOLESTR szSrc = NULL;
    WCHAR *pwcFileContent = NULL;
    LPOLESTR pEntryRef = NULL;
    std::list<LPOLESTR> asxList;
    std::list<LPOLESTR> fileNameList;
    std::list<LPOLESTR>::iterator iFileList;

    TCHAR *pwFileContent = NULL;
    OFSTRUCT fileStruct;
    char *pcFileContent = NULL;
    DWORD iFileLen, iHigh, iRead;
    HANDLE hFile;


    VariantInit(&fileName);

    CComPtr<ITIMEImportMedia> spTIMEMediaPlayer;
    CComPtr<IStream> spStream;
    
    hr = THR(CoGetInterfaceAndReleaseStream(m_pTIMEMediaPlayerStream, IID_TO_PPV(ITIMEImportMedia, &spTIMEMediaPlayer)));
    m_pTIMEMediaPlayerStream = NULL; // no need to release, the previous call released the reference
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetAtomTable()->GetNameFromAtom(m_lSrc, &cpchSrc);
    if (FAILED(hr))
    {
        goto done;
    }
    switch(m_eAsynchronousType)
    {
    case PLAYLIST_CD:
        hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER,  IID_IXMLDOMDocument, (void**)&m_spXMLDoc);
        if (FAILED(hr))
        {
            goto done;
        }

        hr = URLDownloadToCacheFileW(NULL, 
                                     cpchSrc, 
                                     szCacheFileName, 
                                     MAX_PATH, 
                                     0, 
                                     this);
        if (FAILED(hr))
        {
            hr = spTIMEMediaPlayer->InitializeElementAfterDownload();
            goto done;
        }

        V_VT(&fileName) = VT_BSTR;
        V_BSTR(&fileName) = SysAllocString(szCacheFileName);
        hr = m_spXMLDoc->load(fileName, &bXmlFlag);
        if (FAILED(hr))
        {
            hr = spTIMEMediaPlayer->InitializeElementAfterDownload();
            goto done;
        }
        break;
    case PLAYLIST_ASX:
            hr = LoadAsx((WCHAR *)cpchSrc, &pwcFileContent);
            if(FAILED(hr))
            {
                m_fDownloadError = true;
                hr = spTIMEMediaPlayer->InitializeElementAfterDownload();
                goto done;
            }
            hr = CreatePlayList(pwcFileContent, asxList);
            if(FAILED(hr))
            {
                m_fDownloadError = true;
                hr = spTIMEMediaPlayer->InitializeElementAfterDownload();
                goto done;
            }
            delete [] pwcFileContent;
            pwcFileContent = NULL;

            while(!asxList.empty())
            {
                pEntryRef = asxList.back();
                asxList.pop_back();

                for(iFileList = asxList.begin(); iFileList != asxList.end(); iFileList++)
                {
                    if(StrCmpIW((*iFileList), pEntryRef) == 0)
                    {
                        continue;
                    }
                }

                fileNameList.push_back(pEntryRef);

                hr = LoadAsx(pEntryRef, &pwcFileContent);

                pEntryRef = NULL;
                if(FAILED(hr))
                {
                    hr = S_OK;
                    break;
                }
                pEntryRef = NULL;
                if(!m_playList)
                {
                    hr = S_OK;
                    break;
                }
                hr = AddToPlayList(m_playList, pwcFileContent, asxList);
                if(FAILED(hr))
                {
                    hr = S_OK;
                    break;
                }
                delete [] pwcFileContent;
                pwcFileContent = NULL;
            }
            break;
    case MIMEDISCOVERY_ASYNCH:
        {
            // could not determine mime type from the extension.  Try to download the file to get type
            TCHAR szCacheFileName[MAX_PATH+1];
            
            CComPtr<CTIMEBindStatusCallback> pbsc;
            hr = CTIMEBindStatusCallback::CreateTIMEBindStatusCallback(&pbsc);
            if (FAILED(hr))
            {
                goto done;
            }
            
            pbsc->StopAfter(BINDSTATUS_MIMETYPEAVAILABLE);
            
            // this bind is being E_ABORTed - therefore, ignore the error.
            IGNORE_HR(URLDownloadToCacheFileW(NULL, cpchSrc, szCacheFileName, MAX_PATH, 0, pbsc));
            
            Assert(NULL == m_pszDiscoveredMimeType);
            m_pszDiscoveredMimeType = pbsc->GetStatusText() ? ::CopyString(pbsc->GetStatusText()) : NULL;
            if (NULL == m_pszDiscoveredMimeType)
            {
                // either out of memory, or we weren't able to get the mime type.
                hr = spTIMEMediaPlayer->InitializeElementAfterDownload();
                goto done;
            }

            if(StrCmpIW(m_pszDiscoveredMimeType, L"video/x-ms-asf") == 0)
            {
                hFile = CreateFileW(szCacheFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
                if(hFile == INVALID_HANDLE_VALUE)
                {
                    break;
                }

                iFileLen = GetFileSize(hFile, NULL);
                if(iFileLen > 1024)
                {
                    iFileLen = 1024;
                }

                pcFileContent = new char[iFileLen + 1];
                fReadOk = ReadFile(hFile, pcFileContent, iFileLen, &iRead, NULL);
                if((fReadOk == 0) || (iFileLen == 0))
                {
                    m_fDownloadError = true;
                    goto done;
                }

                *(pcFileContent + iRead) = 0;

                pwFileContent = new TCHAR[iRead + 1];
                MultiByteToWideChar(CP_ACP, 0, pcFileContent, -1, pwFileContent, iRead);
                *(pwFileContent + iRead) = 0;

                if(IsDownloadAsx(pwFileContent))
                {
                    delete[] m_pszDiscoveredMimeType;
                    m_pszDiscoveredMimeType = ::CopyString( L"asx");
                }
            }

            break;
        }
    default:
        break;
    }

    hr = spTIMEMediaPlayer->InitializeElementAfterDownload();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    delete [] m_pszDiscoveredMimeType;
    m_pszDiscoveredMimeType = NULL;

    delete [] pwcFileContent;
    pwcFileContent = NULL;

    delete [] pcFileContent;
    pcFileContent = NULL;

    delete [] pwFileContent;
    pwFileContent = NULL;

    VariantClear(&fileName);

    while(!fileNameList.empty())
    {
        pEntryRef = fileNameList.front();
        fileNameList.pop_front();
        delete [] pEntryRef;
        pEntryRef = NULL;
    }
    return hr;
}

bool
CTIMEPlayerNative::IsDownloadAsx(TCHAR *pwFileContent)
{
    CTIMEParser pParser(pwFileContent);
    HRESULT hr;
    bool fRet = true;

    hr = pParser.ParsePlayList(NULL, true, NULL);
    if(FAILED(hr))
    {
        fRet = false;
    }
    return fRet;
}

STDMETHODIMP
CTIMEPlayerNative::GetUniqueID(long * plID)
{
    HRESULT hr = S_OK;
/*
    Assert(NULL != plID);

    *plID = m_lSrc;
*/
    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP
CTIMEPlayerNative::GetPriority(double * pdblPriority)
{
    HRESULT hr = S_OK;

    if (NULL == pdblPriority)
    {
        return E_POINTER;
    }

    if (m_fHavePriority)
    {
        *pdblPriority = m_dblPriority;
    }
    
    Assert(m_pTIMEElementBase != NULL);
    Assert(NULL != m_pTIMEElementBase->GetElement());

    *pdblPriority = INFINITE;

    CComVariant varAttribute;
    
    hr = m_pTIMEElementBase->base_get_begin(&varAttribute);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = VariantChangeType(&varAttribute, &varAttribute, 0, VT_R8);
    if (FAILED(hr))
    {
        if ( DISP_E_TYPEMISMATCH == hr)
        {
            hr = S_OK;
        }
        goto done;
    }
    
    // either they set a priority or a begin time!
    *pdblPriority = varAttribute.dblVal;

    m_dblPriority = *pdblPriority;
    m_fHavePriority = true;

    hr = S_OK;
done:
    return hr;
}


STDMETHODIMP
CTIMEPlayerNative::GetMediaDownloader(ITIMEMediaDownloader ** ppImportMedia)
{
    HRESULT hr = S_OK;

    Assert(NULL != ppImportMedia);

    *ppImportMedia = NULL;

    hr = S_FALSE;
done:
    return hr;
}

STDMETHODIMP
CTIMEPlayerNative::PutMediaDownloader(ITIMEMediaDownloader * pImportMedia)
{
    HRESULT hr = S_OK;
    
    hr = E_NOTIMPL;
done:
    return hr;
}


STDMETHODIMP
CTIMEPlayerNative::CanBeCued(VARIANT_BOOL * pVB_CanCue)
{
    HRESULT hr = S_OK;

    if (NULL == pVB_CanCue)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    *pVB_CanCue = VARIANT_TRUE;
    
    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP
CTIMEPlayerNative::MediaDownloadError()
{
    return S_OK;
}

STDMETHODIMP
CTIMEPlayerNative::InitializeElementAfterDownload()
{
    HRESULT hr = S_OK;
    CComPtr<IXMLDOMDocument> spXMLDoc;
    CComPtr<IXMLDOMNodeList> spXMLNodeList;
    IXMLDOMNode *pCurrNode, *pChildNode;
    IXMLDOMNodeList *pChildList = NULL;
    DOMNodeType nodeType;
    long i, lTrackNr;
    long j, lChildNr;
    long lactiveTrack = 0;
    CComBSTR trackTag = SysAllocString(L"track");
    CComBSTR bstrName;
    CComBSTR bstrText;
    VARIANT varVal;
    int iPlLen = 0, iLoopLen = 0;
    CPlayItem *pItem;
    LPOLESTR pBase, pSrc;
    PlayerList::iterator iPlayer;
    double dblClipBegin, dblClipEnd;

    TraceTag((tagPlayerNative, "CTIMEDshowPlayer(%lx)(%x)::InitializeElementAfterDownload",this));

    if(m_fRemoved)
    {
        hr = E_FAIL;
        goto done;
    }

    switch(m_eAsynchronousType)
    {
    case PLAYLIST_CD:
        if(!m_playList)
        {
            goto done;
        }

        if(m_fDownloadError)
        {
            break;
        }

        GetActiveTrack(&lactiveTrack);

        hr = m_spXMLDoc->getElementsByTagName(trackTag, &spXMLNodeList);
        if (FAILED(hr))
        {
            goto done;
        }

        hr = spXMLNodeList->get_length(&lTrackNr);
        if (FAILED(hr))
        {
            goto done;
        }

        iPlLen = m_playList->GetLength();
        if(iPlLen < lTrackNr)
        {
            iLoopLen = iPlLen;
        }
        else
        {
            iLoopLen = lTrackNr;
        }

        for(i = 0; i < iLoopLen; i++)
        {
            CPlayItem * pItem = m_playList->GetItem(i);

            if(pItem == NULL)
            {
                continue;
            }

            hr = spXMLNodeList->get_item(i, &pCurrNode);
            if(FAILED(hr))
            {
                continue;
            }
            hr = pCurrNode->get_nodeType(&nodeType);
            if(FAILED(hr))
            {
                continue;
            }
            if(nodeType != NODE_ELEMENT)
            {
                pCurrNode->Release();
                continue;
            }
            hr = pCurrNode->get_childNodes(&pChildList);
            if(FAILED(hr))
            {
                continue;
            }
            hr = pChildList->get_length(&lChildNr);
            if (FAILED(hr))
            {
                continue;
            }
            for(j = 0; j < lChildNr; j++)
            {
                hr = pChildList->get_item(j, &pChildNode);
                if (FAILED(hr))
                {
                    pChildNode->Release();
                    continue;
                }

                hr = pChildNode->get_nodeName(&bstrName);
                if (FAILED(hr))
                {
                    pChildNode->Release();
                    continue;
                }
                hr = pChildNode->get_text(&bstrText);
                if (FAILED(hr))
                {
                    pChildNode->Release();
                    continue;
                }
                if(i == lactiveTrack)
                {
                    m_pTIMEElementBase -> FireMediaEvent(PE_METAINFOCHANGED);
                }

                if(StrCmpIW(bstrName, L"name") == 0)
                {
                    pItem->PutTitle(bstrText);
                }

                if(StrCmpIW(bstrName, L"author") == 0)
                {
                    pItem->PutAuthor(bstrText);
                }

                pChildNode->Release();
            }
            pCurrNode->Release();
        }

        m_spXMLDoc.Release();
        m_spXMLDoc = NULL;
        break;
    case PLAYLIST_ASX:

        if(m_fDownloadError)
        {
            m_pTIMEElementBase -> FireMediaEvent(PE_ONMEDIAERROR);
            break;
        }

        if(m_playList)
        {
            //m_pPlayer->SetNativePlayer(this);
            CPlayItem * pItem = m_playList->GetItem(0);
            if (pItem == NULL)
            {
                hr = E_FAIL;
                goto done;
            }
        
            pSrc = (LPOLESTR)(pItem->GetSrc());
            if(pSrc == NULL)
            {
                hr = E_FAIL;
                goto done;
            }
            m_fHardware = false;
        }

        BuildPlayer(m_playerType);

        if(m_playList && m_pPlayer)
        {
            playerList.resize(m_playList->GetLength(), NULL);
            m_durList.resize(m_playList->GetLength(), -1.0);
            m_effectiveDurList.resize(m_playList->GetLength(), 0.0);
            m_validList.resize(m_playList->GetLength(), true);
            m_playedList.resize(m_playList->GetLength(), false);
            m_pPlayer->SetPlaybackSite(this);

            iPlayer = playerList.begin();
            (*iPlayer) = m_pPlayer;
            m_pPlayer.p->AddRef();
            m_pTIMEElementBase -> FireMediaEvent(PE_ONMEDIATRACKCHANGED);
            dblClipBegin = valueNotSet;
            dblClipEnd = valueNotSet;

            hr = m_pPlayer->Init(m_pTIMEElementBase, m_pTIMEElementBase->GetBaseHREF(), pSrc, NULL, dblClipBegin, dblClipEnd);
            delete [] m_lpbase;
            m_lpbase = NULL;
            delete [] m_lpsrc;
            m_lpsrc = CopyString(pSrc);
            delete [] m_lpmimetype;
            m_lpmimetype = NULL;
            m_dblClipEnd = dblClipEnd;
            m_dblClipBegin = dblClipBegin;
            m_iCurrentPlayItem = 0;

        }

        break;
    case MIMEDISCOVERY_ASYNCH:
        {
            if (NULL == m_pszDiscoveredMimeType)
            {
                if (m_pTIMEElementBase != NULL)
                {
                    m_pTIMEElementBase->FireMediaEvent(PE_ONMEDIAERROR);
                }
                hr = E_FAIL;
                goto done;
            }

            hr = THR(PlayerTypeFromMimeType(m_pszDiscoveredMimeType, m_lpbase, m_lpsrc, m_lpmimetype, &m_playerType));
            if (FAILED(hr))
            {
                goto done;
            }

            BuildPlayer(m_playerType);
            if (m_pPlayer)
            {
                const WCHAR * cpchSrc = NULL;
                LPOLESTR pszSrc = NULL;
                hr = GetAtomTable()->GetNameFromAtom(m_lSrc, &cpchSrc);
                if (FAILED(hr))
                {
                    goto done;
                }

                pszSrc = ::CopyString(cpchSrc);
                if (NULL == pszSrc)
                {
                    hr = E_OUTOFMEMORY;
                    goto done;
                }
                delete[] m_lpsrc;
                m_lpsrc = CopyString(pszSrc);

                hr = THR(m_pPlayer->Init(m_pTIMEElementBase, NULL, pszSrc, m_lpmimetype, m_dblClipBegin, m_dblClipEnd));
                if (FAILED(hr))
                {
                    if(m_fHardware == true)
                    {
                        RemovePlayer();
                        m_fHardware = false;
                        m_pPlayer = CTIMEDshowPlayerProxy::CreateDshowPlayerProxy();
                        hr = m_pPlayer->Init(m_pTIMEElementBase, NULL, pszSrc, m_lpmimetype, m_dblClipBegin, m_dblClipEnd);
                        delete [] pszSrc;
                        pszSrc = NULL;
                        if(FAILED(hr))
                        {
                            if (m_pTIMEElementBase != NULL)
                            {
                                m_pTIMEElementBase->FireMediaEvent(PE_ONMEDIAERROR);
                            }
                            goto done;
                        }
                    }
                    else
                    {
                        delete [] pszSrc;
                        pszSrc = NULL;
                    }
                    goto done;
                }
                else
                {
                    delete [] pszSrc;
                    pszSrc = NULL;
                }
            }

            break;
        }
    default:
       break;
    }

done:
    return hr;
}

HRESULT
CTIMEPlayerNative::StartFileDownload(LPOLESTR pFileName, AsynchronousTypes eaType)
{
    HRESULT hr = S_OK;

    hr = THR(CoMarshalInterThreadInterfaceInStream(IID_ITIMEImportMedia, static_cast<ITIMEImportMedia*>(this), &m_pTIMEMediaPlayerStream));
    if (FAILED(hr))
    {
        m_pTIMEMediaPlayerStream = NULL;
    }

    if(m_pTIMEMediaPlayerStream == NULL)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = GetAtomTable()->AddNameToAtomTable(pFileName, &m_lSrc);
    if (FAILED(hr))
    {
        goto done;
    }
    
    Assert(NULL != GetImportManager());
    m_eAsynchronousType = eaType;

    hr = GetImportManager()->Add(this);
    if (FAILED(hr))
    {
        goto done;
    }

done:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\playermc.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1998
//
//  File: src\time\src\playermc.h
//
//  Contents: HTML+TIME Player for the Music Center 
//
//------------------------------------------------------------------------------------

#pragma once

#include "playerbase.h"
#include "externuuids.h"

class CTIMEMediaElement;

class CTIMEMCPlayer :
    public CTIMEBasePlayer,
    public IDLXPlayEventSink
{
public:
    virtual ~CTIMEMCPlayer();
    CTIMEMCPlayer();

    //
    // IUnknown Methods
    //
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);
    STDMETHOD(QueryInterface)(REFIID refiid, void** ppv);

    //
    // CTIMEBasePlayer methods
    //
    HRESULT GetExternalPlayerDispatch(IDispatch **ppDisp);

    HRESULT Init(CTIMEMediaElement *pelem, LPOLESTR base, LPOLESTR src, LPOLESTR lpMimeType, double dblClipBegin = -1.0, double dblClipEnd = -1.0); //lint !e1735
    HRESULT DetachFromHostElement(void);

    virtual void OnTick(double dblSegmentTime,
                        LONG lCurrRepeatCount);
    void    Start();
    void    Stop();
    void    Pause();
    void    Resume();
    void    Repeat();
    HRESULT Reset();
    HRESULT Render(HDC hdc, LPRECT prc);

    HRESULT SetSrc(LPOLESTR base, LPOLESTR src);

    HRESULT SetSize(RECT* prect);

    double  GetCurrentTime();
    HRESULT GetCurrentSyncTime(double & dblSyncTime);
    HRESULT Seek(double dblTime);
    HRESULT GetMediaLength(double &dblLength);
    HRESULT CanSeek(bool& fcanSeek);

    HRESULT GetAuthor(BSTR* pAuthor);
    HRESULT GetTitle(BSTR* pTitle);
    HRESULT GetCopyright(BSTR* pCopyright);

    HRESULT GetVolume(float* pflVolume);
    HRESULT SetVolume(float flVolume);
    HRESULT GetBalance(float* pflBalance);
    HRESULT SetBalance(float flBalance);
    HRESULT GetMute(VARIANT_BOOL* pvarMute);
    HRESULT SetMute(VARIANT_BOOL varMute);

    //
    // Playlist methods
    //
    HRESULT FillPlayList(CPlayList *pPlayList);
    HRESULT SetActiveTrack(long index);
    HRESULT GetActiveTrack(long *index);

    //
    // IDLXPlayEventSink methods
    //
        STDMETHOD(OnDiscInserted)(long CDID);
    STDMETHOD(OnDiscRemoved)(long CDID);
    STDMETHOD(OnPause)(void);
    STDMETHOD(OnStop)(void);
    STDMETHOD(OnPlay)(void);
    STDMETHOD(OnTrackChanged)(short NewTrack);
    STDMETHOD(OnCacheProgress)(short CD, short Track, short PercentCompleted);
    STDMETHOD(OnCacheComplete)(short CD, short Track, short Status);

    virtual HRESULT CueMedia() { return E_NOTIMPL; }

protected:


    HRESULT GetPropertyFromDevicePlaylist (LPOLESTR wzPropertyName, BSTR *pbstrOut);
    HRESULT TranslateMCPlaylist (short siNumTracks, IMCPList *pimcPlayList, CPlayList *pitimePlayList);

    ULONG               m_cRef;
    CComPtr<IMCManager> m_spMCManager;
    CComPtr<IDLXPlay>   m_spMCPlayer;
    CTIMEMediaElement  *m_pcTIMEElem;
    bool                m_fInitialized;
    double              m_dblLocalTime;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\playernative.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: player.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/
#pragma once

#ifndef _PLAYERNATIVE_H
#define _PLAYERNATIVE_H

#include "playerbase.h"
#include "playlist.h"
#include "wmpcd.h"
#include "importman.h"

class CTIMEMediaElement;
typedef enum PlayerType
{
    PLAYER_IMAGE,
    PLAYER_DSHOW,
    PLAYER_WMP,
    PLAYER_DMUSIC,
    PLAYER_DVD,
    PLAYER_CD,
    PLAYER_DSHOWTEST,
    PLAYER_NONE
} tagPlayerType;

typedef enum AsynchronousTypes
{
    PLAYLIST_CD,
    PLAYLIST_ASX,
    MIMEDISCOVERY_ASYNCH,
    ASYNC_NONE
} tagAsynchronousTypes;
    

typedef std::list<ITIMEBasePlayer*> PlayerList;
typedef std::list<double> DurList;
typedef std::list<bool> ValidList;

typedef HRESULT (WINAPI *WMPGETCDDEVICELISTP)(IWMPCDDeviceList **ppList);  
//STDAPI WMPGetCDDeviceList( IWMPCDDeviceList **ppList );

/////////////////////////////////////////////////////////////////////////////
// CTTIMEPlayer

class
__declspec(uuid("efbad7f8-3f94-11d2-b948-00c04fa32195"))
CTIMEPlayerNative :
    public CTIMEBasePlayer,
    public CComObjectRootEx<CComSingleThreadModel>,
    public ITIMEImportMedia,
    public IBindStatusCallback
{
  public:
    CTIMEPlayerNative(PlayerType playerType);
    virtual ~CTIMEPlayerNative();

    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);
    STDMETHOD (QueryInterface)(REFIID refiid, void** ppunk)
        {   return _InternalQueryInterface(refiid, ppunk); };

    virtual HRESULT GetExternalPlayerDispatch(IDispatch **ppDisp);

    virtual HRESULT Init(CTIMEMediaElement *pelem, LPOLESTR base, LPOLESTR src, LPOLESTR lpMimeType, double dblClipBegin = -1.0, double dblClipEnd = -1.0); //lint !e1735
    virtual HRESULT DetachFromHostElement (void);
    virtual CTIMEPlayerNative *GetNativePlayer();
    
    virtual void Start();
    virtual void Stop();
    virtual void Pause();
    virtual void Resume();
    virtual void Repeat();
    virtual HRESULT Reset();
    virtual void PropChangeNotify(DWORD tePropType);
    virtual void ReadyStateNotify(LPWSTR szReadyState);
    virtual bool UpdateSync();
    virtual void Tick();
    virtual void LoadFailNotify(PLAYER_EVENT reason);
    virtual void FireMediaEvent(PLAYER_EVENT plEvent, ITIMEBasePlayer *pBasePlayer = NULL);
    virtual HRESULT Render(HDC hdc, LPRECT prc);

    virtual HRESULT SetSrc(LPOLESTR base, LPOLESTR src);
    virtual HRESULT SetSize(RECT *prect);

    virtual bool SetSyncMaster(bool fSyncMaster);

    virtual double GetCurrentTime();
    virtual HRESULT GetCurrentSyncTime(double & dblSyncTime);
    virtual HRESULT Seek(double dblTime);
    virtual HRESULT GetMediaLength(double &dblLength);
    virtual HRESULT CanSeek(bool &fcanSeek);
    virtual PlayerState GetState();
    virtual HRESULT HasMedia(bool &fHasMedia);
    virtual HRESULT HasVisual(bool &fHasVideo);
    virtual HRESULT HasAudio(bool &fHasAudio);
    virtual void SetClipBegin(double dblClipBegin);
    virtual void SetClipEnd(double dblClipEnd);
    virtual void SetClipBeginFrame(long lClipBeginFrame);
    virtual void SetClipEndFrame(long lClipEndFrame);

    virtual HRESULT IsBroadcast(bool &bisBroad);
    virtual HRESULT HasPlayList(bool &fhasPlayList);
    virtual HRESULT SetRate(double dblRate);
    virtual HRESULT GetRate(double &dblRate);

    virtual HRESULT GetNaturalHeight(long *height);
    virtual HRESULT GetNaturalWidth(long *width);

    virtual HRESULT GetAuthor(BSTR *pAuthor);
    virtual HRESULT GetTitle(BSTR *pTitle);
    virtual HRESULT GetCopyright(BSTR *pCopyright);
    virtual HRESULT GetAbstract(BSTR *pAbstract);
    virtual HRESULT GetRating(BSTR *pAbstract);

    virtual HRESULT GetVolume(float *pflVolume);
    virtual HRESULT SetVolume(float flVolume);
    virtual HRESULT GetMute(VARIANT_BOOL *pvarMute);
    virtual HRESULT SetMute(VARIANT_BOOL varMute);

    virtual HRESULT GetEarliestMediaTime(double &dblEarliestMediaTime);
    virtual HRESULT GetLatestMediaTime(double &dblLatestMediaTime);
    virtual HRESULT SetMinBufferedMediaDur(double MinBufferedMediaDur);
    virtual HRESULT GetMinBufferedMediaDur(double &MinBufferedMediaDur);
    virtual HRESULT GetDownloadTotal(LONGLONG &lldlTotal);
    virtual HRESULT GetDownloadCurrent(LONGLONG &lldlCurrent);
    virtual HRESULT GetIsStreamed(bool &fIsStreamed);
    virtual HRESULT GetBufferingProgress(double &dblBufferingProgress);
    virtual HRESULT GetHasDownloadProgress(bool &fHasDownloadProgress);
    virtual HRESULT GetMimeType(BSTR *pMime);
    virtual HRESULT ConvertFrameToTime(LONGLONG iFrame, double &dblTime);
    virtual HRESULT GetCurrentFrame(LONGLONG &lFrameNr);
    virtual HRESULT GetPlaybackOffset(double &dblOffset);
    virtual HRESULT GetEffectiveOffset(double &dblOffset);

    // 
    // ITIMEPlayerIntegration methods
    //
    virtual HRESULT NotifyTransitionSite (bool fTransitionToggle);

    virtual HRESULT GetPlayList(ITIMEPlayList **ppPlayList);

    // These are to make our internal implementation of playlists work
    // with all players
    virtual HRESULT SetActiveTrack(long index);
    virtual HRESULT GetActiveTrack(long *index);
    void SetNaturalDuration(double dblMediaLength);
    void ClearNaturalDuration();
    HRESULT GetPlayItemOffset(double &dblOffset);
    HRESULT GetPlayItemSeekOffset(double &dblOffset);

    virtual HRESULT onMouseMove(long x, long y);
    virtual HRESULT onMouseDown(long x, long y);

    BEGIN_COM_MAP(CTIMEPlayerNative)
        COM_INTERFACE_ENTRY(ITIMEImportMedia)
        COM_INTERFACE_ENTRY(IBindStatusCallback)
    END_COM_MAP_X();

    //
    // IBindStatusCallback
    //
    STDMETHOD(OnStartBinding)( 
            /* [in] */ DWORD dwReserved,
            /* [in] */ IBinding __RPC_FAR *pib);
        
    STDMETHOD(GetPriority)( 
            /* [out] */ LONG __RPC_FAR *pnPriority);
        
    STDMETHOD(OnLowResource)( 
            /* [in] */ DWORD reserved);
        
    STDMETHOD(OnProgress)( 
            /* [in] */ ULONG ulProgress,
            /* [in] */ ULONG ulProgressMax,
            /* [in] */ ULONG ulStatusCode,
            /* [in] */ LPCWSTR szStatusText);
        
    STDMETHOD(OnStopBinding)( 
            /* [in] */ HRESULT hresult,
            /* [unique][in] */ LPCWSTR szError);
        
    STDMETHOD(GetBindInfo)( 
            /* [out] */ DWORD __RPC_FAR *grfBINDF,
            /* [unique][out][in] */ BINDINFO __RPC_FAR *pbindinfo);
        
    STDMETHOD(OnDataAvailable)( 
            /* [in] */ DWORD grfBSCF,
            /* [in] */ DWORD dwSize,
            /* [in] */ FORMATETC __RPC_FAR *pformatetc,
            /* [in] */ STGMEDIUM __RPC_FAR *pstgmed);
        
    STDMETHOD(OnObjectAvailable)( 
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ IUnknown __RPC_FAR *punk);


    //
    // ITIMEImportMedia methods
    //
    STDMETHOD(CueMedia)();
    STDMETHOD(GetPriority)(double *);
    STDMETHOD(GetUniqueID)(long *);
    STDMETHOD(InitializeElementAfterDownload)();
    STDMETHOD(GetMediaDownloader)(ITIMEMediaDownloader ** ppImportMedia);
    STDMETHOD(PutMediaDownloader)(ITIMEMediaDownloader * pImportMedia);
    STDMETHOD(CanBeCued)(VARIANT_BOOL * pVB_CanCue);
    STDMETHOD(MediaDownloadError)();

  protected:
    HRESULT InternalSetActiveTrack(long index, bool fCheckSkip = true);
    void RemovePlayer();
    void RemovePlayList();
    void BuildPlayer(PlayerType playerType);
    HRESULT PlayerTypeFromMimeType(LPWSTR pszMime, LPOLESTR lpBase, LPOLESTR src, LPOLESTR lpMimeType, PlayerType * pType);
    PlayerType GetPlayerType(LPOLESTR base, LPOLESTR src, LPOLESTR lpMimeType);
    bool FindDVDPlayer();
    HRESULT LoadAsx(WCHAR * pszFileName, WCHAR **ppwFileContent);
    HRESULT CreatePlayList(WCHAR *ppwFileContent, std::list<LPOLESTR> &asxList);
    HRESULT AddToPlayList(CPlayList *pPlayList, WCHAR *pwFileContent, std::list<LPOLESTR> &asxList);
    HRESULT CreateCDPlayList();
    void TryNaturalDur();
    void SetEffectiveDur(bool finished);
    void ResetEffectiveDur();
    HRESULT StartFileDownload(LPOLESTR pFileName, AsynchronousTypes playListType);
    void GetPlayerNumber(double dblSeekTime, int &iPlNr);
    bool IsDownloadAsx(TCHAR *pwFileContent);
    CComPtr<ITIMEBasePlayer> m_pPlayer;
    bool m_fCanChangeSrc;
    PlayerType m_playerType;
    bool m_fHardware;

    static LONG m_fHPlayer;
    static LONG m_fHaveCD;

    //Player parameter block
    LPOLESTR m_lpsrc;
    LPOLESTR m_lpbase;
    LPOLESTR m_lpmimetype;
    double m_dblClipBegin;
    double m_dblClipEnd;

    LPOLESTR m_pszDiscoveredMimeType;

    bool m_fAbortDownload;
    DAComPtr<CPlayList> m_playList;
    PlayerList playerList;
    ValidList m_validList;
    DurList m_durList;
    DurList m_effectiveDurList;
    ValidList m_playedList;
    int m_iCurrentPlayItem;
    bool m_fFiredMediaComplete;
    int m_iChangeUp;
    bool m_fNoNaturalDur;
    bool m_fHandlingEvent;
    bool m_fDownloadError;
    bool m_fRemoved;

    HINSTANCE m_hinstWMPCD;
    WMPGETCDDEVICELISTP m_WMPGetCDDeviceList;

    LPSTREAM m_pTIMEMediaPlayerStream;
    bool m_fHavePriority;
    double m_dblPriority;
    long m_lSrc;
   
    AsynchronousTypes m_eAsynchronousType;

    CComPtr<IXMLDOMDocument> m_spXMLDoc;


  private:
    LONG m_cRef;
    CTIMEPlayerNative();
};

#endif /* _PLAYERBASE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\playerproxy.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 2000
//
//  File: src\time\media\playerproxy.h
//
//  Contents: declaration for CTIMEPlayerProxy
//
//------------------------------------------------------------------------------------
#pragma once

#ifndef _PLAYERDSHOWPROXY_H__
#define _PLAYERDSHOWPROXY_H__

#include "playerbase.h"

class CTIMEPlayerProxy :
    public ITIMEBasePlayer
{

  protected:
    // This class should never be NEW'ed.  
    // Instead create a specific proxy class derived from this class.
    CTIMEPlayerProxy();

  public:
    virtual ~CTIMEPlayerProxy();

    void Block();
    void UnBlock();
    bool CanCallThrough();
    ITIMEBasePlayer *GetInterface();

    //////////////////////////////////////////////////////////////////////////
    // OBJECT MANAGEMENT METHODS: BEGIN
    //////////////////////////////////////////////////////////////////////////
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);
    STDMETHOD (QueryInterface)(REFIID refiid, void** ppunk);
    virtual HRESULT Init(CTIMEMediaElement *pelem, 
                         LPOLESTR base, 
                         LPOLESTR src, 
                         LPOLESTR lpMimeType = NULL, 
                         double dblClipBegin = -1.0, 
                         double dblClipEnd = -1.0);
    virtual HRESULT DetachFromHostElement (void);
    virtual HRESULT GetExternalPlayerDispatch(IDispatch **ppDisp);
    //////////////////////////////////////////////////////////////////////////
    // OBJECT MANAGEMENT METHODS: END
    //////////////////////////////////////////////////////////////////////////
    
    //////////////////////////////////////////////////////////////////////////
    // EVENT HANDLING METHODS: BEGIN
    //////////////////////////////////////////////////////////////////////////
    virtual void Start();
    virtual void Stop();
    virtual void Pause();
    virtual void Resume();
    virtual void Repeat();
    virtual HRESULT Seek(double dblTime);
    //////////////////////////////////////////////////////////////////////////
    // EVENT HANDLING METHODS: END
    //////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////
    // PLAYER PLAYBACK CAPABILITIES: BEGIN
    //////////////////////////////////////////////////////////////////////////
    virtual HRESULT HasMedia(bool &fHasMedia);
    virtual HRESULT HasVisual(bool &fHasVideo);
    virtual HRESULT HasAudio(bool &fHasAudio);
    virtual HRESULT CanSeek(bool &fcanSeek);
    virtual HRESULT CanPause(bool &fcanPause);
    virtual HRESULT CanSeekToMarkers(bool &bcanSeekToM);
    virtual HRESULT IsBroadcast(bool &bisBroad);
    virtual HRESULT HasPlayList(bool &fHasPlayList);

    //////////////////////////////////////////////////////////////////////////
    // PLAYER PLAYBACK CAPABILITIES: END
    //////////////////////////////////////////////////////////////////////////
    
    //////////////////////////////////////////////////////////////////////////
    // STATE MANAGEMENT METHODS: BEGIN
    //////////////////////////////////////////////////////////////////////////
    virtual HRESULT Reset();
    virtual PlayerState GetState();
    virtual void PropChangeNotify(DWORD tePropType);
    virtual void ReadyStateNotify(LPWSTR szReadyState);
    virtual bool UpdateSync();
    virtual void Tick();
    //////////////////////////////////////////////////////////////////////////
    // STATE MANAGEMENT METHODS: END
    //////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////
    // RENDER METHODS: BEGIN
    //////////////////////////////////////////////////////////////////////////
    virtual HRESULT Render(HDC hdc, LPRECT prc);
    virtual HRESULT GetNaturalHeight(long *height);
    virtual HRESULT GetNaturalWidth(long *width);
    virtual HRESULT SetSize(RECT *prect);
    //////////////////////////////////////////////////////////////////////////
    // RENDER METHODS: END
    //////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////
    // TIMING METHODS: BEGIN
    //////////////////////////////////////////////////////////////////////////
    virtual HRESULT GetMediaLength(double &dblLength);
    virtual HRESULT GetEffectiveLength(double &dblLength);
    virtual void GetClipBegin(double &dblClipBegin);
    virtual void SetClipBegin(double dblClipBegin);
    virtual void GetClipEnd(double &dblClipEnd);
    virtual void SetClipEnd(double dblClipEnd);
    virtual void GetClipBeginFrame(long &lClibBeginFrame);
    virtual void SetClipBeginFrame(long lClipBeginFrame);
    virtual void GetClipEndFrame(long &lClipEndFrame);
    virtual void SetClipEndFrame(long lClipEndFrame);
    virtual double GetCurrentTime();
    virtual HRESULT GetCurrentSyncTime(double & dblSyncTime);
    virtual HRESULT SetRate(double dblRate);
    virtual HRESULT GetRate(double &dblRate);
    virtual HRESULT GetPlaybackOffset(double &dblOffset);
    virtual HRESULT GetEffectiveOffset(double &dblOffset);
    //////////////////////////////////////////////////////////////////////////
    // TIMING METHODS: END
    //////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////
    // PROPERTY ACCESSORS: BEGIN
    //////////////////////////////////////////////////////////////////////////
    virtual HRESULT SetSrc(LPOLESTR base, LPOLESTR src);
    virtual HRESULT GetAuthor(BSTR *pAuthor);
    virtual HRESULT GetTitle(BSTR *pTitle);
    virtual HRESULT GetCopyright(BSTR *pCopyright);
    virtual HRESULT GetAbstract(BSTR *pAbstract);
    virtual HRESULT GetRating(BSTR *pRating) ;
    virtual HRESULT GetVolume(float *pflVolume);
    virtual HRESULT SetVolume(float flVolume);
#ifdef NEVER //dorinung 03-16-2000 bug 106458
    virtual HRESULT GetBalance(float *pflBalance);
    virtual HRESULT SetBalance(float flBalance);
#endif
    virtual HRESULT GetMute(VARIANT_BOOL *pvarMute);
    virtual HRESULT SetMute(VARIANT_BOOL varMute);
    virtual HRESULT Save(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);
    //////////////////////////////////////////////////////////////////////////
    // PROPERTY METHODS: END
    //////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////
    // INTEGRATION METHODS: BEGIN
    //////////////////////////////////////////////////////////////////////////
    virtual HRESULT NotifyTransitionSite (bool fTransitionToggle);
    //////////////////////////////////////////////////////////////////////////
    // INTEGRATION METHODS: END
    //////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////
    // PLAYLIST METHODS: BEGIN
    //////////////////////////////////////////////////////////////////////////
    virtual HRESULT GetPlayList(ITIMEPlayList **ppPlayList);
    //////////////////////////////////////////////////////////////////////////
    // PLAYLIST METHODS: END
    //////////////////////////////////////////////////////////////////////////

    virtual HRESULT GetEarliestMediaTime(double &dblEarliestMediaTime);
    virtual HRESULT GetLatestMediaTime(double &dblLatestMediaTime);
    virtual HRESULT SetMinBufferedMediaDur(double MinBufferedMediaDur);
    virtual HRESULT GetMinBufferedMediaDur(double &MinBufferedMediaDur);
    virtual HRESULT GetDownloadTotal(LONGLONG &lldlTotal);
    virtual HRESULT GetDownloadCurrent(LONGLONG &lldlCurrent);
    virtual HRESULT GetIsStreamed(bool &fIsStreamed);
    virtual HRESULT GetBufferingProgress(double &dblBufferingProgress);
    virtual HRESULT GetHasDownloadProgress(bool &fHasDownloadProgress);
    virtual HRESULT GetMimeType(BSTR *pMime);
    virtual HRESULT ConvertFrameToTime(LONGLONG iFrame, double &dblTime);
    virtual HRESULT GetCurrentFrame(LONGLONG &lFrameNr);
    virtual HRESULT GetDownloadProgress(double &dblDownloadProgress);

    virtual HRESULT onMouseMove(long x, long y);
    virtual HRESULT onMouseDown(long x, long y);

    virtual void LoadFailNotify(PLAYER_EVENT reason);
    virtual void SetPlaybackSite(CTIMEBasePlayer *pSite);
    virtual void FireMediaEvent(PLAYER_EVENT plEvent, ITIMEBasePlayer *pBasePlayer = NULL);

  protected:
    virtual HRESULT Init();

    ITIMEBasePlayer *m_pBasePlayer;
    CTIMEBasePlayer *m_pNativePlayer;

  private:

    CritSect            m_CriticalSection;
    bool                m_fBlocked;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\playerproxy.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 2000
//
//  File: src\time\media\playerproxy.h
//
//  Contents: implementation of CTIMEPlayerProxy
//
//------------------------------------------------------------------------------------
#include "headers.h"

#include "playerproxy.h"

DeclareTag(tagPlayerProxy, "TIME: PlayerProxy", "CTIMEPlayerProxy method")

#define ENTER_METHOD \
    Assert(NULL != m_pBasePlayer); \
    CritSectGrabber cs(m_CriticalSection);


CTIMEPlayerProxy::CTIMEPlayerProxy() :
  m_pBasePlayer(NULL),
  m_pNativePlayer(NULL),
  m_fBlocked(false)
{
}

CTIMEPlayerProxy::~CTIMEPlayerProxy()
{
    m_pBasePlayer = NULL;
}

HRESULT
CTIMEPlayerProxy::Init()
{
    return S_OK;
}

STDMETHODIMP_(ULONG)
CTIMEPlayerProxy::AddRef()
{
    Assert(NULL != m_pBasePlayer);
    return m_pBasePlayer->AddRef();
}
STDMETHODIMP_(ULONG)
CTIMEPlayerProxy::Release()
{
    Assert(NULL != m_pBasePlayer);
    return m_pBasePlayer->Release();
}

STDMETHODIMP
CTIMEPlayerProxy::QueryInterface(REFIID riid, void ** ppunk)
{
    Assert(NULL != m_pBasePlayer);
    return m_pBasePlayer->QueryInterface(riid, ppunk);
}

HRESULT
CTIMEPlayerProxy::Init(CTIMEMediaElement* pelem,
                       LPOLESTR base, 
                       LPOLESTR src, 
                       LPOLESTR lpMimeType, 
                       double dblClipBegin, 
                       double dblClipEnd)
{
    Assert(NULL != m_pBasePlayer);
    return m_pBasePlayer->Init(pelem, base, src, lpMimeType, dblClipBegin, dblClipEnd);
}

HRESULT
CTIMEPlayerProxy::DetachFromHostElement()
{
    m_pNativePlayer = NULL;
    Assert(NULL != m_pBasePlayer);
    return m_pBasePlayer->DetachFromHostElement();
}

HRESULT
CTIMEPlayerProxy::GetExternalPlayerDispatch(IDispatch** ppDisp)
{
    Assert(NULL != m_pBasePlayer);
    return m_pBasePlayer->GetExternalPlayerDispatch(ppDisp);
}

void
CTIMEPlayerProxy::Block()
{
    ENTER_METHOD

    m_fBlocked = true;
}

void
CTIMEPlayerProxy::UnBlock()
{
    ENTER_METHOD

    m_fBlocked = false;
}

bool
CTIMEPlayerProxy::CanCallThrough()
{
    return !m_fBlocked;
}

ITIMEBasePlayer*
CTIMEPlayerProxy::GetInterface()
{
    return m_pBasePlayer;
}

void
CTIMEPlayerProxy::SetPlaybackSite(CTIMEBasePlayer *pSite)
{
    m_pNativePlayer = pSite;
    if(m_pBasePlayer)
    {
        m_pBasePlayer->SetPlaybackSite(pSite);
    }
}

void
CTIMEPlayerProxy::FireMediaEvent(PLAYER_EVENT plEvent, ITIMEBasePlayer *pBasePlayer)
{
    CComPtr<ITIMEBasePlayer> spbasePlayer = static_cast<ITIMEBasePlayer*>(this);

    if(m_pNativePlayer)
    {
        m_pNativePlayer->FireMediaEvent(plEvent, spbasePlayer);
    }
}


#define DEFINE_METHOD(method) \
HRESULT \
CTIMEPlayerProxy::method() \
{ \
    ENTER_METHOD \
    TraceTag((tagPlayerProxy, "Entering CTIMEPlayerProxy::##method##(%p)", this)); \
    HRESULT hr; \
    \
    if (CanCallThrough()) \
    { \
        hr = m_pBasePlayer->method(); \
    } \
    else \
    { \
        hr = E_UNEXPECTED; \
    } \
    \
    RRETURN(hr); \
}

#define DEFINE_METHOD1(method, type1, arg1) \
HRESULT \
CTIMEPlayerProxy::method(type1 arg1) \
{ \
    ENTER_METHOD \
    TraceTag((tagPlayerProxy, "Entering CTIMEPlayerProxy::##method##(%p)", this)); \
    HRESULT hr; \
\
    if (CanCallThrough()) \
    { \
        hr = m_pBasePlayer->method(arg1); \
    } \
    else \
    { \
        hr = E_UNEXPECTED; \
    } \
\
    RRETURN( hr ); \
}

#define DEFINE_METHOD2(method, type1, arg1, type2, arg2) \
HRESULT \
CTIMEPlayerProxy::method(type1 arg1, type2 arg2) \
{ \
    ENTER_METHOD \
    TraceTag((tagPlayerProxy, "Entering CTIMEPlayerProxy::##method##(%p)", this)); \
    HRESULT hr; \
\
    if (CanCallThrough()) \
    { \
        hr = m_pBasePlayer->method(arg1, arg2); \
    } \
    else \
    { \
        hr = E_UNEXPECTED; \
    } \
\
    RRETURN( hr ); \
}

#define DEFINE_METHOD3(method, type1, arg1, type2, arg2, type3, arg3) \
HRESULT \
CTIMEPlayerProxy::method(type1 arg1, type2 arg2, type3 arg3) \
{ \
    ENTER_METHOD \
    TraceTag((tagPlayerProxy, "Entering CTIMEPlayerProxy::##method##(%p)", this)); \
    HRESULT hr; \
\
    if (CanCallThrough()) \
    { \
        hr = m_pBasePlayer->method(arg1, arg2, arg3); \
    } \
    else \
    { \
        hr = E_UNEXPECTED; \
    } \
\
    RRETURN( hr ); \
}

#define DEFINE_METHOD_(returntype, method) \
returntype \
CTIMEPlayerProxy::method() \
{ \
    ENTER_METHOD \
    TraceTag((tagPlayerProxy, "Entering CTIMEPlayerProxy::##method##(%p)", this)); \
    returntype retval = 0; \
    \
    if (CanCallThrough()) \
    { \
        retval = m_pBasePlayer->method(); \
    } \
    return retval; \
}

#define DEFINE_METHOD_SPECIAL(returntype, defaultvalue, method) \
returntype \
CTIMEPlayerProxy::method() \
{ \
    ENTER_METHOD \
    TraceTag((tagPlayerProxy, "Entering CTIMEPlayerProxy::##method##(%p)", this)); \
    returntype retval = defaultvalue; \
    \
    if (CanCallThrough()) \
    { \
        retval = m_pBasePlayer->method(); \
    } \
    return retval; \
}

#define DEFINE_METHOD1_void(method, type1, arg1) \
void \
CTIMEPlayerProxy::method(type1 arg1) \
{ \
    ENTER_METHOD \
    TraceTag((tagPlayerProxy, "Entering CTIMEPlayerProxy::##method##(%p)", this)); \
    if (CanCallThrough()) \
    { \
        m_pBasePlayer->method(arg1); \
    } \
    return; \
}

#define DEFINE_METHOD_void(method) \
void \
CTIMEPlayerProxy::method() \
{ \
    ENTER_METHOD \
    TraceTag((tagPlayerProxy, "Entering CTIMEPlayerProxy::##method##(%p)", this)); \
    if (CanCallThrough()) \
    { \
        m_pBasePlayer->method(); \
    } \
    return; \
}


DEFINE_METHOD_void(Start);
DEFINE_METHOD_void(Stop);
DEFINE_METHOD_void(Pause);
DEFINE_METHOD_void(Resume);
DEFINE_METHOD_void(Repeat);
DEFINE_METHOD1(Seek, double, dblTime);

DEFINE_METHOD1(HasMedia, bool&, fHasMedia);
DEFINE_METHOD1(HasVisual, bool&, fHasVideo);
DEFINE_METHOD1(HasAudio, bool&, fHasAudio);
DEFINE_METHOD1(CanSeek, bool&, fCanSeek);
DEFINE_METHOD1(CanPause, bool&, fCanPause);
DEFINE_METHOD1(CanSeekToMarkers, bool&, bcanSeekToM);
DEFINE_METHOD1(IsBroadcast, bool&, bisBroad);
DEFINE_METHOD1(HasPlayList, bool&, fHasPlayList);

//DEFINE_METHOD(Reset);
//DEFINE_METHOD_SPECIAL(PlayerState, PLAYER_STATE_UNKNOWN, GetState);
DEFINE_METHOD1_void(PropChangeNotify, DWORD, tePropType);
DEFINE_METHOD1_void(ReadyStateNotify, LPWSTR, szReadyState);
DEFINE_METHOD_(bool, UpdateSync);
DEFINE_METHOD_void(Tick);

DEFINE_METHOD2(Render, HDC, hdc, LPRECT, prc);
DEFINE_METHOD1(GetNaturalHeight, long*, plHeight);
DEFINE_METHOD1(GetNaturalWidth, long*, plWidth);
DEFINE_METHOD1(SetSize, RECT*, prect);

DEFINE_METHOD1(GetMediaLength, double&,  dblLength);
DEFINE_METHOD1(GetEffectiveLength, double&, dblLength);
DEFINE_METHOD1_void(GetClipBegin, double&, dblClipBegin);
DEFINE_METHOD1_void(SetClipBegin, double, dblClipBegin);
DEFINE_METHOD1_void(GetClipEnd, double&, dblClipEnd);
DEFINE_METHOD1_void(SetClipEnd, double, dblClipEnd);
DEFINE_METHOD1_void(GetClipBeginFrame, long&, lClipBegin);
DEFINE_METHOD1_void(SetClipBeginFrame, long, lClipBegin);
DEFINE_METHOD1_void(GetClipEndFrame, long&, lClipEnd);
DEFINE_METHOD1_void(SetClipEndFrame, long, lClipEnd);
DEFINE_METHOD_(double, GetCurrentTime); //lint !e123
//DEFINE_METHOD1(GetCurrentSyncTime, double&, dblSyncTime);
DEFINE_METHOD1(SetRate, double, dblRate);
DEFINE_METHOD1(GetRate, double&, dblRate);
DEFINE_METHOD1(GetEarliestMediaTime, double&, dblEarliestMediaTime);
DEFINE_METHOD1(GetLatestMediaTime, double&, dblLatestMediaTime);
DEFINE_METHOD1(SetMinBufferedMediaDur, double, dblMinBufferedMediaDur);
DEFINE_METHOD1(GetMinBufferedMediaDur, double&, dblMinBufferedMediaDur);
//DEFINE_METHOD1(GetDownloadTotal, LONGLONG&, lldlTotal);
//DEFINE_METHOD1(GetDownloadCurrent, LONGLONG&, lldlCurrent);
DEFINE_METHOD1(GetIsStreamed, bool&, fIsStreamed);
DEFINE_METHOD1(GetBufferingProgress, double&, dblBufferingProgress);
//DEFINE_METHOD1(GetHasDownloadProgress, bool&, fHasDownloadProgress);
DEFINE_METHOD1(GetMimeType, BSTR*, pAuthor);
DEFINE_METHOD2(ConvertFrameToTime, LONGLONG, iFrame, double&, dblTime);
DEFINE_METHOD1(GetCurrentFrame, LONGLONG&, frameNR);
DEFINE_METHOD1(GetPlaybackOffset, double&, dblOffset);
DEFINE_METHOD1(GetEffectiveOffset, double&, dblOffset);


DEFINE_METHOD2(SetSrc, LPOLESTR, base, LPOLESTR, src);
DEFINE_METHOD1(GetAuthor, BSTR*, pAuthor);
DEFINE_METHOD1(GetTitle, BSTR*, pTitle);
DEFINE_METHOD1(GetCopyright, BSTR*, pCopyright);
DEFINE_METHOD1(GetAbstract, BSTR*, pAbstract);
DEFINE_METHOD1(GetRating, BSTR*, pRating);
DEFINE_METHOD1(GetVolume, float*, pflVolume);
DEFINE_METHOD1(SetVolume, float, flVolume);
#ifdef NEVER //dorinung 03-16-2000 bug 106458
DEFINE_METHOD1(GetBalance, float*, pflBalance);
DEFINE_METHOD1(SetBalance, float, flBalance);
#endif
DEFINE_METHOD1(GetMute, VARIANT_BOOL *, pvarMute);
DEFINE_METHOD1(SetMute, VARIANT_BOOL, varMute);
DEFINE_METHOD3(Save, IPropertyBag2*, pPropBag, BOOL, fClearDirty, BOOL, fSaveAllProperties);

DEFINE_METHOD1(GetPlayList, ITIMEPlayList**, ppPlayList);

DEFINE_METHOD2(onMouseMove, long, x, long, y);
DEFINE_METHOD2(onMouseDown, long, x, long, y);

DEFINE_METHOD1_void(LoadFailNotify, PLAYER_EVENT, reason);


PlayerState
CTIMEPlayerProxy::GetState()
{
    ENTER_METHOD

    return m_pBasePlayer->GetState();
}

HRESULT
CTIMEPlayerProxy::Reset()
{
    ENTER_METHOD

    return m_pBasePlayer->Reset();
}

HRESULT
CTIMEPlayerProxy::GetCurrentSyncTime(double & dblSyncTime)
{
    ENTER_METHOD

    return m_pBasePlayer->GetCurrentSyncTime(dblSyncTime);
}



HRESULT
CTIMEPlayerProxy::GetDownloadTotal(LONGLONG &lldlTotal)
{
    ENTER_METHOD

    return m_pBasePlayer->GetDownloadTotal(lldlTotal);
}

HRESULT
CTIMEPlayerProxy::GetDownloadCurrent(LONGLONG &lldlCurrent)
{
    ENTER_METHOD

    return m_pBasePlayer->GetDownloadCurrent(lldlCurrent);
}


HRESULT
CTIMEPlayerProxy::GetHasDownloadProgress(bool &fHasDownloadProgress)
{
    ENTER_METHOD

    return m_pBasePlayer->GetHasDownloadProgress(fHasDownloadProgress);
}

HRESULT
CTIMEPlayerProxy::GetDownloadProgress(double &dblDownloadProgress)
{
    ENTER_METHOD

    return m_pBasePlayer->GetDownloadProgress(dblDownloadProgress);
}

HRESULT 
CTIMEPlayerProxy::NotifyTransitionSite (bool fTransitionToggle)
{
    ENTER_METHOD

    return m_pBasePlayer->NotifyTransitionSite(fTransitionToggle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\playlist.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * File: Playlist.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#include "headers.h"
#include "playlist.h"
#include "util.h"
#include "playerbase.h"

DeclareTag(tagPlayList, "TIME: Behavior", "CPlayList methods")
DeclareTag(tagPlayItem, "TIME: Behavior", "CPlayItem methods")

//*******************************************************************************
// *  CPlayList
// *******************************************************************************
CPlayList::CPlayList()
: m_rgItems(NULL),
  m_player(NULL),
  m_fLoaded(false)
{
    TraceTag((tagPlayList,
          "CPlayList(%lx)::CPlayList()",
          this));
}

///////////////////////////////////////////////////////////////
//  Name: ~CPlayList
// 
//  Abstract:  Handles destruction of the items array and
//             releasing all pointers in the array
///////////////////////////////////////////////////////////////
CPlayList::~CPlayList()
{
    TraceTag((tagPlayList,
        "CPlayList(%lx)::~CPlayList()",
        this));

    Deinit();

    delete m_rgItems;
    m_rgItems = NULL;
    m_player = NULL;
}

///////////////////////////////////////////////////////////////
//  Name: Init
// 
//  Abstract:  Handles allocation of the items array if it 
//             is ever accessed.
///////////////////////////////////////////////////////////////
HRESULT
CPlayList::Init(CTIMEBasePlayer & player)
{
    HRESULT hr;

    m_player = &player;
    
    if (m_rgItems == NULL)
    {
        m_rgItems = new CPtrAry<CPlayItem *>;
        if (m_rgItems == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }

    hr = S_OK;
  done:
    return hr;
}

void
CPlayList::Deinit()
{
    m_player = NULL;

    Clear();
}

///////////////////////////////////////////////////////////////
//  Name: SetLoaded
// 
//  Abstract:  sets a flag that marks whether the playlist is 
//             loaded or not.
///////////////////////////////////////////////////////////////
void 
CPlayList::SetLoaded(bool bLoaded)
{
    if (bLoaded != m_fLoaded)
    {
        m_fLoaded = bLoaded;

        if (m_fLoaded && V_VT(&m_vNewTrack) != VT_NULL)
        {
            IGNORE_HR(put_activeTrack(m_vNewTrack));
        }

        m_vNewTrack.Clear();
    }
}

///////////////////////////////////////////////////////////////
//  Name: SetLoaded
// 
//  Abstract:  sets a flag that marks whether the playlist is 
//             loaded or not.
///////////////////////////////////////////////////////////////
void 
CPlayList::SetLoadedFlag(bool bLoaded)
{
    if (bLoaded != m_fLoaded)
    {
        m_fLoaded = bLoaded;
    }
}

///////////////////////////////////////////////////////////////
//  Name: get_length
// 
//  Abstract:  returns the size of the array
///////////////////////////////////////////////////////////////
STDMETHODIMP
CPlayList::get_length(long *len)
{
    TraceTag((tagPlayList,
        "CPlayList(%lx)::get_length()",
        this));
    HRESULT hr = S_OK;

    CHECK_RETURN_NULL(len);

    *len = GetLength();

    hr = S_OK;

  done:

    return hr;
}

///////////////////////////////////////////////////////////////
//  Name: get__newEnum
// 
//  Abstract:  Creates the IEnumVARIANT class for this
//             collection.
///////////////////////////////////////////////////////////////
STDMETHODIMP
CPlayList::get__newEnum(IUnknown** p)
{
    TraceTag((tagPlayList,
        "CPlayList(%lx)::get__newEnum()",
        this));

    HRESULT hr;
    CComObject<CPlayListEnum> * pNewEnum;
    
    CHECK_RETURN_SET_NULL(p);

    hr = THR(CComObject<CPlayListEnum>::CreateInstance(&pNewEnum));
    if (hr != S_OK)
    {
        goto done;
    }

    // Init the object
    pNewEnum->Init(*this);

    hr = THR(pNewEnum->QueryInterface(IID_IUnknown, (void **)p));
    if (FAILED(hr))
    {
        delete pNewEnum;
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}

///////////////////////////////////////////////////////////////
//  Name: item
// 
//  Abstract:  returns the item requested by the pvarIndex.  
//             varIndex must be a valid integer value.or 
//             valid string title
///////////////////////////////////////////////////////////////
STDMETHODIMP
CPlayList::item(VARIANT varIndex, ITIMEPlayItem **pPlayItem)
{
    TraceTag((tagPlayList,
              "CPlayList(%lx)::item()",
              this));

    HRESULT hr;
    VARIANT vIndex;

    CHECK_RETURN_SET_NULL(pPlayItem);

    VariantInit(&vIndex);

    hr = THR(VariantChangeTypeEx(&vIndex, &varIndex, LCID_SCRIPTING, 0, VT_I4));
    if (SUCCEEDED(hr)) //handle the case of an index.
    {
        if (vIndex.lVal >= 0 && vIndex.lVal < m_rgItems->Size())
        {
            *pPlayItem = m_rgItems->Item(vIndex.lVal);
        } 
    }
    else
    {
        long lIndex;
        
        hr = THR(VariantChangeTypeEx(&vIndex, &varIndex, LCID_SCRIPTING, 0, VT_BSTR));
        if (FAILED(hr))
        {
            hr = S_OK;
            goto done;
        }

        lIndex = GetIndex(vIndex.bstrVal);
        if (lIndex != -1)
        {
            *pPlayItem = m_rgItems->Item(lIndex);
        }
    }
    
    if (*pPlayItem != NULL)
    {
        (*pPlayItem)->AddRef();
    } 
    
    hr = S_OK;
  done:

    VariantClear(&vIndex);
    return hr;
}

STDMETHODIMP
CPlayList::put_activeTrack(/*[in]*/ VARIANT vTrack)
{
    TraceTag((tagPlayList,
              "CPlayList(%lx)::put_activeTrack()",
              this));
    
    CComPtr <ITIMEPlayItem> pPlayItem;
    long index;
    HRESULT hr;

    // If not active then just ignore everything
    if (m_player == NULL ||
        !m_player->IsActive())
    {
        hr = S_OK;
        goto done;
    }
    
    // if this is not loaded, then delay setting of the track
    if (!m_fLoaded)
    {
        m_vNewTrack = vTrack;
        hr = S_OK;
        goto done; 
    }

    hr = item(vTrack, &pPlayItem);    
    if (FAILED(hr))
    {
        goto done;
    }

    if (pPlayItem == NULL)
    {
        hr = S_OK;
        goto done;
    }

    hr = THR(pPlayItem->get_index(&index));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_player->SetActiveTrack(index));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}

STDMETHODIMP
CPlayList::get_activeTrack(/*[out, retval]*/ ITIMEPlayItem **pPlayItem)
{
    TraceTag((tagPlayList,
              "CPlayList(%lx)::get_activeTrack()",
              this));

    HRESULT hr;
    CPlayItem * p;

    CHECK_RETURN_SET_NULL(pPlayItem);

    if (m_player == NULL)
    {
        hr = S_OK;
        goto done;
    }
    
    p = GetActiveTrack();
    if (p == NULL)
    {
        hr = S_OK;
        goto done;
    }
    
    hr = THR(p->QueryInterface(IID_ITIMEPlayItem,
                               (void **) pPlayItem));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}

//Advances the active Track by one
STDMETHODIMP
CPlayList::nextTrack() 
{
    HRESULT hr;
    
    CPlayItem * pPlayItem;
    long lIndex;

    pPlayItem = GetActiveTrack();
    
    if (pPlayItem == NULL)
    {
        hr = S_OK;
        goto done;
    }

    hr = THR(pPlayItem->get_index(&lIndex));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_player->SetActiveTrack(lIndex + 1));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}

//moves the active track to the previous track
STDMETHODIMP
CPlayList::prevTrack() 
{
    HRESULT hr;
    
    CPlayItem * pPlayItem;
    long lIndex;

    pPlayItem = GetActiveTrack();
    
    if (pPlayItem == NULL)
    {
        hr = S_OK;
        goto done;
    }

    hr = THR(pPlayItem->get_index(&lIndex));
    if (FAILED(hr))
    {
        goto done;
    }

    if (lIndex > 0) //if this is not the first track
    {
        lIndex--;
    }

    hr = THR(m_player->SetActiveTrack(lIndex));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}

//returns the duration of the entire playlist if it is known or -1 if it is not.
STDMETHODIMP
CPlayList::get_dur(double *dur)
{
    HRESULT hr;
    int i;
    double totalDur = 0;

    CHECK_RETURN_NULL(dur);

    *dur = TIME_INFINITE;

    //loop through all playitems.  
    for (i = 0; i < GetLength(); i++)
    {
        double duration;
        CPlayItem * pPlayItem = GetItem(i);

        hr = THR(pPlayItem->get_dur(&duration));
        if (FAILED(hr))
        {
            goto done;          
        }
        
        if (duration == TIME_INFINITE)
        {
            goto done;      
        }
        
        totalDur += duration;
    }
    
    *dur = totalDur;

    hr = S_OK;
  done:
    return hr;
}

// ========================================
// Internal functions
// ========================================


//+-----------------------------------------------------------------------------------
//
//  Member:     CPlayList::NotifyPropertyChanged
//
//  Synopsis:   Notifies clients that a property has changed
//
//  Arguments:  dispid      DISPID of property that has changed      
//
//  Returns:    Success     when function completes successfully
//
//------------------------------------------------------------------------------------
HRESULT
CPlayList::NotifyPropertyChanged(DISPID dispid)
{
    HRESULT hr;

    CComPtr<IConnectionPoint> pICP;

    hr = FindConnectionPoint(IID_IPropertyNotifySink,&pICP); 
    if (SUCCEEDED(hr) && pICP != NULL)
    {
        hr = THR(NotifyPropertySinkCP(pICP, dispid));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done:
    RRETURN(hr);
} // NotifyPropertyChanged


CPlayItem *
CPlayList::GetActiveTrack()
{
    HRESULT hr;
    long l;
    CPlayItem * ppiRet = NULL;
    
    hr = THR(m_player->GetActiveTrack(&l));
    if (FAILED(hr))
    {
        goto done;
    }

    ppiRet = GetItem(l);
  done:
    return ppiRet;
}

CPlayItem *
CPlayList::GetItem(long index)
{
    CPlayItem * ppiRet = NULL;

    if (index >= 0 && index < m_rgItems->Size())
    {
        ppiRet = m_rgItems->Item(index);
    }

    return ppiRet;
}

HRESULT
CPlayList::Add(CPlayItem *pPlayItem, long index)
{
    TraceTag((tagPlayList,
        "CPlayList(%lx)::add()",
        this));
    HRESULT hr = S_OK;

    if (pPlayItem == NULL)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    pPlayItem->AddRef();
    if (index == -1)
    {
        m_rgItems->Append(pPlayItem);
    }
    else
    {
        m_rgItems->Insert(index, pPlayItem);
    }

    // notify that length changed
    IGNORE_HR(NotifyPropertyChanged(DISPID_TIMEPLAYLIST_LENGTH));

    SetIndex();
  done:
    return hr;
}


HRESULT
CPlayList::Remove(long index)
{
    TraceTag((tagPlayList,
              "CPlayList(%lx)::remove()",
              this));
    HRESULT hr;
    
    if (index >= 0 && index < m_rgItems->Size())
    {
        m_rgItems->Item(index)->Deinit();
        m_rgItems->ReleaseAndDelete(index);
    }

    // notify that length changed
    IGNORE_HR(NotifyPropertyChanged(DISPID_TIMEPLAYLIST_LENGTH));

    SetIndex();
    hr = S_OK;
  done:
    return hr;
}


//empties the current playlist.
void
CPlayList::Clear()
{
    if (m_rgItems)
    {
        while (m_rgItems->Size() > 0)
        {   //release and delete the first element of the list until there are no more elements
            m_rgItems->Item(0)->Deinit();
            m_rgItems->ReleaseAndDelete(0);  //release the 
        }
    }

    m_vNewTrack.Clear();
}


////////////////////////////////////////////////////////////////////////////////
// creates an empty playitem.  The info in this needs to be filled by the player.
// This also needs to be added to the playlist collection by the player.
////////////////////////////////////////////////////////////////////////////////
HRESULT
CPlayList::CreatePlayItem(CPlayItem **pPlayItem)
{   
    TraceTag((tagPlayList,
              "CPlayList(%lx)::createPlayItem()",
              this));

    HRESULT hr;
    CComObject<CPlayItem> * pItem;
    
    Assert(pPlayItem != NULL);

    hr = THR(CComObject<CPlayItem>::CreateInstance(&pItem));
    if (hr != S_OK)
    {
        goto done;
    }

    // Init the object
    pItem->Init(*this);

    *pPlayItem = static_cast<CPlayItem *>(pItem);
    pItem->AddRef();
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

void
CPlayList::SetIndex()
{
    long i = 0;
    long length = m_rgItems->Size();

    for (i = length-1; i >= 0; i--)
    {
        m_rgItems->Item(i)->PutIndex(i);
    }
}

long 
CPlayList::GetIndex(LPOLESTR lpstrTitle)
{
    long curIndex = -1;

    for(long i = GetLength()-1; i >= 0; i--)
    {
        CPlayItem * pItem = m_rgItems->Item(i);
        if (pItem != NULL)
        {
            LPCWSTR lpwTitle = pItem->GetTitle();
            
            if (lpwTitle != NULL &&
                StrCmpIW(lpwTitle, lpstrTitle) == 0)
            {
                curIndex = i;
                break;
            }
        }
    }

    return curIndex;
}

//*******************************************************************************
// *  CActiveElementEnum
// *******************************************************************************
CPlayListEnum::CPlayListEnum()
: m_lCurElement(0)
{
}



CPlayListEnum::~CPlayListEnum()
{
}


///////////////////////////////////////////////////////////////
//  Name: Clone
// 
//  Abstract:  Creates a new instance of this object and 
//             sets the m_lCurElement in the new object to
//             the same value as this object.
///////////////////////////////////////////////////////////////
STDMETHODIMP
CPlayListEnum::Clone(IEnumVARIANT **ppEnum)
{
    TraceTag((tagPlayList,
              "CPlayListEnum(%lx)::Clone()",
              this));

    HRESULT hr;
    CComObject<CPlayListEnum> * pNewEnum;
    
    CHECK_RETURN_SET_NULL(ppEnum);

    hr = THR(CComObject<CPlayListEnum>::CreateInstance(&pNewEnum));
    if (hr != S_OK)
    {
        goto done;
    }

    // Init the object
    pNewEnum->Init(*m_playList);

    pNewEnum->SetCurElement(m_lCurElement);

    hr = THR(pNewEnum->QueryInterface(IID_IEnumVARIANT, (void **)ppEnum));
    if (FAILED(hr))
    {
        delete pNewEnum;
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

///////////////////////////////////////////////////////////////
//  Name: Next
// 
//  Abstract:  
///////////////////////////////////////////////////////////////
STDMETHODIMP
CPlayListEnum::Next(unsigned long celt, VARIANT *rgVar, unsigned long *pCeltFetched)
{
    HRESULT hr = S_OK;
    unsigned long i = 0;
    long iCount = 0;
    
    CHECK_RETURN_NULL(rgVar);
    
    //initialize the list
    for (i = 0; i < celt; i++)
    {
        VariantInit(&rgVar[i]);   
    }

    for (i = 0; i < celt; i++)
    {    
        if (m_lCurElement < m_playList->GetLength())
        {
            CPlayItem * pPlayItem = m_playList->GetItem(m_lCurElement);

            Assert(pPlayItem != NULL);
            
            rgVar[i].vt = VT_DISPATCH;
            hr = THR(pPlayItem->QueryInterface(IID_IDispatch, (void **) &(rgVar[i].pdispVal)));
            if (FAILED(hr))
            {
                goto done;
            }

            m_lCurElement++;
            iCount++;
        }
        else
        {
            hr = S_FALSE;
            goto done;
        }
    }

    hr = S_OK;
  done:
    if (pCeltFetched != NULL)
    {
        *pCeltFetched = iCount;
    }

    return hr;
}

///////////////////////////////////////////////////////////////
//  Name: Reset
// 
//  Abstract:  
///////////////////////////////////////////////////////////////
STDMETHODIMP
CPlayListEnum::Reset()
{    
    m_lCurElement = 0;
    return S_OK;
}

///////////////////////////////////////////////////////////////
//  Name: Skip
// 
//  Abstract:  Skips the specified number of elements in the list.
//             This returns S_FALSE if there are not enough elements
//             in the list to skip.
///////////////////////////////////////////////////////////////
STDMETHODIMP
CPlayListEnum::Skip(unsigned long celt)
{
    HRESULT hr;
    long lLen = m_playList->GetLength();
    
    m_lCurElement += (long)celt;
    if (m_lCurElement >= lLen)
    {
        m_lCurElement = lLen;
        hr = S_FALSE;
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}


///////////////////////////////////////////////////////////////
//  Name: SetCurElement
// 
//  Abstract:  Sets the current index to the value specified
//             by celt.
///////////////////////////////////////////////////////////////
void
CPlayListEnum::SetCurElement(unsigned long celt)
{
    long lLen = m_playList->GetLength();

    m_lCurElement = (long)celt;
    if (m_lCurElement >= lLen)
    {
        m_lCurElement = lLen;
    }

    return;
}

//////////////////////////////////////////////////////
//  CPlayItem methods
//
CPlayItem::CPlayItem()
:   m_pPlayList(NULL),
    m_src(NULL),
    m_title(NULL),
    m_copyright(NULL),
    m_author(NULL),
    m_abstract(NULL),
    m_rating(NULL),
    m_lIndex(-1),
    m_dur(valueNotSet),
    m_fCanSkip(true),
    m_banner(NULL),
    m_bannerAbstract(NULL),
    m_bannerMoreInfo(NULL)
{
    TraceTag((tagPlayList,
              "CPlayItem(%lx)::CPlayItem()",
              this));
}

CPlayItem::~CPlayItem() 
{
    TraceTag((tagPlayList,
        "CPlayItem(%lx)::~CPlayItem()",
        this));

    m_pPlayList = NULL;
    delete [] m_src;
    delete [] m_title;
    delete [] m_copyright;
    delete [] m_author;
    delete [] m_abstract;
    delete [] m_rating;
    delete [] m_banner;
    delete [] m_bannerAbstract;
    delete [] m_bannerMoreInfo;
}

void 
CPlayItem::PutDur(double dur)
{ 
    m_dur = dur; 

    // notify that playlist's dur has changed
    if (m_pPlayList)
    {
        IGNORE_HR(m_pPlayList->NotifyPropertyChanged(DISPID_TIMEPLAYLIST_DUR));
    }

    IGNORE_HR(NotifyPropertyChanged(DISPID_TIMEPLAYITEM_DUR));
}


void 
CPlayItem::PutIndex(long index) 
{ 
    m_lIndex = index; 
    IGNORE_HR(NotifyPropertyChanged(DISPID_TIMEPLAYITEM_INDEX));
}


STDMETHODIMP
CPlayItem::setActive()
{
    TraceTag((tagPlayItem,
              "CPlayItem(%lx)::setActive()",
              this));

    VARIANT vIndex;
    HRESULT hr = S_OK;

    VariantInit(&vIndex);
    vIndex.vt = VT_I4;
    vIndex.lVal = m_lIndex;

    hr = m_pPlayList->put_activeTrack(vIndex);
    VariantClear(&vIndex);
    if (FAILED(hr))
    {   
        goto done;
    }   

    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CPlayItem::get_index(long *index)
{
    TraceTag((tagPlayItem,
              "CPlayItem(%lx)::get_index()",
              this));

    HRESULT hr;

    CHECK_RETURN_NULL(index);

    *index = m_lIndex;

    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CPlayItem::get_dur(double *dur)
{
    TraceTag((tagPlayItem,
              "CPlayItem(%lx)::get_dur()",
              this));

    HRESULT hr;

    CHECK_RETURN_NULL(dur);

    if (valueNotSet == m_dur)
    {
        *dur = TIME_INFINITE;
    }
    else
    {
        *dur = m_dur;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CPlayItem::get_src(LPOLESTR *src)
{
    TraceTag((tagPlayItem,
              "CPlayItem(%lx)::get_src()",
              this));

    HRESULT hr;

    CHECK_RETURN_SET_NULL(src);

    *src = SysAllocString(m_src?m_src:L"");

    if (*src == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN1(hr, E_OUTOFMEMORY);
}

STDMETHODIMP
CPlayItem::get_title(LPOLESTR *title)
{
    TraceTag((tagPlayItem,
              "CPlayItem(%lx)::get_title()",
              this));

    HRESULT hr;

    CHECK_RETURN_SET_NULL(title);

    *title = SysAllocString(m_title?m_title:L"");
    if (*title == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN1(hr, E_OUTOFMEMORY);
}

STDMETHODIMP
CPlayItem::get_copyright(LPOLESTR *cpyrght)
{
    TraceTag((tagPlayItem,
              "CPlayItem(%lx)::get_copyright()",
              this));

    HRESULT hr;

    CHECK_RETURN_SET_NULL(cpyrght);

    *cpyrght = SysAllocString(m_copyright?m_copyright:L"");
    if (*cpyrght == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN1(hr, E_OUTOFMEMORY);
}


STDMETHODIMP
CPlayItem::get_author(LPOLESTR *auth)
{
    TraceTag((tagPlayItem,
              "CPlayItem(%lx)::get_author()",
              this));

    HRESULT hr;

    CHECK_RETURN_SET_NULL(auth);

    *auth = SysAllocString(m_author?m_author:L"");
    if (*auth == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN1(hr, E_OUTOFMEMORY);
}

STDMETHODIMP
CPlayItem::get_banner(LPOLESTR *banner)
{
    TraceTag((tagPlayItem,
              "CPlayItem(%lx)::get_banner()",
              this));

    HRESULT hr;

    CHECK_RETURN_SET_NULL(banner);

    *banner = SysAllocString(m_banner?m_banner:L"");
    if (*banner == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN1(hr, E_OUTOFMEMORY);
}

STDMETHODIMP
CPlayItem::get_bannerAbstract(LPOLESTR *abstract)
{
    TraceTag((tagPlayItem,
              "CPlayItem(%lx)::get_bannerAbstract()",
              this));

    HRESULT hr;

    CHECK_RETURN_SET_NULL(abstract);

    *abstract = SysAllocString(m_bannerAbstract?m_bannerAbstract:L"");
    if (*abstract == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN1(hr, E_OUTOFMEMORY);
}

STDMETHODIMP
CPlayItem::get_bannerMoreInfo(LPOLESTR *moreInfo)
{
    TraceTag((tagPlayItem,
              "CPlayItem(%lx)::get_bannerMoreInfo()",
              this));

    HRESULT hr;

    CHECK_RETURN_SET_NULL(moreInfo);

    *moreInfo = SysAllocString(m_bannerMoreInfo?m_bannerMoreInfo:L"");
    if (*moreInfo == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN1(hr, E_OUTOFMEMORY);
}

STDMETHODIMP
CPlayItem::get_abstract(LPOLESTR *abstract)
{
    TraceTag((tagPlayItem,
              "CPlayItem(%lx)::get_abstract()",
              this));

    HRESULT hr;

    CHECK_RETURN_SET_NULL(abstract);

    *abstract = SysAllocString(m_abstract?m_abstract:L"");
    if (*abstract == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN1(hr, E_OUTOFMEMORY);
}

STDMETHODIMP
CPlayItem::get_rating(LPOLESTR *rate)
{
    TraceTag((tagPlayItem,
              "CPlayItem(%lx)::get_rating()",
              this));

    HRESULT hr;

    CHECK_RETURN_SET_NULL(rate);

    *rate = SysAllocString(m_rating?m_rating:L"");
    if (*rate == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN1(hr, E_OUTOFMEMORY);
}


HRESULT
CPlayItem::PutSrc(LPOLESTR src)
{
    HRESULT hr;
    
    delete m_src;
    m_src = NULL;
    
    if (src)
    {
        m_src = CopyString(src);
        if (m_src == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    
    IGNORE_HR(NotifyPropertyChanged(DISPID_TIMEPLAYITEM_SRC));

    hr = S_OK;
  done:
    RRETURN1(hr, E_OUTOFMEMORY);
}

HRESULT
CPlayItem::PutTitle(LPOLESTR title)
{
    HRESULT hr;
    
    delete m_title;
    m_title = NULL;
    
    if (title)
    {
        m_title = CopyString(title);
        if (m_title == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    
    IGNORE_HR(NotifyPropertyChanged(DISPID_TIMEPLAYITEM_TITLE));

    hr = S_OK;
  done:
    RRETURN1(hr, E_OUTOFMEMORY);
}

HRESULT
CPlayItem::PutCopyright(LPOLESTR copyright)
{
    HRESULT hr;
    
    delete m_copyright;
    m_copyright = NULL;
    
    if (copyright)
    {
        m_copyright = CopyString(copyright);
        if (m_copyright == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    
    IGNORE_HR(NotifyPropertyChanged(DISPID_TIMEPLAYITEM_COPYRIGHT));

    hr = S_OK;
  done:
    RRETURN1(hr, E_OUTOFMEMORY);
}

HRESULT
CPlayItem::PutAuthor(LPOLESTR author)
{
    HRESULT hr;
    
    delete m_author;
    m_author = NULL;
    
    if (author)
    {
        m_author = CopyString(author);
        if (m_author == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    
    IGNORE_HR(NotifyPropertyChanged(DISPID_TIMEPLAYITEM_AUTHOR));

    hr = S_OK;
  done:
    RRETURN1(hr, E_OUTOFMEMORY);
}

HRESULT
CPlayItem::PutAbstract(LPOLESTR abstract)
{
    HRESULT hr;
    
    delete m_abstract;
    m_abstract = NULL;
    
    if (abstract)
    {
        m_abstract = CopyString(abstract);
        if (m_abstract == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    
    IGNORE_HR(NotifyPropertyChanged(DISPID_TIMEPLAYITEM_ABSTRACT));

    hr = S_OK;
  done:
    RRETURN1(hr, E_OUTOFMEMORY);
}

HRESULT
CPlayItem::PutRating(LPOLESTR rating)
{
    HRESULT hr;
    
    delete m_rating;
    m_rating = NULL;
    
    if (rating)
    {
        m_rating = CopyString(rating);
        if (m_rating == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    
    IGNORE_HR(NotifyPropertyChanged(DISPID_TIMEPLAYITEM_RATING));

    hr = S_OK;
  done:
    RRETURN1(hr, E_OUTOFMEMORY);
}

HRESULT 
CPlayItem::PutBanner(LPWSTR banner, LPWSTR abstract, LPWSTR moreInfo)
{

    HRESULT hr;
    
    delete [] m_banner;
    delete [] m_bannerAbstract;
    delete [] m_bannerMoreInfo;
    
    m_banner = NULL;
    m_bannerAbstract = NULL;
    m_bannerMoreInfo = NULL;
    
    if (banner)
    {
        m_banner = CopyString(banner);
        if (m_banner == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
        
        if (abstract)
        {
            m_bannerAbstract = CopyString(abstract);
            if (m_bannerAbstract == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }
        
        }
        
        if (moreInfo)
        {
            m_bannerMoreInfo = CopyString(moreInfo);
            if (m_bannerMoreInfo == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }
        
        }
    }
    
    IGNORE_HR(NotifyPropertyChanged(DISPID_TIMEPLAYITEM_BANNER));

    hr = S_OK;
  done:
    RRETURN1(hr, E_OUTOFMEMORY);
}


//+-----------------------------------------------------------------------------------
//
//  Member:     CPlayItem::NotifyPropertyChanged
//
//  Synopsis:   Notifies clients that a property has changed
//
//  Arguments:  dispid      DISPID of property that has changed      
//
//  Returns:    Success     when function completes successfully
//
//------------------------------------------------------------------------------------
HRESULT
CPlayItem::NotifyPropertyChanged(DISPID dispid)
{
    HRESULT hr;

    CComPtr<IConnectionPoint> pICP;

    hr = FindConnectionPoint(IID_IPropertyNotifySink,&pICP); 
    if (SUCCEEDED(hr) && pICP != NULL)
    {
        hr = THR(NotifyPropertySinkCP(pICP, dispid));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done:
    RRETURN(hr);
} // NotifyPropertyChanged
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\playlistdelegator.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 2000
//
//  File: playlistdelegator.cpp
//
//  Contents: playlist object that delegates to the player's playlist object
//
//------------------------------------------------------------------------------------

#include "headers.h"
#include "playlistdelegator.h"


//+-------------------------------------------------------------------------------------
//
// CPlayListDelegator methods
//
//--------------------------------------------------------------------------------------

    
CPlayListDelegator::CPlayListDelegator() :
    m_pPlayList(NULL),
    m_dwAdviseCookie(0)
{

}


CPlayListDelegator::~CPlayListDelegator()
{
    DetachPlayList();
}


void 
CPlayListDelegator::AttachPlayList(ITIMEPlayList * pPlayList)
{
    // detach from the old play list
    DetachPlayList();

    if (pPlayList)
    {
        // cache the pointer 
        pPlayList->AddRef();
        m_pPlayList = pPlayList;

        // sign up for prop change notification
        IGNORE_HR(InitPropertySink());
    }
}


void 
CPlayListDelegator::DetachPlayList()
{
    if (m_pPlayList)
    {
        // unadvise prop change
        UnInitPropertySink();

        // release the cached ptr
        m_pPlayList->Release();
        m_pPlayList = NULL;
    }
}


HRESULT
CPlayListDelegator::GetPlayListConnectionPoint(IConnectionPoint **ppCP)
{
    HRESULT hr = E_FAIL;
    CComPtr<IConnectionPointContainer> spCPC;

    Assert(ppCP != NULL);

    CHECK_RETURN_SET_NULL(ppCP);

    if (!m_pPlayList)
    {
        goto done;
    }

    // Get connection point container
    hr = m_pPlayList->QueryInterface(IID_TO_PPV(IConnectionPointContainer, &spCPC));
    if(FAILED(hr))
    {
        goto done;
    }
    
    // Find the IPropertyNotifySink connection
    hr = spCPC->FindConnectionPoint(IID_IPropertyNotifySink, ppCP);
    if(FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}


HRESULT
CPlayListDelegator::InitPropertySink()
{
    HRESULT hr = S_OK;
    CComPtr<IConnectionPoint> spCP;

    // Find the IPropertyNotifySink connection
    hr = THR(GetPlayListConnectionPoint(&spCP));
    if(FAILED(hr))
    {
        goto done;
    }

    // Advise on it
    hr = spCP->Advise(GetUnknown(), &m_dwAdviseCookie);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    RRETURN(hr);
}

HRESULT
CPlayListDelegator::UnInitPropertySink()
{
    HRESULT hr = S_OK;
    CComPtr<IConnectionPoint> spCP;

    if (0 == m_dwAdviseCookie)
    {
        goto done;
    }

    // Find the IPropertyNotifySink connection
    hr = THR(GetPlayListConnectionPoint(&spCP));
    if(FAILED(hr) || NULL == spCP.p)
    {
        goto done;
    }

    // Unadvise on it
    hr = spCP->Unadvise(m_dwAdviseCookie);
    if (FAILED(hr))
    {
        goto done;
    }

    m_dwAdviseCookie = 0;

    hr = S_OK;
done:
    return hr;
}


//+-----------------------------------------------------------------------------------
//
//  Member:     CPlayListDelegator::NotifyPropertyChanged
//
//  Synopsis:   Notifies clients that a property has changed
//
//  Arguments:  dispid      DISPID of property that has changed      
//
//  Returns:    Success     when function completes successfully
//
//------------------------------------------------------------------------------------
HRESULT
CPlayListDelegator::NotifyPropertyChanged(DISPID dispid)
{
    HRESULT hr;

    CComPtr<IConnectionPoint> pICP;

    hr = FindConnectionPoint(IID_IPropertyNotifySink,&pICP); 
    if (SUCCEEDED(hr) && pICP != NULL)
    {
        hr = THR(NotifyPropertySinkCP(pICP, dispid));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done:
    RRETURN(hr);
} // NotifyPropertyChanged


//+-------------------------------------------------------------------------------------
//
// ITIMEPlayList methods
//
//--------------------------------------------------------------------------------------

    
STDMETHODIMP
CPlayListDelegator::put_activeTrack(VARIANT vTrack)
{
    HRESULT hr = S_OK;

    if (GetPlayList())
    {
        hr = THR(GetPlayList()->put_activeTrack(vTrack));
    }

    RRETURN(hr);
}


STDMETHODIMP
CPlayListDelegator::get_activeTrack(ITIMEPlayItem **ppPlayItem)
{
    HRESULT hr = S_OK;
    
    CHECK_RETURN_SET_NULL(ppPlayItem);

    if (GetPlayList())
    {
        hr = THR(GetPlayList()->get_activeTrack(ppPlayItem));
    }

    RRETURN(hr);
}

    
STDMETHODIMP
CPlayListDelegator::get_dur(double * pdblDur)
{
    HRESULT hr = S_OK;
    
    CHECK_RETURN_NULL(pdblDur);
    
    *pdblDur = 0;

    if (GetPlayList())
    {
        hr = THR(GetPlayList()->get_dur(pdblDur));
    }

    RRETURN(hr);
}


STDMETHODIMP
CPlayListDelegator::item(VARIANT varIndex, ITIMEPlayItem ** ppPlayItem)
{
    HRESULT hr = S_OK;
    
    CHECK_RETURN_SET_NULL(ppPlayItem);

    if (GetPlayList())
    {
        hr = THR(GetPlayList()->item(varIndex, ppPlayItem));
    }

    RRETURN(hr);
}


STDMETHODIMP
CPlayListDelegator::get_length(long * plLength)
{
    HRESULT hr = S_OK;
    
    CHECK_RETURN_NULL(plLength);

    *plLength = 0;

    if (GetPlayList())
    {
        hr = THR(GetPlayList()->get_length(plLength));
    }

    RRETURN(hr);
}


STDMETHODIMP
CPlayListDelegator::get__newEnum(IUnknown** p)
{
    HRESULT hr = S_OK;
    
    CHECK_RETURN_SET_NULL(p);

    if (GetPlayList())
    {
        hr = THR(GetPlayList()->get__newEnum(p));
    }

    RRETURN(hr);
}


//Advances the active Track by one
STDMETHODIMP
CPlayListDelegator::nextTrack()
{
    HRESULT hr = S_OK;
    
    if (GetPlayList())
    {
        hr = THR(GetPlayList()->nextTrack());
    }

    RRETURN(hr);
}


//moves the active track to the previous track
STDMETHODIMP
CPlayListDelegator::prevTrack() 
{
    HRESULT hr = S_OK;
    
    if (GetPlayList())
    {
        hr = THR(GetPlayList()->prevTrack());
    }

    RRETURN(hr);
}


//+-------------------------------------------------------------------------------------
//
// IPropertyNotifySink methods
//
//--------------------------------------------------------------------------------------

STDMETHODIMP
CPlayListDelegator::OnRequestEdit(DISPID dispID)
{
    RRETURN(S_OK);
}


STDMETHODIMP
CPlayListDelegator::OnChanged(DISPID dispID)
{
    return THR(NotifyPropertyChanged(dispID));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\playlistdelegator.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 2000
//
//  File: playlistdelegator.h
//
//  Contents: playlist object that delegates to the player's playlist object
//
//------------------------------------------------------------------------------------

#pragma once

#ifndef _PLAYLISTDELEGATOR_H
#define _PLAYLISTDELEGATOR_H


//+-------------------------------------------------------------------------------------
//
// CPlayListDelegator
//
//--------------------------------------------------------------------------------------

class
__declspec(uuid("2e6c4d81-2b2a-49c6-8158-2b8280d28e00")) 
CPlayListDelegator :  
    public CComObjectRootEx<CComSingleThreadModel>, 
    public CComCoClass<CPlayListDelegator, &__uuidof(CPlayListDelegator)>,
    public ITIMEDispatchImpl<ITIMEPlayList, &IID_ITIMEPlayList>,
    public ISupportErrorInfoImpl<&IID_ITIMEPlayList>,
    public IConnectionPointContainerImpl<CPlayListDelegator>,
    public IPropertyNotifySinkCP<CPlayListDelegator>,
    public IPropertyNotifySink
{
  public:
    
    //+--------------------------------------------------------------------------------
    //
    // Public Methods
    //
    //---------------------------------------------------------------------------------

    CPlayListDelegator();
    virtual ~CPlayListDelegator();

    void AttachPlayList(ITIMEPlayList * pPlayList);
    void DetachPlayList();

#if DBG
    const _TCHAR * GetName() { return __T("CPlayListDelegator"); }
#endif

    //    
    // QI & CP Map
    //

    BEGIN_COM_MAP(CPlayListDelegator)
        COM_INTERFACE_ENTRY(ITIMEPlayList)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IPropertyNotifySink)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    END_COM_MAP();

#ifndef END_COM_MAP_ADDREF

    //
    // IUnknown
    //

    STDMETHOD_(ULONG,AddRef)(void) = 0;
    STDMETHOD_(ULONG,Release)(void) = 0;
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) = 0;
#endif

    // 
    // ITIMEPlayList methods
    //
        
    STDMETHOD(put_activeTrack)(VARIANT vTrack);
    STDMETHOD(get_activeTrack)(ITIMEPlayItem **pPlayItem);
        
    STDMETHOD(get_dur)(double *dur);

    STDMETHOD(item)(VARIANT varIndex,
                    ITIMEPlayItem **pPlayItem);

    STDMETHOD(get_length)(long* len);

    STDMETHOD(get__newEnum)(IUnknown** p);

    STDMETHOD(nextTrack)(); //Advances the active Track by one
    STDMETHOD(prevTrack)(); //moves the active track to the previous track

    //
    // IPropertyNotifySink methods
    //

    STDMETHOD(OnChanged)(DISPID dispID);
    STDMETHOD(OnRequestEdit)(DISPID dispID);

    BEGIN_CONNECTION_POINT_MAP(CPlayListDelegator)
        CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
    END_CONNECTION_POINT_MAP();

    //+--------------------------------------------------------------------------------
    //
    // Public Data
    //
    //---------------------------------------------------------------------------------

  protected:

    //+--------------------------------------------------------------------------------
    //
    // Protected Methods
    //
    //---------------------------------------------------------------------------------

    //+--------------------------------------------------------------------------------
    //
    // Protected Data
    //
    //---------------------------------------------------------------------------------

  private:

    //+--------------------------------------------------------------------------------
    //
    // Private methods
    //
    //---------------------------------------------------------------------------------

    HRESULT NotifyPropertyChanged(DISPID dispid);

    HRESULT GetPlayListConnectionPoint(IConnectionPoint **ppCP);
    HRESULT InitPropertySink();
    HRESULT UnInitPropertySink();
  
    ITIMEPlayList * GetPlayList() { return m_pPlayList; };

    //+--------------------------------------------------------------------------------
    //
    // Private Data
    //
    //---------------------------------------------------------------------------------

    ITIMEPlayList * m_pPlayList;
    DWORD m_dwAdviseCookie;

}; //  CPlayListDelegator


#endif /* _PLAYLISTDELEGATOR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\stopstream.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: stopstream.h
//
//  Contents: stoppable implementation of IStream
//
//------------------------------------------------------------------------------------

#ifndef _STOPSTREAM__H
#define _STOPSTREAM__H

class CStopableStream : public IStream
{
  public:
    CStopableStream() : m_spStream(NULL), m_fCancelled(false) {;}
    virtual ~CStopableStream() {;}

    void SetStream(IStream * pStream) { m_spStream = pStream; }

    STDMETHOD(QueryInterface)(REFGUID riid, void ** ppv)
    {
        return m_spStream->QueryInterface(riid, ppv);
    }

    STDMETHOD_(ULONG, AddRef)(void)
    {
        return m_spStream.p->AddRef();
    }

    STDMETHOD_(ULONG, Release)(void)
    {
        return m_spStream.p->Release();
    }

    // ISequentialStream
    virtual /* [local] */ HRESULT STDMETHODCALLTYPE Read( 
            /* [length_is][size_is][out] */ void __RPC_FAR *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG __RPC_FAR *pcbRead) 
    {
        if (Cancelled())
            return E_FAIL;
        return m_spStream->Read(pv, cb, pcbRead);
    }

        
    virtual /* [local] */ HRESULT STDMETHODCALLTYPE Write( 
            /* [size_is][in] */ const void __RPC_FAR *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG __RPC_FAR *pcbWritten)
    {
        if (Cancelled())
            return E_FAIL;
        return m_spStream->Write(pv, cb, pcbWritten);
    }

    // IStream
    virtual /* [local] */ HRESULT STDMETHODCALLTYPE Seek( 
            /* [in] */ LARGE_INTEGER dlibMove,
            /* [in] */ DWORD dwOrigin,
            /* [out] */ ULARGE_INTEGER __RPC_FAR *plibNewPosition)
    {
        if (Cancelled())
            return E_FAIL;
        return m_spStream->Seek(dlibMove, dwOrigin, plibNewPosition);
    }

    virtual HRESULT STDMETHODCALLTYPE SetSize( 
            /* [in] */ ULARGE_INTEGER libNewSize)
    {
        if (Cancelled())
            return E_FAIL;
        return m_spStream->SetSize(libNewSize);
    }

    virtual /* [local] */ HRESULT STDMETHODCALLTYPE CopyTo( 
            /* [unique][in] */ IStream __RPC_FAR *pstm,
            /* [in] */ ULARGE_INTEGER cb,
            /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbRead,
            /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbWritten)
    {
        if (Cancelled())
            return E_FAIL;
        return m_spStream->CopyTo(pstm, cb, pcbRead, pcbWritten);
    }

    virtual HRESULT STDMETHODCALLTYPE Commit( 
            /* [in] */ DWORD grfCommitFlags)
    {
        if (Cancelled())
            return E_FAIL;
        return m_spStream->Commit(grfCommitFlags);
    }
        
    virtual HRESULT STDMETHODCALLTYPE Revert( void)
    {
        if (Cancelled())
            return E_FAIL;
        return m_spStream->Revert();
    }
        
    virtual HRESULT STDMETHODCALLTYPE LockRegion( 
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType)
    {
        if (Cancelled())
            return E_FAIL;
        return m_spStream->LockRegion(libOffset, cb, dwLockType);
    }
        
    virtual HRESULT STDMETHODCALLTYPE UnlockRegion( 
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType)
    {
        if (Cancelled())
            return E_FAIL;
        return m_spStream->UnlockRegion(libOffset, cb, dwLockType);
    }
        
    virtual HRESULT STDMETHODCALLTYPE Stat( 
            /* [out] */ STATSTG __RPC_FAR *pstatstg,
            /* [in] */ DWORD grfStatFlag)
    {
        if (Cancelled())
            return E_FAIL;
        return m_spStream->Stat(pstatstg, grfStatFlag);
    }
        
    virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppstm)
    {
        if (Cancelled())
            return E_FAIL;
        return m_spStream->Clone(ppstm);
    }

    bool Cancelled() { return m_fCancelled; }
    void SetCancelled() { m_fCancelled = true; }

  private:
    CComPtr<IStream>    m_spStream;
    bool                m_fCancelled;
};

#endif // _STOPSTREAM__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\proxy\flash\nstdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\wmpcd.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Fri Jun 16 13:10:13 2000
 */
/* Compiler settings for .\wmpcd.idl:
    Oicf (OptLev=i2), W0, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wmpcd_h__
#define __wmpcd_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IWMPCDMediaInfo_FWD_DEFINED__
#define __IWMPCDMediaInfo_FWD_DEFINED__
typedef interface IWMPCDMediaInfo IWMPCDMediaInfo;
#endif 	/* __IWMPCDMediaInfo_FWD_DEFINED__ */


#ifndef __IWMPCDDeviceList_FWD_DEFINED__
#define __IWMPCDDeviceList_FWD_DEFINED__
typedef interface IWMPCDDeviceList IWMPCDDeviceList;
#endif 	/* __IWMPCDDeviceList_FWD_DEFINED__ */


#ifndef __IWMPCDDevice_FWD_DEFINED__
#define __IWMPCDDevice_FWD_DEFINED__
typedef interface IWMPCDDevice IWMPCDDevice;
#endif 	/* __IWMPCDDevice_FWD_DEFINED__ */


#ifndef __IWMPCDMixer_FWD_DEFINED__
#define __IWMPCDMixer_FWD_DEFINED__
typedef interface IWMPCDMixer IWMPCDMixer;
#endif 	/* __IWMPCDMixer_FWD_DEFINED__ */


#ifndef __IWMPCDReader_FWD_DEFINED__
#define __IWMPCDReader_FWD_DEFINED__
typedef interface IWMPCDReader IWMPCDReader;
#endif 	/* __IWMPCDReader_FWD_DEFINED__ */


#ifndef __IWMPCDRecorder_FWD_DEFINED__
#define __IWMPCDRecorder_FWD_DEFINED__
typedef interface IWMPCDRecorder IWMPCDRecorder;
#endif 	/* __IWMPCDRecorder_FWD_DEFINED__ */


#ifndef __IWMPCDDeviceCallback_FWD_DEFINED__
#define __IWMPCDDeviceCallback_FWD_DEFINED__
typedef interface IWMPCDDeviceCallback IWMPCDDeviceCallback;
#endif 	/* __IWMPCDDeviceCallback_FWD_DEFINED__ */


#ifndef __IWMPCDReaderCallback_FWD_DEFINED__
#define __IWMPCDReaderCallback_FWD_DEFINED__
typedef interface IWMPCDReaderCallback IWMPCDReaderCallback;
#endif 	/* __IWMPCDReaderCallback_FWD_DEFINED__ */


#ifndef __IWMPCDRecorderCallback_FWD_DEFINED__
#define __IWMPCDRecorderCallback_FWD_DEFINED__
typedef interface IWMPCDRecorderCallback IWMPCDRecorderCallback;
#endif 	/* __IWMPCDRecorderCallback_FWD_DEFINED__ */


/* header files for imported files */
#include "wtypes.h"
#include "oaidl.h"
#include "wmsbuffer.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_wmpcd_0000 */
/* [local] */ 










HRESULT STDMETHODCALLTYPE WMPCreateCDURL( DWORD iDevice, DWORD iTrack, BSTR *pbstrURL );
HRESULT STDMETHODCALLTYPE WMPParseCDURL( LPCWSTR pszURL, DWORD *piDevice, DWORD *piTrack );
HRESULT STDMETHODCALLTYPE WMPGetCDDeviceList( IWMPCDDeviceList **ppList );
HRESULT STDMETHODCALLTYPE WMPCreateCDRecorder( IUnknown *pUnknown, LPCWSTR pszPath, DWORD cRate, DWORD fl, IWMPCDRecorderCallback *pCallback, IWMPCDRecorder **ppRecorder );
HRESULT STDMETHODCALLTYPE WMPFireCDMediaChange( WCHAR chDrive, BOOL fMediaPresent );
HRESULT STDMETHODCALLTYPE WMPCalibrateCDDevice( void );

#define WMPCD_MAX_BLOCK_READ    16
#define WMPCD_MAX_DEVICE_NAME   64

typedef /* [public] */ 
enum __MIDL___MIDL_itf_wmpcd_0000_0001
    {	WMPCD_DEVICE_PLAY_DIGITAL	= 0x1,
	WMPCD_DEVICE_PLAY_CORRECT_ERRORS	= 0x2,
	WMPCD_DEVICE_RECORD_DIGITAL	= 0x4,
	WMPCD_DEVICE_RECORD_CORRECT_ERRORS	= 0x8,
	WMPCD_DEVICE_DEFAULT	= 0x4000
    }	WMPCD_DEVICE_OPTIONS;

typedef /* [public][public] */ struct  __MIDL___MIDL_itf_wmpcd_0000_0002
    {
    WCHAR szName[ 64 ];
    }	WMPCD_DEVICE_INFO;

typedef /* [public][public] */ struct  __MIDL___MIDL_itf_wmpcd_0000_0003
    {
    DWORD flOptions;
    double fRateNormal;
    double fRateCorrection;
    DWORD ccBlockRead;
    DWORD acBlockRead[ 16 ];
    DWORD cBlockOffset;
    }	WMPCD_TEST_INFO;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_wmpcd_0000_0004
    {	WMPCD_READER_CORRECT_ERRORS	= 0x1
    }	WMPCD_READER_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_wmpcd_0000_0005
    {	WMPCD_RECORD_DRM	= 0x1,
	WMPCD_RECORD_CORRECT_ERRORS	= 0x2
    }	WMPCD_RECORDER_FLAGS;

typedef /* [public][public][public][public][public] */ struct  __MIDL___MIDL_itf_wmpcd_0000_0006
    {
    DWORD iBlock;
    DWORD cBlock;
    }	WMPCD_EXTENT;

typedef /* [public][public] */ struct  __MIDL___MIDL_itf_wmpcd_0000_0007
    {
    DWORD fl;
    WMPCD_EXTENT ext;
    }	WMPCD_DISC_INFO;

typedef /* [public][public] */ struct  __MIDL___MIDL_itf_wmpcd_0000_0008
    {
    DWORD fl;
    WMPCD_EXTENT ext;
    }	WMPCD_TRACK_INFO;

typedef /* [public][public][public][public] */ 
enum __MIDL___MIDL_itf_wmpcd_0000_0009
    {	WMPCD_DIGITAL_READER	= 0,
	WMPCD_ANALOG_SAMPLER	= WMPCD_DIGITAL_READER + 1,
	WMPCD_ANALOG_MONITOR	= WMPCD_ANALOG_SAMPLER + 1
    }	WMPCD_READER_TYPE;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_wmpcd_0000_0010
    {	WMPCD_READER_STOPPED	= 0,
	WMPCD_READER_STARTED	= WMPCD_READER_STOPPED + 1,
	WMPCD_READER_PAUSED	= WMPCD_READER_STARTED + 1
    }	WMPCD_READER_STATE;

typedef /* [public][public] */ struct  __MIDL___MIDL_itf_wmpcd_0000_0011
    {
    WMPCD_READER_TYPE rt;
    DWORD cbBuffer;
    DWORD cBuffer;
    LONGLONG cTick;
    }	WMPCD_READER_INFO;



extern RPC_IF_HANDLE __MIDL_itf_wmpcd_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmpcd_0000_v0_0_s_ifspec;

#ifndef __IWMPCDMediaInfo_INTERFACE_DEFINED__
#define __IWMPCDMediaInfo_INTERFACE_DEFINED__

/* interface IWMPCDMediaInfo */
/* [local][object][version][uuid] */ 


EXTERN_C const IID IID_IWMPCDMediaInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("536E6234-732A-40A4-AA7C-00012BFB53DB")
    IWMPCDMediaInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDiscInfo( 
            /* [out] */ WMPCD_DISC_INFO __RPC_FAR *pinfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDiscIdentifier( 
            /* [out] */ BSTR __RPC_FAR *pbstrIdentifier) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTrackCount( 
            /* [out] */ DWORD __RPC_FAR *pcTrack) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTrackInfo( 
            /* [in] */ DWORD iTrack,
            /* [out] */ WMPCD_TRACK_INFO __RPC_FAR *pinfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTrackURL( 
            /* [in] */ DWORD iTrack,
            /* [out] */ BSTR __RPC_FAR *pbstrURL) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPCDMediaInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPCDMediaInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPCDMediaInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPCDMediaInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDiscInfo )( 
            IWMPCDMediaInfo __RPC_FAR * This,
            /* [out] */ WMPCD_DISC_INFO __RPC_FAR *pinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDiscIdentifier )( 
            IWMPCDMediaInfo __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrIdentifier);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTrackCount )( 
            IWMPCDMediaInfo __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcTrack);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTrackInfo )( 
            IWMPCDMediaInfo __RPC_FAR * This,
            /* [in] */ DWORD iTrack,
            /* [out] */ WMPCD_TRACK_INFO __RPC_FAR *pinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTrackURL )( 
            IWMPCDMediaInfo __RPC_FAR * This,
            /* [in] */ DWORD iTrack,
            /* [out] */ BSTR __RPC_FAR *pbstrURL);
        
        END_INTERFACE
    } IWMPCDMediaInfoVtbl;

    interface IWMPCDMediaInfo
    {
        CONST_VTBL struct IWMPCDMediaInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPCDMediaInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPCDMediaInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPCDMediaInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPCDMediaInfo_GetDiscInfo(This,pinfo)	\
    (This)->lpVtbl -> GetDiscInfo(This,pinfo)

#define IWMPCDMediaInfo_GetDiscIdentifier(This,pbstrIdentifier)	\
    (This)->lpVtbl -> GetDiscIdentifier(This,pbstrIdentifier)

#define IWMPCDMediaInfo_GetTrackCount(This,pcTrack)	\
    (This)->lpVtbl -> GetTrackCount(This,pcTrack)

#define IWMPCDMediaInfo_GetTrackInfo(This,iTrack,pinfo)	\
    (This)->lpVtbl -> GetTrackInfo(This,iTrack,pinfo)

#define IWMPCDMediaInfo_GetTrackURL(This,iTrack,pbstrURL)	\
    (This)->lpVtbl -> GetTrackURL(This,iTrack,pbstrURL)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMPCDMediaInfo_GetDiscInfo_Proxy( 
    IWMPCDMediaInfo __RPC_FAR * This,
    /* [out] */ WMPCD_DISC_INFO __RPC_FAR *pinfo);


void __RPC_STUB IWMPCDMediaInfo_GetDiscInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDMediaInfo_GetDiscIdentifier_Proxy( 
    IWMPCDMediaInfo __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrIdentifier);


void __RPC_STUB IWMPCDMediaInfo_GetDiscIdentifier_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDMediaInfo_GetTrackCount_Proxy( 
    IWMPCDMediaInfo __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pcTrack);


void __RPC_STUB IWMPCDMediaInfo_GetTrackCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDMediaInfo_GetTrackInfo_Proxy( 
    IWMPCDMediaInfo __RPC_FAR * This,
    /* [in] */ DWORD iTrack,
    /* [out] */ WMPCD_TRACK_INFO __RPC_FAR *pinfo);


void __RPC_STUB IWMPCDMediaInfo_GetTrackInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDMediaInfo_GetTrackURL_Proxy( 
    IWMPCDMediaInfo __RPC_FAR * This,
    /* [in] */ DWORD iTrack,
    /* [out] */ BSTR __RPC_FAR *pbstrURL);


void __RPC_STUB IWMPCDMediaInfo_GetTrackURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPCDMediaInfo_INTERFACE_DEFINED__ */


#ifndef __IWMPCDDeviceList_INTERFACE_DEFINED__
#define __IWMPCDDeviceList_INTERFACE_DEFINED__

/* interface IWMPCDDeviceList */
/* [local][object][version][uuid] */ 


EXTERN_C const IID IID_IWMPCDDeviceList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5BEC04A2-A90D-4AB0-BAC0-17D15979B26E")
    IWMPCDDeviceList : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDeviceCount( 
            /* [out] */ DWORD __RPC_FAR *pcDevice) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDevice( 
            /* [in] */ DWORD iDevice,
            /* [out] */ IWMPCDDevice __RPC_FAR *__RPC_FAR *ppDevice) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultDevice( 
            /* [out] */ IWMPCDDevice __RPC_FAR *__RPC_FAR *ppDevice) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindDevice( 
            /* [in] */ WCHAR chDrive,
            /* [out] */ IWMPCDDevice __RPC_FAR *__RPC_FAR *ppDevice) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPCDDeviceListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPCDDeviceList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPCDDeviceList __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPCDDeviceList __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDeviceCount )( 
            IWMPCDDeviceList __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcDevice);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDevice )( 
            IWMPCDDeviceList __RPC_FAR * This,
            /* [in] */ DWORD iDevice,
            /* [out] */ IWMPCDDevice __RPC_FAR *__RPC_FAR *ppDevice);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDefaultDevice )( 
            IWMPCDDeviceList __RPC_FAR * This,
            /* [out] */ IWMPCDDevice __RPC_FAR *__RPC_FAR *ppDevice);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindDevice )( 
            IWMPCDDeviceList __RPC_FAR * This,
            /* [in] */ WCHAR chDrive,
            /* [out] */ IWMPCDDevice __RPC_FAR *__RPC_FAR *ppDevice);
        
        END_INTERFACE
    } IWMPCDDeviceListVtbl;

    interface IWMPCDDeviceList
    {
        CONST_VTBL struct IWMPCDDeviceListVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPCDDeviceList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPCDDeviceList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPCDDeviceList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPCDDeviceList_GetDeviceCount(This,pcDevice)	\
    (This)->lpVtbl -> GetDeviceCount(This,pcDevice)

#define IWMPCDDeviceList_GetDevice(This,iDevice,ppDevice)	\
    (This)->lpVtbl -> GetDevice(This,iDevice,ppDevice)

#define IWMPCDDeviceList_GetDefaultDevice(This,ppDevice)	\
    (This)->lpVtbl -> GetDefaultDevice(This,ppDevice)

#define IWMPCDDeviceList_FindDevice(This,chDrive,ppDevice)	\
    (This)->lpVtbl -> FindDevice(This,chDrive,ppDevice)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMPCDDeviceList_GetDeviceCount_Proxy( 
    IWMPCDDeviceList __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pcDevice);


void __RPC_STUB IWMPCDDeviceList_GetDeviceCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDDeviceList_GetDevice_Proxy( 
    IWMPCDDeviceList __RPC_FAR * This,
    /* [in] */ DWORD iDevice,
    /* [out] */ IWMPCDDevice __RPC_FAR *__RPC_FAR *ppDevice);


void __RPC_STUB IWMPCDDeviceList_GetDevice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDDeviceList_GetDefaultDevice_Proxy( 
    IWMPCDDeviceList __RPC_FAR * This,
    /* [out] */ IWMPCDDevice __RPC_FAR *__RPC_FAR *ppDevice);


void __RPC_STUB IWMPCDDeviceList_GetDefaultDevice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDDeviceList_FindDevice_Proxy( 
    IWMPCDDeviceList __RPC_FAR * This,
    /* [in] */ WCHAR chDrive,
    /* [out] */ IWMPCDDevice __RPC_FAR *__RPC_FAR *ppDevice);


void __RPC_STUB IWMPCDDeviceList_FindDevice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPCDDeviceList_INTERFACE_DEFINED__ */


#ifndef __IWMPCDDevice_INTERFACE_DEFINED__
#define __IWMPCDDevice_INTERFACE_DEFINED__

/* interface IWMPCDDevice */
/* [local][object][version][uuid] */ 


EXTERN_C const IID IID_IWMPCDDevice;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E723F9DE-9EDE-4364-BBA1-D984E5716F00")
    IWMPCDDevice : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDeviceIndex( 
            /* [out] */ DWORD __RPC_FAR *piDevice) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDeviceDrive( 
            /* [out] */ WCHAR __RPC_FAR *pchDrive) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDeviceOptions( 
            /* [out] */ DWORD __RPC_FAR *pflOptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDeviceOptions( 
            /* [in] */ DWORD flOptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDeviceInfo( 
            /* [out] */ WMPCD_DEVICE_INFO __RPC_FAR *pinfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TestDevice( 
            /* [out] */ WMPCD_TEST_INFO __RPC_FAR *pinfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FireMediaChange( 
            BOOL fMediaPresent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CalibrateDevice( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsMediaLoaded( 
            /* [out] */ BOOL __RPC_FAR *pfMediaLoaded) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadMedia( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnloadMedia( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMediaInfo( 
            /* [out] */ IWMPCDMediaInfo __RPC_FAR *__RPC_FAR *ppMediaInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateReader( 
            /* [in] */ DWORD iTrack,
            /* [in] */ WMPCD_READER_TYPE rt,
            /* [in] */ DWORD fl,
            /* [in] */ DWORD iPriority,
            /* [in] */ DWORD cmsBuffer,
            /* [in] */ IWMPCDReaderCallback __RPC_FAR *pCallback,
            /* [out] */ IWMPCDReader __RPC_FAR *__RPC_FAR *ppReader) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Advise( 
            /* [in] */ IWMPCDDeviceCallback __RPC_FAR *pCallback,
            /* [out] */ DWORD __RPC_FAR *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unadvise( 
            /* [in] */ DWORD dwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBusy( 
            /* [out] */ BOOL __RPC_FAR *pfIsBusy) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ForceIdle( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPCDDeviceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPCDDevice __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPCDDevice __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPCDDevice __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDeviceIndex )( 
            IWMPCDDevice __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *piDevice);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDeviceDrive )( 
            IWMPCDDevice __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pchDrive);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDeviceOptions )( 
            IWMPCDDevice __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pflOptions);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDeviceOptions )( 
            IWMPCDDevice __RPC_FAR * This,
            /* [in] */ DWORD flOptions);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDeviceInfo )( 
            IWMPCDDevice __RPC_FAR * This,
            /* [out] */ WMPCD_DEVICE_INFO __RPC_FAR *pinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TestDevice )( 
            IWMPCDDevice __RPC_FAR * This,
            /* [out] */ WMPCD_TEST_INFO __RPC_FAR *pinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FireMediaChange )( 
            IWMPCDDevice __RPC_FAR * This,
            BOOL fMediaPresent);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CalibrateDevice )( 
            IWMPCDDevice __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsMediaLoaded )( 
            IWMPCDDevice __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfMediaLoaded);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadMedia )( 
            IWMPCDDevice __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnloadMedia )( 
            IWMPCDDevice __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMediaInfo )( 
            IWMPCDDevice __RPC_FAR * This,
            /* [out] */ IWMPCDMediaInfo __RPC_FAR *__RPC_FAR *ppMediaInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateReader )( 
            IWMPCDDevice __RPC_FAR * This,
            /* [in] */ DWORD iTrack,
            /* [in] */ WMPCD_READER_TYPE rt,
            /* [in] */ DWORD fl,
            /* [in] */ DWORD iPriority,
            /* [in] */ DWORD cmsBuffer,
            /* [in] */ IWMPCDReaderCallback __RPC_FAR *pCallback,
            /* [out] */ IWMPCDReader __RPC_FAR *__RPC_FAR *ppReader);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Advise )( 
            IWMPCDDevice __RPC_FAR * This,
            /* [in] */ IWMPCDDeviceCallback __RPC_FAR *pCallback,
            /* [out] */ DWORD __RPC_FAR *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Unadvise )( 
            IWMPCDDevice __RPC_FAR * This,
            /* [in] */ DWORD dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBusy )( 
            IWMPCDDevice __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfIsBusy);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ForceIdle )( 
            IWMPCDDevice __RPC_FAR * This);
        
        END_INTERFACE
    } IWMPCDDeviceVtbl;

    interface IWMPCDDevice
    {
        CONST_VTBL struct IWMPCDDeviceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPCDDevice_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPCDDevice_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPCDDevice_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPCDDevice_GetDeviceIndex(This,piDevice)	\
    (This)->lpVtbl -> GetDeviceIndex(This,piDevice)

#define IWMPCDDevice_GetDeviceDrive(This,pchDrive)	\
    (This)->lpVtbl -> GetDeviceDrive(This,pchDrive)

#define IWMPCDDevice_GetDeviceOptions(This,pflOptions)	\
    (This)->lpVtbl -> GetDeviceOptions(This,pflOptions)

#define IWMPCDDevice_SetDeviceOptions(This,flOptions)	\
    (This)->lpVtbl -> SetDeviceOptions(This,flOptions)

#define IWMPCDDevice_GetDeviceInfo(This,pinfo)	\
    (This)->lpVtbl -> GetDeviceInfo(This,pinfo)

#define IWMPCDDevice_TestDevice(This,pinfo)	\
    (This)->lpVtbl -> TestDevice(This,pinfo)

#define IWMPCDDevice_FireMediaChange(This,fMediaPresent)	\
    (This)->lpVtbl -> FireMediaChange(This,fMediaPresent)

#define IWMPCDDevice_CalibrateDevice(This)	\
    (This)->lpVtbl -> CalibrateDevice(This)

#define IWMPCDDevice_IsMediaLoaded(This,pfMediaLoaded)	\
    (This)->lpVtbl -> IsMediaLoaded(This,pfMediaLoaded)

#define IWMPCDDevice_LoadMedia(This)	\
    (This)->lpVtbl -> LoadMedia(This)

#define IWMPCDDevice_UnloadMedia(This)	\
    (This)->lpVtbl -> UnloadMedia(This)

#define IWMPCDDevice_GetMediaInfo(This,ppMediaInfo)	\
    (This)->lpVtbl -> GetMediaInfo(This,ppMediaInfo)

#define IWMPCDDevice_CreateReader(This,iTrack,rt,fl,iPriority,cmsBuffer,pCallback,ppReader)	\
    (This)->lpVtbl -> CreateReader(This,iTrack,rt,fl,iPriority,cmsBuffer,pCallback,ppReader)

#define IWMPCDDevice_Advise(This,pCallback,pdwCookie)	\
    (This)->lpVtbl -> Advise(This,pCallback,pdwCookie)

#define IWMPCDDevice_Unadvise(This,dwCookie)	\
    (This)->lpVtbl -> Unadvise(This,dwCookie)

#define IWMPCDDevice_GetBusy(This,pfIsBusy)	\
    (This)->lpVtbl -> GetBusy(This,pfIsBusy)

#define IWMPCDDevice_ForceIdle(This)	\
    (This)->lpVtbl -> ForceIdle(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMPCDDevice_GetDeviceIndex_Proxy( 
    IWMPCDDevice __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *piDevice);


void __RPC_STUB IWMPCDDevice_GetDeviceIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDDevice_GetDeviceDrive_Proxy( 
    IWMPCDDevice __RPC_FAR * This,
    /* [out] */ WCHAR __RPC_FAR *pchDrive);


void __RPC_STUB IWMPCDDevice_GetDeviceDrive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDDevice_GetDeviceOptions_Proxy( 
    IWMPCDDevice __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pflOptions);


void __RPC_STUB IWMPCDDevice_GetDeviceOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDDevice_SetDeviceOptions_Proxy( 
    IWMPCDDevice __RPC_FAR * This,
    /* [in] */ DWORD flOptions);


void __RPC_STUB IWMPCDDevice_SetDeviceOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDDevice_GetDeviceInfo_Proxy( 
    IWMPCDDevice __RPC_FAR * This,
    /* [out] */ WMPCD_DEVICE_INFO __RPC_FAR *pinfo);


void __RPC_STUB IWMPCDDevice_GetDeviceInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDDevice_TestDevice_Proxy( 
    IWMPCDDevice __RPC_FAR * This,
    /* [out] */ WMPCD_TEST_INFO __RPC_FAR *pinfo);


void __RPC_STUB IWMPCDDevice_TestDevice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDDevice_FireMediaChange_Proxy( 
    IWMPCDDevice __RPC_FAR * This,
    BOOL fMediaPresent);


void __RPC_STUB IWMPCDDevice_FireMediaChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDDevice_CalibrateDevice_Proxy( 
    IWMPCDDevice __RPC_FAR * This);


void __RPC_STUB IWMPCDDevice_CalibrateDevice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDDevice_IsMediaLoaded_Proxy( 
    IWMPCDDevice __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfMediaLoaded);


void __RPC_STUB IWMPCDDevice_IsMediaLoaded_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDDevice_LoadMedia_Proxy( 
    IWMPCDDevice __RPC_FAR * This);


void __RPC_STUB IWMPCDDevice_LoadMedia_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDDevice_UnloadMedia_Proxy( 
    IWMPCDDevice __RPC_FAR * This);


void __RPC_STUB IWMPCDDevice_UnloadMedia_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDDevice_GetMediaInfo_Proxy( 
    IWMPCDDevice __RPC_FAR * This,
    /* [out] */ IWMPCDMediaInfo __RPC_FAR *__RPC_FAR *ppMediaInfo);


void __RPC_STUB IWMPCDDevice_GetMediaInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDDevice_CreateReader_Proxy( 
    IWMPCDDevice __RPC_FAR * This,
    /* [in] */ DWORD iTrack,
    /* [in] */ WMPCD_READER_TYPE rt,
    /* [in] */ DWORD fl,
    /* [in] */ DWORD iPriority,
    /* [in] */ DWORD cmsBuffer,
    /* [in] */ IWMPCDReaderCallback __RPC_FAR *pCallback,
    /* [out] */ IWMPCDReader __RPC_FAR *__RPC_FAR *ppReader);


void __RPC_STUB IWMPCDDevice_CreateReader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDDevice_Advise_Proxy( 
    IWMPCDDevice __RPC_FAR * This,
    /* [in] */ IWMPCDDeviceCallback __RPC_FAR *pCallback,
    /* [out] */ DWORD __RPC_FAR *pdwCookie);


void __RPC_STUB IWMPCDDevice_Advise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDDevice_Unadvise_Proxy( 
    IWMPCDDevice __RPC_FAR * This,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB IWMPCDDevice_Unadvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDDevice_GetBusy_Proxy( 
    IWMPCDDevice __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfIsBusy);


void __RPC_STUB IWMPCDDevice_GetBusy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDDevice_ForceIdle_Proxy( 
    IWMPCDDevice __RPC_FAR * This);


void __RPC_STUB IWMPCDDevice_ForceIdle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPCDDevice_INTERFACE_DEFINED__ */


#ifndef __IWMPCDMixer_INTERFACE_DEFINED__
#define __IWMPCDMixer_INTERFACE_DEFINED__

/* interface IWMPCDMixer */
/* [local][object][version][uuid] */ 


EXTERN_C const IID IID_IWMPCDMixer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F8A62F06-32FD-45C3-8079-F846C988D059")
    IWMPCDMixer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPlayLevel( 
            /* [out] */ DWORD __RPC_FAR *pdwLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPlayLevel( 
            /* [in] */ DWORD dwLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPlayBalance( 
            /* [out] */ LONG __RPC_FAR *plBalance) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPlayBalance( 
            /* [in] */ LONG lBalance) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordLevel( 
            /* [out] */ DWORD __RPC_FAR *pdwLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRecordLevel( 
            /* [in] */ DWORD dwLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MutePlay( 
            /* [in] */ BOOL fMute) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SoloRecord( 
            /* [in] */ BOOL fSolo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPCDMixerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPCDMixer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPCDMixer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPCDMixer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPlayLevel )( 
            IWMPCDMixer __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwLevel);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPlayLevel )( 
            IWMPCDMixer __RPC_FAR * This,
            /* [in] */ DWORD dwLevel);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPlayBalance )( 
            IWMPCDMixer __RPC_FAR * This,
            /* [out] */ LONG __RPC_FAR *plBalance);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPlayBalance )( 
            IWMPCDMixer __RPC_FAR * This,
            /* [in] */ LONG lBalance);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRecordLevel )( 
            IWMPCDMixer __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwLevel);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRecordLevel )( 
            IWMPCDMixer __RPC_FAR * This,
            /* [in] */ DWORD dwLevel);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MutePlay )( 
            IWMPCDMixer __RPC_FAR * This,
            /* [in] */ BOOL fMute);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SoloRecord )( 
            IWMPCDMixer __RPC_FAR * This,
            /* [in] */ BOOL fSolo);
        
        END_INTERFACE
    } IWMPCDMixerVtbl;

    interface IWMPCDMixer
    {
        CONST_VTBL struct IWMPCDMixerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPCDMixer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPCDMixer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPCDMixer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPCDMixer_GetPlayLevel(This,pdwLevel)	\
    (This)->lpVtbl -> GetPlayLevel(This,pdwLevel)

#define IWMPCDMixer_SetPlayLevel(This,dwLevel)	\
    (This)->lpVtbl -> SetPlayLevel(This,dwLevel)

#define IWMPCDMixer_GetPlayBalance(This,plBalance)	\
    (This)->lpVtbl -> GetPlayBalance(This,plBalance)

#define IWMPCDMixer_SetPlayBalance(This,lBalance)	\
    (This)->lpVtbl -> SetPlayBalance(This,lBalance)

#define IWMPCDMixer_GetRecordLevel(This,pdwLevel)	\
    (This)->lpVtbl -> GetRecordLevel(This,pdwLevel)

#define IWMPCDMixer_SetRecordLevel(This,dwLevel)	\
    (This)->lpVtbl -> SetRecordLevel(This,dwLevel)

#define IWMPCDMixer_MutePlay(This,fMute)	\
    (This)->lpVtbl -> MutePlay(This,fMute)

#define IWMPCDMixer_SoloRecord(This,fSolo)	\
    (This)->lpVtbl -> SoloRecord(This,fSolo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMPCDMixer_GetPlayLevel_Proxy( 
    IWMPCDMixer __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwLevel);


void __RPC_STUB IWMPCDMixer_GetPlayLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDMixer_SetPlayLevel_Proxy( 
    IWMPCDMixer __RPC_FAR * This,
    /* [in] */ DWORD dwLevel);


void __RPC_STUB IWMPCDMixer_SetPlayLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDMixer_GetPlayBalance_Proxy( 
    IWMPCDMixer __RPC_FAR * This,
    /* [out] */ LONG __RPC_FAR *plBalance);


void __RPC_STUB IWMPCDMixer_GetPlayBalance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDMixer_SetPlayBalance_Proxy( 
    IWMPCDMixer __RPC_FAR * This,
    /* [in] */ LONG lBalance);


void __RPC_STUB IWMPCDMixer_SetPlayBalance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDMixer_GetRecordLevel_Proxy( 
    IWMPCDMixer __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwLevel);


void __RPC_STUB IWMPCDMixer_GetRecordLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDMixer_SetRecordLevel_Proxy( 
    IWMPCDMixer __RPC_FAR * This,
    /* [in] */ DWORD dwLevel);


void __RPC_STUB IWMPCDMixer_SetRecordLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDMixer_MutePlay_Proxy( 
    IWMPCDMixer __RPC_FAR * This,
    /* [in] */ BOOL fMute);


void __RPC_STUB IWMPCDMixer_MutePlay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDMixer_SoloRecord_Proxy( 
    IWMPCDMixer __RPC_FAR * This,
    /* [in] */ BOOL fSolo);


void __RPC_STUB IWMPCDMixer_SoloRecord_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPCDMixer_INTERFACE_DEFINED__ */


#ifndef __IWMPCDReader_INTERFACE_DEFINED__
#define __IWMPCDReader_INTERFACE_DEFINED__

/* interface IWMPCDReader */
/* [local][object][version][uuid] */ 


EXTERN_C const IID IID_IWMPCDReader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("34B59B58-D03D-455F-9A14-52D43FD39B40")
    IWMPCDReader : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetReaderInfo( 
            /* [out] */ WMPCD_READER_INFO __RPC_FAR *pinfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReaderState( 
            WMPCD_READER_STATE __RPC_FAR *prs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartReading( 
            /* [in] */ LONGLONG iTick,
            /* [in] */ LONGLONG cTick,
            /* [in] */ double fRate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SeekReading( 
            /* [in] */ LONGLONG iTick) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PauseReading( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResumeReading( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopReading( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPCDReaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPCDReader __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPCDReader __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPCDReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetReaderInfo )( 
            IWMPCDReader __RPC_FAR * This,
            /* [out] */ WMPCD_READER_INFO __RPC_FAR *pinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetReaderState )( 
            IWMPCDReader __RPC_FAR * This,
            WMPCD_READER_STATE __RPC_FAR *prs);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartReading )( 
            IWMPCDReader __RPC_FAR * This,
            /* [in] */ LONGLONG iTick,
            /* [in] */ LONGLONG cTick,
            /* [in] */ double fRate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SeekReading )( 
            IWMPCDReader __RPC_FAR * This,
            /* [in] */ LONGLONG iTick);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PauseReading )( 
            IWMPCDReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResumeReading )( 
            IWMPCDReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StopReading )( 
            IWMPCDReader __RPC_FAR * This);
        
        END_INTERFACE
    } IWMPCDReaderVtbl;

    interface IWMPCDReader
    {
        CONST_VTBL struct IWMPCDReaderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPCDReader_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPCDReader_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPCDReader_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPCDReader_GetReaderInfo(This,pinfo)	\
    (This)->lpVtbl -> GetReaderInfo(This,pinfo)

#define IWMPCDReader_GetReaderState(This,prs)	\
    (This)->lpVtbl -> GetReaderState(This,prs)

#define IWMPCDReader_StartReading(This,iTick,cTick,fRate)	\
    (This)->lpVtbl -> StartReading(This,iTick,cTick,fRate)

#define IWMPCDReader_SeekReading(This,iTick)	\
    (This)->lpVtbl -> SeekReading(This,iTick)

#define IWMPCDReader_PauseReading(This)	\
    (This)->lpVtbl -> PauseReading(This)

#define IWMPCDReader_ResumeReading(This)	\
    (This)->lpVtbl -> ResumeReading(This)

#define IWMPCDReader_StopReading(This)	\
    (This)->lpVtbl -> StopReading(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMPCDReader_GetReaderInfo_Proxy( 
    IWMPCDReader __RPC_FAR * This,
    /* [out] */ WMPCD_READER_INFO __RPC_FAR *pinfo);


void __RPC_STUB IWMPCDReader_GetReaderInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDReader_GetReaderState_Proxy( 
    IWMPCDReader __RPC_FAR * This,
    WMPCD_READER_STATE __RPC_FAR *prs);


void __RPC_STUB IWMPCDReader_GetReaderState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDReader_StartReading_Proxy( 
    IWMPCDReader __RPC_FAR * This,
    /* [in] */ LONGLONG iTick,
    /* [in] */ LONGLONG cTick,
    /* [in] */ double fRate);


void __RPC_STUB IWMPCDReader_StartReading_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDReader_SeekReading_Proxy( 
    IWMPCDReader __RPC_FAR * This,
    /* [in] */ LONGLONG iTick);


void __RPC_STUB IWMPCDReader_SeekReading_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDReader_PauseReading_Proxy( 
    IWMPCDReader __RPC_FAR * This);


void __RPC_STUB IWMPCDReader_PauseReading_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDReader_ResumeReading_Proxy( 
    IWMPCDReader __RPC_FAR * This);


void __RPC_STUB IWMPCDReader_ResumeReading_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDReader_StopReading_Proxy( 
    IWMPCDReader __RPC_FAR * This);


void __RPC_STUB IWMPCDReader_StopReading_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPCDReader_INTERFACE_DEFINED__ */


#ifndef __IWMPCDRecorder_INTERFACE_DEFINED__
#define __IWMPCDRecorder_INTERFACE_DEFINED__

/* interface IWMPCDRecorder */
/* [local][object][version][uuid] */ 


EXTERN_C const IID IID_IWMPCDRecorder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C5E8649E-30C4-4408-B18E-F75EAC29628D")
    IWMPCDRecorder : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StartRecording( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PauseRecording( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResumeRecording( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopRecording( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPCDRecorderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPCDRecorder __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPCDRecorder __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPCDRecorder __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartRecording )( 
            IWMPCDRecorder __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PauseRecording )( 
            IWMPCDRecorder __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResumeRecording )( 
            IWMPCDRecorder __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StopRecording )( 
            IWMPCDRecorder __RPC_FAR * This);
        
        END_INTERFACE
    } IWMPCDRecorderVtbl;

    interface IWMPCDRecorder
    {
        CONST_VTBL struct IWMPCDRecorderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPCDRecorder_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPCDRecorder_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPCDRecorder_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPCDRecorder_StartRecording(This)	\
    (This)->lpVtbl -> StartRecording(This)

#define IWMPCDRecorder_PauseRecording(This)	\
    (This)->lpVtbl -> PauseRecording(This)

#define IWMPCDRecorder_ResumeRecording(This)	\
    (This)->lpVtbl -> ResumeRecording(This)

#define IWMPCDRecorder_StopRecording(This)	\
    (This)->lpVtbl -> StopRecording(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMPCDRecorder_StartRecording_Proxy( 
    IWMPCDRecorder __RPC_FAR * This);


void __RPC_STUB IWMPCDRecorder_StartRecording_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDRecorder_PauseRecording_Proxy( 
    IWMPCDRecorder __RPC_FAR * This);


void __RPC_STUB IWMPCDRecorder_PauseRecording_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDRecorder_ResumeRecording_Proxy( 
    IWMPCDRecorder __RPC_FAR * This);


void __RPC_STUB IWMPCDRecorder_ResumeRecording_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDRecorder_StopRecording_Proxy( 
    IWMPCDRecorder __RPC_FAR * This);


void __RPC_STUB IWMPCDRecorder_StopRecording_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPCDRecorder_INTERFACE_DEFINED__ */


#ifndef __IWMPCDDeviceCallback_INTERFACE_DEFINED__
#define __IWMPCDDeviceCallback_INTERFACE_DEFINED__

/* interface IWMPCDDeviceCallback */
/* [local][object][version][uuid] */ 


EXTERN_C const IID IID_IWMPCDDeviceCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("63C780F9-0F40-4E4A-8C9E-91F7A48D5946")
    IWMPCDDeviceCallback : public IUnknown
    {
    public:
        virtual void STDMETHODCALLTYPE OnMediaChange( 
            /* [in] */ IWMPCDDevice __RPC_FAR *pDevice) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPCDDeviceCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPCDDeviceCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPCDDeviceCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPCDDeviceCallback __RPC_FAR * This);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *OnMediaChange )( 
            IWMPCDDeviceCallback __RPC_FAR * This,
            /* [in] */ IWMPCDDevice __RPC_FAR *pDevice);
        
        END_INTERFACE
    } IWMPCDDeviceCallbackVtbl;

    interface IWMPCDDeviceCallback
    {
        CONST_VTBL struct IWMPCDDeviceCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPCDDeviceCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPCDDeviceCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPCDDeviceCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPCDDeviceCallback_OnMediaChange(This,pDevice)	\
    (This)->lpVtbl -> OnMediaChange(This,pDevice)

#endif /* COBJMACROS */


#endif 	/* C style interface */



void STDMETHODCALLTYPE IWMPCDDeviceCallback_OnMediaChange_Proxy( 
    IWMPCDDeviceCallback __RPC_FAR * This,
    /* [in] */ IWMPCDDevice __RPC_FAR *pDevice);


void __RPC_STUB IWMPCDDeviceCallback_OnMediaChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPCDDeviceCallback_INTERFACE_DEFINED__ */


#ifndef __IWMPCDReaderCallback_INTERFACE_DEFINED__
#define __IWMPCDReaderCallback_INTERFACE_DEFINED__

/* interface IWMPCDReaderCallback */
/* [local][object][version][uuid] */ 


EXTERN_C const IID IID_IWMPCDReaderCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3916E26F-36A1-4F16-AC1F-B59590A51727")
    IWMPCDReaderCallback : public IUnknown
    {
    public:
        virtual void STDMETHODCALLTYPE OnReadStart( 
            /* [in] */ LONGLONG iTick,
            /* [in] */ LONGLONG cTick,
            /* [in] */ double fRate) = 0;
        
        virtual void STDMETHODCALLTYPE OnReadSeek( 
            /* [in] */ LONGLONG iTick,
            /* [in] */ LONGLONG cTick,
            /* [in] */ double fRate) = 0;
        
        virtual void STDMETHODCALLTYPE OnReadPause( void) = 0;
        
        virtual void STDMETHODCALLTYPE OnReadResume( void) = 0;
        
        virtual void STDMETHODCALLTYPE OnReadStop( 
            /* [in] */ HRESULT hr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnReadSample( 
            /* [in] */ LONGLONG iTick,
            /* [in] */ LONGLONG cTick,
            /* [in] */ IWMSBuffer __RPC_FAR *pBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPCDReaderCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPCDReaderCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPCDReaderCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPCDReaderCallback __RPC_FAR * This);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *OnReadStart )( 
            IWMPCDReaderCallback __RPC_FAR * This,
            /* [in] */ LONGLONG iTick,
            /* [in] */ LONGLONG cTick,
            /* [in] */ double fRate);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *OnReadSeek )( 
            IWMPCDReaderCallback __RPC_FAR * This,
            /* [in] */ LONGLONG iTick,
            /* [in] */ LONGLONG cTick,
            /* [in] */ double fRate);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *OnReadPause )( 
            IWMPCDReaderCallback __RPC_FAR * This);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *OnReadResume )( 
            IWMPCDReaderCallback __RPC_FAR * This);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *OnReadStop )( 
            IWMPCDReaderCallback __RPC_FAR * This,
            /* [in] */ HRESULT hr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnReadSample )( 
            IWMPCDReaderCallback __RPC_FAR * This,
            /* [in] */ LONGLONG iTick,
            /* [in] */ LONGLONG cTick,
            /* [in] */ IWMSBuffer __RPC_FAR *pBuffer);
        
        END_INTERFACE
    } IWMPCDReaderCallbackVtbl;

    interface IWMPCDReaderCallback
    {
        CONST_VTBL struct IWMPCDReaderCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPCDReaderCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPCDReaderCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPCDReaderCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPCDReaderCallback_OnReadStart(This,iTick,cTick,fRate)	\
    (This)->lpVtbl -> OnReadStart(This,iTick,cTick,fRate)

#define IWMPCDReaderCallback_OnReadSeek(This,iTick,cTick,fRate)	\
    (This)->lpVtbl -> OnReadSeek(This,iTick,cTick,fRate)

#define IWMPCDReaderCallback_OnReadPause(This)	\
    (This)->lpVtbl -> OnReadPause(This)

#define IWMPCDReaderCallback_OnReadResume(This)	\
    (This)->lpVtbl -> OnReadResume(This)

#define IWMPCDReaderCallback_OnReadStop(This,hr)	\
    (This)->lpVtbl -> OnReadStop(This,hr)

#define IWMPCDReaderCallback_OnReadSample(This,iTick,cTick,pBuffer)	\
    (This)->lpVtbl -> OnReadSample(This,iTick,cTick,pBuffer)

#endif /* COBJMACROS */


#endif 	/* C style interface */



void STDMETHODCALLTYPE IWMPCDReaderCallback_OnReadStart_Proxy( 
    IWMPCDReaderCallback __RPC_FAR * This,
    /* [in] */ LONGLONG iTick,
    /* [in] */ LONGLONG cTick,
    /* [in] */ double fRate);


void __RPC_STUB IWMPCDReaderCallback_OnReadStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IWMPCDReaderCallback_OnReadSeek_Proxy( 
    IWMPCDReaderCallback __RPC_FAR * This,
    /* [in] */ LONGLONG iTick,
    /* [in] */ LONGLONG cTick,
    /* [in] */ double fRate);


void __RPC_STUB IWMPCDReaderCallback_OnReadSeek_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IWMPCDReaderCallback_OnReadPause_Proxy( 
    IWMPCDReaderCallback __RPC_FAR * This);


void __RPC_STUB IWMPCDReaderCallback_OnReadPause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IWMPCDReaderCallback_OnReadResume_Proxy( 
    IWMPCDReaderCallback __RPC_FAR * This);


void __RPC_STUB IWMPCDReaderCallback_OnReadResume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IWMPCDReaderCallback_OnReadStop_Proxy( 
    IWMPCDReaderCallback __RPC_FAR * This,
    /* [in] */ HRESULT hr);


void __RPC_STUB IWMPCDReaderCallback_OnReadStop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPCDReaderCallback_OnReadSample_Proxy( 
    IWMPCDReaderCallback __RPC_FAR * This,
    /* [in] */ LONGLONG iTick,
    /* [in] */ LONGLONG cTick,
    /* [in] */ IWMSBuffer __RPC_FAR *pBuffer);


void __RPC_STUB IWMPCDReaderCallback_OnReadSample_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPCDReaderCallback_INTERFACE_DEFINED__ */


#ifndef __IWMPCDRecorderCallback_INTERFACE_DEFINED__
#define __IWMPCDRecorderCallback_INTERFACE_DEFINED__

/* interface IWMPCDRecorderCallback */
/* [local][object][version][uuid] */ 


EXTERN_C const IID IID_IWMPCDRecorderCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D3084B23-8DF9-4CAE-BCE1-CF847D2C1870")
    IWMPCDRecorderCallback : public IUnknown
    {
    public:
        virtual void STDMETHODCALLTYPE OnRecordStart( 
            /* [in] */ LONGLONG cTick) = 0;
        
        virtual void STDMETHODCALLTYPE OnRecordPause( void) = 0;
        
        virtual void STDMETHODCALLTYPE OnRecordResume( void) = 0;
        
        virtual void STDMETHODCALLTYPE OnRecordStop( 
            HRESULT hr) = 0;
        
        virtual void STDMETHODCALLTYPE OnRecordProgress( 
            /* [in] */ LONGLONG iTick) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPCDRecorderCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPCDRecorderCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPCDRecorderCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPCDRecorderCallback __RPC_FAR * This);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *OnRecordStart )( 
            IWMPCDRecorderCallback __RPC_FAR * This,
            /* [in] */ LONGLONG cTick);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *OnRecordPause )( 
            IWMPCDRecorderCallback __RPC_FAR * This);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *OnRecordResume )( 
            IWMPCDRecorderCallback __RPC_FAR * This);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *OnRecordStop )( 
            IWMPCDRecorderCallback __RPC_FAR * This,
            HRESULT hr);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *OnRecordProgress )( 
            IWMPCDRecorderCallback __RPC_FAR * This,
            /* [in] */ LONGLONG iTick);
        
        END_INTERFACE
    } IWMPCDRecorderCallbackVtbl;

    interface IWMPCDRecorderCallback
    {
        CONST_VTBL struct IWMPCDRecorderCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPCDRecorderCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPCDRecorderCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPCDRecorderCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPCDRecorderCallback_OnRecordStart(This,cTick)	\
    (This)->lpVtbl -> OnRecordStart(This,cTick)

#define IWMPCDRecorderCallback_OnRecordPause(This)	\
    (This)->lpVtbl -> OnRecordPause(This)

#define IWMPCDRecorderCallback_OnRecordResume(This)	\
    (This)->lpVtbl -> OnRecordResume(This)

#define IWMPCDRecorderCallback_OnRecordStop(This,hr)	\
    (This)->lpVtbl -> OnRecordStop(This,hr)

#define IWMPCDRecorderCallback_OnRecordProgress(This,iTick)	\
    (This)->lpVtbl -> OnRecordProgress(This,iTick)

#endif /* COBJMACROS */


#endif 	/* C style interface */



void STDMETHODCALLTYPE IWMPCDRecorderCallback_OnRecordStart_Proxy( 
    IWMPCDRecorderCallback __RPC_FAR * This,
    /* [in] */ LONGLONG cTick);


void __RPC_STUB IWMPCDRecorderCallback_OnRecordStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IWMPCDRecorderCallback_OnRecordPause_Proxy( 
    IWMPCDRecorderCallback __RPC_FAR * This);


void __RPC_STUB IWMPCDRecorderCallback_OnRecordPause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IWMPCDRecorderCallback_OnRecordResume_Proxy( 
    IWMPCDRecorderCallback __RPC_FAR * This);


void __RPC_STUB IWMPCDRecorderCallback_OnRecordResume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IWMPCDRecorderCallback_OnRecordStop_Proxy( 
    IWMPCDRecorderCallback __RPC_FAR * This,
    HRESULT hr);


void __RPC_STUB IWMPCDRecorderCallback_OnRecordStop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IWMPCDRecorderCallback_OnRecordProgress_Proxy( 
    IWMPCDRecorderCallback __RPC_FAR * This,
    /* [in] */ LONGLONG iTick);


void __RPC_STUB IWMPCDRecorderCallback_OnRecordProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPCDRecorderCallback_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\media\wmsbuffer.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Fri Jun 16 13:10:02 2000
 */
/* Compiler settings for .\wmsbuffer.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wmsbuffer_h__
#define __wmsbuffer_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __INSSBuffer_FWD_DEFINED__
#define __INSSBuffer_FWD_DEFINED__
typedef interface INSSBuffer INSSBuffer;
#endif 	/* __INSSBuffer_FWD_DEFINED__ */


#ifndef __INSSBuffer2_FWD_DEFINED__
#define __INSSBuffer2_FWD_DEFINED__
typedef interface INSSBuffer2 INSSBuffer2;
#endif 	/* __INSSBuffer2_FWD_DEFINED__ */


#ifndef __IWMSBufferAllocator_FWD_DEFINED__
#define __IWMSBufferAllocator_FWD_DEFINED__
typedef interface IWMSBufferAllocator IWMSBufferAllocator;
#endif 	/* __IWMSBufferAllocator_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_wmsbuffer_0000 */
/* [local] */ 

//=========================================================================
//
//  THIS SOFTWARE HAS BEEN LICENSED FROM MICROSOFT CORPORATION PURSUANT 
//  TO THE TERMS OF AN END USER LICENSE AGREEMENT ("EULA").  
//  PLEASE REFER TO THE TEXT OF THE EULA TO DETERMINE THE RIGHTS TO USE THE SOFTWARE.  
//
// Copyright (C) Microsoft Corporation, 1999 - 1999  All Rights Reserved.
//
//=========================================================================
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
EXTERN_GUID( IID_INSSBuffer, 0xE1CD3524,0x03D7,0x11d2,0x9E,0xED,0x00,0x60,0x97,0xD2,0xD7,0xCF );
EXTERN_GUID( IID_IWMSBuffer, 0xE1CD3524,0x03D7,0x11d2,0x9E,0xED,0x00,0x60,0x97,0xD2,0xD7,0xCF );
EXTERN_GUID( IID_IWMSBufferAllocator, 0x61103CA4,0x2033,0x11d2,0x9E,0xF1,0x00,0x60,0x97,0xD2,0xD7,0xCF );
EXTERN_GUID( IID_INSSBuffer2, 0x4f528693, 0x1035, 0x43fe, 0xb4, 0x28, 0x75, 0x75, 0x61, 0xad, 0x3a, 0x68);
#define IWMSBuffer INSSBuffer



extern RPC_IF_HANDLE __MIDL_itf_wmsbuffer_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmsbuffer_0000_v0_0_s_ifspec;

#ifndef __INSSBuffer_INTERFACE_DEFINED__
#define __INSSBuffer_INTERFACE_DEFINED__

/* interface INSSBuffer */
/* [version][uuid][unique][object][local] */ 


EXTERN_C const IID IID_INSSBuffer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E1CD3524-03D7-11d2-9EED-006097D2D7CF")
    INSSBuffer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ DWORD __RPC_FAR *pdwLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLength( 
            /* [in] */ DWORD dwLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxLength( 
            /* [out] */ DWORD __RPC_FAR *pdwLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBuffer( 
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppdwBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBufferAndLength( 
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppdwBuffer,
            /* [out] */ DWORD __RPC_FAR *pdwLength) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INSSBufferVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INSSBuffer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INSSBuffer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INSSBuffer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLength )( 
            INSSBuffer __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLength )( 
            INSSBuffer __RPC_FAR * This,
            /* [in] */ DWORD dwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxLength )( 
            INSSBuffer __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBuffer )( 
            INSSBuffer __RPC_FAR * This,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppdwBuffer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBufferAndLength )( 
            INSSBuffer __RPC_FAR * This,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppdwBuffer,
            /* [out] */ DWORD __RPC_FAR *pdwLength);
        
        END_INTERFACE
    } INSSBufferVtbl;

    interface INSSBuffer
    {
        CONST_VTBL struct INSSBufferVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INSSBuffer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INSSBuffer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INSSBuffer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INSSBuffer_GetLength(This,pdwLength)	\
    (This)->lpVtbl -> GetLength(This,pdwLength)

#define INSSBuffer_SetLength(This,dwLength)	\
    (This)->lpVtbl -> SetLength(This,dwLength)

#define INSSBuffer_GetMaxLength(This,pdwLength)	\
    (This)->lpVtbl -> GetMaxLength(This,pdwLength)

#define INSSBuffer_GetBuffer(This,ppdwBuffer)	\
    (This)->lpVtbl -> GetBuffer(This,ppdwBuffer)

#define INSSBuffer_GetBufferAndLength(This,ppdwBuffer,pdwLength)	\
    (This)->lpVtbl -> GetBufferAndLength(This,ppdwBuffer,pdwLength)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INSSBuffer_GetLength_Proxy( 
    INSSBuffer __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwLength);


void __RPC_STUB INSSBuffer_GetLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INSSBuffer_SetLength_Proxy( 
    INSSBuffer __RPC_FAR * This,
    /* [in] */ DWORD dwLength);


void __RPC_STUB INSSBuffer_SetLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INSSBuffer_GetMaxLength_Proxy( 
    INSSBuffer __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwLength);


void __RPC_STUB INSSBuffer_GetMaxLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INSSBuffer_GetBuffer_Proxy( 
    INSSBuffer __RPC_FAR * This,
    /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppdwBuffer);


void __RPC_STUB INSSBuffer_GetBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INSSBuffer_GetBufferAndLength_Proxy( 
    INSSBuffer __RPC_FAR * This,
    /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppdwBuffer,
    /* [out] */ DWORD __RPC_FAR *pdwLength);


void __RPC_STUB INSSBuffer_GetBufferAndLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INSSBuffer_INTERFACE_DEFINED__ */


#ifndef __INSSBuffer2_INTERFACE_DEFINED__
#define __INSSBuffer2_INTERFACE_DEFINED__

/* interface INSSBuffer2 */
/* [version][uuid][unique][object][local] */ 


EXTERN_C const IID IID_INSSBuffer2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4F528693-1035-43fe-B428-757561AD3A68")
    INSSBuffer2 : public INSSBuffer
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSampleProperties( 
            /* [in] */ DWORD cbProperties,
            /* [out] */ BYTE __RPC_FAR *pbProperties) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSampleProperties( 
            /* [in] */ DWORD cbProperties,
            /* [in] */ BYTE __RPC_FAR *pbProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INSSBuffer2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INSSBuffer2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INSSBuffer2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INSSBuffer2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLength )( 
            INSSBuffer2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLength )( 
            INSSBuffer2 __RPC_FAR * This,
            /* [in] */ DWORD dwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxLength )( 
            INSSBuffer2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBuffer )( 
            INSSBuffer2 __RPC_FAR * This,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppdwBuffer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBufferAndLength )( 
            INSSBuffer2 __RPC_FAR * This,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppdwBuffer,
            /* [out] */ DWORD __RPC_FAR *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSampleProperties )( 
            INSSBuffer2 __RPC_FAR * This,
            /* [in] */ DWORD cbProperties,
            /* [out] */ BYTE __RPC_FAR *pbProperties);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSampleProperties )( 
            INSSBuffer2 __RPC_FAR * This,
            /* [in] */ DWORD cbProperties,
            /* [in] */ BYTE __RPC_FAR *pbProperties);
        
        END_INTERFACE
    } INSSBuffer2Vtbl;

    interface INSSBuffer2
    {
        CONST_VTBL struct INSSBuffer2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INSSBuffer2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INSSBuffer2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INSSBuffer2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INSSBuffer2_GetLength(This,pdwLength)	\
    (This)->lpVtbl -> GetLength(This,pdwLength)

#define INSSBuffer2_SetLength(This,dwLength)	\
    (This)->lpVtbl -> SetLength(This,dwLength)

#define INSSBuffer2_GetMaxLength(This,pdwLength)	\
    (This)->lpVtbl -> GetMaxLength(This,pdwLength)

#define INSSBuffer2_GetBuffer(This,ppdwBuffer)	\
    (This)->lpVtbl -> GetBuffer(This,ppdwBuffer)

#define INSSBuffer2_GetBufferAndLength(This,ppdwBuffer,pdwLength)	\
    (This)->lpVtbl -> GetBufferAndLength(This,ppdwBuffer,pdwLength)


#define INSSBuffer2_GetSampleProperties(This,cbProperties,pbProperties)	\
    (This)->lpVtbl -> GetSampleProperties(This,cbProperties,pbProperties)

#define INSSBuffer2_SetSampleProperties(This,cbProperties,pbProperties)	\
    (This)->lpVtbl -> SetSampleProperties(This,cbProperties,pbProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INSSBuffer2_GetSampleProperties_Proxy( 
    INSSBuffer2 __RPC_FAR * This,
    /* [in] */ DWORD cbProperties,
    /* [out] */ BYTE __RPC_FAR *pbProperties);


void __RPC_STUB INSSBuffer2_GetSampleProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INSSBuffer2_SetSampleProperties_Proxy( 
    INSSBuffer2 __RPC_FAR * This,
    /* [in] */ DWORD cbProperties,
    /* [in] */ BYTE __RPC_FAR *pbProperties);


void __RPC_STUB INSSBuffer2_SetSampleProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INSSBuffer2_INTERFACE_DEFINED__ */


#ifndef __IWMSBufferAllocator_INTERFACE_DEFINED__
#define __IWMSBufferAllocator_INTERFACE_DEFINED__

/* interface IWMSBufferAllocator */
/* [version][uuid][unique][object][local] */ 


EXTERN_C const IID IID_IWMSBufferAllocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("61103CA4-2033-11d2-9EF1-006097D2D7CF")
    IWMSBufferAllocator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AllocateBuffer( 
            /* [in] */ DWORD dwMaxBufferSize,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocatePageSizeBuffer( 
            /* [in] */ DWORD dwMaxBufferSize,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSBufferAllocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMSBufferAllocator __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMSBufferAllocator __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMSBufferAllocator __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateBuffer )( 
            IWMSBufferAllocator __RPC_FAR * This,
            /* [in] */ DWORD dwMaxBufferSize,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocatePageSizeBuffer )( 
            IWMSBufferAllocator __RPC_FAR * This,
            /* [in] */ DWORD dwMaxBufferSize,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer);
        
        END_INTERFACE
    } IWMSBufferAllocatorVtbl;

    interface IWMSBufferAllocator
    {
        CONST_VTBL struct IWMSBufferAllocatorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSBufferAllocator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSBufferAllocator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSBufferAllocator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSBufferAllocator_AllocateBuffer(This,dwMaxBufferSize,ppBuffer)	\
    (This)->lpVtbl -> AllocateBuffer(This,dwMaxBufferSize,ppBuffer)

#define IWMSBufferAllocator_AllocatePageSizeBuffer(This,dwMaxBufferSize,ppBuffer)	\
    (This)->lpVtbl -> AllocatePageSizeBuffer(This,dwMaxBufferSize,ppBuffer)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMSBufferAllocator_AllocateBuffer_Proxy( 
    IWMSBufferAllocator __RPC_FAR * This,
    /* [in] */ DWORD dwMaxBufferSize,
    /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer);


void __RPC_STUB IWMSBufferAllocator_AllocateBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSBufferAllocator_AllocatePageSizeBuffer_Proxy( 
    IWMSBufferAllocator __RPC_FAR * This,
    /* [in] */ DWORD dwMaxBufferSize,
    /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer);


void __RPC_STUB IWMSBufferAllocator_AllocatePageSizeBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSBufferAllocator_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\proxy\flash\flashproxyplayer.cpp ===
// FlashProxy.cpp : Implementation of CFlashProxy
#include "stdafx.h"
#include "FlashPxy.h"
#include "FlashProxyPlayer.h"

const DWORD     NUM_FRAMES_PER_SEC  = 10;
const double    NUM_SEC_PER_FRAME   = 0.1;

const GUID GUID_ShockwaveFlash = {0xD27CDB6E,0xAE6D,0x11CF,{0x96,0xB8,0x44,0x45,0x53,0x54,0x00,0x00}};

/////////////////////////////////////////////////////////////////////////////
// CFlashProxy

CFlashProxy::CFlashProxy() :
    m_pdispFlash(0)
{
}

CFlashProxy::~CFlashProxy()
{
    m_pdispFlash = 0;
}

HRESULT STDMETHODCALLTYPE CFlashProxy::PutBstrProp(OLECHAR* pwzProp, BSTR bstrValue)
{
    VARIANTARG  vararg;
    DISPID      dispid      = NULL;
    HRESULT     hr          = S_OK;
    DISPID      dispidPut   = DISPID_PROPERTYPUT;
    DISPPARAMS  params      = {&vararg, &dispidPut, 1, 1};

    vararg.vt       = VT_BSTR;
    vararg.bstrVal  = bstrValue;

    hr = m_pdispFlash->GetIDsOfNames(IID_NULL, &pwzProp, 1, LOCALE_SYSTEM_DEFAULT, &dispid);
    if (FAILED(hr))
        goto exit;

    hr = m_pdispFlash->Invoke(dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT, DISPATCH_PROPERTYPUT,
            &params, NULL, NULL, NULL);
    if (FAILED(hr))
        goto exit;

    hr = S_OK;

exit:
    return hr;
}

HRESULT STDMETHODCALLTYPE CFlashProxy::CallMethod(OLECHAR* pwzMethod, VARIANT* pvarResult = NULL, VARIANT* pvarArgument1 = NULL)
{
    DISPID      dispid      = NULL;
    HRESULT     hr          = S_OK;
    DISPPARAMS  params      = {pvarArgument1, NULL, 0, 0};

    if (NULL != pvarArgument1)
    {
        params.cArgs = 1;
    }

    hr = m_pdispFlash->GetIDsOfNames(IID_NULL, &pwzMethod, 1, LOCALE_SYSTEM_DEFAULT, &dispid);
    if (FAILED(hr))
        goto exit;

    hr = m_pdispFlash->Invoke(dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT, DISPATCH_METHOD,
            &params, pvarResult, NULL, NULL);
    if (FAILED(hr))
        goto exit;

    hr = S_OK;

exit:
    return hr;
}

HRESULT STDMETHODCALLTYPE CFlashProxy::CreateContainedControl(void)
{
    ATLTRACE(_T("CreateContainedControl\n"));   //lint !e506

    HRESULT             hr = S_OK;
    CComBSTR            bstrHigh(L"high");
    CComBSTR            bstrTransparent(L"transparent");


    hr = CreateControl(GUID_ShockwaveFlash, IID_IDispatch,
            reinterpret_cast<void**>(&m_pdispFlash));
    
    if (FAILED(hr))
        goto exit;                

    hr = PutBstrProp(L"WMode",   bstrTransparent);
    if (FAILED(hr)) goto exit;

//    hr = PutBstrProp(L"Quality", bstrHigh);       // yields a type mismatch... 
//    if (FAILED(hr)) goto exit;                    // ....do we want to set this anyway?

    hr = S_OK;

exit:
    return hr;
}


HRESULT STDMETHODCALLTYPE CFlashProxy::begin(void)
{
    ATLTRACE(_T("begin\n"));    //lint !e506
    HRESULT hr = S_OK;

    hr = SUPER::begin();
    if (FAILED(hr))
        goto exit;


    VARIANT varArg;
    varArg.vt       = VT_I4;
    varArg.intVal   = 0;

    hr = CallMethod(L"GotoFrame", NULL, &varArg);
    if (FAILED(hr))
        goto exit;

    hr = CallMethod(L"Play");
    if (FAILED(hr))
        goto exit;

    hr = S_OK;

exit:
    return hr;
}

HRESULT STDMETHODCALLTYPE CFlashProxy::end(void)
{
    ATLTRACE(_T("end\n"));  //lint !e506
    HRESULT hr = S_OK;
    
    hr = SUPER::end();
    if (FAILED(hr))
        goto exit;

    hr = CallMethod(L"Stop");
    if (FAILED(hr))
        goto exit;

    hr = S_OK;

exit:
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CFlashProxy::resume(void)
{
    ATLTRACE(_T("resume\n"));   //lint !e506
    HRESULT hr = S_OK;
    
    hr = SUPER::resume();
    if (FAILED(hr))
        goto exit;

    hr = CallMethod(L"Play");
    if (FAILED(hr))
        goto exit;

    hr = S_OK;

exit:
    return hr;
}

HRESULT STDMETHODCALLTYPE CFlashProxy::pause(void)
{
    ATLTRACE(_T("pause\n"));    //lint !e506
    HRESULT hr = S_OK;
    
    hr = SUPER::pause();
    if (FAILED(hr))
        goto exit;

    if (m_fSuspended)
    {
        hr = CallMethod(L"Stop");
        if (FAILED(hr))
            goto exit;
    }
    else
    {
        hr = CallMethod(L"Play");
        if (FAILED(hr))
            goto exit;
    }

    hr = S_OK;

exit:
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CFlashProxy::put_src(BSTR   bstrURL)
{
    ATLTRACE(_T("put_src\n"));  //lint !e506
    HRESULT hr = S_OK;
    
    hr = SUPER::put_src(bstrURL);
    if (FAILED(hr)) 
        goto exit;

    hr = PutBstrProp(L"Movie", bstrURL);
    if (FAILED(hr)) 
        goto exit;

    NotifyPropertyChanged(DISPID_TIMEMEDIAPLAYER_MEDIADUR);
    hr = S_OK;

exit:
    return hr;
}


HRESULT STDMETHODCALLTYPE CFlashProxy::put_CurrentTime(double dblCurrentTime)
{
    HRESULT hr      = S_OK;
    VARIANT varArg;

    m_dblTime   = dblCurrentTime;

    varArg.vt   = VT_I4;
    varArg.lVal = static_cast<long>(dblCurrentTime * NUM_FRAMES_PER_SEC);

    hr = CallMethod(L"GotoFrame", NULL, &varArg);
    if (FAILED(hr))
        goto exit;

    hr = CallMethod(L"Play");
    if (FAILED(hr))
        goto exit;

    hr = S_OK;

exit:
    return hr;
}

HRESULT STDMETHODCALLTYPE CFlashProxy::get_CurrentTime(double* pdblCurrentTime)
{
    HRESULT hr = S_OK;
    VARIANT varResult;

    if (IsBadWritePtr(pdblCurrentTime, sizeof(double)))
    {
        hr = E_POINTER;
        goto exit;
    }

    hr = CallMethod(L"CurrentFrame", &varResult);
    if (FAILED(hr))
        goto exit;

    *pdblCurrentTime = varResult.lVal * NUM_SEC_PER_FRAME;

exit:
    return S_OK;
}

STDMETHODIMP CFlashProxy::Init(ITIMEMediaPlayerSite *pSite)
{
    HRESULT hr = S_OK;

    m_spTIMEMediaPlayerSite = pSite;
    if(m_spTIMEMediaPlayerSite == NULL)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = m_spTIMEMediaPlayerSite->get_timeElement(&m_spTIMEElement);
    if(FAILED(hr))
    {
        goto done;
    }

    hr = m_spTIMEMediaPlayerSite->get_timeState(&m_spTIMEState);
    if(FAILED(hr))
    {
        goto done;
    }
    InitPropSink();
done:

    CreateContainedControl();
    return S_OK;
}

STDMETHODIMP CFlashProxy::Detach(void)
{
    m_spTIMEElement.Release();
    m_spTIMEState.Release();

    DeinitPropSink();

    return S_OK;
}


STDMETHODIMP CFlashProxy::reset(void) 
{

    HRESULT hr = S_OK;
    //This is an example of how the proxy has to maintain state
    //consistency between the flash player and the timenode state.
    //The proxy player is encoded by the boolean m_fRunning while 
    //the timenode state is recovered with bNeedActive and bNeedPause.
    //The player current time must be the same as the segmentTime recovered from
    //the time node with the get_segmentTime.

#if 0
    VARIANT_BOOL bNeedActive;
    VARIANT_BOOL bNeedPause;
    double dblSegTime = 0.0, dblPlayerRate = 0.0;
    float flTeSpeed = 0.0;

    if(!m_fInPlaceActivated)
    {
        goto done;
    }

    if(m_spTIMEState == NULL || m_spTIMEElement == NULL)
    {
        goto done;
    }
    hr = m_spTIMEState->get_isActive(&bNeedActive);
    if(FAILED(hr))
    {
        goto done;
    }
    hr = m_spTIMEState->get_isPaused(&bNeedPause);
    if(FAILED(hr))
    {
        goto done;
    }
    hr = m_spTIMEState->get_segmentTime(&dblSegTime);
    if(FAILED(hr))
    {
        goto done;
    }
    hr = m_spTIMEState->get_speed(&flTeSpeed);
    if(FAILED(hr))
    {
        goto done;
    }

    if( !bNeedActive) // see if we need to stop the media.
    {
        if( m_fRunning)
        {
            end();
        }
        goto done;
    }

    if (flTeSpeed <= 0.0)
    {
        hr = S_OK;
        pause();
        goto done;
    }
    if (m_dblScaleFactor != flTeSpeed)
    {
        put_scaleFactor((double)flTeSpeed);
    }


    if( !m_fRunning)
    {
        begin(); // add a seek after this

        seek(dblSegTime);
    }
    else
    {
        //we need to be active so we also seek the media to it's correct position
        seek(dblSegTime);
    }

    //Now see if we need to change the pause state.

    if( bNeedPause)
    {
        pause();
    }
    else
    {
        resume();
    }
done:
#endif // NEVER
    return hr;
}

STDMETHODIMP CFlashProxy::repeat(void)
{
    OutputDebugString(L"CScalePlayer::repeat\n");
    return begin();
}


STDMETHODIMP CFlashProxy::seek(double dblSeekTime)
{

    return S_OK;
}


STDMETHODIMP CFlashProxy::put_clipBegin(VARIANT varClipBegin)
{
    return E_NOTIMPL;
}

STDMETHODIMP CFlashProxy::put_clipEnd(VARIANT varClipEnd)
{
    return E_NOTIMPL;
}


STDMETHODIMP CFlashProxy::get_currTime(double* pdblCurrentTime)
{
    HRESULT hr = E_UNEXPECTED;

    if (IsBadWritePtr(pdblCurrentTime, sizeof(double)))
    {
        hr = E_POINTER;
        goto done;
    }

    // In this function, convert from frames to seconds and return 
    // the current playback time.
    hr = S_OK;

done:

    return E_NOTIMPL;
}


STDMETHODIMP CFlashProxy::get_clipDur(double* pdbl)
{
    HRESULT hr = S_OK;

    return hr;
}

STDMETHODIMP CFlashProxy::get_mediaDur(double* pdbl)
{
    HRESULT hr = S_OK;

    return hr;
}


STDMETHODIMP CFlashProxy::get_state(TimeState *state)
{
    HRESULT hr = S_OK;
    if(state == NULL)
    {
        goto done;
    }

done:
    return hr;
}

STDMETHODIMP CFlashProxy::get_playList(ITIMEPlayList** plist)
{
    HRESULT hr = S_OK;
    if(plist == NULL)
    {
        goto done;
    }

done:
    return E_NOTIMPL;
}


STDMETHODIMP CFlashProxy::get_abstract(BSTR* pbstr)
{
    HRESULT hr = S_OK;
    if(pbstr == NULL)
    {
        goto done;
    }

done:
    return E_NOTIMPL;
}

STDMETHODIMP CFlashProxy::get_author(BSTR* pbstr)
{
    HRESULT hr = S_OK;
    if(pbstr == NULL)
    {
        goto done;
    }

done:
    return E_NOTIMPL;
}

STDMETHODIMP CFlashProxy::get_copyright(BSTR* pbstr)
{
    HRESULT hr = S_OK;
    if(pbstr == NULL)
    {
        goto done;
    }

done:
    return E_NOTIMPL;
}

STDMETHODIMP CFlashProxy::get_rating(BSTR* pbstr)
{
    HRESULT hr = S_OK;
    if(pbstr == NULL)
    {
        goto done;
    }

done:
    return E_NOTIMPL;
}

STDMETHODIMP CFlashProxy::get_title(BSTR* pbstr)
{
    HRESULT hr = S_OK;
    if(pbstr == NULL)
    {
        goto done;
    }

done:
    return E_NOTIMPL;
}

STDMETHODIMP CFlashProxy::get_canPause(VARIANT_BOOL* pvar)
{
    HRESULT hr = S_OK;
    if(pvar == NULL)
    {
        goto done;
    }
    *pvar = VARIANT_TRUE;

done:
    return E_NOTIMPL;
}

STDMETHODIMP CFlashProxy::get_canSeek(VARIANT_BOOL* pvar)
{
    HRESULT hr = S_OK;
    if(pvar == NULL)
    {
        goto done;
    }
    *pvar = VARIANT_TRUE;

done:
    return hr;
}

STDMETHODIMP CFlashProxy::get_hasAudio(VARIANT_BOOL* pvar)
{
    HRESULT hr = S_OK;
    if(pvar == NULL)
    {
        goto done;
    }
    *pvar = VARIANT_FALSE;

done:
    return hr;
}

STDMETHODIMP CFlashProxy::get_hasVisual(VARIANT_BOOL* pvar)
{
    HRESULT hr = S_OK;
    if(pvar == NULL)
    {
        goto done;
    }

    *pvar = VARIANT_TRUE;

done:
    return hr;
}


STDMETHODIMP CFlashProxy::get_mediaHeight(long* pl)
{
    HRESULT hr = S_OK;
    if(pl == NULL)
    {
        goto done;
    }
    *pl = -1;

done:
    return hr;
}

STDMETHODIMP CFlashProxy::get_mediaWidth(long* pl)
{
    HRESULT hr = S_OK;
    if(pl == NULL)
    {
        goto done;
    }

    *pl = -1;
done:
    return hr;
}


STDMETHODIMP CFlashProxy::get_customObject(IDispatch** ppdisp)
{
    HRESULT hr = E_NOTIMPL;

    *ppdisp = NULL;
    return hr;
}

STDMETHODIMP CFlashProxy::getControl(IUnknown ** control)
{
    HRESULT hr = E_FAIL;
    hr = _InternalQueryInterface(IID_IUnknown, (void **)control);

    return hr;
}


HRESULT CFlashProxy::GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP)
{
    return FindConnectionPoint(riid, ppICP);
} // GetConnectionPoint


HRESULT CFlashProxy::NotifyPropertyChanged(DISPID dispid)
{
    HRESULT hr;

    IConnectionPoint *pICP;
    IEnumConnections *pEnum = NULL;

    // This object does not persist anything, hence commenting out the following
    // m_fPropertiesDirty = true;

    hr = GetConnectionPoint(IID_IPropertyNotifySink,&pICP); 
    if (SUCCEEDED(hr) && pICP != NULL)
    {
        hr = pICP->EnumConnections(&pEnum);
        pICP->Release();
        if (FAILED(hr))
        {
            goto done;
        }
        CONNECTDATA cdata;
        hr = pEnum->Next(1, &cdata, NULL);
        while (hr == S_OK)
        {
            // check cdata for the object we need
            IPropertyNotifySink *pNotify;
            hr = cdata.pUnk->QueryInterface(IID_IPropertyNotifySink, (void **)&pNotify);
            cdata.pUnk->Release();
            if (FAILED(hr))
            {
                goto done;
            }
            hr = pNotify->OnChanged(dispid);
            pNotify->Release();
            if (FAILED(hr))
            {
                goto done;
            }
            // and get the next enumeration
            hr = pEnum->Next(1, &cdata, NULL);
        }
    }
done:
    if (NULL != pEnum)
    {
        pEnum->Release();
    }

    return hr;
} // NotifyPropertyChanged

HRESULT CFlashProxy::InitPropSink()
{
    HRESULT hr;
    CComPtr<IConnectionPoint> spCP;
    CComPtr<IConnectionPointContainer> spCPC;
    
    if (!m_spTIMEState)
    {
        goto done;
    }
    
    hr = m_spTIMEState->QueryInterface(IID_IConnectionPointContainer, (void **) &spCPC);
    if (FAILED(hr))
    {
        hr = S_OK;
        goto done;
    }

    // Find the IPropertyNotifySink connection
    hr = spCPC->FindConnectionPoint(IID_IPropertyNotifySink,
                                    &spCP);
    if (FAILED(hr))
    {
        hr = S_OK;
        goto done;
    }

    hr = spCP->Advise(GetUnknown(), &m_dwPropCookie);
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
  done:
    return hr;
}

void CFlashProxy::DeinitPropSink()
{
    HRESULT hr;
    CComPtr<IConnectionPoint> spCP;
    CComPtr<IConnectionPointContainer> spCPC;
    
    if (!m_spTIMEState || !m_dwPropCookie)
    {
        goto done;
    }
    
    hr = m_spTIMEState->QueryInterface(IID_IConnectionPointContainer, (void **) &spCPC);
    if (FAILED(hr))
    {
        goto done;
    }

    // Find the IPropertyNotifySink connection
    hr = spCPC->FindConnectionPoint(IID_IPropertyNotifySink,
                                    &spCP);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = spCP->Unadvise(m_dwPropCookie);
    if (FAILED(hr))
    {
        goto done;
    }
    
  done:
    // Always clear the cookie
    m_dwPropCookie = 0;
    return;
}


STDMETHODIMP
CFlashProxy::OnRequestEdit(DISPID dispID)
{
    return S_OK;
}

STDMETHODIMP
CFlashProxy::OnChanged(DISPID dispID)
{
    float flTeSpeed = 0.0;
    HRESULT hr = S_OK;

    //This function handles property change notifications fired by 
    //the time node. In the example below the speed change notification is processed.

    if(m_spTIMEState == NULL || m_spTIMEElement == NULL)
    {
        goto done;
    }

    switch(dispID)
    {
        case DISPID_TIMESTATE_SPEED:
            hr = m_spTIMEState->get_speed(&flTeSpeed);
            if(FAILED(hr))
            {
                break;
            }
            if(flTeSpeed <= 0.0)
            {
                pause(); //do not play backwards.
                break;
            }
            else
            {
                resume();
            }

            //set playback speed to flTeSpeed
            break;
        default:
            break;
    }
done:
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\proxy\flash\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Flash.rc
//
#define IDS_PROJNAME                    100
#define IDR_FLASHPROXY                  101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\proxy\flash\flashpxy.cpp ===
// Flash.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f Flashps.mk in the project directory.

#include "stdafx.h"
#include <initguid.h>
#include "FlashPxy.h"
#include "FlashPxy_i.c"
#include "FlashProxyPlayer.h"

//
// Misc stuff to keep the linker happy
//
EXTERN_C HANDLE g_hProcessHeap = NULL;  //lint !e509 // g_hProcessHeap is set by the CRT in dllcrt0.c
DWORD g_dwFALSE = 0;
//
// end of misc stuff
//


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_FlashProxy, CFlashProxy)
END_OBJECT_MAP() //lint !e785

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance/*, &LIBID_FLASHLib*/);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(/*TRUE*/);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\proxy\proxybaseimpl.h ===
#pragma once

#include <math.h>
#include <datimeid.h>
#include <comutil.h>


EXTERN_C const IID IID_ITIMEMediaPlayer;
EXTERN_C const IID DIID_TIMEMediaPlayerEvents;

HRESULT WINAPI HandleQI_IConnectionPointContainer(void* pv, REFIID riid, LPVOID* ppv, ULONG_PTR dw);

class CConnectionPointContainer :
    public CComObjectRootEx<CComSingleThreadModel>,
    public IConnectionPointContainerImpl<CConnectionPointContainer>,
    public IConnectionPointImpl<CConnectionPointContainer, &DIID_TIMEMediaPlayerEvents, CComDynamicUnkArray>,
    public IUnknown
{
public:
    CConnectionPointContainer()
    {
    }

    virtual ~CConnectionPointContainer()
    {
    }
    //
    // this class is needed to keep the IConnectionPoint::Unadvise method from 
    // colliding with the IOleObject::Unadvise method.
    //

protected:
    BEGIN_COM_MAP(CConnectionPointContainer)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    END_COM_MAP()

    BEGIN_CONNECTION_POINT_MAP(CConnectionPointContainer)
        CONNECTION_POINT_ENTRY(DIID_TIMEMediaPlayerEvents)
    END_CONNECTION_POINT_MAP()
};

/*
IUnknown
ITIMEMediaPlayer
IOleObject
IViewObject2
IDispatch
IConnectionPointContainer
IRunnableObject
IServiceProvider
IOleInPlaceObject
IOleInPlaceObjectWindowless
IOleInPlaceActiveObject
IOleInPlaceSiteWindowless
IServiceProvider
IServiceProvider
IOleInPlaceObject
*/

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
class CProxyBaseImpl :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CProxyBaseImpl<T_pCLSID, T_pLIBID>, T_pCLSID>,
    public CComControl<CProxyBaseImpl<T_pCLSID, T_pLIBID> >,
    public IDispatchImpl<ITIMEProxyPlayer, &IID_ITIMEProxyPlayer, T_pLIBID>,
    public IOleObjectImpl<CProxyBaseImpl<T_pCLSID, T_pLIBID> >,
    public IOleInPlaceObjectWindowlessImpl<CProxyBaseImpl<T_pCLSID, T_pLIBID> >,
    public IViewObjectExImpl<CProxyBaseImpl<T_pCLSID, T_pLIBID> >,
    public IRunnableObjectImpl<CProxyBaseImpl<T_pCLSID, T_pLIBID> >,
    public IOleClientSite,
    public IOleControlSite,
    public IOleInPlaceFrame,
    public IOleInPlaceSiteWindowless,
    public IOleContainer,
    public IServiceProvider,
    public IBindHost,
    public IOleInPlaceActiveObjectImpl<CProxyBaseImpl<T_pCLSID, T_pLIBID> >,
    public IAdviseSink,
    public ITIMEMediaPlayer
{
protected:
    

    //
    // TIME-related state
    //
    DWORD       m_dwLastRefTime;
    double      m_dblTime;
    bool        m_fSuspended;
    bool        m_fInitialized;
    bool        m_fMediaReady;
    CComBSTR    m_bstrSrc;

    //
    // contained control related state
    //
    DWORD       m_dwCtrlAdviseToken;

    //
    // interfaces from our container
    //
    CComPtr<IOleInPlaceSiteWindowless>  m_pContOleInPlaceSiteWindowless;
    CComPtr<IServiceProvider>           m_pContServiceProvider;

    //
    // interfaces from our contained control
    //
    CComPtr<IUnknown>                   m_pCtrlUnknown;
    CComPtr<IOleObject>                 m_pCtrlOleObject;
    CComPtr<IViewObject>                m_pCtrlViewObject;
    CComPtr<IOleInPlaceObject>          m_pCtrlOleInPlaceObject;


    STDMETHOD(CreateControl)(REFCLSID rclsid, REFIID riid, void** ppv);

    CComPtr<CComObject<CConnectionPointContainer> >     m_pCPC;
    STDMETHOD(GetCPC)(CComObject<CConnectionPointContainer>** ppCCO);

public:

    //
    // TODO: make this protected if possible
    //
    static HRESULT WINAPI HandleQI_IConnectionPointContainer(void* pv, REFIID riid, LPVOID* ppv, ULONG_PTR dw);

    CProxyBaseImpl();
    virtual ~CProxyBaseImpl();

    //
    // TODO: label these
    //
    STDMETHOD(CreateContainedControl)() = 0;
    STDMETHOD(Advise)(IAdviseSink* pAdvSink, DWORD* pdwConnection);
    STDMETHOD(Unadvise)(DWORD dwConnection);


        STDMETHOD(DoVerbInPlaceActivate)(LPCRECT prcPosRect, HWND hwndParent);

    //
    // IViewObject overloads
    //
    STDMETHOD(Draw)(DWORD dwAspect, LONG lindex, void* pvAspect, DVTARGETDEVICE* ptd, HDC hicTargetDev, HDC hdcDraw, 
                    LPCRECTL lprcBounds, LPCRECTL lprcWBounds, BOOL (__stdcall* pfnContinue)(ULONG_PTR), DWORD dwContinue);

    //
    // IOleObject overloads
    //

    STDMETHOD(SetClientSite)(IOleClientSite* pClientSite);
        STDMETHOD(Close)(DWORD dwSaveOption);

    //
    // IOleInPlaceObject overloads
    //
    STDMETHOD(SetObjectRects)(LPCRECT lprcPosRect, LPCRECT lprcClipRect);
        STDMETHOD(InPlaceDeactivate)(void);

    //
    // IAdviseSink
    //
    STDMETHOD_(void,OnClose)();
    STDMETHOD_(void,OnDataChange)(FORMATETC* pFormatetc, STGMEDIUM* pStgmed);
    STDMETHOD_(void,OnRename)(IMoniker* pmk);
    STDMETHOD_(void,OnSave)();
    STDMETHOD_(void,OnViewChange)(DWORD dwAspect, LONG lindex);

    //
    // IOleWindow
    //
    STDMETHOD(GetWindow)(HWND* phwnd);
    STDMETHOD(ContextSensitiveHelp)(BOOL fEnterMode);  // optional

    //
    // IOleInPlaceSite
    //
    STDMETHOD(CanInPlaceActivate)();
    STDMETHOD(OnInPlaceActivate)();
    STDMETHOD(OnUIActivate)();
    STDMETHOD(GetWindowContext)(IOleInPlaceFrame **ppFrame, IOleInPlaceUIWindow **ppDoc, RECT* lprcPosRect,
                                RECT* lprcClipRect, LPOLEINPLACEFRAMEINFO lpFrameInfo);
    STDMETHOD(Scroll)(SIZE scrollExtent);
    STDMETHOD(OnUIDeactivate)(BOOL fUndoable);
    STDMETHOD(OnInPlaceDeactivate)();
    STDMETHOD(DiscardUndoState)();
    STDMETHOD(DeactivateAndUndo)();
    STDMETHOD(OnPosRectChange)(LPCRECT lprcPosRect);

    //
    // IOleInPlaceSiteEx
    //
    STDMETHOD(OnInPlaceActivateEx)(BOOL* pfNoRedraw, DWORD dwFlags);
    STDMETHOD(OnInPlaceDeactivateEx)(BOOL fNoRedraw);
    STDMETHOD(RequestUIActivate)();

    //
    // IOleInPlaceSiteWindowless
    //
    STDMETHOD(CanWindowlessActivate)(void);
    STDMETHOD(GetCapture)(void);
    STDMETHOD(SetCapture)(BOOL fCapture);
    STDMETHOD(GetFocus)(void);
    STDMETHOD(SetFocus)(BOOL fFocus);
    STDMETHOD(GetDC)(LPCRECT pRect, DWORD grfFlags, HDC* phDC);
    STDMETHOD(ReleaseDC)(HDC hDC);
    STDMETHOD(InvalidateRect)(LPCRECT pRect, BOOL fErase);
    STDMETHOD(InvalidateRgn)(HRGN hRGN, BOOL fErase);
    STDMETHOD(ScrollRect)(int dx, int dy, LPCRECT pRectScroll, LPCRECT pRectClip);
    STDMETHOD(AdjustRect)(LPRECT prc);
    STDMETHOD(OnDefWindowMessage)(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT* plResult);

    //
    // IOleInPlaceUIWindow
    //  
    STDMETHOD(GetBorder)(LPRECT lprectBorder);   // not required
    STDMETHOD(RequestBorderSpace)(LPCBORDERWIDTHS pborderwidths);  // not required
    STDMETHOD(SetBorderSpace)(LPCBORDERWIDTHS pborderwidths);      // not required
    STDMETHOD(SetActiveObject)(IOleInPlaceActiveObject *pActiveObject, LPCOLESTR pszObjName);
    STDMETHOD(InsertMenus)(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths);  // not required
    STDMETHOD(SetMenu)(HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject); // not required
    STDMETHOD(RemoveMenus)(HMENU hmenuShared); // not required
    STDMETHOD(SetStatusText)(LPCOLESTR pszStatusText); // not required
    STDMETHOD(EnableModeless)(BOOL fEnable); // optional
    STDMETHOD(TranslateAccelerator)(LPMSG lpmsg, WORD wID); // not required

    //
    // IOleControlSite
    //
    STDMETHOD(OnControlInfoChanged)();
    STDMETHOD(LockInPlaceActive)(BOOL fLock);   // optional
    STDMETHOD(GetExtendedControl)(IDispatch** ppDisp);  // not required
    STDMETHOD(TransformCoords)(POINTL* pPtlHimetric, POINTF* pPtfContainer, DWORD dwFlags);
    STDMETHOD(TranslateAccelerator)(LPMSG lpmsg, DWORD dwID);
    STDMETHOD(OnFocus)(BOOL fGotFocus);
    STDMETHOD(ShowPropertyFrame)();   // not required

    //
    // IParseDisplayName
    //
    STDMETHOD(ParseDisplayName)(IBindCtx* pbc, LPOLESTR pszDisplayName, ULONG* pchEaten, IMoniker** ppmkOut); // not required

    //
    // IOleContainer
    //
    STDMETHOD(EnumObjects)(DWORD grfFlags, IEnumUnknown** ppenum); // not required
    STDMETHOD(LockContainer)(BOOL fLock); // not required

    //
    // IOleClientSite
    //
    STDMETHOD(SaveObject)(); // not required
    STDMETHOD(GetMoniker)(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker** ppmk); // not required
    STDMETHOD(GetContainer)(IOleContainer** ppContainer);
    STDMETHOD(ShowObject)();
    STDMETHOD(OnShowWindow)(BOOL fShow);
    STDMETHOD(RequestNewObjectLayout)();

    //
    // IServiceProvider
    //
    STDMETHOD(QueryService)(REFGUID guidService, REFIID riid, void** ppv);

    //
    // IBindHost
    //
    STDMETHOD(CreateMoniker)(LPOLESTR szName, IBindCtx* pBC, IMoniker** ppmk, DWORD dwReserved);
    STDMETHOD(MonikerBindToObject)(IMoniker* pMk, IBindCtx* pBC, IBindStatusCallback* pBSC, REFIID riid, void** ppvObj);
    STDMETHOD(MonikerBindToStorage)(IMoniker* pMk, IBindCtx* pBC, IBindStatusCallback* pBSC, REFIID riid, void** ppvObj);

    //
    // ITIMEMediaPlayer
    //
    STDMETHOD(Init)(void);
    STDMETHOD(clipBegin)(VARIANT varClipBegin);
    STDMETHOD(clipEnd)(VARIANT varClipEnd);
    STDMETHOD(begin)(void);
    STDMETHOD(end)(void);
    STDMETHOD(resume)(void);
    STDMETHOD(pause)(void);
    STDMETHOD(tick)(void);
    STDMETHOD(put_CurrentTime)(double   dblCurrentTime);
    STDMETHOD(get_CurrentTime)(double* pdblCurrentTime);
    STDMETHOD(put_src)(BSTR   bstrURL);
    STDMETHOD(get_src)(BSTR* pbstrURL);
    STDMETHOD(put_repeat)(long   lTime);
    STDMETHOD(get_repeat)(long* plTime);
    STDMETHOD(cue)(void);

    //
    // ITIMEProxyPlayer
    //
    STDMETHOD(get_playerObject)(IDispatch** ppdispPlayerObject);

BEGIN_COM_MAP(CProxyBaseImpl)
    COM_INTERFACE_ENTRY(ITIMEMediaPlayer)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IOleClientSite)
    COM_INTERFACE_ENTRY(IOleInPlaceFrame)
    COM_INTERFACE_ENTRY(IOleInPlaceSiteEx)
    COM_INTERFACE_ENTRY(IOleInPlaceSiteWindowless)
    COM_INTERFACE_ENTRY(IOleContainer)
    COM_INTERFACE_ENTRY(IServiceProvider)
    COM_INTERFACE_ENTRY(IBindHost)
    COM_INTERFACE_ENTRY(IOleControlSite)
    COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceSiteWindowless)
    COM_INTERFACE_ENTRY2(IOleInPlaceActiveObject, IOleInPlaceActiveObjectImpl<CProxyBaseImpl>)
    COM_INTERFACE_ENTRY2(IOleInPlaceObject, IOleInPlaceObjectWindowlessImpl<CProxyBaseImpl>)
    COM_INTERFACE_ENTRY2(IViewObject2, IViewObjectExImpl<CProxyBaseImpl>)
    COM_INTERFACE_ENTRY_IMPL(IOleObject)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL(IRunnableObject)
    COM_INTERFACE_ENTRY_FUNC(IID_IConnectionPointContainer, 0, HandleQI_IConnectionPointContainer)
END_COM_MAP()

BEGIN_MSG_MAP(CProxyBaseImpl) //lint !e1735 !e522
END_MSG_MAP() //lint !e725 !e550 !e529

};

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::CreateControl(REFCLSID rclsid, REFIID riid, void** ppv)
{
    ATLTRACE(_T("CreateControl\n"));

    if (IsBadWritePtr(ppv, sizeof(void*)))
        return E_POINTER;


    HRESULT hr = S_OK;

    hr = CoCreateInstance(rclsid, NULL, CLSCTX_INPROC, IID_IUnknown, 
            reinterpret_cast<void**>(&m_pCtrlUnknown));
    if (FAILED(hr))
        return hr;

    hr = m_pCtrlUnknown->QueryInterface(IID_IOleObject, 
            reinterpret_cast<void**>(&m_pCtrlOleObject));
    if (FAILED(hr))
        return hr;

    hr = m_pCtrlUnknown->QueryInterface(IID_IViewObject, 
            reinterpret_cast<void**>(&m_pCtrlViewObject));
    if (FAILED(hr))
        return hr;

    hr = m_pCtrlUnknown->QueryInterface(IID_IOleInPlaceObject, 
            reinterpret_cast<void**>(&m_pCtrlOleInPlaceObject));
    if (FAILED(hr))
        return hr;

    hr = m_pCtrlUnknown->QueryInterface(riid, ppv);
    if (FAILED(hr))
        return hr;

    return S_OK;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::Advise(IAdviseSink* pAdvSink, DWORD* pdwConnection)
{
    HRESULT hr = S_OK;
    ATLTRACE(_T("Advise\n"));
    hr = IOleObjectImpl<CProxyBaseImpl<T_pCLSID, T_pLIBID> >::Advise(pAdvSink, pdwConnection);
    if (FAILED(hr))
        return hr;

    //
    //
    //
    ASSERT(NULL == m_dwCtrlAdviseToken);
    if (m_pCtrlOleObject == NULL)
    {
        hr = S_OK;
        return hr;
    }
    hr = m_pCtrlOleObject->Advise(static_cast<IAdviseSink*>(this), &m_dwCtrlAdviseToken);
    //
    //
    //

    return hr;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::Unadvise(DWORD dwConnection)
{
    HRESULT hr = S_OK;
    ATLTRACE(_T("Unadvise\n"));
    hr = IOleObjectImpl<CProxyBaseImpl<T_pCLSID, T_pLIBID> >::Unadvise(dwConnection);
    if (FAILED(hr))
        return hr;

    //
    //
    //
    if (m_pCtrlOleObject && m_dwCtrlAdviseToken)
    {
        hr = m_pCtrlOleObject->Unadvise(m_dwCtrlAdviseToken);
    }
    //
    //
    //

    m_dwCtrlAdviseToken = 0;
    return hr;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::DoVerbInPlaceActivate(LPCRECT prcPosRect, HWND hwndParent)
{
    ATLTRACE(_T("DoVerbInPlaceActivate\n"));
    HRESULT hr = S_OK;

//    hr = InPlaceActivate(OLEIVERB_INPLACEACTIVATE, prcPosRect);
    hr = IOleObjectImpl<CProxyBaseImpl<T_pCLSID, T_pLIBID> >::DoVerbInPlaceActivate(prcPosRect, hwndParent);
    if (FAILED(hr))
        return hr;

    //
    // activate contained control
    //

    if (m_pCtrlOleObject == NULL)
    {
        hr = E_POINTER;
        return hr;
    }
    hr = m_pCtrlOleObject->DoVerb(OLEIVERB_INPLACEACTIVATE, NULL, static_cast<IOleClientSite*>(this),
        0, hwndParent, prcPosRect);
        return hr;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::Draw(DWORD dwAspect, 
    LONG lindex, 
    void* pvAspect, 
    DVTARGETDEVICE* ptd, 
    HDC hicTargetDev, 
    HDC hdcDraw, 
    LPCRECTL lprcBounds, 
    LPCRECTL lprcWBounds, 
    BOOL (__stdcall* pfnContinue)(ULONG_PTR), 
    DWORD dwContinue)
{
    ATLTRACE(_T("Draw\n"));
    HRESULT hr = S_OK;
    hr = m_pCtrlViewObject->Draw(dwAspect, lindex, pvAspect, ptd, hicTargetDev, hdcDraw, lprcBounds, lprcWBounds, pfnContinue, dwContinue);
    return hr;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::SetClientSite(IOleClientSite* pClientSite)
{
    ATLTRACE(_T("SetClientSite\n"));
    HRESULT hr      = S_OK;

    //
    // TODO: do we need this call to the super?
    //
    hr = IOleObjectImpl<CProxyBaseImpl>::SetClientSite(pClientSite);
    if (FAILED(hr))
        goto exit;

    if (NULL == pClientSite)
    {
        ATLTRACE(_T("setting null client site\n"));

        if (m_pCtrlOleObject.p)
        {
            m_pCtrlOleObject->SetClientSite(NULL);
        }

        m_dwLastRefTime                 = 0;
        m_dblTime                       = 0.0;
        m_fSuspended                    = false;
        m_fInitialized                  = false;
        m_fMediaReady                   = false;
        m_bstrSrc.Empty();
        m_dwCtrlAdviseToken             = 0;
        m_pContOleInPlaceSiteWindowless = 0;
        m_pContServiceProvider          = 0;
        m_pCtrlUnknown                  = 0;
        m_pCtrlOleObject                = 0;
        m_pCtrlViewObject               = 0;
        m_pCtrlOleInPlaceObject         = 0;

        hr = S_OK;
        goto exit;
    }

    hr = pClientSite->QueryInterface(IID_IOleInPlaceSiteWindowless, 
            reinterpret_cast<void**>(&m_pContOleInPlaceSiteWindowless));
    if (FAILED(hr))
        goto exit;

    hr = pClientSite->QueryInterface(IID_IServiceProvider,
            reinterpret_cast<void**>(&m_pContServiceProvider));
    if (FAILED(hr))
        goto exit;

    hr = CreateContainedControl();
    if (FAILED(hr))
        goto exit;

    if (m_pCtrlOleObject)
    {
        m_pCtrlOleObject->SetClientSite(this);
    }

    m_fInitialized = true;

exit:
    return S_OK;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
void STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::OnClose()
{
    ATLTRACE(_T("OnClose\n"));
        m_spOleAdviseHolder->SendOnClose();
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
void STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::OnDataChange(FORMATETC* pFormatetc, STGMEDIUM* pStgmed)
{
    ATLTRACE(_T("OnDataChange\n"));
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
void STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::OnRename(IMoniker* pmk)
{
    ATLTRACE(_T("OnRename\n"));
        m_spOleAdviseHolder->SendOnRename(pmk);
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
void STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::OnSave()
{
    ATLTRACE(_T("OnSave\n"));
        m_spOleAdviseHolder->SendOnSave();
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
void STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::OnViewChange(DWORD dwAspect, LONG lindex)
{
    ATLTRACE(_T("OnViewChange\n"));
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::GetWindow(HWND* phwnd)
{
    ATLTRACE(_T("GetWindow\n"));
    return m_pContOleInPlaceSiteWindowless->GetWindow(phwnd);
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::ContextSensitiveHelp(BOOL fEnterMode)  // optional
{
    ATLTRACE(_T("ContextSensitiveHelp\n"));
    return m_pContOleInPlaceSiteWindowless->ContextSensitiveHelp(fEnterMode);
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::CanInPlaceActivate()
{
    ATLTRACE(_T("CanInPlaceActivate\n"));
    return m_pContOleInPlaceSiteWindowless->CanInPlaceActivate();
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::OnInPlaceActivate()
{
    ATLTRACE(_T("OnInPlaceActivate\n"));
    //
    // We don't want to pass this up to our container because
    // we already call this on our container.  This is our 
    // notification from our client.  Only.  That's it.
    //
    return S_OK;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::OnUIActivate()
{
    ATLTRACE(_T("OnUIActivate\n"));
    //
    // We don't want to pass this up to our container because
    // we already call this on our container.  This is our 
    // notification from our client.  Only.  That's it.
    //
    return S_OK;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::GetWindowContext(IOleInPlaceFrame **ppFrame,
  IOleInPlaceUIWindow **ppDoc,
  RECT* lprcPosRect,
  RECT* lprcClipRect,
  LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
    ATLTRACE(_T("GetWindowContext\n"));
    HRESULT hr = S_OK;
    CComPtr<IOleInPlaceFrame>       pFrame;
    CComPtr<IOleInPlaceUIWindow>    pDoc;

    hr = m_pContOleInPlaceSiteWindowless->GetWindowContext(&pFrame, &pDoc, lprcPosRect, lprcClipRect, lpFrameInfo);
    if (FAILED(hr))
        return hr;

    //
    // NOTE: since flash doesn't seem to care about these pointers,
    //       we're not going to give them to it so that it can't get
    //       around the proxy and directly muck with our container.
    //

    *ppFrame    = NULL;
    *ppDoc      = NULL;

    return hr;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::Scroll(SIZE scrollExtent)
{
    ATLTRACE(_T("Scroll\n"));
    return m_pContOleInPlaceSiteWindowless->Scroll(scrollExtent);
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::OnUIDeactivate(BOOL fUndoable)
{
    ATLTRACE(_T("OnUIDeactivate\n"));
    //
    // We don't want to pass this up to our container because
    // we already call this on our container.  This is our 
    // notification from our client.  Only.  That's it.
    //
    return S_OK;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::OnInPlaceDeactivate()
{
    ATLTRACE(_T("OnInPlaceDeactivate\n"));
    //
    // We don't want to pass this up to our container because
    // we already call this on our container.  This is our 
    // notification from our client.  Only.  That's it.
    //
    return S_OK;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::DiscardUndoState()
{
    ATLTRACE(_T("DiscardUndoState\n"));
    return m_pContOleInPlaceSiteWindowless->DiscardUndoState();
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::DeactivateAndUndo()
{
    ATLTRACE(_T("DeactivateAndUndo\n"));
    return m_pContOleInPlaceSiteWindowless->DeactivateAndUndo();
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::OnPosRectChange(LPCRECT lprcPosRect)
{
    ATLTRACE(_T("OnPosRectChange\n"));
    return m_pContOleInPlaceSiteWindowless->OnPosRectChange(lprcPosRect);
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::OnInPlaceActivateEx(BOOL* pfNoRedraw, DWORD dwFlags)
{
    ATLTRACE(_T("OnInPlaceActivateEx\n"));
    //
    // We don't want to pass this up to our container because
    // we already call this on our container.  This is our 
    // notification from our client.  Only.  That's it.
    //
    return S_OK;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::OnInPlaceDeactivateEx(BOOL fNoRedraw)
{
    ATLTRACE(_T("OnInPlaceDeactivateEx\n"));
    //
    // We don't want to pass this up to our container because
    // we already call this on our container.  This is our 
    // notification from our client.  Only.  That's it.
    //
    return S_OK;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::RequestUIActivate()
{
    ATLTRACE(_T("RequestUIActivate\n"));
    return m_pContOleInPlaceSiteWindowless->RequestUIActivate();
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::CanWindowlessActivate(void)
{
    ATLTRACE(_T("CanWindowlessActivate\n"));
    return m_pContOleInPlaceSiteWindowless->CanWindowlessActivate();
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::GetCapture(void)
{
    ATLTRACE(_T("GetCapture\n"));
    return m_pContOleInPlaceSiteWindowless->GetCapture();
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::SetCapture(BOOL fCapture)
{
    ATLTRACE(_T("SetCapture\n"));
    return m_pContOleInPlaceSiteWindowless->SetCapture(fCapture);
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::GetFocus(void)
{
    ATLTRACE(_T("GetFocus\n"));
    return m_pContOleInPlaceSiteWindowless->GetFocus();
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::SetFocus(BOOL fFocus)
{
    ATLTRACE(_T("SetFocus\n"));
    return m_pContOleInPlaceSiteWindowless->SetFocus(fFocus);
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::GetDC(LPCRECT pRect, DWORD grfFlags, HDC* phDC)
{
    ATLTRACE(_T("GetDC\n"));
    return m_pContOleInPlaceSiteWindowless->GetDC(pRect, grfFlags, phDC);
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::ReleaseDC(HDC hDC)
{
    ATLTRACE(_T("ReleaseDC\n"));
    return m_pContOleInPlaceSiteWindowless->ReleaseDC(hDC);
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::InvalidateRect(LPCRECT pRect, BOOL fErase)
{
    ATLTRACE(_T("InvalidateRect\n"));
    return m_pContOleInPlaceSiteWindowless->InvalidateRect(pRect, fErase);
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::InvalidateRgn(HRGN hRGN, BOOL fErase)
{
    ATLTRACE(_T("InvalidateRgn\n"));
    return m_pContOleInPlaceSiteWindowless->InvalidateRgn(hRGN, fErase);
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::ScrollRect(int dx, int dy, LPCRECT pRectScroll, LPCRECT pRectClip)
{
    ATLTRACE(_T("ScrollRect\n"));
    return m_pContOleInPlaceSiteWindowless->ScrollRect(dx, dy, pRectScroll, pRectClip);
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::AdjustRect(LPRECT prc)
{
    ATLTRACE(_T("AdjustRect\n"));
    return m_pContOleInPlaceSiteWindowless->AdjustRect(prc);
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::OnDefWindowMessage(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT* plResult)
{
    ATLTRACE(_T("OnDefWindowMessage\n"));
    return m_pContOleInPlaceSiteWindowless->OnDefWindowMessage(msg, wParam, lParam, plResult);
}






template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::GetBorder(LPRECT lprectBorder)   // not required
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::GetBorder"));
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::RequestBorderSpace(LPCBORDERWIDTHS pborderwidths)  // not required
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::RequestBorderSpace"));
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::SetBorderSpace(LPCBORDERWIDTHS pborderwidths)      // not required
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::SetBorderSpace"));
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::SetActiveObject(IOleInPlaceActiveObject *pActiveObject, LPCOLESTR pszObjName)
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::SetActiveObject"));
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::InsertMenus(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths)  // not required
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::InsertMenus"));
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::SetMenu(HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject) // not required
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::SetMenu"));
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::RemoveMenus(HMENU hmenuShared) // not required
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::RemoveMenus"));
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::SetStatusText(LPCOLESTR pszStatusText) // not required
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::SetStatusText"));
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::EnableModeless(BOOL fEnable) // optional
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::EnableModeless"));
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::TranslateAccelerator(LPMSG lpmsg, WORD wID) // not required
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::TranslateAccelerator"));
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::OnControlInfoChanged()
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::OnControlInfoChanged"));
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::LockInPlaceActive(BOOL fLock)   // optional
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::LockInPlaceActive"));
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::GetExtendedControl(IDispatch** ppDisp)  // not required
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::GetExtendedControl"));
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::TransformCoords(POINTL* pPtlHimetric, POINTF* pPtfContainer, DWORD dwFlags)
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::TransformCoords"));
}






template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::TranslateAccelerator(LPMSG lpmsg, DWORD dwID)
{
    return S_FALSE;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::OnFocus(BOOL fGotFocus)
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::OnFocus"));
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::ShowPropertyFrame()   // not required
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::ShowPropertyFrame"));
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::ParseDisplayName(IBindCtx* pbc, LPOLESTR pszDisplayName, ULONG* pchEaten, IMoniker** ppmkOut) // not required
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::ParseDisplayName"));
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::EnumObjects(DWORD grfFlags, IEnumUnknown** ppenum) // not required
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::EnumObjects"));
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::LockContainer(BOOL fLock) // not required
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::LockContainer"));
}





template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::SaveObject() // not required
{
    ATLTRACE(_T("SaveObject\n"));
    return m_spClientSite->SaveObject();
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker** ppmk) // not required
{
    ATLTRACE(_T("GetMoniker\n"));
    return m_spClientSite->GetMoniker(dwAssign, dwWhichMoniker, ppmk);
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::GetContainer(IOleContainer** ppContainer)
{
    ATLTRACE(_T("GetContainer\n"));
    return m_spClientSite->GetContainer(ppContainer);
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::ShowObject()
{
    ATLTRACE(_T("ShowObject\n"));
    return m_spClientSite->ShowObject();
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::OnShowWindow(BOOL fShow)
{
    ATLTRACE(_T("OnShowWindow\n"));
    return m_spClientSite->OnShowWindow(fShow);
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::RequestNewObjectLayout()
{
    ATLTRACE(_T("RequestNewObjectLayout\n"));
    return m_spClientSite->RequestNewObjectLayout();
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::QueryService(REFGUID guidService, REFIID riid, void** ppv)
{
    ATLTRACE(_T("QueryService\n"));
    if (!m_pContServiceProvider)
    {
        return S_OK;
    }

    return m_pContServiceProvider->QueryService(guidService, riid, ppv);
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::CreateMoniker(LPOLESTR szName, IBindCtx* pBC, IMoniker** ppmk, DWORD dwReserved)
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::CreateMoniker"));
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::MonikerBindToObject(IMoniker* pMk, IBindCtx* pBC, IBindStatusCallback* pBSC, REFIID riid, void** ppvObj)
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::MonikerBindToObject"));
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::MonikerBindToStorage(IMoniker* pMk, IBindCtx* pBC, IBindStatusCallback* pBSC, REFIID riid, void** ppvObj)
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::MonikerBindToStorage"));
}

//
// ITIMEMediaPlayer
//

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::Init(void)
{
    return S_OK;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::clipBegin(VARIANT varClipBegin)
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::clipBegin"));
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::clipEnd(VARIANT varClipEnd)
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::clipEnd"));
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::begin(void)
{
    m_fSuspended    = false;
    m_dwLastRefTime = timeGetTime();
    m_dblTime       = 0;

    return S_OK;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::end(void)
{
    m_fSuspended = true;
    m_dblTime    = -HUGE_VAL;
    return S_OK;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::resume(void)
{
    m_fSuspended    = false;
    m_dwLastRefTime = timeGetTime();
    return S_OK;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::pause(void)
{
    m_fSuspended = true;
    return S_OK;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::tick(void)
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::tick"));
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::put_CurrentTime(double   dblCurrentTime)
{
    m_dblTime = dblCurrentTime;
    return S_OK;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::get_CurrentTime(double* pdblCurrentTime)
{
    if (IsBadWritePtr(pdblCurrentTime, sizeof(double)))
        return E_POINTER;

    if (!m_fSuspended)
    {
        DWORD   dwNow;
        long    lDiff;

        dwNow   = timeGetTime();
        lDiff   = dwNow - m_dwLastRefTime;
        m_dwLastRefTime = dwNow;

        if (lDiff < 0)
            lDiff = -lDiff;

        m_dblTime += (lDiff / 1000.0);
    }

    *pdblCurrentTime = m_dblTime;

    return S_OK;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::put_src(BSTR   bstrURL)
{
    m_bstrSrc = bstrURL;
    return S_OK;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::get_src(BSTR* pbstrURL)
{
    if (IsBadWritePtr(pbstrURL, sizeof(BSTR)))
        return E_POINTER;

    *pbstrURL = m_bstrSrc.Copy();
    if (NULL == *pbstrURL)
        return E_OUTOFMEMORY;

    return S_OK;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::put_repeat(long   lTime)
{
    return S_OK;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::get_repeat(long* plTime)
{
    if (IsBadWritePtr(plTime, sizeof(long*)))
        return E_POINTER;

    *plTime = 1;
    return S_OK;
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::cue(void)
{
    ATLTRACENOTIMPL(_T("CProxyBaseImpl::cue"));
}


template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::SetObjectRects(LPCRECT lprcPosRect, LPCRECT lprcClipRect)
{
    ATLTRACE(_T("SetObjectRects\n"));
    HRESULT                     hr = S_OK;
    CComPtr<IOleInPlaceObject>  pInPlaceObject;

    if (!m_fInitialized)
        return E_UNEXPECTED;

    if (!m_pCtrlOleInPlaceObject)
    {
        return S_OK;
    }

    hr = m_pCtrlOleInPlaceObject->SetObjectRects(lprcPosRect, lprcClipRect);
    return hr;
}


template <const CLSID* T_pCLSID, const IID* T_pLIBID>
CProxyBaseImpl<T_pCLSID, T_pLIBID>::CProxyBaseImpl() :
    m_dwLastRefTime(0),
    m_dblTime(0),
    m_fSuspended(false),
    m_fInitialized(false),
    m_fMediaReady(false),
    m_bstrSrc(),
    m_dwCtrlAdviseToken(0),
    m_pContOleInPlaceSiteWindowless(0),
    m_pContServiceProvider(0),
    m_pCtrlUnknown(0),
    m_pCtrlOleObject(0),
    m_pCtrlViewObject(0),
    m_pCtrlOleInPlaceObject(0)
{
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
CProxyBaseImpl<T_pCLSID, T_pLIBID>::~CProxyBaseImpl()
{
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::InPlaceDeactivate(void)
{
    ATLTRACE(_T("InPlaceDeactivate\n"));
    HRESULT hr = S_OK;
    hr = IOleInPlaceObjectWindowlessImpl<CProxyBaseImpl<T_pCLSID, T_pLIBID> >::InPlaceDeactivate();
    if (FAILED(hr))
        return hr;

    if (!m_pCtrlOleInPlaceObject)
    {
        return S_OK;
    }

    hr = m_pCtrlOleInPlaceObject->InPlaceDeactivate();
    return hr;
}


template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::Close(DWORD dwSaveOption)
{
    ATLTRACE(_T("Close\n"));
    HRESULT hr = S_OK;
    hr = IOleObjectImpl<CProxyBaseImpl<T_pCLSID, T_pLIBID> >::Close(dwSaveOption);
    if (FAILED(hr))
        return hr;

    if (m_pCtrlOleObject == NULL)
    {
        hr = E_POINTER;
        return hr;
    }
    hr = m_pCtrlOleObject->Close(dwSaveOption);
    return hr;
}


template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::GetCPC(CComObject<CConnectionPointContainer>** ppCCO)
{
    if (IsBadWritePtr(ppCCO, sizeof(CComObject<CConnectionPointContainer>*)))
        return E_POINTER;

    if (m_pCPC == NULL)
    {
        //
        // TODO: check for failure
        //
        CComObject<CConnectionPointContainer>::CreateInstance(&m_pCPC);
    }

    *ppCCO = m_pCPC;
    m_pCPC.p->AddRef();
    return S_OK;
}


template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT WINAPI CProxyBaseImpl<T_pCLSID, T_pLIBID>::HandleQI_IConnectionPointContainer(
    void* pv, REFIID riid, LPVOID* ppv, ULONG_PTR dw)
{
    HRESULT hr;
    CComObject<CConnectionPointContainer>* pCPC;

    CProxyBaseImpl<T_pCLSID, T_pLIBID>*  pClass = 
        reinterpret_cast<CProxyBaseImpl<T_pCLSID, T_pLIBID>*>(pv);

    hr = pClass->GetCPC(&pCPC);
    if (FAILED(hr))
        return hr;

    return pCPC->QueryInterface(riid, ppv);
}

template <const CLSID* T_pCLSID, const IID* T_pLIBID>
HRESULT STDMETHODCALLTYPE CProxyBaseImpl<T_pCLSID, T_pLIBID>::get_playerObject(IDispatch** ppdispPlayerObject)
{
    HRESULT hr = S_OK;

    if (IsBadWritePtr(ppdispPlayerObject, sizeof(IDispatch*)))
    {
        hr = E_POINTER;
        goto done;
    }

    if (m_pCtrlOleObject == NULL)
    {
        hr = E_POINTER;
        return hr;
    }
    m_pCtrlUnknown->QueryInterface(IID_IDispatch, 
        reinterpret_cast<void**>(ppdispPlayerObject));

    hr = S_OK;

done:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\proxy\wmp\comutil.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _COMUTIL_H
#define _COMUTIL_H

#define SET_NULL(x) {if (x) *(x) = NULL;}

#define CHECK_RETURN_NULL(x) {if (!(x)) return E_POINTER;}
#define CHECK_RETURN_SET_NULL(x) {if (!(x)) { return E_POINTER ;} else {*(x) = NULL;}}


template <class T>
class DAComPtr
{
  public:
    typedef T _PtrClass;
    DAComPtr() { p = NULL; }
    DAComPtr(T* lp, bool baddref = true)
    {
        p = lp;
        if (p != NULL && baddref)
            p->AddRef();
    }
    DAComPtr(const DAComPtr<T>& lp, bool baddref = true)
    {
        p = lp.p;

        if (p != NULL && baddref)
            p->AddRef();
    }
    ~DAComPtr() {
        if (p) p->Release();
    }
    void Release() {
        if (p) p->Release();
        p = NULL;
    }
    operator T*() { return (T*)p; }
    operator T*() const { return (T*)p; }
    T& operator*() { Assert(p != NULL); return *p; }
    T& operator*() const { Assert(p != NULL); return *p; }
    //The assert on operator& usually indicates a bug.  If this is really
    //what is needed, however, take the address of the p member explicitly.
    T** operator&() { Assert(p == NULL); return &p; }
    T* operator->() { Assert(p != NULL); return p; }
    T* operator->() const { Assert(p != NULL); return p; }
    T* operator=(T* lp)
    {
        return Assign(lp);
    }
    T* operator=(const DAComPtr<T>& lp)
    {
        return Assign(lp.p);
    }

    bool operator!() const { return (p == NULL); }
    operator bool() const { return (p != NULL); }

    T* p;
  protected:
    T* Assign(T* lp) {
        if (lp != NULL)
            lp->AddRef();

        if (p)
            p->Release();

        p = lp;

        return lp;
    }
};

//
// This is copied almost directly from atlcom.h.  It only changes the
// way we load the typelib to not use the registry but the current
// DLL.
//

// Create our own CComTypeInfoHolder so we can ensure which typelib is
// loaded

class CTIMEComTypeInfoHolder
{
// Should be 'protected' but can cause compiler to generate fat code.
public:
        const GUID* m_pguid;
        const TCHAR * m_ptszIndex;

        ITypeInfo* m_pInfo;
        long m_dwRef;

public:
        HRESULT GetTI(LCID lcid, ITypeInfo** ppInfo);

        void AddRef();
        void Release();
        HRESULT GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
        HRESULT GetIDsOfNames(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
                LCID lcid, DISPID* rgdispid);
        HRESULT Invoke(IDispatch* p, DISPID dispidMember, REFIID riid,
                LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
                EXCEPINFO* pexcepinfo, UINT* puArgErr);
};

/////////////////////////////////////////////////////////////////////////////
// ITIMEDispatchImpl

template <class T,
          const IID* piid,
          const TCHAR * ptszIndex = NULL,
          class tihclass = CTIMEComTypeInfoHolder>
class ATL_NO_VTABLE ITIMEDispatchImpl : public T
{
public:
        typedef tihclass _tihclass;
        ITIMEDispatchImpl() {_tih.AddRef();}
        virtual ~ITIMEDispatchImpl() {_tih.Release();}

        STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
        {*pctinfo = 1; return S_OK;}

        STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
        {return _tih.GetTypeInfo(itinfo, lcid, pptinfo);}

        STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
                LCID lcid, DISPID* rgdispid)
        {return _tih.GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);}

        STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid,
                LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
                EXCEPINFO* pexcepinfo, UINT* puArgErr)
        {return _tih.Invoke((IDispatch*)this, dispidMember, riid, lcid,
                wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);}
protected:
        static _tihclass _tih;
        static HRESULT GetTI(LCID lcid, ITypeInfo** ppInfo)
        {return _tih.GetTI(lcid, ppInfo);}
};

template <class T,
          const IID* piid,
          const TCHAR * ptszIndex,
          class tihclass>
typename ITIMEDispatchImpl<T, piid, ptszIndex, tihclass>::_tihclass
ITIMEDispatchImpl<T, piid, ptszIndex, tihclass>::_tih =
{piid, ptszIndex, NULL, 0};

#endif /* _COMUTIL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\proxy\flash\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__D7E0E5BD_DC53_4CEE_979D_CA4D87426206__INCLUDED_)
#define AFX_STDAFX_H__D7E0E5BD_DC53_4CEE_979D_CA4D87426206__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

//#define _ATL_DEBUG_QI
//#define _ATL_DEBUG_INTERFACES
#define ATL_TRACE_LEVEL 5

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlwin.h>
#include <atlctl.h>

#define ASSERT(expr) if (!(expr)) { __asm int 3 }

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__D7E0E5BD_DC53_4CEE_979D_CA4D87426206__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\proxy\flash\flashproxyplayer.h ===
#pragma once

#include "resource.h"       // main symbols
#include "..\ProxyBaseImpl.h"

/////////////////////////////////////////////////////////////////////////////
// CFlashProxy
class CFlashProxy : 
    public CProxyBaseImpl<&CLSID_FlashProxy, &LIBID_FLASHLib>,
    public IConnectionPointContainerImpl<CFlashProxy>,
    public IPropertyNotifySinkCP<CFlashProxy>,
    public IPropertyNotifySink,
    public ITIMEMediaPlayerControl
{
private:
    typedef CProxyBaseImpl<&CLSID_FlashProxy, &LIBID_FLASHLib> SUPER;

    CComPtr<ITIMEMediaPlayerSite> m_spTIMEMediaPlayerSite;
    CComPtr<ITIMEElement> m_spTIMEElement;
    CComPtr<ITIMEState> m_spTIMEState;
    DWORD m_dwPropCookie;

protected:
    CComPtr<IDispatch> m_pdispFlash;

    STDMETHOD(CreateContainedControl)(void);
    STDMETHOD(CallMethod)(OLECHAR* pwzMethod, VARIANT* pvarResult, VARIANT* pvarArgument1);
    STDMETHOD(PutBstrProp)(OLECHAR* pwzProp, BSTR bstrValue);
private:

    HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP);
    HRESULT NotifyPropertyChanged(DISPID dispid);
    HRESULT InitPropSink();
    void DeinitPropSink();

public:
    CFlashProxy();
    virtual ~CFlashProxy();

    STDMETHOD(Init)(ITIMEMediaPlayerSite *pSite);
    STDMETHOD(Detach)(void);

    STDMETHOD(put_clipBegin)(VARIANT varClipBegin);
    STDMETHOD(put_clipEnd)(VARIANT varClipEnd);
    STDMETHOD(begin)(void);
    STDMETHOD(end)(void);
    STDMETHOD(resume)(void);
    STDMETHOD(pause)(void);
    STDMETHOD(reset)(void);
    STDMETHOD(repeat)(void);
    STDMETHOD(seek)(double dblSeekTime);

    STDMETHOD(get_currTime)(double* pdblCurrentTime);
    STDMETHOD(get_clipDur)(double* pdblClipDur);
    STDMETHOD(get_mediaDur)(double* pdblMediaDur);
    STDMETHOD(get_state)(TimeState * ts);
    STDMETHOD(get_playList)(ITIMEPlayList ** plist);

    STDMETHOD(get_abstract)(BSTR* pbstrAbs);
    STDMETHOD(get_author)(BSTR* pbstrAut);
    STDMETHOD(get_copyright)(BSTR* pbstrCop);
    STDMETHOD(get_rating)(BSTR* pbstrRat);
    STDMETHOD(get_title)(BSTR* pbstrTit);

    STDMETHOD(get_canPause(VARIANT_BOOL * b));
    STDMETHOD(get_canSeek(VARIANT_BOOL * b));
    STDMETHOD(get_hasAudio(VARIANT_BOOL * b));
    STDMETHOD(get_hasVisual(VARIANT_BOOL * b));
    STDMETHOD(get_mediaHeight(long * width));
    STDMETHOD(get_mediaWidth(long * height));

    STDMETHOD(put_src)(BSTR   bstrURL);
    STDMETHOD(put_CurrentTime)(double   dblCurrentTime);
    STDMETHOD(get_CurrentTime)(double* pdblCurrentTime);

    STDMETHOD(get_customObject)(IDispatch ** disp);
    STDMETHOD(getControl)(IUnknown ** control);

    //
    // IPropertyNotifySink methods
    //
    STDMETHOD(OnChanged)(DISPID dispID);
    STDMETHOD(OnRequestEdit)(DISPID dispID);

DECLARE_REGISTRY_RESOURCEID(IDR_FLASHPROXY)
DECLARE_NOT_AGGREGATABLE(CFlashProxy)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFlashProxy)
    COM_INTERFACE_ENTRY(ITIMEMediaPlayer)
	COM_INTERFACE_ENTRY(ITIMEMediaPlayerControl)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    COM_INTERFACE_ENTRY(IPropertyNotifySink)
    COM_INTERFACE_ENTRY_CHAIN(SUPER)
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CFlashProxy)
    CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
END_CONNECTION_POINT_MAP();

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\proxy\wmp\nstdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\proxy\wmp\browsewm.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 2001 Microsoft Corporation
 *
 * File: BrowseWM.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#include "w95wraps.h"
#include "shlwapi.h"
#include "stdafx.h"
#include <initguid.h>
#include "BrowseWM.h"
#include "BrowseWM_i.c"
#include "WMPProxyPlayer.h"
#include "ContentProxy.h"

//
// Misc stuff to keep the linker happy
//
EXTERN_C HANDLE g_hProcessHeap = NULL;  //lint !e509 // g_hProcessHeap is set by the CRT in dllcrt0.c
DWORD g_dwFALSE = 0;
//
// end of misc stuff
//


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_ContentProxy, CContentProxy)
    OBJECT_ENTRY(CLSID_WMPProxy, CWMPProxy)
END_OBJECT_MAP() //lint !e785

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(/*TRUE*/);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\proxy\wmp\array.cpp ===
//************************************************************
//
// FileName:        array.cpp
//
// Created:         01/28/98
//
// Author:          TWillie
// 
// Abstract:        Declaration of the array templates
//************************************************************

#include <stdafx.h>
#include "array.h"
#include <windowsx.h>

//  CImplAry class

//
//  NOTE that this file does not include support for artificial
//    error simulation.  There are common usage patterns for arrays
//    which break our normal assumptions about errors.  For instance,
//    ary.EnsureSize() followed by ary.Append(); code which makes
//    this sequence of calls expects ary.Append() to always succeed.
//
//    Because of this, the Ary methods do not use THR internally.
//    Instead, the code which is calling Ary is expected to follow
//    the normal THR rules and use THR() around any call to an
//    Ary method which could conceivably fail.
//
//    This relies on the Ary methods having solid internal error
//    handling, since the error handling within will not be exercised
//    by the normal artifical failure code.
//

//************************************************************
//
//  Member: CImplAry::~CImplAry
//
//  Synopsis:   Resizeable array destructor. Frees storage allocated for the
//      array.
//
//************************************************************

// Suppress new warning about NEW without corresponding DELETE 
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )  

CImplAry::~CImplAry()
{
    if (!UsingStackArray())
    {
        if (NULL != PData())
        {
            GlobalFreePtr(PData()); //lint !e666 !e522
        }
    }

    m_pv = NULL;
    m_c  = 0;
} // ~CImplAry

//************************************************************
//
//  Member:     CImplAry::GetAlloced, public
//
//  Synopsis:   Returns the number of bytes that have been allocated.
//
//  Arguments:  [cb] -- Size of each element
//
//  Notes:      For the CStackAry classes the value returned is m_cStack*cb if
//              we're still using the stack-allocated array.
//
//************************************************************

ULONG
CImplAry::GetAlloced(size_t cb)
{
    if (UsingStackArray())
    {
        return GetStackSize() * cb;
    }

    if(PData()==NULL)
        return 0;
    else return (ULONG) GlobalSize(GlobalPtrHandle(PData()));
} // GetAlloced

//************************************************************
//
//  Member: CImplAry::EnsureSize
//
//  Synopsis:   Ensures that the array is at least the given size. That is,
//      if EnsureSize(c) succeeds, then (c-1) is a valid index. Note
//      that the array maintains a separate count of the number of
//      elements logically in the array, which is obtained with the
//      Size/SetSize methods. The logical size of the array is never
//      larger than the allocated size of the array.
//
//  Arguments:  cb    Element size
//              c     New allocated size for the array.
//
//  Returns:    HRESULT
//
//************************************************************

HRESULT
CImplAry::EnsureSize(size_t cb, long c)
{
    unsigned long cbAlloc;

    // check to see if we need to do anything
    if (UsingStackArray() && (long)(c * cb) <= (long)GetAlloced(cb))
        return S_OK;

    Assert(c >= 0);

    cbAlloc = ((c + 7) & ~7) * cb;
    
    if (UsingStackArray() ||
        (((unsigned long) c > ((m_c + 7) & ~7)) && cbAlloc > (PData()==NULL?0:GlobalSize(GlobalPtrHandle(PData())))))
    {
        if (UsingStackArray())
        {
            //
            // We have to switch from the stack-based array to an allocated
            // one, so allocate the memory and copy the data over.
            //
            void *pbDataOld = PData();

            PData() = GlobalAllocPtr(GHND, cbAlloc);
            if (PData() ==  NULL)
            {
                PData() = pbDataOld;
                return E_OUTOFMEMORY;
            }

            if(pbDataOld!=NULL) {
                  int cbOld  = GetAlloced(cb);
                  memcpy(PData(), pbDataOld, cbOld);
            }
        }
        else
        {
            // if we already have a pointer, realloc
            if (PData())
            {
                void *pTemp = GlobalReAllocPtr(PData(), cbAlloc, GHND); //lint !e666 !e522
                if (pTemp == NULL)
                {
                    return E_OUTOFMEMORY;
                }

                PData() = pTemp;
            }
            else
            {
                PData() = GlobalAllocPtr(GHND, cbAlloc);
                if (PData() == NULL)
                {
                    return E_OUTOFMEMORY;
                }
            }

        }

        m_fDontFree = false;
    }

    return S_OK;
} // EnsureSize

//************************************************************
//
//  Member:     CImplAry::Grow, public
//
//  Synopsis:   Ensures enough memory is allocated for c elements and then
//              sets the size of the array to that much.
//
//  Arguments:  [cb] -- Element Size
//              [c]  -- Number of elements to grow array to.
//
//  Returns:    HRESULT
//
//************************************************************

HRESULT
CImplAry::Grow(size_t cb, int c)
{
    HRESULT hr = EnsureSize(cb, c);
    if (FAILED(hr))
    {
        return hr;
    }

    // ISSUE - This is a very bad design.  This is too dangerous.
    //          Consider the case where c < m_c.
    // bug #14220, ie6 
    SetSize(c);

    return S_OK;
} // Grow

//************************************************************
//
//  Member:     CImplAry::AppendIndirect
//
//  Synopsis:   Appends the given element to the end of the array,
//              incrementing the array's logical size, and growing the
//              array's allocated size if necessary.  Note that the element
//              is passed with a pointer, rather than directly.
//
//  Arguments:  cb        Element size
//              pv        Pointer to the element to be appended
//              ppvPlaced Pointer to the element that's inside the array
//
//  Returns:    HRESULT
//
//  Notes:      If pv is NULL, the element is appended and initialized to
//              zero.
//
//************************************************************

HRESULT
CImplAry::AppendIndirect(size_t cb, void *pv, void **ppvPlaced)
{
    HRESULT hr;

    hr = EnsureSize(cb, m_c + 1);
    if (FAILED(hr))
    {
        return(hr);
    }

    if (ppvPlaced)
    {
        *ppvPlaced = Deref(cb, m_c);
    }

    if (pv == NULL)
    {
        memset(Deref(cb, m_c), 0, cb);
    }
    else
    {
        memcpy(Deref(cb, m_c), pv, cb);
    }

    // increment the count
    m_c++;

    return NOERROR;
} // AppendIndirect

//************************************************************
//
//  Member: CImplAry::DeleteItem
//
//  Synopsis:   Removes the i'th element of the array, shuffling all
//              elements that follow one slot towards the beginning of the
//              array.
//
//  Arguments:  cb  Element size
//              i   Element to delete
//
//************************************************************

void
CImplAry::DeleteItem(size_t cb, int i)
{
    Assert(i >= 0);
    Assert(i < (int)m_c);

    // slide bottom data up one
    memmove(((BYTE *) PData()) + (i * cb),
            ((BYTE *) PData()) + ((i + 1) * cb),
            (m_c - i - 1) * cb);

    // decrement the count
    m_c--;
} // DeleteItem

//************************************************************
//
//  Member: CImplAry::DeleteByValueIndirect
//
//  Synopsis:   Removes the element matching the given value.
//
//  Arguments:  cb  Element size
//              pv  Element to delete
//
//  Returuns:   True if found & deleted.
//
//************************************************************

bool
CImplAry::DeleteByValueIndirect(size_t cb, void *pv)
{
    int i = FindIndirect(cb, pv);
    if (i >= 0)
    {
        DeleteItem(cb, i);
        return true;
    }
    
    return false;
} // DeleteByValueIndirect

//************************************************************
//
//  Member: CImplAry::DeleteMultiple
//
//  Synopsis:   Removes a range of elements of the array, shuffling all
//              elements that follow the last element being deleted slot
//              towards the beginning of the array.
//
//  Arguments:  cb    Element size
//              start First element to delete
//              end   Last element to delete
//
//************************************************************

void
CImplAry::DeleteMultiple(size_t cb, int start, int end)
{
    Assert((start >= 0) && (end >= 0));
    Assert((start < (int)m_c) && (end < (int)m_c));
    Assert(end >= start);

    if ((unsigned)end < (m_c - 1))
    {
        memmove(((BYTE *) PData()) + (start * cb),
                ((BYTE *) PData()) + ((end + 1) * cb),
                (m_c - end - 1) * cb);
    }

    m_c -= (end - start) + 1;
} // DeleteMultiple

//************************************************************
//
//  Member: CImplAry::DeleteAll
//
//  Synopsis:   Efficient method for emptying array of any contents
//
//************************************************************

void
CImplAry::DeleteAll(void)
{
    if (!UsingStackArray())
    {
        if (NULL != PData())
        {
            GlobalFreePtr(PData()); //lint !e666 !e522
        }

        if (m_fStack)
        {
            PData() = GetStackPtr();
            m_fDontFree = true;
        }
        else
        {
            PData() = NULL;
        }
    }

    m_c = 0;
} // DeleteAll

//************************************************************
//
//  Member: CImplAry::InsertIndirect
//
//  Synopsis:   Inserts a pointer pv at index i. The element previously at
//      index i, and all elements that follow it, are shuffled one
//      slot away towards the end of the array.Note that the
//      clement is passed with a pointer, rather than directly.
//
//  Arguments:  cb    Element size
//              i     Index to insert...
//              pv        ...this pointer at
//
//              if pv is NULL then the element is initialized to all zero.
//
//************************************************************

HRESULT
CImplAry::InsertIndirect(size_t cb, int i, void *pv)
{
    HRESULT hr;

    hr = EnsureSize(cb, m_c + 1);
    if (FAILED(hr))
    {
        return(hr);
    }

    memmove(((BYTE *) PData()) + ((i + 1) * cb),
            ((BYTE *) PData()) + (i * cb),
            (m_c - i) * cb);

    if (pv == NULL)
    {
        memset(Deref(cb, i), 0, cb);
    }
    else
    {
        memcpy(Deref(cb, i), pv, cb);
    }

    // increment the count
    m_c++;
    return NOERROR;

} // InsertIndirect

//************************************************************
//
//  Member:     CImplAry::FindIndirect
//
//  Synopsis:   Finds an element of a non-pointer array.
//
//  Arguments:  cb  The size of the element.
//              pv  Pointer to the element.
//
//  Returns:    The index of the element if found, otherwise -1.
//
//************************************************************

int
CImplAry::FindIndirect(size_t cb, void * pv)
{
    int     i;
    void *  pvT;

    pvT = PData();
    for (i = m_c; i > 0; i--)
    {
        if (!memcmp(pv, pvT, cb))
            return m_c - i;

        pvT = (char *) pvT + cb;
    }

    return -1;
} // FindIndirect

//************************************************************
//
//  Member:     CImplAry::Copy
//
//  Synopsis:   Creates a copy from another CImplAry object.
//
//  Arguments:  ary     Object to copy.
//              fAddRef Addref the elements on copy?
//
//************************************************************

HRESULT
CImplAry::Copy(size_t cb, const CImplAry& ary, bool fAddRef)
{
    return(CopyIndirect(cb, ary.m_c, ((CImplAry *)&ary)->PData(), fAddRef));
} // Copy

//************************************************************
//
//  Member:     CImplAry::CopyIndirect
//
//  Synopsis:   Fills a forms array from a C-style array of raw data
//
//  Arguments:  [cb]
//              [c]
//              [pv]
//              [fAddRef]
//
//  Returns:    HRESULT
//
//************************************************************

HRESULT
CImplAry::CopyIndirect(size_t cb, int c, void *pv, bool fAddRef)
{
    if ((pv == NULL) || (cb < 1) || (c < 1))
    {
        return E_INVALIDARG;
    }

    // if we point to ourselves, da!
    if (pv == PData())
        return S_OK;

    // clear data out
    DeleteAll();

    // ensure size we now want
    HRESULT hr = EnsureSize(cb, c);
    if (FAILED(hr))
    {
        return hr;
    }

    // copy data over (blindly)
    memcpy(PData(), pv, c * cb);

    // set element count
    m_c = c;

    if (fAddRef)
    {
        for (IUnknown **ppUnk = (IUnknown **) PData(); c > 0; c--, ppUnk++)
        {
            (*ppUnk)->AddRef();
        }
    }

    return S_OK;
} // CopyIndirect

//************************************************************
//
//  Member:     CImplPtrAry::*
//
//  Synopsis:   CImplPtrAry elements are always of size four.
//              The following functions encode this knowledge.
//
//************************************************************

HRESULT
CImplPtrAry::EnsureSize(long c)
{
    return CImplAry::EnsureSize(sizeof(void *), c);
} // EnsureSize

//************************************************************

HRESULT
CImplPtrAry::Grow(int c)
{
    return CImplAry::Grow(sizeof(void *), c);
} // Grow

//************************************************************

HRESULT
CImplPtrAry::Append(void * pv)
{
    return CImplAry::AppendIndirect(sizeof(void *), &pv);
} // Append

//************************************************************

HRESULT
CImplPtrAry::Insert(int i, void * pv)
{
    return CImplAry::InsertIndirect(sizeof(void *), i, &pv);
} // Insert

//************************************************************

int
CImplPtrAry::Find(void * pv)
{
    int    i;
    void **ppv;

    for (i = 0, ppv = (void **) PData(); (unsigned)i < m_c; i++, ppv++)
    {
        if (pv == *ppv)
            return i;
    }

    return -1;
} // Find

//************************************************************

void
CImplPtrAry::DeleteItem(int i)
{
    CImplAry::DeleteItem(sizeof(void *), i);
}

//************************************************************

bool
CImplPtrAry::DeleteByValue(void *pv)
{
    int i = Find(pv);
    if (i >= 0)
    {
        CImplAry::DeleteItem(sizeof(void *), i);
        return true;
    }

    return false;
} // DeleteByValue

//************************************************************

void
CImplPtrAry::DeleteMultiple(int start, int end)
{
    CImplAry::DeleteMultiple(sizeof(void*), start, end);
} // DeleteMultiple

//************************************************************

void
CImplPtrAry::ReleaseAndDelete(int idx)
{
    IUnknown *pUnk;

    Assert(idx <= (int)m_c);

    // grab element at idx
    pUnk = ((IUnknown **) PData())[idx];
    if (pUnk)
        ReleaseInterface(pUnk);

    DeleteItem(idx);
} // ReleaseAndDelete

//************************************************************

void
CImplPtrAry::ReleaseAll(void)
{
    int        i;
    IUnknown **ppUnk;

    for (i = 0, ppUnk = (IUnknown **) PData(); (unsigned)i < m_c; i++, ppUnk++)
    {
        if (*ppUnk)
            ReleaseInterface(*ppUnk);
    }

    DeleteAll();
} // ReleaseAll

//************************************************************

HRESULT
CImplPtrAry::CopyIndirect(int c, void * pv, bool fAddRef)
{
    return CImplAry::CopyIndirect(sizeof(void *), c, pv, fAddRef);
} // CopyIndirect

//************************************************************

HRESULT
CImplPtrAry::Copy(const CImplAry& ary, bool fAddRef)
{
    return CImplAry::Copy(sizeof(void *), ary, fAddRef);
} // Copy

//************************************************************

HRESULT
CImplPtrAry::EnumElements(REFIID   iid,
                          void   **ppv,
                          bool     fAddRef,
                          bool     fCopy,
                          bool     fDelete)
{
    return CImplAry::EnumElements(sizeof(void *),
                                  iid,
                                  ppv,
                                  fAddRef,
                                  fCopy,
                                  fDelete);
} // EnumElements

//************************************************************

HRESULT
CImplPtrAry::EnumVARIANT(VARTYPE        vt,
                         IEnumVARIANT **ppenum,
                         bool           fCopy,
                         bool           fDelete)
{
    return CImplAry::EnumVARIANT(sizeof(void *),
                                 vt,
                                 ppenum,
                                 fCopy,
                                 fDelete);
} // EnumVARIANT

//************************************************************

// Determines whether a variant is a base type.
#define ISBASEVARTYPE(vt) ((vt & ~VT_TYPEMASK) == 0)

//************************************************************
//
//  CBaseEnum Implementation
//
//************************************************************

//************************************************************
//
//  Member:     CBaseEnum::Init
//
//  Synopsis:   2nd stage initialization performs copy of array if necessary.
//
//  Arguments:  [rgItems] -- Array to enumrate.
//              [fCopy]   -- Copy array?
//
//  Returns:    HRESULT.
//
//************************************************************

HRESULT
CBaseEnum::Init(CImplAry *rgItems, bool fCopy)
{
    HRESULT   hr = S_OK;
    CImplAry *rgCopy = NULL;     // copied array

    if (rgItems == NULL)
    {
        return E_INVALIDARG;
    }

    // Copy array if necessary.
    if (fCopy)
    {
        rgCopy = new CImplAry;
        if (rgCopy == NULL)
        {
            return E_OUTOFMEMORY;
        }

        hr = rgCopy->Copy(m_cb, *rgItems, m_fAddRef);
        if (FAILED(hr))
        {
            delete rgCopy;
            return hr;
        }

        rgItems = rgCopy;
    }

    m_rgItems = rgItems;

    return hr;
} // Init

//************************************************************
//
//  Member:     CBaseEnum::CBaseEnum
//
//  Synopsis:   Constructor.
//
//  Arguments:  [iid]     -- IID of enumerator interface.
//              [fAddRef] -- addref enumerated elements?
//              [fDelete] -- delete array on zero enumerators?
//
//************************************************************

CBaseEnum::CBaseEnum(size_t cb, REFIID iid, bool fAddRef, bool fDelete)
{
    m_ulRefs     = 1;

    m_cb         = cb;
    m_rgItems    = NULL;
    m_piid       = &iid;
    m_i          = 0;
    m_fAddRef    = fAddRef;
    m_fDelete    = fDelete;
} // CBaseEnum

//************************************************************
//
//  Member:     CBaseEnum::CBaseEnum
//
//  Synopsis:   Constructor.
//
//************************************************************

CBaseEnum::CBaseEnum(const CBaseEnum& benum)
{ //lint !e1538
    m_ulRefs     = 1;

    m_cb         = benum.m_cb;
    m_piid       = benum.m_piid;
    m_rgItems    = benum.m_rgItems;
    m_i          = benum.m_i;
    m_fAddRef    = benum.m_fAddRef;
    m_fDelete    = benum.m_fDelete;
} // CBaseEnum

//************************************************************
//
//  Member:     CBaseEnum::~CBaseEnum
//
//  Synopsis:   Destructor.
//
//************************************************************

CBaseEnum::~CBaseEnum(void)
{
    IUnknown **ppUnk;
    int        i;

    if (m_rgItems && m_fDelete)
    {
        if (m_fAddRef)
        {
            for (i = 0, ppUnk = (IUnknown **) Deref(0);
                 i < m_rgItems->Size();
                 i++, ppUnk++)
            {
                ReleaseInterface(*ppUnk);
            }
        }

        delete m_rgItems;
    }
    m_piid = NULL;
} // ~CBaseEnum

//************************************************************
//
//  Member:     CBaseEnum::QueryInterface
//
//  Synopsis:   Per IUnknown::QueryInterface.
//
//************************************************************

STDMETHODIMP
CBaseEnum::QueryInterface(REFIID iid, void ** ppv)
{
    if (IsEqualIID(iid, IID_IUnknown) || IsEqualIID(iid, *m_piid))
    {
        AddRef();
        *ppv = this;
        return NOERROR;
    }

    return E_NOINTERFACE;
} // QueryInterface

//************************************************************
//
//  Member:     CBaseEnum::Skip
//
//  Synopsis:   Per IEnum*
//
//************************************************************

STDMETHODIMP
CBaseEnum::Skip(ULONG celt)
{
    int c = min((int) celt, (int)(m_rgItems->Size() - m_i)); //lint !e666
    m_i += c;

    return ((c == (int) celt) ? S_OK : S_FALSE);
} // Skip

//************************************************************
//
//  Member:     CBaseEnum::Reset
//
//  Synopsis:   Per IEnum*
//
//************************************************************

STDMETHODIMP
CBaseEnum::Reset(void)
{
    m_i = 0;
    return S_OK;
} // Reset

//************************************************************
//
//  CEnumGeneric Implementation
//
//************************************************************

//************************************************************
//
//  Class:      CEnumGeneric (enumg)
//
//  Purpose:    OLE enumerator for class CImplAry.
//
//  Interface:  Next         -- Per IEnum
//              Clone        --     ""
//              Create       -- Creates a new enumerator.
//              CEnumGeneric -- ctor.
//              CEnumGeneric -- ctor.
//
//************************************************************

class CEnumGeneric : public CBaseEnum
{
public:
    //
    //  IEnum methods
    //
    STDMETHOD(Next) (ULONG celt, void *reelt, ULONG *pceltFetched);
    STDMETHOD(Clone) (CBaseEnum **ppenum);

    //
    //  CEnumGeneric methods
    //
    static HRESULT Create(size_t          cb,
                          CImplAry       *rgItems,
                          REFIID          iid,
                          bool            fAddRef,
                          bool            fCopy,
                          bool            fDelete,
                          CEnumGeneric  **ppenum);

protected:
    CEnumGeneric(size_t cb, REFIID iid, bool fAddRef, bool fDelete);
    CEnumGeneric(const CEnumGeneric & enumg);

    CEnumGeneric& operator=(const CEnumGeneric & enumg); // don't define
    CEnumGeneric();
}; // class CEnumGeneric

//************************************************************
//
//  Member:     CEnumGeneric::Create
//
//  Synopsis:   Creates a new CEnumGeneric object.
//
//  Arguments:  [rgItems] -- Array to enumerate.
//              [iid]     -- IID of enumerator interface.
//              [fAddRef] -- AddRef enumerated elements?
//              [fCopy]   -- Copy array enumerated?
//              [fDelete] -- Delete array when zero enumerators of array?
//              [ppenum]  -- Resulting CEnumGeneric object.
//
//************************************************************

HRESULT
CEnumGeneric::Create(size_t          cb,
                     CImplAry       *rgItems,
                     REFIID          iid,
                     bool            fAddRef,
                     bool            fCopy,
                     bool            fDelete,
                     CEnumGeneric  **ppenum)
{
    HRESULT         hr = S_OK;
    CEnumGeneric   *penum;

    Assert(rgItems);
    Assert(ppenum);
    Assert(!fCopy || fDelete);
    
    *ppenum = NULL;
    
    penum = new CEnumGeneric(cb, iid, fAddRef, fDelete);
    if (penum == NULL)
    {
        return E_OUTOFMEMORY;
    }

    hr = penum->Init(rgItems, fCopy);
    if (FAILED(hr))
    {
        ReleaseInterface(penum); //lint !e423
        return hr;
    }

    *ppenum = penum;

    return hr;
} // Create

//************************************************************
//
//  Function:   CEnumGeneric
//
//  Synopsis:   ctor.
//
//  Arguments:  [iid]     -- IID of enumerator interface.
//              [fAddRef] -- AddRef enumerated elements?
//              [fDelete] -- delete array on zero enumerators?
//
//************************************************************

CEnumGeneric::CEnumGeneric(size_t cb, REFIID iid, bool fAddRef, bool fDelete) :
    CBaseEnum(cb, iid, fAddRef, fDelete)
{
} // CEnumGeneric (size_t, REFIID, bool, bool)

//************************************************************
//
//  Function:   CEnumGeneric
//
//  Synopsis:   ctor.
//
//************************************************************

CEnumGeneric::CEnumGeneric(const CEnumGeneric& enumg) : CBaseEnum(enumg)
{
} // CEnumGeneric

//************************************************************
//
//  Member:     CEnumGeneric::Next
//
//  Synopsis:   Returns the next celt members in the enumeration. If less
//              than celt members remain, then the remaining members are
//              returned and S_FALSE is reported. In all cases, the number
//              of elements actually returned in placed in *pceltFetched.
//
//  Arguments:  [celt]          Number of elements to fetch
//              [reelt]         The elements are returned in reelt[]
//              [pceltFetched]  Number of elements actually fetched
//
//************************************************************

STDMETHODIMP
CEnumGeneric::Next(ULONG celt, void *reelt, ULONG *pceltFetched)
{
    int        c;
    int        i;
    IUnknown **ppUnk;

    c = min((int) celt, (int)(m_rgItems->Size() - m_i)); //lint !e666
    if ((c > 0) && (reelt == NULL))
    {
        return E_INVALIDARG;
    }

    // nothing left
    if (c == 0)
        return S_FALSE;

    if (m_fAddRef)
    {
        for (i = 0, ppUnk = (IUnknown **) Deref(m_i); i < c; i++, ppUnk++)
        {
            (*ppUnk)->AddRef();
        }
    }

    memcpy(reelt, (BYTE *) Deref(m_i), c * m_cb);
    
    if (pceltFetched)
    {
        *pceltFetched = c;
    }
    
    m_i += c;

    return ((c == (int) celt) ? S_OK : S_FALSE);
} // Next

//************************************************************
//
//  Member:     CEnumGeneric::Clone
//
//  Synopsis:   Creates a copy of this enumerator; the copy should have the
//              same state as this enumerator.
//
//  Arguments:  [ppenum]    New enumerator is returned in *ppenum
//
//************************************************************

STDMETHODIMP
CEnumGeneric::Clone(CBaseEnum ** ppenum)
{
    HRESULT hr;

    if (ppenum == NULL)
    {
        return E_INVALIDARG;
    }

    *ppenum = NULL;

    hr = m_rgItems->EnumElements(m_cb, *m_piid, (void **) ppenum, m_fAddRef);
    if (FAILED(hr))
    {
        return hr;
    }
    
    (**(CEnumGeneric **)ppenum).m_i = m_i;
    
    return S_OK;
} // Clone

//************************************************************
//
//  Member:     CImplAry::EnumElements
//
//  Synopsis:   Creates and returns an enumerator for the elements of the
//              array.
//
//  Arguments:  [iid]     --    Type of the enumerator.
//              [ppv]     --    Location to put enumerator.
//              [fAddRef] --    AddRef enumerated elements?
//              [fCopy]   --    Create copy of this array for enumerator?
//              [fDelete] --    Delete this after no longer being used by
//                              enumerators?
//
//************************************************************

HRESULT
CImplAry::EnumElements(size_t   cb,
                       REFIID   iid,
                       void   **ppv,
                       bool     fAddRef,
                       bool     fCopy,
                       bool     fDelete)
{
    Assert(ppv);
    return CEnumGeneric::Create(cb,
                                this,
                                iid,
                                fAddRef,
                                fCopy,
                                fDelete,
                                (CEnumGeneric **) ppv);
} // EnumElements

//************************************************************
//
//  CEnumVARIANT Implementation
//
//************************************************************

//************************************************************
//
//  Class:      CEnumVARIANT (enumv)
//
//  Purpose:    OLE enumerator for class CImplAry.
//
//  Interface:  Next         -- Per IEnum
//              Clone        --     ""
//              Create       -- Creates a new enumerator.
//              CEnumGeneric -- ctor.
//              CEnumGeneric -- ctor.
//
//************************************************************

class CEnumVARIANT : public CBaseEnum
{
public:
    //  IEnum methods
    STDMETHOD(Next) (ULONG celt, void *reelt, ULONG *pceltFetched);
    STDMETHOD(Clone) (CBaseEnum **ppenum);

    static HRESULT Create(size_t          cb,
                          CImplAry       *rgItems,
                          VARTYPE         vt,
                          bool            fCopy,
                          bool            fDelete,
                          IEnumVARIANT  **ppenum);

protected:
    CEnumVARIANT(size_t cb, VARTYPE vt, bool fDelete);
    CEnumVARIANT(const CEnumVARIANT & enumv);

    // don't define
    CEnumVARIANT& operator =(const CEnumVARIANT & enumv);
    CEnumVARIANT();

    VARTYPE     m_vt;                    // type of element enumerated
}; // class CEnumVARIANT

//************************************************************
//
//  Member:     CEnumVARIANT::Create
//
//  Synopsis:   Creates a new CEnumGeneric object.
//
//  Arguments:  [rgItems] -- Array to enumerate.
//              [vt]      -- Type of elements enumerated.
//              [fCopy]   -- Copy array enumerated?
//              [fDelete] -- Delete array when zero enumerators of array?
//              [ppenum]  -- Resulting CEnumGeneric object.
//
//************************************************************

HRESULT
CEnumVARIANT::Create(size_t          cb,
                     CImplAry       *rgItems,
                     VARTYPE         vt,
                     bool            fCopy,
                     bool            fDelete,
                     IEnumVARIANT  **ppenum)
{
    HRESULT hr = S_OK;

    Assert(rgItems);
    Assert(ppenum);
    Assert(ISBASEVARTYPE(vt));

    *ppenum = NULL;

    CEnumVARIANT *penum = new CEnumVARIANT(cb, vt, fDelete);
    if (penum == NULL)
    {
        return E_OUTOFMEMORY;
    }

    hr = penum->Init(rgItems, fCopy);
    if (FAILED(hr))
    {
        ReleaseInterface(penum); //lint !e423
        return hr;
    }

    *ppenum = (IEnumVARIANT *) (void *) penum;

    return hr;
} // Create

//************************************************************
//
//  Function:   CEnumVARIANT
//
//  Synopsis:   ctor.
//
//  Arguments:  [vt]      -- Type of elements enumerated.
//              [fDelete] -- delete array on zero enumerators?
//
//************************************************************

CEnumVARIANT::CEnumVARIANT(size_t cb, VARTYPE vt, bool fDelete) :
    CBaseEnum(cb, IID_IEnumVARIANT, vt == VT_UNKNOWN || vt == VT_DISPATCH, fDelete)
{
    Assert(ISBASEVARTYPE(vt));
    m_vt = vt;
} // CEnumVARIANT (size_t, VARTYPE, bool)

//************************************************************
//
//  Function:   CEnumVARIANT
//
//  Synopsis:   ctor.
//
//************************************************************

CEnumVARIANT::CEnumVARIANT(const CEnumVARIANT& enumv) : CBaseEnum(enumv)
{
    m_vt = enumv.m_vt;
} // CEnumVARIANT(const CEnumVARIANT&)

//************************************************************
//
//  Member:     CEnumVARIANT::Next
//
//  Synopsis:   Returns the next celt members in the enumeration. If less
//              than celt members remain, then the remaining members are
//              returned and S_FALSE is reported. In all cases, the number
//              of elements actually returned in placed in *pceltFetched.
//
//  Arguments:  [celt]          Number of elements to fetch
//              [reelt]         The elements are returned in reelt[]
//              [pceltFetched]  Number of elements actually fetched
//
//************************************************************

STDMETHODIMP
CEnumVARIANT::Next(ULONG celt, void *reelt, ULONG *pceltFetched)
{
    HRESULT     hr;
    int         c;
    int         i;
    int         j;
    BYTE       *pb;
    VARIANT    *pvar;

    c = min((int) celt, (int)(m_rgItems->Size() - m_i)); //lint !e666
    
    if ((c > 0) && (reelt == NULL))
    {
        return E_INVALIDARG;
    }

    // nothing left
    if (c == 0)
        return S_FALSE;

    for (i = 0, pb = (BYTE *) Deref(m_i), pvar = (VARIANT *) reelt;
         i < c;
         i++, pb += m_cb, pvar++)
    {
        V_VT(pvar) = m_vt;
        switch (m_vt)
        {
        case VT_I2:
            Assert(sizeof(V_I2(pvar)) == m_cb);
            V_I2(pvar) = *(short *) pb;
            break;

        case VT_I4:
            Assert(sizeof(V_I4(pvar)) == m_cb);
            V_I4(pvar) = *(long *) pb;
            break;

        case VT_BOOL:
            Assert(sizeof(V_BOOL(pvar)) == m_cb);
            V_BOOL(pvar) = (short) -*(int *) pb;
            break;

        case VT_BSTR:
            Assert(sizeof(V_BSTR(pvar)) == m_cb);
            V_BSTR(pvar) = *(BSTR *) pb;
            break;

        case VT_UNKNOWN:
            Assert(sizeof(V_UNKNOWN(pvar)) == m_cb);
            V_UNKNOWN(pvar) = *(IUnknown **) pb;
            V_UNKNOWN(pvar)->AddRef();
            break;

        case VT_DISPATCH:
            Assert(sizeof(V_DISPATCH(pvar)) == m_cb);
            hr = (*(IUnknown **) pb)->QueryInterface(IID_TO_PPV(IDispatch, &V_DISPATCH(pvar)));
            if (FAILED(hr))
            {
                // Cleanup
                j = i;
                while (--j >= 0)
                {
                    ReleaseInterface(((IDispatch **) reelt)[j]);
                }

                return hr;
            }
            break;

        default:
            Assert(0 && "Unknown VARTYPE in IEnumVARIANT::Next");
            break;
        }
    }

    if (pceltFetched)
    {
        *pceltFetched = c;
    }

    m_i += c;
    return ((c == (int) celt) ? NOERROR : S_FALSE);
} // Next

//************************************************************
//
//  Member:     CEnumVARIANT::Clone
//
//  Synopsis:   Creates a copy of this enumerator; the copy should have the
//              same state as this enumerator.
//
//  Arguments:  [ppenum]    New enumerator is returned in *ppenum
//
//************************************************************

STDMETHODIMP
CEnumVARIANT::Clone(CBaseEnum **ppenum)
{
    HRESULT hr = S_OK;

    if (ppenum == NULL)
    {
        return E_INVALIDARG;
    }

    *ppenum = NULL;
   
    hr = m_rgItems->EnumVARIANT(m_cb, m_vt, (IEnumVARIANT **)ppenum);
    if (FAILED(hr))
    {
        return hr;
    }

    (**(CEnumVARIANT **)ppenum).m_i = m_i;
    
    return hr;
} // Clone

//************************************************************
//
//  Member:     CImplAry::EnumElements
//
//  Synopsis:   Creates and returns an IEnumVARIANT enumerator for the elements
//              of the array.
//
//  Arguments:  [vt]      --    Type of elements enumerated.
//              [ppv]     --    Location to put enumerator.
//              [fCopy]   --    Create copy of this array for enumerator?
//              [fDelete] --    Delete this after no longer being used by
//                              enumerators?
//
//************************************************************

HRESULT
CImplAry::EnumVARIANT(size_t         cb,
                      VARTYPE        vt,
                      IEnumVARIANT **ppenum,
                      bool           fCopy,
                      bool           fDelete)
{
    Assert(ppenum);
    return CEnumVARIANT::Create(cb, this, vt, fCopy, fDelete, ppenum);
} // EnumVARIANT

//************************************************************
//
// End of file
//
//************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\proxy\wmp\array.h ===
#ifndef _ARRAY_H_
#define _ARRAY_H_

//************************************************************
//
// FileName:        array.h
//
// Created:         01/28/98
//
// Author:          TWillie
// 
// Abstract:        Declaration of the array templates
//
//************************************************************

#pragma once

#define ULREF_IN_DESTRUCTOR 256

//************************************************************
//
// This is the implementation of the generic resizeable array classes. There
// are four array classes:
//
// CPtrAry<ELEM> --
//
//       Dynamic array class which is optimized for sizeof(ELEM) equal
//       to 4. The array is initially empty with no space or memory allocated
//       for data.
//
// CDataAry<ELEM> --
//
//       Same as CPtrAry but where sizeof(ELEM) is != 4 and less than 128.
//
// CStackPtrAry<ELEM, N> --
//
//       Dynamic array class optimized for sizeof(ELEM) equal to 4.
//       Space for N elements is allocated as member data of the class. If
//       this class is created on the stack, then space for N elements will
//       be created on the stack. The class can grow beyond N elements, at
//       which point memory will be allocated for the array data.
//
// CStackDataAry<ELEM, N> --
//
//       Same as CStackPtrAry, but where sizeof(ELEM) is != 4 and less than 128.
//
//
// All four classes have virtually the same methods, and are used the same.
// The only difference is that the DataAry classes have AppendIndirect and
// InsertIndirect, while the PtrAry classes use Append and Insert. The reason
// for the difference is that the Indirect methods take a pointer to the data,
// while the non-indirect methods take the actual data as an argument.
//
// The Stack arrays (CStackPtrAry and CStackDataAry) are used to pre-allocate
// space for elements in the array. This is useful if you create the array on
// the stack and you know that most of the time the array will be less than
// a certain number of elements. Creating one of these arrays on the stack
// allocates the array on the stack as well, preventing a separate memory
// allocation. Only if the array grows beyond the initial size will any
// additional memory be allocated.
//
// The fastest and most efficient way of looping through all elements in
// the array is as follows:
//
//            ELEM * pElem;
//            int    i;
//
//            for (i = aryElems.Size(), pElem = aryElems;
//                 i > 0;
//                 i--, pElem++)
//            {
//                (*pElem)->DoSomething();
//            }
//
// This loop syntax has been shown to be the fastest and produce the smallest
// code. Here's an example using a real data type:
//
//            CStackPtrAry<CSite*, 16> arySites;
//            CSite **ppSite;
//            int     i;
//
//            // Populate the array.
//            ...
//
//            // Now loop through every element in the array.
//            for (i = arySites.Size(), ppSite = arySites;
//                 i > 0;
//                 i--, ppSite++)
//            {
//                (*ppSite)->DoSomething();
//            }
//
// METHOD DESCRIPTIONS:
//
// Commonly used methods:
//
//        Size()             Returns the number of elements currently stored
//                           in the array.
//
//        operator []        Returns the given element in the array.
//
//        Item(int i)        Returns the given element in the array.
//
//        operator ELEM*     Allows the array class to be cast to a pointer
//                           to ELEM. Returns a pointer to the first element
//                           in the array. (Same as a Base() method).
//
//        Append(ELEM e)     Adds a new pointer to the end of the array,
//                           growing the array if necessary.  Only valid
//                           for arrays of pointers (CPtrAry, CStackPtrAry).
//
//        AppendIndirect(ELEM *pe, ELEM** ppePlaced)
//                           As Append, for non-pointer arrays
//                           (CDataAry, CStackDataAry).
//                           pe [in] - Pointer to element to add to array. The
//                                     data is copied into the array. Can be
//                                     NULL, in which case the new element is
//                                     initialized to all zeroes.
//                           ppePlaced [out] - Returns pointer to the new
//                                     element. Can be NULL.
//
//        Insert(int i, ELEM e)
//                           Inserts a new element (e) at the given index (i)
//                           in the array, growing the array if necessary. Any
//                           elements at or following the index are moved
//                           out of the way.
//
//        InsertIndirect(int i, ELEM *pe)
//                           As Insert, for non-pointer arrays
//                                 (CDataAry, CStackDataAry).
//
//        Find(ELEM e)       Returns the index at which a given element (e)
//                           is found (CPtrAry, CStackPtrAry).
//
//        FindIndirect(ELEM *pe)
//                           As Find, for non-pointer arrays
//                                 (CDataAry, CStackDataAry).
//
//        DeleteAll()        Empties the array and de-allocates associated
//                           memory.
//
//        DeleteItem(int i)  Deletes an element of the array, moving any
//                           elements that follow it to fill
//
//        DeleteMultiple(int start, int end)
//                           Deletes a range of elements from the array,
//                           moving to fill. [start] and [end] are the indices
//                           of the start and end elements (inclusive).
//
//        DeleteByValue(ELEM e)
//                           Delete the element matching the given value.
//
//        DeleteByValueIndirect(ELEM *pe)
//                           As DeleteByValue, for non-pointer arrays.
//                                    (CDataAry, CStackDataAry).
//
//
// Less commonly used methods:
//
//        EnsureSize(long c) If you know how many elements you are going to put
//                          in the array before you actually do it, you can use
//                          EnsureSize to allocate the memory all at once instead
//                          of relying on Append(Indirect) to grow the array. This
//                          can be much more efficient (by causing only a single
//                          memory allocation instead of many) than just using
//                          Append(Indirect). You pass in the number of elements
//                          that memory should be allocated for. Note that this
//                          does not affect the "Size" of the array, which is
//                          the number of elements currently stored in it.
//
//        SetSize(int c)    Sets the "Size" of the array, which is the number
//                          of elements currently stored in it. SetSize will not
//                          allocate memory if you're growing the array.
//                          EnsureSize must be called first to reserve space if
//                          the array is growing. Setting the size smaller does
//                          not de-allocate memory, it just chops off the
//                          elements at the end of the array.
//
//        Grow(int c)       Equivalent to calling EnsureSize(c) followed by
//                          SetSize(c).
//
//        BringToFront(int i) Moves the given element of the array to index 0,
//                          shuffling elements to make room.
//
//        SendToBack(int i) Moves the given element to the end of the array,
//                          shuffling elements to make room.
//
//        Swap(int i, int j) Swaps the given two elements.
//
//        ReleaseAll()      (CPtrAry and CStackPtrAry only) Calls Release()
//                          on each element in the array and empties the array.
//
//        ReleaseAndDelete(int idx)
//                          (CPtrAry and CStackPtrAry only) Calls Release() on
//                          the given element and removes it from the array.
//
//           (See the class definitions below for signatures of the following
//            methods and src\core\cdutil\formsary.cxx for argument
//            descriptions)
//
//        CopyAppend        Appends data from another array (of the same type)
//                          to the end.
//
//        Copy              Copies data from another array (of the same type)
//                          into this array, replacing any existing data.
//
//        CopyAppendIndirect  Appends data from a C-style array of element data
//                          to the end of this array.
//
//        CopyIndirect      Copies elements from a C-style array into this array
//                          replacing any existing data.
//
//        EnumElements      Create an enumerator which supports the given
//                          interface ID for the contents of the array
//
//        EnumVARIANT       Create an IEnumVARIANT enumerator.
//
//        operator void *   Allow the CImplAry class to be cast
//                          to a (void *). Avoid using if possible - use
//                          the type-safe operator ELEM * instead.
//
//************************************************************

//************************************************************
//
// Class:     CImplAry
//
// Purpose:   Base implementation of all the dynamic array classes.
//
// Interface:
//
//        Deref       Returns a pointer to an element of the array;
//                    should only be used by derived classes. Use the
//                    type-safe methods operator[] or Item() instead.
//
//        GetAlloced  Get number of elements allocated
//
//  Members:    m_c          Current size of the array
//              m_pv         Buffer storing the elements
//
//  Note:       The CImplAry class only supports arrays of elements
//              whose size is less than 128.
//
//************************************************************

#define ReleaseInterface(p)\
{\
    /*lint -e550 -e774 -e423*/ /* suppress cRef not referenced, if always evaluates to false, and creation of memory leak */ \
    ULONG cRef = 0u; \
    if (NULL != (p))\
    {\
        cRef = (p)->Release();\
        Assert((int)cRef>=0);\
        (p) = NULL;\
    }\
    PSEUDORETURN(cRef) \
    /*lint -restore */ \
} 

#define IID_TO_PPV(_type,_src)      IID_##_type, \
                                    reinterpret_cast<void **>(static_cast<_type **>(_src))

#if (_M_IX86 >= 300) && defined(DEBUG)
  #define PSEUDORETURN(dw)    _asm { mov eax, dw }
#else
  #define PSEUDORETURN(dw)
#endif // not _M_IX86



class CImplAry
{
    friend class CBaseEnum;
    friend class CEnumGeneric;
    friend class CEnumVARIANT;

public:
    virtual ~CImplAry();

    inline long Size() const
    {
        return m_c;
    } // Size

    inline void SetSize(int c)
    {
        m_c = c;
    } // SetSize

    inline operator void *()
    {
        return PData();
    } // void *
    
    void DeleteAll();

    void * Deref(size_t cb, int i);

#ifdef NO_COPY
    NO_COPY(CImplAry);
#endif
protected:

    //  Methods which are wrapped by inline subclass methods
    CImplAry();

    HRESULT     EnsureSize(size_t cb, long c);
    HRESULT     Grow(size_t cb, int c);
    HRESULT     AppendIndirect(size_t cb, void *pv, void **ppvPlaced=NULL);
    HRESULT     InsertIndirect(size_t cb, int i, void *pv);
    int         FindIndirect(size_t cb, void *);

    void        DeleteItem(size_t cb, int i);
    bool        DeleteByValueIndirect(size_t cb, void *pv);
    void        DeleteMultiple(size_t cb, int start, int end);

    HRESULT     CopyAppend(size_t cb, const CImplAry& ary, bool fAddRef);
    HRESULT     Copy(size_t cb, const CImplAry& ary, bool fAddRef);
    HRESULT     CopyIndirect(size_t cb, int c, void *pv, bool fAddRef);

    ULONG       GetAlloced(size_t cb);

    HRESULT     EnumElements(size_t   cb,
                             REFIID   iid,
                             void   **ppv,
                             bool     fAddRef,
                             bool     fCopy = true,
                             bool     fDelete = true);

    HRESULT     EnumVARIANT(size_t         cb,
                            VARTYPE        vt,
                            IEnumVARIANT **ppenum,
                            bool           fCopy = true,
                            bool           fDelete = true);

    inline bool UsingStackArray()
    {
        return m_fDontFree;
    } // UsingStackArray

    UINT GetStackSize()
    { 
        Assert(m_fStack);
        return *(UINT*)((BYTE*)this + sizeof(CImplAry));
    } // GetStackSize

    void * GetStackPtr()
    {
        Assert(m_fStack);
        return (void*)((BYTE*)this + sizeof(CImplAry) + sizeof(int));
    } // GetStackPtr

    bool          m_fStack;    // Set if we're a stack-based array.
    bool          m_fDontFree; // Cleared if m_pv points to alloced memory.
    unsigned long m_c;         // Count of elements

    void           *m_pv;

    inline void * & PData()
    {
        return m_pv;
    } // PData
};

//************************************************************
//
//  Member:     CImplAry::CImplAry
//
//************************************************************

inline
CImplAry::CImplAry()
{
    memset(this, 0, sizeof(CImplAry));
} // CImplAry 

//************************************************************
//
//  Member:     CImplAry::Deref
//
//  Synopsis:   Returns a pointer to the i'th element of the array. This
//              method is normally called by type-safe methods in derived
//              classes.
//
//  Arguments:  i
//
//************************************************************

inline void *
CImplAry::Deref(size_t cb, int i)
{
    Assert(i >= 0);
    Assert(ULONG( i ) < GetAlloced(cb));

    return ((BYTE *) PData()) + i * cb;
} // Deref

//************************************************************
//
//  Class:      CImplPtrAry (ary)
//
//  Purpose:    Subclass used for arrays of pointers.  In this case, the
//              element size is known to be sizeof(void *).  Normally, the
//              CPtrAry template is used to define a specific concrete
//              implementation of this class, to hold a specific type of
//              pointer.
//
//              See documentation above for use.
//
//************************************************************

class CImplPtrAry : public CImplAry
{
protected:
    CImplPtrAry() : CImplAry()
    {
    } // CImplPtrAry

    HRESULT     Append(void * pv);
    HRESULT     Insert(int i, void * pv);
    int         Find(void * pv);
    bool        DeleteByValue(void *pv);

    HRESULT     CopyAppend(const CImplAry& ary, bool fAddRef);
    HRESULT     Copy(const CImplAry& ary, bool fAddRef);
    HRESULT     CopyIndirect(int c, void * pv, bool fAddRef);


public:
    HRESULT     EnsureSize(long c);

    HRESULT     Grow(int c);

    void        DeleteItem(int i);
    void        DeleteMultiple(int start, int end);

    void        ReleaseAll();
    void        ReleaseAndDelete(int idx);

    HRESULT     EnumElements(REFIID iid,
                             void **ppv,
                             bool   fAddRef,
                             bool   fCopy = true,
                             bool   fDelete = true);

    HRESULT     EnumVARIANT(VARTYPE        vt,
                            IEnumVARIANT **ppenum,
                            bool           fCopy = true,
                            bool           fDelete = true);
}; // CImplPtrAry

//************************************************************
//
//  Class:      CDataAry
//
//  Purpose:    This template class declares a concrete derived class
//              of CImplAry.
//
//              See documentation above for use.
//
//************************************************************

template <class ELEM>
class CDataAry : public CImplAry
{
public:
    CDataAry() : CImplAry()
    {
    } // CDataAry

    operator ELEM *()
    {
        return (ELEM *)PData();
    } // ELEM *

    CDataAry(const CDataAry &);

    ELEM & Item(int i)
    {
        return *(ELEM*)Deref(sizeof(ELEM), i);
    } // Item

    HRESULT EnsureSize(long c)
    {
        return CImplAry::EnsureSize(sizeof(ELEM), c);
    } // EnsureSize
    
    HRESULT Grow(int c)
    {
        return CImplAry::Grow(sizeof(ELEM), c);
    } // Grow
    
    HRESULT AppendIndirect(ELEM *pe, ELEM **ppePlaced=NULL)
    {
        return CImplAry::AppendIndirect(sizeof(ELEM), (void*)pe, (void**)ppePlaced);
    } // AppendIndirect
    
    ELEM * Append()
    {
        ELEM *pElem;
        return AppendIndirect( NULL, & pElem ) ? NULL : pElem;
    } // Append
    
    HRESULT InsertIndirect(int i, ELEM * pe)
    {
        return CImplAry::InsertIndirect(sizeof(ELEM), i, (void*)pe);
    } // InsertIndirect
    
    int FindIndirect(ELEM * pe)
    {
        return CImplAry::FindIndirect(sizeof(ELEM), (void*)pe);
    } // FindIndirect
    
    void DeleteItem(int i)
    {
        CImplAry::DeleteItem(sizeof(ELEM), i);
    } // DeleteItem
    
    bool DeleteByValueIndirect(ELEM *pe)
    {
        return CImplAry::DeleteByValueIndirect(sizeof(ELEM), (void*)pe);
    } // DeleteByValueIndirect
    
    void DeleteMultiple(int start, int end)
    {
        CImplAry::DeleteMultiple(sizeof(ELEM), start, end);
    } // DeleteMultiple
    
    HRESULT CopyAppend(const CDataAry<ELEM>& ary, bool fAddRef)
    {
        return E_NOTIMPL;
    } // CopyAppend
    
    HRESULT Copy(const CDataAry<ELEM>& ary, bool fAddRef)
    {
        return CImplAry::Copy(sizeof(ELEM), ary, fAddRef);
    } // Copy
    
    HRESULT CopyIndirect(int c, ELEM *pv, bool fAddRef)
    {
        return CImplAry::CopyIndirect(sizeof(ELEM), c, (void*)pv, fAddRef);
    } // CopyIndirect

    HRESULT EnumElements(REFIID  iid,
                         void  **ppv,
                         bool    fAddRef,
                         bool    fCopy = true,
                         bool    fDelete = true)
    {
        return CImplAry::EnumElements(sizeof(ELEM), iid, ppv, fAddRef, fCopy, fDelete);
    } // EnumElements

    HRESULT EnumVARIANT(VARTYPE        vt,
                        IEnumVARIANT **ppenum,
                        bool           fCopy = true,
                        bool           fDelete = true)
    {
        return CImplAry::EnumVARIANT(sizeof(ELEM), vt, ppenum, fCopy, fDelete);
    } // EnumVARIANT
}; // CDataAry

//************************************************************
//
//  Class:      CPtrAry
//
//  Purpose:    This template class declares a concrete derived class
//              of CImplPtrAry.
//
//              See documentation above for use.
//
//************************************************************

template <class ELEM>
class CPtrAry : public CImplPtrAry
{
public:

    CPtrAry() : CImplPtrAry()
    {
        Assert(sizeof(ELEM) == sizeof(void*));
    } // CPtrAry
    
    operator ELEM *()
    {
        return (ELEM *)PData();
    } // ELEM *
    
    CPtrAry(const CPtrAry &);

    ELEM & Item(int i)
    {
        return *(ELEM*)Deref(sizeof(ELEM), i);
    } // Item

    HRESULT Append(ELEM e)
    {
        return CImplPtrAry::Append((void*)e);
    } // Append

    HRESULT Insert(int i, ELEM e)
    {
        return CImplPtrAry::Insert(i, (void*)e);
    } // Insert

    bool DeleteByValue(ELEM e)
    {
        return CImplPtrAry::DeleteByValue((void*)e);
    } // DeleteByValue

    int Find(ELEM e)
    {
        return CImplPtrAry::Find((void*)e);
    } // Find

    HRESULT CopyAppend(const CPtrAry<ELEM>& ary, bool fAddRef)
    {
        return E_NOTIMPL;
    } // CopyAppend
    
    HRESULT Copy(const CPtrAry<ELEM>& ary, bool fAddRef)
    {
        return CImplPtrAry::Copy(ary, fAddRef);
    } // Copy
    
    HRESULT CopyIndirect(int c, ELEM *pe, bool fAddRef)
    {
        return CImplPtrAry::CopyIndirect(c, (void*)pe, fAddRef);
    } // CopyIndirect
}; // CPtrAry

//************************************************************
//
//  Class:      CStackDataAry
//
//  Purpose:    Declares a CDataAry that has initial storage on the stack.
//              N elements are declared on the stack, and the array will
//              grow dynamically beyond that if necessary.
//
//              See documentation above for use.
//
//************************************************************

/*lint ++flb*/
template <class ELEM, int N>
class CStackDataAry : public CDataAry<ELEM>
{
public:
    CStackDataAry(): CDataAry<ELEM> ()
    {
        m_cStack     = N;
        m_fStack     = true;
        m_fDontFree  = true;
        PData()      = (void *) & m_achTInit;
    } // CStackDataAry

protected:
    int   m_cStack;                     // Must be first data member.
    char  m_achTInit[N*sizeof(ELEM)];
}; // CStackDataAry
/*lint --flb*/

//************************************************************
//
//  Class:      CStackPtrAry
//
//  Purpose:    Same as CStackDataAry except for pointer types.
//
//              See documentation above for use.
//
//************************************************************

/*lint ++flb*/
template <class ELEM, int N>
class CStackPtrAry : public CPtrAry<ELEM>
{
public:
    CStackPtrAry() : CPtrAry<ELEM> ()
    {
        m_cStack     = N;
        m_fStack     = true;
        m_fDontFree  = true;
        PData()      = (void *) & m_achTInit;
    } // CStackPtrAry

protected:
    int   m_cStack;                     // Must be first data member.
    char  m_achTInit[N*sizeof(ELEM)];
}; // CStackPtrAry
/*lint --flb*/

//************************************************************
//
//  Class:      CBaseEnum (benum)
//
//  Purpose:    Base OLE enumerator class for a CImplAry.
//
//  Interface:  DECLARE_FORMS_STANRARD_IUNKNOWN
//
//              Next                   -- Per IEnum*
//              Skip                   --    ""
//              Reset                  --    ""
//              Clone                  --    ""
//              CBaseEnum              -- ctor.
//              CBaseEnum              -- ctor.
//              ~CBaseEnum             -- dtor.
//              Init                   -- 2nd stage initialization.
//              Deref                  -- gets pointer to element.
//
//  Notes:      Since there is no IEnum interface, we create a vtable
//              with the same layout as all IEnum interfaces.  Be careful
//              where you put virtual function declarations!
//
//************************************************************

class CBaseEnum : public IUnknown
{
public:
    //
    // IUnknown
    //
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppv);
    
    STDMETHOD_(ULONG, AddRef) (void)
    {
        return ++m_ulRefs;
    } // AddRef

    STDMETHOD_(ULONG, Release) (void)
    {
        if (--m_ulRefs == 0)
        {
            m_ulRefs = ULREF_IN_DESTRUCTOR;
            delete this;
            return 0;
        }
        return m_ulRefs;
    } // Release

    ULONG GetRefs(void)
    {
        return m_ulRefs;
    } // GetRefs

    //
    //  IEnum methods
    //
    STDMETHOD(Next) (ULONG celt, void * reelt, ULONG * pceltFetched) PURE;
    STDMETHOD(Skip) (ULONG celt);
    STDMETHOD(Reset) ();
    STDMETHOD(Clone) (CBaseEnum ** ppenum) PURE;

    //
    // Ensure that vtable contains virtual destructor after other virtual methods.
    //
    virtual ~CBaseEnum();

protected:
    CBaseEnum(size_t cb, REFIID iid, bool fAddRef, bool fDelete);
    CBaseEnum(const CBaseEnum & benum);

    CBaseEnum& operator=(const CBaseEnum & benum); // don't define

    HRESULT Init(CImplAry *rgItems, bool fCopy);
    void *  Deref(int i);

    CImplAry   *m_rgItems;
    const IID  *m_piid;
    int         m_i;
    size_t      m_cb;
    bool        m_fAddRef;
    bool        m_fDelete;
    ULONG       m_ulRefs;
    CBaseEnum();
}; // CBaseEnum

//************************************************************
//
//  Member:     CBaseEnum::Deref
//
//  Synopsis:   Forwards deref to m_rgItems.  Required because classes derived
//              from CBaseEnum are friends of CImplAry.
//
//************************************************************

inline void *
CBaseEnum::Deref(int i)
{
    Assert(i >= 0);
    return (BYTE *)m_rgItems->PData() + i * m_cb;
} // Deref 

#endif // _ARRAY_H_

//************************************************************
//
// End of file
//
//************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\proxy\wmp\comutil.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: comutil.cpp
//
//  Contents: 
//
//------------------------------------------------------------------------------------

#include "stdafx.h"
#include "comutil.h"
#include <shlwapi.h>

/////////////////////////////////////////////////////////////////////////////
// CTIMEComTypeInfoHolder

void CTIMEComTypeInfoHolder::AddRef()
{
        EnterCriticalSection(&_Module.m_csTypeInfoHolder);
        m_dwRef++;
        LeaveCriticalSection(&_Module.m_csTypeInfoHolder);
}

void CTIMEComTypeInfoHolder::Release()
{
        EnterCriticalSection(&_Module.m_csTypeInfoHolder);
        if (--m_dwRef == 0)
        {
                if (m_pInfo != NULL)
                        m_pInfo->Release();
                m_pInfo = NULL;
        }
        LeaveCriticalSection(&_Module.m_csTypeInfoHolder);
}

HRESULT CTIMEComTypeInfoHolder::GetTI(LCID lcid, ITypeInfo** ppInfo)
{
    //If this assert occurs then most likely didn't initialize properly
    _ASSERTE(m_pguid != NULL);
    _ASSERTE(ppInfo != NULL);
    USES_CONVERSION; //lint !e522
    *ppInfo = NULL;

    HRESULT hRes = E_FAIL;
    EnterCriticalSection(&_Module.m_csTypeInfoHolder);
    if (m_pInfo == NULL)
    {
        TCHAR szModule[MAX_PATH];

        GetModuleFileName(_Module.m_hInstTypeLib, szModule, MAX_PATH);

        if (m_ptszIndex != NULL)
        {
            PathAppend(szModule, m_ptszIndex);
        }
            
        ITypeLib* pTypeLib;
        LPOLESTR lpszModule = T2OLE(szModule);
        hRes = LoadTypeLib(lpszModule, &pTypeLib);

        if (SUCCEEDED(hRes))
        {
            ITypeInfo* pTypeInfo;
            hRes = pTypeLib->GetTypeInfoOfGuid(*m_pguid, &pTypeInfo);
            if (SUCCEEDED(hRes))
            {
                m_pInfo = pTypeInfo;
            }
            pTypeLib->Release();
        }
    }
    *ppInfo = m_pInfo;
    if (m_pInfo != NULL)
    {
        m_pInfo->AddRef();
        hRes = S_OK;
    }

    LeaveCriticalSection(&_Module.m_csTypeInfoHolder);
    return hRes;
} //lint !e550

HRESULT CTIMEComTypeInfoHolder::GetTypeInfo(UINT /*itinfo*/, LCID lcid,
        ITypeInfo** pptinfo)
{
        HRESULT hRes = E_POINTER;
        if (pptinfo != NULL)
                hRes = GetTI(lcid, pptinfo);
        return hRes;
}

HRESULT CTIMEComTypeInfoHolder::GetIDsOfNames(REFIID /*riid*/, LPOLESTR* rgszNames,
        UINT cNames, LCID lcid, DISPID* rgdispid)
{
        ITypeInfo* pInfo;
        HRESULT hRes = GetTI(lcid, &pInfo);
        if (pInfo != NULL)
        {
                hRes = pInfo->GetIDsOfNames(rgszNames, cNames, rgdispid);
                pInfo->Release();
        }
        return hRes;
}

HRESULT CTIMEComTypeInfoHolder::Invoke(IDispatch* p, DISPID dispidMember, REFIID /*riid*/,
        LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
        EXCEPINFO* pexcepinfo, UINT* puArgErr)
{
        SetErrorInfo(0, NULL);
        ITypeInfo* pInfo;
        HRESULT hRes = GetTI(lcid, &pInfo);
        if (pInfo != NULL)
        {
                hRes = pInfo->Invoke(p, dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
                pInfo->Release();
        }
        return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\proxy\wmp\contentproxy.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 2001 Microsoft Corporation
 *
 * File: ContentProxy.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/
#include "stdafx.h"
#include "browsewm.h"
#include "contentproxy.h"

#define NO_COOKIE   -1
#define ARRAYSIZE( a )  (sizeof(a) / sizeof(a[0]))
#define SIZEOF( a )     sizeof(a)

const DWORD     NUM_FRAMES_PER_SEC  = 10;
const double    NUM_SEC_PER_FRAME   = 0.1;

#define TIME_INFINITE HUGE_VAL

const GUID SID_STimeContent = {0x1ae98e18, 0xc527, 0x4f78, {0xb2, 0xa2, 0x6a, 0x81, 0x7f, 0x9c, 0xd4, 0xf8}};

#define WZ_ONMEDIACOMPLETE      L"onmediacomplete"
#define WZ_ONMEDIAERROR         L"onmediaerror"
#define WZ_ONBEGIN              L"onbegin"
#define WZ_ONEND                L"onend"
#define WZ_ONPAUSE              L"onpause"
#define WZ_ONRESUME             L"onresume"
#define WZ_ONSEEK               L"onseek"

#define WZ_MEDIACOMPLETE        L"mediacomplete"
#define WZ_MEDIAERROR           L"mediaerror"
#define WZ_BEGIN                L"begin"
#define WZ_END                  L"end"
#define WZ_PAUSE                L"pause"
#define WZ_RESUME               L"resume"
#define WZ_SEEK                 L"seek"

static const PWSTR ppszInterestingEvents[] = 
{ 
    WZ_ONMEDIACOMPLETE,
    WZ_ONMEDIAERROR,
    WZ_ONBEGIN,
    WZ_ONEND,
    WZ_ONPAUSE,
    WZ_ONRESUME,
    WZ_ONSEEK
};

/////////////////////////////////////////////////////////////////////////////
// CContentProxy

CContentProxy::CContentProxy() :
    m_spMediaHost(0),
    m_spTimeElement(0),
    m_dblClipDur(TIME_INFINITE),
    m_fEventsHooked(false)
{
}

CContentProxy::~CContentProxy()
{
}

//
// CContentProxy::GetMediaHost
//
HRESULT CContentProxy::GetMediaHost()
{
    HRESULT hr = S_OK;

    if (!m_spMediaHost)
    {
        // Get the Mediahost Service Interface
        hr = QueryService(SID_STimeContent, IID_TO_PPV(IMediaHost, &m_spMediaHost));
        if (FAILED(hr))
        {   
            goto done;
        }   

        if (m_spMediaHost)
        {
            hr = m_spMediaHost->addProxy(GetUnknown());
            if (FAILED(hr))
            {
                goto done;
            }
        }
    }

done:
    return hr;
}

//
// CContentProxy::CreateContainedControl
//
HRESULT STDMETHODCALLTYPE CContentProxy::CreateContainedControl(void)
{
    ATLTRACE(_T("CreateContainedControl\n"));   //lint !e506

    HRESULT hr = S_OK;

    if (!m_spMediaHost)
    {
        hr = GetMediaHost();
    }

    return hr;
}

//
// CContentProxy::fireEvent
//
HRESULT STDMETHODCALLTYPE CContentProxy::fireEvent(enum fireEvent event)
{
    return E_NOTIMPL;
}

//
// CContentProxy::detachPlayer
//
HRESULT STDMETHODCALLTYPE CContentProxy::detachPlayer()
{
    HRESULT hr = S_OK;

    // we will get this call when the media bar behavior needs
    // to unload. To prevent leaking, we should just let go of
    // it.

    UnHookEvents();

    // need to release time player
    m_spTimeElement = NULL;

    if (m_spMediaHost)
    {
        m_spMediaHost->removeProxy(GetUnknown());
    }

    // need to release media band
    m_spMediaHost = NULL;
    
    return hr;
}

// If the client site is changed then an init call must be made.
STDMETHODIMP CContentProxy::SetClientSite(IOleClientSite *pClientSite)
{
    HRESULT hr = S_OK;

    if(!pClientSite)
    {
        m_spOleClientSite.Release();
        m_spOleInPlaceSite.Release();
        m_spOleInPlaceSiteEx.Release();
        m_spOleInPlaceSiteWindowless.Release();
        m_spTIMEMediaPlayerSite.Release();
        m_spTIMEElement.Release();
        m_spTIMEState.Release();

        DeinitPropSink();
        goto done;
    }

    m_spOleClientSite = pClientSite;
    hr = m_spOleClientSite->QueryInterface(IID_IOleInPlaceSite, (void **)&m_spOleInPlaceSite);
    if(FAILED(hr))
    {
        goto punt;
    }
    hr = m_spOleClientSite->QueryInterface(IID_IOleInPlaceSiteEx, (void **)&m_spOleInPlaceSiteEx);
    if(FAILED(hr))
    {
        goto punt;
    }
    hr = m_spOleClientSite->QueryInterface(IID_IOleInPlaceSiteWindowless, (void **)&m_spOleInPlaceSiteWindowless);
    if(FAILED(hr))
    {
        goto punt;
    }

punt:
    hr = CProxyBaseImpl<&CLSID_ContentProxy, &LIBID_WMPProxyLib>::SetClientSite(pClientSite);
    
done:
    return hr;
}

//
// CContentProxy::HookupEvents
//
HRESULT CContentProxy::HookupEvents()
{
    // should only get called from OnCreatedPlayer
    HRESULT hr = S_OK;
    CComPtr<ITIMEContentPlayerSite> spContentPlayerSite;
    CComPtr<IUnknown> spUnk;
    CComPtr<IElementBehaviorSite> spElmSite;
    CComPtr<IHTMLElement> spHTMLElm;
    CComPtr<IHTMLElement2> spHTMLElm2;

    if (!m_spTimeElement)
    {
        hr = E_FAIL;
        goto done;
    }

    if (m_fEventsHooked)
    {
        UnHookEvents();
    }

    hr = m_spTimeElement->QueryInterface(IID_TO_PPV(ITIMEContentPlayerSite, &spContentPlayerSite));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = spContentPlayerSite->GetEventRelaySite(&spUnk);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = spUnk->QueryInterface(IID_TO_PPV(IElementBehaviorSite, &spElmSite));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = spElmSite->GetElement(&spHTMLElm);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = spHTMLElm->QueryInterface(IID_TO_PPV(IHTMLElement2, &spHTMLElm2));
    if (FAILED(hr))
    {
        goto done;
    }

    for (DWORD i = 0; i < ARRAYSIZE(ppszInterestingEvents); i++)
    {
        VARIANT_BOOL bSuccess = FALSE;
        // Try to attach all events. We don't care if they fail
        if (FAILED(spHTMLElm2->attachEvent(ppszInterestingEvents[i], static_cast<IDispatch*>(this), &bSuccess)))
        {
            hr = S_FALSE;
        }
    }

    m_fEventsHooked = true;

done:
    return hr;
}

//
// CContentProxy::UnHookEvents
//
HRESULT CContentProxy::UnHookEvents()
{
    // should only get called from OnCreatedPlayer
    HRESULT hr = S_OK;
    CComPtr<ITIMEContentPlayerSite> spContentPlayerSite;
    CComPtr<IElementBehaviorSite> spElmSite;
    CComPtr<IHTMLElement> spHTMLElm;
    CComPtr<IHTMLElement2> spHTMLElm2;

    if (!m_spTimeElement)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = m_spTimeElement->QueryInterface(IID_TO_PPV(ITIMEContentPlayerSite, &spContentPlayerSite));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = spContentPlayerSite->GetEventRelaySite((IUnknown**)&spElmSite);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = spElmSite->GetElement(&spHTMLElm);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = spHTMLElm->QueryInterface(IID_TO_PPV(IHTMLElement2, &spHTMLElm2));
    if (FAILED(hr))
    {
        goto done;
    }

    for (DWORD i = 0; i < ARRAYSIZE(ppszInterestingEvents); i++)
    {
        VARIANT_BOOL bSuccess = FALSE;
        // Try to attach all events. We don't care if they fail
        spHTMLElm2->detachEvent(ppszInterestingEvents[i], static_cast<IDispatch*>(this));
    }

    m_fEventsHooked = false;

done:
    return hr;
}

//
// CContentProxy::OnCreatedPlayer
//
HRESULT STDMETHODCALLTYPE CContentProxy::OnCreatedPlayer()
{
    HRESULT hr = S_OK;

    if (!m_spMediaHost)
    {
        hr = GetMediaHost();
        if (FAILED(hr))
        {
            goto done;
        }
    }
    // hook up to the media player here
    if (m_spMediaHost)
    {
        // if we already have one, get rid of it
        if (m_spTimeElement)
        {
            m_spTimeElement = NULL;
        }

        // this should return a ITIMEMediaElement
        hr = m_spMediaHost->getMediaPlayer(&m_spTimeElement);
        if (FAILED(hr))
        {
            // we could not get the media player
            // maybe we asked too soon
            goto done;
        }

        hr = HookupEvents();
    }

done:
    return hr;
}

//
// CContentProxy::begin
//
HRESULT STDMETHODCALLTYPE CContentProxy::begin(void)
{
    ATLTRACE(_T("begin\n"));    //lint !e506
    HRESULT hr = S_OK;
    CComVariant spVarURL;

    if (!m_spMediaHost)
    {
        hr = GetMediaHost();
        if (FAILED(hr))
        {
            goto done;
        }
    }

    if (m_bstrURL == NULL)
    {
        if (!m_spTimeElement)
        {
            OnCreatedPlayer();
            if (!m_spTimeElement)
            {
                hr = S_FALSE;
                goto done;
            }

            m_spTimeElement->get_src(&spVarURL);
        }

        if (spVarURL.bstrVal == NULL || V_VT(&spVarURL) != VT_BSTR)
        {
            hr = S_FALSE;
            goto done;
        }

        m_bstrURL.Empty();
        m_bstrURL = spVarURL.bstrVal;

    }


    hr = m_spMediaHost->playURL(m_bstrURL, L"audio/x-ms-asx");
    if (FAILED(hr))
    {
        goto done;
    }

done:
    return hr;
}

//
// CContentProxy::end
//
HRESULT STDMETHODCALLTYPE CContentProxy::end(void)
{
    ATLTRACE(_T("end\n"));    //lint !e506
    HRESULT hr = S_OK;
    return hr;
}

//
// CContentProxy::resume
//
HRESULT STDMETHODCALLTYPE CContentProxy::resume(void)
{
    ATLTRACE(_T("resume\n"));    //lint !e506
    HRESULT hr = S_OK;
    return hr;
}

//
// CContentProxy::pause
//
HRESULT STDMETHODCALLTYPE CContentProxy::pause(void)
{
    ATLTRACE(_T("pause\n"));    //lint !e506
    HRESULT hr = S_OK;
    return hr;
}

//
// CContentProxy::put_src
//
HRESULT STDMETHODCALLTYPE CContentProxy::put_src(BSTR bstrURL)
{
    ATLTRACE(_T("put_src\n"));  //lint !e506
    HRESULT hr = S_OK;
    VARIANT_BOOL vb;

    m_bstrURL.Empty();
    m_bstrURL = bstrURL;

    m_dblClipDur = TIME_INFINITE;

    if (!m_spMediaHost)
    {
        hr = GetMediaHost();
        if (FAILED(hr))
        {
            goto done;
        }
    }

    m_spTIMEState->get_isActive(&vb);
    if (vb == VARIANT_TRUE)
    {
        hr = m_spMediaHost->playURL(bstrURL, L"audio/x-ms-asx");
        if (FAILED(hr))
        {
            goto done;
        }
    }

done:
    return hr;
}

//
// CContentProxy::put_CurrentTime
// Not implemented
//
HRESULT STDMETHODCALLTYPE CContentProxy::put_CurrentTime(double dblCurrentTime)
{
    return E_NOTIMPL;
}

//
// CContentProxy::get_CurrentTime
// Not implemented
//
HRESULT STDMETHODCALLTYPE CContentProxy::get_CurrentTime(double* pdblCurrentTime)
{
    return E_NOTIMPL;
}

//
// CContentProxy::Init
// Sets up everything
//
STDMETHODIMP CContentProxy::Init(ITIMEMediaPlayerSite *pSite)
{
    HRESULT hr = S_OK;
    DAComPtr<IConnectionPointContainer> pcpc;

    m_spTIMEMediaPlayerSite = pSite;
    if(m_spTIMEMediaPlayerSite == NULL)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = m_spTIMEMediaPlayerSite->get_timeElement(&m_spTIMEElement);
    if(FAILED(hr))
    {
        goto done;
    }

    hr = m_spTIMEMediaPlayerSite->get_timeState(&m_spTIMEState);
    if(FAILED(hr))
    {
        goto done;
    }

    hr = InitPropSink();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = CreateContainedControl();
    if (FAILED(hr))
    {
        goto done;
    }

done:
    return S_OK;
}

//
// CContentProxy::Detach
// Cleans up anything we are holding on to
//
STDMETHODIMP CContentProxy::Detach(void)
{
    UnHookEvents();

    // need to release time player
    m_spTimeElement = NULL;

    if (m_spMediaHost)
    {
        m_spMediaHost->removeProxy(GetUnknown());
    }

    // need to release media band
    m_spMediaHost = NULL;
    

    // call this before releasing everything else.
    DeinitPropSink();

    m_spOleClientSite.Release();
    m_spOleInPlaceSite.Release();
    m_spOleInPlaceSiteEx.Release();
    m_spOleInPlaceSiteWindowless.Release();
    m_spTIMEMediaPlayerSite.Release();
    
    m_spTIMEElement.Release();
    m_spTIMEState.Release();

    return S_OK;
}

//
// CContentProxy::reset
// 
STDMETHODIMP CContentProxy::reset(void) 
{
    HRESULT hr = S_OK;
    return hr;
}

//
// CContentProxy::repeat
//
STDMETHODIMP CContentProxy::repeat(void)
{
    return begin();
}

//
// CContentProxy::seek
//
STDMETHODIMP CContentProxy::seek(double dblSeekTime)
{
    HRESULT hr = S_OK;
    return hr;
}

//
// CContentProxy::put_clipBegin
// Not implemented
//
STDMETHODIMP CContentProxy::put_clipBegin(VARIANT varClipBegin)
{
    return E_NOTIMPL;
}

//
// CContentProxy::put_clipEnd
// Not implemented
//
STDMETHODIMP CContentProxy::put_clipEnd(VARIANT varClipEnd)
{
    return E_NOTIMPL;
}

//
// CContentProxy::get_currTime
//
STDMETHODIMP CContentProxy::get_currTime(double* pdblCurrentTime)
{
    HRESULT hr = S_OK;
    CComPtr<ITIMEState> spTimeState;

    if (pdblCurrentTime == NULL)
    {
        return E_POINTER;
    }

    if (!m_spTimeElement)
    {
        OnCreatedPlayer();
        hr = S_OK;
        goto done;
    }

    hr = m_spTimeElement->get_currTimeState(&spTimeState);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = spTimeState->get_activeTime(pdblCurrentTime);

done:
    return hr;
}

//
// CContentProxy::get_clipDur
//
STDMETHODIMP CContentProxy::get_clipDur(double* pdbl)
{
    HRESULT hr = S_OK;

    *pdbl = m_dblClipDur;

    return hr;
}

//
// CContentProxy::get_mediaDur
// Not implemented
//
STDMETHODIMP CContentProxy::get_mediaDur(double* pdbl)
{
    HRESULT hr = S_OK;
    return hr;
}

//
// CContentProxy::get_state
//
STDMETHODIMP CContentProxy::get_state(TimeState *state)
{
    HRESULT hr = S_OK;
    return hr;
}

//
// CContentProxy::get_playList
//
STDMETHODIMP CContentProxy::get_playList(ITIMEPlayList** plist)
{
    HRESULT hr = S_OK;
    return hr;
}

//
// CContentProxy::get_abstract
//
STDMETHODIMP CContentProxy::get_abstract(BSTR* pbstr)
{
    HRESULT hr = S_OK;
    return hr;
}

//
// CContentProxy::get_author
//
STDMETHODIMP CContentProxy::get_author(BSTR* pbstr)
{
    HRESULT hr = S_OK;
    return hr;
}

//
// CContentProxy::get_copyright
//
STDMETHODIMP CContentProxy::get_copyright(BSTR* pbstr)
{
    HRESULT hr = S_OK;
    return hr;
}

//
// CContentProxy::get_rating
//
STDMETHODIMP CContentProxy::get_rating(BSTR* pbstr)
{
    HRESULT hr = S_OK;
    return hr;
}

//
// CContentProxy::get_title
//
STDMETHODIMP CContentProxy::get_title(BSTR* pbstr)
{
    HRESULT hr = S_OK;
    return hr;
}

//
// CContentProxy::get_canPause
//
STDMETHODIMP CContentProxy::get_canPause(VARIANT_BOOL* pvar)
{
    HRESULT hr = S_OK;
    return hr;
}

//
// CContentProxy::get_canSeek
//
STDMETHODIMP CContentProxy::get_canSeek(VARIANT_BOOL* pvar)
{
    HRESULT hr = S_OK;
    return hr;
}

//
// CContentProxy::get_hasAudio
//
STDMETHODIMP CContentProxy::get_hasAudio(VARIANT_BOOL* pvar)
{
    HRESULT hr = S_OK;
    return hr;
}

//
// CContentProxy::get_hasVisual
//
STDMETHODIMP CContentProxy::get_hasVisual(VARIANT_BOOL* pvar)
{
    HRESULT hr = S_OK;
    return hr;
}

//
// CContentProxy::get_mediaHeight
//
STDMETHODIMP CContentProxy::get_mediaHeight(long* pl)
{
    HRESULT hr = S_OK;
    return hr;
}

//
// CContentProxy::get_mediaWidth
//
STDMETHODIMP CContentProxy::get_mediaWidth(long* pl)
{
    HRESULT hr = S_OK;
    return hr;
}

//
// CContentProxy::get_customObject
//
STDMETHODIMP CContentProxy::get_customObject(IDispatch** ppdisp)
{
    HRESULT hr = S_OK;

    return SUPER::get_playerObject(ppdisp);
}

//
// CContentProxy::getControl
//
STDMETHODIMP CContentProxy::getControl(IUnknown ** control)
{
    HRESULT hr = E_FAIL;
    hr = _InternalQueryInterface(IID_IUnknown, (void **)control);
    if (FAILED(hr))
    {
        goto done;
    }

done:
    return hr;
}

//
// CContentProxy::Invoke
// 
STDMETHODIMP
CContentProxy::Invoke(DISPID dispIDMember, REFIID riid, LCID lcid, unsigned short wFlags, 
                         DISPPARAMS *pDispParams, VARIANT *pVarResult,
                         EXCEPINFO *pExcepInfo, UINT *puArgErr) 
{
    HRESULT hr = S_OK;
    CComBSTR sbstrEvent;
    CComPtr <IHTMLEventObj> pEventObj;
            
    if ((NULL != pDispParams) && (NULL != pDispParams->rgvarg) &&
        (V_VT(&(pDispParams->rgvarg[0])) == VT_DISPATCH))
    {
        hr = (pDispParams->rgvarg[0].pdispVal)->QueryInterface(IID_IHTMLEventObj, (void**)&pEventObj);
        if (SUCCEEDED(hr))
        {
            hr = pEventObj->get_type(&sbstrEvent);
        
            if (!sbstrEvent)
            {
                goto punt;
            }

            // relay these
            if (0 == lstrcmpiW(WZ_MEDIACOMPLETE, sbstrEvent))
            {
                NotifyPropertyChanged(DISPID_TIMEMEDIAPLAYER_SRC);
            }
            else if (0 == lstrcmpiW(WZ_MEDIAERROR, sbstrEvent))
            {
                NotifyPropertyChanged(DISPID_TIMEMEDIAPLAYERSITE_REPORTERROR);
            }
            else if (0 == lstrcmpiW(WZ_BEGIN, sbstrEvent))
            {
            }
            else if (0 == lstrcmpiW(WZ_END, sbstrEvent))
            {
                if (m_spTIMEState)
                {
                    m_spTIMEState->get_simpleTime(&m_dblClipDur);
                }
                NotifyPropertyChanged(DISPID_TIMEMEDIAPLAYER_CLIPDUR);
            }
            else if (0 == lstrcmpiW(WZ_PAUSE, sbstrEvent))
            {
                if (m_spTIMEElement)
                {
                    m_spTIMEElement->pauseElement();
                }
            }
            else if (0 == lstrcmpiW(WZ_RESUME, sbstrEvent))
            {
                if (m_spTIMEElement)
                {
                    m_spTIMEElement->resumeElement();
                }
            }
            else if (0 == lstrcmpiW(WZ_SEEK, sbstrEvent))
            {
                double dblTime;
                if (get_currTime(&dblTime) == S_OK)
                {
                    if (m_spTIMEElement)
                    {
                        m_spTIMEElement->seekActiveTime(dblTime);
                    }
                }
            }
        }
    }

punt:
    // Punt it!
    hr = CProxyBaseImpl<&CLSID_ContentProxy, &LIBID_WMPProxyLib>::Invoke(dispIDMember,
                                riid,
                                lcid,
                                wFlags,
                                pDispParams,
                                pVarResult,
                                pExcepInfo,
                                puArgErr);
    return hr;
} // Invoke

//
// CContentProxy::GetConnectionPoint
//
HRESULT CContentProxy::GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP)
{
    return FindConnectionPoint(riid, ppICP);
} // GetConnectionPoint


//
// CContentProxy::NotifyPropertyChanged
// notifies all the connections that one of the property has changed
//
HRESULT CContentProxy::NotifyPropertyChanged(DISPID dispid)
{
    HRESULT hr;

    IConnectionPoint *pICP = NULL;
    IEnumConnections *pEnum = NULL;

    // This object does not persist anything, hence commenting out the following
    // m_fPropertiesDirty = true;

    hr = GetConnectionPoint(IID_IPropertyNotifySink,&pICP); 
    if (SUCCEEDED(hr) && pICP != NULL)
    {
        hr = pICP->EnumConnections(&pEnum);
        pICP->Release();
        if (FAILED(hr))
        {
            goto done;
        }
        CONNECTDATA cdata;
        hr = pEnum->Next(1, &cdata, NULL);
        while (hr == S_OK)
        {
            // check cdata for the object we need
            IPropertyNotifySink *pNotify;
            hr = cdata.pUnk->QueryInterface(IID_IPropertyNotifySink, (void **)&pNotify);
            cdata.pUnk->Release();
            if (FAILED(hr))
            {
                goto done;
            }
            hr = pNotify->OnChanged(dispid);
            pNotify->Release();
            if (FAILED(hr))
            {
                goto done;
            }
            // and get the next enumeration
            hr = pEnum->Next(1, &cdata, NULL);
        }
    }
done:
    if (NULL != pEnum)
    {
        pEnum->Release();
    }

    return hr;
} // NotifyPropertyChanged

//
// CContentProxy::InitPropSink
//
HRESULT CContentProxy::InitPropSink()
{
    HRESULT hr = S_OK;
    CComPtr<IConnectionPoint> spCP;
    CComPtr<IConnectionPointContainer> spCPC;
    
    if (!m_spTIMEState)
    {
        goto done;
    }
    
    hr = m_spTIMEState->QueryInterface(IID_IConnectionPointContainer, (void **) &spCPC);
    if (FAILED(hr))
    {
        hr = S_OK;
        goto done;
    }

    // Find the IPropertyNotifySink connection
    hr = spCPC->FindConnectionPoint(IID_IPropertyNotifySink, &spCP);
    if (FAILED(hr))
    {
        hr = S_OK;
        goto done;
    }

    hr = spCP->Advise(GetUnknown(), &m_dwPropCookie);
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
  done:
    return hr;
}

//
// CContentProxy::DeinitPropSink
//
void CContentProxy::DeinitPropSink()
{
    HRESULT hr;
    CComPtr<IConnectionPoint> spCP;
    CComPtr<IConnectionPointContainer> spCPC;
    
    if (!m_spTIMEState || !m_dwPropCookie)
    {
        goto done;
    }
    
    hr = m_spTIMEState->QueryInterface(IID_IConnectionPointContainer, (void **) &spCPC);
    if (FAILED(hr))
    {
        goto done;
    }

    // Find the IPropertyNotifySink connection
    hr = spCPC->FindConnectionPoint(IID_IPropertyNotifySink,
                                    &spCP);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = spCP->Unadvise(m_dwPropCookie);
    if (FAILED(hr))
    {
        goto done;
    }
    
  done:
    // Always clear the cookie
    m_dwPropCookie = 0;
    return;
}

//
// CContentProxy::OnRequestEdit
//
STDMETHODIMP
CContentProxy::OnRequestEdit(DISPID dispID)
{
    return S_OK;
}

//
// CContentProxy::OnChanged
//
STDMETHODIMP
CContentProxy::OnChanged(DISPID dispID)
{
    float flTeSpeed = 0.0;
    HRESULT hr = S_OK;

    //This function handles property change notifications fired by 
    //the time node. In the example below the speed change notification is processed.

    if(m_spTIMEState == NULL || m_spTIMEElement == NULL)
    {
        goto done;
    }

    switch(dispID)
    {
        case DISPID_TIMESTATE_SPEED:
            //hr = m_spTIMEState->get_speed(&flTeSpeed);
            if(FAILED(hr))
            {
                break;
            }
            if(flTeSpeed <= 0.0)
            {
                pause(); //do not play backwards.
                break;
            }
            else
            {
                resume();
            }

            //set playback speed to flTeSpeed
            break;
        default:
            break;
    }
done:
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\proxy\wmp\errbase.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Mon Jan 29 14:04:27 2001
 */
/* Compiler settings for .\errbase.idl:
    Oicf (OptLev=i2), W0, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __errbase_h__
#define __errbase_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IWMPErrorItemInternal_FWD_DEFINED__
#define __IWMPErrorItemInternal_FWD_DEFINED__
typedef interface IWMPErrorItemInternal IWMPErrorItemInternal;
#endif 	/* __IWMPErrorItemInternal_FWD_DEFINED__ */


#ifndef __IWMPErrorEventSink_FWD_DEFINED__
#define __IWMPErrorEventSink_FWD_DEFINED__
typedef interface IWMPErrorEventSink IWMPErrorEventSink;
#endif 	/* __IWMPErrorEventSink_FWD_DEFINED__ */


#ifndef __IWMPErrorManager_FWD_DEFINED__
#define __IWMPErrorManager_FWD_DEFINED__
typedef interface IWMPErrorManager IWMPErrorManager;
#endif 	/* __IWMPErrorManager_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "wmp.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IWMPErrorItemInternal_INTERFACE_DEFINED__
#define __IWMPErrorItemInternal_INTERFACE_DEFINED__

/* interface IWMPErrorItemInternal */
/* [helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMPErrorItemInternal;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("12664C8E-FF07-447d-A272-BF6706795267")
    IWMPErrorItemInternal : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetError( 
            /* [in] */ HRESULT hr,
            /* [in] */ long lRemedy,
            /* [in] */ BSTR bstrDescription,
            /* [in] */ VARIANT __RPC_FAR *pvarContext,
            /* [in] */ BSTR bstrCustomUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetErrorCodeInternal( 
            /* [out] */ long __RPC_FAR *phr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetErrorDescriptionInternal( 
            /* [out] */ BSTR __RPC_FAR *pbstrDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWebHelpURL( 
            /* [out] */ BSTR __RPC_FAR *pbstrURL) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPErrorItemInternalVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPErrorItemInternal __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPErrorItemInternal __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPErrorItemInternal __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetError )( 
            IWMPErrorItemInternal __RPC_FAR * This,
            /* [in] */ HRESULT hr,
            /* [in] */ long lRemedy,
            /* [in] */ BSTR bstrDescription,
            /* [in] */ VARIANT __RPC_FAR *pvarContext,
            /* [in] */ BSTR bstrCustomUrl);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetErrorCodeInternal )( 
            IWMPErrorItemInternal __RPC_FAR * This,
            /* [out] */ long __RPC_FAR *phr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetErrorDescriptionInternal )( 
            IWMPErrorItemInternal __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrDescription);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWebHelpURL )( 
            IWMPErrorItemInternal __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrURL);
        
        END_INTERFACE
    } IWMPErrorItemInternalVtbl;

    interface IWMPErrorItemInternal
    {
        CONST_VTBL struct IWMPErrorItemInternalVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPErrorItemInternal_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPErrorItemInternal_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPErrorItemInternal_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPErrorItemInternal_SetError(This,hr,lRemedy,bstrDescription,pvarContext,bstrCustomUrl)	\
    (This)->lpVtbl -> SetError(This,hr,lRemedy,bstrDescription,pvarContext,bstrCustomUrl)

#define IWMPErrorItemInternal_GetErrorCodeInternal(This,phr)	\
    (This)->lpVtbl -> GetErrorCodeInternal(This,phr)

#define IWMPErrorItemInternal_GetErrorDescriptionInternal(This,pbstrDescription)	\
    (This)->lpVtbl -> GetErrorDescriptionInternal(This,pbstrDescription)

#define IWMPErrorItemInternal_GetWebHelpURL(This,pbstrURL)	\
    (This)->lpVtbl -> GetWebHelpURL(This,pbstrURL)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMPErrorItemInternal_SetError_Proxy( 
    IWMPErrorItemInternal __RPC_FAR * This,
    /* [in] */ HRESULT hr,
    /* [in] */ long lRemedy,
    /* [in] */ BSTR bstrDescription,
    /* [in] */ VARIANT __RPC_FAR *pvarContext,
    /* [in] */ BSTR bstrCustomUrl);


void __RPC_STUB IWMPErrorItemInternal_SetError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPErrorItemInternal_GetErrorCodeInternal_Proxy( 
    IWMPErrorItemInternal __RPC_FAR * This,
    /* [out] */ long __RPC_FAR *phr);


void __RPC_STUB IWMPErrorItemInternal_GetErrorCodeInternal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPErrorItemInternal_GetErrorDescriptionInternal_Proxy( 
    IWMPErrorItemInternal __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrDescription);


void __RPC_STUB IWMPErrorItemInternal_GetErrorDescriptionInternal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPErrorItemInternal_GetWebHelpURL_Proxy( 
    IWMPErrorItemInternal __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrURL);


void __RPC_STUB IWMPErrorItemInternal_GetWebHelpURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPErrorItemInternal_INTERFACE_DEFINED__ */


#ifndef __IWMPErrorEventSink_INTERFACE_DEFINED__
#define __IWMPErrorEventSink_INTERFACE_DEFINED__

/* interface IWMPErrorEventSink */
/* [helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMPErrorEventSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A53CD8E6-384B-4e80-A5E0-9E869716440E")
    IWMPErrorEventSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnErrorEvent( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPErrorEventSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPErrorEventSink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPErrorEventSink __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPErrorEventSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnErrorEvent )( 
            IWMPErrorEventSink __RPC_FAR * This);
        
        END_INTERFACE
    } IWMPErrorEventSinkVtbl;

    interface IWMPErrorEventSink
    {
        CONST_VTBL struct IWMPErrorEventSinkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPErrorEventSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPErrorEventSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPErrorEventSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPErrorEventSink_OnErrorEvent(This)	\
    (This)->lpVtbl -> OnErrorEvent(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMPErrorEventSink_OnErrorEvent_Proxy( 
    IWMPErrorEventSink __RPC_FAR * This);


void __RPC_STUB IWMPErrorEventSink_OnErrorEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPErrorEventSink_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_errbase_0272 */
/* [local] */ 

typedef 
enum eErrorManagerCaller
    {	eEMCallerAll	= 0,
	eEMCallerScript	= eEMCallerAll + 1,
	eEMCallerInternal	= eEMCallerScript + 1,
	eEMCallerLast	= eEMCallerInternal + 1
    }	eErrorManagerCaller;



extern RPC_IF_HANDLE __MIDL_itf_errbase_0272_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_errbase_0272_v0_0_s_ifspec;

#ifndef __IWMPErrorManager_INTERFACE_DEFINED__
#define __IWMPErrorManager_INTERFACE_DEFINED__

/* interface IWMPErrorManager */
/* [helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMPErrorManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A2440E4D-75EF-43e5-86CA-0C2EFE4CCAF3")
    IWMPErrorManager : public IUnknown
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ErrorCount( 
            /* [retval][out] */ DWORD __RPC_FAR *pdwNumErrors) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetError( 
            /* [in] */ HRESULT hr,
            /* [in] */ long lRemedy,
            /* [in] */ BSTR bstrDescription,
            /* [in] */ VARIANT __RPC_FAR *pvarContext,
            /* [in] */ VARIANT_BOOL vbQuiet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetErrorWithCustomUrl( 
            /* [in] */ HRESULT hr,
            /* [in] */ long lRemedy,
            /* [in] */ BSTR bstrDescription,
            /* [in] */ VARIANT __RPC_FAR *pvarContext,
            /* [in] */ VARIANT_BOOL vbQuiet,
            /* [in] */ BSTR bstrCustomUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ DWORD dwIndex,
            /* [out] */ IWMPErrorItem __RPC_FAR *__RPC_FAR *ppErrorItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterErrorSink( 
            /* [in] */ IWMPErrorEventSink __RPC_FAR *pEventSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterErrorSink( 
            /* [in] */ IWMPErrorEventSink __RPC_FAR *pEventSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SuspendErrorEvents( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResumeErrorEvents( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWebHelpURL( 
            /* [out] */ BSTR __RPC_FAR *pbstrURL,
            /* [in] */ eErrorManagerCaller eCaller) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearErrorQueue( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FireEventIfErrors( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetErrorDescription( 
            /* [in] */ HRESULT hr,
            /* [in] */ long lRemedy,
            /* [out] */ BSTR __RPC_FAR *pbstrURL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateErrorItem( 
            /* [out] */ IWMPErrorItemInternal __RPC_FAR *__RPC_FAR *pErrorItemInternal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPErrorManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPErrorManager __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPErrorManager __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPErrorManager __RPC_FAR * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ErrorCount )( 
            IWMPErrorManager __RPC_FAR * This,
            /* [retval][out] */ DWORD __RPC_FAR *pdwNumErrors);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetError )( 
            IWMPErrorManager __RPC_FAR * This,
            /* [in] */ HRESULT hr,
            /* [in] */ long lRemedy,
            /* [in] */ BSTR bstrDescription,
            /* [in] */ VARIANT __RPC_FAR *pvarContext,
            /* [in] */ VARIANT_BOOL vbQuiet);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetErrorWithCustomUrl )( 
            IWMPErrorManager __RPC_FAR * This,
            /* [in] */ HRESULT hr,
            /* [in] */ long lRemedy,
            /* [in] */ BSTR bstrDescription,
            /* [in] */ VARIANT __RPC_FAR *pvarContext,
            /* [in] */ VARIANT_BOOL vbQuiet,
            /* [in] */ BSTR bstrCustomUrl);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Item )( 
            IWMPErrorManager __RPC_FAR * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ IWMPErrorItem __RPC_FAR *__RPC_FAR *ppErrorItem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterErrorSink )( 
            IWMPErrorManager __RPC_FAR * This,
            /* [in] */ IWMPErrorEventSink __RPC_FAR *pEventSink);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnregisterErrorSink )( 
            IWMPErrorManager __RPC_FAR * This,
            /* [in] */ IWMPErrorEventSink __RPC_FAR *pEventSink);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SuspendErrorEvents )( 
            IWMPErrorManager __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResumeErrorEvents )( 
            IWMPErrorManager __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWebHelpURL )( 
            IWMPErrorManager __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrURL,
            /* [in] */ eErrorManagerCaller eCaller);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearErrorQueue )( 
            IWMPErrorManager __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FireEventIfErrors )( 
            IWMPErrorManager __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetErrorDescription )( 
            IWMPErrorManager __RPC_FAR * This,
            /* [in] */ HRESULT hr,
            /* [in] */ long lRemedy,
            /* [out] */ BSTR __RPC_FAR *pbstrURL);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateErrorItem )( 
            IWMPErrorManager __RPC_FAR * This,
            /* [out] */ IWMPErrorItemInternal __RPC_FAR *__RPC_FAR *pErrorItemInternal);
        
        END_INTERFACE
    } IWMPErrorManagerVtbl;

    interface IWMPErrorManager
    {
        CONST_VTBL struct IWMPErrorManagerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPErrorManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPErrorManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPErrorManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPErrorManager_get_ErrorCount(This,pdwNumErrors)	\
    (This)->lpVtbl -> get_ErrorCount(This,pdwNumErrors)

#define IWMPErrorManager_SetError(This,hr,lRemedy,bstrDescription,pvarContext,vbQuiet)	\
    (This)->lpVtbl -> SetError(This,hr,lRemedy,bstrDescription,pvarContext,vbQuiet)

#define IWMPErrorManager_SetErrorWithCustomUrl(This,hr,lRemedy,bstrDescription,pvarContext,vbQuiet,bstrCustomUrl)	\
    (This)->lpVtbl -> SetErrorWithCustomUrl(This,hr,lRemedy,bstrDescription,pvarContext,vbQuiet,bstrCustomUrl)

#define IWMPErrorManager_Item(This,dwIndex,ppErrorItem)	\
    (This)->lpVtbl -> Item(This,dwIndex,ppErrorItem)

#define IWMPErrorManager_RegisterErrorSink(This,pEventSink)	\
    (This)->lpVtbl -> RegisterErrorSink(This,pEventSink)

#define IWMPErrorManager_UnregisterErrorSink(This,pEventSink)	\
    (This)->lpVtbl -> UnregisterErrorSink(This,pEventSink)

#define IWMPErrorManager_SuspendErrorEvents(This)	\
    (This)->lpVtbl -> SuspendErrorEvents(This)

#define IWMPErrorManager_ResumeErrorEvents(This)	\
    (This)->lpVtbl -> ResumeErrorEvents(This)

#define IWMPErrorManager_GetWebHelpURL(This,pbstrURL,eCaller)	\
    (This)->lpVtbl -> GetWebHelpURL(This,pbstrURL,eCaller)

#define IWMPErrorManager_ClearErrorQueue(This)	\
    (This)->lpVtbl -> ClearErrorQueue(This)

#define IWMPErrorManager_FireEventIfErrors(This)	\
    (This)->lpVtbl -> FireEventIfErrors(This)

#define IWMPErrorManager_GetErrorDescription(This,hr,lRemedy,pbstrURL)	\
    (This)->lpVtbl -> GetErrorDescription(This,hr,lRemedy,pbstrURL)

#define IWMPErrorManager_CreateErrorItem(This,pErrorItemInternal)	\
    (This)->lpVtbl -> CreateErrorItem(This,pErrorItemInternal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE IWMPErrorManager_get_ErrorCount_Proxy( 
    IWMPErrorManager __RPC_FAR * This,
    /* [retval][out] */ DWORD __RPC_FAR *pdwNumErrors);


void __RPC_STUB IWMPErrorManager_get_ErrorCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPErrorManager_SetError_Proxy( 
    IWMPErrorManager __RPC_FAR * This,
    /* [in] */ HRESULT hr,
    /* [in] */ long lRemedy,
    /* [in] */ BSTR bstrDescription,
    /* [in] */ VARIANT __RPC_FAR *pvarContext,
    /* [in] */ VARIANT_BOOL vbQuiet);


void __RPC_STUB IWMPErrorManager_SetError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPErrorManager_SetErrorWithCustomUrl_Proxy( 
    IWMPErrorManager __RPC_FAR * This,
    /* [in] */ HRESULT hr,
    /* [in] */ long lRemedy,
    /* [in] */ BSTR bstrDescription,
    /* [in] */ VARIANT __RPC_FAR *pvarContext,
    /* [in] */ VARIANT_BOOL vbQuiet,
    /* [in] */ BSTR bstrCustomUrl);


void __RPC_STUB IWMPErrorManager_SetErrorWithCustomUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPErrorManager_Item_Proxy( 
    IWMPErrorManager __RPC_FAR * This,
    /* [in] */ DWORD dwIndex,
    /* [out] */ IWMPErrorItem __RPC_FAR *__RPC_FAR *ppErrorItem);


void __RPC_STUB IWMPErrorManager_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPErrorManager_RegisterErrorSink_Proxy( 
    IWMPErrorManager __RPC_FAR * This,
    /* [in] */ IWMPErrorEventSink __RPC_FAR *pEventSink);


void __RPC_STUB IWMPErrorManager_RegisterErrorSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPErrorManager_UnregisterErrorSink_Proxy( 
    IWMPErrorManager __RPC_FAR * This,
    /* [in] */ IWMPErrorEventSink __RPC_FAR *pEventSink);


void __RPC_STUB IWMPErrorManager_UnregisterErrorSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPErrorManager_SuspendErrorEvents_Proxy( 
    IWMPErrorManager __RPC_FAR * This);


void __RPC_STUB IWMPErrorManager_SuspendErrorEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPErrorManager_ResumeErrorEvents_Proxy( 
    IWMPErrorManager __RPC_FAR * This);


void __RPC_STUB IWMPErrorManager_ResumeErrorEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPErrorManager_GetWebHelpURL_Proxy( 
    IWMPErrorManager __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrURL,
    /* [in] */ eErrorManagerCaller eCaller);


void __RPC_STUB IWMPErrorManager_GetWebHelpURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPErrorManager_ClearErrorQueue_Proxy( 
    IWMPErrorManager __RPC_FAR * This);


void __RPC_STUB IWMPErrorManager_ClearErrorQueue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPErrorManager_FireEventIfErrors_Proxy( 
    IWMPErrorManager __RPC_FAR * This);


void __RPC_STUB IWMPErrorManager_FireEventIfErrors_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPErrorManager_GetErrorDescription_Proxy( 
    IWMPErrorManager __RPC_FAR * This,
    /* [in] */ HRESULT hr,
    /* [in] */ long lRemedy,
    /* [out] */ BSTR __RPC_FAR *pbstrURL);


void __RPC_STUB IWMPErrorManager_GetErrorDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPErrorManager_CreateErrorItem_Proxy( 
    IWMPErrorManager __RPC_FAR * This,
    /* [out] */ IWMPErrorItemInternal __RPC_FAR *__RPC_FAR *pErrorItemInternal);


void __RPC_STUB IWMPErrorManager_CreateErrorItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPErrorManager_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\proxy\wmp\contentproxy.h ===
/*******************************************************************************
 *
 * Copyright (c) 2001 Microsoft Corporation
 *
 * File: ContentProxy.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/
#pragma once

#include "w95wraps.h"
#include "resource.h"       // main symbols
#include "..\ProxyBaseImpl.h"
#include "array.h"
#include "mediaprivate.h"
#include "mshtml.h"

interface IMediaHost;

/**************************************************************************************************
 * DANGER --- DANGER --- DANGER --- DANGER --- DANGER --- DANGER --- DANGER --- DANGER --- DANGER *
 *                                                                                                *
 * not using the IDL from shell/browseUI -- this is BAD!!                                         *
 **************************************************************************************************/


const GUID IID_IMediaHost = {0xEF508010,0xC806,0x4356,{0x84,0x92,0xD1,0x5E,0x61,0x6F,0x6F,0x37}};

interface IMediaHost : public IUnknown
{
    public:
        virtual HRESULT STDMETHODCALLTYPE getMediaPlayer(ITIMEMediaElement **ppPlayer) = 0;
        virtual HRESULT STDMETHODCALLTYPE playURL(BSTR bstrURL, BSTR bstrMIME) = 0;
        virtual HRESULT STDMETHODCALLTYPE addProxy(IUnknown *pProxy) = 0;
        virtual HRESULT STDMETHODCALLTYPE removeProxy(IUnknown *pProxy) = 0;
};

/* END OF DANGER **********************************************************************************/

// Need to link -- dunno why its not linking...
DEFINE_GUID(IID_IContentProxy,0xEF508011,0xC806,0x4356,0x84,0x92,0xD1,0x5E,0x61,0x6F,0x6F,0x37);
DEFINE_GUID(IID_ITIMEContentPlayerSite,0x911A444E,0xB951,0x43ea,0xB3,0xAA,0x17,0xEF,0xC2,0x87,0x98,0x31);


/////////////////////////////////////////////////////////////////////////////
// CContentProxy
class CContentProxy : 
    public CProxyBaseImpl<&CLSID_ContentProxy, &LIBID_WMPProxyLib>,
    public IConnectionPointContainerImpl<CContentProxy>,
    public IPropertyNotifySinkCP<CContentProxy>,
    public IPropertyNotifySink,
    public ITIMEMediaPlayerControl,
    public IContentProxy
{
private:
    typedef CProxyBaseImpl<&CLSID_ContentProxy, &LIBID_WMPProxyLib> SUPER;

    CComPtr<ITIMEMediaPlayerSite> m_spTIMEMediaPlayerSite;
    CComPtr<ITIMEElement> m_spTIMEElement;
    CComPtr<ITIMEState> m_spTIMEState;
    DWORD m_dwPropCookie;

protected:
    CComPtr<IOleClientSite> m_spOleClientSite;
    CComPtr<IOleInPlaceSite> m_spOleInPlaceSite;
    CComPtr<IOleInPlaceSiteEx> m_spOleInPlaceSiteEx;
    CComPtr<IOleInPlaceSiteWindowless> m_spOleInPlaceSiteWindowless;

    STDMETHOD(CreateContainedControl)(void);
private:
    CComPtr<IMediaHost> m_spMediaHost;
    CComPtr<ITIMEMediaElement> m_spTimeElement;
    CComBSTR m_bstrURL;
    double m_dblClipDur;
    bool m_fEventsHooked;

    HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP);
    HRESULT NotifyPropertyChanged(DISPID dispid);
    HRESULT InitPropSink();

    void DeinitPropSink();

    HRESULT HookupEvents();
    HRESULT UnHookEvents();
    HRESULT GetMediaHost();

public:
    CContentProxy();
    virtual ~CContentProxy();

    STDMETHOD(Init)(ITIMEMediaPlayerSite *pSite);
    STDMETHOD(Detach)(void);

    STDMETHOD(put_clipBegin)(VARIANT varClipBegin);
    STDMETHOD(put_clipEnd)(VARIANT varClipEnd);
    STDMETHOD(begin)(void);
    STDMETHOD(end)(void);
    STDMETHOD(resume)(void);
    STDMETHOD(pause)(void);
    STDMETHOD(reset)(void);
    STDMETHOD(repeat)(void);
    STDMETHOD(seek)(double dblSeekTime);

    STDMETHOD(get_currTime)(double* pdblCurrentTime);
    STDMETHOD(get_clipDur)(double* pdblClipDur);
    STDMETHOD(get_mediaDur)(double* pdblMediaDur);
    STDMETHOD(get_state)(TimeState * ts);
    STDMETHOD(get_playList)(ITIMEPlayList ** plist);

    STDMETHOD(get_abstract)(BSTR* pbstrAbs);
    STDMETHOD(get_author)(BSTR* pbstrAut);
    STDMETHOD(get_copyright)(BSTR* pbstrCop);
    STDMETHOD(get_rating)(BSTR* pbstrRat);
    STDMETHOD(get_title)(BSTR* pbstrTit);

    STDMETHOD(get_canPause(VARIANT_BOOL * b));
    STDMETHOD(get_canSeek(VARIANT_BOOL * b));
    STDMETHOD(get_hasAudio(VARIANT_BOOL * b));
    STDMETHOD(get_hasVisual(VARIANT_BOOL * b));
    STDMETHOD(get_mediaHeight(long * width));
    STDMETHOD(get_mediaWidth(long * height));

    STDMETHOD(put_src)(BSTR   bstrURL);
    STDMETHOD(put_CurrentTime)(double   dblCurrentTime);
    STDMETHOD(get_CurrentTime)(double* pdblCurrentTime);

    STDMETHOD(get_customObject)(IDispatch ** disp);
    STDMETHOD(getControl)(IUnknown ** control);

    // IContentProxy
    STDMETHOD(OnCreatedPlayer)();
    STDMETHOD(fireEvent)(enum fireEvent event);
    STDMETHOD(detachPlayer)();

    //
    // IPropertyNotifySink methods
    //
    STDMETHOD(OnChanged)(DISPID dispID);
    STDMETHOD(OnRequestEdit)(DISPID dispID);

    STDMETHOD(SetClientSite)(IOleClientSite *pClientSite);

    STDMETHOD(Invoke)(DISPID disIDMember,
                        REFIID riid,
                        LCID lcid,
                        unsigned short wFlags,
                        DISPPARAMS *pDispParams,
                        VARIANT *pVarResult,
                        EXCEPINFO *pExcepInfo,
                        UINT *puArgErr);

DECLARE_REGISTRY_RESOURCEID(IDR_WMPPROXY)
DECLARE_NOT_AGGREGATABLE(CContentProxy)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CContentProxy)
    COM_INTERFACE_ENTRY(ITIMEMediaPlayer)
    COM_INTERFACE_ENTRY(ITIMEMediaPlayerControl)
    COM_INTERFACE_ENTRY(IContentProxy)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    COM_INTERFACE_ENTRY(IPropertyNotifySink)
    COM_INTERFACE_ENTRY_IID(IID_ITIMEMediaElement, IDispatch)
    COM_INTERFACE_ENTRY_CHAIN(SUPER)
END_COM_MAP()


BEGIN_CONNECTION_POINT_MAP(CContentProxy)
    CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
END_CONNECTION_POINT_MAP();

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\proxy\wmp\playlist.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * File: Playlist.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#include "stdafx.h"
#include "browsewm.h"
#include "playlist.h"
#include "shlwapi.h"

//*******************************************************************************
// *  CPlayList
// *******************************************************************************
CPlayList::CPlayList()
: m_rgItems(NULL),
  m_player(NULL),
  m_fLoaded(false)
{
}

///////////////////////////////////////////////////////////////
//  Name: ~CPlayList
// 
//  Abstract:  Handles destruction of the items array and
//             releasing all pointers in the array
///////////////////////////////////////////////////////////////
CPlayList::~CPlayList()
{
    Deinit();

    delete m_rgItems;
    m_rgItems = NULL;
    m_player = NULL;
}

///////////////////////////////////////////////////////////////
//  Name: Init
// 
//  Abstract:  Handles allocation of the items array if it 
//             is ever accessed.
///////////////////////////////////////////////////////////////
HRESULT
CPlayList::Init(CWMPProxy & player)
{
    HRESULT hr;

    m_player = &player;
    
    if (m_rgItems == NULL)
    {
        m_rgItems = new CPtrAry<CPlayItem *>;
        if (m_rgItems == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }

    hr = S_OK;
  done:
    return hr;
}

void
CPlayList::Deinit()
{
    m_player = NULL;

    Clear();
}

///////////////////////////////////////////////////////////////
//  Name: SetLoaded
// 
//  Abstract:  sets a flag that marks whether the playlist is 
//             loaded or not.
///////////////////////////////////////////////////////////////
void 
CPlayList::SetLoaded(bool bLoaded)
{
    if (bLoaded != m_fLoaded)
    {
        m_fLoaded = bLoaded;

        if (m_fLoaded && V_VT(&m_vNewTrack) != VT_NULL)
        {
            put_activeTrack(m_vNewTrack);
        }

        m_vNewTrack.Clear();
    }
}

///////////////////////////////////////////////////////////////
//  Name: SetLoaded
// 
//  Abstract:  sets a flag that marks whether the playlist is 
//             loaded or not.
///////////////////////////////////////////////////////////////
void 
CPlayList::SetLoadedFlag(bool bLoaded)
{
    if (bLoaded != m_fLoaded)
    {
        m_fLoaded = bLoaded;
    }
}

///////////////////////////////////////////////////////////////
//  Name: get_length
// 
//  Abstract:  returns the size of the array
///////////////////////////////////////////////////////////////
STDMETHODIMP
CPlayList::get_length(long *len)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_NULL(len);

    *len = GetLength();

    hr = S_OK;

    return hr;
}

///////////////////////////////////////////////////////////////
//  Name: get__newEnum
// 
//  Abstract:  Creates the IEnumVARIANT class for this
//             collection.
///////////////////////////////////////////////////////////////
STDMETHODIMP
CPlayList::get__newEnum(IUnknown** p)
{
    HRESULT hr;
    CComObject<CPlayListEnum> * pNewEnum;
    
    CHECK_RETURN_SET_NULL(p);

    hr = CComObject<CPlayListEnum>::CreateInstance(&pNewEnum);
    if (hr != S_OK)
    {
        goto done;
    }

    // Init the object
    pNewEnum->Init(*this);

    hr = pNewEnum->QueryInterface(IID_IUnknown, (void **)p);
    if (FAILED(hr))
    {
        delete pNewEnum;
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}

///////////////////////////////////////////////////////////////
//  Name: item
// 
//  Abstract:  returns the item requested by the pvarIndex.  
//             varIndex must be a valid integer value.or 
//             valid string title
///////////////////////////////////////////////////////////////
STDMETHODIMP
CPlayList::item(VARIANT varIndex, ITIMEPlayItem **pPlayItem)
{
    HRESULT hr;
    VARIANT vIndex;

    CHECK_RETURN_SET_NULL(pPlayItem);

    VariantInit(&vIndex);

    hr = VariantChangeTypeEx(&vIndex, &varIndex, LCID_SCRIPTING, 0, VT_I4);
    if (SUCCEEDED(hr)) //handle the case of an index.
    {
        if (vIndex.lVal >= 0 && vIndex.lVal < m_rgItems->Size())
        {
            *pPlayItem = m_rgItems->Item(vIndex.lVal);
        } 
    }
    else
    {
        long lIndex;
        
        hr = VariantChangeTypeEx(&vIndex, &varIndex, LCID_SCRIPTING, 0, VT_BSTR);
        if (FAILED(hr))
        {
            hr = S_OK;
            goto done;
        }

        lIndex = GetIndex(vIndex.bstrVal);
        if (lIndex != -1)
        {
            *pPlayItem = m_rgItems->Item(lIndex);
        }
    }
    
    if (*pPlayItem != NULL)
    {
        (*pPlayItem)->AddRef();
    } 
    
    hr = S_OK;
  done:

    VariantClear(&vIndex);
    return hr;
}

STDMETHODIMP
CPlayList::put_activeTrack(/*[in]*/ VARIANT vTrack)
{
    CComPtr <ITIMEPlayItem> pPlayItem;
    long index;
    HRESULT hr;

    // If not active then just ignore everything
    if (m_player == NULL ||
        !m_player->IsActive())
    {
        hr = S_OK;
        goto done;
    }
    
    // if this is not loaded, then delay setting of the track
    if (!m_fLoaded)
    {
        m_vNewTrack = vTrack;
        hr = S_OK;
        goto done; 
    }

    hr = item(vTrack, &pPlayItem);    
    if (FAILED(hr))
    {
        goto done;
    }

    if (pPlayItem == NULL)
    {
        hr = S_OK;
        goto done;
    }

    hr = pPlayItem->get_index(&index);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = m_player->SetActiveTrack(index);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}

STDMETHODIMP
CPlayList::get_activeTrack(/*[out, retval]*/ ITIMEPlayItem **pPlayItem)
{
    HRESULT hr;
    CPlayItem * p;

    CHECK_RETURN_SET_NULL(pPlayItem);

    if (m_player == NULL)
    {
        hr = S_OK;
        goto done;
    }
    
    p = GetActiveTrack();
    if (p == NULL)
    {
        hr = S_OK;
        goto done;
    }
    
    hr = p->QueryInterface(IID_ITIMEPlayItem,
                               (void **) pPlayItem);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}

//Advances the active Track by one
STDMETHODIMP
CPlayList::nextTrack() 
{
    HRESULT hr;
    
    CPlayItem * pPlayItem;
    long lIndex;

    pPlayItem = GetActiveTrack();
    
    if (pPlayItem == NULL)
    {
        hr = S_OK;
        goto done;
    }

    hr = pPlayItem->get_index(&lIndex);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = m_player->SetActiveTrack(lIndex + 1);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}

//moves the active track to the previous track
STDMETHODIMP
CPlayList::prevTrack() 
{
    HRESULT hr;
    
    CPlayItem * pPlayItem;
    long lIndex;

    pPlayItem = GetActiveTrack();
    
    if (pPlayItem == NULL)
    {
        hr = S_OK;
        goto done;
    }

    hr = pPlayItem->get_index(&lIndex);
    if (FAILED(hr))
    {
        goto done;
    }

    if (lIndex > 0) //if this is not the first track
    {
        lIndex--;
    }

    hr = m_player->SetActiveTrack(lIndex);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}

//returns the duration of the entire playlist if it is known or -1 if it is not.
STDMETHODIMP
CPlayList::get_dur(double *dur)
{
    HRESULT hr;
    int i;
    double totalDur = 0;

    CHECK_RETURN_NULL(dur);

    *dur = TIME_INFINITE;

    //loop through all playitems.  
    for (i = 0; i < GetLength(); i++)
    {
        double duration;
        CPlayItem * pPlayItem = GetItem(i);

        hr = pPlayItem->get_dur(&duration);
        if (FAILED(hr))
        {
            goto done;          
        }
        
        if (duration == TIME_INFINITE)
        {
            goto done;      
        }
        
        totalDur += duration;
    }
    
    *dur = totalDur;

    hr = S_OK;
  done:
    return hr;
}

// ========================================
// Internal functions
// ========================================
/*
HRESULT TIMESetLastError(HRESULT hr, LPCWSTR msg = NULL)
{
    USES_CONVERSION; //lint !e522
    HINSTANCE hInst = 0;
    TCHAR szDesc[1024];
    szDesc[0] = NULL;
    // For a valid HRESULT the id should be in the range [0x0200, 0xffff]
    if (ULONG_PTR( msg ) < 0x10000) // id
    {
        UINT nID = LOWORD((ULONG_PTR)msg);
        _ASSERTE((nID >= 0x0200 && nID <= 0xffff) || hRes != 0);
        if (LoadString(hInst, nID, szDesc, 1024) == 0)
        {
            _ASSERTE(FALSE);
            lstrcpy(szDesc, _T("Unknown Error"));
        }
        //this is a lint problem with the macro expansion.
        msg = T2OLE(szDesc); //lint !e506
        if (hr == 0)
        {
            //another lint problem with the macro expansion
            hr = MAKE_HRESULT(3, FACILITY_ITF, nID); //lint !e648
        }
    }
    CComPtr<ICreateErrorInfo> pICEI;
    if (SUCCEEDED(CreateErrorInfo(&pICEI)))
    {
        CComPtr<IErrorInfo> pErrorInfo;
        pICEI->SetGUID(GUID_NULL);
        LPOLESTR lpsz;
        ProgIDFromCLSID(CLSID_TIME, &lpsz);
        if (lpsz != NULL)
        {
            pICEI->SetSource(lpsz);
        }

        pICEI->SetHelpContext(hr);

        CoTaskMemFree(lpsz);
        pICEI->SetDescription((LPOLESTR)msg);
        if (SUCCEEDED(pICEI->QueryInterface(IID_IErrorInfo, (void**)&pErrorInfo)))
        {
            SetErrorInfo(0, pErrorInfo);
        }
    }

    return (hr == 0) ? DISP_E_EXCEPTION : hr;
} //lint !e550
*/
HRESULT NotifyPropertySinkCP(IConnectionPoint *pICP, DISPID dispid)
{
    HRESULT hr = E_FAIL;
    CComPtr<IEnumConnections> pEnum;

    CHECK_RETURN_NULL(pICP);

    // #14222, ie6
    // dilipk: there are too many copies of this code lying around.
    //                 all objects should use this helper function.
    //

    hr = pICP->EnumConnections(&pEnum);
    if (FAILED(hr))
    {
//        TIMESetLastError(hr);
        goto done;
    }

    CONNECTDATA cdata;

    hr = pEnum->Next(1, &cdata, NULL);
    while (hr == S_OK)
    {
        // check cdata for the object we need
        IPropertyNotifySink *pNotify;

        hr = cdata.pUnk->QueryInterface(IID_TO_PPV(IPropertyNotifySink, &pNotify));
        cdata.pUnk->Release();
        if (FAILED(hr))
        {
//            TIMESetLastError(hr);
            goto done;
        }

        hr = pNotify->OnChanged(dispid);
        ReleaseInterface(pNotify);
        if (FAILED(hr))
        {
//            TIMESetLastError(hr);
            goto done;
        }

        // and get the next enumeration
        hr = pEnum->Next(1, &cdata, NULL);
    }

    hr = S_OK;
done:
    return hr;
} // NotifyPropertyChanged

//+-----------------------------------------------------------------------------------
//
//  Member:     CPlayList::NotifyPropertyChanged
//
//  Synopsis:   Notifies clients that a property has changed
//
//  Arguments:  dispid      DISPID of property that has changed      
//
//  Returns:    Success     when function completes successfully
//
//------------------------------------------------------------------------------------
HRESULT
CPlayList::NotifyPropertyChanged(DISPID dispid)
{
    HRESULT hr;

    CComPtr<IConnectionPoint> pICP;

    hr = FindConnectionPoint(IID_IPropertyNotifySink,&pICP); 
    if (SUCCEEDED(hr) && pICP != NULL)
    {
        hr = NotifyPropertySinkCP(pICP, dispid);
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done:
    return hr;
} // NotifyPropertyChanged


CPlayItem *
CPlayList::GetActiveTrack()
{
    HRESULT hr;
    long l;
    CPlayItem * ppiRet = NULL;
    
    hr = m_player->GetActiveTrack(&l);
    if (FAILED(hr))
    {
        goto done;
    }

    ppiRet = GetItem(l);
  done:
    return ppiRet;
}

CPlayItem *
CPlayList::GetItem(long index)
{
    CPlayItem * ppiRet = NULL;

    if (index >= 0 && index < m_rgItems->Size())
    {
        ppiRet = m_rgItems->Item(index);
    }

    return ppiRet;
}

HRESULT
CPlayList::Add(CPlayItem *pPlayItem, long index)
{
    HRESULT hr = S_OK;

    if (pPlayItem == NULL)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    pPlayItem->AddRef();
    if (index == -1)
    {
        m_rgItems->Append(pPlayItem);
    }
    else
    {
        m_rgItems->Insert(index, pPlayItem);
    }

    // notify that length changed
    NotifyPropertyChanged(DISPID_TIMEPLAYLIST_LENGTH);

    SetIndex();
  done:
    return hr;
}


HRESULT
CPlayList::Remove(long index)
{
    HRESULT hr;
    
    if (index >= 0 && index < m_rgItems->Size())
    {
        m_rgItems->Item(index)->Deinit();
        m_rgItems->ReleaseAndDelete(index);
    }

    // notify that length changed
    NotifyPropertyChanged(DISPID_TIMEPLAYLIST_LENGTH);

    SetIndex();
    hr = S_OK;

    return hr;
}


//empties the current playlist.
void
CPlayList::Clear()
{
    if (m_rgItems)
    {
        while (m_rgItems->Size() > 0)
        {   //release and delete the first element of the list until there are no more elements
            m_rgItems->Item(0)->Deinit();
            m_rgItems->ReleaseAndDelete(0);  //release the 
        }
    }

    m_vNewTrack.Clear();
}


////////////////////////////////////////////////////////////////////////////////
// creates an empty playitem.  The info in this needs to be filled by the player.
// This also needs to be added to the playlist collection by the player.
////////////////////////////////////////////////////////////////////////////////
HRESULT
CPlayList::CreatePlayItem(CPlayItem **pPlayItem)
{   
    HRESULT hr;
    CComObject<CPlayItem> * pItem;
    
    Assert(pPlayItem != NULL);

    hr = CComObject<CPlayItem>::CreateInstance(&pItem);
    if (hr != S_OK)
    {
        goto done;
    }

    // Init the object
    pItem->Init(*this);

    *pPlayItem = static_cast<CPlayItem *>(pItem);
    pItem->AddRef();
    
    hr = S_OK;
  done:
    return hr;
}

void
CPlayList::SetIndex()
{
    long i = 0;
    long length = m_rgItems->Size();

    for (i = length-1; i >= 0; i--)
    {
        m_rgItems->Item(i)->PutIndex(i);
    }
}

long 
CPlayList::GetIndex(LPOLESTR lpstrTitle)
{
    long curIndex = -1;

    for(long i = GetLength()-1; i >= 0; i--)
    {
        CPlayItem * pItem = m_rgItems->Item(i);
        if (pItem != NULL)
        {
            LPCWSTR lpwTitle = pItem->GetTitle();
            
            if (lpwTitle != NULL &&
                StrCmpIW(lpwTitle, lpstrTitle) == 0)
            {
                curIndex = i;
                break;
            }
        }
    }

    return curIndex;
}

//*******************************************************************************
// *  CActiveElementEnum
// *******************************************************************************
CPlayListEnum::CPlayListEnum()
: m_lCurElement(0)
{
}



CPlayListEnum::~CPlayListEnum()
{
}


///////////////////////////////////////////////////////////////
//  Name: Clone
// 
//  Abstract:  Creates a new instance of this object and 
//             sets the m_lCurElement in the new object to
//             the same value as this object.
///////////////////////////////////////////////////////////////
STDMETHODIMP
CPlayListEnum::Clone(IEnumVARIANT **ppEnum)
{
    HRESULT hr;
    CComObject<CPlayListEnum> * pNewEnum;
    
    CHECK_RETURN_SET_NULL(ppEnum);

    hr = CComObject<CPlayListEnum>::CreateInstance(&pNewEnum);
    if (hr != S_OK)
    {
        goto done;
    }

    // Init the object
    pNewEnum->Init(*m_playList);

    pNewEnum->SetCurElement(m_lCurElement);

    hr = pNewEnum->QueryInterface(IID_IEnumVARIANT, (void **)ppEnum);
    if (FAILED(hr))
    {
        delete pNewEnum;
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}

///////////////////////////////////////////////////////////////
//  Name: Next
// 
//  Abstract:  
///////////////////////////////////////////////////////////////
STDMETHODIMP
CPlayListEnum::Next(unsigned long celt, VARIANT *rgVar, unsigned long *pCeltFetched)
{
    HRESULT hr = S_OK;
    unsigned long i = 0;
    long iCount = 0;
    
    CHECK_RETURN_NULL(rgVar);
    
    //initialize the list
    for (i = 0; i < celt; i++)
    {
        VariantInit(&rgVar[i]);   
    }

    for (i = 0; i < celt; i++)
    {    
        if (m_lCurElement < m_playList->GetLength())
        {
            CPlayItem * pPlayItem = m_playList->GetItem(m_lCurElement);

            Assert(pPlayItem != NULL);
            
            rgVar[i].vt = VT_DISPATCH;
            hr = pPlayItem->QueryInterface(IID_IDispatch, (void **) &(rgVar[i].pdispVal));
            if (FAILED(hr))
            {
                goto done;
            }

            m_lCurElement++;
            iCount++;
        }
        else
        {
            hr = S_FALSE;
            goto done;
        }
    }

    hr = S_OK;
  done:
    if (pCeltFetched != NULL)
    {
        *pCeltFetched = iCount;
    }

    return hr;
}

///////////////////////////////////////////////////////////////
//  Name: Reset
// 
//  Abstract:  
///////////////////////////////////////////////////////////////
STDMETHODIMP
CPlayListEnum::Reset()
{    
    m_lCurElement = 0;
    return S_OK;
}

///////////////////////////////////////////////////////////////
//  Name: Skip
// 
//  Abstract:  Skips the specified number of elements in the list.
//             This returns S_FALSE if there are not enough elements
//             in the list to skip.
///////////////////////////////////////////////////////////////
STDMETHODIMP
CPlayListEnum::Skip(unsigned long celt)
{
    HRESULT hr;
    long lLen = m_playList->GetLength();
    
    m_lCurElement += (long)celt;
    if (m_lCurElement >= lLen)
    {
        m_lCurElement = lLen;
        hr = S_FALSE;
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}


///////////////////////////////////////////////////////////////
//  Name: SetCurElement
// 
//  Abstract:  Sets the current index to the value specified
//             by celt.
///////////////////////////////////////////////////////////////
void
CPlayListEnum::SetCurElement(unsigned long celt)
{
    long lLen = m_playList->GetLength();

    m_lCurElement = (long)celt;
    if (m_lCurElement >= lLen)
    {
        m_lCurElement = lLen;
    }

    return;
}

//////////////////////////////////////////////////////
//  CPlayItem methods
//
CPlayItem::CPlayItem()
:   m_pPlayList(NULL),
    m_src(NULL),
    m_title(NULL),
    m_copyright(NULL),
    m_author(NULL),
    m_abstract(NULL),
    m_rating(NULL),
    m_lIndex(-1),
    m_dur(valueNotSet),
    m_fCanSkip(true),
    m_banner(NULL),
    m_bannerAbstract(NULL),
    m_bannerMoreInfo(NULL)
{
}

CPlayItem::~CPlayItem() 
{
    m_pPlayList = NULL;
    delete [] m_src;
    delete [] m_title;
    delete [] m_copyright;
    delete [] m_author;
    delete [] m_abstract;
    delete [] m_rating;
    delete [] m_banner;
    delete [] m_bannerAbstract;
    delete [] m_bannerMoreInfo;
}

void 
CPlayItem::PutDur(double dur)
{ 
    m_dur = dur; 

    // notify that playlist's dur has changed
    if (m_pPlayList)
    {
        m_pPlayList->NotifyPropertyChanged(DISPID_TIMEPLAYLIST_DUR);
    }

    NotifyPropertyChanged(DISPID_TIMEPLAYITEM_DUR);
}


void 
CPlayItem::PutIndex(long index) 
{ 
    m_lIndex = index; 
    NotifyPropertyChanged(DISPID_TIMEPLAYITEM_INDEX);
}


STDMETHODIMP
CPlayItem::setActive()
{
    VARIANT vIndex;
    HRESULT hr = S_OK;

    VariantInit(&vIndex);
    vIndex.vt = VT_I4;
    vIndex.lVal = m_lIndex;

    hr = m_pPlayList->put_activeTrack(vIndex);
    VariantClear(&vIndex);
    if (FAILED(hr))
    {   
        goto done;
    }   

    hr = S_OK;
  done:
    return hr;
}

STDMETHODIMP
CPlayItem::get_index(long *index)
{
    HRESULT hr;

    CHECK_RETURN_NULL(index);

    *index = m_lIndex;

    hr = S_OK;
    return hr;
}

STDMETHODIMP
CPlayItem::get_dur(double *dur)
{
    HRESULT hr;

    CHECK_RETURN_NULL(dur);

    if (valueNotSet == m_dur)
    {
        *dur = TIME_INFINITE;
    }
    else
    {
        *dur = m_dur;
    }

    hr = S_OK;
    return hr;
}

STDMETHODIMP
CPlayItem::get_src(LPOLESTR *src)
{
    HRESULT hr;

    CHECK_RETURN_SET_NULL(src);

    *src = SysAllocString(m_src?m_src:L"");

    if (*src == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}

STDMETHODIMP
CPlayItem::get_title(LPOLESTR *title)
{
    HRESULT hr;

    CHECK_RETURN_SET_NULL(title);

    *title = SysAllocString(m_title?m_title:L"");
    if (*title == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}

STDMETHODIMP
CPlayItem::get_copyright(LPOLESTR *cpyrght)
{
    HRESULT hr;

    CHECK_RETURN_SET_NULL(cpyrght);

    *cpyrght = SysAllocString(m_copyright?m_copyright:L"");
    if (*cpyrght == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}


STDMETHODIMP
CPlayItem::get_author(LPOLESTR *auth)
{
    HRESULT hr;

    CHECK_RETURN_SET_NULL(auth);

    *auth = SysAllocString(m_author?m_author:L"");
    if (*auth == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}

STDMETHODIMP
CPlayItem::get_banner(LPOLESTR *banner)
{
    HRESULT hr;

    CHECK_RETURN_SET_NULL(banner);

    *banner = SysAllocString(m_banner?m_banner:L"");
    if (*banner == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}

STDMETHODIMP
CPlayItem::get_bannerAbstract(LPOLESTR *abstract)
{
    HRESULT hr;

    CHECK_RETURN_SET_NULL(abstract);

    *abstract = SysAllocString(m_bannerAbstract?m_bannerAbstract:L"");
    if (*abstract == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}

STDMETHODIMP
CPlayItem::get_bannerMoreInfo(LPOLESTR *moreInfo)
{
    HRESULT hr;

    CHECK_RETURN_SET_NULL(moreInfo);

    *moreInfo = SysAllocString(m_bannerMoreInfo?m_bannerMoreInfo:L"");
    if (*moreInfo == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}

STDMETHODIMP
CPlayItem::get_abstract(LPOLESTR *abstract)
{
    HRESULT hr;

    CHECK_RETURN_SET_NULL(abstract);

    *abstract = SysAllocString(m_abstract?m_abstract:L"");
    if (*abstract == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}

STDMETHODIMP
CPlayItem::get_rating(LPOLESTR *rate)
{
    HRESULT hr;

    CHECK_RETURN_SET_NULL(rate);

    *rate = SysAllocString(m_rating?m_rating:L"");
    if (*rate == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}


HRESULT
CPlayItem::PutSrc(LPOLESTR src)
{
    HRESULT hr;
    
    delete m_src;
    m_src = NULL;
    
    if (src)
    {
        m_src = CopyString(src);
        if (m_src == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    
    NotifyPropertyChanged(DISPID_TIMEPLAYITEM_SRC);

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CPlayItem::PutTitle(LPOLESTR title)
{
    HRESULT hr;
    
    delete m_title;
    m_title = NULL;
    
    if (title)
    {
        m_title = CopyString(title);
        if (m_title == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    
    NotifyPropertyChanged(DISPID_TIMEPLAYITEM_TITLE);

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CPlayItem::PutCopyright(LPOLESTR copyright)
{
    HRESULT hr;
    
    delete m_copyright;
    m_copyright = NULL;
    
    if (copyright)
    {
        m_copyright = CopyString(copyright);
        if (m_copyright == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    
    NotifyPropertyChanged(DISPID_TIMEPLAYITEM_COPYRIGHT);

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CPlayItem::PutAuthor(LPOLESTR author)
{
    HRESULT hr;
    
    delete m_author;
    m_author = NULL;
    
    if (author)
    {
        m_author = CopyString(author);
        if (m_author == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    
    NotifyPropertyChanged(DISPID_TIMEPLAYITEM_AUTHOR);

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CPlayItem::PutAbstract(LPOLESTR abstract)
{
    HRESULT hr;
    
    delete m_abstract;
    m_abstract = NULL;
    
    if (abstract)
    {
        m_abstract = CopyString(abstract);
        if (m_abstract == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    
    NotifyPropertyChanged(DISPID_TIMEPLAYITEM_ABSTRACT);

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CPlayItem::PutRating(LPOLESTR rating)
{
    HRESULT hr;
    
    delete m_rating;
    m_rating = NULL;
    
    if (rating)
    {
        m_rating = CopyString(rating);
        if (m_rating == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    
    NotifyPropertyChanged(DISPID_TIMEPLAYITEM_RATING);

    hr = S_OK;
  done:
    return hr;
}

HRESULT 
CPlayItem::PutBanner(LPWSTR banner, LPWSTR abstract, LPWSTR moreInfo)
{

    HRESULT hr;
    
    delete [] m_banner;
    delete [] m_bannerAbstract;
    delete [] m_bannerMoreInfo;
    
    m_banner = NULL;
    m_bannerAbstract = NULL;
    m_bannerMoreInfo = NULL;
    
    if (banner)
    {
        m_banner = CopyString(banner);
        if (m_banner == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
        
        if (abstract)
        {
            m_bannerAbstract = CopyString(abstract);
            if (m_bannerAbstract == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }
        
        }
        
        if (moreInfo)
        {
            m_bannerMoreInfo = CopyString(moreInfo);
            if (m_bannerMoreInfo == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }
        
        }
    }
    
    NotifyPropertyChanged(DISPID_TIMEPLAYITEM_BANNER);

    hr = S_OK;
  done:
    return hr;
}


//+-----------------------------------------------------------------------------------
//
//  Member:     CPlayItem::NotifyPropertyChanged
//
//  Synopsis:   Notifies clients that a property has changed
//
//  Arguments:  dispid      DISPID of property that has changed      
//
//  Returns:    Success     when function completes successfully
//
//------------------------------------------------------------------------------------
HRESULT
CPlayItem::NotifyPropertyChanged(DISPID dispid)
{
    HRESULT hr;

    CComPtr<IConnectionPoint> pICP;

    hr = FindConnectionPoint(IID_IPropertyNotifySink,&pICP); 
    if (SUCCEEDED(hr) && pICP != NULL)
    {
        hr = NotifyPropertySinkCP(pICP, dispid);
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done:
    return hr;
} // NotifyPropertyChanged
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\proxy\wmp\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__D7E0E5BD_DC53_4CEE_979D_CA4D87426206__INCLUDED_)
#define AFX_STDAFX_H__D7E0E5BD_DC53_4CEE_979D_CA4D87426206__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
#include "w95wraps.h"

//#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

//#define _ATL_DEBUG_QI
//#define _ATL_DEBUG_INTERFACES
#define ATL_TRACE_LEVEL 5

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlwin.h>
#include <atlctl.h>

#if defined(_M_IX86)
    #define ASSERT(expr) if (!(expr)) { __asm int 3 }
    #define Assert(expr) if (!(expr)) { __asm int 3 }
#else
    #define ASSERT(expr) DebugBreak()
    #define Assert(expr) DebugBreak()
#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__D7E0E5BD_DC53_4CEE_979D_CA4D87426206__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\proxy\wmp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
//
#define IDS_PROJNAME                    100
#define IDR_WMPPROXY                    101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\rsrc\makefile.inc ===
datime.rc : $(SDK_LIB_PATH)\mstime.tlb $(TIMEIDLROOT)\mediaprivate.tlb datime.rcv
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\proxy\wmp\wmpids.h ===
//*****************************************************************************
//
// Microsoft Windows Media Player
// Copyright (C) Microsoft Corporation, 2001
//
// FileName:            wmpids.h
//
// Abstract:            Dispatch ID definitions for all public Windows Media
//                      Player Interfaces
//
//*****************************************************************************



//////////////////////////////////////////////////////////////////////
// Definitions
//////////////////////////////////////////////////////////////////////
#define DISPID_DELTA                            50


//////////////////////////////////////////////////////////////////////
// IWMPCore
//////////////////////////////////////////////////////////////////////
#define DISPID_WMPCORE_BASE                     0
#define DISPID_WMPCORE_URL                      DISPID_WMPCORE_BASE + 1
#define DISPID_WMPCORE_OPENSTATE                DISPID_WMPCORE_BASE + 2
#define DISPID_WMPCORE_CLOSE                    DISPID_WMPCORE_BASE + 3
#define DISPID_WMPCORE_CONTROLS                 DISPID_WMPCORE_BASE + 4
#define DISPID_WMPCORE_SETTINGS                 DISPID_WMPCORE_BASE + 5
#define DISPID_WMPCORE_CURRENTMEDIA             DISPID_WMPCORE_BASE + 6
#define DISPID_WMPCORE_NETWORK                  DISPID_WMPCORE_BASE + 7
#define DISPID_WMPCORE_MEDIACOLLECTION          DISPID_WMPCORE_BASE + 8
#define DISPID_WMPCORE_PLAYLISTCOLLECTION       DISPID_WMPCORE_BASE + 9
#define DISPID_WMPCORE_PLAYSTATE                DISPID_WMPCORE_BASE + 10
#define DISPID_WMPCORE_VERSIONINFO              DISPID_WMPCORE_BASE + 11
#define DISPID_WMPCORE_LAUNCHURL                DISPID_WMPCORE_BASE + 12
#define DISPID_WMPCORE_CURRENTPLAYLIST          DISPID_WMPCORE_BASE + 13
#define DISPID_WMPCORE_CDROMCOLLECTION          DISPID_WMPCORE_BASE + 14
#define DISPID_WMPCORE_CLOSEDCAPTION            DISPID_WMPCORE_BASE + 15
#define DISPID_WMPCORE_ISONLINE                 DISPID_WMPCORE_BASE + 16
#define DISPID_WMPCORE_ERROR                    DISPID_WMPCORE_BASE + 17
#define DISPID_WMPCORE_STATUS                   DISPID_WMPCORE_BASE + 18
#define DISPID_WMPCORE_LAST                     DISPID_WMPCORE_STATUS

//////////////////////////////////////////////////////////////////////
// IPlayer
//////////////////////////////////////////////////////////////////////

#define DISPID_WMPOCX_BASE                  (DISPID_WMPCORE_LAST)
#define DISPID_WMPOCX_ENABLED               (DISPID_WMPOCX_BASE + 1)
#define DISPID_WMPOCX_TRANSPARENTATSTART    (DISPID_WMPOCX_BASE + 2)
#define DISPID_WMPOCX_FULLSCREEN            (DISPID_WMPOCX_BASE + 3)
#define DISPID_WMPOCX_ENABLECONTEXTMENU     (DISPID_WMPOCX_BASE + 4)
#define DISPID_WMPOCX_UIMODE                (DISPID_WMPOCX_BASE + 5)
#define DISPID_WMPOCX_LAST                  DISPID_WMPOCX_UIMODE

#define DISPID_WMPOCX2_BASE                 (DISPID_WMPOCX_LAST)
#define DISPID_WMPOCX2_STRETCHTOFIT         (DISPID_WMPOCX2_BASE + 1)
#define DISPID_WMPOCX2_WINDOWLESSVIDEO      (DISPID_WMPOCX2_BASE + 2)



//////////////////////////////////////////////////////////////////////
// IWMPCore2
//////////////////////////////////////////////////////////////////////
#define DISPID_WMPCORE2_BASE                    (DISPID_WMPCORE_BASE + 39)
#define DISPID_WMPCORE2_DVD                     (DISPID_WMPCORE2_BASE + 1)



//////////////////////////////////////////////////////////////////////
// IWMPControl
//////////////////////////////////////////////////////////////////////
#define DISPID_WMPCONTROLS_BASE                 DISPID_WMPCORE_BASE + DISPID_DELTA
#define DISPID_WMPCONTROLS_PLAY                 DISPID_WMPCONTROLS_BASE + 1
#define DISPID_WMPCONTROLS_STOP                 DISPID_WMPCONTROLS_BASE + 2
#define DISPID_WMPCONTROLS_PAUSE                DISPID_WMPCONTROLS_BASE + 3
#define DISPID_WMPCONTROLS_FASTFORWARD          DISPID_WMPCONTROLS_BASE + 4
#define DISPID_WMPCONTROLS_FASTREVERSE          DISPID_WMPCONTROLS_BASE + 5
#define DISPID_WMPCONTROLS_CURRENTPOSITION      DISPID_WMPCONTROLS_BASE + 6
#define DISPID_WMPCONTROLS_CURRENTPOSITIONSTRING DISPID_WMPCONTROLS_BASE + 7
#define DISPID_WMPCONTROLS_NEXT                 DISPID_WMPCONTROLS_BASE + 8
#define DISPID_WMPCONTROLS_PREVIOUS             DISPID_WMPCONTROLS_BASE + 9
#define DISPID_WMPCONTROLS_CURRENTITEM          DISPID_WMPCONTROLS_BASE + 10
#define DISPID_WMPCONTROLS_CURRENTMARKER        DISPID_WMPCONTROLS_BASE + 11
#define DISPID_WMPCONTROLS_ISAVAILABLE          DISPID_WMPCONTROLS_BASE + 12
#define DISPID_WMPCONTROLS_PLAYITEM             DISPID_WMPCONTROLS_BASE + 13
#define DISPID_WMPCONTROLS2_STEP                DISPID_WMPCONTROLS_BASE + 14

//////////////////////////////////////////////////////////////////////
// IWMPSettings
//////////////////////////////////////////////////////////////////////
#define DISPID_WMPSETTINGS_BASE                 DISPID_WMPCONTROLS_BASE + DISPID_DELTA
#define DISPID_WMPSETTINGS_AUTOSTART            DISPID_WMPSETTINGS_BASE + 1
#define DISPID_WMPSETTINGS_BALANCE              DISPID_WMPSETTINGS_BASE + 2
#define DISPID_WMPSETTINGS_INVOKEURLS           DISPID_WMPSETTINGS_BASE + 3
#define DISPID_WMPSETTINGS_MUTE                 DISPID_WMPSETTINGS_BASE + 4
#define DISPID_WMPSETTINGS_PLAYCOUNT            DISPID_WMPSETTINGS_BASE + 5
#define DISPID_WMPSETTINGS_RATE                 DISPID_WMPSETTINGS_BASE + 6
#define DISPID_WMPSETTINGS_VOLUME               DISPID_WMPSETTINGS_BASE + 7
#define DISPID_WMPSETTINGS_BASEURL              DISPID_WMPSETTINGS_BASE + 8
#define DISPID_WMPSETTINGS_DEFAULTFRAME         DISPID_WMPSETTINGS_BASE + 9
#define DISPID_WMPSETTINGS_GETMODE              DISPID_WMPSETTINGS_BASE + 10
#define DISPID_WMPSETTINGS_SETMODE              DISPID_WMPSETTINGS_BASE + 11
#define DISPID_WMPSETTINGS_ENABLEERRORDIALOGS   DISPID_WMPSETTINGS_BASE + 12
#define DISPID_WMPSETTINGS_ISAVAILABLE          DISPID_WMPSETTINGS_BASE + 13

//////////////////////////////////////////////////////////////////////
// IWMPPlayList
//////////////////////////////////////////////////////////////////////
#define DISPID_WMPPLAYLIST_BASE                 DISPID_WMPSETTINGS_BASE + DISPID_DELTA + DISPID_DELTA
#define DISPID_WMPPLAYLIST_COUNT                DISPID_WMPPLAYLIST_BASE + 1
#define DISPID_WMPPLAYLIST_NAME                 DISPID_WMPPLAYLIST_BASE + 2
#define DISPID_WMPPLAYLIST_GETITEMINFO          DISPID_WMPPLAYLIST_BASE + 3
#define DISPID_WMPPLAYLIST_SETITEMINFO          DISPID_WMPPLAYLIST_BASE + 4
#define DISPID_WMPPLAYLIST_CLEAR                DISPID_WMPPLAYLIST_BASE + 5
#define DISPID_WMPPLAYLIST_INSERTITEM           DISPID_WMPPLAYLIST_BASE + 6
#define DISPID_WMPPLAYLIST_APPENDITEM           DISPID_WMPPLAYLIST_BASE + 7
#define DISPID_WMPPLAYLIST_REMOVEITEM           DISPID_WMPPLAYLIST_BASE + 8
#define DISPID_WMPPLAYLIST_MOVEITEM             DISPID_WMPPLAYLIST_BASE + 9
#define DISPID_WMPPLAYLIST_ATTRIBUTECOUNT       DISPID_WMPPLAYLIST_BASE + 10
#define DISPID_WMPPLAYLIST_ATTRIBUTENAME        DISPID_WMPPLAYLIST_BASE + 11
#define DISPID_WMPPLAYLIST_ITEM                 DISPID_WMPPLAYLIST_BASE + 12
#define DISPID_WMPPLAYLIST_ISIDENTICAL          DISPID_WMPPLAYLIST_BASE + 13

//////////////////////////////////////////////////////////////////////
// IWMPCdrom
//////////////////////////////////////////////////////////////////////

#define DISPID_WMPCDROM_BASE                    DISPID_WMPPLAYLIST_BASE + DISPID_DELTA
#define DISPID_WMPCDROM_DRIVESPECIFIER          DISPID_WMPCDROM_BASE + 1
#define DISPID_WMPCDROM_PLAYLIST                DISPID_WMPCDROM_BASE + 2
#define DISPID_WMPCDROM_EJECT                   DISPID_WMPCDROM_BASE + 3
#define DISPID_WMPCDROM_BUSY                    DISPID_WMPCDROM_BASE + 4

//////////////////////////////////////////////////////////////////////
// IWMPCdromCollection
//////////////////////////////////////////////////////////////////////

#define DISPID_WMPCDROMCOLLECTION_BASE                   DISPID_WMPCDROM_BASE + DISPID_DELTA
#define DISPID_WMPCDROMCOLLECTION_COUNT                  DISPID_WMPCDROMCOLLECTION_BASE + 1
#define DISPID_WMPCDROMCOLLECTION_ITEM                   DISPID_WMPCDROMCOLLECTION_BASE + 2
#define DISPID_WMPCDROMCOLLECTION_GETBYDRIVESPECIFIER    DISPID_WMPCDROMCOLLECTION_BASE + 3
#define DISPID_WMPCDROMCOLLECTION_STARTMONITORINGCDROMS  DISPID_WMPCDROMCOLLECTION_BASE + 4
#define DISPID_WMPCDROMCOLLECTION_STOPMONITORINGCDROMS   DISPID_WMPCDROMCOLLECTION_BASE + 5

//////////////////////////////////////////////////////////////////////
// IWMPStringCollection
//////////////////////////////////////////////////////////////////////
#define DISPID_WMPSTRINGCOLLECTION_BASE                  (DISPID_WMPCDROMCOLLECTION_BASE + DISPID_DELTA + DISPID_DELTA)
#define DISPID_WMPSTRINGCOLLECTION_COUNT                 DISPID_WMPSTRINGCOLLECTION_BASE + 1
#define DISPID_WMPSTRINGCOLLECTION_ITEM                  DISPID_WMPSTRINGCOLLECTION_BASE + 2

//////////////////////////////////////////////////////////////////////
// IWMPMediaCollection
//////////////////////////////////////////////////////////////////////

#define DISPID_WMPMEDIACOLLECTION_BASE              DISPID_WMPSTRINGCOLLECTION_BASE + DISPID_DELTA          
#define DISPID_WMPMEDIACOLLECTION_ADD               DISPID_WMPMEDIACOLLECTION_BASE + 2
#define DISPID_WMPMEDIACOLLECTION_GETALL            DISPID_WMPMEDIACOLLECTION_BASE + 3
#define DISPID_WMPMEDIACOLLECTION_GETBYNAME         DISPID_WMPMEDIACOLLECTION_BASE + 4
#define DISPID_WMPMEDIACOLLECTION_GETBYGENRE        DISPID_WMPMEDIACOLLECTION_BASE + 5
#define DISPID_WMPMEDIACOLLECTION_GETBYAUTHOR       DISPID_WMPMEDIACOLLECTION_BASE + 6
#define DISPID_WMPMEDIACOLLECTION_GETBYALBUM        DISPID_WMPMEDIACOLLECTION_BASE + 7
#define DISPID_WMPMEDIACOLLECTION_GETBYATTRIBUTE    DISPID_WMPMEDIACOLLECTION_BASE + 8
#define DISPID_WMPMEDIACOLLECTION_REMOVE            DISPID_WMPMEDIACOLLECTION_BASE + 9
#define DISPID_WMPMEDIACOLLECTION_GETATTRIBUTESTRINGCOLLECTION DISPID_WMPMEDIACOLLECTION_BASE + 11
#define DISPID_WMPMEDIACOLLECTION_NEWQUERY          DISPID_WMPMEDIACOLLECTION_BASE + 12
#define DISPID_WMPMEDIACOLLECTION_STARTMONITORING   DISPID_WMPMEDIACOLLECTION_BASE + 13
#define DISPID_WMPMEDIACOLLECTION_STOPMONITORING    DISPID_WMPMEDIACOLLECTION_BASE + 14
#define DISPID_WMPMEDIACOLLECTION_STARTCONTENTSCAN  DISPID_WMPMEDIACOLLECTION_BASE + 15
#define DISPID_WMPMEDIACOLLECTION_STOPCONTENTSCAN   DISPID_WMPMEDIACOLLECTION_BASE + 16
#define DISPID_WMPMEDIACOLLECTION_STARTSEARCH       DISPID_WMPMEDIACOLLECTION_BASE + 17
#define DISPID_WMPMEDIACOLLECTION_STOPSEARCH        DISPID_WMPMEDIACOLLECTION_BASE + 18
#define DISPID_WMPMEDIACOLLECTION_UPDATEMETADATA    DISPID_WMPMEDIACOLLECTION_BASE + 19
#define DISPID_WMPMEDIACOLLECTION_GETMEDIAATOM      DISPID_WMPMEDIACOLLECTION_BASE + 20
#define DISPID_WMPMEDIACOLLECTION_SETDELETED        DISPID_WMPMEDIACOLLECTION_BASE + 21
#define DISPID_WMPMEDIACOLLECTION_ISDELETED         DISPID_WMPMEDIACOLLECTION_BASE + 22
#define DISPID_WMPMEDIACOLLECTION_GETBYQUERYDESCRIPTION DISPID_WMPMEDIACOLLECTION_BASE + 23
#define DISPID_WMPMEDIACOLLECTION_FREEZECOLLECTIONCHANGE  DISPID_WMPMEDIACOLLECTION_BASE + 24
#define DISPID_WMPMEDIACOLLECTION_UNFREEZECOLLECTIONCHANGE DISPID_WMPMEDIACOLLECTION_BASE + 25
#define DISPID_WMPMEDIACOLLECTION_POSTCOLLECTIONCHANGE DISPID_WMPMEDIACOLLECTION_BASE + 26

//////////////////////////////////////////////////////////////////////
// IWMPPlaylistCollection
//////////////////////////////////////////////////////////////////////

#define DISPID_WMPPLAYLISTARRAY_BASE                DISPID_WMPMEDIACOLLECTION_BASE + DISPID_DELTA
#define DISPID_WMPPLAYLISTARRAY_COUNT               DISPID_WMPPLAYLISTARRAY_BASE + 1
#define DISPID_WMPPLAYLISTARRAY_ITEM                DISPID_WMPPLAYLISTARRAY_BASE + 2

//////////////////////////////////////////////////////////////////////
// IWMPPlaylistCollection
//////////////////////////////////////////////////////////////////////

#define DISPID_WMPPLAYLISTCOLLECTION_BASE           DISPID_WMPPLAYLISTARRAY_BASE + DISPID_DELTA
#define DISPID_WMPPLAYLISTCOLLECTION_NEWPLAYLIST    DISPID_WMPPLAYLISTCOLLECTION_BASE + 2
#define DISPID_WMPPLAYLISTCOLLECTION_GETALL         DISPID_WMPPLAYLISTCOLLECTION_BASE + 3
#define DISPID_WMPPLAYLISTCOLLECTION_GETBYNAME      DISPID_WMPPLAYLISTCOLLECTION_BASE + 4
#define DISPID_WMPPLAYLISTCOLLECTION_GETBYQUERYDESCRIPTION DISPID_WMPPLAYLISTCOLLECTION_BASE + 5
#define DISPID_WMPPLAYLISTCOLLECTION_REMOVE         DISPID_WMPPLAYLISTCOLLECTION_BASE + 6
#define DISPID_WMPPLAYLISTCOLLECTION_NEWQUERY       DISPID_WMPPLAYLISTCOLLECTION_BASE + 7
#define DISPID_WMPPLAYLISTCOLLECTION_STARTMONITORING DISPID_WMPPLAYLISTCOLLECTION_BASE + 8
#define DISPID_WMPPLAYLISTCOLLECTION_STOPMONITORING DISPID_WMPPLAYLISTCOLLECTION_BASE + 9
#define DISPID_WMPPLAYLISTCOLLECTION_SETDELETED     DISPID_WMPPLAYLISTCOLLECTION_BASE + 10
#define DISPID_WMPPLAYLISTCOLLECTION_ISDELETED      DISPID_WMPPLAYLISTCOLLECTION_BASE + 11
#define DISPID_WMPPLAYLISTCOLLECTION_IMPORTPLAYLIST DISPID_WMPPLAYLISTCOLLECTION_BASE + 12

//////////////////////////////////////////////////////////////////////
//  IWMPMedia
//////////////////////////////////////////////////////////////////////

#define DISPID_WMPMEDIA_BASE                            (DISPID_WMPPLAYLISTCOLLECTION_BASE + (4 * DISPID_DELTA))
#define DISPID_WMPMEDIA_SOURCEURL                       DISPID_WMPMEDIA_BASE + 1
#define DISPID_WMPMEDIA_IMAGESOURCEWIDTH                DISPID_WMPMEDIA_BASE + 2
#define DISPID_WMPMEDIA_IMAGESOURCEHEIGHT               DISPID_WMPMEDIA_BASE + 3
#define DISPID_WMPMEDIA_MARKERCOUNT                     DISPID_WMPMEDIA_BASE + 4
#define DISPID_WMPMEDIA_GETMARKERTIME                   DISPID_WMPMEDIA_BASE + 5
#define DISPID_WMPMEDIA_GETMARKERNAME                   DISPID_WMPMEDIA_BASE + 6
#define DISPID_WMPMEDIA_DURATION                        DISPID_WMPMEDIA_BASE + 7
#define DISPID_WMPMEDIA_DURATIONSTRING                  DISPID_WMPMEDIA_BASE + 8
#define DISPID_WMPMEDIA_ATTRIBUTECOUNT                  DISPID_WMPMEDIA_BASE + 9
#define DISPID_WMPMEDIA_GETATTRIBUTENAME                DISPID_WMPMEDIA_BASE + 10
#define DISPID_WMPMEDIA_GETITEMINFO                     DISPID_WMPMEDIA_BASE + 11
#define DISPID_WMPMEDIA_SETITEMINFO                     DISPID_WMPMEDIA_BASE + 12
#define DISPID_WMPMEDIA_ISIDENTICAL                     DISPID_WMPMEDIA_BASE + 13
#define DISPID_WMPMEDIA_NAME                            DISPID_WMPMEDIA_BASE + 14
#define DISPID_WMPMEDIA_GETITEMINFOBYATOM               DISPID_WMPMEDIA_BASE + 15
#define DISPID_WMPMEDIA_ISMEMBEROF                      DISPID_WMPMEDIA_BASE + 16
#define DISPID_WMPMEDIA_ISREADONLYITEM                  DISPID_WMPMEDIA_BASE + 17
#define DISPID_WMPMEDIA2_ERROR                          DISPID_WMPMEDIA_BASE + 18

//////////////////////////////////////////////////////////////////////
//  IWMPNetwork
//////////////////////////////////////////////////////////////////////

#define DISPID_WMPNETWORK_BASE                            DISPID_WMPMEDIA_BASE + DISPID_DELTA
#define DISPID_WMPNETWORK_BANDWIDTH                       DISPID_WMPNETWORK_BASE + 1
#define DISPID_WMPNETWORK_RECOVEREDPACKETS                DISPID_WMPNETWORK_BASE + 2
#define DISPID_WMPNETWORK_SOURCEPROTOCOL                  DISPID_WMPNETWORK_BASE + 3
#define DISPID_WMPNETWORK_RECEIVEDPACKETS                 DISPID_WMPNETWORK_BASE + 4
#define DISPID_WMPNETWORK_LOSTPACKETS                     DISPID_WMPNETWORK_BASE + 5
#define DISPID_WMPNETWORK_RECEPTIONQUALITY                DISPID_WMPNETWORK_BASE + 6
#define DISPID_WMPNETWORK_BUFFERINGCOUNT                  DISPID_WMPNETWORK_BASE + 7
#define DISPID_WMPNETWORK_BUFFERINGPROGRESS               DISPID_WMPNETWORK_BASE + 8
#define DISPID_WMPNETWORK_BUFFERINGTIME                   DISPID_WMPNETWORK_BASE + 9
#define DISPID_WMPNETWORK_FRAMERATE                       DISPID_WMPNETWORK_BASE + 10
#define DISPID_WMPNETWORK_MAXBITRATE                      DISPID_WMPNETWORK_BASE + 11
#define DISPID_WMPNETWORK_BITRATE                         DISPID_WMPNETWORK_BASE + 12
#define DISPID_WMPNETWORK_GETPROXYSETTINGS                DISPID_WMPNETWORK_BASE + 13
#define DISPID_WMPNETWORK_SETPROXYSETTINGS                DISPID_WMPNETWORK_BASE + 14
#define DISPID_WMPNETWORK_GETPROXYNAME                    DISPID_WMPNETWORK_BASE + 15
#define DISPID_WMPNETWORK_SETPROXYNAME                    DISPID_WMPNETWORK_BASE + 16
#define DISPID_WMPNETWORK_GETPROXYPORT                    DISPID_WMPNETWORK_BASE + 17
#define DISPID_WMPNETWORK_SETPROXYPORT                    DISPID_WMPNETWORK_BASE + 18
#define DISPID_WMPNETWORK_GETPROXYEXCEPTIONLIST           DISPID_WMPNETWORK_BASE + 19
#define DISPID_WMPNETWORK_SETPROXYEXCEPTIONLIST           DISPID_WMPNETWORK_BASE + 20
#define DISPID_WMPNETWORK_GETPROXYBYPASSFORLOCAL          DISPID_WMPNETWORK_BASE + 21
#define DISPID_WMPNETWORK_SETPROXYBYPASSFORLOCAL          DISPID_WMPNETWORK_BASE + 22
#define DISPID_WMPNETWORK_MAXBANDWIDTH                    DISPID_WMPNETWORK_BASE + 23
#define DISPID_WMPNETWORK_DOWNLOADPROGRESS                DISPID_WMPNETWORK_BASE + 24
#define DISPID_WMPNETWORK_ENCODEDFRAMERATE                DISPID_WMPNETWORK_BASE + 25
#define DISPID_WMPNETWORK_FRAMESSKIPPED                   DISPID_WMPNETWORK_BASE + 26

//////////////////////////////////////////////////////////////////////
// IWMPError
//////////////////////////////////////////////////////////////////////
#define DISPID_WMPERROR_BASE                            DISPID_WMPNETWORK_BASE + DISPID_DELTA
#define DISPID_WMPERROR_CLEARERRORQUEUE                 DISPID_WMPERROR_BASE + 1
#define DISPID_WMPERROR_ERRORCOUNT                      DISPID_WMPERROR_BASE + 2
#define DISPID_WMPERROR_ITEM                            DISPID_WMPERROR_BASE + 3
#define DISPID_WMPERROR_WEBHELP                         DISPID_WMPERROR_BASE + 4

//////////////////////////////////////////////////////////////////////
// IWMPErrorItem
//////////////////////////////////////////////////////////////////////
#define DISPID_WMPERRORITEM_BASE                    DISPID_WMPERROR_BASE + DISPID_DELTA
#define DISPID_WMPERRORITEM_ERRORCODE               DISPID_WMPERRORITEM_BASE + 1
#define DISPID_WMPERRORITEM_ERRORDESCRIPTION        DISPID_WMPERRORITEM_BASE + 2
#define DISPID_WMPERRORITEM_ERRORCONTEXT            DISPID_WMPERRORITEM_BASE + 3
#define DISPID_WMPERRORITEM_REMEDY                  DISPID_WMPERRORITEM_BASE + 4
#define DISPID_WMPERRORITEM_CUSTOMURL               DISPID_WMPERRORITEM_BASE + 5

/////////////////////////////////////////////////////////////////////////
// IWMPClosedCaption
/////////////////////////////////////////////////////////////////////////
#define DISPID_WMPCLOSEDCAPTION_BASE                   DISPID_WMPERRORITEM_BASE + DISPID_DELTA
#define DISPID_WMPCLOSEDCAPTION_SAMISTYLE              DISPID_WMPCLOSEDCAPTION_BASE + 1
#define DISPID_WMPCLOSEDCAPTION_SAMILANG               DISPID_WMPCLOSEDCAPTION_BASE + 2
#define DISPID_WMPCLOSEDCAPTION_SAMIFILENAME           DISPID_WMPCLOSEDCAPTION_BASE + 3
#define DISPID_WMPCLOSEDCAPTION_CAPTIONINGID           DISPID_WMPCLOSEDCAPTION_BASE + 4

/////////////////////////////////////////////////////////////////////////
// IWMPDVD
/////////////////////////////////////////////////////////////////////////
#define DISPID_WMPDVD_BASE                              DISPID_WMPCLOSEDCAPTION_BASE + DISPID_DELTA
#define DISPID_WMPDVD_ISAVAILABLE                       DISPID_WMPDVD_BASE + 1
#define DISPID_WMPDVD_DOMAIN                            DISPID_WMPDVD_BASE + 2
#define DISPID_WMPDVD_TOPMENU                           DISPID_WMPDVD_BASE + 3
#define DISPID_WMPDVD_TITLEMENU                         DISPID_WMPDVD_BASE + 4
#define DISPID_WMPDVD_BACK                              DISPID_WMPDVD_BASE + 5
#define DISPID_WMPDVD_RESUME                            DISPID_WMPDVD_BASE + 6

/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
#define DISPID_WMPCORE_MIN                      1
#define DISPID_WMPCORE_MAX                      DISPID_WMPDVD_RESUME


//////////////////////////////////////////////////////////////////////
// DIID_WMPCoreEvents
//////////////////////////////////////////////////////////////////////
#define WMPCOREEVENT_BASE                       5000
#define DISPID_WMPCOREEVENT_OPENSTATECHANGE     (WMPCOREEVENT_BASE + 1)
#define DISPID_WMPCOREEVENT_STATUSCHANGE        (WMPCOREEVENT_BASE + 2)


#define WMPCOREEVENT_CONTROL_BASE               5100
#define DISPID_WMPCOREEVENT_PLAYSTATECHANGE     (WMPCOREEVENT_CONTROL_BASE + 1)

#define WMPCOREEVENT_SEEK_BASE                  5200
#define DISPID_WMPCOREEVENT_ENDOFSTREAM         (WMPCOREEVENT_SEEK_BASE + 1)
#define DISPID_WMPCOREEVENT_POSITIONCHANGE      (WMPCOREEVENT_SEEK_BASE + 2)
#define DISPID_WMPCOREEVENT_MARKERHIT           (WMPCOREEVENT_SEEK_BASE + 3)
#define DISPID_WMPCOREEVENT_DURATIONUNITCHANGE  (WMPCOREEVENT_SEEK_BASE + 4)

#define WMPCOREEVENT_CONTENT_BASE               5300
#define DISPID_WMPCOREEVENT_SCRIPTCOMMAND       (WMPCOREEVENT_CONTENT_BASE + 1)

#define WMPCOREEVENT_NETWORK_BASE               5400
#define DISPID_WMPCOREEVENT_DISCONNECT          (WMPCOREEVENT_NETWORK_BASE + 1)
#define DISPID_WMPCOREEVENT_BUFFERING           (WMPCOREEVENT_NETWORK_BASE + 2)
#define DISPID_WMPCOREEVENT_NEWSTREAM           (WMPCOREEVENT_NETWORK_BASE + 3)

#define WMPCOREEVENT_ERROR_BASE                 5500
#define DISPID_WMPCOREEVENT_ERROR               (WMPCOREEVENT_ERROR_BASE + 1)

#define WMPCOREEVENT_WARNING_BASE               5600
#define DISPID_WMPCOREEVENT_WARNING             (WMPCOREEVENT_WARNING_BASE + 1)

#define WMPCOREEVENT_CDROM_BASE                 5700
#define DISPID_WMPCOREEVENT_CDROMMEDIACHANGE    (WMPCOREEVENT_CDROM_BASE + 1)

#define WMPCOREEVENT_PLAYLIST_BASE                                      5800
#define DISPID_WMPCOREEVENT_PLAYLISTCHANGE                              (WMPCOREEVENT_PLAYLIST_BASE + 1)
#define DISPID_WMPCOREEVENT_MEDIACHANGE                                 (WMPCOREEVENT_PLAYLIST_BASE + 2)
#define DISPID_WMPCOREEVENT_CURRENTMEDIAITEMAVAILABLE                   (WMPCOREEVENT_PLAYLIST_BASE + 3)
#define DISPID_WMPCOREEVENT_CURRENTPLAYLISTCHANGE                       (WMPCOREEVENT_PLAYLIST_BASE + 4)
#define DISPID_WMPCOREEVENT_CURRENTPLAYLISTITEMAVAILABLE                (WMPCOREEVENT_PLAYLIST_BASE + 5)
#define DISPID_WMPCOREEVENT_CURRENTITEMCHANGE                           (WMPCOREEVENT_PLAYLIST_BASE + 6)
#define DISPID_WMPCOREEVENT_MEDIACOLLECTIONCHANGE                       (WMPCOREEVENT_PLAYLIST_BASE + 7)
#define DISPID_WMPCOREEVENT_MEDIACOLLECTIONATTRIBUTESTRINGADDED         (WMPCOREEVENT_PLAYLIST_BASE + 8)
#define DISPID_WMPCOREEVENT_MEDIACOLLECTIONATTRIBUTESTRINGREMOVED       (WMPCOREEVENT_PLAYLIST_BASE + 9)
#define DISPID_WMPCOREEVENT_PLAYLISTCOLLECTIONCHANGE                    (WMPCOREEVENT_PLAYLIST_BASE + 10)
#define DISPID_WMPCOREEVENT_PLAYLISTCOLLECTIONPLAYLISTADDED             (WMPCOREEVENT_PLAYLIST_BASE + 11)
#define DISPID_WMPCOREEVENT_PLAYLISTCOLLECTIONPLAYLISTREMOVED           (WMPCOREEVENT_PLAYLIST_BASE + 12)
#define DISPID_WMPCOREEVENT_MEDIACOLLECTIONCONTENTSCANADDEDITEM         (WMPCOREEVENT_PLAYLIST_BASE + 13)
#define DISPID_WMPCOREEVENT_MEDIACOLLECTIONCONTENTSCANPROGRESS          (WMPCOREEVENT_PLAYLIST_BASE + 14)
#define DISPID_WMPCOREEVENT_MEDIACOLLECTIONSEARCHFOUNDITEM              (WMPCOREEVENT_PLAYLIST_BASE + 15)
#define DISPID_WMPCOREEVENT_MEDIACOLLECTIONSEARCHPROGRESS               (WMPCOREEVENT_PLAYLIST_BASE + 16)
#define DISPID_WMPCOREEVENT_MEDIACOLLECTIONSEARCHCOMPLETE               (WMPCOREEVENT_PLAYLIST_BASE + 17)
#define DISPID_WMPCOREEVENT_PLAYLISTCOLLECTIONPLAYLISTSETASDELETED      (WMPCOREEVENT_PLAYLIST_BASE + 18)
#define DISPID_WMPCOREEVENT_MODECHANGE                                  (WMPCOREEVENT_PLAYLIST_BASE + 19)
#define DISPID_WMPCOREEVENT_MEDIACOLLECTIONATTRIBUTESTRINGCHANGED       (WMPCOREEVENT_PLAYLIST_BASE + 20)
#define DISPID_WMPCOREEVENT_MEDIAERROR                                  (WMPCOREEVENT_PLAYLIST_BASE + 21)
#define DISPID_WMPCOREEVENT_DOMAINCHANGE                                (WMPCOREEVENT_PLAYLIST_BASE + 22)
#define DISPID_WMPCOREEVENT_OPENPLAYLISTSWITCH                          (WMPCOREEVENT_PLAYLIST_BASE + 23)


//*****************************************************************************
//
//  End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\proxy\wmp\wmpproxyplayer.h ===
/*******************************************************************************
 *
 * Copyright (c) 2001 Microsoft Corporation
 *
 * File: WMPProxyPlayer.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/
#pragma once

#include "w95wraps.h"
#include "resource.h"       // main symbols
#include "..\ProxyBaseImpl.h"
#include "array.h"
#include "playlist.h"
#include "wmp_i.c"
#include "wmp.h"

class CPlayList;

/////////////////////////////////////////////////////////////////////////////
// CWMPProxy
class CWMPProxy : 
    public CProxyBaseImpl<&CLSID_WMPProxy, &LIBID_WMPProxyLib>,
    public IConnectionPointContainerImpl<CWMPProxy>,
    public IPropertyNotifySinkCP<CWMPProxy>,
    public IPropertyNotifySink,
    public ITIMEMediaPlayerControl,
    public ITIMEMediaPlayerAudio,
    public ITIMEMediaPlayerNetwork
{
private:
    typedef CProxyBaseImpl<&CLSID_WMPProxy, &LIBID_WMPProxyLib> SUPER;

    CComPtr<ITIMEMediaPlayerSite> m_spTIMEMediaPlayerSite;
    CComPtr<ITIMEElement> m_spTIMEElement;
    CComPtr<ITIMEState> m_spTIMEState;
    DWORD m_dwPropCookie;
    DWORD m_dwMediaEventsCookie;
    DAComPtr<IConnectionPoint> m_pcpMediaEvents;

protected:
    CComPtr<IDispatch> m_pdispWmp;

    CComPtr<IOleClientSite> m_spOleClientSite;
    CComPtr<IOleInPlaceSite> m_spOleInPlaceSite;
    CComPtr<IOleInPlaceSiteEx> m_spOleInPlaceSiteEx;
    CComPtr<IOleInPlaceSiteWindowless> m_spOleInPlaceSiteWindowless;

    STDMETHOD(CreateContainedControl)(void);
    STDMETHOD(CallMethod)(IDispatch* pDispatch, OLECHAR* pwzMethod, VARIANT* pvarResult, VARIANT* pvarArgument1);
    STDMETHOD(PutProp)(IDispatch* pDispatch, OLECHAR* pwzProp, VARIANT* vararg);
    STDMETHOD(GetProp)(IDispatch* pDispatch, OLECHAR* pwzProp, VARIANT* pvarResult, DISPPARAMS* pParams);
private:

    bool m_fNewPlaylist;
    bool m_fPlaylist;
    bool m_fPaused;
    bool m_fRunning;
    bool m_fSrcChanged;
    bool m_fResumedPlay;
    bool m_fAudio;
    bool m_fBuffered;
    bool m_fCurrLevelSet;
    bool m_fEmbeddedPlaylist;
    double m_dblPos;
    double m_dblClipDur;
    long m_lDoneTopLevel;
    long m_lTotalNumInTopLevel;
    CComVariant m_varPlaylist;
    DAComPtr<CPlayList> m_playList;

    HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP);
    HRESULT NotifyPropertyChanged(DISPID dispid);
    HRESULT InitPropSink();
    HRESULT CreatePlayList();
    HRESULT FillPlayList(CPlayList *pPlayList);
    HRESULT ProcessEvent(DISPID dispid, long lCount, VARIANT varParams[]);
    HRESULT OnOpenStateChange(long lCount, VARIANT varParams[]);
    HRESULT OnPlayStateChange(long lCount, VARIANT varParams[]);
    HRESULT GetTrackCount(long* lCount);

    void DeinitPropSink();

public:
    CWMPProxy();
    virtual ~CWMPProxy();

    HRESULT SetActiveTrack(long index);
    HRESULT GetActiveTrack(long* index);
    bool IsActive();

    STDMETHOD(Init)(ITIMEMediaPlayerSite *pSite);
    STDMETHOD(Detach)(void);

    STDMETHOD(put_clipBegin)(VARIANT varClipBegin);
    STDMETHOD(put_clipEnd)(VARIANT varClipEnd);
    STDMETHOD(begin)(void);
    STDMETHOD(end)(void);
    STDMETHOD(resume)(void);
    STDMETHOD(pause)(void);
    STDMETHOD(reset)(void);
    STDMETHOD(repeat)(void);
    STDMETHOD(seek)(double dblSeekTime);

    STDMETHOD(get_currTime)(double* pdblCurrentTime);
    STDMETHOD(get_clipDur)(double* pdblClipDur);
    STDMETHOD(get_mediaDur)(double* pdblMediaDur);
    STDMETHOD(get_state)(TimeState * ts);
    STDMETHOD(get_playList)(ITIMEPlayList ** plist);

    STDMETHOD(get_abstract)(BSTR* pbstrAbs);
    STDMETHOD(get_author)(BSTR* pbstrAut);
    STDMETHOD(get_copyright)(BSTR* pbstrCop);
    STDMETHOD(get_rating)(BSTR* pbstrRat);
    STDMETHOD(get_title)(BSTR* pbstrTit);

    STDMETHOD(get_canPause(VARIANT_BOOL * b));
    STDMETHOD(get_canSeek(VARIANT_BOOL * b));
    STDMETHOD(get_hasAudio(VARIANT_BOOL * b));
    STDMETHOD(get_hasVisual(VARIANT_BOOL * b));
    STDMETHOD(get_mediaHeight(long * width));
    STDMETHOD(get_mediaWidth(long * height));

    STDMETHOD(put_src)(BSTR   bstrURL);
    STDMETHOD(put_CurrentTime)(double   dblCurrentTime);
    STDMETHOD(get_CurrentTime)(double* pdblCurrentTime);

    STDMETHOD(put_volume)(float f);
    STDMETHOD(put_mute)(VARIANT_BOOL m);

    STDMETHOD(get_hasDownloadProgress)(VARIANT_BOOL * b);
    STDMETHOD(get_downloadProgress)(long * l);
    STDMETHOD(get_isBuffered)(VARIANT_BOOL * b);
    STDMETHOD(get_bufferingProgress)(long * l);

    STDMETHOD(get_customObject)(IDispatch ** disp);
    STDMETHOD(getControl)(IUnknown ** control);

    //
    // IPropertyNotifySink methods
    //
    STDMETHOD(OnChanged)(DISPID dispID);
    STDMETHOD(OnRequestEdit)(DISPID dispID);

    STDMETHOD(SetClientSite)(IOleClientSite *pClientSite);

    STDMETHOD(Invoke)(DISPID disIDMember,
                        REFIID riid,
                        LCID lcid,
                        unsigned short wFlags,
                        DISPPARAMS *pDispParams,
                        VARIANT *pVarResult,
                        EXCEPINFO *pExcepInfo,
                        UINT *puArgErr);

DECLARE_REGISTRY_RESOURCEID(IDR_WMPPROXY)
DECLARE_NOT_AGGREGATABLE(CWMPProxy)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CWMPProxy)
    COM_INTERFACE_ENTRY(ITIMEMediaPlayer)
    COM_INTERFACE_ENTRY(ITIMEMediaPlayerAudio)
    COM_INTERFACE_ENTRY(ITIMEMediaPlayerNetwork)
    COM_INTERFACE_ENTRY(ITIMEMediaPlayerControl)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    COM_INTERFACE_ENTRY(IPropertyNotifySink)
    COM_INTERFACE_ENTRY_IID(DIID__WMPOCXEvents, IDispatch)
    COM_INTERFACE_ENTRY_CHAIN(SUPER)
END_COM_MAP()


BEGIN_CONNECTION_POINT_MAP(CWMPProxy)
    CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
END_CONNECTION_POINT_MAP();

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\proxy\wmp\wmpproxyplayer.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 2001 Microsoft Corporation
 *
 * File: WMPProxyPlayer.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/
#include "stdafx.h"
#include "BrowseWM.h"
#include "WMPProxyPlayer.h"
#include "wmpids.h"

const DWORD     NUM_FRAMES_PER_SEC  = 10;
const double    NUM_SEC_PER_FRAME   = 0.1;

// WMP 7/8 GUID
const GUID GUID_WMP = {0x6BF52A52,0x394A,0x11d3,{0xB1,0x53,0x00,0xC0,0x4F,0x79,0xFA,0xA6}};

/////////////////////////////////////////////////////////////////////////////
// CWMPProxy

CWMPProxy::CWMPProxy() :
    m_pdispWmp(0),
    m_fNewPlaylist(false),
    m_fPlaylist(false),
    m_fPaused(false),
    m_fRunning(false),
    m_fSrcChanged(false),
    m_fResumedPlay(false),
    m_fAudio(true),
    m_fBuffered(false),
    m_dblPos(0.0),
    m_dblClipDur(TIME_INFINITE),
    m_dwMediaEventsCookie(0),
    m_fEmbeddedPlaylist(false),
    m_fCurrLevelSet(false),
    m_lTotalNumInTopLevel(0),
    m_lDoneTopLevel(0)
{
}

CWMPProxy::~CWMPProxy()
{
    m_pdispWmp = 0;
}

//
// Put Property
//
HRESULT STDMETHODCALLTYPE CWMPProxy::PutProp(IDispatch* pDispatch, OLECHAR* pwzProp, VARIANT* vararg)
{
    DISPID      dispid      = NULL;
    HRESULT     hr          = S_OK;
    DISPID      dispidPut   = DISPID_PROPERTYPUT;
    DISPPARAMS  params      = {vararg, &dispidPut, 1, 1};

    if (!pDispatch)
    {
        hr = E_POINTER;
        goto done;
    }

    hr = pDispatch->GetIDsOfNames(IID_NULL, &pwzProp, 1, LOCALE_SYSTEM_DEFAULT, &dispid);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pDispatch->Invoke(dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT, DISPATCH_PROPERTYPUT,
            &params, NULL, NULL, NULL);
    if (FAILED(hr))
    {
        goto done;
    }

done:
    return hr;
}

//
// Get Property
//
HRESULT STDMETHODCALLTYPE CWMPProxy::GetProp(IDispatch* pDispatch, OLECHAR* pwzProp, VARIANT* pvarResult,
                                             DISPPARAMS* pParams = NULL)
{
    DISPID      dispid      = NULL;
    HRESULT     hr          = S_OK;
    DISPPARAMS  params      = {NULL, NULL, 0, 0};

    if (!pParams)
    {
        pParams = &params;
    }

    if (!pDispatch)
    {
        hr = E_POINTER;
        goto done;
    }

    hr = pDispatch->GetIDsOfNames(IID_NULL, &pwzProp, 1, LOCALE_SYSTEM_DEFAULT, &dispid);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pDispatch->Invoke(dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT, DISPATCH_PROPERTYGET,
            pParams, pvarResult, NULL, NULL);
    if (FAILED(hr))
    {
        goto done;
    }

done:
    return hr;
}

//
// Call Method
//
HRESULT STDMETHODCALLTYPE CWMPProxy::CallMethod(IDispatch* pDispatch, OLECHAR* pwzMethod, 
                                                VARIANT* pvarResult = NULL, VARIANT* pvarArgument1 = NULL)
{
    DISPID      dispid      = NULL;
    HRESULT     hr          = S_OK;
    DISPPARAMS  params      = {pvarArgument1, NULL, 0, 0};

    if (NULL != pvarArgument1)
    {
        params.cArgs = 1;
    }

    if (!pDispatch)
    {
        hr = E_POINTER;
        goto done;
    }

    hr = pDispatch->GetIDsOfNames(IID_NULL, &pwzMethod, 1, LOCALE_SYSTEM_DEFAULT, &dispid);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pDispatch->Invoke(dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT, DISPATCH_METHOD,
            &params, pvarResult, NULL, NULL);
    if (FAILED(hr))
    {
        goto done;
    }

done:
    return hr;
}

//
// CWMPProxy::CreateContainedControl
// Creates the WMP Control
//
HRESULT STDMETHODCALLTYPE CWMPProxy::CreateContainedControl(void)
{
    ATLTRACE(_T("CreateContainedControl\n"));   //lint !e506

    HRESULT hr = S_OK;
    VARIANT vararg = {0};

    if (!m_pdispWmp)
    {
        hr = CreateControl(GUID_WMP, IID_IDispatch,
                reinterpret_cast<void**>(&m_pdispWmp));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    // Need to change the UIMode to None, so that WMP does not show its own controls
    vararg.vt       = VT_BSTR;
    vararg.bstrVal  = L"none";

    hr = PutProp(m_pdispWmp, L"uiMode", &vararg);
    if (FAILED(hr))
    {
        goto done;
    }

done:
    return hr;
}

// If the client site is changed then an init call must be made.
STDMETHODIMP CWMPProxy::SetClientSite(IOleClientSite *pClientSite)
{
    HRESULT hr = S_OK;

    if(!pClientSite)
    {
        m_spOleClientSite.Release();
        m_spOleInPlaceSite.Release();
        m_spOleInPlaceSiteEx.Release();
        m_spOleInPlaceSiteWindowless.Release();
        m_spTIMEMediaPlayerSite.Release();
        m_spTIMEElement.Release();
        m_spTIMEState.Release();

        DeinitPropSink();
        goto done;
    }

    m_spOleClientSite = pClientSite;
    hr = m_spOleClientSite->QueryInterface(IID_IOleInPlaceSite, (void **)&m_spOleInPlaceSite);
    if(FAILED(hr))
    {
        goto punt;
    }
    hr = m_spOleClientSite->QueryInterface(IID_IOleInPlaceSiteEx, (void **)&m_spOleInPlaceSiteEx);
    if(FAILED(hr))
    {
        goto punt;
    }
    hr = m_spOleClientSite->QueryInterface(IID_IOleInPlaceSiteWindowless, (void **)&m_spOleInPlaceSiteWindowless);
    if(FAILED(hr))
    {
        goto punt;
    }

punt:
    hr = CProxyBaseImpl<&CLSID_WMPProxy, &LIBID_WMPProxyLib>::SetClientSite(pClientSite);
    
done:
    return hr;
}

//
// CWMPProxy::begin
// Starts playing the media item.
//
HRESULT STDMETHODCALLTYPE CWMPProxy::begin(void)
{
    ATLTRACE(_T("begin\n"));    //lint !e506
    HRESULT hr = S_OK;
    VARIANT control = {0};
    VARIANT mediaitem = {0};
    VARIANT position = {0};

    hr = SUPER::begin();
    if (FAILED(hr))
    {
        goto done;
    }

    // get the control object
    hr = GetProp(m_pdispWmp, L"controls", &control);
    if (FAILED(hr))
    {
        goto done;
    }

    // we need to seek to 0 to start playing.
    // there was an issue with play-pause-play,
    // so this is our hack around it.
    position.vt = VT_R8;
    position.dblVal = 0.0;

    hr = PutProp(control.pdispVal, L"currentPosition", &position);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetProp(control.pdispVal, L"currentItem", &mediaitem);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = CallMethod(control.pdispVal, L"play");
    if (FAILED(hr))
    {
        goto done;
    }

    m_fRunning = true;

done:
    VariantClear(&control);
    VariantClear(&mediaitem);

    return hr;
}

//
// CWMPProxy::end
// Stops playing the media item
//
HRESULT STDMETHODCALLTYPE CWMPProxy::end(void)
{
    ATLTRACE(_T("end\n"));    //lint !e506
    HRESULT hr = S_OK;
    VARIANT control = {0};
    long lIndex;

    hr = SUPER::end();
    if (FAILED(hr))
    {
        goto done;
    }

    // need to reset the playlist back to track 0
    GetActiveTrack(&lIndex);
    if (lIndex != 0)
    {
        SetActiveTrack(0);
    }

    hr = GetProp(m_pdispWmp, L"controls", &control);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = CallMethod(control.pdispVal, L"stop");
    if (FAILED(hr))
    {
        goto done;
    }

    m_fRunning = false;

done:
    VariantClear(&control);

    return hr;
}

//
// CWMPProxy::resume
// Resumes playback of a paused media item
//
HRESULT STDMETHODCALLTYPE CWMPProxy::resume(void)
{
    ATLTRACE(_T("resume\n"));    //lint !e506
    HRESULT hr = S_OK;
    VARIANT mediaitem = {0};
    VARIANT control = {0};
    VARIANT position = {0};

    hr = SUPER::resume();
    if (FAILED(hr))
    {
        goto done;
    }

    // if its not paused, exit
    if (m_fPaused)
    {
        m_fPaused = false;

        // everytime to resume play, we get a PlayStateChange event
        // we use that event to fire up some other events within mstime.
        // in order to avoid screwing up our state, we need this
        // to ignore the PlayStateChangeEvent
        m_fResumedPlay = true;

        hr = GetProp(m_pdispWmp, L"controls", &control);
        if (FAILED(hr))
        {
            goto done;    
        }

        hr = CallMethod(control.pdispVal, L"play");
        if (FAILED(hr))
        {
            goto done;
        }

        // seek back to the location we were previously paused at
        // and resume playback from there.
        position.vt = VT_R8;
        position.dblVal = m_dblPos;

        hr = PutProp(control.pdispVal, L"currentPosition", &position);
        if (FAILED(hr))
        {
            goto done;
        }

        hr = GetProp(control.pdispVal, L"currentItem", &mediaitem);
        if (FAILED(hr))
        {
            goto done;
        }
    }

done:
    VariantClear(&control);
    VariantClear(&mediaitem);

    return hr;
}

//
// CWMPProxy::pause
// Pauses playback of a media item
//
HRESULT STDMETHODCALLTYPE CWMPProxy::pause(void)
{
    ATLTRACE(_T("pause\n"));    //lint !e506
    HRESULT hr = S_OK;
    VARIANT control = {0};
    VARIANT position = {0};

    hr = SUPER::pause();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetProp(m_pdispWmp, L"controls", &control);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = CallMethod(control.pdispVal, L"pause");
    if (FAILED(hr))
    {
        goto done;
    }

    // cache the current location of the item
    // resumes at current location
    // some flakiness here...on a resume, we can
    // see the item go back maybe a millisecond or so.
    hr = GetProp(control.pdispVal, L"currentPosition", &position);
    if (FAILED(hr))
    {
        goto done;
    }

    // no need to set paused to true it we are at 0.0
    m_fPaused = false;
    if (position.dblVal > 0)
    {
        m_fPaused = true;
        m_dblPos = position.dblVal;
    }

done:
    VariantClear(&control);

    return hr;
}

//
// CWMPProxy::put_src
// Tells WMP what source to use for the media item
//
HRESULT STDMETHODCALLTYPE CWMPProxy::put_src(BSTR bstrURL)
{
    ATLTRACE(_T("put_src\n"));  //lint !e506
    HRESULT hr = S_OK;
    VARIANT vararg = {0};
    VARIANT control = {0};
    VARIANT settings = {0};
    VARIANT isPlaylist = {0};

    DISPID      dispidGet   = DISPID_UNKNOWN;
    DISPPARAMS  params      = {&vararg, &dispidGet, 1, 0};

    hr = SUPER::put_src(bstrURL);
    if (FAILED(hr))
    {
        goto done;
    }

    // need to set autostart to false.
    // we should ONLY play when we get a begin
    hr = GetProp(m_pdispWmp, L"settings", &settings);
    if (FAILED(hr))
    {
        goto done;
    }

    vararg.vt = VT_BSTR;
    vararg.bstrVal = L"false";
    hr = PutProp(settings.pdispVal, L"autoStart", &vararg);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = PutProp(settings.pdispVal, L"enableErrorDialogs", &vararg);
    if (FAILED(hr))
    {
        goto done;
    }

    vararg.vt = VT_BSTR;
    vararg.bstrVal = L"true";
    hr = PutProp(m_pdispWmp, L"stretchToFit", &vararg);
    // This property is not in WMP7 yet, so it will fail
    // so lets ignore the HRESULT we get back.
    /*
    if (FAILED(hr))
    {
        goto done;
    }
    */

    vararg.vt       = VT_BSTR;
    vararg.bstrVal  = bstrURL;

    hr = PutProp(m_pdispWmp, L"URL", &vararg);
    if (FAILED(hr))
    {
        goto done;
    }

    // if we have a playlist from out previous item,
    // release it.
    if (m_playList)
    {
        m_playList->Deinit();
        m_playList.Release();
    }

    // tells us that our source has just changed.
    // this way, we don't fire a mediacomplete
    // event more than once for any item.
    m_fSrcChanged = true;

    m_fEmbeddedPlaylist = false;
    m_fCurrLevelSet = false;
    m_lTotalNumInTopLevel = 0;
    m_lDoneTopLevel = 0;

done:
    VariantClear(&control);
    VariantClear(&settings);

    return hr;
}

//
// CWMPProxy::put_CurrentTime
// Not implemented
//
HRESULT STDMETHODCALLTYPE CWMPProxy::put_CurrentTime(double dblCurrentTime)
{
    return E_NOTIMPL;
}

//
// CWMPProxy::get_CurrentTime
// Not implemented
//
HRESULT STDMETHODCALLTYPE CWMPProxy::get_CurrentTime(double* pdblCurrentTime)
{
    return E_NOTIMPL;
}

//
// CWMPProxy::Init
// Sets up everything
//
STDMETHODIMP CWMPProxy::Init(ITIMEMediaPlayerSite *pSite)
{
    HRESULT hr = S_OK;
    DAComPtr<IConnectionPointContainer> pcpc;

    m_spTIMEMediaPlayerSite = pSite;
    if(m_spTIMEMediaPlayerSite == NULL)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = m_spTIMEMediaPlayerSite->get_timeElement(&m_spTIMEElement);
    if(FAILED(hr))
    {
        goto done;
    }

    hr = m_spTIMEMediaPlayerSite->get_timeState(&m_spTIMEState);
    if(FAILED(hr))
    {
        goto done;
    }

    hr = InitPropSink();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = CreateContainedControl();
    if (FAILED(hr))
    {
        goto done;
    }

done:
    return S_OK;
}

//
// CWMPProxy::Detach
// Cleans up anything we are holding on to
//
STDMETHODIMP CWMPProxy::Detach(void)
{
    // need to unadvise from WMP
    if ((m_pcpMediaEvents) && (m_dwMediaEventsCookie != 0))
    {
        m_pcpMediaEvents->Unadvise(m_dwMediaEventsCookie);
        m_pcpMediaEvents.Release();
        m_dwMediaEventsCookie = 0;
    }

    // Clean up playlist
    if (m_playList)
    {
        m_playList->Deinit();
        m_playList.Release();
    }

    // we should close the WMP player
    // who knows what they might hold on to if we don't call this
    CallMethod(m_pdispWmp, L"close");
    m_pdispWmp = NULL;

    // call this before releasing everything else.
    DeinitPropSink();

    m_spOleClientSite.Release();
    m_spOleInPlaceSite.Release();
    m_spOleInPlaceSiteEx.Release();
    m_spOleInPlaceSiteWindowless.Release();
    m_spTIMEMediaPlayerSite.Release();
    
    m_spTIMEElement.Release();
    m_spTIMEState.Release();

    return S_OK;
}

//
// CWMPProxy::reset
// 
//
STDMETHODIMP CWMPProxy::reset(void) 
{
    HRESULT hr = S_OK;
    DAComPtr<IConnectionPointContainer> pcpc;

    VARIANT_BOOL bNeedActive;
    VARIANT_BOOL bNeedPause;
    double dblSegTime = 0.0;

    // apparently we have to wait until the script engine is hooked up
    // before we can hook ourseleves up to the events.
    // we should be ok here.
    if(m_dwMediaEventsCookie == 0)
    {
        hr = m_pdispWmp->QueryInterface(IID_TO_PPV(IConnectionPointContainer, &pcpc));
        if (FAILED(hr))
        {
            goto done;
        }

        hr = pcpc->FindConnectionPoint(DIID__WMPOCXEvents, &m_pcpMediaEvents);
        if (FAILED(hr))
        {
            hr = S_OK;
            goto done;
        }

        hr = m_pcpMediaEvents->Advise(GetUnknown(), &m_dwMediaEventsCookie);
        if (FAILED(hr))
        {
            hr = S_OK;
            m_pcpMediaEvents.Release();
            m_dwMediaEventsCookie = 0;
            goto done;
        }
    }

    if(m_spTIMEState == NULL || m_spTIMEElement == NULL)
    {
        goto done;
    }
    hr = m_spTIMEState->get_isActive(&bNeedActive);
    if(FAILED(hr))
    {
        goto done;
    }
    hr = m_spTIMEState->get_isPaused(&bNeedPause);
    if(FAILED(hr))
    {
        goto done;
    }
    hr = m_spTIMEState->get_segmentTime(&dblSegTime);
    if(FAILED(hr))
    {
        goto done;
    }

    if (!bNeedActive) // see if we need to stop the media.
    {
        if(m_fRunning)
        {
            end();
        }
        goto done;
    }

    if (!m_fRunning)
    {
        begin(); // add a seek after this
        seek(dblSegTime);
    }
    else
    {
        //we need to be active so we also seek the media to it's correct position
        seek(dblSegTime);
        m_dblPos = dblSegTime;
    }

    //Now see if we need to change the pause state.

    if (bNeedPause && !m_fPaused)
    {
        pause();
    }
    else if (!bNeedPause && m_fPaused)
    {
        resume();
    }

done:
    return hr;
}

//
// CWMPProxy::repeat
// Repeats the media item
//
STDMETHODIMP CWMPProxy::repeat(void)
{
    return begin();
}

//
// CWMPProxy::seek
// Seeks to a location within a media item
//
STDMETHODIMP CWMPProxy::seek(double dblSeekTime)
{
    HRESULT hr = S_OK;
    VARIANT mediaitem = {0};
    VARIANT control = {0};
    VARIANT position = {0};

    hr = GetProp(m_pdispWmp, L"controls", &control);
    if (FAILED(hr))
    {
        goto done;    
    }

    // hmmm, I wonder if WMP will crap out if this value is something stupid
    // do we need bounds checking?
    position.vt = VT_R8;
    position.dblVal = dblSeekTime;

    hr = PutProp(control.pdispVal, L"currentPosition", &position);
    if (FAILED(hr))
    {
        goto done;
    }

done:
    VariantClear(&control);
    VariantClear(&mediaitem);

    return hr;
}

//
// CWMPProxy::put_clipBegin
// Not implemented
//
STDMETHODIMP CWMPProxy::put_clipBegin(VARIANT varClipBegin)
{
    return E_NOTIMPL;
}

//
// CWMPProxy::put_clipEnd
// Not implemented
//
STDMETHODIMP CWMPProxy::put_clipEnd(VARIANT varClipEnd)
{
    return E_NOTIMPL;
}

//
// CWMPProxy::put_volume
// Sets volume for current media item
//
STDMETHODIMP CWMPProxy::put_volume(float flVolume)
{
    HRESULT hr = S_OK;
    VARIANT settings = {0};
    VARIANTARG vararg = {0};

    hr = GetProp(m_pdispWmp, L"settings", &settings);
    if (FAILED(hr))
    {
        goto done;
    }

    vararg.vt = VT_I4;
    vararg.lVal = (long) (flVolume*100);
    
    hr = PutProp(settings.pdispVal, L"volume", &vararg);
    if (FAILED(hr))
    {
        goto done;
    }

done:
    VariantClear(&settings);

    return hr;
}
 
//
// CWMPProxy::put_mute
// Sets Mute for audio
//

STDMETHODIMP CWMPProxy::put_mute(VARIANT_BOOL bMute)
{
    HRESULT hr = S_OK;
    VARIANT settings = {0};
    VARIANTARG vararg = {0};

    hr = GetProp(m_pdispWmp, L"settings", &settings);
    if (FAILED(hr))
    {
        goto done;
    }

    vararg.vt = VT_BOOL;
    vararg.boolVal = bMute;
    
    hr = PutProp(settings.pdispVal, L"mute", &vararg);
    if (FAILED(hr))
    {
        goto done;
    }

done:
    VariantClear(&settings);

    return hr;
}

//
// CWMPProxy::get_hasDownloadProgress
// returns if there is any download progress or not
//
STDMETHODIMP CWMPProxy::get_hasDownloadProgress(VARIANT_BOOL * bProgress)
{
    HRESULT hr = S_OK;
    VARIANT network = {0};
    VARIANT progress = {0};

    *bProgress = VARIANT_FALSE;

    hr = GetProp(m_pdispWmp, L"network", &network);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetProp(network.pdispVal, L"downloadProgress", &progress);
    if (FAILED(hr))
    {
        goto done;
    }
    

    if (progress.lVal > 0 && progress.lVal < 100)
    {
        *bProgress = VARIANT_TRUE;
    }

done:
    VariantClear(&network);

    return hr;
}

//
// CWMPProxy::get_DownloadProgress
// returns download progress (percent)
//
STDMETHODIMP CWMPProxy::get_downloadProgress(long * lProgress)
{
    HRESULT hr = S_OK;
    VARIANT network = {0};
    VARIANT progress = {0};

    *lProgress = 0;

    hr = GetProp(m_pdispWmp, L"network", &network);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetProp(network.pdispVal, L"downloadProgress", &progress);
    if (FAILED(hr))
    {
        goto done;
    }

    *lProgress = progress.lVal;

done:
    VariantClear(&network);

    return hr;
}

//
// CWMPProxy::get_isBuffered
// returns if object if buffered
//
STDMETHODIMP CWMPProxy::get_isBuffered(VARIANT_BOOL * bBuffered)
{
    *bBuffered = (m_fBuffered ? VARIANT_TRUE : VARIANT_FALSE);
    return S_OK;
}

//
// CWMPProxy::get_bufferingProgress
// returns buffering progress (percent)
//
STDMETHODIMP CWMPProxy::get_bufferingProgress(long * lProgress)
{
    HRESULT hr = S_OK;
    VARIANT network = {0};
    VARIANT progress = {0};

    *lProgress = 0;


    hr = GetProp(m_pdispWmp, L"network", &network);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetProp(network.pdispVal, L"bufferingProgress", &progress);
    if (FAILED(hr))
    {
        goto done;
    }

    *lProgress = progress.lVal;

done:
    VariantClear(&network);

    return hr;
}

//
// CWMPProxy::get_currTime
//
STDMETHODIMP CWMPProxy::get_currTime(double* pdblCurrentTime)
{
    HRESULT hr = S_OK;
    VARIANT control = {0};
    VARIANT position = {0};

    hr = GetProp(m_pdispWmp, L"controls", &control);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetProp(control.pdispVal, L"currentPosition", &position);
    if (FAILED(hr))
    {
        goto done;
    }

    *pdblCurrentTime = position.dblVal;

done:
    VariantClear(&control);

    return hr;
}

//
// CWMPProxy::get_clipDur
// Returns the current duration of the clip
//
STDMETHODIMP CWMPProxy::get_clipDur(double* pdbl)
{
    HRESULT hr = S_OK;
    if (!pdbl)
    {
        return E_POINTER;
    }

    *pdbl = m_dblClipDur;
    return hr;
}

//
// CWMPProxy::get_mediaDur
// Not implemented
//
STDMETHODIMP CWMPProxy::get_mediaDur(double* pdbl)
{
    HRESULT hr = S_OK;
    return hr;
}

//
// CWMPProxy::get_state
// Gets the current state of the player
//
STDMETHODIMP CWMPProxy::get_state(TimeState *state)
{
    HRESULT hr = S_OK;
    VARIANT playstate = {0};

    hr = GetProp(m_pdispWmp, L"playstate", &playstate);
    if (FAILED(hr))
    {
        goto done;
    }

    switch(playstate.lVal)
    {
    case wmppsUndefined:
        *state = TS_Inactive;
        break;
    case wmppsStopped:
    case wmppsPlaying:
    case wmppsMediaEnded:
    case wmppsReady:
        *state = TS_Active;
        break;
    case wmppsBuffering:
    case wmppsWaiting:
        *state = TS_Cueing;
        break;
    case wmppsScanForward:
    case wmppsScanReverse:
        *state = TS_Seeking;
        break;
    default:
        *state = TS_Active;
        break;
    }

done:
    return hr;
}

//
// CWMPProxy::get_playList
// Gets the current playlist
//
STDMETHODIMP CWMPProxy::get_playList(ITIMEPlayList** plist)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_SET_NULL(plist);

    // this is not a playlist source
    if (!m_fPlaylist)
    {
        goto done;
    }
 
    if (m_playList.p)
    {
        hr = m_playList->QueryInterface(IID_ITIMEPlayList, (void**)plist);
        goto done;
    }

    // create a playlist
    hr = CreatePlayList();
    if (FAILED(hr))
    {
        goto done;
    }

    if (!m_playList)
    {
        hr = E_FAIL;
        goto done;
    }

    // fill it
    hr = FillPlayList(m_playList);
    if (FAILED(hr))
    {
        goto done;
    }

    // set loaded to true
    m_playList->SetLoadedFlag(true);

    hr = m_playList->QueryInterface(IID_ITIMEPlayList, (void**)plist);
    if (FAILED(hr))
    {
        goto done;
    }

done:
    return hr;
}

//
// CWMPProxy::get_abstract
// Get media item info
//
STDMETHODIMP CWMPProxy::get_abstract(BSTR* pbstr)
{
    HRESULT hr = S_OK;
    VARIANT media = {0};
    VARIANT control = {0};
    VARIANT iteminfo = {0};
    VARIANTARG  vararg = {0};

    hr = GetProp(m_pdispWmp, L"controls", &control);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetProp(control.pdispVal, L"currentItem", &media);
    if (FAILED(hr))
    {
        goto done;
    }

    vararg.vt       = VT_BSTR;
    vararg.bstrVal  = L"abstract";

    hr = CallMethod(media.pdispVal, L"getItemInfo", &iteminfo, &vararg);
    if(pbstr == NULL)
    {
        goto done;
    }

    *pbstr = iteminfo.bstrVal;

done:
    VariantClear(&media);
    VariantClear(&control);

    return hr;
}

//
// CWMPProxy::get_author
// Get media item info
//
STDMETHODIMP CWMPProxy::get_author(BSTR* pbstr)
{
    HRESULT hr = S_OK;
    VARIANT media = {0};
    VARIANT control = {0};
    VARIANT iteminfo = {0};
    VARIANTARG  vararg = {0};

    hr = GetProp(m_pdispWmp, L"controls", &control);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetProp(control.pdispVal, L"currentItem", &media);
    if (FAILED(hr))
    {
        goto done;
    }

    vararg.vt       = VT_BSTR;
    vararg.bstrVal  = L"author";

    hr = CallMethod(media.pdispVal, L"getItemInfo", &iteminfo, &vararg);
    if(pbstr == NULL)
    {
        goto done;
    }

    *pbstr = iteminfo.bstrVal;

done:
    VariantClear(&media);
    VariantClear(&control);

    return hr;
}

//
// CWMPProxy::get_copyright
// Get media item info
//
STDMETHODIMP CWMPProxy::get_copyright(BSTR* pbstr)
{
    HRESULT hr = S_OK;
    VARIANT media = {0};
    VARIANT control = {0};
    VARIANT iteminfo = {0};
    VARIANTARG  vararg = {0};

    hr = GetProp(m_pdispWmp, L"controls", &control);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetProp(control.pdispVal, L"currentItem", &media);
    if (FAILED(hr))
    {
        goto done;
    }

    vararg.vt       = VT_BSTR;
    vararg.bstrVal  = L"copyright";

    hr = CallMethod(media.pdispVal, L"getItemInfo", &iteminfo, &vararg);
    if(pbstr == NULL)
    {
        goto done;
    }

    *pbstr = iteminfo.bstrVal;

done:
    VariantClear(&media);
    VariantClear(&control);

    return hr;
}

//
// CWMPProxy::get_rating
// Get media item info
//
STDMETHODIMP CWMPProxy::get_rating(BSTR* pbstr)
{
    HRESULT hr = S_OK;
    VARIANT media = {0};
    VARIANT control = {0};
    VARIANT iteminfo = {0};
    VARIANTARG  vararg = {0};

    hr = GetProp(m_pdispWmp, L"controls", &control);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetProp(control.pdispVal, L"currentItem", &media);
    if (FAILED(hr))
    {
        goto done;
    }

    vararg.vt       = VT_BSTR;
    vararg.bstrVal  = L"rating";

    hr = CallMethod(media.pdispVal, L"getItemInfo", &iteminfo, &vararg);
    if(pbstr == NULL)
    {
        goto done;
    }

    *pbstr = iteminfo.bstrVal;

done:
    VariantClear(&media);
    VariantClear(&control);

    return hr;
}

//
// CWMPProxy::get_title
// Get media item info
//
STDMETHODIMP CWMPProxy::get_title(BSTR* pbstr)
{
    HRESULT hr = S_OK;
    VARIANT media = {0};
    VARIANT control = {0};
    VARIANT iteminfo = {0};
    VARIANTARG  vararg = {0};

    hr = GetProp(m_pdispWmp, L"controls", &control);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetProp(control.pdispVal, L"currentItem", &media);
    if (FAILED(hr))
    {
        goto done;
    }

    vararg.vt       = VT_BSTR;
    vararg.bstrVal  = L"title";

    hr = CallMethod(media.pdispVal, L"getItemInfo", &iteminfo, &vararg);
    if(pbstr == NULL)
    {
        goto done;
    }

    *pbstr = iteminfo.bstrVal;

done:
    VariantClear(&media);
    VariantClear(&control);

    return hr;
}

//
// CWMPProxy::get_canPause
// Checks to see it the media item can be paused
//
STDMETHODIMP CWMPProxy::get_canPause(VARIANT_BOOL* pvar)
{
    HRESULT hr = S_OK;
    VARIANT control = {0};
    VARIANT pause = {0};
    VARIANTARG vararg = {0};
    DISPID dispidGet = DISPID_UNKNOWN;
    DISPPARAMS params = {&vararg, &dispidGet, 1, 0};

    if(pvar == NULL)
    {
        hr = E_POINTER;
        goto done;
    }
    *pvar = VARIANT_FALSE;

    hr = GetProp(m_pdispWmp, L"controls", &control);
    if (FAILED(hr))
    {
        goto done;
    }

    vararg.vt = VT_BSTR;
    vararg.bstrVal = L"Pause";

    // WMP docs lie!
    // They say that isAvailable is a Method, rather than a property
    // took me 1/2 hour to figure out that I was doing the wrong thing.
    hr = GetProp(control.pdispVal, L"isAvailable", &pause, &params);
    if (FAILED(hr))
    {
        goto done;
    }

    *pvar = pause.boolVal;

done:
    VariantClear(&control);

    return hr;
}

//
// CWMPProxy::get_canSeek
// Checks to see if we can seek in the media item
// hard coded to return true
//
STDMETHODIMP CWMPProxy::get_canSeek(VARIANT_BOOL* pvar)
{
    HRESULT hr = S_OK;
    CComVariant control;
    CComVariant seek;
    VARIANTARG vararg = {0};
    DISPID dispidGet = DISPID_UNKNOWN;
    DISPPARAMS params = {&vararg, &dispidGet, 1, 0};

    if(pvar == NULL)
    {
        hr = E_POINTER;
        goto done;
    }
    *pvar = VARIANT_FALSE;

    hr = GetProp(m_pdispWmp, L"controls", &control);
    if (FAILED(hr) || (V_VT(&control) != VT_DISPATCH))
    {
        goto done;
    }

    vararg.vt = VT_BSTR;
    vararg.bstrVal = L"CurrentPosition";

    hr = GetProp(V_DISPATCH(&control), L"isAvailable", &seek, &params);
    if (FAILED(hr) || (V_VT(&seek) != VT_BOOL))
    {
        goto done;
    }

    *pvar = V_BOOL(&seek);

done:
    return hr;
}

//
// CWMPProxy::get_hasAudio
// Checks to see if media item has audio?
// hard coded to return false... (?)
//
STDMETHODIMP CWMPProxy::get_hasAudio(VARIANT_BOOL* pvar)
{
    HRESULT hr = S_OK;
    if(pvar == NULL)
    {
        goto done;
    }
    *pvar = VARIANT_FALSE;

done:
    return hr;
}

//
// CWMPProxy::get_hasVisual
// Checks to see if media item has visual
//
STDMETHODIMP CWMPProxy::get_hasVisual(VARIANT_BOOL* pvar)
{
    HRESULT hr = S_OK;
    if(pvar == NULL)
    {
        goto done;
    }

    // If its a audio file, we should have no visual
    // WMP shows visualizations by default, and we dont
    // want that.
    *pvar = m_fAudio ? VARIANT_FALSE : VARIANT_TRUE;

done:
    return hr;
}

//
// CWMPProxy::get_mediaHeight
// Gets the current media height
//
STDMETHODIMP CWMPProxy::get_mediaHeight(long* pl)
{
    HRESULT hr = S_OK;
    VARIANT media = {0};
    VARIANT control = {0};
    VARIANT itemheight = {0};

    hr = GetProp(m_pdispWmp, L"controls", &control);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetProp(control.pdispVal, L"currentItem", &media);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetProp(media.pdispVal, L"imageSourceHeight", &itemheight);
    if (FAILED(hr))
    {
        goto done;
    }

    *pl = itemheight.lVal;

done:
    VariantClear(&media);
    VariantClear(&control);

    return hr;
}

//
// CWMPProxy::get_mediaWidth
// Gets the current media width
//
STDMETHODIMP CWMPProxy::get_mediaWidth(long* pl)
{
    HRESULT hr = S_OK;
    VARIANT media = {0};
    VARIANT control = {0};
    VARIANT itemwidth = {0};

    hr = GetProp(m_pdispWmp, L"controls", &control);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetProp(control.pdispVal, L"currentItem", &media);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetProp(media.pdispVal, L"imageSourceWidth", &itemwidth);
    if (FAILED(hr))
    {
        goto done;
    }

    *pl = itemwidth.lVal;

done:
    VariantClear(&media);
    VariantClear(&control);

    return hr;
}

//
// CWMPProxy::get_customObject
// Return the WMP dispatch object
//
STDMETHODIMP CWMPProxy::get_customObject(IDispatch** ppdisp)
{
    HRESULT hr = S_OK;

    return SUPER::get_playerObject(ppdisp);
}

//
// CWMPProxy::getControl
// Return the control
//
STDMETHODIMP CWMPProxy::getControl(IUnknown ** control)
{
    HRESULT hr = E_FAIL;
    hr = _InternalQueryInterface(IID_IUnknown, (void **)control);
    if (FAILED(hr))
    {
        goto done;
    }

done:
    return hr;
}

//
// CWMPProxy::Invoke
// 
STDMETHODIMP
CWMPProxy::Invoke(DISPID dispIDMember, REFIID riid, LCID lcid, unsigned short wFlags, 
                         DISPPARAMS *pDispParams, VARIANT *pVarResult,
                         EXCEPINFO *pExcepInfo, UINT *puArgErr) 
{
    HRESULT hr = S_OK;

    // We need to process events that we use and punt the rest
    // hmmm, if ProcessEvent returns a failure, should we still punt it?
    // yeah probably, just in case if our parent knows what the hell
    // to do with it.
    hr = ProcessEvent(dispIDMember,
                        pDispParams->cArgs, 
                        pDispParams->rgvarg);

    // Punt it!
    hr = CProxyBaseImpl<&CLSID_WMPProxy, &LIBID_WMPProxyLib>::Invoke(dispIDMember,
                                riid,
                                lcid,
                                wFlags,
                                pDispParams,
                                pVarResult,
                                pExcepInfo,
                                puArgErr);
    return hr;
} // Invoke

//
// CWMPProxy::ProcessEvent
// Process events that we need
//
HRESULT
CWMPProxy::ProcessEvent(DISPID dispid,
                               long lCount, 
                               VARIANT varParams[])
{
    HRESULT hr = S_OK;

    switch (dispid)
    {
      case DISPID_WMPCOREEVENT_BUFFERING:
          if (varParams[0].boolVal == VARIANT_TRUE)
          {
              m_fBuffered = true;
          }
          break;
      case DISPID_WMPCOREEVENT_PLAYSTATECHANGE:
          hr = OnPlayStateChange(lCount, varParams);
          break;
      case DISPID_WMPCOREEVENT_OPENSTATECHANGE:
          hr = OnOpenStateChange(lCount, varParams);
          break;
      case DISPID_WMPCOREEVENT_ERROR:
          hr = NotifyPropertyChanged(DISPID_TIMEMEDIAPLAYERSITE_REPORTERROR);
          break;
      default:
          break;
    }

    return hr;
}

//
// CWMPProxy::OnPlayStateChange
// Handles the Play state change events
//
HRESULT
CWMPProxy::OnPlayStateChange(long lCount, VARIANT varParams[])
{
    HRESULT hr = S_OK;
    VARIANT control = {0};
    VARIANT mediaitem = {0};
    VARIANT duration = {0};
 
    Assert(lCount == 1);
    
    // MediaPlaying
    if (varParams[0].lVal == wmppsPlaying)
    {
        // media just started playing
        // if it was resumed, then ignore
        if (m_fResumedPlay)
        {
            m_fResumedPlay = false;
            goto done;
        }

        // if we have a playlist,
        // we need to check if the item that is playing is
        // the first one, and only fire a duration change event
        // in that case
        if (m_fPlaylist)
        {
            long lindex;
            CPlayItem * pPlayItem;

            hr = GetActiveTrack(&lindex);
            if (FAILED(hr))
            {
                goto done;
            }

            if (lindex == 0)
            {
                // set initial clip duration to infinite
                m_dblClipDur = TIME_INFINITE;
                NotifyPropertyChanged(DISPID_TIMEMEDIAPLAYER_CLIPDUR);
            }

            // we need to update the duration in playitem so that
            // someone can grab it.
            hr = GetProp(m_pdispWmp, L"controls", &control);
            if (FAILED(hr))
            {
                goto done;
            }

            hr = GetProp(control.pdispVal, L"currentItem", &mediaitem);
            if (FAILED(hr))
            {
                goto done;
            }

            hr = GetProp(mediaitem.pdispVal, L"duration", &duration);
            if (FAILED(hr))
            {
                goto done;
            }

            pPlayItem = m_playList->GetActiveTrack();
            if (!pPlayItem)
            {
                goto done;
            }

            pPlayItem->PutDur(duration.dblVal);

            goto done;
        }

        // if its not a playlist,
        // we can just the clip duration from WMP
        // and give that to mstime.
        hr = GetProp(m_pdispWmp, L"controls", &control);
        if (FAILED(hr))
        {
            goto done;
        }

        hr = GetProp(control.pdispVal, L"currentItem", &mediaitem);
        if (FAILED(hr))
        {
            goto done;
        }

        hr = GetProp(mediaitem.pdispVal, L"duration", &duration);
        if (FAILED(hr))
        {
            goto done;
        }

        m_dblClipDur = duration.dblVal;
        NotifyPropertyChanged(DISPID_TIMEMEDIAPLAYER_CLIPDUR);
    }

    // MediaEnded
    if (varParams[0].lVal == wmppsMediaEnded)
    {
        // if its a playlist,
        // we need to check if the item is the last item
        // on the playlist and then
        // we need to get the total media time
        // from mstime and just fire a clip duration
        // change event.
        if (m_fPlaylist)
        {
            long lindex, lcount;

            hr = GetActiveTrack(&lindex);
            if (FAILED(hr))
            {
                goto done;
            }

            hr = GetTrackCount(&lcount);
            if (FAILED(hr))
            {
                goto done;
            }

            if ((lcount-1 == lindex && m_lTotalNumInTopLevel-1 <= m_lDoneTopLevel) ||
                (lcount-1 == lindex && !m_fEmbeddedPlaylist))
            {
                end();
                m_fPlaylist = false;
                if (m_playList)
                {
                    m_playList->Deinit();
                    m_playList.Release();
                }
                m_spTIMEState->get_simpleTime(&m_dblClipDur);
                NotifyPropertyChanged(DISPID_TIMEMEDIAPLAYER_CLIPDUR);
            }

            goto done;
        }

        // if its a single media item
        // even though we got the duration from WMP
        // there is a lag between the media item actually playing
        // and WMP booting up (and sometimes large in some cases)
        // so to be on the safe side, we will just get the time from
        // mstime and use that instead.
        m_spTIMEState->get_segmentTime(&m_dblClipDur);
        NotifyPropertyChanged(DISPID_TIMEMEDIAPLAYER_CLIPDUR);
    }
 
done:
    VariantClear(&mediaitem);
    VariantClear(&control);

    return hr;
}

//
// CWMPProxy::OnOpenStateChange
// Handles the Open State Change events
//
HRESULT
CWMPProxy::OnOpenStateChange(long lCount, VARIANT varParams[])
{
    HRESULT hr = S_OK;

    Assert(lCount == 1);

    if (!m_fRunning && !m_fSrcChanged)
    {
        goto done;
    }
    
    // Playlist Changing
    if (varParams[0].lVal == wmposPlaylistChanging)
    {
        // we have a new playlist
        m_fNewPlaylist = true;
    }
    if (varParams[0].lVal == wmposPlaylistChanged)
    {
        m_fNewPlaylist = true;
        if (m_varPlaylist.vt != VT_EMPTY)
        {
            m_fEmbeddedPlaylist = true;
        }

        CComVariant playlist;

        hr = GetProp(m_pdispWmp, L"currentPlaylist", &playlist);
        if (FAILED(hr))
        {
            goto done;
        }

        if (playlist.pdispVal == m_varPlaylist.pdispVal)
        {
            ++m_lDoneTopLevel;
        }
    }
    // Playlist Opened
    if (varParams[0].lVal == wmposPlaylistOpenNoMedia)
    {
        // our new playlist has opened, so we need to get all the info for it
        if (m_fNewPlaylist)
        {
            DAComPtr<ITIMEPlayList> spPlaylist;
            CComVariant playlist, count;

            // recalulate playlists..
            m_fNewPlaylist = false;
            m_fPlaylist = true;
            
            if (m_playList)
            {
                m_playList->Deinit();
                m_playList.Release();
            }

            hr = GetProp(m_pdispWmp, L"currentPlaylist", &playlist);
            if (FAILED(hr))
            {
                goto done;
            }

            hr = GetProp(playlist.pdispVal, L"count", &count);
            if (FAILED(hr))
            {
                goto done;
            }

            // if we are at the top level
            // get the playlist info for top level
            if (!m_fCurrLevelSet)
            {
                m_varPlaylist.Copy(&playlist);
                m_fCurrLevelSet = true;
                m_lTotalNumInTopLevel = count.lVal;
            }

            get_playList(&spPlaylist);
        }
    }
    // Media Opened
    else if (varParams[0].lVal == wmposMediaOpen)
    {
        // set the default size of the video
        RECT rectSize;

        rectSize.top = rectSize.left = 0;
        get_mediaHeight(&rectSize.bottom);
        get_mediaWidth(&rectSize.right);

        // new media...set buffered to false by default
        // event will capture if its actually buffered or not.
        m_fBuffered = false;

        if ((rectSize.bottom == 0) && (rectSize.right == 0))
        {
            m_fAudio = true;
        }
        else
        {
            m_fAudio = false;
        }

        m_spOleInPlaceSite->OnPosRectChange(&rectSize);

        // this fires the ONMEDIACOMPLETE event
        // so we should only fire it once
        if (m_fSrcChanged)
        {
            NotifyPropertyChanged(DISPID_TIMEMEDIAPLAYER_SRC);
            m_fSrcChanged = false;
        }
        else if (m_fPlaylist)
        {
            // we just got a media open event
            // but it was not a new src
            // so it was obviously a track change
            NotifyPropertyChanged(DISPID_TIMEPLAYLIST_ACTIVETRACK);
        }

        NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_MEDIAHEIGHT);
        NotifyPropertyChanged(DISPID_TIMEMEDIAELEMENT_MEDIAWIDTH);
        NotifyPropertyChanged(DISPID_TIMEMEDIAPLAYER_ABSTRACT);
        NotifyPropertyChanged(DISPID_TIMEMEDIAPLAYER_AUTHOR);
        NotifyPropertyChanged(DISPID_TIMEMEDIAPLAYER_CLIPDUR);
        NotifyPropertyChanged(DISPID_TIMEMEDIAPLAYER_COPYRIGHT);
        NotifyPropertyChanged(DISPID_TIMEMEDIAPLAYER_RATING);
        NotifyPropertyChanged(DISPID_TIMEMEDIAPLAYER_TITLE);
    }

done:
    return hr;
}

//
// CWMPProxy::GetConnectionPoint
//
HRESULT CWMPProxy::GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP)
{
    return FindConnectionPoint(riid, ppICP);
} // GetConnectionPoint


//
// CWMPProxy::NotifyPropertyChanged
// notifies all the connections that one of the property has changed
//
HRESULT CWMPProxy::NotifyPropertyChanged(DISPID dispid)
{
    HRESULT hr;

    IConnectionPoint *pICP;
    IEnumConnections *pEnum = NULL;

    // This object does not persist anything, hence commenting out the following
    // m_fPropertiesDirty = true;

    hr = GetConnectionPoint(IID_IPropertyNotifySink,&pICP); 
    if (SUCCEEDED(hr) && pICP != NULL)
    {
        hr = pICP->EnumConnections(&pEnum);
        pICP->Release();
        if (FAILED(hr))
        {
            goto done;
        }
        CONNECTDATA cdata;
        hr = pEnum->Next(1, &cdata, NULL);
        while (hr == S_OK)
        {
            // check cdata for the object we need
            IPropertyNotifySink *pNotify;
            hr = cdata.pUnk->QueryInterface(IID_IPropertyNotifySink, (void **)&pNotify);
            cdata.pUnk->Release();
            if (FAILED(hr))
            {
                goto done;
            }
            hr = pNotify->OnChanged(dispid);
            pNotify->Release();
            if (FAILED(hr))
            {
                goto done;
            }
            // and get the next enumeration
            hr = pEnum->Next(1, &cdata, NULL);
        }
    }
done:
    if (NULL != pEnum)
    {
        pEnum->Release();
    }

    return hr;
} // NotifyPropertyChanged

//
// CWMPProxy::InitPropSink
//
HRESULT CWMPProxy::InitPropSink()
{
    HRESULT hr = S_OK;
    CComPtr<IConnectionPoint> spCP;
    CComPtr<IConnectionPointContainer> spCPC;
    
    if (!m_spTIMEState)
    {
        goto done;
    }
    
    hr = m_spTIMEState->QueryInterface(IID_IConnectionPointContainer, (void **) &spCPC);
    if (FAILED(hr))
    {
        hr = S_OK;
        goto done;
    }

    // Find the IPropertyNotifySink connection
    hr = spCPC->FindConnectionPoint(IID_IPropertyNotifySink, &spCP);
    if (FAILED(hr))
    {
        hr = S_OK;
        goto done;
    }

    hr = spCP->Advise(GetUnknown(), &m_dwPropCookie);
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
  done:
    return hr;
}

//
// CWMPProxy::DeinitPropSink
//
void CWMPProxy::DeinitPropSink()
{
    HRESULT hr;
    CComPtr<IConnectionPoint> spCP;
    CComPtr<IConnectionPointContainer> spCPC;
    
    if (!m_spTIMEState || !m_dwPropCookie)
    {
        goto done;
    }
    
    hr = m_spTIMEState->QueryInterface(IID_IConnectionPointContainer, (void **) &spCPC);
    if (FAILED(hr))
    {
        goto done;
    }

    // Find the IPropertyNotifySink connection
    hr = spCPC->FindConnectionPoint(IID_IPropertyNotifySink,
                                    &spCP);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = spCP->Unadvise(m_dwPropCookie);
    if (FAILED(hr))
    {
        goto done;
    }
    
  done:
    // Always clear the cookie
    m_dwPropCookie = 0;
    return;
}

//
// CWMPProxy::OnRequestEdit
//
STDMETHODIMP
CWMPProxy::OnRequestEdit(DISPID dispID)
{
    return S_OK;
}

//
// CWMPProxy::OnChanged
//
STDMETHODIMP
CWMPProxy::OnChanged(DISPID dispID)
{
    float flTeSpeed = 0.0;
    HRESULT hr = S_OK;

    //This function handles property change notifications fired by 
    //the time node. In the example below the speed change notification is processed.

    if(m_spTIMEState == NULL || m_spTIMEElement == NULL)
    {
        goto done;
    }

    switch(dispID)
    {
        case DISPID_TIMESTATE_SPEED:
            hr = m_spTIMEState->get_speed(&flTeSpeed);
            if(FAILED(hr))
            {
                break;
            }
            if(flTeSpeed <= 0.0)
            {
                pause(); //do not play backwards.
                break;
            }
            else
            {
                resume();
            }

            //set playback speed to flTeSpeed
            break;
        default:
            break;
    }
done:
    return S_OK;
}

//
// CWMPProxy::GetTrackCount
// gets the number of tracks in the current playlist
//
HRESULT CWMPProxy::GetTrackCount(long* lCount)
{
    HRESULT hr = S_OK;
    VARIANT playlist = {0};
    VARIANT count = {0};

    if (m_fPlaylist && m_playList)
    {
        hr = GetProp(m_pdispWmp, L"currentPlaylist", &playlist);
        if (FAILED(hr))
        {
            goto done;
        }

        hr = GetProp(playlist.pdispVal, L"count", &count);
        if (FAILED(hr))
        {
            goto done;
        }

        if (lCount)
        {
            *lCount = count.lVal;
        }
    }

done:
    VariantClear(&playlist);

    return hr;
}

//
// CWMPProxy::GetActiveTrack
// gets the active track number
//
HRESULT CWMPProxy::GetActiveTrack(long* index)
{
    HRESULT hr = S_OK;
    VARIANT control = {0};
    VARIANT playlist = {0};
    VARIANT playitem1 = {0};
    VARIANT playitem2 = {0};
    VARIANT count = {0};

    VARIANTARG  vararg = {0};
    DISPID      dispidGet   = DISPID_UNKNOWN;
    DISPPARAMS  params      = {&vararg, &dispidGet, 1, 0};

    if (m_fPlaylist && m_playList)
    {
        hr = GetProp(m_pdispWmp, L"controls", &control);
        if (FAILED(hr))
        {
            goto done;
        }

        // retrieve the current item
        hr = GetProp(control.pdispVal, L"currentItem", &playitem1);
        if (FAILED(hr))
        {
            goto done;
        }

        // retrieve the current playlist
        hr = GetProp(m_pdispWmp, L"currentPlaylist", &playlist);
        if (FAILED(hr))
        {
            goto done;
        }

        // gets the number of tracks
        hr = GetProp(playlist.pdispVal, L"count", &count);
        if (FAILED(hr))
        {
            goto done;
        }

        // search for the current item in the current playlist
        for (int i = 0; i < count.lVal; ++i)
        {
            vararg.vt       = VT_UINT;
            vararg.uintVal    = i;

            hr = GetProp(playlist.pdispVal, L"item", &playitem2, &params);
            if (FAILED(hr))
            {
                goto done;
            }

            if (playitem1.pdispVal == playitem2.pdispVal)
            {
                *index = i;
                break;
            }
        }
    }

done:
    VariantClear(&control);
    VariantClear(&playlist);
    VariantClear(&playitem1);
    VariantClear(&playitem2);

    return hr;
}

//
// CWMPProxy::IsActive
//
bool CWMPProxy::IsActive()
{
    return true;
}

//
// CWMPProxy::SetActiveTrack
// set the active track number
//
HRESULT CWMPProxy::SetActiveTrack(long index)
{
    HRESULT hr = S_OK;
    VARIANT playlist = {0};
    VARIANT playitem = {0};
    VARIANT control = {0};
    VARIANTARG  vararg = {0};
    DISPID      dispidGet   = DISPID_UNKNOWN;
    DISPPARAMS  params      = {&vararg, &dispidGet, 1, 0};

    if (m_fPlaylist && m_playList)
    {

        hr = GetProp(m_pdispWmp, L"currentPlaylist", &playlist);
        if (FAILED(hr))
        {
            goto done;
        }

        // set the active track number
        // do we need bounds checking here?
        // probably not, but maybe an assert?
        vararg.vt       = VT_UINT;
        vararg.uintVal    = index;

        hr = GetProp(playlist.pdispVal, L"item", &playitem, &params);
        if (FAILED(hr))
        {
            goto done;
        }

        hr = GetProp(m_pdispWmp, L"controls", &control);
        if (FAILED(hr))
        {
            goto done;
        }

        hr = CallMethod(control.pdispVal, L"playItem", NULL, &playitem);
        if (FAILED(hr))
        {
            goto done;
        }
    }

done:
    VariantClear(&playlist);
    VariantClear(&playitem);
    VariantClear(&control);

    return hr;
}

//
// CWMPProxy::CreatePlayList
// create the playlist object
//
HRESULT CWMPProxy::CreatePlayList()
{
    HRESULT hr = S_OK;

    if (!m_playList)
    {
        CComObject<CPlayList> * pPlayList;

        hr = CComObject<CPlayList>::CreateInstance(&pPlayList);
        if (hr != S_OK)
        {
            goto done;
        }

        // Init the object
        hr = pPlayList->Init(*this);
        if (FAILED(hr))
        {
            delete pPlayList;
            goto done;
        }

        // cache a pointer to the object
        m_playList = static_cast<CPlayList*>(pPlayList);
    }

    hr = S_OK;

done:
    return hr;
}

//
// CWMPProxy::FillPlayList
// fill the playlist object
//
HRESULT CWMPProxy::FillPlayList(CPlayList *pPlayList)
{
    HRESULT hr = S_OK;
    VARIANT playlist = {0};
    VARIANT media = {0};
    VARIANT count = {0};
    VARIANT iteminfo = {0};
    VARIANT duration = {0};
    VARIANTARG  vararg = {0};
    DISPID      dispidGet   = DISPID_UNKNOWN;
    DISPPARAMS  params      = {&vararg, &dispidGet, 1, 0};

    // we changed our source. need to clear out playlist stuff
    hr = GetProp(m_pdispWmp, L"currentPlaylist", &playlist);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetProp(playlist.pdispVal, L"count", &count);
    if (FAILED(hr))
    {
        goto done;
    }

    for (int i = 0; i < count.lVal; ++i)
    {
        CComPtr<CPlayItem> pPlayItem;

        vararg.vt       = VT_BSTR;

        //create the playitem
        hr = pPlayList->CreatePlayItem(&pPlayItem);
        if (FAILED(hr))
        {
            goto done; //can't create playitems.
        }

        // get all the info and fill it in
        vararg.vt = VT_UINT;
        vararg.uintVal = i;
        hr = GetProp(playlist.pdispVal, L"item", &media, &params);
        hr = GetProp(media.pdispVal, L"sourceURL", &iteminfo);
        if (hr == S_OK)
        {
            pPlayItem->PutSrc(iteminfo.bstrVal);
        }

        hr = GetProp(media.pdispVal, L"duration", &duration);
        if (hr == S_OK)
        {
            pPlayItem->PutDur(duration.dblVal);
        }

        vararg.vt       = VT_BSTR;
        vararg.bstrVal  = L"title";
        hr = CallMethod(media.pdispVal, L"getItemInfo", &iteminfo, &vararg);
        if (hr == S_OK)
        {
            pPlayItem->PutTitle(iteminfo.bstrVal);
        }

        vararg.bstrVal  = L"author";
        hr = CallMethod(media.pdispVal, L"getItemInfo", &iteminfo, &vararg);
        if (hr == S_OK)
        {
            pPlayItem->PutAuthor(iteminfo.bstrVal);
        }

        vararg.bstrVal  = L"copyright";
        hr = CallMethod(media.pdispVal, L"getItemInfo", &iteminfo, &vararg);
        if (hr == S_OK)
        {
            pPlayItem->PutCopyright(iteminfo.bstrVal);
        }

        vararg.bstrVal  = L"abstract";
        hr = CallMethod(media.pdispVal, L"getItemInfo", &iteminfo, &vararg);
        if (hr == S_OK)
        {
            pPlayItem->PutAbstract(iteminfo.bstrVal);
        }

        vararg.bstrVal  = L"rating";
        hr = CallMethod(media.pdispVal, L"getItemInfo", &iteminfo, &vararg);
        if (hr == S_OK)
        {
            pPlayItem->PutRating(iteminfo.bstrVal);
        }

        //add the playitem to the playlist.
        pPlayList->Add(pPlayItem, -1);
    }

done:
    VariantClear(&playlist);
    VariantClear(&media);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\proxy\wmp\playlist.h ===
/*******************************************************************************
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * File: Playlist.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/
#pragma once

#ifndef _PLAYLIST_H
#define _PLAYLIST_H

#include "WMPProxyPlayer.h"

class CWMPProxy;
class CPlayItem;

#define TIME_INFINITE HUGE_VAL
#define valueNotSet -1
#define LCID_SCRIPTING 0x0409
#define IID_TO_PPV(_type,_src)      IID_##_type, \
                                    reinterpret_cast<void **>(static_cast<_type **>(_src))

#if (_M_IX86 >= 300) && defined(DEBUG)
  #define PSEUDORETURN(dw)    _asm { mov eax, dw }
#else
  #define PSEUDORETURN(dw)
#endif // not _M_IX86

#define ReleaseInterface(p)\
{\
    /*lint -e550 -e774 -e423*/ /* suppress cRef not referenced, if always evaluates to false, and creation of memory leak */ \
    ULONG cRef = 0u; \
    if (NULL != (p))\
    {\
        cRef = (p)->Release();\
        Assert((int)cRef>=0);\
        (p) = NULL;\
    }\
    PSEUDORETURN(cRef) \
    /*lint -restore */ \
} 

inline WCHAR * CopyString(const WCHAR *str) {
    int len = str?lstrlenW(str)+1:1;
    WCHAR *newstr = new WCHAR [len] ;
    if (newstr) memcpy(newstr,str?str:L"",len * sizeof(WCHAR)) ;
    return newstr ;
}

class
__declspec(uuid("efbad7f8-3f94-11d2-b948-00c04fa32195")) 
CPlayList :  
    public CComObjectRootEx<CComSingleThreadModel>, 
    public CComCoClass<CPlayList, &__uuidof(CPlayList)>,
    public ITIMEDispatchImpl<ITIMEPlayList, &IID_ITIMEPlayList>,
    public ISupportErrorInfoImpl<&IID_ITIMEPlayList>,
    public IConnectionPointContainerImpl<CPlayList>,
    public IPropertyNotifySinkCP<CPlayList>
{
  public:
    CPlayList();
    virtual ~CPlayList();
    HRESULT ConstructArray();
        
    HRESULT Init(CWMPProxy & player);
    void Deinit();

    //    
    // QI & CP Map
    //

    BEGIN_COM_MAP(CPlayList)
        COM_INTERFACE_ENTRY(ITIMEPlayList)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    END_COM_MAP();

#ifndef END_COM_MAP_ADDREF
    //
    // IUnknown
    //

    STDMETHOD_(ULONG,AddRef)(void) = 0;
    STDMETHOD_(ULONG,Release)(void) = 0;
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) = 0;
#endif
    // 
    // ITIMEPlayList methods
    //
        
    STDMETHOD(put_activeTrack)(VARIANT vTrack);
    STDMETHOD(get_activeTrack)(ITIMEPlayItem **pPlayItem);
        
    //returns the duration of the entire playlist if it is known or -1 if it is not.
    STDMETHOD(get_dur)(double *dur);

    STDMETHOD(item)(VARIANT varIndex,
                    ITIMEPlayItem **pPlayItem);

    STDMETHOD(get_length)(long* len);

    STDMETHOD(get__newEnum)(IUnknown** p);

    STDMETHOD(nextTrack)(); //Advances the active Track by one
    STDMETHOD(prevTrack)(); //moves the active track to the previous track

    BEGIN_CONNECTION_POINT_MAP(CPlayList)
        CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
    END_CONNECTION_POINT_MAP();

    // Notification helper
    HRESULT NotifyPropertyChanged(DISPID dispid);

    void Clear();
    void SetLoaded(bool bLoaded);
    void SetLoadedFlag(bool bLoaded);
    long GetLength() { return m_rgItems->Size(); }

    CPlayItem * GetActiveTrack();
    CPlayItem * GetItem(long index);
    
    HRESULT Add(CPlayItem *pPlayItem,
                long index);
    HRESULT Remove(long index);

    void SetIndex();
    long GetIndex(LPOLESTR name);

    HRESULT CreatePlayItem(CPlayItem **pPlayItem);
        
  protected:
    CPtrAry<CPlayItem *>      *m_rgItems;
    CWMPProxy *                m_player;
    bool                       m_fLoaded;
    CComVariant                m_vNewTrack;

}; //lint !e1712


class CPlayListEnum :
    public CComObjectRootEx<CComSingleThreadModel>,
    public IEnumVARIANT
{
  public:
    CPlayListEnum();
    virtual ~CPlayListEnum();

    void Init(CPlayList &playList) { m_playList = &playList; }
    
    // IEnumVARIANT methods
    STDMETHOD(Clone)(IEnumVARIANT **ppEnum);
    STDMETHOD(Next)(unsigned long celt, VARIANT *rgVar, unsigned long *pCeltFetched);
    STDMETHOD(Reset)();
    STDMETHOD(Skip)(unsigned long celt);
    void SetCurElement(unsigned long celt);
                        
    // QI Map
    BEGIN_COM_MAP(CPlayListEnum)
        COM_INTERFACE_ENTRY(IEnumVARIANT)
    END_COM_MAP();

  protected:
    long                        m_lCurElement;
    DAComPtr<CPlayList>         m_playList;
}; //lint !e1712

class
__declspec(uuid("efbad7f8-3f94-11d2-b948-00c04fa32195")) 
CPlayItem :  
    public CComObjectRootEx<CComSingleThreadModel>, 
    public CComCoClass<CPlayItem, &__uuidof(CPlayItem)>,
    public ITIMEDispatchImpl<ITIMEPlayItem2, &IID_ITIMEPlayItem2>,
    public ISupportErrorInfoImpl<&IID_ITIMEPlayItem2>,
    public IConnectionPointContainerImpl<CPlayItem>,
    public IPropertyNotifySinkCP<CPlayItem>
{
  public:
    CPlayItem();
    virtual ~CPlayItem();

    void Init(CPlayList & pPlayList) { m_pPlayList = &pPlayList; }
    void Deinit() { m_pPlayList = NULL; }
    
    // QI Map
    BEGIN_COM_MAP(CPlayItem)
        COM_INTERFACE_ENTRY(ITIMEPlayItem2)
        COM_INTERFACE_ENTRY(ITIMEPlayItem)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    END_COM_MAP();

#ifndef END_COM_MAP_ADDREF
    //
    // IUnknown
    //

    STDMETHOD_(ULONG,AddRef)(void) = 0;
    STDMETHOD_(ULONG,Release)(void) = 0;
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) = 0;
#endif

    //
    // ITIMEPlayItem interface
    //
    STDMETHOD(get_abstract)(LPOLESTR *abs);
    STDMETHOD(get_author)(LPOLESTR *auth);
    STDMETHOD(get_copyright)(LPOLESTR *cpyrght);
    STDMETHOD(get_dur)(double *dur);
    STDMETHOD(get_index)(long *index);
    STDMETHOD(get_rating)(LPOLESTR *rate);
    STDMETHOD(get_src)(LPOLESTR *src);
    STDMETHOD(get_title)(LPOLESTR *title);
    STDMETHOD(setActive)();

    
    //
    // ITIMEPlayItem2 interface
    //
    STDMETHOD(get_banner)(LPOLESTR *banner);
    STDMETHOD(get_bannerAbstract)(LPOLESTR *abstract);
    STDMETHOD(get_bannerMoreInfo)(LPOLESTR *moreInfo);
    
    //
    
    LPCWSTR GetAbstract() const { return m_abstract; }
    HRESULT PutAbstract(LPWSTR abstract);

    LPCWSTR GetAuthor() const { return m_author; }
    HRESULT PutAuthor(LPWSTR author);

    LPCWSTR GetCopyright() const { return m_copyright; }
    HRESULT PutCopyright(LPWSTR copyright);

    double GetDur() const { return m_dur; }
    void PutDur(double dur);

    long GetIndex() const { return m_lIndex; }
    void PutIndex(long index);

    LPCWSTR GetRating() const { return m_rating; }
    HRESULT PutRating(LPWSTR rating);

    LPCWSTR GetSrc() const { return m_src; }
    HRESULT PutSrc(LPWSTR src);

    LPCWSTR GetTitle() const { return m_title; }
    HRESULT PutTitle(LPWSTR title);

    bool GetCanSkip() const { return m_fCanSkip; }
    HRESULT PutCanSkip(bool fCanSkip) { m_fCanSkip = fCanSkip; return S_OK; }

    LPCWSTR GetBanner() const { return m_banner; };
    LPCWSTR GetBannerAbstract() const { return m_bannerAbstract; };
    LPCWSTR GetBannerMoreInfo() const { return m_bannerMoreInfo; };
    HRESULT PutBanner(LPWSTR banner, LPWSTR abstract, LPWSTR moreInfo);

    BEGIN_CONNECTION_POINT_MAP(CPlayItem)
        CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
    END_CONNECTION_POINT_MAP();

    // Notification helper
    HRESULT NotifyPropertyChanged(DISPID dispid);

  protected:
    CPlayList            *m_pPlayList;
    LPWSTR                m_abstract;
    LPWSTR                m_author;
    LPWSTR                m_copyright;
    double                m_dur;
    int                   m_lIndex;
    LPWSTR                m_rating;
    LPWSTR                m_src;
    LPWSTR                m_title;
    bool                  m_fCanSkip;
    LPWSTR                m_banner;
    LPWSTR                m_bannerAbstract;
    LPWSTR                m_bannerMoreInfo;


};  //lint !e1712

#endif /* _PLAYLIST_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\tags\bodyelm.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1998
//
//  File: src\time\src\bodyelm.cpp
//
//  Contents: TIME Body behavior
//
//------------------------------------------------------------------------------------


#include "headers.h"
#include "bodyelm.h"
#include "timeparser.h"

DeclareTag(tagTimeBodyElm, "TIME: Behavior", "CTIMEBodyElement methods")

// static class data.
DWORD CTIMEBodyElement::ms_dwNumBodyElems = 0;

#define MAX_REG_VALUE_LENGTH   50

class CInternalEventNode
{
  public:
    CInternalEventNode(ITIMEInternalEventSink * pSink, double dblTime) :
           m_dblTime(dblTime), m_spSink(pSink) {}
    ~CInternalEventNode() {}

    ITIMEInternalEventSink * GetSink() { return m_spSink; }
    double GetTime() { return m_dblTime; }

  protected:
    CInternalEventNode();
        
  private:
    CComPtr<ITIMEInternalEventSink> m_spSink;
    double                      m_dblTime;
};

CTIMEBodyElement::CTIMEBodyElement() :
    m_player(*this),
    m_bodyPropertyAccesFlags(0),
    m_fStartRoot(false),
    m_bInSiteDetach(false),
    m_fRegistryRead(false),
    m_fPlayVideo(true),
    m_fShowImages(true),
    m_fPlayAudio(true),
    m_fPlayAnimations(true),
    m_bIsLoading(false)
{
    TraceTag((tagTimeBodyElm,
              "CTIMEBodyElement(%lx)::CTIMEBodyElement()",
              this));

    m_clsid = __uuidof(CTIMEBodyElement);
    CTIMEBodyElement::ms_dwNumBodyElems++;
}

CTIMEBodyElement::~CTIMEBodyElement()
{
    CTIMEBodyElement::ms_dwNumBodyElems--;

    if(!m_spBodyElemExternal)
    {
        Assert(0 == m_compsites.size());
        DetachComposerSites();
    }
}


STDMETHODIMP
CTIMEBodyElement::Init(IElementBehaviorSite * pBehaviorSite)
{
    TraceTag((tagTimeBodyElm,
              "CTIMEBodyElement(%lx)::Init(%lx)",
              this,
              pBehaviorSite));
    
    HRESULT hr;

    hr = THR(CTIMEElementBase::Init(pBehaviorSite));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

done:
    if (FAILED(hr))
    {
        Detach();
    }
    
    return hr;
}

HRESULT
CTIMEBodyElement::InitTimeline()
{
    TraceTag((tagTimeBodyElm, "CTIMEBodyElement(%lx)::InitTimeline()", this));
    HRESULT hr;

    hr = CTIMEElementBase::InitTimeline();
    if (FAILED(hr))
    {
        goto done;
    }

    if(m_spBodyElemExternal)
    {
        //if this body is a child in another time tree do not start time event.
        goto done;
    }

    Assert(m_timeline);
    
    if (!m_player.Init(*m_timeline))
    {
        hr = TIMEGetLastError();
        goto done;
    }

    Assert(!m_fStartRoot);

    if (GetElement())
    {
        CComBSTR pbstrReadyState;
        IHTMLElement *pEle = GetElement();
        hr = GetReadyState(pEle, &pbstrReadyState);
        if (FAILED(hr))
        {
            goto done;
        }
        if (StrCmpIW(pbstrReadyState, L"complete") == 0)
        {
            OnLoad();
        }
    }

    hr = S_OK;
done:
    return hr;
}

//*****************************************************************************

void
CTIMEBodyElement::DetachComposerSites (void)
{
    TraceTag((tagTimeBodyElm,
              "CTIMEBodyElement(%lx)::DetachComposerSites()",
              this));

    if (!InsideSiteDetach())
    {
        // Protect against reentrancy from a site's Unregister call.
        m_bInSiteDetach = true;
    
        // Do not allow any failure to abort the detach cycle.
        for (ComposerSiteList::iterator i = m_compsites.begin(); 
             i != m_compsites.end(); i++)
        {
            (*i)->ComposerSiteDetach();
            IGNORE_RETURN((*i)->Release());
        }
        m_compsites.clear();

        m_bInSiteDetach = false;
    }
} // CTIMEBodyElement::DetachComposerSites 

//*****************************************************************************

STDMETHODIMP
CTIMEBodyElement::Detach()
{
    TraceTag((tagTimeBodyElm, "CTIMEBodyElement(%lx)::Detach()", this));
    
    HRESULT hr;

    if(!m_spBodyElemExternal)
    {
        m_fDetaching = true;
        NotifyBodyDetaching();

        // This protects against a bug in trident that causes us to not get
        // the onUnload event before detach.
        if (!IsUnloading())
        {
            NotifyBodyUnloading();
        }

        if (m_fStartRoot)
        {
            Assert(m_timeline != NULL);
            StopRootTime(NULL);
        }

        m_player.Deinit();
    
        DetachComposerSites();
    }

    THR(CTIMEElementBase::Detach());

    if(!m_spBodyElemExternal)
    {
        std::list<CInternalEventNode * >::iterator iter;

        for(;;)
        {
            iter = m_listInternalEvent.begin();
            if (iter == m_listInternalEvent.end())
            {
                break;
            }

            ITIMEInternalEventSink * pIterSink = NULL;

            pIterSink = (*iter)->GetSink();

            IGNORE_HR(RemoveInternalEventSink(pIterSink));
        }    
    }
    
    hr = S_OK;

    return hr;
}


void
CTIMEBodyElement::OnLoad()
{
    TraceTag((tagTimeBodyElm, "CTIMEBodyElement(%lx)::OnLoad()", this));

    bool fPlayVideo = true;
    bool fShowImages = true;
    bool fPlayAudio = true;
    bool fPlayAnimations = true;

    m_bIsLoading = true;
    // start root time now.
    if (!m_fStartRoot)
    {
        HRESULT hr = THR(StartRootTime(NULL));
        if (FAILED(hr))
        {
            TraceTag((tagError, "CTIMEBodyElement::OnLoad - StartRootTime() failed!"));
            goto done;
        }
    }
    
    ReadRegistryMediaSettings(fPlayVideo, fShowImages, fPlayAudio, fPlayAnimations);
    if (!fPlayAudio)
    {
        VARIANT vTrue;
        VariantInit(&vTrue);
        vTrue.vt = VT_BOOL;
        vTrue.boolVal = VARIANT_TRUE;
        base_put_mute(vTrue);
        VariantClear(&vTrue);
    }

  done:
    CTIMEElementBase::OnLoad();
    m_bIsLoading = false;
    NotifyBodyLoading();

    // This is needed since we may have skipped the call in the unload
    // due to a reentrant call during the load
    if (IsUnloading())
    {
        StopRootTime(NULL);
    }
    
    return;
}

void
CTIMEBodyElement::OnUnload()
{
    TraceTag((tagTimeBodyElm,
              "CTIMEBodyElement(%lx)::OnUnload()",
              this));

    NotifyBodyUnloading();

    CTIMEElementBase::OnUnload();

    // Do this here to protect against a call to unload while we are
    // loading.  We do not do this in stoproottime itself since it is
    // used to cleanup from partial initializations
    if (m_fStartRoot)
    {
        StopRootTime(NULL);
    }
}


//+-----------------------------------------------------------------------
//
//  Member:    OnTick
//
//  Overview:  Walks the time-sorted list of internal event callbacks, 
//             looking to see if any element needs a callback this tick
//             After the object is calledback, it is removed from the list
//
//  Arguments: void
//
//  Returns:   void
//
//------------------------------------------------------------------------
void
CTIMEBodyElement::OnTick()
{
    TraceTag((tagTimeBodyElm,
              "CTIMEBodyElem(%lx)::OnTick()",
              this));

    std::list<CInternalEventNode * >::iterator iter;
    CInternalEventNode *pEvNode = NULL;
    double dblSimpleTime;

    if(m_spBodyElemExternal)
    {
        goto done;
    }


    dblSimpleTime = GetMMBvr().GetSimpleTime();

    iter = m_listInternalEvent.begin();
    while (m_listInternalEvent.size() != 0 && 
           iter != m_listInternalEvent.end())
    {
        double dblIterTime = 0.0;
        ITIMEInternalEventSink * pIterSink = NULL;
        
        dblIterTime = (*iter)->GetTime();
        if (dblSimpleTime < dblIterTime)
        {
            // no events to fire at this time
            break;
        }

        pIterSink = (*iter)->GetSink();

        if (NULL != pIterSink)
        {
            IGNORE_HR(pIterSink->InternalEvent());
        }

        pEvNode = (*iter);
        
        // By post incrementing the iterator will be updated before it
        // is erased
        m_listInternalEvent.erase(iter++);

        delete pEvNode;
    }    
done:
    return;
}


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEBodyElement::IsPrintMedia
//
//------------------------------------------------------------------------------
bool 
CTIMEBodyElement::IsPrintMedia()
{
    bool bPrinting = false;
    CComPtr<IHTMLDocument2> spDoc2 = GetDocument();
    CComPtr<IHTMLDocument4> spDoc4;
    CComBSTR bstrMedia;

    if (!spDoc2)
    {
        goto done;
    }

    {
        HRESULT hr = S_OK;

        hr = THR(spDoc2->QueryInterface(IID_TO_PPV(IHTMLDocument4, &spDoc4)));
        if (FAILED(hr))
        {
            goto done;
        }

        hr = THR(spDoc4->get_media(&bstrMedia));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    if (   (::SysStringLen(bstrMedia) > 0) 
        && (0 == StrCmpIW(bstrMedia, WZ_MEDIA_PRINTING)) )
    {
        bPrinting = true;
    }

done :
    return bPrinting;
}
//  Method: CTIMEBodyElement::IsPrintMedia


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEBodyElement::GetTransitionDependencyMgr
//
//------------------------------------------------------------------------------
CTransitionDependencyManager *
CTIMEBodyElement::GetTransitionDependencyMgr()
{
    return &m_TransitionDependencyMgr;
}
//  Method: CTIMEBodyElement::GetTransitionDependencyMgr


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEBodyElement::QueryPlayOnStart
//
//------------------------------------------------------------------------------
bool
CTIMEBodyElement::QueryPlayOnStart()
{
    return ((!IsDocumentInEditMode()) && (!IsPrintMedia()) && (!IsThumbnail()));
} 
//  Method: CTIMEBodyElement::QueryPlayOnStart


//*****************************************************************************

HRESULT
CTIMEBodyElement::StartRootTime(MMTimeline * tl)
{
    HRESULT hr;
    
    hr = THR(CTIMEElementBase::StartRootTime(tl));

    if (FAILED(hr))
    {
        goto done;
    }

    if(m_spBodyElemExternal)
    {
        goto done;
    }

    if (QueryPlayOnStart())
    {
        if (!m_player.Play())
        {
            hr = TIMEGetLastError();
            goto done;
        }
    }
    else
    {
        // always tick at 0
        m_player.OnTimer(0.0);

        if (!m_player.Pause())
        {
            hr = TIMEGetLastError();
            goto done;
        }
    }

    // always tick at 0
    m_player.OnTimer(0.0);

    hr = S_OK;
    m_fStartRoot = true;
  done:

    if (FAILED(hr) && !m_spBodyElemExternal)
    {
        StopRootTime(tl);
    }
    
    return hr;
}

void
CTIMEBodyElement::StopRootTime(MMTimeline * tl)
{
    m_fStartRoot = false;

    if(!m_spBodyElemExternal)
    {
        m_player.Stop();
    }

    CTIMEElementBase::StopRootTime(tl);
}


HRESULT
CTIMEBodyElement::Error()
{
    LPWSTR str = TIMEGetLastErrorString();
    HRESULT hr = TIMEGetLastError();
    
    if (str)
    {
        hr = CComCoClass<CTIMEBodyElement, &__uuidof(CTIMEBodyElement)>::Error(str, IID_ITIMEBodyElement, hr);
        delete [] str;
    }
        
    return hr;
}

//*****************************************************************************

HRESULT 
CTIMEBodyElement::GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP)
{
    return FindConnectionPoint(riid, ppICP);
} // GetConnectionPoint

//*****************************************************************************

bool
CTIMEBodyElement::IsDocumentStarted()
{
    TraceTag((tagTimeBodyElm, "CTIMEBodyElement::IsDocumentStarted"));
    bool frc = false;
    BSTR bstrState = NULL;
    // get state
    HRESULT hr = GetDocument()->get_readyState(&bstrState);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CTIMEBodyElement::IsDocumentStarted - get_readyState() failed!"));
        goto done;
    }

    Assert(bstrState != NULL);

    if (StrCmpIW(bstrState, L"complete") == 0)
    {
        frc = true;
    }

    SysFreeString(bstrState);

done:
    return frc;
}

//*****************************************************************************

bool
CTIMEBodyElement::HaveAnimationsRegistered (void)
{
    return (0 < m_compsites.size());
} // HaveAnimationsRegistered


STDMETHODIMP
CTIMEBodyElement::RegisterComposerSite (IUnknown *piunkComposerSite)
{
    TraceTag((tagTimeBodyElm, "CTIMEBodyElement::RegisterComposerSite(%#lx) precondition : %ld sites registered", 
              piunkComposerSite, m_compsites.size()));

    HRESULT hr;

    // If we're currently detaching our sites, there is no 
    // work to do here.
    if (!InsideSiteDetach())
    {
        CComPtr<IAnimationComposerSiteSink> piSiteSink;

        hr = piunkComposerSite->QueryInterface(IID_TO_PPV(IAnimationComposerSiteSink, 
                                                          &piSiteSink));
        if (FAILED(hr))
        {
            hr = E_INVALIDARG;
            goto done;
        }
        IGNORE_RETURN(piSiteSink.p->AddRef());
        // @@ Need to handle memory error.
        m_compsites.push_back(piSiteSink);

        TraceTag((tagTimeBodyElm, "CTIMEBodyElement::RegisterComposerSite(%#lx) postcondition : %ld sites registered", 
                  piunkComposerSite, m_compsites.size()));
    }

    hr = S_OK;
done :
    RRETURN1(hr, E_INVALIDARG);
}  // CTIMEBodyElement::RegisterComposerSite

//*****************************************************************************

STDMETHODIMP
CTIMEBodyElement::UnregisterComposerSite (IUnknown *piunkComposerSite)
{
    TraceTag((tagTimeBodyElm, "CTIMEBodyElement::UnregisterComposerSite(%#lx) precondition : %ld sites registered", 
              piunkComposerSite, m_compsites.size()));

    HRESULT hr;

    // If we're currently detaching our sites, there is no 
    // work to do here.
    if (!InsideSiteDetach())
    {
        CComPtr<IAnimationComposerSiteSink> piSiteSink;

        hr = piunkComposerSite->QueryInterface(IID_TO_PPV(IAnimationComposerSiteSink, 
                                                          &piSiteSink));
        if (FAILED(hr))
        {
            hr = E_INVALIDARG;
            goto done;
        }

        {
            for (ComposerSiteList::iterator i = m_compsites.begin(); 
                 i != m_compsites.end(); i++)
            {
                if(MatchElements(*i, piSiteSink))
                {
                    // We don't want to let a release on the (*i) 
                    // be the final release for the sink object.
                    CComPtr<IAnimationComposerSiteSink> spMatchedSiteSink = (*i);
                    IGNORE_RETURN(spMatchedSiteSink.p->Release());
                    m_compsites.remove(spMatchedSiteSink);
                    break;
                }
            }

            // If we did not find the site in our list, return S_FALSE.
            if (m_compsites.end() == i)
            {
                hr = S_FALSE;
                goto done;
            }
            TraceTag((tagTimeBodyElm, "CTIMEBodyElement::UnregisterComposerSite(%#lx) postcondition : %ld sites registered", 
                      piunkComposerSite, m_compsites.size()));
        }

    }

    hr = S_OK;
done :
    RRETURN2(hr, S_FALSE, E_INVALIDARG);
}  // CTIMEBodyElement::UnregisterComposerSite

//+-----------------------------------------------------------------------
//
//  Member:    ReadRegistryMediaSettings
//
//  Overview:  Discover registry settings for playing video and showing images
//
//  Arguments: fPlayVideo   [out] should videos be played
//             fShowImages  [out] should images be displayed
//
//  Returns:   void
//
//------------------------------------------------------------------------
void
CTIMEBodyElement::ReadRegistryMediaSettings(bool & fPlayVideo, bool & fShowImages, bool & fPlayAudio, bool & fPlayAnimations)
{
    LONG lRet;
    HKEY hKeyRoot = NULL;

    if (m_fRegistryRead)
    {
        goto done;
    }
    
    lRet = RegOpenKeyEx(HKEY_CURRENT_USER, _T("Software\\Microsoft\\Internet Explorer\\Main"), 0, KEY_READ, &hKeyRoot);
    if (ERROR_SUCCESS != lRet)
    {
        TraceTag((tagError, "CTIMEBodyElement::ReadRegistry, couldn't open Key for registry settings"));
        goto done;
    }

    Assert(NULL != hKeyRoot);

    IsValueTrue(hKeyRoot, _T("Display Inline Images"), m_fShowImages);

    IsValueTrue(hKeyRoot, _T("Display Inline Videos"), m_fPlayVideo);

    IsValueTrue(hKeyRoot, _T("Play_Background_Sounds"), m_fPlayAudio);

    IsValueTrue(hKeyRoot, _T("Play_Animations"), m_fPlayAnimations);



    m_fRegistryRead = true;
done:
    if (hKeyRoot)
    {
        RegCloseKey(hKeyRoot);
    }

    fPlayVideo = m_fPlayVideo;
    fShowImages = m_fShowImages;
    fPlayAudio = m_fPlayAudio;
    fPlayAnimations = m_fPlayAnimations;
    return;
}

//+-----------------------------------------------------------------------
//
//  Member:    IsValueTrue
//
//  Overview:  Read a given value from the opened key
//
//  Arguments: hKeyRoot     Key to read from
//             pchSubKey    value to read out
//             fTrue        [out] true or false value
//
//  Returns:   void
//
//------------------------------------------------------------------------
void
CTIMEBodyElement::IsValueTrue(HKEY hKeyRoot, TCHAR * pchSubKey, bool & fTrue)
{
    DWORD dwSize = MAX_REG_VALUE_LENGTH;
    DWORD dwType;
    BYTE bDataBuf[MAX_REG_VALUE_LENGTH];
    LONG lRet;

    Assert(NULL != hKeyRoot);

    lRet = RegQueryValueEx(hKeyRoot, pchSubKey, 0, &dwType, bDataBuf, &dwSize);
    if (ERROR_SUCCESS != lRet)
    {
        TraceTag((tagTimeBodyElm, "CTIMEBodyElement::IsValueTrue failedRegQueryValueEx"));
        goto done;
    }

    if (REG_DWORD == dwType)
    {
        fTrue = (*(DWORD*)bDataBuf != 0);
    }
    else if (REG_SZ == dwType)
    {
        TCHAR ch = (TCHAR)(*bDataBuf);

        if (_T('1') == ch ||
            _T('y') == ch ||
            _T('Y') == ch)
        {
            fTrue = true;
        }
        else
        {
            fTrue = false;
        }
    }
    else if (REG_BINARY == dwType)
    {
        fTrue = (*(BYTE*)bDataBuf != 0);
    }
    
done:
    return;
}

//*****************************************************************************

void
CTIMEBodyElement::UpdateAnimations (void)
{
    TraceTag((tagTimeBodyElm, "CTIMEBodyElement(%p)::UpdateAnimations()", 
        this));

    ComposerSiteList listCompSites;

    // Make sure we can remove composer sites as we see fit.
    for (ComposerSiteList::iterator i = m_compsites.begin(); 
         i != m_compsites.end(); i++)
    {
        IGNORE_RETURN((*i)->AddRef());
        listCompSites.push_back(*i);
    }

    for (i = listCompSites.begin(); i != listCompSites.end(); i++)
    {
        IGNORE_RETURN((*i)->UpdateAnimations());
    }

    for (i = listCompSites.begin(); i != listCompSites.end(); i++)
    {
        IGNORE_RETURN((*i)->Release());
    }
    listCompSites.clear();

    return;
} // CTIMEBodyElement::UpdateAnimations

//*****************************************************************************


STDMETHODIMP
CTIMEBodyElement::Load(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog)
{
    HRESULT hr = THR(::TimeLoad(this, CTIMEBodyElement::PersistenceMap, pPropBag, pErrorLog));
    if (FAILED(hr))
    { 
        goto done;
    }

    hr = THR(CTIMEElementBase::Load(pPropBag, pErrorLog)); 
done:
    return hr;
}

STDMETHODIMP
CTIMEBodyElement::Save(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    HRESULT hr = THR(::TimeSave(this, CTIMEBodyElement::PersistenceMap, pPropBag, fClearDirty, fSaveAllProperties));
    if (FAILED(hr))
    { 
        goto done;
    }

    hr = THR(CTIMEElementBase::Save(pPropBag, fClearDirty, fSaveAllProperties));
done:
    return hr;
}

//+-----------------------------------------------------------------------------
//
//  Member: AddInternalEventSink, ITIMEInternalEventGenerator
//
//  Overview:  AddRef's objects into a sorted list based on time to fire events.
//
//  Arguments: pSink    pointer to object to receive event
//             dblTime  Body time when passed event should be fired
//
//  Returns:   S_OK if added to list, otherwise E_OUTOFMEMORY
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMEBodyElement::AddInternalEventSink(ITIMEInternalEventSink * pSink, double dblTime)
{
    HRESULT hr = S_OK;

    bool fInserted = false;

    CInternalEventNode * pNode = NULL;
    
    std::list<CInternalEventNode * >::iterator iter;

    if (NULL == pSink)
    {
        hr = E_INVALIDARG;
        goto done;
    }
    
    pNode = new CInternalEventNode(pSink, dblTime);
    if (NULL == pNode)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    
    iter = m_listInternalEvent.begin();
    while (iter != m_listInternalEvent.end())
    {                
        double dblIterTime = (*iter)->GetTime();

        if (dblTime < dblIterTime)
        {
            // insert before
            m_listInternalEvent.insert(iter, pNode);
            fInserted = true;
            break;
        }
        iter++;
    }
    
    if (!fInserted)
    {
        // place at end
        m_listInternalEvent.insert(iter, pNode);
    }    

    hr = S_OK;

done:

    return hr; //lint !e429
}
//  Member: AddInternalEventSink, ITIMEInternalEventGenerator


//+-----------------------------------------------------------------------------
//
//  Member: RemoveInternalEventSink, ITIMEInternalEventGenerator
//
//  Overview:  Removes object from list of events to fire
//
//  Arguments: pSink    pointer to object to be removed
//             dblTime  Body time when passed event should be fired
//
//  Returns:   S_OK if added to list, otherwise E_OUTOFMEMORY
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMEBodyElement::RemoveInternalEventSink(ITIMEInternalEventSink * pSink)
{
    HRESULT hr = S_OK;

    std::list<CInternalEventNode * >::iterator iter;
    if (m_listInternalEvent.size() == 0)
    {
        goto done;
    }

    iter = m_listInternalEvent.begin();
    while (iter != m_listInternalEvent.end())
    {
        ITIMEInternalEventSink * pIterSink = NULL;
        pIterSink = (*iter)->GetSink();
        if (pIterSink == pSink)
        {
            delete (*iter);
            m_listInternalEvent.erase(iter);
            hr = S_OK;
            goto done;
        }
        iter++;
    }

    // element wasn't found in list
    hr = S_FALSE;

done:

    return hr;
}
//  Member: RemoveInternalEventSink, ITIMEInternalEventGenerator


//+-----------------------------------------------------------------------------
//
//  Member: EvaluateTransitionTarget, ITIMETransitionDependencyMgr
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMEBodyElement::EvaluateTransitionTarget(
                                        IUnknown *  punkTransitionTarget,
                                        void *      pvTransitionDependencyMgr)
{
    Assert(punkTransitionTarget);
    Assert(pvTransitionDependencyMgr);

    CTransitionDependencyManager * pTransitionDependencyMgr
        = (CTransitionDependencyManager *)pvTransitionDependencyMgr;

    return m_TransitionDependencyMgr.EvaluateTransitionTarget(
                                                    punkTransitionTarget,
                                                    *pTransitionDependencyMgr);
}
//  Member: EvaluateTransitionTarget, ITIMETransitionDependencyMgr


//+-----------------------------------------------------------------------------
//
//  Member: RegisterElementForSync
//
//------------------------------------------------------------------------------
void
CTIMEBodyElement::RegisterElementForSync(CTIMEElementBase *pelem)
{
    m_syncList.push_back(pelem);
}
//  Member: RegisterElementForSync


void
CTIMEBodyElement::UnRegisterElementForSync(CTIMEElementBase *pelem)
{
    UpdateSyncList::iterator iter;

    for (iter = m_syncList.begin();iter != m_syncList.end(); iter++)
    {
        if(pelem == *iter)
        {
            m_syncList.erase(iter);
            goto done;
        }
    }
done:
    return;
}

void
CTIMEBodyElement::UpdateSyncNotify()
{
    UpdateSyncList::iterator iter;

    for (iter = m_syncList.begin();iter != m_syncList.end(); iter++)
    {
        (*iter)->UpdateSync();
    }
}

HRESULT WINAPI
CTIMEBodyElement::BodyBaseInternalQueryInterface(CTIMEBodyElement* pThis,
                                             void * pv,
                                             const _ATL_INTMAP_ENTRY* pEntries,
                                             REFIID iid,
                                             void** ppvObject)
{
    if (InlineIsEqualGUID(iid, __uuidof(TIMEBodyElementBaseGUID))) 
    {
        *ppvObject = pThis;
        return S_OK;
    }
    
    return BaseInternalQueryInterface(pThis, pv, pEntries, iid, ppvObject);
}

bool
CTIMEBodyElement::IsBody() const
{
    if(m_spBodyElemExternal.p == NULL)
    {
        return true;
    }
    else
    {
        return false;
    }
}

bool
CTIMEBodyElement::IsEmptyBody() const
{
    if(m_spBodyElemExternal.p != NULL)
    {
        return true;
    }
    else
    {
        return false;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\tags\bodyelm.h ===
//------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1998
//
//  File: src\time\src\bodyelm.h
//
//  Contents: TIME Body behavior
//
//------------------------------------------------------------------------------


#pragma once

#ifndef _BODYELM_H
#define _BODYELM_H

#include "timeelmimpl.h"
#include "mmutil.h"
#include "timebvr\mmtimeline.h"
#include "timebvr\mmplayer.h"
#include "timebvr\transdepend.h"
#include "MediaPrivate.h"

class __declspec(uuid("7f94c186-69bb-43c8-bc43-2787f18e4631"))
TIMEBodyElementBaseGUID {}; //lint !e753

//+-----------------------------------------------------------------------------
//
// CTIMEBodyElement
//
//------------------------------------------------------------------------------

typedef std::list<IAnimationComposerSiteSink*> ComposerSiteList;
typedef std::list<CTIMEElementBase*> UpdateSyncList;

class CInternalEventNode;    

class
ATL_NO_VTABLE
__declspec(uuid("efbad7f8-3f94-11d2-b948-00c04fa32195")) 
CTIMEBodyElement :
    public CTIMEElementImpl<ITIMEBodyElement, &IID_ITIMEBodyElement>,
    public CComCoClass<CTIMEBodyElement, &__uuidof(CTIMEBodyElement)>,
    public ISupportErrorInfoImpl<&IID_ITIMEBodyElement>,
    public IConnectionPointContainerImpl<CTIMEBodyElement>,
    public IPersistPropertyBag2,
    public IPropertyNotifySinkCP<CTIMEBodyElement>,
    public IAnimationRoot,
    public ITIMEInternalEventGenerator,
    public ITIMETransitionDependencyMgr
{
public:

    CTIMEBodyElement();
    virtual ~CTIMEBodyElement();
    
#if DBG
    const _TCHAR * GetName() { return __T("CTIMEBodyElement"); }
#endif

    // IElementBehavior methods.

    STDMETHOD(Init)(IElementBehaviorSite * pBvrSite);
    STDMETHOD(Detach)();

    // IPersistPropertyBag2 methods.

    STDMETHOD(GetClassID)(CLSID* pclsid) { return CTIMEElementBase::GetClassID(pclsid); }
    STDMETHOD(InitNew)() { return CTIMEElementBase::InitNew(); }
    STDMETHOD(IsDirty)() { return S_OK; }
    STDMETHOD(Load)(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog);
    STDMETHOD(Save)(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

    // IAnimationRoot methods.

    STDMETHOD(RegisterComposerSite) (IUnknown *piunkComposerSite);
    STDMETHOD(UnregisterComposerSite) (IUnknown *piunkComposerSite);

    // ITIMEInternalEventGenerator methods.

    STDMETHOD(AddInternalEventSink)(ITIMEInternalEventSink * pSink, double dblTime);
    STDMETHOD(RemoveInternalEventSink)(ITIMEInternalEventSink * pSink);
    
    // ITIMETransitionDependencyMgr methods.

    STDMETHOD(EvaluateTransitionTarget)(IUnknown *  punkTransitionTarget,
                                        void *      pvTransitionDependencyMgr);

    // Event Handlers

    virtual void OnLoad();
    virtual void OnUnload();
    virtual void UpdateAnimations();
    virtual void OnTick();

    // QI Map

    BEGIN_COM_MAP(CTIMEBodyElement)
        COM_INTERFACE_ENTRY(ITIMEBodyElement)
        COM_INTERFACE_ENTRY(ITIMEElement)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IAnimationRoot)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
        COM_INTERFACE_ENTRY(IPersistPropertyBag2)
        COM_INTERFACE_ENTRY(ITIMETransitionDependencyMgr)
        COM_INTERFACE_ENTRY_CHAIN(CBaseBvr)
    END_COM_MAP();

    // Connection Point to allow IPropertyNotifySink

    BEGIN_CONNECTION_POINT_MAP(CTIMEBodyElement)
        CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
    END_CONNECTION_POINT_MAP();

    // This must be in the derived class and not the base class since
    // the typecast down to the base class messes things up

    static inline HRESULT WINAPI
    InternalQueryInterface(CTIMEBodyElement* pThis,
                           const _ATL_INTMAP_ENTRY* pEntries,
                           REFIID iid,
                           void** ppvObject);
    static HRESULT WINAPI
    BodyBaseInternalQueryInterface(CTIMEBodyElement* pThis,
                               void * pv,
                               const _ATL_INTMAP_ENTRY* pEntries,
                               REFIID iid,
                               void** ppvObject);

    // Needed by CBvrBase

    void *          GetInstance() { return (ITIMEBodyElement *) this; }
    HRESULT         GetTypeInfo(ITypeInfo ** ppInfo) 
                    { 
                        return GetTI(GetUserDefaultLCID(), ppInfo); 
                    }

    // Misc. methods

    virtual HRESULT InitTimeline();
    MMPlayer &      GetPlayer() { return m_player; }
    virtual bool    IsGroup() const { return true; }
    virtual bool    IsBody() const;
    virtual bool    IsEmptyBody() const;
    float           GetDefaultSyncTolerance() 
                    { 
                        return DEFAULT_SYNC_TOLERANCE_S; 
                    }
    TOKEN           GetDefaultSyncBehavior() { return CANSLIP_TOKEN; }

    bool            IsDocumentStarted();
    bool            IsRootStarted() const { return m_fStartRoot; }
    void            ReadRegistryMediaSettings(bool & fPlayVideo, 
                                              bool & fShowImages, 
                                              bool & fPlayAudio, 
                                              bool & fPlayAnimations);

    void            RegisterElementForSync(CTIMEElementBase * pelem);
    void            UnRegisterElementForSync(CTIMEElementBase * pelem);
    void            UpdateSyncNotify();

    bool            IsPrintMedia();
    bool            IsBodyLoading() { return m_bIsLoading; };

    CTransitionDependencyManager * GetTransitionDependencyMgr();

protected:

    //+-------------------------------------------------------------------------
    //
    // Protected Methods
    //
    //--------------------------------------------------------------------------

    //
    // Persistence and Notification helpers
    //

    virtual HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP);

    //
    // Animation stuff
    //

    void DetachComposerSites(void);
    bool InsideSiteDetach(void) { return m_bInSiteDetach; }
    bool HaveAnimationsRegistered (void);

    //
    // Misc. methods
    //

    HRESULT Error();
    bool    QueryPlayOnStart (void);
    virtual HRESULT StartRootTime(MMTimeline * tl);
    virtual void StopRootTime(MMTimeline * tl);
    virtual bool NeedSyncCB() { return true; }

    //+-------------------------------------------------------------------------
    //
    // Protected Data
    //
    //--------------------------------------------------------------------------

    // Attributes

    // Internal variables
    MMPlayer                m_player;
    DWORD                   m_bodyPropertyAccesFlags;
    static DWORD            ms_dwNumBodyElems;
    ComposerSiteList        m_compsites;
    bool                    m_bInSiteDetach;
    UpdateSyncList          m_syncList;

private:

    //+-------------------------------------------------------------------------
    //
    // Private methods
    //
    //--------------------------------------------------------------------------
    void IsValueTrue(HKEY hKeyRoot, TCHAR * pchSubKey, bool & fTrue);

    //+-------------------------------------------------------------------------
    //
    // Private Data
    //
    //--------------------------------------------------------------------------

    bool                            m_fRegistryRead;
    bool                            m_fPlayVideo;
    bool                            m_fShowImages;
    bool                            m_fStartRoot;
    bool                            m_fPlayAudio;
    bool                            m_fPlayAnimations;
    bool                            m_bIsLoading;

    CTransitionDependencyManager    m_TransitionDependencyMgr;

    static TIME_PERSISTENCE_MAP     PersistenceMap[];

    std::list<CInternalEventNode*>  m_listInternalEvent;

}; 
// CTIMEBodyElement


//+-----------------------------------------------------------------------------
//  CTIMEBodyElement inline methods
//
//  (Note: as a general guideline, single line functions belong in the class declaration)
//
//------------------------------------------------------------------------------


inline 
HRESULT WINAPI
CTIMEBodyElement::InternalQueryInterface(CTIMEBodyElement* pThis,
                                         const _ATL_INTMAP_ENTRY* pEntries,
                                         REFIID iid,
                                         void** ppvObject)
{ 
    return BodyBaseInternalQueryInterface(pThis,
                                        (void *) pThis,
                                        pEntries,
                                        iid,
                                        ppvObject); 
}



#endif /* _BODYELM_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\tags\factory.cpp ===
/*******************************************************************************
 *                                                                              
 * Copyright (c) 1998 Microsoft Corporation
 *
 * Abstract:
 *
 *******************************************************************************/

#include "headers.h"
#include "factory.h"
#include "..\timebvr\timeelm.h"
#include "bodyelm.h"
#include "..\media\mediaelm.h"
#include "..\anim\animelm.h"
#include "..\anim\animmotion.h"
#include "..\anim\animset.h"
#include "..\anim\animcolor.h"
#include "..\anim\animfilter.h"

DeclareTag(tagFactory, "TIME", "CTIMEFactory methods");

CTIMEFactory::CTIMEFactory()
: m_dwSafety(0)
{
    TraceTag((tagFactory,
              "CTIMEFactory(%lx)::CTIMEFactory()",
              this));
}

CTIMEFactory::~CTIMEFactory()
{
    TraceTag((tagFactory,
              "CTIMEFactory(%lx)::~CTIMEFactory()",
              this));
}

STDMETHODIMP 
CTIMEFactory::GetInterfaceSafetyOptions(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
{
    if (pdwSupportedOptions == NULL || pdwEnabledOptions == NULL)
        return E_POINTER;
    HRESULT hr = S_OK;

    if (riid == IID_IDispatch)
    {
        *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
        *pdwEnabledOptions = m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_CALLER;
    }
    else if (riid == IID_IPersistPropertyBag2 )
    {
        *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_DATA;
        *pdwEnabledOptions = m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_DATA;
    }
    else
    {
        *pdwSupportedOptions = 0;
        *pdwEnabledOptions = 0;
        hr = E_NOINTERFACE;
    }
    return hr;
}

STDMETHODIMP
CTIMEFactory::SetInterfaceSafetyOptions(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
{       
        // If we're being asked to set our safe for scripting or
        // safe for initialization options then oblige
        if (riid == IID_IDispatch || riid == IID_IPersistPropertyBag2 )
        {
                // Store our current safety level to return in GetInterfaceSafetyOptions
                m_dwSafety = dwEnabledOptions & dwOptionSetMask;
                return S_OK;
        }

        return E_NOINTERFACE;
}

//+-----------------------------------------------------------
//
// Member:  behavior desc map macros
//
//------------------------------------------------------------

typedef HRESULT FN_CREATEINSTANCE (IElementBehavior ** ppBehavior);

struct BEHAVIOR_DESC
{
    LPCWSTR                 pszTagName;
    FN_CREATEINSTANCE *     pfnCreateInstance;
};

#if 0
// This template should work but for some reason I cannot initialize
// the variable in the struct.  It would make everything a 1 step
// process

template <class className>
HRESULT ElmBvrCreateInstance(IElementBehavior ** ppBehavior)
{
    HRESULT                 hr;
    CComObject<className> * pInstance;
    
    hr = THR(CComObject<className>::CreateInstance(&pInstance));
    if (S_OK != hr)                                                 
    {                                                               
        goto done;                                                  
    }                                                               
                                                                        
    hr = THR(pInstance->QueryInterface(IID_IElementBehavior,        
                                       (void**) ppBehavior));       
    if (S_OK != hr)                                                 
    {                                                               
        goto done;                                                  
    }                                                               
                                                                        
    hr = S_OK;                                                      
  done:                                                               
    if (S_OK != hr)                                                 
    {                                                               
        delete pInstance;                                           
    }
    
    return hr;                                                      
}                                                                   
#endif

#define BEHAVIOR_CREATEINSTANCE(className) className##_CreateInstance

#define DECLARE_BEHAVIOR(className)                                     \
    HRESULT BEHAVIOR_CREATEINSTANCE(className)(IElementBehavior ** ppBehavior)  \
    {                                                                   \
        HRESULT                 hr;                                     \
        CComObject<className> * pInstance;                              \
                                                                        \
        hr = THR(CComObject<className>::CreateInstance(&pInstance));    \
        if (S_OK != hr)                                                 \
        {                                                               \
            goto done;                                                  \
        }                                                               \
                                                                        \
        hr = THR(pInstance->QueryInterface(IID_IElementBehavior,        \
                                           (void**) ppBehavior));       \
        if (S_OK != hr)                                                 \
        {                                                               \
            goto done;                                                  \
        }                                                               \
                                                                        \
        hr = S_OK;                                                      \
    done:                                                               \
        if (S_OK != hr)                                                 \
        {                                                               \
            delete pInstance;                                           \
        }                                                               \
        return hr;                                                      \
    }                                                                   \


#define BEGIN_BEHAVIORS_MAP(x)                         static BEHAVIOR_DESC x[] = {
#define END_BEHAVIORS_MAP()                            { NULL, NULL }}
#define BEHAVIOR_ENTRY(className, tagName)             { tagName, BEHAVIOR_CREATEINSTANCE(className)}

//+-----------------------------------------------------------
//
//  Behaviors map
//
//  To add a new entry: execute steps 1 and 2
//
//------------------------------------------------------------

//
// STEP 1.
//

DECLARE_BEHAVIOR(CTIMEElement);
DECLARE_BEHAVIOR(CTIMEBodyElement);
DECLARE_BEHAVIOR(CTIMEMediaElement);
DECLARE_BEHAVIOR(CTIMEAnimationElement);
DECLARE_BEHAVIOR(CTIMESetAnimation);
DECLARE_BEHAVIOR(CTIMEColorAnimation);
DECLARE_BEHAVIOR(CTIMEMotionAnimation);
DECLARE_BEHAVIOR(CTIMEFilterAnimation);
    
//
// STEP 2.
//

BEGIN_BEHAVIORS_MAP(_BehaviorDescMap)

    //              className               tagName
    //              =========               =======
    BEHAVIOR_ENTRY( CTIMEElement,           WZ_PAR              ),
    BEHAVIOR_ENTRY( CTIMEElement,           WZ_SEQUENCE         ),
    BEHAVIOR_ENTRY( CTIMEElement,           WZ_EXCL             ),
    BEHAVIOR_ENTRY( CTIMEElement,           WZ_SWITCH           ),

    BEHAVIOR_ENTRY( CTIMEMediaElement,      WZ_REF              ),
    BEHAVIOR_ENTRY( CTIMEMediaElement,      WZ_MEDIA            ),
    BEHAVIOR_ENTRY( CTIMEMediaElement,      WZ_IMG              ),
    BEHAVIOR_ENTRY( CTIMEMediaElement,      WZ_AUDIO            ),
    BEHAVIOR_ENTRY( CTIMEMediaElement,      WZ_VIDEO            ),
    BEHAVIOR_ENTRY( CTIMEMediaElement,      WZ_ANIMATION        ),

    BEHAVIOR_ENTRY( CTIMEAnimationElement,  WZ_ANIMATE          ),
    BEHAVIOR_ENTRY( CTIMESetAnimation,      WZ_SET              ),
    BEHAVIOR_ENTRY( CTIMEColorAnimation,    WZ_COLORANIM        ),
    BEHAVIOR_ENTRY( CTIMEMotionAnimation,   WZ_MOTIONANIM       ),
    BEHAVIOR_ENTRY( CTIMEFilterAnimation,   WZ_TRANSITIONFILTER ),
    
END_BEHAVIORS_MAP();

bool
IsBodyElement(IHTMLElement * pElm)
{
    HRESULT hr;
    CComPtr<IHTMLBodyElement> spBody;

    hr = pElm->QueryInterface(IID_IHTMLBodyElement, (void**)&spBody);

    // For some reason this supposedly can succeed and return NULL
    return (S_OK == hr);
}    


bool HasBody(IHTMLElement *spElement)
{
    HRESULT hr = S_OK;
    bool bReturn = false;
    CComPtr <IHTMLElement> pParent = spElement;
    CComPtr <IHTMLElement> pNext;

    while (pParent != NULL)
    {        
        if (IsBodyElement(pParent))
        {
            bReturn = true;
            goto done;
        }        
        hr = THR(pParent->get_parentElement(&pNext));
        if (FAILED(hr))
        {
            goto done;
        }   
        pParent.Release();
        pParent = pNext;
        pNext.Release();
    }

    bReturn = false;

  done:

    return bReturn;
}


HRESULT
LookupTag(IHTMLElement * pElm,
          IElementBehavior ** ppBehavior)
{
    HRESULT         hr;
    CComBSTR        bstrTagName;
    CComBSTR        bstrTagURNName;
    CComBSTR        bstrScopeName;
    BEHAVIOR_DESC   *pDesc;

    //
    // Get the tag name
    //
    
    {
        hr = THR(pElm->get_tagName(&bstrTagName));
        if (FAILED(hr))
        {
            goto done;
        }

        if (bstrTagName == NULL)
        {
            hr = E_UNEXPECTED;
            goto done;
        }
    }

    //
    // Get the tag's URN and scope.
    //

    {
        CComPtr<IHTMLElement2> spElm2;
        hr = THR(pElm->QueryInterface(IID_IHTMLElement2, 
                                      (void **) &spElm2));
        if (SUCCEEDED(hr))
        {
            hr = THR(spElm2->get_tagUrn(&bstrTagURNName));       
            if (FAILED(hr))
            {
                goto done;
            }
            
            hr = THR(spElm2->get_scopeName(&bstrScopeName));       
            if (FAILED(hr))
            {
                goto done;
            }
        }
        else
        {
            goto done;
        }
    }
       
    // Detect whether or not to consult our element behavior factory list.
    // If this tag has no scope name, or the scope is the default
    // then bail out.
    // If there's a URN associated with this tag, and it is not 
    // ours, bail out.
    if ((bstrScopeName == NULL) ||
        (StrCmpIW(bstrScopeName, WZ_DEFAULT_SCOPE_NAME) == 0) ||
        ((bstrTagURNName != NULL) &&
         (StrCmpIW(bstrTagURNName, WZ_TIME_TAG_URN) != 0)))
    {
        hr = S_FALSE;
        goto done;
    }

    //
    // lookup
    //
        
    for (pDesc = _BehaviorDescMap; pDesc->pszTagName; pDesc++)
    {
        if (0 == StrCmpIW(bstrTagName, pDesc->pszTagName))
        {
            hr = THR(pDesc->pfnCreateInstance(ppBehavior));
            goto done;
        }
    }

    hr = S_FALSE;
    
  done:

    RRETURN1(hr, S_FALSE);
}

//+-----------------------------------------------------------
//
// Member:      CTIMEFactory::FindBehavior
//
//------------------------------------------------------------

STDMETHODIMP
CTIMEFactory::FindBehavior(LPOLESTR pszName,
                           LPOLESTR pszUrl,
                           IElementBehaviorSite * pSite,
                           IElementBehavior ** ppBehavior)
{
    TraceTag((tagFactory,
              "CTIMEFactory(%lx)::FindBehavior(%ls, %ls, %#x)",
              this, pszName, pszUrl, pSite));

    HRESULT               hr;
    CComPtr<IHTMLElement> spElement;
    CComBSTR              sBSTR;
    
    CHECK_RETURN_SET_NULL(ppBehavior);

    //
    // Get the element
    //
    
    hr = THR(pSite->GetElement(&spElement));
    if (FAILED(hr))
    {
        goto done;
    }


    //check for body element on page.  If no body then bail.
    if (!HasBody(spElement))
    {
        hr = E_FAIL;
        goto done;
    }


    if (::IsElementPriorityClass(spElement))
    {
        hr = E_FAIL;
        goto done;
    }
    if (::IsElementTransition(spElement))
    {
        hr = E_FAIL;
        goto done;
    }

    //
    // Now create the correct behavior
    //
    
    if (IsBodyElement(spElement))
    {
        hr = THR(BEHAVIOR_CREATEINSTANCE(CTIMEBodyElement)(ppBehavior));
        goto done;
    }
    else
    {
        hr = THR(LookupTag(spElement, ppBehavior));

        // If we fail or return success then we are finished
        // If it returns S_FALSE it means the lookup failed
        if (S_FALSE != hr)
        {
            goto done;
        }
    }
    
    // Just create a normal behavior
    hr = THR(BEHAVIOR_CREATEINSTANCE(CTIMEElement)(ppBehavior));
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

//+-----------------------------------------------------------
//
// Member:      CTIMEFactory::Create, per IElementNamespaceFactory
//
//------------------------------------------------------------

STDMETHODIMP
CTIMEFactory::Create(IElementNamespace * pNamespace)
{
    TraceTag((tagFactory,
              "CTIMEFactory(%lx)::Create(%#x)",
              this,
              pNamespace));

    HRESULT             hr;
    BEHAVIOR_DESC *     pDesc;

    for (pDesc = _BehaviorDescMap; pDesc->pszTagName; pDesc++)
    {
        BSTR bstrTagName = SysAllocString(pDesc->pszTagName);

        hr = THR(pNamespace->AddTag(bstrTagName, 0));

        SysFreeString(bstrTagName);

        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timebvr\collect.cpp ===
//************************************************************
//
// Filename:    collect.cpp
//
// Created:     09/25/98
//
// Author:      twillie
//
//              Collection implementation.
//
//************************************************************

#include "headers.h"
#include "collect.h"

// Suppress new warning about NEW without corresponding DELETE
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )

#define TYPELIB_VERSION_MAJOR 1
#define TYPELIB_VERSION_MINOR 0

#define FL_UNSIGNED   1       /* wcstoul called */
#define FL_NEG        2       /* negative sign found */
#define FL_OVERFLOW   4       /* overflow occured */
#define FL_READDIGIT  8       /* we've read at least one correct digit */

#define LONG_MIN    (-2147483647L - 1) /* minimum (signed) long value */
#define LONG_MAX      2147483647L   /* maximum (signed) long value */
#define ULONG_MAX     0xffffffffUL  /* maximum unsigned long value */

//
// local prototypes
//
static HRESULT PropertyStringToLong(const WCHAR   *nptr,
                                    WCHAR        **endptr,
                                    int            ibase,
                                    int            flags,
                                    unsigned long *plNumber);


DeclareTag(tagTimeCollection, "TIME: Behavior", "CTIMEElementCollection methods")
DeclareTag(tagCollectionCache, "TIME: Behavior", "CCollectionCache methods")


//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    check to see if string is number
//************************************************************

static HRESULT
ttol_with_error(const WCHAR *pStr, long *plValue)
{
    // Always do base 10 regardless of contents of
    return PropertyStringToLong(pStr, NULL, 10, 0, (unsigned long *)plValue);
} // ttol_with_error

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    try to convert string to number
//************************************************************
static HRESULT
PropertyStringToLong(const WCHAR   *nptr,
                     WCHAR        **endptr,
                     int            ibase,
                     int            flags,
                     unsigned long *plNumber)
{
    const WCHAR *p;
    WCHAR c;
    unsigned long number;
    unsigned digval;
    unsigned long maxval;

    *plNumber = 0;                  /* on error result is 0 */

    p = nptr;                       /* p is our scanning pointer */
    number = 0;                     /* start with zero */

    c = *p++;                       /* read char */
    while (_istspace(c))
        c = *p++;                   /* skip whitespace */

    if (c == '-')
    {
        flags |= FL_NEG;        /* remember minus sign */
        c = *p++;
    }
    else if (c == '+')
        c = *p++;               /* skip sign */

    if (ibase < 0 || ibase == 1 || ibase > 36)
    {
        /* bad base! */
        if (endptr)
            /* store beginning of string in endptr */
            *endptr = (WCHAR *)nptr;
        return E_POINTER;              /* return 0 */
    }
    else if (ibase == 0)
    {
        /* determine base free-lance, based on first two chars of
           string */
        if (c != L'0')
            ibase = 10;
        else if (*p == L'x' || *p == L'X')
            ibase = 16;
        else
            ibase = 8;
    }

    if (ibase == 16)
    {
        /* we might have 0x in front of number; remove if there */
        if (c == L'0' && (*p == L'x' || *p == L'X'))
        {
            ++p;
            c = *p++;       /* advance past prefix */
        }
    }

    /* if our number exceeds this, we will overflow on multiply */
    maxval = ULONG_MAX / ibase; //lint !e573


    for (;;)
    {      /* exit in middle of loop */
        /* convert c to value */
        if (IsCharAlphaNumeric(c))
            digval = c - L'0';
        else if (IsCharAlpha(c))
        {
            if (ibase > 10)
            {
                digval = (unsigned) PtrToUlong(CharUpper((LPTSTR)(LONG_PTR)c)) - L'A' + 10;
            }
            else
            {
                return E_INVALIDARG;              /* return 0 */
            }
        }
        else
            break;

        if (digval >= (unsigned)ibase)
            break;          /* exit loop if bad digit found */

        /* record the fact we have read one digit */
        flags |= FL_READDIGIT;

        /* we now need to compute number = number * base + digval,
           but we need to know if overflow occured.  This requires
           a tricky pre-check. */

        if (number < maxval || (number == maxval &&
            (unsigned long)digval <= ULONG_MAX % ibase)) //lint !e573
        {
            /* we won't overflow, go ahead and multiply */
            number = number * ibase + digval;
        }
        else
        {
            /* we would have overflowed -- set the overflow flag */
            flags |= FL_OVERFLOW;
        }

        c = *p++;               /* read next digit */
    }

    --p;                            /* point to place that stopped scan */

    if (!(flags & FL_READDIGIT))
    {
        number = 0L;                        /* return 0 */

        /* no number there; return 0 and point to beginning of
           string */
        if (endptr)
            /* store beginning of string in endptr later on */
            p = nptr;

        return E_INVALIDARG;            // Return error not a number
    }
    else if ((flags & FL_OVERFLOW) ||
              (!(flags & FL_UNSIGNED) &&
                (((flags & FL_NEG) && (number > -LONG_MIN)) || //lint !e648 !e574
                  (!(flags & FL_NEG) && (number > LONG_MAX)))))
    {
        /* overflow or signed overflow occurred */
        //errno = ERANGE;
        if (flags & FL_UNSIGNED)
            number = ULONG_MAX;
        else if (flags & FL_NEG)
            number = (unsigned long)(-LONG_MIN); //lint !e648
        else
            number = LONG_MAX;
    }

    if (endptr != NULL)
        /* store pointer to char that stopped the scan */
        *endptr = (WCHAR *)p;

    if (flags & FL_NEG)
        /* negate result if there was a neg sign */
        number = (unsigned long)(-(long)number);

    *plNumber = number;
    return S_OK;                  /* done. */
} // PropertyStringToLong

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    constructor
//************************************************************

CTIMEElementCollection::CTIMEElementCollection(CCollectionCache *pCollectionCache, long lIndex) :
    m_pCollectionCache(pCollectionCache),
    m_lCollectionIndex(lIndex),
    m_pInfo(NULL),
    m_cRef(0)
{
} // CTIMEElementCollection

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    destructor
//************************************************************

CTIMEElementCollection::~CTIMEElementCollection()
{
    ReleaseInterface(m_pInfo);
    m_pCollectionCache = NULL;
} // ~CTIMEElementCollection

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:        AddRef
//************************************************************

STDMETHODIMP_(ULONG) CTIMEElementCollection::AddRef(void)
{
    return m_cRef++;
} // AddRef

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:        Release
//************************************************************

STDMETHODIMP_(ULONG) CTIMEElementCollection::Release(void)
{
    if (m_cRef == 0)
    {
        TraceTag((tagError, "CTIMEElementCollection::Release - YIKES! Trying to decrement when Ref count is zero"));
        return m_cRef;
    }

    if (0 != --m_cRef)
    {
        return m_cRef;
    }

    delete this;
    return 0;
} // Release

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:        QI
//************************************************************

STDMETHODIMP
CTIMEElementCollection::QueryInterface(REFIID riid, void **ppv)
{
    *ppv = NULL;
    if (IsEqualIID(riid, IID_IUnknown))
    {
        // SAFECAST macro doesn't work with IUnknown
        *ppv = this;
    }
    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppv = SAFECAST((ITIMEElementCollection*)this, IDispatch*);
    }
    else if (IsEqualIID(riid, IID_IDispatchEx))
    {
        *ppv = SAFECAST(this, IDispatchEx*);
    }
    else if (IsEqualIID(riid, IID_ITIMEElementCollection))
    {
        *ppv = SAFECAST(this, ITIMEElementCollection*);
    }

    if (NULL != *ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
} // QueryInterface

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    IDispatch - GetTypeInfoCount
//************************************************************

STDMETHODIMP
CTIMEElementCollection::GetTypeInfoCount(UINT FAR *pctinfo)
{
    if (pctinfo == NULL)
    {
        TraceTag((tagError, "CTIMEElementCollection::GetTypeInfoCount - Invalid param (UINT FAR *)"));
        return TIMESetLastError(E_POINTER);
    }

    *pctinfo = 1;
    return S_OK;
} // GetTypeInfoCount

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    IDispatch - GetTypeInfo
//************************************************************

STDMETHODIMP
CTIMEElementCollection::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
{
    if (pptinfo == NULL)
    {
        TraceTag((tagError, "CTIMEElementCollection::GetTypeInfo - Invalid param (ITypeInfo**)"));
        return TIMESetLastError(E_POINTER);
    }

    return GetTI(pptinfo);
} // GetTypeInfo

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    IDispatch - GetIDsOfNames
//************************************************************

STDMETHODIMP
CTIMEElementCollection::GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames,
                                  UINT cNames, LCID lcid, DISPID FAR *rgdispid)
{
    // punt to IDispatchEx impl.
    return GetDispID(rgszNames[0], cNames, rgdispid);
} // GetIDsOfNames

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    IDispatch - Invoke
//************************************************************

STDMETHODIMP
CTIMEElementCollection::Invoke(DISPID dispidMember, REFIID iid, LCID lcid, WORD wFlags,
                           DISPPARAMS *pdispparams, VARIANT *pvarResult,
                           EXCEPINFO *pexcepinfo, UINT *pArg)
{
    // punt to IDispatchEx impl.
    return InvokeEx(dispidMember,
                    lcid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    NULL);
} // Invoke

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    IDispatchEx - InvokeEx
//************************************************************

STDMETHODIMP
CTIMEElementCollection::InvokeEx(DISPID            dispidMember,
                             LCID              lcid,
                             WORD              wFlags,
                             DISPPARAMS       *pdispparams,
                             VARIANT          *pvarResult,
                             EXCEPINFO        *pexcepinfo,
                             IServiceProvider *pSrvProvider)
{
    HRESULT hr;

    hr = m_pCollectionCache->InvokeEx(m_lCollectionIndex, dispidMember, lcid, wFlags,
                                      pdispparams, pvarResult, pexcepinfo, pSrvProvider);

    // if that failed, try typelib
    if (FAILED(hr))
    {
        ITypeInfo *pInfo;
        hr = GetTI(&pInfo);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CTIMEElementCollection::InvokeEx - GetTI() failed"));
            return TIMESetLastError(hr);
        }

        UINT* puArgErr = NULL;

        IDispatch *pDisp = NULL;
        hr = QueryInterface(IID_TO_PPV(IDispatch, &pDisp));
        if (FAILED(hr))
            return TIMESetLastError(hr);

        Assert(pInfo != NULL);

        hr = pInfo->Invoke(pDisp, dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
        ReleaseInterface(pInfo);
        ReleaseInterface(pDisp);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CTIMEElementCollection::InvokeEx - Invoke failed on Typelib"));
            return TIMESetLastError(hr);
        }
    }

    return hr;
} // InvokeEx

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    IDispatchEx - GetDispID
//************************************************************

STDMETHODIMP
CTIMEElementCollection::GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    HRESULT hr = m_pCollectionCache->GetDispID(m_lCollectionIndex, bstrName, grfdex, pid);

    // if we failed or found nothing, try typelib
    if ((FAILED(hr)) || (*pid == DISPID_UNKNOWN))
    {
        // have string, see if it's a member function/property in typelib
        ITypeInfo *pInfo;
        hr = GetTI(&pInfo);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CTIMEElementCollection::GetDispID - GetTI() failed"));
            return TIMESetLastError(hr);
        }

        Assert(pInfo != NULL);

        LPOLESTR rgszNames[1];
        rgszNames[0] = bstrName;

        hr = pInfo->GetIDsOfNames(rgszNames, 1, pid);
        ReleaseInterface(pInfo);
    }

    return hr;
} // GetDispID

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    IDispatchEx - deleteMemberByName
//************************************************************

STDMETHODIMP
CTIMEElementCollection::DeleteMemberByName(BSTR bstrName, DWORD grfdex)
{
    return TIMESetLastError(m_pCollectionCache->DeleteMemberByName(m_lCollectionIndex, bstrName, grfdex));
} // deleteMemberByName

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    IDispatchEx - deleteMemberByDispID
//************************************************************

STDMETHODIMP
CTIMEElementCollection::DeleteMemberByDispID(DISPID id)
{
    return TIMESetLastError(m_pCollectionCache->DeleteMemberByDispID(m_lCollectionIndex, id));
} // deleteMemberByDispID

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    IDispatchEx - GetMemberProperties
//************************************************************

STDMETHODIMP
CTIMEElementCollection::GetMemberProperties(DISPID id, DWORD grfdexFetch, DWORD *pgrfdex)
{
    return TIMESetLastError(m_pCollectionCache->GetMemberProperties(m_lCollectionIndex, id, grfdexFetch, pgrfdex));
} // GetMemberProperties

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    IDispatchEx - GetMemberName
//************************************************************

STDMETHODIMP
CTIMEElementCollection::GetMemberName(DISPID id, BSTR *pbstrName)
{
    return TIMESetLastError(m_pCollectionCache->GetMemberName(m_lCollectionIndex, id, pbstrName));
} // GetMemberName

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    IDispatchEx - GetNextDispID
//************************************************************

STDMETHODIMP
CTIMEElementCollection::GetNextDispID(DWORD grfdex, DISPID id, DISPID *prgid)
{
    return TIMESetLastError(m_pCollectionCache->GetNextDispID(m_lCollectionIndex, grfdex, id, prgid));
} // GetNextDispID

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    IDispatchEx - GetNameSpaceParent
//************************************************************

STDMETHODIMP
CTIMEElementCollection::GetNameSpaceParent(IUnknown **ppUnk)
{
    HRESULT hr = m_pCollectionCache->GetNameSpaceParent(m_lCollectionIndex, ppUnk);
    if (FAILED(hr))
    {
        TIMESetLastError(hr);
    }
    return hr;
} // GetNameSpaceParent

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    ITIMEElementCollection - get_length
//************************************************************

STDMETHODIMP
CTIMEElementCollection::get_length(long *plSize)
{
    HRESULT hr = m_pCollectionCache->get_length(m_lCollectionIndex, plSize);
    if (FAILED(hr))
    {
        TIMESetLastError(hr);
    }
    return hr;
} // get_length

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    ITIMEElementCollection - put_length
//************************************************************

STDMETHODIMP
CTIMEElementCollection::put_length(long lSize)
{
    return TIMESetLastError(m_pCollectionCache->put_length(m_lCollectionIndex, lSize));
} // put_length

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    ITIMEElementCollection - item
//************************************************************

STDMETHODIMP
CTIMEElementCollection::item(VARIANTARG var1, VARIANTARG var2, IDispatch **ppDisp)
{
    HRESULT hr = m_pCollectionCache->item(m_lCollectionIndex, var1, var2, ppDisp);
    if (FAILED(hr))
    {
        TIMESetLastError(hr);
    }
    return hr;
} // item

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    ITIMEElementCollection - tags
//************************************************************

STDMETHODIMP
CTIMEElementCollection::tags(VARIANT var1, IDispatch **ppDisp)
{
    
    HRESULT hr = m_pCollectionCache->tags(m_lCollectionIndex, var1, ppDisp);
    if (FAILED(hr))
    {
        TIMESetLastError(hr);
    }
    return hr;
} // tags

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    ITIMEElementCollection - get__newEnum
//************************************************************

STDMETHODIMP
CTIMEElementCollection::get__newEnum(IUnknown ** ppEnum)
{
    
    HRESULT hr = m_pCollectionCache->get__newEnum(m_lCollectionIndex, ppEnum);
    if (FAILED(hr))
    {
        TIMESetLastError(hr);
    }
    return hr;
} // get__newEnum

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    helper function for typeinfo
//************************************************************

HRESULT
CTIMEElementCollection::GetTI(ITypeInfo **pptinfo)
{
    HRESULT hr = E_FAIL;

    Assert(pptinfo != NULL);  //GetTI is an private internal function.  pptinfo should always be valid

    *pptinfo = NULL;

    if (m_pInfo == NULL)
    {
        ITypeLib* pTypeLib = NULL;

        hr = LoadRegTypeLib(LIBID_MSTIME, TYPELIB_VERSION_MAJOR, TYPELIB_VERSION_MINOR, LCID_SCRIPTING, &pTypeLib);
        if (SUCCEEDED(hr))
        {
            ITypeInfo* pTypeInfo = NULL;

            hr = pTypeLib->GetTypeInfoOfGuid(IID_ITIMEElementCollection, &pTypeInfo);
            if (SUCCEEDED(hr))
            {
                m_pInfo = pTypeInfo;
            }

            ReleaseInterface(pTypeLib);
        }
    }

    *pptinfo = m_pInfo;
    if (m_pInfo != NULL)
    {
        m_pInfo->AddRef();
        hr = S_OK;
    }

    return hr;
} // GetTI

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Constructor
//************************************************************

CCollectionCache::CCollectionCache(CTIMEElementBase *pBase,
                                   CAtomTable *pAtomTable /* = NULL */,
                                   PFN_CVOID_ENSURE pfnEnsure /* = NULL */,
                                   PFN_CVOID_CREATECOL pfnCreation /* = NULL */,
                                   PFN_CVOID_REMOVEOBJECT pfnRemove /* = NULL */,
                                   PFN_CVOID_ADDNEWOBJECT pfnAddNewObject /* = NULL */) :
    m_pBase(pBase),
    m_pAtomTable(pAtomTable),
    m_pfnEnsure(pfnEnsure),
    m_pfnCreateCollection(pfnCreation),
    m_pfnRemoveObject(pfnRemove),
    m_pfnAddNewObject(pfnAddNewObject),
    m_lReservedSize(0),
    m_lCollectionVersion(0),
    m_lDynamicCollectionVersion(0),
    m_rgItems(NULL),
    m_pElemEnum(NULL),
    m_lEnumItem(0)
{
    Assert(m_pBase != NULL);
} // CCollectionCache

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Destructor
//************************************************************

CCollectionCache::~CCollectionCache()
{
    if (m_rgItems)
    {
        long lSize = m_rgItems->Size();

        for (long lIndex = 0; lIndex < lSize; lIndex++)
        {
            CCacheItem *pce = (*m_rgItems)[lIndex];
            if (pce->m_fOKToDelete)
            {
                // delete CCacheItem
                delete pce;
                pce = NULL;
            }
        }

        // delete array of CCacheItems
        delete m_rgItems;
        m_rgItems = NULL;
    }
    m_pElemEnum = NULL;
    m_pBase = NULL;
    m_pAtomTable = NULL;
    m_pfnEnsure = NULL;
    m_pfnRemoveObject = NULL;
    m_pfnCreateCollection = NULL;
    m_pfnAddNewObject = NULL;
} // ~CCollectionCache

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Initialize class
//************************************************************

HRESULT
CCollectionCache::Init(long lReservedSize, long lIdentityIndex /* = -1 */)
{
    HRESULT hr = E_INVALIDARG;

    m_lReservedSize = lReservedSize;

    // Clear the reserved part of the cache.
    if (m_lReservedSize >= 0)
    {
        m_rgItems = NEW CPtrAry<CCacheItem *>;
        if (m_rgItems == NULL)
        {
            TraceTag((tagError, "CCollectionCache::Init - unable to alloc mem for array"));
            return E_OUTOFMEMORY;
        }

        // this is a speed thing.  Since we know we need a certain size,
        // make it so.
        hr = m_rgItems->EnsureSize(m_lReservedSize);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CCollectionCache::Init - unable to init array to reserved size"));
            return hr;
        }

        // loop through initializing each reserved array
        for (long lIndex = 0; lIndex < lReservedSize; lIndex++)
        {
            // create new cache item
            CCacheItem *pce = NEW CCacheItem();
            if (pce == NULL)
            {
                TraceTag((tagError, "CCollectionCache::Init - unable to alloc mem for array (CCacheItem)"));
                return E_OUTOFMEMORY;
            }

            // add item to array
            hr = m_rgItems->Append(pce);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::Init - unable to add cache item"));
                delete pce;
                return hr;
            }

            // attach CTIMEElementCollection to item
            hr = CreateCollectionHelper(&pce->m_pDisp, lIndex);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::Init - CreateCollectionHelper() failed"));
                return hr; //lint !e429
            }
        } //lint !e429

        // handle identity flag
        if ((lIdentityIndex >= 0) && (lIdentityIndex < m_lReservedSize))
        {
            (*m_rgItems)[lIdentityIndex]->m_fIdentity = true;
        }
    }

    return S_OK;
} // Init

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Get IDispatch for collection index
//************************************************************

HRESULT
CCollectionCache::GetCollectionDisp(long lCollectionIndex, IDispatch **ppDisp)
{
    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::GetCollectionDisp - Invalid param (collection index)"));
        return E_INVALIDARG;
    }

    if (ppDisp == NULL)
    {
        TraceTag((tagError, "CCollectionCache::GetCollectionDisp - Invalid param (IDispatch**)"));
        return E_POINTER;
    }

    *ppDisp = NULL;

    // fetch particular Collection
    CCacheItem *pce = (*m_rgItems)[lCollectionIndex];

    // if identity, QI for IDispatch and return
    if (pce->m_fIdentity)
    {
        return GetOuterDisp(lCollectionIndex, m_pBase, ppDisp);
    }

    // if not identity and there is a collection, addref and return it
    Assert(pce->m_pDisp != NULL);

    pce->m_pDisp->AddRef();
    *ppDisp = pce->m_pDisp;

    return S_OK;
} // GetCollectionDisp

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Set collection cache type
//************************************************************

HRESULT
CCollectionCache::SetCollectionType(long lCollectionIndex, COLLECTIONCACHETYPE cctype)
{
    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::SetCollectionType - Invalid index"));
        return E_INVALIDARG;
    }

    CCacheItem *pce = (*m_rgItems)[lCollectionIndex];
    pce->m_cctype = cctype;
    return S_OK;
} // SetCollectionType

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    given an index, see if it's a child collection
//************************************************************

bool
CCollectionCache::IsChildrenCollection(long lCollectionIndex)
{
    if ((lCollectionIndex >= 0) && lCollectionIndex < m_rgItems->Size())
    {
        CCacheItem *pce = (*m_rgItems)[lCollectionIndex];
        if (pce->m_cctype == ctChildren)
            return true;
    }
    return false;
} // IsChildrenCollection

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    given an index, see if it's an all collection
//************************************************************

bool
CCollectionCache::IsAllCollection(long lCollectionIndex)
{
    if ((lCollectionIndex >= 0) && lCollectionIndex < m_rgItems->Size())
    {
        CCacheItem *pce = (*m_rgItems)[lCollectionIndex];
        if (pce->m_cctype == ctAll)
            return true;
    }
    return false;
} // IsAllCollection

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Implementation of IDispatchEx - GetDispID
//************************************************************

HRESULT
CCollectionCache::GetDispID(long lCollectionIndex, BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    HRESULT hr;
    long    lItemIndex = 0;

    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::GetDispID - Invalid param (collection index)"));
        return E_INVALIDARG;
    }

    if (pid == NULL)
    {
        TraceTag((tagError, "CCollectionCache::GetDispID - Invalid param (DISPID*)"));
        return E_POINTER;
    }

    *pid = 0;

    // make sure array is up-to-date.
    hr = EnsureArray(lCollectionIndex);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::GetDispID - EnsureArray() failed"));
        return hr;
    }

    // check for index (number) - which equates to an ordinal
    hr = ttol_with_error(bstrName, &lItemIndex);
    if (hr == S_OK)
    {
        // Try to map name to a named element in the collection.
        // Ignore it if we're not promoting ordinals
        if (!(*m_rgItems)[lCollectionIndex]->m_fPromoteOrdinals)
        {
            return DISP_E_UNKNOWNNAME;
        }

        if (m_pfnAddNewObject)
        {
            // The presence of m_pfnAddNewObject indicates that the collection
            // allows setting to arbitrary indices. Expando on the collection
            // is not allowed.
            *pid = GetOrdinalMemberMin(lCollectionIndex) + lItemIndex;
            if (*pid > GetOrdinalMemberMax(lCollectionIndex))
            {
                return DISP_E_UNKNOWNNAME;
            }
            return S_OK;
        }

        // Without a m_pfnAddNewObject, the collection only supports
        // access to ordinals in the current range. Other accesses
        // become expando.
        if ((lItemIndex >= 0) &&
            (lItemIndex < Size(lCollectionIndex)))
        {
            *pid = GetOrdinalMemberMin(lCollectionIndex) + lItemIndex;
            if (*pid > GetOrdinalMemberMax(lCollectionIndex) )
            {
                return DISP_E_UNKNOWNNAME;
            }
            return S_OK;
        }

        return DISP_E_UNKNOWNNAME;
    }

    // see if it's an expando

    // If we don't promote named items - nothing more to do
    if (!(*m_rgItems)[lCollectionIndex]->m_fPromoteNames)
        return DISP_E_UNKNOWNNAME;

    CTIMEElementBase *pElem = NULL;
    long lIndex = 0;
    bool fCaseSensitive = ( grfdex & fdexNameCaseSensitive ) != 0;

    // check to make sure min/max are not wacky
    Assert((*m_rgItems)[lCollectionIndex]->m_dispidMin != 0);
    Assert(((*m_rgItems)[lCollectionIndex]->m_dispidMax != 0) &&
            ((*m_rgItems)[lCollectionIndex]->m_dispidMax > (*m_rgItems)[lCollectionIndex]->m_dispidMin));

    hr = GetItemByName(lCollectionIndex, bstrName, lIndex, &pElem, fCaseSensitive);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::GetDispID - GetItemByName() failed"));
        return hr;
    }

    Assert(pElem != NULL);  // double check to make sure we found something

    // add name to table
    long lOffset = 0;
    hr =  m_pAtomTable->AddNameToAtomTable(bstrName, &lOffset);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::GetDispID - AddNameToAtomTable() failed"));
        return hr;
    }

    // cook up an ID based on offset plus case sensitivity
    long lMax;
    if (fCaseSensitive)
    {
        lOffset += GetSensitiveNamedMemberMin(lCollectionIndex);
        lMax = GetSensitiveNamedMemberMax(lCollectionIndex);
    }
    else
    {
        lOffset += GetNotSensitiveNamedMemberMin(lCollectionIndex);
        lMax = GetNotSensitiveNamedMemberMax(lCollectionIndex);
    }

    *pid = lOffset;

    // if id greater than the max, punt
    if (*pid > lMax)
    {
        hr = DISP_E_UNKNOWNNAME;
    }
    return hr;
} // GetDispID

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Implementation of IDispatchEx - InvokeEx
//************************************************************

HRESULT
CCollectionCache::InvokeEx(long lCollectionIndex, DISPID id, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, IServiceProvider *pSrvProvider)
{
    HRESULT hr;

    // validate params
    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::InvokeEx - Invalid param (collection index)"));
        return E_INVALIDARG;
    }

    if (pdispparams == NULL)
    {
        TraceTag((tagError, "CCollectionCache::InvokeEx - Invalid param (DISPPARAMS*)"));
        return E_POINTER;
    }

    // make sure array is up-to-date
    hr = EnsureArray(lCollectionIndex);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::InvokeEx - unable to ensure array index"));
        return hr;
    }

    // make sure ID is in collection range
    // Note: this stop's requests for length which is handled
    //       in CTIMEElementCollection
    if ((id < (*m_rgItems)[lCollectionIndex]->m_dispidMin) ||
        (id > (*m_rgItems)[lCollectionIndex]->m_dispidMax))
        return DISP_E_MEMBERNOTFOUND;

    //
    // check for ordinal
    //
    if (IsOrdinalCollectionMember(lCollectionIndex, id))
    {
        if (wFlags & DISPATCH_PROPERTYPUT )
        {
            if (!m_pfnAddNewObject)
            {
                TraceTag((tagError, "CCollectionCache::InvokeEx - invalid arg passed to invoke"));
                return E_INVALIDARG;
            }

            if (!(pdispparams && pdispparams->cArgs == 1)) //lint !e774
                // No result type we need one for the get to return.
                return DISP_E_MEMBERNOTFOUND;

            // Only allow VARIANT of type IDispatch to be put
            if (pdispparams->rgvarg[0].vt == VT_NULL)
            {
                // the options collection is special. it allows
                // options[n] = NULL to be specified. in this case
                // map the invoke to a delete on that appropriate index
                if ((*m_rgItems)[lCollectionIndex]->m_fSettableNULL)
                {
                    hr = Remove(lCollectionIndex, id - GetOrdinalMemberMin(lCollectionIndex));

                    // Like Nav - silently ignore the put if its's outside the current range
                    if ( hr == E_INVALIDARG )
                        return S_OK;
                    return hr;
                }
                return E_INVALIDARG;
            }
            else if (pdispparams->rgvarg[0].vt != VT_DISPATCH)
            {
                return E_INVALIDARG;
            }

            // All OK, let the collection cache validate the Put
            return ((CVoid *)((void *)m_pBase)->*m_pfnAddNewObject)(lCollectionIndex, //lint !e10
                                                                    V_DISPATCH(pdispparams->rgvarg),
                                                                    id - GetOrdinalMemberMin(lCollectionIndex));
        }
        else if (wFlags & DISPATCH_PROPERTYGET)
        {
            VARIANTARG      v1;
            VARIANTARG      v2;
            long            lIndex = id - GetOrdinalMemberMin(lCollectionIndex);

            if (!((lIndex >= 0) && (lIndex < Size(lCollectionIndex))))
            {
                hr = S_OK;
                if (pvarResult)
                {
                    VariantClear(pvarResult);
                    pvarResult->vt = VT_NULL;
                    return S_OK;
                }
            }

            v1.vt = VT_I4;
            v1.lVal = lIndex;

            // Always get the item by index.
            v2.vt = VT_ERROR;

            if (pvarResult)
            {
                hr = item(lCollectionIndex, v1, v2, &(pvarResult->pdispVal));
                if (SUCCEEDED(hr))
                {
                    if (!(pvarResult->pdispVal))
                    {
                        hr = E_FAIL;        // use super::Invoke
                    }
                    else
                    {
                        pvarResult->vt = VT_DISPATCH;
                    }
                }
            }
            return hr;
        }

        TraceTag((tagError, "CCollectionCache::InvokeEx - Invalid invocation of ordinal ID"));
        return DISP_E_MEMBERNOTFOUND;
    }

    //
    // check for expando
    //
    if (IsNamedCollectionMember(lCollectionIndex, id))
    {
        bool  fCaseSensitive;
        long  lOffset;

        lOffset = GetNamedMemberOffset(lCollectionIndex, id, &fCaseSensitive);

        const WCHAR  *pwszName;
        hr = m_pAtomTable->GetNameFromAtom(id - lOffset, &pwszName);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CCollectionCache::InvokeEx - GetNameFromAtom() failed"));
            return hr;
        }

        // find name
        IDispatch *pDisp = NULL;
        hr = GetDisp(lCollectionIndex,
                     pwszName,
                     false,
                     &pDisp,
                     fCaseSensitive);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CCollectionCache::InvokeEx - unable to GetDisp for expando"));
            return hr;
        }

        Assert(pDisp != NULL);
        UINT* puArgErr = NULL;

        if (wFlags == DISPATCH_PROPERTYGET ||
            wFlags == (DISPATCH_METHOD | DISPATCH_PROPERTYGET))
        {
            if (pvarResult == NULL)
            {
                TraceTag((tagError, "CCollectionCache::InvokeEx - invalid param (VARIANT*)"));
                return E_POINTER;
            }

            // cArgs==1 when Doc.foo(0) is used and =0 when Doc.foo.count
            //  this is only an issue when there are multiple occurances
            //  of foo, and a collection is supposed to be returned by
            //  document.foo
            if (pdispparams->cArgs > 1)
            {
                TraceTag((tagError, "CCollectionCache::InvokeEx - bad param count on get_/method call"));
                return DISP_E_BADPARAMCOUNT;
            }
            else if (pdispparams->cArgs == 1)
            {
                return pDisp->Invoke(DISPID_VALUE, IID_NULL, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
            }
            else
            {
                V_VT(pvarResult) = VT_DISPATCH;
                V_DISPATCH(pvarResult) = pDisp;
                return S_OK;
            }
        }
        else if (wFlags == DISPATCH_PROPERTYPUT ||
                 wFlags == DISPATCH_PROPERTYPUTREF)
        {
            if (pdispparams->cArgs != 1)
            {
                TraceTag((tagError, "CCollectionCache::InvokeEx - bad param count on put_ call"));
                return DISP_E_BADPARAMCOUNT;
            }

            return pDisp->Invoke(DISPID_VALUE, IID_NULL, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
        }

        // Any other kind of invocation is not valid.
        TraceTag((tagError, "CCollectionCache::InvokeEx - Invalid invocation of Named ID"));
        return DISP_E_MEMBERNOTFOUND;
    }

    // punt back to outer Invoke...
    return DISP_E_MEMBERNOTFOUND;
} // InvokeEx

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Implementation of IDispatchEx - deleteMemberByName
//              Not needed
//************************************************************

HRESULT
CCollectionCache::DeleteMemberByName(long lCollectionIndex, BSTR bstrName, DWORD grfdex)
{
    return E_NOTIMPL;
} // deleteMemberByName

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Implementation of IDispatchEx - deleteMemberByDispID
//              Not needed
//************************************************************

HRESULT
CCollectionCache::DeleteMemberByDispID(long lCollectionIndex, DISPID id)
{
    return E_NOTIMPL;
} // GetMemberProperties

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Implementation of IDispatchEx - GetMemberProperties
//              Not needed
//************************************************************

HRESULT
CCollectionCache::GetMemberProperties(long lCollectionIndex, DISPID id, DWORD grfdexFetch, DWORD* pgrfdex)
{
    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::GetMemberProperties - Invalid param (collection index)"));
        return E_INVALIDARG;
    }

    if (pgrfdex == NULL)
    {
        TraceTag((tagError, "CCollectionCache::GetMemberProperties - Invalid param (DWORD*)"));
        return E_POINTER;
    }

    *pgrfdex = 0;
    return E_NOTIMPL;
} // GetMemberProperties

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Implementation of IDispatchEx - GetMemberName
//************************************************************

HRESULT
CCollectionCache::GetMemberName(long lCollectionIndex, DISPID id, BSTR *pbstrName)
{
    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::GetMemberName - Invalid param (collection index)"));
        return E_INVALIDARG;
    }

    if (pbstrName == NULL)
    {
        TraceTag((tagError, "CCollectionCache::GetMemberName - Invalid param (BSTR*)"));
        return E_POINTER;
    }

    *pbstrName = NULL;

    // Make sure our collection is up-to-date.
    HRESULT hr = EnsureArray(lCollectionIndex);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::GetMemberName - unable to ensure array"));
        return S_FALSE;
    }

    // check to see if DISPID is an ordinal
    if (IsOrdinalCollectionMember(lCollectionIndex, id))
    {
        long lOffset = id - GetOrdinalMemberMin(lCollectionIndex);
        CTIMEElementBase *pElem = NULL;

        // element
        hr = GetItemByIndex(lCollectionIndex, lOffset, &pElem);
        if (FAILED(hr) || (pElem == NULL))
        {
            TraceTag((tagError, "CCollectionCache::GetMemberName - GetItemByIndex() failed"));
            return DISP_E_MEMBERNOTFOUND;
        }

        Assert(pElem != NULL);

        if ((*m_rgItems[lCollectionIndex])->m_fPromoteNames)
        {
            // get ID string
            hr = pElem->getIDString(pbstrName);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::GetMemberName - unable to find ID for element"));
                return DISP_E_MEMBERNOTFOUND;
            }
        }

        // check to see that it's either NULL or ""
        // if so, stick offset in string
        if ((*pbstrName == NULL) || (lstrlenW(*pbstrName) == 0))
        {
            // set offset as text
            VARIANT varData;
            VariantInit(&varData);

            V_VT(&varData) = VT_I4;
            V_I4(&varData) = lOffset;

            VARIANT varNew;
            VariantInit(&varNew);
            hr = VariantChangeTypeEx(&varNew, &varData, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::GetMemberName - Unable to coerce long to BSTR"));
                // NOTE: we return DISP_E_MEMBERNOTFOUND instead of hr
                //       due to predefined method constraints
                return DISP_E_MEMBERNOTFOUND;
            }

            // Since we are going to return the BSTR, no need calling ClearVariant(&varNew).
            VariantClear(&varData);
            *pbstrName = V_BSTR(&varNew);
            return S_OK;
        }

        return S_OK;
    }

    // unable to find DISPID
    return DISP_E_MEMBERNOTFOUND;
} // GetMemberName

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Implementation of IDispatchEx - GetNextDispID
//************************************************************

HRESULT
CCollectionCache::GetNextDispID(long lCollectionIndex, DWORD grfdex, DISPID id, DISPID *prgid)
{
    HRESULT hr;

    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::GetNextDispID - Invalid param (collection index)"));
        return E_INVALIDARG;
    }

    if (prgid == NULL)
    {
        TraceTag((tagError, "CCollectionCache::GetNextDispID - Invalid param (DISPID*)"));
        return E_POINTER;
    }

    *prgid = 0;

    // Make sure our collection is up-to-date.
    hr = EnsureArray(lCollectionIndex);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::GetNextDispID - unable to ensure array"));
        return S_FALSE;
    }

    // check to see if we are have been sent the enumerator index. (FFFFFFFF)
    if (id == DISPID_STARTENUM)
    {
         // move to the beginning of the array (0)
         *prgid = GetOrdinalMemberMin(lCollectionIndex);
         return S_OK;
    }

    // validate that we are working with ordinals
    if (IsOrdinalCollectionMember(lCollectionIndex, id))
    {
        // calc new offset
        long lItemIndex = id - GetOrdinalMemberMin(lCollectionIndex) + 1;

        // Is the number within range for an item in the collection?
        // We *must* call GetItemCount to be exact.
        long lSize = 0;
        hr = GetItemCount(lCollectionIndex, &lSize);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CCollectionCache::GetNextDispID - GetItemCount() failed"));
            return S_FALSE;
        }

        // this is usually were we stop
        if ((lItemIndex < 0) || (lItemIndex >= lSize))
        {
            return S_FALSE;
        }

        // calc new DISPID
        *prgid = GetOrdinalMemberMin(lCollectionIndex) + lItemIndex;

        // check to see if calc DISPID is out of range
        if (*prgid > GetOrdinalMemberMax(lCollectionIndex))
        {
            // this signal's that we are done.
            *prgid = DISPID_UNKNOWN;
        }
        return S_OK;
    }

    // not found
    return S_FALSE;
} // GetNextDispID

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Implementation of IDispatchEx - GetNameSpaceParent
//************************************************************

HRESULT
CCollectionCache::GetNameSpaceParent(long lCollectionIndex, IUnknown **ppUnk)
{
    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::GetNameSpaceParent - Invalid param (collection index)"));
        return E_INVALIDARG;
    }

    if (ppUnk == NULL)
    {
        TraceTag((tagError, "CCollectionCache::GetNameSpaceParent - Invalid param (IUnknown**)"));
        return E_POINTER;
    }

    *ppUnk = NULL;
    return S_OK;
} // GetNameSpaceParent

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Implementation of standard Collection - get_length
//************************************************************

HRESULT
CCollectionCache::get_length(long lCollectionIndex, long *pretval)
{
    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::get_length - Invalid param (collection index)"));
        return E_INVALIDARG;
    }

    if (pretval == NULL)
    {
        TraceTag((tagError, "CCollectionCache::get_length - Invalid param (long*)"));
        return E_POINTER;
    }

    *pretval = 0;

    // Make sure our collection is up-to-date.
    HRESULT hr = EnsureArray(lCollectionIndex);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::get_length - unable to ensure array"));
        return hr;
    }

    return GetItemCount(lCollectionIndex, pretval);
} // get_length

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Implementation of standard Collection - put_length
//              not needed.
//************************************************************

HRESULT
CCollectionCache::put_length(long lCollectionIndex, long retval)
{
    return E_NOTIMPL;
} // put_length

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    item is a standard method for collections
//              which looks up an item in a collection using
//              either a name or a numeric index.
//
//              we handle the following parameter cases:
//                  0 params            : by index = 0
//                  1 params bstr       : by name, index = 0
//                  1 params #          : by index
//                  2 params bstr, #    : by name, index
//                  2 params #, bstr    : by index, ignoring bstr
//************************************************************

HRESULT
CCollectionCache::item(long lCollectionIndex, VARIANTARG var1, VARIANTARG var2, IDispatch **ppDisp)
{
    HRESULT   hr;
    VARIANT  *pvarName = NULL;
    VARIANT  *pvarIndex = NULL;
    VARIANT  *pvar = NULL;
    long     lItemIndex = 0;

    // validate out param
    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::item - Invalid param (collection index)"));
        return E_INVALIDARG;
    }

    if (ppDisp == NULL)
    {
        TraceTag((tagError, "CCollectionCache::item - Invalid param (IDispatch**)"));
        return E_POINTER;
    }

    // initialize out param
    *ppDisp = NULL;

    pvar = (V_VT(&var1) == (VT_BYREF | VT_VARIANT)) ? V_VARIANTREF(&var1) : &var1; //lint !e655

    // check to see if first param is a string
    if ((V_VT(pvar) == VT_BSTR) || V_VT(pvar) == (VT_BYREF|VT_BSTR)) //lint !e655
    {
        pvarName = (V_VT(pvar) & VT_BYREF) ? V_VARIANTREF(pvar) : pvar; //lint !e655

        // check second param.  If valid, it must be a secondary index (numeric)
        if ((V_VT(&var2) != VT_ERROR) && (V_VT(&var2) != VT_EMPTY))
        {
            pvarIndex = &var2;
        }
    }
    // first param is an index.
    // NOTE: we blow off the second param
    else if ((V_VT(&var1) != VT_ERROR) && (V_VT(&var1) != VT_EMPTY))
    {
        pvarIndex = &var1;
    }

    // Make sure our collection is up-to-date.
    hr = EnsureArray(lCollectionIndex);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::item- unable to ensure array"));
        return hr;
    }

    // if we have a pvarIndex, get it
    if (pvarIndex)
    {
        VARIANT varNum;

        VariantInit(&varNum);

        hr = VariantChangeTypeEx(&varNum, pvarIndex, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_I4);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CCollectionCache::item - unable to convert variant to index"));
            return hr;
        }

        lItemIndex = V_I4(&varNum);

        VariantClear(&varNum);
    }

    // First, see if we have a string as first param
    if (pvarName)
    {
        BSTR bstrName = V_BSTR(pvarName);

        // NOTE: lItemIndex is always passed in.  In the case
        // were we have no secondary index specifed, it will
        // always be zero.
        if (pvarIndex)
        {
            // this ALWAYS returns a single CTIMEElementBase
            hr = GetDisp(lCollectionIndex, bstrName, lItemIndex, ppDisp);
            if (hr == DISP_E_MEMBERNOTFOUND)
                hr = S_OK;
            return hr;
        }
        else
        {
            // this could return either a collection or an CTIMEElementBase
            hr = GetDisp(lCollectionIndex, bstrName, false, ppDisp);
            if (hr == DISP_E_MEMBERNOTFOUND)
                hr = S_OK;
            return hr;
        }
    }
    else if (pvarIndex)
    {
        // this ALWAYS returns a single CTIMEElementBase
        hr = GetDisp(lCollectionIndex, lItemIndex, ppDisp);
        if (hr == DISP_E_MEMBERNOTFOUND)
            hr = S_OK;
        return hr;
    }

    TraceTag((tagError, "CCollectionCache::item - Invalid args passed in to ::item"));
    return E_INVALIDARG;
} //item

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    get__NewEnum is a standard method for collections
//              returns an enumeration of all the items in a
//              collection.
//************************************************************

HRESULT
CCollectionCache::get__newEnum(long lCollectionIndex, IUnknown **ppUnk)
{
    HRESULT hr;

    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::get__newEnum - Invalid param (collection index)"));
        return E_INVALIDARG;
    }

    if (ppUnk == NULL)
    {
        TraceTag((tagError, "CCollectionCache::get__newEnum - Invalid param (IUnknown**)"));
        return E_POINTER;
    }

    *ppUnk = NULL;

    // Make sure our collection is up-to-date.
    hr = EnsureArray(lCollectionIndex);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::get__newEnum - unable to ensure array"));
        return hr;
    }

    // Create new array
    CPtrAry<IUnknown *> *prgElem = NEW CPtrAry<IUnknown *>;
    if (prgElem == NULL)
    {
        TraceTag((tagError, "CCollectionCache::get__newEnum - unable to alloc mem for ptr array"));
        return E_OUTOFMEMORY;
    }

    // child collection
    if (IsChildrenCollection(lCollectionIndex))
    {
        Assert(m_pBase != NULL);

        // get child count
        long lCount = m_pBase->GetImmediateChildCount();
        // loop through, adding children
        for(long lIndex = 0; lIndex < lCount; lIndex++)
        {
            // get element
            CTIMEElementBase *pElemChild = m_pBase->GetChild(lIndex);
            Assert(pElemChild != NULL);
            // get IUnknown for element
            IUnknown *pIUnknown = NULL;
            hr = GetUnknown(lCollectionIndex, pElemChild, &pIUnknown);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::get__newEnum - unable to find IUnknown for element"));
                prgElem->ReleaseAll();
                delete prgElem;
                return hr;
            }

            // append to array
            hr = prgElem->Append(pIUnknown);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::get__newEnum - unable to append pointer"));
                ReleaseInterface(pIUnknown);
                prgElem->ReleaseAll();
                delete prgElem;
                return hr;
            }
        }
    }
    else if (IsAllCollection(lCollectionIndex)) // is it all collection?
    {
        EnumStart();

        // iterate over every element
        for (;;)
        {
            // get element
            CTIMEElementBase *pElem = NULL;
            hr = EnumNextElement(lCollectionIndex, &pElem);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::get__newEnum - EnumNextElement() failed"));
                prgElem->ReleaseAll();
                delete prgElem;
                return hr;
            }

            // if pElem is NULL, we are done.
            if (pElem == NULL)
                break;

            // get IUnknown for element
            IUnknown *pIUnknown = NULL;
            hr = GetUnknown(lCollectionIndex, pElem, &pIUnknown);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::get__newEnum - unable to find IUnknown for element"));
                prgElem->ReleaseAll();
                delete prgElem;
                return hr;
            }

            // append to array
            hr = prgElem->Append(pIUnknown);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::get__newEnum - unable to append pointer"));
                ReleaseInterface(pIUnknown);
                prgElem->ReleaseAll();
                delete prgElem;
                return hr;
            }

        }
    }
    else // must be an array impl
    {
        long lSize = (*m_rgItems)[lCollectionIndex]->m_rgElem->Size();

        // This is a speed thing.  Since we know the size, alloc now for
        // array.
        hr = prgElem->EnsureSize(lSize);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CCollectionCache::get__newEnum - unable to ensure array"));
            prgElem->ReleaseAll();
            delete prgElem;
            return hr;
        }

        for (long lIndex = 0; lIndex < lSize; lIndex++)
        {
            IDispatch * pdisp;

            hr = GetDisp(lCollectionIndex, lIndex, &pdisp);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::get__newEnum - GetDisp() failed for index"));
                prgElem->ReleaseAll();
                delete prgElem;
                return hr;
            }

            hr = prgElem->Append(pdisp);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::get__newEnum - unable to append item"));
                prgElem->ReleaseAll();
                delete prgElem;
                return hr;
            }
        }
    } // end of "else everything"

    // Turn the snapshot into an enumerator.
    hr = prgElem->EnumVARIANT(VT_DISPATCH, (IEnumVARIANT **)ppUnk, FALSE, TRUE);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::get__newEnum - EnumVARIANT() failed"));
        prgElem->ReleaseAll();
        delete prgElem;
    }

    return hr;
} // get__newEnum

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Return a subcollection containing only the
//              elements of this collection that have the
//              specified tag name.
//************************************************************

HRESULT
CCollectionCache::tags(long lCollectionIndex, VARIANT var1, IDispatch** ppDisp)
{
    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::tags - Invalid param (Collection index)"));
        return E_INVALIDARG;
    }

    if (ppDisp == NULL)
    {
        TraceTag((tagError, "CCollectionCache::tags - Invalid param (IDispatch**)"));
        return E_POINTER;
    }

    *ppDisp = NULL;

    VARIANT *pvarName = NULL;
    pvarName = (V_VT(&var1) == (VT_BYREF | VT_VARIANT)) ? V_VARIANTREF(&var1) : &var1; //lint !e655

    if ((V_VT(pvarName)==VT_BSTR) || V_VT(pvarName)==(VT_BYREF|VT_BSTR)) //lint !e655
    {
        pvarName = (V_VT(pvarName)&VT_BYREF) ? V_VARIANTREF(pvarName) : pvarName; //lint !e655
    }
    else
    {
        return DISP_E_MEMBERNOTFOUND;
    }

    // Make sure our collection is up-to-date.
    HRESULT hr = EnsureArray(lCollectionIndex);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::item- unable to ensure array"));
        return hr;
    }

    // Get a collection of the specified tags.
    // NOTE: ALWAYS returns a collection
    return GetDisp(lCollectionIndex, V_BSTR(pvarName), true, ppDisp);
} //get_tags

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    returns Size of a collection
//************************************************************

long
CCollectionCache::Size(long lCollectionIndex)
{
    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::Size - invalid param (collection index)"));
        return E_INVALIDARG;
    }

    // Make sure our collection is up-to-date.
    HRESULT hr = EnsureArray(lCollectionIndex);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::Size - unable to ensure array"));
        return hr;
    }

    // if all or children collection, use GetItemCount
    if (IsChildrenCollection(lCollectionIndex) || IsAllCollection(lCollectionIndex))
    {
        long    cElem = 0;
        hr = GetItemCount(lCollectionIndex, &cElem);
        if (FAILED(hr)) {
            TraceTag((tagError, "CCollectionCache::Size - GetItemCount() failed"));
        }

        return cElem;
    }
    else
    {
        // must be an array. return size.
        return (*m_rgItems)[lCollectionIndex]->m_rgElem->Size();
    }
}

HRESULT
CCollectionCache::GetItem(long lCollectionIndex, long i, CTIMEElementBase **ppElem)
{
    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::GetItem - invalid param (collection index)"));
        return E_INVALIDARG;
    }

    if (ppElem == NULL)
    {
        TraceTag((tagError, "CCollectionCache::GetItem - invalid param (CTIMEElementBase**)"));
        return E_POINTER;
    }

    // if all or children collection, use GetItemByIndex
    if (IsChildrenCollection(lCollectionIndex) || IsAllCollection(lCollectionIndex))
    {
        HRESULT hr = GetItemByIndex(lCollectionIndex, i, ppElem);
        if (FAILED(hr))
        {
            if (hr == DISP_E_MEMBERNOTFOUND)
                TraceTag((tagCollectionCache, "CCollectionCache::GetItem - GetItemByIndex didn't find anything!"));
            else
                TraceTag((tagError, "CCollectionCache::GetItem - GetItemByIndex() failed"));
        }
        return hr;
    }
    else
    {
        // must be array.  access index.
        CCacheItem *pce = (*m_rgItems)[lCollectionIndex];
        Assert(pce != NULL);
        *ppElem = (*pce->m_rgElem)[i];
        return S_OK;
    }
} // GetItem

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Validate the given collection Index
//************************************************************

HRESULT
CCollectionCache::EnsureArray(long lCollectionIndex)
{
    HRESULT hr = S_OK;

    if (m_pfnEnsure)
    {
        hr = (((CVoid *)(void *)m_pBase)->*m_pfnEnsure)(&m_lCollectionVersion);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CCollectionCache::EnsureArray - outer Ensure function failed"));
            return hr;
        }
    }

    // used for customized collections
    //
    // if versions don't match invalidate everything
    if (m_lCollectionVersion != m_lDynamicCollectionVersion)
    {
        long lSize = m_rgItems->Size();
        for (long lIndex = m_lReservedSize; lIndex < lSize; lIndex++)
            (*m_rgItems)[lIndex]->m_fInvalid = true;

        // reset version number
        m_lDynamicCollectionVersion = m_lCollectionVersion;
    }

    CCacheItem *pce = (*m_rgItems)[lCollectionIndex];
    if ((lCollectionIndex >= m_lReservedSize) && pce->m_fInvalid)
    {
        // Ensure the collection we're based upon
        // note that this is a recursive call
        hr = EnsureArray(pce->m_lDependentIndex);
        if (FAILED(hr))
            return hr;

        switch (pce->m_cctype)
        {
        case ctTag:
            // Rebuild based on name
            hr = BuildNamedArray(pce->m_lDependentIndex,
                                 pce->m_bstrName,
                                 true,
                                 &pce->m_rgElem);
            if (hr == S_OK)
                pce->m_fInvalid = false;
            break;

        case ctNamed:
            // Rebuild based on tag name
            hr = BuildNamedArray(pce->m_lDependentIndex,
                                 pce->m_bstrName,
                                 false,
                                 &pce->m_rgElem);
            if (hr == S_OK)
                pce->m_fInvalid = false;
            break;


            // all && children collection is dynamic, no need to rebuild
        case ctChildren:
        case ctAll:
            TraceTag((tagError, "CCollectionCache::EnsureArray - This is odd.  Why are we doing this?"));
            Assert(false);
            break;

        case ctFreeEntry:
            // Free collection waiting to be reused
            break;

        default:
            TraceTag((tagError, "CCollectionCache::EnsureArray - invalid cache type"));
            Assert(false);
            break;
        }
    }

    return hr;
} // EnsureArray

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    This gets the out IDispatch for a given CTIMEElementBase
//************************************************************

HRESULT
CCollectionCache::GetOuterDisp(long lCollectionIndex, CTIMEElementBase *pElem, IDispatch **ppDisp)
{
    Assert(ppDisp != NULL);
    *ppDisp = NULL;

    Assert(pElem != NULL);

    HRESULT hr = E_UNEXPECTED;
    CCacheItem *pce = (*m_rgItems)[lCollectionIndex];
    Assert(pce != NULL);

    IHTMLElement *pHTMLElem = pElem->GetElement();
    Assert(NULL != pHTMLElem);
    hr = THR(pHTMLElem->QueryInterface(IID_TO_PPV(IDispatch, ppDisp)));

    return hr;
} //lint !e529

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Creates a new collection
//************************************************************

HRESULT
CCollectionCache::CreateCollectionHelper(IDispatch **ppDisp, long lCollectionIndex)
{
    HRESULT hr;

    *ppDisp = NULL;

    if (m_pfnCreateCollection)
    {
        return (((CVoid *)(void *)m_pBase)->*m_pfnCreateCollection)(ppDisp, lCollectionIndex);
    }

    CTIMEElementCollection *pobj = NEW CTIMEElementCollection(this, lCollectionIndex);
    if (pobj == NULL)
    {
        TraceTag((tagError, "CCollectionCache::CreateCollectionHelper - unable to alloc mem for collection"));
        return E_OUTOFMEMORY;
    }

    hr = pobj->QueryInterface(IID_TO_PPV(IDispatch, ppDisp));
    return hr; //lint !e429
} // CreateCollectionHelper

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    retrieved offset of Named Member, given a DISPID
//************************************************************

long
CCollectionCache::GetNamedMemberOffset(long    lCollectionIndex,
                                       DISPID  id,
                                       bool   *pfCaseSensitive /* = NULL */)
{
    long lOffset;
    bool fSensitive;

    Assert(IsNamedCollectionMember(lCollectionIndex, id));

    // Check to see wich half of the dispid space the value goes
    if (IsSensitiveNamedCollectionMember(lCollectionIndex, id))
    {
        lOffset = GetSensitiveNamedMemberMin(lCollectionIndex);
        fSensitive = true;
    }
    else
    {
        lOffset = GetNotSensitiveNamedMemberMin(lCollectionIndex);
        fSensitive = false;
    }

    // return the sensitivity flag if required
    if (pfCaseSensitive != NULL)
        *pfCaseSensitive = fSensitive;

    return lOffset;
} // GetNamedMemberOffset

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Compares names
//************************************************************

bool
CCollectionCache::CompareName(CTIMEElementBase *pElem, const WCHAR *pwszName, bool fTagName, bool fCaseSensitive /* = false */)
{
    if (pwszName == NULL)
        return false;

    BSTR bstrSrcName = NULL;
    HRESULT hr;
    if (fTagName)
        hr = pElem->getTagString(&bstrSrcName);
    else
        hr = pElem->getIDString(&bstrSrcName);

    if (FAILED(hr))
    {
        TraceTag((tagError, "Unable to retrieve src name from element"));
        return false;
    }

    if (bstrSrcName == NULL)
        return false;

    long lCompare;
    if (fCaseSensitive)
        lCompare = StrCmpW(bstrSrcName, pwszName);
    else
        lCompare = StrCmpIW(bstrSrcName, pwszName);

    // free bstr
    SysFreeString(bstrSrcName);

    return (lCompare == 0);
} // CompareName

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    removes an item from collection.
//              NOTE: that in order to do this, caller (owner
//              of the cache) need to provide Remove function.
//************************************************************

HRESULT
CCollectionCache::Remove(long lCollectionIndex, long lItemIndex)
{
    // Make sure our collection is up-to-date.
    HRESULT hr = EnsureArray(lCollectionIndex);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::Remove - unable to ensure array"));
        return hr;
    }

    CCacheItem *pce = (*m_rgItems)[lCollectionIndex];
    if ((lItemIndex < 0) || (lItemIndex >= pce->m_rgElem->Size()))
    {
        TraceTag((tagError, "CCollectionCache::Remove - invalid index"));
        return E_INVALIDARG;
    }

    if (!m_pfnRemoveObject)
    {
        TraceTag((tagError, "CCollectionCache::Remove - outer function not defined"));
        return CTL_E_METHODNOTAPPLICABLE;
    }

    return ((CVoid *)((void *)m_pBase)->*m_pfnRemoveObject)(lCollectionIndex, lItemIndex); //lint !e10
} // Remove

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Builds a Named array from a given collection
//************************************************************

HRESULT
CCollectionCache::BuildNamedArray(long lCollectionIndex, const WCHAR *pwszName, bool fTagName, CPtrAry<CTIMEElementBase *> **prgNamed, bool fCaseSensitive /* = false */)
{
    CPtrAry<CTIMEElementBase *> *rgTemp = *prgNamed;
    HRESULT                      hr = S_OK;

    // if this array already exists, clear it.
    // Otherwise create a new array.
    if (rgTemp)
    {
        rgTemp->SetSize(0);
    }
    else
    {
        rgTemp = NEW CPtrAry<CTIMEElementBase *>;
        if (rgTemp == NULL)
        {
            TraceTag((tagError, "CCollectionCache::BuildNamedArray - unable to alloc mem for array"));
            return E_OUTOFMEMORY;
        }
    }

    // figure out which collection we are looking at,
    // look for matches, and build array

    if (IsChildrenCollection(lCollectionIndex))
    {
        Assert(m_pBase != NULL);

        // get child count
        long lCount = m_pBase->GetImmediateChildCount();
        for(long lIndex = 0; lIndex < lCount; lIndex++)
        {
            // get element
            CTIMEElementBase *pElemChild = m_pBase->GetChild(lIndex);
            Assert(pElemChild != NULL);

            if (CompareName(pElemChild, pwszName, fTagName, fCaseSensitive))
            {
                // append to array
                hr = rgTemp->Append(pElemChild);
                if (FAILED(hr))
                {
                    TraceTag((tagError, "CCollectionCache::BuildNamedArray - unable to append item"));
                    delete rgTemp;
                    return hr;
                }
            }
        }
        *prgNamed = rgTemp;
        return hr;
    }
    else if (IsAllCollection(lCollectionIndex))
    {
        EnumStart();

        // iterate over every element
        for (;;)
        {
            // get element
            CTIMEElementBase *pElem = NULL;
            hr = EnumNextElement(lCollectionIndex, &pElem);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::BuildNamedArray - EnumNextElement() failed"));
                delete rgTemp;
                return hr;
            }

            // if pElem is NULL, we are done.
            if (pElem == NULL)
                break;

            // compare name
            if (CompareName(pElem, pwszName, fTagName, fCaseSensitive))
            {
                // append to array
                hr = rgTemp->Append(pElem);
                if (FAILED(hr))
                {
                    TraceTag((tagError, "CCollectionCache::BuildNamedArray - unable to append item"));
                    delete rgTemp;
                    return hr;
                }
            }
        }
        *prgNamed = rgTemp;
        return hr;
    }
    else
    {
        // Must be a named array
        // Build a list of named elements.
        long               lSize = (*m_rgItems)[lCollectionIndex]->m_rgElem->Size();
        CTIMEElementBase  *pElem = NULL;

        for (long lIndex = 0; lIndex < lSize; lIndex++)
        {
            pElem = (*(*m_rgItems)[lCollectionIndex]->m_rgElem)[lIndex];
            Assert(pElem != NULL);

            if (CompareName(pElem, pwszName, fTagName, fCaseSensitive))
            {
                hr = rgTemp->Append(pElem);
                if (FAILED(hr))
                {
                    TraceTag((tagError, "CCollectionCache::BuildNamedArray - unable to append item"));
                    delete rgTemp;
                    return hr;
                }
            }
        }

        *prgNamed = rgTemp;
        return hr;
    }
} //lint !e429

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    return IUnknown Interface for a given CTIMEElementBase
//************************************************************

HRESULT
CCollectionCache::GetUnknown(long lCollectionIndex, CTIMEElementBase *pElem, IUnknown **ppUnk)
{
    Assert(ppUnk != NULL);
    *ppUnk = NULL;

    Assert(pElem != NULL);

    HRESULT hr = E_UNEXPECTED;
    CCacheItem *pce = (*m_rgItems)[lCollectionIndex];
    Assert(pce != NULL);

    IHTMLElement *pHTMLElem = pElem->GetElement();
    Assert(NULL != pHTMLElem);
    hr = THR(pHTMLElem->QueryInterface(IID_TO_PPV(IUnknown, ppUnk)));

    return hr;
} //lint !e529

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Get IDispatch given an Index into a collection
//************************************************************

HRESULT
CCollectionCache::GetDisp(long lCollectionIndex, long lItemIndex, IDispatch **ppDisp)
{
    CTIMEElementBase *pElem = NULL;
    HRESULT hr = GetItemByIndex(lCollectionIndex, lItemIndex, &pElem);
    if (FAILED(hr) ||
        pElem == NULL)
    {
        TraceTag((tagError, "CCollectionCache::GetDisp - GetItemByIndex() failed"));
        return (pElem==NULL)?E_FAIL:hr;
    }

    Assert(pElem != NULL);

    return GetOuterDisp(lCollectionIndex, pElem, ppDisp);
} // GetDisp (long, long, IDispatch **)

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Get IDispatch given a name and index
//************************************************************

HRESULT
CCollectionCache::GetDisp(long lCollectionIndex, const WCHAR *pwszName, long lIndex, IDispatch **ppDisp, bool fCaseSensitive /*= false */)
{
    CTIMEElementBase *pElem = NULL;
    HRESULT hr = GetItemByName(lCollectionIndex, pwszName, lIndex, &pElem, fCaseSensitive);
    if (FAILED(hr) ||
        pElem == NULL)
    {
        TraceTag((tagError, "CCollectionCache::GetDisp - GetItemByName() failed"));
        return (pElem==NULL)?E_FAIL:hr;
    }

    Assert(pElem != NULL);

    return GetOuterDisp(lCollectionIndex, pElem, ppDisp);
} // GetDisp (long, const WCHAR *, long, IDispatch **, bool)

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Get IDispatch given a name.  Could return
//              either a CTIMEElementBase or sub collection depending
//              on results.
//************************************************************

HRESULT
CCollectionCache::GetDisp(long         lCollectionIndex,
                          const WCHAR *pwszName,
                          bool         fTagName,
                          IDispatch  **ppDisp,
                          bool         fCaseSensitive /* = false */)
{
    CPtrAry<CTIMEElementBase *> *rgNamed = NULL;
    HRESULT                      hr = S_OK;

    // figure out if we have this collection already built
    // return this named collection if it already exists.
    CCacheItem *pce = NULL;

    Assert(ppDisp != NULL);
    *ppDisp = NULL;

    long lSize = m_rgItems->Size();
    for (long lIndex = m_lReservedSize; lIndex < lSize; lIndex++)
    {
        pce = (*m_rgItems)[lIndex];

        // if CaseSensitivites match and
        //    Index matches DependentIndex
        //    either a tag or named collection
        bool fIsCaseSensitive = pce->m_fIsCaseSensitive ? true : false;

        if ((fIsCaseSensitive == fCaseSensitive) && //lint !e731
            (lCollectionIndex == pce->m_lDependentIndex) &&
            ((fTagName && pce->m_cctype == ctTag) ||
             (!fTagName && pce->m_cctype == ctNamed)))
        {
            // compare names
            long lCompare;
            if (fCaseSensitive)
                lCompare = StrCmpW(pwszName, pce->m_bstrName);
            else
                lCompare = StrCmpIW(pwszName, pce->m_bstrName);

            // if we found a match, we are done
            if (lCompare == 0)
            {
                // addref IDispatch since we returning it
                pce->m_pDisp->AddRef();
                *ppDisp = pce->m_pDisp;
                return S_OK;
            }
        }
    }

    // Build a list of named elements.
    hr = BuildNamedArray(lCollectionIndex, pwszName, fTagName, &rgNamed, fCaseSensitive);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::GetDisp - BuildNamedArray() failed"));
        return hr;
    }

    // if we found nothing and are NOT enumerating tags, return
    // not a failure case
    if ((rgNamed->Size() == 0) && !fTagName)
    {
        delete rgNamed;
        return DISP_E_MEMBERNOTFOUND;
    }

    // if only one element was found and we are NOT
    // enumerating tags, then QI for IDispatch for that
    // element and return it.  This only happens in ::item.
    if ((rgNamed->Size() == 1) && !fTagName)
    {
        hr = GetOuterDisp(lCollectionIndex, (*rgNamed)[0], ppDisp);
        Assert(ppDisp != NULL);

        // return ppDisp and release the array.
        delete rgNamed;
        if (FAILED(hr)) {
            TraceTag((tagError, "CCollectionCache::GetDisp - GetOuterDisp() failed"));
        }
        return hr;
    }

    // We found more than one item.  Initialize global list
    // and return IDispatch of collection.
    long lNewIndex = m_rgItems->Size();

    // create new cache item
    pce = NEW CCacheItem();
    if (pce == NULL)
    {
        TraceTag((tagError, "CCollectionCache::GetDisp - unable to alloc memory for cache item"));
        delete rgNamed;
        return E_OUTOFMEMORY;
    }

    // assign pointer to new cache item
    hr = m_rgItems->Append(pce);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::GetDisp - Append() failed"));
        delete pce;
        delete rgNamed;
        return hr;
    }

    hr = CreateCollectionHelper(ppDisp, lNewIndex);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::GetDisp - CreateCollectionHelper() failed"));
        delete rgNamed;
        return hr; //lint !e429
    }

    Assert(*ppDisp != NULL);

    // init name
    pce->m_bstrName = SysAllocString(pwszName);
    if (pce->m_bstrName == NULL)
    {
        ReleaseInterface(*ppDisp);
        delete rgNamed;
        TraceTag((tagError, "CCollectionCache::GetDisp - unable to alloc mem for string"));
        return E_OUTOFMEMORY; //lint !e429
    }

    pce->m_pDisp            = *ppDisp;
    pce->m_rgElem           = rgNamed;
    pce->m_lDependentIndex  = lCollectionIndex;       // Remember the index we depend on.
    pce->m_cctype           = fTagName ? ctTag : ctNamed;
    pce->m_fInvalid         = false;
    pce->m_fIsCaseSensitive = fCaseSensitive;

    // The collection this named collection was built from is now
    // used to rebuild (ensure) this collection. so we need to
    // put a reference on it so that it will not go away.
    // The matching Release() will be done in the dtor
    // although it is not necessary to addref the reserved collections
    // it is done anyhow, simply for consistency.  This addref
    // only needs to be done for non-reserved collections
    if (lNewIndex >= m_lReservedSize)
    {
        (*ppDisp)->AddRef();
    }

    return S_OK; //lint !e429
} // GetDisp (long, const WCHAR *, bool, IDispatch **, bool)

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Get the number of items in this collection.
//              The default implementation of this method uses
//              EnumStart and EnumNextElement to tally the number
//              of items.  For some subclasses of collection, there
//              will be more efficient means of doing this (e.g.
//              the item count may be stored explicitly.)
//************************************************************

HRESULT
CCollectionCache::GetItemCount(long lCollectionIndex, long *plCount)
{
    Assert(plCount != NULL);
    *plCount = 0;

    if (IsChildrenCollection(lCollectionIndex))
    {
        Assert(m_pBase != NULL);
        *plCount = m_pBase->GetImmediateChildCount();
        return S_OK;
    }
    else if (IsAllCollection(lCollectionIndex))
    {
        Assert(m_pBase != NULL);
        *plCount = m_pBase->GetAllChildCount();
        return S_OK;
    }
    else
    {
        Assert( ((*m_rgItems)[lCollectionIndex]->m_cctype == ctNamed) ||
                ((*m_rgItems)[lCollectionIndex]->m_cctype == ctTag) );

        // must be standard array.  (i.e. sub-collection
        // move to correct offset and find size of array
        *plCount = (*m_rgItems)[lCollectionIndex]->m_rgElem->Size();
        return S_OK;
    }
} // GetItemCount

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Get an indexed item.  The default implementation
//              uses EnumStart and EnumNextElement to scan through
//              the items.  For some subclasses of collection, there
//              will be more efficient means of doing this (e.g.
//              the items are stored in a contiguous array, making
//              random access of the items trivial.)  If the index
//              is out of range, this method will still return
//              S_OK, but pElem will contain NULL.
//************************************************************

HRESULT
CCollectionCache::GetItemByIndex(long lCollectionIndex, long lElementIndex, CTIMEElementBase **ppElem, bool fContinueFromPreviousSearch, long lLast)
{
    Assert(ppElem != NULL);
    *ppElem = NULL;

    if (IsChildrenCollection(lCollectionIndex))
    {
        Assert(m_pBase != NULL);

        // check to see if index is greater than count
        long lChildCount = m_pBase->GetImmediateChildCount();
        if (lElementIndex < 0 || lElementIndex >= lChildCount)
        {
            return E_INVALIDARG;
        }

        *ppElem = m_pBase->GetChild(lElementIndex);
        return S_OK;
    }
    else if (IsAllCollection(lCollectionIndex))
    {
        // All Collection
        // Note: since this is iterative, check to see if we start at the
        //       beginning or from a previous spot.
        long lCount = lLast;
        Assert(lElementIndex >= lLast);
        if (!fContinueFromPreviousSearch)
        {
            lCount = 0;
            EnumStart();
        }

        for (;;)
        {
            HRESULT hr = EnumNextElement(lCollectionIndex, ppElem);
            if (FAILED(hr))
            {
                TraceTag((tagError,  "CCollectionCache::GetItemByIndex - EnumNextElement() failed"));
                return hr;
            }

            Assert(ppElem != NULL);
            if (*ppElem == NULL)
            {
                // we have exceeded the bounds of the collection,
                // and therefor this is an invalid index
                return E_INVALIDARG;
            }

            // Keep scanning until we reach lElementIndex or the
            // last item in the collection.
            if (lElementIndex == lCount)
                break;
            lCount++;
        }
        return S_OK;
    }
    else
    {
        // must be standard array
        // get element at index
        CCacheItem *pce = (*m_rgItems)[lCollectionIndex];
        if ( (lElementIndex < 0) ||
             (lElementIndex >= pce->m_rgElem->Size()) )
        {
            TraceTag((tagError, "CCollectionCache::GetItemByIndex - invalid index"));
            return E_INVALIDARG;
        }

        *ppElem = (*pce->m_rgElem)[lElementIndex];
        return S_OK;
    }
} // GetItemByIndex


//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    Return an item in the collection with a
//              specified id.  If no such item is found,
//              pElem will contain NULL.
//************************************************************

HRESULT
CCollectionCache::GetItemByName(long lCollectionIndex, const WCHAR *pwszName, long lElementIndex, CTIMEElementBase **ppElem, bool fCaseSensitive)
{
    long    lItem = 0;

    Assert(ppElem != NULL);
    *ppElem = NULL;

    if (IsAllCollection(lCollectionIndex) ||
        IsChildrenCollection(lCollectionIndex))
    {
        EnumStart();

        for (;;)
        {
            HRESULT hr = EnumNextElement(lCollectionIndex, ppElem);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::GetItemByName - EnumNextElement() failed"));
                return hr;
            }

            // See if this was the last item in the collection
            if (*ppElem == NULL)
                break;

            // Compare the element's id to the target id
            if (CompareName(*ppElem, pwszName, false, fCaseSensitive))
            {
                // check to see if we are on specified index
                if (lElementIndex == lItem)
                    return S_OK;

                // continue looking
                lItem++;
            }
        }
        // not an error condition
        return DISP_E_MEMBERNOTFOUND;
    }
    else
    {
        long               lSize = (*m_rgItems)[lCollectionIndex]->m_rgElem->Size();
        CTIMEElementBase  *pElem = NULL;

        // loop thru array, looking for a match.
        // if an index is specified, then keep looking until index condition is met.
        for (long lIndex = 0; lIndex < lSize; lIndex++)
        {
            pElem = (*(*m_rgItems)[lCollectionIndex]->m_rgElem)[lIndex];

            Assert(pElem != NULL);

            if (CompareName(pElem, pwszName, false, fCaseSensitive))
            {
                    // check to see if we are on specified index
                    if (lElementIndex == lItem)
                    {
                        *ppElem = pElem;
                        return S_OK;
                    }

                    // continue looking
                    lItem++;
            }
        }

        // NOTE: if we got here, we didn't find anything
        return DISP_E_MEMBERNOTFOUND;
    }
} // GetItemByName

//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    This function initializes variables so we can
//              start walking the tree.
//************************************************************

void
CCollectionCache::EnumStart()
{
    m_pElemEnum = m_pBase;
    m_lEnumItem = 0;
} // EnumStart


//************************************************************
// Author:      twillie
// Created:     02/06/98
// Abstract:    This function does the walking of our heirarchial
//              tree.
//************************************************************

HRESULT
CCollectionCache::EnumNextElement(long lCollectionIndex, CTIMEElementBase **ppElem)
{
    HRESULT hr;
    Assert(ppElem != NULL);
    *ppElem = NULL;

    if (IsChildrenCollection(lCollectionIndex))
    {
        hr = GetItemByIndex(lCollectionIndex, m_lEnumItem, ppElem);
        m_lEnumItem++;
        return hr;
    }
    else
    {
        long lChildCount = m_pElemEnum->GetImmediateChildCount();
        while (m_lEnumItem == lChildCount)
        {
            // We're one past the last element in the current child element
            // being enumerated.
            if (m_pElemEnum == m_pBase)
            {
                // We're done if we reached the last item in the
                // root element.
                *ppElem = NULL;
                return S_OK;
            }
            else
            {
                // Otherwise, back up the tree until we find some children
                // that we haven't traversed yet.
                CTIMEElementBase *pElemParent = m_pElemEnum->GetParent();
                Assert(pElemParent != NULL);

                // It's probably better if we maintain a stack of offsets
                // during traversal, but since no element can appear more
                // than once in the scene graph, we can scan to find our
                // offset in the parent's child array.
                lChildCount = pElemParent->GetImmediateChildCount();
                m_lEnumItem = 0;

                while (m_lEnumItem < lChildCount)
                {
                    CTIMEElementBase *pElemChild = pElemParent->GetChild(m_lEnumItem);
                    m_lEnumItem++;
                    if (pElemChild == m_pElemEnum)
                        break;
                }

                m_pElemEnum = pElemParent;
            }
        }

        // This can only be the result of scene graph corruption
        // during traversal.
        Assert(m_lEnumItem < lChildCount);

        if (NULL == m_pElemEnum)
        {
            return E_UNEXPECTED;
        }

        *ppElem = m_pElemEnum->GetChild(m_lEnumItem);
        Assert(*ppElem != NULL);

        // Advance to the next element.  If the current element is
        // has children, we move down the tree and start enumerating its
        // children.  Otherwise, we'll move on to the next child
        // of m_pElemEnum.
        if ((*ppElem)->GetImmediateChildCount() == 0)
        {
            m_lEnumItem++;
        }
        else
        {
            m_lEnumItem = 0;
            m_pElemEnum = *ppElem;
        }

        return S_OK;
    }
} // EnumNextElement


//************************************************************
//
// End of File
//
//************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\tags\tagsattr.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: tagsattr.cpp
//
//  Contents: attributes for tags
//
//------------------------------------------------------------------------------------

#include "headers.h"
//#include "eventelm.h"
#include "bodyelm.h"
#include "tokens.h"
#include "attr.h"


//+-----------------------------------------------------------------------------------
//
// Time body Element Attributes
//
//------------------------------------------------------------------------------------

//+-----------------------------------------------------------------------------------
//
// Static functions for persistence (used by the TIME_PERSISTENCE_MAP below)
//
//------------------------------------------------------------------------------------

#define TBE CTIMEBodyElement

                // Function Name    // Class // Attr Accessor      // COM put_ fn     // COM get_ fn   // IDL Arg type

//+-----------------------------------------------------------------------------------
//
//  Declare TIME_PERSISTENCE_MAP
//
//------------------------------------------------------------------------------------

BEGIN_TIME_PERSISTENCE_MAP(CTIMEBodyElement)
                           // Attr Name      // Function Name

END_TIME_PERSISTENCE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timebvr\activeele.h ===
/*******************************************************************************
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * File: ActiveEle.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _ACTIVEELE_H
#define _ACTIVEELE_H

#include "timeelmbase.h"

class
__declspec(uuid("efbad7f8-3f94-11d2-b948-00c04fa32195")) 
CActiveElementCollection :  
    public CComObjectRootEx<CComSingleThreadModel>, 
    public CComCoClass<CActiveElementCollection, &__uuidof(CActiveElementCollection)>,
    public ITIMEDispatchImpl<ITIMEActiveElementCollection, &IID_ITIMEActiveElementCollection>
{
    public:
        CActiveElementCollection(CTIMEElementBase & elm);
        virtual ~CActiveElementCollection();
        HRESULT ConstructArray();
        //ITimeActiveElementCollection methods
        
        STDMETHOD(get_length)(/*[out, retval]*/ long* len);
        STDMETHOD(get__newEnum)(/*[out, retval]*/ IUnknown** p);
        STDMETHOD(item)(/*[in]*/ VARIANT varIndex, /*[out, retval]*/ VARIANT* pvarResult);

        STDMETHOD(addActiveElement)(IUnknown *pUnk);
        STDMETHOD(removeActiveElement)(IUnknown *pUnk);
        
        //IUnknown interface
        STDMETHOD(QueryInterface)(REFIID iid, void **ppvObject)
        {   return _InternalQueryInterface(iid, ppvObject); };
        STDMETHOD_(ULONG, AddRef)()
        {   return InternalAddRef(); };
        STDMETHOD_(ULONG, Release)()
        { 
            ULONG l = InternalRelease();
            if (l == 0) delete this;
            return l;
        };


        // QI Map
        BEGIN_COM_MAP(CActiveElementCollection)
            COM_INTERFACE_ENTRY(ITIMEActiveElementCollection)
            COM_INTERFACE_ENTRY(IDispatch)
        END_COM_MAP_X();

    protected:
        CPtrAry<IUnknown *>      *m_rgItems;  //an array of IUnknown pointers
        CTIMEElementBase &        m_elm;

}; //lint !e1712


class CActiveElementEnum :
    public CComObjectRootEx<CComSingleThreadModel>,
    public IEnumVARIANT
{
   public:
        CActiveElementEnum(CActiveElementCollection &EleCol);
        virtual ~CActiveElementEnum();

        // IEnumVARIANT methods
        STDMETHOD(Clone)(IEnumVARIANT **ppEnum);
        STDMETHOD(Next)(unsigned long celt, VARIANT *rgVar, unsigned long *pCeltFetched);
        STDMETHOD(Reset)();
        STDMETHOD(Skip)(unsigned long celt);
        void SetCurElement(unsigned long celt);
                        
        //IUnknown interface
        STDMETHOD(QueryInterface)(REFIID iid, void **ppvObject)
        {   return _InternalQueryInterface(iid, ppvObject); };
        STDMETHOD_(ULONG, AddRef)()
        {   return InternalAddRef(); };
        STDMETHOD_(ULONG, Release)()
        { 
            ULONG l = InternalRelease();
            if (l == 0) delete this;
            return l;
        };

        // QI Map
        BEGIN_COM_MAP(CActiveElementEnum)
            COM_INTERFACE_ENTRY(IEnumVARIANT)
        END_COM_MAP_X();

    protected:
        long                        m_lCurElement;
        CActiveElementCollection  & m_EleCollection;
}; //lint !e1712



#endif /* _ACTIVEELE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\tags\factory.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/

#pragma once

#ifndef _FACTORY_H
#define _FACTORY_H

class ATL_NO_VTABLE CTIMEFactory
    : public CComObjectRootEx<CComSingleThreadModel>,
      public CComCoClass<CTIMEFactory, &CLSID_TIMEFactory>,
      public IElementBehaviorFactory,
      public IElementNamespaceFactory,
      public IObjectSafety,
      public ITIMEFactory
{
  public:
    CTIMEFactory();
    virtual ~CTIMEFactory();

    DECLARE_NOT_AGGREGATABLE(CTIMEFactory)

#if DBG
    const _TCHAR * GetName() { return __T("CTIMEFactory"); }
#endif

    // IElementBehaviorFactory
    
    STDMETHOD(FindBehavior)(LPOLESTR pchNameSpace,
                            LPOLESTR pchTagName,
                            IElementBehaviorSite * pUnkArg,
                            IElementBehavior ** ppBehavior);

    //
    // IElementNamespaceFactory
    //

    STDMETHOD(Create)(IElementNamespace * pNamespace);

    // IObjectSafetyImpl
    STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid,
                                         DWORD dwOptionSetMask,
                                         DWORD dwEnabledOptions);
    STDMETHOD(GetInterfaceSafetyOptions)(REFIID riid, 
                                         DWORD *pdwSupportedOptions, 
                                         DWORD *pdwEnabledOptions);
    
    // ITIMEFactory

    DECLARE_REGISTRY(CLSID_TIMEFactory,
                     LIBID __T(".TIMEFactory.1"),
                     LIBID __T(".TIMEFactory"),
                     0,
                     THREADFLAGS_BOTH);
    
    BEGIN_COM_MAP(CTIMEFactory)
        COM_INTERFACE_ENTRY(IElementBehaviorFactory)
        COM_INTERFACE_ENTRY(IElementNamespaceFactory)
        COM_INTERFACE_ENTRY(ITIMEFactory)
        COM_INTERFACE_ENTRY(IObjectSafety)
    END_COM_MAP();

  protected:
    long m_dwSafety;
};

#endif /* _FACTORY_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timebvr\currtimestate.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1998
//
//  File: src\time\src\currtimestate.cpp
//
//  Contents: TIME currTimeState object
//
//------------------------------------------------------------------------------------

#include "headers.h"
#include "timeelmbase.h"
#include "currtimestate.h"

//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMECurrTimeState::CTIMECurrTimeState
//
//  Synopsis:   init member variables
//
//  Arguments:  none
//
//  Returns:    nothing
//
//------------------------------------------------------------------------------------
CTIMECurrTimeState::CTIMECurrTimeState() :
    m_pTEB(NULL)
{
    // do nothing
} // CTIMECurrTimeState

//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMECurrTimeState::~CTIMECurrTimeState
//
//  Synopsis:   free member variables
//
//  Arguments:  none
//
//  Returns:    nothing
//
//------------------------------------------------------------------------------------
CTIMECurrTimeState::~CTIMECurrTimeState()
{
    m_pTEB = NULL;
}

//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMECurrTimeState::Init
//
//  Synopsis:   Store weak ref to containing CTIMEElementBase
//
//  Arguments:  pointer to containing CTIMEElementBase
//
//  Returns:    
//
//------------------------------------------------------------------------------------
void
CTIMECurrTimeState::Init(CTIMEElementBase * pTEB) 
{ 
    Assert(pTEB);
    m_pTEB = pTEB; 
} // Init


//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMECurrTimeState::Deinit
//
//  Synopsis:   Null out weak ref to containing CTIMEElementBase
//
//  Arguments:  pointer to containing CTIMEElementBase
//
//  Returns:    
//
//------------------------------------------------------------------------------------
void
CTIMECurrTimeState::Deinit()
{ 
    m_pTEB = NULL; 
} // Deinit


//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMECurrTimeState::get_isActive
//
//  Synopsis:   Call through to timing engine
//
//  Arguments:  out param
//
//  Returns:    S_OK, E_POINTER
//
//------------------------------------------------------------------------------------
STDMETHODIMP
CTIMECurrTimeState::get_isActive(/*[retval, out]*/ VARIANT_BOOL * pvbActive) 
{ 
    CHECK_RETURN_NULL(pvbActive);

    *pvbActive = VARIANT_FALSE;

    Assert(m_pTEB);
    
    if (m_pTEB->IsReady())
    {
        bool bIsActive = m_pTEB->GetMMBvr().IsActive();
        *pvbActive = bIsActive ? VARIANT_TRUE : VARIANT_FALSE;
    }

    RRETURN(S_OK);
} // get_isActive


//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMECurrTimeState::get_isOn
//
//  Synopsis:   Call through to timing engine
//
//  Arguments:  out param
//
//  Returns:    S_OK, E_POINTER
//
//------------------------------------------------------------------------------------
STDMETHODIMP
CTIMECurrTimeState::get_isOn(/*[retval, out]*/ VARIANT_BOOL * pvbOn) 
{ 
    CHECK_RETURN_NULL(pvbOn);

    *pvbOn = VARIANT_FALSE;

    Assert(m_pTEB);
    
    if (m_pTEB->IsReady())
    {
        bool bIsOn = m_pTEB->GetMMBvr().IsOn();
        *pvbOn = bIsOn ? VARIANT_TRUE : VARIANT_FALSE;
    }

    RRETURN(S_OK);
} // get_isOn


//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMECurrTimeState::get_isPaused
//
//  Synopsis:   Call through to timing engine
//
//  Arguments:  out param
//
//  Returns:    S_OK, E_POINTER
//
//------------------------------------------------------------------------------------
STDMETHODIMP
CTIMECurrTimeState::get_isPaused(/*[retval, out]*/ VARIANT_BOOL * pvbPaused) 
{ 
    CHECK_RETURN_NULL(pvbPaused);

    *pvbPaused = VARIANT_FALSE;

    Assert(m_pTEB);
    
    if (m_pTEB->IsReady())
    {
        *pvbPaused = m_pTEB->IsCurrPaused() ? VARIANT_TRUE : VARIANT_FALSE;
    }

    if (m_pTEB->GetParent() && *pvbPaused == VARIANT_TRUE)
    {
        *pvbPaused = m_pTEB->GetParent()->IsActive() || m_pTEB->GetParent()->GetMMBvr().IsDisabled() ? VARIANT_TRUE : VARIANT_FALSE;
    }

    RRETURN(S_OK);
} // get_isPaused


//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMECurrTimeState::get_repeatCount
//
//  Synopsis:   Call through to timing engine
//
//  Arguments:  out param
//
//  Returns:    S_OK, E_POINTER
//
//------------------------------------------------------------------------------------
STDMETHODIMP
CTIMECurrTimeState::get_repeatCount(/*[retval, out]*/ long * plCount)
{
    CHECK_RETURN_NULL(plCount);

    *plCount = 1L;

    Assert(m_pTEB);
    
    if (m_pTEB->IsReady())
    {
        *plCount = m_pTEB->GetMMBvr().GetCurrentRepeatCount();
    }

    RRETURN(S_OK);
} // get_repeatCount


//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMECurrTimeState::get_speed
//
//  Synopsis:   Call through to timing engine
//
//  Arguments:  out param
//
//  Returns:    S_OK, E_POINTER
//
//------------------------------------------------------------------------------------
STDMETHODIMP
CTIMECurrTimeState::get_speed(/*[retval, out]*/ float * pflSpeed) 
{ 
    CHECK_RETURN_NULL(pflSpeed);

    *pflSpeed = 1.0f;

    Assert(m_pTEB);
    
    if (m_pTEB->IsReady())
    {
        *pflSpeed = m_pTEB->GetMMBvr().GetCurrSpeed();
    }

    RRETURN(S_OK);
} // get_speed


//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMECurrTimeState::get_simpleTime
//
//  Synopsis:   Call through to timing engine
//
//  Arguments:  out param
//
//  Returns:    S_OK, E_POINTER
//
//------------------------------------------------------------------------------------
STDMETHODIMP
CTIMECurrTimeState::get_simpleTime(/*[retval, out]*/ double * pdblTime) 
{ 
    CHECK_RETURN_NULL(pdblTime);

    *pdblTime = 0.0;

    Assert(m_pTEB);
    
    if (m_pTEB->IsReady())
    {
        *pdblTime = m_pTEB->GetMMBvr().GetSimpleTime();
    }

    RRETURN(S_OK);
} // get_simpleTime

//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMECurrTimeState::get_segmentTime
//
//  Synopsis:   Call through to timing engine
//
//  Arguments:  out param
//
//  Returns:    S_OK, E_POINTER
//
//------------------------------------------------------------------------------------
STDMETHODIMP
CTIMECurrTimeState::get_segmentTime(/*[retval, out]*/ double * pdblTime) 
{ 
    CHECK_RETURN_NULL(pdblTime);

    *pdblTime = 0.0;

    Assert(m_pTEB);
    
    if (m_pTEB->IsReady())
    {
        *pdblTime = m_pTEB->GetMMBvr().GetSegmentTime();
    }

    RRETURN(S_OK);
} // get_segmentTime


//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMECurrTimeState::get_activeTime
//
//  Synopsis:   Call through to timing engine
//
//  Arguments:  out param
//
//  Returns:    S_OK, E_POINTER
//
//------------------------------------------------------------------------------------
STDMETHODIMP
CTIMECurrTimeState::get_activeTime(/*[retval, out]*/ double * pdblTime) 
{ 
    CHECK_RETURN_NULL(pdblTime);

    *pdblTime = 0.0;

    Assert(m_pTEB);
    
    if (m_pTEB->IsReady())
    {
        *pdblTime = m_pTEB->GetMMBvr().GetActiveTime();
    }

    RRETURN(S_OK);
} // get_activeTime


//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMECurrTimeState::get_activeBeginTime
//
//  Synopsis:   Call through to timing engine
//
//  Arguments:  out param
//
//  Returns:    S_OK, E_POINTER
//
//------------------------------------------------------------------------------------
STDMETHODIMP
CTIMECurrTimeState::get_parentTimeBegin(/*[retval, out]*/ double * pdblTime) 
{ 
    CHECK_RETURN_NULL(pdblTime);

    *pdblTime = TIME_INFINITE;

    Assert(m_pTEB);
    
    if (m_pTEB->IsReady())
    {
        *pdblTime = m_pTEB->GetMMBvr().GetActiveBeginTime();
    }

    RRETURN(S_OK);
} // get_activeBeginTime


//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMECurrTimeState::get_activeEndTime
//
//  Synopsis:   Call through to timing engine
//
//  Arguments:  out param
//
//  Returns:    S_OK, E_POINTER
//
//------------------------------------------------------------------------------------
STDMETHODIMP
CTIMECurrTimeState::get_parentTimeEnd(/*[retval, out]*/ double * pdblTime) 
{ 
    CHECK_RETURN_NULL(pdblTime);

    *pdblTime = TIME_INFINITE;

    Assert(m_pTEB);
    
    if (m_pTEB->IsReady())
    {
        *pdblTime = m_pTEB->GetMMBvr().GetActiveEndTime();
    }

    RRETURN(S_OK);
} // get_activeEndTime


//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMECurrTimeState::get_activeDur
//
//  Synopsis:   Call through to timing engine
//
//  Arguments:  out param
//
//  Returns:    S_OK, E_POINTER
//
//------------------------------------------------------------------------------------
STDMETHODIMP
CTIMECurrTimeState::get_activeDur(/*[retval, out]*/ double * pdblTime) 
{ 
    CHECK_RETURN_NULL(pdblTime);

    *pdblTime = TIME_INFINITE;

    Assert(m_pTEB);
    
    if (m_pTEB->IsReady())
    {
        *pdblTime = m_pTEB->GetMMBvr().GetActiveDur();
    }

    RRETURN(S_OK);
} // get_activeDur


//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMECurrTimeState::get_segmentDur
//
//  Synopsis:   Call through to timing engine
//
//  Arguments:  out param
//
//  Returns:    S_OK, E_POINTER
//
//------------------------------------------------------------------------------------
STDMETHODIMP
CTIMECurrTimeState::get_segmentDur(/*[retval, out]*/ double * pdblTime) 
{ 
    CHECK_RETURN_NULL(pdblTime);

    *pdblTime = TIME_INFINITE;

    Assert(m_pTEB);
    
    if (m_pTEB->IsReady())
    {
        *pdblTime = m_pTEB->GetMMBvr().GetSegmentDur();
    }

    RRETURN(S_OK);
} // get_segmentDur

//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMECurrTimeState::NotifyPropertyChanged
//
//  Synopsis:   Notifies clients that a property has changed
//              (Copied from CBaseBehavior)
//
//  Arguments:  dispid      DISPID of property that has changed      
//
//  Returns:    Success     when function completes successfully
//
//------------------------------------------------------------------------------------
HRESULT
CTIMECurrTimeState::NotifyPropertyChanged(DISPID dispid)
{
    HRESULT hr;

    IConnectionPoint *pICP;
    IEnumConnections *pEnum = NULL;

    // This object does not persist anything, hence commenting out the following
    // m_fPropertiesDirty = true;

    hr = GetConnectionPoint(IID_IPropertyNotifySink,&pICP); 
    if (SUCCEEDED(hr) && pICP != NULL)
    {
        hr = pICP->EnumConnections(&pEnum);
        ReleaseInterface(pICP);
        if (FAILED(hr))
        {
            //DPF_ERR("Error finding connection enumerator");
            //return SetErrorInfo(hr);
            TIMESetLastError(hr);
            goto done;
        }
        CONNECTDATA cdata;
        hr = pEnum->Next(1, &cdata, NULL);
        while (hr == S_OK)
        {
            // check cdata for the object we need
            IPropertyNotifySink *pNotify;
            hr = cdata.pUnk->QueryInterface(IID_TO_PPV(IPropertyNotifySink, &pNotify));
            cdata.pUnk->Release();
            if (FAILED(hr))
            {
                //DPF_ERR("Error invalid object found in connection enumeration");
                //return SetErrorInfo(hr);
                TIMESetLastError(hr);
                goto done;
            }
            hr = pNotify->OnChanged(dispid);
            ReleaseInterface(pNotify);
            if (FAILED(hr))
            {
                //DPF_ERR("Error calling Notify sink's on change");
                //return SetErrorInfo(hr);
                TIMESetLastError(hr);
                goto done;
            }
            // and get the next enumeration
            hr = pEnum->Next(1, &cdata, NULL);
        }
    }
done:
    if (NULL != pEnum)
    {
        ReleaseInterface(pEnum);
    }

    return hr;
} // NotifyPropertyChanged


//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMECurrTimeState::GetConnectionPoint
//
//  Synopsis:   Gets the connection point for the given outgoing interface. This is abstracted
//              out to allow for future modifications to the inheritance hierarchy.
//
//  Arguments:  dispid      DISPID of property that has changed      
//
//------------------------------------------------------------------------------------
HRESULT 
CTIMECurrTimeState::GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP)
{
    return FindConnectionPoint(riid, ppICP);
} // GetConnectionPoint

//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMECurrTimeState::get_simpleDur
//
//  Synopsis:   Call through to timing engine
//
//  Arguments:  out param
//
//  Returns:    S_OK, E_POINTER
//
//------------------------------------------------------------------------------------
STDMETHODIMP
CTIMECurrTimeState::get_simpleDur(/*[retval, out]*/ double * pdblDur) 
{ 
    CHECK_RETURN_NULL(pdblDur);

    *pdblDur = TIME_INFINITE;

    Assert(m_pTEB);
    
    if (m_pTEB->IsReady())
    {
        *pdblDur = m_pTEB->GetMMBvr().GetSimpleDur();
    }

    RRETURN(S_OK);
} // get_simpleDur

//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMECurrTimeState::get_state
//
//  Synopsis:   Returns timeState of this element (active, inactive or holding)
//
//  Arguments:  [ptsState]     out param
//
//  Returns:    [E_POINTER]     bad arg 
//              [S_OK]          success
//
//------------------------------------------------------------------------------------

STDMETHODIMP
CTIMECurrTimeState::get_state(TimeState * ptsState)
{
    CHECK_RETURN_NULL(ptsState);

    *ptsState = m_pTEB->GetTimeState();

    RRETURN(S_OK);
}


//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMECurrTimeState::get_stateString
//
//  Synopsis:   Gets timeState and translates it to the appropriate string (active, inactive or holding)
//
//  Arguments:  [pbstrState]     out param
//
//  Returns:    [E_POINTER]     bad arg 
//              [S_OK]          success
//
//------------------------------------------------------------------------------------

STDMETHODIMP
CTIMECurrTimeState::get_stateString(BSTR * pbstrState)
{
    HRESULT hr;
    
    CHECK_RETURN_SET_NULL(pbstrState);

    switch (m_pTEB->GetTimeState())
    {
      case TS_Active:
      {
          *pbstrState = SysAllocString(WZ_STATE_ACTIVE);
          break;
      }

      default:
      case TS_Inactive:
      {
          *pbstrState = SysAllocString(WZ_STATE_INACTIVE);
          break;
      }

      case TS_Holding:
      {
          *pbstrState = SysAllocString(WZ_STATE_HOLDING);
          break;
      }

      case TS_Cueing:
      {
          *pbstrState = SysAllocString(WZ_STATE_CUEING);
          break;
      }

      case TS_Seeking:
      {
          *pbstrState = SysAllocString(WZ_STATE_SEEKING);
          break;
      }
    } // switch

    if (NULL == *pbstrState)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMECurrTimeState::get_progress
//
//  Synopsis:   Call through to timing engine
//
//  Arguments:  out param
//
//  Returns:    S_OK, E_POINTER
//
//------------------------------------------------------------------------------------
STDMETHODIMP
CTIMECurrTimeState::get_progress(double * pdblProgress)
{
    CHECK_RETURN_NULL(pdblProgress);

    *pdblProgress = 0.0;

    Assert(m_pTEB);
    
    if (m_pTEB->IsReady())
    {
        *pdblProgress = m_pTEB->GetMMBvr().GetProgress();
    }

    RRETURN(S_OK);
} // get_progress

//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMECurrTimeState::get_volume
//
//  Synopsis:   Call through to timing engine
//
//  Arguments:  out param
//
//  Returns:    S_OK, E_POINTER
//
//------------------------------------------------------------------------------------
STDMETHODIMP
CTIMECurrTimeState::get_volume(float * pfltVol)
{
    CHECK_RETURN_NULL(pfltVol);

    *pfltVol = 1.0f;

    Assert(m_pTEB);
    
    if (m_pTEB->IsReady())
    {
        *pfltVol = m_pTEB->GetCascadedVolume() * 100;
    }

    RRETURN(S_OK);
} // get_volume

//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMECurrTimeState::get_isMuted
//
//  Synopsis:   Call through to timing engine
//
//  Arguments:  out param
//
//  Returns:    S_OK, E_POINTER
//
//------------------------------------------------------------------------------------
STDMETHODIMP
CTIMECurrTimeState::get_isMuted(VARIANT_BOOL * pvbMuted)
{
    CHECK_RETURN_NULL(pvbMuted);
    bool bIsMuted = false;

    Assert(m_pTEB);
    
    if (m_pTEB->IsReady())
    {
        bIsMuted = m_pTEB->GetCascadedMute();
    }

    *pvbMuted = (bIsMuted)?VARIANT_TRUE:VARIANT_FALSE;

    RRETURN(S_OK);
    
} // get_isMuted
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timebvr\activeele.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * File: ActiveEle.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#include "headers.h"
#include "activeele.h"

//*******************************************************************************
// *  CActiveElementCollection
// *******************************************************************************
CActiveElementCollection::CActiveElementCollection(CTIMEElementBase & elm)
: m_rgItems(NULL),
  m_elm(elm)
{
    
}

///////////////////////////////////////////////////////////////
//  Name: ConstructArray
// 
//  Abstract:  Handles allocation of the items array if it 
//             is ever accessed.
///////////////////////////////////////////////////////////////
HRESULT CActiveElementCollection::ConstructArray()
{
    HRESULT hr = S_OK;

    m_rgItems = NEW CPtrAry<IUnknown *>;
    if (m_rgItems == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;

  done:

    return hr;
}

///////////////////////////////////////////////////////////////
//  Name: ~CActiveElementCollection
// 
//  Abstract:  Handles destruction of the items array and
//             releasing all pointers in the array
///////////////////////////////////////////////////////////////
CActiveElementCollection::~CActiveElementCollection()
{
    if (m_rgItems)
    {
        while (m_rgItems->Size() > 0)
        {   //release and delete the first element of the list until there are no more elements
            m_rgItems->ReleaseAndDelete(0);  //release the 
        }

        // delete array
        delete m_rgItems;
        m_rgItems = NULL;
    }
}

///////////////////////////////////////////////////////////////
//  Name: get_length
// 
//  Abstract:  returns the size of the array
///////////////////////////////////////////////////////////////
STDMETHODIMP
CActiveElementCollection::get_length(long *len)
{
    HRESULT hr = S_OK;

    if (len == NULL)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    if (m_rgItems == NULL)
    {
        hr = ConstructArray();
        if (FAILED(hr))
        {
            goto done;
        }
    }
    *len = m_rgItems->Size();

    hr = S_OK;

  done:

    return hr;
}

///////////////////////////////////////////////////////////////
//  Name: get__newEnum
// 
//  Abstract:  Creates the IEnumVARIANT class for this
//             collection.
///////////////////////////////////////////////////////////////
STDMETHODIMP
CActiveElementCollection::get__newEnum(IUnknown** p)
{
    HRESULT hr = S_OK;
    CActiveElementEnum *pNewEnum = NULL;
    
    if (p == NULL)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    pNewEnum = NEW CActiveElementEnum(*this);
    if (pNewEnum == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = THR(pNewEnum->QueryInterface(IID_IUnknown, (void **)p));
    if (FAILED(hr))
    {
        goto done;
    }
    
  done:
    if (FAILED(hr))
    {
        if (pNewEnum != NULL)
        {
            delete pNewEnum;
        }
    }
    return hr;
}

///////////////////////////////////////////////////////////////
//  Name: item
// 
//  Abstract:  returns the item requested by the pvarIndex.  
//             pvarIndex must be a valid integer value.
///////////////////////////////////////////////////////////////
STDMETHODIMP
CActiveElementCollection::item(VARIANT varIndex, VARIANT* pvarResult)
{
    HRESULT hr = S_OK;
    VARIANT vIndex;
    IUnknown *pUnk = NULL;  //do not free this, it is not referenced.
    IDispatch *pDisp = NULL; //do not free this, it is passed as a return value.

    if (m_rgItems == NULL)
    {
        hr = ConstructArray();
        if (FAILED(hr))
        {
            goto done;
        }
    }

    if (pvarResult == NULL)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    VariantInit(&vIndex);

    hr = THR(VariantChangeTypeEx(&vIndex, &varIndex, LCID_SCRIPTING, 0, VT_I4));
    if (FAILED(hr))
    {
        hr = E_INVALIDARG;
        goto done;
    }
    
    if (vIndex.lVal >= 0 && vIndex.lVal <= m_rgItems->Size() - 1)
    {
        pUnk = m_rgItems->Item(vIndex.lVal);
        
        hr = THR(pUnk->QueryInterface(IID_IDispatch, (void **)&pDisp));
        if (FAILED(hr))
        {
            hr = E_FAIL;
            goto done;
        }
        VariantClear(pvarResult);
        pvarResult->vt = VT_DISPATCH;
        pvarResult->pdispVal = pDisp;
    }
    else
    {
        hr = E_INVALIDARG;
        goto done;
    }

    hr = S_OK;
    
  done:

    VariantClear(&vIndex);

    return hr;
}


///////////////////////////////////////////////////////////////
//  Name: addActiveElement
// 
//  Abstract:  Adds an element to the list by adding it's 
//             IUnknown pointer.
///////////////////////////////////////////////////////////////
STDMETHODIMP
CActiveElementCollection::addActiveElement(IUnknown *pUnk)
{
    HRESULT hr = S_OK;
    long lCount = 0;
    long lIndex = 0;
    bool bInList = false;

    if (m_rgItems == NULL)
    {
        hr = ConstructArray();
        if (FAILED(hr))
        {
            goto done;
        }
    }

    //check to see if the element is already in the list    
    lCount = m_rgItems->Size();
    lIndex = lCount - 1;
    while (lIndex >= 0 && bInList == false)
    {
        //compare to find the right object
        IUnknown *pItem = m_rgItems->Item(lIndex);
        if (pItem == pUnk)
        {
            bInList = true;
        }
        lIndex--;
    }
    //only add the element if it is not already in the list
    if (bInList == false)
    {
        pUnk->AddRef();
        m_rgItems->Append(pUnk);
        m_elm.NotifyPropertyChanged(DISPID_TIMEELEMENT_ACTIVEELEMENTS);
    }

  done:
    return hr;
}



///////////////////////////////////////////////////////////////
//  Name: removeActiveElement
// 
//  Abstract:  Removes an element to the list by searching for 
//             matching IUnknown pointers.  This is only valid
//             if the pointers remain IUnknown pointers because
//             an object must always return the same IUnknown
//             pointer, but that is not true for other interfaces.
///////////////////////////////////////////////////////////////
STDMETHODIMP
CActiveElementCollection::removeActiveElement(IUnknown *pUnk)
{
    HRESULT hr;
    long lCount = 0, lIndex = 0;

    if (m_rgItems == NULL)
    {
        hr = S_OK;
        goto done;
    }

    lCount = m_rgItems->Size();
    for (lIndex = lCount - 1; lIndex >= 0; lIndex--)
    {
        //compare to find the right object
        IUnknown *pItem = m_rgItems->Item(lIndex);
        if (pItem == pUnk)
        {
            m_rgItems->ReleaseAndDelete(lIndex);
            m_elm.NotifyPropertyChanged(DISPID_TIMEELEMENT_ACTIVEELEMENTS);
        }
    }
    
    hr = S_OK;

  done:
    RRETURN(hr);
}

//*******************************************************************************
// *  CActiveElementEnum
// *******************************************************************************
CActiveElementEnum::CActiveElementEnum(CActiveElementCollection & EleCol)
: m_EleCollection(EleCol),
  m_lCurElement(0)
{
    m_EleCollection.AddRef();
}



CActiveElementEnum::~CActiveElementEnum()
{
    m_EleCollection.Release();
}


///////////////////////////////////////////////////////////////
//  Name: Clone
// 
//  Abstract:  Creates a new instance of this object and 
//             sets the m_lCurElement in the new object to
//             the same value as this object.
///////////////////////////////////////////////////////////////
STDMETHODIMP
CActiveElementEnum::Clone(IEnumVARIANT **ppEnum)
{
    HRESULT hr = S_OK;
    CActiveElementEnum *pNewEnum = NULL;
    if (ppEnum == NULL)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    pNewEnum = NEW CActiveElementEnum(m_EleCollection);
    if (pNewEnum == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    
    pNewEnum->SetCurElement(m_lCurElement);
    hr = THR(pNewEnum->QueryInterface(IID_IEnumVARIANT, (void **)ppEnum));
    if (FAILED(hr))
    {
        *ppEnum = NULL;
        goto done;
    }

  done:
    if (FAILED(hr))
    {
        if (pNewEnum != NULL)
        {
            delete pNewEnum;
        }
    }
    return hr;
}

///////////////////////////////////////////////////////////////
//  Name: Next
// 
//  Abstract:  
///////////////////////////////////////////////////////////////
STDMETHODIMP
CActiveElementEnum::Next(unsigned long celt, VARIANT *rgVar, unsigned long *pCeltFetched)
{
    HRESULT hr = S_OK;
    unsigned long i = 0;
    long len = 0;
    long iCount = 0;

    if (rgVar == NULL)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    
    //initialize the list
    for (i = 0; i < celt; i++)
    {
        VariantInit(&rgVar[i]);   
    }

    for (i = 0; i < celt; i++)
    {    
        CComVariant vCount;
        VariantInit(&vCount);
     
        hr = THR(m_EleCollection.get_length(&len));
        if (FAILED(hr))
        {
            goto done;
        }
        if (m_lCurElement < len)
        {
            vCount.vt = VT_I4;
            vCount.lVal = m_lCurElement;
            hr = THR(m_EleCollection.item(vCount, &rgVar[i]));
            if (FAILED(hr))
            {
                goto done;
            }
            m_lCurElement++;
            iCount++;
        }
        else
        {
            hr = S_FALSE;
            goto done;
        }
    }

  done:

    if (pCeltFetched != NULL)
    {
        *pCeltFetched = iCount;
    }

    return hr;
}

///////////////////////////////////////////////////////////////
//  Name: Reset
// 
//  Abstract:  
///////////////////////////////////////////////////////////////
STDMETHODIMP
CActiveElementEnum::Reset()
{    
    m_lCurElement = 0;
    return S_OK;
}

///////////////////////////////////////////////////////////////
//  Name: Skip
// 
//  Abstract:  Skips the specified number of elements in the list.
//             This returns S_FALSE if there are not enough elements
//             in the list to skip.
///////////////////////////////////////////////////////////////
STDMETHODIMP
CActiveElementEnum::Skip(unsigned long celt)
{
    HRESULT hr = S_OK;
    long lLen = 0;

    m_lCurElement = m_lCurElement + (long)celt;
    hr = THR(m_EleCollection.get_length(&lLen));
    if (FAILED(hr))
    {
        goto done;
    }
    
    if (m_lCurElement >= lLen)
    {
        m_lCurElement = lLen;
        hr = S_FALSE;
    }

  done:

    return hr;
}


///////////////////////////////////////////////////////////////
//  Name: SetCurElement
// 
//  Abstract:  Sets the current index to the value specified
//             by celt.
///////////////////////////////////////////////////////////////
void
CActiveElementEnum::SetCurElement(unsigned long celt)
{
    HRESULT hr = S_OK;
    long lLen = 0;

    m_lCurElement = (long)celt;
    hr = THR(m_EleCollection.get_length(&lLen));
    if (FAILED(hr))
    {
        goto done;
    }
    
    if (m_lCurElement >= lLen)
    {
        m_lCurElement = lLen;
    }

  done:

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timebvr\collect.h ===
#ifndef __COLLECT_H_
#define __COLLECT_H_

//************************************************************
//
// Filename:    collect.h
//
// Created:     09/25/97
//
// Author:      twillie
//
// Abstract:    Collection implementation.
//              
//************************************************************

#include "dispex.h"
#include "atomtable.h"
#include "timeelmbase.h"
#include "array.h"
#include "mstimeid.h"


#define NOT_DEPENDENT_COLLECTION   -1
#define CTL_E_METHODNOTAPPLICABLE  STD_CTL_SCODE(444)

class CTIMEElementBase;

//
// A class for declaring poiners to member functions
//
class CVoid
{
}; // CVoid

//
// prototype macros for function over rides
// These are used when owner of collection wants to customize it.
//
typedef HRESULT (STDMETHODCALLTYPE CVoid::*PFN_CVOID_ENSURE)(long *plVersionCookie);

typedef HRESULT (STDMETHODCALLTYPE CVoid::*PFN_CVOID_CREATECOL)(IDispatch **pDisp,
                                                      long        lIndex);

typedef HRESULT (STDMETHODCALLTYPE CVoid::*PFN_CVOID_REMOVEOBJECT)(long lCollection,
                                                         long lIndex);
typedef HRESULT (STDMETHODCALLTYPE CVoid::*PFN_CVOID_ADDNEWOBJECT)(long       lIndex, 
                                                         IDispatch *pObject, 
                                                         long       index);

typedef enum COLLECTIONCACHETYPE
{
    ctFreeEntry,
    ctNamed,
    ctTag,
    ctAll,
    ctChildren
} tagCOLLECTIONCACHETYPE;

//
// CCollectionCache
//
class CCollectionCache
{
    class CCacheItem
    {
    public:
        CCacheItem() :
            m_pDisp(NULL),
            m_rgElem(NULL),
            m_cctype(ctFreeEntry),
            m_bstrName(NULL),
            m_lDependentIndex(NOT_DEPENDENT_COLLECTION),
            m_dispidMin(DISPID_COLLECTION_RESERVED_MIN),
            m_dispidMax(DISPID_COLLECTION_RESERVED_MAX),
            m_fInvalid(true),
            m_fIdentity(false),
            m_fOKToDelete(true),
            m_fNeedRebuild(false),
            m_fPromoteNames(true),
            m_fPromoteOrdinals(true),
            m_fGetLastCollectionItem(false),
            m_fIsCaseSensitive(false),
            m_fSettableNULL(false)
        {
        } // constructor

        virtual ~CCacheItem()
        {
            if (m_rgElem)
            {
                delete m_rgElem;
                m_rgElem = NULL;
            }

            ReleaseInterface(m_pDisp);

            if (m_bstrName)
            {
                SysFreeString(m_bstrName);
                m_bstrName = NULL;
            }
        } // destructor

        IDispatch                   *m_pDisp;           // IDispatch for ICrElementCollection
        CPtrAry<CTIMEElementBase *> *m_rgElem;          // array of elements in collection
        COLLECTIONCACHETYPE          m_cctype;          // cache type
        BSTR                         m_bstrName;        // Name if name-based
        long                         m_lDependentIndex; // Index of item that this depends.
        DISPID                       m_dispidMin;       // Offset to add/subtract
        DISPID                       m_dispidMax;       // Offset to add/subtract

        // bit flags
        bool  m_fInvalid:1;      // set for named collections only
        bool  m_fIdentity:1;     // set when a collection is Identity with its container/base object
        bool  m_fOKToDelete:1;   // true for collections that the cache cooks up false when Base Obj provided this CPtrAry
        bool  m_fNeedRebuild:1;  // true is collection need to be rebuilt.
        bool  m_fPromoteNames:1;    // true if we promote names from the object
        bool  m_fPromoteOrdinals:1; // true if we promote ordinals from the object
        bool  m_fGetLastCollectionItem:1; // true to fetch last item only in collection
        bool  m_fIsCaseSensitive:1;       // true if item's name must be compared in case sensitive manner
        bool  m_fSettableNULL:1;          // true when collection[n]=NULL is valid. normally false.
    }; // CCacheItem

public:
    //
    // Constructor/Destructor
    //    
    CCollectionCache(CTIMEElementBase *pBase,
                     CAtomTable *pAtomTable = NULL,
                     PFN_CVOID_ENSURE pfnEnsure = NULL,
                     PFN_CVOID_CREATECOL pfnCreation = NULL,
                     PFN_CVOID_REMOVEOBJECT pfnRemove = NULL,
                     PFN_CVOID_ADDNEWOBJECT pfnAddNewObject = NULL);
    virtual ~CCollectionCache();

    //
    // internal methods
    //
    HRESULT Init(long lReservedSize, long lIdentityIndex = -1);
    HRESULT GetCollectionDisp(long lCollectionIndex, IDispatch **ppDisp);
    HRESULT SetCollectionType(long lCollectionIndex, COLLECTIONCACHETYPE cctype);
    long Size(long lCollectionIndex);
    HRESULT GetItem(long lCollectionIndex, long i, CTIMEElementBase **ppElem);
    void Invalidate();
    void BumpVersion();

    //
    // IDispatchEx methods
    //
    HRESULT GetDispID(long lCollectionIndex, BSTR bstrName, DWORD grfdex, DISPID *pid);
    HRESULT InvokeEx(long                 lCollectionIndex, 
                     DISPID               dispidMember,
                     LCID                 lcid,
                     WORD                 wFlags,
                     DISPPARAMS          *pdispparams,
                     VARIANT             *pvarResult,
                     EXCEPINFO           *pexcepinfo,
                     IServiceProvider    *pSrvProvider);
    HRESULT DeleteMemberByName(long lCollectionIndex, BSTR bstr,DWORD grfdex);
    HRESULT DeleteMemberByDispID(long lCollectionIndex, DISPID id);
    HRESULT GetMemberProperties(long lCollectionIndex, DISPID id, DWORD grfdexFetch, DWORD *pgrfdex);
    HRESULT GetMemberName(long lCollectionIndex, DISPID id, BSTR *pbstrName);
    HRESULT GetNextDispID(long lCollectionIndex, DWORD grfdex, DISPID id, DISPID *prgid);
    HRESULT GetNameSpaceParent(long lCollectionIndex, IUnknown **ppunk);
    
    //
    // Standard collection methods
    //
    HRESULT put_length(long lIndex, long retval);
    HRESULT get_length(long lIndex, long *retval);
    HRESULT get__newEnum(long lIndex, IUnknown **retval);
    HRESULT item(long lIndex, VARIANTARG varName, VARIANTARG varIndex, IDispatch **pDisp);
    HRESULT tags(long lIndex, VARIANT varName, IDispatch **pDisp);

private:
    // private functions
    HRESULT EnsureArray(long lCollectionIndex);
    void EnumStart(void);
    HRESULT EnumNextElement(long lCollectionIndex, CTIMEElementBase **pElem);

    HRESULT GetOuterDisp(long lCollectionIndex, CTIMEElementBase *pElem, IDispatch **ppDisp);
    HRESULT Remove(long lCollection, long lItemIndex);
    HRESULT CreateCollectionHelper(IDispatch **ppDisp, long lIndex);

    bool CompareName(CTIMEElementBase *pElem, const WCHAR *pwszName, bool fTagName, bool fCaseSensitive = false);

    HRESULT BuildNamedArray(long lCollectionIndex, const WCHAR *pwszName, bool fTagName, CPtrAry<CTIMEElementBase *> **prgNamed, bool fCaseSensitive = false);
    HRESULT GetUnknown(long lCollectionIndex, CTIMEElementBase *pElem, IUnknown **ppUnk);    
    
    HRESULT GetDisp(long lCollectionIndex, long lItemIndex, IDispatch **ppDisp);
    HRESULT GetDisp(long lCollectionIndex, const WCHAR *pwszName, long lItemIndex, IDispatch **ppDisp, bool fCaseSensitive = false);
    HRESULT GetDisp(long lCollectionIndex, const WCHAR *pwszName, bool fTagName, IDispatch **ppDisp, bool fCaseSensitive = false);

    HRESULT GetItemCount(long lIndex, long *plCount);
    HRESULT GetItemByIndex(long lIndex, long lElementIndex, CTIMEElementBase **pElem, bool fContinueFromPreviousSearch = false, long lLast = 0);
    HRESULT GetItemByName(long lIndex, const WCHAR *pwszName, long lElementIndex, CTIMEElementBase **pElem, bool fCaseSensitive = false);

    bool IsChildrenCollection(long lCollectionIndex);
    bool IsAllCollection(long lCollectionIndex);
    
    bool ValidateCollectionIndex(long lCollectionIndex);

    DISPID GetNamedMemberMin(long lCollectionIndex);
    DISPID GetNamedMemberMax(long lCollectionIndex);
    DISPID GetOrdinalMemberMin(long lCollectionIndex);
    DISPID GetOrdinalMemberMax(long lCollectionIndex);
    bool IsNamedCollectionMember(long lCollectionIndex, DISPID dispidMember);
    bool IsOrdinalCollectionMember(long lCollectionIndex, DISPID dispidMember);
    DISPID GetSensitiveNamedMemberMin (long lCollectionIndex);
    DISPID GetSensitiveNamedMemberMax(long lCollectionIndex);
    DISPID GetNotSensitiveNamedMemberMin(long lCollectionIndex);
    DISPID GetNotSensitiveNamedMemberMax(long lCollectionIndex);
    bool IsSensitiveNamedCollectionMember(long lCollectionIndex, DISPID dispidMember);
    bool IsNotSensitiveNamedCollectionMember( long lCollectionIndex, DISPID dispidMember);
    long GetNamedMemberOffset(long lCollectionIndex, DISPID id, bool *pfCaseSensitive = NULL);

private:
    CTIMEElementBase       *m_pElemEnum;        // Used as a place holder when we walk the tree
    long                    m_lEnumItem;        // Used as a place holder when we walk the tree
    long                    m_lReservedSize;    // number of CElementCollections that are reserved

    CPtrAry<CCacheItem *>  *m_rgItems;          // array of CCachItems

    long                    m_lCollectionVersion;
    long                    m_lDynamicCollectionVersion;

    CTIMEElementBase       *m_pBase;
    CAtomTable             *m_pAtomTable;       // array of named elements which we have DISPID's for
    
    // functions used to over ride default collection behavior                      
    PFN_CVOID_ENSURE        m_pfnEnsure;
    PFN_CVOID_REMOVEOBJECT  m_pfnRemoveObject; 
    PFN_CVOID_CREATECOL     m_pfnCreateCollection;
    PFN_CVOID_ADDNEWOBJECT  m_pfnAddNewObject;
protected:
    CCollectionCache();
}; // CCollectionCache

//
// CTIMEElementCollection
//
class CTIMEElementCollection : 
    public IDispatchEx,
    public ITIMEElementCollection,
    public ISupportErrorInfoImpl<&IID_ITIMEElementCollection>
{
public:
    CTIMEElementCollection(CCollectionCache *pCollectionCache, long lIndex);

    //
    // IUnknown Methods
    //
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    STDMETHODIMP QueryInterface(REFIID, void**);

    //
    // IDispatch methods
    //
    STDMETHOD(GetTypeInfoCount)(UINT FAR *pctinfo);
    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo **pptinfo);
    STDMETHOD(GetIDsOfNames)(REFIID                riid,
                             LPOLESTR             *rgszNames,
                             UINT                  cNames,
                             LCID                  lcid,
                             DISPID FAR           *rgdispid);
    STDMETHOD(Invoke)(DISPID          dispidMember,
                      REFIID          riid,
                      LCID            lcid,
                      WORD            wFlags,
                      DISPPARAMS     *pdispparams,
                      VARIANT        *pvarResult,
                      EXCEPINFO      *pexcepinfo,
                      UINT           *puArgErr);

    //
    // IDispatchEx methods
    //
    STDMETHOD(GetDispID)(BSTR bstrName, DWORD grfdex, DISPID *pid);
    STDMETHOD(InvokeEx)(DISPID               dispidMember,
                       LCID                 lcid,
                       WORD                 wFlags,
                       DISPPARAMS          *pdispparams,
                       VARIANT             *pvarResult,
                       EXCEPINFO           *pexcepinfo,
                       IServiceProvider    *pSrvProvider);
    STDMETHOD(DeleteMemberByName)(BSTR bstr,DWORD grfdex);
    STDMETHOD(DeleteMemberByDispID)(DISPID id);
    STDMETHOD(GetMemberProperties)(DISPID id, DWORD grfdexFetch, DWORD *pgrfdex);
    STDMETHOD(GetMemberName)(DISPID id, BSTR *pbstrName);
    STDMETHOD(GetNextDispID)(DWORD grfdex, DISPID id, DISPID *prgid);
    STDMETHOD(GetNameSpaceParent)(IUnknown **ppunk);
    
    //
    // Standard collection methods
    //
    STDMETHOD(put_length)(long retval);
    STDMETHOD(get_length)(long *retval);
    STDMETHOD(get__newEnum)(IUnknown **retval);
    STDMETHOD(item)(VARIANTARG varName, VARIANTARG varIndex, IDispatch **pDisp);
    STDMETHOD(tags)(VARIANT varName, IDispatch **pDisp);

private:
    virtual ~CTIMEElementCollection();
    HRESULT GetTI(ITypeInfo **pptinfo);

private:
    CCollectionCache *m_pCollectionCache;  // pointer to the cache
    long              m_lCollectionIndex;  // denotes which collection we are
    ULONG             m_cRef;
    ITypeInfo        *m_pInfo;             // our TypeInfo Interface
protected:
    CTIMEElementCollection();
}; // CTIMEElementCollection

//************************************************************
// inline's for CCollectionCache
//************************************************************
inline void CCollectionCache::Invalidate()
{
    m_lCollectionVersion        = 0;
    m_lDynamicCollectionVersion = 0;        
} // Invalidate

inline void CCollectionCache::BumpVersion()
{
    m_lCollectionVersion++;
} // BumpVersion

inline bool CCollectionCache::ValidateCollectionIndex(long lCollectionIndex)
{
    if ((lCollectionIndex >= 0) && (lCollectionIndex < m_rgItems->Size()))
        return true;
    return false;
} // ValidateCollectionIndex

inline DISPID CCollectionCache::GetNamedMemberMin(long lCollectionIndex) 
{
    return (*m_rgItems)[lCollectionIndex]->m_dispidMin; 
} // GetNamedMemberMin

inline DISPID CCollectionCache::GetNamedMemberMax(long lCollectionIndex)
{ 
    return ((*m_rgItems)[lCollectionIndex]->m_dispidMin + 
            (((*m_rgItems)[lCollectionIndex]->m_dispidMax - (*m_rgItems)[lCollectionIndex]->m_dispidMin) / 2));
} // GetNamedMemberMax

inline DISPID CCollectionCache::GetOrdinalMemberMin(long lCollectionIndex)
{
    return GetNamedMemberMax(lCollectionIndex) + 1;
} // GetOrdinalMemberMin

inline DISPID CCollectionCache::GetOrdinalMemberMax(long lCollectionIndex)
{
    return (*m_rgItems)[lCollectionIndex]->m_dispidMax;
} // GetOrdinalMemberMax

inline bool CCollectionCache::IsNamedCollectionMember(long lCollectionIndex, DISPID dispidMember)
{
    return ((dispidMember >= GetNamedMemberMin(lCollectionIndex)) &&
            (dispidMember <= GetNamedMemberMax(lCollectionIndex)));
} // IsNamedCollectionMember

inline bool CCollectionCache::IsOrdinalCollectionMember(long lCollectionIndex, DISPID dispidMember)
{
    return ((dispidMember >= GetOrdinalMemberMin(lCollectionIndex)) && 
            (dispidMember <= GetOrdinalMemberMax(lCollectionIndex)));
} // IsOrdinalCollectionMember

inline DISPID CCollectionCache::GetSensitiveNamedMemberMin (long lCollectionIndex)
{
    return GetNamedMemberMin(lCollectionIndex);
} // GetSensitiveNamedMemberMin

inline DISPID CCollectionCache::GetSensitiveNamedMemberMax(long lCollectionIndex)
{ 
    return (GetNamedMemberMin(lCollectionIndex) + 
            ((GetNamedMemberMax(lCollectionIndex) - GetNamedMemberMin(lCollectionIndex)) / 2));
} // GetSensitiveNamedMemberMax

inline DISPID CCollectionCache::GetNotSensitiveNamedMemberMin(long lCollectionIndex)
{
    return GetSensitiveNamedMemberMax(lCollectionIndex) + 1;
} // GetNotSensitiveNamedMemberMin
 
inline DISPID CCollectionCache::GetNotSensitiveNamedMemberMax(long lCollectionIndex)
{ 
    return GetNamedMemberMax(lCollectionIndex);
} // GetNotSensitiveNamedMemberMax

inline bool CCollectionCache::IsSensitiveNamedCollectionMember(long lCollectionIndex, DISPID dispidMember)
{
    return ((dispidMember >= GetSensitiveNamedMemberMin(lCollectionIndex)) && 
            (dispidMember <= GetSensitiveNamedMemberMax(lCollectionIndex))) ;
} // IsSensitiveNamedCollectionMember

inline bool CCollectionCache::IsNotSensitiveNamedCollectionMember( long lCollectionIndex, DISPID dispidMember)
{
    return ((dispidMember >= GetNotSensitiveNamedMemberMin(lCollectionIndex)) && 
            (dispidMember <= GetNotSensitiveNamedMemberMax(lCollectionIndex))) ;
} // IsNotSensitiveNamedCollectionMember

#endif //__COLLECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timebvr\currtimestate.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1998
//
//  File: src\time\src\currtimestate.h
//
//  Contents: TIME currTimeState object
//
//------------------------------------------------------------------------------------


#pragma once

#ifndef _CURRTIMESTATE_H
#define _CURRTIMESTATE_H

class CTIMEElementBase;

//+-------------------------------------------------------------------------------------
//
// CTIMETimeState
//
//--------------------------------------------------------------------------------------

class
__declspec(uuid("275CE6A0-7D26-41f9-B5E6-57EE053C5A0E")) 
CTIMECurrTimeState :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CTIMECurrTimeState, &__uuidof(CTIMECurrTimeState)>,
    public ITIMEDispatchImpl<ITIMEState, &IID_ITIMEState>,
    public ISupportErrorInfoImpl<&IID_ITIMEState>,
    public IConnectionPointContainerImpl<CTIMECurrTimeState>,
    public IPropertyNotifySinkCP<CTIMECurrTimeState>
{

  public:

    //+--------------------------------------------------------------------------------
    //
    // Public Methods
    //
    //---------------------------------------------------------------------------------

    CTIMECurrTimeState();
    virtual ~CTIMECurrTimeState();

    void Init(CTIMEElementBase * pTEB);
    void Deinit();
        
#if DBG
    const _TCHAR * GetName() { return __T("CTIMECurrTimeState"); }
#endif
    
    BEGIN_COM_MAP(CTIMECurrTimeState)
     COM_INTERFACE_ENTRY(ITIMEState)
     COM_INTERFACE_ENTRY(IDispatch)
     COM_INTERFACE_ENTRY(ISupportErrorInfo)
     COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    END_COM_MAP();
                                                             
#ifndef END_COM_MAP_ADDREF
    //
    // IUnknown
    //

    STDMETHOD_(ULONG,AddRef)(void) = 0;
    STDMETHOD_(ULONG,Release)(void) = 0;
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) = 0;
#endif

    //
    // ITimeState
    //

    STDMETHOD(get_activeDur)(double * pdblDuration);

    STDMETHOD(get_activeTime)(double * pdblTime);

    STDMETHOD(get_isActive)(VARIANT_BOOL * vbActive);

    STDMETHOD(get_isOn)(VARIANT_BOOL * pvbOn);

    STDMETHOD(get_isPaused)(VARIANT_BOOL * pvbPaused);

    STDMETHOD(get_isMuted)(VARIANT_BOOL * muted);

    STDMETHOD(get_parentTimeBegin)(double * pdblTime);

    STDMETHOD(get_parentTimeEnd)(double * pdblTime);

    STDMETHOD(get_progress)(double * progress);

    STDMETHOD(get_repeatCount)(long * plCount);

    STDMETHOD(get_segmentDur)(double * pdblDuration);

    STDMETHOD(get_segmentTime)(double * pdblTime);

    STDMETHOD(get_simpleTime)(double * pdblTime);

    STDMETHOD(get_simpleDur)(double * dur);

    STDMETHOD(get_speed)(float * pflSpeed);

    STDMETHOD(get_state)(TimeState * timeState);

    STDMETHOD(get_stateString)(BSTR * state);

    STDMETHOD(get_volume)(float * vol);

    //
    // ATL Maps
    //

    BEGIN_CONNECTION_POINT_MAP(CTIMECurrTimeState)
        CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
    END_CONNECTION_POINT_MAP();

    //
    // Property Change Notification
    //

    HRESULT NotifyPropertyChanged(DISPID dispid);

    //+--------------------------------------------------------------------------------
    //
    // Public Data
    //
    //---------------------------------------------------------------------------------

  protected:

    //+--------------------------------------------------------------------------------
    //
    // Protected Methods
    //
    //---------------------------------------------------------------------------------

    // Notification Helper
    HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP);

    //+--------------------------------------------------------------------------------
    //
    // Protected Data
    //
    //---------------------------------------------------------------------------------

    CTIMEElementBase * m_pTEB;


  private:

    //+--------------------------------------------------------------------------------
    //
    // Private methods
    //
    //---------------------------------------------------------------------------------

    //+--------------------------------------------------------------------------------
    //
    // Private Data
    //
    //---------------------------------------------------------------------------------

}; // CTIMECurrTimeState


//+---------------------------------------------------------------------------------
//  CTIMECurrTimeState inline methods
//
//  (Note: as a general guideline, single line functions belong in the class declaration)
//
//----------------------------------------------------------------------------------


#endif /* _CURRTIMESTATE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timebvr\mmmedia.h ===
#ifndef _MMMEDIA_H__
#define _MMMEDIA_H__

#pragma once

#include "mmtimeline.h"

class MMMedia :
    public MMTimeline
{
  public:
    MMMedia(CTIMEElementBase & elm, bool bFireEvents);
    virtual ~MMMedia();

    virtual bool Init();
    virtual HRESULT Update(bool bBegin,
                           bool bEnd);

  protected:
    MMMedia();
  
  private:
};

#endif // _MMMEDIA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timebvr\mmexcl.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmtimeline.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _MMEXCL_H
#define _MMEXCL_H

#include "mmtimeline.h"

typedef enum EXCL_STATE
{
    PAUSED,
    STOPPED,
    NUM_STATES
} tag_EXCL_STATE;
    
class MMExcl :
    public MMTimeline
{
  public:
    MMExcl(CTIMEElementBase & elm, bool bFireEvents);
    virtual ~MMExcl();
    
    virtual bool Init();
    virtual HRESULT AddBehavior(MMBaseBvr & bvr);
    virtual void RemoveBehavior(MMBaseBvr & bvr);
    
    virtual bool childEventNotify(MMBaseBvr * pBvr, double dblLocalTime, TE_EVENT_TYPE et);
    virtual bool childPropNotify(MMBaseBvr * pBvr, DWORD *tePropType);

  protected:
    MMExcl();
 
  private:
    CPtrAry<MMBaseBvr *> m_pPendingList;
    CDataAry<EXCL_STATE> m_pPendingState;
    CDataAry<bool> m_pbIsPriorityClass;
    MMBaseBvr * m_pPlaying;
    CTIMEElementBase &   m_baseTIMEEelm;

    typedef enum RELATIONSHIP
    {
        HIGHER,
        PEERS,
        LOWER,
        NUM_RELATIONSHIPS
    };

    void GetRelationship(MMBaseBvr * pBvrRunning, 
                         MMBaseBvr * pBvrInterrupting, 
                         RELATIONSHIP & rel);
    bool ArePeers(IHTMLElement * pElm1, IHTMLElement * pElm2);
    bool IsHigherPriority(IHTMLElement * pElmLeft, IHTMLElement * pElmRight);

    void EndCurrent();
    void ClearQueue();
    void PauseCurrentAndAddToQueue();
    void DeferBeginAndAddToQueue(MMBaseBvr * pBvr);
    void StopBegin(MMBaseBvr * pBvr);

    void AddToQueue(MMBaseBvr * pBvr, EXCL_STATE state);

    bool IsInBeingAdjustedList(MMBaseBvr * pBvr);
    bool IsAtEndTime(MMBaseBvr *pBvr);
    void RemoveDuplicates(MMBaseBvr *pBvr);
    bool UsingPriorityClasses();
    bool IsPriorityClass(MMBaseBvr *pBvr);
    IHTMLElement *GetParentElement(IHTMLElement *pEle);
    std::list<MMBaseBvr*> m_beingadjustedlist;
};

#endif /* _MMEXCL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timebvr\mmmedia.cpp ===
#include "headers.h"
#include "mmmedia.h"
#include "timeelmbase.h"

#define SUPER MMTimeline

MMMedia::MMMedia(CTIMEElementBase & elm, bool bFireEvents) :
    SUPER(elm, bFireEvents)
{
}

MMMedia::~MMMedia()
{
}

bool
MMMedia::Init()
{
    bool ok = false;

    ok = SUPER::Init();
    if (!ok)
    {
        goto done;
    }

    ok = true;
done:
    return ok;
}    

HRESULT
MMMedia::Update(bool bBegin,
                bool bEnd)
{
    HRESULT hr = S_OK;
    LPWSTR str = NULL;

    hr = SUPER::Update(bBegin, bEnd);
    if (FAILED(hr))
    {
        goto done;
    }

    str = m_elm.GetEndSync();
    if (NULL == str)
    {
        m_mes = MEF_MEDIA;
        IGNORE_HR(m_timeline->put_endSync(TE_ENDSYNC_MEDIA));
        UpdateEndSync();
    }

    hr = S_OK;
done:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timebvr\mmexcl.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 2000
//
//  File: src\time\timebvr\mmexcl.cpp
//
//  Contents: implementation of MMExcl and CExclStacc
//
//------------------------------------------------------------------------------------

#include "headers.h"
#include "mmexcl.h"
#include "timeelmbase.h"

DeclareTag(tagMMUTILExcl, "TIME: Behavior", "MMExcl methods")

#define SUPER MMTimeline


//+-----------------------------------------------------------------------
//
//  Member:    MMExcl::MMExcl
//
//  Overview:  constructor
//
//  Arguments: elm  element this bvr is associated with
//             bFireEvents  whether or not to fire events
//             
//  Returns:   void
//
//------------------------------------------------------------------------
MMExcl::MMExcl(CTIMEElementBase & elm, bool bFireEvents) :
    SUPER(elm, bFireEvents),
    m_pPlaying(NULL),
    m_baseTIMEEelm (elm)
{
}

//+-----------------------------------------------------------------------
//
//  Member:    MMExcl::~MMExcl
//
//  Overview:  destructor
//
//  Arguments: void
//             
//  Returns:   void
//
//------------------------------------------------------------------------
MMExcl::~MMExcl()
{
    m_pPlaying = NULL;
    
    ClearQueue();
}
    
//+-----------------------------------------------------------------------
//
//  Member:    MMExcl::Init
//
//  Overview:  initialized the stack for excl
//
//  Arguments: void
//             
//  Returns:   void
//
//------------------------------------------------------------------------
bool 
MMExcl::Init()
{
    bool ok = false;

    ok = SUPER::Init();
    if (!ok)
    {
        goto done;
    }

    ok = true;
 done:
    return ok;
}
    
//+-----------------------------------------------------------------------
//
//  Member:    MMExcl::RemoveBehavior
//
//  Overview:  Removes children
//
//  Arguments: bvr  element to remove
//             
//  Returns:   void
//
//------------------------------------------------------------------------
void
MMExcl::RemoveBehavior(MMBaseBvr & bvr)
{
    long lPriIndex = m_children.Find(&bvr);
    if ((0 <= lPriIndex) && (m_pbIsPriorityClass.Size() > lPriIndex))
    {
        m_pbIsPriorityClass.DeleteItem(lPriIndex);
    }
    
    SUPER::RemoveBehavior(bvr);

    long lIndex = m_pPendingList.Find(&bvr);
    if ((lIndex >= 0) && (lIndex < m_pPendingState.Size()))
    {
        m_pPendingList.DeleteByValue(&bvr); 
        m_pPendingState.DeleteItem(lIndex);
    }
}

HRESULT 
MMExcl::AddBehavior(MMBaseBvr & bvr)
{
    HRESULT hr = S_OK;
    bool bIsPriority = false;
    hr = SUPER::AddBehavior(bvr);

    if (SUCCEEDED(hr))
    {
        bIsPriority = IsPriorityClass(&bvr);
        m_pbIsPriorityClass.AppendIndirect(&bIsPriority, NULL);
    }

    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    MMExcl::ArePeers
//
//  Overview:  determines if two HTML Elements have the same parent or
//             are the same depth from the t:excl tag.
//
//  Arguments: pEl1, pElm2 - elements to compare
//             
//  Returns:   true if parents are same, otherwise false
//
//------------------------------------------------------------------------
bool
MMExcl::ArePeers(IHTMLElement * pElm1, IHTMLElement * pElm2)
{
    HRESULT hr = S_OK;
    IHTMLElement *spParent1 = NULL;
    IHTMLElement *spParent2 = NULL;
    CComPtr <IUnknown> pUnk1;
    CComPtr <IUnknown> pUnk2;
    CComPtr<IHTMLElement> spNext;
    bool fArePeers = false;

    Assert(NULL != pElm1);
    Assert(NULL != pElm2);

    //otherwise determine if the elements have the same priority class.
    spParent1 = GetParentElement(pElm1);
    spParent2 = GetParentElement(pElm2);

    if (spParent1 == NULL && spParent2 == NULL)
    {
        fArePeers = true;
    }
    else if (spParent1 == NULL || spParent2 == NULL)
    {
        fArePeers = false;
    }
    else 
    {
        hr = THR(spParent1->QueryInterface(IID_IUnknown, (void**)&pUnk1));
        if (FAILED(hr))
        {
            fArePeers = false;
            goto done;
        }
        hr = THR(spParent2->QueryInterface(IID_IUnknown, (void**)&pUnk2));
        if (FAILED(hr))
        {
            fArePeers = false;
            goto done;
        }
        
        fArePeers = (pUnk1 == pUnk2);
        
    }

    
done:

    if (spParent1)
    {
        spParent1->Release();
    }
    if (spParent2)
    {
        spParent2->Release();
    }
    return fArePeers;
}

//returns either the parent priority class or the parent excl if no priority class exists.
IHTMLElement *
MMExcl::GetParentElement(IHTMLElement *pEle)
{
    IHTMLElement *pReturnEle = NULL;
    CComPtr<IHTMLElement> pEleParent;
    CComPtr <IHTMLElement> pNext;
    CComPtr <IHTMLElement> pExclEle;
    CComPtr <IUnknown> pUnkExclEle;

    BSTR bstrTagName = NULL;
    HRESULT hr = S_OK;
    bool bDone = false;

    hr = THR(pEle->get_parentElement(&pEleParent));
    if (FAILED(hr))
    {
        pReturnEle = NULL;
        goto done;        
    }

    //get the element associated with this timeline
    pExclEle = m_baseTIMEEelm.GetElement();
    if (pExclEle == NULL)
    {
        pReturnEle = NULL;
        goto done;                
    }
    hr = THR(pExclEle->QueryInterface (IID_IUnknown, (void**)&pUnkExclEle));
    if (FAILED(hr))
    {
        pReturnEle = NULL;
        goto done;                        
    }


    while (pEleParent != NULL && bDone != true)
    {
        hr = THR(pEleParent->get_tagName(&bstrTagName));
        if (FAILED(hr))
        {
            pReturnEle = NULL;
            goto done;        
        }
        if (bstrTagName != NULL)
        {
            // if this is a priority class then return it.
            if (StrCmpIW(bstrTagName, WZ_PRIORITYCLASS_NAME) == 0)
            {
                pReturnEle = pEleParent;
                pReturnEle->AddRef();
                bDone = true;
            }
            else
            {
                // else determine if this is the excl element.
                //NOTE: it will not work to just check for 
                //the excl tagname because it could be any tag with 
                //timecontainer=excl
                CComPtr <IUnknown> pUnk;
                hr = THR(pEleParent->QueryInterface(IID_IUnknown, (void**)&pUnk));
                if (FAILED(hr))
                {
                    pReturnEle = NULL;
                    bDone = true;
                }
                if (pUnkExclEle == pUnk)
                {
                    pReturnEle = pEleParent;
                    pReturnEle->AddRef();
                    bDone = true;
                }
            }
            SysFreeString(bstrTagName);
            bstrTagName = NULL;
        }
        
        hr = THR(pEleParent->get_parentElement(&pNext));
        if (FAILED(hr))
        {
            pReturnEle = NULL;
            goto done;        
        }
        pEleParent.Release();
        pEleParent = pNext;
        pNext.Release();
     }

  done:

    if (bstrTagName)
    {
        SysFreeString(bstrTagName);
    }
    return pReturnEle;
}


//+-----------------------------------------------------------------------
//
//  Member:    MMExcl::IsHigherPriority
//
//  Overview:  determines if the elements passed in are related such that:
//              pElmLeft > pElmRight where > mean higher priority
//
//  Arguments: pElmLeft, pElmRight - element to compare
//             
//  Returns:   true if pElmLeft > pElmRight, otherwise false
//
//------------------------------------------------------------------------
bool 
MMExcl::IsHigherPriority(IHTMLElement * pElmLeft, IHTMLElement * pElmRight)
{
    Assert(NULL != pElmLeft);
    Assert(NULL != pElmRight);
    Assert(!ArePeers(pElmLeft, pElmRight));

    HRESULT hr = S_OK;
    
    bool fIsHigher = false;

    CComPtr<IHTMLElement> spExcl;
    CComPtr<IHTMLElement> spParentLeft;
    CComPtr<IHTMLElement> spParentRight;
    CComPtr<IDispatch>  spDispCollection;
    CComPtr<IHTMLElementCollection> spCollection;
    
    // guarantee that the parents are peers     
    hr = pElmLeft->get_parentElement(&spParentLeft);
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = pElmRight->get_parentElement(&spParentRight);
    if (FAILED(hr))
    {
        goto done;
    }
    
    if (!ArePeers(spParentLeft, spParentRight))
    {
        // the parent elements are not peers
        goto done;
    }

    // guarantee the parents are children of this excl

    hr = spParentLeft->get_parentElement(&spExcl);
    if (FAILED(hr))
    {
        goto done;
    }
    
    if (!MatchElements(spExcl, GetElement().GetElement()))
    {
        // the parent of the parents is not this excl
        goto done;
    }

    hr = spExcl->get_children(&spDispCollection);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = spDispCollection->QueryInterface(IID_TO_PPV(IHTMLElementCollection, &spCollection));
    if (FAILED(hr))
    {
        goto done;
    }

    {
        long lCollectionLength;
        long lCount;
        hr = spCollection->get_length(&lCollectionLength);
        if (FAILED(hr))
        {
            goto done;
        }
        
        for(lCount = 0; lCount < lCollectionLength; lCount++)
        {
            CComPtr<IDispatch> spDispatch;
            CComVariant varName(lCount);
            CComVariant varIndex;
            
            hr = spCollection->item(varName, varIndex, &spDispatch);
            if (FAILED(hr))
            {
                goto done;
            }

            if (MatchElements(spDispatch, spParentLeft))
            {
                fIsHigher = true;
                break;
            }
            else if (MatchElements(spDispatch, spParentRight))
            {
                fIsHigher = false;
                break;
            }
        }
    }
    
done:
    return fIsHigher;
}

//+-----------------------------------------------------------------------
//
//  Member:    MMExcl::GetRelationShip
//
//  Overview:  Determines the relationship between elements
//
//  Arguments: pBvrRunning, pBvrInterrupting - elements to decide relationship
//             rel - where to store the relationship
//
//  Returns:   void
//
//------------------------------------------------------------------------
void
MMExcl::GetRelationship(MMBaseBvr * pBvrRunning, 
                        MMBaseBvr * pBvrInterrupting, 
                        RELATIONSHIP & rel)
{
    // choose a default
    rel = PEERS;

    IHTMLElement * pElmRunning = pBvrRunning->GetElement().GetElement();
    IHTMLElement * pElmInterrupting = pBvrInterrupting->GetElement().GetElement();
    if (NULL == pElmRunning || NULL == pElmInterrupting)
    {
        goto done;
    }

    if (ArePeers(pElmRunning, pElmInterrupting))
    {
        rel = PEERS;
        goto done;
    }

    if (IsHigherPriority(pElmRunning, pElmInterrupting))
    {
        rel = LOWER;
        goto done;
    }

    //Assert(IsHigherPriority(pElmInterrupting, pElmRunning));
    rel = HIGHER;
    
done:
    return;
}

//+-----------------------------------------------------------------------
//
//  Member:    MMExcl::childEventNotify
//
//  Overview:  
//
//  Arguments: pBvr - element receiving event
//             dblLocalTime - time at which the event occurred
//             et - event that occurred
//             
//  Returns:   true if event should be processed, false otherwise
//
//------------------------------------------------------------------------
bool
MMExcl::childEventNotify(MMBaseBvr * pBvr, double dblLocalTime, TE_EVENT_TYPE et)
{
    TraceTag((tagMMUTILExcl, 
        "MMExcl::childEventNotify(%p) event %d on element %ls",
        this,
        et,
        pBvr->GetID() ? pBvr->GetID() : L"Unknown" ));

    Assert(NULL != pBvr);

    bool fProcessEvent = true;

    fProcessEvent = SUPER::childEventNotify(pBvr, dblLocalTime, et);
    if (false == fProcessEvent)
    {
        goto done;
    }

    if ( m_pPlaying != pBvr && IsInBeingAdjustedList(pBvr))
    {
        fProcessEvent = false;
        goto done;
    }

    switch(et)
    {
        case TE_EVENT_RESUME:
        {
            long lChild = m_pPendingList.Find(pBvr);
            if (lChild == -1 && pBvr != m_pPlaying)
            {
                goto done;
            }
        }
        case TE_EVENT_BEGIN:
        {
            long lChild = -1;
            int l = m_children.Size();
            int i = 0;

            for (i = 0; i < l; i++)
            {
                MMBaseBvr *pBvr2 = m_children.Item(i);
                
                if (pBvr2->GetElement().GetFill() == FREEZE_TOKEN)
                {
                    pBvr2->GetElement().ToggleTimeAction(false);
                }
            }

            //if the exlcusive is using priority classes and this is not a priority class
            //then the begin on it needs to be cancelled and ignored.
            if (UsingPriorityClasses() && !IsPriorityClass(pBvr)) 
            { 
                StopBegin(pBvr);
                fProcessEvent = false;
                break;
            }


            if (NULL == m_pPlaying)
            {
                m_pPlaying = pBvr;
                break;
            }
            if (pBvr == m_pPlaying)
            {
                m_pPlaying->GetElement().ToggleTimeAction(true);
                break;
            }
        
            
            RELATIONSHIP rel;
            GetRelationship(m_pPlaying, pBvr, rel);
            TOKEN action;

            switch(rel)
            {
            case HIGHER:
            {
                action = m_pPlaying->GetElement().GetPriorityClassHigher();
                if ( STOP_TOKEN == action )
                {
                    EndCurrent();
                } 
                else if ( PAUSE_TOKEN == action )
                {
                    if (IsAtEndTime(pBvr))
                    {
                        DeferBeginAndAddToQueue(pBvr);
                        fProcessEvent = false;
                    }
                    else
                    {
                        PauseCurrentAndAddToQueue();
                    }
                }
                else
                {
                    // should never get here
                    Assert(false);
                }
                break; // HIGHER
            }    
            case PEERS:
            {
                action = m_pPlaying->GetElement().GetPriorityClassPeers();
                if ( STOP_TOKEN == action )
                {
                    EndCurrent();
                }
                else if ( PAUSE_TOKEN == action )
                {
                    
                    if (IsAtEndTime(pBvr))
                    { //this is the case of events coming in in an incorrect order
                        DeferBeginAndAddToQueue(pBvr);                    
                        fProcessEvent = false;
                    }
                    else
                    {
                        PauseCurrentAndAddToQueue();
                    }
                }
                else if ( DEFER_TOKEN == action )
                {
                    DeferBeginAndAddToQueue(pBvr);
                    fProcessEvent = false;
                }
                else if ( NEVER_TOKEN == action )
                {
                    if (IsAtEndTime(pBvr))
                    { //this is the case of events coming in in an incorrect order
                        DeferBeginAndAddToQueue(pBvr);                    
                    }
                    else
                    {                    
                        StopBegin(pBvr);
                    }
                    fProcessEvent = false;
                }
                else
                {
                    // should never get here
                    Assert(false);
                }
                break; // PEERS
            }
            case LOWER:
            {
                action = m_pPlaying->GetElement().GetPriorityClassLower();
                if ( DEFER_TOKEN == action )
                {
                    DeferBeginAndAddToQueue(pBvr);
                    fProcessEvent = false;
                }
                else if ( NEVER_TOKEN == action )
                {
                    if (IsAtEndTime(pBvr))
                    { //this is the case of events coming in in an incorrect order
                        DeferBeginAndAddToQueue(pBvr);                    
                    }
                    else
                    {                    
                        StopBegin(pBvr);
                    }
                    fProcessEvent = false;
                }
                else 
                {
                    // should never get here
                    Assert(false);
                }
                break; // LOWER
            }
            default:
            {
                // should never get here
                Assert(false);
                break;
            }
        }  // switch(rel)

        if (fProcessEvent)
        {
            m_pPlaying = pBvr;
        }

        lChild = m_pPendingList.Find(m_pPlaying);
        if (lChild != -1)
        {
            m_pPendingList.DeleteItem(lChild);
        }
        m_pPlaying->Enable();
        m_pPlaying->GetElement().ToggleTimeAction(true);
        break; // TE_EVENT_BEGIN
    }

    case TE_EVENT_END:    
    {
        if (m_pPlaying == pBvr && !IsInBeingAdjustedList(m_pPlaying))
        {
            // check to see if there was a previously playing item
            EXCL_STATE state;
         
            MMBaseBvr * pPrevPlaying = NULL;
            if (m_pPendingList.Size() > 0)
            {
                pPrevPlaying = m_pPendingList.Item(0);
                state = m_pPendingState.Item(0);
                m_pPendingList.DeleteByValue(pPrevPlaying);    
                m_pPendingState.DeleteItem(0);
            }
            m_pPlaying = pPrevPlaying;
            if ((pPrevPlaying != NULL))
            {
                if (PAUSED == state)
                {
                    TraceTag((tagMMUTILExcl, 
                        "MMExcl::childEventNotify(%d) toggling %ls on",
                        this,
                        pPrevPlaying->GetID() ? pPrevPlaying->GetID() : L"Unknown" ));
                    
                    // For now the order is important since the event
                    // is used in the media portion and not the
                    // property change notification
                    pPrevPlaying->Enable();
                    pPrevPlaying->Resume();
                }
                else if (STOPPED == state)
                {
                    TraceTag((tagMMUTILExcl, 
                        "MMExcl::childEventNotify(%d) beginning %ls ",
                        this,
                        pPrevPlaying->GetID() ? pPrevPlaying->GetID() : L"Unknown" ));

                    pPrevPlaying->Enable();
                    pPrevPlaying->GetElement().FireEvent(TE_ONBEGIN, 0.0, 0, 0);
                }
            }
        }
        else
        {
            long lCurBvr = m_pPendingList.Find(pBvr);
            if (lCurBvr != -1)
            {
                m_pPendingList.DeleteByValue(m_pPendingList.Item(lCurBvr));
                m_pPendingState.DeleteItem(lCurBvr);
                pBvr->Enable();
            }
            fProcessEvent = true;
        }
        break; //TE_EVENT_END
    }
    default:
        break;
    } // switch

done:

    return fProcessEvent;
}


bool 
MMExcl::IsAtEndTime(MMBaseBvr *pBvr)
{
    double dblActiveEndTime = m_pPlaying->GetActiveEndTime();
    double dblCurrParentTime = m_pPlaying->GetCurrParentTime();

    if (dblActiveEndTime <= dblCurrParentTime)
    { //this is the case of events coming in in an incorrect order
        return true;
    }
    else
    {                    
        return false;
    } 
}
//+-----------------------------------------------------------------------
//
//  Member:    MMExcl::childPropNotify
//
//  Overview:  
//
//  Arguments: pBvr - element receiving notification
//             tePropType - type of notification occurring
//
//  Returns:   true if element should process notification, otherwise false
//
//------------------------------------------------------------------------
bool
MMExcl::childPropNotify(MMBaseBvr * pBvr, DWORD *tePropType)
{
    Assert(NULL != pBvr);

    bool fProcessNotify = true;
    DWORD dwTemp = *tePropType & TE_PROPERTY_ISON;

    if (!SUPER::childPropNotify(pBvr, tePropType))
    {
        fProcessNotify = false;
        goto done;
    }

    if (IsInBeingAdjustedList(pBvr))
    {
        if (dwTemp == TE_PROPERTY_ISON && pBvr == m_pPlaying)    
        {
            fProcessNotify = true;
        }
        else
        {
            fProcessNotify = false;
        }
        goto done;
    }

    fProcessNotify = true;
done:
    return fProcessNotify;
}

//+-----------------------------------------------------------------------
//
//  Member:    MMExcl::IsInBeingAdjustedList
//
//  Overview:  Determine if element is currently being adjusted
//
//  Arguments: pBvr - element to check if in list
//             
//  Returns:   true if element is in list, otherwise false
//
//------------------------------------------------------------------------
bool
MMExcl::IsInBeingAdjustedList(MMBaseBvr * pBvr)
{
    std::list<MMBaseBvr*>::iterator iter;
    iter = m_beingadjustedlist.begin();
    while(iter != m_beingadjustedlist.end())
    {
        if ((*iter) == pBvr)
        {
            return true;
        }
        iter++;
    }
    return false;
}

//+-----------------------------------------------------------------------
//
//  Member:    MMExcl::EndCurrent
//
//  Overview:  Ends the currently running element
//
//  Arguments: void
//             
//  Returns:   void
//
//------------------------------------------------------------------------
void 
MMExcl::EndCurrent()
{
    MMBaseBvr * pBvr = m_pPlaying;
    m_beingadjustedlist.push_front(pBvr);

    pBvr->End(0.0);

    m_beingadjustedlist.remove(pBvr);
}

//+-----------------------------------------------------------------------
//
//  Member:    MMExcl::ClearQueue()
//
//  Overview:  Clears the Queue
//
//  Arguments: void
//             
//  Returns:   void
//
//------------------------------------------------------------------------
void 
MMExcl::ClearQueue()
{
    while (m_pPendingList.Size() > 0)
    {
        m_pPendingList.DeleteByValue(m_pPendingList.Item(0));
        m_pPendingState.DeleteItem(0);
    }
}

//+-----------------------------------------------------------------------
//
//  Member:    MMExcl::PauseCurrentAndAddToQueue
//
//  Overview:  Pause the current element, toggle it's timeaction off, 
//              and add it to the Queue in a paused state
//
//  Arguments: void
//             
//  Returns:   void
//
//------------------------------------------------------------------------
void 
MMExcl::PauseCurrentAndAddToQueue()
{
    MMBaseBvr * pBvr = m_pPlaying;
    m_beingadjustedlist.push_front(pBvr);
    
    IGNORE_HR(pBvr->Pause());
    IGNORE_HR(pBvr->Disable());
    AddToQueue(pBvr, PAUSED);

    m_beingadjustedlist.remove(pBvr);
}

//+-----------------------------------------------------------------------
//
//  Member:    MMExcl::DeferBeginAndAddToQueue
//
//  Overview:  end element element passed in and 
//              add it to the Queue in a stopped stade.
//
//  Arguments: pBvr - element to defer begin on
//             
//  Returns:   void
//
//------------------------------------------------------------------------
void 
MMExcl::DeferBeginAndAddToQueue(MMBaseBvr * pBvr)
{
    long lCurIndex = 0;
    m_beingadjustedlist.push_front(pBvr);
    
    //need to check to see if this is already in the queue and if so, what it's state is.
    AddToQueue(pBvr, STOPPED);
    lCurIndex = m_pPendingList.Find(pBvr);
    if (lCurIndex != -1)
    {
        EXCL_STATE curState = m_pPendingState.Item(lCurIndex);
        if (curState == PAUSED)
        {
            if (!pBvr->IsPaused())
            {
                pBvr->Pause();
            }

            if (!pBvr->IsDisabled())
            {
                pBvr->Disable();
            }
        }
        else
        {        
            pBvr->Disable();
            pBvr->GetElement().ToggleTimeAction(false);
        }
    }

    m_beingadjustedlist.remove(pBvr);
}

//+-----------------------------------------------------------------------
//
//  Member:    MMExcl::StopBegin
//
//  Overview:  stop an element from beginning
//
//  Arguments: pBvr - element to stop
//             
//  Returns:   void
//
//------------------------------------------------------------------------
void 
MMExcl::StopBegin(MMBaseBvr * pBvr)
{
    long lCurBvr = m_pPendingList.Find(pBvr);
    long lSize = m_pPendingList.Size();
    m_beingadjustedlist.push_front(pBvr);
    if (lCurBvr < 0 || lCurBvr >= lSize)
    {
        pBvr->End(0.0);
    }

    m_beingadjustedlist.remove(pBvr);
}

//+-----------------------------------------------------------------------
//
//  Member:    MMExcl::AddToQueue
//
//  Overview:  Add element to Queue in the correct order.
//
//  Arguments: pBvr - element to add
//             state - state to add element in
//             
//  Returns:   void
//
//------------------------------------------------------------------------
void
MMExcl::AddToQueue(MMBaseBvr * pBvr, EXCL_STATE state)
{
    bool bDone = false;
    long lCurElement = -1;

    while (lCurElement < m_pPendingList.Size()-1 && !bDone)
    {
        RELATIONSHIP rel;
        TOKEN action;
        
        lCurElement++;
        MMBaseBvr *pCurBvr = m_pPendingList.Item(lCurElement);
        GetRelationship(pBvr, pCurBvr, rel);
        switch (rel)
        {
        case HIGHER:
            //never insert before an element of higher priority.
            break;
        case PEERS:
            if (state == PAUSED)  //only insert before peers if state is paused.
            {
                bDone = true;
            }
            break;
        case LOWER:
            bDone = true;  //insert before any element of a lower priority.
            //insert here.
            break;
        }
    }
    
    if (lCurElement == -1)
    {
        lCurElement = 0;
    }
    if (bDone == true)
    {
        m_pPendingList.Insert(lCurElement, pBvr);
        m_pPendingState.InsertIndirect(lCurElement, &state);
    }
    else
    {
        m_pPendingList.Append(pBvr);
        m_pPendingState.AppendIndirect(&state, NULL);
    }
   
    RemoveDuplicates(pBvr);
}

void 
MMExcl::RemoveDuplicates(MMBaseBvr *pBvr)
{
    bool bFirstInstance = true;
    int i = 0;
    while (i < m_pPendingList.Size())
    {
        MMBaseBvr *curBvr = m_pPendingList.Item(i);

        if (curBvr == pBvr)
        {
            if (bFirstInstance)
            {
                bFirstInstance = false;
                i++;
            }
            else
            {
                m_pPendingList.DeleteItem(i);    
                m_pPendingState.DeleteItem(i);
            }
        }
        else if (curBvr == m_pPlaying)
        {
            m_pPendingList.DeleteItem(i);    
            m_pPendingState.DeleteItem(i);
        }
        else
        {
            i++;
        }
    }
}

bool 
MMExcl::UsingPriorityClasses()
{
    bool bUsingPri = false;
    int i = 0;

    for(i = 0; i < m_pbIsPriorityClass.Size(); i++)
    {
        bUsingPri |= m_pbIsPriorityClass.Item(i);
    }

    return bUsingPri;
}

bool 
MMExcl::IsPriorityClass(MMBaseBvr *pBvr)
{
    bool bIsPriClass = false;
    IHTMLElement *pEle = NULL;  //this is a weak reference and will not be released.
    CComPtr<IHTMLElement> pEleParent;
    CComPtr <IHTMLElement> pNext;
    BSTR bstrTagName = NULL;
    HRESULT hr = S_OK;
    bool bDone = false;

    pEle = pBvr->GetElement().GetElement();
    if (pEle == NULL)

    {
        bIsPriClass = false;
        goto done;
    }

    hr = THR(pEle->get_parentElement(&pEleParent));
    if (FAILED(hr))
    {
        bIsPriClass = false;
        goto done;        
    }

    while (pEleParent != NULL && bDone != true)
    {
        hr = THR(pEleParent->get_tagName(&bstrTagName));
        if (FAILED(hr))
        {
            bIsPriClass = false;
            goto done;        
        }
        if (bstrTagName != NULL)
        {
            if (StrCmpIW(bstrTagName, WZ_PRIORITYCLASS_NAME) == 0)
            {
                bIsPriClass = true;
                bDone = true;
            }
            else if (StrCmpIW(bstrTagName, WZ_EXCL) == 0)
            {
                bIsPriClass = false;
                bDone = true;
            }
            SysFreeString(bstrTagName);
            bstrTagName = NULL;
        }
        
        hr = THR(pEleParent->get_parentElement(&pNext));
        if (FAILED(hr))
        {
            bIsPriClass = false;
            goto done;        
        }
        pEleParent.Release();
        pEleParent = pNext;
        pNext.Release();
     }

  done:

    if (bstrTagName)
    {
        SysFreeString(bstrTagName);
    }
    return bIsPriClass;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timebvr\mmseq.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmtimeline.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _MMSEQ_H
#define _MMSEQ_H

#include "mmtimeline.h"

class MMSeq :
    public MMTimeline
{
  public:
    MMSeq(CTIMEElementBase & elm, bool bFireEvents);
    virtual ~MMSeq();
    
    virtual bool Init();

    virtual bool childEventNotify(MMBaseBvr * bvr, double dblLocalTime, TE_EVENT_TYPE et);
    virtual bool childMediaEventNotify(MMBaseBvr * pBvr, double dblLocalTime, TIME_EVENT et);
    virtual bool childPropNotify(MMBaseBvr * pBvr, DWORD *tePropType);

    virtual HRESULT prevElement();
    virtual HRESULT nextElement();
    virtual HRESULT reverse();
    virtual HRESULT load();
    virtual HRESULT begin();

    virtual HRESULT AddBehavior(MMBaseBvr & bvr);
    virtual void RemoveBehavior(MMBaseBvr & bvr);
    virtual HRESULT updateSyncArc(bool bBegin, MMBaseBvr *bvr);
    virtual HRESULT Update(bool bUpdateBegin, bool bUpdateEnd);

  protected:
      MMSeq();
      long FindBvr(MMBaseBvr *bvr);
      double GetOffset(MMBaseBvr *bvr, bool bBegin);
      bool GetEvent(MMBaseBvr *bvr, bool bBegin);
      void FindDurations();
      long GetNextElement(long lCurElement, bool bForward);
      bool IsSet(MMBaseBvr *bvr);
      void updateSyncArcs(bool bSet, bool bReset); //updates all sync arcs in the sequence
      long FindFirstDuration();
      long FindLastDuration();
      bool isLastElement(long nIndex);
      long GetPredecessorForSyncArc (long nCurr);
      
  private:

      bool                      m_bDisallowEnd;
      bool                      m_bIgnoreNextEnd;
      long                      m_lActiveElement;
      CTIMEElementBase &        m_baseTIMEEelm;
      bool                      m_bReversing;
      double                   *m_pdblChildDurations; //the duration of the child element
      bool                     *m_fMediaHasDownloaded; //flags whether the media has downloaded.  For non-media elements this will be set to true
      bool                     *m_fAddByOffset; //flags whether the element duration is by offset
      bool                      m_bLoaded;
      bool                      m_bInPrev;
};

#endif /* _MMSEQ_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timebvr\mmtimeline.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmutil.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#include "headers.h"
#include "mmtimeline.h"
#include "timeelm.h"

#include "mmplayer.h"

DeclareTag(tagMMUTILTimeline, "TIME: Behavior", "MMTimeline methods")


// =======================================================================
//
// MMTimeline
//
// =======================================================================

MMTimeline::MMTimeline(CTIMEElementBase & elm, bool bFireEvents)
: MMBaseBvr(elm,bFireEvents),
  m_player(NULL),
  m_mes(MEF_NONE)
{
    TraceTag((tagMMUTILTimeline,
              "MMTimeline(%p)::MMTimeline(%p,%d,%d)",
              this,
              &elm,
              bFireEvents,
              m_mes));
}

MMTimeline::~MMTimeline()
{
    TraceTag((tagMMUTILTimeline,
              "MMTimeline(%p)::~MMTimeline()",
              this));
    if (m_player != NULL)
    {
        m_player->ClearTimeline();
        m_player = NULL;
    }
}

bool
MMTimeline::Init()
{
    TraceTag((tagMMUTILTimeline,
              "MMTimeline(%p)::Init()",
              this));

    bool ok = false;
    HRESULT hr;
    DAComPtr<ITIMENode> tn;
    
    hr = THR(TECreateTimeline(m_elm.GetID(), &m_timeline));
    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
        goto done;
    }
    
    hr = THR(m_timeline->QueryInterface(IID_ITIMENode,
                                        (void **) &tn));
    
    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
        goto done;
    }
    
    if (!MMBaseBvr::Init(tn))
    {
        goto done;
    }
    
    ok = true;
  done:
    return ok;
}

HRESULT
MMTimeline::AddBehavior(MMBaseBvr & bvr)
{
    TraceTag((tagMMUTILTimeline,
              "MMTimeline(%p)::AddBehavior(%p)",
              this,
              &bvr));

    bool ok = false;
    HRESULT hr;

    CTIMEElementBase *pelm = &bvr.GetElement();

    // Make sure that my element is the parent of the element
    Assert(pelm->GetParent() == &GetElement());

    UpdateChild(bvr);
    
    hr = THR(m_timeline->addNode(bvr.GetMMBvr()));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_children.Append(&bvr));
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
  done:
    if (FAILED(hr))
    {
        RemoveBehavior(bvr);
    }
    
    RRETURN(hr);
}

void
MMTimeline::RemoveBehavior(MMBaseBvr & bvr)
{
    TraceTag((tagMMUTILTimeline,
              "MMTimeline(%p)::RemoveBehavior(%p)",
              this,
              &bvr));

    if (bvr.GetMMBvr())
    {
        m_timeline->removeNode(bvr.GetMMBvr());
    }

    m_children.DeleteByValue(&bvr);
}

void
MMTimeline::Clear()
{
    TraceTag((tagMMUTILTimeline,
              "MMTimeline(%p)::Clear()",
              this));

    // TODO: Need to flesh this out
}

void
MMTimeline::UpdateEndSync()
{
    TraceTag((tagMMUTILTimeline,
              "MMTimeline(%p)::UpdateEndSync()",
              this));

    MMBaseBvr **ppBvr;
    int i;

    for (i = m_children.Size(), ppBvr = m_children;
         i > 0;
         i--, ppBvr++)
    {
        UpdateChild(**ppBvr);
    }
}
    
void
MMTimeline::UpdateChild(MMBaseBvr & pChild)
{
    TraceTag((tagMMUTILTimeline,
              "MMTimeline(%p)::UpdateChild(%p)",
              this,
              &pChild));

    bool bSet = false;
    
    switch (m_mes)
    {
      default:
        AssertStr(false, "Invalid endsync value in MMTimeline");
      case MEF_MEDIA:
      case MEF_NONE:
        bSet = false;
        break;
      case MEF_ALL:
        bSet = true;
        break;
      case MEF_ID:
        {
            LPCWSTR str = m_elm.GetEndSync();
            LPCWSTR id = pChild.GetElement().GetID();

            bSet = (str != NULL &&
                    id != NULL &&
                    StrCmpIW(str, id) == 0);
        }
        break;
    }

    pChild.SetEndSync(bSet);
}

HRESULT
MMTimeline::Update(bool bUpdateBegin,
                   bool bUpdateEnd)
{
    TraceTag((tagMMUTILTimeline,
              "MMTimeline(%p)::Update(%d, %d)",
              this,
              bUpdateBegin,
              bUpdateEnd));

    HRESULT hr;
        
    // Now update the timeline properties

    // Handle endsync
    LPOLESTR str = m_elm.GetEndSync();
    TE_ENDSYNC endSync = TE_ENDSYNC_LAST;
    
    if (str == NULL)
    {
        if (m_elm.IsBody())
        {
            endSync = TE_ENDSYNC_NONE;
            m_mes = MEF_NONE;
        }
        else
        {
            endSync = TE_ENDSYNC_LAST;
            m_mes = MEF_ALL;
        }
    }
    else if (StrCmpIW(str, WZ_LAST) == 0)
    {
        endSync = TE_ENDSYNC_LAST;
        m_mes = MEF_ALL;
    }
    else if (StrCmpIW(str, WZ_NONE) == 0)
    {
        endSync = TE_ENDSYNC_NONE;
        m_mes = MEF_NONE;
    }
    else if (StrCmpIW(str, WZ_FIRST) == 0)
    {
        endSync = TE_ENDSYNC_FIRST;
        m_mes = MEF_ALL;
    }
    else if (StrCmpIW(str, WZ_ALL) == 0)
    {
        endSync = TE_ENDSYNC_ALL;
        m_mes = MEF_ALL;
    }
    else
    {
        endSync = TE_ENDSYNC_FIRST;
        m_mes = MEF_ID;
    }

    // First turn it off, then update the children, and then add back
    // the new value
    
    IGNORE_HR(m_timeline->put_endSync(TE_ENDSYNC_NONE));

    UpdateEndSync();
    
    IGNORE_HR(m_timeline->put_endSync(endSync));

    hr = THR(MMBaseBvr::Update(bUpdateBegin, bUpdateEnd));
    if (FAILED(hr))
    {
        goto done;
    } 
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

bool
MMTimeline::childEventNotify(MMBaseBvr * pBvr, double dblLocalTime, TE_EVENT_TYPE et)
{
    Assert(NULL != pBvr);

    bool fProcessEvent = false;

    fProcessEvent = true;
done:
    return fProcessEvent;
}

bool 
MMTimeline::childPropNotify(MMBaseBvr * pBvr, DWORD *tePropType)
{
    return m_elm.ChildPropNotify(pBvr->GetElement(),
                                 *tePropType);
}

HRESULT 
MMTimeline::toggleTimeAction(bool bOn)
{
    if (!bOn)
    {
        int i = 0;
        while (i < m_children.Size())
        {
            MMBaseBvr *pBvr = m_children.Item(i);
            pBvr->GetElement().ToggleTimeAction(bOn);
            i++;
        }    
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timebvr\mmplayer.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmutil.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _MMPLAYER_H
#define _MMPLAYER_H

#include "mmutil.h"

class CTIMEBodyElement;

class MMPlayer
    : public ClockSink
{
  public:
    MMPlayer(CTIMEBodyElement & elm);
    ~MMPlayer();
    
    bool Init(MMTimeline & tl);
    void Deinit();

    bool Play();
    bool Stop();
    bool Pause();
    bool Resume();
    bool Tick(double gTime);
    // This forces one tick, so updates will be drawn even 
    // when the clock and player are paused (used for editing)
    bool TickOnceWhenPaused(void);
    
    inline HRESULT AddBehavior(MMBaseBvr & bvr)
    { return m_timeline->AddBehavior(bvr); }
    inline void RemoveBehavior(MMBaseBvr & bvr)
    { m_timeline->RemoveBehavior(bvr); }

    inline void Clear()
    { m_timeline->Clear(); }
    
    inline HRESULT Update(bool bBegin,
                          bool bEnd)
    { return m_timeline->Update(bBegin, bEnd); }
    
    ITIMENodeMgr * GetMMPlayer()
    { return m_player; }
    MMTimeline & GetTimeline()
    { return *m_timeline; }

    double GetCurrentTime()
    { if (m_clock) return m_clock->GetCurrentTime(); else return 0; }

    void ClearTimeline()
    { m_timeline = NULL; }

    void OnTimer(double time);

  protected:
    CTIMEBodyElement & m_elm;
    bool m_fReleased;
    MMTimeline * m_timeline;
    CComPtr<ITIMENodeMgr> m_player;
    Clock                 *m_clock;
    MMPlayer();
};

#endif /* _MMPLAYER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timebvr\mmseq.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmutil.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#include "headers.h"
#include "mmseq.h"
#include "timeelmbase.h"

DeclareTag(tagMMUTILSeq, "TIME: Behavior", "MMSeq methods")

#define SUPER MMTimeline

const double cfSmallTimeDelta = (DBL_EPSILON);
// =======================================================================
//
// MMSeq
//
// =======================================================================

MMSeq::MMSeq(CTIMEElementBase & elm, bool bFireEvents) :
    SUPER(elm, bFireEvents),
    m_bDisallowEnd(false),
    m_lActiveElement(-1),
    m_baseTIMEEelm(elm),
    m_bReversing(false),
    m_pdblChildDurations(NULL),
    m_fMediaHasDownloaded(NULL),
    m_bLoaded(false),
    m_fAddByOffset(NULL),
    m_bIgnoreNextEnd(false),
    m_bInPrev(false)
{

}

MMSeq::~MMSeq()
{
    delete [] m_pdblChildDurations;
    m_pdblChildDurations = NULL;
    delete [] m_fMediaHasDownloaded;
    m_fMediaHasDownloaded = NULL;
    delete [] m_fAddByOffset;
    m_fAddByOffset = NULL;    
}


bool 
MMSeq::Init()
{
    bool ok = false;

    ok = SUPER::Init();
    if (!ok)
    {
    }

    ok = true;
 done:
    return ok;
}
    

//+-----------------------------------------------------------------------
//
//  Member:    MMSeq::childEventNotify
//
//  Overview:  
//
//  Arguments: pBvr - element receiving event
//             dblLocalTime - time at which the event occurred
//             et - event that occurred
//             
//  Returns:   true if event should be processed, false otherwise
//
//------------------------------------------------------------------------
bool
MMSeq::childEventNotify(MMBaseBvr * bvr, double dblLocalTime, TE_EVENT_TYPE et)
{
    TraceTag((tagMMUTILSeq,
              "MMSeq(%p, %ls)::childEventNotify(%p, %ls): localTime = %g, event = %s",
              this,
              GetElement().GetID(),
                          bvr,
                          bvr->GetElement().GetID(),
                          dblLocalTime,
                          EventString(et)));

    bool fProcessEvent = true;
        
    fProcessEvent = SUPER::childEventNotify(bvr, dblLocalTime, et);
    if (fProcessEvent == false)
    {
        goto done;
    }

    switch(et)
    {
        case TE_EVENT_BEGIN:
        {
            
            //check that this is a valid element to be firing a begin event
            long lCurChild = FindBvr(bvr);
            long lNextChild = GetNextElement(m_lActiveElement, !m_bReversing);

            //the active element hasn't been updated yet.
            if (m_lActiveElement >= 0 && m_lActiveElement < m_children.Size()) 
            {
                MMBaseBvr *pBvr = m_children.Item(m_lActiveElement);
                if (pBvr->GetElement().GetFill() == FREEZE_TOKEN)
                {
                    pBvr->GetElement().ToggleTimeAction(false);
                }
            }
            //update the active element
            m_lActiveElement = lCurChild;
        }
            break;

        case TE_EVENT_END:
        {
    
            //check that this is a valid element to be firing an end event
            long lCurChild = FindBvr(bvr);

            if (m_bReversing)
            {
                long lPrevChild = GetNextElement(m_lActiveElement, true);
                if (m_lActiveElement != -1 && m_children.Item(m_lActiveElement)->IsActive())
                {
                    if (lCurChild != lPrevChild)
                    {
                        fProcessEvent = false;
                        goto done;
                    }
                }
                else if (lCurChild != FindFirstDuration())
                {
                    fProcessEvent = false;
                    goto done;
                }
            }
            else
            {
                long lPrevChild = m_lActiveElement;
                if (m_bInPrev)
                {
                    lPrevChild = GetNextElement(m_lActiveElement, true);
                }
                
                if (lCurChild != lPrevChild &&  lCurChild != m_lActiveElement )
                {
                    fProcessEvent = false;
                    goto done;
                }
            }

            if (m_bIgnoreNextEnd == false && m_bInPrev == false)
            {
                long lCurChild = FindBvr(bvr);
                if (isLastElement(lCurChild))
                {
                    m_lActiveElement = -1;
                }
            }
            m_bIgnoreNextEnd = false;
        }
            break;
        default:
            break;
    }


    fProcessEvent = true;

done:

    if (et == TE_EVENT_END && fProcessEvent == false)
    {
        long lCurChild = FindBvr(bvr);
        if (lCurChild != m_lActiveElement && m_lActiveElement != -1) 
        {
            MMBaseBvr *pBvr = m_children.Item(m_lActiveElement);
            if (pBvr->GetElement().GetFill() == FREEZE_TOKEN)
            {
                pBvr->GetElement().ToggleTimeAction(false);
            }
        }
    }

    return fProcessEvent;
}

bool 
MMSeq::childMediaEventNotify(MMBaseBvr * pBvr, double dblLocalTime, TIME_EVENT et)
{
    switch (et)
    {
        case TE_ONMEDIACOMPLETE:
        {
            long lCurBvr = FindBvr(pBvr);
            if (m_fMediaHasDownloaded != NULL)
            {
                m_fMediaHasDownloaded[lCurBvr] = true;               
            }
            if (m_pdblChildDurations != NULL)
            {   
                CComPtr <ITIMEMediaElement> pMediaElm;
                double dblMediaDur = 0.0;
                HRESULT hr = S_OK;
                hr = THR(pBvr->GetElement().QueryInterface(IID_ITIMEMediaElement, (void**)&pMediaElm));
                if (SUCCEEDED(hr))
                {
                    hr = THR(pMediaElm->get_mediaDur(&dblMediaDur));
                    if (SUCCEEDED(hr))
                    {
                        m_pdblChildDurations[lCurBvr] = dblMediaDur;
                        if (m_lActiveElement == lCurBvr && m_pdblChildDurations[lCurBvr] == HUGE_VAL)
                        {
                            //need to end this element and begin the next one.
                            m_pdblChildDurations[lCurBvr] = 0.0;
                            pBvr->GetElement().base_endElement(cfSmallTimeDelta);
                            pBvr->Reset(false);
                        }
                    }
                }
            
            }
        }
        break;
    
        case TE_ONMEDIAERROR:
        {
            long lCurBvr = FindBvr(pBvr);
            if (m_pdblChildDurations != NULL)
            {   
                if (m_pdblChildDurations[lCurBvr] == HUGE_VAL)
                {
                    m_pdblChildDurations[lCurBvr] = 0.0;
                    if (m_lActiveElement == lCurBvr)
                    {
                        //need to end this element and begin the next one.
                        pBvr->GetElement().base_endElement(cfSmallTimeDelta);
                        pBvr->Reset(false);
                    }
                }
            }
        }
        break;

        default:
            break;
    }

    return true;
}

long 
MMSeq::GetNextElement(long lCurElement, bool bForward)
{
    long lNextElement = lCurElement;
    long lNextInc = (bForward) ? 1 : -1;
    lNextElement += lNextInc;

    if (lNextElement >= m_children.Size() || lNextElement < 0)
    {
        lNextElement = -1;
    }
     
    return lNextElement;    
}

HRESULT
MMSeq::prevElement()
{
    HRESULT hr = S_OK;
    long lLength = 0;
    int i = 0;
    MMBaseBvr *bvr = NULL;

    lLength = m_children.Size();
 
    if (m_lActiveElement == -1)
    {
        goto done;
    }

    bvr = m_children.Item(m_lActiveElement);
    if (bvr == NULL)
    {
        goto done;
    }

    m_bDisallowEnd = true;
    if (m_bReversing == false)
    {
        if (bvr->IsActive())
        {
            m_bInPrev = true;
            if (m_lActiveElement == FindFirstDuration())
            {
                // If the element is locked it needs to seek the timeline to 
                // zero.  This is for bug #107744 (ie5 DB)
                if (bvr->GetElement().IsLocked() == true)
                {
                    //m_elm.GetMMBvr().Reset(false); // For bug 20073
                    m_elm.GetMMBvr().SeekSegmentTime(0.0);
                }
                else
                {
                    bvr->SeekSegmentTime(0.0);
                }
            }
            else
            {
                long lLastElement = FindLastDuration();
                double dblSimpleTime = m_baseTIMEEelm.GetMMBvr().GetSimpleTime();
                long lNextPlaying = GetNextElement(m_lActiveElement, false);
                bool m_bIgnoreNextEnd = (lLastElement == m_lActiveElement);
                Assert(lNextPlaying != -1);
                
                MMBaseBvr *pNextPlaying = m_children.Item(lNextPlaying);
                pNextPlaying->BeginAt(dblSimpleTime, 0.0);
                bvr->Reset(false);
            }    
            m_bInPrev = false;
        }
    }
    else
    {
        // ISSUE: doesn't work for autoreverse
    }

    hr = S_OK;

  done:
    m_bDisallowEnd = false;
    return hr;
}


HRESULT
MMSeq::nextElement()
{
    HRESULT hr = S_OK;
    long lLength = 0;
    int i = 0;
    MMBaseBvr *bvr = NULL;

    if (m_lActiveElement == -1)
    {
        goto done;
    }

    bvr = m_children.Item(m_lActiveElement);
    if (bvr == NULL)
    {
        goto done;
    }

    if (bvr->IsActive())
    {
        if (m_bReversing == false)
        {
            double dblSimpleTime = m_baseTIMEEelm.GetMMBvr().GetSimpleTime();
            bvr->EndAt(dblSimpleTime, 0.0);        
        }
        else
        {
            // ISSUE : Doesn't work for autoreverse.     
        }
    }

    hr = S_OK;

  done:

    return hr;
}



long 
MMSeq::FindBvr(MMBaseBvr *bvr)
{
    long i = 0;
    long lIndex = m_children.Find(bvr);

    return lIndex;
}


bool
MMSeq::GetEvent(MMBaseBvr *bvr, bool bBegin)
{

    bool bEvent = false;
    TimeValueList *tv;
    TimeValueSTLList *l;
    TimeValueSTLList::iterator iter;

    if (bBegin == true)
    {
        tv = &(bvr->GetElement().GetRealBeginValue());
    }
    else
    {
        tv = &(bvr->GetElement().GetRealEndValue());
    }
    l = &(tv->GetList());

    long x = l->size();
    if ( x <= 0)
    {
        goto done;
    }
    for (iter = l->begin(); iter != l->end(); iter++)
    {
        TimeValue *p = (*iter);
        double dblOffset = p->GetOffset();
        MMBaseBvr * pmmbvr = NULL;
    
        if (p->GetEvent() != NULL)
        {
            bEvent = true;
            goto done;
        }
    }

    bEvent = false;

  done:

    return bEvent;
}

double 
MMSeq::GetOffset(MMBaseBvr *bvr, bool bBegin)
{
    double dblBeginTime = 0.0;
    TimeValueList *tv;
    TimeValueSTLList *l;
    TimeValueSTLList::iterator iter;

    if (bBegin == true)
    {
        tv = &(bvr->GetElement().GetRealBeginValue());
    }
    else
    {
        tv = &(bvr->GetElement().GetRealEndValue());
    }
    l = &(tv->GetList());

    long x = l->size();
    if ( x <= 0)
    {
        goto done;
    }
    for (iter = l->begin(); iter != l->end(); iter++)
    {
        TimeValue *p = (*iter);
        double dblOffset = p->GetOffset();
        MMBaseBvr * pmmbvr = NULL;
    
        if (p->GetEvent() == NULL)
        {
            Assert(p->GetElement() == NULL);
            dblBeginTime = dblOffset;
            goto done;
        }
    }

    dblBeginTime = 0.0;

  done:

    return dblBeginTime;
}

HRESULT 
MMSeq::reverse()
{
    m_bReversing = !m_bReversing;
    m_lActiveElement = -1; 
    return S_OK;
}


HRESULT 
MMSeq::begin()
{
    if (!m_bLoaded)  //this handles the case of being dynamically added to the page
    {
        load();
    }
    m_baseTIMEEelm.GetMMBvr().PutNaturalDur((double)TE_UNDEFINED_VALUE);
    return S_OK;
}



HRESULT
MMSeq::AddBehavior(MMBaseBvr & bvr)
{
    bool ok = false;
    CComPtr <IUnknown> pUnk;
    CComPtr <IDispatch> pChildColDisp;
    CComPtr <IHTMLElementCollection> pChildCol;    
    VARIANT vName, vIndex, vClass;
    CComBSTR bstrClassName = L"classname";
    CComBSTR bstrClass = L"class";
    int i = 0, j = 0;
    HRESULT hr = S_OK;
    long lChildCount = 0;
    bool bInserted = false;
    bool *fMediaHasDownloaded = NULL;
    bool bAppended = false;

    CTIMEElementBase *pelm = NULL;

    fMediaHasDownloaded = NEW bool [m_children.Size() + 1];
    if (fMediaHasDownloaded == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    ZeroMemory(fMediaHasDownloaded, sizeof(bool) * (m_children.Size() + 1));

    VariantInit(&vClass);
    VariantInit(&vName);
    VariantInit(&vIndex);
    vName.vt = VT_I4;
    vName.lVal = 0;

    pelm = &bvr.GetElement();

    // Make sure that my element is the parent of the element
    Assert(pelm->GetParent() == &GetElement());

    UpdateChild(bvr);
    
    hr = THR(m_timeline->addNode(bvr.GetMMBvr()));
    if (FAILED(hr))
    {
        goto done;
    }
    
    //get the IUnknown of the element that this behavior is attached to.
    hr = THR(pelm->GetElement()->QueryInterface(IID_IUnknown, (void **) &pUnk));
    if (FAILED(hr))
    {
        goto done;
    }   

    //get all of the html children of this element.
    hr = GetElement().GetElement()->get_children(&pChildColDisp);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pChildColDisp->QueryInterface(IID_IHTMLElementCollection, (void **)&pChildCol);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pChildCol->get_length(&lChildCount);
    if (FAILED(hr))
    {
        goto done;
    }

    //get the collection of all top level time children of this element.
    i = 0;
    j = 0;
    while (i < lChildCount)
    {
        CComPtr <IDispatch> pChildDisp;
        CComPtr <IHTMLElement> pChild;      
        CComPtr <ITIMEElement> pTimeElement;  
        
        vName.lVal = i;
    
        hr = pChildCol->item(vName, vIndex, &pChildDisp);
        if (FAILED(hr) || pChildDisp == NULL)
        {
            continue;
        }


        hr = FindBehaviorInterface(m_baseTIMEEelm.GetBehaviorName(),
                                   pChildDisp,
                                   IID_ITIMEElement,
                                   (void**)&pTimeElement);
        if (FAILED(hr))
        {
            CComPtr <IHTMLElement> pChildEle;

            hr = THR(pChildDisp->QueryInterface(IID_IHTMLElement, (void **)&pChildEle));
            if (SUCCEEDED(hr))
            {
                hr = pChildEle->getAttribute(bstrClassName, 0, &vClass);
                if (SUCCEEDED(hr))
                {
                    if ((vClass.vt == VT_BSTR) && (vClass.bstrVal != NULL) && StrCmpIW(vClass.bstrVal, L"time") == 0)
                    {
                        hr = S_OK;
                    }
                    else
                    {
                        hr = E_FAIL;
                        VariantClear(&vClass);
                        hr = pChildEle->getAttribute(bstrClass, 0, &vClass);
                        if (SUCCEEDED(hr))
                        {
                            if ((vClass.vt == VT_BSTR) && (vClass.bstrVal != NULL) && StrCmpIW(vClass.bstrVal, L"time") == 0)
                            {
                                hr = S_OK;
                            }
                            else
                            {
                                hr = E_FAIL;
                            }
                        }
                    }
                }
            }
        }
        if (SUCCEEDED(hr))
        {
            CComPtr <IUnknown> pTimeChildUnk;

            hr = THR(pChildDisp->QueryInterface(IID_IUnknown, (void**)&pTimeChildUnk));
            if (SUCCEEDED(hr))
            {
                if (pUnk == pTimeChildUnk)
                {
                    if (j < m_children.Size())
                    {
                        hr = THR(m_children.Insert(j, &bvr));
                    }
                    else
                    {
                        hr = THR(m_children.Append(&bvr));
                        m_bIgnoreNextEnd = true;
                        bAppended = true;
                    }
                    bInserted = true;
                    break;
                }
            }
            j++;
        }
        i++;
    }

    if (m_fMediaHasDownloaded != NULL)
    {
        for (i = 0; i < m_children.Size(); i++)
        {
            if (i == j)
                fMediaHasDownloaded[i] = false;
            if (i > j)
            {
                fMediaHasDownloaded[i] = m_fMediaHasDownloaded[i - 1];
            }
            else
            {
                fMediaHasDownloaded[i] = m_fMediaHasDownloaded[i];
            }
        }
        delete [] m_fMediaHasDownloaded;
        m_fMediaHasDownloaded = fMediaHasDownloaded;
        fMediaHasDownloaded = NULL;
    }
    else
    {
        m_fMediaHasDownloaded = fMediaHasDownloaded;
        fMediaHasDownloaded = NULL;
    }

    if (!bInserted)
    {
        hr = THR(m_children.Append(&bvr));
        bAppended = true;
    }
    
    
    if (m_bLoaded == true) //adding a behavior at runtime
    {
        m_bDisallowEnd = true;
        FindDurations();    
        updateSyncArcs(false, false); //clear the syncArcs
        updateSyncArcs(true, true); //reset the syncArcs
        m_bDisallowEnd = false;
    }

    hr = S_OK;
  done:

    VariantClear(&vName);
    VariantClear(&vIndex);
    VariantClear(&vClass);
    
    if (FAILED(hr))
    {
        RemoveBehavior(bvr);
    }
    
    RRETURN(hr);
}

//+-----------------------------------------------------------------------
//
//  Member:    MMSeq::childPropNotify
//
//  Overview:  
//
//  Arguments: pBvr - element receiving notification
//             tePropType - type of notification occurring
//
//  Returns:   true if element should process notification, otherwise false
//
//------------------------------------------------------------------------
bool
MMSeq::childPropNotify(MMBaseBvr * pBvr, DWORD *tePropType)
{
    Assert(NULL != pBvr);

    bool fProcessNotify = true;
    DWORD dwTemp = *tePropType & TE_PROPERTY_ISON;

    if (dwTemp == TE_PROPERTY_ISON)
    {
        if (pBvr->GetElement().GetFill() == FREEZE_TOKEN)
        {
            *tePropType = *tePropType - TE_PROPERTY_ISON;
        }
    }

    if (!SUPER::childPropNotify(pBvr, tePropType))
    {
        fProcessNotify = false;
        goto done;
    }

    fProcessNotify = true;
done:
    return fProcessNotify;
}


void 
MMSeq::FindDurations()
{
    long lLength = m_children.Size();
    long i = 0;

    delete [] m_pdblChildDurations;
    m_pdblChildDurations = NULL;

    delete [] m_fAddByOffset;
    m_fAddByOffset = NULL;

    m_pdblChildDurations = NEW double [lLength];
    if (m_pdblChildDurations == NULL)
    {
        goto done; //out of memory.
    }
    ZeroMemory(m_pdblChildDurations, sizeof(double) * lLength);

    
    m_fAddByOffset = NEW bool [lLength];
    if (m_fAddByOffset == NULL)
    {
        goto done; //out of memory.
    }
    ZeroMemory(m_fAddByOffset, sizeof(bool) * lLength);

    for (i = 0; i < lLength; i++)
    {
        MMBaseBvr *pBvr = m_children.Item(i);

        if (pBvr == NULL)
        {
            m_pdblChildDurations[i] = 0.0;
            continue;
        }

        m_pdblChildDurations[i] = pBvr->GetActiveDur();

        if (m_pdblChildDurations[i] == HUGE_VAL)
        {
            m_pdblChildDurations[i] = pBvr->GetActiveEndTime();
        }
        else if (m_pdblChildDurations[i] == 0.0)
        {
            CTIMEElementBase & elm = pBvr->GetElement();
            // need to check for dur and repeatdur properties.
            if (elm.GetEndAttr().IsSet() == true && 
                (elm.GetDurAttr().IsSet() == false ||
                 elm.GetDuration() == 0.0))
            {
                m_pdblChildDurations[i] = pBvr->GetActiveEndTime();
            }
        }

              
        if (m_pdblChildDurations[i] == HUGE_VAL)
        {
            double dblEndOffset = GetOffset(pBvr, false);
            if (dblEndOffset != 0.0)
            {
                m_pdblChildDurations[i] = dblEndOffset;
            }
        }
        if (m_pdblChildDurations[i] == HUGE_VAL)
        {
            HRESULT hr = S_OK;
            CComPtr <ITIMEMediaElement> pMediaElm;
            CTIMEElementBase & elm = pBvr->GetElement();

            // need to check for dur and repeatdur properties.
            if (elm.GetRepeatDur() == valueNotSet && 
                (elm.GetDuration() == valueNotSet ||
                 elm.GetDuration() == HUGE_VAL))
            {
                // need to check if this is a media element
                hr = elm.QueryInterface(IID_ITIMEMediaElement, (void **)&pMediaElm);
                if (FAILED(hr)) 
                {
                    // this is not a media element 
                    //m_pdblChildDurations[i] = 0.0;
                    m_fMediaHasDownloaded[i] = true;
                }
                else
                {
                    double dblMediaDur = 0.0;
                    hr = THR(pMediaElm->get_mediaDur(&dblMediaDur));
                    if (SUCCEEDED(hr) && dblMediaDur != -1)
                    {   
                        m_pdblChildDurations[i] = dblMediaDur;
                        m_fMediaHasDownloaded[i] = true;
                    }
                }
            }
        }

        if (m_pdblChildDurations[i] == HUGE_VAL && m_fMediaHasDownloaded[i] == true)
        {   //need to check for an end event.
            bool bHasEnd = GetEvent(pBvr, false);
            if (bHasEnd == false && GetElement().IsGroup() == false)
            {
                m_pdblChildDurations[i] = -1.0;
            }
        }

        if (m_pdblChildDurations[i] == -1.0)
        {
            
            if (i+1 < m_children.Size())
            {
                MMBaseBvr *pNextBvr = m_children.Item(i+1);
                double dblOffset = GetOffset(pNextBvr, true);
                if (dblOffset > 0.0)
                {
                    m_pdblChildDurations[i] = dblOffset;
                    m_fAddByOffset[i] = true;
                }
            }
        }
        if (m_pdblChildDurations[i] == 0.0 && pBvr->GetElement().IsGroup())
        {
            m_pdblChildDurations[i] = HUGE_VAL;
        }
        if (i == m_children.Size() - 1 && m_pdblChildDurations[i] == 0.0)
        {
            MMBaseBvr *pChildBvr = m_children.Item(i);
            TOKEN tFill = pChildBvr->GetElement().GetFill();

            // We do not have an easy way of 
            // determining what the proper duration
            // of a child with a transition fill
            // value is.  It may be latched to 
            // a transition living completely
            // outside this container.  It's 
            // also possible that the transition
            // has not even been added to the graph 
            // at all yet.
            if (   (tFill == HOLD_TOKEN)
                || (tFill == TRANSITION_TOKEN))
            {
                m_pdblChildDurations[i] = HUGE_VAL;
            }
        }
    }

  done:

    return;
}


void 
MMSeq::RemoveBehavior(MMBaseBvr & bvr)
{
    if (bvr.IsActive() == true)
    {
        nextElement();
    }

    SUPER::RemoveBehavior(bvr);

    updateSyncArcs(false, false);
    updateSyncArcs(true, true);

}

HRESULT
MMSeq::load()
{
    HRESULT hr = S_OK;

    if (!m_bLoaded)
    {
        m_bLoaded = true;
        FindDurations();    
        updateSyncArcs(true, true);
    }
    return hr;
}

bool 
MMSeq::isLastElement(long nIndex)
{
    long lIndex = 0;
    long lNextChild = 0;
    bool bFirst = true;
    bool bMatch = false;
     
    while (lNextChild != -1) //loop to find the last valid child in the sequence
    {
        lNextChild = GetNextElement(lNextChild, true); 
        if (lNextChild != -1)
        {
            bFirst = false;
            lIndex = lNextChild;
        }
    }
    if (bFirst && m_pdblChildDurations[0] != 0.0)
    {
        lIndex = 0;
    }

    if (lIndex == nIndex)
    {
        bMatch = true;
    }

    return bMatch;
}

void 
MMSeq::updateSyncArcs(bool bSet, bool bReset)
{
    long lSize = m_children.Size();
    for(int i = 0; i < lSize; i++)
    {
        MMBaseBvr *pBvr = m_children.Item(i);

        Assert(NULL != pBvr);
        if (bSet && (pBvr->GetEnabled())) 
        {
            updateSyncArc(true, pBvr);
        }
        else //clear
        {
            pBvr->ClearSyncArcs(true);
            pBvr->ClearSyncArcs(false);
        }
        if (bReset == true)
        {
            pBvr->Reset(false);
        }
    }
}

long 
MMSeq::FindFirstDuration()
{
    bool bFirst = false;
    int i = 0;

    while (i < m_children.Size() && bFirst == false)
    {
        //if this has a duration of has not downloaded media then it is the first duration.
        if ((m_pdblChildDurations[i] != 0.0) || 
            ((m_fMediaHasDownloaded[i] == false) && (m_pdblChildDurations[i] == HUGE_VAL)))
        {
             bFirst = true;
        }
        else
        {
            i++;
        }
    }

    if (i == m_children.Size())
    {
         i = -1;
    }

    return i;
}

long 
MMSeq::FindLastDuration()
{
    bool bLast = false;
    int i = m_children.Size() - 1;

    while (i >= 0 && bLast == false)
    {
        //if this has a duration of has not downloaded media then it is the first duration.
        if ((m_pdblChildDurations[i] != 0.0) || 
            ((m_fMediaHasDownloaded[i] == false) && (m_pdblChildDurations[i] == HUGE_VAL)))
        {
             bLast = true;
        }
        else
        {
            i--;
        }
    }

    return i;
}

long
MMSeq::GetPredecessorForSyncArc (long nCurr)
{
    long lPrev = nCurr;
    MMBaseBvr *pmmbvrPrev = NULL;

    do
    {
        lPrev = GetNextElement(lPrev, false);
        if (lPrev < 0)
        {
            break;
        }
        pmmbvrPrev = m_children.Item(lPrev);
        if (NULL == pmmbvrPrev)
        {
            lPrev = -1;
            break;
        }
    } while (!pmmbvrPrev->GetEnabled());

    return lPrev;
}

HRESULT 
MMSeq::updateSyncArc(bool bBegin, MMBaseBvr *pBvr)
{
    TE_TIMEPOINT tetp;
    MMBaseBvr * pmmbvr = NULL;
    double dblOffset = 0.0;
    HRESULT hr = S_OK;  

    
    // get index of current child from parent
    int nIndex = FindBvr(pBvr);
    //get the element behind the current element
    long lNext = GetPredecessorForSyncArc(nIndex); 

    if (m_pdblChildDurations == NULL || m_fAddByOffset == NULL)
    {
        goto done;
    }
    // It better have been in the list
    if (nIndex == -1)
    {
        goto done;
    }
    
    dblOffset = GetOffset(pBvr, true);

    if (   (nIndex == 0)
        || (-1 == lNext))
    {
        tetp = TE_TIMEPOINT_NONE;
        pmmbvr = NULL;
    }
    else
    {
        tetp = TE_TIMEPOINT_END;
        
        if (lNext >= 0)
        {
            if (m_fAddByOffset[lNext] == true)
            {
                if (m_pdblChildDurations[lNext] != 0.0)
                {
                    dblOffset = cfSmallTimeDelta;
                }
            }
        }
        pmmbvr = m_children.Item(lNext);

        if (dblOffset == 0.0)
        {
            dblOffset = cfSmallTimeDelta;
        }
    }

    pBvr->AddOneTimeValue(pmmbvr,
                          tetp,
                          dblOffset,
                          true);

    //if this is beginning because of an offset then set it's end point to be
    //it's begin point + it's duration
    if (m_fAddByOffset[nIndex] == true && m_pdblChildDurations[nIndex] != 0.0) 
    {                                   
        pBvr->AddOneTimeValue(pBvr,
                              TE_TIMEPOINT_BEGIN,
                              m_pdblChildDurations[nIndex] ,
                              false);
    }
    else if (m_fAddByOffset[nIndex] == true && m_pdblChildDurations[nIndex] == 0.0) 
    {
        pBvr->AddOneTimeValue(pBvr,
                              TE_TIMEPOINT_BEGIN,
                              cfSmallTimeDelta,
                              false);

    }
    else if (m_pdblChildDurations[nIndex] == 0.0 )
    {   
        if (!(FindFirstDuration() == -1 && nIndex == m_children.Size() - 1))
        {
            //pBvr->SetZeroRepeatDur(true);
            pBvr->Update(false, true);
        }
        else if (nIndex == m_children.Size() - 1)
        {
            pBvr->AddOneTimeValue(pBvr,
                                  TE_TIMEPOINT_BEGIN,
                                  cfSmallTimeDelta,
                                 false);
        }
    }


  done:
    return hr;
}


HRESULT
MMSeq::Update(bool bUpdateBegin,
              bool bUpdateEnd)
{
    HRESULT hr = S_OK;
    TE_ENDSYNC endSync = TE_ENDSYNC_LAST;
    m_mes = MEF_ALL;

    // First turn it off, then update the children, and then add back
    // the new value
    
    IGNORE_HR(m_timeline->put_endSync(TE_ENDSYNC_NONE));

    UpdateEndSync();
    
    IGNORE_HR(m_timeline->put_endSync(endSync));

    hr = THR(MMBaseBvr::Update(bUpdateBegin, bUpdateEnd));
    if (FAILED(hr))
    {
        goto done;
    } 
    
    hr = S_OK;
  done:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timebvr\mmtimeline.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmtimeline.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _MMTIMELINE_H
#define _MMTIMELINE_H

#include "mmutil.h"
#include "eventmgr.h"

class MMTimeline :
    public MMBaseBvr
{
  public:
    MMTimeline(CTIMEElementBase & elm, bool bFireEvents);
    virtual ~MMTimeline();
    
    virtual bool Init();
    
    virtual HRESULT AddBehavior(MMBaseBvr & bvr);
    virtual void RemoveBehavior(MMBaseBvr & bvr);
    virtual void Clear();
    
    virtual HRESULT Update(bool bBegin,
                           bool bEnd);

    virtual bool childEventNotify(MMBaseBvr * pBvr, double dblLocalTime, TE_EVENT_TYPE et);
    virtual bool childMediaEventNotify(MMBaseBvr * pBvr, double dblLocalTime, TIME_EVENT et) 
        { return true; };
    virtual bool childPropNotify(MMBaseBvr * pBvr, DWORD *tePropType);
    
    ITIMEContainer * GetMMTimeline()
    { return m_timeline; }
    void put_Player(MMPlayer *player)
    { m_player = player; }

    virtual HRESULT prevElement() 
        { return E_NOTIMPL; };
    virtual HRESULT nextElement() 
        { return E_NOTIMPL; };
    virtual HRESULT begin() 
        { return S_OK; };
    virtual HRESULT reverse() 
        { return S_OK; };
    virtual HRESULT end()
        { return S_OK; };
    virtual HRESULT seek(double dblTime)
        { return S_OK; };
    virtual HRESULT repeat()
        { return S_OK; };
    virtual HRESULT load()
        { return S_OK; };
    virtual HRESULT toggleTimeAction(bool bOn);
    virtual HRESULT updateSyncArc(bool bBegin, MMBaseBvr *bvr)
        { return S_OK; };

  protected:
    CComPtr<ITIMEContainer> m_timeline;

    // These are the children we have already added because we found
    // their base
    CPtrAry<MMBaseBvr *> m_children;

    enum MM_ENDSYNC_FLAGS
    {
        MEF_NONE  = 0,
        MEF_ALL   = 1,
        MEF_ID    = 2,
        MEF_MEDIA = 3,
    };
    
    MM_ENDSYNC_FLAGS m_mes;
    
    void UpdateEndSync();
    
    virtual void UpdateChild(MMBaseBvr &);
    
  private:
     MMPlayer * m_player;
  protected:
      MMTimeline();
};

#endif /* _MMTIMELINE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timebvr\tebcollect.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: tebcollect.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "timeelmbase.h"


DeclareTag(tagTEBCollect, "TIME: Behavior", "CTIMEElementBase collection methods");


// CAtomTable is used as a static object by CTIMEElementBase and needs to be 
// thread safe since we can have multiple trident threads in the same process
static CritSect g_TEBCriticalSection;


STDMETHODIMP CTIMEElementBase::CreateActiveEleCollection()
{
    HRESULT hr = S_OK;
    
    //create the ActiveElementCollection for any timeline element
    if (((m_TTATimeContainer != ttUninitialized && m_TTATimeContainer != ttNone) ||
        (m_bIsSwitch == true)) &&
        !m_activeElementCollection)
    {
        m_activeElementCollection = NEW CActiveElementCollection(*this);
        if (!m_activeElementCollection)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }

  done:
    return hr;
}

//************************************************************
// Author:      twillie
// Created:     10/07/98
// Abstract:    helper function to wade thru cache.
//************************************************************

HRESULT
CTIMEElementBase::GetCollection(COLLECTION_INDEX index, ITIMEElementCollection ** ppDisp)
{
    HRESULT hr;

    // validate out param
    if (ppDisp == NULL)
        return TIMESetLastError(E_POINTER);

    *ppDisp = NULL;

    hr = EnsureCollectionCache();
    if (FAILED(hr))
    {
        TraceTag((tagError, "CTIMEElementBase::GetCollection - EnsureCollectionCache() failed"));
        return hr;
    }

    // call in
    return m_pCollectionCache->GetCollectionDisp(index, (IDispatch **)ppDisp);
} // GetCollection

//************************************************************
// Author:      twillie
// Created:     10/07/98
// Abstract:    Make sure collection cache is up
//************************************************************

HRESULT 
CTIMEElementBase::EnsureCollectionCache()
{
    // check to see if collection cache has been created
    if (m_pCollectionCache == NULL)
    {
        // bring up collection cache
        // NOTE: we need to handle TIMESetLastError here as
        // cache object doesn't have that concept.
        m_pCollectionCache = NEW CCollectionCache(this, GetAtomTable());
        if (m_pCollectionCache == NULL)
        {
            TraceTag((tagError, "CTIMEElementBase::EnsureCollectionCache - Unable to create Collection Cache"));
            return TIMESetLastError(E_OUTOFMEMORY);
        }

        HRESULT hr = m_pCollectionCache->Init(NUM_COLLECTIONS);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CTIMEElementBase::EnsureCollectionCache - collection cache init failed"));
            delete m_pCollectionCache;
            return TIMESetLastError(hr);
        }

        // set collection types
        m_pCollectionCache->SetCollectionType(ciAllElements, ctAll);
        m_pCollectionCache->SetCollectionType(ciChildrenElements, ctChildren);
    }

    return S_OK;
} // EnsureCollectionCache

//************************************************************
// Author:      twillie
// Created:     10/07/98
// Abstract:    invalidate all collection cache's that might
//              reference this object.
//************************************************************

HRESULT 
CTIMEElementBase::InvalidateCollectionCache()
{
    CTIMEElementBase *pelem = this;

    // walk up tree, invalidating CollectionCache's
    // we skip if the collection is not initialized
    // we walk until we run out of parent's.  In this
    // manner, we keep the collectioncache fresh, even
    // if the object branch is orphaned.
    while (pelem != NULL)
    {
        // not everybody will have the collection cache
        // initialized
        CCollectionCache *pCollCache = pelem->GetCollectionCache();        
        if (pCollCache != NULL)
            pCollCache->BumpVersion();
        
        // move to parent
        pelem = pelem->GetParent();
    }

    return S_OK;
} // InvalidateCollectionCache

//************************************************************
// Author:      twillie
// Created:     10/07/98
// Abstract:    init Atom Table
//              Note:  this is only done once and then addref'd.
//************************************************************

HRESULT 
CTIMEElementBase::InitAtomTable()
{
    // CAtomTable is used as a static object by CTIMEElementBase and needs to be 
    // thread safe since we can have multiple trident threads in the same process
    CritSectGrabber cs(g_TEBCriticalSection);
    
    if (s_cAtomTableRef == 0)
    {
        Assert(s_pAtomTable == NULL);

        s_pAtomTable = NEW CAtomTable();
        if (s_pAtomTable == NULL)
        {
            TraceTag((tagError, "CElement::InitAtomTable - alloc failed for CAtomTable"));
            return TIMESetLastError(E_OUTOFMEMORY);
        }
        s_pAtomTable->AddRef();
    }

    s_cAtomTableRef++;
    return S_OK;
} // InitAtomTable

//************************************************************
// Author:      twillie
// Created:     10/07/98
// Abstract:    release Atom Table
//              Note: this decrement's until zero and then
//              releases the Atom table.
//************************************************************

void 
CTIMEElementBase::ReleaseAtomTable()
{
    // CAtomTable is used as a static object by CTIMEElementBase and needs to be 
    // thread safe since we can have multiple trident threads in the same process
    CritSectGrabber cs(g_TEBCriticalSection);

    Assert(s_pAtomTable != NULL);
    Assert(s_cAtomTableRef > 0);
    if (s_cAtomTableRef > 0)
    {
        s_cAtomTableRef--;
        if (s_cAtomTableRef == 0)
        {
            if (s_pAtomTable != NULL)
            {
                s_pAtomTable->Release();
                s_pAtomTable = NULL;
            }
        }
    }
    return;
} // ReleaseAtomTable
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timebvr\mmutil.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmutil.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#include "headers.h"
#include "mmutil.h"
#include "timeelm.h"
#include "..\tags\bodyelm.h"

DeclareTag(tagMMUTILBvr, "TIME: Behavior", "MMBvr methods")
DeclareTag(tagMMUTILBaseBvr, "TIME: Behavior", "MMBaseBvr methods")
DeclareTag(tagMMUTILPlayer, "TIME: Behavior", "MMPlayer methods")
DeclareTag(tagMMUTILEvents, "TIME: Behavior", "MMBaseBvr Events")

MMBaseBvr::MMBaseBvr(CTIMEElementBase & elm, bool bFireEvents)
: m_elm(elm),
#if DBG
  m_id(NULL),
#endif //DBG
  m_bFireEvents(bFireEvents),
  m_bEnabled(true),
  m_bZeroRepeatDur(false)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::MMBaseBvr(%p,%d)",
              this,
              &elm,
              bFireEvents));
}

MMBaseBvr::~MMBaseBvr()
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::~MMBaseBvr()",
              this));

    if (m_teb)
    {
        m_teb->SetMMBvr(NULL);
        m_bvr->removeBehavior((ITIMENodeBehavior *) m_teb);
        m_teb.Release();
    }

    ClearSyncArcs(true);
    ClearSyncArcs(false);
#if DBG
    if (NULL != m_id)
    {
        delete[] m_id;
        m_id = NULL;
    }
#endif //DBG
}

bool
MMBaseBvr::Init(ITIMENode * node)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::Init(%p)",
              this,
              node));

    bool ok = false;
    HRESULT hr;
    
    Assert(node != NULL);
    
    m_bvr = node;

#if DBG
    if (NULL != m_elm.GetID())
    {
        m_id = CopyString(m_elm.GetID());
        if (NULL == m_id)
        {
            TIMESetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }
    }
#endif DBG

    if (m_bFireEvents)
    {
        m_teb = NEW TEBvr;
        
        if (!m_teb)
        {
            TIMESetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }
        
        m_teb->SetMMBvr(this);

        hr = THR(m_bvr->addBehavior((ITIMENodeBehavior *) m_teb));
        if (FAILED(hr))
        {
            TIMESetLastError(hr, NULL);
            goto done;
        }
    }
    
    ok = true;
  done:
    if (!ok)
    {
        m_teb.Release();
        m_bvr.Release();
    }
    
    return ok;
}

HRESULT
MMBaseBvr::Begin(double dblOffset)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::Begin(%g)",
              this,
              dblOffset));

    HRESULT hr;

    if (m_bvr)
    {
        double dblParentTime = GetCurrParentTime();
    
        hr = THR(m_bvr->beginAt(dblParentTime + dblOffset));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
MMBaseBvr::Reset(bool bLightweight)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::Reset(%d)",
              this,
              bLightweight));

    HRESULT hr;

    if (bLightweight)
    {
        hr = THR(m_bvr->update(0));
    }
    else
    {
        hr = THR(m_bvr->reset());
    }

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
MMBaseBvr::End(double dblOffset)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::End(%g)",
              this,
              dblOffset));

    HRESULT hr;
    
    if (m_bvr)
    {
        double dblParentTime = GetCurrParentTime();
    
        hr = THR(m_bvr->endAt(dblParentTime + dblOffset));
        if (FAILED(hr))
        {
            goto done;
        }
    }
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
MMBaseBvr::Pause()
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::Pause()",
              this));

    HRESULT hr;

    hr = THR(m_bvr->pause());

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
MMBaseBvr::Resume()
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::Resume()",
              this));

    HRESULT hr;

    hr = THR(m_bvr->resume());

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
MMBaseBvr::Disable()
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::Disable()",
              this));

    HRESULT hr;

    hr = THR(m_bvr->disable());

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
MMBaseBvr::Enable()
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::Enable()",
              this));

    HRESULT hr;

    hr = THR(m_bvr->enable());

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
MMBaseBvr::SeekSegmentTime(double dblSegmentTime)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::SeekSegmentTime(%g)",
              this,
              dblSegmentTime));

    HRESULT hr;
    
    hr = THR(m_bvr->seekSegmentTime(dblSegmentTime));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
MMBaseBvr::SeekActiveTime(double dblActiveTime)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::SeekActiveTime(%g)",
              this,
              dblActiveTime));

    HRESULT hr;
    
    hr = THR(m_bvr->seekActiveTime(dblActiveTime));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
MMBaseBvr::SeekTo(long lRepeatCount, double dblSegmentTime)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::SeekTo(%ld, %g)",
              this,
              lRepeatCount,
              dblSegmentTime));

    HRESULT hr;
    
    hr = THR(m_bvr->seekTo(lRepeatCount, dblSegmentTime));

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

double
MMBaseBvr::GetActiveTime() const
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::GetActiveTime()",
              this));

    double d = 0;
    
    if (m_bvr)
    {
        THR(m_bvr->get_currActiveTime(&d));
    }

    return d;
}

double
MMBaseBvr::GetProgress() const
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::GetProgress()",
              this));

    double d = 0;
    
    if (m_bvr)
    {
        THR(m_bvr->get_currProgress(&d));
    }

    return d;
}

double
MMBaseBvr::GetSegmentDur() const
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::GetSegmentDur()",
              this));

    double d = 0;
    
    if (m_bvr)
    {
        THR(m_bvr->get_currSegmentDur(&d));
    }

    return d;
}

double
MMBaseBvr::GetSegmentTime() const
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::GetSegmentTime()",
              this));

    double d = 0;
    
    if (m_bvr)
    {
        THR(m_bvr->get_currSegmentTime(&d));
    }

    return d;
}

double
MMBaseBvr::GetSimpleDur() const
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::GetSimpleDur()",
              this));

    double d = 0;
    
    if (m_bvr)
    {
        THR(m_bvr->get_currSimpleDur(&d));
    }

    return d;
}

double
MMBaseBvr::GetSimpleTime() const
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::GetSimpleTime()",
              this));

    double d = 0;
    
    if (m_bvr)
    {
        THR(m_bvr->get_currSimpleTime(&d));
    }

    return d;
}

LONG
MMBaseBvr::GetCurrentRepeatCount() const
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::GetCurrentRepeatCount()",
              this));

    LONG l = 1;
    
    if (m_bvr)
    {
        THR(m_bvr->get_currRepeatCount(&l));
    }

    return l;
}

double
MMBaseBvr::GetRepeatCount() const
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::GetRepeatCount()",
              this));

    double d = 1;
    
    if (m_bvr)
    {
        THR(m_bvr->get_repeatCount(&d));
    }

    return d;
}

double
MMBaseBvr::GetRepeatDur() const
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::GetRepeatDur()",
              this));

    double d = 0;
    
    if (m_bvr)
    {
        THR(m_bvr->get_repeatDur(&d));
    }

    return d;
}

float 
MMBaseBvr::GetSpeed() const
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::GetSpeed()",
              this));

    float fl = 1.0f;
    
    if (m_bvr)
    {
        THR(m_bvr->get_speed(&fl));
    }

    return fl;
}

float 
MMBaseBvr::GetCurrSpeed() const
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::GetSpeed()",
              this));

    float fl = 1.0f;
    
    if (m_bvr)
    {
        THR(m_bvr->get_currSpeed(&fl));
    }

    return fl;
}

double
MMBaseBvr::GetActiveBeginTime() const
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::GetActiveBeginTime()",
              this));

    double d = TIME_INFINITE;
    
    if (m_bvr)
    {
        THR(m_bvr->get_beginParentTime(&d));
    }

    return d;
}

double
MMBaseBvr::GetActiveEndTime() const
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::GetActiveEndTime()",
              this));

    double d = TIME_INFINITE;
    
    if (m_bvr)
    {
        THR(m_bvr->get_endParentTime(&d));
    }

    return d;
}

double
MMBaseBvr::GetActiveDur() const
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::GetActiveDur()",
              this));

    double d = TIME_INFINITE;
    
    if (m_bvr)
    {
        THR(m_bvr->get_activeDur(&d));

        if (d == TIME_INFINITE)
        {
            double dbTime = valueNotSet;
            HRESULT hr = THR(m_bvr->get_naturalDur(&dbTime));
            if (SUCCEEDED(hr) && dbTime != valueNotSet)
            {
                d = dbTime;
            }
        }
    }

    return d;
}


TE_STATE
MMBaseBvr::GetPlayState() const
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::GetPlayState()",
              this));

    TE_STATE s = TE_STATE_INACTIVE;
    
    if (m_bvr)
    {
        THR(m_bvr->get_stateFlags(&s));
    }

    return s;
}

HRESULT
MMBaseBvr::BeginAt(double dblParentTime, double dblOffset)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::BeginAt(%g, %g)",
              this,
              dblParentTime,
              dblOffset));

    HRESULT hr;

    if (m_bvr)
    {
        hr = THR(m_bvr->beginAt(dblParentTime + dblOffset));
        if (FAILED(hr))
        {
            goto done;
        }
    }
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
MMBaseBvr::EndAt(double dblParentTime, double dblOffset)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::EndAt(%g, %g)",
              this,
              dblParentTime,
              dblOffset));

    HRESULT hr;

    if (m_bvr)
    {
        hr = THR(m_bvr->endAt(dblParentTime + dblOffset));
        if (FAILED(hr))
        {
            goto done;
        }
    }
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

double
MMBaseBvr::GetCurrParentTime() const
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::GetCurrParentTime()",
              this));

    double d = TIME_INFINITE;
    
    if (m_bvr)
    {
        THR(m_bvr->get_currParentTime(&d));
    }

    return d;
}

void
MMBaseBvr::AddOneTimeValue(MMBaseBvr * pmmbvr,
                           TE_TIMEPOINT tetp,
                           double dblOffset,
                           bool bBegin)
{
    TraceTag((tagMMUTILBvr,
              "MMBaseBvr(%p)::AddOneTimeValue(%p, %d, %g, %d)",
              this,
              pmmbvr,
              tetp,
              dblOffset,
              bBegin));

    HRESULT hr;
    
    if (tetp == TE_TIMEPOINT_NONE)
    {
        if (bBegin)
        {
            IGNORE_HR(m_bvr->addBegin(dblOffset, NULL));
        }
        else
        {
            IGNORE_HR(m_bvr->addEnd(dblOffset, NULL));
        }
    }
    else
    {
        LONG lCookie;
        ITIMENode * ptn = pmmbvr->GetMMBvr();
        
        if (bBegin)
        {
            hr = THR(m_bvr->addBeginSyncArc(ptn,
                                            tetp,
                                            dblOffset,
                                            &lCookie));

            if (SUCCEEDED(hr))
            {
                // @@ ISSUE : This does not detect memory failures (bug 14217, ie6)
                m_cmBegin.insert(CookieMap::value_type(&pmmbvr->GetElement(), lCookie));
            }
        }
        else
        {
            hr = THR(m_bvr->addEndSyncArc(ptn,
                                          tetp,
                                          dblOffset,
                                          &lCookie));

            if (SUCCEEDED(hr))
            {
                // @@ ISSUE : This does not detect memory failures (bug 14217, ie6)
                m_cmEnd.insert(CookieMap::value_type(&pmmbvr->GetElement(), lCookie));
            }
        }
    }
    
  done:
    return;
}

void
MMBaseBvr::AddSyncArcs(bool bBegin)
{
    TraceTag((tagMMUTILBvr,
              "MMBaseBvr(%p)::AddSyncArcs(%d)",
              this,
              bBegin));

    
    CTIMEElementBase * ptebParent = GetElement().GetParent();
    TimelineType tt = ptebParent?ptebParent->GetTimeContainer():ttPar;
    
    TimeValueList & tvl = bBegin?GetElement().GetRealBeginValue():GetElement().GetRealEndValue();
    TimeValueSTLList & l = tvl.GetList();
    long lBeginAddCount = 0;
    TimeValueSTLList::iterator iter;
    bool bHaveEvent = false;
    bool bHaveIndefinite = false;
    
    ClearSyncArcs(bBegin);
    
    if (l.size() == 0)
    {
        if (bBegin)
        {
            switch(tt)
            {
              case ttPar:
              //case ttExcl:
                AddOneTimeValue(NULL,
                                TE_TIMEPOINT_NONE,
                                0.0,
                                true);
                break;
              case ttSeq:
                {
                    ptebParent->GetMMTimeline()->updateSyncArc(bBegin, this);
                }
                break;

              default:
                break;
            }
        }
        
        goto done;
    }
    
    for (iter = l.begin();
         iter != l.end();
         iter++)
    {
        TimeValue *p = (*iter);

        TE_TIMEPOINT tetp = TE_TIMEPOINT_NONE;
        double dblOffset = p->GetOffset();
        MMBaseBvr * pmmbvr = NULL;
        
        if (p->GetEvent() == NULL)
        {
            Assert(p->GetElement() == NULL);
            
            tetp = TE_TIMEPOINT_NONE;

            if (dblOffset == TIME_INFINITE)
            {
                bHaveIndefinite = true;
            }
        }
        else if (StrCmpIW(p->GetEvent(), WZ_TIMEBASE_BEGIN) == 0)
        {
            //if there is no element associated with this event then do not add it.
            if (p->GetElement() == NULL)
            {
                continue;
            }
            tetp = TE_TIMEPOINT_BEGIN;
        }
        else if (StrCmpIW(p->GetEvent(), WZ_TIMEBASE_END) == 0)
        {
            //if there is no element associated with this event then do not add it.
            if (p->GetElement() == NULL)
            {
                continue;
            }
            tetp = TE_TIMEPOINT_END;
        }
        else
        {
            // This was an event and not a sync arc - set flag and continue

            bHaveEvent = true;
            continue;
        }

        if (tt == ttSeq && bBegin)
        {
            continue;
        }
        else
        {
            if (p->GetElement() != NULL)
            {
                if (GetElement().GetBody() == NULL)
                {
                    continue;
                }
                
                // TODO: We should return all the ids which match the
                // sync arc since dynamically added elements add any duplicates
                CTIMEElementBase * pteb = GetElement().GetBody()->FindID(p->GetElement());
                
                if (pteb == NULL)
                {
                    // Simply ignore and move on
                    continue;
                }

                pmmbvr = &pteb->GetMMBvr();
            }
            else
            {
                pmmbvr = this;
            }
        
            Assert(pmmbvr != NULL);
        }

        AddOneTimeValue(pmmbvr,
                        tetp,
                        dblOffset,
                        bBegin);
    }    

    // If there are events and no indefinite was added then we need to
    // make sure we add an indefinite ourselves
    // We only need to do this for end since begin will be unaffected
    if (!bBegin && bHaveEvent && !bHaveIndefinite)
    {
        AddOneTimeValue(NULL,
                        TE_TIMEPOINT_NONE,
                        TIME_INFINITE,
                        bBegin);
    }

  done:
    return;
}

void
MMBaseBvr::ClearSyncArcs(bool bBegin)
{
    TraceTag((tagMMUTILBvr,
              "MMBaseBvr(%p)::ClearSyncArcs(%d)",
              this,
              bBegin));

    if (bBegin)
    {
        m_bvr->removeBegin(0);
        m_cmBegin.clear();
    }
    else
    {
        m_bvr->removeEnd(0);
        m_cmEnd.clear();
    }
}

HRESULT
MMBaseBvr::Update(bool bUpdateBegin,
                  bool bUpdateEnd)
{
    TraceTag((tagMMUTILBvr,
              "MMBaseBvr(%p)::Update(%d, %d)",
              this,
              bUpdateBegin,
              bUpdateEnd));

    HRESULT hr;
    double d;
    
    if (m_bEnabled == false)
    {
        ClearSyncArcs(true);
        ClearSyncArcs(false);
    
        
        TE_TIMEPOINT tetp = TE_TIMEPOINT_NONE;
        double dblOffset = INDEFINITE;
        MMBaseBvr * pmmbvr = this;

        AddOneTimeValue(pmmbvr,
                        tetp,
                        dblOffset,
                        true);

        IGNORE_HR(m_bvr->put_dur(0.0));
        IGNORE_HR(m_bvr->put_restart(TE_RESTART_NEVER));
        hr = S_OK;
        goto done;
    }

    if (bUpdateBegin)
    {
        AddSyncArcs(true);
    }
    
    if (bUpdateEnd)
    {
        AddSyncArcs(false);
    }
    
    if (m_elm.GetDurAttr().IsSet())
    {
        d = m_elm.GetDurAttr();
        if (d != 0.0 && d < 0.001)  //clamp the duration to prevent the browser from appearing to hang.
        {
            d = 0.001;
        }
    }
    else if (m_elm.GetRepeatDurAttr().IsSet() == false && 
             m_elm.GetRepeatAttr().IsSet() == false && 
             m_elm.GetEndAttr().IsSet() == true )         
    {   
        d = HUGE_VAL;
    }
    else
    {
        d = TE_UNDEFINED_VALUE;
    }
    IGNORE_HR(m_bvr->put_dur(d));
    
    if (m_elm.GetRepeatAttr().IsSet())
    {
        d = m_elm.GetRepeatAttr();
    }
    else
    {
        d = TE_UNDEFINED_VALUE;
    }
    IGNORE_HR(m_bvr->put_repeatCount(d));
    
    if (m_bZeroRepeatDur == true)
    {
        d = 0;
    }
    else if (m_elm.GetRepeatDurAttr().IsSet())
    {
        d = m_elm.GetRepeatDurAttr();
    }
    else
    {
        d = TE_UNDEFINED_VALUE;
    }
    IGNORE_HR(m_bvr->put_repeatDur(d));

    IGNORE_HR(m_bvr->put_accelerate(m_elm.GetAccel()));
    IGNORE_HR(m_bvr->put_decelerate(m_elm.GetDecel()));

    IGNORE_HR(m_bvr->put_autoReverse(m_elm.GetAutoReverse()));
    IGNORE_HR(m_bvr->put_speed(m_elm.GetSpeed()));

    DWORD flags;

    flags = 0;

    if (m_elm.IsLocked())
    {
        flags |= TE_FLAGS_LOCKED;
    }
    
    if (m_elm.IsSyncMaster())
    {
        flags |= TE_FLAGS_MASTER;
    }

    IGNORE_HR(m_bvr->put_flags(flags));
 
    bool bNeedFill;
    bNeedFill = (   (m_elm.GetFill() == HOLD_TOKEN) || (m_elm.GetFill() == FREEZE_TOKEN) 
                 || (m_elm.GetFill() == TRANSITION_TOKEN));
    IGNORE_HR(m_bvr->put_fill((bNeedFill)?TE_FILL_FREEZE:TE_FILL_REMOVE));

    {
        TE_RESTART_FLAGS ter;

        if (m_elm.GetRestart() == WHENNOTACTIVE_TOKEN)
        {
            ter = TE_RESTART_WHEN_NOT_ACTIVE;
        }
        else if (m_elm.GetRestart() == NEVER_TOKEN)
        {
            ter = TE_RESTART_NEVER;
        }
        else
        {
            ter = TE_RESTART_ALWAYS;
        }
        
        IGNORE_HR(m_bvr->put_restart(ter));
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

double
MMBaseBvr::DocumentTimeToParentTime(double documentTime)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::DocumentTimeToParentTime(%g)",
              this,
              documentTime));

    double d = TIME_INFINITE;
    
    if (m_bvr)
    {
        THR(m_bvr->documentTimeToParentTime(documentTime, &d));
    }

    return d;
}

double
MMBaseBvr::ParentTimeToDocumentTime(double parentTime)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::ParentTimeToDocumentTime(%g)",
              this,
              parentTime));

    double d = TIME_INFINITE;
    
    if (m_bvr)
    {
        THR(m_bvr->parentTimeToDocumentTime(parentTime, &d));
    }

    return d;
}

        
double
MMBaseBvr::ParentTimeToActiveTime(double parentTime)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::ParentTimeToActiveTime(%g)",
              this,
              parentTime));

    double d = TIME_INFINITE;
    
    if (m_bvr)
    {
        THR(m_bvr->parentTimeToActiveTime(parentTime, &d));
    }

    return d;
}

double
MMBaseBvr::ActiveTimeToParentTime(double activeTime)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::ActiveTimeToParentTime(%g)",
              this,
              activeTime));

    double d = TIME_INFINITE;
    
    if (m_bvr)
    {
        THR(m_bvr->activeTimeToParentTime(activeTime, &d));
    }

    return d;
}


double
MMBaseBvr::ActiveTimeToSegmentTime(double activeTime)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::ActiveTimeToSegmentTime(%g)",
              this,
              activeTime));

    double d = TIME_INFINITE;
    
    if (m_bvr)
    {
        THR(m_bvr->activeTimeToSegmentTime(activeTime, &d));
    }

    return d;
}

double
MMBaseBvr::SegmentTimeToActiveTime(double segmentTime)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::SegmentTimeToActiveTime(%g)",
              this,
              segmentTime));

    double d = TIME_INFINITE;
    
    if (m_bvr)
    {
        THR(m_bvr->segmentTimeToActiveTime(segmentTime, &d));
    }

    return d;
}


double
MMBaseBvr::SegmentTimeToSimpleTime(double segmentTime)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::SegmentTimeToSimpleTime(%g)",
              this,
              segmentTime));

    double d = TIME_INFINITE;
    
    if (m_bvr)
    {
        THR(m_bvr->segmentTimeToSimpleTime(segmentTime, &d));
    }

    return d;
}

double
MMBaseBvr::SimpleTimeToSegmentTime(double simpleTime)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::SimpleTimeToSegmentTime(%g)",
              this,
              simpleTime));

    double d = TIME_INFINITE;
    
    if (m_bvr)
    {
        THR(m_bvr->simpleTimeToSegmentTime(simpleTime, &d));
    }

    return d;
}

HRESULT
MMBaseBvr::PutNaturalDur(double dblNaturalDur)
{
    HRESULT hr;
    
    if (!m_bvr)
    {
        hr = E_FAIL;
        goto done;
    }

    if (0.0 == dblNaturalDur)
    {
        double dblRepeatCount = 0.0;
        double dblRepeatDur = 0.0;

        hr = THR(m_bvr->get_repeatCount(&dblRepeatCount));
        if (FAILED(hr))
        {
            goto done;
        }
        
        hr = THR(m_bvr->get_repeatDur(&dblRepeatDur));
        if (FAILED(hr))
        {
            goto done;
        }

        //
        // timing engine can not handle indefinite repeat with zero natural duration
        // nor can it handle any repeat duration with zero natural duration
        //
        if (TIME_INFINITE == dblRepeatCount || TE_UNDEFINED_VALUE != dblRepeatDur)
        {
            hr = S_OK;
            goto done;
        }
    }

    //if the current element is a sequence then do not allow the natural duration to be set 
    //unless the natural duration is being cleared.  
    //NOTENOTE:  this will have to be revisited if dur="media" is allowed as a value that 
    //           affects the duration of sequences.
    if (GetElement().IsSequence() && dblNaturalDur != TE_UNDEFINED_VALUE)
    {
        hr = S_OK;
        goto done;
    }

    hr = THR(m_bvr->put_naturalDur(dblNaturalDur));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

double
MMBaseBvr::GetNaturalDur()
{
    double dblRet = TIME_INFINITE;
    
    if (m_bvr)
    {
        IGNORE_HR(m_bvr->get_naturalDur(&dblRet));
    }
    
  done:
    return dblRet;
}

void
MMBaseBvr::SetEndSync(bool b)
{
    DWORD dwFlags = 0;
    
    IGNORE_HR(m_bvr->get_flags(&dwFlags));

    if (b)
    {
        dwFlags |= TE_FLAGS_ENDSYNC;
    }
    else
    {
        dwFlags &= ~TE_FLAGS_ENDSYNC;
    }

    IGNORE_HR(m_bvr->put_flags(dwFlags));
}

void
MMBaseBvr::SetSyncMaster(bool b)
{
    DWORD dwFlags = 0;
    
    IGNORE_HR(m_bvr->get_flags(&dwFlags));

    if (b)
    {
        dwFlags |= TE_FLAGS_MASTER;
    }
    else
    {
        dwFlags &= ~TE_FLAGS_MASTER;
    }

    IGNORE_HR(m_bvr->put_flags(dwFlags));
}

void
MMBaseBvr::ElementChangeNotify(CTIMEElementBase & teb,
                               ELM_CHANGE_TYPE ect)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::ElementChangeNotify(%p, %d)",
              this,
              &teb,
              ect));
    
    bool bNeedUpdate = false;
    
    switch(ect)
    {
      case ELM_ADDED:
        {
            CTIMEElementBase * ptebParent = GetElement().GetParent();
            TimelineType tt = ptebParent?ptebParent->GetTimeContainer():ttPar;

            if (tt != ttSeq)
            {
                if (CheckForSyncArc(true, teb))
                {
                    bNeedUpdate = true;
                }
            }

            if (CheckForSyncArc(false, teb))
            {
                bNeedUpdate = true;
            }
        }
        
        break;
      case ELM_DELETED:
        {
            if (DeleteFromCookieMap(true, teb))
            {
                bNeedUpdate = true;
            }
            
            if (DeleteFromCookieMap(false, teb))
            {
                bNeedUpdate = true;
            }
        }

        break;
    }

    if (bNeedUpdate)
    {
        IGNORE_HR(m_bvr->update(0));
    }
}

bool
MMBaseBvr::CheckForSyncArc(bool bBegin,
                           CTIMEElementBase & teb)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::CTIMEElementBase(%d, %p)",
              this,
              bBegin,
              &teb));

    LPCWSTR lpwStr = teb.GetID();
    bool bRet = false;
    
    // Now iterate through the list to see if we care about this string
    TimeValueList & tvl = bBegin?GetElement().GetRealBeginValue():GetElement().GetRealEndValue();
    TimeValueSTLList & l = tvl.GetList();
    TimeValueSTLList::iterator i;

    for (i = l.begin();
         i != l.end();
         i++)
    {
        TimeValue *p = (*i);

        if (p->GetElement() == NULL &&
            lpwStr == NULL)
        {
            // do nothing
        }
        else if (p->GetEvent() == NULL ||
                 p->GetElement() == NULL ||
                 lpwStr == NULL ||
                 StrCmpIW(p->GetElement(), lpwStr) != 0)
        {
            continue;
        }

        
        TE_TIMEPOINT tetp;

        if  (p->GetEvent() == NULL)
        {
            continue;
        }
        
        if (StrCmpIW(p->GetEvent(), WZ_TIMEBASE_BEGIN) == 0)
        {
            tetp = TE_TIMEPOINT_BEGIN;
        }
        else if (StrCmpIW(p->GetEvent(), WZ_TIMEBASE_END) == 0)
        {
            tetp = TE_TIMEPOINT_END;
        }
        else
        {
            // This was an event and not a sync arc - ignore it
            continue;
        }

        double dblOffset = p->GetOffset();
        MMBaseBvr & mmbvr = teb.GetMMBvr();

        AddOneTimeValue(&mmbvr,
                        tetp,
                        dblOffset,
                        bBegin);

        bRet = true;
    }    
    
  done:
    return bRet;
}

bool
MMBaseBvr::DeleteFromCookieMap(bool bBegin,
                               CTIMEElementBase & teb)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%p)::DeleteFromCookieMap(%d, %p)",
              this,
              bBegin,
              &teb));

    bool bRet = false;
    
    CookieMap & cm = bBegin?m_cmBegin:m_cmEnd;
    
    CookieMap::iterator i = cm.find(&teb);

    while (i != cm.end() && (*i).first == &teb)
    {
        bRet = true;
        
        if (bBegin)
        {
            IGNORE_HR(m_bvr->removeBegin((*i).second));
        }
        else
        {
            IGNORE_HR(m_bvr->removeEnd((*i).second));
        }

        cm.erase(i++);
    }

    return bRet;
}

//
//
//

MMBaseBvr::TEBvr::TEBvr()
: m_mmbvr(NULL),
  m_cRef(0)
{
}

MMBaseBvr::TEBvr::~TEBvr()
{
    Assert (m_cRef == 0);
    m_mmbvr = NULL;
}
        
STDMETHODIMP_(ULONG)
MMBaseBvr::TEBvr::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
MMBaseBvr::TEBvr::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
MMBaseBvr::TEBvr::QueryInterface(REFIID riid, void **ppv)
{
    CHECK_RETURN_SET_NULL(ppv);

    if (InlineIsEqualUnknown(riid))
    {
        *ppv = (void *)(IUnknown *)this;
    }
    else if (InlineIsEqualGUID(riid, IID_ITIMENodeBehavior))
    {
        *ppv = (void *)(ITIMENodeBehavior *)this;
    }
    else
    {
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

STDMETHODIMP
MMBaseBvr::TEBvr::eventNotify(double dblLocalTime,
                              TE_EVENT_TYPE et,
                              long lRepeatCount)
{
    TraceTag((tagMMUTILEvents,
              "MMBaseBvr(%p, %ls)::eventNotify(localTime = %g, event = %s)",
              this,
              m_mmbvr->GetElement().GetID(),
              dblLocalTime,
              EventString(et)));

    if (!m_mmbvr)
    {
        goto done;
    }

    Assert(m_mmbvr->m_bFireEvents);

    if (NULL != m_mmbvr->GetElement().GetParent())
    {
        MMTimeline * pMMParent = m_mmbvr->GetElement().GetParent()->GetMMTimeline();
        if (NULL != pMMParent)
        {
            bool bFireOut = pMMParent->childEventNotify(m_mmbvr, dblLocalTime, et);
            if (false == bFireOut)
            {
                goto done;
            }
        }
    }
    
    TIME_EVENT newet;
        
    switch(et)
    {
      case TE_EVENT_BEGIN:
        newet = TE_ONBEGIN;
        break;
      case TE_EVENT_END:
        newet = TE_ONEND;
        break;
      case TE_EVENT_REPEAT:
        newet = TE_ONREPEAT;
        break;
      case TE_EVENT_AUTOREVERSE:
        newet = TE_ONREVERSE;
        break;
      case TE_EVENT_PAUSE:
        newet = TE_ONPAUSE;
        break;
      case TE_EVENT_RESUME:
        newet = TE_ONRESUME;
        break;
      case TE_EVENT_RESET:
        newet = TE_ONRESET;
        break;
      case TE_EVENT_UPDATE:
        newet = TE_ONUPDATE;
        break;
      case TE_EVENT_SEEK:
        newet = TE_ONSEEK;
        break;
      default:
        goto done;
    }
        
    // The reason we check again is that our parent could have done
    // something which causes us to shut down.
    if (m_mmbvr)
    {
        THR(m_mmbvr->m_elm.FireEvent(newet, dblLocalTime, 0, lRepeatCount));
    }
    
  done:
    return S_OK;
}

STDMETHODIMP
MMBaseBvr::TEBvr::getSyncTime(double * dblNewTime,
                              LONG * lNewRepeatCount,
                              VARIANT_BOOL * vbCueing)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_NULL(dblNewTime);
    CHECK_RETURN_NULL(lNewRepeatCount);
    CHECK_RETURN_NULL(vbCueing);

    // Initialize to the same time
    
    *dblNewTime = TE_UNDEFINED_VALUE;
    *lNewRepeatCount = TE_UNDEFINED_VALUE;
    *vbCueing = VARIANT_FALSE;

    bool bCueing = false;
    
    if (!m_mmbvr)
    {
        hr = S_FALSE;
        goto done;
    }
    
    hr = THR(m_mmbvr->m_elm.GetSyncMaster(*dblNewTime,
                                          *lNewRepeatCount,
                                          bCueing));
    if (S_OK != hr)
    {
        if (E_NOTIMPL == hr)
        {
            hr = S_FALSE;
        }
        
        goto done;
    }
    
    *vbCueing = bCueing?VARIANT_TRUE:VARIANT_FALSE;
    
    hr = S_OK;
  done:
    RRETURN1(hr, S_FALSE);
}

STDMETHODIMP
MMBaseBvr::TEBvr::tick()
{
    if (!m_mmbvr)
    {
        goto done;
    }

    m_mmbvr->m_elm.OnTick();
  
  done:
    return S_OK;
}

void 
MMBaseBvr::SetEnabled(bool bEnabled)
{
    m_bEnabled = bEnabled;
}

STDMETHODIMP
MMBaseBvr::TEBvr::propNotify(DWORD tePropType)
{
    if (!m_mmbvr)
    {
        goto done;
    }

    if (NULL != m_mmbvr->GetElement().GetParent())
    {
        MMTimeline * pMMParent = m_mmbvr->GetElement().GetParent()->GetMMTimeline();
        if (NULL != pMMParent)
        {
            bool bFireOut = pMMParent->childPropNotify(m_mmbvr, &tePropType);
            if (false == bFireOut)
            {
                goto done;
            }
        }
    }

    // The reason we check again is that our parent could have done
    // something which causes us to shut down.
    if (m_mmbvr)
    {
        m_mmbvr->m_elm.OnTEPropChange(tePropType);
    }

  done:
    return S_OK;
}

/////////////////////////////////////////////////////////////////////
// MMBvr
/////////////////////////////////////////////////////////////////////

MMBvr::MMBvr(CTIMEElementBase & elm, bool bFireEvents, bool fNeedSyncCB)
: MMBaseBvr(elm,bFireEvents),
  m_fNeedSyncCB(fNeedSyncCB)
{
    TraceTag((tagMMUTILBvr,
              "MMBvr(%p)::MMBvr(%p,%d)",
              this,
              &elm,
              bFireEvents));
}

MMBvr::~MMBvr()
{
    TraceTag((tagMMUTILBvr,
              "MMBvr(%p)::~MMBvr()",
              this));
}

bool
MMBvr::Init()
{
    TraceTag((tagMMUTILBvr,
              "MMBvr(%p)::Init()",
              this));

    bool ok = false;
    HRESULT hr;
    DAComPtr<ITIMENode> tn;
    
    hr = THR(TECreateBehavior(m_elm.GetID(), &tn));
    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
        goto done;
    }
      
    if (!MMBaseBvr::Init(tn))
    {
        hr = TIMEGetLastError();
        goto done;
    }
    
    ok = true;
  done:
    return ok;
}

//
// MMPlayer
//

MMPlayer::MMPlayer(CTIMEBodyElement & elm)
: m_elm(elm),
  m_fReleased(false),
  m_timeline(NULL),
  m_clock(NULL)
{
    TraceTag((tagMMUTILPlayer,
              "MMPlayer(%p)::MMPlayer(%p)",
              this,
              &elm));
}

MMPlayer::~MMPlayer()
{
    TraceTag((tagMMUTILPlayer,
              "MMPlayer(%p)::~MMPlayer()",
              this));

    if (m_timeline)
    {
        m_timeline->put_Player(NULL);
    }

    Deinit();
    m_timeline = NULL;
    ReleaseInterface(m_clock);
}

bool
MMPlayer::Init(MMTimeline & tl)
{
    TraceTag((tagMMUTILPlayer,
              "MMPlayer(%p)::Init(%p)",
              this,
              &tl));

    bool ok = false;
    HRESULT hr;
    
    m_timeline = &tl;
    if (m_timeline != NULL) //lint !e774
    {
        m_timeline->put_Player(this);
    }

    hr = THR(TECreatePlayer(m_elm.GetID(),
                            m_timeline->GetMMTimeline(),
                            &m_elm,
                            &m_player));
    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
        goto done;
    }
    
    m_clock = new Clock;
    if (NULL == m_clock)
    {
        TIMESetLastError(E_OUTOFMEMORY, NULL);
        goto done;
    }

    m_clock->SetSink(this);
    
    hr = THR(m_clock->SetITimer(&m_elm, 20));
    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
        goto done;
    }
    
    ok = true;
  done:
    if (!ok)
    {
        m_player.Release();
    }
    
    return ok;
}

void
MMPlayer::Deinit()
{
    TraceTag((tagMMUTILPlayer,
              "MMPlayer(%p)::Deinit()",
              this));

    if (!m_fReleased)
    {
        m_fReleased = true;
    }

    if (m_clock)
    {
        m_clock->Stop();
        m_clock->SetSink(NULL);
    }
    ReleaseInterface(m_clock);

    m_player.Release();
}

bool
MMPlayer::Play()
{
    TraceTag((tagMMUTILPlayer,
              "MMPlayer(%p)::Play()",
              this));

    bool ok = false;
    
    HRESULT hr;

    if (!m_player)
    {
        TIMESetLastError(E_FAIL, NULL);
        goto done;
    }
    
    hr = THR(m_player->begin());

    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
        goto done;
    }

    if (NULL == m_clock)
    {
        TIMESetLastError(E_FAIL, NULL);
        goto done;
    }

    hr = THR(m_clock->Start());

    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
        goto done;
    }

    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
        goto done;
    }

    ok = true;
  done:
    if (!ok)
    {
        if (!m_player)
        {
            m_player->end();
        }
        if (m_clock)
        {
            m_clock->Stop();
        }
    }
    
    return ok;
}

bool
MMPlayer::Pause()
{
    TraceTag((tagMMUTILPlayer,
              "MMPlayer(%p)::Pause()",
              this));

    bool ok = false;
    
    HRESULT hr;

    if (!m_player)
    {
        TIMESetLastError(E_FAIL, NULL);
        goto done;
    }
    
    hr = THR(m_player->pause());

    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
        goto done;
    }

    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
        goto done;
    }

    ok = true;
  done:
    return ok;
}

bool
MMPlayer::Resume()
{
    TraceTag((tagMMUTILPlayer,
              "MMPlayer(%p)::Resume()",
              this));

    bool ok = false;
    
    HRESULT hr;

    if (!m_player)
    {
        TIMESetLastError(E_FAIL, NULL);
        goto done;
    }
    
    hr = THR(m_player->resume());

    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
        goto done;
    }

    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
        goto done;
    }

    ok = true;
  done:
    return ok;
}

bool
MMPlayer::Stop()
{
    TraceTag((tagMMUTILPlayer,
              "MMPlayer(%p)::Stop()",
              this));

    bool ok = false;

    if (m_player)
    {
        IGNORE_HR(m_player->end());
    }
    
    if (NULL != m_clock)
    {
        IGNORE_HR(m_clock->Stop());
    }

    ok = true;

    return ok;
}

bool
MMPlayer::Tick(double gTime)
{
    TraceTag((tagMMUTILPlayer,
              "MMPlayer(%p)::Tick(%g)",
              this,
              gTime));

    bool ok = false;
    
    HRESULT hr;

    if (!m_player)
    {
        TIMESetLastError(E_FAIL, NULL);
        goto done;
    }
    
    hr = THR(m_player->tick(gTime));

    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
        goto done;
    }

    ok = true;
  done:
    return ok;
}

bool 
MMPlayer::TickOnceWhenPaused()
{
    // DBL_EPSILON is defined in float.h such that
    // 1.0 + DBL_EPSILON != 1.0
    return Tick(GetCurrentTime() + DBL_EPSILON);
}


void
MMPlayer::OnTimer(double time)
{
    TraceTag((tagMMUTILPlayer,
              "MMPlayer(%p)::OnTimer(%g)",
              this,
              time));

    Tick(time);
    if (!m_fReleased)
    {
        m_elm.UpdateAnimations();
        m_elm.UpdateSyncNotify();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timebvr\timeaction.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: src\time\src\timeaction.h
//
//  Contents: Class that encapsulates timeAction functionality
//
//  Note: This is meant to be nested in CTIMEElementBase. It maintains a weak reference to 
//        it's container CTIMEElementBase.
//
//------------------------------------------------------------------------------------

#pragma once

#ifndef _TIMEACTION_H
#define _TIMEACTION_H

#include "tokens.h"

class CTIMEElementBase;

//+-------------------------------------------------------------------------------------
//
// CTIMEAction
//
//--------------------------------------------------------------------------------------

class CTimeAction
{

public:

    //+--------------------------------------------------------------------------------
    //
    // Public Methods
    //
    //---------------------------------------------------------------------------------

    CTimeAction(CTIMEElementBase * pTEB);
    virtual ~CTimeAction();

    bool Init();
    bool Detach();

    // Accessors
    HRESULT SetTimeAction(LPWSTR pstrAction);
    TOKEN GetTimeAction();

    IHTMLElement * GetElement();

    // Initialization/Deinitialization
    bool AddTimeAction();
    bool RemoveTimeAction();

    // notification that the element has loaded
    void OnLoad();

    // Apply the time action
    bool ToggleTimeAction(bool on);

    bool UpdateDefaultTimeAction();

    bool IsTimeActionOn() { return m_bTimeActionOn; }

    LPWSTR GetTimeActionString();

    //+--------------------------------------------------------------------------------
    //
    // Public Data
    //
    //---------------------------------------------------------------------------------

protected:

    //+--------------------------------------------------------------------------------
    //
    // Protected Methods
    //
    //---------------------------------------------------------------------------------

    // These are not meant to be used
    CTimeAction();
    CTimeAction(const CTimeAction&);

    //+--------------------------------------------------------------------------------
    //
    // Protected Data
    //
    //---------------------------------------------------------------------------------

private:

    //+--------------------------------------------------------------------------------
    //
    // Private methods
    //
    //---------------------------------------------------------------------------------

    // Is this a "class: ..." timeAction
    bool IsClass(LPOLESTR pstrAction, size_t * pOffset);
    // Remove time action classes from original classes string
    HRESULT RemoveClasses(/*in*/  LPWSTR    pstrOriginalClasses, 
                          /*in*/  LPWSTR    pstrTimeActionClasses, 
                          /*out*/ LPWSTR *  ppstrUniqueClasses);

    TOKEN GetDefaultTimeAction();

    bool AddIntrinsicTimeAction();
    bool RemoveIntrinsicTimeAction();
    bool ToggleIntrinsicTimeAction(bool on);

    bool ToggleBold(bool on);
    bool ToggleAnchor(bool on);
    bool ToggleItalic(bool on);

    bool ToggleStyleSelector(bool   on, 
                             BSTR   bstrPropertyName, 
                             LPWSTR pstrActive, 
                             LPWSTR pstrInactive);

    bool EnableStyleInheritance(BSTR bstrPropertyName);
    void DisableStyleInheritance(BSTR bstrPropertyName);
    
    bool SetStyleProperty(BSTR      bstrPropertyName, 
                          VARIANT & varPropertyValue);

    bool CacheOriginalExpression(BSTR bstrPropertyName);
    bool RestoreOriginalExpression(LPWSTR pstrPropertyName);

    bool IsInSequence();
    bool IsContainerTag(); 
    bool IsSpecialTag();
    bool IsGroup();
    bool IsMedia();
    bool IsPageUnloading();
    bool IsDetaching();
    bool IsLoaded();

    void ParseTagName();


    //+--------------------------------------------------------------------------------
    //
    // Private Data
    //
    //---------------------------------------------------------------------------------

    // Enum for tag type
    enum TagType 
    {
        TAGTYPE_UNINITIALIZED,
        TAGTYPE_B, 
        TAGTYPE_A, 
        TAGTYPE_I, 
        TAGTYPE_EM, 
        TAGTYPE_AREA, 
        TAGTYPE_STRONG,
        TAGTYPE_OTHER 
    };

    // timeAction attribute string
    LPWSTR              m_pstrTimeAction;
    // index of start of classNames substring in m_pstrTimeAction 
    int                 m_iClassNames;
    // Tokenized timeAction
    TOKEN               m_timeAction;
    // Cached original value of affected property
    LPWSTR              m_pstrOrigAction;
    // Original Classes minus timeAction classes
    LPWSTR              m_pstrUniqueClasses;
    // Pointer to container (weak ref)  
    CTIMEElementBase *  m_pTEB;
    // enum that stores the HTML tagName
    TagType             m_tagType;
    // Cache original expression set on a property
    LPWSTR              m_pstrOrigExpr;
    // Cache the current expression set on a property (set by us)
    LPWSTR              m_pstrTimeExpr;
    // the cached intrinsic timeAction property
    LPWSTR              m_pstrIntrinsicTimeAction;
    bool                m_fContainerTag;
    bool                m_fUseDefault;
    bool                m_bTimeActionOn;
}; // CTimeAction


//+---------------------------------------------------------------------------------
//  CTIMEAction inline methods
//
//  (Note: as a general guideline, single line functions belong in the class declaration)
//
//----------------------------------------------------------------------------------

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timebvr\timeelm.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: timeelm.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "timeelm.h"

DeclareTag(tagTimeElm, "TIME: Behavior", "CTIMEElement methods");

// static class data.
DWORD CTIMEElement::ms_dwNumTimeElems = 0;

CTIMEElement::CTIMEElement()
{
    m_clsid = __uuidof(CTIMEElement);
    TraceTag((tagTimeElm,
              "CTIMEElement(%lx)::CTIMEElement()",
              this));
    CTIMEElement::ms_dwNumTimeElems++;
}

CTIMEElement::~CTIMEElement()
{
    CTIMEElement::ms_dwNumTimeElems--;
}


HRESULT
CTIMEElement::Error()
{
    LPWSTR str = TIMEGetLastErrorString();
    HRESULT hr = TIMEGetLastError();
    
    if (str)
    {
        hr = CComCoClass<CTIMEElement, &__uuidof(CTIMEElement)>::Error(str, IID_ITIMEElement, hr);
        delete [] str;
    }

    return hr;
}

//*****************************************************************************

HRESULT 
CTIMEElement::GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP)
{
    return FindConnectionPoint(riid, ppICP);
} // GetConnectionPoint


STDMETHODIMP
CTIMEElement::Load(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog)
{
    return THR(CTIMEElementBase::Load(pPropBag, pErrorLog)); 
}

STDMETHODIMP
CTIMEElement::Save(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    return THR(CTIMEElementBase::Save(pPropBag, fClearDirty, fSaveAllProperties));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timebvr\timeaction.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: src\time\src\timeaction.cpp
//
//  Contents: Class that encapsulates timeAction functionality
//
//------------------------------------------------------------------------------------


#include "headers.h"
#include "timeaction.h"
#include "timeelmbase.h"


DeclareTag(tagTimeAction, "TIME: Behavior", "CTimeAction methods");


static const LPWSTR WZ_BLANK    = L"";
static const LPWSTR WZ_SPACE    = L" ";
static const LPWSTR WZ_B        = L"B";
static const LPWSTR WZ_I        = L"I";
static const LPWSTR WZ_A        = L"A";
static const LPWSTR WZ_EM       = L"EM";
static const LPWSTR WZ_AREA     = L"AREA";
static const LPWSTR WZ_STRONG   = L"STRONG";
static const LPWSTR WZ_HTML     = L"HTML";
static const LPWSTR WZ_NORMAL   = L"normal";
static const LPWSTR WZ_ITALIC   = L"italic";
static const LPWSTR WZ_BOLD     = L"bold";
static const LPWSTR WZ_HREF     = L"href";
static const LPWSTR WZ_JSCRIPT  = L"JScript";

static const LPWSTR WZ_PARENT_CURRSTYLE     = L"parentElement.currentStyle.";
static const LPWSTR WZ_FONTWEIGHT           = L"fontWeight";
static const LPWSTR WZ_FONTSTYLE            = L"fontStyle";

//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::CTimeAction
//
//  Synopsis:   Constructor
//
//  Arguments:  [pTEB]          pointer to container
//
//------------------------------------------------------------------------------------
CTimeAction::CTimeAction(CTIMEElementBase * pTEB) :
    m_pTEB(pTEB),
    m_timeAction(NULL),
    m_pstrTimeAction(NULL),
    m_iClassNames(0),
    m_pstrOrigAction(NULL),
    m_pstrUniqueClasses(NULL),
    m_tagType(TAGTYPE_UNINITIALIZED),
    m_pstrOrigExpr(NULL),
    m_pstrTimeExpr(NULL),
    m_pstrIntrinsicTimeAction(NULL),
    m_fContainerTag(false),
    m_fUseDefault(true),
    m_bTimeActionOn(false)
{

} // CTimeAction


//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::~CTimeAction
//
//  Synopsis:   Destructor
//
//  Arguments:  none
//
//------------------------------------------------------------------------------------
CTimeAction::~CTimeAction()
{
    delete [] m_pstrTimeAction;
    m_pstrTimeAction = 0;

    delete [] m_pstrOrigAction;
    m_pstrOrigAction = 0;

    delete [] m_pstrUniqueClasses;
    m_pstrUniqueClasses = 0;

    delete [] m_pstrOrigExpr;
    m_pstrOrigExpr = 0;

    delete [] m_pstrTimeExpr;
    m_pstrTimeExpr = 0;

    delete [] m_pstrIntrinsicTimeAction;
    m_pstrIntrinsicTimeAction = 0;

    m_timeAction = 0;

    // weak ref
    m_pTEB = NULL; 
} // ~CTimeAction


bool
CTimeAction::Init()
{
    if (!AddIntrinsicTimeAction())
    {
        Assert("Could not add intrinsic timeAction" && false);
    }

    return UpdateDefaultTimeAction();

} // Init


bool
CTimeAction::Detach()
{
    bool ok;

    ok = RemoveIntrinsicTimeAction();
    Assert(ok);

    ok = RemoveTimeAction();
done:
    return ok;
} // Detach



//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::GetElement
//
//  Synopsis:   Accessor for HTML element
//
//  Arguments:  none
//
//  Returns:    pointer to containing HTML element
//
//------------------------------------------------------------------------------------
IHTMLElement * 
CTimeAction::GetElement()
{
    Assert(NULL != m_pTEB);
    return m_pTEB->GetElement(); 
}


//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::GetTimeAction
//
//  Synopsis:   Accessor for m_timeAction
//
//  Arguments:  none
//
//  Returns:    current timeAction
//
//------------------------------------------------------------------------------------
TOKEN 
CTimeAction::GetTimeAction()
{ 
    return m_timeAction; 
} // GetTimeAction


//+-----------------------------------------------------------------------------------
//
//  Member:     OnLoad
//
//  Synopsis:   notification that element has loaded. This is required because
//              this is the earliest we can know that Element Behaviors have finished initalizing.
//
//  Arguments:  none
//
//  Returns:    void
//
//------------------------------------------------------------------------------------
void 
CTimeAction::OnLoad()
{ 
    // Init the timeAction
    if (NULL == m_pstrOrigAction)
    {
        AddTimeAction();
    }
} // OnLoad


//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::IsClass
//
//  Synopsis:   Checks if the given string begins with CLASS_TOKEN followed by SEPARATOR_TOKEN
//              (ignoring leading and trailing whitespace around CLASS_TOKEN). Comparisons are
//              case in-sensitive, 
//
//  Arguments:  [pstrAction]    String to be tested
//              [pOffset]       If this is NULL, it is ignored. If it is non-NULL, then if return 
//                              value is [true], this points to the index of the first char 
//                              after SEPARATOR_TOKEN
//
//  Returns:    [true]      if there is a positive match (see synopsis)
//              [false]     otherwise    
//
//------------------------------------------------------------------------------------
bool 
CTimeAction::IsClass(LPOLESTR pstrAction, size_t * pOffset)
{
    bool ok = false;
    size_t index, length;

    // check args
    if (NULL == pstrAction)
    {
        goto done;
    }

    if (NULL != pOffset)
    {
        // intialize to some value
        *pOffset = 0;
    }

    // done if string length is less than minimum length 
    length = wcslen(pstrAction);
    if (length < static_cast<size_t>(nCLASS_TOKEN_LENGTH + nSEPARATOR_TOKEN_LENGTH))
    {
        goto done;
    }

    // find first non-whitespace character
    index = StrSpnW(pstrAction, WZ_SPACE);

    // done if remaining string isn't long enough
    if (length < index + nCLASS_TOKEN_LENGTH + nSEPARATOR_TOKEN_LENGTH)
    {
        goto done;
    }

    // check that the following chars match CLASS_TOKEN 
    if (StrCmpNIW(static_cast<WCHAR*>(CLASS_TOKEN), &(pstrAction[index]), nCLASS_TOKEN_LENGTH) == 0)
    {
        // advance to next char after CLASS_TOKEN
        index += nCLASS_TOKEN_LENGTH;
    }
    else
    {
        goto done;
    }

    // find the first non-whitespace char after CLASS_TOKEN
    index += StrSpnW(&(pstrAction[index]), WZ_SPACE);

    // done if remaining string isn't long enough
    if (length < index + nSEPARATOR_TOKEN_LENGTH)
    {
        goto done;
    }

    // check that the following chars match SEPARATOR_TOKEN 
    if (StrCmpNIW(static_cast<WCHAR*>(SEPARATOR_TOKEN), &(pstrAction[index]), nSEPARATOR_TOKEN_LENGTH) == 0)
    {
        // advance to next char after SEPARATOR_TOKEN
        index += nSEPARATOR_TOKEN_LENGTH;
    }
    else
    {
        goto done;
    }

    if (NULL != pOffset)
    {
        // return the first char after ":"
        *pOffset = index;
    }

    ok = true;
done:
    return ok;
} // IsClass

    

//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::SetTimeAction
//
//  Synopsis:   sets the time action (also removes and adds the timeAction)
//
//  Arguments:  [pstrAction]    time action to be set
//
//  Returns:    [S_OK]      if successful
//              Failure     otherwise    
//
//------------------------------------------------------------------------------------
HRESULT
CTimeAction::SetTimeAction(LPWSTR pstrAction)
{
    TraceTag((tagTimeAction,
              "CTIMEAction(%lx)::SetTimeAction(%ls) id=%ls",
              this,
              pstrAction,
              m_pTEB->GetID()?m_pTEB->GetID():L"unknown"));

    HRESULT hr = S_OK;
    TOKEN tok_action;
    size_t offset = 0;

    Assert(pstrAction);

    //
    // check for timeaction="class: ..."
    //

    // verify that this is a valid "class:" timeAction (colon is REQUIRED) and 
    // get the offset of the the class names substring
    if (IsClass(pstrAction, &offset))
    {
        tok_action = CLASS_TOKEN;

        // store the timeaction string
        if (m_pstrTimeAction)
        {
            delete [] m_pstrTimeAction;
        }
        m_pstrTimeAction = CopyString(pstrAction);
        if (m_pstrTimeAction == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        // store the offset of the className substring
        m_iClassNames = offset;
    }
    else
    {
        tok_action = StringToToken(pstrAction);

        //
        // Validate the token 
        //

        if (DISPLAY_TOKEN == tok_action     ||
            VISIBILITY_TOKEN == tok_action  ||
            STYLE_TOKEN == tok_action       ||
            (NONE_TOKEN == tok_action && IsGroup()))
        {
            // valid
            m_fUseDefault = false;
        }
        else
        {
            // invalid, use default
            tok_action = GetDefaultTimeAction();
            m_fUseDefault = true;
        }
    }
    
    //
    // Update the timeAction 
    //

    if (m_timeAction != tok_action || CLASS_TOKEN == tok_action)
    {
        RemoveTimeAction();
        m_timeAction = tok_action;
        AddTimeAction();
    }
    
    hr = S_OK;
done:
    return hr;
} // SetTimeAction


//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::GetDefaultTimeAction
//
//  Synopsis:   Returns the default timeAction
//
//  Arguments:  none
//
//  Returns:    timeAction
//
//------------------------------------------------------------------------------------
TOKEN
CTimeAction::GetDefaultTimeAction()
{
    TOKEN tokTimeAction;

    if (IsContainerTag() || IsSpecialTag())
    {
        tokTimeAction = NONE_TOKEN;
    }
    else
    {
        if(IsInSequence())
        {
            tokTimeAction = DISPLAY_TOKEN;
        }
        else
        {
            if (IsMedia())
            {
                tokTimeAction = NONE_TOKEN;
            }
            else
            {
                tokTimeAction = VISIBILITY_TOKEN;
            }
        }
    }

    return tokTimeAction;
} // GetDefaultTimeAction


//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::RemoveClasses
//
//  Synopsis:   Returns a string that contains classes that are in the className string
//              but not in the timeAction string.
//
//  Arguments:  [pstrOriginalClasses]   className attribute set on the HTML element (1)
//              [pstrTimeActionClasses] classes in the timeAction string (2)
//              [ppstrUniqueClasses]    string containing classes in (1) but not in (2)
//
//  Returns:    [S_OK]      if successful
//              Failure     otherwise    
//
//  Note:       1. returns space separated string
//              2. Memory mgmt: If method returns success, caller needs to free memory in ppstrUniqueClasses
//
//------------------------------------------------------------------------------------
HRESULT 
CTimeAction::RemoveClasses(/*in*/  LPWSTR    pstrOriginalClasses, 
                           /*in*/  LPWSTR    pstrTimeActionClasses, 
                           /*out*/ LPWSTR *  ppstrUniqueClasses)
{
    HRESULT hr = E_FAIL;
    CPtrAry<STRING_TOKEN*> aryTokens1;
    CPtrAry<STRING_TOKEN*> aryTokens2;
    CPtrAry<STRING_TOKEN*> ary1Minus2;

    CHECK_RETURN_SET_NULL(ppstrUniqueClasses);

    // if pstrOriginalClasses is NULL or an Empty string, difference = NULL
    if (NULL == pstrOriginalClasses || NULL == pstrOriginalClasses[0])
    {
        *ppstrUniqueClasses = NULL;
        hr = S_OK;
        goto done;
    }

    // if pstrTimeActionClasses is NULL or an Empty string, difference = pstrOriginalClasses
    if (NULL == pstrTimeActionClasses || NULL == pstrTimeActionClasses[0])
    {
        *ppstrUniqueClasses = CopyString(pstrOriginalClasses);
        if (NULL == *ppstrUniqueClasses)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = S_OK;
        }
        goto done;
    }

    //
    // Parse Class Names into tokens
    //

    // parse pstrOriginalClasses into tokens
    hr = THR(::StringToTokens(pstrOriginalClasses, WZ_SPACE, &aryTokens1));
    if (FAILED(hr))
    {
        goto done;
    }

    // parse pstrTimeActionClasses into tokens
    hr = THR(::StringToTokens(pstrTimeActionClasses, WZ_SPACE, &aryTokens2));
    if (FAILED(hr))
    {
        goto done;
    }

    //
    // do set difference (aryTokens1 - aryTokens2)
    //

    hr = THR(::TokenSetDifference(&aryTokens1, pstrOriginalClasses, &aryTokens2, pstrTimeActionClasses, &ary1Minus2));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(::TokensToString(&ary1Minus2, pstrOriginalClasses, ppstrUniqueClasses));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
done:
    IGNORE_HR(::FreeStringTokenArray(&aryTokens1));
    IGNORE_HR(::FreeStringTokenArray(&aryTokens2));
    IGNORE_HR(::FreeStringTokenArray(&ary1Minus2));
    return hr;
} // RemoveClasses


//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::AddTimeAction
//
//  Synopsis:   Caches the original state of the target element
//
//  Arguments:  None
//
//  Returns:    [true]      if successful
//              [false]     otherwise    
//
//------------------------------------------------------------------------------------
bool
CTimeAction::AddTimeAction()
{
    TraceTag((tagTimeAction,
              "CTIMEAction(%lx)::AddTimeAction() id=%ls",
              this,
              m_pTEB->GetID()?m_pTEB->GetID():L"unknown"));
    
    bool ok = false;
    BSTR bstr = NULL;
    HRESULT hr;
    CComPtr<IHTMLStyle> s;

    if (IsDetaching() || IsPageUnloading())
    {
        ok = true;
        goto done;
    }

    if (m_timeAction == NONE_TOKEN || m_timeAction == NULL)
    {
        ok = true;
        goto done;
    }
    else if (m_timeAction == STYLE_TOKEN)
    {
        
        if ((!GetElement()) || FAILED(THR(GetElement()->get_style(&s))))
        {
            goto done;
        }

        hr = THR(s->get_cssText(&bstr));
        if (FAILED(hr))
        {
            goto done;
        }
            
        if (m_pstrOrigAction)
        {
            delete [] m_pstrOrigAction;
        }

        if (NULL == bstr)
        {
            m_pstrOrigAction = NULL;
            goto done;
        }
        m_pstrOrigAction = CopyString(bstr);

        if (NULL == m_pstrOrigAction)
        {
            TIMESetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }
    }
    else if (m_timeAction == DISPLAY_TOKEN)
    {
        hr = THR(m_pTEB->GetRuntimeStyle(&s));
        if (FAILED(hr))
        {
            goto done;
        }

        if (FAILED(THR(s->get_display(&bstr))))
        {
            goto done;
        }
        
        if (m_pstrOrigAction)
        {
            delete [] m_pstrOrigAction;
        }
        m_pstrOrigAction = CopyString(bstr);
        if (NULL == m_pstrOrigAction)
        {
            TIMESetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }
    }
    else if (m_timeAction == CLASS_TOKEN)
    {
        if (!GetElement())
        {
            goto done;
        }

        hr = THR(GetElement()->get_className(&bstr));
        if (FAILED(hr))
        {
            goto done;
        }

        if (m_pstrOrigAction)
        {
            delete [] m_pstrOrigAction;
        }
        m_pstrOrigAction = CopyString(bstr);
        if (NULL == m_pstrOrigAction)
        {
            TIMESetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }

        // Compute (Original Classes) - (TimeAction Classes)
        if (m_pstrUniqueClasses)
        {
            delete [] m_pstrUniqueClasses;
            m_pstrUniqueClasses = NULL;
        }
        hr = RemoveClasses(m_pstrOrigAction, 
                           &(m_pstrTimeAction[m_iClassNames]), 
                           &m_pstrUniqueClasses);
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else
    {
        hr = THR(m_pTEB->GetRuntimeStyle(&s));
        if (FAILED(hr))
        {
            goto done;
        }

        if (FAILED(THR(s->get_visibility(&bstr))))
        {
            goto done;
        }
       
        if (m_pstrOrigAction)
        {
            delete [] m_pstrOrigAction;
        }
        m_pstrOrigAction = CopyString(bstr);
        if (NULL == m_pstrOrigAction)
        {
            TIMESetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }
    }

    ok = true;
done:
    SysFreeString(bstr);
    return ok;
} // AddTimeAction


//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::AddIntrinsicTimeAction
//
//  Synopsis:   Cache the original value of the affected attribute
//
//  Arguments:  None
//
//  Returns:    [true]      if successful
//              [false]     otherwise    
//
//------------------------------------------------------------------------------------
bool
CTimeAction::AddIntrinsicTimeAction()
{   
    bool ok = false;
    HRESULT hr = S_OK;
    CComPtr<IHTMLStyle> s;
    CComBSTR sbstrOriginal;
    
    if (IsDetaching() || IsPageUnloading())
    {
        ok = true;
        goto done;
    }

    // check if we have anything to do
    if (!IsSpecialTag())
    {
        ok = true;
        goto done;
    }

    //
    // Get the attribute value
    //

    switch (m_tagType)
    {
        case TAGTYPE_B:
        case TAGTYPE_STRONG:
        {
            hr = THR(m_pTEB->GetRuntimeStyle(&s));
            if (FAILED(hr))
            {
                goto done;
            }

            hr = THR(s->get_fontWeight(&sbstrOriginal));
            if (FAILED(hr))
            {
                goto done;
            }

            break;
        }
    
        case TAGTYPE_I:
        case TAGTYPE_EM:
        {
            hr = THR(m_pTEB->GetRuntimeStyle(&s));
            if (FAILED(hr))
            {
                goto done;
            }

            hr = THR(s->get_fontStyle(&sbstrOriginal));
            if (FAILED(hr))
            {
                goto done;
            }
            
            break;
        }

        case TAGTYPE_A:
        {
            if (!GetElement())
            {
                goto done;
            }

            CComPtr<IHTMLAnchorElement> spAnchorElem;
            hr = THR(GetElement()->QueryInterface(IID_TO_PPV(IHTMLAnchorElement, &spAnchorElem)));
            if (FAILED(hr))
            {
                // This has to succeed
                Assert(false);
                goto done;
            }

            hr = THR(spAnchorElem->get_href(&sbstrOriginal));
            if (FAILED(hr))
            {
                goto done;
            }

            break;
        }

        case TAGTYPE_AREA:
        {
            if (!GetElement())
            {
                goto done;
            }

            CComPtr<IHTMLAreaElement> spAreaElem;
            hr = THR(GetElement()->QueryInterface(IID_TO_PPV(IHTMLAreaElement, &spAreaElem)));
            if (FAILED(hr))
            {
                // This has to succeed
                Assert(false);
                goto done;
            }

            hr = THR(spAreaElem->get_href(&sbstrOriginal));
            if (FAILED(hr))
            {
                goto done;
            }

            break;
        }

        default:
        {
            // this should never be reached.
            Assert(false);
            goto done;
        }

    } // switch (m_tagType)

    //
    // Save the attribute value
    //

    if (m_pstrIntrinsicTimeAction)
    {
        delete [] m_pstrIntrinsicTimeAction;
    }
    m_pstrIntrinsicTimeAction = CopyString(sbstrOriginal);
    if (NULL == m_pstrIntrinsicTimeAction)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    ok = true;
done:
    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
    }
    return ok;
} // AddIntrinsicTimeAction


//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::RemoveTimeAction
//
//  Synopsis:   Restores target element to its original state
//
//  Arguments:  None
//
//  Returns:    [true]      if successful
//              [false]     otherwise    
//
//------------------------------------------------------------------------------------
bool
CTimeAction::RemoveTimeAction()
{
    TraceTag((tagTimeAction,
              "CTIMEAction(%lx)::RemoveTimeAction() id=%ls",
              this,
              m_pTEB->GetID()?m_pTEB->GetID():L"unknown"));
    
    bool ok = false;
    HRESULT hr = S_OK;
    BSTR bstr = NULL;
    CComPtr<IHTMLStyle> s;

    if (IsPageUnloading())
    {
        ok = true;
        goto done;
    }

    if (NULL == m_pstrOrigAction)
    {
        // Nothin to remove
        ok = true;
        goto done;
    }
    
    if (m_timeAction == NONE_TOKEN || m_timeAction == NULL)
    {
        ok = true;
        goto done;
    }
    else if (m_timeAction == STYLE_TOKEN)
    {
        if ((!GetElement()) || FAILED(THR(GetElement()->get_style(&s))))
        {
            goto done;
        }
        
        bstr = SysAllocString(m_pstrOrigAction);
        
        if (bstr == NULL)
        {
            TIMESetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }
    
        THR(s->put_cssText(bstr));
    }
    else if (m_timeAction == DISPLAY_TOKEN)
    {
        // get runtime OR static style
        Assert(NULL != m_pTEB);
        hr = m_pTEB->GetRuntimeStyle(&s);
        if (FAILED(hr))
        {
            goto done;
        }
        
        bstr = SysAllocString(m_pstrOrigAction);
    
        if (bstr == NULL)
        {
            TIMESetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }
    
        THR(s->put_display(bstr));
    }
    else if (m_timeAction == CLASS_TOKEN)
    {
        if (!GetElement())
        {
            goto done;
        }

        bstr = SysAllocString(m_pstrOrigAction);
    
        if (bstr == NULL)
        {
            TIMESetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }

        hr = THR(GetElement()->put_className(bstr));

        if (FAILED(hr))
        {
            goto done;
        }
    }
    else
    {
        // get runtime OR static style
        Assert(NULL != m_pTEB);
        hr = m_pTEB->GetRuntimeStyle(&s);
        if (FAILED(hr))
        {
            goto done;
        }
        
        bstr = SysAllocString(m_pstrOrigAction);
        if (bstr == NULL)
        {
            TIMESetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }
    
        THR(s->put_visibility(bstr));
    }

    ok = true;
done:
    SysFreeString(bstr);
    if (m_pstrOrigAction)
    {
        delete [] m_pstrOrigAction;
        m_pstrOrigAction = 0;
    }
    return ok;
} // RemoveTimeAction


//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::RemoveIntrinsicTimeAction
//
//  Synopsis:   Restore the affected attribute to its original value 
//
//  Arguments:  None
//
//  Returns:    [true]      if successful
//              [false]     otherwise    
//
//------------------------------------------------------------------------------------
bool
CTimeAction::RemoveIntrinsicTimeAction()
{   
    bool ok = false;
    HRESULT hr = S_OK;
    CComBSTR sbstrOriginal;
    
    if (IsPageUnloading())
    {
        ok = true;
        goto done;
    }

    // check if we have anything to do
    if (!IsSpecialTag())
    {
        ok = true;
        goto done;
    }

    if (m_pstrIntrinsicTimeAction)
    {
        // Allocate BSTR value
        sbstrOriginal = SysAllocString(m_pstrIntrinsicTimeAction);
        if (sbstrOriginal == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }

    //
    // Restore attribute to original value
    //

    switch (m_tagType)
    {
        case TAGTYPE_B:
        case TAGTYPE_STRONG:
        {
            if (m_pstrIntrinsicTimeAction)
            {
                CComPtr<IHTMLStyle> s;
                hr = THR(m_pTEB->GetRuntimeStyle(&s));
                if (FAILED(hr))
                {
                    goto done;
                }

                hr = THR(s->put_fontWeight(sbstrOriginal));
                if (FAILED(hr))
                {
                    goto done;
                }
            }

            // restore the original expression set on the property
            if (!RestoreOriginalExpression(WZ_FONTWEIGHT))
            {
                hr = TIMEGetLastError();
                goto done;
            }

            break;
        }
    
        case TAGTYPE_I:
        case TAGTYPE_EM:
        {
            if (m_pstrIntrinsicTimeAction)
            {
                CComPtr<IHTMLStyle> s;
                hr = THR(m_pTEB->GetRuntimeStyle(&s));
                if (FAILED(hr))
                {
                    goto done;
                }

                hr = THR(s->put_fontStyle(sbstrOriginal));
                if (FAILED(hr))
                {
                    goto done;
                }
            }

            // restore the original expression set on the property
            if (!RestoreOriginalExpression(WZ_FONTSTYLE))
            {
                hr = TIMEGetLastError();
                goto done;
            }

            break;
        }

        case TAGTYPE_A:
        {
            if (m_pstrIntrinsicTimeAction)
            {
                if (!GetElement())
                {
                    goto done;
                }

                CComPtr<IHTMLAnchorElement> spAnchorElem;
                hr = THR(GetElement()->QueryInterface(IID_TO_PPV(IHTMLAnchorElement, &spAnchorElem)));
                if (FAILED(hr))
                {
                    // This has to succeed
                    Assert(false);
                    goto done;
                }

                hr = THR(spAnchorElem->put_href(sbstrOriginal));
                if (FAILED(hr))
                {
                    goto done;
                }
            }

            break;
        }

        case TAGTYPE_AREA:
        {
            if (m_pstrIntrinsicTimeAction)
            {
                if (!GetElement())
                {
                    goto done;
                }

                CComPtr<IHTMLAreaElement> spAreaElem;
                hr = THR(GetElement()->QueryInterface(IID_TO_PPV(IHTMLAreaElement, &spAreaElem)));
                if (FAILED(hr))
                {
                    // This has to succeed
                    Assert(false);
                    goto done;
                }

                hr = THR(spAreaElem->put_href(sbstrOriginal));
                if (FAILED(hr))
                {
                    goto done;
                }
            }

            break;
        }

        default:
        {
            // this should never be reached.
            Assert(false);
            goto done;
        }

    } // switch (m_tagType)

    ok = true;
done:
    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
    }
    return ok;
} // RemoveIntrinsicTimeAction


//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::ToggleTimeAction
//
//  Synopsis:   Applies the time action to the target element
//
//  Arguments:  [on]        [true] => Element is active, and vice-versa
//
//  Returns:    [true]      if successful
//              [false]     otherwise    
//
//------------------------------------------------------------------------------------
bool
CTimeAction::ToggleTimeAction(bool on)
{
    TraceTag((tagTimeAction,
              "CTIMEAction(%lx)::ToggleTimeAction(%d) id=%ls",
              this,
              on,
              m_pTEB->GetID()?m_pTEB->GetID():L"unknown"));
    
    bool ok = false;
    BSTR bstr = NULL;
    HRESULT hr = S_OK;
    CComPtr<IHTMLStyle> s;

    if (IsDetaching() || IsPageUnloading())
    {
        ok = true;
        goto done;
    }

    // Always apply the intrinsic timeAction
    ToggleIntrinsicTimeAction(on);

    if (m_timeAction == NONE_TOKEN || m_timeAction == NULL)
    {
        ok = true;
        goto done;
    }
    else if (m_timeAction == STYLE_TOKEN)
    {
        if (NULL == m_pstrOrigAction)
        {
            // nothing to toggle
            ok = true;
            goto done;
        }
        if ((!GetElement()) || FAILED(THR(GetElement()->get_style(&s))))
        {
            goto done;
        }
        
        if (on)
        {
            bstr = SysAllocString(m_pstrOrigAction);
        }
        else
        {
            bstr = SysAllocString(TokenToString(NONE_TOKEN));
        }
    
        if (bstr == NULL)
        {
            TIMESetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }
    
        THR(s->put_cssText(bstr));
    }
    else if (m_timeAction == DISPLAY_TOKEN)
    {
        bool bFocus = m_pTEB->HasFocus();
        // get runtime OR static style
        Assert(NULL != m_pTEB);
        hr = m_pTEB->GetRuntimeStyle(&s);
        if (FAILED(hr))
        {
            goto done;
        }
        
        if (on)
        {
            bstr = SysAllocString(m_pstrOrigAction);
        }
        else
        {
            bstr = SysAllocString(TokenToString(NONE_TOKEN));
        }
    
        if (bstr == NULL)
        {
            TIMESetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }
    

        THR(s->put_display(bstr));
        if (bFocus == true)
        {
            ReleaseCapture();
        }
    }
    else if (m_timeAction == CLASS_TOKEN)
    {
        if (!GetElement())
        {
            goto done;
        }

        CComBSTR sbstrTemp;

        if (NULL == m_pstrUniqueClasses)
        {
            sbstrTemp = L"";
        }
        else
        {
            sbstrTemp = m_pstrUniqueClasses;
        }

        if (!sbstrTemp)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        if (on)
        {
            sbstrTemp.Append(WZ_SPACE);
            sbstrTemp.Append(&(m_pstrTimeAction[m_iClassNames]));
            if (!sbstrTemp)
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }
        }

        hr = THR(GetElement()->put_className(sbstrTemp));
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else
    {
        bool bFocus = m_pTEB->HasFocus();
        // get runtime OR static style
        Assert(NULL != m_pTEB);
        hr = m_pTEB->GetRuntimeStyle(&s);
        if (FAILED(hr))
        {
            goto done;
        }
        
        if (on)
        {
            bstr = SysAllocString(m_pstrOrigAction);
        }
        else
        {
            bstr = SysAllocString(TokenToString(HIDDEN_TOKEN));
        }
    
        if (bstr == NULL)
        {
            TIMESetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }
    
        THR(s->put_visibility(bstr));
        if (bFocus == true)
        {
            ReleaseCapture();
        }
    }

    ok = true;
done:

    m_bTimeActionOn = on; 

    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
    }
    SysFreeString(bstr);
    return ok;
} // ToggleTimeAction


//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::CacheOriginalExpression
//
//  Synopsis:   Caches any expression set on the given runtimeStyle property.
//
//  Arguments:  property name
//
//  Returns:    [true]      if successful
//              [false]     otherwise    
//
//------------------------------------------------------------------------------------
bool 
CTimeAction::CacheOriginalExpression(BSTR bstrPropertyName)
{
    HRESULT              hr = S_OK;
    bool                 ok = false;
    CComPtr<IHTMLStyle>  spStyle;
    CComPtr<IHTMLStyle2> spStyle2;
    CComVariant          svarExpr;

    // Done if we've already cached the expression.
    if (m_pstrOrigExpr)
    {
        ok = true;
        goto done;
    }

    Assert(bstrPropertyName);

    hr = THR(m_pTEB->GetRuntimeStyle(&spStyle));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(spStyle->QueryInterface(IID_TO_PPV(IHTMLStyle2, &spStyle2)));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(spStyle2->getExpression(bstrPropertyName, &svarExpr));
    if (FAILED(hr))
    {
        goto done;
    }
    
    // done if there was no expression
    if (VT_EMPTY == V_VT(&svarExpr))
    {
        ok = true;
        goto done;
    }

    // change type to VT_BSTR
    if (VT_BSTR != V_VT(&svarExpr))
    {
        hr = THR(VariantChangeTypeEx(&svarExpr, &svarExpr, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    // check if an expression is set
    if (V_BSTR(&svarExpr) && (0 != StrCmpIW(WZ_BLANK, V_BSTR(&svarExpr))))
    {
        // cache if it has been set externally
        if (!m_pstrTimeExpr || (0 != StrCmpIW(V_BSTR(&svarExpr), m_pstrTimeExpr)))
        {
            delete [] m_pstrOrigExpr;

            m_pstrOrigExpr = CopyString(V_BSTR(&svarExpr));
            if (NULL == m_pstrOrigExpr)
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }
        }
    }
    
    ok = true;
done:
    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
    }
    return ok;
} // CacheOriginalExpression


//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::RestoreOriginalExpression
//
//  Synopsis:   Restores any expression that was cached.
//
//  Arguments:  property name
//
//  Returns:    [true]      if successful
//              [false]     otherwise    
//
//------------------------------------------------------------------------------------
bool 
CTimeAction::RestoreOriginalExpression(LPWSTR pstrPropertyName)
{
    HRESULT              hr = S_OK;
    bool                 ok = false;
    CComPtr<IHTMLStyle>  spStyle;
    CComPtr<IHTMLStyle2> spStyle2;
    CComBSTR             sbstrPropertyName;

    Assert(pstrPropertyName);

    sbstrPropertyName = pstrPropertyName;
    if (!sbstrPropertyName)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = THR(m_pTEB->GetRuntimeStyle(&spStyle));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(spStyle->QueryInterface(IID_TO_PPV(IHTMLStyle2, &spStyle2)));
    if (FAILED(hr))
    {
        goto done;
    }


    if (m_pstrOrigExpr)
    {
        CComBSTR sbstrExpression(m_pstrOrigExpr);
        CComBSTR sbstrLanguage(WZ_JSCRIPT);
        if (!sbstrExpression || !sbstrLanguage)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        hr = THR(spStyle2->setExpression(sbstrPropertyName, sbstrExpression, sbstrLanguage));
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else
    {
        DisableStyleInheritance(sbstrPropertyName);
    }

    //
    // Indicate that we have restored the original expression 
    //

    delete [] m_pstrOrigExpr;
    m_pstrOrigExpr = NULL;

    delete [] m_pstrTimeExpr;
    m_pstrTimeExpr = NULL;

    ok = true;
done:
    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
    }
    return ok;
} // RestoreOriginalExpression


//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::EnableStyleInheritance
//
//  Synopsis:   Sets an expression on the runtimeStyle property to be the parent's 
//              currentStyle property.
//
//  Arguments:  runtimeStyle property that needs to inherit
//
//  Returns:    [true]      if successful
//              [false]     otherwise    
//
//------------------------------------------------------------------------------------
bool
CTimeAction::EnableStyleInheritance(BSTR bstrPropertyName)
{
    HRESULT              hr = S_OK;
    bool                 ok = false;
    CComPtr<IHTMLStyle>  spStyle;
    CComPtr<IHTMLStyle2> spStyle2;
    CComBSTR             sbstrExpression;
    CComBSTR             sbstrLanguage;

    // Done if we've already set the expression.
    if (m_pstrTimeExpr)
    {
        ok = true;
        goto done;
    }

    // don't set expressions unless the page has loaded
    // This is due to possible existence of multiple elements
    // sharing the same id (108705)
    if (!IsLoaded())
    {
        goto done;
    }

    Assert(bstrPropertyName);

    hr = THR(m_pTEB->GetRuntimeStyle(&spStyle));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(spStyle->QueryInterface(IID_TO_PPV(IHTMLStyle2, &spStyle2)));
    if (FAILED(hr))
    {
        goto done;
    }

    // Set an expression on the runtimeStyle property
    sbstrExpression.Append(WZ_PARENT_CURRSTYLE);
    sbstrExpression.Append(bstrPropertyName);
    sbstrLanguage = WZ_JSCRIPT;
    if (!sbstrExpression || !sbstrLanguage)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    // cache the original expression before blowing it away
    if (!CacheOriginalExpression(bstrPropertyName))
    {
        IGNORE_HR(TIMEGetLastError());
    }


    hr = THR(spStyle2->setExpression(bstrPropertyName, sbstrExpression, sbstrLanguage));
    if (FAILED(hr))
    {
        goto done;
    }

    // store the expression we have set
    m_pstrTimeExpr = CopyString(sbstrExpression);
    if (NULL == m_pstrTimeExpr)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    ok = true;
done:
    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
    }
    
    return ok;
} // EnableStyleInheritance


//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::DisableStyleInheritance
//
//  Synopsis:   Removes the expression on the runtimeStyle property
//
//  Arguments:  runtimeStyle property that needs to not inherit
//
//  Returns:    [true]      if successful
//              [false]     otherwise    
//
//------------------------------------------------------------------------------------
void 
CTimeAction::DisableStyleInheritance(BSTR bstrPropertyName)
{
    HRESULT              hr = S_OK;
    CComPtr<IHTMLStyle>  spStyle;
    CComPtr<IHTMLStyle2> spStyle2;
    VARIANT_BOOL         vbSuccess;

    Assert(bstrPropertyName);

    // Done if we've not set an expression.
    if (!m_pstrTimeExpr)
    {
        goto done;
    }

    hr = THR(m_pTEB->GetRuntimeStyle(&spStyle));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(spStyle->QueryInterface(IID_TO_PPV(IHTMLStyle2, &spStyle2)));
    if (FAILED(hr))
    {
        goto done;
    }

    // cache the original expression before blowing it away
    if (!CacheOriginalExpression(bstrPropertyName))
    {
        IGNORE_HR(TIMEGetLastError());
    }

    IGNORE_HR(spStyle2->removeExpression(bstrPropertyName, &vbSuccess));

    // Indicate that we have removed our custom expression
    delete [] m_pstrTimeExpr;
    m_pstrTimeExpr = NULL;

done:
    if (FAILED(hr))
    {
        // For tracing
        IGNORE_HR(hr);
    }
    return;
} // DisableStyleInheritance


//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::SetStyleProperty
//
//  Synopsis:   sets the given value on the given runtimeStyle property 
//
//  Arguments:  property name and value
//
//  Returns:    [true]      if successful
//              [false]     otherwise    
//
//------------------------------------------------------------------------------------
bool 
CTimeAction::SetStyleProperty(BSTR bstrPropertyName, VARIANT & varPropertyValue)
{
    bool ok = false;
    HRESULT hr = E_FAIL;
    CComPtr<IHTMLStyle> spStyle;
    
    hr = THR(m_pTEB->GetRuntimeStyle(&spStyle));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(spStyle->setAttribute(bstrPropertyName, varPropertyValue, VARIANT_FALSE));
    if (FAILED(hr))
    {
        goto done;
    }

    ok = true;
done:
    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
    }
    
    return ok;
} // SetRuntimeProperty


//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::ToggleStyleSelector
//
//  Synopsis:   When toggling on, set the active value on the runtimeStyle.
//              When toggling off, set an expression on the runtime style property 
//              to fake inheritance when inactive
//
//  Arguments:  on/off, property name, active and inactive value.
//
//  Returns:    [true]      if successful
//              [false]     otherwise    
//
//------------------------------------------------------------------------------------
bool 
CTimeAction::ToggleStyleSelector(bool on, BSTR bstrPropertyName, LPWSTR pstrActive, LPWSTR pstrInactive)
{
    bool ok = false;
    HRESULT hr = S_OK;
    CComVariant svarPropertyValue;
  
    if (on)
    {
        // Remove any expression set on the runtimeStyle property
        DisableStyleInheritance(bstrPropertyName);

        // Set the active value on the runtimeStyle property
        svarPropertyValue = pstrActive;
        if (NULL == V_BSTR(&svarPropertyValue))
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        if (!SetStyleProperty(bstrPropertyName, svarPropertyValue))  
        {
            hr = TIMEGetLastError();
            goto done;
        }
    }
    else
    {
        // Make the property inherit its value from the parent
        if (!EnableStyleInheritance(bstrPropertyName))
        {
            // If property could not be made to inherit, just set the inactive value
            svarPropertyValue = pstrInactive;

            if (NULL == V_BSTR(&svarPropertyValue))
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }

            if (!SetStyleProperty(bstrPropertyName, svarPropertyValue))  
            {
                hr = TIMEGetLastError();
                goto done;
            }
        }
    }

    ok = true;
done:
    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
    }
    
    return ok;
} // ToggleStyleSelector


//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::ToggleBold
//
//  Synopsis:   Delegate to ToggleStyleSelector()
//
//  Arguments:  on/off
//
//  Returns:    [true]      if successful
//              [false]     otherwise    
//
//------------------------------------------------------------------------------------
bool 
CTimeAction::ToggleBold(bool on)
{
    HRESULT hr = S_OK;
    bool ok = false;

    CComBSTR sbstrPropertyName(WZ_FONTWEIGHT);
    if (!sbstrPropertyName)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    ok = ToggleStyleSelector(on, sbstrPropertyName, WZ_BOLD, WZ_NORMAL);

done:
    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
    }
    
    return ok;
} // ToggleBold


//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::ToggleItalic
//
//  Synopsis:   Delegate to ToggleStyleSelector()
//
//  Arguments:  on/off
//
//  Returns:    [true]      if successful
//              [false]     otherwise    
//
//------------------------------------------------------------------------------------
bool 
CTimeAction::ToggleItalic(bool on)
{
    HRESULT hr = S_OK;
    bool ok = false;

    CComBSTR sbstrPropertyName(WZ_FONTSTYLE);
    if (!sbstrPropertyName)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    ok = ToggleStyleSelector(on, sbstrPropertyName, WZ_ITALIC, WZ_NORMAL);

done:
    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
    }
    
    return ok;
} // ToggleItalic


//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::ToggleAnchor
//
//  Synopsis:   Handles A and AREA tags. Removes/Applies the href property. 
//
//  Arguments:  on/off
//
//  Returns:    [true]      if successful
//              [false]     otherwise    
//
//------------------------------------------------------------------------------------
bool 
CTimeAction::ToggleAnchor(bool on)
{
    bool ok = false;
    CComBSTR sbstr;
    HRESULT hr = S_OK;

    if (NULL == m_pstrIntrinsicTimeAction)
    {
        // nothing to toggle
        hr = S_OK;
        ok = true;
        goto done;
    }

    if (!GetElement())
    {
        goto done;
    }

    // dilipk: This will cause incorrect persistence if we save when element is inactive (ie6 bug #14218)
    if (on)
    {
        sbstr = SysAllocString(m_pstrIntrinsicTimeAction);
        if (sbstr == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        if (TAGTYPE_A == m_tagType)
        {
            CComPtr<IHTMLAnchorElement> spAnchorElem;
            hr = THR(GetElement()->QueryInterface(IID_TO_PPV(IHTMLAnchorElement, &spAnchorElem)));
            if (FAILED(hr))
            {
                // This has to succeed
                Assert(false);
                goto done;
            }

            hr = THR(spAnchorElem->put_href(sbstr));
            if (FAILED(hr))
            {
                goto done;
            }
        }
        else
        {
            // This is TAGTYPE_AREA

            CComPtr<IHTMLAreaElement> spAreaElem;
            hr = THR(GetElement()->QueryInterface(IID_TO_PPV(IHTMLAreaElement, &spAreaElem)));
            if (FAILED(hr))
            {
                // This has to succeed
                Assert(false);
                goto done;
            }

            hr = THR(spAreaElem->put_href(sbstr));
            if (FAILED(hr))
            {
                goto done;
            }
        }
    }
    else
    {
        // toggle timeAction off
        CComBSTR sbstrAttrName;
        sbstrAttrName = SysAllocString(WZ_HREF);
        if (sbstrAttrName == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        VARIANT_BOOL vbSuccess = VARIANT_FALSE;
        hr = THR(GetElement()->removeAttribute(sbstrAttrName, VARIANT_FALSE, &vbSuccess));
        if (FAILED(hr))
        {
            goto done;
        }
        if (VARIANT_FALSE == vbSuccess)
        {
            hr = E_FAIL;
            goto done;
        }
    } // if (on)

    ok = true;
done:
    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
    }
    
    return ok;
} // ToggleAnchor


//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::ToggleIntrinsicTimeAction
//
//  Synopsis:   toggles the intrinsic timeAction values. 
//
//  Arguments:  on/off
//
//  Returns:    [true]      if successful
//              [false]     otherwise    
//
//------------------------------------------------------------------------------------
bool 
CTimeAction::ToggleIntrinsicTimeAction(bool on)
{
    bool ok = false;
    HRESULT hr = S_OK;
    CComPtr<IHTMLStyle> s;
    CComBSTR sbstr;
    CComPtr<IHTMLStyle2> spStyle2;
    
    if (IsDetaching() || IsPageUnloading())
    {
        ok = true;
        goto done;
    }

    // if this is not a special tag, we have no work to do
    if (!IsSpecialTag())
    {
        ok = true;
        goto done;
    }

    //
    // Toggle the attribute value
    //

    switch (m_tagType)
    {
        case TAGTYPE_B:
        case TAGTYPE_STRONG:
        {
            if (!ToggleBold(on))
            {
                hr = TIMEGetLastError();
                goto done;
            }
            break;
        }
    
        case TAGTYPE_I:
        case TAGTYPE_EM:
        {
            if (!ToggleItalic(on))
            {
                hr = TIMEGetLastError();
                goto done;
            }
            break;
        }

        case TAGTYPE_A:
        case TAGTYPE_AREA:
        {
            if (!ToggleAnchor(on))
            {
                hr = TIMEGetLastError();
                goto done;
            }
            break;
        }

        default:
        {
            // this should never be reached.
            Assert(false);
            hr = E_FAIL;
            goto done;
        }
    } // switch (m_tagType)

    ok = true;
done:
    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
    }
    return ok;
} // ToggleIntrinsicTimeAction


//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::UpdateDefaultTimeAction
//
//  Synopsis:   Determines the default timeAction for the time element and sets it
//
//  Arguments:  none
//
//  Returns:    true  - Success
//              false - Failure   
//
//------------------------------------------------------------------------------------
bool
CTimeAction::UpdateDefaultTimeAction()
{
    TOKEN tokDefaultTimeAction;

    if (IsDetaching() || IsPageUnloading())
    {
        goto done;
    }

    // if the timeAction is set to the default, update it
    if (m_fUseDefault)
    {
        tokDefaultTimeAction = GetDefaultTimeAction();

        if (m_timeAction != tokDefaultTimeAction)
        {
            RemoveTimeAction();
            m_timeAction = tokDefaultTimeAction;
            AddTimeAction();
        }
    }

done:
    return true;
} // UpdateDefaultTimeAction


//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::ParseTagName
//
//  Synopsis:   Parses the tag name and checks the scopeName to be "HTML" where required
//
//  Arguments:  none
//
//  Returns:    [true]      if successful
//              [false]     otherwise    
//
//------------------------------------------------------------------------------------
void
CTimeAction::ParseTagName()
{
    CComBSTR sbstrTagName;

    if (TAGTYPE_UNINITIALIZED != m_tagType)
    {
        return;
    }

    // initialize tag type
    m_tagType = TAGTYPE_OTHER;

    if (GetElement() == NULL)
    {
        return;
    }

    // Get the tag name
    IGNORE_HR(GetElement()->get_tagName(&sbstrTagName));
    Assert(sbstrTagName.m_str);
    if (sbstrTagName)
    {
        // Parse the tag name
        if (0 == StrCmpIW(sbstrTagName, WZ_B))
        {
            m_tagType = TAGTYPE_B;
        }
        else if (0 == StrCmpIW(sbstrTagName, WZ_I))
        {
            m_tagType = TAGTYPE_I;
        }
        else if (0 == StrCmpIW(sbstrTagName, WZ_A))
        {
            m_tagType = TAGTYPE_A;
        }
        else if (0 == StrCmpIW(sbstrTagName, WZ_EM))
        {
            m_tagType = TAGTYPE_EM;
        }
        else if (0 == StrCmpIW(sbstrTagName, WZ_AREA))
        {
            m_tagType = TAGTYPE_AREA;
        }
        else if (0 == StrCmpIW(sbstrTagName, WZ_STRONG))
        {
            m_tagType = TAGTYPE_STRONG;
        }
        else if (0 == StrCmpIW(sbstrTagName, WZ_BODY) ||
                 0 == StrCmpIW(sbstrTagName, WZ_EXCL) ||
                 0 == StrCmpIW(sbstrTagName, WZ_PAR)  ||
                 0 == StrCmpIW(sbstrTagName, WZ_SEQUENCE))
        {
            // Is it better to use urn to differentiate time tags? (bug 14219, ie6)
            m_fContainerTag = true;
        }
    }

    // if it is special tag, try to ensure that the scopeName is "HTML"
    if (m_tagType != TAGTYPE_OTHER)
    {
        CComPtr<IHTMLElement2> spElement2;

        // Try to get the namespace
        HRESULT hr = THR(GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &spElement2)));
        if (SUCCEEDED(hr))
        {
            CComBSTR sbstrScopeName;

            IGNORE_HR(spElement2->get_scopeName(&sbstrScopeName));
            // make sure the scope name is HTML
            if (sbstrScopeName && 0 != StrCmpIW(sbstrScopeName, WZ_HTML))
            {
                m_tagType = TAGTYPE_OTHER;
            }
        }

    }
} // ParseTagName


LPWSTR 
CTimeAction::GetTimeActionString()
{
    return m_pstrOrigAction;
}

//+-----------------------------------------------------------------------------------
//
//  Member:     CTimeAction::IsSpecialTag
//
//  Synopsis:   Checks the parsed tagName
//
//  Arguments:  none
//
//  Returns:    [true]      if the tag is a special tag (B, STRONG, I, EM, A, AREA) 
//              [false]     otherwise    
//
//------------------------------------------------------------------------------------
bool 
CTimeAction::IsSpecialTag() 
{ 
    // Parse the HTML tag
    ParseTagName();

    return (m_tagType != TAGTYPE_OTHER); 
}


inline
bool
CTimeAction::IsInSequence()
{
    Assert(m_pTEB);
    return (m_pTEB->GetParent() && 
            m_pTEB->GetParent()->IsSequence());
}


inline
bool 
CTimeAction::IsContainerTag() 
{     
    // Parse the HTML tag
    ParseTagName();

    return m_fContainerTag; 
}


inline
bool 
CTimeAction::IsGroup() 
{     
    return (m_pTEB && m_pTEB->IsGroup());
}


inline
bool
CTimeAction::IsMedia()
{
    return (m_pTEB && m_pTEB->IsMedia());
}


inline
bool 
CTimeAction::IsPageUnloading()
{
    Assert(m_pTEB);
    return (m_pTEB->IsUnloading() || m_pTEB->IsBodyUnloading());
}


inline
bool 
CTimeAction::IsDetaching()
{
    Assert(m_pTEB);
    return (m_pTEB->IsDetaching());
}

inline
bool 
CTimeAction::IsLoaded()
{
    Assert(m_pTEB);
    return (m_pTEB->IsLoaded());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timebvr\timeelmbase.cpp ===
//------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1998
//
//  File: timeelmbase.cpp
//
//  Contents: TIME Behavior base class
//
//------------------------------------------------------------------------------

#include "headers.h"
#include "timeelmbase.h"
#include "..\tags\bodyelm.h"
#include "currtimestate.h"
#include "util.h"
#include "mmseq.h"
#include "mmexcl.h"
#include "mmmedia.h"
#include "trans.h"
#include "transdepend.h"

// Suppress new warning about NEW without corresponding DELETE 
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )  

static OLECHAR *g_szRepeatCount = L"Iteration";

//+-----------------------------------------------------------------------------
//
//  Trace Tags
//
//------------------------------------------------------------------------------
DeclareTag(tagTimeElmBase, "TIME: Behavior", "CTIMEElementBase methods");
DeclareTag(tagTimeElmBaseEvents, "TIME: Behavior", "CTIMEElementBase Events");
DeclareTag(tagTimeElmUpdateTimeAction, "TIME : Behavior", "UpdateTimeAction");
DeclareTag(tagTimeElmBaseNeedFill, "TIME: Behavior", "CTIMEElementBase::NeedFill");
DeclareTag(tagTimeTransitionFill, "SMIL Transitions", "Transition fill dependents");

//+-----------------------------------------------------------------------------
//
//  Static Variables
//
//------------------------------------------------------------------------------
DWORD CTIMEElementBase::s_cAtomTableRef = 0;
CAtomTable *CTIMEElementBase::s_pAtomTable = NULL;

static const IID IID_IThumbnailView = {0x7bb0b520,0xb1a7,0x11d2,{0xbb,0x23,0x0,0xc0,0x4f,0x79,0xab,0xcd}};
// Error strings used when  string table resource fails to load
static const LPWSTR WZ_ERROR_STRING_FORMAT  = L"Invalid argument! ID:'%.100ls'; Member:'%.100ls'; Value:'%.800ls'";
static const long MAX_ERR_STRING_LEN = 1024;

//+-----------------------------------------------------------------------------
//
//  Default Values for properties
//
//------------------------------------------------------------------------------
#define DEFAULT_M_DUR valueNotSet
#define DEFAULT_M_END NULL
#define DEFAULT_M_ENDSYNC NULL
#define DEFAULT_M_REPEAT 1
#define DEFAULT_M_REPEATDUR valueNotSet
#define DEFAULT_M_TIMELINETYPE ttUninitialized
#define DEFAULT_M_SYNCBEHAVIOR INVALID_TOKEN
#define DEFAULT_M_SYNCTOLERANCE valueNotSet
#define DEFAULT_M_PTIMEPARENT NULL
#define DEFAULT_M_ID NULL
#define DEFAULT_M_MMBVR NULL
#define DEFAULT_M_BSTARTED false
#define DEFAULT_M_PCOLLECTIONCACHE NULL
#define DEFAULT_M_TIMELINE NULL
#define DEFAULT_M_ACCELERATE 0.0f
#define DEFAULT_M_DECELERATE 0.0f
#define DEFAULT_M_BAUTOREVERSE false
#define DEFAULT_M_FLTSPEED 1.0f
#define DEFAULT_M_BLOADED false,
#define DEFAULT_M_FILL REMOVE_TOKEN
#define DEFAULT_M_RESTART ALWAYS_TOKEN
#define DEFAULT_M_FTIMELINEINITIALIZED false
#define DEFAULT_M_REALBEGINTIME valueNotSet
#define DEFAULT_M_REALDURATION valueNotSet
#define DEFAULT_M_REALREPEATTIME valueNotSet
#define DEFAULT_M_REALREPEATCOUNT valueNotSet
#define DEFAULT_M_REALREPEATINTERVALDURATION valueNotSet
#define DEFAULT_M_PROPERTYACCESFLAGS 0
#define DEFAULT_M_MLOFFSETWIDTH 0
#define DEFAULT_M_FLVOLUME 1.0f
#define DEFAULT_M_VBMUTE VARIANT_FALSE
#define DEFAULT_M_UPDATEMODE AUTO_TOKEN
#define DEFAULT_M_TRANSIN   NULL
#define DEFAULT_M_TRANSOUT  NULL


//+-----------------------------------------------------------------------------
//
//  Member:     CTIMEElementBase::CTIMEElementBase
//
//  Synopsis:   Default Constructor
//
//  Arguments:  none
//
//------------------------------------------------------------------------------
CTIMEElementBase::CTIMEElementBase() :
    m_SABegin(NULL),
    m_FADur(DEFAULT_M_DUR), //lint !e747
    m_SAEnd(DEFAULT_M_END),
    m_SAEndSync(DEFAULT_M_ENDSYNC),
    m_FARepeat(DEFAULT_M_REPEAT), //lint !e747
    m_FARepeatDur(DEFAULT_M_REPEATDUR), //lint !e747
    m_privateRepeat(0),
    m_SATimeAction(NULL),
    m_timeAction(this),
    m_TTATimeContainer(ttUninitialized),
    m_TASyncBehavior(INVALID_TOKEN),
    m_FASyncTolerance(valueNotSet), //lint !e747
    m_pTIMEParent(DEFAULT_M_PTIMEPARENT),
    m_id(DEFAULT_M_ID),
    m_mmbvr(DEFAULT_M_MMBVR),
    m_bStarted(DEFAULT_M_BSTARTED),
    m_pCollectionCache(DEFAULT_M_PCOLLECTIONCACHE),
    m_timeline(DEFAULT_M_TIMELINE),
    m_FAAccelerate(DEFAULT_M_ACCELERATE),
    m_FADecelerate(DEFAULT_M_DECELERATE),
    m_BAAutoReverse(DEFAULT_M_BAUTOREVERSE),
    m_FASpeed(DEFAULT_M_FLTSPEED),
    m_TARestart(DEFAULT_M_RESTART),
    m_bLoaded(false),
    m_bUnloading(false),
    m_TAFill(DEFAULT_M_FILL),
    m_fTimelineInitialized(false),
    m_realDuration(valueNotSet),
    m_realRepeatTime(valueNotSet),
    m_realRepeatCount(valueNotSet),
    m_realIntervalDuration(valueNotSet),
    m_propertyAccesFlags(0),
    m_FAVolume(DEFAULT_M_FLVOLUME),
    m_BAMute(DEFAULT_M_VBMUTE),
    m_dLastRepeatEventNotifyTime(0.0),
    m_BASyncMaster(false),
    m_fCachedSyncMaster(false),
    m_sHasSyncMMediaChild(-1),
    m_fDetaching(false),
    m_TAUpdateMode(DEFAULT_M_UPDATEMODE),
    m_tokPriorityClassPeers(STOP_TOKEN),
    m_tokPriorityClassHigher(PAUSE_TOKEN),
    m_tokPriorityClassLower(DEFER_TOKEN),
    m_bIsSwitch(false),
    m_bBodyUnloading(false),
    m_bNeedDetach(false),
    m_bBodyDetaching(false),
    m_fUseDefaultFill(false),
    m_fHasPlayed(false),
    m_enumIsThumbnail(TSB_UNINITIALIZED),
    m_bReadyStateComplete(false),
    m_bAttachedAtomTable(false),
    m_fInTransitionDependentsList(false),
    m_fEndingTransition(false),
    m_ExtenalBodyTime(valueNotSet),
    m_SAtransIn(DEFAULT_M_TRANSIN),
    m_SAtransOut(DEFAULT_M_TRANSOUT),
    m_sptransIn(NULL),
    m_sptransOut(NULL),
    m_vbDrawFlag(VARIANT_TRUE),
    m_fHasWallClock(false),
    m_fLocalTimeDirty(true)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::CTIMEElementBase()",
              this));
 
    GetLocalTime(&m_timeSystemBeginTime);

    TEM_DECLARE_EVENTMGR();
} // CTIMEElementBase


//+-----------------------------------------------------------------------------
//
//  Member:     CTIMEElementBase::~CTIMEElementBase
//
//  Synopsis:   Default Destructor
//
//  Arguments:  none
//
//------------------------------------------------------------------------------
CTIMEElementBase::~CTIMEElementBase()
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::~CTIMEElementBase()",
              this));

    // delete attribute strings
    delete [] m_SABegin.GetValue();
    delete [] m_SAEnd.GetValue();
    delete [] m_SAEndSync.GetValue();
    delete [] m_SATimeAction.GetValue();
    delete [] m_SAtransIn.GetValue();
    delete [] m_SAtransOut.GetValue();

    // delete other strings
    delete [] m_id;
    delete m_mmbvr;

    // !!! Do not delete m_timeline since m_mmbvr points to the same
    // object
    m_mmbvr = NULL;
    m_timeline = NULL;

    if (m_pCollectionCache != NULL)
    {
        delete m_pCollectionCache;
        m_pCollectionCache = NULL;
    }
        
    m_pTIMEParent = NULL;

    TEM_FREE_EVENTMGR();

    // double check the children list
    Assert(m_pTIMEChildren.Size() == 0);

    if (m_pCurrTimeState)
    {
        m_pCurrTimeState->Deinit();
        m_pCurrTimeState.Release();
    }
    m_tokPriorityClassPeers = NULL;
    m_tokPriorityClassHigher = NULL;
    m_tokPriorityClassLower = NULL;
} // ~CTIMEElementBase


//+-----------------------------------------------------------------------------
//
//  Member:     CTIMEElementBase::Init, IElementBehavior
//
//  Synopsis:   First method called by MSHTML after creation of this behavior
//
//  Arguments:  pointer to our bvr site
//
//  Returns:    [HRESULT]
//
//------------------------------------------------------------------------------
STDMETHODIMP
CTIMEElementBase::Init(IElementBehaviorSite * pBehaviorSite)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::Init(%p)",
              this,
              pBehaviorSite));
    
    HRESULT hr;
    BSTR bstrID = NULL;
    BSTR bstrTagName = NULL;
    CTIMEBodyElement *pBodyElement;
    CComPtr<ITIMEElement> pTIMEElem = NULL;
    CComPtr<IHTMLElement> spHTMLBodyElm;
    CComPtr<ITIMEBodyElement> spTIMEBodyElement;


    hr = THR(CBaseBvr::Init(pBehaviorSite));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = GetSyncBaseBody(GetElement(), &m_spBodyElemExternal);
    if(SUCCEEDED(hr) && m_spBodyElemExternal)
    {
        pBodyElement = GetTIMEBodyElement(m_spBodyElemExternal);
        if(pBodyElement && pBodyElement->IsReady())
        {
            m_ExtenalBodyTime = pBodyElement->GetMMBvr().GetActiveTime();
        }
    }

    // since we support t:par and t:sequence, get tag name and
    // see if we are one of the above.  By default, we are ttNone.
    hr = THR(GetElement()->get_tagName(&bstrTagName));
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(m_TTATimeContainer == ttUninitialized);

    if (StrCmpIW(bstrTagName, WZ_PAR) == 0)
    {
        // Using InternalSet instead of SetValue, to prevent attribute from being persisted
        m_TTATimeContainer.InternalSet(ttPar);
    }
    else if (StrCmpIW(bstrTagName, WZ_EXCL) == 0)
    {
        // Using InternalSet instead of SetValue, to prevent attribute from being persisted
        m_TTATimeContainer.InternalSet(ttExcl);
    }
    else if (StrCmpIW(bstrTagName, WZ_SEQUENCE) == 0)
    {
        // Using InternalSet instead of SetValue, to prevent attribute from being persisted
        m_TTATimeContainer.InternalSet(ttSeq);
    }
    else if (StrCmpIW(bstrTagName, WZ_BODY) == 0)
    {
        // Using InternalSet instead of SetValue, to prevent attribute from being persisted
        m_TTATimeContainer.InternalSet(ttPar);
    }
    else if (StrCmpIW(bstrTagName, WZ_SWITCH) == 0)
    {
        m_bIsSwitch = true;
    }

    SysFreeString(bstrTagName);

    hr = CreateActiveEleCollection();
    if (FAILED(hr))
    {   
        goto done;
    }   

    // get ID of element and cache it
    hr = THR(GetElement()->get_id(&bstrID));
    if (SUCCEEDED(hr) && bstrID)
    {
        m_id = CopyString(bstrID);
        if (m_id == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    SysFreeString(bstrID);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = TEM_INIT_EVENTMANAGER(m_pHTMLEle, pBehaviorSite);
    if (FAILED(hr))
    {
        goto done;
    }

    m_bAttachedAtomTable = true;
    // init atom table for collections
    hr = THR(InitAtomTable());
    if (FAILED(hr))
    {
        goto done;
    }

    if (!IsBody())
    {
        hr = THR(AddBodyBehavior(GetElement()));
        if (FAILED(hr))
        {
            goto done;
        }

        if(!m_spBodyElemExternal)
        {
            // if we are not a body element, walk up the HTML tree looking for our TIME parent.
            hr = ParentElement();
            if (FAILED(hr))
            {
                goto done;
            }
        }
        else
        {
            if (IsEmptyBody())
            {
                hr = THR(GetBodyElement(GetElement(), IID_IHTMLElement,
                                        reinterpret_cast<void **>(&spHTMLBodyElm)));
                if(FAILED(hr))
                {
                    spHTMLBodyElm = NULL;
                }
                if (m_spBodyElemExternal && spHTMLBodyElm)
                {
                    hr = THR(m_spBodyElemExternal->QueryInterface(IID_ITIMEElement, (void **)&pTIMEElem));
                    if (FAILED(hr))
                    {
                        goto done;
                    }
                    // get TIME interface
                    hr = FindBehaviorInterface(GetBehaviorName(),
                                               spHTMLBodyElm,
                                               IID_ITIMEBodyElement,
                                               (void**)&spTIMEBodyElement);
                    if (FAILED(hr))
                    {
                        goto done;
                    }
                    pBodyElement = GetTIMEBodyElement(spTIMEBodyElement);
                    if(!pBodyElement)
                    {
                        goto done;
                    }
                    hr = pBodyElement->SetParent(pTIMEElem);

                    hr = THR(AddBodyBehavior(GetElement()));
                    if (FAILED(hr))
                    {
                        goto done;
                    }
                }
            }
            else
            {
                hr = ParentElement();
                if (FAILED(hr))
                {
                    goto done;
                }
            }
        }
    }

    // init the timeAction and toggle it
    m_timeAction.Init();
    UpdateTimeAction();

    SetupPriorityClassParent();
    
    hr = S_OK;
  done:
    return hr;
} // Init


void
CTIMEElementBase::SetupPriorityClassParent()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLElement> spParentElement;
    CComBSTR sBSTR;
    CComVariant sVariant;
    TOKEN tempToken;

    hr = m_pHTMLEle->get_parentElement(&spParentElement);
    if (FAILED(hr) || spParentElement == NULL)
    {
        goto done;
    }

    if (!::IsElementPriorityClass(spParentElement))
    {
        goto done;
    }

    // the parent of this element is a priority class element
    hr = spParentElement->getAttribute(L"peers", 0, &sVariant);
    if (FAILED(hr))
    {
        goto done;
    }
    {
        CTIMEParser tParser(&sVariant);
        hr = tParser.ParsePriorityClass(tempToken);
        if (SUCCEEDED(hr))
        {
            m_tokPriorityClassPeers = tempToken;
        }
    }
    
    hr = spParentElement->getAttribute(L"higher", 0, &sVariant);
    if (FAILED(hr))
    {
        goto done;
    }
    {
        CTIMEParser tParser(&sVariant);
        hr = tParser.ParsePriorityClass(tempToken);
        if (SUCCEEDED(hr) && 
            ( STOP_TOKEN == tempToken || PAUSE_TOKEN == tempToken ))
        {
            m_tokPriorityClassHigher = tempToken;
        }
    }
    hr = spParentElement->getAttribute(L"lower", 0, &sVariant);
    if (FAILED(hr))
    {
        goto done;
    }
    {
        CTIMEParser tParser(&sVariant);
        hr = tParser.ParsePriorityClass(tempToken);
        if (SUCCEEDED(hr) && 
            ( DEFER_TOKEN == tempToken || NEVER_TOKEN == tempToken ))
        {
            m_tokPriorityClassLower = tempToken;
        }
    }

done:
    return;    
}

STDMETHODIMP
CTIMEElementBase::Notify(LONG event, VARIANT * pVar)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::Notify(%lx)",
              this,
              event));

    THR(CBaseBvr::Notify(event, pVar));

    return S_OK;
}

STDMETHODIMP
CTIMEElementBase::Detach()
{
    TraceTag((tagTimeElmBase, "CTIMEElementBase(%p)::Detach()", this));
    CComPtr<ITIMEElement> pTIMEParent;

    if (GetBody() != NULL && GetBody()->IsBodyLoading() == true)
    {
        m_bNeedDetach = true;
        goto done;
    }

    m_fDetaching = true; // This flag is used to indicate that the element is gone
                         // do not remove or change the meaning of this flag.
    
    if (GetParent() != NULL && !IsUnloading())
    {
        IGNORE_HR(GetParent()->QueryInterface(IID_TO_PPV(ITIMEElement, &pTIMEParent)));
    }

    m_activeElementCollection.Release();

    IGNORE_HR(UnparentElement());

    // clear all children from holding a reference to ourselves
    // NOTE: this is a weak reference
    while (m_pTIMEChildren.Size() > 0)
    {
        CTIMEElementBase *pChild = m_pTIMEChildren[0];
        pChild->AddRef();
        pChild->SetParent(pTIMEParent, false);
            
        if (!IsUnloading())
        {
            // if we found a parent and it's timeline is present,
            // kick-start our root time.
            CTIMEElementBase *pElemNewParent = pChild->GetParent();
            if (pElemNewParent != NULL)
            {
                MMTimeline *tl = pElemNewParent->GetMMTimeline();
                if (tl != NULL)
                    pChild->StartRootTime(tl);
            }
        }
        pChild->Release();
    }
    m_pTIMEChildren.DeleteAll();

    CTIMEElementBase ** ppElm;
    int i;

    for (i = m_pTIMEZombiChildren.Size(), ppElm = m_pTIMEZombiChildren;
         i > 0;
         i--, ppElm++)
    {
        Assert(ppElm);
        if ((*ppElm))
        {
            (*ppElm)->Release();
        }
    }

    m_pTIMEZombiChildren.DeleteAll();

    //delete m_mmbvr;
    //m_mmbvr = NULL;

    // Do not delete m_timeline since it is the same object as
    // m_mmbvr
    m_timeline = NULL;
    
    m_timeAction.Detach();
    
    TEM_CLEANUP_EVENTMANAGER();

    IGNORE_HR(CBaseBvr::Detach());
    
    if (m_bAttachedAtomTable)
    {
        ReleaseAtomTable();
        m_bAttachedAtomTable = false;
    }

    RemoveFromTransitionDependents();

    RemoveTrans();

  done:

    return S_OK;
}

/////////////////////////////////////////////////////////////////////
// ITIMEElement base interfaces
/////////////////////////////////////////////////////////////////////

HRESULT
CTIMEElementBase::base_get_begin(VARIANT * time)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase::(%p)::base_get_begin()",
              this));

    HRESULT hr;

    CHECK_RETURN_NULL(time);

    hr = THR(VariantClear(time));
    if (FAILED(hr))
    {
        goto done;
    }
    
    V_VT(time) = VT_BSTR;
    V_BSTR(time) = SysAllocString(m_SABegin);

    hr = S_OK;
  done:
    return hr;
}


//+-----------------------------------------------------------------------------
//
//  Member:     CTIMEElementBase::base_put_begin
//
//  Synopsis:   Internal method for setting Begin
//
//  Arguments:  time    Variant that contains the attribute value string
//
//  Returns:    S_OK, Error
//
//------------------------------------------------------------------------------

HRESULT
CTIMEElementBase::base_put_begin(VARIANT time)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase::(%p)::base_put_begin()",
              this));

    HRESULT hr;
    // Reset the old values
    m_realBeginValue.Clear();
    
    // prevent memory leak on 2nd+ calls
    delete [] m_SABegin.GetValue();
    m_SABegin.Reset(NULL);
    if (m_fLocalTimeDirty)
    {
        GetLocalTime(&m_timeSystemBeginTime);
        m_fLocalTimeDirty = false;
    }

    if(V_VT(&time) != VT_NULL)
    {
        CComVariant v;

        hr = THR(VariantChangeTypeEx(&v,
                                     &time,
                                     LCID_SCRIPTING,
                                     VARIANT_NOUSEROVERRIDE,
                                     VT_BSTR));
        if (FAILED(hr))
        {
            goto done;
        }
    
        {
            LPWSTR lpwStr = CopyString(V_BSTR(&v));

            if (lpwStr == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }

            m_SABegin.SetValue(lpwStr);
        }

        {
            CTIMEParser pParser(&v);
            
            IGNORE_HR(pParser.ParseTimeValueList(m_realBeginValue, &m_fHasWallClock, &m_timeSystemBeginTime));

            if (IsValidtvList(&m_realBeginValue) != true)
            {
                m_realBeginValue.Clear();
            }
        }
    }


    hr = S_OK;
  done:
    // We always reset the attribute, so we should always call UpdateMMAPI
    IGNORE_HR(UpdateMMAPI(true, false));
    if (GetParent() && GetParent()->IsSequence() == false)
    {
        IGNORE_HR(TEM_SET_TIME_BEGINEVENT(m_realBeginValue));
    }

    NotifyPropertyChanged(DISPID_TIMEELEMENT_BEGIN);
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::base_get_dur(VARIANT * time)
{
    HRESULT hr = S_OK;
    VARIANT fTemp;
    if (time == NULL)
    {
        hr = E_POINTER;
        goto done;
    }
    hr = THR(VariantClear(time));
    if (FAILED(hr))
    {
        goto done;
    }
    
    VariantInit(&fTemp);
    fTemp.vt = VT_R4;
    fTemp.fltVal = m_FADur;

    if( m_FADur != INDEFINITE &&
        m_FADur >= 0.0 )
    {
        hr = THR(VariantChangeTypeEx(time, &fTemp, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR));
        if (!SUCCEEDED(hr))
        {
            VariantClear(&fTemp);
            goto done;
        }
    }
    else
    {
        V_VT(time) = VT_BSTR;
        V_BSTR(time) = SysAllocString(WZ_INDEFINITE);
    }


    VariantClear(&fTemp);
    
    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_dur(VARIANT time)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase::(%p)::base_put_dur()",
              this));

    HRESULT hr = E_FAIL;
    double dblTemp = DEFAULT_M_DUR;

    m_FADur.Reset(static_cast<float>(DEFAULT_M_DUR));

    if(V_VT(&time) != VT_NULL)
    {
        CTIMEParser pParser(&time);
        
        hr = THR(pParser.ParseDur(dblTemp));
        if (FAILED(hr))
        {
            goto done;
        }

        if (dblTemp < 0.0)
        {
            IGNORE_HR(ReportInvalidArg(WZ_DUR, time));
            // ignoring invalid arg as per smil-boston spec
        }
        else
        {
            m_FADur.SetValue(static_cast<float>(dblTemp));
        }
    }

    hr = S_OK;

  done:

    // We always reset the attribute, so we should always call UpdateMMAPI
    IGNORE_HR(UpdateMMAPI(false, false));

    NotifyPropertyChanged(DISPID_TIMEELEMENT_DUR);
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::base_get_end(VARIANT * time)
{
    HRESULT hr;
    
    CHECK_RETURN_NULL(time);

    hr = THR(VariantClear(time));
    if (FAILED(hr))
    {
        goto done;
    }
    
    V_VT(time) = VT_BSTR;
    V_BSTR(time) = SysAllocString(m_SAEnd);

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_end(VARIANT time)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase::(%p)::base_put_end()",
              this));

    HRESULT hr;
    
    // Reset the old values
    m_realEndValue.Clear();
    m_SAEnd.Reset(NULL);

    if(V_VT(&time) != VT_NULL)
    {
        CComVariant v;

        hr = THR(VariantChangeTypeEx(&v,
                                     &time,
                                     LCID_SCRIPTING,
                                     VARIANT_NOUSEROVERRIDE,
                                     VT_BSTR));
        if (FAILED(hr))
        {
            goto done;
        }

        {
            CTIMEParser pParser(&v);
            
            IGNORE_HR(pParser.ParseTimeValueList(m_realEndValue));
            
            if (IsValidtvList(&m_realEndValue) != true)
            {
                m_realEndValue.Clear();
            }
            else
            {
                LPWSTR lpwStr = CopyString(V_BSTR(&v));

                if (lpwStr == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    goto done;
                }

                m_SAEnd.SetValue(lpwStr);
            }
        }
    }


    hr = S_OK;
  done:
    // We always reset the attribute, so we should always call UpdateMMAPI
    IGNORE_HR(UpdateMMAPI(false, true));
    IGNORE_HR(TEM_SET_TIME_ENDEVENT(m_realEndValue));

    NotifyPropertyChanged(DISPID_TIMEELEMENT_END);
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::base_get_endSync(BSTR * time)
{
    HRESULT hr = S_OK;
    
    CHECK_RETURN_NULL(time);

    *time = SysAllocString(m_SAEndSync);

    hr = S_OK;
done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_endSync(BSTR time)
{
    CComVariant v;
    HRESULT hr = S_OK;
    
    delete [] m_SAEndSync.GetValue();
    m_SAEndSync.Reset(DEFAULT_M_ENDSYNC);

    if (time != NULL)
    {
        LPWSTR pstrTemp = CopyString(time);
        if (NULL != pstrTemp)
        {
            m_SAEndSync.SetValue(pstrTemp);
        }
        else
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    
    hr = S_OK;
  done:
    // We always reset the attribute, so we should always call UpdateMMAPI
    IGNORE_HR(UpdateMMAPI(false, false));

    NotifyPropertyChanged(DISPID_TIMEELEMENT_ENDSYNC);
    return hr;
}

HRESULT
CTIMEElementBase::base_get_repeatCount(VARIANT * time)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::base_get_repeatCount(%g)",
              this,
              time));
    HRESULT hr = S_OK;
    // Still need to take in to consideration "infinite"
    
    CHECK_RETURN_NULL(time);

    hr = THR(VariantClear(time));
    if (FAILED(hr))
    {
        goto done;
    }
    
    if(m_FARepeat != INDEFINITE)
    {
        V_VT(time) = VT_R4;
        V_R4(time) = m_FARepeat;
    }
    else
    {
        V_VT(time) = VT_BSTR;
        V_BSTR(time) = SysAllocString(WZ_INDEFINITE);
    }

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_repeatCount(VARIANT time)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::base_put_repeatCount(%g)",
              this,
              time));

    HRESULT hr = E_FAIL;
    
    m_FARepeat.Reset(static_cast<float>(DEFAULT_M_REPEAT));

    if(V_VT(&time) != VT_NULL)
    {
        CTIMEParser pParser(&time);

        double dblTemp;
        hr = THR(pParser.ParseNumber(dblTemp));
        if (SUCCEEDED(hr))
        {
            if (0.0 < dblTemp)
            {
                m_FARepeat.SetValue((float) dblTemp);
            }
            else
            {
                IGNORE_HR(ReportInvalidArg(WZ_REPEATCOUNT, time));
            }
        }
    }

    hr = S_OK;
  done:
    // We always reset the attribute, so we should always call UpdateMMAPI
    IGNORE_HR(UpdateMMAPI(false, false));

    NotifyPropertyChanged(DISPID_TIMEELEMENT_REPEATCOUNT);
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::base_get_repeatDur(VARIANT * time)
{
    HRESULT hr = S_OK;
    VARIANT fTemp, bstrTemp;

    CHECK_RETURN_NULL(time);

    hr = THR(VariantClear(time));
    if (FAILED(hr))
    {
        goto done;
    }
    
    if(m_FARepeatDur != INDEFINITE &&
       m_FARepeatDur >= 0.0f)
    {
        VariantInit(&fTemp);
        VariantInit(&bstrTemp);
        fTemp.vt = VT_R4;
        fTemp.fltVal = m_FARepeatDur;

        hr = THR(VariantChangeTypeEx(&bstrTemp, &fTemp, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR));
        if (SUCCEEDED(hr))
        {
            time->vt = VT_BSTR;
            time->bstrVal = SysAllocString(bstrTemp.bstrVal);
        }
        else
        {
            time->vt = VT_R4;
            time->fltVal = fTemp.fltVal;
        }
        VariantClear(&fTemp);
        SysFreeString(bstrTemp.bstrVal);
        VariantClear(&bstrTemp);
    }
    else
    {
        V_VT(time) = VT_BSTR;
        V_BSTR(time) = SysAllocString(WZ_INDEFINITE);
    }

    hr = S_OK;
done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_repeatDur(VARIANT time)
{
    HRESULT hr = E_FAIL;

    m_FARepeatDur.Reset(static_cast<float>(DEFAULT_M_REPEATDUR));

    if(V_VT(&time) != VT_NULL)
    {
        CTIMEParser pParser(&time);

        double dblTemp = DEFAULT_M_REPEATDUR;
        hr = THR(pParser.ParseRepeatDur(dblTemp));
        if (S_OK == hr)
        {
            if (dblTemp < 0.0)
            {
                // don't want to pass negative values to the timing engine.
                IGNORE_HR(ReportInvalidArg(WZ_REPEATDUR, time));
            }
            else
            {
                m_FARepeatDur.SetValue((float) dblTemp);
            }
        }
    }

    hr = S_OK;
  done:
    // We always reset the attribute, so we should always call UpdateMMAPI
    IGNORE_HR(UpdateMMAPI(false, false));

    NotifyPropertyChanged(DISPID_TIMEELEMENT_REPEATDUR);
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::base_get_accelerate(VARIANT * v)
{
    HRESULT hr;

    CHECK_RETURN_NULL(v);

    hr = THR(VariantClear(v));
    if (FAILED(hr))
    {
        goto done;
    }

    V_VT(v) = VT_R4;
    V_R4(v) = m_FAAccelerate;

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_accelerate(VARIANT v)
{
    HRESULT hr = S_OK;
    double e;

    m_FAAccelerate.Reset(DEFAULT_M_ACCELERATE);

    CTIMEParser pParser(&v);
            
    hr = pParser.ParseNumber(e);
    if (FAILED(hr))
    {
        hr = S_FALSE;
        goto done;
    }
    
    if (e < 0.0 || e > 1.0)
    {
        IGNORE_HR(ReportInvalidArg(WZ_ACCELERATE, v));
        goto done;
    }
    
    m_FAAccelerate.SetValue((float) e);

    hr = S_OK;
  done:
    // We always reset the attribute, so we should always call UpdateMMAPI
    IGNORE_HR(UpdateMMAPI(false, false));
    
    NotifyPropertyChanged(DISPID_TIMEELEMENT_ACCELERATE);
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::base_get_decelerate(VARIANT * v)
{
    HRESULT hr;

    CHECK_RETURN_NULL(v);

    hr = THR(VariantClear(v));
    if (FAILED(hr))
    {
        goto done;
    }

    V_VT(v) = VT_R4;
    V_R4(v) = m_FADecelerate;

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_decelerate(VARIANT v)
{
    HRESULT hr = S_OK;
    double e;
    
    m_FADecelerate.Reset(DEFAULT_M_DECELERATE);

    CTIMEParser pParser(&v);
            
    hr = pParser.ParseNumber(e);
    if (FAILED(hr))
    {
        hr = S_FALSE;
        goto done;
    }
    
    if (e < 0.0 || e > 1.0)
    {
        IGNORE_HR(ReportInvalidArg(WZ_DECELERATE, v));
        goto done;
    }
    
    m_FADecelerate.SetValue((float) e);
    
    hr = S_OK;
  done:
    // We always reset the attribute, so we should always call UpdateMMAPI
    IGNORE_HR(UpdateMMAPI(false, false));

    NotifyPropertyChanged(DISPID_TIMEELEMENT_DECELERATE);
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::base_get_autoReverse(VARIANT * b)
{
    CHECK_RETURN_NULL(b);

    VariantInit(b);
    b->vt = VT_BOOL;
    b->boolVal = m_BAAutoReverse?VARIANT_TRUE:VARIANT_FALSE;

    return S_OK;
}

HRESULT
CTIMEElementBase::base_put_autoReverse(VARIANT b)
{
    HRESULT hr;
    bool fTemp = false;
    if (b.vt != VT_BOOL)
    {
        CTIMEParser pParser(&b);
        hr = pParser.ParseBoolean(fTemp);
        if (FAILED(hr))
        {
            hr = S_OK;
            goto done;
        }
    }
    else
    {
        fTemp = b.boolVal?true:false;
    }

    m_BAAutoReverse.SetValue(fTemp);

    hr = S_OK;

  done:
    // We always set the attribute, so we should always call UpdateMMAPI
    IGNORE_HR(UpdateMMAPI(false, false));

    NotifyPropertyChanged(DISPID_TIMEELEMENT_AUTOREVERSE);
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::base_get_speed(VARIANT * f)
{
    CHECK_RETURN_NULL(f);

    VariantInit(f);
    f->vt = VT_R4;
    f->fltVal = m_FASpeed;

    return S_OK;
}

HRESULT
CTIMEElementBase::base_put_speed(VARIANT f)
{
    HRESULT hr = S_OK;
    float fltSpeed = 0.0;

    m_FASpeed.Reset(DEFAULT_M_FLTSPEED);    
    if (f.vt != VT_R4)
    {
        double dblTemp = 0.0;
        CTIMEParser pParser(&f);
        hr = pParser.ParseNumber(dblTemp, true);
        if (FAILED(hr))
        {
            hr = S_OK;
            IGNORE_HR(ReportInvalidArg(WZ_SPEED, f));
            goto done;
        }
        fltSpeed = (float)dblTemp;
    }
    else
    {
        fltSpeed = f.fltVal;
    }

    if (fltSpeed == 0.0f)
    {
        IGNORE_HR(ReportInvalidArg(WZ_SPEED, f));
        goto done;
    }
    
    m_FASpeed.SetValue(fltSpeed);

    hr = S_OK;
  done:
    // We always reset the attribute, so we should always call UpdateMMAPI
    IGNORE_HR(UpdateMMAPI(false, false));

    NotifyPropertyChanged(DISPID_TIMEELEMENT_SPEED);
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::base_get_fill (BSTR *pbstrFill)
{
    HRESULT hr;

    CHECK_RETURN_NULL(pbstrFill);

    *pbstrFill = ::SysAllocString(TokenToString(m_TAFill));

    hr = S_OK;
done:
    RRETURN(hr);
} // base_get_fill

HRESULT
CTIMEElementBase::base_put_fill (BSTR bstrFill)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase::(%p)::base_put_fill(%ls)",
              this,
              bstrFill));

    HRESULT hr;

    m_TAFill.Reset(DEFAULT_M_FILL);

    if (bstrFill != NULL)
    {
        TOKEN tokFillVal;
        CTIMEParser pParser(bstrFill);

        hr = THR(pParser.ParseFill(tokFillVal));
        if (S_OK == hr)
        {
            m_TAFill.SetValue(tokFillVal);
        }
    }

    hr = S_OK;

  done:
    // We always reset the attribute, so we should always call UpdateMMAPI
    IGNORE_HR(UpdateMMAPI(false, false));
    UpdateTimeAction();

    NotifyPropertyChanged(DISPID_TIMEELEMENT_FILL);
    RRETURN(hr);
} // base_put_fill

HRESULT
CTIMEElementBase::base_get_restart (LPOLESTR *pRestart)
{
    HRESULT hr;

    CHECK_RETURN_NULL(pRestart);

    *pRestart = ::SysAllocString(TokenToString(m_TARestart));

    hr = S_OK;
  done:
    RRETURN(hr);
} // base_get_restart

HRESULT
CTIMEElementBase::base_put_restart(LPOLESTR pRestart)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase::(%p)::base_put_restart(%ls)",
              this,
              pRestart));

    HRESULT hr;

    m_TARestart.Reset(DEFAULT_M_RESTART);

    if (pRestart != NULL)
    {
        TOKEN tokRestartVal;
        CTIMEParser pParser(pRestart);

        hr = THR(pParser.ParseRestart(tokRestartVal));

        if (S_OK == hr)
        {
            m_TARestart.SetValue(tokRestartVal);
        }
    }

    hr = S_OK;

  done:
    // We always reset the attribute, so we should always call UpdateMMAPI
    IGNORE_HR(UpdateMMAPI(false, false));

    NotifyPropertyChanged(DISPID_TIMEELEMENT_RESTART);
    RRETURN(hr);
} // base_put_restart


HRESULT
CTIMEElementBase::base_get_timeAction(BSTR * pbstrTimeAction)
{
    CHECK_RETURN_NULL(pbstrTimeAction);

    *pbstrTimeAction = SysAllocString(m_SATimeAction.GetValue());
    RRETURN(S_OK);
}


HRESULT
CTIMEElementBase::base_put_timeAction(BSTR bstrTimeAction)
{
    HRESULT hr;
    LPOLESTR pstrTimeAction = NULL;

    // reset the attribute
    delete [] m_SATimeAction.GetValue();
    m_SATimeAction.Reset(NULL);

    // ISSUE: dilipk: this should be delayed till all of persistence is complete (for timeContainer)
    // also should use the parser here

    pstrTimeAction = TrimCopyString(bstrTimeAction);
    if (!pstrTimeAction)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
  
    // delegate to helper
    hr = m_timeAction.SetTimeAction(pstrTimeAction);
    if (FAILED(hr))
    {
        // fire error event
        CComVariant svarTimeAction(bstrTimeAction);
        ReportInvalidArg(WZ_TIMEACTION, svarTimeAction);
        goto done;
    }

    // update the timeAction
    UpdateTimeAction();

    // Update the attribute
    m_SATimeAction.SetValue(pstrTimeAction);

    hr = S_OK;
  done:
    NotifyPropertyChanged(DISPID_TIMEELEMENT_TIMEACTION);

    RRETURN(hr);
}

HRESULT
CTIMEElementBase::base_get_timeContainer(LPOLESTR * pbstrTimeLine)
{
    HRESULT hr = S_OK;
    CHECK_RETURN_NULL(pbstrTimeLine);
    LPWSTR wszTimelineString = WZ_NONE;

    switch(m_TTATimeContainer)
    {
      case ttPar :
        wszTimelineString = WZ_PAR;
        break;
      case ttExcl:
        wszTimelineString = WZ_EXCL;
        break;
      case ttSeq :
        wszTimelineString = WZ_SEQUENCE;
        break;
      default:
        wszTimelineString = WZ_NONE;
    }

    *pbstrTimeLine = SysAllocString(wszTimelineString);
    if (NULL == *pbstrTimeLine)
        hr = E_OUTOFMEMORY;

    return hr;
} // base_get_timeContainer


// Note this is a DOM-read-only property. It can only be set through persistence.
HRESULT
CTIMEElementBase::base_put_timeContainer(LPOLESTR bstrNewTimeline)
{
    HRESULT      hr = S_OK;
    BSTR         bstrTagName = NULL;
    TimelineType newTimelineType = ttNone;
    TimelineType oldTimelineType = m_TTATimeContainer.GetValue();

    CHECK_RETURN_NULL(bstrNewTimeline);

    if (m_TTATimeContainer.IsSet() == false && m_TTATimeContainer != ttUninitialized && !IsBody())
    {
        goto done;
    }
    
    // Bail if property is being dynamically changed. It can only be set through persistence.
    // Just being defensive here (property is read-only in the IDL) since bad things 
    // can happen if this property is changed outside of persistence.
    if (m_fTimelineInitialized)
    {
        hr = E_FAIL;
        goto done;
    }
    
    // Parse the property
    {
        CTIMEParser pParser(bstrNewTimeline);
        
        hr = THR(pParser.ParseTimeLine(newTimelineType));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    //
    // Check for early exit
    //

    // Bail if old and new value are same
    if (oldTimelineType == newTimelineType)
    {
        hr = S_OK;
        goto done;
    }
    // Bail if TagName is invalid
    hr = THR(GetElement()->get_tagName(&bstrTagName));
    if (FAILED(hr))
    {
        goto done;
    }
    if (StrCmpIW(bstrTagName, WZ_PAR) == 0 || 
        StrCmpIW(bstrTagName, WZ_SEQUENCE) == 0 || 
        StrCmpIW(bstrTagName, WZ_EXCL) == 0)
    {
        hr = E_FAIL;
        goto done;
    }

    m_TTATimeContainer.Reset(ttUninitialized);
    // Store the new attribute value
    m_TTATimeContainer.SetValue(newTimelineType);

    hr = CreateActiveEleCollection();
    if (FAILED(hr))
    {   
        goto done;
    }   


    hr = S_OK;
done:
    SysFreeString(bstrTagName);
    NotifyPropertyChanged(DISPID_TIMEELEMENT_TIMECONTAINER);
    RRETURN(hr);
} // base_put_timeContainer

HRESULT
CTIMEElementBase::base_get_syncBehavior(LPOLESTR * ppstrSync)
{
    HRESULT hr;
    
    CHECK_RETURN_SET_NULL(ppstrSync);

    if (DEFAULT_M_SYNCBEHAVIOR == m_TASyncBehavior.GetValue())
    {
        *ppstrSync = SysAllocString(TokenToString(CANSLIP_TOKEN));
    }
    else
    {
        *ppstrSync = SysAllocString(TokenToString(m_TASyncBehavior.GetValue()));
    }

    if (*ppstrSync == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    
    hr = S_OK;
done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_syncBehavior(LPOLESTR pstrSync)
{
    HRESULT hr;

    m_TASyncBehavior.Reset(NULL);

    {
        TOKEN tok_sync;
        CTIMEParser pParser(pstrSync);
        
        hr = THR(pParser.ParseSyncBehavior(tok_sync));
        if (S_OK == hr)
        {
            m_TASyncBehavior.SetValue(tok_sync);
        }
    }
    
    hr = S_OK;

  done:
    // We always reset the attribute, so we should always call UpdateMMAPI
    IGNORE_HR(UpdateMMAPI(false, false));

    NotifyPropertyChanged(DISPID_TIMEELEMENT_SYNCBEHAVIOR);
    RRETURN(hr);
}


HRESULT
CTIMEElementBase::base_get_syncTolerance(VARIANT * time)
{
    HRESULT hr;
    CComVariant varTemp;
    CHECK_RETURN_NULL(time);

    hr = THR(VariantClear(time));
    if (FAILED(hr))
    {
        goto done;
    }
    
    V_VT(&varTemp) = VT_R4;
    V_R4(&varTemp)= m_FASyncTolerance.GetValue();

    hr = THR(VariantChangeTypeEx(&varTemp, &varTemp, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR));
    if (SUCCEEDED(hr))
    {
        hr = ::VariantCopy(time, &varTemp);
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else
    {
        V_VT(time) = VT_R4;
        V_R4(time) = m_FASyncTolerance.GetValue();
    }

    hr = S_OK;
done:
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::base_put_syncTolerance(VARIANT time)
{
    HRESULT hr = S_OK;
    double dblTemp;

    m_FASyncTolerance.Reset((float)valueNotSet);

    CTIMEParser pParser(&time);
        
    hr = THR(pParser.ParseClockValue(dblTemp));
    if (S_OK == hr)
    {
        m_FASyncTolerance.SetValue((float) dblTemp);
    }

    hr = S_OK;

  done:
    // We always reset the attribute, so we should always call UpdateMMAPI
    IGNORE_HR(UpdateMMAPI(false, false));

    NotifyPropertyChanged(DISPID_TIMEELEMENT_SYNCTOLERANCE);
    RRETURN(hr);
}


HRESULT 
CTIMEElementBase::base_get_volume(VARIANT * vVal)
{
    CHECK_RETURN_NULL(vVal);

    VariantInit(vVal);
    vVal->vt = VT_R4;
    vVal->fltVal = m_FAVolume * 100;

    return S_OK;
}


HRESULT 
CTIMEElementBase::base_put_volume(VARIANT vVal)
{
    HRESULT hr = S_OK;
    float fltVol = 0.0;

    m_FAVolume.Reset(DEFAULT_M_FLVOLUME);
    if (vVal.vt != VT_R4)
    {
        double dblTemp = 0.0;
        CTIMEParser pParser(&vVal);
        hr = pParser.ParseNumber(dblTemp, true);
        if (FAILED(hr))
        {
            hr = S_OK;
            IGNORE_HR(ReportInvalidArg(WZ_VOLUME, vVal));
            goto done;
        }
        fltVol = (float)dblTemp;
    }
    else
    {
        fltVol = vVal.fltVal;
    }

    if (fltVol < 0.0f || fltVol > 100.0f)
    {
        IGNORE_HR(ReportInvalidArg(WZ_VOLUME, vVal));
        goto done;
    }
    
    fltVol = fltVol / 100.0f;
    m_FAVolume.SetValue(fltVol);

    hr = S_OK;
  done:
    // We always reset the attribute, so we should always call CascadedPropertyChanged
    IGNORE_HR(CascadedPropertyChanged(true));

    NotifyPropertyChanged(DISPID_TIMEELEMENT_VOLUME);
    return hr;
}

    
HRESULT 
CTIMEElementBase::base_get_mute(VARIANT * pvbVal)
{
    CHECK_RETURN_NULL(pvbVal);

    VariantInit(pvbVal);
    pvbVal->vt = VT_BOOL;
    pvbVal->boolVal = m_BAMute ? VARIANT_TRUE : VARIANT_FALSE;

    return S_OK;
}


HRESULT 
CTIMEElementBase::base_put_mute(VARIANT vbVal)
{
    HRESULT hr;
    bool fTemp = false;    

    if (vbVal.vt != VT_BOOL)
    {
        CTIMEParser pParser(&vbVal);
        hr = pParser.ParseBoolean(fTemp);
        if (FAILED(hr))
        {
            hr = S_OK;
            goto done;
        }
    }
    else
    {
        fTemp = vbVal.boolVal?true:false;
    }
        
    m_BAMute.SetValue(fTemp);

    hr = S_OK;
done:
    // We always set the attribute, so we should always call CascadedPropertyChanged
    hr = THR(CascadedPropertyChanged(true));

    NotifyPropertyChanged(DISPID_TIMEELEMENT_MUTE);
    return hr;
}

HRESULT
CTIMEElementBase::base_pauseElement()
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::base_pauseElement()",
              this));

    HRESULT hr;
    
    if (!IsReady())
    {
        hr = S_OK;
        goto done;
    }
    
    hr = THR(m_mmbvr->Pause());
    if (FAILED(hr))
    {
        goto done;
    } 

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::base_resumeElement()
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::base_resumeElement()",
              this));

    HRESULT hr;
    
    if (!IsReady())
    {
        hr = S_OK;
        goto done;
    }
    
    hr = THR(m_mmbvr->Resume());
    if (FAILED(hr))
    {
        goto done;
    } 

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::base_resetElement()
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::base_resetElement()",
              this));

    HRESULT hr;
    
    if (!IsReady())
    {
        hr = S_OK;
        goto done;
    }
    
    hr = THR(m_mmbvr->Reset(false));
    if (FAILED(hr))
    {
        goto done;
    } 

    hr = S_OK;
  done:
    RRETURN(hr);
}

//
// Update animation on seek if we are in edit mode since the timer is disabled. 
// Taking the conservative approach of detecting
// seeks at the seek methods instead of responding to the seek event.
void            
CTIMEElementBase::HandleAnimationSeek()
{
    if (IsDocumentInEditMode())
    {
        CTIMEBodyElement * pBody = GetBody();

        if (pBody)
        {
            // need to update twice to account for time boundaries
            pBody->UpdateAnimations();
            pBody->UpdateAnimations();
        }
    }
}


HRESULT
CTIMEElementBase::base_seekSegmentTime(double segmentTime)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::base_seekSegmentTime(%g)",
              this,
              segmentTime));
 
    HRESULT hr;
    
    if (!IsReady())
    {
        hr = S_OK;
        goto done;
    }
    
    hr = THR(m_mmbvr->SeekSegmentTime(segmentTime));
    if (FAILED(hr))
    {
        goto done;
    } 

    // tick animations
    HandleAnimationSeek();

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::base_seekActiveTime(double activeTime)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::base_seekActiveTime(%g)",
              this,
              activeTime));
 
    HRESULT hr;

    if (!IsReady() || !IsActive())
    {
        hr = S_OK;
        goto done;
    }
    
    hr = THR(m_mmbvr->SeekActiveTime(activeTime));
    if (FAILED(hr))
    {
        goto done;
    } 

    // tick animations
    HandleAnimationSeek();

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::base_seekTo(LONG lRepeatCount,
                              double segmentTime)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::base_seekSegmentTime(%ld, %g)",
              this,
              lRepeatCount,
              segmentTime));
 
    HRESULT hr;

    if (!IsReady())
    {
        hr = S_OK;
        goto done;
    }
    
    hr = THR(m_mmbvr->SeekTo(lRepeatCount, segmentTime));
    if (FAILED(hr))
    {
        goto done;
    } 

    // tick animations
    HandleAnimationSeek();

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::base_beginElement(double dblOffset)
{
    HRESULT hr;

    if (!IsReady())
    {
        hr = S_OK;
        goto done;
    }

    if (GetParent() && GetParent()->IsSequence())
    {
        hr = S_OK;
        goto done;
    }

    hr =THR(BeginElement(dblOffset));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::base_endElement(double dblOffset)
{
    HRESULT hr;

    if (!IsReady())
    {
        hr = S_OK;
        goto done;
    }
    
    hr = THR(m_mmbvr->End(dblOffset));
    if (FAILED(hr))
    {
        goto done;
    } 
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::base_nextElement()
{
    HRESULT hr;

    if (IsSequence())
    {
        if (m_timeline)
        {
            hr = m_timeline->nextElement();
            if (FAILED(hr))
            {
                goto done;
            }
        }
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::base_prevElement()
{
    HRESULT hr;

    if (IsSequence())
    {
        if (m_timeline)
        {
            hr = m_timeline->prevElement();
            if (FAILED(hr))
            {
                goto done;
            }
        }
    }
    hr = S_OK;

  done:
    RRETURN(hr);
}

//+-----------------------------------------------------------------------------
//
//  Member:     CTIMEElementBase::base_get_currTimeState
//
//  Synopsis:   Returns currTimeState object for this element
//
//  Arguments:  out param
//
//  Returns:    S_OK, E_POINTER, E_OUTOFMEMORY
//
//------------------------------------------------------------------------------------
HRESULT 
CTIMEElementBase::base_get_currTimeState(ITIMEState ** ppTimeState) 
{
    HRESULT hr;

    CHECK_RETURN_SET_NULL(ppTimeState);

    //
    // Do lazy creation of currTimeState object
    //

    if (!m_pCurrTimeState)
    {
        CComObject<CTIMECurrTimeState> * pTimeState = NULL;

        hr = THR(CComObject<CTIMECurrTimeState>::CreateInstance(&pTimeState));
        if (FAILED(hr))
        {
            goto done;
        }

        // cache a pointer to the timeState object
        m_pCurrTimeState = static_cast<CTIMECurrTimeState*>(pTimeState);

        // Init the currTimeState object
        m_pCurrTimeState->Init(this);
    }

    // Return the dispatch
    hr = THR(m_pCurrTimeState->QueryInterface(IID_TO_PPV(ITIMEState, ppTimeState)));
    if (FAILED(hr))
    {
        // This should not happen
        Assert(false);
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
} // base_get_currTimeState


HRESULT 
CTIMEElementBase::base_get_activeElements(ITIMEActiveElementCollection **ppDisp)
{

    HRESULT hr = S_OK;
    if (ppDisp == NULL)
    {
        TraceTag((tagError, "CTIMEElementBase::base_get_activeElements - invalid arg"));
        hr = E_POINTER;
        goto done;
    }
    
    *ppDisp = NULL;

    if (m_activeElementCollection)
    {
        hr = THR(m_activeElementCollection->QueryInterface(IID_ITIMEActiveElementCollection, (void**)ppDisp));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;

  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_get_hasMedia(/*[out, retval]*/ VARIANT_BOOL * pvbVal)
{
    CHECK_RETURN_NULL(pvbVal);

    *pvbVal = (ContainsMediaElement() ? VARIANT_TRUE : VARIANT_FALSE);

    return S_OK;
}


HRESULT
CTIMEElementBase::base_get_timeAll(ITIMEElementCollection **allColl)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase::base_get_timeAll"));

    HRESULT hr;

    CHECK_RETURN_SET_NULL(allColl);

    hr = THR(GetCollection(ciAllElements, allColl));
    if (FAILED(hr))
    {
        goto done;
    } 

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::base_get_timeChildren(ITIMEElementCollection **childColl)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase::base_get_timeChildren"));

    HRESULT hr;

    CHECK_RETURN_SET_NULL(childColl);

    hr = THR(GetCollection(ciChildrenElements, childColl));
    if (FAILED(hr))
    {
        goto done;
    } 

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::base_get_timeParent(ITIMEElement **ppElm)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase::base_get_timeParent"));

    HRESULT hr;

    CHECK_RETURN_SET_NULL(ppElm);

    if (m_pTIMEParent != NULL)
    {
        hr = THR(m_pTIMEParent->QueryInterface(IID_ITIMEElement, (void**)ppElm));
        if (FAILED(hr))
        {
            goto done;
        } 
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

//+-----------------------------------------------------------------------------
//
//  Member:     CTIMEElementBase::base_get_isPaused
//
//  Synopsis:   Call through to timing engine
//
//  Arguments:  out param
//
//  Returns:    S_OK, E_POINTER
//
//------------------------------------------------------------------------------
HRESULT
CTIMEElementBase::base_get_isPaused(VARIANT_BOOL * b)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase::base_get_isPaused"));

    HRESULT hr;

    CHECK_RETURN_NULL(b);

    *b = IsPaused() ? VARIANT_TRUE : VARIANT_FALSE;

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::base_get_syncMaster(VARIANT *pfSyncMaster)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase::base_get_syncMaster"));

    HRESULT hr;

    CHECK_RETURN_NULL(pfSyncMaster);

    VariantInit(pfSyncMaster);
    pfSyncMaster->vt = VT_BOOL;
    pfSyncMaster->boolVal = m_BASyncMaster ? VARIANT_TRUE : VARIANT_FALSE;

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT 
CTIMEElementBase::ClearCachedSyncMaster()
{
    HRESULT hr = S_OK;

    if (m_fCachedSyncMaster != m_BASyncMaster)
    {
        m_fCachedSyncMaster = m_BASyncMaster;

        hr = THR(m_mmbvr->Update(false, false));
        if (FAILED(hr))
        {
            goto done;
        }
    }

  done:
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::PutCachedSyncMaster(bool fSyncMaster)
{
    HRESULT hr = S_OK;
    m_fCachedSyncMaster = fSyncMaster;

    if (!IsReady())
    {
        hr = S_OK;
        goto done;
    }

    SetSyncMaster(fSyncMaster);
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_syncMaster(VARIANT vSyncMaster)
{
    TraceTag((tagTimeElmBase,
              "CTIMEMediaElement::base_put_syncMaster"));
    HRESULT hr;
    bool fTemp = false;
    CTIMEElementBase *syncRootNode = NULL;
    std::list<CTIMEElementBase*> syncList;
    std::list<CTIMEElementBase*>::iterator iter;
    bool fFound = false;

    if (vSyncMaster.vt != VT_BOOL)
    {

        CTIMEParser pParser(&vSyncMaster);

        hr = pParser.ParseBoolean(fTemp);
        if (FAILED(hr))
        {
            hr = S_OK;
            goto done;
        }
    }
    else
    {
        fTemp = vSyncMaster.boolVal?true:false;
    }

    if(!IsReady()) //set the persisted value only when loading the page.
    {
        m_BASyncMaster.SetValue(fTemp);
    }

    if(!IsMedia() || !IsReady())
    {
        hr = S_OK;
        goto done;
    }
    
    syncRootNode = FindLockedParent();
    if(syncRootNode == NULL)
    {
        hr = S_OK;
        goto done;
    }
    syncRootNode->GetSyncMasterList(syncList);
    if(fTemp)
    {
        for (iter = syncList.begin();iter != syncList.end(); iter++)
        {
            if((*iter)->IsSyncMaster())
            {
                (*iter)->SetSyncMaster(false);
            }
        }
        SetSyncMaster(true);
    }
    else
    {
        SetSyncMaster(false);
        if(syncList.size() >= 1)
        {
            for (iter = syncList.begin();iter != syncList.end(); iter++)
            {
                if((*iter)->m_BASyncMaster && ((*iter) != this))
                {
                    (*iter)->SetSyncMaster(true);
                    fFound = true;
                    break;
                }
            }
            if(!fFound)
            {
                for (iter = syncList.begin();iter != syncList.end(); iter++)
                {
                    if((*iter) != this)
                    {
                        (*iter)->SetSyncMaster(true);
                        fFound = true;
                        break;
                    }
                }
            }

        }
    }


    hr = S_OK;
  done:
    NotifyPropertyChanged(DISPID_TIMEELEMENT_SYNCMASTER);
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::base_documentTimeToParentTime(double documentTime,
                                                double * parentTime)
{
    TraceTag((tagTimeElmBase,
              "CTIMEMediaElement::base_documentTimeToParentTime(%g)",
              documentTime));

    HRESULT hr;
    
    CHECK_RETURN_NULL(parentTime);

    if (!IsReady())
    {
        *parentTime = TIME_INFINITE;
        hr = S_OK;
        goto done;
    }
    
    *parentTime = m_mmbvr->DocumentTimeToParentTime(documentTime);
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::base_parentTimeToDocumentTime(double parentTime,
                                                double * documentTime)
{
    TraceTag((tagTimeElmBase,
              "CTIMEMediaElement::base_parentTimeToDocumentTime(%g)",
              parentTime));

    HRESULT hr;
    
    CHECK_RETURN_NULL(documentTime);

    if (!IsReady())
    {
        *documentTime = TIME_INFINITE;
        hr = S_OK;
        goto done;
    }
    
    *documentTime = m_mmbvr->ParentTimeToDocumentTime(parentTime);
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

        
HRESULT
CTIMEElementBase::base_parentTimeToActiveTime(double parentTime,
                                              double * activeTime)
{
    TraceTag((tagTimeElmBase,
              "CTIMEMediaElement::base_parentTimeToActiveTime(%g)",
              parentTime));

    HRESULT hr;
    
    CHECK_RETURN_NULL(activeTime);

    if (!IsReady())
    {
        *activeTime = TIME_INFINITE;
        hr = S_OK;
        goto done;
    }
    
    *activeTime = m_mmbvr->ParentTimeToActiveTime(parentTime);
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

        
HRESULT
CTIMEElementBase::base_activeTimeToParentTime(double activeTime,
                                              double * parentTime)
{
    TraceTag((tagTimeElmBase,
              "CTIMEMediaElement::base_activeTimeToParentTime(%g)",
              activeTime));

    HRESULT hr;
    
    CHECK_RETURN_NULL(parentTime);

    if (!IsReady())
    {
        *parentTime = TIME_INFINITE;
        hr = S_OK;
        goto done;
    }
    
    *parentTime = m_mmbvr->ActiveTimeToParentTime(activeTime);
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

        
HRESULT
CTIMEElementBase::base_activeTimeToSegmentTime(double activeTime,
                                               double * segmentTime)
{
    TraceTag((tagTimeElmBase,
              "CTIMEMediaElement::base_activeTimeToSegmentTime(%g)",
              activeTime));

    HRESULT hr;
    
    CHECK_RETURN_NULL(segmentTime);

    if (!IsReady())
    {
        *segmentTime = TIME_INFINITE;
        hr = S_OK;
        goto done;
    }
    
    *segmentTime = m_mmbvr->ActiveTimeToSegmentTime(activeTime);
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

        
HRESULT
CTIMEElementBase::base_segmentTimeToActiveTime(double segmentTime,
                                               double * activeTime)
{
    TraceTag((tagTimeElmBase,
              "CTIMEMediaElement::base_segmentTimeToActiveTime(%g)",
              segmentTime));

    HRESULT hr;
    
    CHECK_RETURN_NULL(activeTime);

    if (!IsReady())
    {
        *activeTime = TIME_INFINITE;
        hr = S_OK;
        goto done;
    }
    
    *activeTime = m_mmbvr->SegmentTimeToActiveTime(segmentTime);
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

        
HRESULT
CTIMEElementBase::base_segmentTimeToSimpleTime(double segmentTime,
                                               double * simpleTime)
{
    TraceTag((tagTimeElmBase,
              "CTIMEMediaElement::base_segmentTimeToSimpleTime(%g)",
              segmentTime));

    HRESULT hr;
    
    CHECK_RETURN_NULL(simpleTime);

    if (!IsReady())
    {
        *simpleTime = TIME_INFINITE;
        hr = S_OK;
        goto done;
    }
    
    *simpleTime = m_mmbvr->SegmentTimeToSimpleTime(segmentTime);
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

        
HRESULT
CTIMEElementBase::base_simpleTimeToSegmentTime(double simpleTime,
                                               double * segmentTime)
{
    TraceTag((tagTimeElmBase,
              "CTIMEMediaElement::base_simpleTimeToSegmentTime(%g)",
              simpleTime));

    HRESULT hr;
    
    CHECK_RETURN_NULL(segmentTime);

    if (!IsReady())
    {
        *segmentTime = TIME_INFINITE;
        hr = S_OK;
        goto done;
    }
    
    *segmentTime = m_mmbvr->SimpleTimeToSegmentTime(simpleTime);
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT 
CTIMEElementBase::BeginElement(double dblOffset)
{
    HRESULT hr;

    m_mmbvr->Resume();
    
    hr = THR(m_mmbvr->Begin(dblOffset));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}
    

HRESULT
CTIMEElementBase::AddTIMEElement(CTIMEElementBase *elm)
{
    HRESULT hr = S_OK;

    elm->AddRef(); // add refing for m_pTIMEChildren
 
    hr = THR(m_pTIMEChildren.Append(elm));
    if (FAILED(hr))
    {
        goto done;
    }

    NotifyPropertyChanged(DISPID_TIMEELEMENT_TIMECHILDREN);

done:
    return hr;
}

HRESULT
CTIMEElementBase::RemoveTIMEElement(CTIMEElementBase *elm)
{
    HRESULT hr = S_OK;

    bool bFound = m_pTIMEChildren.DeleteByValue(elm);
    if (!bFound)
    {
        // no real error returned.  should fix up the array code...
        goto done;
    }

    IGNORE_HR(m_pTIMEZombiChildren.Append(elm));

    NotifyPropertyChanged(DISPID_TIMEELEMENT_TIMECHILDREN);

done:
    return hr;
}

//*****************************************************************************
// method:   ReparentChildren()
//
// abstract: this method walks down an HTML tree, reparenting children that
//           have TIME behaviors to this TIME element.
//           Note:  if we find a TIME element that is a group, we need to stop.
//*****************************************************************************
HRESULT
CTIMEElementBase::ReparentChildren(ITIMEElement *pTIMEParent, IHTMLElement *pElem)
{
    CComPtr<IDispatch>               pChildrenDisp;
    CComPtr<IHTMLElementCollection>  pChildrenCollection;
    VARIANT varName;
    VARIANT varIndex;
    HRESULT hr;
    long    lChildren = 0;
    long    i;

    if (pElem == NULL)
    {
        hr = E_FAIL;
        Assert(false && "CTIMEElementBase::ReparentChildren was passed a NULL!");
        goto done;
    }

    // get pointer to children
    hr = THR(pElem->get_children(&pChildrenDisp));
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(pChildrenDisp.p != NULL);

    // move to collection interface
    hr = THR(pChildrenDisp->QueryInterface(IID_IHTMLElementCollection, (void**)&pChildrenCollection));
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(pChildrenCollection.p != NULL);

    // get length
    hr = THR(pChildrenCollection->get_length(&lChildren));
    if (FAILED(hr))
    {
        goto done;     
    }

    // Variants for IHTMLElementCollection->item() call.
    // NOTE: we are using first Variant as an index.  The second variant
    //       is along for the ride.  The second variant only comes into play
    //       when you use the first variant as a name and multiple names exist.
    //       Then, the second can act as a index.
    VariantInit(&varName);
    varName.vt = VT_I4;
    varName.lVal = 0;

    VariantInit(&varIndex);

    // loop thru children
    for (i = 0; i < lChildren; i++)
    {
        CComPtr<IDispatch>       pChildDisp;
        CComPtr<ITIMEElement>    pTIMEElem;
        CComPtr<IHTMLElement>    pChildElement;
        CTIMEElementBase *pTempTEB = NULL;

        varName.lVal = i;

        // get indexed child
        hr = THR(pChildrenCollection->item(varName, varIndex, &pChildDisp));
        if (FAILED(hr))
        {
            goto done;
        }

        Assert(pChildDisp.p != NULL);

        // get IHTMLElement
        hr = THR(pChildDisp->QueryInterface(IID_IHTMLElement, (void**)&pChildElement));
        if (FAILED(hr))
        {
            goto done;
        }
        
        // Is there a TIME behavior on this element
        pTIMEElem = NULL;
        hr = FindBehaviorInterface(GetBehaviorName(),
                                   pChildElement,
                                   IID_ITIMEElement,
                                   (void**)&pTIMEElem);
        if (SUCCEEDED(hr))
        {
            Assert(pTIMEElem.p != NULL);
            pTempTEB = GetTIMEElementBase(pTIMEElem);
            
            Assert(pTempTEB != NULL);

            // set parent.  do not set children
            hr = pTempTEB->SetParent(pTIMEParent, false);
            if (FAILED(hr))
            {
                goto done;
            }
        }

        // if NO TIME was found or the TIME element is not a group
        // continue walking down the tree
        if ( (pTIMEElem.p == NULL) || 
             ((pTempTEB != NULL) && !pTempTEB->IsGroup()) )
        {
            hr = ReparentChildren(pTIMEParent, pChildElement);
            if (FAILED(hr))
            {
                goto done;
            }
        }
    } // for loop

    hr = S_OK;
done:
    return hr;
}

//*****************************************************************************
// method:   UnparentElement()
//
// abstract: this is a centralized method that knows how to detach a TIME element
//           from it's parent (if it has one).  There only two cases when this is
//           called.  Either you are shutting down (ie ::detach()) or you are being
//           reparented (ie SetParent() with new parent).
//*****************************************************************************
HRESULT
CTIMEElementBase::UnparentElement()
{
    HRESULT hr;

    // stop timeline
    if (m_bStarted)
    {
        MMTimeline * tl = NULL;
        if (m_pTIMEParent != NULL)
            tl = m_pTIMEParent->GetMMTimeline();
        StopRootTime(tl);
    }

    if (m_pTIMEParent != NULL)
    {
        // if the parent is around, traverse back up, invalidating the collection cache.
        THR(InvalidateCollectionCache());
    
        // clear ourselves from our parents list
        hr = THR(m_pTIMEParent->RemoveTIMEElement(this));
        if (FAILED(hr))
        {
            goto done;
        }
    
        // these are both week references and we should NULL them since
        // we have no parent and are not associated with the inner TIME
        // heirarchy.
        m_pTIMEParent = NULL;
    }

    hr = S_OK;
done:
    return hr;
}

HRESULT
CTIMEElementBase::SetParent(ITIMEElement *pElem, bool fReparentChildren /* true */)
{
    HRESULT hr = S_OK;
    CTIMEElementBase *pTempTEB = NULL;

    // for the body return with an error
    if (IsBody())
    {
        TraceTag((tagError, "CTIMEElementBase::SetParent - error trying to parent a body element"));
        hr = E_UNEXPECTED;
        goto done;
    }

    // if we already have a parent, remove ourselves from it's child list
    if (m_pTIMEParent != NULL)
    {
        CComPtr<ITIMEElement> pParent;

        // PERF: if the parent coming in is equal to current parent, make it a nop
        // NOTE: this can never fail!
        THR(m_pTIMEParent->QueryInterface(IID_ITIMEElement, (void**)&pParent));
        if (pParent == pElem)
        {
            hr = S_OK;
            goto done;
        }

        // need to unparent element.
        hr = UnparentElement();
        if (FAILED(hr))
        {
            TraceTag((tagError, "CTIMEElementBase::SetParent(%p) - UnparentElement() failed", this));
            goto done;
        }
    }

    Assert(m_pTIMEParent == NULL);

    // if NULL was passed in, our work is done
    if (pElem == NULL)
    {
        hr = S_OK;
        goto done;
    }

    // move from the interface pointer to the class pointer
    pTempTEB = GetTIMEElementBase(pElem);
    if (pTempTEB == NULL)
    {
        TraceTag((tagError, "CTIMEElementBase::SetParent - GetTIMEElementBase() failed"));
        hr = E_INVALIDARG;
        goto done;
    }

    // add ourselves as a child
    hr = THR(pTempTEB->AddTIMEElement(this));
    if (FAILED(hr))
    {
        goto done;
    }

    // cache the parent
    // this is a weak reference
    m_pTIMEParent = pTempTEB;

    // Force an update of the default timeAction
    m_timeAction.UpdateDefaultTimeAction();
    UpdateTimeAction();

    // reparent any children of this HTML element that have children, if we
    // are a group.
    if (fReparentChildren && IsGroup())
    {
        CComPtr<ITIMEElement> pTIMEElem;

        // This should ALWAYS work
        THR(QueryInterface(IID_ITIMEElement, (void**)&pTIMEElem));
        Assert(pTIMEElem.p != NULL);
        hr = ReparentChildren(pTIMEElem, GetElement());
        if (FAILED(hr))
        {
            goto done;
        }
    }

    // Tell subtree to recalculate cascaded properties
    THR(hr = CascadedPropertyChanged(true));

    hr = S_OK;
done:
    return hr;
}

HRESULT
CTIMEElementBase::ParentElement()
{
    TraceTag((tagTimeElmBase, "CTIMEElementBase::ParentElement"));
    // Loop thru parents until one is found with TIME on it
    bool fFound = false;
    bool fBehaviorExists = false;
    CComPtr<IHTMLElement> pElem = GetElement();
    CComPtr<IHTMLElement> pElemParent = NULL;
    CComPtr<ITIMEElement> pTIMEElem = NULL;
    HRESULT hr = S_FALSE;

    Assert(!IsBody());

    // walk up the HTML tree, looking for element's with TIME behaviors on them
    while (!fFound)
    {
        CComPtr<ITIMEElement> spTIMEParent;

        hr = THR(pElem->get_parentElement(&pElemParent));
        if (FAILED(hr))
        {
            TraceTag((tagError, "CTIMEElementBase::ParentElement - get_parentElement() failed"));
            goto done;
        }

        // see if we have a parent
        // If not, this is an orphaned case
        if (pElemParent.p == NULL)
        {
            TraceTag((tagTimeElmBase, "CTIMEElementBase::ParentElement - orphaned node!!!"));
            hr = S_FALSE;
            goto done;
        }

        // see if TIME behavior exists on parent
        fBehaviorExists = false;
        hr = FindBehaviorInterface(GetBehaviorName(),
                                   pElemParent,
                                   IID_ITIMEElement,
                                   (void**)&spTIMEParent);
        if (FAILED(hr))
        {
            fBehaviorExists = false;
        }
        else
        {
            fBehaviorExists = true;
        }

        // if this element has a TIME behavior and is either a 
        // par or seq, then we have found our parent.
        if (fBehaviorExists && IsGroup(pElemParent))
        {
            fFound = true;
        }
        else
        {
            // continue walking up the tree
            pElem = pElemParent;
            pElemParent.Release();
        }
    }

    // if we found a parent with TIME, add our selves to it's children

    Assert(fFound);
    if (pElemParent.p != NULL)
    {
        // get TIME interface
        hr = FindBehaviorInterface(GetBehaviorName(),
                                   pElemParent,
                                   IID_ITIMEElement,
                                   (void**)&pTIMEElem);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CTIMEElementBase::ParentElement - FindTIMEInterface() failed"));
            goto done;
        }
        
        Assert(pTIMEElem.p != NULL);

        // set our parent
        hr = THR(SetParent(pTIMEElem));
        if (FAILED(hr))
        {
            TraceTag((tagError, "CTIMEElementBase::ParentElement - SetParent() failed"));
            goto done;
        }
        hr = S_OK;
    }

done:

    return hr;
}

HRESULT
CTIMEElementBase::StartRootTime(MMTimeline * tl)
{
    HRESULT hr = S_OK;

    if (!m_fTimelineInitialized)
    {
        goto done;
    }

    Assert(!m_bStarted);

    if (m_bIsSwitch)
    {
        SwitchInnerElements();
    }
    else
    {
        IHTMLElement *pEle = GetElement();  //do not release this pointer
        if (pEle != NULL)
        {
            CComPtr <IHTMLElement> pEleParent;
            hr = THR(pEle->get_parentElement(&pEleParent));
            if (SUCCEEDED(hr) && pEleParent != NULL)
            {
                CComBSTR bstrTagName;
                hr = THR(pEleParent->get_tagName(&bstrTagName));
                if (SUCCEEDED(hr))
                {
                    if (StrCmpIW(bstrTagName, WZ_SWITCH) != 0)
                    {
                        CComPtr <IDispatch> pDisp;
                        hr = THR(pEle->QueryInterface(IID_IDispatch, (void**)&pDisp));
                        if (SUCCEEDED(hr))
                        {
                            //bool bMatch = true;
                            bool bMatch = MatchTestAttributes(pDisp);
                            if (bMatch == false)
                            {
                                DisableElement(pDisp);
                            }
                        }
                    }
                }
            }
        }
    }

    m_bStarted = true;

    hr = THR(Update());
    if (FAILED(hr))
    {
        goto done;
    } 

    Assert(tl || m_timeline);
    Assert(NULL != m_mmbvr);

    // Need to make sure the timeline passed in
    if (tl != NULL)
    {
        hr = THR(tl->AddBehavior(*m_mmbvr));
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else
    {
        // Usually the add does the reset (automatic when a parent is
        // changed
        // However, this is the root and it does not get updated until
        // too late so update here

        hr = THR(m_mmbvr->Reset(false));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    if (GetBody() && GetBody()->IsRootStarted())
    {
        GetBody()->ElementChangeNotify(*this, ELM_ADDED);
    }
    
    // is this element a par or seq
    if (IsGroup())
    {
        CTIMEElementBase **ppElm;
        int i;
    
        for (i = m_pTIMEChildren.Size(), ppElm = m_pTIMEChildren;
             i > 0;
             i--, ppElm++)
        {
            Assert(m_timeline);
        
            hr = THR((*ppElm)->StartRootTime(m_timeline));
            if (FAILED(hr))
            {
                goto done;
            }
        }
    }
    else
    {
        // If we are not par then we should not have children
        Assert(m_pTIMEChildren.Size() == 0);
    }

    if(GetBody() != NULL)
    {
        if(IsMedia() && !IsThumbnail())
        {
            GetBody()->RegisterElementForSync(this);
        }
    }

    short i;
    CTIMEElementBase **ppElm;

    for (i = 0, ppElm = m_pTIMEChildren; i < m_pTIMEChildren.Size();i++, ppElm++)
    {
        if((*ppElm)->IsLocked() && (m_sHasSyncMMediaChild == -1))
        {
            if((*ppElm)->IsSyncMaster() || ((*ppElm)->m_sHasSyncMMediaChild != -1))
            {
                m_sHasSyncMMediaChild = i;
            }
        }
        else if((*ppElm)->IsLocked() && (m_sHasSyncMMediaChild != -1))
        {
            if((*ppElm)->IsSyncMaster() || ((*ppElm)->m_sHasSyncMMediaChild != -1))
            {
                RemoveSyncMasterFromBranch(*ppElm);
            }
        }
    }

    hr = S_OK;

  done:
    if (FAILED(hr))
    {
        StopRootTime(tl);
    }
    
    RRETURN(hr);
}

void
CTIMEElementBase::StopRootTime(MMTimeline * tl)
{
    CTIMEElementBase *pElem = NULL;
    Assert(NULL != m_mmbvr);

    // Begin Sync master code
    if(IsSyncMaster() || m_sHasSyncMMediaChild != -1)
    {
        if(((pElem = GetParent()) != NULL) && (pElem->m_sHasSyncMMediaChild != -1))
        {
            if(pElem->m_pTIMEChildren[pElem->m_sHasSyncMMediaChild] == this)
            {
                pElem->m_sHasSyncMMediaChild = -1;
            }
        }
    }
    // End Sync master code

    if(IsMedia() && !IsThumbnail() && GetBody() != NULL)
    {
        GetBody()->UnRegisterElementForSync(this);
    }

    if (tl != NULL)
    {
        tl->RemoveBehavior(*m_mmbvr);
    }

    // if this a par or seq, then process children
    if (IsGroup())
    {
        CTIMEElementBase **ppElm;
        int i;
    
        for (i = m_pTIMEChildren.Size(), ppElm = m_pTIMEChildren;
             i > 0;
             i--, ppElm++)
        {
            Assert(m_timeline);
            (*ppElm)->StopRootTime(m_timeline);
        }
    }
    else
    {
        // If we are not par then we should not have children
        Assert(m_pTIMEChildren.Size() == 0);
    }
    
    if (GetBody() && GetBody()->IsRootStarted() && !IsUnloading())
    {
        GetBody()->ElementChangeNotify(*this, ELM_DELETED);
    }
    
    m_bStarted = false;

    return;
}

HRESULT
CTIMEElementBase::Update()
{
    HRESULT hr;

    // bail if still loading properties or we haven't started playing 
    if (!IsReady())
    {
        hr = S_OK;
        goto done;
    }
    
    hr = THR(UpdateMMAPI(true, true));
    if (FAILED(hr))
    {
        goto done;
    } 

    hr = S_OK;
  done:
    RRETURN(hr);
}

void
CTIMEElementBase::CalcTimes()
{
    //
    // Since repeat defaults to 1 and the time engine takes the min of repeat and RepeatDur,
    // we need to set repeat to infinity if repeat is not set and repeatDur is set. 
    //

    if (m_FARepeatDur.IsSet())
    {
        if (m_FARepeat.IsSet())
        {
            m_realRepeatCount = m_FARepeat;
        }
        else
        {
            m_realRepeatCount = static_cast<float>(TIME_INFINITE);
        }
    }
    else
    {
        m_realRepeatCount = m_FARepeat;
    }
    
    if (m_FADur != valueNotSet)
    {
        m_realDuration = m_FADur;
    }
    else 
    {
        m_realDuration = INDEFINITE;
    }
    
    if (m_realDuration == 0.0f)
    {
        m_realDuration = INDEFINITE;
    }
 
    if (m_BAAutoReverse && (HUGE_VAL != m_realDuration))
    {
        m_realIntervalDuration = m_realDuration * 2;
    }
    else
    {
        m_realIntervalDuration = m_realDuration;
    }
    
    if (m_FARepeatDur != valueNotSet)
    {
        m_realRepeatTime = m_FARepeatDur;
    }
    else
    {
        m_realRepeatTime = m_FARepeat * m_realIntervalDuration;
    }
    
}


bool
CTIMEElementBase::AddTimeAction()
{
    return m_timeAction.AddTimeAction();
}

bool
CTIMEElementBase::RemoveTimeAction()
{
    return m_timeAction.RemoveTimeAction();
}

bool
CTIMEElementBase::ToggleTimeAction(bool on)
{
    if (m_timeline)
    {
        m_timeline->toggleTimeAction(on);
    }
    return m_timeAction.ToggleTimeAction(on);
}

bool
CTIMEElementBase::IsSequencedElementOn (void)
{
    bool fOn = m_mmbvr->IsOn();
    bool fActive = m_mmbvr->IsActive();

    // IsOn will return true for an element
    // even when the time container's rules
    // dictate that it should be off.
    Assert(GetParent() != NULL);
    Assert(GetParent()->IsSequence());

    if ((fOn) && (!fActive))
    {
        // on and !active and fill=hold --> on
        if (GetFill() == HOLD_TOKEN)
        {
            TraceTag((tagTimeElmUpdateTimeAction, 
                      "SEQ(%ls) : IsOn = %ls fill=hold",
                      GetID(),
                      m_mmbvr->IsOn() ? L"true" : L"false"
                     ));
            goto done;
        }
        // on and !active and fill = transition
        // we're on iff we're still a pending 
        // transition dependent.
        else if (GetFill() == TRANSITION_TOKEN)
        {
            fOn = (fOn && m_fInTransitionDependentsList && (!m_fEndingTransition));
        }
        else if (GetFill() == FREEZE_TOKEN)
        {
            // !active and to the left of the successor element's begin.
            CTIMEElementBase *ptebParent = GetParent();
            CPtrAry<CTIMEElementBase*> *paryPeers = (&ptebParent->m_pTIMEChildren);
            int iThis = paryPeers->Find(this);

            // If we're the last item in the sequence, 
            // assume the IsOn result is good.
            if (ptebParent->GetImmediateChildCount() > (iThis + 1))
            {
                // Get our successor element in the sequence.
                CTIMEElementBase *ptebNext = paryPeers->Item(iThis + 1);

                Assert(NULL != ptebNext);
                if (NULL != ptebNext)
                {
                    // Find out whether we are to the left of 
                    // our successors' begin time.
                    CComPtr<ITIMEState> spParentState;
                    CComPtr<ITIMEState> spSuccessorState;

                    HRESULT hr = THR(ptebParent->base_get_currTimeState(&spParentState));
                    if (FAILED(hr))
                    {
                        goto done;
                    }
                    
                    hr = THR(ptebNext->base_get_currTimeState(&spSuccessorState));
                    if (FAILED(hr))
                    {
                        goto done;
                    }

                    {
                        double dblParentTime = 0.0;
                        double dblSuccessorBeginTime = 0.0;

                        THR(spSuccessorState->get_parentTimeBegin(&dblSuccessorBeginTime));
                        THR(spParentState->get_segmentTime(&dblParentTime));

                        // If we're to the left of our successor's begin time,
                        // we should be on.
                        if (dblParentTime >= dblSuccessorBeginTime)
                        {
                            fOn = false;
                            TraceTag((tagTimeElmUpdateTimeAction, 
                                      "SEQ(%ls) : fOn=false fill=freeze parent=%g succ.begin=%g",
                                      GetID(),
                                      dblParentTime, dblSuccessorBeginTime
                                     ));
                        }
                        else
                        {
                            TraceTag((tagTimeElmUpdateTimeAction, 
                                      "SEQ(%ls) : fOn=true fill=freeze parent=%g succ.begin=%g",
                                      GetID(),
                                      dblParentTime, dblSuccessorBeginTime
                                     ));
                        }
                    }
                }
            }
            else
            {
                TraceTag((tagTimeElmUpdateTimeAction, 
                          "SEQ(%ls) : IsOn = %ls last child in sequence",
                          GetID(),
                          m_mmbvr->IsOn() ? L"true" : L"false"
                         ));
            }
        }
    }
    else 
    {
        TraceTag((tagTimeElmUpdateTimeAction, 
                  "SEQ(%ls) : IsOn = %ls IsActive = %ls",
                  GetID(),
                  m_mmbvr->IsOn() ? L"true" : L"false",
                  m_mmbvr->IsActive() ? L"true" : L"false"
                 ));
    }

done :
    return fOn;
}

void
CTIMEElementBase::UpdateTimeAction()
{
    bool fOn = false;

    if (m_mmbvr != NULL)
    {
        fOn = m_mmbvr->IsOn();

        if (GetParent() != NULL)
        {

            // Permit the applicable container to 
            // influence the element's state.
            if (GetParent()->IsSequence() == true)
            {
                fOn = IsSequencedElementOn();
            }
            else if (GetParent()->IsExcl() == true)
            {
                fOn = (   fOn 
                       && (   (m_mmbvr->IsActive() == true) 
                           || (GetFill() != FREEZE_TOKEN))
                      );
            }
            else
            {
                // Catch all for fill=transition.  
                // m_fEndingTransition is only on during OnEndTransition.
                fOn = (fOn && (!m_fEndingTransition));
            }
        }
    }
    else
    {
        fOn = false;
    }

    // If we're shutting ourselves off, and we might be in the 
    // transition dependent list, pull out of it.

    if (false == fOn)
    {
       RemoveFromTransitionDependents();
    }

    TraceTag((tagTimeTransitionFill,
              "CTIMEElementBase(%p)::UpdateTimeAction(%ls, %ls)",
              this, m_id, fOn ? L"on" : L"off"));

    ToggleTimeAction(fOn);    
}


//+-----------------------------------------------------------------------------
//
//  Member:     CTIMEElementBase::GetRuntimeStyle
//
//  Synopsis:   Tries to get Runtime style. If that fails (IE4), tries to get static style.
//
//  Arguments:  [s]     output variable
//
//  Returns:    [E_POINTER]     if bad arg 
//              [S_OK]          if got runtime or static style
//              [E_FAIL]        otherwise
//
//------------------------------------------------------------------------------

STDMETHODIMP
CTIMEElementBase::GetRuntimeStyle(IHTMLStyle ** s)
{
    CComPtr<IHTMLElement2> pElement2;
    HRESULT hr;

    CHECK_RETURN_SET_NULL(s);

    if (!GetElement())
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(GetElement()->QueryInterface(IID_IHTMLElement2, (void **)&pElement2));
    
    if (SUCCEEDED(hr))
    {
       if (!pElement2 || FAILED(THR(pElement2->get_runtimeStyle(s))))
        {
            hr = E_FAIL;
            goto done;
        }
    }
    else
    {
        // IE4 path
        hr = THR(GetElement()->get_style(s));
        if (FAILED(hr))
        {
            hr = E_FAIL;
            goto done;
        }
    }

    hr = S_OK;
done:
    return hr;
} // GetRuntimeStyle


HRESULT
CTIMEElementBase::FireEvent(TIME_EVENT TimeEvent,
                            double dblLocalTime,
                            DWORD flags,
                            long lRepeatCount)
{
    TraceTag((tagTimeElmBaseEvents,
              "CTIMEElementBase(%p, %ls)::FireEvent(%g, %d)",
              this,
              GetID()?GetID():L"Unknown",
              dblLocalTime,
              TimeEvent));
    
    HRESULT hr = S_OK;
    LPWSTR szParamNames[1]; 
    VARIANT varParams[1]; 
    VariantInit(&varParams[0]);
    szParamNames[0] = NULL;
    long lParamCount = 0;

    if (GetMMBvr().GetEnabled() == false)
    { 
        goto done;
    }
    InitOnLoad();
    
    switch(TimeEvent)
    {
      case TE_ONBEGIN:
        OnBegin(dblLocalTime, flags);
        break;
      case TE_ONEND:
        OnEnd(dblLocalTime);
        break;
      case TE_ONPAUSE:
        OnPause(dblLocalTime);
        break;
      case TE_ONRESUME:
        OnResume(dblLocalTime);
        break;
      case TE_ONRESET:
        OnReset(dblLocalTime, flags);
        break;
      case TE_ONREPEAT:
        varParams[0].vt = VT_I4;
        varParams[0].lVal = lRepeatCount;
        szParamNames[0] = CopyString(g_szRepeatCount);
        lParamCount = 1;
        OnRepeat(dblLocalTime);
        break;
      case TE_ONSEEK:
        OnSeek(dblLocalTime);
        break;
      case TE_ONREVERSE:
        OnReverse(dblLocalTime);
        break;
      case TE_ONUPDATE:
        OnUpdate(dblLocalTime, flags);
        TimeEvent = TE_ONRESET;
        break;
      default:
        break;
    }

    if (!IsUnloading() && !IsDetaching())
    {        
        hr = FireEvents(TimeEvent, lParamCount, szParamNames, varParams);
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
  done:

    if (szParamNames[0])
    {
        delete [] szParamNames[0];
    }
    VariantClear(&varParams[0]);
    RRETURN(hr);
}

bool
CTIMEElementBase::ChildPropNotify(CTIMEElementBase & teb,
                                  DWORD & tePropType)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p, %ls)::ChildPropNotify(%p, %d)",
              this,
              GetID(),
              &teb,
              tePropType));

    HRESULT hr;
    
    if ((tePropType & TE_PROPERTY_ISACTIVE) != 0)
    {
        CActiveElementCollection *pElmCol = GetActiveElementCollection();

        if (teb.GetElement() != NULL &&
            pElmCol != NULL)
        {
            CComPtr<IUnknown> pUnk;

            hr = THR(teb.GetElement()->QueryInterface(IID_IUnknown, (void **)&pUnk));
            if (SUCCEEDED(hr))
            {
                if (teb.IsActive())
                {
                    IGNORE_HR(pElmCol->addActiveElement(pUnk));
                }
                else
                {
                    IGNORE_HR(pElmCol->removeActiveElement(pUnk));
                }
            }
        }
    }

    return true;
}

void 
CTIMEElementBase::UpdateEndEvents()
{
    if (IsBodyDetaching() == false)
    {
        TEM_TOGGLE_END_EVENT(IsActive());
    }
}

void 
CTIMEElementBase::OnReverse(double dblLocalTime)
{
    if (m_timeline != NULL)
    {
        m_timeline->reverse();
    }
}

void 
CTIMEElementBase::OnRepeat(double dbllastTime)
{
    if (m_timeline != NULL)
    {
        m_timeline->repeat();
    }
}


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::AddToTransitionDependents
//
//------------------------------------------------------------------------------
void
CTIMEElementBase::AddToTransitionDependents()
{
    TraceTag((tagTimeTransitionFill,
              "CTIMEElementBase(%p)::AddToTransitionDependents(%p)",
              this, 
              m_pHTMLEle));

    HRESULT             hr      = S_OK;
    CTIMEBodyElement *  pBody   = GetBody();

    Assert(!IsBody());

    AssertSz(pBody,
             "CTIMEElementBase::AddToTransitionDependents called and"
              " there's no CTIMEBodyElement from which we would get"
              " a CTransitionDependencyManager.");

    if (!pBody)
    {
        goto done;
    }

    hr = THR(pBody->GetTransitionDependencyMgr()->AddDependent(this));

    if (FAILED(hr))
    {
        goto done;
    }

    m_fInTransitionDependentsList = true;

done:

    return;
}
//  Method: CTIMEElementBase::AddToTransitionDependents


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::RemoveFromTransitionDependents
//
//------------------------------------------------------------------------------
void
CTIMEElementBase::RemoveFromTransitionDependents()
{
    TraceTag((tagTimeTransitionFill,
              "CTIMEElementBase(%p)::RemoveFromTransitionDependents(%p)",
              this, 
              m_pHTMLEle));

    HRESULT             hr      = S_OK;
    CTIMEBodyElement *  pBody   = GetBody();

    if (!m_fInTransitionDependentsList)
    {
        goto done;
    }

    Assert(!IsBody());

    AssertSz(pBody,
             "CTIMEElementBase::RemoveFromTransitionDependents called and"
              " there's no CTIMEBodyElement from which we would get"
              " a CTransitionDependencyManager.");

    if (!pBody)
    {
        goto done;
    }

    hr = THR(pBody->GetTransitionDependencyMgr()->RemoveDependent(this));

    if (FAILED(hr))
    {
        goto done;
    }

    m_fInTransitionDependentsList = false;

done:

    return;
}
//  Method: CTIMEElementBase::RemoveFromTransitionDependents


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::OnResolveDependent
//
//------------------------------------------------------------------------------
HRESULT 
CTIMEElementBase::OnResolveDependent(
                                    CTransitionDependencyManager * pcNewManager)
{
    // @@ ISSUE do we need to cache the new manager here?
    // All dependents are strongly referenced by their managers,
    // so we may be okay without this complexity.

    return S_OK;
}
//  Method: CTIMEElementBase::OnResolveDependent


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::OnBeginTransition
//
//------------------------------------------------------------------------------
HRESULT 
CTIMEElementBase::OnBeginTransition (void)
{
    return S_OK;
}
//  Method: CTIMEElementBase::OnBeginTransition


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::OnEndTransition
//
//------------------------------------------------------------------------------
HRESULT 
CTIMEElementBase::OnEndTransition (void)
{
    m_fEndingTransition = true;
    UpdateTimeAction();
    m_fEndingTransition = false;

    return S_OK;
}
//  Method: CTIMEElementBase::OnEndTransition


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::OnBegin
//
//------------------------------------------------------------------------------
void
CTIMEElementBase::OnBegin(double dblLocalTime, DWORD flags)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::OnBegin()",
              this));

    Assert(NULL != m_mmbvr->GetMMBvr());

    if (m_timeline != NULL)
    {
        m_timeline->begin();
    }

    if( !m_bUnloading)
    {
        UpdateTimeAction();
        m_dLastRepeatEventNotifyTime = 0.0;
    }

    if (IsGroup() && !IsBody())
    {
        CTIMEElementBase **ppElm;
        int i;
    
        for (i = m_pTIMEChildren.Size(), ppElm = m_pTIMEChildren;
             i > 0;
             i--, ppElm++)
        {
            if ((*ppElm)->HasWallClock())
            {
                CComVariant beginTime;
                (*ppElm)->SetLocalTimeDirty(true);
                (*ppElm)->base_get_begin(&beginTime);
                (*ppElm)->base_put_begin(beginTime);
            }
        }
    }

    RemoveFromTransitionDependents();

    m_fHasPlayed = true;
}
//  Method: CTIMEElementBase::OnBegin


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::OnEnd
//
//------------------------------------------------------------------------------
void
CTIMEElementBase::OnEnd(double dblLocalTime)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::OnEnd()",
              this));
    
    Assert(m_mmbvr != NULL);
    Assert(m_mmbvr->GetMMBvr() != NULL);

    if (m_timeline != NULL)
    {
        m_timeline->end();
    }

    if (GetFill() == TRANSITION_TOKEN)
    {
        AddToTransitionDependents();
    }

    // Code Review: We may have just called AddToTransitionDependents, and 
    // UpdateTimeAction may call RemoveFromTransitionDependents.  Do we know
    // for a fact that we won't accidentally undo our Add?

    UpdateTimeAction();
}
//  Method: CTIMEElementBase::OnEnd


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::OnPause
//
//------------------------------------------------------------------------------
void
CTIMEElementBase::OnPause(double dblLocalTime)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::OnPause()",
              this)); 

    UpdateTimeAction();
}
//  Method: CTIMEElementBase::OnPause


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::OnResume
//
//------------------------------------------------------------------------------
void
CTIMEElementBase::OnResume(double dblLocalTime)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::OnResume()",
              this));

    UpdateTimeAction();
}
//  Method: CTIMEElementBase::OnResume


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::OnReset
//
//------------------------------------------------------------------------------
void
CTIMEElementBase::OnReset(double dblLocalTime, DWORD flags)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::OnReset()",
              this));

    UpdateTimeAction();
}
//  Method: CTIMEElementBase::OnReset


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::GetSyncMaster
//
//------------------------------------------------------------------------------
HRESULT
CTIMEElementBase::GetSyncMaster(double & dblNewSegmentTime,
                                LONG & lNewRepeatCount,
                                bool & bCueing)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::GetSyncMaster()",
              this));

    return S_FALSE;
}
//  Method: CTIMEElementBase::GetSyncMaster


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::OnTick
//
//------------------------------------------------------------------------------
void
CTIMEElementBase::OnTick()
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::OnTick()",
              this));
}
//  Method: CTIMEElementBase::OnTick


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::OnTEPropChange
//
//------------------------------------------------------------------------------
void
CTIMEElementBase::OnTEPropChange(DWORD tePropType)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::OnTEPropChange(%#x)",
              this,
              tePropType));

    if(m_fDetaching)
    {
        goto done;
    }

    if ((tePropType & TE_PROPERTY_TIME) != 0)
    {
        NotifyTimeStateChange(DISPID_TIMESTATE_SIMPLETIME);
        NotifyTimeStateChange(DISPID_TIMESTATE_SEGMENTTIME);
        NotifyTimeStateChange(DISPID_TIMESTATE_ACTIVETIME);
    }
    
    if ((tePropType & TE_PROPERTY_PROGRESS) != 0)
    {
        NotifyTimeStateChange(DISPID_TIMESTATE_PROGRESS);
    }
    
    // Optimize for the common case of only the time/progress changing
    if (tePropType == (TE_PROPERTY_TIME | TE_PROPERTY_PROGRESS))
    {
        goto done;
    }
    
    if ((tePropType & TE_PROPERTY_REPEATCOUNT) != 0)
    {
        NotifyTimeStateChange(DISPID_TIMESTATE_REPEATCOUNT);
    }
    
    if ((tePropType & TE_PROPERTY_SEGMENTDUR) != 0)
    {
        NotifyTimeStateChange(DISPID_TIMESTATE_SEGMENTDUR);
    }
    
    if ((tePropType & TE_PROPERTY_IMPLICITDUR) != 0)
    {
    }
    
    if ((tePropType & TE_PROPERTY_SIMPLEDUR) != 0)
    {
        NotifyTimeStateChange(DISPID_TIMESTATE_SIMPLEDUR);
    }
    
    if ((tePropType & TE_PROPERTY_ACTIVEDUR) != 0)
    {
        NotifyTimeStateChange(DISPID_TIMESTATE_ACTIVEDUR);
    }
    
    if ((tePropType & TE_PROPERTY_SPEED) != 0)
    {
        NotifyTimeStateChange(DISPID_TIMESTATE_SPEED);
    }
    
    if ((tePropType & TE_PROPERTY_BEGINPARENTTIME) != 0)
    {
        NotifyTimeStateChange(DISPID_TIMESTATE_PARENTTIMEBEGIN);
    }
    
    if ((tePropType & TE_PROPERTY_ENDPARENTTIME) != 0)
    {
        NotifyTimeStateChange(DISPID_TIMESTATE_PARENTTIMEEND);
    }
    
    if ((tePropType & TE_PROPERTY_ISACTIVE) != 0)
    {
        UpdateEndEvents();
        NotifyTimeStateChange(DISPID_TIMESTATE_ISACTIVE);
    }
    
    if ((tePropType & TE_PROPERTY_ISON) != 0)
    {
        UpdateTimeAction();
        NotifyTimeStateChange(DISPID_TIMESTATE_ISON);
    }
    
    if ((tePropType & TE_PROPERTY_ISCURRPAUSED) != 0)
    {
        NotifyTimeStateChange(DISPID_TIMESTATE_ISPAUSED);
    }
    
    if ((tePropType & TE_PROPERTY_ISPAUSED) != 0)
    {
        NotifyPropertyChanged(DISPID_TIMEELEMENT_ISPAUSED);
    }
    
    if ((tePropType & TE_PROPERTY_STATEFLAGS) != 0)
    {
        NotifyTimeStateChange(DISPID_TIMESTATE_STATE);
        NotifyTimeStateChange(DISPID_TIMESTATE_STATESTRING);
    }

done:

    return;
}
//  Method: CTIMEElementBase::OnTEPropChange


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::OnSeek
//
//------------------------------------------------------------------------------
void
CTIMEElementBase::OnSeek(double dblLocalTime)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::OnSeek()",
              this)); 

    if (m_timeline != NULL)
    {
        m_timeline->seek(dblLocalTime);
    }

    UpdateTimeAction();
}
//  Method: CTIMEElementBase::OnSeek


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::OnLoad
//
//------------------------------------------------------------------------------
void
CTIMEElementBase::OnLoad()
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::OnLoad()",
              this));

    if (m_bLoaded == true)
    {
        //don't load a second time
        goto done;
    }

    m_bLoaded = true;

    if (m_bNeedDetach == true)
    {
        Detach();
        goto done;
    }

    // notify and update the timeAction. This is required because
    // this is the earliest we can know that Element Behaviors have finished initalizing.
    m_timeAction.OnLoad();

    if (m_timeline != NULL)
    {
        m_timeline->load();
    }
    
    UpdateTimeAction();

    //check to see if this element has already been disabled.
    if (GetElement() != NULL)
    {
        CComBSTR bstrSwitch = WZ_SWITCHCHILDDISABLED;
        VARIANT vValue;
        HRESULT hr = S_OK;
        VariantInit(&vValue);
        hr = GetElement()->getAttribute(bstrSwitch, 0, &vValue);
        if (SUCCEEDED(hr))
        {
            if (vValue.vt == VT_BOOL && vValue.boolVal == VARIANT_TRUE)
            {
                CComPtr <IDispatch> pDisp;
                hr = THR(GetElement()->QueryInterface(IID_IDispatch, (void**)&pDisp));
                if (SUCCEEDED(hr))
                {
                    DisableElement(pDisp);
                }
            }
        }
        VariantClear(&vValue);
    }

    if ( IsTransitionPresent() )
    {
        CreateTrans();
    }

done:

    return;
}
//  Method: CTIMEElementBase::OnLoad


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::DisableElement
//
//------------------------------------------------------------------------------
HRESULT 
CTIMEElementBase::DisableElement(IDispatch *pEleDisp)
{
    //hide the element and set it's begin to indefinite.
    CComPtr <IHTMLStyle> pStyle;
    CComPtr <IHTMLElement> pEle;
    CComPtr <ITIMEElement> pTimeElement;
    CComPtr <IHTMLElement2> pEle2;
    HRESULT hr = S_OK;
    int k = 0;

    if (GetParent() == NULL)
    {
        goto done;
    }

    hr = THR(pEleDisp->QueryInterface(IID_IHTMLElement, (void**)&pEle));
    if (FAILED(hr))
    {
        goto done;
    }       

    hr = FindBehaviorInterface(GetBehaviorName(),
                               pEleDisp,
                               IID_ITIMEElement,
                               (void**)&pTimeElement);
    if (SUCCEEDED(hr))
    {
        //need to find the time element that is associated with this object.
        int iTimeEleCount = GetParent()->m_pTIMEChildren.Size();
        CTIMEElementBase *pEleBase = NULL;
        CComPtr <IUnknown> pTimeEleUnk;

        hr = THR(pTimeElement->QueryInterface(IID_IUnknown, (void**)&pTimeEleUnk));
        if (SUCCEEDED(hr))
        {
            CComPtr<IUnknown> pEleUnk;
            for (k = 0; k < iTimeEleCount; k++)
            {
                pEleBase = GetParent()->m_pTIMEChildren.Item(k);
                if (pEleBase != NULL)
                {   
                    pEleUnk.Release();
                    hr = THR(pEleBase->QueryInterface(IID_IUnknown, (void**)&pEleUnk));
                    if (SUCCEEDED(hr))
                    {
                        if (pEleUnk == pTimeEleUnk)
                        {
                            pEleBase->GetMMBvr().SetEnabled(false);
                            pEleBase->GetMMBvr().Update(true, true);
                        }
                    }
                }
            }
        }
    }

    hr = THR(pEle->QueryInterface(IID_IHTMLElement2, (void**)&pEle2));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pEle2->get_runtimeStyle(&pStyle));
    if (SUCCEEDED(hr))
    {
        CComBSTR bstrDisplay = WZ_NONE;
        hr = THR(pStyle->put_display(bstrDisplay));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    {
        CComBSTR bstrDisabled = WZ_SWITCHCHILDDISABLED;
        VARIANT vTrue;
        VariantInit(&vTrue);
        vTrue.vt = VT_BOOL;
        vTrue.boolVal = VARIANT_TRUE;
        IGNORE_HR(pEle->setAttribute(bstrDisabled, vTrue, VARIANT_TRUE));
        VariantClear(&vTrue);
    }

    hr = S_OK;

  done:

    return hr;
}
//  Method: CTIMEElementBase::DisableElement


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::MatchTestAttributes
//
//------------------------------------------------------------------------------
bool
CTIMEElementBase::MatchTestAttributes(IDispatch *pEleDisp)
{
    HRESULT     hr                      = E_FAIL;
    CComBSTR    bstrLanguage            = L"systemLanguage";
    CComBSTR    bstrCaption             = L"systemCaptions";
    CComBSTR    bstrBitrate             = L"systemBitrate";
    CComBSTR    bstrOverdubOrCaptions   = L"systemOverdubOrSubtitle";
    LPWSTR      lpszUserLanguage        = NULL;
    LPWSTR *    szLanguageArray         = NULL;
    bool        bSystemCaption          = false;
    bool        bSystemOverdub          = false;
    bool        bNeedLanguageMatch      = false;
    bool        bIsLanguageMatch        = false;
    bool        bNeedCaptionMatch       = false;
    bool        bIsCaptionMatch         = false;
    bool        bNeedOverdubMatch       = false;
    bool        bIsOverdubMatch         = false;
    bool        bNeedBitrateMatch       = false;
    bool        bIsBitrateMatch         = false;
    bool        bMatched                = false;
    long        lLangCount              = 0;
    long        lSystemBitrate          = 0;
    int         i                       = 0;
    
    VARIANT     vLanguage;
    VARIANT     vCaption;
    VARIANT     vOverdub;
    VARIANT     vBitrate;    
    CComVariant vDur;
    CComVariant vBegin;

    CComPtr<IHTMLElement> pEle;   
    
    hr = THR(pEleDisp->QueryInterface(IID_IHTMLElement, (void**)&pEle));
    if (FAILED(hr))
    {
        goto done;
    }

    vDur.vt = VT_R4;
    vDur.fltVal = 0.0f;
    vBegin.vt = VT_BSTR;
    vBegin.bstrVal = SysAllocString(WZ_INDEFINITE);
    
    //get the system settings
    bSystemOverdub = GetSystemOverDub();
    bSystemCaption = GetSystemCaption();
    lpszUserLanguage = GetSystemLanguage(pEle);
    if (lpszUserLanguage == NULL)
    {
        hr = E_FAIL;
        goto done;
    }

    VariantInit(&vCaption);
    VariantInit(&vLanguage);
    VariantInit(&vOverdub);
    VariantInit(&vBitrate);
        
    //get the language attribute from the element.
    hr = pEle->getAttribute(bstrLanguage, 0, &vLanguage);
    if (SUCCEEDED(hr))
    {
        if (vLanguage.vt == VT_BSTR)
        {
            bNeedLanguageMatch = true;
            CTIMEParser pParser(&vLanguage);
            hr = pParser.ParseSystemLanguages(lLangCount, &szLanguageArray);
            if (SUCCEEDED(hr))
            {
                //determine if there is a match
                for (i = 0; i < lLangCount; i++)
                {
                    if (szLanguageArray[i] != NULL)
                    {
                        if (lstrlenW(szLanguageArray[i]) == 2)
                        {
                            if (StrCmpNIW(szLanguageArray[i], lpszUserLanguage, 2) == 0)
                            {
                                bIsLanguageMatch = true;
                            }
                        }
                        else
                        {
                            if (StrCmpIW(szLanguageArray[i], lpszUserLanguage) == 0)
                            {
                                bIsLanguageMatch = true;
                            }
                        }
                        // clean up the language list.
                        delete [] szLanguageArray[i];
                        szLanguageArray[i] = NULL;
                    }
                }
                delete [] szLanguageArray;
                szLanguageArray = NULL;
            }
        }
    }

    //get caption attribute
    hr = pEle->getAttribute(bstrCaption, 0, &vCaption);
    if (SUCCEEDED(hr))
    {
        if (vCaption.vt == VT_BSTR)
        {
            bNeedCaptionMatch = true;
            if (bSystemCaption)
            {
                bIsCaptionMatch = StrCmpIW(vCaption.bstrVal, L"on") == 0;
            }
            else
            {
                bIsCaptionMatch = StrCmpIW(vCaption.bstrVal, L"off") == 0;
            }
        }
    }

    //get the OverdubOrCaptions attribute
    hr = pEle->getAttribute(bstrOverdubOrCaptions, 0, &vOverdub);
    if (SUCCEEDED(hr))
    {
        if (vOverdub.vt == VT_BSTR)
        {
            bNeedOverdubMatch = true;
            if (bSystemOverdub)
            {
                bIsOverdubMatch = StrCmpIW(vOverdub.bstrVal, L"overdub") == 0;
            }
            else 
            {
                bIsOverdubMatch = StrCmpIW(vOverdub.bstrVal, L"subtitle") == 0;
            }
        }
    }

    //get the SystemBitrate attribute
    hr = pEle->getAttribute(bstrBitrate, 0, &vBitrate);
    if (SUCCEEDED(hr) && vBitrate.vt != VT_NULL)
    {
        bNeedBitrateMatch = true;
        hr = VariantChangeTypeEx(&vBitrate, &vBitrate, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_I4);
        if (SUCCEEDED(hr))
        {
            LPWSTR lpszConnectType = GetSystemConnectionType();
            if (StrCmpIW(lpszConnectType, WZ_LAN) == 0)
            {
                bIsBitrateMatch = true;
            }
            else
            {
                long lSystemBitrate = 0;
                hr = GetSystemBitrate(&lSystemBitrate); 
                if (FAILED(hr) || lSystemBitrate >= vBitrate.lVal) 
                {
                    bIsBitrateMatch = true;
                }
            }
            delete [] lpszConnectType;
            lpszConnectType = NULL;
        }
    }

    if ((bIsLanguageMatch == true || bNeedLanguageMatch != true) &&
        (bIsCaptionMatch == true || bNeedCaptionMatch != true) &&
        (bIsOverdubMatch == true || bNeedOverdubMatch != true) &&
        (bIsBitrateMatch == true ||  bNeedBitrateMatch != true))
    {
        bMatched = true;
    }

done:

    VariantClear(&vLanguage);
    VariantClear(&vCaption);
    VariantClear(&vOverdub);
    VariantClear(&vBitrate);

    if (lpszUserLanguage)
    {
        delete [] lpszUserLanguage;
        lpszUserLanguage = NULL;
    }

    return bMatched;
}
//  Method: CTIMEElementBase::MatchTestAttributes


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::SwitchInnerElements
//
//------------------------------------------------------------------------------
HRESULT 
CTIMEElementBase::SwitchInnerElements()
{
    HRESULT hr = E_FAIL;
    IHTMLElement *pEle = NULL; //do not release this
    CComPtr <IDispatch> pChildColDisp;
    CComPtr <IHTMLElementCollection> pChildCol;    
    VARIANT vName, vIndex;
    
    CComPtr <IDispatch> pChildDisp;
    CComPtr <IHTMLElement> pChild;

    long lChildCount = 0;
    bool bMatched = false;
    int j = 0;

    VariantInit(&vName);
    vName.vt = VT_I4;
    VariantInit(&vIndex);
    pEle = GetElement();
    if (pEle == NULL)
    {
        goto done;
    }
    
    //get all of the html children of this element.
    hr = pEle->get_children(&pChildColDisp);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pChildColDisp->QueryInterface(IID_IHTMLElementCollection, (void **)&pChildCol);
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = pChildCol->get_length(&lChildCount);
    if (FAILED(hr))
    {
        goto done;
    }

    //loop through the children until they are all queried or a match is found.
    for (j = 0; j < lChildCount; j++)
    {
        CComBSTR bstrTagName;
        pChildDisp.Release();
        pChild.Release();        
    
        vName.lVal = j;
    
        hr = pChildCol->item(vName, vIndex, &pChildDisp);
        if (FAILED(hr) || pChildDisp == NULL)
        {
            continue;
        }
        hr = THR(pChildDisp->QueryInterface(IID_IHTMLElement, (void**)&pChild));
        if (FAILED(hr))
        {
            continue;
        }

        hr = THR(pChild->get_tagName(&bstrTagName));
        if (FAILED(hr))
        {
            goto done;
        }
        if (!bMatched && StrCmpW(L"!", bstrTagName) != 0)
        {
            bMatched = MatchTestAttributes(pChildDisp);        
            if (bMatched == true)
            {
                bMatched = true;
                if (m_activeElementCollection)
                {
                    //do not call pUnk->Release() on add, it will be handled by the ActiveElement Collection
                    CComPtr<IUnknown> pUnk;
                    hr = THR(pChild->QueryInterface(IID_IUnknown, (void **)&pUnk));
                    if (SUCCEEDED(hr))
                    {
                        IGNORE_HR(m_activeElementCollection->addActiveElement(pUnk));
                    }
                }
            }
            else
            {
                hr = DisableElement(pChildDisp);
                if (FAILED(hr))
                {
                    goto done;
                }
            }
        }
        else //if no match then remove.
        { 
            hr = DisableElement(pChildDisp);
            if (FAILED(hr))
            {
                goto done;
            }
        }        
    }

    hr = S_OK;

done:

    return hr;
}
//  Method: CTIMEElementBase::SwitchInnerElements


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::GetPlayState
//
//------------------------------------------------------------------------------
TE_STATE
CTIMEElementBase::GetPlayState()
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::GetPlayState()",
              this));

    TE_STATE retState = TE_STATE_INACTIVE;

    if (NULL != m_mmbvr)
    {
        retState = m_mmbvr->GetPlayState();
    }

    return retState;
}
//  Method: CTIMEElementBase::GetPlayState


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::GetTimeState
//
//------------------------------------------------------------------------------
TimeState
CTIMEElementBase::GetTimeState()
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::GetTimeState()",
              this));

    TimeState ts = TS_Inactive;

    if (!IsReady())
    {
        goto done;
    }

    if (m_mmbvr->IsActive())
    {
        ts = TS_Active;
    }
    else if (m_mmbvr->IsOn())
    {
        bool bTimeAction = m_timeAction.IsTimeActionOn();
        bool bIsInSeq = GetParent()->IsSequence();
        if (bIsInSeq && bTimeAction == false)
        {
            ts = TS_Inactive;
        }
        else
        {
            ts = TS_Holding;
        }
    }

done:

    return ts;
}
//  Method: CTIMEElementBase::GetTimeState

//
// Sneaky way to get a CTIMEElementBase out of an ITIMEElement:
//

class __declspec(uuid("AED49AA3-5C7A-11d2-AF2D-00A0C9A03B8C"))
TIMEElementBaseGUID {}; //lint !e753


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::BaseInternalQueryInterface
//
//------------------------------------------------------------------------------
HRESULT WINAPI
CTIMEElementBase::BaseInternalQueryInterface(CTIMEElementBase* pThis,
                                             void * pv,
                                             const _ATL_INTMAP_ENTRY* pEntries,
                                             REFIID iid,
                                             void** ppvObject)
{
    if (InlineIsEqualGUID(iid, __uuidof(TIMEElementBaseGUID))) 
    {
        *ppvObject = pThis;
        return S_OK;
    }
    
    return CComObjectRootEx<CComSingleThreadModel>::InternalQueryInterface(pv,
                                                                           pEntries,
                                                                           iid,
                                                                           ppvObject);
}
//  Method: CTIMEElementBase::BaseInternalQueryInterface
    
    
//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::GetTIMEElementBase
//
//  Notes:  This function does NOT return an addrefed outgoing CTIMEElementBase
//
//------------------------------------------------------------------------------
CTIMEElementBase *
GetTIMEElementBase(IUnknown * pInputUnknown)
{
    CTIMEElementBase * pTEB = NULL;

    if (pInputUnknown) 
    {
        pInputUnknown->QueryInterface(__uuidof(TIMEElementBaseGUID),(void **)&pTEB);
    }
    
    if (pTEB == NULL) 
    {
        TIMESetLastError(E_INVALIDARG, NULL);
    }
                
    return pTEB;
}
//  Method: CTIMEElementBase::GetTIMEElementBase


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::GetTIMEBodyElement
//
//  Notes:  This function does NOT return an addrefed outgoing CTIMEBodyElement
//
//------------------------------------------------------------------------------
CTIMEBodyElement *
GetTIMEBodyElement(ITIMEBodyElement * pInputUnknown)
{
    CTIMEBodyElement * pTEB = NULL;

    if (pInputUnknown) 
    {
        pInputUnknown->QueryInterface(__uuidof(TIMEBodyElementBaseGUID),(void **)&pTEB);
    }
                
    return pTEB;
}
//  Method: CTIMEElementBase::GetTIMEBodyElement


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::getTagString
//
//  Overview:
//      Get Tag string from HTML element.
//
//------------------------------------------------------------------------------
HRESULT 
CTIMEElementBase::getTagString(BSTR *pbstrID)
{
    return GetElement()->get_id(pbstrID);
}
//  Method: CTIMEElementBase::getTagString


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::getIDString
//
//  Overview:
//      Get ID string from HTML element.
//
//------------------------------------------------------------------------------
HRESULT 
CTIMEElementBase::getIDString(BSTR *pbstrTag)
{
    return GetElement()->get_id(pbstrTag);
}
//  Method: CTIMEElementBase::getIDString


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::IsGroup
//
//------------------------------------------------------------------------------
bool
CTIMEElementBase::IsGroup(IHTMLElement *pElement)
{
    HRESULT hr;
    bool    rc = false;
    CComPtr<ITIMEElement> pTIMEElem;
    CComPtr<ITIMEBodyElement> pTIMEBody;
    BSTR  bstrTimeline = NULL;
    BSTR  bstrTagName = NULL;

    hr = FindBehaviorInterface(GetBehaviorName(),
                               pElement,
                               IID_ITIMEElement,
                               (void**)&pTIMEElem);
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(pTIMEElem.p != NULL);

    hr = pTIMEElem->get_timeContainer(&bstrTimeline);
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(bstrTimeline != NULL);

    // Check to see what the contents of the BSTR are.
    // If it is a seq, par or excl, we want to return true.
    if ( (bstrTimeline != NULL) && 
         ((StrCmpIW(bstrTimeline, WZ_PAR) == 0) || 
          (StrCmpIW(bstrTimeline, WZ_EXCL) == 0) || 
          (StrCmpIW(bstrTimeline, WZ_SEQUENCE) == 0)) )
    {
         rc = true;
         goto done;
    }
    
    // check to see if it is the body element.
    // if so, then the element is *always" a group.
    hr = pTIMEElem->QueryInterface(IID_ITIMEBodyElement, (void**)&pTIMEBody);
    if (SUCCEEDED(hr))
    {
         rc = true;
         goto done;
    }

    // see if the tag name is <t:par> or <t:seq>
    hr = THR(pElement->get_tagName(&bstrTagName));
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(bstrTagName != NULL);

    if ( (StrCmpIW(bstrTagName, WZ_PAR) == 0) || 
         (StrCmpIW(bstrTagName, WZ_EXCL) == 0) ||
         (StrCmpIW(bstrTagName, WZ_SEQUENCE) == 0) )
    {
         rc = true;
         goto done;
    }

done:

    if (bstrTagName != NULL)
        SysFreeString(bstrTagName);
    if (bstrTimeline != NULL)
        SysFreeString(bstrTimeline);
    return rc;
}
//  Method: CTIMEElementBase::IsGroup


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::IsDocumentInEditMode
//
//------------------------------------------------------------------------------
bool
CTIMEElementBase::IsDocumentInEditMode()
{
    HRESULT hr;
    bool fRC = false;
    BSTR bstrMode = NULL;
    IDispatch *pDisp = NULL;
    IHTMLDocument2 *pDoc = NULL;
    IHTMLElement *pElem = GetElement();
    
    // if there is no pElem, we are not attached to an HTML element, and can't give any information.
    if (NULL == pElem)
        return false;
    
    hr = pElem->get_document(&pDisp);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerSite::Init - unable to get document pointer from element!!!"));
        goto done;
    }

    Assert(pDisp != NULL);

    hr = pDisp->QueryInterface(IID_TO_PPV(IHTMLDocument2, &pDoc));
    ReleaseInterface(pDisp);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerSite::Init - unable to QI for document pointer!!!"));
        goto done;
    }

    Assert(pDoc != NULL);

    hr = pDoc->get_designMode(&bstrMode);
    ReleaseInterface(pDoc);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerSite::Init - unable to QI for document pointer!!!"));
        goto done;
    }
    
    if (StrCmpIW(bstrMode, L"On") == 0)
    {
        fRC = true;
    }

    SysFreeString(bstrMode);

done:

    return fRC;
}
//  Method: CTIMEElementBase::IsDocumentInEditMode


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::GetSize
//
//  Overview:        
//      Return return left,top,width,height of element.
//
//------------------------------------------------------------------------------
HRESULT
CTIMEElementBase::GetSize(RECT *prcPos)
{
    HRESULT hr;
    long lWidth = 0;
    long lHeight = 0;
    IHTMLElement *pElem = GetElement();
    CComPtr<IHTMLElement2> spElem2;

    CComPtr<IHTMLStyle> spStyle;

    if (prcPos == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (pElem == NULL)
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    prcPos->left = 0;
    prcPos->top = 0;
    prcPos->right = 0;
    prcPos->bottom = 0;

   
    hr = THR(pElem->get_style(&spStyle));
    if (FAILED(hr))
    {
        goto done;
    }
    hr = THR(spStyle->get_pixelWidth(&lWidth));
    if (FAILED(hr))
    {
        goto done;
    }
    hr = THR(spStyle->get_pixelHeight(&lHeight));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pElem->QueryInterface(IID_IHTMLElement2, (void **)&spElem2));

    if (SUCCEEDED(hr) &&
       (lWidth  != 0 && lHeight != 0))
    {
        hr = THR(spElem2->get_clientWidth(&lWidth));
        if (FAILED(hr))
        {
            goto done;
        }
        
        hr = THR(spElem2->get_clientHeight(&lHeight));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    // fill in rect
    prcPos->left = prcPos->top = 0;
    prcPos->right = lWidth;
    prcPos->bottom = lHeight;

    TraceTag((tagTimeElmBase, "CTIMEElementBase::GetSize(%d, %d, %d, %d)", prcPos->left, prcPos->top, prcPos->right, prcPos->bottom));

    hr = S_OK;

done:

    return hr;
}
//  Method: CTIMEElementBase::GetSize


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::ClearSize
//
//------------------------------------------------------------------------------
HRESULT
CTIMEElementBase::ClearSize()
{
    CComPtr<IHTMLStyle> pStyle;
    CComPtr<IHTMLElement2> pElement2;
    
    HRESULT hr = E_FAIL;

    if (!GetElement())        
    {
        goto done;
    }
    
    hr = THR(GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElement2)));
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = THR(pElement2->get_runtimeStyle(&pStyle));
    if (FAILED(hr))
    {
        goto done;
    }

    if (!pStyle)
    {
        Assert(false);
    }

    hr = pStyle->put_pixelWidth(0);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pStyle->put_pixelHeight(0);
    if (FAILED(hr))
    {
        goto done;
    }

done:

    return hr;
}
//  Method: CTIMEElementBase::ClearSize


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::SetWidth
//
//------------------------------------------------------------------------------
HRESULT
CTIMEElementBase::SetWidth(long lwidth)
{
    CComPtr<IHTMLStyle>     pStyle;
    CComPtr<IHTMLElement2>  pElem2;
    IHTMLElement *          pElem   = GetElement();

    HRESULT hr;
    long    lCurWidth       = 0;
    long    lClientWidth    = 0;
    int     i               = 0;

    if (pElem == NULL)
    {
        hr = E_UNEXPECTED;
        goto done;
    }


    lClientWidth = lwidth; 
    
    hr = THR(GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElem2)));
    if (FAILED(hr))
    {
        // IE4 path
        hr = THR(pElem->get_style(&pStyle));
        if (FAILED(hr))
        {
            goto done;
        }

    }
    else
    {
        hr = THR(pElem2->get_runtimeStyle(&pStyle));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    if (!pStyle)
    {
        Assert(false);
    }

    // Request increasingly larger total size (pixel width) until we get the correct client size.
    // This iterative solution is to avoid having to parse the border size etc. (strings sith dimensions)
    // that Trident returns.
    i = 0;
    while (((lCurWidth != lClientWidth)) && i < 5)
                    // the i < 5 condition limits the loop to 5 times through
                    // this causes the case of bordersize > 5 * the size of the element
                    // to fail.  In this case the default will be to ignore the border and
                    // simply set the size.
    {
        // if we got more than what we requested in the last iteration, might have infinite loop
        Assert(lCurWidth <= lClientWidth);

        i++;
        if (lCurWidth == 0)
        {
            lCurWidth = lClientWidth * i; //increase in mutiples incase the first size is not larger than the border width
        }
        else if (lCurWidth != lClientWidth)  // != 0 and != Requested width
        {
            lCurWidth =  lClientWidth * (i - 1) + (lClientWidth - lCurWidth);  
        }

        hr = THR(pStyle->put_pixelWidth(lCurWidth));
        if (FAILED(hr))
            goto done;

        if (!pElem2)
        {
            hr = THR(pStyle->get_pixelWidth(&lCurWidth));
            if (FAILED(hr))
            {
                goto done;
            }
        }
        else
        {        
            hr = THR(pElem2->get_clientWidth(&lCurWidth));
            if (FAILED(hr))
            {
                goto done;
            }
        }
    } // while

    if ((lCurWidth != lClientWidth) &&
           (i == 5))  // if the max count has been reached, then simply set the element 
    {                 // size to the requested size without trying to compensate for a border.
        hr = THR(pStyle->put_pixelWidth(lClientWidth));
        if (FAILED(hr))
            goto done;
    }

    hr = S_OK;

done:

    return hr;
}
//  Method: CTIMEElementBase::SetWidth


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::SetHeight
//
//------------------------------------------------------------------------------
HRESULT
CTIMEElementBase::SetHeight(long lheight)
{
    CComPtr<IHTMLStyle> pStyle;
    CComPtr<IHTMLElement2> pElem2;
    IHTMLElement *pElem = GetElement();

    HRESULT hr;
    long lCurHeight = 0;
    long lClientHeight = 0;
    int i = 0;

    if (pElem == NULL)
    {
        hr = E_UNEXPECTED;
        goto done;
    }


    lClientHeight = lheight; 
    
    hr = THR(GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElem2)));
    if (FAILED(hr))
    {
        // IE4 path
        hr = THR(pElem->get_style(&pStyle));
        if (FAILED(hr))
        {
            goto done;
        }

    }
    else
    {
        hr = THR(pElem2->get_runtimeStyle(&pStyle));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    if (!pStyle)
    {
        Assert(false);
    }

    // Request increasingly larger total size (pixel width) until we get the correct client size.
    // This iterative solution is to avoid having to parse the border size etc. (strings sith dimensions)
    // that Trident returns.
    i = 0;
    while (((lCurHeight != lClientHeight)) && i < 5)
                    // the i < 5 condition limits the loop to 5 times through
                    // this causes the case of bordersize > 5 * the size of the element
                    // to fail.  In this case the default will be to ignore the border and
                    // simply set the size.
    {
        // if we got more than what we requested in the last iteration, might have infinite loop
        //Assert(lCurHeight <= lClientHeight);

        i++;
        if (lCurHeight == 0)
        {
            lCurHeight = lClientHeight * i; //increase in mutiples incase the first size is not larger than the border width
        }
        else if (lCurHeight != lClientHeight)  // != 0 and != Requested width
        {
            lCurHeight =  lClientHeight * (i - 1) + (lClientHeight - lCurHeight);  
        }

        hr = THR(pStyle->put_pixelHeight(lCurHeight));
        if (FAILED(hr))
            goto done;

        if (!pElem2)
        {
            hr = THR(pStyle->get_pixelHeight(&lCurHeight));
            if (FAILED(hr))
            {
                goto done;
            }
        }
        else
        {        
            hr = THR(pElem2->get_clientHeight(&lCurHeight));
            if (FAILED(hr))
            {
                goto done;
            }
        }
    } // while

    if ((lCurHeight != lClientHeight) &&
           (i == 5))  // if the max count has been reached, then simply set the element 
    {                 // size to the requested size without trying to compensate for a border.
        hr = THR(pStyle->put_pixelHeight(lClientHeight));
        if (FAILED(hr))
            goto done;
    }

    hr = S_OK;

done:

    return hr;
}
//  Method: CTIMEElementBase::SetHeight


//+-----------------------------------------------------------------------------
//
//  Method: CTIMEElementBase::SetSize
//
//------------------------------------------------------------------------------
HRESULT
CTIMEElementBase::SetSize(const RECT *prcPos)
{
    CComPtr<IHTMLStyle> pStyle;
    CComPtr<IHTMLElement2> pElem2;
    IHTMLElement *pElem = GetElement();

    HRESULT hr;
    long lLeft = 0;
    long lTop = 0;
    long lCurWidth = 0;
    long lCurHeight = 0;
    long lClientWidth = 0;
    long lClientHeight = 0;
    int i = 0;

    if (prcPos == NULL)    
    {
        hr = E_POINTER;
        goto done;
    }

    if (pElem == NULL)
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    // negative size is unexpected
    Assert((prcPos->right - prcPos->left) >= 0);
    Assert((prcPos->bottom - prcPos->top) >= 0);

    // if width or height is zero or less, bail
    if ( ((prcPos->right - prcPos->left) <= 0) ||
         ((prcPos->bottom - prcPos->top) <= 0) )
    {
        hr = ClearSize();
        goto done;
    }

    lClientWidth = prcPos->right - prcPos->left;
    lClientHeight = prcPos->bottom - prcPos->top; 
    
    hr = THR(GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElem2)));
    if (FAILED(hr))
    {
        // IE4 path
        hr = THR(pElem->get_style(&pStyle));
        if (FAILED(hr))
        {
            goto done;
        }

    }
    else
    {
        hr = THR(pElem2->get_runtimeStyle(&pStyle));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    // get offset into document.
    hr = THR(pElem->get_offsetLeft(&lLeft));
    if (FAILED(hr))
        goto done;

    hr = THR(pElem->get_offsetTop(&lTop));
    if (FAILED(hr))
        goto done;

    if (!pStyle)
    {
        Assert(false);
    }

    // Request increasingly larger total size (pixel width) until we get the correct client size.
    // This iterative solution is to avoid having to parse the border size etc. (strings sith dimensions)
    // that Trident returns.
    i = 0;
    while (((lCurWidth != lClientWidth) ||
           (lCurHeight != lClientHeight)) &&
           i < 5)   // the i < 5 condition limits the loop to 5 times through
                    // this causes the case of bordersize > 5 * the size of the element
                    // to fail.  In this case the default will be to ignore the border and
                    // simply set the size.
    {
        // if we got more than what we requested in the last iteration, might have infinite loop

        i++;
        if (lCurWidth == 0)
        {
            lCurWidth = lClientWidth * i; //increase in mutiples in case the first size is not larger than the border width
        }
        else if (lCurWidth != lClientWidth)  // != 0 and != Requested width
        {
            lCurWidth =  lClientWidth * (i - 1) + (lClientWidth - lCurWidth);  
        }
        if (lCurHeight == 0)
        {
            lCurHeight = lClientHeight * i; //increase in mutiples incase the first size is not larger than the border width
        }
        else if (lCurHeight != lClientHeight)  // != 0 and != Requested width
        {
            lCurHeight =  lClientHeight * (i - 1) + (lClientHeight - lCurHeight);  
        }

        // Set the total size (client size + borders etc.)
        hr = THR(pStyle->put_pixelWidth(lCurWidth));
        if (FAILED(hr))
            goto done;

        hr = THR(pStyle->put_pixelHeight(lCurHeight));
        if (FAILED(hr))
            goto done;

        if (!pElem2)
        {
            // IE4 path
            hr = THR(pStyle->get_pixelWidth(&lCurWidth));
            if (FAILED(hr))
            {
                goto done;
            }
            hr = THR(pStyle->get_pixelHeight(&lCurHeight));
            if (FAILED(hr))
            {
                goto done;
            }
        }
        else
        {
            //get the current client size
            hr = THR(pElem2->get_clientWidth(&lCurWidth));
            if (FAILED(hr))
            {
                goto done;
            }
        
            hr = THR(pElem2->get_clientHeight(&lCurHeight));
            if (FAILED(hr))
            {
                goto done;
            }
        }
    } // while

    if (((lCurWidth != lClientWidth) ||
           (lCurHeight != lClientHeight)) &&
           (i == 5))  // if the max count has been reached, then simply set the element 
    {                 // size to the requested size without trying to compensate for a border.
        hr = THR(pStyle->put_pixelWidth(lClientWidth));
        if (FAILED(hr))
            goto done;

        hr = THR(pStyle->put_pixelHeight(lClientHeight));
        if (FAILED(hr))
            goto done;
    }

    hr = S_OK;

done:

    TraceTag((tagTimeElmBase, 
              "CTIMEElementBase::SetSize(%d, %d, %d, %d) [pos(%d, %d)]", 
              prcPos->left, 
              prcPos->top, 
              prcPos->right, 
              prcPos->bottom, 
              lLeft, 
              lTop));

    return hr;
}
//  Method: CTIMEElementBase::SetSize



//+-----------------------------------------------------------------------------------
//
//  Member: CTIMEElementBase::InitTimeline
//
//  Synopsis:   Creates the MMUtils time container and starts root time if body's root
//              time has already started (dynamic creation)
//
//------------------------------------------------------------------------------------
HRESULT
CTIMEElementBase::InitTimeline (void)
{
    HRESULT hr = S_OK;

    if (!m_fTimelineInitialized)
    {
        if (IsGroup())
        {
            if (IsExcl())
            {
                m_timeline = NEW MMExcl(*this, true);
            }
            else if (IsSequence())
            {
                m_timeline = NEW MMSeq(*this, true);
            }
            else
            {
                m_timeline = NEW MMTimeline(*this, true);
            }

            if (m_timeline == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }

            // Immediately assign to m_mmbvr so we ensure that we clean it
            // up on destruction since the m_timeline is ignored
            m_mmbvr = m_timeline;

            if (!m_timeline->Init())
            {
                hr = TIMEGetLastError();
                goto done;
            }
        }
        else
        {
            MMBaseBvr * b;
            if (IsMedia())
            {
                b = NEW MMMedia(*this, true);
            }
            else
            {
                b = NEW MMBvr(*this, true, IsSyncMaster());
            }

            if (b == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }

            // Immediately assign to m_mmbvr so we ensure that we clean it
            // up on destruction
            m_mmbvr = b;

            if (!b->Init())
            {
                hr = TIMEGetLastError();
                goto done;
            }
        }
        m_fTimelineInitialized = true;
    }

    if(m_spBodyElemExternal && (m_ExtenalBodyTime != valueNotSet) && IsEmptyBody())
    {
        TimeValue *tv;

        tv = new TimeValue(NULL,
                           NULL,
                           m_ExtenalBodyTime);

        if (tv == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        m_realBeginValue.GetList().push_back(tv);
     }

    // if we are not the body, have a cached body element pointer, and it is started (i.e. StartRootTimte)
    // then we should start ourselves and do not wait for notification.
    if (!IsBody() && (GetBody() != NULL) && GetBody()->IsRootStarted())
    {
        // being extra careful.  If we have a body cached, we know we are parented and that we can reach
        // back.
        if (GetParent() != NULL)
        {
            hr = THR(StartRootTime(GetParent()->GetMMTimeline()));
            if (FAILED(hr))
            {
                TraceTag((tagError, "CTIMEBodyElement::InitTimeline - StartRootTime() failed!"));
                goto done;
            }
        }
    }

done :

    return hr;
}
//  Member: CTIMEElementBase::InitTimeline




////////////////////////////////////////////////////////////////////////////////////////////////////
// Persistance Helpers
////////////////////////////////////////////////////////////////////////////////////////////////////




//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMEElementBase::OnPropertiesLoaded, CBaseBvr
//
//  Synopsis:   This method is called by IPersistPropertyBag2::Load after it has
//              successfully loaded properties
//
//  Arguments:  None
//
//  Returns:    Return value of CTIMEElementBase::InitTimeline
//
//------------------------------------------------------------------------------------
STDMETHODIMP
CTIMEElementBase::OnPropertiesLoaded(void)
{
    HRESULT hr;

    // Once we've read the properties in, 
    // set up the timeline.  This is immutable
    // in script.
    hr = InitTimeline();

    if (IsGroup() == false &&
        m_FADur.IsSet() == false &&
        m_FARepeat.IsSet() == false &&
        m_FARepeatDur.IsSet() == false &&
        m_SAEnd.IsSet() == false &&
        m_TAFill.IsSet() == false)
    {
        m_fUseDefaultFill = true;
        m_TAFill.InternalSet(FREEZE_TOKEN);
    }

    
    if (GetElement())
    {
        CComBSTR pbstrReadyState;
        IHTMLElement *pEle = GetElement();
        hr = GetReadyState(pEle, &pbstrReadyState);
        if (SUCCEEDED(hr))
        {
            if (StrCmpIW(pbstrReadyState, L"complete") == 0)
            {
                OnLoad();
                m_bReadyStateComplete = true;
            }
        }
    }

    return hr;
} // OnPropertiesLoaded


//*****************************************************************************
// if elment doesn't exist in child list, make return -1.
int
CTIMEElementBase::GetTimeChildIndex(CTIMEElementBase *pelm)
{
    if (pelm == NULL)
        return -1;

    long lSize = m_pTIMEChildren.Size();
    for (long i=0; i < lSize; i++)
    {
        if (m_pTIMEChildren[i] == pelm)
             return i;
    }

    // didn't find it
    return -1;
} // GetTimeChildIndex

//
// returns a weak reference to the BodyElement
//
CTIMEBodyElement *
CTIMEElementBase::GetBody()
{
    CTIMEBodyElement * pBody = NULL;

    if (GetParent())
    {
        pBody = GetParent()->GetBody();
    }
    else if (IsBody())
    {
        pBody = (CTIMEBodyElement*)this;
    }
    
done:
    return pBody;
}

MMPlayer *
CTIMEElementBase::GetPlayer()
{
    CTIMEBodyElement * pTIMEBody = GetBody();
    if (pTIMEBody)
    {
        return &(pTIMEBody->GetPlayer());
    }
    else
    {
        return NULL;
    }
}

float
CTIMEElementBase::GetRealSyncTolerance()
{
    if (m_FASyncTolerance == valueNotSet)
    {
        if (GetBody())
        {
            return GetBody()->GetDefaultSyncTolerance();
        }
        else
        {
            return DEFAULT_SYNC_TOLERANCE_S;
        }
    }
    else
    {
        return m_FASyncTolerance;
    }
}
    
TOKEN
CTIMEElementBase::GetRealSyncBehavior()
{
    if (GetParent() != NULL && GetParent()->IsSequence())
    {
        return LOCKED_TOKEN;
    }
    
    if (m_TASyncBehavior == INVALID_TOKEN)
    {
        return GetBody()->GetDefaultSyncBehavior();
    }
    else
    {
        return m_TASyncBehavior;
    }
}    


STDMETHODIMP
CTIMEElementBase::EventNotify(long event)
{
    return S_OK;
}


HRESULT 
CTIMEElementBase::base_beginElementAt(double time, double dblOffset)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::base_beginElementAt()",
              this));

    HRESULT hr;

    if (!IsReady())
    {
        hr = S_OK;
        goto done;
    }

    if (GetParent() && GetParent()->IsSequence())
    {
        hr = S_OK;
        goto done;
    }
    
    hr = THR(m_mmbvr->BeginAt(time, dblOffset));
    if (FAILED(hr))
    {
        goto done;
    } 

    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT 
CTIMEElementBase::base_endElementAt(double time, double dblOffset)
{    
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::base_endElementAt()",
              this));
    HRESULT hr;
    
    if (!IsReady())
    {
        hr = S_OK;
        goto done;
    }
    
    hr = THR(m_mmbvr->EndAt(time, dblOffset));
    if (FAILED(hr))
    {
        goto done;
    } 

    hr = S_OK;
  done:
    RRETURN(hr);
}

//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMEElementBase::IsNodeAtBeginTime
//
//  Synopsis:   Returns true if a node's current time is equal to it's begin time.
//              This happens when a node has been marked active but has not yet started
//              playing (ticking).
//
//  Arguments:  None
//
//  Returns:    bool
//
//------------------------------------------------------------------------------------
bool
CTIMEElementBase::IsNodeAtBeginTime()
{
    double dblActiveBeginTime;
    double dblCurrParentTime;

    if (!IsReady())
    {
        return false;
    }

    dblActiveBeginTime = GetMMBvr().GetActiveBeginTime();
    dblCurrParentTime = GetMMBvr().GetCurrParentTime();

    if (dblActiveBeginTime != TIME_INFINITE &&
        dblCurrParentTime != TIME_INFINITE &&
        dblActiveBeginTime == dblCurrParentTime)
    {
        return true;
    }
    else
    {
        return false;
    }
}

STDMETHODIMP
CTIMEElementBase::onBeginEndEvent(bool bBegin, float beginTime, float beginOffset, 
                                  bool bEnd, float endTime, float endOffset)
{
    HRESULT hr = S_OK;

    if (bBegin && bEnd)
    {
        if (m_TARestart == ALWAYS_TOKEN)
        {
            bEnd = false;  //this cancels the end and allows the begin
        }
        else if (m_TARestart == NEVER_TOKEN)
        {
            if (m_fHasPlayed == true)
            {
                bBegin = false; //this cancels the end and allows the begin
            }
            else
            {
                bEnd = false;
            }
        }
        else if (m_TARestart == WHENNOTACTIVE_TOKEN) //check the active state
        {
            if (IsActive())
            {
                bBegin = false;
            }
            else
            {
                bEnd = false;
            }
        }
        else
        {
            Assert("Invalid restart token during begin event handler" && false);                    
        }

    }

    if (bBegin)
    {
        if (beginTime != valueNotSet)
        {
            double dblParentTime = 0.0;

            dblParentTime = m_mmbvr->DocumentTimeToParentTime(static_cast<double>(beginTime));

            hr = THR(base_beginElementAt(dblParentTime, static_cast<double>(beginOffset)));
        }
        else
        {
            hr = THR(base_beginElement(static_cast<double>(beginOffset)));
        }
    }

    if (bEnd)
    {
        if (IsNodeAtBeginTime() && endOffset == 0.0f && GetParent() && GetParent()->IsSequence())
        {
            goto done;
        }
        // Need to convert the incoming time from global to local to make endAt work.
        if (endTime != valueNotSet)
        {
            double dblParentTime = 0.0;

            dblParentTime = m_mmbvr->DocumentTimeToParentTime(static_cast<double>(endTime));

            hr = THR(base_endElementAt(dblParentTime, static_cast<double>(endOffset)));
        }
        else
        {
            hr = THR(base_endElement(static_cast<double>(endOffset)));
        }
    }
  done:
    return hr;
}


STDMETHODIMP
CTIMEElementBase::onPauseEvent(float time, float fOffset)
{
    return S_OK;
}

STDMETHODIMP
CTIMEElementBase::onResumeEvent(float time, float fOffset)
{
    return S_OK;
}

STDMETHODIMP
CTIMEElementBase::onLoadEvent()
{
    if (IsBody())
    {
        OnLoad();
    }
    return S_OK;
}

STDMETHODIMP
CTIMEElementBase::onUnloadEvent()
{
    OnBeforeUnload();  //signal that the element is unloading now.  No further events
                       //will be fired.
    OnUnload();  
    return S_OK;
}

void
CTIMEElementBase::NotifyBodyUnloading()
{
    m_bBodyUnloading = true;

    if (IsGroup())
    {
        CTIMEElementBase ** ppElm;
        int i;

        for (i = m_pTIMEChildren.Size(), ppElm = m_pTIMEChildren;
             i > 0;
             i--, ppElm++)
        {
            Assert(ppElm);
            if ((*ppElm))
            {
                (*ppElm)->NotifyBodyUnloading();
            }
        }
    }
}

void
CTIMEElementBase::NotifyBodyDetaching()
{
    m_bBodyDetaching = true;

    if (IsGroup())
    {
        CTIMEElementBase ** ppElm;
        int i;

        for (i = m_pTIMEChildren.Size(), ppElm = m_pTIMEChildren;
             i > 0;
             i--, ppElm++)
        {
            Assert(ppElm);
            if ((*ppElm))
            {
                (*ppElm)->NotifyBodyDetaching();
            }
        }
    }
}

void
CTIMEElementBase::NotifyBodyLoading()
{    
    //load the children
    if (IsGroup())
    {
        CTIMEElementBase ** ppElm;
        int i;

        for (i = m_pTIMEChildren.Size(), ppElm = m_pTIMEChildren;
             i > 0;
             i--, ppElm++)
        {
            Assert(ppElm);
            if ((*ppElm))
            {
                (*ppElm)->NotifyBodyLoading();
            }
        }
    }
    
    //load the element;
    if (IsBody() == false)
    {
        OnLoad();
    }
}

STDMETHODIMP
CTIMEElementBase::onReadyStateChangeEvent(LPOLESTR lpstrReadyState)
{
    CComBSTR bstrReadyState;
    if (IsBodyDetaching() == true)
    {
        //this should only be hit in the case of thumbnail view which detachs without unloading
        goto done; 
    }

    GetReadyState  (GetElement(), &bstrReadyState);
    if (bstrReadyState != NULL && StrCmpIW(bstrReadyState, L"complete") == 0)
    {
        m_bReadyStateComplete = true;
    }
    else
    {
        m_bReadyStateComplete = false;
    }

  done:

    return S_OK;

}

STDMETHODIMP
CTIMEElementBase::onStopEvent(float time)
{
    HRESULT hr = S_OK;

    if (IsBody())
    {
        hr = THR(base_pauseElement());
    }
    return hr;
}

STDMETHODIMP
CTIMEElementBase::get_playState(long *State)
{
    HRESULT hr = S_OK;

    TE_STATE CurrState = GetPlayState();
    
    if (State == NULL)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    *State = (long)CurrState;

  done:

    return hr;
}

float
CTIMEElementBase::GetGlobalTime()
{
    float f = 0;

    MMPlayer * p = GetPlayer();
    
    if (p != NULL)
    {   
        f = static_cast<float>(GetPlayer()->GetCurrentTime());
    }

    return f;
}


//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMEElementBase::ReportInvalidArg
//
//  Synopsis:   Wrapper for ReportError; handles "Invalid Argument" error messages.
//
//  Arguments:  property name and invalid value
//
//  Returns:    S_FALSE if English error message was used (localized error message not available)
//
//------------------------------------------------------------------------------------
HRESULT 
CTIMEElementBase::ReportInvalidArg(LPCWSTR pstrPropName, VARIANT & varValue)
{
    Assert(pstrPropName);
    Assert(VT_NULL != varValue.vt);
    Assert(VT_EMPTY != varValue.vt);

    // Convert argument to string
    CComVariant svarTemp;
    HRESULT hr = THR(VariantChangeTypeEx(&svarTemp, &varValue, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR));
    if (FAILED(hr))
    {
        // conversion failed, null out the variant
        Assert(false && "Unexpected failure converting variant");
        svarTemp.bstrVal = NULL;
        svarTemp.vt = VT_BSTR;
    }

    // load localized message and fire event
    hr = THR(ReportError(IDR_INVALID_ARG, 
                        (GetID() ? GetID() : L""), 
                        pstrPropName, 
                        svarTemp.bstrVal));
    if (FAILED(hr))
    {
        // Couldn't get localized resource, use non-localized error message
        WCHAR strMesg[MAX_ERR_STRING_LEN + 1];
        wnsprintf(
            strMesg,
            MAX_ERR_STRING_LEN + 1,
            WZ_ERROR_STRING_FORMAT,
            GetID() ? GetID() : L"",
            pstrPropName,
            svarTemp.bstrVal);
    
        // fire the error event
        hr = THR(FireErrorEvent(strMesg));
        if (SUCCEEDED(hr))
        {
            // indicate that localized string could not be used
            hr = S_FALSE;
        }
    }

    return hr;
} // ReportInvalidArg


//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMEElementBase::ReportError
//
//  Synopsis:   Loads the format string from localized resources and 
//              fires the error event. 
//
//  Arguments:  Resource ID and variable list of format string arguments
//
//  Returns:    E_FAIL if resource could not be loaded
//
//------------------------------------------------------------------------------------
HRESULT
CTIMEElementBase::ReportError(UINT uResID, ...)
{
    USES_CONVERSION; //lint !e522
    HRESULT hr = S_OK;
    va_list args;

    va_start(args, uResID);

    //
    // Load the resource string
    //

    WCHAR pwstrResStr[MAX_ERR_STRING_LEN + 1];
    pwstrResStr[0] = NULL;

    HINSTANCE hInst = _Module.GetResourceInstance();

    // load the localized resource string
    if (!LoadStringW(hInst, uResID, pwstrResStr, MAX_ERR_STRING_LEN))
    {
        // Couldn't load resource
        Assert("Error loading resource string" && false);
        hr = E_FAIL;
        goto done;
    }
    else
    {
        // Format the error message
        WCHAR pstrErrorMsg[MAX_ERR_STRING_LEN + 1];
        wvnsprintf(pstrErrorMsg, MAX_ERR_STRING_LEN, pwstrResStr, args);

        // Fire the error event
        hr = THR(FireErrorEvent(pstrErrorMsg));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done:
    return hr;
} // ReportError


//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMEElementBase::FireErrorEvent
//
//  Synopsis:   fires the error event on the body. 
//
//  Arguments:  Error message string
//
//  Returns:    
//
//------------------------------------------------------------------------------------
HRESULT 
CTIMEElementBase::FireErrorEvent(LPOLESTR szError)
{
    LPWSTR szParamNames[1] = {{ L"Error" }};
    VARIANT varParams[1];
    HRESULT hr = E_FAIL;
    CTIMEBodyElement *pBody = NULL;

    //initialize the event values
    VariantInit(&varParams[0]);
    varParams[0].vt =  VT_BSTR;
    if (szError)
    {
        varParams[0].bstrVal = SysAllocString(szError);
    }
    else
    {
        varParams[0].bstrVal = SysAllocString(L"");
    }

    pBody = GetBody();
    if (!pBody)
    {
        goto done;
    }

    hr = THR(pBody->FireEvents(TE_ONTIMEERROR, 1, szParamNames, varParams));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:

    VariantClear(&varParams[0]);
    return hr;
} // FireErrorEvent

    
//////////////////////////////////////////////////////////
//  Wraps the FIRE_EVENT macro into the event manager
//////////////////////////////////////////////////////////
HRESULT 
CTIMEElementBase::FireEvents(TIME_EVENT TimeEvent, 
                             long lCount, 
                             LPWSTR szParamNames[], 
                             VARIANT varParams[])
{
    HRESULT hr = S_OK;
    float fltTime = 0.0f;
    CComBSTR bstrReadyState;
    if (IsBodyDetaching() == true)
    {
        //this should only be hit in the case of thumbnail view which detachs without unloading
        goto done; 
    }

    fltTime = GetGlobalTime();
    if (TimeEvent == TE_ONMEDIACOMPLETE || TimeEvent == TE_ONMEDIAERROR)
    {
        if (GetParent() != NULL && GetParent()->GetMMTimeline() != NULL)
        {
            GetParent()->GetMMTimeline()->childMediaEventNotify(m_mmbvr, 0.0, TimeEvent);
        }
    }

    if (m_bReadyStateComplete == false)
    {
        GetReadyState  (GetElement(), &bstrReadyState);
        if (bstrReadyState != NULL && StrCmpIW(bstrReadyState, L"complete") == 0)
        {
            m_bReadyStateComplete = true;
        }
        else
        {
            m_bReadyStateComplete = false;
        }
    }

    if (m_bReadyStateComplete == true)
    {
        hr = TEM_FIRE_EVENT(TimeEvent, lCount, szParamNames, varParams, fltTime);
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;

  done:

    return hr;
}

//Determines if the element associated with this behavior has the focus or not.
bool 
CTIMEElementBase::HasFocus()
{
    CComPtr <IDispatch> pDocDisp;
    CComPtr <IHTMLDocument2> pDoc2;
    CComPtr <IHTMLElement> pEle;
    CComPtr <IUnknown> pUnk1;
    CComPtr <IUnknown> pUnk2;
    HRESULT hr = S_OK;
    bool bFocus = false;

    if (GetElement() == NULL)
    {
        goto done;
    }

    hr = THR(GetElement()->get_document(&pDocDisp));
    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
        goto done;
    }
    hr = THR(pDocDisp->QueryInterface(IID_IHTMLDocument2, (void **)&pDoc2));
    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
        goto done;
    }
    hr = pDoc2->get_activeElement(&pEle);
    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
        goto done;
    }
    //it is possible for the above call to succeed and still not return an element
    if (pEle == NULL)  
    {
        goto done;
    }

    hr = THR(pEle->QueryInterface(IID_IUnknown, (void **)&pUnk1));
    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
        goto done;
    }
    hr = THR(GetElement()->QueryInterface(IID_IUnknown, (void **)&pUnk2));
    if (FAILED(hr))
    {
        TIMESetLastError(hr, NULL);
        goto done; 
    }


    if (pUnk1 == pUnk2)
    {
        bFocus = true;
    }
done:
        
    return bFocus;
}


//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMEElementBase::IsReady
//
//  Synopsis:   Returns true if IsStarted is true (this guarantees 1. persistance is done, 
//              2. We have a Time Engine Node, 3. we have a parent and 4. we have a body)
//
//  Arguments:  None
//
//  Returns:    Return value of CTIMEElementBase::InitTimeline
//
//------------------------------------------------------------------------------------
bool
CTIMEElementBase::IsReady() const
{
    bool fIsReady = false;

    if (!IsStarted())
    {
        goto done;
    }

    // TODO: dilipk 10/13/99: eventually need to include a check for ReadyState of the bvr

    // Asserting these just to be safe. These should always succeed if we get here.
    Assert(NULL != m_mmbvr);
    // Check if we have a Time Engine node
    Assert(NULL != m_mmbvr->GetMMBvr());
    // Check if we have a parent
    Assert(NULL != m_pTIMEParent || IsBody());
    
    fIsReady = true;
done:
    return fIsReady;
} // IsReady


//+-----------------------------------------------------------------------------------
//
//  Member:     CTIMEElementBase::CascadedPropertyChanged
//
//  Synopsis:   Notify children that a cascaded property has changed on an ancestor (so they can
//              recompute values if necessary). This is recursive,
//              so eventually all of the sub-tree receives notification.
//
//  Returns:    Failure     An overriding method failed (e.g. CTIMEMediaElement::CascadedPropertyChanged)
//              S_OK        Otherwise
//
//------------------------------------------------------------------------------------

STDMETHODIMP
CTIMEElementBase::CascadedPropertyChanged(bool fNotifyChildren)
{
    HRESULT hr;
    CTIMEElementBase **ppElm;
    int i;

    if (fNotifyChildren)
    {
        for (i = m_pTIMEChildren.Size(), ppElm = m_pTIMEChildren;
             i > 0;
             i--, ppElm++)
        {
            Assert(ppElm);
            hr = THR((*ppElm)->CascadedPropertyChanged(fNotifyChildren));
            if (FAILED(hr))
            {
                goto done;
            }
        }
    }

    hr = S_OK;
done:
    return hr;
}


void
CTIMEElementBase::GetCascadedAudioProps(float * pflCascadedVolume, bool * pfCascadedMute)
{
    float flVolume = 0.0;
    bool bMuted = false;
    Assert(pflCascadedVolume);
    Assert(pfCascadedMute);

    flVolume = GetVolumeAttr().GetValue();
    bMuted = GetMuteAttr().GetValue();

    CTIMEElementBase * pTEBParent = GetParent();
    while(NULL != pTEBParent)
    {
        flVolume *= pTEBParent->GetVolumeAttr().GetValue();
        if (pTEBParent->GetMuteAttr().GetValue())
        {
            bMuted = true;
        }

        // early termination
        if (0.0f == flVolume &&  bMuted)
        {
            *pflCascadedVolume = 0.0f;
            *pfCascadedMute = true;
            return;
        }

        pTEBParent = pTEBParent->GetParent();
    }
    
    *pflCascadedVolume = flVolume;
    *pfCascadedMute = bMuted;

}


float
CTIMEElementBase::GetCascadedVolume()
{
    float flVolume;
    bool fMute;

    GetCascadedAudioProps(&flVolume, &fMute);

    return flVolume;
}


bool
CTIMEElementBase::GetCascadedMute()
{
    float flVolume;
    bool fMute;

    GetCascadedAudioProps(&flVolume, &fMute);

    return fMute;
}


//+-----------------------------------------------------------------------
//
//  Member:    base_get_updateMode
//
//  Overview:  alloc a bstr that represents the updateMode
//
//  Arguments: pbstrUpdateMode  where to store the BSTR
//             
//  Returns:   S_OK on Success, error code otherwise
//
//------------------------------------------------------------------------
HRESULT
CTIMEElementBase::base_get_updateMode(BSTR * pbstrUpdateMode)
{
    HRESULT hr = S_OK;

    CHECK_RETURN_SET_NULL(pbstrUpdateMode);

    *pbstrUpdateMode = ::SysAllocString(TokenToString(m_TAUpdateMode));
    
    hr = S_OK;
done:
    RRETURN(hr);
}

//+-----------------------------------------------------------------------
//
//  Member:    base_put_updateMode
//
//  Overview:  changes mode used when attributes are changed
//
//  Arguments: bstrUpdateMode   Mode to change to, one of Reset, Auto, or manual
//             
//  Returns:   S_OK on Success, error code otherwise
//
//------------------------------------------------------------------------
HRESULT
CTIMEElementBase::base_put_updateMode(BSTR bstrUpdateMode)
{
    HRESULT hr = S_OK;

    m_TAUpdateMode.Reset(DEFAULT_M_UPDATEMODE);
    
    if (NULL != bstrUpdateMode)
    {
        TOKEN tokUpdateModeVal;
        CTIMEParser pParser(bstrUpdateMode);

        hr = THR(pParser.ParseUpdateMode(tokUpdateModeVal));
        if (S_OK == hr)
        {
            m_TAUpdateMode.SetValue(tokUpdateModeVal);
        }
    }
    
    hr = S_OK;
  done:
    NotifyPropertyChanged(DISPID_TIMEELEMENT_UPDATEMODE);
    RRETURN(hr);
}

HRESULT
CTIMEElementBase::UpdateMMAPI(bool bUpdateBegin,
                              bool bUpdateEnd)
{
    HRESULT hr = S_OK;

    if (!IsReady() ||
        (MANUAL_TOKEN == m_TAUpdateMode))
    {
        hr = S_OK;
        goto done;
    }

    if (m_FADur.IsSet() && m_FADur == 0.0)
    {
        if (m_FARepeat.IsSet() && TIME_INFINITE == m_FARepeat)
        {
            VARIANT v;
            v.vt = VT_R4;
            v.fltVal = m_FARepeat;
            IGNORE_HR(ReportInvalidArg(WZ_REPEATCOUNT, v));
            goto done;
        }
            
        if (TE_UNDEFINED_VALUE != m_FARepeatDur)
        {
            VARIANT v;
            v.vt = VT_R4;
            v.fltVal = m_FARepeatDur;
            IGNORE_HR(ReportInvalidArg(WZ_REPEATDUR, v));
            goto done;
        }
    }

    if (m_SABegin.GetValue() && !StrCmpIW(m_SABegin, WZ_INDEFINITE))
    {
        // cannot have begin == indefinte with repeatDur == indefinite and dur == unknown
        if (m_FARepeatDur.IsSet() && m_FARepeatDur == TIME_INFINITE && !m_FADur.IsSet())
        {
            VARIANT v;
            v.vt = VT_R4;
            v.fltVal = m_FARepeatDur;
            IGNORE_HR(ReportInvalidArg(WZ_REPEATDUR, v));
            goto done;
        }

        // cannot have begin == indefinte with repeatCount == indefinite and dur == unknown
        if (m_FARepeat.IsSet() && m_FARepeat == TIME_INFINITE && !m_FADur.IsSet())
        {
            VARIANT v;
            v.vt = VT_R4;
            v.fltVal = m_FARepeat;
            IGNORE_HR(ReportInvalidArg(WZ_REPEATCOUNT, v));
            goto done;
        }
    }

    CalcTimes();

    // Force updating of the timing structures

    IGNORE_HR(m_mmbvr->Update(bUpdateBegin, bUpdateEnd));

    if (AUTO_TOKEN == m_TAUpdateMode)
    {
        IGNORE_HR(m_mmbvr->Reset(true));
    }
    else if (RESET_TOKEN == m_TAUpdateMode)
    {
        IGNORE_HR(m_mmbvr->Reset(false));
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMEElementBase::Load(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog)
{
    HRESULT hr = THR(::TimeLoad(this, CTIMEElementBase::PersistenceMap, pPropBag, pErrorLog));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(CBaseBvr::Load(pPropBag, pErrorLog));
done:
    return hr;
}

STDMETHODIMP
CTIMEElementBase::Save(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    HRESULT hr = S_OK;

    hr = THR(::TimeSave(this, CTIMEElementBase::PersistenceMap, pPropBag, fClearDirty, fSaveAllProperties));
    if (FAILED(hr))
    {
        goto done;
    }

    if (GetTimeAction() == STYLE_TOKEN && 
        m_timeAction.IsTimeActionOn() == false && 
        m_timeAction.GetTimeActionString() != NULL)
    {
        CComPtr <IHTMLStyle> pStyle;
        CComBSTR bstr;
        if (GetElement())
        {
            hr = THR(GetElement()->get_style(&pStyle));
            if (SUCCEEDED(hr))
            {
                hr = THR(pStyle->get_cssText(&bstr));
                if (SUCCEEDED(hr))
                {
                    if (bstr.m_str == NULL)
                    {
                        VARIANT vValue;
                        PROPBAG2 propbag;
                        propbag.vt = VT_BSTR;
                        propbag.pstrName = (LPWSTR)STYLE_TOKEN;
                        VariantInit(&vValue);
                        vValue.vt = VT_BSTR;
                        vValue.bstrVal = SysAllocString(m_timeAction.GetTimeActionString());
                        pPropBag->Write(1, &propbag, &vValue);
                        VariantClear(&vValue);
                    }
                }
            }
        }   
    }

    hr = THR(CBaseBvr::Save(pPropBag, fClearDirty, fSaveAllProperties));
done:
    return hr;

}

//+-----------------------------------------------------------------------
//
//  Member:    FindID
//
//  Overview:  Looks for an ID in the current element and its children
//
//  Arguments: lpwId     The id to look for
//             
//  Returns:   The element if it is found otherwise NULL
//
//------------------------------------------------------------------------
CTIMEElementBase *
CTIMEElementBase::FindID(LPCWSTR lpwId)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::FindID(%ls)",
              this,
              lpwId));

    Assert(lpwId != NULL);
    
    CTIMEElementBase * ptebRet;

    CTIMEElementBase **ppElm;
    int i;
    
    if (GetID() != NULL && StrCmpIW(lpwId, GetID()) == 0)
    {
        ptebRet = this;
        goto done;
    }
    
    for (i = m_pTIMEChildren.Size(), ppElm = m_pTIMEChildren;
         i > 0;
         i--, ppElm++)
    {
        ptebRet = (*ppElm)->FindID(lpwId);

        if (ptebRet != NULL)
        {
            goto done;
        }
    }
    
    ptebRet = NULL;
  done:
    return ptebRet;
}

//+-----------------------------------------------------------------------
//
//  Member:    ElementChangeNotify
//
//  Overview:  This will notify an element and its children that a
//  change occurred to another element
//
//  Arguments: pteb     The element which changed
//             tct      The change that occurred
//             
//  Returns:   void
//
//------------------------------------------------------------------------
void
CTIMEElementBase::ElementChangeNotify(CTIMEElementBase & teb,
                                      ELM_CHANGE_TYPE ect)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%p)::FindID(%p, %d)",
              this,
              &teb,
              ect));

    if (m_mmbvr == NULL)
    {
        goto done;
    }
    
    m_mmbvr->ElementChangeNotify(teb, ect);
    
    CTIMEElementBase **ppElm;
    int i;

    for (i = m_pTIMEChildren.Size(), ppElm = m_pTIMEChildren;
         i > 0;
         i--, ppElm++)
    {
        (*ppElm)->ElementChangeNotify(teb, ect);
    }

  done:
    return;
}

bool            
CTIMEElementBase::NeedFill()
{ 
    bool bNeedFill = false;

    if (GetFill() == REMOVE_TOKEN)
    {
        bNeedFill = false;
        TraceTag((tagTimeElmBaseNeedFill,
                  "CTIMEElementBase(%p, %ls)::NeedFill(fill==remove, %ls)",
                  this, GetID(), bNeedFill ? L"true" : L"false"));
    }
    else if (GetParent() == NULL)
    {
        bNeedFill = true;
        TraceTag((tagTimeElmBaseNeedFill,
                  "CTIMEElementBase(%p, %ls)::NeedFill(parent==NULL, %ls)",
                  this, GetID(), bNeedFill ? L"true" : L"false"));
    }
    else if (GetParent()->IsActive())
    {
        if (GetParent()->IsSequence())
        {
            bool bIsOn = m_timeAction.IsTimeActionOn();
            if(   (GetFill() == HOLD_TOKEN) 
               || (   ((GetFill() == FREEZE_TOKEN) || (m_fInTransitionDependentsList)) 
                   && (bIsOn == true)
                  )
              )
            {
                bNeedFill = true;
                TraceTag((tagTimeElmBaseNeedFill,
                          "CTIMEElementBase(%p, %ls)::NeedFill(parent==sequence, %ls)",
                          this, GetID(), bNeedFill ? L"true" : L"false"));
            }
            else
            {
                bNeedFill = false;
                TraceTag((tagTimeElmBaseNeedFill,
                          "CTIMEElementBase(%p, %ls)::NeedFill(parent==sequence, %ls)",
                          this, GetID(), bNeedFill ? L"true" : L"false"));
            }
        }
        else
        {
            bNeedFill = true;
            TraceTag((tagTimeElmBaseNeedFill,
                      "CTIMEElementBase(%p, %ls)::NeedFill(parent!=sequence, %ls)",
                      this, GetID(), bNeedFill ? L"true" : L"false"));
        }
    }
    else //the parent is not active
    {
        bNeedFill = GetParent()->NeedFill();
        TraceTag((tagTimeElmBaseNeedFill,
                  "CTIMEElementBase(%p, %ls)::NeedFill(parent not active, %ls)",
                  this, GetID(), bNeedFill ? L"true" : L"false"));
    }

    return bNeedFill; 
}


TOKEN    
CTIMEElementBase::GetFill()
{ 
    return m_TAFill; 
}

//*****************************************************************************

bool 
CTIMEElementBase::IsThumbnail()
{
    HRESULT hr;
    bool fThumbnail = false;

    switch (m_enumIsThumbnail)
    {
        // Uninitialized. Check if we are a thumbnail.
        case TSB_UNINITIALIZED:
        {
            CComPtr<IDispatch> spDispDoc;
            CComPtr<IHTMLDocument> spDoc;
            CComPtr<IHTMLDocument2> spDoc2;
            CComPtr<IOleObject> spOleObj;
            CComPtr<IOleClientSite> spClientSite;
            CComPtr<IUnknown> spUnkThumbnail;

            Assert(GetElement());

            hr = GetElement()->get_document(&spDispDoc);
            if (FAILED(hr))
            {
                goto done;
            }

            hr = spDispDoc->QueryInterface(IID_TO_PPV(IHTMLDocument2, &spDoc2));
            if (FAILED(hr))
            {
                goto done;
            }

            hr = spDoc2->QueryInterface(IID_TO_PPV(IOleObject, &spOleObj));
            if (FAILED(hr))
            {
                goto done;
            }

            hr = spOleObj->GetClientSite(&spClientSite);
            if (FAILED(hr) || spClientSite == NULL)
            {
                goto done;
            }

            hr = spClientSite->QueryInterface(IID_IThumbnailView, reinterpret_cast<void**>(&spUnkThumbnail));
            if (FAILED(hr))
            {
                goto done;
            }

            if (spUnkThumbnail.p)
            {
                fThumbnail = true;
            }
        }
        break;

        // Already checked, and we are NOT a thumbnail
        case TSB_FALSE:
        {
            fThumbnail = false;
        }
        break;

        // Already checked, and we ARE a thumbnail
        case TSB_TRUE:
        {
            fThumbnail = true;
        }
        break;

        default:
        {
            Assert(false);
        }
        break;
    } // switch

done:
    m_enumIsThumbnail = (fThumbnail ? TSB_TRUE : TSB_FALSE);

    return fThumbnail;
} // IsThumbnail


void
CTIMEElementBase::NotifyPropertyChanged(DISPID dispid)
{
    if (IsDetaching() || IsUnloading() || IsBodyUnloading())
    {
        return;
    }

    CBaseBvr::NotifyPropertyChanged(dispid);
}


void
CTIMEElementBase::SetSyncMaster(bool b)
{
    m_fCachedSyncMaster = b;

    if (!IsReady())
    {
        goto done;
    }
    
    m_mmbvr->SetSyncMaster(b);
done:
    return;
}

CTIMEElementBase*
CTIMEElementBase::FindLockedParent()
{
    CTIMEElementBase *pelem = this;

    while(pelem->GetParent())
    {
        if(pelem->IsBody())
        {
            break;
        }
        if(!pelem->IsLocked())
        {
            break;
        }
        pelem = pelem -> GetParent();
    }

    return pelem;
}

void
CTIMEElementBase::RemoveSyncMasterFromBranch(CTIMEElementBase *pElmStart)
{
    CTIMEElementBase *pElm = pElmStart;
    int childNr;

    while(1) //lint !e716
    {
        childNr = pElm->m_sHasSyncMMediaChild;
        pElm->m_sHasSyncMMediaChild = -1;

        if((childNr == -1) || ((pElm->m_pTIMEChildren).Size() == 0))
        {
            if(pElm->IsSyncMaster())
            {
                pElm->SetSyncMaster(false);
            }
            break;
        }
        pElm = pElm->m_pTIMEChildren[childNr];
    }

done:
    return;
}

void
CTIMEElementBase::GetSyncMasterList(std::list<CTIMEElementBase*> &syncList)
{
    int i;
    CTIMEElementBase **ppElm;

    for (i = m_pTIMEChildren.Size(), ppElm = m_pTIMEChildren; i > 0;i--, ppElm++)
    {
        if((*ppElm)->IsLocked())
        {
            (*ppElm)->GetSyncMasterList(syncList);
        }
    }

    if((m_BASyncMaster && IsMedia()) || m_fCachedSyncMaster || IsMedia())
    {
        syncList.push_back(this);
    }

}

//*****************************************************************************

HRESULT
CTIMEElementBase::base_get_transIn (VARIANT * transIn)
{
    // Uncomment when basic transitions are enabled.
    return E_NOTIMPL;
#if 0
    HRESULT hr;
    
    if (transIn == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(transIn))))
    {
        goto done;
    }
    
    V_VT(transIn) = VT_BSTR;
    V_BSTR(transIn) = SysAllocString(m_SAtransIn);

    hr = S_OK;
  done:
    return hr;
#endif
}

//*****************************************************************************

HRESULT
CTIMEElementBase::base_put_transIn(VARIANT transIn)
{
    // Uncomment when basic transitions are enabled.
    return E_NOTIMPL;
#if 0
    CComVariant v;
    HRESULT hr;
    bool clearFlag = false;

    if(V_VT(&transIn) == VT_NULL)
    {
        clearFlag = true;
    }
    else
    {
        hr = v.ChangeType(VT_BSTR, &transIn);

        if (FAILED(hr))
        {
            goto done;
        }
    }

    delete [] m_SAtransIn.GetValue();

    if(!clearFlag)
    {
        m_SAtransIn.SetValue(CopyString(V_BSTR(&v)));
    }
    else
    {
        m_SAtransIn.Reset(DEFAULT_M_TRANSIN);
    }

    NotifyPropertyChanged(DISPID_TIMEELEMENT2_TRANSIN);

done:
    return S_OK;
#endif
}

//*****************************************************************************

HRESULT
CTIMEElementBase::base_get_transOut(VARIANT * transOut)
{
    // Uncomment when basic transitions are enabled.
    return E_NOTIMPL;
#if 0
    HRESULT hr;
    
    if (transOut == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(transOut))))
    {
        goto done;
    }
    
    V_VT(transOut) = VT_BSTR;
    V_BSTR(transOut) = SysAllocString(m_SAtransOut);

    hr = S_OK;
  done:
    return hr;
#endif
}

//*****************************************************************************

HRESULT
CTIMEElementBase::base_put_transOut(VARIANT transOut)
{
    // Uncomment when basic transitions are enabled.
    return E_NOTIMPL;
#if 0
    CComVariant v;
    HRESULT hr;
    bool clearFlag = false;

    if(V_VT(&transOut) == VT_NULL)
    {
        clearFlag = true;
    }
    else
    {
        hr = v.ChangeType(VT_BSTR, &transOut);

        if (FAILED(hr))
        {
            goto done;
        }
    }

    delete [] m_SAtransOut.GetValue();

    if(!clearFlag)
    {
        m_SAtransOut.SetValue(CopyString(V_BSTR(&v)));
    }
    else
    {
        m_SAtransOut.Reset(DEFAULT_M_TRANSOUT);
    }

    NotifyPropertyChanged(DISPID_TIMEELEMENT2_TRANSOUT);

done:
    return S_OK;
#endif
}

//*****************************************************************************

HRESULT
CTIMEElementBase::RemoveTrans()
{
    if (m_sptransIn)
    {
        m_sptransIn->Detach();
    }
    if (m_sptransOut)
    {
        m_sptransOut->Detach();
    }

    m_sptransIn = NULL;
    m_sptransOut = NULL;

    return S_OK;
}

//*****************************************************************************

HRESULT 
CreateAndPopulateTrans(ITransitionElement ** ppTransition, 
                       ITIMEElement * piTarget, 
                       IHTMLElement * pHTML,
                       VARIANT_BOOL vbIsTransIn)
{
    HRESULT hr = S_OK;
    
    CComPtr<ITransitionElement> spTransition;

    if (VARIANT_TRUE == vbIsTransIn)
    {
        hr = THR(CreateTransIn(&spTransition));
    }
    else
    {
        hr = THR(CreateTransOut(&spTransition));
    }

    if (FAILED(hr))
    {
        goto done;
    }
        
    hr = THR(spTransition->put_htmlElement(pHTML));
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = THR(spTransition->put_timeElement(piTarget));
    if (FAILED(hr))
    {
        goto done;
    }

    if (ppTransition)
    {
        *ppTransition = spTransition;
        (*ppTransition)->AddRef();
    }

    hr = S_OK;
done:
    RRETURN(hr);
}

//*****************************************************************************

HRESULT
CTIMEElementBase::CreateTrans()
{
    HRESULT hr = S_OK;
    CComPtr<ITIMEElement> spte;

    hr = THR(QueryInterface(IID_TO_PPV(ITIMEElement, &spte)));
    if (FAILED(hr))
    {
        goto done;
    }
    
    if (m_SAtransIn)
    {
        // Transition in
        hr = CreateAndPopulateTrans(&m_sptransIn, spte, GetElement(), VARIANT_TRUE);
        if (FAILED(hr))
        {
            goto done;
        }
        
        hr = THR(m_sptransIn->put_template(m_SAtransIn));
        if (FAILED(hr))
        {
            goto done;
        }
        
        hr = THR(m_sptransIn->Init());
        if (FAILED(hr))
        {
            goto done;
        }
    }

    if (m_SAtransOut)
    {
        // Transition out
        hr = CreateAndPopulateTrans(&m_sptransOut, spte, GetElement(), VARIANT_FALSE);
        if (FAILED(hr))
        {
            goto done;
        }
        
        hr = THR(m_sptransOut->put_template(m_SAtransOut));
        if (FAILED(hr))
        {
            goto done;
        }
        
        hr = THR(m_sptransOut->Init());
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
done:
    if (FAILED(hr))
    {
        RemoveTrans();
    }

    RRETURN(hr);
}

//*****************************************************************************

bool
CTIMEElementBase::IsTransitionPresent()
{
    bool bRet = false;

    // check if there is a Transition attribute set
    if (m_SAtransIn || m_SAtransOut)
    {
        bRet = true;
        goto done;
    }

done:
    return bRet;
}

//*****************************************************************************

STDMETHODIMP
CTIMEElementBase::InitTransitionSite (void)
{
    return S_OK;
}

//*****************************************************************************

STDMETHODIMP
CTIMEElementBase::DetachTransitionSite (void)
{
    return S_OK;
}

//*****************************************************************************

STDMETHODIMP_(void)
CTIMEElementBase::SetDrawFlag(VARIANT_BOOL vb)
{
    m_vbDrawFlag = vb;
    return;
}

//*****************************************************************************

STDMETHODIMP
CTIMEElementBase::get_timeParentNode (ITIMENode  ** ppNode)
{
    HRESULT hr = S_OK;
    CTIMEElementBase *pcParent = GetParent();

    if (NULL == pcParent)
    {
        hr = E_FAIL;
        goto done;
    }

    {
        ITIMENode * pNode = pcParent->GetMMBvr().GetMMBvr();

        if ((NULL == pNode) || (NULL == ppNode))
        {
            hr = E_UNEXPECTED;
            goto done;
        }

        pNode->AddRef();
        *ppNode = pNode;
    }

    hr = S_OK;
done : 
    return hr;
}

//*****************************************************************************

STDMETHODIMP
CTIMEElementBase::get_node(ITIMENode  ** ppNode)
{
    Assert(ppNode);
    
    ITIMENode * pNode = GetMMBvr().GetMMBvr();
    if (pNode && ppNode)
    {
        pNode->AddRef();
        *ppNode = pNode;
        return S_OK;
    }

    return E_FAIL;
}

//*****************************************************************************

STDMETHODIMP
CTIMEElementBase::FireTransitionEvent (TIME_EVENT event)
{
    return FireEvent(event, 0, 0, 0);
}

//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timebvr\timeattr.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: timeattr.cpp
//
//  Contents: ITIMEElement attributes
//
//------------------------------------------------------------------------------------

#include "headers.h"
#include "timeelmbase.h"
#include "tokens.h"


//+-----------------------------------------------------------------------------------
//
// Static functions for persistence (used by the TIME_PERSISTENCE_MAP below)
//
//------------------------------------------------------------------------------------

#define TEB CTIMEElementBase

                // Function Name // Class // Attr Accessor      // COM put_ fn          // COM get_ fn   // IDL Arg type
TIME_PERSIST_FN(TEB_Accelerate,    TEB,   GetAccelerateAttr,    base_put_accelerate,    base_get_accelerate,    VARIANT);
TIME_PERSIST_FN(TEB_AutoReverse,   TEB,   GetAutoReverseAttr,   base_put_autoReverse,   base_get_autoReverse,   VARIANT);
TIME_PERSIST_FN(TEB_Begin,         TEB,   GetBeginAttr,         base_put_begin,         base_get_begin,         VARIANT);
TIME_PERSIST_FN(TEB_Decelerate,    TEB,   GetDecelerateAttr,    base_put_decelerate,    base_get_decelerate,    VARIANT);
TIME_PERSIST_FN(TEB_Dur,           TEB,   GetDurAttr,           base_put_dur,           base_get_dur,           VARIANT);
TIME_PERSIST_FN(TEB_End,           TEB,   GetEndAttr,           base_put_end,           base_get_end,           VARIANT);
TIME_PERSIST_FN(TEB_EndSync,       TEB,   GetEndSyncAttr,       base_put_endSync,       base_get_endSync,       VT_BSTR);
TIME_PERSIST_FN(TEB_Fill,          TEB,   GetFillAttr,          base_put_fill,          base_get_fill,          VT_BSTR);
TIME_PERSIST_FN(TEB_Mute,          TEB,   GetMuteAttr,          base_put_mute,          base_get_mute,          VARIANT);
TIME_PERSIST_FN(TEB_RepeatCount,   TEB,   GetRepeatAttr,        base_put_repeatCount,   base_get_repeatCount,   VARIANT);
TIME_PERSIST_FN(TEB_RepeatDur,     TEB,   GetRepeatDurAttr,     base_put_repeatDur,     base_get_repeatDur,     VARIANT);
TIME_PERSIST_FN(TEB_Restart,       TEB,   GetRestartAttr,       base_put_restart,       base_get_restart,       VT_BSTR);
TIME_PERSIST_FN(TEB_Speed,         TEB,   GetSpeedAttr,         base_put_speed,         base_get_speed,         VARIANT);
TIME_PERSIST_FN(TEB_SyncTolerance, TEB,   GetSyncToleranceAttr, base_put_syncTolerance, base_get_syncTolerance, VARIANT);
TIME_PERSIST_FN(TEB_SyncBehavior,  TEB,   GetSyncBehaviorAttr,  base_put_syncBehavior,  base_get_syncBehavior,  VT_BSTR);
TIME_PERSIST_FN(TEB_SyncMaster,    TEB,   GetSyncMasterAttr,    base_put_syncMaster,    base_get_syncMaster,    VARIANT);
TIME_PERSIST_FN(TEB_TimeAction,    TEB,   GetTimeActionAttr,    base_put_timeAction,    base_get_timeAction,    VT_BSTR);
TIME_PERSIST_FN(TEB_TimeContainer, TEB,   GetTimeContainerAttr, base_put_timeContainer, base_get_timeContainer, VT_BSTR);
TIME_PERSIST_FN(TEB_UpdateMode,    TEB,   GetUpdateModeAttr,    base_put_updateMode,    base_get_updateMode,    VT_BSTR);
TIME_PERSIST_FN(TEB_Volume,        TEB,   GetVolumeAttr,        base_put_volume,        base_get_volume,        VARIANT);
TIME_PERSIST_FN(TEB_TransIn,       TEB,   GetTransInAttr,       base_put_transIn,       base_get_transIn,       VARIANT);
TIME_PERSIST_FN(TEB_TransOut,      TEB,   GetTransOutAttr,      base_put_transOut,      base_get_transOut,      VARIANT);



//+-----------------------------------------------------------------------------------
//
//  Declare TIME_PERSISTENCE_MAP
//
//------------------------------------------------------------------------------------

//
// NOTE: timeContainer must preceed timeAction in the persistence map for correct results. (103374)
//

BEGIN_TIME_PERSISTENCE_MAP(CTIMEElementBase)
                           // Attr Name         // Function Name
    PERSISTENCE_MAP_ENTRY( WZ_ACCELERATE,       TEB_Accelerate )
    PERSISTENCE_MAP_ENTRY( WZ_AUTOREVERSE,      TEB_AutoReverse )
    PERSISTENCE_MAP_ENTRY( WZ_BEGIN,            TEB_Begin )
    PERSISTENCE_MAP_ENTRY( WZ_DECELERATE,       TEB_Decelerate )
    PERSISTENCE_MAP_ENTRY( WZ_DUR,              TEB_Dur )
    PERSISTENCE_MAP_ENTRY( WZ_END,              TEB_End )
    PERSISTENCE_MAP_ENTRY( WZ_ENDSYNC,          TEB_EndSync )
    PERSISTENCE_MAP_ENTRY( WZ_FILL,             TEB_Fill )
    PERSISTENCE_MAP_ENTRY( WZ_MUTE,             TEB_Mute )
    PERSISTENCE_MAP_ENTRY( WZ_REPEATCOUNT,      TEB_RepeatCount )
    PERSISTENCE_MAP_ENTRY( WZ_REPEATDUR,        TEB_RepeatDur )
    PERSISTENCE_MAP_ENTRY( WZ_RESTART,          TEB_Restart )
    PERSISTENCE_MAP_ENTRY( WZ_SPEED,            TEB_Speed )
    PERSISTENCE_MAP_ENTRY( WZ_SYNCTOLERANCE,    TEB_SyncTolerance )
    PERSISTENCE_MAP_ENTRY( WZ_SYNCBEHAVIOR,     TEB_SyncBehavior )
    PERSISTENCE_MAP_ENTRY( WZ_SYNCMASTER,       TEB_SyncMaster )
    PERSISTENCE_MAP_ENTRY( WZ_TIMECONTAINER,    TEB_TimeContainer )
    PERSISTENCE_MAP_ENTRY( WZ_TIMEACTION,       TEB_TimeAction ) /* This should always come after timeContainer */
    PERSISTENCE_MAP_ENTRY( WZ_UPDATEMODE,       TEB_UpdateMode )
    PERSISTENCE_MAP_ENTRY( WZ_VOLUME,           TEB_Volume )
    PERSISTENCE_MAP_ENTRY( WZ_TRANSIN,          TEB_TransIn )
    PERSISTENCE_MAP_ENTRY( WZ_TRANSOUT,         TEB_TransOut )
    
END_TIME_PERSISTENCE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timebvr\timeelm.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1998
//
//  File: src\time\src\timeelm.h
//
//  Contents: TIME behavior
//
//------------------------------------------------------------------------------------


#pragma once


#ifndef _TIMEELM_H
#define _TIMEELM_H

#include "timeelmimpl.h"

//+-------------------------------------------------------------------------------------
//
// CTIMEElement
//
//--------------------------------------------------------------------------------------

class
ATL_NO_VTABLE
__declspec(uuid("efbad7f8-3f94-11d2-b948-00c04fa32195")) 
CTIMEElement :
    public CTIMEElementImpl<ITIMEElement, &IID_ITIMEElement>,
    public CComCoClass<CTIMEElement, &__uuidof(CTIMEElement)>,
    public ISupportErrorInfoImpl<&IID_ITIMEElement>,
    public IConnectionPointContainerImpl<CTIMEElement>,
    public IPersistPropertyBag2,
    public ITIMETransitionSite,
    public IPropertyNotifySinkCP<CTIMEElement>
{

public:

    //+--------------------------------------------------------------------------------
    //
    // Public Methods
    //
    //---------------------------------------------------------------------------------

    CTIMEElement();
    virtual ~CTIMEElement();
        
#if DBG
    const _TCHAR * GetName() { return __T("CTIMEElement"); }
#endif

    //
    // IPersistPropertyBag2
    // 

    STDMETHOD(GetClassID)(CLSID* pclsid) { return CTIMEElementBase::GetClassID(pclsid); }
    STDMETHOD(InitNew)(void) { return CTIMEElementBase::InitNew(); }
    STDMETHOD(IsDirty)(void) { return S_OK; }
    STDMETHOD(Load)(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog);
    STDMETHOD(Save)(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

    //
    // ITIMETransitionSite
    //
    STDMETHOD(InitTransitionSite)(void)
    { return CTIMEElementBase::InitTransitionSite(); }
    STDMETHOD(DetachTransitionSite)(void)
    { return CTIMEElementBase::DetachTransitionSite(); }
    STDMETHOD_(void, SetDrawFlag)(VARIANT_BOOL b)
    { return CTIMEElementBase::SetDrawFlag(b); }
    STDMETHOD(get_node)(ITIMENode ** ppNode)
    { return CTIMEElementBase::get_node(ppNode); }
    STDMETHOD(get_timeParentNode)(ITIMENode  ** ppNode)
    { return CTIMEElementBase::get_timeParentNode(ppNode); }
    STDMETHOD(FireTransitionEvent)(TIME_EVENT event)
    { return CTIMEElementBase::FireTransitionEvent(event); }

    //
    // QI Map
    //

    BEGIN_COM_MAP(CTIMEElement)
        COM_INTERFACE_ENTRY(ITIMEElement)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ITIMETransitionSite)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IPersistPropertyBag2)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
        COM_INTERFACE_ENTRY_CHAIN(CBaseBvr)
    END_COM_MAP();

    //
    // Connection Point to allow IPropertyNotifySink
    //

    BEGIN_CONNECTION_POINT_MAP(CTIMEElement)
        CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
    END_CONNECTION_POINT_MAP();

    //
    // This must be in the derived class and not the base class since
    // the typecast down to the base class messes things up
    //

    static inline HRESULT WINAPI
    InternalQueryInterface(CTIMEElement* pThis,
                           const _ATL_INTMAP_ENTRY* pEntries,
                           REFIID iid,
                           void** ppvObject);

    //
    // Needed by CBvrBase
    //

    void * GetInstance() { return (ITIMEElement *) this; }
    HRESULT GetTypeInfo(ITypeInfo ** ppInfo) { return GetTI(GetUserDefaultLCID(), ppInfo); }
    
    //+--------------------------------------------------------------------------------
    //
    // Public Data
    //
    //---------------------------------------------------------------------------------

protected:
    
    //+--------------------------------------------------------------------------------
    //
    // Protected Methods
    //
    //---------------------------------------------------------------------------------

    //
    // Persistence and Notification helpers
    //

    virtual HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP);

    //
    // Misc. methods
    //

    HRESULT Error();

    //+--------------------------------------------------------------------------------
    //
    // Protected Data
    //
    //---------------------------------------------------------------------------------

    static DWORD            ms_dwNumTimeElems;

private:

    //+--------------------------------------------------------------------------------
    //
    // Private methods
    //
    //---------------------------------------------------------------------------------

    //+--------------------------------------------------------------------------------
    //
    // Private Data
    //
    //---------------------------------------------------------------------------------
 
}; // CTIMEElement




//+---------------------------------------------------------------------------------
//  CTIMEElement inline methods
//
//  (Note: as a general guideline, single line functions belong in the class declaration)
//
//----------------------------------------------------------------------------------

inline 
HRESULT WINAPI
CTIMEElement::InternalQueryInterface(CTIMEElement* pThis,
                                     const _ATL_INTMAP_ENTRY* pEntries,
                                     REFIID iid,
                                     void** ppvObject)
{ 
    return BaseInternalQueryInterface(pThis,
                                      (void *) pThis,
                                      pEntries,
                                      iid,
                                      ppvObject); 
}


#endif /* _TIMEELM_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timebvr\timeelmbase.h ===
//+-----------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1998
//
//  File: timeelmbase.h
//
//  Contents: TIME Element base class
//
//------------------------------------------------------------------------------

#pragma once

#ifndef _TIMEELMBASE_H
#define _TIMEELMBASE_H

#include "resource.h"
#include "basebvr.h"
#include "tokens.h"
#include "eventmgr.h"
#include "mmutil.h"
#include "mmtimeline.h"
#include "collect.h"
#include "activeele.h"
#include "timeaction.h"
#include "timevalue.h"
#include "timeparser.h"
#include "attr.h"
#include "transsite.h"

class CCollectionCache;
class CActiveElementCollection;
class CTIMECurrTimeState;
class CTIMEBodyElement;
class CTransitionDependencyManager;
interface ITransitionElement;

const float DEFAULT_SYNC_TOLERANCE_S = 0.2f;

// disabling because already defined in eventmgr.h
// #define valueNotSet                   -1

//+-----------------------------------------------------------------------------
//
// CTIMEElementBase
//
//------------------------------------------------------------------------------

class
ATL_NO_VTABLE
CTIMEElementBase : 
    public CTIMEEventSite,
    public CBaseBvr
{

  public:

    //+-------------------------------------------------------------------------
    //
    // Public Methods
    //
    //--------------------------------------------------------------------------

    CTIMEElementBase();
    virtual ~CTIMEElementBase();
        
#if DBG
    const _TCHAR * GetName() { return __T("CTIMEElementBase"); }
#endif

    //
    // Enum definitions
    //

    typedef enum COLLECTION_INDEX
    {
        ciAllElements,
        ciChildrenElements,
        NUM_COLLECTIONS
    };

    //
    // IUnknown
    //

    STDMETHOD_(ULONG,AddRef)(void) = 0;
    STDMETHOD_(ULONG,Release)(void) = 0;
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) = 0;

    //
    // IElementBehavior
    //

    STDMETHOD(Init)(IElementBehaviorSite * pBvrSite);
    STDMETHOD(Notify)(LONG event, VARIANT * pVar);
    STDMETHOD(Detach)();

    //
    // ITIMEElement properties
    //
    
    HRESULT base_get_accelerate(VARIANT *);
    HRESULT base_put_accelerate(VARIANT);

    HRESULT base_get_autoReverse(VARIANT *);
    HRESULT base_put_autoReverse(VARIANT );

    HRESULT base_get_begin(VARIANT * time);
    HRESULT base_put_begin(VARIANT time);

    HRESULT base_get_decelerate(VARIANT * );
    HRESULT base_put_decelerate(VARIANT);

    HRESULT base_get_dur(VARIANT * time);
    HRESULT base_put_dur(VARIANT time);

    HRESULT base_get_end(VARIANT * time);
    HRESULT base_put_end(VARIANT time);

    HRESULT base_get_fill(LPOLESTR * f);
    HRESULT base_put_fill(LPOLESTR f);

    HRESULT base_get_mute(VARIANT * b);
    HRESULT base_put_mute(VARIANT b);

    HRESULT base_get_repeatCount(VARIANT * c);
    HRESULT base_put_repeatCount(VARIANT c);

    HRESULT base_get_repeatDur(VARIANT * time);
    HRESULT base_put_repeatDur(VARIANT time);

    HRESULT base_get_restart(LPOLESTR *);
    HRESULT base_put_restart(LPOLESTR );

    HRESULT base_get_speed(VARIANT * speed);
    HRESULT base_put_speed(VARIANT speed);

    HRESULT base_get_syncBehavior(LPOLESTR * sync);
    HRESULT base_put_syncBehavior(LPOLESTR sync);

    HRESULT base_get_syncTolerance(VARIANT * tol);
    HRESULT base_put_syncTolerance(VARIANT tol);

    HRESULT base_get_syncMaster(VARIANT * b);
    HRESULT base_put_syncMaster(VARIANT b);

    HRESULT base_get_timeAction(LPOLESTR * time);
    HRESULT base_put_timeAction(LPOLESTR time);

    HRESULT base_get_timeContainer(LPOLESTR *);
    HRESULT base_put_timeContainer(LPOLESTR );

    HRESULT base_get_volume(VARIANT * val);
    HRESULT base_put_volume(VARIANT val);

    // Basic transition properties
    HRESULT base_get_transIn (VARIANT * val);
    HRESULT base_put_transIn (VARIANT val);
    HRESULT base_get_transOut (VARIANT * val);
    HRESULT base_put_transOut (VARIANT val);

    // Properties
    HRESULT base_get_currTimeState(ITIMEState ** TimeState);

    HRESULT base_get_timeAll(ITIMEElementCollection **allColl);

    HRESULT base_get_timeChildren(ITIMEElementCollection **childColl);
    bool            IsNodeAtBeginTime();

    HRESULT base_get_timeParent(ITIMEElement ** parent);

    HRESULT base_get_isPaused(VARIANT_BOOL * b);

    // Methods
    HRESULT base_beginElement(double dblOffset);

    HRESULT base_beginElementAt(double parentTime, double dblOffset);

    HRESULT base_endElement(double dblOffset);

    HRESULT base_endElementAt(double parentTime, double dblOffset);

    HRESULT base_pauseElement();

    HRESULT base_resetElement();

    HRESULT base_resumeElement();

    HRESULT base_seekActiveTime(double activeTime);
        
    HRESULT base_seekSegmentTime(double segmentTime);
        
    HRESULT base_seekTo(LONG repeatCount, double segmentTime);
        
    HRESULT base_documentTimeToParentTime(double documentTime,
                                          double * parentTime);
        
    HRESULT base_parentTimeToDocumentTime(double parentTime,
                                          double * documentTime);
        
    HRESULT base_parentTimeToActiveTime(double parentTime,
                                        double * activeTime);
        
    HRESULT base_activeTimeToParentTime(double activeTime,
                                        double * parentTime);
        
    HRESULT base_activeTimeToSegmentTime(double activeTime,
                                         double * segmentTime);
        
    HRESULT base_segmentTimeToActiveTime(double segmentTime,
                                         double * activeTime);
        
    HRESULT base_segmentTimeToSimpleTime(double segmentTime,
                                         double * simpleTime);
        
    HRESULT base_simpleTimeToSegmentTime(double simpleTime,
                                         double * segmentTime);
        
    // Container attributes
    HRESULT base_get_endSync(LPOLESTR * es);
    HRESULT base_put_endSync(LPOLESTR es);

    // Container Properties
    HRESULT base_get_activeElements(ITIMEActiveElementCollection **activeColl);
    HRESULT base_get_hasMedia(VARIANT_BOOL * pvbVal);

    // Container Methods
    HRESULT base_nextElement();
    HRESULT base_prevElement();

    HRESULT base_get_updateMode(BSTR * pbstrUpdateMode);
    HRESULT base_put_updateMode(BSTR bstrUpdateMode);
    
    //
    //
    //
    
    HRESULT GetCollection(COLLECTION_INDEX index, ITIMEElementCollection **ppDisp);
    HRESULT BeginElement(double dblOffset);
    HRESULT AddTIMEElement(CTIMEElementBase *bvr);
    HRESULT RemoveTIMEElement(CTIMEElementBase *bvr);

    //
    // ITIMETransitionSite
    //
    STDMETHOD(InitTransitionSite)(void);
    STDMETHOD(DetachTransitionSite)(void);
    STDMETHOD_(void, SetDrawFlag)(VARIANT_BOOL b);
    STDMETHOD(get_node)(ITIMENode ** ppNode);
    STDMETHOD(get_timeParentNode)(ITIMENode  ** ppNode);
    STDMETHOD(FireTransitionEvent)(TIME_EVENT event);

    //
    // CTIMEEventSite methods
    //

    STDMETHOD(EventNotify)(long event);
    STDMETHOD(onBeginEndEvent)(bool bBegin, float beginTime, float beginOffset, bool bend, float endTime, float endOffset);
    STDMETHOD(onPauseEvent)(float time, float fOffset);
    STDMETHOD(onResumeEvent)(float time, float fOffset);
    STDMETHOD(onLoadEvent)();
    STDMETHOD(onUnloadEvent)();
    STDMETHOD(onReadyStateChangeEvent)(LPOLESTR lpstrReadyState);
    STDMETHOD(onStopEvent)(float time);
    STDMETHOD(get_playState)(long *State);
    float GetGlobalTime();
    bool IsThumbnail();

    //
    // QI Stuff
    //

    // We cannot put the real one here since the typecast causes it to
    // get the wrong vtables
    static HRESULT WINAPI
    BaseInternalQueryInterface(CTIMEElementBase* pThis,
                               void * pv,
                               const _ATL_INTMAP_ENTRY* pEntries,
                               REFIID iid,
                               void** ppvObject);
    // This must be in the derived class and not the base class since
    // the typecast down to the base class messes things up
    // Add a dummy one to assert just in case the derived class does
    // not add one
    static inline HRESULT WINAPI
    InternalQueryInterface(CTIMEElementBase* pThis,
                           const _ATL_INTMAP_ENTRY* pEntries,
                           REFIID iid,
                           void** ppvObject);

    //
    // Event Handlers
    //

    virtual void OnLoad();
    virtual void OnUnload()                         {}
    virtual void OnBeforeUnload (void)              { m_bUnloading = true; }
    virtual void OnPropChange(LPOLESTR propname)    {}
    virtual void OnReadyStateChange(TOKEN state)    {}
    virtual void OnBegin(double dblLocalTime, DWORD flags);
    virtual void OnReverse(double dblLocalTime);
    virtual void OnEnd(double dblLocalTime);
    virtual void OnPause(double dblLocalTime);
    virtual void OnResume(double dblLocalTime);
    virtual void OnReset(double dblLocalTime, DWORD flags);
    virtual void OnUpdate(double dblLocalTime, DWORD flags) {};
    virtual void OnRepeat(double dbllastTime);
    virtual void OnSeek(double dblLocalTime);
    virtual void OnTick();
    virtual void OnTEPropChange(DWORD tePropType);
    virtual void UpdateSync() {}
    virtual void NotifyBodyUnloading();
    virtual void NotifyBodyDetaching();
    virtual void NotifyBodyLoading();

    //
    // State query functions
    //

    bool            IsLocked()              { return GetRealSyncBehavior() == LOCKED_TOKEN; }
    virtual bool    IsGroup() const         { return (m_TTATimeContainer == ttPar) || (m_TTATimeContainer == ttSeq) || (m_TTATimeContainer == ttExcl); }
    bool            IsGroup(IHTMLElement *pElement); // determine if elem passed in is a group
    bool            IsPar() const           { return (m_TTATimeContainer == ttPar); }
    bool            IsSequence() const      { return (m_TTATimeContainer == ttSeq); }
    bool            IsExcl() const          { return (m_TTATimeContainer == ttExcl); }
    TimelineType    GetTimeContainer() const{ return m_TTATimeContainer; }
    virtual bool    IsBody() const          { return false; }
    virtual bool    IsEmptyBody() const          { return false; }
    virtual bool    IsMedia() const          { return false; }

    // Use of IsStarted() will be deprecated, use IsReady() instead 
    bool            IsStarted() const       { return m_bStarted; }
    bool            IsDetaching()           { return m_fDetaching; }
    bool            IsUnloading (void)      { return m_bUnloading; }
    bool            IsBodyUnloading (void)  { return m_bBodyUnloading; }
    bool            IsBodyDetaching (void)  { return m_bBodyDetaching; }
    bool            IsDocumentInEditMode();
    bool            IsPaused() const;
    bool            IsCurrPaused() const;
    virtual bool    isNaturalDuration()     { return false;}
    bool            HasFocus();
    bool            IsReady() const;
    bool            IsActive() const;
    bool            IsOn() const;
    bool            IsSyncMaster() const    { return m_fCachedSyncMaster; } 
    bool            NeedFill();
    bool            GetTESpeed(float &flSpeed);
    double          GetTESimpleTime();
    void            SetSyncMaster(bool b);
    virtual bool    ContainsMediaElement() { return false; }
    bool            IsLoaded() { return m_bLoaded; }
    bool            HasWallClock() { return m_fHasWallClock; }

    //
    // GetXXXAttr Accessors
    //

    CAttr<float>        & GetSpeedAttr()         { return m_FASpeed; }
    CAttr<float>        & GetVolumeAttr()        { return m_FAVolume; }
    CAttr<float>        & GetDurAttr()           { return m_FADur; }
    CAttr<float>        & GetAccelerateAttr()    { return m_FAAccelerate; }
    CAttr<float>        & GetDecelerateAttr()    { return m_FADecelerate; }
    CAttr<float>        & GetRepeatAttr()        { return m_FARepeat; }
    CAttr<float>        & GetRepeatDurAttr()     { return m_FARepeatDur; }
    CAttr<float>        & GetSyncToleranceAttr() { return m_FASyncTolerance; }
    CAttr<bool>         & GetAutoReverseAttr()   { return m_BAAutoReverse; }
    CAttr<bool>         & GetMuteAttr()          { return m_BAMute; }
    CAttr<bool>         & GetSyncMasterAttr()    { return m_BASyncMaster; }
    CAttr<TOKEN>        & GetFillAttr()          { return m_TAFill; } 
    CAttr<TOKEN>        & GetRestartAttr()       { return m_TARestart; } 
    CAttr<TOKEN>        & GetSyncBehaviorAttr()  { return m_TASyncBehavior; } 
    CAttr<LPWSTR>       & GetBeginAttr()         { return m_SABegin; } 
    CAttr<LPWSTR>       & GetEndAttr()           { return m_SAEnd; } 
    CAttr<LPWSTR>       & GetEndSyncAttr()       { return m_SAEndSync; } 
    CAttr<TimelineType> & GetTimeContainerAttr() { return m_TTATimeContainer; }
    CAttr<LPWSTR>       & GetTimeActionAttr()    { return m_SATimeAction; }
    CAttr<TOKEN>        & GetUpdateModeAttr()    { return m_TAUpdateMode; }
    CAttr<LPWSTR>       & GetTransInAttr ()      { return m_SAtransIn; }
    CAttr<LPWSTR>       & GetTransOutAttr ()     { return m_SAtransOut; }
    
    //
    // General Accessors
    //

    // GetXXX 
    LPWSTR   GetBeginTime() const                { return m_SABegin;}
    float    GetDuration() const                 { return m_FADur; } 
    float    GetRepeat() const                   { return m_FARepeat; }
    float    GetRepeatDur() const                { return m_FARepeatDur; }
    float    GetAccel() const                    { return m_FAAccelerate; }
    float    GetDecel() const                    { return m_FADecelerate; }
    bool     GetAutoReverse() const              { return m_BAAutoReverse; }
    float    GetSpeed() const                    { return m_FASpeed; }
    TOKEN    GetTimeAction()                     { return m_timeAction.GetTimeAction(); }
    LPWSTR   GetEnd() const                      { return m_SAEnd; }
    LPWSTR   GetEndSync();                  
    // Be aware that this can return NULL if no ID was set on the element
    LPWSTR   GetID() const                       { return m_id; }
    float    GetVolume() const                   { return m_FAVolume; }
    bool     GetMuted() const                    { return m_BAMute; }
    void     GetCascadedAudioProps(float * pflCascadedVolume, bool * pfCascadedMute);
    float    GetCascadedVolume();
    bool     GetCascadedMute();
    TOKEN    GetFill();
    TOKEN    GetRestart() const                  { return m_TARestart; }
    float    GetRealDuration() const             { return m_realDuration; }
    float    GetRealRepeatTime() const           { return m_realRepeatTime; }
    float    GetRealRepeatCount() const          { return m_realRepeatCount; }
    float    GetRealIntervalDuration(void) const { return m_realIntervalDuration; }
    long     GetImmediateChildCount() const      { return m_pTIMEChildren.Size(); } 
    float    GetRealSyncTolerance();
    TOKEN    GetRealSyncBehavior();
    TE_STATE GetPlayState();
    int      GetTimeChildIndex(CTIMEElementBase *pelm);
    long     GetAllChildCount();
    HRESULT  getTagString(BSTR *pbstrID);
    HRESULT  getIDString(BSTR *pbstrTag);

    TimeValueList & GetRealBeginValue()         { return m_realBeginValue; }
    TimeValueList & GetRealEndValue()           { return m_realEndValue; }

    CActiveElementCollection * 
             GetActiveElementCollection()       { return m_activeElementCollection; }
    CCollectionCache *         
             GetCollectionCache()               { return m_pCollectionCache; }
    CTIMEElementBase *         
             GetChild(long i);
    CTIMEElementBase *         
             GetParent()                        { return m_pTIMEParent; }
    CTIMEBodyElement * GetBody();
    MMPlayer *      GetPlayer();
    MMBaseBvr &     GetMMBvr();
    MMTimeline *    GetMMTimeline()                    { return m_timeline; }
    virtual HRESULT GetSyncMaster(double & dblNewSegmentTime,
                                  LONG & lNewRepeatCount,
                                  bool & bCueing);
    virtual HRESULT GetSize(RECT * prcPos);
    virtual TimeState GetTimeState();
    bool    GetIsSwitch()                       { return m_bIsSwitch; };
    bool    GetUseDefaultFill()                 { return m_fUseDefaultFill; };
    void    UpdateDefaultFill(TOKEN tFill)      { m_TAFill.InternalSet(tFill); };

    // SetXXX/PutXXX
    virtual HRESULT SetSize(const RECT * prcPos);
    HRESULT SetHeight(long lheight);
    HRESULT SetWidth(long lwidth);
    HRESULT PutCachedSyncMaster(bool fSyncMaster);
    void SetLocalTimeDirty(bool fDirty) { m_fLocalTimeDirty = fDirty; }

    //
    // Helpers for dealing with ids of time elements
    //
    
    CTIMEElementBase * FindID(LPCWSTR lpwId);
    void ElementChangeNotify(CTIMEElementBase & teb, ELM_CHANGE_TYPE ect);
    
    //
    // Misc. methods
    //

    HRESULT FireEvents(TIME_EVENT TimeEvent, 
                       long lCount, 
                       LPWSTR szParamNames[], 
                       VARIANT varParams[]);
    bool ChildPropNotify(CTIMEElementBase & teb,
                         DWORD & tePropType);
    HRESULT ClearSize();
    STDMETHOD(GetRuntimeStyle)(IHTMLStyle ** s);
    HRESULT Update();
    virtual HRESULT InitTimeline(void);
    HRESULT FireEvent(TIME_EVENT TimeEvent, double dblLocalTime, DWORD flags, long lRepeatCount);
    HRESULT EnsureCollectionCache();
    HRESULT InvalidateCollectionCache();
    HRESULT ClearCachedSyncMaster();

    //
    // fill=transition notifications
    //
    HRESULT OnResolveDependent(CTransitionDependencyManager *pcNewManager);
    HRESULT OnBeginTransition (void);
    HRESULT OnEndTransition (void);

    // DOM Error reporting utilities 
    HRESULT FireErrorEvent(LPOLESTR szError);
    HRESULT ReportError(UINT uResID, ...);
    HRESULT ReportInvalidArg(LPCWSTR pstrPropName, VARIANT & varValue);
    void NotifyPropertyChanged(DISPID dispid);

    //sets volume, mute on player
    virtual void UpdatePlayerAudioProperties() {};
        
    bool        IsDetaching() const { return m_fDetaching; }

    CAtomTable *GetAtomTable();

    virtual bool ToggleTimeAction(bool on);

    TOKEN       GetPriorityClassHigher() { return m_tokPriorityClassHigher; }
    TOKEN       GetPriorityClassPeers() { return m_tokPriorityClassPeers; }
    TOKEN       GetPriorityClassLower() { return m_tokPriorityClassLower; }

    void NotifyTimeStateChange(DISPID dispid);
    
    //
    // Accessors
    //

    virtual LPCWSTR GetBehaviorURN() { return WZ_TIME_URN; }
    virtual LPCWSTR GetBehaviorName(void) { return WZ_REGISTERED_TIME_NAME; }
    void            GetSyncMasterList(std::list<CTIMEElementBase*> &syncList);

    HRESULT SetParent(ITIMEElement *pelem, bool fReparentChildren = true);

protected:

    //+-------------------------------------------------------------------------
    //
    // Protected Methods
    //
    //--------------------------------------------------------------------------

    //
    // Event map for the new event manager.
    //

    DECLARE_EVENT_MANAGER() //this must be in the base class, not the child classes.

    BEGIN_TIME_EVENTMAP() 
        TEM_INIT_EVENTMANAGER_SITE() 
        TEM_REGISTER_EVENT(TE_ONBEGIN)
        TEM_REGISTER_EVENT(TE_ONPAUSE)
        TEM_REGISTER_EVENT(TE_ONRESUME)
        TEM_REGISTER_EVENT(TE_ONEND)
        TEM_REGISTER_EVENT(TE_ONREPEAT)
        TEM_REGISTER_EVENT(TE_ONREVERSE)
        TEM_REGISTER_EVENT(TE_ONRESET)
        TEM_REGISTER_EVENT(TE_ONSEEK)
        TEM_REGISTER_EVENT(TE_ONTIMEERROR)
        TEM_REGISTER_EVENT(TE_ONTRANSITIONINBEGIN)
        TEM_REGISTER_EVENT(TE_ONTRANSITIONINEND)
        TEM_REGISTER_EVENT(TE_ONTRANSITIONOUTBEGIN)
        TEM_REGISTER_EVENT(TE_ONTRANSITIONOUTEND)
        TEM_REGISTER_EVENT(TE_ONTRANSITIONREPEAT)
        TEM_REGISTER_EVENT_NOTIFICATION(TEN_LOAD)
        TEM_REGISTER_EVENT_NOTIFICATION(TEN_UNLOAD)
        TEM_REGISTER_EVENT_NOTIFICATION(TEN_READYSTATECHANGE)
        TEM_REGISTER_EVENT_NOTIFICATION(TEN_STOP)
    END_TIME_EVENTMAP()

    //
    // Persistence and Notification helpers
    //

    STDMETHOD(OnPropertiesLoaded)(void);
    STDMETHOD(Load)(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog);
    STDMETHOD(Save)(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

    //
    // TimeAction related methods
    //

    bool        AddTimeAction();
    bool        RemoveTimeAction();
    void        UpdateTimeAction();
    void        UpdateEndEvents();

    //
    // TransitionDependentList methods
    //
    void        AddToTransitionDependents      (void);
    void        RemoveFromTransitionDependents (void);

    //
    // State query methods
    //

    virtual bool IsBehaviorAttached(void) { return IsTIMEBehaviorAttached(GetElement()); }

    //
    // Misc. methods
    //

    STDMETHOD(      CreateActiveEleCollection)();
    virtual HRESULT Error(void) = 0;
    virtual HRESULT StartRootTime(MMTimeline * tl);
    virtual void    StopRootTime(MMTimeline * tl);
    void            CalcTimes();
    STDMETHOD(      CascadedPropertyChanged)(bool fNotifyChildren);
    virtual void    InitOnLoad(){};
    void            HandleAnimationSeek();
    VARIANT_BOOL    GetDrawFlag (void)
    { return m_vbDrawFlag; }

    CTIMEElementBase* FindLockedParent();
    void RemoveSyncMasterFromBranch(CTIMEElementBase *pElmStart);
    void SetupPriorityClassParent();

    bool IsSequencedElementOn (void);
    
    //+-------------------------------------------------------------------------
    //
    // Protected Data
    //
    //--------------------------------------------------------------------------

    // Attributes
    CAttr<LPWSTR>   m_SABegin;
    CAttr<float>    m_FADur;
    CAttr<LPWSTR>   m_SAEnd;
    CAttr<LPWSTR>   m_SAEndSync;
    CAttr<TOKEN>    m_TAFill;
    CAttr<TOKEN>    m_TARestart;
    CAttr<float>    m_FARepeat;
    CAttr<float>    m_FARepeatDur;
    CAttr<float>    m_FAAccelerate;
    CAttr<float>    m_FADecelerate;
    CAttr<bool>     m_BAAutoReverse;
    CAttr<float>    m_FASpeed;
    CAttr<TOKEN>    m_TASyncBehavior;
    CAttr<float>    m_FASyncTolerance;
    CAttr<TimelineType> m_TTATimeContainer;
    CAttr<float>    m_FAVolume;
    CAttr<bool>     m_BAMute;
    CAttr<bool>     m_BASyncMaster;
    CAttr<LPWSTR>   m_SATimeAction;
    CAttr<TOKEN>    m_TAUpdateMode;
    CAttr<LPWSTR>   m_SAtransIn;
    CAttr<LPWSTR>   m_SAtransOut;
    
    // internal variables
    LPWSTR          m_id;
    CTimeAction     m_timeAction;
    bool            m_fCachedSyncMaster;
    short           m_sHasSyncMMediaChild;
    bool            m_bLoaded;
    bool            m_bUnloading;
    bool            m_bBodyUnloading;
    bool            m_bBodyDetaching;
    bool            m_fTimelineInitialized;
    TimeValueList   m_realBeginValue;
    TimeValueList   m_realEndValue;
    float           m_realDuration;
    float           m_realRepeatTime;
    float           m_realRepeatCount;
    float           m_realIntervalDuration;
    MMBaseBvr      *m_mmbvr;
    bool            m_bStarted;
    double          m_dLastRepeatEventNotifyTime;
    bool            m_bIsSwitch;
    bool            m_fUseDefaultFill;
    bool            m_fHasPlayed;
    bool            m_fInTransitionDependentsList;
    bool            m_fEndingTransition;
    SYSTEMTIME      m_timeSystemBeginTime;
    bool            m_fLocalTimeDirty;
    bool            m_fHasWallClock;

    CTIMEElementBase            *m_pTIMEParent;
    CPtrAry<CTIMEElementBase*>   m_pTIMEChildren;
    CPtrAry<CTIMEElementBase*>   m_pTIMEZombiChildren;
    MMTimeline                  *m_timeline;
    DAComPtr<CTIMECurrTimeState>          m_pCurrTimeState;
    DAComPtr<CActiveElementCollection>    m_activeElementCollection;
    bool            m_fDetaching;

    TOKEN           m_tokPriorityClassPeers;
    TOKEN           m_tokPriorityClassHigher;
    TOKEN           m_tokPriorityClassLower;
    CComPtr<ITIMEBodyElement>   m_spBodyElemExternal;
    double          m_ExtenalBodyTime;

    
private:

    //+-------------------------------------------------------------------------
    //
    // Private Methods
    //
    //--------------------------------------------------------------------------

    HRESULT UnparentElement();
    HRESULT ParentElement();
    HRESULT ReparentChildren(ITIMEElement *pTIMEParent, IHTMLElement *pelem);
    HRESULT UpdateMMAPI(bool bUpdateBegin,
                        bool bUpdateEnd);
    HRESULT InitAtomTable();
    void    ReleaseAtomTable();
    HRESULT SwitchInnerElements();
    HRESULT DisableElement(IDispatch *pEleDisp);
    bool MatchTestAttributes(IDispatch *pEleDisp);
    HRESULT CreateTrans();
    HRESULT RemoveTrans();
    bool    IsTransitionPresent();

    //+-------------------------------------------------------------------------
    //
    // Private Data
    //
    //--------------------------------------------------------------------------

    static TIME_PERSISTENCE_MAP PersistenceMap[];
    CCollectionCache  *         m_pCollectionCache;
    static CAtomTable *         s_pAtomTable;
    static DWORD                s_cAtomTableRef;

    DWORD                       m_propertyAccesFlags;
    float                       m_privateRepeat;
    bool                        m_bNeedDetach;
    bool                        m_bReadyStateComplete;
    TRI_STATE_BOOL              m_enumIsThumbnail;
    bool                        m_bAttachedAtomTable;
    CComPtr<ITransitionElement> m_sptransIn;
    CComPtr<ITransitionElement> m_sptransOut;

    // for ITIMETransitionSite
    VARIANT_BOOL                m_vbDrawFlag;

}; // CTIMEElementBase

//
// This function does NOT return an addrefed outgoing CTIMEElementBase
//
CTIMEElementBase * GetTIMEElementBase(IUnknown * pInputUnknown);
CTIMEBodyElement * GetTIMEBodyElement(ITIMEBodyElement * pInputUnknown);


//+---------------------------------------------------------------------------------
//  CTIMEElementBase inline methods
//
//  (Note: as a general guideline, single line functions belong in the class declaration)
//
//----------------------------------------------------------------------------------

inline 
CAtomTable *
CTIMEElementBase::GetAtomTable()
{
    Assert(s_pAtomTable != NULL);
    return s_pAtomTable;
} // GetAtomTable

inline 
long 
CTIMEElementBase::GetAllChildCount()
{
    long lSize = m_pTIMEChildren.Size();
    long lCount = 0;
    for (long i=0; i < lSize; i++)
        lCount += m_pTIMEChildren[i]->GetAllChildCount();
    return lCount + lSize;
} // GetAllChildCount

inline 
CTIMEElementBase * 
CTIMEElementBase::GetChild(long i)
{
    Assert(i >= 0);
    return m_pTIMEChildren[i];
} // GetChild

inline 
HRESULT WINAPI
CTIMEElementBase::InternalQueryInterface(CTIMEElementBase* pThis,
                                         const _ATL_INTMAP_ENTRY* pEntries,
                                         REFIID iid,
                                         void** ppvObject)
{
    AssertStr(false, "InternalQueryInterface not defined in base class");
    return E_FAIL;
}

inline
MMBaseBvr &                
CTIMEElementBase::GetMMBvr() 
{ 
    Assert(m_mmbvr); 
    return *m_mmbvr; 
}

inline bool
CTIMEElementBase::IsActive() const
{
    return (IsReady() && m_mmbvr->IsActive());
}

inline bool
CTIMEElementBase::IsOn() const
{
    return (IsReady() && m_mmbvr->IsOn());
}

inline bool
CTIMEElementBase::IsPaused() const
{
    return (IsReady() && m_mmbvr->IsPaused());
}

inline bool
CTIMEElementBase::IsCurrPaused() const
{
    return (IsReady() && m_mmbvr->IsCurrPaused());
}

inline bool
CTIMEElementBase::GetTESpeed(float &flSpeed)
{
    flSpeed = 1.0;

    if(!IsReady())
    {
        return false;
    }
    flSpeed = m_mmbvr->GetCurrSpeed();
    return true;
}

inline double
CTIMEElementBase::GetTESimpleTime()
{
    double dblRet = 0.0;

    if (IsReady())
    {
        dblRet = m_mmbvr->GetSimpleTime();
    }
    
    return dblRet;
}

#include "currtimestate.h"

inline void
CTIMEElementBase::NotifyTimeStateChange(DISPID dispid)
{
    if (m_pCurrTimeState)
    {
        IGNORE_HR(m_pCurrTimeState->NotifyPropertyChanged(dispid));
    }
}

inline LPWSTR   
CTIMEElementBase::GetEndSync() 
{ 
    if (!IsSequence())
    {
        return m_SAEndSync; 
    }
    else
    {
        return NULL;
    }
}


#endif /* _TIMEELMBASE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timebvr\transdepend.cpp ===
//------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 2000
//
//  File: transdepend.cpp
//
//  Contents: Transition Dependency Manager
//
//------------------------------------------------------------------------------

#include "headers.h"
#include "timeelmbase.h"
#include "transdepend.h"

DeclareTag(tagTimeTransitionFillDependent, "SMIL Transitions", "Transition fill dependent manager");




//+-----------------------------------------------------------------------------
//
//  Method: CTransitionDependencyManager::CTransitionDependencyManager
//
//------------------------------------------------------------------------------
CTransitionDependencyManager::CTransitionDependencyManager()
{
}
//  Method: CTransitionDependencyManager::CTransitionDependencyManager


//+-----------------------------------------------------------------------------
//
//  Method: CTransitionDependencyManager::~CTransitionDependencyManager
//
//------------------------------------------------------------------------------
CTransitionDependencyManager::~CTransitionDependencyManager()
{
    ReleaseAllDependents();
} 
//  Method: CTransitionDependencyManager::~CTransitionDependencyManager


//+-----------------------------------------------------------------------------
//
//  Method: CTransitionDependencyManager::ReleaseAllDependents
//
//------------------------------------------------------------------------------
void
CTransitionDependencyManager::ReleaseAllDependents()
{
    TraceTag((tagTimeTransitionFillDependent,
              "CTransitionDependencyManager(%p)::ReleaseAllDependents()",
              this));

    while (m_listDependents.size() > 0)
    {
        CTIMEElementBase * pteb = m_listDependents.front();

        pteb->Release();

        m_listDependents.pop_front();
    }
}
//  Method: CTransitionDependencyManager::ReleaseAllDependents


//+-----------------------------------------------------------------------------
//
//  Method: CTransitionDependencyManager::AddDependent
//
//------------------------------------------------------------------------------
HRESULT
CTransitionDependencyManager::AddDependent(CTIMEElementBase * ptebDependent)
{
    HRESULT hr = S_OK;

    TraceTag((tagTimeTransitionFillDependent,
              "CTransitionDependencyManager(%p)::AddDependent(%p)",
              this,
              ptebDependent));

    if (NULL == ptebDependent)
    {
        hr = E_POINTER;

        goto done;
    }

    ptebDependent->AddRef();

    m_listDependents.push_front(ptebDependent);
    
    hr = S_OK;

done:

    RRETURN(hr);
}
//  Method: CTransitionDependencyManager::AddDependent


//+-----------------------------------------------------------------------------
//
//  Method: CTransitionDependencyManager::RemoveDependent
//
//------------------------------------------------------------------------------
HRESULT
CTransitionDependencyManager::RemoveDependent(CTIMEElementBase * ptebDependent)
{
    HRESULT hr = S_OK;

    TraceTag((tagTimeTransitionFillDependent,
              "CTransitionDependencyManager(%p)::RemoveDependent(%p)",
              this, 
              ptebDependent));

    if (NULL == ptebDependent)
    {
        hr = E_POINTER;

        goto done;
    }

    // Find this element in the list.

    for (TransitionDependentsList::iterator i = m_listDependents.begin(); 
         i != m_listDependents.end(); i++)
    {
        CTIMEElementBase * pteb = *i;

        if (ptebDependent == pteb)
        {
            pteb->Release();

            m_listDependents.erase(i);

            break;
        }
    }

    hr = S_OK;

done:

    RRETURN(hr);
}
//  Method: CTransitionDependencyManager::RemoveDependent


//+-----------------------------------------------------------------------------
//
//  Method: CTransitionDependencyManager::EvaluateTransitionTarget
//
//------------------------------------------------------------------------------
HRESULT 
CTransitionDependencyManager::EvaluateTransitionTarget(
                            IUnknown *                      punkTransitionTarget, 
                            CTransitionDependencyManager &  crefDependencies)
{
    while (m_listDependents.size() > 0)
    {
        // @@ ISSUE pauld
        // Short cut for now.  What we really want to do is to compare the target and 
        // dependent candidate for spatial overlap.  For now, we're going straight to 
        // the lists, and not using the Add/Remove methods.

        CTIMEElementBase * pteb = m_listDependents.front();

        TraceTag((tagTimeTransitionFillDependent,
                  "CTransitionDependencyManager(%p)::EvaluateTransitionTarget"
                   " migrating dependent(%p) to target(%p)",
                  this, 
                  pteb, 
                  punkTransitionTarget));

        crefDependencies.m_listDependents.push_front(pteb);

        m_listDependents.pop_front();
    }

done:

    return S_OK;
}
//  Method: CTransitionDependencyManager::EvaluateTransitionTarget
   

//+-----------------------------------------------------------------------------
//
//  Method: CTransitionDependencyManager::NotifyAndReleaseDependents
//
//------------------------------------------------------------------------------
HRESULT 
CTransitionDependencyManager::NotifyAndReleaseDependents()
{
    while (m_listDependents.size() > 0)
    {
        CTIMEElementBase * pteb = m_listDependents.front();

        pteb->OnEndTransition();
        pteb->Release();

        m_listDependents.pop_front();
    }

done:

    return S_OK;
}
//  Method: CTransitionDependencyManager::NotifyAndReleaseDependents
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timebvr\transdepend.h ===
//+-----------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 2000
//
//  File: transdepend.h
//
//  Contents: Transition Dependency Manager
//
//------------------------------------------------------------------------------

#pragma once

#ifndef _TRANSDEPEND_H
#define _TRANSDEPEND_H

typedef std::list<CTIMEElementBase*> TransitionDependentsList;

class CTransitionDependencyManager
{
private:

    TransitionDependentsList m_listDependents;

public:

    CTransitionDependencyManager();
    virtual ~CTransitionDependencyManager();

    // CTransitionDependencyManager methods 

    HRESULT AddDependent(CTIMEElementBase *  tebDependent);
    HRESULT RemoveDependent(CTIMEElementBase *  tebDependent);

    // Used by the transition object -- determines whether a particular 
    // transition target should assume responsibility for a set of dependencies.
    // Called when the transition begins.

    HRESULT EvaluateTransitionTarget(
                        IUnknown *                      punkTransitionTarget,
                        CTransitionDependencyManager &  crefDependencies);

    // Called when the transition ends.

    HRESULT NotifyAndReleaseDependents();

    void ReleaseAllDependents();
};

#endif // _TRANSDEPEND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timeeng\beginend.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: beginend.cpp
//
//  Contents: 
//
//------------------------------------------------------------------------------------

#include "headers.h"
#include "Container.h"
#include "Node.h"
#include "NodeMgr.h"

DeclareTag(tagBeginEnd, "TIME: Engine", "CTIMENode begin/end methods");

HRESULT
CTIMENode::AttachToSyncArc()
{
    TraceTag((tagBeginEnd,
              "CTIMENode(%p)::AttachToSyncArc()",
              this));
    
    HRESULT hr;
    
    hr = THR(m_saBeginList.Attach());
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = THR(m_saEndList.Attach());
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
  done:
    if (FAILED(hr))
    {
        DetachFromSyncArc();
    }
    
    RRETURN(hr);
}
    
void
CTIMENode::DetachFromSyncArc()
{
    TraceTag((tagBeginEnd,
              "CTIMENode(%p)::DetachFromSyncArc()",
              this));

    m_saBeginList.Detach();
    m_saEndList.Detach();
}

void
CTIMENode::UpdateSinks(CEventList * l, DWORD dwFlags)
{
    TraceTag((tagBeginEnd,
              "CTIMENode(%p)::UpdateSinks(%p, %x)",
              this,
              l,
              dwFlags));

    m_ptsBeginSinks.Update(l, dwFlags);

    m_ptsEndSinks.Update(l, dwFlags);

    // Only notify parent if this is not a time shift
    if ((dwFlags & TS_TIMESHIFT) == 0 &&
        GetParent())
    {
        GetParent()->ParentUpdateSink(l, *this);
    }

  done:
    return;
}


void
CTIMENode::SyncArcUpdate(CEventList * l,
                         bool bBeginSink,
                         ISyncArc & tb)
{
    TraceTag((tagBeginEnd,
              "CTIMENode(%p)::SyncArcUpdate(%p, %d, %p)",
              this,
              l,
              bBeginSink,
              &tb));
    
    Assert(IsReady());
    
    if (bBeginSink)
    {
        RecalcBeginSyncArcChange(l, tb.GetCurrTimeBase());
    }
    else
    {
        RecalcEndSyncArcChange(l, tb.GetCurrTimeBase());
    }
    
  done:
    return;
}

void
CTIMENode::UpdateBeginTime(CEventList * l,
                           double dblTime,
                           bool bPropagate)
{
    TraceTag((tagBeginEnd,
              "CTIMENode(%p)::UpdateBeginTime(%g, %p, %d)",
              this,
              dblTime,
              l,
              bPropagate));

    if (dblTime != m_dblBeginParentTime)
    {
        m_dblBeginParentTime = dblTime;

        PropNotify(l, TE_PROPERTY_BEGINPARENTTIME);

        if (bPropagate)
        {
            if ((m_dwUpdateCycleFlags & TE_INUPDATEBEGIN) != 0)
            {
                TraceTag((tagError,
                          "CTIMENode(%p)::UpdateBeginTime: Detected begin cycle"));

                goto done;
            }

            m_dwUpdateCycleFlags |= TE_INUPDATEBEGIN;
            
            m_ptsBeginSinks.Update(l, 0);

            m_dwUpdateCycleFlags &= ~TE_INUPDATEBEGIN;
        }
    }
    
  done:
    return;
}

void
CTIMENode::UpdateEndTime(CEventList * l, double dblTime, bool bPropagate)
{
    TraceTag((tagBeginEnd,
              "CTIMENode(%p)::UpdateEndTime(%g, %p, %d)",
              this,
              dblTime,
              l,
              bPropagate));

    if (dblTime < GetBeginParentTime())
    {
        dblTime = GetBeginParentTime();
    }
    
    if (dblTime != m_dblEndParentTime)
    {
        m_dblEndParentTime = dblTime;

        PropNotify(l, TE_PROPERTY_ENDPARENTTIME);

        if (bPropagate)
        {
            if ((m_dwUpdateCycleFlags & TE_INUPDATEEND) != 0)
            {
                TraceTag((tagError,
                          "CTIMENode(%p)::UpdateEndTime: Detected end cycle"));

                goto done;
            }

            m_dwUpdateCycleFlags |= TE_INUPDATEEND;
            
            m_ptsEndSinks.Update(l, 0);

            m_dwUpdateCycleFlags &= ~TE_INUPDATEEND;
        }
    }
    
  done:
    return;
}

void
CTIMENode::UpdateEndSyncTime(double dblTime)
{
    TraceTag((tagBeginEnd,
              "CTIMENode(%p)::UpdateEndSyncTime(%g)",
              this,
              dblTime));

    if (dblTime < GetBeginParentTime())
    {
        dblTime = GetBeginParentTime();
    }
    
    if (dblTime != m_dblEndSyncParentTime)
    {
        m_dblEndSyncParentTime = dblTime;
    }
    
  done:
    return;
}

void
CTIMENode::UpdateLastEndSyncTime(CEventList * l, double dblTime, bool bPropagate)
{
    TraceTag((tagBeginEnd,
              "CTIMENode(%p)::UpdateLastEndSyncTime(%g, %p, %d)",
              this,
              dblTime,
              l,
              bPropagate));

    if (dblTime < GetEndSyncParentTime())
    {
        dblTime = GetEndSyncParentTime();
    }
    
    if (dblTime != m_dblLastEndSyncParentTime)
    {
        m_dblLastEndSyncParentTime = dblTime;

        if (bPropagate && IsEndSync())
        {
            if ((m_dwUpdateCycleFlags & TE_INUPDATEENDSYNC) != 0)
            {
                TraceTag((tagError,
                          "CTIMENode(%p)::UpdateLastEndsyncTime: Detected endsync cycle"));

                goto done;
            }

            m_dwUpdateCycleFlags |= TE_INUPDATEENDSYNC;
            
            if (GetParent())
            {
                GetParent()->ParentUpdateSink(l, *this);
            }
            
            m_dwUpdateCycleFlags &= ~TE_INUPDATEENDSYNC;
        }
    }
    
  done:
    return;
}

void
SkipTo(DoubleSet & ds,
       DoubleSet::iterator & i,
       double dblTime)
{
    while (i != ds.end())
    {
        if (*i >= dblTime)
        {
            break;
        }
        
        i++;
    }
}

double
CTIMENode::CalcNaturalBeginBound(double dblParentTime,
                                 bool bInclusive,
                                 bool bStrict)
{
    TraceTag((tagBeginEnd,
              "CTIMENode(%p)::CalcNaturalBeginBound(%g, %d, %d)",
              this,
              dblParentTime,
              bInclusive,
              bStrict));

    Assert(IsReady());

    double dblRet = TIME_INFINITE;

    DoubleSet dsBegin;
    DoubleSet dsEnd;
    DoubleSet::iterator i;
    DoubleSet::iterator e;
    double dblLocalDur;

    m_saBeginList.GetSortedSet(dsBegin,
                               true);
    m_saEndList.GetSortedSet(dsEnd,
                             false);
    dblLocalDur = CalcCurrLocalDur();
    
    double dblNextEnd;
    double dblNextBegin;

    dblNextBegin = TIME_INFINITE;
    dblNextEnd = -TIME_INFINITE;
    
    i = dsBegin.begin();
    e = dsEnd.begin();

    while(i != dsBegin.end()) //lint !e716
    {
        double t = *i;
        
        // See if there are any end times greater than the begin or
        // that the list of ends is empty
        if (dsEnd.size() != 0)
        {
            SkipTo(dsEnd, e, t);
            
            if (e == dsEnd.end())
            {
                break;
            }
        }
        
        // Update the begin
        dblNextBegin = t;

        // Update the next end time
        dblNextEnd = dblNextBegin + dblLocalDur;

        // Check the end list
        if (e != dsEnd.end() && *e < dblNextEnd)
        {
            Assert(*e >= dblNextBegin);
            
            dblNextEnd = *e;
        }

        // Advance to the next begin value
        // The skipto below will not work by itself when an end time
        // is the same as a begin time so this takes care of that
        i++;

        SkipTo(dsBegin, i, dblNextEnd);

        if (i == dsBegin.end())
        {
            break;
        }
        
        t = *i;
        
        // See if the new time is greater than the parent time
        if (t > dblParentTime ||
            (!bInclusive && t == dblParentTime))
        {
            break;
        }
    }

    dblRet = dblNextBegin;
    
    if (bStrict)
    {
        if (dblRet > dblParentTime || (dblRet == dblParentTime && !bInclusive))
        {
            dblRet = TIME_INFINITE;
        }
    }
    
  done:
    return dblRet;
}

void
CTIMENode::CalcBeginBound(double dblBaseTime,
                          bool bStrict,
                          double & dblBeginBound)
{
    TraceTag((tagBeginEnd,
              "CTIMENode(%p)::CalcBeginBound(%g, %d)",
              this,
              dblBaseTime,
              bStrict));

    double dblRet;
    TEDirection dir = GetParentDirection();
    bool bInclusive = (dir == TED_Forward);
    double dblMaxEnd;
    
    if (!IsReady())
    {
        dblRet = TIME_INFINITE;
        goto done;
    }

    // Get the max end value to use for clamping
    dblMaxEnd = GetMaxEnd();

    // This is based on the restart flag

    switch(GetRestart())
    {
      default:
        AssertStr(false, "Invalid restart flag");
      case TE_RESTART_ALWAYS:  //lint !e616
        if (dblBaseTime > dblMaxEnd)
        {
            dblBaseTime = dblMaxEnd;
        }
        
        dblRet = m_saBeginList.LowerBound(dblBaseTime,
                                          bInclusive,
                                          bStrict,
                                          true,
                                          bInclusive);

        if (dblMaxEnd < dblRet)
        {
            dblRet = TIME_INFINITE;
            goto done;
        }
        
        break;
      case TE_RESTART_NEVER:
        dblRet = m_saBeginList.UpperBound(-TIME_INFINITE,
                                          true,
                                          bStrict,
                                          true,
                                          true);

        if (dblMaxEnd < dblRet)
        {
            dblRet = TIME_INFINITE;
            goto done;
        }
        
        break;
      case TE_RESTART_WHEN_NOT_ACTIVE:
        dblRet = CalcNaturalBeginBound(dblBaseTime, bInclusive, bStrict);

        Assert(dblRet == TIME_INFINITE || dblMaxEnd >= dblRet);
        
        break;
    }

  done:
    dblBeginBound = dblRet;
}

void
CTIMENode::CalcEndBound(double dblParentTime,
                        bool bIncludeOneShots,
                        double & dblEndBound,
                        double & dblEndSyncBound)
{
    TraceTag((tagBeginEnd,
              "CTIMENode(%p)::CalcEndBound(%g)",
              this,
              dblParentTime));

    double dblRet;
    double dblEndSyncRet;
    
    if (!IsReady())
    {
        dblRet = TIME_INFINITE;
        dblEndSyncRet = TIME_INFINITE;
        goto done;
    }

    // We used to reject oneshots on first tick but this breaks the
    // endElement calls.  We need to address the filtering up higher
    // We do this by reseting the end one shots whenever we update the
    // begin time
    
    if (dblParentTime < GetBeginParentTime())
    {
        bIncludeOneShots = false;
    }

    // This is based on the restart flag
    dblRet = m_saEndList.UpperBound(dblParentTime,
                                    true,
                                    true,
                                    bIncludeOneShots,
                                    true);

    dblEndSyncRet = dblRet;

    switch(GetRestart())
    {
      default:
        AssertStr(false, "Invalid restart flag");
      case TE_RESTART_ALWAYS: //lint !e616
        {
            bool bInclusive = (dblParentTime > GetBeginParentTime());
            
            double dblBeginBound = m_saBeginList.UpperBound(dblParentTime,
                                                            bInclusive,
                                                            true,
                                                            bIncludeOneShots,
                                                            bInclusive);
            dblRet = min(dblRet, dblBeginBound);
        }        
        break;
      case TE_RESTART_NEVER:
      case TE_RESTART_WHEN_NOT_ACTIVE:
        // Don't do anything
        break;
    }

  done:
    dblEndBound = dblRet;
    dblEndSyncBound = dblEndSyncRet;
}

void
CTIMENode::CalcBeginTime(double dblBaseTime,
                         double & dblBeginTime)
{
    TraceTag((tagBeginEnd,
              "CTIMENode(%p)::CalcBeginTime(%g)",
              this,
              dblBaseTime));

    CalcBeginBound(dblBaseTime, false, dblBeginTime);
}

void
CTIMENode::CalcNextBeginTime(double dblBaseTime,
                             bool bForceInclusive,
                             double & dblBeginTime)
{
    TraceTag((tagBeginEnd,
              "CTIMENode(%p)::CalcNextBeginTime(%g, %d)",
              this,
              dblBaseTime,
              bForceInclusive));

    double dblRet;
    TEDirection dir = GetParentDirection();
    
    Assert(IsReady());

    if (dir == TED_Forward)
    {
        double dblMaxEnd = GetMaxEnd();
        
        bool bInclusive = (bForceInclusive ||
                           GetBeginParentTime() != GetEndParentTime() ||
                           GetBeginParentTime() != dblBaseTime);

        // One unusual thing here is that we are always inclusive of
        // one shots.  This is because a beginElement can come in at
        // the same time that a previous begin/endelement calls were
        // made.  We want to accept this and it should not cause
        // problems since one shots are reset after we begin
        dblRet = m_saBeginList.UpperBound(dblBaseTime,
                                          bInclusive,
                                          true,
                                          true,
                                          true);

        if (dblRet > dblMaxEnd)
        {
            dblRet = TIME_INFINITE;
        }
    }
    else
    {
        CalcBeginBound(dblBaseTime, true, dblRet);
    }
    
    dblBeginTime = dblRet;
}

double
CalcIntrinsicEndTime(CTIMENode & tn,
                     double dblParentTime,
                     double dblSegmentTime,
                     long lRepeatCount,
                     double dblActiveTime)
{
    TraceTag((tagBeginEnd,
              "CalcIntrinsicEndTime(%p, %g, %g, %ld, %g)",
              &tn,
              dblParentTime,
              dblSegmentTime,
              lRepeatCount,
              dblActiveTime));

    double dblRet;
    double dblSegmentDur = tn.CalcCurrSegmentDur();

    // Figure out how much repeat time is left and then sutract
    // the last current time
    // This is the amount of time remaining from the last tick
    // time is parent time

    // If the segment time is infinite then this will ultimately end
    // up either getting clamp by the active dur below or just ignored
    // later begin the sync arcs ended early.  If the repeat count is
    // expired this will still return infinity since we never reach
    // the repeat count but expect the segment time to be equal to the
    // segment dur.  Again, if the segment dur is infinite then this
    // will cause everything to be ignored.
    dblRet = (tn.CalcRepeatCount() - lRepeatCount) * dblSegmentDur;
            
    // Now subtract the elapsed segment time to get the amount of
    // time left
    dblRet -= dblSegmentTime;
        
    // Now add the elapsed time
    dblRet += dblActiveTime;
        
    // Clamp it
    dblRet = Clamp(0.0,
                   dblRet,
                   tn.GetActiveDur());
        
    // Now transform it into local time
    dblRet = tn.ReverseActiveTimeTransform(dblRet);
    
    // Now figure out how much extra time we added
    dblRet -= tn.ReverseActiveTimeTransform(dblActiveTime);
        
    // Now add the the current parent time
    dblRet += dblParentTime;

    return dblRet;
}

void
CTIMENode::CalcEndTime(double dblBaseTime,
                       bool bIncludeOneShots,
                       double dblParentTime,
                       double dblElapsedSegmentTime,
                       long lElapsedRepeatCount,
                       double dblElapsedActiveTime,
                       double & dblEndTime,
                       double & dblEndSyncTime)
{
    TraceTag((tagBeginEnd,
              "CTIMENode(%p)::CalcEndTime(%g, %d, %g, %g, %ld, %g)",
              this,
              dblBaseTime,
              bIncludeOneShots,
              dblParentTime,
              dblElapsedSegmentTime,
              lElapsedRepeatCount,
              dblElapsedActiveTime));

    double dblEndRet;
    double dblEndSyncRet;
    
    Assert(dblElapsedSegmentTime >= 0.0 &&
           dblElapsedSegmentTime <= CalcCurrSegmentDur());
    Assert(lElapsedRepeatCount >= 0 &&
           lElapsedRepeatCount < CalcRepeatCount());
    
    if (!IsReady())
    {
        dblEndRet = TIME_INFINITE;
        dblEndSyncRet = TIME_INFINITE;
        goto done;
    }

    double dblCalcEnd;
    dblCalcEnd = ::CalcIntrinsicEndTime(*this,
                                        dblParentTime,
                                        dblElapsedSegmentTime,
                                        lElapsedRepeatCount,
                                        dblElapsedActiveTime);
    
    double dblEndBound;
    double dblEndSyncBound;

    CalcEndBound(dblBaseTime,
                 bIncludeOneShots,
                 dblEndBound,
                 dblEndSyncBound);

    // Now take the minimum of the two
    dblEndRet = min(dblEndBound, dblCalcEnd);
    dblEndSyncRet = min(dblEndSyncBound, dblCalcEnd);
    
  done:
    dblEndTime = dblEndRet;
    dblEndSyncTime = dblEndSyncRet;
}

//
// This assume that the begin and end parent times are set so it can
// optimize a little bit
//

double
CTIMENode::CalcLastEndSyncTime()
{
    TraceTag((tagBeginEnd,
              "CTIMENode(%p)::CalcLastEndSyncTime()",
              this));

    double dblRet;
    
    if (!IsReady())
    {
        dblRet = TIME_INFINITE;
        goto done;
    }

    if (GetRestart() == TE_RESTART_NEVER)
    {
        dblRet = GetEndSyncParentTime();
        goto done;
    }
    
    double dblMaxEnd;
    dblMaxEnd = GetMaxEnd();

    bool bInclusive;
    bInclusive = (dblMaxEnd != TIME_INFINITE);
    
    double dblMaxBegin;
    dblMaxBegin = m_saBeginList.LowerBound(dblMaxEnd,
                                           bInclusive,
                                           true,
                                           true,
                                           bInclusive);

    // If we are in the last instance then use the currently
    // determined value
    if (dblMaxBegin <= GetBeginParentTime())
    {
        dblRet = GetEndSyncParentTime();
        goto done;
    }
    
    // If we are in the active period for the last begin then it
    // should be ignored if we are restart when not active
    if (GetRestart() == TE_RESTART_WHEN_NOT_ACTIVE &&
        dblMaxBegin < GetEndParentTime())
    {
        dblRet = GetEndSyncParentTime();
        goto done;
    }
    
    double dblCalcEnd;
    dblCalcEnd = dblMaxBegin + CalcCurrLocalDur();
    
    double dblEndBound;
    dblEndBound = m_saEndList.UpperBound(dblMaxBegin,
                                         true,
                                         true,
                                         false,
                                         false);

    dblRet = min(dblCalcEnd, dblEndBound);
  done:
    return dblRet;
}

void
CTIMENode::ResetBeginTime(CEventList * l,
                          double dblParentTime,
                          bool bPropagate)
{
    TraceTag((tagBeginEnd,
              "CTIMENode(%p)::ResetBeginTime(%p, %g, %d)",
              this,
              l,
              dblParentTime,
              bPropagate));

    double dblBegin;
            
    CalcBeginTime(dblParentTime, dblBegin);

    // Need to update this now so that the calcendtime gets the
    // correct end point
    UpdateBeginTime(l, dblBegin, bPropagate);
}

void
CTIMENode::ResetEndTime(CEventList * l,
                        double dblParentTime,
                        bool bPropagate)
{
    TraceTag((tagBeginEnd,
              "CTIMENode(%p)::ResetEndTime(%p, %g, %d)",
              this,
              l,
              dblParentTime,
              bPropagate));

    double dblEnd;
    double dblEndSync;
    TEDirection dir = GetParentDirection();
            
    CalcEndTime(GetBeginParentTime(),
                false,
                GetBeginParentTime(),
                0.0,
                0,
                0.0,
                dblEnd,
                dblEndSync);

    UpdateEndTime(l, dblEnd, bPropagate);
    UpdateEndSyncTime(dblEndSync);

    double dblLastEndSyncTime;
    dblLastEndSyncTime = CalcLastEndSyncTime();
    
    UpdateLastEndSyncTime(l, dblLastEndSyncTime, bPropagate);

    if (dir == TED_Forward)
    {
        if (dblParentTime < GetEndParentTime() ||
            (IsFirstTick() && dblParentTime == GetEndParentTime()))
        {
            UpdateNextBoundaryTime(GetBeginParentTime());
        }
        else
        {
            double dblBegin;
            
            CalcNextBeginTime(dblParentTime, false, dblBegin);
            UpdateNextBoundaryTime(dblBegin);
        }
    }
    else
    {
        UpdateNextBoundaryTime(GetEndParentTime());
    }
}

void
CTIMENode::RecalcEndTime(CEventList * l,
                         double dblBaseTime,
                         double dblParentTime,
                         bool bPropagate)
{
    TraceTag((tagBeginEnd,
              "CTIMENode(%p)::RecalcEndTime(%p, %g, %g, %d)",
              this,
              l,
              dblBaseTime,
              dblParentTime,
              bPropagate));

    double dblSegmentTime = 0.0;
    long lRepeatCount = 0;
    double dblElapsedActiveTime = 0.0;

    if (GetSyncParentTime() != TIME_INFINITE)
    {
        Assert(GetSyncRepeatCount() != TE_UNDEFINED_VALUE);
        Assert(GetSyncSegmentTime() != TIME_INFINITE);
        Assert(GetSyncActiveTime() != TIME_INFINITE);
            
        lRepeatCount = GetSyncRepeatCount();
        dblSegmentTime = GetSyncSegmentTime();
        dblElapsedActiveTime = GetSyncActiveTime();
    }
    else if (IsActive() &&
             -TIME_INFINITE != m_dblCurrParentTime)
    {
        Assert(GetSyncRepeatCount() == TE_UNDEFINED_VALUE);
        Assert(GetSyncSegmentTime() == TIME_INFINITE);
        Assert(GetSyncActiveTime() == TIME_INFINITE);

        dblSegmentTime = m_dblCurrSegmentTime;
        lRepeatCount = m_lCurrRepeatCount;
        dblElapsedActiveTime = CalcElapsedActiveTime();
    }
    
    double dblEnd;
    double dblEndSync;
    
    CalcEndTime(dblBaseTime,
                true,
                dblParentTime,
                dblSegmentTime,
                lRepeatCount,
                dblElapsedActiveTime,
                dblEnd,
                dblEndSync);

    UpdateEndTime(l, dblEnd, bPropagate);
    UpdateEndSyncTime(dblEndSync);

    double dblLastEndSyncTime;
    dblLastEndSyncTime = CalcLastEndSyncTime();
    
    UpdateLastEndSyncTime(l, dblLastEndSyncTime, bPropagate);

  done:
    return;
}

#ifdef _WIN64
#pragma optimize("",off)
#endif

void
CTIMENode::RecalcCurrEndTime(CEventList * l,
                             bool bPropagate)
{
    TraceTag((tagBeginEnd,
              "CTIMENode(%p)::RecalcEndTime(%p, %d)",
              this,
              l,
              bPropagate));

    double dblParentTime;

    if (GetSyncParentTime() != TIME_INFINITE)
    {
        dblParentTime = GetSyncParentTime();
    }
    else if (IsActive() &&
             -TIME_INFINITE != m_dblCurrParentTime)
    {
        dblParentTime = m_dblCurrParentTime;
    }
    else
    {
        dblParentTime = GetBeginParentTime();
    }
    
    RecalcEndTime(l, GetBeginParentTime(), dblParentTime, bPropagate);
}

#ifdef _WIN64
#pragma optimize("",on)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timeeng\container.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "Node.h"
#include "Container.h"

DeclareTag(tagTEContainer, "TIME: Engine", "CTIMEContainer methods")
DeclareTag(tagTEEndSync, "TIME: Engine", "EndSync")

CTIMEContainer::CTIMEContainer()
: m_tesEndSync(TE_ENDSYNC_NONE),
  m_bIgnoreParentUpdate(false)
{
    TraceTag((tagTEContainer,
              "CTIMEContainer(%p)::CTIMEContainer()",
              this));
}

CTIMEContainer::~CTIMEContainer()
{
    TraceTag((tagTEContainer,
              "CTIMEContainer(%p)::~CTIMEContainer()",
              this));
}

HRESULT
CTIMEContainer::Init(LPOLESTR id)
{
    TraceTag((tagTEContainer,
              "CTIMEContainer(%p)::Init(%ls)",
              this,
              id));
    
    HRESULT hr;

    hr = CTIMENode::Init(id);
    
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

void CTIMEContainer::FinalRelease()
{
    TIMENodeList ::iterator i;

    // release bvrs in children list
    for (i = m_children.begin(); i != m_children.end(); i++)
    {
        (*i)->Release();
    }
    m_children.clear();
} // FinalRelease()



STDMETHODIMP
CTIMEContainer::addNode(ITIMENode *bvr)
{
    TraceTag((tagTEContainer,
              "CTIMEContainer(%p)::addNode(%p)",
              this,
              bvr));
    
    CHECK_RETURN_NULL(bvr);

    HRESULT hr;
    
    CTIMENode * mmbvr;

    mmbvr = GetBvr(bvr);

    if (mmbvr == NULL)
    {
        hr = E_INVALIDARG;
        goto done;
    }
    
    if (mmbvr->GetMgr() != NULL ||
        mmbvr->GetParent() != NULL)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    hr = THR(Add(mmbvr));
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMEContainer::removeNode(ITIMENode *bvr)
{
    TraceTag((tagTEContainer,
              "CTIMEContainer(%p)::removeNode(%p)",
              this,
              bvr));
    
    CHECK_RETURN_NULL(bvr);

    HRESULT hr;
    
    CTIMENode * mmbvr;

    mmbvr = GetBvr(bvr);

    if (mmbvr == NULL)
    {
        hr = E_INVALIDARG;
        goto done;
    }
    
    if (mmbvr->GetParent() != this)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    hr = THR(Remove(mmbvr));
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMEContainer::get_numChildren(long * l)
{
    TraceTag((tagTEContainer,
              "CTIMEContainer(%p)::get_numChildren(%p)",
              this,
              l));
    
    CHECK_RETURN_NULL(l);

    *l = m_children.size();

    return S_OK;
}

//
// Internal methods
//

HRESULT
CTIMEContainer::Add(CTIMENode *bvr)
{
    TraceTag((tagTEContainer,
              "CTIMEContainer(%p)::Add(%p)",
              this,
              bvr));
    
    Assert(bvr);
    Assert(bvr->GetParent() == NULL);
    
    HRESULT hr;
    
    bvr->SetParent(this);

    Assert(bvr->GetMgr() == NULL);
    
    if (GetMgr() != NULL)
    {
        hr = bvr->SetMgr(GetMgr());
        if (FAILED(hr))
        {
            goto done;
        }
    }
    
    hr = THR(AddToChildren(bvr));
    if (FAILED(hr))
    {
        goto done;
    }

    // If I am currently active then I need to tick my child
    if (IsActive())
    {
        CEventList l;
    
        bvr->TickEvent(&l,
                       TE_EVENT_BEGIN,
                       0);

        hr = THR(l.FireEvents());
        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = S_OK;
  done:
    if (FAILED(hr))
    {
        IGNORE_HR(Remove(bvr));
    }
    
    RRETURN(hr);
}

HRESULT
CTIMEContainer::Remove(CTIMENode *bvr)
{
    TraceTag((tagTEContainer,
              "CTIMEContainer(%p)::Remove(%p)",
              this,
              bvr));
    
    Assert(bvr);
    
    // This needs to be callable even from a partially added behavior
    
    // TODO: We should probably fire an end event here
    RemoveFromChildren(bvr);

    // The order here is important
    bvr->ClearMgr();
    bvr->ClearParent();
    
    return S_OK;
}

HRESULT
CTIMEContainer::AddToChildren(CTIMENode * bvr)
{
    TraceTag((tagTEContainer,
              "CTIMEContainer(%p)::AddToChildren(%p)",
              this,
              bvr));

    HRESULT hr;
    
    bvr->AddRef();
    // @@ ISSUE : Need to handle memory error
    m_children.push_back(bvr);
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

void
CTIMEContainer::RemoveFromChildren(CTIMENode * bvr)
{
    TraceTag((tagTEContainer,
              "CTIMEContainer(%p)::RemoveFromChildren(%p)",
              this,
              bvr));

    // TODO: Need to cycle through the children and remove all
    // dependents
    
    for (TIMENodeList::iterator i = m_children.begin(); 
         i != m_children.end(); 
         i++)
    {
        if((*i) == bvr)
        {
            bvr->Release();
        }
    }
    
    m_children.remove(bvr);
}

bool 
CTIMEContainer::IsChild(const CTIMENode & tn) const
{
    TraceTag((tagTEContainer,
              "CTIMEContainer(%p)::IsChild(%p)",
              this,
              &tn));

    for (TIMENodeList::iterator i = m_children.begin(); 
         i != m_children.end(); 
         i++)
    {
        if((*i) == &tn)
        {
            return true;
        }
    }
    
    return false;
}

HRESULT
CTIMEContainer::SetMgr(CTIMENodeMgr * ptnm)
{
    TraceTag((tagTEContainer,
              "CTIMEContainer(%p)::SetMgr(%p)",
              this,
              ptnm));

    HRESULT hr;
    
    hr = CTIMENode::SetMgr(ptnm);
    if (FAILED(hr))
    {
        goto done;
    }

    {
        for (TIMENodeList::iterator i = m_children.begin(); 
             i != m_children.end(); 
             i++)
        {
            hr = (*i)->SetMgr(ptnm);
            if (FAILED(hr))
            {
                goto done;
            }
        }
    }

    hr = S_OK;
  done:
    if (FAILED(hr))
    {
        ClearMgr();
    }
    RRETURN(hr);
}

void
CTIMEContainer::ClearMgr()
{
    TraceTag((tagTEContainer,
              "CTIMEContainer(%p)::ClearMgr()",
              this));

    for (TIMENodeList::iterator i = m_children.begin(); 
         i != m_children.end(); 
         i++)
    {
        (*i)->ClearMgr();
    }

    CTIMENode::ClearMgr();
}

void
CTIMEContainer::ResetChildren(CEventList * l, bool bPropagate)
{
    TraceTag((tagTEContainer,
              "CTIMEContainer(%p)::ResetChildren(%p, %d)",
              this,
              l,
              bPropagate));

    bool bOld = m_bIgnoreParentUpdate;

    m_bIgnoreParentUpdate = true;
    
    // Need to reset all children
        
    for (TIMENodeList::iterator i = m_children.begin(); 
         i != m_children.end(); 
         i++)
    {
        // Do not propagate changes until everyone has been reset
        (*i)->ResetNode(l, false, true);
    }
        
    for (i = m_children.begin(); 
         i != m_children.end(); 
         i++)
    {
        (*i)->ResetSinks(l);
    }

    m_bIgnoreParentUpdate = bOld;
    
    if (bPropagate)
    {
        CalcImplicitDur(l);
    }
}

void
CTIMEContainer::TickChildren(CEventList * l,
                             double dblNewSegmentTime,
                             bool bNeedPlay)
{
    TraceTag((tagTEContainer,
              "CTIMEContainer(%p)::TickChildren(%g, %d, %d, %d)",
              this,
              dblNewSegmentTime,
              GetDirection(),
              m_bFirstTick,
              bNeedPlay));
    
    dblNewSegmentTime = ApplySimpleTimeTransform(dblNewSegmentTime);

    if (CalcSimpleDirection() == TED_Forward)
    {
        for (TIMENodeList::iterator i = m_children.begin();
             i != m_children.end();
             i++)
        {
            (*i)->Tick(l,
                       dblNewSegmentTime,
                       bNeedPlay);
        }
    }
    else
    {
        for (TIMENodeList::reverse_iterator i = m_children.rbegin();
             i != m_children.rend();
             i++)
        {
            (*i)->Tick(l,
                       dblNewSegmentTime,
                       bNeedPlay);
        }
    }
}

void
CTIMEContainer::ParentUpdateSink(CEventList * l,
                                 CTIMENode & tn)
{
    TraceTag((tagTEContainer,
              "CTIMEContainer(%p)::CalcImplicitDur(%p, %p)",
              this,
              &l,
              &tn));

    TEDirection dir = CalcActiveDirection();

    // Never recalc on a child notification when going backwards
    if (!m_bIgnoreParentUpdate && dir == TED_Forward)
    {
        CalcImplicitDur(l);
    }
    
  done:
    return;
}

void
CTIMEContainer::CalcImplicitDur(CEventList * l)
{
    TraceTag((tagTEContainer,
              "CTIMEContainer(%p)::CalcImplicitDur(%p)",
              this,
              l));

    double d = TIME_INFINITE;
    double dblPrevSegmentDur = CalcCurrSegmentDur();
    
    // The rule is:
    //
    // - Start with infinite since if no children have a begin time
    //   endsync does not take effect
    // - Next only consider children who have a begin time and are
    //   playable
    // - For last - take the greatest of the values.  If it is the
    //   first value then use it since infinity will always be greater
    // - For first - take the least of the values
    
    bool bFirst = true;
    
    if (GetEndSync() == TE_ENDSYNC_FIRST ||
        GetEndSync() == TE_ENDSYNC_ALL ||
        GetEndSync() == TE_ENDSYNC_LAST)
    {
        for (TIMENodeList::iterator i = m_children.begin();
             i != m_children.end();
             i++)
        {
            CTIMENode * ptn = *i;
            
            if (!ptn->IsEndSync())
            {
                continue;
            }

            double dblEndSyncTime = ptn->GetLastEndSyncParentTime();

            switch(GetEndSync())
            {
              case TE_ENDSYNC_LAST:
                if (ptn->GetBeginParentTime() != TIME_INFINITE)
                {
                    if (bFirst || dblEndSyncTime > d)
                    {
                        d = dblEndSyncTime;
                        bFirst = false;
                    }
                }

                break;
              case TE_ENDSYNC_FIRST:
                if (ptn->GetBeginParentTime() != TIME_INFINITE)
                {
                    if (dblEndSyncTime < d)
                    {
                        d = dblEndSyncTime;
                    }
                }
                break;
              case TE_ENDSYNC_ALL:
                if (bFirst || dblEndSyncTime > d)
                {
                    d = dblEndSyncTime;
                    bFirst = false;
                }

                break;
            } //lint !e787
        }
    }
    else if (GetEndSync() == TE_ENDSYNC_MEDIA)
    {
        d = TE_UNDEFINED_VALUE;
    }
    
    if (m_dblImplicitDur != d)
    {
        m_dblImplicitDur = d;
        
        PropNotify(l,
                   (TE_PROPERTY_IMPLICITDUR));

        double dblSegmentDur;
        dblSegmentDur = CalcCurrSegmentDur();
    
        if (dblPrevSegmentDur != dblSegmentDur)
        {
            PropNotify(l,
                       (TE_PROPERTY_SEGMENTDUR));
        
            RecalcSegmentDurChange(l, false);
        }
    }

  done:
    return;
}

STDMETHODIMP
CTIMEContainer::get_endSync(TE_ENDSYNC * es)
{
    TraceTag((tagTEContainer,
              "CTIMEContainer(%p)::get_endSync()",
              this));

    CHECK_RETURN_NULL(es);

    *es = m_tesEndSync;
    
    return S_OK;
}

STDMETHODIMP
CTIMEContainer::put_endSync(TE_ENDSYNC es)
{
    TraceTag((tagTEContainer,
              "CTIMEContainer(%p)::put_endSync(%d)",
              this,
              es));

    HRESULT hr;
    CEventList l;
    
    m_tesEndSync = es;

    CalcImplicitDur(&l);

    hr = THR(l.FireEvents());
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
CTIMEContainer::Error()
{
    LPWSTR str = TIMEGetLastErrorString();
    HRESULT hr = TIMEGetLastError();
    
    TraceTag((tagError,
              "CTIMEContainer(%p)::Error(%hr,%ls)",
              this,
              hr,
              str?str:L"NULL"));

    if (str)
    {
        hr = CComCoClass<CTIMEContainer, &__uuidof(CTIMEContainer)>::Error(str, IID_ITIMEContainer, hr);
        delete [] str;
    }
    
    RRETURN(hr);
}

#if DBG
void
CTIMEContainer::Print(int spaces)
{
    CTIMENode::Print(spaces);
    
    TraceTag((tagPrintTimeTree,
              "%*s{",
              spaces,
              ""));

    for (TIMENodeList::iterator i = m_children.begin(); 
         i != m_children.end(); 
         i++)
    {
        (*i)->Print(spaces + 2);
    }
    
    TraceTag((tagPrintTimeTree,
              "%*s}",
              spaces,
              ""));
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timeeng\factory.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "Node.h"
#include "Container.h"
#include "NodeMgr.h"

HRESULT
TECreateBehavior(LPOLESTR id, ITIMENode **ppOut)
{
    CHECK_RETURN_SET_NULL(ppOut);
    
    HRESULT hr;
    CComObject<CTIMENode> *pNew;
    CComObject<CTIMENode>::CreateInstance(&pNew);

    if (!pNew)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = THR(pNew->Init(id));
        if (SUCCEEDED(hr))
        {
            hr = THR(pNew->QueryInterface(IID_ITIMENode, (void **)ppOut));
        }
    }

    if (FAILED(hr))
    {
        delete pNew;
    }

    return hr;
}

HRESULT
TECreateTimeline(LPOLESTR id, ITIMEContainer **ppOut)
{
    CHECK_RETURN_SET_NULL(ppOut);
    
    HRESULT hr;
    
    CComObject<CTIMEContainer> *pNew;
    CComObject<CTIMEContainer>::CreateInstance(&pNew);

    if (!pNew)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = THR(pNew->Init(id));
        
        if (SUCCEEDED(hr))
        {
            hr = THR(pNew->QueryInterface(IID_ITIMEContainer,
                                          (void **)ppOut));
        }
    }

    if (FAILED(hr))
    {
        delete pNew;
    }

    return hr;
}

HRESULT
TECreatePlayer(LPOLESTR id,
               IUnknown * punk,
               IServiceProvider * sp,
               ITIMENodeMgr **ppOut)
{
    CHECK_RETURN_SET_NULL(ppOut);
    
    HRESULT hr;
    
    CComObject<CTIMENodeMgr> *pNew;
    CComObject<CTIMENodeMgr>::CreateInstance(&pNew);

    if (!pNew)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        CComPtr<ITIMENode> bvr;

        hr = THR(punk->QueryInterface(IID_ITIMENode, (void**)&bvr));
        hr = THR(pNew->Init(id,bvr,sp));
        
        if (SUCCEEDED(hr))
        {
            hr = THR(pNew->QueryInterface(IID_ITIMENodeMgr,
                                          (void **)ppOut));
        }
    }

    if (FAILED(hr))
    {
        delete pNew;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timeeng\ease.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmease.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "Node.h"

void
CTIMENode::CalculateEaseCoeff()
{
    Assert(m_fltAccel >= 0.0f && m_fltAccel <= 1.0f);
    Assert(m_fltDecel >= 0.0f && m_fltDecel <= 1.0f);

    double dblDur = GetSimpleDur();

    // We need to ease the behavior if we are not infinite and either
    // ease in or ease out percentagMMes are non-zero
    
    m_bNeedEase = (dblDur != TIME_INFINITE &&
                   (m_fltAccel > 0.0f || m_fltDecel > 0.0f) &&
                   (m_fltAccel + m_fltDecel <= 1.0f));

    if (!m_bNeedEase) return;
    
    double dblAccelDuration = m_fltAccel * dblDur;
    double dblDecelDuration = m_fltDecel * dblDur;
    double dblMiddleDuration = dblDur - dblAccelDuration - dblDecelDuration;
    
    // Compute B1, the velocity during segment B.
    double flInvB1 = (-0.5f * m_fltAccel +
                     -0.5f * m_fltDecel + 1.0f);
    Assert(flInvB1 > 0.0f);
    m_flB1 = 1.0f / flInvB1;
    
    // Basically for accelerated pieces - t = t0 + v0 * t + 1/2 at^2
    // and a = Vend - Vstart / t

    if (dblAccelDuration != 0.0f) {
        m_flA0 = 0.0f;
        m_flA1 = 0;
        m_flA2 = 0.5f * (m_flB1 - m_flA1) / dblAccelDuration;
    } else {
        m_flA0 = m_flA1 = m_flA2 = 0.0f;
    }

    m_flB0 = static_cast<float>(m_flA0 + m_flA1 * dblAccelDuration + m_flA2 * dblAccelDuration * dblAccelDuration);
    
    if (dblDecelDuration != 0.0) {
        m_flC0 = static_cast<float>(m_flB1 * dblMiddleDuration + m_flB0);
        m_flC1 = m_flB1;
        m_flC2 = static_cast<float>(-0.5f * m_flC1 / dblDecelDuration);
    } else {
        m_flC0 = m_flC1 = m_flC2 = 0.0f;
    }

    m_fltAccelEnd = static_cast<float>(dblAccelDuration);
    m_fltDecelStart = static_cast<float>(dblDur - dblDecelDuration);
}

static double
Quadratic(double time, float flA, float flB, float flC)
{
    // Need to calculate ax^2 + bx + c
    // Use x * (a * x + b) + c - since it requires 1 less multiply
    
    return (time * (flA * time + flB) + flC);
}

double
CTIMENode::ApplySimpleTimeTransform(double time) const
{
    if (!m_bNeedEase || time <= 0 || time >= CalcCurrSegmentDur())
        return time;
    
    if (time <= m_fltAccelEnd) {
        return Quadratic(time, m_flA2, m_flA1, m_flA0);
    } else if (time < m_fltDecelStart) {
        return Quadratic(time - m_fltAccelEnd, 0.0f, m_flB1, m_flB0);
    } else {
        return Quadratic(time - m_fltDecelStart, m_flC2, m_flC1, m_flC0);
    }
}

double
CTIMENode::ReverseSimpleTimeTransform(double time) const
{
    return time;
}

double
CTIMENode::ApplyActiveTimeTransform(double dblTime) const
{
    return dblTime * GetRate();
}

double
CTIMENode::ReverseActiveTimeTransform(double dblTime) const
{
    return dblTime / GetRate();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timeeng\methods.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: methods.cpp
//
//  Contents: 
//
//------------------------------------------------------------------------------------

#include "headers.h"
#include "Container.h"
#include "Node.h"
#include "NodeMgr.h"

class __declspec(uuid("f912d958-5c28-11d2-b957-3078302c2030"))
BvrGuid {};

HRESULT WINAPI
CTIMENode::BaseInternalQueryInterface(CTIMENode* pThis,
                                       void * pv,
                                       const _ATL_INTMAP_ENTRY* pEntries,
                                       REFIID iid,
                                       void** ppvObject)
{
    // Do not do an addref but return the original this pointer to
    // give access to the class pointer itself.
    
    if (InlineIsEqualGUID(iid, __uuidof(BvrGuid)))
    {
        *ppvObject = pThis;
        return S_OK;
    }
    
    return CComObjectRootEx<CComSingleThreadModel>::InternalQueryInterface(pv,
                                                                           pEntries,
                                                                           iid,
                                                                           ppvObject);
}
        
CTIMENode *
GetBvr(IUnknown * pbvr)
{
    // This is a total hack to get the original class data.  The QI is
    // implemented above and does NOT do a addref so we do not need to
    // release it
    
    CTIMENode * bvr = NULL;

    if (pbvr)
    {
        // !!!! This does not do an addref
        pbvr->QueryInterface(__uuidof(BvrGuid),(void **)&bvr);
    }
    
    if (bvr == NULL)
    {
        TIMESetLastError(E_INVALIDARG, NULL);
    }
                
    return bvr;
}

STDMETHODIMP
CTIMENode::beginAt(double dblParentTime)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::beginAt(%g)",
              this,
              dblParentTime));

    HRESULT hr;
    CEventList l;
    
    // If we are not ready then return
    if (!IsReady() ||
        !GetContainer().ContainerIsActive())
    {
        hr = S_OK;
        goto done;
    }

    if (IsActive())
    {
        if (GetRestart() != TE_RESTART_ALWAYS)
        {
            hr = S_OK;
            goto done;
        }

        hr = THR(endAt(GetCurrParentTime()));
        if (FAILED(hr))
        {
            goto done;
        }
    }
    
    CSyncArcOffset * pto;
    
    pto = new CSyncArcOffset(dblParentTime);

    if (pto == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    
    hr = THR(m_saBeginList.Add(* static_cast<ISyncArc *>(pto),
                               true,
                               NULL));
    if (FAILED(hr))
    {
        goto done;
    }
    
    RecalcBeginSyncArcChange(&l, dblParentTime);
    
    if (m_bFirstTick && IsActive())
    {
        // We need to defer the begin if we are locked, on our begin
        // point, and our parent needs a first tick
        bool bSkip = (IsLocked() &&
                      GetCurrParentTime() == CalcActiveBeginPoint() &&
                      GetContainer().ContainerIsFirstTick());

        if (!bSkip)
        {
            TickEvent(&l, TE_EVENT_BEGIN, 0);
        }
    }
    
            
    hr = THR(l.FireEvents());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr); //lint !e429
}

STDMETHODIMP
CTIMENode::addBegin(double dblParentTime,
                    LONG * cookie)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::addBegin(%#x)",
              this,
              dblParentTime));

    HRESULT hr;

    SET_NULL(cookie);

    CSyncArcOffset * pto;
    
    pto = new CSyncArcOffset(dblParentTime);

    if (pto == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    
    hr = THR(m_saBeginList.Add(* static_cast<ISyncArc *>(pto),
                               false,
                               cookie));
    if (FAILED(hr))
    {
        goto done;
    }
    
    Invalidate(TE_INVALIDATE_BEGIN);
    
    hr = S_OK;
  done:
    RRETURN1(hr, E_OUTOFMEMORY); //lint !e429
}

STDMETHODIMP
CTIMENode::addBeginSyncArc(ITIMENode * node,
                           TE_TIMEPOINT tep,
                           double dblOffset,
                           LONG * cookie)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::addBeginSyncArc(%p, %#x, %g)",
              this,
              node,
              tep,
              dblOffset));

    HRESULT hr;
    
    CHECK_RETURN_NULL(node);
    SET_NULL(cookie);

    CTIMENode * ptn = GetBvr(node);
    if (!ptn)
    {
        hr = E_INVALIDARG;
        goto done;
    }
     
    CSyncArcTimeBase * ptb;
    ptb = new CSyncArcTimeBase(m_saBeginList,
                               *ptn,
                               tep,
                               dblOffset);

    if (ptb == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    
    hr = THR(m_saBeginList.Add(* static_cast<ISyncArc *>(ptb),
                               false,
                               cookie));
    if (FAILED(hr))
    {
        goto done;
    }
    
    Invalidate(TE_INVALIDATE_BEGIN);
    
    hr = S_OK;
  done:
    RRETURN2(hr, E_OUTOFMEMORY, E_INVALIDARG); //lint !e429
}

STDMETHODIMP
CTIMENode::removeBegin(LONG cookie)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::addBegin(%#x)",
              this,
              cookie));

    HRESULT hr;
    bool bNeedUpdate = false;

    if (cookie == 0)
    {
        bNeedUpdate = m_saBeginList.Clear();
    }
    else
    {
        bNeedUpdate = m_saBeginList.Remove(cookie, true);
    }
    
    if (bNeedUpdate)
    {
        Invalidate(TE_INVALIDATE_BEGIN);
    }
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMENode::endAt(double dblParentTime)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::endAt(%g)",
              this,
              dblParentTime));

    HRESULT hr;
    CEventList l;
    
    // If we are not ready then return
    if (!IsReady() ||
        !GetContainer().ContainerIsActive())
    {
        hr = S_OK;
        goto done;
    }

    // #14226 ie6 DB
    // This causes problems when you call begin immediately
    // followed by an end call from script.  It also will do the
    // wrong thing if you seek to the middle and start playing since
    // you should react to those events.
    // I need to see if we can solve the case of a begin and end event
    // being the same a different way.  It probably needs to go in
    // timeelmbase.cpp
    
#if 0
    // If we are not active or we have not ticked yet (which means
    // that we just became active) then ignore all end ats.
    if (!IsActive() || IsFirstTick())
    {
        hr = S_OK;
        goto done;
    }
#endif
    
    CSyncArcOffset * pto;
    
    pto = new CSyncArcOffset(dblParentTime);

    if (pto == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    
    hr = THR(m_saEndList.Add(* static_cast<ISyncArc *>(pto),
                             true,
                             NULL));
    if (FAILED(hr))
    {
        goto done;
    }
    
    RecalcEndSyncArcChange(&l, dblParentTime);
    
    hr = THR(l.FireEvents());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr); //lint !e429
}

STDMETHODIMP
CTIMENode::addEnd(double dblParentTime,
                  LONG * cookie)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::addEnd(%#x)",
              this,
              dblParentTime));

    HRESULT hr;

    SET_NULL(cookie);

    CSyncArcOffset * pto;
    
    pto = new CSyncArcOffset(dblParentTime);

    if (pto == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    
    hr = THR(m_saEndList.Add(* static_cast<ISyncArc *>(pto),
                             false,
                             cookie));
    if (FAILED(hr))
    {
        goto done;
    }
    
    Invalidate(TE_INVALIDATE_END);
    
    hr = S_OK;
  done:
    RRETURN1(hr, E_OUTOFMEMORY); //lint !e429
}

STDMETHODIMP
CTIMENode::addEndSyncArc(ITIMENode * node,
                         TE_TIMEPOINT tep,
                         double dblOffset,
                         LONG * cookie)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::addEndSyncArc(%p, %#x, %g)",
              this,
              node,
              tep,
              dblOffset));

    HRESULT hr;

    CHECK_RETURN_NULL(node);
    SET_NULL(cookie);

    CTIMENode * ptn = GetBvr(node);
    if (!ptn)
    {
        hr = E_INVALIDARG;
        goto done;
    }
     
    CSyncArcTimeBase * ptb;
    ptb = new CSyncArcTimeBase(m_saEndList,
                               *ptn,
                               tep,
                               dblOffset);

    if (ptb == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    
    hr = THR(m_saEndList.Add(* static_cast<ISyncArc *>(ptb),
                             false,
                             cookie));
    if (FAILED(hr))
    {
        goto done;
    }
    
    Invalidate(TE_INVALIDATE_END);
    
    hr = S_OK;
  done:
    RRETURN1(hr, E_OUTOFMEMORY); //lint !e429
}

STDMETHODIMP
CTIMENode::removeEnd(LONG cookie)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::addEnd(%#x)",
              this,
              cookie));

    HRESULT hr;
    bool bNeedUpdate = false;

    if (cookie == 0)
    {
        bNeedUpdate = m_saEndList.Clear();
    }
    else
    {
        bNeedUpdate = m_saEndList.Remove(cookie, true);
    }
    
    if (bNeedUpdate)
    {
        Invalidate(TE_INVALIDATE_END);
    }
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMENode::pause()
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::pause()",
              this));

    HRESULT hr;
    CEventList l;
    
    // If we are not ready then return an error
    if (!IsReady())
    {
        hr = E_FAIL;
        goto done;
    }

    if (!IsActive())
    {
        hr = S_OK;
        goto done;
    }

    if (!CalcIsPaused())
    {
        m_bIsParentPaused = GetContainer().ContainerIsPaused();

        EventNotify(&l, CalcElapsedActiveTime(), TE_EVENT_PAUSE);

        m_bIsPaused = true;

        TickEventChildren(&l, TE_EVENT_PAUSE, 0);
    }

    // Set before firing events
    m_bIsPaused = true;
    
    PropNotify(&l, TE_PROPERTY_ISPAUSED | TE_PROPERTY_ISCURRPAUSED);

    hr = THR(l.FireEvents());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMENode::resume()
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::resume()",
              this));

    HRESULT hr;
    CEventList l;
    
    // If we are not ready then return an error
    if (!IsReady())
    {
        hr = E_FAIL;
        goto done;
    }

    // If we are not active then we cannot be paused
    if (!IsActive())
    {
        hr = S_OK;
        goto done;
    }
    
    // If we were paused and our parent was not paused then fire a
    // resume event
    if (CalcIsPaused() && !GetIsParentPaused())
    {
        m_bIsPaused = false;

        m_bIsParentPaused = GetContainer().ContainerIsPaused();

        EventNotify(&l, CalcElapsedActiveTime(), TE_EVENT_RESUME);

        TickEventChildren(&l, TE_EVENT_RESUME, 0);
    }
    
    // Set before firing the event
    m_bIsPaused = false;
    
    PropNotify(&l, TE_PROPERTY_ISPAUSED | TE_PROPERTY_ISCURRPAUSED);

    hr = THR(l.FireEvents());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMENode::disable()
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::disable()",
              this));

    HRESULT hr;
    CEventList l;
    
    // If we are not ready then return an error
    if (!IsReady())
    {
        hr = E_FAIL;
        goto done;
    }

    if (!CalcIsDisabled())
    {
        m_bIsParentDisabled = GetContainer().ContainerIsDisabled();

        EventNotify(&l, CalcElapsedActiveTime(), TE_EVENT_DISABLE);

        m_bIsDisabled = true;

        TickEventChildren(&l, TE_EVENT_DISABLE, 0);
    }

    // Set before firing events
    m_bIsDisabled = true;
    
    PropNotify(&l,
               (TE_PROPERTY_TIME |
                TE_PROPERTY_REPEATCOUNT |
                TE_PROPERTY_PROGRESS |
                TE_PROPERTY_ISACTIVE |
                TE_PROPERTY_ISON |
                TE_PROPERTY_STATEFLAGS |
                TE_PROPERTY_ISDISABLED |
                TE_PROPERTY_ISCURRDISABLED));

    hr = THR(l.FireEvents());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMENode::enable()
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::enable()",
              this));

    HRESULT hr;
    CEventList l;
    
    // If we are not ready then return an error
    if (!IsReady())
    {
        hr = E_FAIL;
        goto done;
    }

    // If we were enabled and our parent was not enabled then fire an
    // enable event
    if (CalcIsDisabled() && !GetIsParentDisabled())
    {
        m_bIsDisabled = false;

        m_bIsParentDisabled = GetContainer().ContainerIsDisabled();

        EventNotify(&l, CalcElapsedActiveTime(), TE_EVENT_ENABLE);

        TickEventChildren(&l, TE_EVENT_ENABLE, 0);
    }
    
    // Set before firing the event
    m_bIsDisabled = false;
    
    PropNotify(&l,
               (TE_PROPERTY_TIME |
                TE_PROPERTY_REPEATCOUNT |
                TE_PROPERTY_PROGRESS |
                TE_PROPERTY_ISACTIVE |
                TE_PROPERTY_ISON |
                TE_PROPERTY_STATEFLAGS |
                TE_PROPERTY_ISDISABLED |
                TE_PROPERTY_ISCURRDISABLED));

    hr = THR(l.FireEvents());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMENode::reset()
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::reset()",
              this));

    HRESULT hr;
    CEventList l;
    bool bPrevActive = (IsActive() && !IsFirstTick());
    
    // If we are not ready then return an error
    if (!IsReady())
    {
        hr = E_FAIL;
        goto done;
    }

    ResetNode(&l, true);
    
    if (IsActive())
    {
        if (!bPrevActive)
        {
            TickEvent(&l, TE_EVENT_BEGIN, 0);
        }
        else
        {
            m_bFirstTick = false;
        }
    }

    hr = THR(l.FireEvents());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

// This takes times which are post ease (since this is what the user
// sees)

STDMETHODIMP
CTIMENode::seekSegmentTime(double dblSegmentTime)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::seekSegmentTime(%g)",
              this,
              dblSegmentTime));

    HRESULT hr;
    CEventList l;

    // If we are not ready then return an error
    if (!IsReady())
    {
        hr = E_FAIL;
        goto done;
    }

    // If we are not active then we cannot be seeked
    if (!IsActive())
    {
        hr = E_FAIL;
        goto done;
    }
    
    hr = THR(SeekTo(GetCurrRepeatCount(), dblSegmentTime, &l));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(l.FireEvents());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMENode::seekActiveTime(double dblActiveTime)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::seekActiveTime(%g)",
              this,
              dblActiveTime));

    HRESULT hr;
    CEventList l;

    // If we are not ready then return an error
    if (!IsReady())
    {
        hr = E_FAIL;
        goto done;
    }

    // If we are not active then we cannot be seeked
    if (!IsActive())
    {
        hr = E_FAIL;
        goto done;
    }
    
    double dblSegmentDur;
    dblSegmentDur = CalcCurrSegmentDur();
    
    LONG lCurrRepeat;
    double dblNewSegmentTime;

    CalcActiveComponents(dblActiveTime,
                         dblNewSegmentTime,
                         lCurrRepeat);

    hr = THR(SeekTo(lCurrRepeat, dblNewSegmentTime, &l));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(l.FireEvents());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
} //lint !e550

// This takes times which are post ease (since this is what the user
// sees)

STDMETHODIMP
CTIMENode::seekTo(LONG lRepeatCount, double dblSegmentTime)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::seekTo(%ld, %g)",
              this,
              lRepeatCount,
              dblSegmentTime));

    HRESULT hr;
    CEventList l;

    // If we are not ready then return an error
    if (!IsReady())
    {
        hr = E_FAIL;
        goto done;
    }

    // If we are not active then we cannot be seeked
    if (!IsActive())
    {
        hr = E_FAIL;
        goto done;
    }
    
    hr = THR(SeekTo(lRepeatCount, dblSegmentTime, &l));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(l.FireEvents());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMENode::update(DWORD dwFlags)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::update(%x)",
              this,
              dwFlags));

    HRESULT hr;

    // If we are not ready then return an error
    if (!IsReady())
    {
        hr = E_FAIL;
        goto done;
    }

    Invalidate(dwFlags);
    
    hr = THR(EnsureUpdate());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMENode::addBehavior(ITIMENodeBehavior * tnb)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::addBehavior(%#x)",
              this,
              tnb));
    
    RRETURN(m_nbList.Add(tnb));
}

STDMETHODIMP
CTIMENode::removeBehavior(ITIMENodeBehavior * tnb)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::removeBehavior(%#x)",
              this,
              tnb));
    
    RRETURN(m_nbList.Remove(tnb));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timeeng\node.cpp ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: node.cpp
//
//  Contents: 
//
//------------------------------------------------------------------------------------

#include "headers.h"
#include "Container.h"
#include "Node.h"
#include "NodeMgr.h"

DeclareTag(tagTIMENode, "TIME: Engine", "CTIMENode methods");

CTIMENode::CTIMENode()
: m_pszID(NULL),
  m_dblDur(TE_UNDEFINED_VALUE),
  m_dblRepeatCount(TE_UNDEFINED_VALUE),
  m_dblRepeatDur(TE_UNDEFINED_VALUE),
  m_tefFill(TE_FILL_REMOVE),
  m_bAutoReverse(false),
  m_fltSpeed(1),
  m_fltAccel(0),
  m_fltDecel(0),
  m_dwFlags(0),
  m_teRestart(TE_RESTART_ALWAYS),
  m_dblNaturalDur(TE_UNDEFINED_VALUE),
  m_dblImplicitDur(TE_UNDEFINED_VALUE),

  // Runtime attributes
  // Indicate everything is invalid
  m_dwInvalidateFlags(0xffffffff),
  
  m_dblBeginParentTime(TIME_INFINITE),
  m_dblEndParentTime(TIME_INFINITE),
  m_dblEndSyncParentTime(TIME_INFINITE),
  m_dblLastEndSyncParentTime(TIME_INFINITE),

  m_dblNextBoundaryParentTime(TIME_INFINITE),

  m_dblActiveDur(TIME_INFINITE),
  m_dblCurrParentTime(-TIME_INFINITE),

  m_lCurrRepeatCount(0),
  m_dblElapsedActiveRepeatTime(0.0),
  m_dblCurrSegmentTime(0.0),

  m_dblSyncSegmentTime(TIME_INFINITE),
  m_lSyncRepeatCount(TE_UNDEFINED_VALUE),
  m_dblSyncActiveTime(TIME_INFINITE),
  m_dblSyncParentTime(TIME_INFINITE),
  m_dblSyncNewParentTime(TIME_INFINITE),

  m_dblSimpleDur(0.0),
  m_dblSegmentDur(0.0),
  m_bFirstTick(true),
  m_bIsActive(false),
  m_bDeferredActive(false),
  m_fltRate(1.0f),
  m_fltParentRate(1.0f),
  m_tedDirection(TED_Forward),
  m_tedParentDirection(TED_Forward),
  m_bSyncCueing(false),
  
  // Time base management
  m_saBeginList(*this, true),
  m_saEndList(*this, false),

#if OLD_TIME_ENGINE
  m_flA0(0),
  m_flA1(0),
  m_flA2(0),
  m_flB0(0),
  m_flB1(0),
  m_flC0(0),
  m_flC1(0),
  m_flC2(0),
  m_bNeedEase(false),
  m_fltAccelEnd(0),
  m_fltDecelStart(0),
#endif
  
  m_bIsPaused(false),
  m_bIsParentPaused(false),
    
  m_bIsDisabled(false),
  m_bIsParentDisabled(false),
    
  m_dwPropChanges(0),
  
  m_bInTick(false),
  m_bNeedSegmentRecalc(false),
  m_bEndedByParent(false),

  m_dwUpdateCycleFlags(0),
  
  // Internal state management
  m_ptnParent(NULL),
  m_ptnmNodeMgr(NULL)

#ifdef NEW_TIMING_ENGINE
  m_startOnEventTime(-MM_INFINITE),
#endif // NEW_TIMING_ENGINE

{
    TraceTag((tagTIMENode,
              "CTIMENode(%p)::CTIMENode()",
              this));
}

CTIMENode::~CTIMENode()
{
    TraceTag((tagTIMENode,
              "CTIMENode(%p)::~CTIMENode()",
              this));

    delete m_pszID;

    Assert(m_ptnParent == NULL);
    m_ptnParent = NULL;

    Assert(m_ptnmNodeMgr == NULL);
    m_ptnmNodeMgr = NULL;
}

HRESULT
CTIMENode::Init(LPOLESTR id)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%p)::Init(%ls)",
              this,
              id));

    HRESULT hr;
    
    // Calculate all the internal timing state
    CalcTimingAttr(NULL);
    
    if (id)
    {
        m_pszID = CopyString(id);
        
        if (m_pszID == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
  
    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
CTIMENode::Error()
{
    LPWSTR str = TIMEGetLastErrorString();
    HRESULT hr = TIMEGetLastError();
    
    TraceTag((tagError,
              "CTIMENode(%p)::Error(%hr,%ls)",
              this,
              hr,
              str?str:L"NULL"));

    if (str)
    {
        hr = CComCoClass<CTIMENode, &__uuidof(CTIMENode)>::Error(str, IID_ITIMENode, hr);
        delete [] str;
    }

    RRETURN(hr);
}

void
CTIMENode::CalcTimingAttr(CEventList * l)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%p)::CalcTimingAttr(%#x)",
              this,
              l));
    
    // Determine the simple duration
    if (TE_UNDEFINED_VALUE == m_dblDur)
    {
        m_dblSimpleDur = TIME_INFINITE;
    }
    else
    {
        m_dblSimpleDur = m_dblDur;
    }
    
    // Calculate the time for each iteration of the repeat
    m_dblSegmentDur = m_dblSimpleDur;

    // If we are autoreversing then double the time period for a
    // single repeat
    if (m_bAutoReverse)
    {
        m_dblSegmentDur *= 2;
    }
        
    // Now multiply by the number of repeats we need
    double dblCalcRepDur;
    dblCalcRepDur = m_dblSegmentDur * CalcRepeatCount();
    
    // Now take the least of the calculated duration and the repeatDur
    // property
    if (m_dblRepeatDur == TE_UNDEFINED_VALUE)
    {
        m_dblActiveDur = dblCalcRepDur;
    }
    else
    {
        m_dblActiveDur = min(m_dblRepeatDur, dblCalcRepDur);
    }

    Assert(m_fltSpeed != 0.0f);
    
    m_fltRate = fabs(m_fltSpeed);

    CalcSimpleTimingAttr();

    PropNotify(l,
               (TE_PROPERTY_SEGMENTDUR |
                TE_PROPERTY_SIMPLEDUR |
                TE_PROPERTY_ACTIVEDUR |
                TE_PROPERTY_PROGRESS |
                TE_PROPERTY_SPEED));
}

void
CTIMENode::CalcSimpleTimingAttr()
{
    TraceTag((tagTIMENode,
              "CTIMENode(%p)::CalcSimpleTimingAttr()",
              this));

    CalculateEaseCoeff();

    Assert(m_fltSpeed != 0.0f);
    m_tedDirection = (m_fltSpeed >= 0.0f)?TED_Forward:TED_Backward;
}

void
CTIMENode::Invalidate(DWORD dwFlags)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%p)::Invalidate(%x)",
              this,
              dwFlags));

    if (IsReady())
    {
        m_dwInvalidateFlags |= dwFlags;
    }
}

//
// NodeMgr code
//

// The key is to ensure everything is connected when a node mgr is
// available.  This is how the IsReady flag is set and causes all
// timebase propagation to occur

HRESULT
CTIMENode::SetMgr(CTIMENodeMgr * mgr)
{
    // Make sure there was not a nodemgr set already
    Assert(m_ptnmNodeMgr == NULL);

    // Either we have a parent set or the node manager is managing us
    Assert(m_ptnParent != NULL ||
           mgr->GetTIMENode() == this);
    
    HRESULT hr;
    
    if (mgr == NULL)
    {
        AssertSz(false, "The node manager was set to NULL");
        hr = E_INVALIDARG;
        goto done;
    }

    // Set the node manager - this makes us ready
    m_ptnmNodeMgr = mgr;
    
    // Now we need to attach to the timebases before we update our
    // internal state variables
    
    // Attach to the time bases
    hr = THR(AttachToSyncArc());
    if (FAILED(hr))
    {
        goto done;
    }
    
    {
        CEventList l;

        // Now update ourselves completely so we get the correct initial
        // state

        ResetNode(&l, true);

        IGNORE_HR(l.FireEvents());
    }

#if OLD_TIME_ENGINE
    // if we need to registered a Timer Event, add it to the player.
    if (IsSyncMaster())
    {
        m_ptnmNodeMgr->AddBvrCB(this);
    }
#endif

    hr = S_OK;
  done:
    if (FAILED(hr))
    {
        ClearMgr();
    }
    
    RRETURN(hr);
}

void
CTIMENode::ClearMgr()
{
#if OLD_TIME_ENGINE
    // if we registered a Timer Event, remove it from the player.
    // Make sure we check for the player since we may not have
    // actually set it yet.
    if (IsSyncMaster() && m_ptnmNodeMgr)
    {
        m_ptnmNodeMgr->RemoveBvrCB(this);
    }
#endif

    DetachFromSyncArc();
    
    m_ptnmNodeMgr = NULL;
}

void
CTIMENode::ResetNode(CEventList * l,
                     bool bPropagate,
                     bool bResetOneShot)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%p)::ResetNode(%p, %d, %d)",
              this,
              l,
              bPropagate,
              bResetOneShot));

    double dblParentTime;
    bool bPrevActive = (IsActive() && !IsFirstTick());
    bool bPrevPaused = CalcIsPaused();
    bool bPrevDisabled = CalcIsDisabled();
    
    double dblActiveTime = CalcElapsedActiveTime();
    
    // Reset state variables
    
    if (bResetOneShot)
    {
        ResetOneShots();
    }

    m_bIsActive = false;
    m_bDeferredActive = false;
    m_bEndedByParent = false;
    m_bIsPaused = false;
    m_bFirstTick = true;
    m_dblImplicitDur = TE_UNDEFINED_VALUE;
    ResetSyncTimes();

    {
        const CNodeContainer * pcnc = GetContainerPtr();
        
        if (pcnc)
        {
            m_bIsParentPaused = pcnc->ContainerIsPaused();
            m_bIsParentDisabled = pcnc->ContainerIsDisabled();
            m_fltParentRate = pcnc->ContainerGetRate();
            m_tedParentDirection = pcnc->ContainerGetDirection();
            dblParentTime = pcnc->ContainerGetSimpleTime();
        }
        else
        {
            m_bIsParentPaused = false;
            m_bIsParentDisabled = false;
            m_fltParentRate = 1.0f;
            m_tedParentDirection = TED_Forward;
            dblParentTime = 0.0;
        }
    }
    
    // Update this here since so many places use it
    m_dblCurrParentTime = dblParentTime;

    // Calculate all the internal timing state
    CalcTimingAttr(l);
    
    // Don't propagate since the ResetSink will do that.

    ResetBeginAndEndTimes(l, dblParentTime, false);

    CalcRuntimeState(l, dblParentTime, 0.0);

    m_dwInvalidateFlags = 0;

    if (bPropagate)
    {
        ResetSinks(l);
    }

    // Do this here so state is correct
    
    // Always fire the reset to ensure all peers clear their state
    EventNotify(l, 0.0, TE_EVENT_RESET);

    PropNotify(l,
               (TE_PROPERTY_IMPLICITDUR |
                TE_PROPERTY_ISPAUSED |
                TE_PROPERTY_ISCURRPAUSED |
                TE_PROPERTY_ISDISABLED |
                TE_PROPERTY_ISCURRDISABLED));
    
    // Do not fire the begin since we may need to cue but we do not
    // find that out until tick time
    
    // This should happen only when we are newly added to an already
    // paused container
    if (!bPrevPaused && CalcIsPaused())
    {
        EventNotify(l, dblActiveTime, TE_EVENT_PAUSE);
    }
    
    if (!bPrevDisabled && CalcIsDisabled())
    {
        EventNotify(l, dblActiveTime, TE_EVENT_DISABLE);
    }
    
    // Now go through our children
    ResetChildren(l, true);
    
    if (bPrevPaused && !CalcIsPaused())
    {
        EventNotify(l, dblActiveTime, TE_EVENT_RESUME);
    }
    
    if (bPrevDisabled && !CalcIsDisabled())
    {
        EventNotify(l, dblActiveTime, TE_EVENT_ENABLE);
    }
    
    if (bPrevActive != IsActive())
    {
        if (!IsActive())
        {
            EventNotify(l, dblActiveTime, TE_EVENT_END);
        }
    }
    else
    {
        m_bFirstTick = false;
    }
    
  done:
    return;
}
    
void
CTIMENode::ResetChildren(CEventList * l, bool bPropagate)
{
}

void
CTIMENode::UpdateNode(CEventList * l)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%p)::UpdateNode(%p)",
              this,
              l));

    bool bNeedEndCalc = false;
    bool bNeedBeginCalc = false;
    bool bNeedRuntimeCalc = false;
    bool bNeedTimingCalc = false;
//    double dblSegmentTime = GetCurrSegmentTime();
//    long lRepeatCount = GetCurrRepeatCount();
    double dblLocalSlip = 0.0;
    
    Assert(IsReady());
    
    if (m_dwInvalidateFlags == 0)
    {
        goto done;
    }
    
    if (GetContainer().ContainerIsActive())
    {
        EventNotify(l, 0.0, TE_EVENT_UPDATE);
    }
    
    // Reset state variables
    
    if (0 != (m_dwInvalidateFlags & TE_INVALIDATE_BEGIN))
    {
        bNeedEndCalc = true;
        bNeedBeginCalc = true;
        bNeedRuntimeCalc = true;
    }
    
    if (0 != (m_dwInvalidateFlags & TE_INVALIDATE_END))
    {
        bNeedEndCalc = true;
    }
    
    if (0 != (m_dwInvalidateFlags & TE_INVALIDATE_SIMPLETIME))
    {
        bNeedTimingCalc = true;
    }
    
    if (0 != (m_dwInvalidateFlags & TE_INVALIDATE_DUR))
    {
        bNeedTimingCalc = true;
        bNeedRuntimeCalc = true;
        bNeedEndCalc = true;
    }

    // Clear the flags now
    
    m_dwInvalidateFlags = 0;

    if (bNeedRuntimeCalc)
    {
        dblLocalSlip = (CalcCurrLocalTime() -
                        CalcElapsedLocalTime());
    }

    if (bNeedTimingCalc)
    {
        const CNodeContainer * pcnc = GetContainerPtr();
        
        if (pcnc)
        {
            m_fltParentRate = pcnc->ContainerGetRate();
            m_tedParentDirection = pcnc->ContainerGetDirection();
        }
        else
        {
            m_fltParentRate = 1.0f;
            m_tedParentDirection = TED_Forward;
        }
    
        // Calculate all the internal timing state
        CalcTimingAttr(l);
    }
    
    if (bNeedBeginCalc)
    {
        ResetSyncTimes();
        m_bFirstTick = true;

        ResetBeginTime(l, m_dblCurrParentTime, true);
    }

    if (bNeedRuntimeCalc)
    {
        if (bNeedEndCalc)
        {
            ResetEndTime(l, m_dblCurrParentTime, true);
        }

        CalcCurrRuntimeState(l, dblLocalSlip);
    }
    else
    {
        if (bNeedEndCalc)
        {
            RecalcCurrEndTime(l, true);
        }
    }
    
    PropNotify(l,
               (TE_PROPERTY_ISON |
                TE_PROPERTY_STATEFLAGS));

    // Now go through and reset children
    ResetChildren(l, true);
    
  done:
    return;
}

HRESULT
CTIMENode::EnsureUpdate()
{
    TraceTag((tagTIMENode,
              "CTIMENode(%p)::EnsureUpdate()",
              this));

    HRESULT hr;
    CEventList l;
    
    UpdateNode(&l);

    hr = THR(l.FireEvents());
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

void
CTIMENode::CalcCurrRuntimeState(CEventList *l,
                                double dblLocalLag)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%p)::CalcCurrRuntimeState(%p, %g)",
              this,
              l,
              dblLocalLag));
    
    const CNodeContainer * pcnc = GetContainerPtr();
        
    if (pcnc)
    {
        double dblParentTime = 0.0;

        if (GetSyncParentTime() != TIME_INFINITE)
        {
            dblParentTime = GetSyncParentTime();
        }
        else
        {
            dblParentTime = pcnc->ContainerGetSimpleTime();
        }

        CalcRuntimeState(l, dblParentTime, dblLocalLag);
    }
    else
    {
        ResetRuntimeState(l, -TIME_INFINITE);
    }
}

void
CTIMENode::CalcRuntimeState(CEventList *l,
                            double dblParentSimpleTime,
                            double dblLocalLag)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%p)::CalcRuntimeState(%p, %g, %g)",
              this,
              l,
              dblParentSimpleTime,
              dblLocalLag));
    
    if (dblLocalLag == -TIME_INFINITE)
    {
        dblLocalLag = 0;
    }

    if (!IsReady())
    {
        ResetRuntimeState(l,
                          dblParentSimpleTime);
        goto done;
    }
    
    m_dblCurrParentTime = dblParentSimpleTime;

    if (!GetContainer().ContainerIsActive() ||
        dblParentSimpleTime < GetBeginParentTime() ||
        dblParentSimpleTime > GetEndParentTime() ||
        (!m_bFirstTick && dblParentSimpleTime == GetEndParentTime()))
    {
        m_bIsActive = false;
    }
    else
    {
        // this means we are currently active - set the active
        // flag
        m_bIsActive = true;
    }
        
    // See if we were active but clipped by our parent
    if (!IsActive() &&
        dblParentSimpleTime >= GetBeginParentTime() &&
        dblParentSimpleTime < GetEndParentTime())
    {
        m_bEndedByParent = true;
    }
    else
    {
        m_bEndedByParent = false;
    }

    double dblElapsedActiveTime;
            
    if (GetSyncParentTime() != TIME_INFINITE)
    {
        Assert(GetSyncSegmentTime() != TIME_INFINITE);
        Assert(GetSyncRepeatCount() != TE_UNDEFINED_VALUE);
        Assert(GetSyncActiveTime() != TIME_INFINITE);

        m_dblCurrSegmentTime = GetSyncSegmentTime();
        m_lCurrRepeatCount = GetSyncRepeatCount();
        dblElapsedActiveTime = GetSyncActiveTime();
    }
    else
    {
        //
        // We now need to calculate the elapsed active time
        // First get the elapsed local time and then convert it
        // If there is not known active dur then we need to do
        // something reasonable when reversing
        //
        
        // First get the local time
        dblElapsedActiveTime = dblParentSimpleTime - GetBeginParentTime();
            
        // Next remove the lag
        dblElapsedActiveTime -= dblLocalLag;
            
        // Now convert to active time
        // No need to clamp the values since the conversion function does
        // this itself.
        dblElapsedActiveTime = LocalTimeToActiveTime(dblElapsedActiveTime);
            
        CalcActiveComponents(dblElapsedActiveTime,
                             m_dblCurrSegmentTime,
                             m_lCurrRepeatCount);
    }
        
    m_dblElapsedActiveRepeatTime = dblElapsedActiveTime - m_dblCurrSegmentTime;

    Assert(GetCurrRepeatCount() <= CalcRepeatCount());
    Assert(CalcElapsedActiveTime() <= CalcEffectiveActiveDur());

    PropNotify(l,
               (TE_PROPERTY_TIME |
                TE_PROPERTY_REPEATCOUNT |
                TE_PROPERTY_PROGRESS |
                TE_PROPERTY_ISACTIVE |
                TE_PROPERTY_ISON |
                TE_PROPERTY_STATEFLAGS));

  done:
    return;
}


void
CTIMENode::ResetRuntimeState(CEventList *l,
                             double dblParentSimpleTime)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%p)::ResetRuntimeState(%p, %g)",
              this,
              l,
              dblParentSimpleTime));
    
    double dblSegmentDur = CalcCurrSegmentDur();
    
    m_bIsActive = false;
    m_bEndedByParent = false;
    m_dblCurrParentTime = dblParentSimpleTime;

    if (GetSyncParentTime() != TIME_INFINITE)
    {
        m_dblCurrParentTime = GetSyncParentTime();

        Assert(GetSyncSegmentTime() != TIME_INFINITE);
        Assert(GetSyncRepeatCount() != TE_UNDEFINED_VALUE);
        Assert(GetSyncActiveTime() != TIME_INFINITE);

        m_dblCurrSegmentTime = GetSyncSegmentTime();
        m_lCurrRepeatCount = GetSyncRepeatCount();
        m_dblElapsedActiveRepeatTime = GetSyncActiveTime() - m_dblCurrSegmentTime;
    }
    else if (CalcActiveDirection() == TED_Forward ||
             dblSegmentDur == TIME_INFINITE)
    {
        m_dblCurrSegmentTime = 0.0;
        m_lCurrRepeatCount = 0;
        m_dblElapsedActiveRepeatTime = 0.0;
    }
    else
    {
        m_dblElapsedActiveRepeatTime = CalcCurrActiveDur();
        CalcActiveComponents(m_dblElapsedActiveRepeatTime,
                             m_dblCurrSegmentTime,
                             m_lCurrRepeatCount);
    }

    PropNotify(l,
               (TE_PROPERTY_TIME |
                TE_PROPERTY_REPEATCOUNT |
                TE_PROPERTY_PROGRESS |
                TE_PROPERTY_ISACTIVE |
                TE_PROPERTY_ISON |
                TE_PROPERTY_STATEFLAGS));
}

void
CTIMENode::RecalcSegmentDurChange(CEventList * l,
                                  bool bRecalcTiming,
                                  bool bForce)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%p, %ls)::RecalcSegmentDurChange(%p, %d, %d)",
              this,
              GetID(),
              l,
              bRecalcTiming,
              bForce));

    bool bPrevActive = IsActive();
    double dblLocalSlip;

    if (IsInTick() && !bForce)
    {
        // We do not expect to get called to force timing recalc when
        // we are in tick.  If this fires then we need to cache this
        // flag as well
        Assert(!bRecalcTiming);
        m_bNeedSegmentRecalc = true;
        goto done;
    }
    
    // Clear the segment recalc flag
    m_bNeedSegmentRecalc = false;

    // First calculate the local slip
    dblLocalSlip = (CalcCurrLocalTime() - CalcElapsedLocalTime());

    // Now clamp the segment duration
    {
        double dblSegmentDur = CalcCurrSegmentDur();
        if (m_dblCurrSegmentTime > dblSegmentDur)
        {
            m_dblCurrSegmentTime = dblSegmentDur;
        }
    }

    if (!IsReady())
    {
        RecalcCurrEndTime(l, true);
        goto done;
    }
    
    TEDirection dir;
    dir = CalcActiveDirection();

    if (((dir == TED_Forward) &&
         (GetCurrParentTime() >= GetEndParentTime())) ||
        
        ((dir == TED_Backward) &&
         (GetCurrParentTime() <= GetEndParentTime())))
    {
        goto done;
    }
    
    if (dir == TED_Backward || bRecalcTiming)
    {
        long lPrevRepeatCount = GetCurrRepeatCount();
        
        ResetEndTime(l, GetCurrParentTime(), true);

        CalcCurrRuntimeState(l, dblLocalSlip);


        if (GetCurrRepeatCount() != lPrevRepeatCount)
        {
            EventNotify(l, CalcElapsedActiveTime(), TE_EVENT_REPEAT, GetCurrRepeatCount());
        }
                
        EventNotify(l, CalcElapsedActiveTime(), TE_EVENT_RESET);

        // Do not propagate the change otherwise this gets recursive
        ResetChildren(l, false);
    }
    else
    {
        RecalcCurrEndTime(l, true);
    }

    if (bPrevActive != IsActive())
    {
        if (IsActive())
        {
            EventNotify(l, CalcElapsedActiveTime(), TE_EVENT_BEGIN);
            TickEvent(l, TE_EVENT_BEGIN, 0);
        }
        else
        {
            TickEvent(l, TE_EVENT_END, 0);
            EventNotify(l, CalcElapsedActiveTime(), TE_EVENT_END);
        }
    }
    
  done:
    return;
}

void
CTIMENode::RecalcBeginSyncArcChange(CEventList * l,
                                    double dblNewTime)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%p)::RecalcBeginSyncArcChange(%p, %g)",
              this,
              l,
              dblNewTime));

    Assert(IsReady());
    
    TEDirection dir = CalcActiveDirection();
    
    if (m_dwUpdateCycleFlags != 0)
    {
        goto done;
    }
    
    if (IsActive() ||
        (GetCurrParentTime() >= GetBeginParentTime() &&
         GetCurrParentTime() < GetEndParentTime()))
    {
        // If we are not a restart then we cannot affect the begin or end
        if (GetRestart() != TE_RESTART_ALWAYS)
        {
            goto done;
        }

        if (dir == TED_Forward)
        {
            if (dblNewTime > GetBeginParentTime() &&
                dblNewTime < GetCurrParentTime())
            {
                UpdateNextTickBounds(l,
                                     dblNewTime,
                                     GetCurrParentTime());
                UpdateNextBoundaryTime(dblNewTime);
            }
            else
            {
                RecalcCurrEndTime(l, true);

                if (GetCurrParentTime() >= GetEndParentTime())
                {
                    TickEvent(l, TE_EVENT_END, 0);

                    double dblBegin;
                    CalcNextBeginTime(GetCurrParentTime(),
                                      false,
                                      dblBegin);
            
                    // Indicate that the next tick bounds is the end time
                    UpdateNextBoundaryTime(dblBegin);

                    if (dblBegin == GetCurrParentTime())
                    {
                        // Update the tick bounds passing the new begin time and the
                        // current parent time
                        UpdateNextTickBounds(l,
                                             dblBegin,
                                             GetCurrParentTime());
                    }
                }
            }
        }
        else
        {
            if (dblNewTime <= GetCurrParentTime() &&
                dblNewTime > GetBeginParentTime())
            {
                double dblBegin;
                CalcNextBeginTime(GetCurrParentTime(),
                                  false,
                                  dblBegin);
    
                if (dblBegin != GetBeginParentTime())
                {
                    // Update the tick bounds passing the new begin time and the
                    // current parent time
                    UpdateNextTickBounds(l,
                                         dblBegin,
                                         GetCurrParentTime());

                    // Indicate that the next tick bounds is the end time
                    UpdateNextBoundaryTime(GetEndParentTime());
                }
            }
        }
    }
    else if (GetCurrParentTime() < GetBeginParentTime())
    {
        Assert(!IsActive());
        
        // If we are going forward we should update the times
        // If we are going backwards then only update if the new
        // time is less than the current time
        if (dir == TED_Forward)
        {
            // Use -TIME_INFINITE since the new begin time is in the future which
            // means we have never begin before
            double dblBegin;
            CalcNextBeginTime(-TIME_INFINITE,
                              false,
                              dblBegin);
    
            UpdateNextTickBounds(l,
                                 dblBegin,
                                 GetCurrParentTime());
            UpdateNextBoundaryTime(dblBegin);
        }
        else
        {
            if (dblNewTime <= GetCurrParentTime())
            {
                UpdateNextTickBounds(l,
                                     dblNewTime,
                                     GetCurrParentTime());
                UpdateNextBoundaryTime(GetEndParentTime());
            }
        }
    }
    else
    {
        Assert(!IsActive());
        Assert(GetCurrParentTime() >= GetBeginParentTime());

        if (dir == TED_Forward)
        {
            if (GetRestart() == TE_RESTART_NEVER)
            {
                goto done;
            }
            
            if (dblNewTime <= GetCurrParentTime() &&
                dblNewTime > GetBeginParentTime() &&
                (GetRestart() == TE_RESTART_ALWAYS ||
                 dblNewTime >= GetEndParentTime()))
            {
                UpdateNextTickBounds(l,
                                     dblNewTime,
                                     GetCurrParentTime());
                UpdateNextBoundaryTime(dblNewTime);
            }
            else
            {
                double dblBegin;
                CalcNextBeginTime(GetCurrParentTime(),
                                  false,
                                  dblBegin);

                UpdateNextBoundaryTime(dblBegin);
                
                if (dblBegin == GetCurrParentTime())
                {
                    UpdateNextTickBounds(l,
                                         dblBegin,
                                         GetCurrParentTime());
                }
            }
        }
        else
        {
            // dir == TED_Backward

            double dblBegin;
            CalcNextBeginTime(GetCurrParentTime(),
                              false,
                              dblBegin);
    
            // Update the tick bounds passing the new begin time and the
            // current parent time
            UpdateNextTickBounds(l,
                                 dblBegin,
                                 GetCurrParentTime());

            // Indicate that the next tick bounds is the end time
            UpdateNextBoundaryTime(GetEndParentTime());
        }
    }

  done:
    return;
}

void
CTIMENode::RecalcEndSyncArcChange(CEventList * l,
                                  double dblNewTime)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%p)::RecalcEndSyncArcChange(%p, %g)",
              this,
              l,
              dblNewTime));

    Assert(IsReady());
    
    TEDirection dir = CalcActiveDirection();
    
    if (m_dwUpdateCycleFlags != 0)
    {
        goto done;
    }
    
    if (dir == TED_Forward)
    {
        // Do not recalc if we passed the end point yet
        if (GetCurrParentTime() >= GetEndParentTime())
        {
            goto done;
        }

        RecalcCurrEndTime(l, true);

        if (IsActive() &&
            GetCurrParentTime() >= GetEndParentTime())
        {
            TickEvent(l, TE_EVENT_END, 0);

            double dblBegin;
            CalcNextBeginTime(GetCurrParentTime(),
                              false,
                              dblBegin);
            
            // Indicate that the next tick bounds is the end time
            UpdateNextBoundaryTime(dblBegin);

            if (dblBegin == GetCurrParentTime())
            {
                // Update the tick bounds passing the new begin time and the
                // current parent time
                UpdateNextTickBounds(l,
                                     dblBegin,
                                     GetCurrParentTime());
            }
        }
    }
    else
    {
        if (GetCurrParentTime() <= GetEndParentTime())
        {
            goto done;
        }
        
        double dblBegin;
        CalcNextBeginTime(GetCurrParentTime(),
                          false,
                          dblBegin);
    
        // Update the tick bounds passing the new begin time and the
        // current parent time
        UpdateNextTickBounds(l,
                             dblBegin,
                             GetCurrParentTime());
        
        // Indicate that the next tick bounds is the end time
        UpdateNextBoundaryTime(GetEndParentTime());
    }

  done:
    return;
}

void
CTIMENode::HandleTimeShift(CEventList * l)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%p)::HandleTimeShift(%p)",
              this,
              l));

    // First update ourselves from the time shift
    m_saBeginList.UpdateFromLongSyncArcs(l);
    m_saEndList.UpdateFromLongSyncArcs(l);
    
    // Now notify our syncs that our time has shifted
    UpdateSinks(l, TS_TIMESHIFT);
}

double
CTIMENode::CalcCurrSimpleTime() const
{
    double ret = GetCurrSegmentTime();

    Assert(ret != TIME_INFINITE && ret != -TIME_INFINITE);
    
    ret = SegmentTimeToSimpleTime(ret);

    return ret;
}

double
CTIMENode::CalcCurrSimpleDur() const
{
    double d;
    
    if (GetDur() != TE_UNDEFINED_VALUE)
    {
        d = GetSimpleDur();
    }
    else
    {
        double dblImpl = GetImplicitDur();
        double dblNat = GetNaturalDur();

        if (dblImpl == TE_UNDEFINED_VALUE)
        {
            if (dblNat == TE_UNDEFINED_VALUE)
            {
                d = TIME_INFINITE;
            }
            else
            {
                d = dblNat;
            }
        }
        else if (dblNat == TE_UNDEFINED_VALUE)
        {
            Assert(dblImpl != TE_UNDEFINED_VALUE);
            d = dblImpl;
        }
        else if (dblNat == 0)
        {
            d = dblImpl;
        }
        else
        {
            d = max(dblNat, dblImpl);
        }
    }

    return d;
}

double
CTIMENode::CalcCurrActiveDur() const
{
    double ret = CalcCurrSegmentDur() * CalcRepeatCount();
    
    ret = Clamp(0.0,
                ret,
                GetActiveDur());
    
    return ret;
}

double
CTIMENode::CalcEffectiveActiveDur() const
{
    double dblRet;
    double dblSegmentDur = CalcCurrSegmentDur();

    // Figure out how much repeat time is left and then sutract
    // the last current time
    // This is the amount of time remaining from the last tick
    // time is parent time

    // If the segment time is infinite then this will ultimately end
    // up either getting clamp by the active dur below or just ignored
    // later begin the sync arcs ended early.  If the repeat count is
    // expired this will still return infinity since we never reach
    // the repeat count but expect the segment time to be equal to the
    // segment dur.  Again, if the segment dur is infinite then this
    // will cause everything to be ignored.
    dblRet = (CalcRepeatCount() - GetCurrRepeatCount()) * dblSegmentDur;
            
    // Now add the elapsed repeat time
    dblRet += GetElapsedActiveRepeatTime();
        
    // Clamp it
    dblRet = Clamp(0.0,
                   dblRet,
                   GetActiveDur());

    return dblRet;
}

//
// This needs to be very efficient since we call it a lot and we do
// not want to cache it
//

TEDirection
CTIMENode::CalcActiveDirection() const
{
    TEDirection tedRet;

    // Take our parent direction
    tedRet = GetParentDirection();
    
    // See if we are currently suppose to be reversing and invert our
    // direction
    if (TEIsBackward(GetDirection()))
    {
        tedRet = TEReverse(tedRet);
    }

    return tedRet;
}

bool
CTIMENode::IsAutoReversing(double dblSegmentTime) const
{
    return (GetAutoReverse() &&
            (dblSegmentTime > GetSimpleDur() ||
             (dblSegmentTime == GetSimpleDur() && TEIsForward(CalcActiveDirection()))));
}

TEDirection
CTIMENode::CalcSimpleDirection() const
{
    TEDirection tedRet;

    // Take our initial direction
    tedRet = CalcActiveDirection();
    
    // See if we are currently suppose to be reversing and invert our
    // direction
    if (IsAutoReversing(GetCurrSegmentTime()))
    {
        // Since this is really a bool this will work
        tedRet = TEReverse(tedRet);
    }

    return tedRet;
}

// This is inclusive of the end time
bool
CTIMENode::CalcIsOn() const
{
    bool ok = false;
    
    if (!IsReady())
    {
        goto done;
    }
    
    if (CalcIsActive())
    {
        ok = true;
        goto done;
    }

    if (!GetContainer().ContainerIsOn())
    {
        goto done;
    }
    
    if (IsEndedByParent())
    {
        ok = true;
        goto done;
    }

    if (GetFill() == TE_FILL_FREEZE &&
        GetCurrParentTime() >= GetBeginParentTime())
    {
        ok = true;
        goto done;
    }
    
  done:
    return ok;
}

CNodeContainer &
CTIMENode::GetContainer() const
{
    if (GetParent() != NULL)
    {
        return *(GetParent());
    }
    else
    {
        Assert(GetMgr() != NULL);
        
        return *(GetMgr());
    }
}

const CNodeContainer *
CTIMENode::GetContainerPtr() const
{
    if (GetParent() != NULL)
    {
        return GetParent();
    }
    else if (GetMgr() != NULL)
    {
        return GetMgr();
    }
    else
    {
        return NULL;
    }
}

#if DBG
void
CTIMENode::Print(int spaces)
{
    TraceTag((tagPrintTimeTree,
              "%*s[(%p,%ls): "
              "simpledur = %g, segmentdur = %g, "
              "calcsegmentdur = %g, actDur = %g, "
              "repcnt = %g, repdur = %g, "
              "autoreverse = %d]",
              spaces,
              "",
              this,
              m_pszID,
              m_dblSimpleDur,
              m_dblSegmentDur,
              CalcCurrSegmentDur(),
              m_dblActiveDur,
              m_dblRepeatCount,
              m_dblRepeatDur,
              m_bAutoReverse));
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timeeng\container.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: container.h
//
//  Contents: 
//
//------------------------------------------------------------------------------------

#ifndef _TECONTAINER_H
#define _TECONTAINER_H

#include "NodeMgr.h"

class
__declspec(uuid("0dfe0bae-537c-11d2-b955-3078302c2030")) 
ATL_NO_VTABLE
CTIMEContainer
    : public CComCoClass<CTIMEContainer, &__uuidof(CTIMEContainer)>,
      public ITIMEContainer,
      public ISupportErrorInfoImpl<&IID_ITIMEContainer>,
      public CTIMENode
{
  public:
    CTIMEContainer();
    virtual ~CTIMEContainer();

    HRESULT Init(LPOLESTR id);
    
    void FinalRelease();

#if DBG
    const _TCHAR * GetName() { return __T("CTIMEContainer"); }
#endif

    BEGIN_COM_MAP(CTIMEContainer)
        COM_INTERFACE_ENTRY2(ITIMENode, CTIMENode)
        COM_INTERFACE_ENTRY(ITIMEContainer)
        COM_INTERFACE_ENTRY2(ISupportErrorInfo,ITIMEContainer)
    END_COM_MAP();

    // This must be in the derived class and not the base class since
    // the typecast down to the base class messes things up
    static inline HRESULT WINAPI
        InternalQueryInterface(CTIMEContainer* pThis,
                               const _ATL_INTMAP_ENTRY* pEntries,
                               REFIID iid,
                               void** ppvObject)
    { return BaseInternalQueryInterface(pThis,
                                        (void *) pThis,
                                        pEntries,
                                        iid,
                                        ppvObject); }

    

    //
    // ITIMEContainer
    //
    
    STDMETHOD(addNode)(ITIMENode * tn);
    STDMETHOD(removeNode)(ITIMENode * tn);
    STDMETHOD(get_numChildren)(long * l);
    
    STDMETHOD(get_endSync)(TE_ENDSYNC * flags);
    STDMETHOD(put_endSync)(TE_ENDSYNC flags);

    TE_ENDSYNC GetEndSync() { return m_tesEndSync; }

    void ParentUpdateSink(CEventList * l,
                          CTIMENode & tn);

  protected:
    HRESULT Error();

    // Overridden from CTIMENode so we can process our children
    HRESULT SetMgr(CTIMENodeMgr * ptnm);
    void ClearMgr();

    HRESULT Add(CTIMENode *bvr); //lint !e1411
    HRESULT Remove(CTIMENode *bvr); //lint !e1411
    
    bool IsChild(const CTIMENode & tn) const;
    
    HRESULT AddToChildren(CTIMENode * bvr);
    void RemoveFromChildren(CTIMENode * bvr);
    
    void TickChildren(CEventList * l,
                      double dblNewSegmentTime,
                      bool bNeedPlay);
    
    void TickEventChildren(CEventList * l,
                           TE_EVENT_TYPE et,
                           DWORD dwFlags);
    
    virtual void ResetChildren(CEventList * l, bool bPropagate);

    void CalcImplicitDur(CEventList * l);
    
#if DBG
    virtual void Print(int spaces);
#endif
  protected:
    TIMENodeList  m_children;
    TE_ENDSYNC    m_tesEndSync;
    bool          m_bIgnoreParentUpdate;
};

#endif /* _TECONTAINER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timeeng\nodebvr.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: nodebvr.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _NODEBVR_H
#define _NODEBVR_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CNodeBvrList
{
  public:
    CNodeBvrList();
    ~CNodeBvrList();

    HRESULT Add(ITIMENodeBehavior * bvr);
    HRESULT Remove(ITIMENodeBehavior * bvr);
    
    HRESULT DispatchTick();

    HRESULT DispatchEventNotify(double eventTime,
                                TE_EVENT_TYPE eventType, 
                                long lRepeatCount = 0);
    HRESULT DispatchGetSyncTime(double & dblNewTime,
                                LONG & lNewRepeatCount,
                                bool & bCueing);
    HRESULT DispatchPropNotify(DWORD tePropType);
  protected:
    typedef std::list<ITIMENodeBehavior *> TIMENodeBvrList;

    TIMENodeBvrList m_tnbList;
};

#endif /* _NODEBVR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timeeng\node.h ===
//+-----------------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (c) Microsoft Corporation, 1999
//
//  File: node.h
//
//  Contents: 
//
//------------------------------------------------------------------------------------

#ifndef _TIMENODE_H
#define _TIMENODE_H

#pragma once

#include "timebase.h"
#include "nodebvr.h"
#include "nodecontainer.h"

class CTIMEContainer;
class CTIMENodeMgr;

extern TRACETAG tagTIMENode;

class CTIMENode;
typedef std::list<CTIMENode*> TIMENodeList;
class CEventList;

#define TE_INVALIDATE_BEGIN      0x00000001
#define TE_INVALIDATE_END        0x00000002
#define TE_INVALIDATE_DUR        0x00000004
#define TE_INVALIDATE_SIMPLETIME 0x00000008
#define TE_INVALIDATE_STATE      0x00000010
    
// This is for detecting cycles
#define TE_INUPDATEBEGIN         0x00000001
#define TE_INUPDATEEND           0x00000002
#define TE_INUPDATEENDSYNC       0x00000004

// Tick Event Flags
// This flags means that we are in a child of the originator of the
// event.  This is used to know why we ended the element (due to the
// element naturally ending or the parent ending).
#define TE_EVENT_INCHILD         0x10000000

class
__declspec(uuid("ad8888cc-537a-11d2-b955-3078302c2030")) 
ATL_NO_VTABLE CTIMENode
    : public CComObjectRootEx<CComSingleThreadModel>,
      public CComCoClass<CTIMENode, &__uuidof(CTIMENode)>,
      public ITIMENode,
      public ISupportErrorInfoImpl<&IID_ITIMENode>,
      public CNodeContainer
{
  public:
    CTIMENode();
    virtual ~CTIMENode();

    HRESULT Init(LPOLESTR id);
    
#if DBG
    virtual const _TCHAR * GetName() const { return __T("CTIMENode"); }
#endif

    BEGIN_COM_MAP(CTIMENode)
        COM_INTERFACE_ENTRY(ITIMENode)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
    END_COM_MAP();


    // Stuff to get ATL working correctly
    
    static HRESULT WINAPI
        BaseInternalQueryInterface(CTIMENode* pThis,
                                   void * pv,
                                   const _ATL_INTMAP_ENTRY* pEntries,
                                   REFIID iid,
                                   void** ppvObject);
    // This must be in the derived class and not the base class since
    // the typecast down to the base class messes things up
    static inline HRESULT WINAPI
        InternalQueryInterface(CTIMENode* pThis,
                               const _ATL_INTMAP_ENTRY* pEntries,
                               REFIID iid,
                               void** ppvObject)
        { return BaseInternalQueryInterface(pThis,
                                            (void *) pThis,
                                            pEntries,
                                            iid,
                                            ppvObject); }

#ifndef END_COM_MAP_ADDREF
    // IUnknown
    
    STDMETHOD_(ULONG,AddRef)(void) = 0;
    STDMETHOD_(ULONG,Release)(void) = 0;
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) = 0;
#endif

    //
    // ITIMENode interface
    //
    
    STDMETHOD(get_id)(LPOLESTR * s);
    STDMETHOD(put_id)(LPOLESTR s);
        
    STDMETHOD(get_dur)(double * pdbl);
    STDMETHOD(put_dur)(double dbl);
        
    STDMETHOD(get_repeatCount)(double * pdbl);
    STDMETHOD(put_repeatCount)(double dbl);
       
    STDMETHOD(get_repeatDur)(double * f);
    STDMETHOD(put_repeatDur)(double f);
        
    STDMETHOD(get_fill)(TE_FILL_FLAGS *);
    STDMETHOD(put_fill)(TE_FILL_FLAGS);
    
    STDMETHOD(get_autoReverse)(VARIANT_BOOL * pr);
    STDMETHOD(put_autoReverse)(VARIANT_BOOL r);
        
    STDMETHOD(get_speed)(float *);
    STDMETHOD(put_speed)(float);

    STDMETHOD(get_accelerate)(float *);
    STDMETHOD(put_accelerate)(float);

    STDMETHOD(get_decelerate)(float *);
    STDMETHOD(put_decelerate)(float);

    STDMETHOD(get_flags)(DWORD *);
    STDMETHOD(put_flags)(DWORD);

    STDMETHOD(get_restart)(TE_RESTART_FLAGS * pr);
    STDMETHOD(put_restart)(TE_RESTART_FLAGS r);
        
    //
    // Begin
    //
    STDMETHOD(addBegin)(double dblOffset,
                        LONG * cookie);
    STDMETHOD(addBeginSyncArc)(ITIMENode * node,
                               TE_TIMEPOINT tep,
                               double dblOffset,
                               LONG * cookie);
    // If you specify 0 then we will remove everything
    STDMETHOD(removeBegin)(LONG cookie);
    
    STDMETHOD(beginAt)(double dblParentTime);

    //
    // End
    //
    STDMETHOD(addEnd)(double dblOffset,
                      LONG * cookie);
    STDMETHOD(addEndSyncArc)(ITIMENode * node,
                             TE_TIMEPOINT tep,
                             double dblOffset,
                             LONG * cookie);
    // If you specify 0 then we will remove everything
    STDMETHOD(removeEnd)(LONG cookie);
    
    STDMETHOD(endAt)(double dblParentTime);

    STDMETHOD(pause)();
    STDMETHOD(resume)();
    
    STDMETHOD(enable)();
    STDMETHOD(disable)();
    
    STDMETHOD(seekSegmentTime)(double dblSegmentTime);
    STDMETHOD(seekActiveTime)(double dblActiveTime);
    STDMETHOD(seekTo)(LONG lRepeatCount, double dblSegmentTime);

    //
    // Calculated values
    //

    STDMETHOD(get_beginParentTime)(double * d);
    
    // This is the time on the parents timeline at which the node
    // will or already has ended.  If it is infinite then the end
    // time is unknown.
    // This is in posttransformed parent time.
    STDMETHOD(get_endParentTime)(double * d);
    
    // This is the current simple time of the node.
    STDMETHOD(get_currSimpleTime)(double * d);
    
    // This is the number of times the node has repeated
    STDMETHOD(get_currRepeatCount)(LONG * l);

    // This is the current segment time of the node.
    STDMETHOD(get_currSegmentTime)(double * d);
    
    STDMETHOD(get_currImplicitDur)(double * d);
    
    STDMETHOD(get_currActiveTime)(double * d);

    STDMETHOD(get_currProgress)(double * d);

    STDMETHOD(get_currSegmentDur)(double * d);

    STDMETHOD(get_currSimpleDur)(double * d);

    STDMETHOD(get_currSpeed)(float * speed);

    STDMETHOD(get_naturalDur)(double *);
    STDMETHOD(put_naturalDur)(double);
    
    //
    // These are read-only attributes
    //
    
    // This is the total time during which the element is active.
    // This does not include fill time which extends past the active
    // duration.
    STDMETHOD(get_activeDur)(double *);

    // This is the parent's time when the last tick occurred (when it
    // was currTime)
    STDMETHOD(get_currParentTime)(double * d);

    // This will return whether the node is active.  This will be
    // false if the node is in the fill period
    STDMETHOD(get_isActive)(VARIANT_BOOL * b);

    // This will return true if the node is active or in the fill period
    STDMETHOD(get_isOn)(VARIANT_BOOL * b);

    // This will return whether node itself has been paused explicitly
    STDMETHOD(get_isPaused)(VARIANT_BOOL * b);

    // This will return whether node itself has been paused explicitly
    STDMETHOD(get_isCurrPaused)(VARIANT_BOOL * b);

    // This will return whether node itself has been disabled explicitly
    STDMETHOD(get_isDisabled)(VARIANT_BOOL * b);

    // This will return whether node itself has been disabled explicitly
    STDMETHOD(get_isCurrDisabled)(VARIANT_BOOL * b);

    // This will return the detailed state flags
    STDMETHOD(get_stateFlags)(TE_STATE * lFlags);

    //
    // Methods
    //
    
    STDMETHOD(reset)();

    // This will update the attributes and propagate to the media
    // leaves.
    STDMETHOD(update)(DWORD dwFlags);


    STDMETHOD(addBehavior)(ITIMENodeBehavior * tnb);
    STDMETHOD(removeBehavior)(ITIMENodeBehavior * tnb);
    
    STDMETHOD(documentTimeToParentTime)(double dblDocumentTime,
                                      double * pdblParentTime);
    STDMETHOD(parentTimeToDocumentTime)(double dblParentTime,
                                      double * pdblDocumentTime);
    STDMETHOD(parentTimeToActiveTime)(double dblParentTime,
                                      double * pdblActiveTime);
    STDMETHOD(activeTimeToParentTime)(double dblActiveTime,
                                      double * pdblParentTime);
    STDMETHOD(activeTimeToSegmentTime)(double dblActiveTime,
                                      double * pdblSegmentTime);
    STDMETHOD(segmentTimeToActiveTime)(double dblSegmentTime,
                                      double * pdblActiveTime);
    STDMETHOD(simpleTimeToSegmentTime)(double dblSimpleTime,
                                      double * pdblSegmentTime);
    STDMETHOD(segmentTimeToSimpleTime)(double dblSegmentTime,
                                      double * pdblSimpleTime);

    //
    // CTIMENode virtual methods
    //

    HRESULT DispatchTick(bool bTickChildren,
                         DWORD dwFlags);

    HRESULT DispatchEvent(double time,
                          TE_EVENT_TYPE et,
                          long lRepeatCount);

    HRESULT DispatchPropChange(DWORD tePropTypes);

    HRESULT DispatchGetSyncTime(double & dblNewTime,
                                LONG & lNewRepeatCount,
                                bool & bCueing);
    
    //
    // CNodeContainer
    //
    
    double ContainerGetSegmentTime() const { return GetCurrSegmentTime(); }
    double ContainerGetSimpleTime() const { return CalcCurrSimpleTime(); }
    TEDirection ContainerGetDirection() const { return CalcSimpleDirection(); }
    float  ContainerGetRate() const { return GetCurrRate(); }
    bool   ContainerIsActive() const { return IsActive(); }
    bool   ContainerIsOn() const { return CalcIsOn(); }
    bool   ContainerIsPaused() const { return CalcIsPaused(); }
    bool   ContainerIsDisabled() const { return CalcIsDisabled(); }
    bool   ContainerIsDeferredActive() const { return IsDeferredActive(); }
    bool   ContainerIsFirstTick() const { return IsFirstTick(); }

    //
    // Accessors
    //

    LPCWSTR           GetID() const { return m_pszID; }
    double            GetDur() const { return m_dblDur; }
    double            GetRepeatCount() const { return m_dblRepeatCount; }
    double            GetRepeatDur() const { return m_dblRepeatDur; }
    TE_FILL_FLAGS     GetFill() const { return m_tefFill; }
    bool              GetAutoReverse() const { return m_bAutoReverse; }
    float             GetSpeed() const { return m_fltSpeed; }
    float             GetAccel() const { return m_fltAccel; }
    float             GetDecel() const { return m_fltDecel; }
    DWORD             GetFlags() const { return m_dwFlags; }
    TE_RESTART_FLAGS  GetRestart() const { return m_teRestart; }
    double            GetNaturalDur() const { return m_dblNaturalDur; }
    double            GetImplicitDur() const { return m_dblImplicitDur; }

    // This just returns whether we are currently set to be paused.
    // It does not take into account our parent's pause state.
    bool              GetIsPaused() const { return m_bIsPaused; }

    bool              GetIsDisabled() const { return m_bIsDisabled; }

    //
    // 
    //
    
    inline bool IsSyncMaster() const;
    inline bool IsLocked() const;
    inline bool IsCanSlip() const;
    inline bool IsEndSync() const;
    
    // Parent state
    CTIMEContainer * GetParent() const { return m_ptnParent; }
    void SetParent(CTIMEContainer * ptnParent);
    void ClearParent();

    // We must always set the parent before the node mgr
    // All attaching and sink work is only done when a node mgr exists
    CTIMENodeMgr * GetMgr() const { return m_ptnmNodeMgr; }
    virtual HRESULT SetMgr(CTIMENodeMgr * ptnm);
    virtual void ClearMgr();

    CNodeContainer & GetContainer() const;
    const CNodeContainer * GetContainerPtr() const;
    
    virtual void ResetNode(CEventList * l,
                           bool bPropagate = true,
                           bool bResetOneShot = true); //lint !e1735

    virtual void UpdateNode(CEventList * l);
    virtual void ResetChildren(CEventList * l, bool bPropagate);
    virtual void CalcImplicitDur(CEventList * l) {}

    void UpdateSinks(CEventList * l, DWORD dwFlags);
    void ResetSinks(CEventList * l);
    void ResetOneShots();

    HRESULT EnsureUpdate();
    
    // We are not considered ready until we know our node mgr.
    bool     IsReady() const { return m_ptnmNodeMgr != NULL; }
    bool     IsActive() const { return m_bIsActive; }
    bool     IsDeferredActive() const { return m_bDeferredActive; }
    bool     IsEndedByParent() const { return m_bEndedByParent; }
    bool     CalcIsOn() const;
    bool     CalcIsActive() const;

    // This returns whether we are truly paused or not - regardless of
    // why.  This is true if either we are paused or our parent
    bool     CalcIsPaused() const;
    bool     GetIsParentPaused() const { return m_bIsParentPaused; }

    bool     CalcIsDisabled() const;
    bool     GetIsParentDisabled() const { return m_bIsParentDisabled; }

    double   GetBeginParentTime() const { return m_dblBeginParentTime; }
    double   GetEndParentTime() const { return m_dblEndParentTime; }
    double   CalcActiveBeginPoint(TEDirection ted) const;
    double   CalcActiveEndPoint(TEDirection ted) const;
    double   CalcActiveBeginPoint() const;
    double   CalcActiveEndPoint() const;
    double   GetEndSyncParentTime() const { return m_dblEndSyncParentTime; }
    double   GetLastEndSyncParentTime() const { return m_dblLastEndSyncParentTime; }
    double   GetNextBoundaryParentTime() const { return m_dblNextBoundaryParentTime; }
    double   GetCurrParentTime() const { return m_dblCurrParentTime; }
    LONG     GetCurrRepeatCount() const { return m_lCurrRepeatCount; }
    double   GetCurrSegmentTime() const { return m_dblCurrSegmentTime; }
    double   GetElapsedActiveRepeatTime() const { return m_dblElapsedActiveRepeatTime; }
    double   CalcElapsedActiveTime() const;

    double   GetActiveDur() const { return m_dblActiveDur; }
    double   CalcLocalDur() const;
    double   GetSimpleDur() const { return m_dblSimpleDur; }
    double   GetSegmentDur() const { return m_dblSegmentDur; }
    double   CalcCurrSimpleDur() const;
    double   CalcCurrSegmentDur() const;
    double   CalcCurrLocalDur() const;
    double   CalcCurrActiveDur() const;
    double   CalcEffectiveActiveDur() const;
    double   CalcEffectiveLocalDur() const;
    double   CalcRepeatCount() const;
    
    bool        IsFirstTick() const { return m_bFirstTick; }
    TEDirection GetParentDirection() const { return m_tedParentDirection; }
    TEDirection GetDirection() const { return m_tedDirection; }
    TEDirection CalcActiveDirection() const;
    TEDirection CalcSimpleDirection() const;
    float       GetParentRate() const { return m_fltParentRate; }
    float       GetRate() const { return m_fltRate; }
    float       GetCurrRate() const;
    
    bool        IsInTick() const { return m_bInTick; }

    const CSyncArcList & GetBeginList() const { return m_saBeginList; }
    const CSyncArcList & GetEndList() const { return m_saEndList; }

    //
    // State management methods
    //

    // Invalidate should be called after each inline attribute is
    // changed to ensure that the runtime attributes are updated at
    // the appropriate time
    // The flags indicates which attributes have become dirty.
    virtual void Invalidate(DWORD dwFlags);

    // Dependency management
    inline HRESULT AddBeginTimeSink(ITimeSink * sink);
    inline void RemoveBeginTimeSink(ITimeSink * sink);

    inline HRESULT AddEndTimeSink(ITimeSink* sink);
    inline void RemoveEndTimeSink(ITimeSink* sink);
    
    void SyncArcUpdate(CEventList * l,
                       bool bBeginSink,
                       ISyncArc & tb);
    
    //
    // Ticking and event mgr
    //
    
    // This will call all the behaviors which are currently running
    // with the given event.  This is used when the timeline needs to
    // process a specific event like Pause/Resume/Stop/Play.
    
    void TickEvent(CEventList * l,
                   TE_EVENT_TYPE et,
                   DWORD dwFlags);
    
    void Tick(CEventList * l,
              double dblNewParentTime,
              bool bNeedBegin);

    // The time here is the local time
    void EventNotify(CEventList *l,
                     double lTime,
                     TE_EVENT_TYPE et,
                     long lRepeatCount = 0);
    
    void PropNotify(CEventList *l,
                    DWORD pt);
    
    // This will check to see if we are in our active period
    inline bool CheckActiveTime(double t, bool bRespectEndHold) const;

    //
    // Synchronization
    //
    
    double GetSyncSegmentTime() const { return m_dblSyncSegmentTime; }
    LONG   GetSyncRepeatCount() const { return m_lSyncRepeatCount; }
    double GetSyncActiveTime() const { return m_dblSyncActiveTime; }
    double GetSyncParentTime() const { return m_dblSyncParentTime; }
    double GetSyncNewParentTime() const { return m_dblSyncNewParentTime; }
    bool   IsSyncCueing() const { return m_bSyncCueing; }

#if OLD_TIME_ENGINE
    virtual HRESULT OnBvrCB(CEventList * l,
                            double gTime);
#endif
    HRESULT CheckSyncTimes(double & dblNewSegmentTime,
                           LONG & lNewRepeatCount) const;
    HRESULT SyncNode(CEventList * l,
                     double dblNextGlobalTime,
                     double dblNewTime,
                     LONG lNewRepeatCount,
                     bool bCueing);
    HRESULT SetSyncTimes(double dblNewSegmentTime,
                         LONG lNewRepeatCount,
                         double dblNewActiveTime,
                         double dblNewLocalTime,
                         double dblNextLocalTime,
                         bool bCueing);
    void ResetSyncTimes();

#if DBG
    virtual void Print(int spaces);
#endif

    // Timeline methods
    
    double CalcCurrLocalTime() const;
    double CalcCurrSimpleTime() const;
    double CalcElapsedLocalTime() const;

    // This will take the given time and transform it to the correct
    // eased time
    // If the time is outside of our duration (i.e. <0 or >
    // m_duration) this will just return the given time
    double ApplySimpleTimeTransform(double time) const;

    // This will take the given time and transform it to the time it
    // would have been w/o an ease
    double ReverseSimpleTimeTransform(double time) const;

    double ApplyActiveTimeTransform(double time) const;
    double ReverseActiveTimeTransform(double time) const;

    //
    // These functions all clamp input and output values to ensure
    // that nothing invalid is returned.  If you need functionality
    // which checks the bounds do so before calling the function
    // 

    double CalcParentTimeFromActiveTime(double time) const;
    double CalcActiveTimeFromParentTime(double time) const;
    double CalcActiveTimeFromParentTimeForSyncArc(double time) const;
    double CalcActiveTimeFromParentTimeNoBounds(double dblParentTime) const;

    double CalcParentTimeFromGlobalTime(double time) const;
    double CalcParentTimeFromGlobalTimeForSyncArc(double time) const;
    double CalcGlobalTimeFromParentTime(double time) const;

    double ActiveTimeToLocalTime(double time) const;
    double LocalTimeToActiveTime(double time) const;

    double CalcActiveTimeFromSegmentTime(double segmentTime) const;
    double CalcSegmentTimeFromActiveTime(double activeTime, bool bTruncate) const;

    double SegmentTimeToSimpleTime(double segmentTime) const;
    double SimpleTimeToSegmentTime(double simpleTime) const;

    bool IsAutoReversing(double dblSegmentTime) const;

    void SetPropChange(DWORD pt);
    void ClearPropChange();
    DWORD GetPropChange() const;
    
  protected:
    // All dependents are added only when we are ready.
    // If the timenode is changed after we are considered ready then
    // it needs to detach and reattach itself.
    HRESULT AttachToSyncArc();
    void DetachFromSyncArc();
    
    double GetMaxEnd() const;
    
    void UpdateBeginTime(CEventList * l, double dblTime, bool bPropagate);
    void UpdateEndTime(CEventList * l, double dblTime, bool bPropagate);
    void UpdateEndSyncTime(double dblTime);
    void UpdateLastEndSyncTime(CEventList * l, double dblTime, bool bPropagate);

    void UpdateNextBoundaryTime(double dblTime);

    // Given the parent time these will calculate the correct bounds
    // from the sync arc lists
    void CalcBeginBound(double dblBaseTime,
                        bool bStrict,
                        double & dblBeginBound);
    void CalcEndBound(double dblParentTime,
                      bool bIncludeOneShots,
                      double & dblEndBound,
                      double & dblEndSyncBound);
    
    double CalcNaturalBeginBound(double dblParentTime,
                                 bool bInclusive,
                                 bool bStrict);

    void CalcBeginTime(double dblBaseTime,
                       double & dblBeginTime);
    void CalcEndTime(double dblBaseTime,
                     bool bIncludeOneShots,
                     double dblParentTime,
                     double dblElapsedSegmentTime,
                     long lElapsedRepeatCount,
                     double dblElapsedActiveTime,
                     double & dblEndTime,
                     double & dblEndSyncTime);

    double CalcLastEndSyncTime();
    
    void CalcNextBeginTime(double dblBaseTime,
                           bool bForceInclusive,
                           double & dblBeginTime);

    void ResetBeginTime(CEventList * l,
                        double dblParentTime,
                        bool bPropagate);
    void ResetEndTime(CEventList * l,
                      double dblParentTime,
                      bool bPropagate);
    void ResetBeginAndEndTimes(CEventList * l,
                               double dblParentTime,
                               bool bPropagate);
    void RecalcEndTime(CEventList * l,
                       double dblBaseTime,
                       double dblParentTime,
                       bool bPropagate);

    // This will conditionally recalc the end time since we should not
    // always allow it unless there is a full reset
    void RecalcCurrEndTime(CEventList * l, bool bPropagate);

    void RecalcSegmentDurChange(CEventList * l,
                                bool bRecalcTiming,
                                bool bForce = false);
    void RecalcBeginSyncArcChange(CEventList * l,
                                  double dblNewTime);
    void RecalcEndSyncArcChange(CEventList * l,
                                double dblNewTime);

    HRESULT SeekTo(LONG lNewRepeatCount,
                   double dblNewSegmentTime,
                   CEventList * l);

    double CalcNewActiveTime(double dblNewSegmentTime,
                             LONG lNewRepeatCount);

    // This needs to be used when calculating the repeat count and
    // segment time since the last repeat boundary should not get
    // rounded up and normal calculations do a mod which is wrong
    // For example, dur=3,r=2.
    //              ActiveTime=6 should result in:
    //              cursegtime=3, currep = 1
    
    void CalcActiveComponents(double dblActiveTime,
                              double & dblSegmentTime,
                              long & lRepeatCount);
    
    // This will update the timing attributes (accel, decel, speed,
    // dur, etc.).

    void CalcTimingAttr(CEventList * l);
    void CalcSimpleTimingAttr();
    void CalculateEaseCoeff();

    HRESULT Error();

    void UpdateNextTickBounds(CEventList * l,
                              double dblBeginTime,
                              double dblParentTime);
    
    bool TickInactivePeriod(CEventList * l,
                            double dblNewParentTime);

    bool TickInstance(CEventList * l,
                      double dblNewParentTime,
                      bool bNeedBegin);
    bool TickSingleInstance(CEventList * l,
                            double dblLastParentTime,
                            double dblNewParentTime,
                            double dblAdjustedParentTime,
                            bool bNeedBegin);
    
    bool TickActive(CEventList * l,
                    double dblNewActiveTime,
                    bool bNeedBegin,
                    bool bNeedEnd);

    bool TickActiveForward(CEventList * l,
                           double dblNewActiveTime,
                           bool bNeedBegin);
    bool TickSegmentForward(CEventList * l,
                            double dblActiveSegmentBound,
                            double dblLastSegmentTime,
                            double dblNewSegmentTime,
                            bool bNeedBegin);

    bool TickActiveBackward(CEventList * l,
                            double dblNewActiveTime,
                            bool bNeedBegin);
    bool TickSegmentBackward(CEventList * l,
                             double dblActiveSegmentBound,
                             double dblLastSegmentTime,
                             double dblNewSegmentTime,
                             bool bNeedBegin);

    virtual void TickChildren(CEventList * l,
                              double dblNewSegmentTime,
                              bool bNeedPlay);

    virtual bool TickEventPre(CEventList * l,
                              TE_EVENT_TYPE et,
                              DWORD dwFlags);
    
    virtual void TickEventChildren(CEventList * l,
                                   TE_EVENT_TYPE et,
                                   DWORD dwFlags);
    
    virtual bool TickEventPost(CEventList * l,
                               TE_EVENT_TYPE et,
                               DWORD dwFlags);
    
    // This will appropriately update due to a seek
    void HandleSeekUpdate(CEventList * l);

    // This will update the node due to a parent time shift
    void HandleTimeShift(CEventList * l);
    
    // This will recalc the runtime state based on the parent's simple time
    // Lag is the extra amount of time which has elapsed.
    void CalcRuntimeState(CEventList * l,
                          double dblParentSimpleTime,
                          double dblLocalLag);
    void CalcCurrRuntimeState(CEventList * l,
                              double dblLocalLag);
    void ResetRuntimeState(CEventList * l,
                           double dblParentSimpleTime);

    // ================================
    // DATA declarations
    // ================================

  protected:
    LPWSTR               m_pszID;
    double               m_dblDur;
    double               m_dblRepeatCount;
    double               m_dblRepeatDur;
    TE_FILL_FLAGS        m_tefFill;
    bool                 m_bAutoReverse;
    float                m_fltSpeed;
    float                m_fltAccel;
    float                m_fltDecel;
    DWORD                m_dwFlags;
    TE_RESTART_FLAGS     m_teRestart;
    double               m_dblNaturalDur;
    double               m_dblImplicitDur;
    
    DWORD                m_dwUpdateCycleFlags;
    
    CTIMEContainer *  m_ptnParent;
    CTIMENodeMgr *    m_ptnmNodeMgr;
    
    DWORD             m_dwInvalidateFlags;
    
    // *** These are the runtime attr - begin
    // These are in parent time space (post accel/decel)
    double            m_dblBeginParentTime;
    double            m_dblEndParentTime;
    double            m_dblEndSyncParentTime;
    double            m_dblLastEndSyncParentTime;

    // When active this is set left at its previous value
    // When not active this is the value to look for to see when we
    // are transitioning into the active period.  When going backwards
    // it is the next end, when going forward it is the next begin
    // If there is no next boundary then this is set to TIME_INFINITE
    double            m_dblNextBoundaryParentTime;

    double            m_dblCurrParentTime;

    LONG              m_lCurrRepeatCount;
    double            m_dblCurrSegmentTime;
    double            m_dblElapsedActiveRepeatTime;
    bool              m_bFirstTick;
    bool              m_bIsActive;
    bool              m_bDeferredActive;
    TEDirection       m_tedDirection;
    TEDirection       m_tedParentDirection;
    float             m_fltRate;
    float             m_fltParentRate;

    double            m_dblSyncSegmentTime;
    LONG              m_lSyncRepeatCount;
    double            m_dblSyncActiveTime;
    double            m_dblSyncParentTime;
    double            m_dblSyncNewParentTime;
    bool              m_bSyncCueing;
    // *** These are the runtime attr - end

    double            m_dblActiveDur;
    double            m_dblSimpleDur;
    double            m_dblSegmentDur;
    
    //TODO: these could be allocated as needed.  They may be fairly rarely used.
    TimeSinkList      m_ptsBeginSinks;
    TimeSinkList      m_ptsEndSinks;

    CSyncArcList m_saBeginList;
    CSyncArcList m_saEndList;

    CNodeBvrList      m_nbList;
#if OLD_TIME_ENGINE
    // The ease-in/out behavior modifier is applied using timeline
    // substitution.  The substitute timeline consists of three pieces
    // A, B and C, which are the ease-in, constant velocity and ease-out
    // parts respectively.  For B, a linear timeline is substituted; for
    // A and C, a quadratic warping of the input time is required.

    float m_flA0, m_flA1, m_flA2; // coefficients for the A piece
    float m_flB0, m_flB1;         // coefficients for the B piece
    float m_flC0, m_flC1, m_flC2; // coefficients for the C piece

    // These are the times to perform ease in/out
    float m_fltAccelEnd;
    float m_fltDecelStart;
    bool m_bNeedEase;
#endif

    bool m_bIsPaused;
    bool m_bIsParentPaused;

    bool m_bIsDisabled;
    bool m_bIsParentDisabled;

    DWORD m_dwPropChanges;

    bool  m_bInTick;
    bool  m_bNeedSegmentRecalc;
    bool  m_bEndedByParent;
};


class CEventData;

class CEventList
{
  public:
    CEventList();
    ~CEventList();

    HRESULT FireEvents();
    void Clear();
    HRESULT Add(CTIMENode * node,
                double time,
                TE_EVENT_TYPE et,
                long lRepeatCount);
    HRESULT AddPropChange(CTIMENode * node);
#if DBG
    void Print();
#endif
  protected:
    typedef std::list<CEventData *> CEventDataList;
    typedef std::set<CTIMENode *> CPropNodeSet;

    CEventDataList m_eventList;
    CPropNodeSet m_propSet;
};

CTIMENode * GetBvr(IUnknown *);

#if DBG
char * CreatePropString(DWORD dwFlags, char * pstr, DWORD dwSize);
#endif

// ==========================================
// Inlined functions
// ==========================================

#if DBG
inline char *
EventString(TE_EVENT_TYPE et)
{
    switch(et) {
      case TE_EVENT_BEGIN:
        return "Begin";
      case TE_EVENT_END:
        return "End";
      case TE_EVENT_PAUSE:
        return "Pause";
      case TE_EVENT_RESUME:
        return "Resume";
      case TE_EVENT_REPEAT:
        return "Repeat";
      case TE_EVENT_AUTOREVERSE:
        return "Autoreverse";
      case TE_EVENT_RESET:
        return "Reset";
      case TE_EVENT_SEEK:
        return "Seek";
      case TE_EVENT_PARENT_TIMESHIFT:
        return "ParentTimeShift";
      case TE_EVENT_ENABLE:
        return "Enable";
      case TE_EVENT_DISABLE:
        return "Disable";
      default:
        return "Unknown";
    }
}

inline char *
PropString(TE_PROPERTY_TYPE pt)
{
    switch(pt) {
      case TE_PROPERTY_TIME:
        return "Time";
      case TE_PROPERTY_REPEATCOUNT:
        return "RepeatCount";
      case TE_PROPERTY_SEGMENTDUR:
        return "SegmentDur";
      case TE_PROPERTY_IMPLICITDUR:
        return "ImplicitDur";
      case TE_PROPERTY_SIMPLEDUR:
        return "SimpleDur";
      case TE_PROPERTY_ACTIVEDUR:
        return "ActiveDur";
      case TE_PROPERTY_PROGRESS:
        return "Progress";
      case TE_PROPERTY_SPEED:
        return "Speed";
      case TE_PROPERTY_BEGINPARENTTIME:
        return "BeginParentTime";
      case TE_PROPERTY_ENDPARENTTIME:
        return "EndParentTime";
      case TE_PROPERTY_ISACTIVE:
        return "IsActive";
      case TE_PROPERTY_ISON:
        return "IsOn";
      case TE_PROPERTY_ISPAUSED:
        return "IsPaused";
      case TE_PROPERTY_ISCURRPAUSED:
        return "IsCurrPaused";
      case TE_PROPERTY_ISDISABLED:
        return "IsDisabled";
      case TE_PROPERTY_ISCURRDISABLED:
        return "IsCurrDisabled";
      case TE_PROPERTY_STATEFLAGS:
        return "StateFlags";
      default:
        return "Unknown";
    }
}
#endif

inline bool
CTIMENode::CalcIsPaused() const
{
    return (GetIsPaused() || GetIsParentPaused());
}

inline bool
CTIMENode::CalcIsDisabled() const
{
    return (GetIsDisabled() || GetIsParentDisabled());
}

inline bool
CTIMENode::IsSyncMaster() const
{
    return ((m_dwFlags & TE_FLAGS_MASTER) != 0);
}

inline bool
CTIMENode::IsLocked() const
{
    return ((m_dwFlags & TE_FLAGS_LOCKED) != 0);
}

inline bool
CTIMENode::IsCanSlip() const
{
    return !IsLocked();
}

inline bool
CTIMENode::IsEndSync() const
{
    return ((m_dwFlags & TE_FLAGS_ENDSYNC) != 0);
}

inline void
CTIMENode::SetParent(CTIMEContainer * parent)
{
    Assert(m_ptnParent == NULL);

    m_ptnParent = parent;
}

inline void
CTIMENode::ClearParent()
{
    // We better not have a node mgr if we are clearing the parent
    Assert(m_ptnmNodeMgr == NULL);
    m_ptnParent = NULL;
}

inline HRESULT
CTIMENode::AddBeginTimeSink(ITimeSink * sink)
{
    return m_ptsBeginSinks.Add(sink);
}

inline void
CTIMENode::RemoveBeginTimeSink(ITimeSink * sink)
{
    m_ptsBeginSinks.Remove(sink);
}

inline HRESULT
CTIMENode::AddEndTimeSink(ITimeSink* sink)
{
    return m_ptsEndSinks.Add(sink);
}

inline void
CTIMENode::RemoveEndTimeSink(ITimeSink* sink)
{
    m_ptsEndSinks.Remove(sink);
}

// This is inclusive of the end time
inline bool
CTIMENode::CheckActiveTime(double t, bool bRespectEndHold) const
{
    return (t != TIME_INFINITE &&
            t >= GetBeginParentTime() &&
            (bRespectEndHold || t < GetEndParentTime()));
}

inline double
CTIMENode::CalcElapsedLocalTime() const
{
    return ReverseActiveTimeTransform(CalcElapsedActiveTime());
}

inline HRESULT
CTIMENode::DispatchEvent(double time, TE_EVENT_TYPE et, long lRepeatCount)
{
    return m_nbList.DispatchEventNotify(time, et, lRepeatCount);
}

inline HRESULT
CTIMENode::DispatchGetSyncTime(double & dblNewTime,
                               LONG & lNewRepeatCount,
                               bool & bCueing)
{
    return m_nbList.DispatchGetSyncTime(dblNewTime,
                                        lNewRepeatCount,
                                        bCueing);
}

inline HRESULT
CTIMENode::DispatchPropChange(DWORD tePropType)
{
    return m_nbList.DispatchPropNotify(tePropType);
}

inline double
CTIMENode::CalcCurrSegmentDur() const
{
    double d;
    
    if (GetDur() != TE_UNDEFINED_VALUE)
    {
        d = GetSegmentDur();
    }
    else
    {
        d = CalcCurrSimpleDur();
    }

    return d;
}

inline double
CTIMENode::CalcEffectiveLocalDur() const
{
    return GetEndParentTime() - GetBeginParentTime();
}

inline double
CTIMENode::CalcLocalDur() const
{
    return ReverseActiveTimeTransform(GetActiveDur());
}

inline double
CTIMENode::CalcCurrLocalDur() const
{
    return ReverseActiveTimeTransform(CalcCurrActiveDur());
}

// This is simply the multiplication of our rate and our parent's
// rate
inline float
CTIMENode::GetCurrRate() const
{
    return (GetParentRate() * GetRate());
}

inline double
CTIMENode::CalcCurrLocalTime() const
{
    return GetCurrParentTime() - GetBeginParentTime();
}

inline double
CTIMENode::CalcElapsedActiveTime() const
{
    return GetElapsedActiveRepeatTime() + GetCurrSegmentTime();
}

inline void
CTIMENode::SetPropChange(DWORD pt)
{
    m_dwPropChanges |= pt;
}

inline DWORD
CTIMENode::GetPropChange() const
{
    return m_dwPropChanges;
}

inline void
CTIMENode::ClearPropChange()
{
    m_dwPropChanges = 0;
}

inline void
CTIMENode::ResetOneShots()
{
    m_saBeginList.Reset();
    m_saEndList.Reset();
}

inline void
CTIMENode::ResetSinks(CEventList * l)
{
    UpdateSinks(l, 0);
}

inline void
CTIMENode::UpdateNextBoundaryTime(double dblTime)
{
    m_dblNextBoundaryParentTime = dblTime;
}

inline void
CTIMENode::ResetBeginAndEndTimes(CEventList * l,
                                 double dblParentTime,
                                 bool bPropagate)
{
    ResetBeginTime(l, dblParentTime, bPropagate);
    ResetEndTime(l, dblParentTime, bPropagate);
}

inline double
CTIMENode::CalcRepeatCount() const
{
    double d;
    
    if (GetRepeatCount() != TE_UNDEFINED_VALUE)
    {
        d = GetRepeatCount();
    }
    else if (GetRepeatDur() != TE_UNDEFINED_VALUE)
    {
        d = TIME_INFINITE;
    }
    else
    {
        d = 1.0;
    }

    return d;
}

inline bool
CTIMENode::CalcIsActive() const
{
    return IsActive() && !IsDeferredActive();
}

inline double
CTIMENode::CalcActiveBeginPoint(TEDirection ted) const
{
    if (ted == TED_Forward)
    {
        return GetBeginParentTime();
    }
    else
    {
        return GetEndParentTime();
    }
}

inline double
CTIMENode::CalcActiveEndPoint(TEDirection ted) const
{
    if (ted == TED_Forward)
    {
        return GetEndParentTime();
    }
    else
    {
        return GetBeginParentTime();
    }
}

inline double
CTIMENode::CalcActiveBeginPoint() const
{
    return CalcActiveBeginPoint(GetParentDirection());
}

inline double
CTIMENode::CalcActiveEndPoint() const
{
    return CalcActiveEndPoint(GetParentDirection());
}

inline double
CTIMENode::GetMaxEnd() const
{
    return m_saEndList.LowerBound(TIME_INFINITE,
                                  true,
                                  false,
                                  false,
                                  false);
}

#endif /* _TIMENODE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timeeng\nodebvr.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: nodebvr.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#include "headers.h"
#include "Node.h"

DeclareTag(tagTIMENodeBvr, "TIME: Engine", "Behavior methods");

typedef std::list<ITIMENodeBehavior *> TIMENodeBvrList;

CNodeBvrList::CNodeBvrList()
{
    TraceTag((tagTIMENodeBvr,
              "CNodeBvrList(%lx)::CNodeBvrList()",
              this));
}

CNodeBvrList::~CNodeBvrList()
{
    TraceTag((tagTIMENodeBvr,
              "CNodeBvrList(%lx)::~CNodeBvrList()",
              this));
}

HRESULT
CNodeBvrList::Add(ITIMENodeBehavior * tnb)
{
    TraceTag((tagTIMENodeBvr,
              "CNodeBvrList(%lx)::Add(%#x)",
              this,
              tnb));
    
    HRESULT hr;

    // TODO: Need to handle out of memory conditions
    m_tnbList.push_back(tnb);
    tnb->AddRef();
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
CNodeBvrList::Remove(ITIMENodeBehavior * tnb)
{
    TraceTag((tagTIMENodeBvr,
              "CNodeBvrList(%lx)::Remove(%#x)",
              this,
              tnb));
    
    HRESULT hr;
    TIMENodeBvrList ::iterator i;

    for (i = m_tnbList.begin(); i != m_tnbList.end(); i++)
    {
        if ((*i) == tnb)
        {
            m_tnbList.erase(i);
            tnb->Release();
            break;
        }
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

class Dispatcher
{
  public:
    virtual HRESULT DoIt(ITIMENodeBehavior *) = 0;
};

HRESULT
Dispatch(const TIMENodeBvrList & l,
         HRESULT initialHR,
         Dispatcher & d)
{
    HRESULT hr = initialHR;

    TIMENodeBvrList ::iterator i;

    // Since the user might do something during the callback which can
    // affect this list we copy the list, addref each node bvrs and
    // then and only then call out into the behavior.  This ensures
    // that we have a strong reference and a private data structure
    // which cannot be hurt by reentrancy
    
    // @@ ISSUE : We can run out of memory
    TIMENodeBvrList bvrListCopy(l);

    // Now addref the node bvrs
    for (i = bvrListCopy.begin(); i != bvrListCopy.end(); i++)
    {
        (*i)->AddRef();
    }

    // TODO: We should actually addref our container so that it cannot
    // go away during the callback
    // We do not have the object stored so postpone for now
    
    // Now dispatch and release
    for (i = bvrListCopy.begin(); i != bvrListCopy.end(); i++)
    {
        HRESULT tmphr;

        tmphr = THR(d.DoIt(*i));
        (*i)->Release();
        
        if (S_OK != tmphr)
        {
            hr = tmphr;
        }
    }

  done:
    RRETURN1(hr, initialHR);
}

class TickDispatcher
    : public Dispatcher
{
  public:
    TickDispatcher() {}

    virtual HRESULT DoIt(ITIMENodeBehavior * ptnb)
    {
        return THR(ptnb->tick());
    }
};

HRESULT
CNodeBvrList::DispatchTick()
{
    TraceTag((tagTIMENodeBvr,
              "CNodeBvrList(%lx)::DispatchTick()",
              this));
    
    HRESULT hr;

    TickDispatcher td;

    hr = THR(Dispatch(m_tnbList, S_OK, td));

    RRETURN(hr);
}

class EventDispatcher
    : public Dispatcher
{
  public:
    EventDispatcher(double eventTime,
                    TE_EVENT_TYPE eventType,
                    long repeatCount) :
    m_eventTime(eventTime),
    m_eventType(eventType),
    m_lRepeatCount(repeatCount)
    {}

    virtual HRESULT DoIt(ITIMENodeBehavior * ptnb)
    {
        return THR(ptnb->eventNotify(m_eventTime, m_eventType, m_lRepeatCount));
    }

    double m_eventTime;
    TE_EVENT_TYPE m_eventType;
    long m_lRepeatCount;
  protected:
    EventDispatcher();
};

HRESULT
CNodeBvrList::DispatchEventNotify(double eventTime,
                                  TE_EVENT_TYPE eventType,
                                  long lRepeatCount)
{
    TraceTag((tagTIMENodeBvr,
              "CNodeBvrList(%lx)::DispatchEventNotify(%g, %s)",
              this,
              eventTime,
              EventString(eventType)));
    
    HRESULT hr;

    EventDispatcher ed(eventTime, eventType, lRepeatCount);

    hr = THR(Dispatch(m_tnbList, S_OK, ed));
    
    RRETURN(hr);
}

HRESULT
CNodeBvrList::DispatchGetSyncTime(double & dblNewTime,
                                  LONG & lNewRepeatCount,
                                  bool & bCueing)
{
    TraceTag((tagTIMENodeBvr,
              "CNodeBvrList(%lx)::DispatchGetSyncTime()",
              this));
    
    HRESULT hr;
    TIMENodeBvrList ::iterator i;

    hr = S_FALSE;

    for (i = m_tnbList.begin(); i != m_tnbList.end(); i++)
    {
        VARIANT_BOOL vb;
        HRESULT tmphr;

        tmphr = THR((*i)->getSyncTime(&dblNewTime,
                                      &lNewRepeatCount,
                                      &vb));
        if (tmphr == S_OK)
        {
            hr = S_OK;
            bCueing = (vb == VARIANT_FALSE)?false:true;
            break;
        }
    }
    
    RRETURN1(hr, S_FALSE);
}

class PropDispatcher
    : public Dispatcher
{
  public:
    PropDispatcher(DWORD tePropType)
    : m_tePropType(tePropType)
    {}

    virtual HRESULT DoIt(ITIMENodeBehavior * ptnb)
    {
        return THR(ptnb->propNotify(m_tePropType));
    }

    DWORD m_tePropType;
  protected:
    PropDispatcher();
};

HRESULT
CNodeBvrList::DispatchPropNotify(DWORD tePropType)
{
    TraceTag((tagTIMENodeBvr,
              "CNodeBvrList(%lx)::DispatchPropNotify(%d)",
              this,
              tePropType));
    
    HRESULT hr;

    PropDispatcher pd(tePropType);

    hr = THR(Dispatch(m_tnbList, S_OK, pd));

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timeeng\nodemgr.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "NodeMgr.h"
#include "Node.h"

DeclareTag(tagMMPlayer, "TIME: Engine", "CTIMENodeMgr methods")
DeclareTag(tagMMDetailNotify, "TIME: Engine", "Detailed notify")
DeclareTag(tagPrintTimeTree, "TIME: Engine", "Print TIME Tree")

CTIMENodeMgr::CTIMENodeMgr()
: m_id(NULL),
  m_bIsActive(false),
  m_bIsPaused(false),
  m_bForward(true),
  m_bNeedsUpdate(true),
  m_firstTick(true),
  m_mmbvr(NULL),
  m_curGlobalTime(0.0),
  m_lastTickTime(0.0),
  m_globalStartTime(0.0)
{
}

CTIMENodeMgr::~CTIMENodeMgr()
{
    Deinit();
} //lint !e1740

HRESULT
CTIMENodeMgr::Init(LPOLESTR id,
                   ITIMENode * bvr,
                   IServiceProvider * sp)
{
    TraceTag((tagMMPlayer,
              "CTIMENodeMgr(%lx)::Init(%ls, %#lx, %#lx)",
              this,
              id,
              bvr,
              sp));
    
    HRESULT hr;
    
    Deinit();
    
    if (!bvr || !sp)
    {
        TraceTag((tagError,
                  "CTIMENodeMgr(%lx)::Init: Invalid behavior passed in.",
                  this));
                  
        hr = E_INVALIDARG;
        goto done;
    }

    if (id)
    {
        m_id = CopyString(id);
        
        if (m_id == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    
    m_sp = sp;
    
    CTIMENode * cbvr;

    cbvr = GetBvr(bvr);
    
    if (!cbvr)
    {
        TraceTag((tagError,
                  "CTIMENodeMgr(%lx)::Init: Invalid behavior passed in.",
                  this));
                  
        hr = E_INVALIDARG;
        goto done;
    }

    m_mmbvr = cbvr;
    
    m_mmbvr->SetParent(NULL);

    hr = m_mmbvr->SetMgr(this);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:

    if (FAILED(hr))
    {
        // Clean up now
        Deinit();
    }
    
    RRETURN(hr);
}

void
CTIMENodeMgr::Deinit()
{
    TraceTag((tagMMPlayer,
              "CTIMENodeMgr(%lx)::Deinit()",
              this));

    // Ensure the player will not try to call us since we are going away

    if (m_mmbvr)
    {
        m_mmbvr->ClearMgr();
        m_mmbvr.Release();
    }

    m_sp.Release();
    
    delete m_id;
    m_id = NULL;

#if OLD_TIME_ENGINE
    BvrCBList::iterator j;
    for (j = m_bvrCBList.begin(); j != m_bvrCBList.end(); j++)
    {
        (*j)->Release();
    }
#endif
}

STDMETHODIMP
CTIMENodeMgr::get_id(LPOLESTR * p)
{
    TraceTag((tagMMPlayer,
              "CTIMENodeMgr(%lx)::get_id()",
              this));

    HRESULT hr;
    
    CHECK_RETURN_SET_NULL(p);

    if (m_id)
    {
        *p = SysAllocString(m_id);

        if (*p == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMENodeMgr::put_id(LPOLESTR s)
{
    TraceTag((tagMMPlayer,
              "CTIMENodeMgr(%lx)::put_id(%ls)",
              this,
              s));

    HRESULT hr;

    delete m_id;
    m_id = NULL;

    if (s)
    {
        s = CopyString(s);

        if (s == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}
        
STDMETHODIMP
CTIMENodeMgr::get_node(ITIMENode ** pptn)
{
    CHECK_RETURN_SET_NULL(pptn);

    return m_mmbvr->QueryInterface(IID_ITIMENode,
                                   (void **) pptn);
}

STDMETHODIMP
CTIMENodeMgr::get_stateFlags(TE_STATE * lFlags)
{
    TraceTag((tagMMPlayer,
              "CTIMENodeMgr(%lx)::get_stateFlags()",
              this));

    CHECK_RETURN_NULL(lFlags);

    if (!IsActive())
    {
        *lFlags = TE_STATE_INACTIVE;
    }
    else if (IsPaused())
    {
        *lFlags = TE_STATE_PAUSED;
    }
    else
    {
        *lFlags = TE_STATE_ACTIVE;
    }
    
    return S_OK;
}

STDMETHODIMP
CTIMENodeMgr::get_currTime(double * d)
{
    CHECK_RETURN_NULL(d);

    *d = m_curGlobalTime;

    return S_OK;
}

STDMETHODIMP
CTIMENodeMgr::seek(double lTime)
{
    TraceTag((tagMMPlayer,
              "CTIMENodeMgr(%lx)::seek(%g)",
              this,
              lTime));

    HRESULT hr;

    // Need to update m_curGlobalTime and m_globalStartTime

    // The global time needs to be reset so that the current tick time
    // will put the global time at lTime.
    //

    // The current global time nees to be lTime
    m_curGlobalTime = lTime;

    // Since: m_lastTickTime == m_curGlobalTime - m_globalStartTime
    // then m_globalStartTime = m_curGlobalTime - m_lastTickTime
    m_globalStartTime = m_curGlobalTime - m_lastTickTime;

    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMENodeMgr::begin()
{
    TraceTag((tagMMPlayer,
              "CTIMENodeMgr(%lx)::begin()",
              this));

    HRESULT hr;
    CEventList l;

    if (IsActive())
    {
        hr = E_FAIL;
        goto done;
    }
        
    hr = THR(BeginMgr(l, m_curGlobalTime));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(l.FireEvents());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMENodeMgr::end()
{
    TraceTag((tagMMPlayer,
              "CTIMENodeMgr(%lx)::end()",
              this));

    HRESULT hr;
    CEventList l;

    if (!IsActive())
    {
        hr = S_OK;
        goto done;
    }
    
    hr = THR(EndMgr(m_curGlobalTime));
    if (FAILED(hr))
    {
        goto done;
    }

    TickEvent(l, TE_EVENT_END, 0);

    hr = THR(l.FireEvents());
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMENodeMgr::pause()
{
    TraceTag((tagMMPlayer,
              "CTIMENodeMgr(%lx)::lPause()",
              this));

    HRESULT hr;
    CEventList l;

    if (IsPaused())
    {
        hr = S_OK;
        goto done;
    }
    
    if (!IsActive())
    {
        hr = THR(begin());
        if (FAILED(hr))
        {
            goto done;
        }
    }
    
    Assert(IsActive());
        
    hr = THR(PauseMgr());
    if (FAILED(hr))
    {
        goto done;
    }

    TickEvent(l, TE_EVENT_PAUSE, 0);

    hr = THR(l.FireEvents());
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMENodeMgr::resume()
{
    TraceTag((tagMMPlayer,
              "CTIMENodeMgr(%lx)::resume()",
              this));

    HRESULT hr;
    CEventList l;

    if (!IsActive())
    {
        hr = THR(begin());
        if (FAILED(hr))
        {
            goto done;
        }
    }
    else if (IsPaused())
    {
        hr = THR(ResumeMgr());
        if (FAILED(hr))
        {
            goto done;
        }
        
        TickEvent(l, TE_EVENT_RESUME, 0);
        
        hr = THR(l.FireEvents());
        if (FAILED(hr))
        {
            goto done;
        }
    }
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
CTIMENodeMgr::BeginMgr(CEventList & l,
                       double lTime)
{
    HRESULT hr;
    
    m_bIsActive = true;
    m_bIsPaused = false;

    // We know ticks must start at 0
    m_lastTickTime = 0.0;

    // The global time at tick time 0.0 is lTime
    m_globalStartTime = lTime;

    // The current global time is lTime since it is tick time 0.0
    m_curGlobalTime = lTime;

    m_firstTick = true;

    m_mmbvr->ResetNode(&l);
                                
#if DBG
    if (IsTagEnabled(tagPrintTimeTree))
    {
        m_mmbvr->Print(0);
    }
#endif
    
    hr = S_OK;
  done:
    if (FAILED(hr))
    {
        IGNORE_HR(EndMgr(lTime));
    }
    
    RRETURN(hr);
}

HRESULT
CTIMENodeMgr::EndMgr(double lTime)
{
    HRESULT hr;
    
    m_bIsActive = false;
    m_bIsPaused = false;
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
CTIMENodeMgr::PauseMgr()
{
    HRESULT hr;
    
    Assert(IsActive());
    
    m_bIsPaused = true;
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

HRESULT
CTIMENodeMgr::ResumeMgr()
{
    HRESULT hr;
    
    Assert(IsActive());
    Assert(IsPaused());

    m_bIsPaused = false;
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

STDMETHODIMP
CTIMENodeMgr::tick(double tickTime)
{
    TraceTag((tagMMPlayer,
              "CTIMENodeMgr(%lx)::tick(%g)",
              this,
              tickTime));

    HRESULT hr;
    double gTime;
    CEventList l;

    // Make sure the tick times do not go backwards
    if (tickTime < m_lastTickTime)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    // Convert the new tick time to global time
    gTime = TickTimeToGlobalTime(tickTime);
    
#if OLD_TIME_ENGINE
    {
        BvrCBList::iterator i;

        // @@ ISSUE : We can run out of memory
        BvrCBList bvrCBListCopy(m_bvrCBList);

        // Now addref the node bvrCBs
        for (i = bvrCBListCopy.begin();
             i != bvrCBListCopy.end();
             i++)
        {
            (*i)->AddRef();
        }
        
        // process any callbacks that have been registered
        for (i = bvrCBListCopy.begin();
             i != bvrCBListCopy.end();
             i++)
        {
            (*i)->OnBvrCB(&l, gTime);
            (*i)->Release();
        }
    }
#endif

    // Be aware that the previous calls seems to cause us to get
    // reentered above and can shut us down.  We need to make sure
    // that between there and here we make no assumptions about
    // state.  Currently we do not so it will work fine.
    
    if (gTime != m_curGlobalTime || m_firstTick)
    {
        Tick(l, gTime);

        // Update the variables so any callbacks get the correct info
        m_curGlobalTime = gTime;
        m_lastTickTime = tickTime;
        m_firstTick = false;
    }
    
    hr = THR(l.FireEvents());
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

void
CTIMENodeMgr::Tick(CEventList & l,
                   double lTime)
{
    TraceTag((tagMMPlayer,
              "CTIMENodeMgr(%lx)::Tick(%lx, %g)",
              this,
              &l,
              lTime));

    TraceTag((tagMMDetailNotify,
              "Tick(%lx): lTime - %g, m_curGlobalTime - %g, firsttick - %d",
              this,
              lTime,
              m_curGlobalTime,
              m_firstTick));
    
    m_mmbvr->Tick(&l,
                  lTime,
                  false);
}

void
CTIMENodeMgr::TickEvent(CEventList &l,
                        TE_EVENT_TYPE event,
                        DWORD dwFlags)
{
    m_mmbvr->TickEvent(&l, event, 0);

    m_firstTick = false;
}

#if OLD_TIME_ENGINE
HRESULT
CTIMENodeMgr::AddBvrCB(CTIMENode *pbvr)
{
    Assert(pbvr != NULL);

    // Now add it last so we do not need to remove it if we fail
    // We need to addref for the list storage
    pbvr->AddRef();
    m_bvrCBList.push_back(pbvr);
    return S_OK;
} // AddBvrCB

HRESULT
CTIMENodeMgr::RemoveBvrCB(CTIMENode *pbvr)
{
    Assert(pbvr != NULL);
    
    BvrCBList::iterator i;
    for (i = m_bvrCBList.begin(); i != m_bvrCBList.end(); i++)
    {
        if ((*i) == pbvr)
        {
            m_bvrCBList.erase(i);
            pbvr->Release();
            break;
        }
    }
    return S_OK;
} // RemoveBvrCB
#endif

HRESULT
CTIMENodeMgr::Error()
{
    LPWSTR str = TIMEGetLastErrorString();
    HRESULT hr = TIMEGetLastError();
    
    if (str)
    {
        hr = CComCoClass<CTIMENodeMgr, &__uuidof(CTIMENodeMgr)>::Error(str, IID_ITIMENodeMgr, hr);
        delete [] str;
    }
    
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timeeng\notify.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmnotify.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#include "headers.h"
#include "Node.h"
#include "Container.h"

DeclareTag(tagMMNotify, "TIME: Engine", "Notifications")
DeclareTag(tagMMNotifyRepeat, "TIME: Engine", "Notifications - Repeats")
DeclareTag(tagMMNotifyTimeShift, "TIME: Engine", "Notifications - Time Shifts")
DeclareTag(tagMMNotifyReset, "TIME: Engine", "Notifications - Resets")
DeclareTag(tagMMPropNotify, "TIME: Engine", "Property Notifications")

#define MAX_EVENTS_PER_TICK 30000  //this is the maximum allowable events per tick

// IMPORTANT!!!!!
// This needs to be called in the right order so that we get the
// correct children firing during the current interval but they get
// reset for the next interval. Otherwise we will not get the correct
// results.

void
CTIMENode::EventNotify(CEventList * l,
                       double evTime,
                       TE_EVENT_TYPE et,
                       long lRepeatCount)
{
#if DBG
    TRACETAG tag;

    switch(et)
    {
      case TE_EVENT_REPEAT:
        tag = tagMMNotifyRepeat;
        break;
      case TE_EVENT_PARENT_TIMESHIFT:
        tag = tagMMNotifyTimeShift;
        break;
      case TE_EVENT_RESET:
        tag = tagMMNotifyReset;
        break;
      default:
        tag = tagMMNotify;
        break;
    }
    
    TraceTag((tag,
              "CTIMENode(%p,%ls)::EventNotify(%p): evTime = %g, evParentTime = %g, event = %s, rc = %d",
              this,
              GetID(),
              l,
              evTime,
              evTime + GetBeginParentTime(),
              EventString(et),
              lRepeatCount));
#endif

    switch (et)
    {
      case TE_EVENT_BEGIN:
        m_bIsActive = true;
        m_bFirstTick = false;
        m_bDeferredActive = false;

        // Reset the flag when we become active
        m_bEndedByParent = false;

        // Clear all the events from the timeline
        ResetOneShots();

        PropNotify(l,
                   (TE_PROPERTY_ISACTIVE | TE_PROPERTY_ISON));
        break;
      case TE_EVENT_END:
        m_bIsActive = false;
        m_bFirstTick = false;
        PropNotify(l,
                   (TE_PROPERTY_ISACTIVE | TE_PROPERTY_ISON));
        break;
      case TE_EVENT_REPEAT:
        if (GetAutoReverse())
        {
            PropNotify(l,
                       TE_PROPERTY_SPEED);
        }
        break;
      case TE_EVENT_AUTOREVERSE:
        PropNotify(l,
                   TE_PROPERTY_SPEED);
        break;
      default:
        break;
    }

    if (l)
    {
        IGNORE_HR(l->Add(this, evTime, et, lRepeatCount));
    }

  done:
    return;
}

void
CTIMENode::PropNotify(CEventList *l,
                      DWORD pt)
{
    char buf[1024];
    
    TraceTag((tagMMPropNotify,
              "CTIMENode(%p, %ls)::PropNotify(%p): prop = %s",
              this,
              GetID(),
              l,
              CreatePropString(pt,
                               buf,
                               ARRAY_SIZE(buf))));

    HRESULT hr;
    
    if (l)
    {
        SetPropChange(pt);

        hr = THR(l->AddPropChange(this));
        if (FAILED(hr))
        {
            goto done;
        }
    }

  done:
    return;
} //lint !e529

    
class CEventData
{
  public:
    CEventData(CTIMENode * node,
               double time,
               TE_EVENT_TYPE et,
               long lRepeatCount);
    ~CEventData();

    HRESULT CallEvent();

    CTIMENode* GetNode() { return m_node; }
    TE_EVENT_TYPE GetEventType() { return m_et; }
  protected:
    DAComPtr<CTIMENode> m_node;
    double m_time;
    TE_EVENT_TYPE m_et;
    long m_lRepeatCount;

    CEventData();
};

CEventData::CEventData(CTIMENode * node,
                       double time,
                       TE_EVENT_TYPE et,
                       long lRepeatCount)
: m_node(node),
  m_time(time),
  m_et(et),
  m_lRepeatCount(lRepeatCount)
{
}

CEventData::~CEventData()
{
}

HRESULT
CEventData::CallEvent()
{
    RRETURN(THR(m_node->DispatchEvent(m_time, m_et, m_lRepeatCount)));
}

DeclareTag(tagCEventList, "TIME: Engine", "Event List")

//
// CEventList methods
//
CEventList::CEventList()
{
}

CEventList::~CEventList()
{
    Clear();
}

HRESULT
CEventList::FireEvents()
{
    TraceTag((tagCEventList,
              "CEventList(%p)::FireEvents()",
              this));

    HRESULT hr;
    
    hr = S_OK;

    {
        for (CEventDataList::iterator i = m_eventList.begin();
             i != m_eventList.end();
             i++)
        {
            HRESULT tmphr = THR((*i)->CallEvent());
            if (FAILED(tmphr))
            {
                hr = tmphr;
            }

            delete (*i);
        }

        m_eventList.clear();
    }
    
    {
        for (CPropNodeSet::iterator i = m_propSet.begin();
             i != m_propSet.end();
             i++)
        {
            CTIMENode * pn = *i;
            
            HRESULT tmphr = THR(pn->DispatchPropChange(pn->GetPropChange()));
            if (FAILED(tmphr))
            {
                hr = tmphr;
            }

            pn->ClearPropChange();
            
            pn->Release();
        }

        m_propSet.clear();
    }
    
    RRETURN(hr);
}

void
CEventList::Clear()
{
    TraceTag((tagCEventList,
              "CEventList(%p)::Clear()",
              this));

    {
        for (CEventDataList::iterator i = m_eventList.begin();
             i != m_eventList.end();
             i++)
        {
            delete (*i);
        }

        m_eventList.clear();
    }

    {
        for (CPropNodeSet::iterator i = m_propSet.begin();
             i != m_propSet.end();
             i++)
        {
            // Do not clear the prop change since we are not sure we
            // fired the event
            (*i)->Release();
        }

        m_propSet.clear();
    }
}

HRESULT
CEventList::Add(CTIMENode * node,
                double time,
                TE_EVENT_TYPE et,
                long lRepeatCount)
{
    HRESULT hr;
    
    CEventData * data = NEW CEventData(node,
                                       time,
                                       et,
                                       lRepeatCount);
    
    if (NULL == data)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    // @@ ISSUE : This does not detect memory failures
    if (m_eventList.size() < MAX_EVENTS_PER_TICK)
    {
        m_eventList.push_back(data);
    }
    else
    {
        // a-naande windows bug 693111 8-26-02
        // have to delete data if we don't add it to the list
        // since previously this method returned S_OK in this case,
        // leave that behavior unchanged
        delete data;
    }
    
    hr = S_OK;
  done:
    RRETURN(hr); //lint !e429
}

HRESULT
CEventList::AddPropChange(CTIMENode * node)
{
    HRESULT hr;
    
    // @@ ISSUE : This does not detect memory failures
    if (m_propSet.insert(node).second)
    {
        node->AddRef();
    }
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

#if DBG
void
CEventList::Print()
{
    TraceTag((tagMMNotify,
              "Starting PrintCEventList"));

    {
        for (CEventDataList::iterator i = m_eventList.begin();
             i != m_eventList.end();
             i++)
        {
            TraceTag((tagMMNotify,
                      "CTIMENode(%p)     Event=%d",
                      (*i)->GetNode(),
                      (*i)->GetEventType() ));
        }
    }

    {
        for (CPropNodeSet::iterator i = m_propSet.begin();
             i != m_propSet.end();
             i++)
        {
            CTIMENode * pn = *i;
            char buf[1024];
            
            TraceTag((tagMMNotify,
                      "CTIMENode(%p)     Prop=%s",
                      pn,
                      CreatePropString(pn->GetPropChange(),
                                       buf,
                                       ARRAY_SIZE(buf))));
        }
    }
}

#endif
    
#if DBG
void PrintCEventList(CEventList &l)
{
    l.Print();
}

void
AppendPropString(DWORD dwFlags,
                 TE_PROPERTY_TYPE pt,
                 char *pstr,
                 DWORD dwSize,
                 bool & bFirst)
{
    if ((dwFlags & pt) != 0)
    {
        if (!bFirst)
        {
            StrCatBuffA(pstr, ";", dwSize);
        }

        bFirst = false;
        
        StrCatBuffA(pstr, PropString(pt), dwSize);
    }
}

char *
CreatePropString(DWORD dwFlags, char * pstr, DWORD dwSize)
{
    bool bFirst = true;
    
    if (dwSize >= 1)
    {
        pstr[0] = 0;
    }
    
    AppendPropString(dwFlags, TE_PROPERTY_TIME, pstr, dwSize, bFirst);
    AppendPropString(dwFlags, TE_PROPERTY_REPEATCOUNT, pstr, dwSize, bFirst);
    AppendPropString(dwFlags, TE_PROPERTY_SEGMENTDUR, pstr, dwSize, bFirst);
    AppendPropString(dwFlags, TE_PROPERTY_IMPLICITDUR, pstr, dwSize, bFirst);
    AppendPropString(dwFlags, TE_PROPERTY_SIMPLEDUR, pstr, dwSize, bFirst);
    AppendPropString(dwFlags, TE_PROPERTY_ACTIVEDUR, pstr, dwSize, bFirst);
    AppendPropString(dwFlags, TE_PROPERTY_PROGRESS, pstr, dwSize, bFirst);
    AppendPropString(dwFlags, TE_PROPERTY_SPEED, pstr, dwSize, bFirst);
    AppendPropString(dwFlags, TE_PROPERTY_BEGINPARENTTIME, pstr, dwSize, bFirst);
    AppendPropString(dwFlags, TE_PROPERTY_ENDPARENTTIME, pstr, dwSize, bFirst);
    AppendPropString(dwFlags, TE_PROPERTY_ISACTIVE, pstr, dwSize, bFirst);
    AppendPropString(dwFlags, TE_PROPERTY_ISON, pstr, dwSize, bFirst);
    AppendPropString(dwFlags, TE_PROPERTY_ISPAUSED, pstr, dwSize, bFirst);
    AppendPropString(dwFlags, TE_PROPERTY_ISCURRPAUSED, pstr, dwSize, bFirst);
    AppendPropString(dwFlags, TE_PROPERTY_STATEFLAGS, pstr, dwSize, bFirst);
    AppendPropString(dwFlags, TE_PROPERTY_ISDISABLED, pstr, dwSize, bFirst);
    AppendPropString(dwFlags, TE_PROPERTY_ISCURRDISABLED, pstr, dwSize, bFirst);

    return pstr;
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timeeng\nodecontainer.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: nodecontainer.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _NODECONTAINER_H
#define _NODECONTAINER_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class ATL_NO_VTABLE
CNodeContainer
{
  public:
    virtual double ContainerGetSegmentTime() const = 0;
    virtual double ContainerGetSimpleTime() const = 0;
    virtual TEDirection ContainerGetDirection() const = 0;
    virtual float  ContainerGetRate() const = 0;
    virtual bool   ContainerIsActive() const = 0;
    virtual bool   ContainerIsOn() const = 0;
    virtual bool   ContainerIsPaused() const = 0;
    virtual bool   ContainerIsDeferredActive() const = 0;
    virtual bool   ContainerIsFirstTick() const = 0;
    virtual bool   ContainerIsDisabled() const = 0;
};

#endif /* _NODECONTAINER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timeeng\nodemgr.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: TIMENodeMgr.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#ifndef _MMPLAYER_H
#define _MMPLAYER_H

#include "Node.h"
#include <mshtml.h>
#include <vector>
#include "nodecontainer.h"

extern TRACETAG tagPrintTimeTree;

interface ITIMENode;

typedef std::list< CTIMENode * > BvrCBList;

class
__declspec(uuid("48ddc6be-5c06-11d2-b957-3078302c2030")) 
ATL_NO_VTABLE CTIMENodeMgr
    : public CComObjectRootEx<CComSingleThreadModel>,
      public CComCoClass<CTIMENodeMgr, &__uuidof(CTIMENodeMgr)>,
      public ITIMENodeMgr,
      public ISupportErrorInfoImpl<&IID_ITIMENodeMgr>,
      public CNodeContainer
{
  public:
    CTIMENodeMgr();
    virtual ~CTIMENodeMgr();

    HRESULT Init(LPOLESTR id,
                 ITIMENode * bvr,
                 IServiceProvider * sp);

    void Deinit();
    
#if DBG
    const _TCHAR * GetName() { return __T("CTIMENodeMgr"); }
#endif

    BEGIN_COM_MAP(CTIMENodeMgr)
        COM_INTERFACE_ENTRY(ITIMENodeMgr)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
    END_COM_MAP();

#ifndef END_COM_MAP_ADDREF
    // IUnknown
    
    STDMETHOD_(ULONG,AddRef)(void) = 0;
    STDMETHOD_(ULONG,Release)(void) = 0;
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) = 0;
#endif
    
    //
    // ITIMEMMPlayer
    //
    
    STDMETHOD(get_id)(LPOLESTR * s);
    STDMETHOD(put_id)(LPOLESTR s);
        
    STDMETHOD(begin)();
    STDMETHOD(end)();
    STDMETHOD(pause)();
    STDMETHOD(resume)();
    STDMETHOD(seek)(double dblTime);
    
    STDMETHOD(get_stateFlags)(TE_STATE *);
        
    STDMETHOD(get_currTime)(double * dblTime);

    STDMETHOD(get_node)(ITIMENode ** pptn);

    STDMETHOD(tick)(double dblTime);
    
    //
    // CNodeContainer
    //
    
    double ContainerGetSegmentTime() const { return GetCurrTime(); }
    double ContainerGetSimpleTime() const { return GetCurrTime(); }
    TEDirection ContainerGetDirection() const { return GetDirection(); }
    float  ContainerGetRate() const { return GetRate(); }
    bool   ContainerIsActive() const { return IsActive(); }
    bool   ContainerIsOn() const { return true; }
    bool   ContainerIsPaused() const { return IsPaused(); }
    bool   ContainerIsDisabled() const { return false; }
    bool   ContainerIsDeferredActive() const { return false; }
    bool   ContainerIsFirstTick() const { return IsFirstTick(); }

    //
    // Accessors
    //

    bool IsActive() const { return m_bIsActive; }
    bool IsPaused() const { return m_bIsPaused; }

    void Invalidate() { m_bNeedsUpdate = true; }

    bool IsFirstTick() const { return m_firstTick; }
    double GetCurrTime() const { return m_curGlobalTime; }
    TEDirection GetDirection() const { return TED_Forward; }
    float GetRate() const { return 1.0f; }
    
    // This indicates that a tick is required to update internal
    // state.  The node mgr needs to request this from the client
    void RequestTick();
    
#if OLD_TIME_ENGINE
    HRESULT AddBvrCB(CTIMENode *pbvr);
    HRESULT RemoveBvrCB(CTIMENode *pbvr);
#endif

    // !!This does not addref!!
    IServiceProvider * GetServiceProvider();
    CTIMENode * GetTIMENode() { return m_mmbvr; }
  protected:
    HRESULT BeginMgr(CEventList &l,
                     double lTime);
    HRESULT EndMgr(double lTime);
    HRESULT PauseMgr();
    HRESULT ResumeMgr();
    
    void TickEvent(CEventList &l,
                   TE_EVENT_TYPE event,
                   DWORD dwFlags);
    
    void Tick(CEventList & l,
              double lTime);
    
    HRESULT Error();
    
  protected:
    DAComPtr<CTIMENode> m_mmbvr;
    CComPtr<IServiceProvider> m_sp;

    bool m_bIsActive;
    bool m_bIsPaused;
    bool m_bNeedsUpdate;
    bool m_firstTick;
    
    //
    // Relationships:
    //    m_lastTickTime - m_tickStartTime == m_curGlobalTime - m_globalStartTime
    //    m_tickStartTime is implicitly 0
    // thus:
    //    m_lastTickTime == m_curGlobalTime - m_globalStartTime
    //
    
    double m_curGlobalTime;
    double m_globalStartTime;
    
    inline double TickTimeToGlobalTime(double tickTime);
  private:
/*lint ++flb*/
    LPWSTR m_id;
    bool m_bForward;
    double m_lastTickTime;
#if OLD_TIME_ENGINE
    BvrCBList m_bvrCBList;
#endif
/*lint --flb*/

};

inline IServiceProvider *
CTIMENodeMgr::GetServiceProvider()
{
    return m_sp;
}

// Since: m_lastTickTime == m_curGlobalTime - m_globalStartTime
// then gTime == tickTime + m_globalStartTime

inline double
CTIMENodeMgr::TickTimeToGlobalTime(double tickTime)
{
    return tickTime + m_globalStartTime;
}

#endif /* _MMPLAYER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timeeng\props.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmprops.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "Node.h"
#include "NodeMgr.h"

STDMETHODIMP
CTIMENode::get_id(LPOLESTR * p)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::get_id()",
              this));

    HRESULT hr;
    
    CHECK_RETURN_SET_NULL(p);

    if (m_pszID)
    {
        *p = SysAllocString(m_pszID);

        if (*p == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    
    hr = S_OK;
  done:
    return hr;
}

STDMETHODIMP
CTIMENode::put_id(LPOLESTR s)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::put_id(%ls)",
              this,
              s));

    HRESULT hr;

    delete m_pszID;
    m_pszID = NULL;

    if (s)
    {
        m_pszID = CopyString(s);

        if (m_pszID == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }

    hr = S_OK;
  done:
    return hr;
}
        
STDMETHODIMP
CTIMENode::get_dur(double * pdur)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::get_dur()",
              this));

    CHECK_RETURN_NULL(pdur);

    *pdur = m_dblDur;
    return S_OK;
}

STDMETHODIMP
CTIMENode::put_dur(double dur)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::put_dur(%g)",
              this,
              dur));

    // TODO: Should this be invalid?
    if (dur != TE_UNDEFINED_VALUE &&
        dur < 0.0)
    {
        return E_INVALIDARG;
    }
    
    if (m_dblDur != dur)
    {
        m_dblDur = dur;
        
        Invalidate(TE_INVALIDATE_DUR);
    }
    
    return S_OK;
}
        
STDMETHODIMP
CTIMENode::get_repeatCount(double * prepeat)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::get_repeatCount()",
              this));

    CHECK_RETURN_NULL(prepeat);

    *prepeat = m_dblRepeatCount;
    return S_OK;
}

STDMETHODIMP
CTIMENode::put_repeatCount(double repeat)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::put_repeatCount(%d)",
              this,
              repeat));

    if (repeat != TE_UNDEFINED_VALUE &&
        repeat < 0.0)
    {
        return E_INVALIDARG;
    }
    
    if (m_dblRepeatCount != repeat)
    {
        m_dblRepeatCount = repeat;
        
        Invalidate(TE_INVALIDATE_DUR);
    }

    return S_OK;
}
        
STDMETHODIMP
CTIMENode::get_repeatDur(double * pr)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::get_repeatDur()",
              this));

    CHECK_RETURN_NULL(pr);

    *pr = m_dblRepeatDur;
    return S_OK;
}

STDMETHODIMP
CTIMENode::put_repeatDur(double r)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::put_repeatDur(%g)",
              this,
              r));

    if (r != TE_UNDEFINED_VALUE &&
        r < 0.0)
    {
        return E_INVALIDARG;
    }
    
    if (m_dblRepeatDur != r)
    {
        m_dblRepeatDur = r;
        
        Invalidate(TE_INVALIDATE_DUR);
    }

    return S_OK;
}
        
STDMETHODIMP
CTIMENode::get_fill(TE_FILL_FLAGS * ptef)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::get_fill()",
              this));

    CHECK_RETURN_NULL(ptef);

    *ptef = m_tefFill;
    return S_OK;
}

STDMETHODIMP
CTIMENode::put_fill(TE_FILL_FLAGS tef)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::put_repeatDur(%x)",
              this,
              tef));

    if (m_tefFill != tef)
    {
        m_tefFill = tef;
        
        Invalidate(TE_INVALIDATE_STATE);
    }
    
    return S_OK;
}
    
STDMETHODIMP
CTIMENode::get_autoReverse(VARIANT_BOOL * pautoreverse)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::get_autoReverse()",
              this));

    CHECK_RETURN_NULL(pautoreverse);

    *pautoreverse = m_bAutoReverse;
    return S_OK;
}

STDMETHODIMP
CTIMENode::put_autoReverse(VARIANT_BOOL autoreverse)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::put_autoReverse(%d)",
              this,
              autoreverse));

    bool ar = autoreverse?true:false;
    
    if (m_bAutoReverse != ar)
    {
        m_bAutoReverse = ar;
        
        Invalidate(TE_INVALIDATE_DUR);
    }
    
    return S_OK;
}
        
STDMETHODIMP
CTIMENode::get_speed(float * pflt)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::get_speed()",
              this));

    CHECK_RETURN_NULL(pflt);

    *pflt = m_fltSpeed;
    return S_OK;
}

STDMETHODIMP
CTIMENode::put_speed(float flt)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::put_speed(%g)",
              this,
              flt));

    if (flt == 0.0f)
    {
        return E_INVALIDARG;
    }
    
    if (m_fltSpeed != flt)
    {
        Invalidate(TE_INVALIDATE_SIMPLETIME | TE_INVALIDATE_END);

        m_fltSpeed = flt;
    }
    
    return S_OK;
}
        
STDMETHODIMP
CTIMENode::get_accelerate(float * pflt)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::get_accelerate()",
              this));

    CHECK_RETURN_NULL(pflt);

    *pflt = m_fltAccel;
    return S_OK;
}

STDMETHODIMP
CTIMENode::put_accelerate(float flt)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::put_accelerate(%g)",
              this,
              flt));

    if (flt < 0.0 || flt > 1.0) return E_INVALIDARG;
    
    if (m_fltAccel != flt)
    {
        m_fltAccel = flt;
        
        Invalidate(TE_INVALIDATE_SIMPLETIME);
    }
    
    return S_OK;
}
        
STDMETHODIMP
CTIMENode::get_decelerate(float * pflt)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::get_decelerate()",
              this));

    CHECK_RETURN_NULL(pflt);

    *pflt = m_fltDecel;
    return S_OK;
}

STDMETHODIMP
CTIMENode::put_decelerate(float flt)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::put_decelerate(%g)",
              this,
              flt));

    if (flt < 0.0 || flt > 1.0) return E_INVALIDARG;

    if (m_fltDecel != flt)
    {
        m_fltDecel = flt;
        
        Invalidate(TE_INVALIDATE_SIMPLETIME);
    }
    
    return S_OK;
}
        
STDMETHODIMP
CTIMENode::get_flags(DWORD * flags)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::get_flags()",
              this));

    CHECK_RETURN_NULL(flags);

    *flags = m_dwFlags;

    return S_OK;
}

STDMETHODIMP
CTIMENode::put_flags(DWORD flags)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::put_flags(%d)",
              this,
              flags));

    // if we need to registered a Timer Callback, add it to the player.
    if (m_ptnmNodeMgr)
    {
        bool newcs = (flags & TE_FLAGS_MASTER) != 0;
        bool oldcs = IsSyncMaster();
        
        // If the clock source parameter changed update ourselves in
        // the player
        if (newcs && !oldcs)
        {
            m_ptnmNodeMgr->AddBvrCB(this);
        }
        else if (oldcs && !newcs)
        {
            m_ptnmNodeMgr->RemoveBvrCB(this);
        }
    }

    m_dwFlags = flags;

    return S_OK;
}

STDMETHODIMP
CTIMENode::get_restart(TE_RESTART_FLAGS * pr)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::get_restart()",
              this));

    CHECK_RETURN_NULL(pr);

    *pr = m_teRestart;
    return S_OK;
}

STDMETHODIMP
CTIMENode::put_restart(TE_RESTART_FLAGS r)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::put_restart(%#x)",
              this,
              r));

    m_teRestart = r;
    
    return S_OK;
}
        
STDMETHODIMP
CTIMENode::get_naturalDur(double * pdbl)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::get_naturalDur()",
              this));

    CHECK_RETURN_NULL(pdbl);
    *pdbl = m_dblNaturalDur;
    return S_OK;
}

STDMETHODIMP
CTIMENode::put_naturalDur(double dbl)
{
    TraceTag((tagTIMENode,
              "CTIMENode(%lx)::put_naturalDur(%g)",
              this,
              dbl));

    HRESULT hr;
    CEventList l;
    bool bRecalc = false;
    double dblPrevSegmentDur = CalcCurrSegmentDur();
    
    if (dbl != TE_UNDEFINED_VALUE &&
        dbl < 0.0)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    if (m_dblNaturalDur == TE_UNDEFINED_VALUE
        && GetCurrRepeatCount() == 0)
    {
        bRecalc = true;
    }
    
    m_dblNaturalDur = dbl;

    double dblSegmentDur;
    dblSegmentDur = CalcCurrSegmentDur();
    
    if (dblPrevSegmentDur == dblSegmentDur)
    {
        hr = S_OK;
        goto done;
    }
    
    PropNotify(&l, TE_PROPERTY_SEGMENTDUR);

    RecalcSegmentDurChange(&l, bRecalc);
    
    hr = THR(l.FireEvents());
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
  done:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timeeng\seek.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: seek.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "Node.h"
#include "container.h"

DeclareTag(tagTIMESeek, "TIME: Engine", "Seeking");

HRESULT
CTIMENode::SeekTo(LONG lNewRepeatCount,
                  double dblNewSegmentTime,
                  CEventList * l)
{
    TraceTag((tagTIMESeek,
              "CTIMENode(%lx)::SeekTo(%ld,%g,%#x)",
              this,
              lNewRepeatCount,
              dblNewSegmentTime,
              l));

    HRESULT hr;
    double dblSegmentDur = CalcCurrSegmentDur();
    
    Assert(IsActive());

    // Max out at the segment duration
    if (dblNewSegmentTime > dblSegmentDur)
    {
        dblNewSegmentTime = dblSegmentDur;
    }
    else if (dblNewSegmentTime < 0)
    {
        dblNewSegmentTime = 0;
    }
    
    if (lNewRepeatCount >= CalcRepeatCount())
    {
        lNewRepeatCount = CalcRepeatCount() - 1;
    }
    else if (lNewRepeatCount < 0)
    {
        lNewRepeatCount = 0;
    }
    
    // See if we are indeed seeking
    if (GetCurrSegmentTime() == dblNewSegmentTime &&
        GetCurrRepeatCount() == lNewRepeatCount)
    {
        hr = S_OK;
        goto done;
    }

    double dblNewActiveTime;
    dblNewActiveTime = CalcNewActiveTime(dblNewSegmentTime,
                                         lNewRepeatCount);
    double dblNewParentTime;
    dblNewParentTime = CalcParentTimeFromActiveTime(dblNewActiveTime);

    if (IsLocked())
    {
        if (GetParent())
        {
            double dblParentSegmentTime;
            dblParentSegmentTime = GetParent()->SimpleTimeToSegmentTime(dblNewParentTime);

            hr = THR(GetParent()->SeekTo(GetParent()->GetCurrRepeatCount(),
                                         dblParentSegmentTime,
                                         l));
            if (FAILED(hr))
            {
                goto done;
            }
        }
        else
        {
            hr = E_FAIL;
            goto done;
        }
    }
    else
    {
        TE_EVENT_TYPE te = (lNewRepeatCount == GetCurrRepeatCount())?TE_EVENT_SEEK:TE_EVENT_RESET;
         
        m_dblElapsedActiveRepeatTime = dblNewActiveTime - dblNewSegmentTime;

        // This is a very weird way to calculate this but it leads to
        // fewer precision problems.  Since tick calculates things by
        // subtracting active time we should do this as well
        
        m_dblCurrSegmentTime = dblNewActiveTime - m_dblElapsedActiveRepeatTime;
        // Again due to precision problems clamp the segment dur
        m_dblCurrSegmentTime = Clamp(0.0,
                                     m_dblCurrSegmentTime,
                                     dblSegmentDur);
        
        m_lCurrRepeatCount = lNewRepeatCount;
        
        PropNotify(l,
                   (TE_PROPERTY_TIME |
                    TE_PROPERTY_REPEATCOUNT |
                    TE_PROPERTY_PROGRESS));
        
        // Fire a seek event on ourself
        EventNotify(l, CalcElapsedActiveTime(), te);

        // Now recalc our end time and propagate to dependencies
        RecalcCurrEndTime(l, true);

        // Now fire a tick event to our children letting them know the
        // parent time has been changed
        TickEventChildren(l, te, 0);

        if (te == TE_EVENT_SEEK)
        {
            // Fire a parent time shift event
            TickEventChildren(l, TE_EVENT_PARENT_TIMESHIFT, 0);
        }
    }
    
    hr = S_OK;
  done:
    RRETURN(hr);
}

void
CTIMENode::HandleSeekUpdate(CEventList * l)
{
    TraceTag((tagTIMESeek,
              "CTIMENode(%lx)::HandleSeekUpdate(%#x)",
              this,
              l));

    double dblParentSimpleTime = GetContainer().ContainerGetSimpleTime();
    double dblSegmentDur = CalcCurrSegmentDur();
    bool bPrevActive = IsActive();
    
    // We really did not seek - just return
    if (dblParentSimpleTime == GetCurrParentTime())
    {
        // we may be in a fill region
        PropNotify(l, TE_PROPERTY_ISON);
        goto done;
    }

    // See if the seek moves us out of the current instance.  If so
    // then we need a full reset
    if (dblParentSimpleTime < GetBeginParentTime() ||
        dblParentSimpleTime > GetEndParentTime())
    {
        ResetNode(l, true, false);
        goto done;
    }
    else if (!IsActive())
    {
        CalcCurrRuntimeState(l, 0.0);
    }

    // See if we are seeking before the current repeat boundary.  If
    // not then we can use this point as the boundary and not do a
    // reset of the repeat boundary
    //
    // If we are passing an earlier repeat boundary then we need to do
    // a repeat boundary recalc

#if 0
    else if (dblNewLocalTime >= m_dblLastLocalRepeatTime)
    {
        double dblNewElapsedTime;
        
        if (dblParentSimpleTime > GetActiveEndTime() ||
            (!m_bFirstTick && dblParentSimpleTime == GetActiveEndTime()))
        {
            m_bIsActive = false;
            dblNewLocalTime = GetActiveEndTime() - GetActiveBeginTime();
        }
        else
        {
            // We should already be active at this point - but check
            // to make sure
            Assert(m_bIsActive);
        }

        dblNewElapsedTime = m_dblLastSegmentTime + (dblNewLocalTime - m_dblLastLocalTime);
        if (dblNewElapsedTime < 0)
        {
            dblNewElapsedTime = 0;
        }
        
        if (dblNewElapsedTime < dblSegmentDur)
        {
            m_dblLastSegmentTime = dblNewElapsedTime;
        }
        else
        {
            long lNewRepeats = int(dblNewElapsedTime / dblSegmentDur);
            double dblNewElapsedRepeatTime = lNewRepeats * dblSegmentDur;

            m_lCurrRepeatCount += lNewRepeats;
            Assert(m_lCurrRepeatCount <= CalcRepeatCount());

            m_dblElapsedRepeatTime += dblNewElapsedRepeatTime;
            Assert(m_dblElapsedRepeatTime <= m_dblActiveDur);
        
            // The segment time is the remainder left
            m_dblLastSegmentTime = dblNewElapsedTime - dblNewElapsedRepeatTime;
            Assert(m_dblLastSegmentTime <= dblSegmentDur);

            // The new repeat time is the time when the segment began
            m_dblLastLocalRepeatTime = dblNewLocalTime - m_dblLastSegmentTime;

            if (0.0 > m_dblLastLocalRepeatTime)
            {
                m_dblLastLocalRepeatTime = 0.0;
            }
        }

        m_dblLastLocalTime = dblNewLocalTime;
    }
#endif
    else
    {
        // Recalc the runtime state taking into account the lag
        CalcCurrRuntimeState(l,
                             CalcCurrLocalTime() - CalcElapsedLocalTime());
    }

    if (bPrevActive != IsActive())
    {
        // Only fire the begin if it lands anywhere but on the begin
        // point
        if (IsActive())
        {
            // We need to defer the begin if we are locked, on our begin
            // point, and our parent needs a first tick
            // TODO: Consider adding a fudge of a little bit to hold
            // off the begin since we get truncation sometimes
            bool bSkip = (IsLocked() &&
                          GetCurrParentTime() == CalcActiveBeginPoint() &&
                          GetContainer().ContainerIsFirstTick());
            if (bSkip)
            {
                // Defer the begin
                m_bFirstTick = true;
            }
            else
            {
                EventNotify(l, CalcElapsedActiveTime(), TE_EVENT_BEGIN);
            }
        }
        else
        {
            EventNotify(l, CalcElapsedActiveTime(), TE_EVENT_END);
        }
    }
    
  done:
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\time\timeeng\runtimeprops.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: runtimeprops.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/



#include "headers.h"
#include "Node.h"
#include "NodeMgr.h"

DeclareTag(tagTIMENodeRTProps, "TIME: Engine", "CTIMENode runtime props");

STDMETHODIMP
CTIMENode::get_beginParentTime(double * d)
{
    TraceTag((tagTIMENodeRTProps,
              "CTIMENode(%lx)::get_beginParentTime()",
              this));

    CHECK_RETURN_NULL(d);
    
    *d = GetBeginParentTime();
    
    return S_OK;
}

// This is the time on the parents timeline at which the node
// will or already has ended.  If it is infinite then the end
// time