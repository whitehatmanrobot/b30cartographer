  IUnknown *pUnkOuter,
    REFIID riid,
    void **ppvObj
    )
{
    CCredentials Credentials;
    CIISApplicationPool FAR * pApplicationPool = NULL;
    HRESULT hr = S_OK;
    BSTR bstrAdsPath = NULL;
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer * pLexer = NULL;
    LPWSTR pszIISPathName  = NULL;
    LPWSTR *pszPoolName;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));

    hr = AllocateApplicationPoolObject(pUnkOuter, Credentials, &pApplicationPool);
    BAIL_ON_FAILURE(hr);

    //
    // get ServerName and pszPath
    //

    hr = pApplicationPool->_pADs->get_ADsPath(&bstrAdsPath);
    BAIL_ON_FAILURE(hr);

    pLexer = new CLexer();
    hr = pLexer->Initialize(bstrAdsPath);
    BAIL_ON_FAILURE(hr);

    //
    // Parse the pathname
    //

    hr = ADsObject(pLexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    pszIISPathName = AllocADsStr(bstrAdsPath);
    if (!pszIISPathName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    *pszIISPathName = L'\0';
    hr = BuildIISPathFromADsPath(
                    pObjectInfo,
                    pszIISPathName
                    );
    BAIL_ON_FAILURE(hr);

    pszPoolName = &(ObjectInfo.ComponentArray[ObjectInfo.NumComponents-1].szComponent);

    hr = pApplicationPool->InitializeApplicationPoolObject(
                pObjectInfo->TreeName,
                pszIISPathName,
                *pszPoolName );
    BAIL_ON_FAILURE(hr);

    //
    // pass non-delegating IUnknown back to the aggregator
    //

    *ppvObj = (INonDelegatingUnknown FAR *) pApplicationPool;

    if (bstrAdsPath)
    {
        ADsFreeString(bstrAdsPath);
    }

    if (pLexer) {
        delete pLexer;
    }

    if (pszIISPathName ) {
        FreeADsStr( pszIISPathName );
    }

    FreeObjectInfo( &ObjectInfo );

    RRETURN(hr);

error:

    if (bstrAdsPath) {
        ADsFreeString(bstrAdsPath);
    }

    if (pLexer) {
        delete pLexer;
    }

    if (pszIISPathName ) {
        FreeADsStr( pszIISPathName );
    }

    FreeObjectInfo( &ObjectInfo );

    *ppvObj = NULL;

    delete pApplicationPool;

    RRETURN(hr);

}


CIISApplicationPool::~CIISApplicationPool( )
{
    if (_pszServerName) {
        FreeADsStr(_pszServerName);
    }

    if (_pszMetaBasePath) {
        FreeADsStr(_pszMetaBasePath);
    }

    if (_pszPoolName) {
        FreeADsStr(_pszPoolName);
    }

    delete _pDispMgr;
}


STDMETHODIMP
CIISApplicationPool::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    HRESULT hr = S_OK;
   
    hr = _pUnkOuter->QueryInterface(iid,ppv);

    RRETURN(hr);
}

HRESULT
CIISApplicationPool::AllocateApplicationPoolObject(
    IUnknown *pUnkOuter,
    CCredentials& Credentials,
    CIISApplicationPool ** ppApplicationPool
    )
{
    CIISApplicationPool FAR * pApplicationPool = NULL;
    IADs FAR *  pADs = NULL;
    CAggregateeDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pApplicationPool = new CIISApplicationPool();
    if (pApplicationPool == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregateeDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                LIBID_IISExt,
                IID_IISApplicationPool,
                (IISApplicationPool *)pApplicationPool,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    //
    // Store the IADs Pointer, but again do NOT ref-count
    // this pointer - we keep the pointer around, but do
    // a release immediately.
    //
 
    hr = pUnkOuter->QueryInterface(IID_IADs, (void **)&pADs);
    pADs->Release();
    pApplicationPool->_pADs = pADs;

    //
    // Store the pointer to the pUnkOuter object
    // AND DO NOT add ref this pointer
    //
    pApplicationPool->_pUnkOuter = pUnkOuter;
  
    pApplicationPool->_Credentials = Credentials;
    pApplicationPool->_pDispMgr = pDispMgr;
    *ppApplicationPool = pApplicationPool;

    RRETURN(hr);

error:

    delete  pDispMgr;
    delete  pApplicationPool;

    RRETURN(hr);
}

HRESULT
CIISApplicationPool::InitializeApplicationPoolObject(
    LPWSTR pszServerName,
    LPWSTR pszPath,
    LPWSTR pszPoolName
    )
{
    HRESULT hr = S_OK;

    if (pszServerName) {
        _pszServerName = AllocADsStr(pszServerName);

        if (!_pszServerName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    if (pszPath) {
        _pszMetaBasePath = AllocADsStr(pszPath);

        if (!_pszMetaBasePath) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    if (pszPoolName) {
        _pszPoolName = AllocADsStr(pszPoolName);

        if (!_pszPoolName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    hr = InitServerInfo(pszServerName, &_pAdminBase);
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}

STDMETHODIMP
CIISApplicationPool::ADSIInitializeDispatchManager(
    long dwExtensionId
    )
{
    HRESULT hr = S_OK;

    if (_fDispInitialized) {

        RRETURN(E_FAIL);
    }

    hr = _pDispMgr->InitializeDispMgr(dwExtensionId);

    if (SUCCEEDED(hr)) {
        _fDispInitialized = TRUE;
    }

    RRETURN(hr);
}


STDMETHODIMP
CIISApplicationPool::ADSIInitializeObject(
    THIS_ BSTR lpszUserName,
    BSTR lpszPassword,
    long lnReserved
    )
{
    CCredentials NewCredentials(lpszUserName, lpszPassword, lnReserved);

    _Credentials = NewCredentials;

    RRETURN(S_OK);
}


STDMETHODIMP
CIISApplicationPool::ADSIReleaseObject()
{
    delete this;
    RRETURN(S_OK);
}


STDMETHODIMP
CIISApplicationPool::NonDelegatingQueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    ASSERT(ppv);
    
    if (IsEqualIID(iid, IID_IISApplicationPool)) {

        *ppv = (IADsUser FAR *) this;

    } else if (IsEqualIID(iid, IID_IADsExtension)) {

        *ppv = (IADsExtension FAR *) this;
                                
    } else if (IsEqualIID(iid, IID_IUnknown)) {
        
        //
        // probably not needed since our 3rd party extension does not stand 
        // alone and provider does not ask for this, but to be safe
        //
        *ppv = (INonDelegatingUnknown FAR *) this;

    } else {
        
        *ppv = NULL;
        return E_NOINTERFACE;
    } 


    //
    // Delegating AddRef to aggregator for IADsExtesnion and IISApplicationPool.
    // AddRef on itself for IPrivateUnknown.   (both tested.)
    //

    ((IUnknown *) (*ppv)) -> AddRef();       

    return S_OK;
}


//
// IADsExtension::Operate()
//

STDMETHODIMP
CIISApplicationPool::Operate(
    THIS_ DWORD dwCode,
    VARIANT varUserName,
    VARIANT varPassword,
    VARIANT varFlags
    )
{
    RRETURN(E_NOTIMPL);
}

//
// Helper routine for ExecMethod.
// Gets Win32 error from the metabase
//
HRESULT
CIISApplicationPool::IISGetAppPoolWin32Error(
    METADATA_HANDLE hObjHandle,
    HRESULT*        phrError)
{
    DBG_ASSERT(phrError != NULL);

    long    lWin32Error = 0;
    DWORD   dwLen;

    METADATA_RECORD mr = {
        MD_WIN32_ERROR, 
        METADATA_NO_ATTRIBUTES,
        IIS_MD_UT_SERVER,
        DWORD_METADATA,
        sizeof(DWORD),
        (unsigned char*)&lWin32Error,
        0
        };  
    
    HRESULT hr = _pAdminBase->GetData(
        hObjHandle,
        _pszMetaBasePath,
        &mr,
        &dwLen);
    if(hr == MD_ERROR_DATA_NOT_FOUND)
    {
        hr = S_FALSE;
    }

    //
    // Set out param
    //
    *phrError = HRESULT_FROM_WIN32(lWin32Error);

    RRETURN(hr);
}

//
// Helper Functions
//

HRESULT
CIISApplicationPool::IISGetAppPoolState(
    METADATA_HANDLE hObjHandle,
    PDWORD pdwState
    )
{

    HRESULT hr = S_OK;
    DWORD dwBufferSize = sizeof(DWORD);
    METADATA_RECORD mdrMDData;
    LPBYTE pBuffer = (LPBYTE)pdwState;

    MD_SET_DATA_RECORD(&mdrMDData,
                       MD_APPPOOL_STATE,    // server state
                       METADATA_NO_ATTRIBUTES,
                       IIS_MD_UT_SERVER,
                       DWORD_METADATA,
                       dwBufferSize,
                       pBuffer);

    hr = InitServerInfo(_pszServerName, &_pAdminBase);
    BAIL_ON_FAILURE(hr);

    hr = _pAdminBase->GetData(
             hObjHandle,
             _pszMetaBasePath,
             &mdrMDData,
             &dwBufferSize
             );
    if (FAILED(hr)) {
        if( hr == MD_ERROR_DATA_NOT_FOUND )
        {
            //
            // If the data is not there, but the path exists, then the
            // most likely cause is that the app pool is not running and
            // this object was just created.
            //
            // Since MD_APPPOOL_STATE would be set as stopped if the
            // app pool were running when the key is added, we'll just 
            // say that it's stopped. 
            // 
            *pdwState = MD_APPPOOL_STATE_STOPPED;
            hr = S_FALSE;
        }

        else if ((HRESULT_CODE(hr) == RPC_S_SERVER_UNAVAILABLE) ||
            ((HRESULT_CODE(hr) >= RPC_S_NO_CALL_ACTIVE) &&
             (HRESULT_CODE(hr) <= RPC_S_CALL_FAILED_DNE)) || 
            hr == RPC_E_DISCONNECTED || hr == MD_ERROR_SECURE_CHANNEL_FAILURE) {
            
            hr = ReCacheAdminBase(_pszServerName, &_pAdminBase);
            BAIL_ON_FAILURE(hr);

            hr = _pAdminBase->GetData(
                hObjHandle,
                _pszMetaBasePath,
                &mdrMDData,
                &dwBufferSize
                );

            if (FAILED(hr)) 
            {
                if( hr == MD_ERROR_DATA_NOT_FOUND )
                {
                    *pdwState = MD_APPPOOL_STATE_STOPPED;
                    hr = S_FALSE;
                }
            }

            BAIL_ON_FAILURE(hr);
        }

        else
        {
            BAIL_ON_FAILURE(hr);
        }
    }
error:

    RRETURN(hr);
}

HRESULT
CIISApplicationPool::IISSetCommand(
    METADATA_HANDLE hObjHandle,
    DWORD dwControl
    )
{

    HRESULT hr = S_OK;
    DWORD dwBufferSize = sizeof(DWORD);
    METADATA_RECORD mdrMDData;
    LPBYTE pBuffer = (LPBYTE)&dwControl;

    MD_SET_DATA_RECORD(&mdrMDData,
                       MD_APPPOOL_COMMAND,  // app pool command
                       METADATA_NO_ATTRIBUTES,
                       IIS_MD_UT_SERVER,
                       DWORD_METADATA,
                       dwBufferSize,
                       pBuffer);

    hr = _pAdminBase->SetData(
             hObjHandle,
             L"",
             &mdrMDData
             );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);

}

//
// Helper routine for ExecMethod.
// Clears Win32 error 
//
HRESULT
CIISApplicationPool::IISClearAppPoolWin32Error(
    METADATA_HANDLE hObjHandle )
{
    long    lWin32Error = 0;

    METADATA_RECORD mr = {
        MD_WIN32_ERROR, 
        METADATA_VOLATILE,
        IIS_MD_UT_SERVER,
        DWORD_METADATA,
        sizeof(DWORD),
        (unsigned char*)&lWin32Error,
        0
        };  
    
    HRESULT hr = _pAdminBase->SetData(
        hObjHandle,
        L"",
        &mr );

    RRETURN(hr);
}

HRESULT
CIISApplicationPool::IISControlAppPool(
    DWORD dwControl
    )
{
    METADATA_HANDLE hObjHandle = NULL;
    DWORD dwTargetState;
    DWORD dwState = 0;
    DWORD dwSleepTotal = 0L;

    HRESULT hr = S_OK;
    HRESULT hrMbNode = S_OK;

    switch(dwControl)
    {
    case MD_APPPOOL_COMMAND_STOP:
        dwTargetState = MD_APPPOOL_STATE_STOPPED;
        break;

    case MD_SERVER_COMMAND_START:
        dwTargetState = MD_APPPOOL_STATE_STARTED;
        break;

    default:
        hr = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
        BAIL_ON_FAILURE(hr);
    }

    hr = IISGetAppPoolState(METADATA_MASTER_ROOT_HANDLE, &dwState);
    BAIL_ON_FAILURE(hr);
 
    if (dwState == dwTargetState) {
        RRETURN (hr);
    }

    //
    // Write the command to the metabase
    //

    hr = OpenAdminBaseKey(
               _pszServerName,
               _pszMetaBasePath,
               METADATA_PERMISSION_WRITE,
               &_pAdminBase,
               &hObjHandle
               );
    BAIL_ON_FAILURE(hr);

    hr = IISClearAppPoolWin32Error(hObjHandle);
    BAIL_ON_FAILURE(hr);

    hr = IISSetCommand(hObjHandle, dwControl);
    BAIL_ON_FAILURE(hr);

    CloseAdminBaseKey(_pAdminBase, hObjHandle);

    while (dwSleepTotal < MAX_SLEEP_INST) {
        hr = IISGetAppPoolState(METADATA_MASTER_ROOT_HANDLE, &dwState);
        BAIL_ON_FAILURE(hr);

        hrMbNode = 0;

        hr = IISGetAppPoolWin32Error(METADATA_MASTER_ROOT_HANDLE, &hrMbNode);
        BAIL_ON_FAILURE(hr);

        //
        // Done one way or another
        //
        if (dwState == dwTargetState)
        {
            break;
        }

        // check to see if there was a Win32 error from the app pool
        if (FAILED(hrMbNode))
        {
            hr = hrMbNode;
            BAIL_ON_FAILURE(hr);
        }

        //
        // Still waiting...
        //
        ::Sleep(SLEEP_INTERVAL);

        dwSleepTotal += SLEEP_INTERVAL;
    }

    if (dwSleepTotal >= MAX_SLEEP_INST)
    {
        //
        // Timed out.  If there is a real error in the metabase
        // use it, otherwise use a generic timeout error
        //

        hr = HRESULT_FROM_WIN32(ERROR_SERVICE_REQUEST_TIMEOUT);
    }

error :

    if (_pAdminBase && hObjHandle) {
        CloseAdminBaseKey(_pAdminBase, hObjHandle);
    }

    RRETURN (hr);
}

STDMETHODIMP
CIISApplicationPool::Start(THIS)
{
    RRETURN(IISControlAppPool(MD_APPPOOL_COMMAND_START));
}

STDMETHODIMP
CIISApplicationPool::Stop(THIS)
{
    RRETURN(IISControlAppPool(MD_APPPOOL_COMMAND_STOP));
}

STDMETHODIMP
CIISApplicationPool::Recycle(THIS)
{
    HRESULT hr = S_OK;
    COSERVERINFO csiName;
    COSERVERINFO *pcsiParam = &csiName;
    IClassFactory * pcsfFactory = NULL;
    IIISApplicationAdmin * pAppAdmin = NULL;

    memset(pcsiParam, 0, sizeof(COSERVERINFO));

    //
    // special case to handle "localhost" to work-around ole32 bug
    //

    if (_pszServerName == NULL || _wcsicmp(_pszServerName,L"localhost") == 0) {
        pcsiParam->pwszName =  NULL;
    }
    else {
        pcsiParam->pwszName = _pszServerName;
    }

    csiName.pAuthInfo = NULL;
    pcsiParam = &csiName;

    hr = CoGetClassObject(
                CLSID_WamAdmin,
                CLSCTX_SERVER,
                pcsiParam,
                IID_IClassFactory,
                (void**) &pcsfFactory
                );

    BAIL_ON_FAILURE(hr);

    hr = pcsfFactory->CreateInstance(
                NULL,
                IID_IIISApplicationAdmin,
                (void **) &pAppAdmin
                );
    BAIL_ON_FAILURE(hr);

    hr = pAppAdmin->RecycleApplicationPool( _pszPoolName );

    BAIL_ON_FAILURE(hr);

error:
    if (pcsfFactory) {
        pcsfFactory->Release();
    }
    if (pAppAdmin) {
        pAppAdmin->Release();
    } 

    RRETURN(hr);
}

STDMETHODIMP
CIISApplicationPool::EnumAppsInPool(
        VARIANT FAR* pvBuffer
        )
{
    HRESULT hr = S_OK;
    COSERVERINFO csiName;
    COSERVERINFO *pcsiParam = &csiName;
    IClassFactory * pcsfFactory = NULL;
    IIISApplicationAdmin * pAppAdmin = NULL;
    BSTR bstr = NULL;

    memset(pcsiParam, 0, sizeof(COSERVERINFO));

    //
    // special case to handle "localhost" to work-around ole32 bug
    //

    if (_pszServerName == NULL || _wcsicmp(_pszServerName,L"localhost") == 0) {
        pcsiParam->pwszName =  NULL;
    }
    else {
        pcsiParam->pwszName = _pszServerName;
    }

    csiName.pAuthInfo = NULL;
    pcsiParam = &csiName;

    hr = CoGetClassObject(
                CLSID_WamAdmin,
                CLSCTX_SERVER,
                pcsiParam,
                IID_IClassFactory,
                (void**) &pcsfFactory
                );

    BAIL_ON_FAILURE(hr);

    hr = pcsfFactory->CreateInstance(
                NULL,
                IID_IIISApplicationAdmin,
                (void **) &pAppAdmin
                );
    BAIL_ON_FAILURE(hr);

    hr = pAppAdmin->EnumerateApplicationsInPool( _pszPoolName, &bstr );

    BAIL_ON_FAILURE(hr);

    hr = MakeVariantFromStringArray( (LPWSTR)bstr, pvBuffer);
    BAIL_ON_FAILURE(hr);

error:
    if (pcsfFactory) {
        pcsfFactory->Release();
    }
    if (pAppAdmin) {
        pAppAdmin->Release();
    } 

    RRETURN(hr);
}

HRESULT
CIISApplicationPool::MakeVariantFromStringArray(
    LPWSTR pszList,
    VARIANT *pvVariant
)
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    LPWSTR pszStrList;
    WCHAR wchPath[MAX_PATH];


    if  ( (pszList != NULL) && (0 != wcslen(pszList)) )
    {
        long nCount = 0;
        long i = 0;
        pszStrList = pszList;

        if (*pszStrList == L'\0') {
            nCount = 1;
            pszStrList++;
        }

        while (*pszStrList != L'\0') {
            while (*pszStrList != L'\0') {
                pszStrList++;
            }
            nCount++;
            pszStrList++;
        }

        aBound.lLbound = 0;
        aBound.cElements = nCount;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        pszStrList = pszList;
        for (i = 0; i < nCount; i++ )
        {
            VARIANT v;

            VariantInit(&v);
            V_VT(&v) = VT_BSTR;

            hr = ADsAllocString( pszStrList, &(V_BSTR(&v)));

            BAIL_ON_FAILURE(hr);

            hr = SafeArrayPutElement( aList, &i, &v );

            VariantClear(&v);
            BAIL_ON_FAILURE(hr);

            pszStrList += wcslen(pszStrList) + 1;
        }

        VariantInit( pvVariant );
        V_VT(pvVariant) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pvVariant) = aList;

    }
    else
    {
        aBound.lLbound = 0;
        aBound.cElements = 0;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        VariantInit( pvVariant );
        V_VT(pvVariant) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pvVariant) = aList;
    }

    return S_OK;

error:

    if ( aList )
        SafeArrayDestroy( aList );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\iisext\cappcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cappcf.cxx
//
//  Contents:  IIS App Object Class Factory Code
//
//             CIISAppCF::CreateInstance
//
//----------------------------------------------------------------------------
#include "iisext.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CIISAppCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CIISAppCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = S_OK;

    if (!pUnkOuter)
        RRETURN(E_FAIL);

    hr = CIISApp::CreateApp(
                pUnkOuter,
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\iisext\capp.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:  capp.cxx
//
//  Contents:  Contains methods for CIISApp object
//
//  History:   20-1-98     SophiaC    Created.
//
//----------------------------------------------------------------------------

#include "iisext.hxx"
#pragma hdrstop
#define INITGUID

//  Class CIISApp

DEFINE_IPrivateDispatch_Implementation(CIISApp)
DEFINE_DELEGATING_IDispatch_Implementation(CIISApp)
DEFINE_CONTAINED_IADs_Implementation(CIISApp)
DEFINE_IADsExtension_Implementation(CIISApp)

CIISApp::CIISApp():
        _pUnkOuter(NULL),
        _pADs(NULL),
        _pszServerName(NULL),
        _pszMetaBasePath(NULL),
        _pAdminBase(NULL),
        _pWamAdmin(NULL),
        _pWamAdmin2(NULL),
        _pAppAdmin(NULL),
        _pDispMgr(NULL),
        _fDispInitialized(FALSE)
{
    ENLIST_TRACKING(CIISApp);
}

HRESULT
CIISApp::CreateApp(
    IUnknown *pUnkOuter,
    REFIID riid,
    void **ppvObj
    )
{
    CCredentials Credentials;
    CIISApp FAR * pApp = NULL;
    HRESULT hr = S_OK;
    BSTR bstrAdsPath = NULL;
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer * pLexer = NULL;
    LPWSTR pszIISPathName = NULL;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));

    hr = AllocateAppObject(pUnkOuter, Credentials, &pApp);
    BAIL_ON_FAILURE(hr);

    //
    // get ServerName and pszPath
    //

    hr = pApp->_pADs->get_ADsPath(&bstrAdsPath);
    BAIL_ON_FAILURE(hr);

    pLexer = new CLexer();
    hr = pLexer->Initialize(bstrAdsPath);
    BAIL_ON_FAILURE(hr);

    //
    // Parse the pathname
    //

    hr = ADsObject(pLexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    pszIISPathName = AllocADsStr(bstrAdsPath);
    if (!pszIISPathName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    *pszIISPathName = L'\0';
    hr = BuildIISPathFromADsPath(
                    pObjectInfo,
                    pszIISPathName
                    );
    BAIL_ON_FAILURE(hr);

    hr = pApp->InitializeAppObject(
                pObjectInfo->TreeName,
                pszIISPathName );
    BAIL_ON_FAILURE(hr);

    //
    // pass non-delegating IUnknown back to the aggregator
    //

    *ppvObj = (INonDelegatingUnknown FAR *) pApp;

    if (bstrAdsPath) {
        ADsFreeString(bstrAdsPath);
    }

    if (pLexer) {
        delete pLexer;
    }

    if (pszIISPathName ) {
        FreeADsStr( pszIISPathName );
    }

    FreeObjectInfo( &ObjectInfo );

    RRETURN(hr);

error:

    if (bstrAdsPath) {
        ADsFreeString(bstrAdsPath);
    }

    if (pLexer) {
        delete pLexer;
    }

    if (pszIISPathName ) {
        FreeADsStr( pszIISPathName );
    }

    FreeObjectInfo( &ObjectInfo );

    *ppvObj = NULL;

    delete pApp;

    RRETURN(hr);

}


CIISApp::~CIISApp( )
{

    if (_pWamAdmin) {
        _pWamAdmin->Release();
    }

    if (_pWamAdmin2) {
        _pWamAdmin2->Release();
    }

    if (_pAppAdmin) {
        _pAppAdmin->Release();
    }

    if (_pszServerName) {
        FreeADsStr(_pszServerName);
    }

    if (_pszMetaBasePath) {
        FreeADsStr(_pszMetaBasePath);
    }

    delete _pDispMgr;
}


STDMETHODIMP
CIISApp::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    HRESULT hr = S_OK;

    hr = _pUnkOuter->QueryInterface(iid,ppv);

    RRETURN(hr);
}

HRESULT
CIISApp::AllocateAppObject(
    IUnknown *pUnkOuter,
    CCredentials& Credentials,
    CIISApp ** ppApp
    )
{
    CIISApp FAR * pApp = NULL;
    IADs FAR *  pADs = NULL;
    CAggregateeDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pApp = new CIISApp();
    if (pApp == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregateeDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                LIBID_IISExt,
                IID_IISApp3,
                (IISApp3 *)pApp,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    //
    // Store the IADs Pointer, but again do NOT ref-count
    // this pointer - we keep the pointer around, but do
    // a release immediately.
    //

    hr = pUnkOuter->QueryInterface(IID_IADs, (void **)&pADs);
    pADs->Release();
    pApp->_pADs = pADs;

    //
    // Store the pointer to the pUnkOuter object
    // AND DO NOT add ref this pointer
    //

    pApp->_pUnkOuter = pUnkOuter;

    pApp->_Credentials = Credentials;
    pApp->_pDispMgr = pDispMgr;
    *ppApp = pApp;

    RRETURN(hr);

error:

    delete  pDispMgr;
    delete  pApp;

    RRETURN(hr);
}

HRESULT
CIISApp::InitializeAppObject(
    LPWSTR pszServerName,
    LPWSTR pszPath
    )
{
    HRESULT hr = S_OK;
    DWORD dwState;

    if (pszServerName) {
        _pszServerName = AllocADsStr(pszServerName);

        if (!_pszServerName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    if (pszPath) {
        _pszMetaBasePath = AllocADsStr(pszPath);

        if (!_pszMetaBasePath) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    hr = InitServerInfo(pszServerName, &_pAdminBase);
    BAIL_ON_FAILURE(hr);

	hr = InitWamAdm(pszServerName);
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}

HRESULT
CIISApp::InitWamAdm(
    LPWSTR pszServerName
    )
{
    HRESULT hr = S_OK;

    COSERVERINFO csiName;
    COSERVERINFO *pcsiParam = &csiName;

    memset(pcsiParam, 0, sizeof(COSERVERINFO));

    //
    // special case to handle "localhost" to work-around ole32 bug
    //

    if (pszServerName == NULL || _wcsicmp(pszServerName,L"localhost") == 0) {
        pcsiParam->pwszName =  NULL;
    }
    else {
        pcsiParam->pwszName =  pszServerName;
    }

    csiName.pAuthInfo = NULL;

    
    MULTI_QI  rgInterfaces[3];

    rgInterfaces[0].hr = NOERROR;
    rgInterfaces[0].pIID = &IID_IWamAdmin;
    rgInterfaces[0].pItf = NULL;

    rgInterfaces[1].hr = NOERROR;
    rgInterfaces[1].pIID = &IID_IIISApplicationAdmin;
    rgInterfaces[1].pItf = NULL;

    rgInterfaces[2].hr = NOERROR;
    rgInterfaces[2].pIID = &IID_IWamAdmin2;
    rgInterfaces[2].pItf = NULL;

    hr = CoCreateInstanceEx( CLSID_WamAdmin,
                             NULL,
                             CLSCTX_SERVER,
                             pcsiParam,
                             3,
                             rgInterfaces
                             );

    if( SUCCEEDED(hr) )
    {
        if( SUCCEEDED(rgInterfaces[0].hr) )
        {
            _pWamAdmin = (IWamAdmin *)rgInterfaces[0].pItf;
        }

        if( SUCCEEDED(rgInterfaces[1].hr) )
        {
            _pAppAdmin = (IIISApplicationAdmin *)rgInterfaces[1].pItf;
        }

        if( SUCCEEDED(rgInterfaces[2].hr) )
        {
            _pWamAdmin2 = (IWamAdmin2 *)rgInterfaces[2].pItf;
        }
    }

    RRETURN(hr);

}

//+---------------------------------------------------------------------------
//
//  Function:   CIISApp::AppCreate
//
//  Synopsis:   
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    07/14/97  SophiaC    Created
//
// Notes:
//----------------------------------------------------------------------------
STDMETHODIMP
CIISApp::AppCreate(
    THIS_ VARIANT_BOOL bSetInProcFlag
    )
{
    HRESULT hr = S_OK;
    BOOL boolCreatePool = FALSE;
    LPWSTR pszPoolName;

    if (_pAppAdmin) {
        
        pszPoolName = NULL;
        boolCreatePool = FALSE;

        hr = _pAppAdmin->CreateApplication((LPWSTR)_pszMetaBasePath,
                               bSetInProcFlag ? 0 : 1,
                               pszPoolName,
                               boolCreatePool
                               );
    }

    else if (_pWamAdmin) {
        hr = _pWamAdmin->AppCreate((LPWSTR)_pszMetaBasePath, 
                           bSetInProcFlag ? TRUE : FALSE);
    }

    else {
        hr = E_NOINTERFACE;
    }

    RRETURN(hr);
}

STDMETHODIMP
CIISApp::AppCreate2(                  
    IN LONG lAppMode
    )
{
    HRESULT hr = S_OK;
    BOOL boolCreatePool = FALSE;
    LPWSTR pszPoolName;

    if (_pAppAdmin) {
        pszPoolName = NULL;
        boolCreatePool = FALSE;
             
        hr = _pAppAdmin->CreateApplication((LPWSTR)_pszMetaBasePath,
                               lAppMode,
                               pszPoolName,
                               boolCreatePool
                               );
    }

    else if (_pWamAdmin2) {
        hr = _pWamAdmin2->AppCreate2( (LPWSTR)_pszMetaBasePath, lAppMode );
    }

    else {
        hr = E_NOINTERFACE;
    }

    RRETURN(hr);
}

STDMETHODIMP
CIISApp::AppCreate3(                  
    IN LONG lAppMode,
    VARIANT bstrAppPoolId,
    VARIANT bCreatePool
    )
{
    HRESULT hr = S_OK;
    BOOL boolCreatePool = FALSE;
    LPWSTR pszPoolName;

    if (_pAppAdmin) {
        if (bstrAppPoolId.vt == VT_BSTR) {
            pszPoolName = bstrAppPoolId.bstrVal;
        }
        else {
            pszPoolName = NULL;
        }

        if (bCreatePool.vt == VT_BOOL) {
            if (bCreatePool.boolVal == VARIANT_TRUE) {
                boolCreatePool = TRUE;
            }
            else {
                boolCreatePool = FALSE;
            }
        }

             
        hr = _pAppAdmin->CreateApplication((LPWSTR)_pszMetaBasePath,
                               lAppMode,
                               pszPoolName,
                               boolCreatePool
                               );
    }

    else if (_pWamAdmin2) {
        hr = _pWamAdmin2->AppCreate2( (LPWSTR)_pszMetaBasePath, lAppMode );
    }

    else {
        hr = E_NOINTERFACE;
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CIISApp::AppDelete
//
//  Synopsis:   
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    07/14/96 SophiaC  Created
//
//----------------------------------------------------------------------------
STDMETHODIMP
CIISApp::AppDelete(THIS)
{
    HRESULT hr = S_OK;

    if (_pAppAdmin) {
        hr = _pAppAdmin->DeleteApplication((LPWSTR)_pszMetaBasePath, FALSE);
    }
    
    else if (_pWamAdmin) {
        hr = _pWamAdmin->AppDelete((LPWSTR)_pszMetaBasePath, FALSE);
    }

    else {
        hr = E_NOINTERFACE;
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CIISApp::AppDeleteRecursive
//
//  Synopsis:   
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    07/14/96 SophiaC  Created
//
//----------------------------------------------------------------------------
STDMETHODIMP
CIISApp::AppDeleteRecursive(THIS)
{
    HRESULT hr = S_OK;

    if (_pAppAdmin) {
        hr = _pAppAdmin->DeleteApplication((LPWSTR)_pszMetaBasePath, TRUE);
    }

    else if (_pWamAdmin) {
        hr = _pWamAdmin->AppDelete((LPWSTR)_pszMetaBasePath, TRUE);
    }

    else {
        hr = E_NOINTERFACE;
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CIISApp::AppUnLoad
//
//  Synopsis:   
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    07-14-96    SophiaC     Created
//
//----------------------------------------------------------------------------
STDMETHODIMP
CIISApp::AppUnLoad(THIS)
{
    HRESULT hr = S_OK;
    hr = _pWamAdmin->AppUnLoad((LPWSTR)_pszMetaBasePath, FALSE);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CIISApp::AppUnLoadRecursive
//
//  Synopsis:   
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    07-14-96    SophiaC     Created
//
//----------------------------------------------------------------------------
STDMETHODIMP
CIISApp::AppUnLoadRecursive(THIS)
{
    HRESULT hr = S_OK;
    hr = _pWamAdmin->AppUnLoad((LPWSTR)_pszMetaBasePath, TRUE);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CIISApp::AppDisable
//
//  Synopsis:   
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    07-14-96    SophiaC     Created
//
//----------------------------------------------------------------------------
STDMETHODIMP
CIISApp::AppDisable(THIS)
{
    HRESULT hr = S_OK;
    hr = _pWamAdmin->AppDeleteRecoverable((LPWSTR)_pszMetaBasePath, FALSE);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CIISApp::AppDisableRecursive
//
//  Synopsis:   
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    07-14-96    SophiaC     Created
//
//----------------------------------------------------------------------------
STDMETHODIMP
CIISApp::AppDisableRecursive(THIS)
{
    HRESULT hr = S_OK;
    hr = _pWamAdmin->AppDeleteRecoverable((LPWSTR)_pszMetaBasePath, TRUE);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CIISApp::AppGetStatus
//
//  Synopsis:  
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    07/14/96  SophiaC Created
//
//----------------------------------------------------------------------------
STDMETHODIMP
CIISApp::AppGetStatus(THIS_ DWORD * pdwStatus)
{
    HRESULT hr = S_OK;
    hr = _pWamAdmin->AppGetStatus((LPWSTR)_pszMetaBasePath, pdwStatus);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CIISApp::AppGetStatus2
//
//  Synopsis:   AppGetStatus is not automation compliant. This version
//              is.
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CIISApp::AppGetStatus2( LONG * lpStatus )
{
    HRESULT     hr;
    hr = _pWamAdmin->AppGetStatus((LPWSTR)_pszMetaBasePath, (LPDWORD)lpStatus);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CIISApp::AppEnable
//
//  Synopsis:   
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    07-14-96    SophiaC     Created
//
//----------------------------------------------------------------------------
STDMETHODIMP
CIISApp::AppEnable(THIS)
{
    HRESULT hr = S_OK;
    hr = _pWamAdmin->AppRecover((LPWSTR)_pszMetaBasePath, FALSE);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CIISApp::AspAppRestart
//
//  Synopsis:   
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    07-14-96    SophiaC     Created
//
//----------------------------------------------------------------------------
STDMETHODIMP
CIISApp::AspAppRestart(THIS)
{
    HRESULT hr = S_OK;
    DWORD dwState = 0;
    METADATA_HANDLE hObjHandle = NULL;

    hr = IISCheckApp(METADATA_MASTER_ROOT_HANDLE);
    BAIL_ON_FAILURE(hr);

    hr = IISGetState(METADATA_MASTER_ROOT_HANDLE, &dwState);
    BAIL_ON_FAILURE(hr);

    //
    // Write the value to the metabase
    //

    hr = OpenAdminBaseKey(
               _pszServerName,
               _pszMetaBasePath,
               METADATA_PERMISSION_WRITE,
               &_pAdminBase,
               &hObjHandle
               );
    BAIL_ON_FAILURE(hr);

    dwState = dwState ? 0 : 1;
    hr = IISSetState(hObjHandle, dwState);
    BAIL_ON_FAILURE(hr);

    dwState = dwState ? 0 : 1;
    hr = IISSetState(hObjHandle, dwState);
    BAIL_ON_FAILURE(hr);

    CloseAdminBaseKey(_pAdminBase, hObjHandle);

error:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CIISApp::AppEnableRecursive
//
//  Synopsis:   
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    07-14-96    SophiaC     Created
//
//----------------------------------------------------------------------------
STDMETHODIMP
CIISApp::AppEnableRecursive(THIS)
{
    HRESULT hr = S_OK;
    hr = _pWamAdmin->AppRecover((LPWSTR)_pszMetaBasePath, TRUE);
    RRETURN(hr);
}

HRESULT
CIISApp::IISSetState(
    METADATA_HANDLE hObjHandle,
    DWORD dwState
    )
{

    HRESULT hr = S_OK;
    DWORD dwBufferSize = sizeof(DWORD);
    METADATA_RECORD mdrMDData;
    LPBYTE pBuffer = (LPBYTE)&dwState;

    MD_SET_DATA_RECORD(&mdrMDData,
                       MD_ASP_ENABLEAPPLICATIONRESTART,
                       METADATA_INHERIT,
                       ASP_MD_UT_APP,
                       DWORD_METADATA,
                       dwBufferSize,
                       pBuffer);

    hr = _pAdminBase->SetData(
             hObjHandle,
             L"",
             &mdrMDData
             );

    RRETURN(hr);
}

HRESULT
CIISApp::IISCheckApp(
    METADATA_HANDLE hObjHandle
    )
{

    HRESULT hr = S_OK;
    DWORD dwBufferSize;
    METADATA_RECORD mdrMDData;
    LPBYTE pBuffer;
    WCHAR DataBuf[MAX_PATH];
    DWORD dwState;

    pBuffer = (LPBYTE) DataBuf;
    dwBufferSize = MAX_PATH;
    MD_SET_DATA_RECORD(&mdrMDData,
                       MD_APP_ROOT,
                       METADATA_INHERIT|METADATA_ISINHERITED,
                       IIS_MD_UT_FILE,
                       STRING_METADATA,
                       dwBufferSize,
                       pBuffer);

    hr = _pAdminBase->GetData(
             hObjHandle,
             _pszMetaBasePath,
             &mdrMDData,
             &dwBufferSize
             );
    BAIL_ON_FAILURE(hr);

    if (mdrMDData.dwMDAttributes & METADATA_ISINHERITED) {
        hr = MD_ERROR_DATA_NOT_FOUND;
        BAIL_ON_FAILURE(hr);
    }

    pBuffer = (LPBYTE) &dwState;
    dwBufferSize = sizeof(DWORD);
    MD_SET_DATA_RECORD(&mdrMDData,
                       MD_APP_ISOLATED,
                       METADATA_INHERIT|METADATA_ISINHERITED,
                       IIS_MD_UT_WAM,
                       DWORD_METADATA,
                       dwBufferSize,
                       pBuffer);

    hr = _pAdminBase->GetData(
             hObjHandle,
             _pszMetaBasePath,
             &mdrMDData,
             &dwBufferSize
             );
    BAIL_ON_FAILURE(hr);

    if (mdrMDData.dwMDAttributes & METADATA_ISINHERITED) {
        hr = MD_ERROR_DATA_NOT_FOUND;
        BAIL_ON_FAILURE(hr);
    }

error:

    RRETURN(hr);

}

HRESULT
CIISApp::IISGetState(
    METADATA_HANDLE hObjHandle,
    PDWORD pdwState
    )
{

    HRESULT hr = S_OK;
    DWORD dwBufferSize = sizeof(DWORD);
    METADATA_RECORD mdrMDData;
    LPBYTE pBuffer = (LPBYTE)pdwState;

    MD_SET_DATA_RECORD(&mdrMDData,
                       MD_ASP_ENABLEAPPLICATIONRESTART,
                       METADATA_INHERIT,
                       ASP_MD_UT_APP,
                       DWORD_METADATA,
                       dwBufferSize,
                       pBuffer);

    hr = _pAdminBase->GetData(
             hObjHandle,
             _pszMetaBasePath,
             &mdrMDData,
             &dwBufferSize
             );

    RRETURN(hr);

}


STDMETHODIMP
CIISApp::ADSIInitializeDispatchManager(
    long dwExtensionId
    )
{
    HRESULT hr = S_OK;

    if (_fDispInitialized) {

        RRETURN(E_FAIL);
    }

    hr = _pDispMgr->InitializeDispMgr(dwExtensionId);

    if (SUCCEEDED(hr)) {
        _fDispInitialized = TRUE;
    }

    RRETURN(hr);
}

STDMETHODIMP
CIISApp::ADSIInitializeObject(
    THIS_ BSTR lpszUserName,
    BSTR lpszPassword,
    long lnReserved
    )
{

    CCredentials NewCredentials(lpszUserName, lpszPassword, lnReserved);

    _Credentials = NewCredentials;

    RRETURN(S_OK);
}

STDMETHODIMP
CIISApp::ADSIReleaseObject()
{
    delete this;
    RRETURN(S_OK);
}

STDMETHODIMP
CIISApp::NonDelegatingQueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    ASSERT(ppv);

    if (IsEqualIID(iid, IID_IISApp)) {

        *ppv = (IISApp3 FAR *) this;

    } 
    else if (IsEqualIID(iid, IID_IISApp2)) {
        *ppv = (IISApp3 FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IISApp3)) {
        *ppv = (IISApp3 FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsExtension)) {

        *ppv = (IADsExtension FAR *) this;

    } else if (IsEqualIID(iid, IID_IUnknown)) {

        //
        // probably not needed since our 3rd party extension does not stand
        // alone and provider does not ask for this, but to be safe
        //
        *ppv = (INonDelegatingUnknown FAR *) this;

    } else {

        *ppv = NULL;
        return E_NOINTERFACE;
    }


    //
    // Delegating AddRef to aggregator for IADsExtesnion and IISApp.
    // AddRef on itself for IPrivateUnknown.   (both tested.)
    //

    ((IUnknown *) (*ppv)) -> AddRef();

    return S_OK;
}



//
// IADsExtension::Operate()
//

STDMETHODIMP
CIISApp::Operate(
    THIS_ DWORD dwCode,
    VARIANT varUserName,
    VARIANT varPassword,
    VARIANT varFlags
    )
{
    RRETURN(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\iisext\ccomp.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:  ccomp.cxx
//
//  Contents:  Contains methods for CIISComputer object
//
//  History:   20-1-98     SophiaC    Created.
//
//----------------------------------------------------------------------------

#include "iisext.hxx"
#pragma hdrstop


//  Class CIISComputer

DEFINE_IPrivateDispatch_Implementation(CIISComputer)
DEFINE_DELEGATING_IDispatch_Implementation(CIISComputer)
DEFINE_CONTAINED_IADs_Implementation(CIISComputer)
DEFINE_IADsExtension_Implementation(CIISComputer)

CIISComputer::CIISComputer():
        _pUnkOuter(NULL),
        _pADs(NULL),
        _pszServerName(NULL),
        _pszMetaBasePath(NULL),
        _pAdminBase(NULL),
        _pDispMgr(NULL),
        _fDispInitialized(FALSE)
{
    ENLIST_TRACKING(CIISComputer);
}

HRESULT
CIISComputer::CreateComputer(
    IUnknown *pUnkOuter,
    REFIID riid,
    void **ppvObj
    )
{
    CCredentials Credentials;
    CIISComputer FAR * pComputer = NULL;
    HRESULT hr = S_OK;
    BSTR bstrAdsPath = NULL;
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer * pLexer = NULL;
    LPWSTR pszIISPathName  = NULL;

    hr = AllocateComputerObject(pUnkOuter, Credentials, &pComputer);
    BAIL_ON_FAILURE(hr);

    //
    // get ServerName and pszPath
    //

    hr = pComputer->_pADs->get_ADsPath(&bstrAdsPath);
    BAIL_ON_FAILURE(hr);

    pLexer = new CLexer();
    hr = pLexer->Initialize(bstrAdsPath);
    BAIL_ON_FAILURE(hr);

    //
    // Parse the pathname
    //

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = ADsObject(pLexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    pszIISPathName = AllocADsStr(bstrAdsPath);
    if (!pszIISPathName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    *pszIISPathName = L'\0';
    hr = BuildIISPathFromADsPath(
                    pObjectInfo,
                    pszIISPathName
                    );
    BAIL_ON_FAILURE(hr);

    hr = pComputer->InitializeComputerObject(
                pObjectInfo->TreeName,
                pszIISPathName );
    BAIL_ON_FAILURE(hr);

    //
    // pass non-delegating IUnknown back to the aggregator
    //

    *ppvObj = (INonDelegatingUnknown FAR *) pComputer;

    if (bstrAdsPath)
    {
        ADsFreeString(bstrAdsPath);
    }

    if (pLexer) {
        delete pLexer;
    }

    if (pszIISPathName ) {
        FreeADsStr( pszIISPathName );
    }

    FreeObjectInfo( &ObjectInfo );

    RRETURN(hr);

error:

    if (bstrAdsPath) {
        ADsFreeString(bstrAdsPath);
    }

    if (pLexer) {
        delete pLexer;
    }

    if (pszIISPathName ) {
        FreeADsStr( pszIISPathName );
    }

    FreeObjectInfo( &ObjectInfo );

    *ppvObj = NULL;

    delete pComputer;

    RRETURN(hr);

}


CIISComputer::~CIISComputer( )
{
    if (_pszServerName) {
        FreeADsStr(_pszServerName);
    }

    if (_pszMetaBasePath) {
        FreeADsStr(_pszMetaBasePath);
    }

    delete _pDispMgr;
}


STDMETHODIMP
CIISComputer::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    HRESULT hr = S_OK;
   
    hr = _pUnkOuter->QueryInterface(iid,ppv);

    RRETURN(hr);
}

HRESULT
CIISComputer::AllocateComputerObject(
    IUnknown *pUnkOuter,
    CCredentials& Credentials,
    CIISComputer ** ppComputer
    )
{
    CIISComputer FAR * pComputer = NULL;
    IADs FAR *  pADs = NULL;
    CAggregateeDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pComputer = new CIISComputer();
    if (pComputer == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregateeDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                LIBID_IISExt,
                IID_IISComputer2,
                (IISComputer2 *)pComputer,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    //
    // Store the IADs Pointer, but again do NOT ref-count
    // this pointer - we keep the pointer around, but do
    // a release immediately.
    //
 
    hr = pUnkOuter->QueryInterface(IID_IADs, (void **)&pADs);
    pADs->Release();
    pComputer->_pADs = pADs;

    //
    // Store the pointer to the pUnkOuter object
    // AND DO NOT add ref this pointer
    //
    pComputer->_pUnkOuter = pUnkOuter;
  
    pComputer->_Credentials = Credentials;
    pComputer->_pDispMgr = pDispMgr;
    *ppComputer = pComputer;

    RRETURN(hr);

error:

    delete  pDispMgr;
    delete  pComputer;

    RRETURN(hr);
}

HRESULT
CIISComputer::InitializeComputerObject(
    LPWSTR pszServerName,
    LPWSTR pszPath
    )
{
    HRESULT hr = S_OK;

    if (pszServerName) {
        _pszServerName = AllocADsStr(pszServerName);

        if (!_pszServerName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    if (pszPath) {
        _pszMetaBasePath = AllocADsStr(pszPath);

        if (!_pszMetaBasePath) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    hr = InitServerInfo(pszServerName, &_pAdminBase);
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   CIISComputer::Backup
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    07/14/97  SophiaC    Created
//
// Notes:
//----------------------------------------------------------------------------

STDMETHODIMP
CIISComputer::Backup(
    BSTR bstrLocation,
    LONG lVersion,
    LONG lFlags
    )
{
    HRESULT hr = S_OK;
    hr =  _pAdminBase->Backup((LPWSTR)bstrLocation,
                               lVersion,
                               lFlags);
    RRETURN(hr);
}

STDMETHODIMP
CIISComputer::BackupWithPassword(
    BSTR bstrLocation,
    LONG lVersion,
    LONG lFlags,
    BSTR bstrPassword
    )
{
	HRESULT hr = S_OK;
	IMSAdminBase2 * pInterface2 = NULL;
	if (SUCCEEDED(hr = _pAdminBase->QueryInterface(IID_IMSAdminBase2, (void **)&pInterface2)))
	{
		hr = pInterface2->BackupWithPasswd(bstrLocation, lVersion, lFlags, bstrPassword);
		pInterface2->Release();
	}
    
    RRETURN(hr);
}

STDMETHODIMP
CIISComputer::SaveData()
{
    HRESULT hr = S_OK;

    hr = _pAdminBase->SaveData();

    RRETURN(hr);
}

STDMETHODIMP
CIISComputer::Export(
	BSTR bstrPassword,
	BSTR bstrFilename,
	BSTR bstrSourcePath,
	LONG lFlags
	)
{
	HRESULT hr = S_OK;
	IMSAdminBase2 * pInterface2 = NULL;
	if (SUCCEEDED(hr = _pAdminBase->QueryInterface(IID_IMSAdminBase2, (void **)&pInterface2)))
	{
		hr = pInterface2->Export(bstrPassword, bstrFilename, bstrSourcePath, lFlags);
		pInterface2->Release();
	}

	RRETURN(hr);
}

STDMETHODIMP
CIISComputer::Import(
	BSTR bstrPassword,
	BSTR bstrFilename,
	BSTR bstrSourcePath,
	BSTR bstrDestPath,
	LONG lFlags
	)
{
	HRESULT hr = S_OK;
	IMSAdminBase2 * pInterface2 = NULL;
	if (SUCCEEDED(hr = _pAdminBase->QueryInterface(IID_IMSAdminBase2, (void **)&pInterface2)))
	{
		hr = pInterface2->Import(bstrPassword, bstrFilename, bstrSourcePath, bstrDestPath, lFlags);
		pInterface2->Release();
	}

	RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CIISComputer::Restore
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    07/14/96 SophiaC  Created
//
//----------------------------------------------------------------------------


STDMETHODIMP
CIISComputer::Restore(
    BSTR bstrLocation,
    LONG lVersion,
    LONG lFlags
    )
{
    HRESULT hr = S_OK;

    hr =  _pAdminBase->Restore((LPWSTR)bstrLocation,
                               lVersion,
                               lFlags);

    RRETURN(hr);
}

STDMETHODIMP
CIISComputer::RestoreWithPassword(
    BSTR bstrLocation,
    LONG lVersion,
    LONG lFlags,
    BSTR bstrPassword
    )
{
	HRESULT hr = S_OK;

	IMSAdminBase2 * pInterface2 = NULL;

	if (SUCCEEDED(hr = _pAdminBase->QueryInterface(IID_IMSAdminBase2, (void **)&pInterface2)))
	{
		hr = pInterface2->RestoreWithPasswd(bstrLocation, lVersion, lFlags, bstrPassword);
		pInterface2->Release();
	}

   RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CIISComputer::EnumBackups
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    07-14-96    SophiaC     Created
//
//----------------------------------------------------------------------------


STDMETHODIMP
CIISComputer::EnumBackups(
    BSTR bstrLocation,
    LONG lIndex,
    VARIANT *pvVersion,
    VARIANT *pvLocation,
    VARIANT *pvDate
    )
{
    HRESULT hr = S_OK;
    FILETIME ftBackupTime;
    WORD wFatDate;
    WORD wFatTime;
    WCHAR Location[MD_BACKUP_MAX_LEN];
    DWORD dwVersion;

    VariantInit( pvVersion );
    VariantInit( pvLocation );
    VariantInit( pvDate );

    Location[0] = L'\0';

    if (bstrLocation) {
        wcscpy((LPWSTR)Location, (LPWSTR)bstrLocation);
    }

    hr = _pAdminBase->EnumBackups((LPWSTR)Location,
                                  (PDWORD)&dwVersion,
                                  &ftBackupTime,
                                  lIndex);

    if (SUCCEEDED(hr)) {

        pvVersion->vt = VT_I4;
        pvLocation->vt = VT_BSTR;
        pvDate->vt = VT_DATE;

        if (!FileTimeToDosDateTime( &ftBackupTime, &wFatDate, &wFatTime)){
            hr = HRESULT_FROM_WIN32(GetLastError());
            BAIL_ON_FAILURE(hr);
        }

        if (!DosDateTimeToVariantTime(wFatDate, wFatTime, &pvDate->date)){
            hr = HRESULT_FROM_WIN32(GetLastError());
            BAIL_ON_FAILURE(hr);
        }

        pvVersion->lVal = (long)dwVersion;

        hr = ADsAllocString(
                (LPWSTR)Location,
                &pvLocation->bstrVal
                );
    }

error :

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CIISComputer::DeleteBackup
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    07/14/96  SophiaC Created
//
//----------------------------------------------------------------------------


STDMETHODIMP
CIISComputer::DeleteBackup(
    BSTR bstrLocation,
    LONG lVersion
    )
{
    HRESULT hr = S_OK;
    hr =  _pAdminBase->DeleteBackup((LPWSTR)bstrLocation,
                                    lVersion
                                    );
    RRETURN(hr);
}


STDMETHODIMP
CIISComputer::ADSIInitializeDispatchManager(
    long dwExtensionId
    )
{
    HRESULT hr = S_OK;

    if (_fDispInitialized) {

        RRETURN(E_FAIL);
    }

    hr = _pDispMgr->InitializeDispMgr(dwExtensionId);

    if (SUCCEEDED(hr)) {
        _fDispInitialized = TRUE;
    }

    RRETURN(hr);
}


STDMETHODIMP
CIISComputer::ADSIInitializeObject(
    THIS_ BSTR lpszUserName,
    BSTR lpszPassword,
    long lnReserved
    )
{
    CCredentials NewCredentials(lpszUserName, lpszPassword, lnReserved);

    _Credentials = NewCredentials;

    RRETURN(S_OK);
}


STDMETHODIMP
CIISComputer::ADSIReleaseObject()
{
    delete this;
    RRETURN(S_OK);
}


STDMETHODIMP
CIISComputer::NonDelegatingQueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    ASSERT(ppv);
    
    if (IsEqualIID(iid, IID_IISComputer)) {

        *ppv = (IADsUser FAR *) this;

    } else if (IsEqualIID(iid, IID_IISComputer2)) {

        *ppv = (IADsUser FAR *) this;

    } else if (IsEqualIID(iid, IID_IADsExtension)) {

        *ppv = (IADsExtension FAR *) this;
                                
    } else if (IsEqualIID(iid, IID_IUnknown)) {
        
        //
        // probably not needed since our 3rd party extension does not stand 
        // alone and provider does not ask for this, but to be safe
        //
        *ppv = (INonDelegatingUnknown FAR *) this;

    } else {
        
        *ppv = NULL;
        return E_NOINTERFACE;
    } 


    //
    // Delegating AddRef to aggregator for IADsExtesnion and IISComputer.
    // AddRef on itself for IPrivateUnknown.   (both tested.)
    //

    ((IUnknown *) (*ppv)) -> AddRef();       

    return S_OK;
}


//
// IADsExtension::Operate()
//

STDMETHODIMP
CIISComputer::Operate(
    THIS_ DWORD dwCode,
    VARIANT varUserName,
    VARIANT varPassword,
    VARIANT varFlags
    )
{
    RRETURN(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\iisext\ccompcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  ccompcf.cxx
//
//  Contents:  IIS Computer Object Class Factory Code
//
//             CIISComputerCF::CreateInstance
//
//----------------------------------------------------------------------------
#include "iisext.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CIISComputerCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CIISComputerCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = S_OK;

    if (!pUnkOuter)
        RRETURN(E_FAIL);

    hr = CIISComputer::CreateComputer(
                pUnkOuter,
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\iisext\cdispmgr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       cdispmgr.cxx
//
//  Contents:   The dispatch manager -- a class to manage
//		multiple IDispatch-callable interfaces.
//
//  Classes:	CAggregateeDispMgr
//
//  Functions:	None external.
//
//  History:    ??-???-??   KrishnaG   created
//		07-Sep-97   t-blakej   Commented, cleaned up, made
//                                     independent of ADSI.
//
//  See cdispmgr.hxx for a more thorough description of the dispatch manager.
//
//----------------------------------------------------------------------------

//
// Since this class is useful outside of ADSI, some work has been taken to
// make it not depend on any ADSI-specific code.  It needs two ADSI header
// files (cdispmgr.hxx and iprops.hxx), but they only depend on definitions
// from standard system header files.
//
// To accomodate the current building method in ADSI, the precompiled
// header "procs.hxx" is included; this includes all the necessary ADSI
// header files and definitions.  But for use outside of ADSI, the few
// necessary header files are explicitly included below; see the comment by
// "#ifndef ADsAssert".
//
// So if not compiling for ADSI, comment the following two lines out.
//

#include "iisext.hxx"
#pragma hdrstop

//////////////////////////////////////////////////////////////////////////////
//
// General helper definitions, routines, and inclusions:

// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-	Begin Non-ADSI compile stuff
//
// This macro is defined by the precompiled header file, so the following
// will only be included if not compiling for ADSI.
//
#ifndef ADsAssert

//
// Necessary system headers.
//
#define UNICODE
#define _UNICODE
#define _OLEAUT32_
#define INC_OLE2
#include <windows.h>
#include <stdio.h>

//
// Necessary class definitions used by the dispatch manager.
// Edit these paths if necessary.
//
#include "cdispmgr.hxx"
#include "iprops.hxx"

#endif	// ADsAssert
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-	End Non-ADSI compile stuff

//
// A simple assert function.
//
#if DBG == 1
//+---------------------------------------------------------------------------
//
//  Function:   AssertEx
//
//  Synopsis:   Display assertion information.
//
//  Effects:    Called when an assertion is hit.
//
//  History:	Simplified from Win4AssertEx, to make this dispatch manager
//  		not depend on other files.
//
//----------------------------------------------------------------------------
static void
AssertEx(char const *szFile, int iLine, char const *szMessage)
{
    static char szAssertCaption[100];

    sprintf(szAssertCaption, "File: %s line %u, thread id %d",
	szFile, iLine, GetCurrentThreadId());

    if (IDCANCEL == MessageBoxA(
                NULL,
                (char *) szMessage,
                (LPSTR) szAssertCaption,
                MB_SETFOREGROUND |
                MB_TASKMODAL | MB_ICONEXCLAMATION | MB_OKCANCEL
                ))
    {
	DebugBreak();
    }
}
# define DispMgrAssert(x)  (void)((x) || (AssertEx(__FILE__, __LINE__, #x),0))
#else
# define AssertEx(f,l,m)   
# define DispMgrAssert(x)  
#endif

//////////////////////////////////////////////////////////////////////////////
//
// Inline routines:

static inline LONG
getDispMgrId(DISPID InputDispId)
{
    return (InputDispId & 0x7f000000) >> 24;
}

static inline LONG
getTypeInfoId(DISPID InputDispId)
{
    return (InputDispId & 0x00ff0000) >> 16;
}

static inline LONG
getDispId(DISPID InputDispId)
{
    return (InputDispId & 0x0000ffff);
}

static inline void
MakeDISPID(
    LONG ExtensionId,
    LONG TypeInfoId,
    LONG DispId,
    DISPID *pResult
    )
{
    if (DispId == DISPID_UNKNOWN){

    	*pResult = DispId;

    }else if (TypeInfoId < 0 || TypeInfoId >= 0x100 ||
	                DispId < 0 || DispId >= 0x10000){

	    //
	    // Might happen if some object has very large dispid's.
	    // But we can't handle it if it does.
	    //
	    *pResult = DISPID_UNKNOWN;
    }
    else{

	    *pResult = ((ExtensionId & 0xff) << 24) |((TypeInfoId & 0xff) << 16) | (DispId & 0xffff);

    }

}


static inline void
MakeDISPIDs(
    LONG ExtensionId,
    LONG TypeInfoId,
    DISPID *rgdispid,
    unsigned int cNames
    )
{
    for (unsigned int i = 0; i < cNames; i++)
    {
        MakeDISPID(ExtensionId, TypeInfoId, rgdispid[i], &rgdispid[i]);
    }
}

//////////////////////////////////////////////////////////////////////////////
//
// Public methods:

CAggregateeDispMgr::CAggregateeDispMgr()
{
    _pTypeInfoEntry = NULL;
    _pDispidNewEnum = NULL;
    _dwTypeInfoId = 0;
    _pDispidValue = NULL;
    _pPropertyCache = NULL;
    _dwPropCacheID = 0;
    _dwExtensionID = 0;
}

CAggregateeDispMgr::~CAggregateeDispMgr()
{
    PTYPEINFOENTRY pTypeInfoEntry = NULL;
    PTYPEINFOENTRY pTemp = NULL;
    ITypeInfo *pTypeInfo = NULL;

    pTypeInfoEntry = _pTypeInfoEntry;

    while (pTypeInfoEntry) {

        pTemp = pTypeInfoEntry;

        pTypeInfo = (ITypeInfo *)pTypeInfoEntry->ptypeinfo;
        pTypeInfo->Release();

        pTypeInfoEntry = pTemp->pNext;

        LocalFree(pTemp);
    }

}

void
CAggregateeDispMgr::RegisterPropertyCache(IPropertyCache *pPropertyCache)
{
    _pPropertyCache = pPropertyCache;
    _dwPropCacheID = gentypeinfoid();
}


STDMETHODIMP
CAggregateeDispMgr::GetTypeInfoCount(unsigned int *pctinfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CAggregateeDispMgr::GetTypeInfo(unsigned int itinfo, LCID lcid, ITypeInfo **pptinfo)
{
    return E_NOTIMPL;
}

//
// This works only for single names; if multiple names are
// passed we die big time. This is help us get going using VB's _NewEnum
//

STDMETHODIMP
CAggregateeDispMgr::GetIDsOfNames(REFIID iid, LPWSTR *rgszNames,
        unsigned int cNames, LCID lcid, DISPID *rgdispid)
{
    PTYPEINFOENTRY pTypeInfo = NULL;
    HRESULT hr = DISP_E_UNKNOWNNAME;

    //
    // Try our list of TypeInfos.
    //
    pTypeInfo = _pTypeInfoEntry;
    while (pTypeInfo) {
        hr = DispGetIDsOfNames(((ITypeInfo *)pTypeInfo->ptypeinfo),
                                rgszNames,
                                cNames,
                                rgdispid
                                );
        if (SUCCEEDED(hr)) {

            // 
            // aggregatee no longer needs to include extension id
            // in dispid.  
            // TODO: change function to get rid of ext id = 0 during clean up
            //

            MakeDISPIDs(0, pTypeInfo->TypeInfoId, rgdispid, cNames);
            return hr;
        }
        pTypeInfo = pTypeInfo->pNext;
    }

    //
    // Try our property cache.
    //
    if (FAILED(hr) && _pPropertyCache) {
	hr = S_OK;
	for (DWORD dw = 0; dw < cNames; dw++) {
	    if (FAILED(_pPropertyCache->locateproperty(rgszNames[dw],
		    (PDWORD)(rgdispid + dw)))) {
		hr = DISP_E_UNKNOWNNAME;
		rgdispid[dw] = DISPID_UNKNOWN;
	    }
	}
	if (SUCCEEDED(hr)) {

            // 
            // aggregatee no longer needs to include extension id
            // in dispid.  
            // TODO: change function to get rid of ext id = 0 during clean up
            //

	    MakeDISPIDs(0, _dwPropCacheID, rgdispid, cNames);
	}
    }

    return hr;
}

STDMETHODIMP
CAggregateeDispMgr::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,
	unsigned short wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
	EXCEPINFO *pexcepinfo, unsigned int *puArgErr)
{
        //
        // Clear the error object before we call invoke.
        //
        SetErrorInfo(0, NULL);

        return TypeInfoInvoke(dispidMember,
                               iid,
                               lcid,
                               wFlags,
                               pdispparams,
                               pvarResult,
                               pexcepinfo,
                               puArgErr
                               );
}

//////////////////////////////////////////////////////////////////////////////
//
// Private methods and helper functions:

void *
CAggregateeDispMgr::getInterfacePtr(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry = FindTypeInfoEntry(TypeInfoId);
    return (pTypeInfoEntry ? pTypeInfoEntry->pInterfacePointer : NULL);
}

ITypeInfo *
CAggregateeDispMgr::getTypeInfo(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry = FindTypeInfoEntry(TypeInfoId);
    return (ITypeInfo *)(pTypeInfoEntry ? pTypeInfoEntry->ptypeinfo : NULL);
}

PTYPEINFOENTRY
CAggregateeDispMgr::FindTypeInfoEntry(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    pTypeInfoEntry = _pTypeInfoEntry;
    while (pTypeInfoEntry) {
        if (pTypeInfoEntry->TypeInfoId == TypeInfoId) {
            return pTypeInfoEntry;
        }
        pTypeInfoEntry = pTypeInfoEntry->pNext;
    }
    return NULL;
}

PTYPEINFOENTRY
CAggregateeDispMgr::FindTypeInfo(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    pTypeInfoEntry = _pTypeInfoEntry;
    while (pTypeInfoEntry) {
        if (pTypeInfoEntry->ptypeinfo == pTypeInfo) {
            return pTypeInfoEntry;
        }
        pTypeInfoEntry = pTypeInfoEntry->pNext;
    }
    return NULL;
}

HRESULT
CAggregateeDispMgr::AddTypeInfo(void *ptypeinfo, void *pIntfptr)
{
    PTYPEINFOENTRY pTypeInfoEntry = NULL;
    HRESULT hr;

    if (FindTypeInfo(ptypeinfo)) {
        return E_FAIL;
    }
    pTypeInfoEntry = (PTYPEINFOENTRY)LocalAlloc(LPTR,sizeof(TYPEINFOENTRY));
    if (!pTypeInfoEntry) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pTypeInfoEntry->ptypeinfo = ptypeinfo;
    pTypeInfoEntry->TypeInfoId = gentypeinfoid();
    pTypeInfoEntry->pInterfacePointer = pIntfptr;

    pTypeInfoEntry->pNext = _pTypeInfoEntry;
    _pTypeInfoEntry = pTypeInfoEntry;

    return S_OK;

error:
    return hr;
}

STDMETHODIMP
CAggregateeDispMgr::TypeInfoInvoke(DISPID dispidMember, REFIID iid, LCID lcid,
	unsigned short wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
	EXCEPINFO *pexcepinfo, unsigned int *puArgErr)
{
    void *pInterfacePtr = NULL;
    DISPID dispid = 0;
    DISPID typeinfoid = 0;
    ITypeInfo *pTypeInfo = NULL;
    HRESULT hr = S_OK;

    if (dispidMember <= 0) {

    	//
	    // One of the special DISPIDs.
	    //
	    // If we have an interface pointer for it, use that.
	    // If we don't, and we have a base IDispatch pointer,
	    //   pass it to the base pointer's Invoke() method.
	    // If we don't, and we don't have a base IDispatch pointer,
	    //   return failure.
	    //

        dispid = dispidMember;
        switch (dispid) {

        case DISPID_VALUE:
            if (_pDispidValue) {
                pTypeInfo = (ITypeInfo *)_pDispidValue->ptypeinfo;
                pInterfacePtr = _pDispidValue->pInterfacePointer;
            }
	    break;

        case DISPID_NEWENUM:
            if (_pDispidNewEnum) {
                pTypeInfo = (ITypeInfo *)_pDispidNewEnum->ptypeinfo;
                pInterfacePtr = _pDispidNewEnum->pInterfacePointer;
            }
            break;

        default:
            break;
        }

	    if (!pInterfacePtr) {

	        BAIL_ON_FAILURE(hr = DISP_E_MEMBERNOTFOUND);

	    }else {

            //
            // Fill in the special case scenarios here
            //

            hr = DispInvoke(
                    pInterfacePtr,
                    pTypeInfo,
                    dispid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );

            return(hr);

        }

    } else {

        //                           	
	    // A regular DISPID of ours.
	    //

        typeinfoid = getTypeInfoId(dispidMember);
        dispid = getDispId(dispidMember);

	    if ((_pPropertyCache == NULL) || (typeinfoid != _dwPropCacheID)) {
	        pInterfacePtr = getInterfacePtr(typeinfoid);
	        pTypeInfo = getTypeInfo(typeinfoid);
	        if (!pTypeInfo)
		        //
		    // Shouldn't happen.
		    //
		    BAIL_ON_FAILURE(hr = DISP_E_MEMBERNOTFOUND);
	    }

        if ((_pPropertyCache == NULL) || (typeinfoid != _dwPropCacheID)) {

            //
            // A regular interface.
            //

            hr = DispInvoke(
                    pInterfacePtr,
                    pTypeInfo,
                    dispid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );
        }else {

            //
            // A "dynamic DISPID", for the property cache.
            //

            hr = AggregateeDynamicDispidInvoke(
                        _pPropertyCache,
                        dispid,
                        wFlags,
                        pdispparams,
                        pvarResult
                        );

        }

    }

error:
    return hr;
}


HRESULT
AggregateeDynamicDispidInvoke(
    IPropertyCache * pPropertyCache,
    DISPID  dispid,
    unsigned short wFlags,
    DISPPARAMS *pdispparams,
    VARIANT * pvarResult
    )
{
    HRESULT hr = S_OK;

    if (!pPropertyCache) {

        return(E_INVALIDARG);
    }

    if (wFlags & DISPATCH_PROPERTYGET) {

        if (!pvarResult) {
            BAIL_ON_FAILURE(hr = E_INVALIDARG);
        }

        hr = pPropertyCache->getproperty((DWORD)dispid,pvarResult);

        if (FAILED(hr)) {

#if 1
            // This lets us return S_OK and a VT_EMPTY variant if
            // there's no data.  #if this out to disable it.
            V_VT(pvarResult) = VT_EMPTY;
            hr = S_OK;
#else

            V_VT(pvarResult) = VT_ERROR;
#endif

        }
    }else if (wFlags & DISPATCH_PROPERTYPUT) {

        //
        // only handles one argument.
        //

        if (pdispparams[0].cArgs != 1){
            hr = DISP_E_BADPARAMCOUNT;
        }
        else {

            hr = pPropertyCache->putproperty(
                        (DWORD)dispid,
                        pdispparams[0].rgvarg[0]
                        );
        }

    }else {
        hr = E_INVALIDARG;
    }

error:
    return(hr);

}


HRESULT
CAggregateeDispMgr::MarkAsNewEnum(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    if (!pTypeInfo) {
        return E_FAIL;
    }
    if (!(pTypeInfoEntry = FindTypeInfo(pTypeInfo))) {
        return E_FAIL;
    }
    _pDispidNewEnum = pTypeInfoEntry;
    return S_OK;
}

HRESULT
CAggregateeDispMgr::MarkAsItem(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    if (!pTypeInfo) {
        return E_FAIL;
    }
    if (!(pTypeInfoEntry = FindTypeInfo(pTypeInfo))) {
        return E_FAIL;
    }
    _pDispidValue = pTypeInfoEntry;
    return S_OK;
}

LONG
CAggregateeDispMgr::gentypeinfoid()
{
    //
    // This would mean we've registered 65536 IDispatch methods
    //   in this object's dispatch manager.  We lose.
    //
    DispMgrAssert(_dwTypeInfoId < 0xffff);

    return (_dwTypeInfoId++);
}

typedef struct _typeinfotable
{
    GUID iid;
    ITypeInfo * pTypeInfo;
    struct _typeinfotable *pNext;
}TYPEINFO_TABLE, *PTYPEINFO_TABLE;


ITypeInfo *
AggregateeFindTypeInfo(
    PTYPEINFO_TABLE pTypeInfoTable,
    REFIID iid
    )
{
    PTYPEINFO_TABLE pTemp = NULL;

    pTemp = pTypeInfoTable;

    while (pTemp) {
        if (IsEqualIID(iid, pTemp->iid)) {
            return pTemp->pTypeInfo;
        }
        pTemp = pTemp->pNext;
    }
    return NULL;
}

//+------------------------------------------------------------------------
//
//  Function:   LoadTypeInfo
//
//  Synopsis:   Loads a typeinfo from a registered typelib.
//
//  Arguments:  [clsidTL] --  TypeLib GUID
//              [clsidTI] --  TypeInfo GUID
//              [ppTI]    --  Resulting typeInfo
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
AggregateeLoadTypeInfo(CLSID clsidTL, CLSID clsidTI, LPTYPEINFO *ppTI)
{
    HRESULT     hr;
    ITypeLib *  pTL;

    DispMgrAssert(ppTI);
    *ppTI = NULL;
    hr = LoadRegTypeLib(clsidTL, 1, 0, LOCALE_SYSTEM_DEFAULT, &pTL);
    if (hr)
        return hr;

    hr = pTL->GetTypeInfoOfGuid(clsidTI, ppTI);
    pTL->Release();
    return hr;
}

HRESULT
CAggregateeDispMgr::LoadTypeInfoEntry(
    REFIID libid,
    REFIID iid,
    void * pIntf,
    DISPID SpecialId
    )
{
    ITypeInfo * pTypeInfo = NULL;
    HRESULT hr;

    hr = AggregateeLoadTypeInfo(libid, iid, &pTypeInfo);
    BAIL_ON_FAILURE(hr);

    hr = AddTypeInfo(pTypeInfo, pIntf);
    BAIL_ON_FAILURE(hr);

    if (SpecialId == -4) {
	hr = MarkAsNewEnum(pTypeInfo);
    } else if (SpecialId == DISPID_VALUE) {
	hr = MarkAsItem(pTypeInfo);
    }

    return S_OK;

error:
    if (pTypeInfo)
	pTypeInfo->Release();

    return hr;
}

//
// Kept for backwards compatibility.
//
HRESULT
LoadTypeInfoEntry(
    CAggregateeDispMgr *pDispMgr,
    REFIID libid,
    REFIID iid,
    void * pIntf,
    DISPID SpecialId
    )
{
    return pDispMgr->LoadTypeInfoEntry(libid, iid, pIntf, SpecialId);
}

HRESULT
CAggregateeDispMgr::InitializeDispMgr(
    DWORD dwExtensionID
    )
{
    if (dwExtensionID > 255) {
        return(E_FAIL);
    }
    _dwExtensionID = dwExtensionID;

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\iisext\cmacro.h ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cmacro.h
//
//  Contents:  Macros for adsi methods
//
//  History:   21-04-97     sophiac    Created.
//
//----------------------------------------------------------------------------

#define DEFINE_CONTAINED_IADs_Implementation(cls)                   \
STDMETHODIMP                                                          \
cls::get_Name(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(_pADs->get_Name(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_ADsPath(THIS_ BSTR FAR* retval)                              \
{                                                                     \
                                                                      \
    RRETURN(_pADs->get_ADsPath(retval));                            \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Class(THIS_ BSTR FAR* retval)                                \
{                                                                     \
                                                                      \
    RRETURN(_pADs->get_Class(retval));                              \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Parent(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(_pADs->get_Parent(retval));                             \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Schema(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(_pADs->get_Schema(retval));                             \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_GUID(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(_pADs->get_GUID(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Get(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                    \
{                                                                     \
    RRETURN(_pADs->Get(bstrName, pvProp));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Put(THIS_ BSTR bstrName, VARIANT vProp)                          \
{                                                                     \
    RRETURN(_pADs->Put(bstrName, vProp));                             \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::GetEx(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                  \
{                                                                     \
    RRETURN(_pADs->GetEx(bstrName, pvProp));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::PutEx(THIS_ long lnControlCode, BSTR bstrName, VARIANT vProp)    \
{                                                                     \
    RRETURN(_pADs->PutEx(lnControlCode, bstrName, vProp));            \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetInfo(THIS_)                                                   \
{                                                                     \
    RRETURN(_pADs->GetInfo());                                        \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::SetInfo(THIS_ )                                                  \
{                                                                     \
    RRETURN(_pADs->SetInfo());                                        \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)            \
{                                                                     \
    RRETURN(_pADs->GetInfoEx(vProperties, lnReserved));               \
}


#define DEFINE_CONTAINED_IDSObject_Implementation(cls)                \
STDMETHODIMP                                                          \
cls::SetObjectAttributes(                                             \
    PADS_ATTR_DEF pAttributeEntries,                                  \
    DWORD dwNumAttributes,                                            \
    DWORD *pdwNumAttributesModified                                   \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->SetObjectAttributes(                             \
                        pAttributeEntries,                            \
                        dwNumAttributes,                              \
                        pdwNumAttributesModified                      \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetObjectAttributes(                                             \
    PADS_ATTR_NAME pAttributeNames,                                   \
    DWORD dwNumberAttributes,                                         \
    PADS_ATTR_DEF *ppAttributeEntries,                                \
    DWORD * pdwNumAttributesReturned                                  \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->GetObjectAttributes(                             \
                        pAttributeNames,                              \
                        dwNumberAttributes,                           \
                        ppAttributeEntries,                           \
                        pdwNumAttributesReturned                      \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::CreateDSObject(                                                  \
    LPWSTR pszRDNName,                                                \
    PADS_ATTR_DEF pAttributeEntries,                                  \
    DWORD dwNumAttributes                                             \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->CreateDSObject(                                  \
                        pszRDNName,                                   \
                        pAttributeEntries,                            \
                        dwNumAttributes                               \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::DeleteDSObject(                                                  \
    LPWSTR pszRDNName                                                 \
    )                                                                 \
                                                                      \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->DeleteDSObject(                                  \
                        pszRDNName                                    \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetObjectInformation(                                            \
    THIS_ PADS_OBJECT_INFO  *  ppObjInfo                              \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->GetObjectInformation(                            \
                            ppObjInfo                                 \
                            );                                        \
    RRETURN(hr);                                                      \
}

#define DEFINE_CONTAINED_IADsContainer_Implementation(cls)          \
STDMETHODIMP                                                          \
cls::get_Filter(THIS_ VARIANT FAR* pVar )                             \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->get_Filter( pVar );                    \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::put_Filter(THIS_ VARIANT Var )                                   \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->put_Filter( Var );                     \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Hints(THIS_ VARIANT FAR* pVar )                              \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->get_Hints( pVar );                     \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::put_Hints(THIS_ VARIANT Var )                                    \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->put_Hints( Var );                      \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Count(THIS_ long FAR* retval)                                \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->get_Count( retval );                   \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get__NewEnum(THIS_ IUnknown * FAR * retval )                     \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->get__NewEnum( retval );                \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetObject(THIS_ BSTR ClassName, BSTR RelativeName,               \
               IDispatch * FAR * ppObject )                           \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->GetObject( ClassName, RelativeName, ppObject ); \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Create(THIS_ BSTR ClassName, BSTR RelativeName,                  \
            IDispatch * FAR * ppObject )                               \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr =_pADsContainer->Create( ClassName, RelativeName, ppObject );  \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Delete(THIS_ BSTR ClassName, BSTR SourceName )                   \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->Delete( ClassName, SourceName );       \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::CopyHere(THIS_ BSTR SourceName, BSTR NewName,                    \
              IDispatch * FAR * ppObject )                            \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                           \
        hr = _pADsContainer->CopyHere( SourceName, NewName, ppObject );  \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::MoveHere(THIS_ BSTR SourceName, BSTR NewName,                    \
              IDispatch * FAR * ppObject )                            \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                           \
        hr = _pADsContainer->MoveHere( SourceName, NewName, ppObject );  \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     

#define DEFINE_CONTAINED_IIsBaseObject_Implementation(cls)            \
STDMETHODIMP                                                          \
cls::GetDataPaths(THIS_ BSTR bstrName, LONG lnAttribute,              \
                  VARIANT FAR* pvProp)                                \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pIIsBaseObject) {                                           \
        hr = _pIIsBaseObject->GetDataPaths( bstrName, lnAttribute, pvProp);   \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetPropertyAttribObj(THIS_ BSTR bstrName,                        \
                          IDispatch * FAR *ppObject)                  \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pIIsBaseObject) {                                           \
        hr = _pIIsBaseObject->GetPropertyAttribObj(bstrName, ppObject); \
    }                                                                 \
    RRETURN(hr);                                                      \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\iisext\crmapcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  crmapcf.cxx
//
//  Contents:  IIS cert mapper Object Class Factory Code
//
//             CIIScert mapperCF::CreateInstance
//
//----------------------------------------------------------------------------
#include "iisext.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CIISDsCrMapCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CIISDsCrMapCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = S_OK;

    if (!pUnkOuter)
        RRETURN(E_FAIL);

    hr = CIISDsCrMap::Create(
                pUnkOuter,
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\iisext\csrv.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:  csrv.cxx
//
//  Contents:  Contains methods for CIISServer object
//
//  History:   21-1-98     SophiaC    Created.
//
//----------------------------------------------------------------------------

#include "iisext.hxx"
#pragma hdrstop

//
// Period to sleep while waiting for service to attain desired state
//
#define SLEEP_INTERVAL (500L)
#define MAX_SLEEP_INST (60000)       // For an instance

//  Class CIISServer

DEFINE_IPrivateDispatch_Implementation(CIISServer)
DEFINE_DELEGATING_IDispatch_Implementation(CIISServer)
DEFINE_CONTAINED_IADs_Implementation(CIISServer)
DEFINE_IADsExtension_Implementation(CIISServer)

CIISServer::CIISServer():
        _pUnkOuter(NULL),
        _pADs(NULL),
        _pszServerName(NULL),
        _pszMetaBasePath(NULL),
		_pAdminBase(NULL),
        _pDispMgr(NULL),
        _fDispInitialized(FALSE)
{
    ENLIST_TRACKING(CIISServer);
}

HRESULT
CIISServer::CreateServer(
    IUnknown *pUnkOuter,
    REFIID riid,
    void **ppvObj
    )
{
    CCredentials Credentials;
    CIISServer FAR * pServer = NULL;               
    HRESULT hr = S_OK;
    BSTR bstrAdsPath = NULL;
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer * pLexer = NULL;
    LPWSTR pszIISPathName = NULL;   

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));

    hr = AllocateServerObject(pUnkOuter, Credentials, &pServer);
    BAIL_ON_FAILURE(hr);

    //
    // get ServerName and pszPath
    //

    hr = pServer->_pADs->get_ADsPath(&bstrAdsPath);
    BAIL_ON_FAILURE(hr);

    pLexer = new CLexer();
    hr = pLexer->Initialize(bstrAdsPath);
    BAIL_ON_FAILURE(hr);

    //
    // Parse the pathname
    //

    hr = ADsObject(pLexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);
    pszIISPathName = AllocADsStr(bstrAdsPath);
    if (!pszIISPathName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    *pszIISPathName = L'\0';
    hr = BuildIISPathFromADsPath(
                    pObjectInfo,
                    pszIISPathName
                    );
    BAIL_ON_FAILURE(hr);

    hr = pServer->InitializeServerObject(
                pObjectInfo->TreeName,
                pszIISPathName );
    BAIL_ON_FAILURE(hr);

    //
    // pass non-delegating IUnknown back to the aggregator
    //

    *ppvObj = (INonDelegatingUnknown FAR *) pServer;

    if (bstrAdsPath)
    {
        ADsFreeString(bstrAdsPath);
    }

    if (pLexer) {
        delete pLexer;
    }

    if (pszIISPathName ) {
        FreeADsStr( pszIISPathName );
    }

    FreeObjectInfo( &ObjectInfo );

    RRETURN(hr);

error:

    if (bstrAdsPath)
    {
        ADsFreeString(bstrAdsPath);
    }

    if (pLexer) {
        delete pLexer;
    }

    if (pszIISPathName ) {
        FreeADsStr( pszIISPathName );
    }

    FreeObjectInfo( &ObjectInfo );

    *ppvObj = NULL;

    delete pServer;

    RRETURN(hr);

}


CIISServer::~CIISServer( )
{

    if (_pszServerName) {
        FreeADsStr(_pszServerName);
    }

    if (_pszMetaBasePath) {
        FreeADsStr(_pszMetaBasePath);
    }

    delete _pDispMgr;
}


STDMETHODIMP
CIISServer::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    HRESULT hr = S_OK;

    hr = _pUnkOuter->QueryInterface(iid,ppv);

    RRETURN(hr); 

}

HRESULT
CIISServer::AllocateServerObject(
    IUnknown *pUnkOuter,
    CCredentials& Credentials,
    CIISServer ** ppServer
    )
{
    CIISServer FAR * pServer = NULL;
    IADs FAR * pADs = NULL;
    CAggregateeDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pServer = new CIISServer();
    if (pServer == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregateeDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                LIBID_ADs,
                IID_IADsServiceOperations,
                (IADsServiceOperations *)pServer,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    //
    // Store the IADs Pointer, but again do NOT ref-count
    // this pointer - we keep the pointer around, but do
    // a release immediately.
    //

    hr = pUnkOuter->QueryInterface(IID_IADs, (void **)&pADs);
    pADs->Release();
    pServer->_pADs = pADs;

    //
    // Store the pointer to the pUnkOuter object
    // AND DO NOT add ref this pointer
    //

    pServer->_pUnkOuter = pUnkOuter;

    //
    // Store the pointer to the internal generic object
    // AND add ref this pointer
    //

    pServer->_Credentials = Credentials;
    pServer->_pDispMgr = pDispMgr;
    *ppServer = pServer;

    RRETURN(hr);

error:

    delete  pDispMgr;
    delete  pServer;

    RRETURN(hr);
}

HRESULT
CIISServer::InitializeServerObject(
    LPWSTR pszServerName,
    LPWSTR pszPath
    )
{
    HRESULT hr = S_OK;

    if (pszServerName) {
        _pszServerName = AllocADsStr(pszServerName);

        if (!_pszServerName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    if (pszPath) {
        _pszMetaBasePath = AllocADsStr(pszPath);

        if (!_pszMetaBasePath) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

	hr = InitServerInfo(pszServerName, &_pAdminBase);
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}


STDMETHODIMP
CIISServer::SetPassword(THIS_ BSTR bstrNewPassword)
{
    RRETURN(E_NOTIMPL);
}


//+---------------------------------------------------------------------------
//
//  Function:   CIISServer::Start
//
//  Synopsis:   Attempts to start the service specified in _bstrServiceName on
//              the server named in _bstrPath.
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    01/04/97  SophiaC    Created
//
// Notes:
//----------------------------------------------------------------------------

STDMETHODIMP
CIISServer::Start(THIS)
{
    RRETURN(IISControlServer(MD_SERVER_COMMAND_START));
}

//+---------------------------------------------------------------------------
//
//  Function:   CIISServer::Stop
//
//  Synopsis:   Attempts to stop the service specified in _bstrServiceName on
//              the server named in _bstrPath.
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    01/04/96 SophiaC  Created
//
//----------------------------------------------------------------------------


STDMETHODIMP
CIISServer::Stop(THIS)
{
    RRETURN(IISControlServer(MD_SERVER_COMMAND_STOP));
}

//+---------------------------------------------------------------------------
//
//  Function:   CIISServer::Pause
//
//  Synopsis:   Attempts to pause the service named _bstrServiceName on the
//              server named in _bstrPath.
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    01-04-96    SophiaC     Created
//
//----------------------------------------------------------------------------


STDMETHODIMP
CIISServer::Pause(THIS)
{
    RRETURN(IISControlServer(MD_SERVER_COMMAND_PAUSE));
}

//+---------------------------------------------------------------------------
//
//  Function:   CIISServer::Continue
//
//  Synopsis:   Attempts to "unpause" the service specified in _bstrServiceName
//              on the server named in _bstrPath.
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    01/04/96  SophiaC Created
//
//----------------------------------------------------------------------------


STDMETHODIMP
CIISServer::Continue(THIS)
{
    RRETURN(IISControlServer(MD_SERVER_COMMAND_CONTINUE));
}

STDMETHODIMP
CIISServer::get_Status(THIS_ long FAR* plStatusCode)
{
    HRESULT hr = S_OK;
    DWORD dwStatus = 0;
    DWORD dwCurrentState = 0;

    if(plStatusCode == NULL){
        RRETURN(E_POINTER);
    }

    hr = IISGetServerState(METADATA_MASTER_ROOT_HANDLE, &dwCurrentState);
    BAIL_ON_FAILURE(hr);

    *plStatusCode = (long) dwCurrentState; 

error:

    RRETURN(hr);
}


//
// Helper Functions
//

HRESULT
CIISServer::IISGetServerState(
    METADATA_HANDLE hObjHandle,
    PDWORD pdwState
    )
{

    HRESULT hr = S_OK;
    DWORD dwBufferSize = sizeof(DWORD);
    METADATA_RECORD mdrMDData;
    LPBYTE pBuffer = (LPBYTE)pdwState;

    MD_SET_DATA_RECORD(&mdrMDData,
                       MD_SERVER_STATE,    // server state
                       METADATA_NO_ATTRIBUTES,
                       IIS_MD_UT_SERVER,
                       DWORD_METADATA,
                       dwBufferSize,
                       pBuffer);

    hr = _pAdminBase->GetData(
             hObjHandle,
             _pszMetaBasePath,
             &mdrMDData,
             &dwBufferSize
             );
    if (FAILED(hr)) {
	    if( hr == MD_ERROR_DATA_NOT_FOUND )
	    {
	        //
	        // If the data is not there, but the path exists, then the
	        // most likely cause is that the service is not running and
	        // this object was just created.
	        //
	        // Since MD_SERVER_STATE would be set as stopped if the
	        // service were running when the key is added, we'll just 
	        // say that it's stopped. 
	        // 
	        // Note: starting the server or service will automatically set 
	        // the MB value.
	        //
	        *pdwState = MD_SERVER_STATE_STOPPED;
	        hr = S_FALSE;
	    }

        else if ((HRESULT_CODE(hr) == RPC_S_SERVER_UNAVAILABLE) ||
            ((HRESULT_CODE(hr) >= RPC_S_NO_CALL_ACTIVE) &&
             (HRESULT_CODE(hr) <= RPC_S_CALL_FAILED_DNE)) || 
            hr == RPC_E_DISCONNECTED || hr == MD_ERROR_SECURE_CHANNEL_FAILURE) {
			
            hr = ReCacheAdminBase(_pszServerName, &_pAdminBase);
            BAIL_ON_FAILURE(hr);

		    hr = _pAdminBase->GetData(
		             hObjHandle,
		             _pszMetaBasePath,
		             &mdrMDData,
		             &dwBufferSize
		             );
            if (FAILED(hr)) {
	            if( hr == MD_ERROR_DATA_NOT_FOUND )
	            {
	                *pdwState = MD_SERVER_STATE_STOPPED;
	                hr = S_FALSE;
	            }
            }
			BAIL_ON_FAILURE(hr);
		}

	    else
	    {
	        BAIL_ON_FAILURE(hr);
	    }
	}
error:

    RRETURN(hr);
}

//
// Helper routine for ExecMethod.
// Gets Win32 error from the metabase
//
HRESULT
CIISServer::IISGetServerWin32Error(
    METADATA_HANDLE hObjHandle,
    HRESULT*        phrError)
{
    DBG_ASSERT(phrError != NULL);

    long    lWin32Error = 0;
    DWORD   dwLen;

    METADATA_RECORD mr = {
        MD_WIN32_ERROR, 
        METADATA_NO_ATTRIBUTES,
        IIS_MD_UT_SERVER,
        DWORD_METADATA,
        sizeof(DWORD),
        (unsigned char*)&lWin32Error,
        0
        };  
    
    HRESULT hr = _pAdminBase->GetData(
        hObjHandle,
        _pszMetaBasePath,
        &mr,
        &dwLen);
    if(hr == MD_ERROR_DATA_NOT_FOUND)
    {
        hr = S_FALSE;
    }

    //
    // Set out param
    //
    *phrError = HRESULT_FROM_WIN32(lWin32Error);

    RRETURN(hr);
}

//
// Helper routine for ExecMethod.
// Clears Win32 error 
//
HRESULT
CIISServer::IISClearServerWin32Error(
    METADATA_HANDLE hObjHandle )
{
    long    lWin32Error = 0;

    METADATA_RECORD mr = {
        MD_WIN32_ERROR, 
        METADATA_VOLATILE,
        IIS_MD_UT_SERVER,
        DWORD_METADATA,
        sizeof(DWORD),
        (unsigned char*)&lWin32Error,
        0
        };  
    
    HRESULT hr = _pAdminBase->SetData(
        hObjHandle,
        L"",
        &mr );

    RRETURN(hr);
}

HRESULT
CIISServer::IISControlServer(
    DWORD dwControl
    )
{
    METADATA_HANDLE hObjHandle = NULL;
    DWORD dwTargetState;
    DWORD dwPendingState;
    DWORD dwState = 0;
    DWORD dwSleepTotal = 0L;

    HRESULT hr = S_OK;
    HRESULT hrMbNode = S_OK;

    switch(dwControl)
    {
    case MD_SERVER_COMMAND_STOP:
        dwTargetState = MD_SERVER_STATE_STOPPED;
        dwPendingState = MD_SERVER_STATE_STOPPING;
        break;

    case MD_SERVER_COMMAND_START:
        dwTargetState = MD_SERVER_STATE_STARTED;
        dwPendingState = MD_SERVER_STATE_STARTING;
        break;

    case MD_SERVER_COMMAND_CONTINUE:
        dwTargetState = MD_SERVER_STATE_STARTED;
        dwPendingState = MD_SERVER_STATE_CONTINUING;
        break;

    case MD_SERVER_COMMAND_PAUSE:
        dwTargetState = MD_SERVER_STATE_PAUSED;
        dwPendingState = MD_SERVER_STATE_PAUSING;
        break;

    default:
        hr = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
        BAIL_ON_FAILURE(hr);
    }

    hr = IISGetServerState(METADATA_MASTER_ROOT_HANDLE, &dwState);
    BAIL_ON_FAILURE(hr);
 
    if (dwState == dwTargetState) {
        RRETURN (hr);
    }

    //
    // Write the command to the metabase
    //

    hr = OpenAdminBaseKey(
               _pszServerName,
               _pszMetaBasePath,
               METADATA_PERMISSION_WRITE,
               &_pAdminBase,
               &hObjHandle
               );
    BAIL_ON_FAILURE(hr);

    hr = IISClearServerWin32Error(hObjHandle);
    BAIL_ON_FAILURE(hr);

    hr = IISSetCommand(hObjHandle, dwControl);
    BAIL_ON_FAILURE(hr);

    CloseAdminBaseKey(_pAdminBase, hObjHandle);

    while (dwSleepTotal < MAX_SLEEP_INST) {
        hr = IISGetServerState(METADATA_MASTER_ROOT_HANDLE, &dwState);
        BAIL_ON_FAILURE(hr);

        hrMbNode = 0;

        hr = IISGetServerWin32Error(METADATA_MASTER_ROOT_HANDLE, &hrMbNode);
        BAIL_ON_FAILURE(hr);

        // check to see if we hit the target state
        if (dwState != dwPendingState)
        {
            //
            // Done one way or another
            //
            if (dwState == dwTargetState)
            {
                break;
            }
        }

        // check to see if there was a Win32 error from the server
        if (FAILED(hrMbNode))
        {
            hr = hrMbNode;
            BAIL_ON_FAILURE(hr);
        }

        //
        // Still pending...
        //
        ::Sleep(SLEEP_INTERVAL);

        dwSleepTotal += SLEEP_INTERVAL;
    }

    if (dwSleepTotal >= MAX_SLEEP_INST)
    {
        //
        // Timed out.  If there is a real error in the metabase
        // use it, otherwise use a generic timeout error
        //

        hr = HRESULT_FROM_WIN32(ERROR_SERVICE_REQUEST_TIMEOUT);
    }

error :

    if (_pAdminBase && hObjHandle) {
        CloseAdminBaseKey(_pAdminBase, hObjHandle);
    }

    RRETURN (hr);
}


HRESULT
CIISServer::IISSetCommand(
    METADATA_HANDLE hObjHandle,
    DWORD dwControl
    )
{

    HRESULT hr = S_OK;
    DWORD dwBufferSize = sizeof(DWORD);
    METADATA_RECORD mdrMDData;
    LPBYTE pBuffer = (LPBYTE)&dwControl;

    MD_SET_DATA_RECORD(&mdrMDData,
                       MD_SERVER_COMMAND,  // server command
                       METADATA_VOLATILE,
                       IIS_MD_UT_SERVER,
                       DWORD_METADATA,
                       dwBufferSize,
                       pBuffer);

    hr = _pAdminBase->SetData(
             hObjHandle,
             L"",
             &mdrMDData
             );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);

}

STDMETHODIMP
CIISServer::ADSIInitializeDispatchManager(
    long dwExtensionId
    )
{
    HRESULT hr = S_OK;

    if (_fDispInitialized) {

        RRETURN(E_FAIL);
    }

    hr = _pDispMgr->InitializeDispMgr(dwExtensionId);

    if (SUCCEEDED(hr)) {
        _fDispInitialized = TRUE;
    }

    RRETURN(hr);
}

STDMETHODIMP
CIISServer::ADSIInitializeObject(
    THIS_ BSTR lpszUserName,
    BSTR lpszPassword,
    long lnReserved
    )
{

    CCredentials NewCredentials(lpszUserName, lpszPassword, lnReserved);

    _Credentials = NewCredentials;

    RRETURN(S_OK);
}

STDMETHODIMP
CIISServer::ADSIReleaseObject()
{
    delete this;
    RRETURN(S_OK);
}

STDMETHODIMP
CIISServer::NonDelegatingQueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IADsServiceOperations)) {

        *ppv = (IADsUser FAR *) this;

    } else if (IsEqualIID(iid, IID_IADsExtension)) {

        *ppv = (IADsExtension FAR *) this;

    } else if (IsEqualIID(iid, IID_IUnknown)) {

        //
        // probably not needed since our 3rd party extension does not stand
        // alone and provider does not ask for this, but to be safe
        //
        *ppv = (INonDelegatingUnknown FAR *) this;

    } else {

        *ppv = NULL;
        return E_NOINTERFACE;
    }


    //
    // Delegating AddRef to aggregator for IADsExtesnion and IISServer.
    // AddRef on itself for IPrivateUnknown.   (both tested.)
    //

    ((IUnknown *) (*ppv)) -> AddRef();

    return S_OK;
}



//
// IADsExtension::Operate()
//

STDMETHODIMP
CIISServer::Operate(
    THIS_ DWORD dwCode,
    VARIANT varUserName,
    VARIANT varPassword,
    VARIANT varFlags
    )
{
    RRETURN(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\iisext\common.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:  common.cxx
//
//  Contents:  Microsoft ADs IIS Common routines 
//
//  History:   28-Feb-97     SophiaC    Created.
//
//----------------------------------------------------------------------------
#include "iisext.hxx"

extern SERVER_CACHE * g_pServerCache;
extern WIN32_CRITSEC * g_pGlobalLock;

#pragma hdrstop


#define DEFAULT_TIMEOUT_VALUE                    30000



//+------------------------------------------------------------------------
//
//  Class:      Common
//
//  Purpose:    Contains Winnt routines and properties that are common to
//              all Winnt objects. Winnt objects get the routines and
//              properties through C++ inheritance.
//
//-------------------------------------------------------------------------

HRESULT
MakeVariantFromStringArray(
    LPWSTR pszList,
    VARIANT *pvVariant
)
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    LPWSTR pszStrList;
    WCHAR wchPath[MAX_PATH];


    if  (pszList != NULL)
    {
        long nCount = 0;
        long i = 0;
        pszStrList = pszList;

        if (*pszStrList == L'\0') {
            nCount = 1;
            pszStrList++;
        }

        while (*pszStrList != L'\0') {
            while (*pszStrList != L'\0') {
                pszStrList++;
            }
            nCount++;
            pszStrList++;
        }

        aBound.lLbound = 0;
        aBound.cElements = nCount;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        pszStrList = pszList;
        for (i = 0; i < nCount; i++ )
        {
            VARIANT v;

            VariantInit(&v);
            V_VT(&v) = VT_BSTR;

            hr = ADsAllocString( pszStrList, &(V_BSTR(&v)));

            BAIL_ON_FAILURE(hr);

            hr = SafeArrayPutElement( aList, &i, &v );

            VariantClear(&v);
            BAIL_ON_FAILURE(hr);

            pszStrList += wcslen(pszStrList) + 1;
        }

        VariantInit( pvVariant );
        V_VT(pvVariant) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pvVariant) = aList;

    }
    else
    {
        aBound.lLbound = 0;
        aBound.cElements = 0;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        VariantInit( pvVariant );
        V_VT(pvVariant) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pvVariant) = aList;
    }

    return S_OK;

error:

    if ( aList )
        SafeArrayDestroy( aList );

    return hr;
}

HRESULT
ReCacheAdminBase(
    IN LPWSTR pszServerName,
    IN OUT IMSAdminBase **ppAdminBase
    )
{
    HRESULT hr = S_OK;
    SERVER_CACHE_ITEM * item = NULL;
    DWORD dwThreadId;

    IMSAdminBase * pAdminBase = *ppAdminBase;
    IMSAdminBase * pOldAdminBase = *ppAdminBase;

    // RPC error caused this function to be called, so try to
    // recover the connection

    hr = InitAdminBase(pszServerName, &pAdminBase);
    BAIL_ON_FAILURE(hr);

    // we will return this one, so save it in the OUT param
    *ppAdminBase = pAdminBase;

    // update the cache
    dwThreadId = GetCurrentThreadId();
    item = g_pServerCache->Find(pszServerName, dwThreadId);

    if (item != NULL)
    {
        UninitAdminBase(pOldAdminBase);
        item->UpdateAdminBase(pAdminBase, dwThreadId);
    }

error :
    RRETURN(hr);
}

HRESULT
OpenAdminBaseKey(
    IN LPWSTR pszServerName,
    IN LPWSTR pszPathName,
    IN DWORD dwAccessType,
    IN OUT IMSAdminBase **ppAdminBase,
    OUT METADATA_HANDLE *phHandle
    )
{
    HRESULT hr;
    IMSAdminBase *pAdminBase = *ppAdminBase;
    METADATA_HANDLE RootHandle = NULL;
    DWORD dwThreadId;

    hr = pAdminBase->OpenKey(
                METADATA_MASTER_ROOT_HANDLE,
                pszPathName,
                dwAccessType,
                DEFAULT_TIMEOUT_VALUE,
                &RootHandle
                );

    if (FAILED(hr)) {
        if ((HRESULT_CODE(hr) == RPC_S_SERVER_UNAVAILABLE) ||
            ((HRESULT_CODE(hr) >= RPC_S_NO_CALL_ACTIVE) &&
             (HRESULT_CODE(hr) <= RPC_S_CALL_FAILED_DNE)) || 
            hr == RPC_E_DISCONNECTED) {

            hr = ReCacheAdminBase(pszServerName, &pAdminBase);
            BAIL_ON_FAILURE(hr);
            *ppAdminBase = pAdminBase;

            hr = pAdminBase->OpenKey(
                        METADATA_MASTER_ROOT_HANDLE,
                        pszPathName,
                        dwAccessType,
                        DEFAULT_TIMEOUT_VALUE,
                        &RootHandle
                        );
            BAIL_ON_FAILURE(hr);
        }
    }

error :

    if (FAILED(hr)) {

        if (pAdminBase && RootHandle) {
            pAdminBase->CloseKey(RootHandle);
        }
    }
    else {
        *phHandle = RootHandle;
    }

    RRETURN(hr);
}


VOID
CloseAdminBaseKey(
    IN IMSAdminBase *pAdminBase,
    IN METADATA_HANDLE hHandle
    )
{
    HRESULT hr;

    if (pAdminBase) {
        hr = pAdminBase->CloseKey(hHandle);
    }

    return;
}




HRESULT
InitAdminBase(
    IN LPWSTR pszServerName,
    OUT IMSAdminBase **ppAdminBase
    )
{
    HRESULT hr = S_OK;

    COSERVERINFO csiName;
    COSERVERINFO *pcsiParam = &csiName;
    IClassFactory * pcsfFactory = NULL;
    IMSAdminBase * pAdminBase = NULL;
    IMSAdminBase * pAdminBaseT = NULL;

    memset(pcsiParam, 0, sizeof(COSERVERINFO));

    //
    // special case to handle "localhost" to work-around ole32 bug
    //

    if (pszServerName == NULL || _wcsicmp(pszServerName,L"localhost") == 0) {
        pcsiParam->pwszName =  NULL;
    }
    else {
        pcsiParam->pwszName =  pszServerName;
    }

    csiName.pAuthInfo = NULL;
    pcsiParam = &csiName;

    hr = CoGetClassObject(
                CLSID_MSAdminBase,
                CLSCTX_SERVER,
                pcsiParam,
                IID_IClassFactory,
                (void**) &pcsfFactory
                );

    BAIL_ON_FAILURE(hr);

    hr = pcsfFactory->CreateInstance(
                NULL,
                IID_IMSAdminBase,
                (void **) &pAdminBaseT
                );
    BAIL_ON_FAILURE(hr);

	hr = pAdminBaseT->UnmarshalInterface((IMSAdminBaseW **)&pAdminBase);
    pAdminBaseT->Release();
    pAdminBaseT = NULL;
	BAIL_ON_FAILURE(hr);
    *ppAdminBase = pAdminBase;

error:

    if (pcsfFactory) {
        pcsfFactory->Release();
    }

    RRETURN(hr);
}

VOID
UninitAdminBase(
    IN IMSAdminBase * pAdminBase
    )
{
    if (pAdminBase != NULL) {
        pAdminBase->Release();
    }
}

HRESULT
InitServerInfo(
    IN LPWSTR pszServerName,
    OUT IMSAdminBase ** ppObject
    )
{
    HRESULT hr = S_OK;
    IMSAdminBase * pAdminBase = NULL;
    SERVER_CACHE_ITEM * item;
    BOOL Success;
    DWORD dwThreadId;

    ASSERT(g_pServerCache != NULL);

    //
    // We'll return the localhost machine config to the users if 
    // pszServerName == NULL, e.g. IIS:
    //

    if (pszServerName == NULL) {
        pszServerName = L"Localhost";
    }

    dwThreadId = GetCurrentThreadId();

    if ((item = g_pServerCache->Find(pszServerName, dwThreadId)) == NULL) {

        //
        // get pAdminBase
        //

        hr = InitAdminBase(pszServerName, &pAdminBase);
        BAIL_ON_FAILURE(hr);

        item = new SERVER_CACHE_ITEM(pszServerName,
                                     pAdminBase,
                                     dwThreadId,
                                     Success);

        if (item == NULL || !Success) {
            if (item != NULL) {
                UninitAdminBase(pAdminBase);
                delete item;
            }
            RRETURN(E_OUTOFMEMORY); // OUT_OF_MEMORY;
        }

        if (g_pServerCache->Insert(item) == FALSE) {
            UninitAdminBase(pAdminBase);
            delete item;
            RRETURN(E_OUTOFMEMORY); // OUT_OF_MEMORY;
        }
    }

    *ppObject = item->pAdminBase;

error :

    RRETURN(hr);

}


HRESULT
InitWamAdmin(
    IN LPWSTR pszServerName,
    OUT IWamAdmin2 **ppWamAdmin
    )
{
    HRESULT hr = S_OK;

    COSERVERINFO csiName;
    COSERVERINFO *pcsiParam = &csiName;
    IClassFactory * pcsfFactory = NULL;
    IWamAdmin2 * pWamAdmin = NULL;

    memset(pcsiParam, 0, sizeof(COSERVERINFO));

    //
    // special case to handle "localhost" to work-around ole32 bug
    //

    if (pszServerName == NULL || _wcsicmp(pszServerName,L"localhost") == 0) {
        pcsiParam->pwszName =  NULL;
    }
    else {
        pcsiParam->pwszName =  pszServerName;
    }

    csiName.pAuthInfo = NULL;
    pcsiParam = &csiName;

    hr = CoGetClassObject(
                CLSID_WamAdmin,
                CLSCTX_SERVER,
                pcsiParam,
                IID_IClassFactory,
                (void**) &pcsfFactory
                );

    BAIL_ON_FAILURE(hr);

    hr = pcsfFactory->CreateInstance(
                NULL,
                IID_IWamAdmin2,
                (void **) &pWamAdmin
                );
    BAIL_ON_FAILURE(hr);

    *ppWamAdmin = pWamAdmin;

error:

    if (pcsfFactory) {
        pcsfFactory->Release();
    }

    RRETURN(hr);
}


VOID
UninitWamAdmin(
    IN IWamAdmin2 *pWamAdmin
    )
{
    if (pWamAdmin != NULL) {
        pWamAdmin->Release();
    }
}



HRESULT
BuildIISPathFromADsPath(
    POBJECTINFO pObjectInfo,
    LPWSTR pszIISPathName
    )
{

    DWORD dwNumComponents = 0;
    DWORD i = 0;

    dwNumComponents = pObjectInfo->NumComponents;

    //
    // wcscat "LM" to IIS Metabase path
    //

    wcscat(pszIISPathName, L"/LM/");

    if (dwNumComponents) {


        for (i = 0; i < dwNumComponents; i++) {


            if (wcscmp(pObjectInfo->ComponentArray[i].szComponent, L"[Root]")){
                   wcscat(pszIISPathName, pObjectInfo->ComponentArray[i].szComponent);
            }
            else {
                   if( i == dwNumComponents -1 ) {
                       wcscat(pszIISPathName, L"/");
                   }
            }

            if( i < dwNumComponents -1 ) {
                wcscat(pszIISPathName,L"/");
            }
        }

    }

    RRETURN(S_OK);

}


VOID
FreeObjectInfo(
    POBJECTINFO pObjectInfo
    )
{
    if ( !pObjectInfo )
        return;

    if (pObjectInfo->ProviderName)
    {
        FreeADsStr( pObjectInfo->ProviderName );
    }

    if (pObjectInfo->TreeName)
    {
        FreeADsStr( pObjectInfo->TreeName );
    }

    if ((pObjectInfo->ComponentArray) && (pObjectInfo->NumComponents))
    {
        for ( DWORD i = 0; i < pObjectInfo->NumComponents; i++ ) {
            if (pObjectInfo->ComponentArray[i].szComponent) {
                FreeADsStr( pObjectInfo->ComponentArray[i].szComponent );
            }
            if (pObjectInfo->ComponentArray[i].szValue) {
                FreeADsStr( pObjectInfo->ComponentArray[i].szValue );
            }
        }
    }

    if (pObjectInfo->ComponentArray) {
        FreeADsMem(pObjectInfo->ComponentArray);
    }

    // We don't need to free pObjectInfo since the object is always a static
    // variable on the stack.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\iisext\crmap.cxx ===
/*++


Copyright (c) 1997  Microsoft Corporation

Module Name:

    crmap.cxx

Abstract:

    ADSIIS cert mapper object
    Certificate mappings storage has changed for IIS6. 
    ADSI however has to support downlevel admin of
    IIS5, IIS5.1

    NSEPM support was removed from IIS6 and 1to1 client certificate
    mapping information is now stored under <site>/Cert11/Mappings
    node directly in the metabase
    Functions with IIS6 postfix access new location
    for 1to1 client certificate mappings storage
    
Author:

    Philippe Choquier (phillich)    10-Apr-1997

--*/

#include "iisext.hxx"
#pragma hdrstop

#include <nsepname.hxx>
#include <dbgutil.h>

DEFINE_IPrivateDispatch_Implementation(CIISDsCrMap)
DEFINE_DELEGATING_IDispatch_Implementation(CIISDsCrMap)
DEFINE_CONTAINED_IADs_Implementation(CIISDsCrMap)
DEFINE_IADsExtension_Implementation(CIISDsCrMap)

#define LOCAL_MAX_SIZE METADATA_MAX_NAME_LEN + 1

const int SHA1_HASH_SIZE = 20;


//Local functions used only for IIS6

HRESULT
GetStringAFromBSTR( 
    BSTR    bstr,
    LPSTR*  psz,
    LPDWORD pdwLen,
    BOOL    fAddDelimInCount = TRUE
    );

HRESULT
GetBlobFromVariant( 
    VARIANT*    pVar,
    PBYTE*      ppbOut,
    LPDWORD     pcbOut
  );

HRESULT
SetVariantAsBSTRFromStringW(
    VARIANT*    pvarReturn, 
    DWORD       cbLen,
    LPBYTE      pbIn 
  );

HRESULT
SetBSTRFromStringW( 
    BSTR*   pbstrRet,
    DWORD   cb, 
    LPBYTE  sz 
  );

//
// Local functions used for IIS5 and IIS6
//

HRESULT
GetStringFromBSTR( 
    BSTR    bstr,
    LPSTR*  psz,
    LPDWORD pdwLen,
    BOOL    fAddDelimInCount = TRUE
    );

HRESULT
GetStringFromVariant( 
    VARIANT*    pVar,
    LPSTR*      psz,
    LPDWORD     pdwLen,
    BOOL        fAddDelimInCount = TRUE
    );

VOID
FreeString( 
    LPSTR   psz 
    );

HRESULT
SetBSTR( 
    BSTR*   pbstrRet,
    DWORD   cch, 
    LPBYTE  sz 
    );

HRESULT
SetVariantAsByteArray(
    VARIANT*    pvarReturn, 
    DWORD       cbLen,
    LPBYTE      pbIn 
    );

HRESULT
SetVariantAsBSTR(
    VARIANT*    pvarReturn, 
    DWORD       cbLen,
    LPBYTE      pbIn 
    );

HRESULT
SetVariantAsLong(
    VARIANT*    pvarReturn, 
    DWORD       dwV
    );

HRESULT 
VariantResolveDispatch(
    VARIANT *   pVarOut, 
    VARIANT *   pVarIn
    );


HRESULT
GetCertificateHashString(
    PBYTE pbCert,
    DWORD cbCert,
    WCHAR *pwszCertHash,
    DWORD cchCertHashBuffer)
/*++

Routine Description:

    verifies validity of cert blob by creating cert context
    and retrieves SHA1 hash and converts it to WCHAR *

    Used for IIS6 only

Arguments:

    pbCert - X.509 certificate blob
    cbCert - size of the cert blob in bytes
    pwszCertHash - buffer must be big enough to fit SHA1 hash in hex string form
                   (40 WCHAR + terminating 0 )
    cchCertHashBuffer - size of the CertHash buffer in WCHARS (includes terminating 0)
Returns:

    HRESULT

--*/
    
{
    HRESULT         hr = E_FAIL;
    BYTE            rgbHash[ SHA1_HASH_SIZE ];
    DWORD           cbSize = SHA1_HASH_SIZE;

    #ifndef HEX_DIGIT
    #define HEX_DIGIT( nDigit )                            \
    (WCHAR)((nDigit) > 9 ?                              \
          (nDigit) - 10 + L'a'                          \
        : (nDigit) + L'0')
    #endif

    PCCERT_CONTEXT pCertContext = NULL;
    pCertContext = CertCreateCertificateContext(
                                    X509_ASN_ENCODING, 
                                    (const BYTE *)pbCert, 
                                    cbCert );
    
    if ( pCertContext == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        return hr; 
    }

    //
    // get hash of the certificate to be verified
    //
    if ( !CertGetCertificateContextProperty( pCertContext,
                                             CERT_SHA1_HASH_PROP_ID,
                                             rgbHash,
                                             &cbSize ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        CertFreeCertificateContext( pCertContext );
        pCertContext=NULL;
        return hr;
    }
    
    CertFreeCertificateContext( pCertContext );
    pCertContext = NULL;

    if ( cchCertHashBuffer <  SHA1_HASH_SIZE * 2 + 1  )
    {
        // we don't have big enough buffer to store
        // hex string of the SHA1 hash each byte takes 2 chars + terminating 0 
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        DBG_ASSERT( FALSE );
        return hr;
    }

    //
    // convert to text
    //
    for (int i = 0; i < sizeof(rgbHash); i ++ )
    {
        *(pwszCertHash++) = HEX_DIGIT( ( rgbHash[ i ] >> 4 ) );
        *(pwszCertHash++) = HEX_DIGIT( ( rgbHash[ i ] & 0x0F ) );
    }
    *(pwszCertHash) = L'\0';
    #undef HEX_DIGIT
    return S_OK;
}

//
// Mapping functins for IIS6
//


HRESULT
CIISDsCrMap::CreateMappingIIS6(
    VARIANT     vCert,
    BSTR        bstrNtAcct,
    BSTR        bstrNtPwd,
    BSTR        bstrName,
    LONG        lEnabled
    )
/*++

Routine Description:

    Create a mapping entry

Arguments:

    vCert - X.509 certificate
    bstrNtAcct - NT acct to map to
    bstrNtPwd - NT pwd
    bstrName - friendly name for mapping entry
    lEnabled - 1 to enable mapping entry, 0 to disable it

Returns:

    COM status

--*/
{
    HRESULT     hres;
    LPBYTE      pbCert = NULL;
    DWORD       cbCert;
    LPBYTE      pRes;
    DWORD       cRes;
    VARIANT     vOldAcct;
    VARIANT     vOldCert;
    VARIANT     vOldPwd;
    VARIANT     vOldName;
    VARIANT     vOldEnabledFlag;
    PCCERT_CONTEXT pcCert = NULL;
    WCHAR       wszCertHash[ 2*SHA1_HASH_SIZE + 1];
    BOOL        fFoundExisting = FALSE;

    //
    // Do some sanity checks on the cert 
    //
    if ( SUCCEEDED( hres = GetBlobFromVariant( &vCert, 
                                               &pbCert,
                                               &cbCert ) ) )
    {
        //
        // verify validity of certificate blob
        // and retrieve certificate hash
        //

        if ( FAILED( hres = GetCertificateHashString( 
                                                pbCert,
                                                cbCert, 
                                                wszCertHash,
                                                sizeof( wszCertHash )/sizeof( WCHAR ) ) ) )
        {
            DBGPRINTF((DBG_CONTEXT,
                       "Invalid cert passed to CreateMapping() 0x%x\n", hres));
            //
            // If the decoding fails, GetLastError() returns an ASN1 decoding
            // error that is obtained by subtracting CRYPT_E_OSS_ERROR from the returned
            // error and looking in file asn1code.h for the actual error. To avoid the
            // cryptic ASN1 errors, we'll just return a general "invalid arg" error 
            //
            goto Exit;
        }
    }
    else
    {
        goto Exit;
    }

    //
    // check if we already have a mapping for this cert; if we do, we'll replace that mapping
    // with the new one
    //
    
    WCHAR       achIndex[METADATA_MAX_NAME_LEN + 1];
    
    if ( SUCCEEDED( hres = OpenMd( L"Cert11/Mappings", 
                                   METADATA_PERMISSION_WRITE|METADATA_PERMISSION_READ ) ) )
    {
        if ( SUCCEEDED(hres = Locate( IISMAPPER_LOCATE_BY_CERT, 
                                      vCert,
                                      achIndex )) )
        {
            fFoundExisting = TRUE;
            DBGPRINTF((DBG_CONTEXT,
                       "Replacing old 1-1 cert mapping with new mapping\n"));
            
            
            if ( FAILED( hres = SetMdData( achIndex, MD_MAPENABLED, DWORD_METADATA, 
                                               sizeof(DWORD), (LPBYTE)&lEnabled ) ) ||
                 FAILED( hres = SetMdData( achIndex, MD_MAPNAME, STRING_METADATA, 
                                           sizeof(WCHAR) * (SysStringLen(bstrName) + 1 ), 
                                           (LPBYTE)bstrName ) ) ||
                 FAILED( hres = SetMdData( achIndex, MD_MAPNTPWD, STRING_METADATA, 
                                           sizeof(WCHAR) * (SysStringLen(bstrNtPwd) + 1 ), 
                                           (LPBYTE)bstrNtPwd ) ) ||
                 FAILED( hres = SetMdData( achIndex, MD_MAPNTACCT, STRING_METADATA, 
                                           sizeof(WCHAR) * (SysStringLen(bstrNtAcct) + 1 ),
                                           (LPBYTE)bstrNtAcct ) ) ||
                 FAILED( hres = SetMdData( achIndex, MD_MAPCERT, BINARY_METADATA, 
                                           cbCert, (LPBYTE)pbCert ) ) )
            {
                //NOP - Something failed 
            }
        }
        CloseMd( SUCCEEDED( hres ) );
    }
    
    //
    // New mapping
    //
    if ( !fFoundExisting )
    {
        //
        // check mapping exists, create if not
        //
        hres = OpenMd( L"Cert11/Mappings", METADATA_PERMISSION_WRITE|METADATA_PERMISSION_READ );

        if ( hres == RETURNCODETOHRESULT( ERROR_PATH_NOT_FOUND ) )
        {
            if ( SUCCEEDED( hres = OpenMd( L"", 
                                           METADATA_PERMISSION_WRITE|METADATA_PERMISSION_READ ) ) )
            {
                hres = CreateMdObject( L"Cert11/Mappings" );
                CloseMd( FALSE );

                // Reopen to the correct node.
                hres = OpenMd( L"Cert11/Mappings", METADATA_PERMISSION_WRITE|METADATA_PERMISSION_READ );
            }
        }

        // failed to open metabase

        if ( FAILED( hres ) )
        {
            goto Exit;
        }

        //
        // adding the new mapping under it's CertHash node
        //

        if ( SUCCEEDED( hres = CreateMdObject( wszCertHash ) ) )
        {

            if ( FAILED( hres = SetMdData( wszCertHash, MD_MAPENABLED, DWORD_METADATA, 
                                           sizeof(DWORD), (LPBYTE)&lEnabled ) ) ||
                 FAILED( hres = SetMdData( wszCertHash, MD_MAPNAME, STRING_METADATA, 
                                           sizeof(WCHAR) * (SysStringLen(bstrName) + 1 ), 
                                           (LPBYTE)bstrName ) ) ||
                 FAILED( hres = SetMdData( wszCertHash, MD_MAPNTPWD, STRING_METADATA, 
                                           sizeof(WCHAR) * (SysStringLen(bstrNtPwd) + 1 ), 
                                           (LPBYTE)bstrNtPwd ) ) ||
                 FAILED( hres = SetMdData( wszCertHash, MD_MAPNTACCT, STRING_METADATA, 
                                           sizeof(WCHAR) * (SysStringLen(bstrNtAcct) + 1 ),
                                           (LPBYTE)bstrNtAcct ) ) ||
                 FAILED( hres = SetMdData( wszCertHash, MD_MAPCERT, BINARY_METADATA, 
                                           cbCert, (LPBYTE)pbCert ) ) )
            {
            }
        }
        CloseMd( SUCCEEDED( hres ) );
    }

Exit:
    if( pbCert != NULL )
    {
        LocalFree( pbCert );
        pbCert = NULL;
    }

    return hres;
}


HRESULT
CIISDsCrMap::GetMappingIIS6(
    LONG        lMethod,
    VARIANT     vKey,
    VARIANT*    pvCert,
    VARIANT*    pbstrNtAcct,
    VARIANT*    pbstrNtPwd,
    VARIANT*    pbstrName,
    VARIANT*    plEnabled
    )
/*++

Routine Description:

    Get a mapping entry using key

Arguments:

    lMethod - method to use for access ( IISMAPPER_LOCATE_BY_* )
    vKey - key to use to locate mapping
    pvCert - X.509 certificate
    pbstrNtAcct - NT acct to map to
    pbstrNtPwd - NT pwd
    pbstrName - friendly name for mapping entry
    plEnabled - 1 to enable mapping entry, 0 to disable it

Returns:

    COM status

--*/
{
    WCHAR       achIndex[METADATA_MAX_NAME_LEN + 1];
    HRESULT     hres;
    DWORD       dwLen;
    LPBYTE      pbData = NULL;

    VariantInit( pvCert );
    VariantInit( pbstrNtAcct );
    VariantInit( pbstrNtPwd );
    VariantInit( pbstrName );
    VariantInit( plEnabled );

    if ( SUCCEEDED( hres = OpenMd( L"Cert11/Mappings", 
                                   METADATA_PERMISSION_WRITE|METADATA_PERMISSION_READ ) ) )
    {
        if ( SUCCEEDED(hres = Locate( lMethod, vKey, achIndex )) )
        {
            if ( SUCCEEDED( hres = GetMdData( achIndex, MD_MAPCERT, BINARY_METADATA, &dwLen, 
                                              &pbData ) ) )
            {
                if ( FAILED( hres = SetVariantAsByteArray( pvCert, dwLen, pbData ) ) )
                {
                    goto Done;
                }
                LocalFree( pbData );
            }
            else
            {
                if ( hres != MD_ERROR_DATA_NOT_FOUND ||
                     FAILED( hres = SetVariantAsByteArray( pvCert, 0, (PBYTE)"" ) ) )
                {
                    goto Done;
                }
            }

            if ( SUCCEEDED( hres = GetMdData( achIndex, MD_MAPNTACCT, STRING_METADATA, &dwLen, 
                                              &pbData ) ) )
            {
                if ( FAILED( hres = SetVariantAsBSTRFromStringW( 
                                                pbstrNtAcct, 
                                                dwLen, pbData ) ) )
                {
                    goto Done;
                }
                LocalFree( pbData );
                pbData = NULL;
            }
            else
            {
                if ( hres != MD_ERROR_DATA_NOT_FOUND ||
                     FAILED ( hres = SetVariantAsBSTRFromStringW( 
                                                pbstrNtAcct, 
                                                sizeof(L""), (LPBYTE)L"" ) ) )
                {
                    goto Done;
                }
            }

            if ( SUCCEEDED( hres = GetMdData( achIndex, MD_MAPNTPWD, STRING_METADATA, &dwLen, 
                                              &pbData ) ) )
            {
                if ( FAILED( hres = SetVariantAsBSTRFromStringW( 
                                                pbstrNtPwd, 
                                                dwLen, pbData ) ) )
                { 
                    goto Done;
                }
                LocalFree( pbData );
                pbData = NULL;
            }
            else
            {
                if ( hres != MD_ERROR_DATA_NOT_FOUND ||
                    FAILED( hres = SetVariantAsBSTRFromStringW( 
                                                pbstrNtPwd, 
                                                sizeof(L""), (LPBYTE)L"" ) ) )
                { 
                    goto Done;
                }
            }

            if ( SUCCEEDED( hres = GetMdData( achIndex, MD_MAPNAME, STRING_METADATA, &dwLen, 
                                              &pbData ) ) )
            {
                if ( FAILED( hres = SetVariantAsBSTRFromStringW( 
                                                pbstrName, 
                                                dwLen, pbData ) ) )
                { 
                    goto Done;
                }
                LocalFree( pbData );
                pbData = NULL;
            }
            else
            {
                if ( hres != MD_ERROR_DATA_NOT_FOUND ||
                    FAILED( hres = SetVariantAsBSTRFromStringW( 
                                                pbstrName, 
                                                sizeof(L""), (LPBYTE)L"" ) ) )
                { 
                    goto Done;
                }
            }

            if ( SUCCEEDED( hres = GetMdData( achIndex, MD_MAPENABLED, DWORD_METADATA, &dwLen, 
                                           &pbData ) ) )
            {
                if ( FAILED( hres = SetVariantAsLong( plEnabled, *(LPDWORD)pbData ) ) )
                { 
                    goto Done;
                }
                LocalFree( pbData );
                pbData = NULL;
            }
            else
            {
                if ( hres != MD_ERROR_DATA_NOT_FOUND ||
                     FAILED( hres = SetVariantAsLong( plEnabled, FALSE ) ) )
                { 
                    goto Done;
                }
                hres = S_OK;
            }


        }

Done:
        if ( pbData != NULL )
        {
            LocalFree( pbData );
            pbData = NULL;
        }
        CloseMd( FALSE );
    }

    return hres;
}


HRESULT
CIISDsCrMap::DeleteMappingIIS6(
    LONG        lMethod,
    VARIANT     vKey
    )
/*++

Routine Description:

    Delete a mapping entry using key

Arguments:

    lMethod - method to use for access ( IISMAPPER_LOCATE_BY_* )
    vKey - key to use to locate mapping

Returns:

    COM status

--*/
{
    WCHAR       achIndex[METADATA_MAX_NAME_LEN + 1];
    HRESULT     hres;

    if ( SUCCEEDED( hres = OpenMd( L"Cert11/Mappings", 
                                   METADATA_PERMISSION_WRITE|METADATA_PERMISSION_READ ) ) )
    {
        if ( SUCCEEDED(hres = Locate( lMethod, vKey, achIndex )) )
        {
            hres = DeleteMdObject( achIndex );
        }
        CloseMd( TRUE );
    }

    return hres;
}


HRESULT
CIISDsCrMap::SetEnabledIIS6(
    LONG        lMethod,
    VARIANT     vKey,
    LONG        lEnabled
    )
/*++

Routine Description:

    Set the enable flag on a mapping entry using key

Arguments:

    lMethod - method to use for access ( IISMAPPER_LOCATE_BY_* )
    vKey - key to use to locate mapping
    lEnabled - 1 to enable, 0 to disable

Returns:

    COM status

--*/
{
    WCHAR       achIndex[METADATA_MAX_NAME_LEN + 1];
    HRESULT     hres;

    if ( SUCCEEDED( hres = OpenMd( L"Cert11/Mappings", 
                                   METADATA_PERMISSION_WRITE|METADATA_PERMISSION_READ ) ) )
    {
        if ( SUCCEEDED(hres = Locate( lMethod, vKey, achIndex )) )
        {
            hres = SetMdData( achIndex, MD_MAPENABLED, DWORD_METADATA, sizeof(DWORD), (LPBYTE)&lEnabled );
        }
        CloseMd( TRUE );
    }

    return hres;
}


HRESULT
CIISDsCrMap::SetNameIIS6(
    LONG        lMethod,
    VARIANT     vKey,
    BSTR        bstrName
    )
/*++

Routine Description:

    Set the Name on a mapping entry using key

Arguments:

    lMethod - method to use for access ( IISMAPPER_LOCATE_BY_* )
    vKey - key to use to locate mapping
    bstrName - name to assign to mapping entry

Returns:

    COM status

--*/
{
    return SetStringIIS6( lMethod, vKey, bstrName, MD_MAPNAME );
}


HRESULT
CIISDsCrMap::SetStringIIS6(
    LONG        lMethod,
    VARIANT     vKey,
    BSTR        bstrName,
    DWORD       dwProp
    )
/*++

Routine Description:

    Set a string property on a mapping entry using key

Arguments:

    lMethod - method to use for access ( IISMAPPER_LOCATE_BY_* )
    vKey - key to use to locate mapping
    bstrName - string content to assign to mapping entry
    dwProp - property ID to assign to

Returns:

    COM status

--*/
{
    WCHAR       achIndex[METADATA_MAX_NAME_LEN + 1];
    LPSTR       pszName = NULL;
    HRESULT     hres;
    DWORD       dwLen;


    if ( SUCCEEDED( hres = OpenMd( L"Cert11/Mappings", 
                                   METADATA_PERMISSION_WRITE|METADATA_PERMISSION_READ ) ) )
    {
        if ( SUCCEEDED(hres = Locate( lMethod, vKey, achIndex )) )
        {
            hres = SetMdData( achIndex, dwProp, STRING_METADATA, 
                sizeof(WCHAR) * (SysStringLen(bstrName) + 1 ),
                (LPBYTE)bstrName );
        }
        CloseMd( TRUE );
    }

    return hres;
}


HRESULT
CIISDsCrMap::SetPwdIIS6(
    LONG        lMethod,
    VARIANT     vKey,
    BSTR        bstrPwd
    )
/*++

Routine Description:

    Set the Password on a mapping entry using key

Arguments:

    lMethod - method to use for access ( IISMAPPER_LOCATE_BY_* )
    vKey - key to use to locate mapping
    bstrPwd - password to assign to mapping entry

Returns:

    COM status

--*/
{
    // Password must be saved with METADATA_SECURE flag
    // SetMdData() is used by SetStringIIS6() and it will take care of it
    //
    return SetStringIIS6( lMethod, vKey, bstrPwd, MD_MAPNTPWD );
}


HRESULT
CIISDsCrMap::SetAcctIIS6(
    LONG        lMethod,
    VARIANT     vKey,
    BSTR        bstrAcct
    )
/*++

Routine Description:

    Set the NT account name on a mapping entry using key

Arguments:

    lMethod - method to use for access ( IISMAPPER_LOCATE_BY_* )
    vKey - key to use to locate mapping
    bstrAcct - NT account name to assign to mapping entry

Returns:

    COM status

--*/
{
    return SetStringIIS6( lMethod, vKey, bstrAcct, MD_MAPNTACCT );
}



//////

HRESULT
CIISDsCrMap::LocateIIS6(
    LONG    lMethod,
    VARIANT vKey,
    LPWSTR  pszResKey 
    )
/*++

Routine Description:

    Locate a mapping entry based on key
    OpenMd() must be called 1st

Arguments:

    lMethod - method to use for access ( IISMAPPER_LOCATE_BY_* )
    vKey - key to use to locate mapping
    pszResKey - must be METADATA_MAX_NAME_LEN + 1 WCHARs long

Returns:

    COM status

--*/
{
    HRESULT     hres;
    PBYTE       pbKeyData = NULL;
    DWORD       cbKeyData =0;
    PBYTE       pbCert = NULL;
    DWORD       cbCert =0;
    DWORD       dwProp;
    LPSTR       pRes;
    DWORD       cRes;
    BOOL        fAddDelim = TRUE;
    VARIANT     vKeyUI4;
    VARIANT     vKeyBSTR;

    WCHAR       achIndex[ METADATA_MAX_NAME_LEN + 1 ];
    DWORD       dwIndex = 0;
    DWORD       cbData = 0;
    PBYTE       pbData = NULL;


    VariantInit( &vKeyUI4 );  
    VariantInit( &vKeyBSTR );  
    if ( lMethod == IISMAPPER_LOCATE_BY_INDEX )
    {
        //
        // Convert index to numeric value VT_UI4 (within variant)
        //

        if ( FAILED( hres = VariantChangeType( &vKeyUI4, &vKey, 0, VT_UI4 ) ) )
        {
            goto Exit;
        }
        if ( V_UI4( &vKeyUI4 ) == 0 )
        {
            // Error PATH_NOT_FOUND chosen for backward compatibility
            // with version IIS5.1 and older
            //
            hres = HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND );
            goto Exit;
        }
        hres = m_pcAdmCom->EnumKeys( m_hmd,
                                     L"",
                                     achIndex,
                                     V_UI4( &vKeyUI4 ) - 1
                                     );
        if ( hres == HRESULT_FROM_WIN32( ERROR_NO_MORE_ITEMS ) )
        {
            // Error PATH_NOT_FOUND chosen for backward compatibility
            // with version IIS5.1 and older
            //
            hres = HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND );
        }
        goto Exit;
    }

    //
    // get ptr to data
    //

    

    if ( lMethod == IISMAPPER_LOCATE_BY_CERT )
    {
        // Now this is really wacky. Because of the legacy of the bad 
        // decision in the past the CERT is not enforced to be byte array
        // It can be passed as string. That causes problems with
        // conversions between byte array and UNICODE and back 
        // but we got to stick with it for compatibility with previous versions.
        //
        
        if ( FAILED( hres = GetBlobFromVariant( &vKey, &pbCert, &cbCert ) ) )
        {
            goto Exit;
        }
        pbKeyData = pbCert;
        cbKeyData = cbCert;
    }
    else
    {
        //
        // the rest of the lookups (by mapping, name or by account name)
        // assumes string
        //
        if ( FAILED( hres = VariantChangeType( &vKeyBSTR, &vKey, 0, VT_BSTR ) ) )
        {
            goto Exit;
        }
        pbKeyData = (PBYTE) V_BSTR( &vKeyBSTR );
        cbKeyData = ( SysStringLen(V_BSTR( &vKeyBSTR )) + 1 ) * sizeof(WCHAR);
    }
    

    //
    // enumerate all entries to find match
    // Now this is really slooow if many mappings are configured
    //
    for(;;)
    {
        hres = m_pcAdmCom->EnumKeys( m_hmd,
                                     L"",
                                     achIndex,
                                     dwIndex
                                     );
        if ( FAILED( hres ) )
        {
            if ( hres == HRESULT_FROM_WIN32( ERROR_NO_MORE_ITEMS ) )
            {
                // Error PATH_NOT_FOUND chosen for backward compatibility
                // with version IIS5.1 and older
                //
                hres = HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND );
            }
            goto Exit;
        }
        
              switch ( lMethod )
        {
        case IISMAPPER_LOCATE_BY_CERT:
            hres = GetMdData( achIndex, MD_MAPCERT, BINARY_METADATA, &cbData, 
                                                  &pbData );
            if ( hres == MD_ERROR_DATA_NOT_FOUND )
            {
                cbData = 0;
                pbData = NULL;
            }
            else if ( FAILED( hres ) )
            {
                // goto next entry
                break;
            }
            //
            // compare if key is matching value read from metabase
            //

            if ( cbData == cbKeyData )
            {
                if ( ( cbData == 0 ) || 
                     memcmp( pbKeyData, pbData, cbData ) == 0 )
                {
                    // we found match
                    hres = S_OK;
                    goto Exit;
                }
            }
            break;
        case IISMAPPER_LOCATE_BY_ACCT:
            hres = GetMdData( achIndex, MD_MAPNTACCT, STRING_METADATA, &cbData, 
                                              &pbData );
            if ( hres == MD_ERROR_DATA_NOT_FOUND )
            {
                cbData = sizeof(L"");
                pbData = (PBYTE) L"";
            }
            else if ( FAILED( hres ) )
            {
                // goto next entry
                break;
            }

            if ( cbData == cbKeyData )
            {
                if ( _wcsicmp( (WCHAR *) pbKeyData, (WCHAR *) pbData ) == 0 )
                {
                    // we found match
                    hres = S_OK;
                    goto Exit;
                }
            }
            
            break;
        case IISMAPPER_LOCATE_BY_NAME:
            hres = GetMdData( achIndex, MD_MAPNAME, STRING_METADATA, &cbData, 
                                              &pbData );
            if ( hres == MD_ERROR_DATA_NOT_FOUND )
            {
                cbData = sizeof(L"");
                pbData = (PBYTE) L"";
            }
            else if ( FAILED( hres ) )
            {
                // goto next entry
                break;
            }

            if ( cbData == cbKeyData )
            {
                if ( _wcsicmp( (WCHAR *) pbKeyData, (WCHAR *) pbData ) == 0 )
                {
                    // we found match
                    hres = S_OK;
                    goto Exit;
                }
            }

            break;
        }
        
        if ( pbData != NULL )
        {
            LocalFree( pbData );
            pbData = NULL;
        }

        dwIndex++;
    }

Exit:

    if ( pbData != NULL )
    {
        LocalFree( pbData );
        pbData = NULL;
    }
    
    if ( pbCert != NULL )
    {
        LocalFree( pbCert );
        pbCert = NULL;
    }

    if ( SUCCEEDED( hres ) )
    {
        wcsncpy( pszResKey, achIndex, METADATA_MAX_NAME_LEN + 1 );
        pszResKey[ METADATA_MAX_NAME_LEN ] ='\0';
    }
    VariantClear( &vKeyUI4 );  
    VariantClear( &vKeyBSTR );

    return hres;
}


//
// IIS5, IIS51 mapping functions
// They call IIS6 mapping function when connecting to IIS6 box
//

HRESULT
CIISDsCrMap::CreateMapping(
    VARIANT     vCert,
    BSTR        bstrNtAcct,
    BSTR        bstrNtPwd,
    BSTR        bstrName,
    LONG        lEnabled
    )
/*++

Routine Description:

    Create a mapping entry

Arguments:

    vCert - X.509 certificate
    bstrNtAcct - NT acct to map to
    bstrNtPwd - NT pwd
    bstrName - friendly name for mapping entry
    lEnabled - 1 to enable mapping entry, 0 to disable it

Returns:

    COM status

--*/
{
    if ( m_fIsIIS6 )
    {
        return CreateMappingIIS6( vCert,
                                  bstrNtAcct,
                                  bstrNtPwd,
                                  bstrName,
                                  lEnabled );
    }
    
    HRESULT     hres;
    LPBYTE      pbCert = NULL;
    DWORD       cCert;
    LPSTR       pszNtAcct = NULL;
    LPSTR       pszNtPwd = NULL;
    LPSTR       pszName = NULL;
    LPBYTE      pRes;
    DWORD       cRes;
    DWORD       cName;
    DWORD       cNtAcct;
    DWORD       cNtPwd;
    WCHAR       achIndex[LOCAL_MAX_SIZE];
    VARIANT     vOldAcct;
    VARIANT     vOldCert;
    VARIANT     vOldPwd;
    VARIANT     vOldName;
    VARIANT     vOldEnabledFlag;
    PCCERT_CONTEXT pcCert = NULL;

    //
    // Do some sanity checks on the cert 
    //
    if ( SUCCEEDED( hres = GetStringFromVariant( &vCert, 
                                                 (LPSTR*)&pbCert,
                                                 &cCert,
                                                 FALSE ) ) )
    {
        //
        // try to construct a cert context
        //
        if ( !( pcCert = CertCreateCertificateContext( X509_ASN_ENCODING,
                                                       pbCert,
                                                       cCert ) ) )
        {
            DBGPRINTF((DBG_CONTEXT,
                       "Invalid cert passed to CreateMapping()\n"));
            //
            // If the decoding fails, GetLastError() returns an ASN1 decoding
            // error that is obtained by subtracting CRYPT_E_OSS_ERROR from the returned
            // error and looking in file asn1code.h for the actual error. To avoid the
            // cryptic ASN1 errors, we'll just return a general "invalid arg" error 
            //
            hres = RETURNCODETOHRESULT( E_INVALIDARG );
            FreeString( (LPSTR) pbCert );
            goto Exit;
        }

        CertFreeCertificateContext( pcCert );
    }
    else
    {
        goto Exit;
    }

    //
    // check if we already have a mapping for this cert; if we do, we'll replace that mapping
    // with the new one
    //
    if ( SUCCEEDED( hres = GetMapping( IISMAPPER_LOCATE_BY_CERT,
                                       vCert,
                                       &vOldCert,
                                       &vOldAcct,
                                       &vOldPwd,
                                       &vOldName,
                                       &vOldEnabledFlag ) ) )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "Replacing old 1-1 cert mapping with new mapping\n"));

        if ( FAILED( hres = SetName( IISMAPPER_LOCATE_BY_CERT,
                                     vCert,
                                     bstrName ) ) ||
             FAILED( hres = SetAcct( IISMAPPER_LOCATE_BY_CERT,
                                     vCert,
                                     bstrNtAcct ) ) ||
             FAILED( hres = SetPwd( IISMAPPER_LOCATE_BY_CERT,
                                    vCert,
                                    bstrNtPwd ) ) ||
             FAILED( hres = SetEnabled( IISMAPPER_LOCATE_BY_CERT,
                                        vCert,
                                        lEnabled ) ) )
        {
            hres; //NOP - Something failed 
        }
    }
    //
    // New mapping
    //
    else if ( hres == RETURNCODETOHRESULT( ERROR_PATH_NOT_FOUND ) )
    {
        //
        // check mapping exists, create if not
        //
        hres = OpenMd( L"Cert11", METADATA_PERMISSION_WRITE|METADATA_PERMISSION_READ );

        if ( hres == RETURNCODETOHRESULT( ERROR_PATH_NOT_FOUND ) )
        {
            if ( SUCCEEDED( hres = OpenMd( L"", 
                                           METADATA_PERMISSION_WRITE|METADATA_PERMISSION_READ ) ) )
            {
                hres = CreateMdObject( L"Cert11" );
                CloseMd( FALSE );

                // Reopen to the correct node.
                hres = OpenMd( L"Cert11", METADATA_PERMISSION_WRITE|METADATA_PERMISSION_READ );
            }
        }

        if ( FAILED( hres ) )
        {
            goto Exit;
        }

        //
        // adding mapping cert "0" means add @ end of list
        //

        if ( SUCCEEDED( hres = CreateMdObject( L"mappings/0" ) ) )
        {
            if ( SUCCEEDED( hres = GetMdData( L"", MD_NSEPM_ACCESS_CERT, DWORD_METADATA, &
                                              cRes, &pRes ) ) )
            {
                if ( cRes == sizeof(DWORD ) )
                {
                    wsprintfW( achIndex, L"mappings/%u", *(LPDWORD)pRes );

                    if ( FAILED( hres = GetStringFromBSTR( bstrNtAcct, &pszNtAcct, &cNtAcct ) ) ||
                         FAILED( hres = GetStringFromBSTR( bstrNtPwd, &pszNtPwd, &cNtPwd ) ) ||
                         FAILED( hres = GetStringFromBSTR( bstrName, &pszName, &cName ) ) ||
                         FAILED( hres = SetMdData( achIndex, MD_MAPENABLED, DWORD_METADATA, 
                                                   sizeof(DWORD), (LPBYTE)&lEnabled ) ) ||
                         FAILED( hres = SetMdData( achIndex, MD_MAPNAME, STRING_METADATA, 
                                                   cName, (LPBYTE)pszName ) ) ||
                         FAILED( hres = SetMdData( achIndex, MD_MAPNTPWD, STRING_METADATA, 
                                                   cNtPwd, (LPBYTE)pszNtPwd ) ) ||
                         FAILED( hres = SetMdData( achIndex, MD_MAPNTACCT, STRING_METADATA, 
                                                   cNtAcct, (LPBYTE)pszNtAcct ) ) ||
                         FAILED( hres = SetMdData( achIndex, MD_MAPCERT, BINARY_METADATA, 
                                                   cCert, (LPBYTE)pbCert ) ) )
                    {
                    }
                }   
                else
                {
                    hres = E_FAIL;
                }
            }
        }
    }

    CloseMd( SUCCEEDED( hres ) );

    FreeString( (LPSTR)pbCert );
    FreeString( pszNtAcct );
    FreeString( pszNtPwd );
    FreeString( pszName );

Exit:

    return hres;
}


HRESULT
CIISDsCrMap::GetMapping(
    LONG        lMethod,
    VARIANT     vKey,
    VARIANT*    pvCert,
    VARIANT*    pbstrNtAcct,
    VARIANT*    pbstrNtPwd,
    VARIANT*    pbstrName,
    VARIANT*    plEnabled
    )
/*++

Routine Description:

    Get a mapping entry using key

Arguments:

    lMethod - method to use for access ( IISMAPPER_LOCATE_BY_* )
    vKey - key to use to locate mapping
    pvCert - X.509 certificate
    pbstrNtAcct - NT acct to map to
    pbstrNtPwd - NT pwd
    pbstrName - friendly name for mapping entry
    plEnabled - 1 to enable mapping entry, 0 to disable it

Returns:

    COM status

--*/
{
    if ( m_fIsIIS6 )
    {
        return GetMappingIIS6( lMethod,
                               vKey,
                               pvCert,
                               pbstrNtAcct,
                               pbstrNtPwd,
                               pbstrName,
                               plEnabled );
    }
    
    WCHAR       achIndex[LOCAL_MAX_SIZE];
    HRESULT     hres;
    DWORD       dwLen;
    LPBYTE      pbData;

    VariantInit( pvCert );
    VariantInit( pbstrNtAcct );
    VariantInit( pbstrNtPwd );
    VariantInit( pbstrName );
    VariantInit( plEnabled );

    if ( SUCCEEDED( hres = OpenMd( L"Cert11", 
                                   METADATA_PERMISSION_WRITE|METADATA_PERMISSION_READ ) ) )
    {
        if ( SUCCEEDED(hres = Locate( lMethod, vKey, achIndex )) )
        {
            if ( SUCCEEDED( hres = GetMdData( achIndex, MD_MAPCERT, BINARY_METADATA, &dwLen, 
                                              &pbData ) ) )
            {
                hres = SetVariantAsByteArray( pvCert, dwLen, pbData );
                LocalFree( pbData );
            }
            else
            {
                goto Done;
            }

            if ( SUCCEEDED( hres = GetMdData( achIndex, MD_MAPNTACCT, STRING_METADATA, &dwLen, 
                                              &pbData ) ) )
            {
                hres = SetVariantAsBSTR( pbstrNtAcct, dwLen, pbData );
                LocalFree( pbData );
            }
            else
            {
                goto Done;
            }

            if ( SUCCEEDED( hres = GetMdData( achIndex, MD_MAPNTPWD, STRING_METADATA, &dwLen, 
                                              &pbData ) ) )
            {
                hres = SetVariantAsBSTR( pbstrNtPwd, dwLen, pbData );
                LocalFree( pbData );
            }
            else
            {
                goto Done;
            }

            if ( SUCCEEDED( hres = GetMdData( achIndex, MD_MAPNAME, STRING_METADATA, &dwLen, 
                                              &pbData ) ) )
            {
                hres = SetVariantAsBSTR( pbstrName, dwLen, pbData );
                LocalFree( pbData );
            }
            else
            {
                goto Done;
            }

            if ( FAILED( hres = GetMdData( achIndex, MD_MAPENABLED, STRING_METADATA, &dwLen, 
                                           &pbData ) ) )
            {
                SetVariantAsLong( plEnabled, FALSE );
            }
            else
            {
                SetVariantAsLong( plEnabled, *(LPDWORD)pbData );
                LocalFree( pbData );
            }
        }

Done:
        CloseMd( FALSE );
    }

    return hres;
}


HRESULT
CIISDsCrMap::DeleteMapping(
    LONG        lMethod,
    VARIANT     vKey
    )
/*++

Routine Description:

    Delete a mapping entry using key

Arguments:

    lMethod - method to use for access ( IISMAPPER_LOCATE_BY_* )
    vKey - key to use to locate mapping

Returns:

    COM status

--*/
{
    if ( m_fIsIIS6 )
    {
        return DeleteMappingIIS6( lMethod,
                                  vKey );
    }
    WCHAR       achIndex[LOCAL_MAX_SIZE];
    HRESULT     hres;

    if ( SUCCEEDED( hres = OpenMd( L"Cert11", 
                                   METADATA_PERMISSION_WRITE|METADATA_PERMISSION_READ ) ) )
    {
        if ( SUCCEEDED(hres = Locate( lMethod, vKey, achIndex )) )
        {
            hres = DeleteMdObject( achIndex );
        }
        CloseMd( TRUE );
    }

    return hres;
}


HRESULT
CIISDsCrMap::SetEnabled(
    LONG        lMethod,
    VARIANT     vKey,
    LONG        lEnabled
    )
/*++

Routine Description:

    Set the enable flag on a mapping entry using key

Arguments:

    lMethod - method to use for access ( IISMAPPER_LOCATE_BY_* )
    vKey - key to use to locate mapping
    lEnabled - 1 to enable, 0 to disable

Returns:

    COM status

--*/
{
    if ( m_fIsIIS6 )
    {
        return SetEnabledIIS6( lMethod,
                               vKey,
                               lEnabled );
    }
    
    WCHAR       achIndex[LOCAL_MAX_SIZE];
    HRESULT     hres;

    if ( SUCCEEDED( hres = OpenMd( L"Cert11", 
                                   METADATA_PERMISSION_WRITE|METADATA_PERMISSION_READ ) ) )
    {
        if ( SUCCEEDED(hres = Locate( lMethod, vKey, achIndex )) )
        {
            hres = SetMdData( achIndex, MD_MAPENABLED, DWORD_METADATA, sizeof(DWORD), (LPBYTE)&lEnabled );
        }
        CloseMd( TRUE );
    }

    return hres;
}


HRESULT
CIISDsCrMap::SetName(
    LONG        lMethod,
    VARIANT     vKey,
    BSTR        bstrName
    )
/*++

Routine Description:

    Set the Name on a mapping entry using key

Arguments:

    lMethod - method to use for access ( IISMAPPER_LOCATE_BY_* )
    vKey - key to use to locate mapping
    bstrName - name to assign to mapping entry

Returns:

    COM status

--*/
{
    if ( m_fIsIIS6 )
    {
        return SetNameIIS6( lMethod,
                            vKey,
                            bstrName );
    }

    return SetString( lMethod, vKey, bstrName, MD_MAPNAME );
}


HRESULT
CIISDsCrMap::SetString(
    LONG        lMethod,
    VARIANT     vKey,
    BSTR        bstrName,
    DWORD       dwProp
    )
/*++

Routine Description:

    Set a string property on a mapping entry using key

Arguments:

    lMethod - method to use for access ( IISMAPPER_LOCATE_BY_* )
    vKey - key to use to locate mapping
    bstrName - string content to assign to mapping entry
    dwProp - property ID to assign to

Returns:

    COM status

--*/
{
    WCHAR       achIndex[LOCAL_MAX_SIZE];
    LPSTR       pszName = NULL;
    HRESULT     hres;
    DWORD       dwLen;


    if ( FAILED( hres = GetStringFromBSTR( bstrName, &pszName, &dwLen, TRUE ) ) )
    {
        return hres;
    }

    if ( SUCCEEDED( hres = OpenMd( L"Cert11", 
                                   METADATA_PERMISSION_WRITE|METADATA_PERMISSION_READ ) ) )
    {
        if ( SUCCEEDED(hres = Locate( lMethod, vKey, achIndex )) )
        {
            hres = SetMdData( achIndex, dwProp, STRING_METADATA, dwLen, (LPBYTE)pszName );
        }
        CloseMd( TRUE );
    }

    FreeString( pszName );

    return hres;
}


HRESULT
CIISDsCrMap::SetPwd(
    LONG        lMethod,
    VARIANT     vKey,
    BSTR        bstrPwd
    )
/*++

Routine Description:

    Set the Password on a mapping entry using key

Arguments:

    lMethod - method to use for access ( IISMAPPER_LOCATE_BY_* )
    vKey - key to use to locate mapping
    bstrPwd - password to assign to mapping entry

Returns:

    COM status

--*/
{
    if ( m_fIsIIS6 )
    {
        return SetPwdIIS6( lMethod,
                           vKey,
                           bstrPwd );
    }

    return SetString( lMethod, vKey, bstrPwd, MD_MAPNTPWD );
}


HRESULT
CIISDsCrMap::SetAcct(
    LONG        lMethod,
    VARIANT     vKey,
    BSTR        bstrAcct
    )
/*++

Routine Description:

    Set the NT account name on a mapping entry using key

Arguments:

    lMethod - method to use for access ( IISMAPPER_LOCATE_BY_* )
    vKey - key to use to locate mapping
    bstrAcct - NT account name to assign to mapping entry

Returns:

    COM status

--*/
{
    if ( m_fIsIIS6 )
    {
        return SetAcctIIS6( lMethod,
                            vKey,
                            bstrAcct );
    }

    return SetString( lMethod, vKey, bstrAcct, MD_MAPNTACCT );
}



////


HRESULT
CIISDsCrMap::OpenMd(
    LPWSTR  pszOpenPath,
    DWORD   dwPermission
    )
/*++

Routine Description:

    Open metabase using path & permission
    path is relative to the top of the name space extension ( i.e. /.../<nsepm> )

Arguments:

    pszOpenPath - path to open inside name space extension
    dwPermission - metabase permission ( read/write )

Returns:

    COM status

--*/
{
    HRESULT hres;
    LPWSTR  pszPath;
    UINT    cL = wcslen( m_pszMetabasePath );

    pszPath = (LPWSTR)LocalAlloc( LMEM_FIXED, (wcslen(pszOpenPath) + 1 + cL + 1)*sizeof(WCHAR) );

    if ( pszPath == NULL )
    {
        return E_OUTOFMEMORY;
    }

    memcpy( pszPath, m_pszMetabasePath, cL * sizeof(WCHAR) );
    if ( cL && m_pszMetabasePath[cL-1] != L'/' && *pszOpenPath && *pszOpenPath != L'/' )
    {
        pszPath[cL++] = L'/';
    }
    wcscpy( pszPath + cL, pszOpenPath );

    hres = OpenAdminBaseKey(
                m_pszServerName,
                pszPath,
                dwPermission,
                &m_pcAdmCom,
                &m_hmd
                );

    LocalFree( pszPath );

    if ( FAILED(hres) )
    {
        m_hmd = NULL;
    }

    return hres;
}


HRESULT
CIISDsCrMap::CloseMd(
    BOOL fSave
    )
/*++

Routine Description:

    close metabase

Arguments:

    fSave - TRUE to save data immediatly

Returns:

    COM status

--*/
{
    CloseAdminBaseKey( m_pcAdmCom, m_hmd );
    m_hmd = NULL;
    
    if ( m_pcAdmCom && fSave )
    {
        m_pcAdmCom->SaveData();
    }

    return S_OK;
}


HRESULT
CIISDsCrMap::DeleteMdObject(
    LPWSTR  pszKey
    )
/*++

Routine Description:

    Delete metabase object in an opened tree
    OpenMd() must be called 1st

Arguments:

    pszKey - key to delete in opened metabase

Returns:

    COM status

--*/
{
    return m_pcAdmCom->DeleteKey( m_hmd, pszKey );
}


HRESULT
CIISDsCrMap::CreateMdObject(
    LPWSTR  pszKey
    )
/*++

Routine Description:

    Create metabase object in an opened tree
    OpenMd() must be called 1st

Arguments:

    pszKey - key to create in opened metabase

Returns:

    COM status

--*/
{
    return m_pcAdmCom->AddKey( m_hmd, pszKey );
}


HRESULT
CIISDsCrMap::SetMdData( 
    LPWSTR  achIndex, 
    DWORD   dwProp,
    DWORD   dwDataType,
    DWORD   dwDataLen,
    LPBYTE  pbData 
    )
/*++

Routine Description:

    Set a metabase property
    OpenMd() must be called 1st
    Property will be stored with NULL attribute, except for MD_MAPPWD
     which will be stored with METADATA_SECURE

Arguments:

    achIndex - key name where to store property
    dwProp - property ID
    dwDataType - property data type
    dwDataLen - property length
    pbData - property value

Returns:

    COM status

--*/
{
    METADATA_RECORD     md;

    md.dwMDDataLen = dwDataLen;
    md.dwMDDataType = dwDataType;
    md.dwMDIdentifier = dwProp;
    md.dwMDAttributes = (dwProp == MD_MAPNTPWD) ? METADATA_SECURE : 0;
    md.pbMDData = pbData;

    return m_pcAdmCom->SetData( m_hmd, achIndex, &md );
}


HRESULT
CIISDsCrMap::GetMdData( 
    LPWSTR  achIndex, 
    DWORD   dwProp,
    DWORD   dwDataType,
    LPDWORD pdwDataLen,
    LPBYTE* ppbData 
    )
/*++

Routine Description:

    Get a metabase property
    OpenMd() must be called 1st

Arguments:

    achIndex - key name where to get property
    dwProp - property ID
    dwDataType - property data type
    pdwDataLen - property length
    ppData - property value, to be freed using LocalFree() on successfull return

Returns:

    COM status

--*/
{
    HRESULT             hres;
    METADATA_RECORD     md;
    DWORD               dwRequired;

    md.dwMDDataLen = 0;
    md.dwMDDataType = dwDataType;
    md.dwMDIdentifier = dwProp;
    md.dwMDAttributes = 0;
    md.pbMDData = NULL;

    if ( FAILED(hres = m_pcAdmCom->GetData( m_hmd, achIndex, &md, &dwRequired )) )
    {
        if ( hres == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER) )
        {
            if ( (*ppbData = (LPBYTE)LocalAlloc( LMEM_FIXED, dwRequired )) == NULL )
            {
                return E_OUTOFMEMORY;
            }
            md.pbMDData = *ppbData;
            md.dwMDDataLen = dwRequired;
            hres = m_pcAdmCom->GetData( m_hmd, achIndex, &md, &dwRequired );
            *pdwDataLen = md.dwMDDataLen;
        }
    }
    else
    {
       *pdwDataLen = 0;
       *ppbData = NULL;
    }

    return hres;
}


//////

HRESULT
CIISDsCrMap::Locate(
    LONG    lMethod,
    VARIANT vKey,
    LPWSTR  pszResKey
    )
/*++

Routine Description:

    Locate a mapping entry based on key
    OpenMd() must be called 1st

Arguments:

    lMethod - method to use for access ( IISMAPPER_LOCATE_BY_* )
    vKey - key to use to locate mapping
    pszResKey - 

Returns:

    COM status

--*/
{
    if ( m_fIsIIS6 )
    {
        return LocateIIS6( lMethod,
                           vKey,
                           pszResKey );
    }
    
    HRESULT     hres;
    LPSTR       pV = NULL;
    DWORD       cV;
    DWORD       dwProp;
    LPSTR       pRes;
    DWORD       cRes;
    BOOL        fAddDelim = TRUE;

    //
    // determine method
    //

    switch ( lMethod )
    {
        case IISMAPPER_LOCATE_BY_CERT:
            dwProp = MD_NSEPM_ACCESS_CERT;
            fAddDelim = FALSE;
            break;

        case IISMAPPER_LOCATE_BY_NAME:
            dwProp = MD_NSEPM_ACCESS_NAME;
            break;

        case IISMAPPER_LOCATE_BY_ACCT:
            dwProp = MD_NSEPM_ACCESS_ACCOUNT;
            break;

        case IISMAPPER_LOCATE_BY_INDEX:
            if ( SUCCEEDED( hres = GetStringFromVariant( &vKey, &pV, &cV, TRUE ) ) )
            {
                WCHAR       pwV[LOCAL_MAX_SIZE]; 
                int i = MultiByteToWideChar(CP_ACP, 0, pV, cV, pwV, LOCAL_MAX_SIZE);
                
                if (i ==0) 
                    return E_FAIL;  // MultiByteToWideChar failure
                if (i >= (int)(LOCAL_MAX_SIZE - wcslen(L"mappings/"))) 
                    return E_FAIL;  //pwV is too big for pszResKey
                
                wsprintfW( pszResKey, L"mappings/%s", pwV );
            }
            goto Exit;

        default:
            return E_FAIL;
    }

    //
    // get ptr to data
    //

    if ( SUCCEEDED( hres = GetStringFromVariant( &vKey, &pV, &cV, fAddDelim ) ) )
    {
        //
        // set search prop, get result
        //

        if ( SUCCEEDED( hres = SetMdData( L"", dwProp, BINARY_METADATA, cV, (LPBYTE)pV ) ) )
        {
            if ( SUCCEEDED( hres = GetMdData( L"", dwProp, DWORD_METADATA, &cRes, (LPBYTE*)&pRes ) ) )
            {
                if ( cRes == sizeof(DWORD ) )
                {
                    wsprintfW( pszResKey, L"mappings/%u", *(LPDWORD)pRes );
                }
                else
                {
                    hres = E_FAIL;
                }
                LocalFree( pRes );
            }
        }
    }

Exit:

    FreeString( pV );

    return hres;
}


HRESULT
GetStringFromBSTR( 
    BSTR    bstr,
    LPSTR*  psz,
    LPDWORD pdwLen,
    BOOL    fAddDelimInCount
    )
/*++

Routine Description:

    Allocate string buffer from BSTR

Arguments:

    bstr - bstr to convert from
    psz - updated with ptr to buffer, to be freed with FreeString()
    pdwLen - updated with strlen(string), incremented by 1 if fAddDelimInCount is TRUE
    fAddDelimInCount - TRUE to increment *pdwLen 

Returns:

    COM status

--*/
{
    UINT    cch = SysStringLen(bstr);
    UINT    cchT;

    // include NULL terminator

    *pdwLen = cch + (fAddDelimInCount ? 1 : 0);

    CHAR *szNew = (CHAR*)LocalAlloc( LMEM_FIXED, (2 * cch) + 1);			// * 2 for worst case DBCS string
    if (szNew == NULL)
    {
        return E_OUTOFMEMORY;
    }

    cchT = WideCharToMultiByte(CP_ACP, 0, bstr, cch + 1, szNew, (2 * cch) + 1, NULL, NULL);

    *psz = szNew;

    return NOERROR;
}


HRESULT
GetStringFromVariant( 
    VARIANT*    pVar,
    LPSTR*      psz,
    LPDWORD     pdwLen,
    BOOL        fAddDelim
    )
/*++

Routine Description:

    Allocate string buffer from BSTR

Arguments:

    pVar - variant to convert from. Recognizes BSTR, VT_ARRAY|VT_UI1, ByRef or ByVal
    psz - updated with ptr to buffer, to be freed with FreeString()
    pdwLen - updated with size of input, incremented by 1 if fAddDelimInCount is TRUE
    fAddDelimInCount - TRUE to increment *pdwLen 

Returns:

    COM status

--*/
{
    LPBYTE  pbV;
    UINT    cV;
    HRESULT hres;
    WORD    vt = V_VT(pVar);
    BOOL    fByRef = FALSE;
    VARIANT vOut;

    VariantInit( &vOut );

    if ( vt & VT_BYREF )
    {
        vt &= ~VT_BYREF;
        fByRef = TRUE;
    }

    if ( vt == VT_DISPATCH )
    {
        if ( FAILED(hres = VariantResolveDispatch( &vOut, pVar )) )
        {
            return hres;
        }
        pVar = &vOut;
        vt = V_VT(pVar);
        if ( fByRef = vt & VT_BYREF )
        {
            vt &= ~VT_BYREF;
        }
    }

    // if pVar is BSTR, convert to multibytes

    if ( vt == VT_VARIANT )
    {
        pVar = (VARIANT*)V_BSTR(pVar);
        vt = V_VT(pVar);
        if ( fByRef = vt & VT_BYREF )
        {
            vt &= ~VT_BYREF;
        }
    }

    if ( vt == VT_BSTR )
    {
        hres = GetStringFromBSTR( fByRef ? 
                                    *(BSTR*)V_BSTR(pVar) :
                                    V_BSTR(pVar), 
                                  psz, 
                                  pdwLen,
                                  fAddDelim );
    }
    else if( vt == (VT_ARRAY | VT_UI1) )
    {
        long        lBound, uBound, lItem;
        BYTE        bValue;
        SAFEARRAY*  pSafeArray;

   
        // array of VT_UI1 (probably OctetString)
   
        pSafeArray  = fByRef ? *(SAFEARRAY**)V_BSTR(pVar) : V_ARRAY( pVar );

        hres = SafeArrayGetLBound(pSafeArray, 1, &lBound);
        hres = SafeArrayGetUBound(pSafeArray, 1, &uBound);

        cV = uBound - lBound + 1;

        if ( !(pbV = (LPBYTE)LocalAlloc( LMEM_FIXED, cV )) )
        {
            hres = E_OUTOFMEMORY;
            goto Exit;
        }

        hres = S_OK;

        for( lItem = lBound; lItem <= uBound ; lItem++ )
        {
            hres  = SafeArrayGetElement( pSafeArray, &lItem, &bValue );
            if( FAILED( hres ) )
            {
                break;
            }
            pbV[lItem-lBound] = bValue;
        }

        *psz = (LPSTR)pbV;
        *pdwLen = cV;
    }
    else if( vt == (VT_ARRAY | VT_VARIANT) )
    {
        long        lBound, uBound, lItem;
        VARIANT     vValue;
        BYTE        bValue;
        SAFEARRAY*  pSafeArray;

   
        // array of VT_VARIANT (probably VT_I4 )
   
        pSafeArray  = fByRef ? *(SAFEARRAY**)V_BSTR(pVar) : V_ARRAY( pVar );

        hres = SafeArrayGetLBound(pSafeArray, 1, &lBound);
        hres = SafeArrayGetUBound(pSafeArray, 1, &uBound);

        cV = uBound - lBound + 1;

        if ( !(pbV = (LPBYTE)LocalAlloc( LMEM_FIXED, cV )) )
        {
            hres = E_OUTOFMEMORY;
            goto Exit;
        }

        hres = S_OK;

        for( lItem = lBound; lItem <= uBound ; lItem++ )
        {
            hres  = SafeArrayGetElement( pSafeArray, &lItem, &vValue );
            if( FAILED( hres ) )
            {
                break;
            }
            if ( V_VT(&vValue) == VT_UI1 )
            {
                bValue = V_UI1(&vValue);
            }
            else if ( V_VT(&vValue) == VT_I2 )
            {
                bValue = (BYTE)V_I2(&vValue);
            }
            else if ( V_VT(&vValue) == VT_I4 )
            {
                bValue = (BYTE)V_I4(&vValue);
            }
            else
            {
                bValue = 0;
            }
            pbV[lItem-lBound] = bValue;
        }

        *psz = (LPSTR)pbV;
        *pdwLen = cV;
    }
    else
    {
        hres = E_FAIL;
    }

Exit:
    VariantClear( &vOut );

    return hres;
}



HRESULT
GetStringAFromBSTR( 
    BSTR    bstr,
    LPSTR*  psz,
    LPDWORD pdwLen,
    BOOL    fAddDelimInCount
    )
/*++

Routine Description:

    Allocate string buffer from BSTR - for IIS6 only

Arguments:

    bstr - bstr to convert from
    psz - updated with ptr to buffer, to be freed with FreeString()
    pdwLen - updated with strlen(string), incremented by 1 if fAddDelimInCount is TRUE
    fAddDelimInCount - TRUE to increment *pdwLen 

Returns:

    COM status

--*/
{
    UINT    cch = SysStringLen(bstr);
    UINT    cchT;

    // include NULL terminator

    *pdwLen = cch + (fAddDelimInCount ? 1 : 0);

    CHAR *szNew = (CHAR*)LocalAlloc( LMEM_FIXED, (2 * cch) + 1);			// * 2 for worst case DBCS string
    if (szNew == NULL)
    {
        return E_OUTOFMEMORY;
    }

    cchT = WideCharToMultiByte(CP_ACP, 0, bstr, cch + 1, szNew, (2 * cch) + 1, NULL, NULL);

    *psz = szNew;

    return NOERROR;
}



HRESULT
GetBlobFromVariant( 
    VARIANT*    pVar,
    PBYTE*      ppbOut,
    LPDWORD     pcbOut
  )
/*++

Routine Description:

    Allocate string buffer from BSTR - for IIS6 only

Arguments:

    pVar - variant to convert from. Recognizes BSTR, VT_ARRAY|VT_UI1, ByRef or ByVal
    ppbOut - updated with ptr to buffer, to be freed with LocalFree()
    pcbOut - updated with size of input
    

Returns:

    COM status

--*/
{
    LPBYTE  pbV;
    UINT    cV;
    HRESULT hres;
    WORD    vt = V_VT(pVar);
    BOOL    fByRef = FALSE;
    VARIANT vOut;

    VariantInit( &vOut );

    if ( vt & VT_BYREF )
    {
        vt &= ~VT_BYREF;
        fByRef = TRUE;
    }

    if ( vt == VT_DISPATCH )
    {
        if ( FAILED(hres = VariantResolveDispatch( &vOut, pVar )) )
        {
            return hres;
        }
        pVar = &vOut;
        vt = V_VT(pVar);
        if ( fByRef = vt & VT_BYREF )
        {
            vt &= ~VT_BYREF;
        }
    }

    // if pVar is BSTR, convert to multibytes

    if ( vt == VT_VARIANT )
    {
        pVar = (VARIANT*)V_BSTR(pVar);
        vt = V_VT(pVar);
        if ( fByRef = vt & VT_BYREF )
        {
            vt &= ~VT_BYREF;
        }
    }

    if ( vt == VT_BSTR )
    {
        hres = GetStringAFromBSTR( fByRef ? 
                                    *(BSTR*)V_BSTR(pVar) :
                                    V_BSTR(pVar), 
                                  (LPSTR *)ppbOut, 
                                  pcbOut,
                                  FALSE );
    }
    else if( vt == (VT_ARRAY | VT_UI1) )
    {
        long        lBound, uBound, lItem;
        BYTE        bValue;
        SAFEARRAY*  pSafeArray;

   
        // array of VT_UI1 (probably OctetString)
   
        pSafeArray  = fByRef ? *(SAFEARRAY**)V_BSTR(pVar) : V_ARRAY( pVar );

        hres = SafeArrayGetLBound(pSafeArray, 1, &lBound);
        hres = SafeArrayGetUBound(pSafeArray, 1, &uBound);

        cV = uBound - lBound + 1;

        if ( !(pbV = (LPBYTE)LocalAlloc( LMEM_FIXED, cV )) )
        {
            hres = E_OUTOFMEMORY;
            goto Exit;
        }

        hres = S_OK;

        for( lItem = lBound; lItem <= uBound ; lItem++ )
        {
            hres  = SafeArrayGetElement( pSafeArray, &lItem, &bValue );
            if( FAILED( hres ) )
            {
                break;
            }
            pbV[lItem-lBound] = bValue;
        }

        *ppbOut = pbV;
        *pcbOut = cV;
    }
    else if( vt == (VT_ARRAY | VT_VARIANT) )
    {
        long        lBound, uBound, lItem;
        VARIANT     vValue;
        BYTE        bValue;
        SAFEARRAY*  pSafeArray;

   
        // array of VT_VARIANT (probably VT_I4 )
   
        pSafeArray  = fByRef ? *(SAFEARRAY**)V_BSTR(pVar) : V_ARRAY( pVar );

        hres = SafeArrayGetLBound(pSafeArray, 1, &lBound);
        hres = SafeArrayGetUBound(pSafeArray, 1, &uBound);

        cV = uBound - lBound + 1;

        if ( !(pbV = (LPBYTE)LocalAlloc( LMEM_FIXED, cV )) )
        {
            hres = E_OUTOFMEMORY;
            goto Exit;
        }

        hres = S_OK;

        for( lItem = lBound; lItem <= uBound ; lItem++ )
        {
            hres  = SafeArrayGetElement( pSafeArray, &lItem, &vValue );
            if( FAILED( hres ) )
            {
                break;
            }
            if ( V_VT(&vValue) == VT_UI1 )
            {
                bValue = V_UI1(&vValue);
            }
            else if ( V_VT(&vValue) == VT_I2 )
            {
                bValue = (BYTE)V_I2(&vValue);
            }
            else if ( V_VT(&vValue) == VT_I4 )
            {
                bValue = (BYTE)V_I4(&vValue);
            }
            else
            {
                bValue = 0;
            }
            pbV[lItem-lBound] = bValue;
        }

        *ppbOut = pbV;
        *pcbOut = cV;
    }
    else
    {
        hres = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

Exit:
    VariantClear( &vOut );

    return hres;
}




VOID
FreeString( 
    LPSTR   psz 
    )
/*++

Routine Description:

    Free a string returned by GetStringFromVariant() or GetStringFromBTR()
    can be NULL

Arguments:

    psz - string to free, can be NULL

Returns:

    Nothing

--*/
{
    if ( psz )
    {
        LocalFree( psz );
    }
}


HRESULT
SetBSTR( 
    BSTR*   pbstrRet,
    DWORD   cch, 
    LPBYTE  sz 
    )
/*++

Routine Description:

    Build a BSTR from byte array - for IIS5, IIS5.1 assumes ansi string on input

Arguments:

    pbstrRet - updated with BSTR
    cch - byte count in sz
    sz - byte array

Returns:

    COM status

--*/
{
    BSTR bstrRet;
    
    if (sz == NULL)
    {
        *pbstrRet = NULL;
        return(NOERROR);
    }
        
    // Allocate a string of the desired length
    // SysAllocStringLen allocates enough room for unicode characters plus a null
    // Given a NULL string it will just allocate the space

    bstrRet = SysAllocStringLen(NULL, cch);
    if (bstrRet == NULL)
    {
        return(E_OUTOFMEMORY);
    }

    // If we were given "", we will have cch=0.  return the empty bstr
    // otherwise, really copy/convert the string
    // NOTE we pass -1 as 4th parameter of MultiByteToWideChar for DBCS support

    if (cch != 0)
    {
        UINT cchTemp = 0;
        if (MultiByteToWideChar(CP_ACP, 0, (LPSTR)sz, -1, bstrRet, cch+1) == 0)
        {
            SysFreeString(bstrRet);
            return(HRESULT_FROM_WIN32(GetLastError()));
        }

        // If there are some DBCS characters in the sz(Input), then, the character count of BSTR(DWORD) is 
        // already set to cch(strlen(sz)) in SysAllocStringLen(NULL, cch), we cannot change the count, 
        // and later call of SysStringLen(bstr) always returns the number of characters specified in the
        // cch parameter at allocation time.  Bad, because one DBCS character(2 bytes) will convert
        // to one UNICODE character(2 bytes), not 2 UNICODE characters(4 bytes).
        // Example: For input sz contains only one DBCS character, we want to see SysStringLen(bstr) 
        // = 1, not 2.

        bstrRet[cch] = 0;
        cchTemp = wcslen(bstrRet);
        if (cchTemp < cch)
        {
            BSTR bstrTemp = SysAllocString(bstrRet);
            SysFreeString(bstrRet);
            bstrRet = bstrTemp;	
            cch = cchTemp;
        }
    }

   if (bstrRet != NULL)
       bstrRet[cch] = 0;
    *pbstrRet = bstrRet;

    return(NOERROR);
}




HRESULT
SetBSTRFromStringW( 
    BSTR*   pbstrRet,
    DWORD   cb, 
    LPBYTE  sz 
    )
/*++

Routine Description:

    Build a BSTR from byte array (that is actually WCHAR string) 

Arguments:

    pbstrRet - updated with BSTR
    cb - byte count 
    sz - byte array (we assume WCHAR string)

Returns:

    COM status

--*/
{
    BSTR bstrRet;
    
    if (sz == NULL)
    {
        *pbstrRet = NULL;
        return(NOERROR);
    }
        
    // Allocate a string of the desired length
    // SysAllocStringLen allocates enough room for unicode characters plus a null
    // Given a NULL string it will just allocate the space

    bstrRet = SysAllocStringLen(NULL, cb/sizeof(WCHAR));
    if (bstrRet == NULL)
    {
        return(E_OUTOFMEMORY);
    }
    wcsncpy( bstrRet, (WCHAR *) sz, cb/sizeof(WCHAR) );

    *pbstrRet = bstrRet;

    return(NOERROR);
}


HRESULT
CIISDsCrMap::Create(
    IUnknown *pUnkOuter,
    REFIID riid,
    void **ppvObj
    )
/*++

Routine Description:

    Create a CIISDsCrMap

Arguments:

    pUnkOuter - ptr to iunknown
    riid - requested IID
    ppvObj - updated with ptr to requested IID

Returns:

    COM status

--*/
{
    CCredentials Credentials;
    CIISDsCrMap FAR * pMap = NULL;
    HRESULT hr = S_OK;
    BSTR bstrAdsPath = NULL;
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer * pLexer = NULL;
    LPWSTR pszIISPathName = NULL;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
  
    hr = AllocateObject(pUnkOuter, Credentials, &pMap);
    BAIL_ON_FAILURE(hr);

    //
    // get ServerName and pszPath
    //

    hr = pMap->_pADs->get_ADsPath(&bstrAdsPath);
    BAIL_ON_FAILURE(hr);

    pLexer = new CLexer();
    hr = pLexer->Initialize(bstrAdsPath);
    BAIL_ON_FAILURE(hr);

    //
    // Parse the pathname
    //

    hr = ADsObject(pLexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    pszIISPathName = AllocADsStr(bstrAdsPath);
    if (!pszIISPathName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    *pszIISPathName = L'\0';
    hr = BuildIISPathFromADsPath(
                    pObjectInfo,
                    pszIISPathName
                    );
    BAIL_ON_FAILURE(hr);

    hr = pMap->Init( pObjectInfo->TreeName,
                     pszIISPathName );
    BAIL_ON_FAILURE(hr);

    //
    // pass non-delegating IUnknown back to the aggregator
    //

    *ppvObj = (INonDelegatingUnknown FAR *) pMap;

    if (bstrAdsPath) {
        ADsFreeString(bstrAdsPath);
    }

    if (pLexer) {
        delete pLexer;
    }

    if (pszIISPathName ) {
        FreeADsStr( pszIISPathName );
    }

    FreeObjectInfo( &ObjectInfo );

    RRETURN(hr);

error:

    if (bstrAdsPath) {
        ADsFreeString(bstrAdsPath);
    }

    if (pLexer) {
        delete pLexer;
    }

    if (pszIISPathName ) {
        FreeADsStr( pszIISPathName );
    }

    FreeObjectInfo( &ObjectInfo );

    *ppvObj = NULL;

    delete pMap;

    RRETURN(hr);
}


STDMETHODIMP
CIISDsCrMap::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
/*++

Routine Description:

    Query interface to CIISDsCrMap

Arguments:

    iid - requested IID
    ppv - updated with ptr to requested IID

Returns:

    COM status

--*/
{
    HRESULT hr = S_OK;

    hr = _pUnkOuter->QueryInterface(iid,ppv);

    RRETURN(hr);
}


CIISDsCrMap::CIISDsCrMap(
    )
/*++

Routine Description:

    CIISDsCrMap constructor

Arguments:

    pADs - ptr to contained ADs
    Credentials - credential
    pDispMgr - ptr to dispatch manager

Returns:

    Nothing

--*/
{ 
    m_pcAdmCom = NULL; 
    m_hmd = NULL; 
    m_pszServerName = NULL; 
    m_pszMetabasePath = NULL; 
    m_ADsPath = NULL; 
    _pADs = NULL; 
    _pDispMgr = NULL; 
    m_fIsIIS6 = TRUE;
    ENLIST_TRACKING(CIISDsCrMap);
}


CIISDsCrMap::~CIISDsCrMap(
    )
/*++

Routine Description:

    CIISDsCrMap destructor

Arguments:

    None

Returns:

    Nothing

--*/
{
    if ( m_ADsPath ) 
    {
        ADsFreeString( m_ADsPath );
    }

    if ( m_pszServerName ) 
    {
        LocalFree( m_pszServerName );
    }

    if ( m_pszMetabasePath )
    {
        LocalFree( m_pszMetabasePath );
    }

    if ( _pDispMgr )
    {
        delete _pDispMgr;
    }
}


HRESULT
CIISDsCrMap::AllocateObject(
    IUnknown *pUnkOuter,
    CCredentials& Credentials,
    CIISDsCrMap ** ppMap
    )
/*++

Routine Description:

    Allocate CIISDsCrMap

Arguments:

    pUnkOuter - ptr to iunknown
    Credentials - credential
    ppMap - updated with ptr to IUnknown to Allocated object

Returns:

    COM status

--*/
{
    CIISDsCrMap FAR * pMap = NULL;
    IADs FAR * pADs = NULL;
    CAggregateeDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pDispMgr = new CAggregateeDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pMap = new CIISDsCrMap();
    if (pMap == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                LIBID_IISExt,   //LIBID_ADs,
                IID_IISDsCrMap,
                (IISDsCrMap *)pMap,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    //
    // Store the IADs Pointer, but again do NOT ref-count
    // this pointer - we keep the pointer around, but do
    // a release immediately.
    //

    hr = pUnkOuter->QueryInterface(IID_IADs, (void **)&pADs);
    pADs->Release();
    pMap->_pADs = pADs;

    //
    // Store the pointer to the pUnkOuter object
    // AND DO NOT add ref this pointer
    //

    pMap->_pUnkOuter = pUnkOuter;

    pMap->m_Credentials = Credentials;
    pMap->_pDispMgr = pDispMgr;
    *ppMap = pMap;

    RRETURN(hr);

error:
    delete  pDispMgr;
    delete  pMap;

    RRETURN(hr);
}


HRESULT
CIISDsCrMap::Init( 
    LPWSTR  pszServerName, 
    LPWSTR  pszMetabasePath 
    )
/*++

Routine Description:

    Initialize CIISDsCrMap

Arguments:

    pszServerName - target computer name for metabase access
    pszParent - metabase path to IisMapper object

Returns:

    COM status

--*/
{
    UINT cL;
    HRESULT hr = S_OK;
    DWORD dwMajVer = 0;
    DWORD dwLen = 0;
    METADATA_RECORD mr = {
        MD_SERVER_VERSION_MAJOR, 
        METADATA_NO_ATTRIBUTES,
        IIS_MD_UT_SERVER,
        DWORD_METADATA,
        sizeof(DWORD),
        (unsigned char*)&dwMajVer,
        0
        };  
    
    hr = InitServerInfo(pszServerName, &m_pcAdmCom);
    BAIL_ON_FAILURE(hr);

    // need to set m_fIsIIS6
    METADATA_HANDLE MDataHandle;
    hr = OpenAdminBaseKey(pszServerName,
            L"/LM/W3SVC/Info",
            METADATA_PERMISSION_READ,
            &m_pcAdmCom,
            &MDataHandle);

    if (HRESULTTOWIN32(hr) == ERROR_PATH_NOT_FOUND)
    {
        m_fIsIIS6 = FALSE;
    }
    else
    {
        BAIL_ON_FAILURE(hr);
    }

    if (hr == S_OK)
    {
        hr = m_pcAdmCom->GetData(
            MDataHandle,
            L"",
            &mr,
            &dwLen);

        if(hr == MD_ERROR_DATA_NOT_FOUND)
        {
            m_fIsIIS6 = FALSE;
        }
        else
        {
            BAIL_ON_FAILURE(hr);
        }

        if (hr == S_OK)
        {
            if (dwMajVer >= 6)
            {
                m_fIsIIS6 = TRUE;    
            }
            else
            {
                m_fIsIIS6 = FALSE;
            }
        }
    }

    hr = S_OK;

    cL = wcslen( pszServerName );
    if ( m_pszServerName = (LPWSTR)LocalAlloc( LMEM_FIXED, ( cL + 1 )*sizeof(WCHAR) ) )
    {
        memcpy( m_pszServerName, pszServerName, ( cL + 1 )*sizeof(WCHAR) );
    }
    else
    {
        BAIL_ON_FAILURE(hr=E_OUTOFMEMORY);
    }

    cL = wcslen( pszMetabasePath );
    while ( cL && pszMetabasePath[cL-1] != L'/' && pszMetabasePath[cL-1] != L'\\' )
    {
        --cL;
    }
    if ( m_fIsIIS6 && ( m_pszMetabasePath = (LPWSTR)LocalAlloc( LMEM_FIXED, (( cL + 1 )*sizeof(WCHAR) ) )))
    {
        memcpy( m_pszMetabasePath, pszMetabasePath, cL * sizeof(WCHAR) );
        m_pszMetabasePath[ cL ] = L'\0';
    }
    else if ( !m_fIsIIS6 && ( m_pszMetabasePath = (LPWSTR)LocalAlloc( LMEM_FIXED, ( cL*sizeof(WCHAR) + sizeof(L"<nsepm>") )) ) )
    {
        memcpy( m_pszMetabasePath, pszMetabasePath, cL * sizeof(WCHAR) );
        memcpy( m_pszMetabasePath + cL, L"<nsepm>", sizeof(L"<nsepm>") );
    }
    else
    {
        BAIL_ON_FAILURE(hr=E_OUTOFMEMORY);
    }

error:
    if (m_pcAdmCom)
    {
        CloseAdminBaseKey(m_pcAdmCom, MDataHandle);
    }

    return hr;
}


HRESULT
SetVariantAsByteArray(
    VARIANT*    pvarReturn, 
    DWORD       cbLen,
    LPBYTE      pbIn 
    )
/*++

Routine Description:

    Create variant as byte array

Arguments:

    pVarReturn - ptr to created variant
    cbLen - byte count
    pbIn - byte array

Returns:

    COM status

--*/
{
    HRESULT         hr;
    SAFEARRAYBOUND  rgsabound[1];
    BYTE *          pbData = NULL;

    // Set the variant type of the output parameter

    V_VT(pvarReturn) = VT_ARRAY|VT_UI1;
    V_ARRAY(pvarReturn) = NULL;

    // Allocate a SafeArray for the data

    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = cbLen;

    V_ARRAY(pvarReturn) = SafeArrayCreate(VT_UI1, 1, rgsabound);
    if (V_ARRAY(pvarReturn) == NULL)
    {
        return E_OUTOFMEMORY;
    }

    if (FAILED(SafeArrayAccessData(V_ARRAY(pvarReturn), (void **) &pbData)))
    {
        return E_UNEXPECTED;
    }

    memcpy(pbData, pbIn, cbLen );

    SafeArrayUnaccessData(V_ARRAY(pvarReturn));

    return NOERROR;
}


HRESULT
SetVariantAsBSTR(
    VARIANT*    pvarReturn, 
    DWORD       cbLen,
    LPBYTE      pbIn 
    )
/*++

Routine Description:

    Create variant BSTR

Arguments:

    pVarReturn - ptr to created variant
    cbLen - byte count
    pbIn - byte array

Returns:

    COM status

--*/
{
    HRESULT         hr;

    V_VT(pvarReturn) = VT_BSTR;
    return SetBSTR( &V_BSTR(pvarReturn), cbLen, pbIn );
}

HRESULT
SetVariantAsBSTRFromStringW(
    VARIANT*    pvarReturn, 
    DWORD       cbLen,
    LPBYTE      pbIn 
    )
/*++

Routine Description:

    Create variant BSTR

Arguments:

    pVarReturn - ptr to created variant
    cbLen - byte count
    pbIn - byte array

Returns:

    COM status

--*/
{
    HRESULT         hr;

    V_VT(pvarReturn) = VT_BSTR;
    return SetBSTRFromStringW( &V_BSTR(pvarReturn), cbLen, pbIn );
}

HRESULT
SetVariantAsLong(
    VARIANT*    pvarReturn, 
    DWORD       dwV
    )
/*++

Routine Description:

    Create variant as long

Arguments:

    pVarReturn - ptr to created variant
    dwV - value

Returns:

    COM status

--*/
{
    HRESULT         hr;

    V_VT(pvarReturn) = VT_I4;
    V_I4(pvarReturn) = dwV;

    return S_OK;
}


HRESULT 
VariantResolveDispatch(
    VARIANT *   pVarOut, 
    VARIANT *   pVarIn
    )
/*++

Routine Description:

    Extract value from IDispatch default property

Arguments:

    pVarOut - ptr to created variant
    pVarIn - ptr to IDispatch variant to resolve

Returns:

    COM status

--*/
{
    VARIANT		varResolved;		// value of IDispatch::Invoke
    DISPPARAMS	dispParamsNoArgs = {NULL, NULL, 0, 0}; 
    EXCEPINFO	ExcepInfo;
    HRESULT		hrCopy;


    VariantInit(pVarOut);

    hrCopy = VariantCopy(pVarOut, pVarIn);

    if (FAILED(hrCopy))
    {
        return hrCopy;
    }

    // follow the IDispatch chain.
    //
    while (V_VT(pVarOut) == VT_DISPATCH)
    {
        HRESULT hrInvoke = S_OK;

        // If the variant is equal to Nothing, then it can be argued
        // with certainty that it does not have a default property!
        // hence we return DISP_E_MEMBERNOTFOUND for this case.
        //
        if (V_DISPATCH(pVarOut) == NULL)
        {
            hrInvoke = DISP_E_MEMBERNOTFOUND;
        }
        else
        {
            VariantInit(&varResolved);
            hrInvoke = V_DISPATCH(pVarOut)->Invoke(
                            DISPID_VALUE,
                            IID_NULL,
                            LOCALE_SYSTEM_DEFAULT,
                            DISPATCH_PROPERTYGET | DISPATCH_METHOD,
                            &dispParamsNoArgs,
                            &varResolved,
                            &ExcepInfo,
                            NULL);
        }

        if (FAILED(hrInvoke))
        {
            if (hrInvoke == DISP_E_EXCEPTION)
            {			
                //
                // forward the ExcepInfo from Invoke to caller's ExcepInfo
                //
                SysFreeString(ExcepInfo.bstrHelpFile);
            }

            VariantClear(pVarOut);
            return hrInvoke;
        }

        // The correct code to restart the loop is:
        //
        //		VariantClear(pVar)
        //		VariantCopy(pVar, &varResolved);
        //		VariantClear(&varResolved);
        //
        // however, the same affect can be achieved by:
        //
        //		VariantClear(pVar)
        //		*pVar = varResolved;
        //		VariantInit(&varResolved)
        //
        // this avoids a copy.  The equivalence rests in the fact that
        // *pVar will contain the pointers of varResolved, after we
        // trash varResolved (WITHOUT releasing strings or dispatch
        // pointers), so the net ref count is unchanged. For strings,
        // there is still only one pointer to the string.
        //
        // NOTE: the next interation of the loop will do the VariantInit.
        //
        VariantClear(pVarOut);
        *pVarOut = varResolved;
    }

    return S_OK;
}

STDMETHODIMP
CIISDsCrMap::NonDelegatingQueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    ASSERT(ppv);

    if (IsEqualIID(iid, IID_IISDsCrMap)) {

        *ppv = (IADsUser FAR *) this;

    } else if (IsEqualIID(iid, IID_IADsExtension)) {

        *ppv = (IADsExtension FAR *) this;

    } else if (IsEqualIID(iid, IID_IUnknown)) {

        //
        // probably not needed since our 3rd party extension does not stand
        // alone and provider does not ask for this, but to be safe
        //
        *ppv = (INonDelegatingUnknown FAR *) this;

    } else {

        *ppv = NULL;
        return E_NOINTERFACE;
    }


    //
    // Delegating AddRef to aggregator for IADsExtesnion and IISDsCrMap.
    // AddRef on itself for IPrivateUnknown.   (both tested.)
    //

    ((IUnknown *) (*ppv)) -> AddRef();

    return S_OK;
}



//
// IADsExtension::Operate()
//

STDMETHODIMP
CIISDsCrMap::Operate(
    THIS_ DWORD dwCode,
    VARIANT varUserName,
    VARIANT varPassword,
    VARIANT varFlags
    )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISDsCrMap::ADSIInitializeDispatchManager(
    long dwExtensionId
    )
{
    HRESULT hr = S_OK;

    if (_fDispInitialized) {

        RRETURN(E_FAIL);
    }

    hr = _pDispMgr->InitializeDispMgr(dwExtensionId);

    if (SUCCEEDED(hr)) {
        _fDispInitialized = TRUE;
    }

    RRETURN(hr);
}


STDMETHODIMP
CIISDsCrMap::ADSIInitializeObject(
    THIS_ BSTR lpszUserName,
    BSTR lpszPassword,
    long lnReserved
    )
{
    CCredentials NewCredentials(lpszUserName, lpszPassword, lnReserved);

    m_Credentials = NewCredentials;

    RRETURN(S_OK);
}


STDMETHODIMP
CIISDsCrMap::ADSIReleaseObject()
{
    delete this;
    RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\iisext\csrvcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  csrvcf.cxx
//
//  Contents:  IIS Server Object Class Factory Code
//
//             CIISServerCF::CreateInstance
//
//----------------------------------------------------------------------------
#include "iisext.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CIISServerCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CIISServerCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = S_OK;

    if (!pUnkOuter)
        RRETURN(E_FAIL);

    hr = CIISServer::CreateServer(
                pUnkOuter,
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\iisext\cwebservice.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2001
//
//  File:  cwebservice.cxx
//
//  Contents:  Contains methods for CIISWebService object
//
//  History:   01-15-2001     BrentMid    Created.
//
//----------------------------------------------------------------------------

#include "iisext.hxx"
#include <initguid.h>
#include "iwamreg.h"
#include "sitecreator.h"
#include "secconlib.h"

#pragma hdrstop

//  Class CIISWebService

DEFINE_IPrivateDispatch_Implementation(CIISWebService)
DEFINE_DELEGATING_IDispatch_Implementation(CIISWebService)
DEFINE_CONTAINED_IADs_Implementation(CIISWebService)
DEFINE_IADsExtension_Implementation(CIISWebService)

CIISWebService::CIISWebService():
        _pUnkOuter(NULL),
        _pADs(NULL),
        _pszServerName(NULL),
        _pszMetaBasePath(NULL),
        _pAdminBase(NULL),
        _pDispMgr(NULL),
        _fDispInitialized(FALSE)
{
    ENLIST_TRACKING(CIISWebService);
}

HRESULT
CIISWebService::CreateWebService(
    IUnknown *pUnkOuter,
    REFIID riid,
    void **ppvObj
    )
{
    CCredentials Credentials;
    CIISWebService FAR * pWebService = NULL;
    HRESULT hr = S_OK;
    BSTR bstrAdsPath = NULL;
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer * pLexer = NULL;
    LPWSTR pszIISPathName  = NULL;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));

    hr = AllocateWebServiceObject(pUnkOuter, Credentials, &pWebService);
    BAIL_ON_FAILURE(hr);

    //
    // get ServerName and pszPath
    //

    hr = pWebService->_pADs->get_ADsPath(&bstrAdsPath);
    BAIL_ON_FAILURE(hr);

    pLexer = new CLexer();
    hr = pLexer->Initialize(bstrAdsPath);
    BAIL_ON_FAILURE(hr);

    //
    // Parse the pathname
    //

    hr = ADsObject(pLexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    pszIISPathName = AllocADsStr(bstrAdsPath);
    if (!pszIISPathName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    *pszIISPathName = L'\0';
    hr = BuildIISPathFromADsPath(
                    pObjectInfo,
                    pszIISPathName
                    );
    BAIL_ON_FAILURE(hr);

    hr = pWebService->InitializeWebServiceObject(
                pObjectInfo->TreeName,
                pszIISPathName );
    BAIL_ON_FAILURE(hr);

    //
    // pass non-delegating IUnknown back to the aggregator
    //

    *ppvObj = (INonDelegatingUnknown FAR *) pWebService;

    if (bstrAdsPath)
    {
        ADsFreeString(bstrAdsPath);
    }

    if (pLexer) {
        delete pLexer;
    }

    if (pszIISPathName ) {
        FreeADsStr( pszIISPathName );
    }

    FreeObjectInfo( &ObjectInfo );

    RRETURN(hr);

error:

    if (bstrAdsPath) {
        ADsFreeString(bstrAdsPath);
    }

    if (pLexer) {
        delete pLexer;
    }

    if (pszIISPathName ) {
        FreeADsStr( pszIISPathName );
    }

    FreeObjectInfo( &ObjectInfo );

    *ppvObj = NULL;

    delete pWebService;

    RRETURN(hr);

}


CIISWebService::~CIISWebService( )
{
    if (_pszServerName) {
        FreeADsStr(_pszServerName);
    }

    if (_pszMetaBasePath) {
        FreeADsStr(_pszMetaBasePath);
    }

    delete _pDispMgr;
}


STDMETHODIMP
CIISWebService::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    HRESULT hr = S_OK;
   
    hr = _pUnkOuter->QueryInterface(iid,ppv);

    RRETURN(hr);
}

HRESULT
CIISWebService::AllocateWebServiceObject(
    IUnknown *pUnkOuter,
    CCredentials& Credentials,
    CIISWebService ** ppWebService
    )
{
    CIISWebService FAR * pWebService = NULL;
    IADs FAR *  pADs = NULL;
    CAggregateeDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pWebService = new CIISWebService();
    if (pWebService == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregateeDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                LIBID_IISExt,
                IID_IISWebService,
                (IISWebService *)pWebService,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    //
    // Store the IADs Pointer, but again do NOT ref-count
    // this pointer - we keep the pointer around, but do
    // a release immediately.
    //
 
    hr = pUnkOuter->QueryInterface(IID_IADs, (void **)&pADs);
    pADs->Release();
    pWebService->_pADs = pADs;

    //
    // Store the pointer to the pUnkOuter object
    // AND DO NOT add ref this pointer
    //
    pWebService->_pUnkOuter = pUnkOuter;
    pWebService->_Credentials = Credentials;
    pWebService->_pDispMgr = pDispMgr;
    *ppWebService = pWebService;

    RRETURN(hr);

error:

    delete  pDispMgr;
    delete  pWebService;

    RRETURN(hr);
}

HRESULT
CIISWebService::InitializeWebServiceObject(
    LPWSTR pszServerName,
    LPWSTR pszPath
    )
{
    HRESULT hr = S_OK;

    if (pszServerName) {
        _pszServerName = AllocADsStr(pszServerName);

        if (!_pszServerName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    if (pszPath) {
        _pszMetaBasePath = AllocADsStr(pszPath);

        if (!_pszMetaBasePath) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    hr = InitServerInfo(pszServerName, &_pAdminBase);
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}

STDMETHODIMP
CIISWebService::ADSIInitializeDispatchManager(
    long dwExtensionId
    )
{
    HRESULT hr = S_OK;

    if (_fDispInitialized) {

        RRETURN(E_FAIL);
    }

    hr = _pDispMgr->InitializeDispMgr(dwExtensionId);

    if (SUCCEEDED(hr)) {
        _fDispInitialized = TRUE;
    }

    RRETURN(hr);
}

STDMETHODIMP
CIISWebService::ADSIInitializeObject(
    THIS_ BSTR lpszUserName,
    BSTR lpszPassword,
    long lnReserved
    )
{
    CCredentials NewCredentials(lpszUserName, lpszPassword, lnReserved);

    _Credentials = NewCredentials;

    RRETURN(S_OK);
}


STDMETHODIMP
CIISWebService::ADSIReleaseObject()
{
    delete this;
    RRETURN(S_OK);
}


STDMETHODIMP
CIISWebService::NonDelegatingQueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    ASSERT(ppv);
    
    if (IsEqualIID(iid, IID_IISWebService)) {

        *ppv = (IADsUser FAR *) this;

    } else if (IsEqualIID(iid, IID_IADsExtension)) {

        *ppv = (IADsExtension FAR *) this;
                                
    } else if (IsEqualIID(iid, IID_IUnknown)) {
        
        //
        // probably not needed since our 3rd party extension does not stand 
        // alone and provider does not ask for this, but to be safe
        //
        *ppv = (INonDelegatingUnknown FAR *) this;

    } else {
        
        *ppv = NULL;
        return E_NOINTERFACE;
    } 


    //
    // Delegating AddRef to aggregator for IADsExtesnion and IISWebService.
    // AddRef on itself for IPrivateUnknown.   (both tested.)
    //

    ((IUnknown *) (*ppv)) -> AddRef();       

    return S_OK;
}


//
// IADsExtension::Operate()
//

STDMETHODIMP
CIISWebService::Operate(
    THIS_ DWORD dwCode,
    VARIANT varUserName,
    VARIANT varPassword,
    VARIANT varFlags
    )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISWebService::EnableApplication(
    BSTR bstrAppName
    )
{
    HRESULT hr = S_OK;

    CSecConLib consoleHelper(_pAdminBase);
    hr = consoleHelper.EnableApplication(bstrAppName, _pszMetaBasePath);

    return hr;
}

STDMETHODIMP
CIISWebService::RemoveApplication(
    BSTR bstrAppName
    )
{
    HRESULT hr = S_OK;

    CSecConLib consoleHelper(_pAdminBase);
    hr = consoleHelper.RemoveApplication(bstrAppName, _pszMetaBasePath);

    return hr;
}

STDMETHODIMP
CIISWebService::QueryGroupIDStatus(
        BSTR    bstrGroupID,
        VARIANT FAR* pvBuffer
        )
{
    HRESULT hr = S_OK;

    DWORD  dwBufSize = 0;
    WCHAR* pBuffer   = NULL;

    CSecConLib consoleHelper(_pAdminBase);
    hr = consoleHelper.QueryGroupIDStatus( _pszMetaBasePath, bstrGroupID, &pBuffer, &dwBufSize);
    BAIL_ON_FAILURE(hr);

    hr = MakeVariantFromStringArray( (LPWSTR)pBuffer, pvBuffer);
    BAIL_ON_FAILURE(hr);

error:
    if (pBuffer)
    {
        delete [] pBuffer;    
    }

    return hr;
}
STDMETHODIMP
CIISWebService::ListApplications(
        VARIANT FAR* pvBuffer
        )
{
    HRESULT hr = S_OK;

    DWORD  dwBufSize = 0;
    WCHAR* pBuffer   = NULL;

    CSecConLib consoleHelper(_pAdminBase);
    hr = consoleHelper.ListApplications( _pszMetaBasePath, &pBuffer, &dwBufSize);
    BAIL_ON_FAILURE(hr);

    hr = MakeVariantFromStringArray( (LPWSTR)pBuffer, pvBuffer);
    BAIL_ON_FAILURE(hr);

error:
    if (pBuffer)
    {
        delete [] pBuffer;    
    }

    return hr;
}

STDMETHODIMP
CIISWebService::AddDependency(
    BSTR bstrApplication,
    BSTR bstrGroupID
    )
{
    HRESULT hr = S_OK;

    CSecConLib consoleHelper(_pAdminBase);
    hr = consoleHelper.AddDependency(bstrApplication, bstrGroupID, _pszMetaBasePath);

    return hr;
}

STDMETHODIMP
CIISWebService::RemoveDependency(
    BSTR bstrApplication,
    BSTR bstrGroupID
    )
{
    HRESULT hr = S_OK;

    CSecConLib consoleHelper(_pAdminBase);
    hr = consoleHelper.RemoveDependency(bstrApplication, bstrGroupID, _pszMetaBasePath);

    return hr;
}

STDMETHODIMP
CIISWebService::EnableWebServiceExtension(
    BSTR bstrExtension
    )
{
    HRESULT hr = S_OK;

    CSecConLib consoleHelper(_pAdminBase);
    hr = consoleHelper.EnableWebServiceExtension(bstrExtension, _pszMetaBasePath);

    return hr;
}

STDMETHODIMP
CIISWebService::DisableWebServiceExtension(
    BSTR bstrExtension
    )
{
    HRESULT hr = S_OK;

    CSecConLib consoleHelper(_pAdminBase);
    hr = consoleHelper.DisableWebServiceExtension(bstrExtension, _pszMetaBasePath);

    return hr;
}

STDMETHODIMP
CIISWebService::ListWebServiceExtensions(
        VARIANT FAR* pvBuffer
        )
{
    HRESULT hr = S_OK;

    DWORD  dwBufSize = 0;
    WCHAR* pBuffer   = NULL;

    CSecConLib consoleHelper(_pAdminBase);
    hr = consoleHelper.ListWebServiceExtensions( _pszMetaBasePath, &pBuffer, &dwBufSize);
    BAIL_ON_FAILURE(hr);

    hr = MakeVariantFromStringArray( (LPWSTR)pBuffer, pvBuffer);
    BAIL_ON_FAILURE(hr);

error:
    if (pBuffer)
    {
        delete [] pBuffer;    
    }

    return hr;
}

STDMETHODIMP
CIISWebService::EnableExtensionFile(
    BSTR bstrExtensionFile
    )
{
    HRESULT hr = S_OK;

    CSecConLib consoleHelper(_pAdminBase);
    hr = consoleHelper.EnableExtensionFile(bstrExtensionFile, _pszMetaBasePath);

    return hr;
}

STDMETHODIMP
CIISWebService::DisableExtensionFile(
    BSTR bstrExtensionFile
    )
{
    HRESULT hr = S_OK;

    CSecConLib consoleHelper(_pAdminBase);
    hr = consoleHelper.DisableExtensionFile(bstrExtensionFile, _pszMetaBasePath);

    return hr;
}

STDMETHODIMP
CIISWebService::AddExtensionFile(
    BSTR         bstrExtensionFile,
    VARIANT      bAccess,
    BSTR         bstrGroupID,
    VARIANT      bCanDelete,
    BSTR         bstrDescription
    )
{
    HRESULT hr         = S_OK;
    bool    boolCanDelete = false;
    bool    boolAccess    = false;

    if (bCanDelete.vt == VT_BOOL) 
    {
        if (bCanDelete.boolVal == VARIANT_TRUE) 
        {
            boolCanDelete = true;
        }
        else 
        {
            boolCanDelete = false;
        }
    }

    if (bAccess.vt == VT_BOOL) 
    {
        if (bAccess.boolVal == VARIANT_TRUE) 
        {
            boolAccess = true;
        }
        else 
        {
            boolAccess = false;
        }
    }

    CSecConLib consoleHelper(_pAdminBase);
    hr = consoleHelper.AddExtensionFile(bstrExtensionFile, boolAccess, bstrGroupID, 
                                        boolCanDelete, bstrDescription, _pszMetaBasePath);

    return hr;
}

STDMETHODIMP
CIISWebService::DeleteExtensionFileRecord(
    BSTR bstrExtensionFile
    )
{
    HRESULT hr = S_OK;

    CSecConLib consoleHelper(_pAdminBase);
    hr = consoleHelper.DeleteExtensionFileRecord(bstrExtensionFile, _pszMetaBasePath);

    return hr;
}

STDMETHODIMP
CIISWebService::ListExtensionFiles(
        VARIANT FAR* pvBuffer
        )
{
    HRESULT hr = S_OK;

    DWORD  dwBufSize = 0;
    WCHAR* pBuffer   = NULL;

    CSecConLib consoleHelper(_pAdminBase);
    hr = consoleHelper.ListExtensionFiles( _pszMetaBasePath, &pBuffer, &dwBufSize);
    BAIL_ON_FAILURE(hr);

    hr = MakeVariantFromStringArray( (LPWSTR)pBuffer, pvBuffer);
    BAIL_ON_FAILURE(hr);

error:
    if (pBuffer)
    {
        delete [] pBuffer;    
    }

    return hr;
}

STDMETHODIMP
CIISWebService::CreateNewSite(
    BSTR bstrServerComment,
    VARIANT *pvServerBindings,
    BSTR bstrRootVDirPath,
    VARIANT vServerID,
    VARIANT *pvActualID
    )
{
    HRESULT hr = S_OK;
    DWORD dwSiteID = 0;
    DWORD * pdwSiteID = &dwSiteID;
    DWORD dwNewSiteID = 0;
    IIISApplicationAdmin * pAppAdmin = NULL;
    COSERVERINFO csiName;
    COSERVERINFO *pcsiParam = &csiName;
    IClassFactory * pcsfFactory = NULL;
    CSiteCreator SiteCreator(_pAdminBase);
    VARIANT vVar;
    WCHAR* wszServerBindings = NULL;
    WCHAR* pIndex = NULL;
    VARIANT * pVarArray = NULL;
    DWORD dwNumValues = 0;

    memset(pcsiParam, 0, sizeof(COSERVERINFO));

    //
    // special case to handle "localhost" to work-around ole32 bug
    //

    if (_pszServerName == NULL || _wcsicmp(_pszServerName,L"localhost") == 0) {
        pcsiParam->pwszName =  NULL;
    }
    else {
        pcsiParam->pwszName =  _pszServerName;
    }

    csiName.pAuthInfo = NULL;
    pcsiParam = &csiName;


    // call VariantChangeType here to convert to VT_I4 and plug into vServerID
    hr = VariantChangeType(&vServerID, &vServerID, 0, VT_I4);
    BAIL_ON_FAILURE(hr);

    if ((vServerID.vt == VT_I4) && (vServerID.lVal != 0)) {
        *pdwSiteID = vServerID.lVal;
    }
    else {
        pdwSiteID = NULL;
    }

    hr = CoGetClassObject(
                CLSID_WamAdmin,
                CLSCTX_SERVER,
                pcsiParam,
                IID_IClassFactory,
                (void**) &pcsfFactory
                );

    BAIL_ON_FAILURE(hr);

    hr = pcsfFactory->CreateInstance(
                NULL,
                IID_IIISApplicationAdmin,
                (void **) &pAppAdmin
                );
    BAIL_ON_FAILURE(hr);
    
    VariantInit(&vVar);

    hr = VariantCopyInd(&vVar, pvServerBindings);
    BAIL_ON_FAILURE(hr);

    if ( VT_DISPATCH == V_VT(&vVar) )   // JScript Array
    {
        // Output here is VT_BSTR, of format: "str_1,str_2,str_3, ... str_n\0"
        hr = VariantChangeType( &vVar, &vVar, 0, VT_BSTR );    
        BAIL_ON_FAILURE(hr);

        wszServerBindings = new WCHAR [wcslen(vVar.bstrVal) + 2];  // 1 for NULL, 1 for extra NULL

        if (!wszServerBindings) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        wcscpy(wszServerBindings, vVar.bstrVal);

        // change VT_BSTR to MULTISZ format: "str_1\0str_2\0str_3\0 ... str_n\0"
        pIndex = wszServerBindings;
        while ( *pIndex != 0 )
        {
            if ( *pIndex == L',' )
            {
                *pIndex = 0;
            }

            pIndex++;
        }
        *(++pIndex) = 0;
    }
    else if ( (VT_ARRAY | VT_VARIANT) == V_VT(&vVar) )   // VBS Array = SafeArray
    {
        // Allocates wszServerBindings and puts in MULTISZ format
        hr = ConvertArrayToMultiSZ( vVar, &wszServerBindings );
        BAIL_ON_FAILURE(hr);
    }
    else
    {
        hr = E_INVALIDARG;
        BAIL_ON_FAILURE(hr);
    }

    hr = SiteCreator.CreateNewSite2(SC_W3SVC, bstrServerComment, wszServerBindings, 
                                    bstrRootVDirPath, pAppAdmin, &dwNewSiteID, pdwSiteID);
                                    
    BAIL_ON_FAILURE(hr);
     
    VariantInit( pvActualID );

    pvActualID->vt = VT_I4;
    pvActualID->lVal = dwNewSiteID;

error:
    
    if (pcsfFactory) {
        pcsfFactory->Release();
    }
 
    if (pAppAdmin) {
        pAppAdmin->Release();
    } 

    if (wszServerBindings) {
        delete [] wszServerBindings;
    }

    RRETURN(hr);
}

HRESULT
CIISWebService::ConvertArrayToMultiSZ(
    VARIANT varSafeArray,
    WCHAR **pszServerBindings
    )
{
    HRESULT hr = S_OK;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;
    DWORD i = 0;
    SAFEARRAY * pArray = NULL;
    DWORD dwLen = 0;
    DWORD dwNumVariants = 0;
    VARIANT * pVarArray = NULL;
    VARIANT pElem;
    WCHAR* wszServerBindings = NULL;

    if(!(V_ISARRAY(&varSafeArray)))
       RRETURN(E_FAIL);

    //
    // This handles by-ref and regular SafeArrays.
    //

    if (V_VT(&varSafeArray) & VT_BYREF)
        pArray = *(V_ARRAYREF(&varSafeArray));
    else
        pArray = V_ARRAY(&varSafeArray);


    //
    // Check that there is only one dimension in this array
    //
    if (pArray && pArray->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Check that there is at least one element in this array
    //

    if (!pArray ||  
        ( pArray->rgsabound[0].cElements == 0) ) {

        wszServerBindings = new WCHAR [2];
        wszServerBindings[0] = 0;
        wszServerBindings[1] = 1;
    } 
    else {  

        //
        // We know that this is a valid single dimension array
        //

        hr = SafeArrayGetLBound(pArray,
                                1,
                                (long FAR *)&dwSLBound
                                );
        BAIL_ON_FAILURE(hr);

        hr = SafeArrayGetUBound(pArray,
                                1,
                                (long FAR *)&dwSUBound
                                );
        BAIL_ON_FAILURE(hr);

        dwNumVariants = dwSUBound - dwSLBound + 1;
        dwLen = 0;

        pVarArray = (PVARIANT)AllocADsMem(
                                    sizeof(VARIANT)*dwNumVariants
                                    );
        if (!pVarArray) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        
        for (i = dwSLBound; i <= dwSUBound; i++) {

            VariantInit(&pElem);
            hr = SafeArrayGetElement(pArray,
                                    (long FAR *)&i,
                                    &pElem
                                    );
            BAIL_ON_FAILURE(hr);
        
            hr = VariantChangeType(&pElem, &pElem, 0, VT_BSTR);
            BAIL_ON_FAILURE(hr);

            dwLen = dwLen + wcslen(pElem.bstrVal) + 1;
            pVarArray[i] = pElem;
        }

        wszServerBindings = new WCHAR [dwLen + 1];

        WCHAR * pServerBindings = wszServerBindings;

        for (i = dwSLBound; i <= dwSUBound; i++) {
            
            wcscpy(pServerBindings, pVarArray[i].bstrVal);
            
            while (*pServerBindings != 0) {
                pServerBindings++;
            }         

            pServerBindings++;
        }

        *pServerBindings = 0;

    }

    *pszServerBindings = wszServerBindings;

error:
    if (pVarArray) {
        FreeADsMem(pVarArray);
    }

    RRETURN(hr);
}

STDMETHODIMP
CIISWebService::GetCurrentMode(
    VARIANT FAR* pvServerMode
    )
{
    HRESULT hr = S_OK;
    DWORD dwServerMode = 0;
    COSERVERINFO csiName;
    COSERVERINFO *pcsiParam = &csiName;
    IClassFactory * pcsfFactory = NULL;
    IWamAdmin * pWamAdmin = NULL;
    IIISApplicationAdmin * pAppAdmin = NULL;

    memset(pcsiParam, 0, sizeof(COSERVERINFO));

    //
    // special case to handle "localhost" to work-around ole32 bug
    //

    if (_pszServerName == NULL || _wcsicmp(_pszServerName,L"localhost") == 0) {
        pcsiParam->pwszName =  NULL;
    }
    else {
        pcsiParam->pwszName =  _pszServerName;
    }

    csiName.pAuthInfo = NULL;
    pcsiParam = &csiName;

    hr = CoGetClassObject(
                CLSID_WamAdmin,
                CLSCTX_SERVER,
                pcsiParam,
                IID_IClassFactory,
                (void**) &pcsfFactory
                );

    BAIL_ON_FAILURE(hr);

    hr = pcsfFactory->CreateInstance(
                NULL,
                IID_IWamAdmin,
                (void **) &pWamAdmin
                );
    BAIL_ON_FAILURE(hr);

    // test here for 5.1 compat 

    hr = pWamAdmin->QueryInterface(
                    IID_IIISApplicationAdmin,
                    (void **)&pAppAdmin
                    );

    BAIL_ON_FAILURE(hr);

    // Call GetProcessMode - it's returning GetCurrentMode
    // after it checks to make sure the W3SVC is running.

    hr = pAppAdmin->GetProcessMode( &dwServerMode );

    BAIL_ON_FAILURE(hr);

    VariantInit( pvServerMode );

    pvServerMode->vt = VT_I4;
    pvServerMode->lVal = dwServerMode;

error:
    if (pcsfFactory) {
        pcsfFactory->Release();
    }
    if (pWamAdmin) {
        pWamAdmin->Release();
    }
    if (pAppAdmin) {
        pAppAdmin->Release();
    } 

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\iisext\cwebservicecf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:  cwebservicecf.cxx
//
//  Contents:  IIS WebService Object Class Factory Code
//
//             CIISWebServiceCF::CreateInstance
//
//----------------------------------------------------------------------------
#include "iisext.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CIISWebServiceCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    11-10-2000    BrentMid     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CIISWebServiceCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = S_OK;

    if (!pUnkOuter)
        RRETURN(E_FAIL);

    hr = CIISWebService::CreateWebService(
                pUnkOuter,
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\iisext\extres.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       extres.h
//
//  Contents:   IIS Extension  DLL ID
//
//  Functions:
//
//----------------------------------------------------------------------------
#define IISEXT_PROVIDER_ID    1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\iisext\fsmacro.h ===
#define PUT_PROPERTY_LONG(this, Property) \
                RRETURN(put_LONG_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        l##Property \
                                        ))

#define GET_PROPERTY_LONG(this, Property) \
                RRETURN(get_LONG_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ))


#define PUT_PROPERTY_BSTR(this, Property) \
                RRETURN(put_BSTR_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        bstr##Property \
                                        ))

#define GET_PROPERTY_BSTR(this, Property) \
                RRETURN(get_BSTR_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ))


#define PUT_PROPERTY_VARIANT_BOOL(this, Property) \
                RRETURN(put_VARIANT_BOOL_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        f##Property\
                                        ))

#define GET_PROPERTY_VARIANT_BOOL(this, Property) \
                RRETURN(get_VARIANT_BOOL_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ))


#define PUT_PROPERTY_DATE(this, Property) \
                RRETURN(put_DATE_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        da##Property \
                                        ))

#define GET_PROPERTY_DATE(this, Property) \
                RRETURN(get_DATE_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ))


#define PUT_PROPERTY_VARIANT(this, Property) \
                RRETURN(put_VARIANT_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        v##Property \
                                        ))

#define GET_PROPERTY_VARIANT(this, Property) \
                RRETURN(get_VARIANT_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\iisext\iisext.h ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:  iisext.h
//
//  Contents:  Macros for ADSI IIS Extension methods
//
//  History:   25-Feb-97   SophiaC    Created.
//
//----------------------------------------------------------------------------

#define IIS_LIBIID_IISExt                  2a56ea30-afeb-11d1-9868-00a0c922e703 
#define IIS_IID_IISApp                     46FBBB80-0192-11d1-9C39-00A0C922E703
#define IIS_IID_IISApp2                    603DCBEA-7350-11d2-A7BE-0000F8085B95
#define IIS_IID_IISApp3                    2812B639-8FAC-4510-96C5-71DDBD1F54FC
#define IIS_IID_IISComputer                CF87A2E0-078B-11d1-9C3D-00A0C922E703
#define IIS_IID_IISComputer2               63d89839-5762-4a68-b1b9-3507ea76cbbf
#define IIS_IID_IISDsCrMap                 edcd6a60-b053-11d0-a62f-00a0c922e752
#define IIS_IID_IISApplicationPool         0B3CB1E1-829A-4c06-8B09-F56DA1894C88
#define IIS_IID_IISApplicationPools        587F123F-49B4-49dd-939E-F4547AA3FA75
#define IIS_IID_IISWebService              EE46D40C-1B38-4a02-898D-358E74DFC9D2

#define IIS_CLSID_IISExtApp                b4f34438-afec-11d1-9868-00a0c922e703
#define IIS_CLSID_IISExtComputer           91ef9258-afec-11d1-9868-00a0c922e703
#define IIS_CLSID_IISExtServer             c3b32488-afec-11d1-9868-00a0c922e703
#define IIS_CLSID_IISExtDsCrMap            bc36cde8-afeb-11d1-9868-00a0c922e703
#define IIS_CLSID_IISExtApplicationPool    E99F9D0C-FB39-402b-9EEB-AA185237BD34
#define IIS_CLSID_IISExtApplicationPools   95863074-A389-406a-A2D7-D98BFC95B905
#define IIS_CLSID_IISExtWebService         40B8F873-B30E-475d-BEC5-4D0EBB0DBAF3


#define PROPERTY_RO(name,type, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] type * retval);

#define PROPERTY_LONG_RW(name, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] long * retval);    \
                                                      \
        [propput, id(prid)]                           \
        HRESULT name([in] long ln##name);

#define PROPERTY_LONG_RO(name, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] long * retval);

#define PROPERTY_BSTR_RW(name, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] BSTR * retval);    \
                                                      \
        [propput, id(prid)]                           \
        HRESULT name([in] BSTR bstr##name);

#define PROPERTY_BSTR_RO(name, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] BSTR * retval);

#define PROPERTY_VARIANT_BOOL_RW(name, prid)          \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] VARIANT_BOOL * retval); \
                                                      \
        [propput, id(prid)]                           \
        HRESULT name([in] VARIANT_BOOL f##name);

#define PROPERTY_VARIANT_BOOL_RO(name, prid)          \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] VARIANT_BOOL * retval);

#define PROPERTY_VARIANT_RW(name, prid)               \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] VARIANT * retval); \
                                                      \
        [propput, id(prid)]                           \
        HRESULT name([in] VARIANT v##name);

#define PROPERTY_VARIANT_RO(name, prid)               \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] VARIANT * retval); \

#define PROPERTY_DATE_RW(name, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] DATE * retval);    \
                                                      \
        [propput, id(prid)]                           \
        HRESULT name([in] DATE da##name);

#define PROPERTY_DATE_RO(name, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] DATE * retval);

#define PROPERTY_DISPATCH_RW(name, prid)              \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] IDispatch ** retval);    \
                                                      \
        [propput, id(prid)]                           \
        HRESULT name([in] IDispatch * p##name);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\iisext\guid.c ===
/*++

   Copyright (c) 1997-1999 Microsoft Corporation

   Module  Name :

       iisext_guid.c

   Abstract:

        Contains ADSI IISExtensions CLSIDs, LIBIDs, and IIDs

   Environment:

      Win32 User Mode

--*/

#define INITGUID


#include <ole2.h>
#include "iwamreg.h"
#include "iadmw.h" 


//--------------------------------------------------------------------------
//
//  ADSI IISExtensions CLSIDs
//
//--------------------------------------------------------------------------

const IID LIBID_IISExt = {0x2a56ea30,0xafeb,0x11d1,{0x98,0x68,0x00,0xa0,0xc9,0x22,0xe7,0x03}};

const CLSID CLSID_IISExtDsCrMap = {0xbc36cde8,0xafeb,0x11d1,{0x98,0x68,0x00,0xa0,0xc9,0x22,0xe7,0x03}};

const CLSID CLSID_IISExtComputer = {0x91ef9258,0xafec,0x11d1,{0x98,0x68,0x00,0xa0,0xc9,0x22,0xe7,0x03}};

const CLSID CLSID_IISExtApp = {0xb4f34438,0xafec,0x11d1,{0x98,0x68,0x00,0xa0,0xc9,0x22,0xe7,0x03}};

const CLSID CLSID_IISExtServer = {0xc3b32488,0xafec,0x11d1,{0x98,0x68,0x00,0xa0,0xc9,0x22,0xe7,0x03}};

const CLSID CLSID_IISExtApplicationPool = { 0xe99f9d0c, 0xfb39, 0x402b, { 0x9e, 0xeb, 0xaa, 0x18, 0x52, 0x37, 0xbd, 0x34 } };

const CLSID CLSID_IISExtApplicationPools = { 0x95863074, 0xa389, 0x406a, { 0xa2, 0xd7, 0xd9, 0x8b, 0xfc, 0x95, 0xb9, 0x5 } };

const CLSID CLSID_IISExtWebService = { 0x40b8f873, 0xb30e, 0x475d, { 0xbe, 0xc5, 0x4d, 0xe, 0xbb, 0xd, 0xba, 0xf3 } };

DEFINE_GUID(IID_IISDsCrMap, 0xedcd6a60, 0xb053, 0x11d0, 0xa6, 0x2f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x52);

DEFINE_GUID(IID_IISApp, 0x46fbbb80, 0x192, 0x11d1, 0x9c, 0x39, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x3);

DEFINE_GUID(IID_IISApp2, 0x603DCBEA, 0x7350, 0x11d2, 0xA7, 0xBE, 0x0, 0x0, 0xF8, 0x8, 0x5B, 0x95);

DEFINE_GUID(IID_IISApp3, 0x2812b639, 0x8fac, 0x4510, 0x96, 0xc5, 0x71, 0xdd, 0xbd, 0x1f, 0x54, 0xfc);

DEFINE_GUID(IID_IISComputer, 0xcf87a2e0, 0x78b, 0x11d1, 0x9c, 0x3d, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x3);

DEFINE_GUID(IID_IISComputer2, 0x63d89839, 0x5762, 0x4a68, 0xb1, 0xb9, 0x35, 0xa07, 0xea, 0x76, 0xcb, 0xbf);

DEFINE_GUID(IID_IISApplicationPool, 0xb3cb1e1, 0x829a, 0x4c06, 0x8b, 0x9, 0xf5, 0x6d, 0xa1, 0x89, 0x4c, 0x88);

DEFINE_GUID(IID_IISApplicationPools, 0x587f123f, 0x49b4, 0x49dd, 0x93, 0x9e, 0xf4, 0x54, 0x7a, 0xa3, 0xfa, 0x75);

DEFINE_GUID(IID_IISWebService, 0xee46d40c, 0x1b38, 0x4a02, 0x89, 0x8d, 0x35, 0x8e, 0x74, 0xdf, 0xc9, 0xd2);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\iisext\guid.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       guid.h
//
//  Contents:   extern references for IIS ext guids
//
//  History:    16-Jan-98   SophiaC
//
//
//----------------------------------------------------------------------------

#ifndef __GUID_H__
#define __GUID_H__

#ifdef __cplusplus
extern "C" {
#endif

//-------------------------------------------
//
// IISExt CLSIDs
//
//-------------------------------------------


//
// IISExt objects
//

extern const CLSID LIBID_IISExt;


extern const CLSID CLSID_IISExtDsCrMap;

extern const CLSID CLSID_IISExtApp;

extern const CLSID CLSID_IISExtComputer;

extern const CLSID CLSID_IISExtServer;

extern const CLSID CLSID_IISExtApplicationPool;

extern const CLSID CLSID_IISExtApplicationPools;

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\iisext\macro.h ===
//
//             This NonDelegating interface is completely for 3rd-party 
//              extension objects based on our implementation only. NO need 
//              to export to ADISclients or 3rd part writer or typelib.  
//              Will put it here for now. Move -> ?? 
//

#ifndef _INonDelegatingUnknown
#define _INonDelegatingUnknown
interface INonDelegatingUnknown
{
    //
    //            Do I have to use __RPC_FAR * instead ?? (for marshalling?)
    //            May be not now since in proc server now. But should make
    //            it generalized. Look up and copy from IUnknown.

    virtual HRESULT STDMETHODCALLTYPE
    NonDelegatingQueryInterface(const IID&, void **) = 0; 

    virtual ULONG STDMETHODCALLTYPE 
    NonDelegatingAddRef() = 0;

    virtual ULONG STDMETHODCALLTYPE 
    NonDelegatingRelease() = 0;
};
#endif


#define BAIL_ON_NULL(p)       \
        if (!(p)) {           \
                goto error;   \
        }

#define BAIL_IF_ERROR(hr) \
        if (FAILED(hr)) {       \
                goto cleanup;   \
        }\

#define BAIL_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                goto error;   \
        }\

#define CONTINUE_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                continue;   \
        }\

#define BAIL_ON_SUCCESS(hr) \
        if (SUCCEEDED(hr)) {       \
                goto error;   \
        }\

#define QUERY_INTERFACE(hr, ptr, iid, ppObj) \
        hr = ptr->QueryInterface(iid, (void **)ppObj); \
        if (FAILED(hr)) {    \
                goto cleanup;\
        }\


#define RRETURN_ENUM_STATUS(hr) \
        if (hr != S_OK) {       \
            RRETURN(S_FALSE);   \
        }                       \
        RRETURN(S_OK);




#define DEFINE_IDispatch_Implementation_Unimplemented(cls) \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)        \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,        \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,   \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid, \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}




#define DEFINE_IDispatch_Implementation(cls)                          \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfoCount(pctinfo));                \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfo(itinfo,                        \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
        RRETURN(_pDispMgr->GetIDsOfNames(iid,                         \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
        RRETURN (_pDispMgr->Invoke(dispidMember,                      \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}

#define DEFINE_IADs_Implementation(cls)                             \
STDMETHODIMP                                                          \
cls::get_Name(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreName(retval));                                    \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_ADsPath(THIS_ BSTR FAR* retval)                            \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsPath(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Class(THIS_ BSTR FAR* retval)                                \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsClass(retval));                              \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Parent(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreParent(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Schema(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreSchema(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_GUID(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreGUID(retval));                                    \
}

#define DEFINE_IADsPutGet_UnImplementation(cls)                          \
STDMETHODIMP                                                             \
cls::Get(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                       \
{                                                                        \
    RRETURN(E_NOTIMPL);                                                  \
}                                                                        \
                                                                         \
STDMETHODIMP                                                             \
cls::Put(THIS_ BSTR bstrName, VARIANT vProp)                             \
{                                                                        \
    RRETURN(E_NOTIMPL);                                                  \
}                                                                        \
                                                                         \
STDMETHODIMP                                                             \
cls::GetEx(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                     \
{                                                                        \
    RRETURN(E_NOTIMPL);                                                  \
}                                                                        \
                                                                         \
STDMETHODIMP                                                             \
cls::PutEx(THIS_ long lnControlCode, BSTR bstrName, VARIANT vProp)       \
{                                                                        \
    RRETURN(E_NOTIMPL);                                                  \
}


#define DEFINE_IPrivateDispatch_Implementation(cls)                   \
STDMETHODIMP                                                          \
cls::ADSIGetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfoCount(pctinfo));                \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::ADSIGetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfo(itinfo,                        \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
}                                                                     \
STDMETHODIMP                                                          \
cls::ADSIGetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
        RRETURN(_pDispMgr->GetIDsOfNames(iid,                         \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::ADSIInvoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
        RRETURN (_pDispMgr->Invoke(dispidMember,                      \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}


//
//            add the shell of DEFINE_IADsExtension_Imp to VC++ template 
//            for 3rd party extension - including Operate, can even include 
//            dwCode switches - would be nice. Later
//
// Will not include Operate() in macro since funct'n sligthly more complicated ?
// 

//
//            LPWSTR ?? OLECHAR * won't compile ?? but declaration use
//            OLECHAR * ?? win95/98 ??
//

#define DEFINE_IADsExtension_Implementation(cls)                        \
STDMETHODIMP                                                            \
cls::PrivateGetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,            \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)           \
{                                                                       \
        RRETURN(_pDispMgr->GetIDsOfNames(iid,                           \
                                         rgszNames,                     \
                                         cNames,                        \
                                         lcid,                          \
                                         rgdispid                       \
                                         ));                            \
}                                                                       \
                                                                        \
STDMETHODIMP                                                            \
cls::PrivateInvoke(DISPID dispidMember, REFIID iid, LCID lcid,          \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,             \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,             \
        unsigned int FAR* puArgErr)                                     \
{                                                                       \
        RRETURN (_pDispMgr->Invoke(dispidMember,                        \
                                   iid,                                 \
                                   lcid,                                \
                                   wFlags,                              \
                                   pdispparams,                         \
                                   pvarResult,                          \
                                   pexcepinfo,                          \
                                   puArgErr                             \
                                   ));                                  \
}



#define DEFINE_DELEGATING_IDispatch_Implementation(cls)                          \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
        RRETURN(_pADs->GetTypeInfoCount(pctinfo));                    \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
        RRETURN(_pADs->GetTypeInfo(itinfo,                            \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
        RRETURN(_pADs->GetIDsOfNames(iid,                             \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
        RRETURN (_pADs->Invoke(dispidMember,                          \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\iisext\property.cxx ===
#include "iisext.hxx"
#pragma hdrstop


#define VALIDATE_PTR(pPtr) \
    if (!pPtr) { \
        hr = E_ADS_BAD_PARAMETER;\
    }\
    BAIL_ON_FAILURE(hr);




HRESULT
put_BSTR_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    BSTR   pSrcStringProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackStringinVariant(
            pSrcStringProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);


error:

    VariantClear( &varInputData );
    RRETURN(hr);
}

HRESULT
get_BSTR_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    BSTR *ppDestStringProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( ppDestStringProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackStringfromVariant(
            varOutputData,
            ppDestStringProperty
            );
    BAIL_ON_FAILURE(hr);


error:

    VariantClear( &varOutputData );
    RRETURN(hr);
}

HRESULT
put_LONG_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    LONG   lSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackLONGinVariant(
            lSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varInputData );
    RRETURN(hr);
}

HRESULT
get_LONG_Property(
    IADs * pADsObject,
    BSTR  bstrPropertyName,
    PLONG plDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( plDestProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackLONGfromVariant(
            varOutputData,
            plDestProperty
            );
    BAIL_ON_FAILURE(hr);


error:

    VariantClear( &varOutputData );
    RRETURN(hr);

}

HRESULT
put_DATE_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    DATE   daSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackDATEinVariant(
            daSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varInputData );
    RRETURN(hr);
}

HRESULT
get_DATE_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    PDATE pdaDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( pdaDestProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackDATEfromVariant(
            varOutputData,
            pdaDestProperty
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varOutputData );
    RRETURN(hr);
}

HRESULT
put_VARIANT_BOOL_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    VARIANT_BOOL   fSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackVARIANT_BOOLinVariant(
            fSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varInputData );
    RRETURN(hr);
}

HRESULT
get_VARIANT_BOOL_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    PVARIANT_BOOL pfDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( pfDestProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackVARIANT_BOOLfromVariant(
            varOutputData,
            pfDestProperty
            );
    BAIL_ON_FAILURE(hr);


error:

    VariantClear( &varOutputData );
    RRETURN(hr);
}

HRESULT
put_VARIANT_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    VARIANT   vSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackVARIANTinVariant(
            vSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varInputData );
    RRETURN(hr);
}

HRESULT
get_VARIANT_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    PVARIANT pvDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( pvDestProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackVARIANTfromVariant(
            varOutputData,
            pvDestProperty
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varOutputData );
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\iisext\libmain.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       libmain.cxx
//
//  Contents:   LibMain for iisext.dll
//
//  Functions:  LibMain, DllGetClassObject
//
//  History:    25-1-98   sophiac   Created.
//
//----------------------------------------------------------------------------
#include "iisext.hxx"
#pragma hdrstop


HINSTANCE g_hInst = NULL;


//
//  Global Data
//

WIN32_CRITSEC * g_pGlobalLock = NULL;
SERVER_CACHE * g_pServerCache = NULL;



DECLARE_DEBUG_PRINTS_OBJECT()
#ifdef _NO_TRACING_
DECLARE_DEBUG_VARIABLE();
#endif

//---------------------------------------------------------------------------
// ADs debug print, mem leak and object tracking-related stuff
//---------------------------------------------------------------------------

DECLARE_INFOLEVEL(ADs)

//+---------------------------------------------------------------------------
//
//  Function:   ShutDown
//
//  Synopsis:   Function to handle printing out heap debugging display
//
//----------------------------------------------------------------------------
inline VOID ShutDown()
{
#if DBG==1
#ifndef MSVC
     DUMP_TRACKING_INFO_DELETE();
     DeleteCriticalSection(&g_csOT);
     DeleteCriticalSection(&g_csMem);
#endif  // ifndef MSVC
     DeleteCriticalSection(&g_csDP);
#endif
}

extern "C" DWORD heapInfoLevel;
extern "C" DWORD OtInfoLevel;
extern "C" DWORD ADsInfoLevel;

//+---------------------------------------------------------------------------
//
//  Function:   GetINIHeapInfoLevel
//
//  Synopsis:   Gets various infolevel values from win.ini
//
//----------------------------------------------------------------------------
inline VOID GetINIHeapInfoLevel()
{
#if DBG==1
    const INT MAXINFOLEN=11;
    WCHAR  awcs[MAXINFOLEN];

#ifndef MSVC
    if (GetProfileString(L"IISEXT",L"heapInfoLevel", L"00000003", awcs,MAXINFOLEN))
        heapInfoLevel = wcstoul(awcs, NULL, 16);

    if (GetProfileString(L"IISEXT",L"Ot", L"00000003", awcs, MAXINFOLEN))
        OtInfoLevel = wcstoul(awcs, NULL, 16);

#endif  // MSVC

    if (GetProfileString(L"IISEXT",L"ADsInfoLevel", L"00000003", awcs,MAXINFOLEN))
        ADsInfoLevel = wcstoul(awcs, NULL, 16);
#endif
}

//  Globals


ULONG  g_ulObjCount = 0;  // Number of objects alive in oleds.dll


//+------------------------------------------------------------------------
//
//  Macro that calculates the number of elements in a statically-defined
//  array.
//
//  Note - I swiped this from ADsary.cxx - A type-safe array class. Remember
//  to swipe the whole thing as required.
//-------------------------------------------------------------------------
#define ARRAY_SIZE(_a)  (sizeof(_a) / sizeof(_a[0]))

CIISComputerCF            g_cfComputer;
CIISServerCF              g_cfServer;   
CIISAppCF                 g_cfApp;    
CIISDsCrMapCF             g_cfDsCrMap;
CIISApplicationPoolCF     g_cfApplicationPool;
CIISApplicationPoolsCF    g_cfApplicationPools;
CIISWebServiceCF          g_cfWebService;

//+------------------------------------------------------------------------
//
//  oleds class factories
//
//-------------------------------------------------------------------------

struct CLSCACHE
{
    const CLSID *   pclsid;
    IClassFactory * pCF;
};



CLSCACHE g_aclscache[] =
{
    &CLSID_IISExtComputer,                     &g_cfComputer,
    &CLSID_IISExtServer,                       &g_cfServer,
    &CLSID_IISExtApp,                          &g_cfApp,
    &CLSID_IISExtDsCrMap,                      &g_cfDsCrMap,  
	&CLSID_IISExtApplicationPool,              &g_cfApplicationPool,
	&CLSID_IISExtApplicationPools,             &g_cfApplicationPools,
	&CLSID_IISExtWebService,                   &g_cfWebService
};


//+---------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Standard DLL entrypoint for locating class factories
//
//----------------------------------------------------------------

STDAPI
DllGetClassObject(REFCLSID clsid, REFIID iid, LPVOID FAR* ppv)
{
    HRESULT         hr;
    size_t          i;

    for (i = 0; i < ARRAY_SIZE(g_aclscache); i++)
    {
        if (IsEqualCLSID(clsid, *g_aclscache[i].pclsid))
        {
            hr = g_aclscache[i].pCF->QueryInterface(iid, ppv);
            RRETURN(hr);
        }
    }

    *ppv = NULL;

    //
    // Add Debugging Code to indicate that the oleds.DllGetClassObject has been called with an unknown CLSID.
    //

    return E_NOINTERFACE;
}

//+---------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:   Standard DLL entrypoint to determine if DLL can be unloaded
//
//---------------------------------------------------------------

STDAPI
DllCanUnloadNow(void)
{
    HRESULT hr;

    hr = S_FALSE;

    return hr;
}

//+---------------------------------------------------------------
//
//  Function:   LibMain
//
//  Synopsis:   Standard DLL initialization entrypoint
//
//---------------------------------------------------------------

EXTERN_C BOOL __cdecl
LibMain(HINSTANCE hInst, ULONG ulReason, LPVOID pvReserved)
{
    HRESULT     hr;

    switch (ulReason)
    {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hInst);
        g_pGlobalLock = new WIN32_CRITSEC();
        g_pServerCache = new SERVER_CACHE();

        g_hInst = hInst;


#if DBG==1
#ifndef MSVC
        InitializeCriticalSection(&g_csOT);
        InitializeCriticalSection(&g_csMem);
#endif
        InitializeCriticalSection(&g_csDP);
#endif

#ifdef _NO_TRACING_
        CREATE_DEBUG_PRINT_OBJECT("iisext");
        SET_DEBUG_FLAGS(DEBUG_ERROR);
#endif

        break;


    case DLL_PROCESS_DETACH:

#ifdef _NO_TRACING_
        DELETE_DEBUG_PRINT_OBJECT();
#endif
        
        ShutDown();

        delete(g_pGlobalLock);
        delete(g_pServerCache);

        break;

    default:
        break;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   entry point for NT - post .546
//
//----------------------------------------------------------------------------
BOOL
DllMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    return LibMain((HINSTANCE)hDll, dwReason, lpReserved);
}


//+------------------------------------------------------------------------
//
//  Function:   GetCachedClsidIndex
//
//  Synopsis:   Returns the index of the given CLSID in the cache, or
//              -1 if the CLSID is not present in the cache
//
//  Arguments:  [clsid]
//
//  Returns:    int
//
//-------------------------------------------------------------------------

int
GetCachedClsidIndex(REFCLSID clsid)
{
    int             i;
    CLSCACHE *      pclscache;

    for (i = 0, pclscache = g_aclscache;
         i < ARRAY_SIZE(g_aclscache);
         i ++, pclscache++)
    {
        if (IsEqualCLSID(*pclscache->pclsid, clsid))
            return i;
    }

    return -1;
}




//+------------------------------------------------------------------------
//
//  Function:   GetCachedClassFactory
//
//  Synopsis:   Returns the cached class factory with the given index.
//              The pointer returned has been AddRef'd.
//
//  Arguments:  [iclsid]
//
//  Returns:    IClassFactory *
//
//-------------------------------------------------------------------------

IClassFactory *
GetCachedClassFactory(int iclsid)
{
    IClassFactory * pCF;

    // Assert(iclsid >= 0);
    // Assert(iclsid < ARRAY_SIZE(g_aclscache));

    pCF = g_aclscache[iclsid].pCF;
    pCF->AddRef();

    return pCF;
}




//+------------------------------------------------------------------------
//
//  Function:   GetCachedClsid
//
//  Synopsis:   Returns the CLSID corresponding to the given index.
//              Normally, code should call GetCachedClassFactory to get
//              the class factory directly.
//
//  Arguments:  [iclsid]    --  Clsid index
//              [pclsid]    --  Matching clsid returned in *pclsid
//
//-------------------------------------------------------------------------

void
GetCachedClsid(int iclsid, CLSID * pclsid)
{
    // Assert(iclsid >= 0);
    // Assert(iclsid < ARRAY_SIZE(g_aclscache));

    *pclsid = *g_aclscache[iclsid].pclsid;
}


//+------------------------------------------------------------------------
//
//  Function:   DllRegisterServer
//
//  Synopsis:   Register registry keys for adsiis
//
//  Arguments:  None
//
//-------------------------------------------------------------------------

STDAPI DllRegisterServer(
    )
{
    HKEY hKeyCLSID, hKeyTemp;
    DWORD dwDisposition;
    HMODULE hModule;
    HRESULT hr;
    ITypeLib   *pITypeLib;
    WCHAR pszName[MAX_PATH +1];
    int i;

    hModule=GetModuleHandle(TEXT("IISEXT.DLL"));

    if (!hModule) {
            return E_UNEXPECTED;
            }

    if (GetModuleFileName(hModule, pszName, (sizeof pszName)/(sizeof pszName[0]) ) ==0) {
            return E_UNEXPECTED;
            }

    DWORD dwNameSize = (wcslen(pszName) + 1) * sizeof(WCHAR);

    hr=LoadTypeLibEx(pszName, REGKIND_REGISTER, &pITypeLib);
    if (FAILED(hr)) {
        return E_UNEXPECTED;
    }

    pITypeLib->Release();

    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                       TEXT("Software\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\IIsCertMapper\\{bc36cde8-afeb-11d1-9868-00a0c922e703}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT("Interfaces"), NULL, REG_MULTI_SZ,
                      (BYTE*) TEXT("{edcd6a60-b053-11d0-a62f-00a0c922e752}"),
                      sizeof(TEXT("{edcd6a60-b053-11d0-a62f-00a0c922e752}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                       TEXT("Software\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\IIsComputer\\{91ef9258-afec-11d1-9868-00a0c922e703}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT("Interfaces"), NULL, REG_MULTI_SZ,
                      (BYTE*) TEXT("{CF87A2E0-078B-11d1-9C3D-00A0C922E703}"),
                      sizeof(TEXT("{CF87A2E0-078B-11d1-9C3D-00A0C922E703}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                       TEXT("Software\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\IIsApplicationPool\\{E99F9D0C-FB39-402b-9EEB-AA185237BD34}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT("Interfaces"), NULL, REG_MULTI_SZ,
                      (BYTE*) TEXT("{0B3CB1E1-829A-4c06-8B09-F56DA1894C88}"),
                      sizeof(TEXT("{0B3CB1E1-829A-4c06-8B09-F56DA1894C88}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                       TEXT("Software\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\IIsApplicationPools\\{95863074-A389-406a-A2D7-D98BFC95B905}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT("Interfaces"), NULL, REG_MULTI_SZ,
                      (BYTE*) TEXT("{587F123F-49B4-49dd-939E-F4547AA3FA75}"),
                      sizeof(TEXT("{587F123F-49B4-49dd-939E-F4547AA3FA75}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                       TEXT("Software\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\IIsWebService\\{40B8F873-B30E-475d-BEC5-4D0EBB0DBAF3}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT("Interfaces"), NULL, REG_MULTI_SZ,
                      (BYTE*) TEXT("{EE46D40C-1B38-4a02-898D-358E74DFC9D2}"),
                      sizeof(TEXT("{EE46D40C-1B38-4a02-898D-358E74DFC9D2}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                       TEXT("Software\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\IIsApp\\{b4f34438-afec-11d1-9868-00a0c922e703}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }
//    if (RegSetValueEx(hKeyTemp, TEXT("Interfaces"), NULL, REG_MULTI_SZ,
//                      (BYTE*) TEXT("{46FBBB80-0192-11d1-9C39-00A0C922E703}"),
//                      sizeof(TEXT("{46FBBB80-0192-11d1-9C39-00A0C922E703}")))!=ERROR_SUCCESS) {
//                RegCloseKey(hKeyTemp);
//                return E_UNEXPECTED;
//                }
	TCHAR appInterfaces[] = 
		TEXT("{46FBBB80-0192-11d1-9C39-00A0C922E703}\0{603DCBEA-7350-11d2-A7BE-0000F8085B95}\0{2812b639-8fac-4510-96c5-71ddbd1f54fc}\0\0");
    if (RegSetValueEx(hKeyTemp, TEXT("Interfaces"), NULL, REG_MULTI_SZ,
                      (BYTE*) appInterfaces, sizeof(appInterfaces))!=ERROR_SUCCESS) 
    {
        RegCloseKey(hKeyTemp);
        return E_UNEXPECTED;
    }
    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                       TEXT("Software\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\IIsServer\\{c3b32488-afec-11d1-9868-00a0c922e703}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT("Interfaces"), NULL, REG_MULTI_SZ,
                      (BYTE*) TEXT("{5d7b33f0-31ca-11cf-a98a-00aa006bc149}"),
                      sizeof(TEXT("{5d7b33f0-31ca-11cf-a98a-00aa006bc149}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("IISExtDsCrMap\\CLSID"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("{bc36cde8-afeb-11d1-9868-00a0c922e703}"),
                      sizeof(TEXT("{bc36cde8-afeb-11d1-9868-00a0c922e703}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    //
    // register CLSID
    //

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("CLSID\\{bc36cde8-afeb-11d1-9868-00a0c922e703}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyCLSID, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("IIS Cert Map Extension"),
                      sizeof(TEXT("IIS Cert Map Extension")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("InprocServer32"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) pszName,
                      dwNameSize)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT("ThreadingModel"), NULL, REG_SZ,
                      (BYTE*) TEXT("Both"),
                      sizeof(TEXT("Both")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("ProgID"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("IISExtDsCrMap"),
                      sizeof(TEXT("IISExtDsCrMap")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("TypeLib"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("{2a56ea30-afeb-11d1-9868-00a0c922e703}"),
                      sizeof(TEXT("{2a56ea30-afeb-11d1-9868-00a0c922e703}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("Version"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("0.0"),
                      sizeof(TEXT("0.0")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);
    RegCloseKey(hKeyCLSID);

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("IISExtComputer\\CLSID"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("{91ef9258-afec-11d1-9868-00a0c922e703}"),
                      sizeof(TEXT("{91ef9258-afec-11d1-9868-00a0c922e703}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    //
    // register CLSID
    //

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("CLSID\\{91ef9258-afec-11d1-9868-00a0c922e703}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyCLSID, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("IIS Computer Extension"),
                      sizeof(TEXT("IIS Computer Extension")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("InprocServer32"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) pszName,
                      dwNameSize)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT("ThreadingModel"), NULL, REG_SZ,
                      (BYTE*) TEXT("Both"),
                      sizeof(TEXT("Both")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("ProgID"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("IISExtComputer"),
                      sizeof(TEXT("IISExtComputer")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("TypeLib"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("{2a56ea30-afeb-11d1-9868-00a0c922e703}"),
                      sizeof(TEXT("{2a56ea30-afeb-11d1-9868-00a0c922e703}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("Version"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("0.0"),
                      sizeof(TEXT("0.0")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);
    RegCloseKey(hKeyCLSID);

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("IISExtApplicationPool\\CLSID"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("{E99F9D0C-FB39-402b-9EEB-AA185237BD34}"),
                      sizeof(TEXT("{E99F9D0C-FB39-402b-9EEB-AA185237BD34}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    //
    // register CLSID
    //

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("CLSID\\{E99F9D0C-FB39-402b-9EEB-AA185237BD34}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyCLSID, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("IIS ApplicationPool Extension"),
                      sizeof(TEXT("IIS ApplicationPool Extension")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("InprocServer32"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) pszName,
                      dwNameSize)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT("ThreadingModel"), NULL, REG_SZ,
                      (BYTE*) TEXT("Both"),
                      sizeof(TEXT("Both")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("ProgID"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("IISExtApplicationPool"),
                      sizeof(TEXT("IISExtApplicationPool")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("TypeLib"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("{2a56ea30-afeb-11d1-9868-00a0c922e703}"),
                      sizeof(TEXT("{2a56ea30-afeb-11d1-9868-00a0c922e703}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("Version"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("0.0"),
                      sizeof(TEXT("0.0")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);
    RegCloseKey(hKeyCLSID);

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("IISExtApplicationPools\\CLSID"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("{95863074-A389-406a-A2D7-D98BFC95B905}"),
                      sizeof(TEXT("{95863074-A389-406a-A2D7-D98BFC95B905}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("CLSID\\{95863074-A389-406a-A2D7-D98BFC95B905}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyCLSID, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("IIS ApplicationPools Extension"),
                      sizeof(TEXT("IIS ApplicationPools Extension")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("InprocServer32"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) pszName,
                      dwNameSize)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT("ThreadingModel"), NULL, REG_SZ,
                      (BYTE*) TEXT("Both"),
                      sizeof(TEXT("Both")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("ProgID"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("IISExtApplicationPools"),
                      sizeof(TEXT("IISExtApplicationPools")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("TypeLib"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("{2a56ea30-afeb-11d1-9868-00a0c922e703}"),
                      sizeof(TEXT("{2a56ea30-afeb-11d1-9868-00a0c922e703}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("Version"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("0.0"),
                      sizeof(TEXT("0.0")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);
    RegCloseKey(hKeyCLSID);

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("IISWebService\\CLSID"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("{40B8F873-B30E-475d-BEC5-4D0EBB0DBAF3}"),
                      sizeof(TEXT("{40B8F873-B30E-475d-BEC5-4D0EBB0DBAF3}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("CLSID\\{40B8F873-B30E-475d-BEC5-4D0EBB0DBAF3}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyCLSID, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("IIS Web Service Extension"),
                      sizeof(TEXT("IIS Web Service Extension")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("InprocServer32"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) pszName,
                      dwNameSize)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT("ThreadingModel"), NULL, REG_SZ,
                      (BYTE*) TEXT("Both"),
                      sizeof(TEXT("Both")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("ProgID"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("IISExtWebService"),
                      sizeof(TEXT("IISExtWebService")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("TypeLib"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("{2a56ea30-afeb-11d1-9868-00a0c922e703}"),
                      sizeof(TEXT("{2a56ea30-afeb-11d1-9868-00a0c922e703}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("Version"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("0.0"),
                      sizeof(TEXT("0.0")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);
    RegCloseKey(hKeyCLSID);

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("IISExtApp\\CLSID"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("{b4f34438-afec-11d1-9868-00a0c922e703}"),
                      sizeof(TEXT("{b4f34438-afec-11d1-9868-00a0c922e703}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    //
    // register CLSID
    //

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("CLSID\\{b4f34438-afec-11d1-9868-00a0c922e703}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyCLSID, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("IIS App Extension"),
                      sizeof(TEXT("IIS App Extension")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("InprocServer32"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) pszName,
                      dwNameSize)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT("ThreadingModel"), NULL, REG_SZ,
                      (BYTE*) TEXT("Both"),
                      sizeof(TEXT("Both")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("ProgID"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("IISExtApp"),
                      sizeof(TEXT("IISExtApp")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("TypeLib"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("{2a56ea30-afeb-11d1-9868-00a0c922e703}"),
                      sizeof(TEXT("{2a56ea30-afeb-11d1-9868-00a0c922e703}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("Version"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("0.0"),
                      sizeof(TEXT("0.0")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);
    RegCloseKey(hKeyCLSID);

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("IISExtServer\\CLSID"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("{c3b32488-afec-11d1-9868-00a0c922e703}"),
                      sizeof(TEXT("{c3b32488-afec-11d1-9868-00a0c922e703}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    //
    // register CLSID
    //

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("CLSID\\{c3b32488-afec-11d1-9868-00a0c922e703}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyCLSID, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("IIS Server Extension"),
                      sizeof(TEXT("IIS Server Extension")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("InprocServer32"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) pszName,
                      dwNameSize)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT("ThreadingModel"), NULL, REG_SZ,
                      (BYTE*) TEXT("Both"),
                      sizeof(TEXT("Both")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("ProgID"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("IISExtServer"),
                      sizeof(TEXT("IISExtServer")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("TypeLib"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("{2a56ea30-afeb-11d1-9868-00a0c922e703}"),
                      sizeof(TEXT("{2a56ea30-afeb-11d1-9868-00a0c922e703}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("Version"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("0.0"),
                      sizeof(TEXT("0.0")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);
    RegCloseKey(hKeyCLSID);

    return NOERROR;

}

//+------------------------------------------------------------------------
//
//  Function:   DllUnregisterServer
//
//  Synopsis:   Register registry keys for adsiis
//
//  Arguments:  None
//
//+------------------------------------------------------------------------
/* #pragma INTRINSA suppress=all */
STDAPI DllUnregisterServer(void) {

    UnRegisterTypeLib(LIBID_IISExt,
                      1,
                      0,
                      0,
                      SYS_WIN32);

    RegDeleteKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\IIsCertMapper\\{bc36cde8-afeb-11d1-9868-00a0c922e703}"));
    RegDeleteKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\IIsCertMapper"));
    RegDeleteKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\IIsComputer\\{91ef9258-afec-11d1-9868-00a0c922e703}"));
    RegDeleteKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\IIsComputer"));
    RegDeleteKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\IIsApplicationPool\\{E99F9D0C-FB39-402b-9EEB-AA185237BD34}"));
    RegDeleteKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\IIsApplicationPool"));
    RegDeleteKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\IIsWebService\\{40B8F873-B30E-475d-BEC5-4D0EBB0DBAF3}"));
    RegDeleteKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\IIsWebService"));
    RegDeleteKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\IIsApplicationPools\\{95863074-A389-406a-A2D7-D98BFC95B905}"));
    RegDeleteKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\IIsApplicationPools"));
    RegDeleteKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\IIsApp\\{b4f34438-afec-11d1-9868-00a0c922e703}"));
    RegDeleteKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\IIsApp"));
    RegDeleteKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\IIsServer\\{c3b32488-afec-11d1-9868-00a0c922e703}"));
    RegDeleteKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\IIsServer"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("IISExtDsCrMap\\CLSID"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("IISExtDsCrMap"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{bc36cde8-afeb-11d1-9868-00a0c922e703}\\InprocServer32"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{bc36cde8-afeb-11d1-9868-00a0c922e703}\\ProgID"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{bc36cde8-afeb-11d1-9868-00a0c922e703}\\TypeLib"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{bc36cde8-afeb-11d1-9868-00a0c922e703}\\Version"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{bc36cde8-afeb-11d1-9868-00a0c922e703}"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("IISExtComputer\\CLSID"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("IISExtComputer"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{91ef9258-afec-11d1-9868-00a0c922e703}\\InprocServer32"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{91ef9258-afec-11d1-9868-00a0c922e703}\\ProgID"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{91ef9258-afec-11d1-9868-00a0c922e703}\\TypeLib"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{91ef9258-afec-11d1-9868-00a0c922e703}\\Version"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{91ef9258-afec-11d1-9868-00a0c922e703}"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("IISExtApplicationPool\\CLSID"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("IISExtApplicationPool"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{E99F9D0C-FB39-402b-9EEB-AA185237BD34}\\InprocServer32"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{E99F9D0C-FB39-402b-9EEB-AA185237BD34}\\ProgID"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{E99F9D0C-FB39-402b-9EEB-AA185237BD34}\\TypeLib"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{E99F9D0C-FB39-402b-9EEB-AA185237BD34}\\Version"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{E99F9D0C-FB39-402b-9EEB-AA185237BD34}"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("IISExtApplicationPools\\CLSID"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("IISExtApplicationPools"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{95863074-A389-406a-A2D7-D98BFC95B905}\\InprocServer32"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{95863074-A389-406a-A2D7-D98BFC95B905}\\ProgID"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{95863074-A389-406a-A2D7-D98BFC95B905}\\TypeLib"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{95863074-A389-406a-A2D7-D98BFC95B905}\\Version"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{95863074-A389-406a-A2D7-D98BFC95B905}"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("IISExtWebService\\CLSID"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("IISExtWebService"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{40B8F873-B30E-475d-BEC5-4D0EBB0DBAF3}\\InprocServer32"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{40B8F873-B30E-475d-BEC5-4D0EBB0DBAF3}\\ProgID"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{40B8F873-B30E-475d-BEC5-4D0EBB0DBAF3}\\TypeLib"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{40B8F873-B30E-475d-BEC5-4D0EBB0DBAF3}\\Version"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{40B8F873-B30E-475d-BEC5-4D0EBB0DBAF3}"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("IISExtApp\\CLSID"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("IISExtApp"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{91ef9258-afec-11d1-9868-00a0c922e703}\\InprocServer32"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{91ef9258-afec-11d1-9868-00a0c922e703}\\ProgID"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{91ef9258-afec-11d1-9868-00a0c922e703}\\TypeLib"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{91ef9258-afec-11d1-9868-00a0c922e703}\\Version"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{91ef9258-afec-11d1-9868-00a0c922e703}"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("IISExtServer\\CLSID"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("IISExtServer"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{c3b32488-afec-11d1-9868-00a0c922e703}\\InprocServer32"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{c3b32488-afec-11d1-9868-00a0c922e703}\\ProgID"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{c3b32488-afec-11d1-9868-00a0c922e703}\\TypeLib"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{c3b32488-afec-11d1-9868-00a0c922e703}\\Version"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{c3b32488-afec-11d1-9868-00a0c922e703}"));

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\iisext\svrcache.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:  svrcache.cxx
//
//  Contents:  Caching code for com interface pointer and schema pointer
//
//  History:   28-Apr-97     SophiaC    Created.
//
//----------------------------------------------------------------------------
#include <iisext.hxx>

BOOL SERVER_CACHE::Insert(SERVER_CACHE_ITEM * item)
// returns TRUE if succeed
{
    ASSERT(NULL != item);
    CLock lock;
#ifdef DBG
    SERVER_CACHE_ITEM * item2;
    Cache.Reset();
    while (NULL != (item2 = Cache.Next()))
        {
        if ((0 == _wcsicmp(item->ServerName, item2->ServerName)) &&
            (item->dwThreadId == item2->dwThreadId))
            {
            ASSERT(!"item already exists");
            }
        }
#endif
    item->key = Cache.Insert(item);
    return item->key != -1;
}

SERVER_CACHE_ITEM * SERVER_CACHE::Delete(LPWSTR ServerName, DWORD dwThreadId)
// returns item found
{
    SERVER_CACHE_ITEM * item;
    CLock lock;
    Cache.Reset();
    while (NULL != (item = Cache.Next()))
        {
        if ((0 == _wcsicmp(ServerName, item->ServerName)) &&
            (dwThreadId == item->dwThreadId))
            {
            Cache.Delete(item->key);
            if (item->ServerName) {
                delete item->ServerName;
            }
            return item; 
            }
        }
    return NULL;
}

SERVER_CACHE_ITEM * SERVER_CACHE::Find(LPWSTR ServerName, DWORD dwThreadId)
// returns pointer to the item found
{
    SERVER_CACHE_ITEM * item;
    CLock lock;
    Cache.Reset();
    while (NULL != (item = Cache.Next()))
        {
        if ((0 == _wcsicmp(ServerName, item->ServerName)) &&
            (dwThreadId == item->dwThreadId))
            {
            return item;
            }
        }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\iisext\parse.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:  parse.cxx
//
//  Contents:  IIS Pathname Parser
//
//  The Pathname Parser is a key component in ADs providers. It checks for
//  syntactic validity of an ADs pathname that has been passed to this
//  provider. If the syntax is valid, then an OBJECTINFO structure is
//  constructed. This OBJECTINFO structure contains a componentized version
//  of the ADs pathname for this object.
//
//  Note all that is being done is a syntax check. Rather than special-case
//  every single new nuance to pathnames, all path checking must conform to
//  the grammar rules laid out by the parser.
//
//
//
//  History:
//----------------------------------------------------------------------------
#include "iisext.hxx"
#pragma hdrstop

// Object -> PathName, Type, eos
// Object -> PathName, eos

//+---------------------------------------------------------------------------
//  Function:   ADsObject
//
//  Synopsis:   parses an ADs pathname passed to this provider. This function
//              parses the following grammar rules
//
//              <ADsObject> -> <ProviderName> <IISObject>
//
//
//  Arguments:  [CLexer * pTokenizer] - a lexical analyzer object
//              [POBJECTINFO pObjectInfo] - a pointer to an OBJECTINFO structure
//
//  Returns:    [HRESULT] 0 if successful, error HRESULT if not
//
//  Modifies:   pTokenizer (consumes the input buffer)
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
ADsObject(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = ProviderName(pTokenizer, pObjectInfo);
    BAIL_IF_ERROR(hr);

    pObjectInfo->ComponentArray = NULL;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    switch (dwToken) {

    case TOKEN_END:
        RRETURN(S_OK);

    case TOKEN_COMMA:
        hr = Type(pTokenizer, pObjectInfo);
        BAIL_IF_ERROR(hr);
        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);
        if (dwToken == TOKEN_END) {
            RRETURN(S_OK);
        }else {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

    default:
        hr = pTokenizer->PushBackToken();


        hr = IISObject(pTokenizer, pObjectInfo);
        BAIL_IF_ERROR(hr);

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);

        switch (dwToken) {
        case TOKEN_END:
            RRETURN(S_OK);

        case TOKEN_COMMA:
            hr = Type(pTokenizer, pObjectInfo);
            BAIL_IF_ERROR(hr);
            hr = pTokenizer->GetNextToken(szToken, &dwToken);
            BAIL_IF_ERROR(hr);
            if (dwToken == TOKEN_END) {
                RRETURN(S_OK);
            }else {
                RRETURN(E_ADS_BAD_PATHNAME);
            }

        default:
            RRETURN(E_FAIL);

        }
    }

cleanup:
    RRETURN(hr);

}



//+---------------------------------------------------------------------------
//  Function:   IISObject
//
//  Synopsis:   parses an ADs pathname passed to this provider. This function
//              parses the following grammar rules
//
//              <IISObject> -> "\\""identifier""\" <IISObject>
//
//
//  Arguments:  [CLexer * pTokenizer] - a lexical analyzer object
//              [POBJECTINFO pObjectInfo] - a pointer to an OBJECTINFO structure
//
//  Returns:    [HRESULT] 0 if successful, error HRESULT if not
//
//  Modifies:   pTokenizer (consumes the input buffer)
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------

HRESULT
IISObject(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if ((dwToken != TOKEN_FSLASH) &&  (dwToken != TOKEN_BSLASH)) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }


    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if ((dwToken != TOKEN_FSLASH) && (dwToken != TOKEN_BSLASH)) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }


    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if (dwToken != TOKEN_IDENTIFIER) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    hr = AddTreeName(pObjectInfo, szToken);
    BAIL_IF_ERROR(hr);

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    //
    // If we get an TOKEN_END, then we have a tree name only \\<tree_name>
    //

    if (dwToken == TOKEN_END || dwToken == TOKEN_COMMA) {
        hr = pTokenizer->PushBackToken();
        RRETURN(S_OK);
    }

    if ((dwToken != TOKEN_BSLASH) && (dwToken != TOKEN_FSLASH)) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    hr = PathName(pTokenizer, pObjectInfo);
    BAIL_IF_ERROR(hr);

cleanup:
    RRETURN(hr);
}

HRESULT
ProviderName(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    if (dwToken == TOKEN_ATSIGN) {

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);

        if (dwToken != TOKEN_IDENTIFIER) {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

        hr = AddProviderName(pObjectInfo, szToken);

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);


        if (dwToken != TOKEN_EXCLAMATION) {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

    }else if (dwToken == TOKEN_IDENTIFIER) {

        hr = AddProviderName(pObjectInfo, szToken);

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);


        if (dwToken != TOKEN_COLON) {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

    }else {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    //
    // You can now disable the processing for "@" and "!" treat them
    // as ordinary characters.
    //

    pTokenizer->SetAtDisabler(TRUE);


    RRETURN(S_OK);

cleanup:

    RRETURN(hr);
}


// PathName -> Component \\ PathName
// PathName -> Component
HRESULT
DsPathName(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if ((dwToken != TOKEN_FSLASH) && (dwToken != TOKEN_BSLASH)) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }


    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if ((dwToken != TOKEN_FSLASH) && (dwToken != TOKEN_BSLASH)) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    hr = PathName(pTokenizer, pObjectInfo);
    BAIL_IF_ERROR(hr);

    RRETURN(S_OK);

cleanup:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
PathName(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    HRESULT hr;
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;

    do
    {
        hr = Component(pTokenizer, pObjectInfo);
        BAIL_IF_ERROR(hr);

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);
    }
    while( (dwToken == TOKEN_BSLASH) || (dwToken == TOKEN_FSLASH) );

    hr = pTokenizer->PushBackToken();
    BAIL_IF_ERROR(hr);

cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:  Component -> <identifier>
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
Component(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szValue[MAX_TOKEN_LENGTH];
    WCHAR szEqual[MAX_TOKEN_LENGTH];
    WCHAR szComponent[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = pTokenizer->GetNextToken(szComponent, &dwToken);
    BAIL_IF_ERROR(hr);

    if (dwToken != TOKEN_IDENTIFIER) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    hr = pTokenizer->GetNextToken(szEqual, &dwToken);
    BAIL_IF_ERROR(hr);

    if (dwToken == TOKEN_EQUAL) {

        hr = pTokenizer->GetNextToken(szValue, &dwToken);
        BAIL_IF_ERROR(hr);

        if (dwToken != TOKEN_IDENTIFIER) {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

        hr = AddComponent(pObjectInfo, szComponent, szValue);
        BAIL_IF_ERROR(hr);

    }else {

        hr = AddComponent(pObjectInfo, szComponent, NULL);
        BAIL_IF_ERROR(hr);

        hr = pTokenizer->PushBackToken();
        BAIL_IF_ERROR(hr);
    }

    RRETURN(S_OK);

cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CLexer::CLexer():
                _ptr(NULL),
                _Buffer(NULL),
                _dwLastTokenLength(0),
                _dwLastToken(0),
                _dwEndofString(0),
                _bAtDisabled(FALSE)
{
        return;
}

HRESULT
CLexer::Initialize(LPWSTR szBuffer)
{
    if (!szBuffer || !*szBuffer) {
        RRETURN(S_OK);
    }

    _Buffer = AllocADsStr(szBuffer);

    if (!_Buffer) {
        RRETURN(E_OUTOFMEMORY);
    }
    _ptr = _Buffer;
    RRETURN(S_OK);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    08-12-96   t-danal     Created.
//
//----------------------------------------------------------------------------
CLexer::~CLexer()
{
    FreeADsStr(_Buffer);
}

/*++
    This routine assumes that szToken is a buffer of at least MAX_TOKEN_LENGTH
--*/
HRESULT
CLexer::GetNextToken(LPWSTR szToken, LPDWORD pdwToken)
{
    WCHAR c;
    DWORD state = 0;
    LPWSTR pch = szToken;

    memset(szToken, 0, sizeof(WCHAR) * MAX_TOKEN_LENGTH);
    _dwLastTokenLength = 0;
    while (1) {
        c = NextChar();
        switch (state) {
        case  0:
            if (_dwLastTokenLength++ >= MAX_TOKEN_LENGTH) {
                RRETURN(RETURNCODETOHRESULT(ERROR_INVALID_NAME));
            }
            *pch++ = c;

            if (c == L'\\') {
                *pdwToken = TOKEN_BSLASH;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            }else if (c == L'/') {
                *pdwToken = TOKEN_FSLASH;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            }else if (c == L',') {
                *pdwToken = TOKEN_COMMA;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            }else if (c == L'='){
                *pdwToken = TOKEN_EQUAL;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            }
            else if (c == L':'){
                *pdwToken = TOKEN_COLON;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            }else if (c == L'\0'){
                *pdwToken = TOKEN_END;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            }else if (c == L'@') {

                if (!_bAtDisabled) {

                    *pdwToken = TOKEN_ATSIGN;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);


                }else {
                    state = 1;
                }

            }else if (c == L'!'){

                if (!_bAtDisabled) {

                    *pdwToken = TOKEN_EXCLAMATION;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);


                }else {
                    state = 1;
                }

            }else {

                state = 1;
            }
            break;


        case 1:
            if (c == L'\\' || c == L'\0' || c == L',' ||
                    c == L'=' || 
                    c == L':' || c == L'/') {
                PushbackChar();

                *pdwToken = TOKEN_IDENTIFIER;
                _dwLastToken = *pdwToken;
                RRETURN (S_OK);

            }else if (c == L'@' || c == L'!') {

                if (!_bAtDisabled) {

                    PushbackChar();

                    *pdwToken = TOKEN_IDENTIFIER;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);


                }else {

                    if (_dwLastTokenLength++ >= MAX_TOKEN_LENGTH) {
                        RRETURN(RETURNCODETOHRESULT(ERROR_INVALID_NAME));
                    }
                    *pch++ = c;
                    state = 1;
                    break;

                }

            }else {
                if (_dwLastTokenLength++ >= MAX_TOKEN_LENGTH) {
                    RRETURN(RETURNCODETOHRESULT(ERROR_INVALID_NAME));
                }
                *pch++ = c;
                state = 1;
                break;
            }

        default:
            RRETURN(E_FAIL);
        }
    }
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
WCHAR
CLexer::NextChar()
{
    if (_ptr == NULL || *_ptr == L'\0') {
        _dwEndofString = TRUE;
        return(L'\0');
    }
    return(*_ptr++);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CLexer::PushBackToken()
{
    if (_dwLastToken == TOKEN_END) {
        RRETURN(S_OK);
    }
    _ptr -= _dwLastTokenLength;

    RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
void
CLexer::PushbackChar()
{
    if (_dwEndofString) {
        return;
    }
    _ptr--;

}

#if 0
//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
BOOL
CLexer::IsKeyword(LPWSTR szToken, LPDWORD pdwToken)
{
    DWORD i = 0;

    for (i = 0; i < MAX_KEYWORDS; i++) {
        if (!_wcsicmp(szToken, KeywordList[i].Keyword)) {
            *pdwToken = KeywordList[i].dwTokenId;
            return(TRUE);
        }
    }
    *pdwToken = 0;
    return(FALSE);
}

#endif

//+---------------------------------------------------------------------------
//Function:
//
//Synopsis:
//
//Arguments:
//
//Returns:
//
//Modifies:
//
//History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
AddComponent(POBJECTINFO pObjectInfo, LPWSTR szComponent, LPWSTR szValue)
{
    if (!szComponent || !*szComponent) {
        RRETURN(E_FAIL);
    }


    if (pObjectInfo->ComponentArray == NULL) {
        pObjectInfo->ComponentArray =
               (PCOMPONENT) AllocADsMem(sizeof(COMPONENT)*MAXCOMPONENTS);
        pObjectInfo->MaxComponents = MAXCOMPONENTS;
    }
    else if (pObjectInfo->NumComponents == pObjectInfo->MaxComponents) {
        pObjectInfo->ComponentArray =
               (PCOMPONENT) ReallocADsMem(
                                  pObjectInfo->ComponentArray,
                                  sizeof(COMPONENT)*pObjectInfo->MaxComponents,
                                  sizeof(COMPONENT)*(
                                    pObjectInfo->MaxComponents+MAXCOMPONENTS)
                                  );
        pObjectInfo->MaxComponents += MAXCOMPONENTS;
    }

    pObjectInfo->ComponentArray[pObjectInfo->NumComponents].szComponent =
                        AllocADsStr(szComponent);

    if (szValue && *szValue) {
        pObjectInfo->ComponentArray[pObjectInfo->NumComponents].szValue =
                        AllocADsStr(szValue);
    }
    else {
        pObjectInfo->ComponentArray[pObjectInfo->NumComponents].szValue = NULL;
    }

    pObjectInfo->NumComponents++;

    RRETURN(S_OK);
}

HRESULT
AddProviderName(POBJECTINFO pObjectInfo, LPWSTR szToken)
{
    if (!szToken || !*szToken) {
        RRETURN(E_FAIL);
    }

    pObjectInfo->ProviderName = AllocADsStr(szToken);

    RRETURN(S_OK);
}


HRESULT
AddTreeName(POBJECTINFO pObjectInfo, LPWSTR szToken)
{
    if (!szToken || !*szToken) {
        RRETURN(E_FAIL);
    }

    pObjectInfo->TreeName = AllocADsStr(szToken);

    RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
SetType(POBJECTINFO pObjectInfo, DWORD dwToken)
{
    pObjectInfo->ObjectType = dwToken;
    RRETURN(S_OK);
}


// Type -> "user", "group","printer","service", "fileservice"

//+---------------------------------------------------------------------------
// Function:    Type
//
// Synopsis:    Parses Type-> "user" | "group" etc
//
// Arguments:   [CLexer * pTokenizer]
//              [POBJECTINFo pObjectInfo]
//
// Returns:     HRESULT
//
// Modifies:    -
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------


HRESULT
Type(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_PATH];
    DWORD dwToken;
    HRESULT hr;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    if (dwToken == TOKEN_IDENTIFIER ) {
        RRETURN(hr);
    }

    RRETURN(E_FAIL);

cleanup:
    RRETURN(hr);
}


void
CLexer::SetAtDisabler(
    BOOL bFlag
    )
{
    _bAtDisabled = bFlag;
}

BOOL
CLexer::GetAtDisabler()
{
    return(_bAtDisabled);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\iisext\sdict.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:  sdict.cxx
//
//  Contents:  simple dictionary 
//
//  History:   28-Feb-97     SophiaC    Created.
//
//----------------------------------------------------------------------------
#include <iisext.hxx>

SIMPLE_DICT::SIMPLE_DICT()
{
    cDictSize = 0;
    iNextItem = 0;
    cDictSlots = INITIALDICTSLOTS;

    DictSlots = InitialDictSlots;
    memset(DictSlots, 0, sizeof(void *) * cDictSlots);
}

SIMPLE_DICT::~SIMPLE_DICT()
{
    if (DictSlots != InitialDictSlots)
        delete DictSlots;
}

int
SIMPLE_DICT::Insert (
    void *Item
    )
{
    int iDictSlots;
    void * * NewDictSlots;

    for (iDictSlots = 0; iDictSlots < cDictSlots; iDictSlots++)

        if (DictSlots[iDictSlots] == NULL)
            {
            DictSlots[iDictSlots] = Item;
            cDictSize += 1;
            return(iDictSlots);
            }

    // If we fell through to here, it must mean that the dictionary is
    // full; hence we need to allocate more space and copy the old
    // dictionary into it.

    NewDictSlots = (void * *) new char[sizeof(void *)*cDictSlots*2];
    if (!NewDictSlots)
        return(-1);

    memcpy(NewDictSlots, DictSlots, sizeof(void *) * cDictSlots);
    memset(NewDictSlots+iDictSlots, 0,  sizeof(void *) * cDictSlots);

    if (DictSlots != InitialDictSlots)
        delete DictSlots;
    DictSlots = NewDictSlots;

    cDictSlots *= 2;

    DictSlots[iDictSlots] = Item;
    cDictSize += 1;
    return(iDictSlots);
}

void *
SIMPLE_DICT::Find (
    int Key
    )
{
    if (Key >= cDictSlots)
        return(NULL);

    return(DictSlots[Key]);
}

void *
SIMPLE_DICT::DeleteItemByBruteForce(
    void * Item
    )
{

    if (Item == 0)
       {
       return (0);
       }

    for (int i = 0; i < cDictSlots; i++)
        {
        if (DictSlots[i] == Item)
           {
           DictSlots[i] = NULL;
           cDictSize -= 1;
           return (Item);
           }
        }

    return (0);
}

void *
SIMPLE_DICT::Delete (
    int Key
    )
{
    void *Item;

    if (Key >= cDictSlots)
        {
        return(NULL);
        }

    Item = DictSlots[Key];
    ASSERT((DictSlots[Key]));

    cDictSize -= 1;
    DictSlots[Key] = NULL;

    return(Item);
}

void *
SIMPLE_DICT::Next (
    )
{
    for ( ; iNextItem < cDictSlots; iNextItem++)
        {
        if (DictSlots[iNextItem])
            return(DictSlots[iNextItem++]);
        }

    iNextItem = NULL;
    return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\iisext\common\makefile.inc ===
.SUFFIXES: .def

{..\}.def{obj\$(TARGET_DIRECTORY)}.def:
    $(C_PREPROCESSOR) $<  > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\iisext\winnt\makefile.inc ===
!INCLUDE ..\common\makefile.inc



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\oleds2.0\include\heapstat.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       Heapstats.hxx
//
//  Contents:   Structure that holds heap statistics.
//
//  Classes:    HEAPSTATS
//
//  History:    26-Oct-93 DavidBak      Created
//
//--------------------------------------------------------------------------

#if !defined(__HEAPSTAT_HXX__)
#define __HEAPSTAT_HXX__

#if (PERFSNAP == 1) || (DBG == 1)

//+-------------------------------------------------------------------------
//
//  Class:      HEAPSTATS
//
//  Purpose:    Data structure containing performance counters from the heap.
//              Used in our version of operator new.
//              See common\src\except\memory.cxx.
//
//--------------------------------------------------------------------------

typedef struct _HeapStats
{
    ULONG	cNew;
    ULONG	cZeroNew;
    ULONG	cDelete;
    ULONG	cZeroDelete;
    ULONG	cRealloc;
    ULONG       cbNewed;
    ULONG       cbDeleted;
} HEAPSTATS;

//
// GetHeapStats is in memory.cxx
//

#ifdef __cplusplus
extern "C" {
#endif

void GetHeapStats(HEAPSTATS * hsStats);

#ifdef __cplusplus
}
#endif


#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\oleds2.0\include\adsi.h ===
//---------------------------------------------------------------------------
//
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997
//
//  File:  adsi.h
//
//  Contents:  Microsoft ADs LDAP Provider DSObject
//
//
//  History:   02-20-97    yihsins    Created.
//
//----------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

#include "adserr.h"
#include "adssts.h"
#include "adsnms.h"
#include "adsdb.h"

#include "adstype.h"

HRESULT
ADSIOpenDSObject(
    LPWSTR pszDNName,
    LPWSTR pszUserName,
    LPWSTR pszPassword,
    LONG   lnReserved,
    PHANDLE phDSObject
    );

HRESULT
ADSICloseDSObject(
    HANDLE hDSObject
    );

HRESULT
ADSISetObjectAttributes(
    HANDLE hDSObject,
    PADS_ATTR_INFO pAttributeEntries,
    DWORD dwNumAttributes,
    DWORD *pdwNumAttributesModified
    );

HRESULT
ADSIGetObjectAttributes(
    HANDLE hDSObject,
    LPWSTR *pAttributeNames,
    DWORD dwNumberAttributes,
    PADS_ATTR_INFO *ppAttributeEntries,
    DWORD * pdwNumAttributesReturned
    );

HRESULT
ADSICreateDSObject(
    HANDLE hParentDSObject,
    LPWSTR pszRDNName,
    PADS_ATTR_INFO pAttributeEntries,
    DWORD dwNumAttributes
    );

HRESULT
ADSIDeleteDSObject(
    HANDLE hParentDSObject,
    LPWSTR pszRDNName
    );

BOOL
FreeADsMem(
   LPVOID pMem
);


HRESULT
ADSISetSearchPreference(
    HANDLE hDSObject,
    IN PADS_SEARCHPREF_INFO pSearchPrefs,
    IN DWORD   dwNumPrefs
    );


HRESULT
ADSIExecuteSearch(
    HANDLE hDSObject,
    IN LPWSTR pszSearchFilter,
    IN LPWSTR * pAttributeNames,
    IN DWORD dwNumberAttributes,
    OUT PADS_SEARCH_HANDLE phSearchHandle
    );

HRESULT
ADSIAbandonSearch(
    HANDLE hDSObject,
    OUT PADS_SEARCH_HANDLE phSearchHandle
    );


HRESULT
ADSICloseSearchHandle (
    HANDLE hDSObject,
    IN ADS_SEARCH_HANDLE hSearchHandle
    );


HRESULT
ADSIGetFirstRow(
    HANDLE hDSObject,
    IN ADS_SEARCH_HANDLE hSearchHandle
    );

HRESULT
ADSIGetNextRow(
    HANDLE hDSObject,
    IN ADS_SEARCH_HANDLE hSearchHandle
    );


HRESULT
ADSIGetPreviousRow(
    HANDLE hDSObject,
    IN ADS_SEARCH_HANDLE hSearchHandle
    );


HRESULT
ADSIGetColumn(
    HANDLE hDSObject,
    IN ADS_SEARCH_HANDLE hSearchHandle,
    IN LPWSTR pszColumnName,
    OUT PADS_SEARCH_COLUMN pColumn
    );


HRESULT
ADSIGetNextColumnName(
    HANDLE hDSObject,
    IN ADS_SEARCH_HANDLE hSearchHandle,
    OUT LPWSTR * ppszColumnName
    );


HRESULT
ADSIFreeColumn(
    HANDLE hDSObject,
    IN PADS_SEARCH_COLUMN pColumn
    );

HRESULT
ADSIEnumAttributes(
    HANDLE hDSObject,
    LPWSTR * ppszAttrNames,
    DWORD dwNumAttributes,
    PADS_ATTR_DEF * ppAttrDefinition,
    DWORD * pdwNumAttributes
    );

HRESULT
ADSICreateAttributeDefinition(
    HANDLE hDSObject,
    LPWSTR pszAttributeName,
    PADS_ATTR_DEF pAttributeDefinition
    );

HRESULT
ADSIReadAttributeDefinition(
    HANDLE hDSObject,
    LPWSTR pszAttributeName,
    PADS_ATTR_DEF * pAttributeDefinition
    );

HRESULT
ADSIWriteAttributeDefinition(
    HANDLE hDSObject,
    LPWSTR pszAttributeName,
    PADS_ATTR_DEF  pAttributeDefinition
    );

HRESULT
ADSIDeleteAttributeDefinition(
    HANDLE hDSObject,
    LPWSTR pszAttributeName
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\iisext\iis60\makefile.inc ===
!INCLUDE ..\common\makefile.inc



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\oleds2.0\include\oledsdbg.h ===
//+-------------------------------------------------------------------------
//
// File:      oledsdbg.h
//
// Contains:  Debugging stuff for use by the ADs code
//
// History:
//
//
//--------------------------------------------------------------------------

#ifndef _ADSDBG_H_
#define _ADSDBG_H_
//--------------------------------------------------------------------------
//
// Debugging Stuff
//
//--------------------------------------------------------------------------


#include <formdeb.h>

#if DBG == 1
#define ADsDebugOut(x)  ADsInlineDebugOut x
#define ADsAssert(x)    Win4Assert(x)
#define ADsVerify(x)    ADsAssert(x)

//
// HeapValidate() is only available from NTs kernel32.dll
//

#if defined(DAYTONA)
#define VDATEHEAP()       Win4Assert(HeapValidate(GetProcessHeap(), 0, NULL))
#else
#define VDATEHEAP()
#endif

#else
#define ADsDebugOut(x)
#define ADsAssert(x)
#define ADsVerify(x)    x
#define VDATEHEAP()
#endif


DECLARE_DEBUG(ADs);

#ifdef Assert
#undef Assert
#endif

//
// You should use ADsAssert, not Assert
//
#define Assert(x) ADsAssert(x)

#endif //_ADSDBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\oleds2.0\include\caiheap.h ===
//+---------------------------------------------------------------------------
//  File:       caiheap.h
//
//  Contents:   Heap debugging structures and routines for the heap code
//		in commnot
//
//  History:    28-Oct-92   IsaacHe	Created
//
//----------------------------------------------------------------------------


//
// We keep a stack backtrace for each allocated block of memory.  DEPTHTRACE
// is the number of frames that we record
//
#define DEPTHTRACE   26			// depth of stack backtraces

//
// The AllocArena structure has this signature at its front.  We put a
// signature on the structure to allow external processes to snapshot the
// debug information and do some minimal check to see they are looking at the
// right stuff
//
const char HEAPSIG[] = { 'H', 'E', 'P', DEPTHTRACE };

// We keep track of the stack backtraces of allocation calls
// in these structues.

struct HeapAllocRec {
	DWORD	sum;		// checksum of stack backtrace
	void *fTrace[ DEPTHTRACE ];	// stack backtrace
	DWORD	count;		// # of un-freed allocs from this place
	size_t	bytes;		// # of un-freed bytes from this place
	struct AllocArena *paa;	// points back to the beginning...
	struct {
		DWORD	count;	// # of allocs from this place
		size_t	bytes;	// # of bytes from this place
	} total;
	union {
		struct HeapAllocRec *next; // next bucket in the hash list
		void *ImageBase; 	// base addr of containing module
	} u;
};

struct AllocArena {

	char Signature [ sizeof(HEAPSIG) ];
	char comment[ 32 ];
	CRITICAL_SECTION csExclusive;	// ensures single writer

	struct {
		int KeepStackTrace:1;	// are stack records being kept?
	} flags;

	ULONG cAllocs;			// # of non zero Alloc calls
	ULONG czAllocs;			// # of Alloc calls w/zero count
	ULONG cFrees;			// # of Free calls
	ULONG cReAllocs;		// # of realloc calls
	ULONG cMissed;			// # of missed stack backtraces
	ULONG cRecords;			// index of next free AllocRec entry
	ULONG cBytesNow;		// # of bytes currently allocated
	ULONG cBytesTotal;		// # of bytes ever allocated
	ULONG cTotalRecords;		// Total # of AllocRecs
	ULONG cPaths;			// # of distinct allocation paths

	struct {
		ULONG total[ 32 ];	// total number of allocations
		ULONG now[ 32 ];	// current # of simul allocs
		ULONG simul[ 32 ];	// highest # of simul allocs
	} Histogram;

	struct HeapAllocRec AllocRec[1]; // vector of records starts here..
};

/*
 * Allocators may want to associate one of these structures with every
 * allocation...
 */
struct AHeader {
	struct HeapAllocRec FAR *p;
	size_t size;
};

STDAPI_(struct AllocArena ** )
AllocArenaAddr( void );

STDAPI_( struct AllocArena * )
AllocArenaCreate( DWORD memctx, char FAR *comment );

STDAPI_( struct HeapAllocRec FAR * )
AllocArenaRecordAlloc( struct AllocArena *paa, size_t bytes );

STDAPI_(void)
AllocArenaRecordReAlloc( struct HeapAllocRec FAR *vp,
			size_t oldbytes, size_t newbytes );

STDAPI_(void)
AllocArenaRecordFree( struct HeapAllocRec FAR *vp, size_t bytes );

STDAPI_(void)
AllocArenaDump( struct AllocArena *paa );

STDAPI_( void )
AllocArenaDumpRecord( struct HeapAllocRec FAR *bp );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\oleds2.0\include\memory.h ===
#ifndef _MEMORY_H_INCLUDED_
#define _MEMORY_H_INCLUDED_

#ifdef __cplusplus
extern "C" {
#endif

LPVOID
AllocADsMem(
    DWORD cb
);

BOOL
FreeADsMem(
   LPVOID pMem
);

LPVOID
ReallocADsMem(
   LPVOID pOldMem,
   DWORD cbOld,
   DWORD cbNew
);

LPWSTR
AllocADsStr(
    LPWSTR pStr
);

BOOL
FreeADsStr(
   LPWSTR pStr
);


BOOL
ReallocADsStr(
   LPWSTR *ppStr,
   LPWSTR pStr
);

#if DBG

extern LIST_ENTRY ADsMemList ;

extern CRITICAL_SECTION ADsMemCritSect ;

VOID InitADsMem(
    VOID
    ) ;

VOID AssertADsMemLeaks(
    VOID
    ) ;


VOID
DumpMemoryTracker();


#else

#define InitADsMem()
#define AssertADsMemLeaks()

#define DumpMemoryTracker()



#endif

#ifdef __cplusplus
}
#endif


#endif // _MEMORY_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\oleds2.0\include\adstype.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:
//
//  Contents:
//
//  Functions:
//
//  History:
//
//----------------------------------------------------------------------------
#ifndef _ADSTYPE_H_INCLUDED_
#define _ADSTYPE_H_INCLUDED_

typedef enum {
   ADSTYPE_INVALID = 0,
   ADSTYPE_DN_STRING,
   ADSTYPE_CASE_EXACT_STRING,
   ADSTYPE_CASE_IGNORE_STRING,
   ADSTYPE_PRINTABLE_STRING,
   ADSTYPE_NUMERIC_STRING,
   ADSTYPE_BOOLEAN,
   ADSTYPE_INTEGER,
   ADSTYPE_OCTET_STRING,
   ADSTYPE_UTC_TIME,
   ADSTYPE_LARGE_INTEGER,
   ADSTYPE_PROV_SPECIFIC,
   ADSTYPE_OBJECT_CLASS,
   ADSTYPE_CASEIGNORE_LIST,
   ADSTYPE_OCTET_LIST,
   ADSTYPE_PATH,
   ADSTYPE_POSTALADDRESS,
   ADSTYPE_TIMESTAMP,
   ADSTYPE_BACKLINK,
   ADSTYPE_TYPEDNAME,
   ADSTYPE_HOLD,
   ADSTYPE_NETADDRESS,
   ADSTYPE_REPLICAPOINTER,
   ADSTYPE_FAXNUMBER,
   ADSTYPE_EMAIL,
   ADSTYPE_NT_SECURITY_DESCRIPTOR
} ADSTYPEENUM;
typedef ADSTYPEENUM ADSTYPE;

typedef unsigned char BYTE, *LPBYTE, *PBYTE;


//
// ADS Case DN String syntax
//

typedef LPWSTR ADS_DN_STRING, * PADS_DN_STRING;

//
// ADS Case Exact String syntax
//

typedef LPWSTR ADS_CASE_EXACT_STRING, * PADS_CASE_EXACT_STRING;

//
// ADS Case Ignore String syntax
//

typedef LPWSTR ADS_CASE_IGNORE_STRING, *PADS_CASE_IGNORE_STRING;

//
// ADS Printable String syntax
//

typedef LPWSTR ADS_PRINTABLE_STRING, *PADS_PRINTABLE_STRING;

//
// ADS Numeric String syntax
//
//

typedef LPWSTR ADS_NUMERIC_STRING, *PADS_NUMERIC_STRING;


//
// ADS Boolean syntax
//

typedef DWORD ADS_BOOLEAN, * LPNDS_BOOLEAN;

//
// Example: ADS Integer syntax
//

typedef DWORD ADS_INTEGER, *PADS_INTEGER;

//
// ADS Octet String syntax
//

typedef struct
{
    DWORD  dwLength;
    LPBYTE lpValue;

} ADS_OCTET_STRING, *PADS_OCTET_STRING;


//
// ADS NT Security Descriptor syntax
//

typedef struct
{
    DWORD  dwLength;
    LPBYTE lpValue;

} ADS_NT_SECURITY_DESCRIPTOR, *PADS_NT_SECURITY_DESCRIPTOR;


//
// ADS UTC Time Syntax
//

typedef SYSTEMTIME ADS_UTC_TIME, *PADS_UTC_TIME;


typedef LARGE_INTEGER ADS_LARGE_INTEGER, *PADS_LARGE_INTEGER;



//
// ADS ClassName syntax
//

typedef LPWSTR  ADS_OBJECT_CLASS, *PADS_OBJECT_CLASS;

typedef struct
{
    DWORD  dwLength;
    LPBYTE lpValue;

} ADS_PROV_SPECIFIC, *PADS_PROV_SPECIFIC;

//
// Extended Syntaxes for NDS
//
typedef struct _ADS_CASEIGNORE_LIST
{
    struct _ADS_CASEIGNORE_LIST *Next;
    LPWSTR            String;

}
ADS_CASEIGNORE_LIST, *PADS_CASEIGNORE_LIST;


typedef struct _ADS_OCTET_LIST
{
    struct _ADS_OCTET_LIST *Next;
    DWORD  Length;
    BYTE * Data;

} ADS_OCTET_LIST, *PADS_OCTET_LIST;

typedef struct
{
    DWORD  Type;
    LPWSTR VolumeName;
    LPWSTR Path;

} ADS_PATH, *PADS_PATH;

typedef struct
{
    LPWSTR PostalAddress[6]; // Value is limited to 6 lines,
                             // 30 characters each.

} ADS_POSTALADDRESS, *PADS_POSTALADDRESS;

typedef struct
{
    DWORD WholeSeconds; // Zero equals 12:00 midnight, January 1, 1970, UTC
    DWORD EventID;

} ADS_TIMESTAMP, *PADS_TIMESTAMP;

typedef struct
{
    DWORD  RemoteID;
    LPWSTR ObjectName;

} ADS_BACKLINK, *PADS_BACKLINK;

typedef struct
{
    LPWSTR ObjectName;
    DWORD  Level;
    DWORD  Interval;

} ADS_TYPEDNAME, *PADS_TYPEDNAME;

typedef struct
{
    LPWSTR ObjectName;
    DWORD  Amount;

} ADS_HOLD, *PADS_HOLD;

typedef struct
{
    DWORD  AddressType; // 0 = IPX,
    DWORD  AddressLength;
    BYTE * Address;

} ADS_NETADDRESS, *PADS_NETADDRESS;

typedef struct
{
    LPWSTR ServerName;
    DWORD  ReplicaType;
    DWORD  ReplicaNumber;
    DWORD  Count;
    PADS_NETADDRESS ReplicaAddressHints;
} ADS_REPLICAPOINTER, *PADS_REPLICAPOINTER;

typedef struct
{
    LPWSTR TelephoneNumber;
    DWORD  NumberOfBits;
    LPBYTE Parameters;
} ADS_FAXNUMBER, *PADS_FAXNUMBER;

typedef struct
{
    LPWSTR Address;
    DWORD  Type;
} ADS_EMAIL, *PADS_EMAIL;


typedef struct _adsvalue{
   ADSTYPE dwType;
   union {
      ADS_DN_STRING                     DNString;
      ADS_CASE_EXACT_STRING             CaseExactString;
      ADS_CASE_IGNORE_STRING            CaseIgnoreString;
      ADS_PRINTABLE_STRING              PrintableString;
      ADS_NUMERIC_STRING                NumericString;
      ADS_BOOLEAN                       Boolean;
      ADS_INTEGER                       Integer;
      ADS_OCTET_STRING                  OctetString;
      ADS_UTC_TIME                      UTCTime;
      ADS_LARGE_INTEGER                 LargeInteger;
      ADS_OBJECT_CLASS                  ClassName;
      ADS_PROV_SPECIFIC                 ProviderSpecific;
      PADS_CASEIGNORE_LIST              pCaseIgnoreList;
      PADS_OCTET_LIST                   pOctetList;
      PADS_PATH                         pPath;
      PADS_POSTALADDRESS                pPostalAddress;
      ADS_TIMESTAMP                     Timestamp;
      ADS_BACKLINK                      BackLink;
      PADS_TYPEDNAME                    pTypedName;
      ADS_HOLD                          Hold;
      PADS_NETADDRESS                   pNetAddress;
      PADS_REPLICAPOINTER               pReplicaPointer;
      PADS_FAXNUMBER                    pFaxNumber;
      ADS_EMAIL                         Email;
      ADS_NT_SECURITY_DESCRIPTOR        SecurityDescriptor;
   };
}ADSVALUE, *PADSVALUE, *LPADSVALUE;

typedef struct _ads_attr_info{
    LPWSTR  pszAttrName;
    DWORD   dwControlCode;
    ADSTYPE dwADsType;
    PADSVALUE pADsValues;
    DWORD   dwNumValues;
} ADS_ATTR_INFO, *PADS_ATTR_INFO;


const int  ADS_SECURE_AUTHENTICATION = 0x00000001;
const int  ADS_USE_ENCRYPTION        = 0x00000002;
const int  ADS_READONLY_SERVER       = 0x00000004;
const int  ADS_PROMPT_CREDENTIALS    = 0x00000008;
const int  ADS_NO_AUTHENTICATION     = 0x00000010;

/* ADS attribute modification operations */

const int ADS_ATTR_CLEAR          =  1; /* Clear all values from an attribute */
const int ADS_ATTR_UPDATE         =  2; /* Update values on an attribute */
const int ADS_ATTR_APPEND         =  3; /* Append  values to an attribute  */
const int ADS_ATTR_DELETE         =  4; /* Delete values from an attribute  */


typedef struct _ads_object_info{
    LPWSTR pszRDN;
    LPWSTR pszObjectDN;
    LPWSTR pszParentDN;
    LPWSTR pszSchemaDN;
    LPWSTR pszClassName;
} ADS_OBJECT_INFO, *PADS_OBJECT_INFO;

typedef enum {
    ADS_STATUS_S_OK = 0,
    ADS_STATUS_INVALID_SEARCHPREF,
    ADS_STATUS_INVALID_SEARCHPREFVALUE
} ADS_STATUSENUM;

typedef ADS_STATUSENUM ADS_STATUS, *PADS_STATUS;



typedef enum {
    ADS_DEREF_NEVER           = 0,
    ADS_DEREF_SEARCHING       = 1,
    ADS_DEREF_FINDING         = 2,
    ADS_DEREF_ALWAYS          = 3
} ADS_DEREFENUM;

typedef enum {
    ADS_SCOPE_BASE            = 0,
    ADS_SCOPE_ONELEVEL        = 1,
    ADS_SCOPE_SUBTREE         = 2
} ADS_SCOPEENUM;


//
// Values for ChaseReferral Option.

const int ADS_CHASE_REFERRALS_NEVER         =  0x00000000;
const int ADS_CHASE_REFERRALS_SUBORDINATE   =  0x00000020;
const int ADS_CHASE_REFERRALS_EXTERNAL      =  0x00000040;
const int ADS_CHASE_REFERRALS_ALWAYS        =
            (ADS_CHASE_REFERRALS_SUBORDINATE | ADS_CHASE_REFERRALS_EXTERNAL);

typedef enum {
   ADS_SEARCHPREF_ASYNCHRONOUS,
   ADS_SEARCHPREF_DEREF_ALIASES,
   ADS_SEARCHPREF_SIZE_LIMIT,
   ADS_SEARCHPREF_TIME_LIMIT,
   ADS_SEARCHPREF_ATTRIBTYPES_ONLY,
   ADS_SEARCHPREF_SEARCH_SCOPE,
   ADS_SEARCHPREF_TIMEOUT,
   ADS_SEARCHPREF_PAGESIZE,
   ADS_SEARCHPREF_PAGED_TIME_LIMIT,
   ADS_SEARCHPREF_CHASE_REFERRALS,
   ADS_SEARCHPREF_SORT_ON,
   ADS_SEARCHPREF_CACHE_RESULTS
} ADS_SEARCHPREF_ENUM;

typedef ADS_SEARCHPREF_ENUM ADS_SEARCHPREF;

typedef struct ads_searchpref_info{
    ADS_SEARCHPREF dwSearchPref;
    ADSVALUE vValue;
    ADS_STATUS dwStatus;
} ADS_SEARCHPREF_INFO, *PADS_SEARCHPREF_INFO, *LPADS_SEARCHPREF_INFO;


typedef HANDLE ADS_SEARCH_HANDLE, *PADS_SEARCH_HANDLE;


typedef struct ads_search_column {
   LPWSTR  pszAttrName;
   ADSTYPE dwADsType;
   PADSVALUE pADsValues;
   DWORD   dwNumValues;
   HANDLE hReserved;
} ADS_SEARCH_COLUMN, *PADS_SEARCH_COLUMN;

typedef struct _ads_attr_def {
   LPWSTR pszAttrName;
    ADSTYPE dwADsType;
    DWORD dwMinRange;
    DWORD dwMaxRange;
    BOOL fMultiValued;
}ADS_ATTR_DEF, *PADS_ATTR_DEF;


typedef struct _ads_sortkey {

    LPWSTR  pszAttrType;
    LPWSTR  pszReserved;
    BOOLEAN fReverseorder;

} ADS_SORTKEY, *PADS_SORTKEY;


//
// 3rd Party Extension 
//

//
// Valid dispids for extension.  
//
// - Max 24 bits. 
// - 0 reserved for DISPID_VALUE dealt with by aggregator.
// - DISPID_UNKNOWN (-1) also allowed. 
// - Others -ve dispids dealt with by aggregator only.
//

const int ADS_EXT_MINEXTDISPID = 1 ;
const int ADS_EXT_MAXEXTDISPID = 16777215 ;


//
// dwCodes for IADsExtension::Operate 
// 

const int ADS_EXT_INITCREDENTIALS = 1 ;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\oleds2.0\include\rowprov.h ===
//-----------------------------------------------------------------------------------
// Microsoft OLE DB Provider for ODBC data
// (C) Copyright 1994 - 1996 By Microsoft Corporation.
//
// @doc
//
// @module ROWPROV.H | Definition of the Row Provider interface used by the generic
//					   flavor of the TempTable.
//
//
// @rev 1 | 04-03-96 | WlodekN | Created
// @rev 2 | 07-24-96 | EricJ   | Added PropID
//
//-----------------------------------------------------------------------------------


#ifndef __ROWPROV_INCL__
#define __ROWPROV_INCL__


//---------------------------------- C L A S S E S ----------------------------------


// Abstract class for objects providing row data to the generic TempTable.
class IRowProvider : public IUnknown
{
	public:
		virtual STDMETHODIMP GetColumn
				(
				ULONG		icol,
				DBSTATUS	*pwStatus,
				ULONG		*pdwLength,
				BYTE		*pbData
				) = 0;
		virtual STDMETHODIMP NextRow
				(
				void
				) = 0;
};

EXTERN_C const IID IID_IRowProvider;
EXTERN_C const GUID DBPROPSET_TEMPTABLE;

// TempTable Property IDs.
enum tagetmptablepropid
{
	DBPROP_INSTANTPOPULATION=2,	// TRUE = Prepopulate.  FALSE = Lazy population.
	DBPROP_DBCOLBYREF,			// TRUE = Clear BYREF flags from IColumnsInfo, source owns memory.
	DBPROP_DONTALLOCBYREFCOLS,	// TRUE = TempTable only allocates ptr for BYREF columns.
};


#endif	// __ROWPROV_INCL__

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\oleds2.0\include\iadsp.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.03.0110 */
/* at Wed Sep 03 00:29:14 1997
 */
/* Compiler settings for adsp.odl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __iadsp_h__
#define __iadsp_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IADsObjectOptions_FWD_DEFINED__
#define __IADsObjectOptions_FWD_DEFINED__
typedef interface IADsObjectOptions IADsObjectOptions;
#endif 	/* __IADsObjectOptions_FWD_DEFINED__ */


void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __ActiveDsP_LIBRARY_DEFINED__
#define __ActiveDsP_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: ActiveDsP
 * at Wed Sep 03 00:29:14 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [helpstring][version][uuid] */ 



EXTERN_C const IID LIBID_ActiveDsP;

#ifndef __IADsObjectOptions_INTERFACE_DEFINED__
#define __IADsObjectOptions_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IADsObjectOptions
 * at Wed Sep 03 00:29:14 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][uuid] */ 



EXTERN_C const IID IID_IADsObjectOptions;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("46f14fda-232b-11d1-a808-00c04fd8d5a8")
    IADsObjectOptions : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetOption( 
            DWORD dwOption,
            void __RPC_FAR *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOption( 
            DWORD dwOption,
            void __RPC_FAR *pValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsObjectOptionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IADsObjectOptions __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IADsObjectOptions __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IADsObjectOptions __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOption )( 
            IADsObjectOptions __RPC_FAR * This,
            DWORD dwOption,
            void __RPC_FAR *pValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOption )( 
            IADsObjectOptions __RPC_FAR * This,
            DWORD dwOption,
            void __RPC_FAR *pValue);
        
        END_INTERFACE
    } IADsObjectOptionsVtbl;

    interface IADsObjectOptions
    {
        CONST_VTBL struct IADsObjectOptionsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsObjectOptions_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsObjectOptions_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsObjectOptions_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsObjectOptions_GetOption(This,dwOption,pValue)	\
    (This)->lpVtbl -> GetOption(This,dwOption,pValue)

#define IADsObjectOptions_SetOption(This,dwOption,pValue)	\
    (This)->lpVtbl -> SetOption(This,dwOption,pValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IADsObjectOptions_GetOption_Proxy( 
    IADsObjectOptions __RPC_FAR * This,
    DWORD dwOption,
    void __RPC_FAR *pValue);


void __RPC_STUB IADsObjectOptions_GetOption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IADsObjectOptions_SetOption_Proxy( 
    IADsObjectOptions __RPC_FAR * This,
    DWORD dwOption,
    void __RPC_FAR *pValue);


void __RPC_STUB IADsObjectOptions_SetOption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsObjectOptions_INTERFACE_DEFINED__ */

#endif /* __ActiveDsP_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\oleds2.0\include\svcprov.h ===
#include "rpc.h"
#include "rpcndr.h"

#ifndef __svcprov_h__
#define __svcprov_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IProvideDBService_FWD_DEFINED__
#define __IProvideDBService_FWD_DEFINED__
typedef interface IProvideDBService IProvideDBService;
#endif 	/* __IProvideDBService_FWD_DEFINED__ */

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IProvideDBService_INTERFACE_DEFINED__
#define __IProvideDBService_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IProvideDBService
 * at Mon Apr 22 16:40:51 1996
 * using MIDL 2.00.72
 ****************************************/
/* [unique][uuid][object][local] */ 

// @msg IID_IProvideDBService | {EFF65380-9C98-11CF-B963-00AA0044773D}
DEFINE_GUID(IID_IProvideDBService, 0xEFF65380L,0x9C98,0x11CF,0xB9,0x63,0x00,0xAA,0x00,0x44,0x77,0x3D);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IProvideDBService : public IUnknown
    {
    public:
        virtual HRESULT __stdcall ProvideService( 
            /* [in] */ ULONG cProvidedPropertySets,
            /* [size_is][in] */ DBPROPSET __RPC_FAR rgProvidedPropertySets[  ],
            /* [in] */ ULONG cRequestedPropertySets,
            /* [size_is][in] */ DBPROPSET __RPC_FAR rgRequestedPropertySets[  ],
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ IUnknown __RPC_FAR *pDataProvider,
            /* [in] */ REFIID riidRequested,
            /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppServiceProvider) = 0;
        
    };
    
#else 	/* C style interface */
    
    typedef struct IProvideDBServiceVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IProvideDBService __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IProvideDBService __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IProvideDBService __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *ProvideService )( 
            IProvideDBService __RPC_FAR * This,
            /* [in] */ ULONG cProvidedPropertySets,
            /* [size_is][in] */ DBPROPSET __RPC_FAR rgProvidedPropertySets[  ],
            /* [in] */ ULONG cRequestedPropertySets,
            /* [size_is][in] */ DBPROPSET __RPC_FAR rgRequestedPropertySets[  ],
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ IUnknown __RPC_FAR *pDataProvider,
            /* [in] */ REFIID riidRequested,
            /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppServiceProvider);
        
    } IProvideDBServiceVtbl;
    
    interface IProvideDBService
    {
        CONST_VTBL struct IProvideDBServiceVtbl __RPC_FAR *lpVtbl;
    };
    
    

#ifdef COBJMACROS


#define IProvideDBService_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IProvideDBService_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IProvideDBService_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IProvideDBService_ProvideService(This,cProvidedProperties,rgProvidedProperties,cRequestedProperties,rgRequestedProperties,pUnkOuter,pDataProvider,riidRequested,ppServiceProvider)	\
    (This)->lpVtbl -> ProvideService(This,cProvidedProperties,rgProvidedProperties,cRequestedProperties,rgRequestedProperties,pUnkOuter,pDataProvider,riidRequested,ppServiceProvider)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IProvideDBService_ProvideService_Proxy( 
    IProvideDBService __RPC_FAR * This,
    /* [in] */ ULONG cProvidedPropertySets,
    /* [size_is][in] */ DBPROPSET __RPC_FAR rgProvidedPropertySets[  ],
    /* [in] */ ULONG cRequestedPropertySets,
    /* [size_is][in] */ DBPROPSET __RPC_FAR rgRequestedPropertySets[  ],
    /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
    /* [in] */ IUnknown __RPC_FAR *pDataProvider,
    /* [in] */ REFIID riidRequested,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppServiceProvider);



void __RPC_STUB IProvideDBService_ProvideService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IProvideDBService_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\oleds2.0\include\msdatt.h ===
//--------------------------------------------------------------------
// Microsoft OLE DB Rowset Service Provider
// (C) Copyright 1994 - 1996 By Microsoft Corporation.
//
// @doc
//
// @module MSDATT.H | Service Provider Specific definitions
//
//--------------------------------------------------------------------

#ifndef  _MSDATT_H_
#define  _MSDATT_H_


// Provider Class Id
#ifdef DBINITCONSTANTS
extern const GUID CLSID_MSDATT               = {0xc8b522ceL,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};
#else // !DBINITCONSTANTS
extern const GUID CLSID_MSDATT;
#endif // DBINITCONSTANTS

#endif //_MSDATT_H_
//----
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\oleds2.0\include\formdeb.h ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991, Microsoft Corporation.
//
//  File:       formdeb.h
//
//  Contents:   Private project-wide Win 4 definitions
//
//  History:    23-Jul-91   KyleP       Created.
//              15-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        Consolidated win4p.hxx
//              22-Oct-91   SatoNa      Added SHLSTRICT
//              29-Apr-92   BartoszM    Moved from win4p.h
//               3-Jun-92   BruceFo     Added SMUISTRICT
//              17-Dec-92   AlexT       Moved UN..._PARM out of DEVL==1
//              30-Sep-93   KyleP       DEVL obsolete
//              18-Jun-94   AlexT       Make Assert a better statement
//              08-Aug-94   DonCl       copied from cinc and renamed formdeb.h
//
//----------------------------------------------------------------------------

#ifndef __FORMDEB_H__
#define __FORMDEB_H__
#define __DEBNOT_H__    // keep debnot.h from being included accidentally

#include <stdarg.h>

//----------------------------------------------------------------------------
//  Parameter Macros
//
//  To avoid compiler warnings for unimplemented functions, use
//  UNIMPLEMENTED_PARM(x) for each unreferenced parameter.  This will
//  later be defined to nul to reveal functions that we forgot to implement.
//
//  For functions which will never use a parameter, use
//  UNREFERENCED_PARM(x).
//

#define UNIMPLEMENTED_PARM(x)   (x)

#define UNREFERENCED_PARM(x)    (x)

//----------------------------------------------------------------------------
//
//  New STRICT defines should be added in two places below:
//
//  1)  Add the following within the ifdef ALLSTRICT/endif:
//
//      #ifndef xxSTRICT
//      #  define xxSTRICT
//      #endif
//
//      These entries are in alphabetical order.
//
//  2)  Add the following to the #if clause that defines ANYSTRICT:
//
//      #if ... || defined(xxSTRICT) || ...
//
//      so that ANYSTRICT is defined if any of the STRICT defines are.
//

#if (DBG == 1) || (OFSDBG == 1)

#  ifndef CATSTRICT
#    define CATSTRICT
#  endif

#  ifndef CISTRICT
#    define CISTRICT
#  endif

#  ifndef CMSSTRICT
#    define CMSSTRICT
#  endif

#  ifndef DLOSSTRICT
#    define DLOSSTRICT
#  endif

#  ifndef EVSTRICT
#    define EVSTRICT
#  endif

#  ifndef ICLSTRICT
#    define ICLSTRICT
#  endif

#  ifndef INSSTRICT
#    define INSSTRICT
#  endif

#  ifndef JWSTRICT
#    define JWSTRICT
#  endif

#  ifndef NSSTRICT
#    define NSSTRICT
#  endif

#  ifndef OLSTRICT
#    define OLSTRICT
#  endif

#  ifndef OMSTRICT
#    define OMSTRICT
#  endif

#  ifndef REPLSTRICT
#    define REPLSTRICT
#  endif

#  ifndef SHLSTRICT
#    define SHLSTRICT
#  endif

#  ifndef SLSTRICT
#    define SLSTRICT
#  endif

#  ifndef SMUISTRICT
#    define SMUISTRICT
#  endif

#  ifndef SOMSTRICT
#    define SOMSTRICT
#  endif

#  ifndef VCSTRICT
#    define VCSTRICT
#  endif

#  ifndef VQSTRICT
#    define VQSTRICT
#  endif

#  ifndef WMASTRICT
#    define WMASTRICT
#  endif


#endif // (DBG == 1) || (OFSDBG == 1)

//
//  ANYSTRICT
//

#if defined(CATSTRICT) || \
    defined(CISTRICT)  || \
    defined(CMSSTRICT) || \
    defined(DLOSSTRICT)|| \
    defined(ICLSTRICT) || \
    defined(INSSTRICT) || \
    defined(JWSTRICT)  || \
    defined(NSSTRICT)  || \
    defined(OLSTRICT)  || \
    defined(OMSTRICT)  || \
    defined(REPLSTRICT)|| \
    defined(SHLSTRICT) || \
    defined(SLSTRICT)  || \
    defined(SMUISTRICT)|| \
    defined(SOMSTRICT) || \
    defined(VCSTRICT)  || \
    defined(VQSTRICT)  || \
    defined(WMASTRICT)

#  define ANYSTRICT

#endif

#if (DBG != 1 && OFSDBG != 1) && defined(ANYSTRICT)
#pragma message Asserts are defined in a RETAIL build...
#endif


#if defined(WIN32)
 #include <windef.h>
#endif

#ifndef EXPORTDEF
 #define EXPORTDEF
#endif
#ifndef EXPORTIMP
 #define EXPORTIMP
#endif
#ifndef EXPORTED
 #define EXPORTED  _cdecl
#endif
#ifndef APINOT
#ifdef _X86_
 #define APINOT    _stdcall
#else
 #define APINOT    _cdecl
#endif
#endif

//
// DEBUG -- DEBUG -- DEBUG -- DEBUG -- DEBUG
//

#if (DBG == 1) || (OFSDBG == 1)

//
// Debug print functions.
//

#ifdef __cplusplus
extern "C" {
# define EXTRNC "C"
#else
# define EXTRNC
#endif



// vdprintf should only be called from xxDebugOut()

   EXPORTDEF void          APINOT
   vdprintf(
       unsigned long ulCompMask,
       char const *pszComp,
       char const *ppszfmt,
       va_list  ArgList);

   #define _Win4Assert Win4AssertEx

   EXPORTDEF void          APINOT
   Win4AssertEx(
       char const *pszFile,
       int iLine,
       char const *pszMsg);

   EXPORTDEF int           APINOT
   PopUpError(
       char const *pszMsg,
       int iLine,
       char const *pszFile);

   #define _SetWin4InfoLevel SetWin4InfoLevel

   EXPORTDEF unsigned long APINOT
   SetWin4InfoLevel(
       unsigned long ulNewLevel);

   EXPORTDEF unsigned long APINOT
   SetWin4InfoMask(
       unsigned long ulNewMask);

   #define _SetWin4AssertLevel SetWin4AssertLevel

   EXPORTDEF unsigned long APINOT
   SetWin4AssertLevel(
       unsigned long ulNewLevel);

   EXPORTDEF unsigned long APINOT
   SetWin4ExceptionLevel(
       unsigned long ulNewLevel);

#ifdef __cplusplus
}
#endif // __cplusplus

# define EXSTRICT      // (EXception STRICT) - Enabled if ANYSTRICT is enabled

# define Win4Assert(x)  \
        (void)((x) || (Win4AssertEx(__FILE__, __LINE__, #x),0))

# define Assert(x)      \
        (void)((x) || (Win4AssertEx(__FILE__, __LINE__, #x),0))

# define Verify(x) Assert(x)


//
// Debug print macros
//

# define DEB_ERROR               0x00000001      // exported error paths
# define DEB_WARN                0x00000002      // exported warnings
# define DEB_TRACE               0x00000004      // exported trace messages

# define DEB_DBGOUT              0x00000010      // Output to debugger
# define DEB_STDOUT              0x00000020      // Output to stdout

# define DEB_IERROR              0x00000100      // internal error paths
# define DEB_IWARN               0x00000200      // internal warnings
# define DEB_ITRACE              0x00000400      // internal trace messages

# define DEB_USER1               0x00010000      // User defined
# define DEB_USER2               0x00020000      // User defined
# define DEB_USER3               0x00040000      // User defined
# define DEB_USER4               0x00080000      // User defined
# define DEB_USER5               0x00100000      // User defined
# define DEB_USER6               0x00200000      // User defined
# define DEB_USER7               0x00400000      // User defined
# define DEB_USER8               0x00800000      // User defined
# define DEB_USER9               0x01000000      // User defined
# define DEB_USER10              0x02000000      // User defined
# define DEB_USER11              0x04000000      // User defined
# define DEB_USER12              0x08000000      // User defined
# define DEB_USER13              0x10000000      // User defined
# define DEB_USER14              0x20000000      // User defined
# define DEB_USER15              0x40000000      // User defined

# define DEB_NOCOMPNAME          0x80000000      // suppress component name

# define DEB_FORCE               0x7fffffff      // force message

# define ASSRT_MESSAGE           0x00000001      // Output a message
# define ASSRT_BREAK             0x00000002      // Int 3 on assertion
# define ASSRT_POPUP             0x00000004      // And popup message

# define EXCEPT_MESSAGE          0x00000001      // Output a message
# define EXCEPT_BREAK            0x00000002      // Int 3 on exception
# define EXCEPT_POPUP            0x00000004      // Popup message
# define EXCEPT_FAULT            0x00000008      // generate int 3 on access violation


//+----------------------------------------------------------------------
//
// DECLARE_DEBUG(comp)
// DECLARE_INFOLEVEL(comp)
//
// This macro defines xxDebugOut where xx is the component prefix
// to be defined. This declares a static variable 'xxInfoLevel', which
// can be used to control the type of xxDebugOut messages printed to
// the terminal. For example, xxInfoLevel may be set at the debug terminal.
// This will enable the user to turn debugging messages on or off, based
// on the type desired. The predefined types are defined below. Component
// specific values should use the upper 24 bits
//
// To Use:
//
// 1)   In your components main include file, include the line
//              DECLARE_DEBUG(comp)
//      where comp is your component prefix
//
// 2)   In one of your components source files, include the line
//              DECLARE_INFOLEVEL(comp)
//      where comp is your component prefix. This will define the
//      global variable that will control output.
//
// It is suggested that any component define bits be combined with
// existing bits. For example, if you had a specific error path that you
// wanted, you might define DEB_<comp>_ERRORxxx as being
//
// (0x100 | DEB_ERROR)
//
// This way, we can turn on DEB_ERROR and get the error, or just 0x100
// and get only your error.
//
// Define values that are specific to your xxInfoLevel variable in your
// own file, like ciquery.hxx.
//
//-----------------------------------------------------------------------

# ifndef DEF_INFOLEVEL
#  define DEF_INFOLEVEL (DEB_ERROR | DEB_WARN)
# endif



//
// Back to the info level stuff.
//

# ifdef __cplusplus
extern "C" {
# endif // __cplusplus

# define DECLARE_INFOLEVEL(comp) \
        extern EXTRNC unsigned long comp##InfoLevel = DEF_INFOLEVEL;\
        extern EXTRNC char *comp##InfoLevelString = #comp;

# ifdef __cplusplus
}
# endif

# ifdef __cplusplus

#  define DECLARE_DEBUG(comp) \
    extern EXTRNC unsigned long comp##InfoLevel; \
    extern EXTRNC char *comp##InfoLevelString; \
    _inline void \
    comp##InlineDebugOut(unsigned long fDebugMask, char const *pszfmt, ...) \
    { \
        if (comp##InfoLevel & fDebugMask) \
        { \
            va_list va; \
            va_start (va, pszfmt); \
            vdprintf(fDebugMask, comp##InfoLevelString, pszfmt, va);\
            va_end(va); \
        } \
    }     \
    \
    class comp##CDbgTrace\
    {\
    private:\
        unsigned long _ulFlags;\
        char const * const _pszName;\
    public:\
        comp##CDbgTrace(unsigned long ulFlags, char const * const pszName);\
        ~comp##CDbgTrace();\
    };\
    \
    inline comp##CDbgTrace::comp##CDbgTrace(\
            unsigned long ulFlags,\
            char const * const pszName)\
    : _ulFlags(ulFlags), _pszName(pszName)\
    {\
        comp##InlineDebugOut(_ulFlags, "Entering %s\n", _pszName);\
    }\
    \
    inline comp##CDbgTrace::~comp##CDbgTrace()\
    {\
        comp##InlineDebugOut(_ulFlags, "Exiting %s\n", _pszName);\
    }

# else  // ! __cplusplus

#  define DECLARE_DEBUG(comp) \
    extern EXTRNC unsigned long comp##InfoLevel; \
    extern EXTRNC char *comp##InfoLevelString; \
    _inline void \
    comp##InlineDebugOut(unsigned long fDebugMask, char const *pszfmt, ...) \
    { \
        if (comp##InfoLevel & fDebugMask) \
        { \
            va_list va; \
            va_start (va, pszfmt); \
            vdprintf(fDebugMask, comp##InfoLevelString, pszfmt, va);\
            va_end(va); \
        } \
    }

# endif // ! __cplusplus

#else  // DBG == 0

//
// NO DEBUG -- NO DEBUG -- NO DEBUG -- NO DEBUG -- NO DEBUG
//

# define Win4Assert(x)  NULL
# define Assert(x)      NULL
# define Verify(x)     (x)

# define DECLARE_DEBUG(comp)
# define DECLARE_INFOLEVEL(comp)

#endif // DBG == 0

#endif // __DEBNOT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\oleds2.0\include\oledserr.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    oledserr.h

Abstract:

    Contains the entry point for
        ADsGetLastError
        ADsSetLastError
        ADsFreeAllErrorRecords

Author:


    Ram Viswanathan (ramv) 20-Sep-1996

Environment:

    User Mode - Win32


---*/

#ifndef _OLEDSERR_H_INCLUDED_
#define _OLEDSERR_H_INCLUDED_

#ifdef _cplusplus
extern "C" {
#endif

HRESULT
ADsGetLastError(
    OUT     LPDWORD lpError,
    OUT     LPWSTR  lpErrorBuf,
    IN      DWORD   dwErrorBufLen,
    OUT     LPWSTR  lpNameBuf,
    IN      DWORD   dwNameBufLen
    );

VOID
ADsSetLastError(
    IN  DWORD   dwErr,
    IN  LPWSTR  pszError,
    IN  LPWSTR  pszProvider
    );

VOID
ADsFreeAllErrorRecords(
    VOID
    );

//=======================
// Data Structures
//=======================

typedef struct _ERROR_RECORD {
    struct  _ERROR_RECORD   *Prev;
    struct  _ERROR_RECORD   *Next;
    DWORD                   dwThreadId;
    DWORD                   dwErrorCode;
    LPWSTR                  pszErrorText;      // This is an allocated buffer
    LPWSTR                  pszProviderName;   // This is an allocated buffer
} ERROR_RECORD, *LPERROR_RECORD;



//
// Global Data Structures
//

extern 
ERROR_RECORD        ADsErrorRecList;    // Initialized to zeros by loader

extern
CRITICAL_SECTION    ADsErrorRecCritSec; // Initialized in libmain.cxx



//=======================
// MACROS
//=======================

#define FIND_END_OF_LIST(record)    while(record->Next != NULL) {   \
                                        record=record->Next;        \
                                    }

#define REMOVE_FROM_LIST(record)    record->Prev->Next = record->Next;      \
                                    if (record->Next != NULL) {             \
                                        record->Next->Prev = record->Prev;  \
                                    }

#define ADD_TO_LIST(record, newRec) FIND_END_OF_LIST(record)    \
                                    record->Next = newRec;      \
                                    newRec->Prev = record;      \
                                    newRec->Next = NULL;


//
// Local Functions
//

LPERROR_RECORD
ADsAllocErrorRecord(
    VOID);

LPERROR_RECORD
ADsFindErrorRecord(
    VOID);

#ifdef _cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\oleds2.0\include\macro.h ===
#define BAIL_IF_ERROR(hr) \
        if (FAILED(hr)) {       \
                goto cleanup;   \
        }\

#define BAIL_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                goto error;   \
        }\

#define CONTINUE_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                continue;   \
        }\

#define BAIL_ON_SUCCESS(hr) \
        if (SUCCEEDED(hr)) {       \
                goto error;   \
        }\

#define QUERY_INTERFACE(hr, ptr, iid, ppObj) \
        hr = ptr->QueryInterface(iid, (void **)ppObj); \
        if (FAILED(hr)) {    \
                goto cleanup;\
        }\


#define RRETURN_ENUM_STATUS(hr) \
        if (hr != S_OK) {       \
            RRETURN(S_FALSE);   \
        }                       \
        RRETURN(S_OK);




#define DEFINE_IDispatch_Implementation_Unimplemented(cls) \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)        \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,        \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,   \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid, \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}




#define DEFINE_IDispatch_Implementation(cls)                          \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfoCount(pctinfo));                \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfo(itinfo,                        \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
        RRETURN(_pDispMgr->GetIDsOfNames(iid,                         \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
        RRETURN (_pDispMgr->Invoke(dispidMember,                      \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}

#define DEFINE_IADs_Implementation(cls)                             \
STDMETHODIMP                                                          \
cls::get_Name(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreName(retval));                                    \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_ADsPath(THIS_ BSTR FAR* retval)                            \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsPath(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Class(THIS_ BSTR FAR* retval)                                \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsClass(retval));                              \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Parent(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreParent(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Schema(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreSchema(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_GUID(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreGUID(retval));                                    \
}                                                                     \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\oleds2.0\win95\win95.inc ===
#
# These flags do not get used because we do our
# own thing (for now).
#

CHICAGO_PRODUCT=1
ALT_PROJECT_TARGET=win95

#
# Instead of the CHICAGO_PRODUCT flag, we just
# use USE_MAPSYM so BINPLACE works.  (I think.)
#

#USE_MAPSYM=1

#
# Default target path. Can be overridden after include.
#

TARGET_PATH=$(DSLIBRARY)\chicago
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\oleds2.0\win95\charset.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    charset.h

Abstract:

    Contains prototypes Unicode <-> Ansi/MBCS conversions (see charset.c)

Author:

    Danilo Almeida  (t-danal)  06-17-96

Revision History:

--*/

#include <windows.h>
#include <malloc.h>

//
// Memory allocation macros
//

#define                                                      \
AllocMem(                                                    \
    Size,                                                    \
    pBuffer                                                  \
    )                                                        \
(                                                            \
    (*pBuffer = (LPBYTE)malloc((size_t)Size)) == NULL        \
    ?                                                        \
    ERROR_NOT_ENOUGH_MEMORY                                  \
    :                                                        \
    NO_ERROR                                                 \
);

#define                                                      \
FreeMem(                                                     \
    Buffer                                                   \
    )                                                        \
(                                                            \
    free((void *)Buffer)                                     \
);


// Function prototypes

UINT
AllocAnsi(
    LPCWSTR pwszUnicode,
    LPSTR *ppszAnsi
    );

VOID
FreeAnsi(
    LPSTR pszAnsi
    );

UINT
AllocUnicode(
    LPCSTR pszAnsi,
    LPWSTR *ppwszUnicode
    );

int
AllocUnicode2(
    LPCSTR pszAnsi,
    int cch,
    LPWSTR *ppwszUnicode
    );

VOID
FreeUnicode(
    LPWSTR pwszUnicodeAllocated
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\oleds2.0\win95\nexus.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    nexus.h

Abstract:

    Contains some thunking for Net APIs

Author:

    Danilo Almeida  (t-danal)  06-27-96

Revision History:

--*/

#ifndef __OLEDS_NEXUS__
#define __OLEDS_NEXUS__

#include <windows.h>
#include <lm.h>

#ifdef __cplusplus
extern "C" {
#endif

NET_API_STATUS NET_API_FUNCTION
NetGetDCNameW (
    LPCWSTR servername,
    LPCWSTR domainname,
    LPBYTE *bufptr
);

NET_API_STATUS NET_API_FUNCTION
NetServerEnumW(
    LPCWSTR  ServerName,
    DWORD    Level,
    LPBYTE * BufPtr,
    DWORD    PrefMaxLen,
    LPDWORD  EntriesRead,
    LPDWORD  TotalEntries,
    DWORD    ServerType,
    LPCWSTR  Domain,
    LPDWORD  ResumeHandle
);

#ifdef __cplusplus
}
#endif

#endif // __OLEDS_NEXUS__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\oleds2.0\win95\nexus.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    nexus.h

Abstract:

    Contains some thunking for Net APIs

Author:

    Danilo Almeida  (t-danal)  06-27-96

Revision History:

--*/

#include "nexus.h"

NET_API_STATUS NET_API_FUNCTION
NetGetDCName (
    LPCWSTR servername,
    LPCWSTR domainname,
    LPBYTE *bufptr
)
{
    return NetGetDCNameW(servername,
                         domainname,
                         bufptr);
}

NET_API_STATUS NET_API_FUNCTION
NetServerEnum(
    LPCWSTR   ServerName,
    DWORD    Level,
    LPBYTE * BufPtr,
    DWORD    PrefMaxLen,
    LPDWORD  EntriesRead,
    LPDWORD  TotalEntries,
    DWORD    ServerType,
    LPCWSTR   Domain,
    LPDWORD  ResumeHandle
)
{
    return NetServerEnumW(ServerName, 
                          Level, 
                          BufPtr, 
                          PrefMaxLen, 
                          EntriesRead, 
                          TotalEntries, 
                          ServerType, 
                          Domain, 
                          ResumeHandle);
}

NET_API_STATUS NET_API_FUNCTION
NetUserChangePassword(
    LPCWSTR domainname,  // pointer to server or domain name string
    LPCWSTR username,    // pointer to user name string
    LPCWSTR oldpassword, // pointer to old password string
    LPCWSTR newpassword  // pointer to new password string
)
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}
/*
HANDLE WINAPI
AddPrinterW(
    LPWSTR pName,      // pointer to server name 
    DWORD Level,       // printer info. structure level  
    LPBYTE pPrinter    // pointer to structure 
)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return NULL;
}
BOOL WINAPI
SetJobW(
    HANDLE hPrinter,    // handle of printer object 
    DWORD JobId,        // job-identification value 
    DWORD Level,        // structure level 
    LPBYTE  Job,        // address of job info structures  
    DWORD Command       // job-command value 
)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

BOOL WINAPI
EnumPrintersW(
    DWORD Flags,        // types of printer objects to enumerate 
    LPTSTR Name,        // name of printer object 
    DWORD Level,        // specifies type of printer info structure 
    LPBYTE pPrinterEnum,// points to buffer to receive printer info structures 
    DWORD cbBuf,        // size, in bytes, of array 
    LPDWORD pcbNeeded,  // points to num of bytes copied or required
    LPDWORD pcReturned  // points to num of printer info. structures copied 
)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\oleds2.0\win95\charset.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    charset.c

Abstract:

    Contains some functions to do Unicode <-> Ansi/MBCS convertsions.

Author:

    Danilo Almeida  (t-danal)  06-17-96

Revision History:

--*/


//
// INCLUDES
//

#include <string.h>
#include "charset.h"

/*
 *  AnsiBytesFromUnicode
 *
 *  Description:
 *      Given a Unicode string, returns number of bytes needed for Ansi version
 *
 *  In:
 *      pwszUnicode - pointer to Unicode string
 */

int
AnsiBytesFromUnicode(
    LPCWSTR pwszUnicode
    )
{
    return WideCharToMultiByte(CP_ACP,
                               0,
                               pwszUnicode,
                               -1,
                               NULL,
                               0,
                               NULL,
                               NULL);
}


/*
 *  AllocAnsi
 *
 *  Description:
 *      Given a Unicode string, allocate a new Ansi translation of that string
 *
 *  In:
 *      pwszUnicode - pointer to original Unicode string
 *      ppszAnsi    - pointer to cell to hold new MCBS string addr
 *
 *  Out:
 *      ppszAnsi    - contains new MBCS string
 *
 *  Returns:
 *      Error code or 0 if successful.
 *
 *  Notes:
 *      The client must free the allocated string with FreeAnsi.
 */

UINT
AllocAnsi(
    LPCWSTR pwszUnicode,
    LPSTR* ppszAnsi
    )
{
    UINT     err;
    BYTE *   pbAlloc;
    INT      cbUnicode;
    INT      cbAnsi;

    if (pwszUnicode == NULL)
    {
        *ppszAnsi = NULL;
        return 0;
    }

    cbAnsi = AnsiBytesFromUnicode(pwszUnicode);
    err = AllocMem(cbAnsi, &pbAlloc);
    if (err)
        return err;

    cbUnicode = wcslen(pwszUnicode)+1;

    *ppszAnsi = (LPSTR)pbAlloc;

    err = (UINT) !WideCharToMultiByte(CP_ACP,
                                      0,
                                      pwszUnicode,
                                      cbUnicode,
                                      *ppszAnsi,
                                      cbAnsi,
                                      NULL,
                                      NULL);
    if (err)
    {
        *ppszAnsi = NULL;
        FreeMem(pbAlloc);
        return ( (UINT)GetLastError() );
    }

    return 0;
}


/*
 *  FreeAnsi
 *
 *  Description:
 *      Deallocates an Ansi string allocated by AllocAnsi
 *
 *  In:
 *      pszAnsi - pointer to the Ansi string
 *
 *  Out:
 *      pszAnsi - invalid pointer - string has been freed
 */

VOID
FreeAnsi(LPSTR pszAnsi)
{
    if (pszAnsi != NULL)
        FreeMem((LPBYTE)pszAnsi);
}

/*
 *  AllocUnicode
 *
 *  Description:
 *      Given an Ansi string, allocates an Unicode version of that string
 *
 *  In:
 *      pszAnsi         - pointer to original MBCS string
 *      ppwszUnicode    - pointer to new Unicode string address
 *
 *  Out:
 *      ppwszUnicode    - points to new Unicode string
 *
 *  Returns:
 *      Error code or 0 if successful.
 *
 *  Notes:
 *      The client must free the allocated string with FreeUnicode.
 */

UINT
AllocUnicode(
    LPCSTR   pszAnsi,
    LPWSTR * ppwszUnicode )
{
    UINT     err;
    BYTE *   pbAlloc;
    INT      cbAnsi;

    if (pszAnsi == NULL)
    {
        *ppwszUnicode = NULL;
        return 0;
    }

    // Allocate space for Unicode string (may be a little extra if MBCS)

    cbAnsi = strlen(pszAnsi)+1;
    err = AllocMem(sizeof(WCHAR) * cbAnsi, &pbAlloc);
    if (err)
        return err;

    *ppwszUnicode = (LPWSTR)pbAlloc;

    err = (UINT) !MultiByteToWideChar(CP_ACP,
                                      MB_PRECOMPOSED,
                                      pszAnsi,
                                      cbAnsi,
                                      *ppwszUnicode,
                                      cbAnsi);
    if (err)
    {
        *ppwszUnicode = NULL;
        FreeMem(pbAlloc);
        return ( (UINT)GetLastError() );
    }

    return 0;
}

/*
 *  AllocUnicode2
 *
 *  Description:
 *      Given a MBCS string, allocates a new Unicode version of that string
 *
 *  In:
 *      pszAnsi         - pointer to original MBCS string
 *      cbAnsi          - number of bytes to convert
 *      ppwszUnicode    - pointer to where to return new Unicode string address
 *
 *  Out:
 *      ppwszUnicode    - contains new Unicode string
 *
 *  Returns:
 *      Returns number of characters written.
 *
 *  Notes:
 *      The client must free the allocated string with FreeUnicode.
 */

int
AllocUnicode2(
    LPCSTR   pszAnsi,
    int      cbAnsi,
    LPWSTR * ppwszUnicode)
{
    UINT     err;
    BYTE *   pbAlloc;
    INT      cwch;

    *ppwszUnicode = NULL;
    SetLastError(ERROR_SUCCESS);

    if (cbAnsi == 0)
        return 0;

    err = AllocMem(sizeof(WCHAR) * cbAnsi, &pbAlloc);
    if (err)
    {
        SetLastError(err);
        return 0;
    }

    *ppwszUnicode = (LPWSTR)pbAlloc;

    cwch = MultiByteToWideChar(CP_ACP,
                               MB_PRECOMPOSED,
                               pszAnsi,
                               cbAnsi,
                               *ppwszUnicode,
                               cbAnsi);

    if (cwch == 0)
    {
        *ppwszUnicode = NULL;
        FreeMem(pbAlloc);
    }

    return cwch;
}

/*
 *  FreeUnicode
 *
 *  Description:
 *      Deallocates a Unicode string allocatedd by AllocUnicode/AllocUnicode2
 *
 *  In:
 *      pwszUnicode - pointer to the Unicode string
 *
 *  Out:
 *      pwszUnicode - invalid pointer - string has been freed
 */

VOID
FreeUnicode( LPWSTR pwszUnicode )
{
    if (pwszUnicode != NULL)
        FreeMem((LPBYTE)pwszUnicode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\oleds2.0\win95\win95api.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    win95api.h

Abstract:

    Contains some thunking for Unicode KERNEL32 and USER32 APIs

Author:

    Danilo Almeida  (t-danal)  07-01-96

Revision History:

--*/

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _WINBASE_
#ifndef __WIN95BASE__
#define __WIN95BASE__

// KERNEL32.DLL

#define GetProfileIntW                  Win95GetProfileIntW
#define CreateSemaphoreW                Win95CreateSemaphoreW
#define LoadLibraryW                    Win95LoadLibraryW
#define SystemTimeToTzSpecificLocalTime Win95SystemTimeToTzSpecificLocalTime

UINT
WINAPI
GetProfileIntW(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    INT nDefault
    );

HANDLE
WINAPI
CreateSemaphoreW(
    LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
    LONG lInitialCount,
    LONG lMaximumCount,
    LPCWSTR lpName
    );

HMODULE
WINAPI
LoadLibraryW(
    LPCWSTR lpLibFileName
    );

BOOL
WINAPI
SystemTimeToTzSpecificLocalTime(
    LPTIME_ZONE_INFORMATION lpTimeZoneInformation,
    LPSYSTEMTIME lpUniversalTime,
    LPSYSTEMTIME lpLocalTime
    );

#endif // __WIN95BASE__
#endif // _WINBASE_ (KERNEL32.DLL)


// USER32.DLL

#ifdef _WINUSER_
#ifndef __WIN95USER__
#define __WIN95USER__

#define wvsprintfW                      Win95wvsprintfW
#define wsprintfW                       Win95wsprintfW

int
WINAPI
wvsprintfW(
    LPWSTR lpOut,
    LPCWSTR lpFmt,
    va_list arglist);

int
WINAPIV
wsprintfW(
    LPWSTR lpOut,
    LPCWSTR lpFmt,
    ...);

#endif // __WIN95USER__
#endif // _WINUSER_ (USER32.DLL)

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\oleds2.0\win95\win95api.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    win95api.c

Abstract:

    Contains some thunking for Unicode KERNEL32 and USER32 APIs

Author:

    Danilo Almeida  (t-danal)  01-Jul-1996

Revision History:

--*/

#include <windows.h>
#include "charset.h"
#include "win95api.h"

UINT
WINAPI
GetProfileIntW(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    INT nDefault
)
{
    LPSTR alpAppName;
    LPSTR alpKeyName;
    UINT err;

    err = AllocAnsi(lpAppName, &alpAppName);
    if (err)
        return nDefault;
    err = AllocAnsi(lpKeyName, &alpKeyName);
    if (err) {
        FreeAnsi(alpAppName);
        return nDefault;
    }
    err = GetProfileIntA((LPCSTR)alpAppName, (LPCSTR)alpKeyName, nDefault);
    FreeAnsi(alpAppName);
    FreeAnsi(alpKeyName);
    return err;
}

HANDLE
WINAPI
CreateSemaphoreW(
    LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
    LONG lInitialCount,
    LONG lMaximumCount,
    LPCWSTR lpName
)
{
    LPSTR alpName;
    UINT err;
    HANDLE hSemaphore;

    err = AllocAnsi(lpName, &alpName);
    if (err) {
        SetLastError(err);
        return NULL;
    }
    hSemaphore = CreateSemaphoreA(lpSemaphoreAttributes,
                                  lInitialCount,
                                  lMaximumCount,
                                  alpName);
    FreeAnsi(alpName);
    return hSemaphore;
}

HMODULE
WINAPI
LoadLibraryW(
    LPCWSTR lpLibFileName
)
{
    LPSTR alpLibFileName;
    UINT err;
    HMODULE hLibrary;

    err = AllocAnsi(lpLibFileName, &alpLibFileName);
    if (err) {
        SetLastError(err);
        return NULL;
    }
    hLibrary = LoadLibraryA(alpLibFileName);
    FreeAnsi(alpLibFileName);
    return hLibrary;
}

BOOL
WINAPI
SystemTimeToTzSpecificLocalTime(
    LPTIME_ZONE_INFORMATION lpTimeZoneInformation,
    LPSYSTEMTIME lpUniversalTime,
    LPSYSTEMTIME lpLocalTime
)
{
    FILETIME UniversalFileTime;
    FILETIME LocalFileTime;
    if (!SystemTimeToFileTime(lpUniversalTime, &UniversalFileTime))
        return FALSE;
    if(!FileTimeToLocalFileTime(&UniversalFileTime, &LocalFileTime))
        return FALSE;
    if(!FileTimeToSystemTime(&LocalFileTime, lpLocalTime))
        return FALSE;
    return TRUE;
}

/****************************** Module Header ******************************\
* Module Name: wsprintf.c
*
* Copyright (c) 1985-91, Microsoft Corporation
*  sprintf.c
*
*  Implements Windows friendly versions of sprintf and vsprintf
*
*  History:
*   2-15-89  craigc     Initial
*  11-12-90  MikeHar    Ported from windows 3
\***************************************************************************/

/* Max number of characters. Doesn't include termination character */
#define WSPRINTF_LIMIT 1024

#define out(c) if (cchLimit) {*lpOut++=(c); cchLimit--;} else goto errorout


/***************************************************************************\
* SP_GetFmtValueW
*
*  reads a width or precision value from the format string
*
* History:
*  11-12-90  MikeHar    Ported from windows 3
*  07-27-92  GregoryW   Created Unicode version (copied from SP_GetFmtValue)
\***************************************************************************/

LPCWSTR SP_GetFmtValueW(
    LPCWSTR lpch,
    int *lpw)
{
    int ii = 0;

    /* It might not work for some locales or digit sets */
    while (*lpch >= L'0' && *lpch <= L'9') {
        ii *= 10;
        ii += (int)(*lpch - L'0');
        lpch++;
    }

    *lpw = ii;

    /*
     * return the address of the first non-digit character
     */
    return lpch;
}

/***************************************************************************\
* SP_PutNumberW
*
* Takes an unsigned long integer and places it into a buffer, respecting
* a buffer limit, a radix, and a case select (upper or lower, for hex).
*
*
* History:
*  11-12-90  MikeHar    Ported from windows 3 asm --> C
*  12-11-90  GregoryW   need to increment lpstr after assignment of mod
*  02-11-92  GregoryW   temporary version until we have C runtime support
\***************************************************************************/

int SP_PutNumberW(
    LPWSTR lpstr,
    DWORD n,
    int   limit,
    DWORD radix,
    int   uppercase)
{
    DWORD mod;
    int count = 0;

    /* It might not work for some locales or digit sets */
    if(uppercase)
        uppercase =  'A'-'0'-10;
    else
        uppercase = 'a'-'0'-10;

    if (count < limit) {
        do  {
            mod =  n % radix;
            n /= radix;

            mod += '0';
            if (mod > '9')
            mod += uppercase;
            *lpstr++ = (WCHAR)mod;
            count++;
        } while((count < limit) && n);
    }

    return count;
}

/***************************************************************************\
* SP_ReverseW
*
*  reverses a string in place
*
* History:
*  11-12-90  MikeHar    Ported from windows 3 asm --> C
*  12-11-90  GregoryW   fixed boundary conditions; removed count
*  02-11-92  GregoryW   temporary version until we have C runtime support
\***************************************************************************/

void SP_ReverseW(
    LPWSTR lpFirst,
    LPWSTR lpLast)
{
    WCHAR ch;

    while(lpLast > lpFirst){
        ch = *lpFirst;
        *lpFirst++ = *lpLast;
        *lpLast-- = ch;
    }
}


/***************************************************************************\
* wvsprintfW (API)
*
* wsprintfW() calls this function.
*
* History:
*    11-Feb-1992 GregoryW copied xwvsprintf
*         Temporary hack until we have C runtime support
\***************************************************************************/

int WINAPI wvsprintfW(
    LPWSTR lpOut,
    LPCWSTR lpFmt,
    va_list arglist)
{
    BOOL fAllocateMem;
    WCHAR prefix, fillch;
    int left, width, prec, size, sign, radix, upper, hprefix;
    int cchLimit = WSPRINTF_LIMIT, cch;
    LPWSTR lpT, lpTWC;
    LPBYTE psz;
    va_list varglist = arglist;
    union {
        long l;
        unsigned long ul;
        char sz[2];
        WCHAR wsz[2];
    } val;

    while (*lpFmt != 0) {
        if (*lpFmt == L'%') {

            /*
             * read the flags.  These can be in any order
             */
            left = 0;
            prefix = 0;
            while (*++lpFmt) {
                if (*lpFmt == L'-')
                    left++;
                else if (*lpFmt == L'#')
                    prefix++;
                else
                    break;
            }

            /*
             * find fill character
             */
            if (*lpFmt == L'0') {
                fillch = L'0';
                lpFmt++;
            } else
                fillch = L' ';

            /*
             * read the width specification
             */
            lpFmt = SP_GetFmtValueW(lpFmt, &cch);
            width = cch;

            /*
             * read the precision
             */
            if (*lpFmt == L'.') {
                lpFmt = SP_GetFmtValueW(++lpFmt, &cch);
                prec = cch;
            } else
                prec = -1;

            /*
             * get the operand size
             * default size: size == 0
             * long number:  size == 1
             * wide chars:   size == 2
             * It may be a good idea to check the value of size when it
             * is tested for non-zero below (IanJa)
             */
            hprefix = 0;
            if ((*lpFmt == L'w') || (*lpFmt == L't')) {
                size = 2;
                lpFmt++;
            } else if (*lpFmt == L'l') {
                size = 1;
                lpFmt++;
            } else {
                size = 0;
                if (*lpFmt == L'h') {
                    lpFmt++;
                    hprefix = 1;
                }
            }

            upper = 0;
            sign = 0;
            radix = 10;

            switch (*lpFmt) {
            case 0:
                goto errorout;

            case L'i':
            case L'd':
                size=1;
                sign++;

                /*** FALL THROUGH to case 'u' ***/

            case L'u':
                /* turn off prefix if decimal */
                prefix = 0;
donumeric:
                /* special cases to act like MSC v5.10 */
                if (left || prec >= 0)
                    fillch = L' ';

                /*
                 * if size == 1, "%lu" was specified (good);
                 * if size == 2, "%wu" was specified (bad)
                 */
                if (size) {
                    val.l = va_arg(varglist, LONG);
                } else if (sign) {
                    val.l = va_arg(varglist, SHORT);
                } else {
                    val.ul = va_arg(varglist, unsigned);
                }

                if (sign && val.l < 0L)
                    val.l = -val.l;
                else
                    sign = 0;

                lpT = lpOut;

                /*
                 * blast the number backwards into the user buffer
                 */
                cch = SP_PutNumberW(lpOut, val.l, cchLimit, radix, upper);
                if (!(cchLimit -= cch))
                    goto errorout;

                lpOut += cch;
                width -= cch;
                prec -= cch;
                if (prec > 0)
                    width -= prec;

                /*
                 * fill to the field precision
                 */
                while (prec-- > 0)
                    out(L'0');

                if (width > 0 && !left) {
                    /*
                     * if we're filling with spaces, put sign first
                     */
                    if (fillch != L'0') {
                        if (sign) {
                            sign = 0;
                            out(L'-');
                            width--;
                        }

                        if (prefix) {
                            out(prefix);
                            out(L'0');
                            prefix = 0;
                        }
                    }

                    if (sign)
                        width--;

                    /*
                     * fill to the field width
                     */
                    while (width-- > 0)
                        out(fillch);

                    /*
                     * still have a sign?
                     */
                    if (sign)
                        out(L'-');

                    if (prefix) {
                        out(prefix);
                        out(L'0');
                    }

                    /*
                     * now reverse the string in place
                     */
                    SP_ReverseW(lpT, lpOut - 1);
                } else {
                    /*
                     * add the sign character
                     */
                    if (sign) {
                        out(L'-');
                        width--;
                    }

                    if (prefix) {
                        out(prefix);
                        out(L'0');
                    }

                    /*
                     * reverse the string in place
                     */
                    SP_ReverseW(lpT, lpOut - 1);

                    /*
                     * pad to the right of the string in case left aligned
                     */
                    while (width-- > 0)
                        out(fillch);
                }
                break;

            case L'X':
                upper++;

                /*** FALL THROUGH to case 'x' ***/

            case L'x':
                radix = 16;
                if (prefix)
                    if (upper)
                        prefix = L'X';
                    else
                        prefix = L'x';
                goto donumeric;

            case L'c':
                if (!size && !hprefix) {
                    size = 1;           // force WCHAR
                }

                /*** FALL THROUGH to case 'C' ***/

            case L'C':
                /*
                 * if size == 0, "%C" or "%hc" was specified (CHAR);
                 * if size == 1, "%c" or "%lc" was specified (WCHAR);
                 * if size == 2, "%wc" or "%tc" was specified (WCHAR)
                 */
                cch = 1; /* One character must be copied to the output buffer */
                if (size) {
                    val.wsz[0] = va_arg(varglist, WCHAR);
                    val.wsz[1] = 0;
                    lpT = val.wsz;
                    goto putwstring;
                } else {
                    val.sz[0] = va_arg(varglist, CHAR);
                    val.sz[1] = 0;
                    psz = val.sz;
                    goto putstring;
                }

            case L's':
                if (!size && !hprefix) {
                    size = 1;           // force LPWSTR
                }

                /*** FALL THROUGH to case 'S' ***/

            case L'S':
                /*
                 * if size == 0, "%S" or "%hs" was specified (LPSTR)
                 * if size == 1, "%s" or "%ls" was specified (LPWSTR);
                 * if size == 2, "%ws" or "%ts" was specified (LPWSTR)
                 */
                if (size) {
                    lpT = va_arg(varglist, LPWSTR);
                    cch = wcslen(lpT);
putwstring:
                    fAllocateMem = FALSE;
                } else {
                    psz = va_arg(varglist, LPBYTE);
                    cch = strlen(psz);
putstring:
                    cch = AllocUnicode2(psz, cch, &lpTWC);
                    fAllocateMem = (BOOL) cch;
                    lpT = lpTWC;
                }

                if (prec >= 0 && cch > prec)
                    cch = prec;
                width -= cch;

                if (fAllocateMem) {
                    if (cch + (width < 0 ? 0 : width) >= cchLimit) {
                        FreeUnicode(lpTWC);
                        goto errorout;
                    }
                }

                if (left) {
                    while (cch--)
                        out(*lpT++);
                    while (width-- > 0)
                        out(fillch);
                } else {
                    while (width-- > 0)
                        out(fillch);
                    while (cch--)
                        out(*lpT++);
                }

                if (fAllocateMem) {
                     FreeUnicode(lpTWC);
                }

                break;

            default:
normalch:
                out((WCHAR)*lpFmt);
                break;
            }  /* END OF SWITCH(*lpFmt) */
        }  /* END OF IF(%) */ else
            goto normalch;  /* character not a '%', just do it */

        /*
         * advance to next format string character
         */
        lpFmt++;
    }  /* END OF OUTER WHILE LOOP */

errorout:
    *lpOut = 0;

    return WSPRINTF_LIMIT - cchLimit;
}

int WINAPIV wsprintfW(
    LPWSTR lpOut,
    LPCWSTR lpFmt,
    ...)
{
    va_list arglist;
    int ret;

    va_start(arglist, lpFmt);
    ret = wvsprintfW(lpOut, lpFmt, arglist);
    va_end(arglist);
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\tests\qstest\makefile.inc ===
#
# Supplemental rules for generating Type library.
#
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\oleds2.0\win95\win95reg.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    win95reg.c

Abstract:

    Contains some thunking for Unicode Registry APIs (Local Calls only)

Author:

    Danilo Almeida  (t-danal)  07-01-96

Revision History:

--*/

#include <windows.h>
#include "charset.h"
#include "win95reg.h"
#include <stdlib.h>

#define IsRegString(x) \
              ((x == REG_SZ) || (x == REG_EXPAND_SZ) || (x == REG_MULTI_SZ))

DWORD
RegStringConvert(
    DWORD Type, 
    LPCSTR pszAnsi, 
    LPWSTR *ppszWide,
    LPDWORD lpcbWide)
{
    int cbAnsi;
    int ccAnsi;
    int cb;
    int cc;
    LPWSTR pszWide;
    UINT err;

    if (!ppszWide)
        return ERROR_INVALID_PARAMETER;

    if (!lpcbWide)
        return ERROR_INVALID_PARAMETER;

    if (!pszAnsi)
    {
        *lpcbWide = 0;
        return ERROR_SUCCESS;
    }

    if (Type != REG_MULTI_SZ)
        cbAnsi = strlen(pszAnsi) + 1;
    else
    {
        cbAnsi = 0;
        do {
            cb = strlen(pszAnsi+cbAnsi) + 1;
            cbAnsi += cb;
        } while (*pszAnsi);
    }

    err = AllocMem(cbAnsi * sizeof(WCHAR), (LPBYTE *) ppszWide);
    if (err)
        return err;
    pszWide = *ppszWide;

    *lpcbWide = sizeof(WCHAR) *
                MultiByteToWideChar(CP_ACP,
                               MB_PRECOMPOSED,
                               pszAnsi,
                               cbAnsi,
                               pszWide,
                               cbAnsi * sizeof(WCHAR));
    if (*lpcbWide == 0)
    {
        if (pszWide)
            FreeMem(pszWide);
        return GetLastError();
    }
    return ERROR_SUCCESS;
}

DWORD
RegEnumKeyExUnicodeString(
    HKEY hKey,
    DWORD dwIndex,
    LPDWORD lpReserved,
    LPBYTE *pNameBuf,
    LPDWORD lpcbName,
    LPBYTE *pClassBuf,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime
    )
{
    LONG result;
    UINT err;

    LPBYTE NameBuf;
    LPBYTE ClassBuf = NULL;

    DWORD cbName;
    DWORD cbClass;

    if (!lpcbName)
        return ERROR_INVALID_PARAMETER;

    cbName = (*lpcbName)++;
    err = AllocMem(cbName + 1, &NameBuf);
    if (err)
        return err;

    if (lpcbClass)
    {
        cbClass = (*lpcbClass)++;
        err = AllocMem(cbClass + 1, &ClassBuf);
        if (err)
        {
            FreeMem(NameBuf);
            return err;
        }
    }

    result = RegEnumKeyExA(
                  hKey,
                  dwIndex,
                  NameBuf,
                  lpcbName,
                  lpReserved,
                  ClassBuf,
                  lpcbClass,
                  lpftLastWriteTime
                  );

    if (result == ERROR_MORE_DATA ||
        cbName != *lpcbName ||
        (lpcbClass && cbClass != *lpcbClass))
        result = ERROR_INVALID_DATA;
    else if (result == ERROR_SUCCESS)
    {
        result = RegStringConvert(
            REG_SZ, 
            (LPCSTR)NameBuf, 
            (LPWSTR *)pNameBuf, 
            lpcbName
            );
        if (result != ERROR_SUCCESS)
            goto cleanup;
        if (lpcbClass)
            result = RegStringConvert(
                REG_SZ, 
                (LPCSTR)ClassBuf, 
                (LPWSTR *)pClassBuf, 
                lpcbClass
                );
        if (result != ERROR_SUCCESS)
            goto cleanup;

        // Want number of chars, not bytes, subtracting out the NULL
        *lpcbName /= sizeof(WCHAR);
        *lpcbName--;
        if (lpcbClass) {
            *lpcbClass /= sizeof(WCHAR);
            *lpcbClass--;
        }
    }

cleanup:
    if (ClassBuf)
        FreeMem(ClassBuf);
    FreeMem(NameBuf);
    return result;
}

DWORD
RegQueryValueExUnicodeString(
    HKEY hKey,
    LPCSTR lpValueNameA,
    LPDWORD lpReserved,
    DWORD TypeReq,
    LPDWORD lpcbData,
    LPBYTE *pBuffer
    )
{
    LONG result;
    UINT err;

    LPBYTE Buffer;

    DWORD Type;
    DWORD cbData;

    err = AllocMem(*lpcbData, &Buffer);
    if (err)
        return err;

    cbData = *lpcbData;
    result = RegQueryValueExA(
                  hKey,
                  lpValueNameA,
                  lpReserved,
                  &Type,
                  Buffer,
                  &cbData
                  );

    if (result == ERROR_MORE_DATA ||
        (result == ERROR_SUCCESS && (Type != TypeReq ||
                                     cbData != *lpcbData)))
        result = ERROR_INVALID_DATA;
    else if (result == ERROR_SUCCESS)
        result = RegStringConvert(
            Type, 
            (LPCSTR)Buffer, 
            (LPWSTR *)pBuffer, 
            lpcbData
            );

    FreeMem(Buffer);
    return result;
}

LONG
APIENTRY
RegOpenKeyExW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD ulOptions,
    REGSAM samDesired,
    PHKEY phkResult
    )
{
    LPSTR lpSubKeyA;
    LONG result;
    UINT err;

    err = AllocAnsi(lpSubKey, &lpSubKeyA);
    if (err)
        return (LONG) err;
    result = RegOpenKeyExA(
                 hKey, 
                 lpSubKeyA, 
                 ulOptions, 
                 samDesired, 
                 phkResult
                 );
    FreeAnsi(lpSubKeyA);
    return result;
}


LONG
APIENTRY
RegQueryValueExW (
    HKEY hKey,
    LPCWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    )
{
    LPSTR lpValueNameA = NULL;
    LONG result;
    UINT err;

    DWORD Type;
    DWORD ccWide;
    DWORD cbData = *lpcbData;
    LPBYTE Buffer = NULL;

    if (lpData && !lpcbData)
        return ERROR_INVALID_PARAMETER;

    err = AllocAnsi(lpValueName, &lpValueNameA);
    if (err)
        return err;

    result = RegQueryValueExA(
                 hKey,
                 lpValueNameA,
                 lpReserved,
                 &Type,
                 lpData,
                 lpcbData
                 );

    if (lpType)
        *lpType = Type;

    if (result != ERROR_SUCCESS && 
        result != ERROR_MORE_DATA)    // Did the call err?
        goto cleanup;

    if (!IsRegString(Type))    // Do we have a string?
        goto cleanup;
    if (!lpData && !lpcbData)  // If both are NULL, no extra work
        goto cleanup;

    result = RegQueryValueExUnicodeString(
                              hKey, 
                              lpValueNameA, 
                              lpReserved, 
                              Type, 
                              lpcbData, 
                              &Buffer
                              );

    if (result == ERROR_SUCCESS)
    {
        if (cbData < *lpcbData)
            result = ERROR_MORE_DATA;
        else
            CopyMemory(lpData, Buffer, *lpcbData);
    }

cleanup:
    if (lpValueNameA != NULL)
         FreeAnsi(lpValueNameA);
    if (Buffer != NULL)
         FreeMem(Buffer);
    return result;
}
                                         
LONG
APIENTRY
RegSetValueExW (
    HKEY hKey,
    LPCWSTR lpValueName,
    DWORD Reserved,
    DWORD dwType,
    CONST BYTE* lpData,
    DWORD cbData
    )
{
    LPSTR lpValueNameA;
    LONG result;
    UINT err;
    LPSTR lpDataA = NULL;

    err = AllocAnsi(lpValueName, &lpValueNameA);
    if (err)
        return (LONG) err;
    if (IsRegString(dwType)) {
        AllocAnsi((LPWSTR)lpData, &lpDataA);
        lpData = (CONST BYTE *)lpDataA;
    }
    result = RegSetValueExA(
                 hKey,
                 lpValueNameA,
                 Reserved,
                 dwType,
                 lpData,
                 cbData
                 );
    FreeAnsi(lpValueNameA);
    if (lpDataA)
        FreeAnsi(lpDataA);
    return result;
}

LONG
APIENTRY
RegEnumKeyExW (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime
    )
{
    LONG result;
    UINT err;

    DWORD cbName;
    DWORD cbClass;

    LPBYTE NameBuf = NULL;
    LPBYTE ClassBuf = NULL;

    if (lpcbName)
        cbName = *lpcbName;
    else
        return ERROR_INVALID_PARAMETER;

    if (lpcbClass)
        cbClass = *lpcbClass;

    result = RegEnumKeyExA(
                 hKey,
                 dwIndex,
                 (LPSTR)lpName,
                 lpcbName,
                 lpReserved,
                 (LPSTR)lpClass,
                 lpcbClass,
                 lpftLastWriteTime
                 );

    if (result != ERROR_SUCCESS && result != ERROR_MORE_DATA)
        return result;

    result = RegEnumKeyExUnicodeString(
                 hKey,
                 dwIndex,
                 lpReserved,
                 &NameBuf,
                 lpcbName,
                 &ClassBuf,
                 lpcbClass,
                 lpftLastWriteTime
                 );
    
    if (result == ERROR_SUCCESS)
    {
        if ((cbName < *lpcbName) ||
            (lpcbClass && (cbClass < *lpcbClass)))
            result = ERROR_MORE_DATA;
        else
        {
            CopyMemory(lpName, NameBuf, sizeof(WCHAR)*(*lpcbName+1));
            if (lpcbClass)
                CopyMemory(lpClass, ClassBuf, sizeof(WCHAR)*(*lpcbClass+1));
        }
    }

    if (NameBuf != NULL)
         FreeMem(NameBuf);
    if (ClassBuf != NULL)
         FreeMem(ClassBuf);
    return result;
}

LONG
APIENTRY
RegCreateKeyExW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD Reserved,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    )
{
    LPSTR lpSubKeyA;
    LPSTR lpClassA;
    LONG result;
    UINT err;

    err = AllocAnsi(lpSubKey, &lpSubKeyA);
    if (err)
        return (LONG) err;
    err = AllocAnsi(lpClass, &lpClassA);
    if (err) {
        FreeAnsi(lpSubKeyA);
        return (LONG) err;
    }
    result = RegCreateKeyExA(
                 hKey,
                 lpSubKeyA,
                 Reserved,
                 lpClassA,
                 dwOptions,
                 samDesired,
                 lpSecurityAttributes,
                 phkResult,
                 lpdwDisposition
                 );
    FreeAnsi(lpSubKeyA);
    FreeAnsi(lpClassA);
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\addcert.cpp ===
// AddCert.cpp : implementation file
//

#include "stdafx.h"
#include "certmap.h"

// persistence and mapping includes
#include "WrapMaps.h"
#include "wrapmb.h"

#include "ListRow.h"
#include "ChkLstCt.h"

// mapping page includes
#include "brwsdlg.h"
#include "EdtOne11.h"
#include "Ed11Maps.h"
#include "Map11Pge.h"

extern "C"
{
    #include <wincrypt.h>
    #include <schannel.h>
}

#include <iismap.hxx>
#include <iiscmr.hxx>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#define COL_NUM_NAME        0
#define COL_NUM_NTACCOUNT   1

#define CERT_HEADER         "-----BEGIN CERTIFICATE-----"



// the code that reads the certificate file is pretty much lifted from the
// keyring application. Which pretty much lifted it from the setkey application

// defines taken from the old KeyGen utility
#define MESSAGE_HEADER  "-----BEGIN NEW CERTIFICATE REQUEST-----\r\n"
#define MESSAGE_TRAILER "-----END NEW CERTIFICATE REQUEST-----\r\n"
#define MIME_TYPE       "Content-Type: application/x-pkcs10\r\n"
#define MIME_ENCODING   "Content-Transfer-Encoding: base64\r\n\r\n"

void uudecode_cert(char *bufcoded, DWORD *pcbDecoded );


//---------------------------------------------------------------------------
// originally from keyring - modified to fit
BOOL CMap11Page::FAddCertificateFile( CString szFile )
    {
    CFile       cfile;
    PVOID       pData = NULL;
    BOOL        fSuccess =FALSE;;

    // open the file
    if ( !cfile.Open( szFile, CFile::modeRead | CFile::shareDenyNone ) )
        return FALSE;

    // how big is the file - add one so we can zero terminate the buffer
    DWORD   cbCertificate = cfile.GetLength() + 1;

    // make sure the file has some size
    if ( !cbCertificate )
        {
        AfxMessageBox( IDS_ERR_INVALID_CERTIFICATE );
        return FALSE;
        }

    // put the rest of the operation in a try/catch
    try
        {
        PCCERT_CONTEXT pCertContext=NULL; //used to determine whether cert file is binary DER encoded
        // allocate space for the data
        pData = GlobalAlloc( GPTR, cbCertificate );
        if ( !pData ) AfxThrowMemoryException();

        // copy in the data from the file to the pointer - will throw and exception
        DWORD cbRead = cfile.Read( pData, cbCertificate );

        // zero terminate for decoding
        ((BYTE*)pData)[cbRead] = 0;

        // close the file
        cfile.Close();

        //certificate file may be either be binary DER file or BASE64 encoded file

        // try binary DER encoded first
        pCertContext= CertCreateCertificateContext(X509_ASN_ENCODING, (const BYTE *)pData, cbRead);
        if(pCertContext != NULL)
        {
                // we created certificate context only to verify that file is binary DER encoded
                // free it now
                CertFreeCertificateContext(pCertContext);
                pCertContext=NULL;
        }
        else    // now try BASE64 encoded
        {       
                // we don't care about header ----BEGIN CERTIFICATE----- or trailer-----END CERTIFICATE-----, 
				// uudecode will take care of that
                uudecode_cert( (PCHAR)pData, &cbRead );
        }
        // we now have a pointer to a certificate. Lets keep it clean looking
        // call another subroutine to finish the job.
        fSuccess = FAddCertificate( (PUCHAR)pData, cbRead );

    }catch( CException * pException )
        {
        pException->Delete();
        // return failure
        fSuccess = FALSE;

    // if the pointer was allocated, deallocate it
    if ( pData )
        {
        GlobalFree( pData );
        pData = NULL;
        }
    }

    // return success
    return fSuccess;
    }

    #define CERT_HEADER_LEN 17
    CHAR CertTag[ 13 ] = { 0x04, 0x0b, 'c', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e' };

//---------------------------------------------------------------------------
// we are passed in a complete certificate. We need to parse out the subject
// and the issuer fields so we can add the mapping. Then add the mapping.
#define CF_CERT_FROM_FILE 2
BOOL CMap11Page::FAddCertificate( PUCHAR pCertificate, DWORD cbCertificate )
    {
    BOOL    fSuccess = FALSE;

    // thankfully, the certificate is already in the correct format.
    // this means that, for now at least, we don't have to do anything
    // special to it to store it. However, we should crack it once just
    // to see that we can to prove that it is a valid cert.

    ASSERT( pCertificate );
    if ( !pCertificate ) return FALSE;

    // crack the certificate to prove that we can
    PX509Certificate    p509 = NULL;
    fSuccess = SslCrackCertificate( pCertificate, cbCertificate, CF_CERT_FROM_FILE, &p509 );
    if ( fSuccess )
        {
        SslFreeCertificate( p509 );
        }
    else
        {
        // we were not able to crack the certificate. Alert the user and fail
        AfxMessageBox( IDS_ERR_INVALID_CERTIFICATE );
        return FALSE;
        }

    // by this point we know we have a valid certificate, make the new mapping and fill it in
    // make the new mapping object
    C11Mapping* pMapping = PNewMapping();
    ASSERT( pMapping );
    if( !pMapping )
        {
        AfxThrowMemoryException();  // seems fairly appropriate
        return FALSE;
        }


    // one more thing before we add the certificate. Skip the header if it is there
    PUCHAR pCert = pCertificate;
    DWORD cbCert = cbCertificate;
    if ( memcmp( pCert + 4, CertTag, sizeof( CertTag ) ) == 0 )
    {
        pCert += CERT_HEADER_LEN;
        cbCert -= CERT_HEADER_LEN;
    }


    // install the certificate into the mapping
    fSuccess &= pMapping->SetCertificate( pCert, cbCert );

    // by default, the mapping is enabled
    fSuccess &= pMapping->SetMapEnabled( TRUE );

    // install a default name
    CString sz;
    
    sz.LoadString( IDS_DEFAULT_11MAP );

    fSuccess &= pMapping->SetMapName( sz );

    // install a blank mapping
    fSuccess &= pMapping->SetNTAccount( "" );

    if ( !fSuccess )
        AfxThrowMemoryException();  // seems fairly appropriate


    // now edit the newly created mapping object. If the user cancels,
    // then do not add it to the mapper object nor the list
    if ( !EditOneMapping( pMapping) )
        {
        DeleteMapping( pMapping );
        return FALSE;
        }

    // add the mapping item to the list control
    fSuccess = FAddMappingToList( pMapping );

    // one more test for success
    if ( !fSuccess )
        {
        DeleteMapping( pMapping );
        ASSERT( FALSE );
        }

    // mark the mapping to be saved
    if ( fSuccess )
        MarkToSave( pMapping );

    // return the answer
    return fSuccess;
    }


//      ==============================================================
//      The function  'uudecode_cert'  IS THE SAME function that is
//      found in file:  Addcert.cpp if we make the following code
//      have a FALSE for bAddWrapperAroundCert -- surely we can unify
//      these 2 functions.  Having 2 functions named 'uudecode_cert'
//      was causing me LINKING errors.  + we have 2 instances of
//      the external tables: uudecode_cert and pr2six
//
//      Since I am linking both Addcert.cpp and CKey.cpp I choose to
//      leave the defintions intact for CKey.cpp   [ and have extended
//      uudecode_cert by adding conditional code as shown below] Further
//      work needs to be done after identification as to why I need both
//      Addcert.cpp and CKey.cpp to pass bAddWrapperAroundCert as a
//      parameter so that both files can be supported.
//      ==============================================================
//  BOOL  bAddWrapperAroundCert = TRUE;
//  if (bAddWrapperAroundCert) {
//     //
//     //  Now we need to add a new wrapper sequence around the certificate
//     //  indicating this is a certificate
//     //
// 
//     memmove( beginbuf + sizeof(abCertHeader),
//              beginbuf,
//              nbytesdecoded );
// 
//     memcpy( beginbuf,
//             abCertHeader,
//             sizeof(abCertHeader) );
// 
//     //
//     //  The beginning record size is the total number of bytes decoded plus
//     //  the number of bytes in the certificate header
//     //
// 
//     beginbuf[CERT_SIZE_HIBYTE] = (BYTE) (((USHORT)nbytesdecoded+CERT_RECORD) >> 8);
//     beginbuf[CERT_SIZE_LOBYTE] = (BYTE) ((USHORT)nbytesdecoded+CERT_RECORD);
// 
//     nbytesdecoded += sizeof(abCertHeader);
//   }

// #ifdef WE_ARE_USING_THE_VERSION_IN__CKey_cpp__NOT_THIS_ONE__ITS_JUST_LIKE_THIS_ONE_WITH_1SMALL_CHANGE

//============================ BASED ON SETKEY
const int pr2six[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63,
    52,53,54,55,56,57,58,59,60,61,64,64,64,64,64,64,64,0,1,2,3,4,5,6,7,8,9,
    10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,64,26,27,
    28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

//
//  We have to squirt a record into the decoded stream
//

#define CERT_RECORD            13
#define CERT_SIZE_HIBYTE        2       //  Index into record of record size
#define CERT_SIZE_LOBYTE        3

unsigned char abCertHeader[] = {0x30, 0x82,           // Record
                                0x00, 0x00,           // Size of cert + buff
                                0x04, 0x0b, 0x63, 0x65,// Cert record data
                                0x72, 0x74, 0x69, 0x66,
                                0x69, 0x63, 0x61, 0x74,
                                0x65 };

void uudecode_cert(char *bufcoded, DWORD *pcbDecoded )
{
    int nbytesdecoded;
    char *bufin = bufcoded;
    unsigned char *bufout = (unsigned char *)bufcoded;
    unsigned char *pbuf;
    int nprbytes;
    char * beginbuf = bufcoded;

    ASSERT(bufcoded);
    ASSERT(pcbDecoded);

    /* Strip leading whitespace. */

    while(*bufcoded==' ' ||
          *bufcoded == '\t' ||
          *bufcoded == '\r' ||
          *bufcoded == '\n' )
    {
          bufcoded++;
    }

    //
    //  If there is a beginning '---- ....' then skip the first line
    //

    if ( bufcoded[0] == '-' && bufcoded[1] == '-' )
    {
        bufin = strchr( bufcoded, '\n' );

        if ( bufin )
        {
            bufin++;
            bufcoded = bufin;
        }
        else
        {
            bufin = bufcoded;
        }
    }
    else
    {
        bufin = bufcoded;
    }

    //
    //  Strip all cr/lf from the block
    //

    pbuf = (unsigned char *)bufin;
    while ( *pbuf )
    {
        if ( (*pbuf == ' ') || (*pbuf == '\r') || (*pbuf == '\n') )
        {
            memmove( (void*)pbuf, pbuf+1, strlen( (char*)pbuf + 1) + 1 );
        }
        else
        {
            pbuf++;
        }
    }

    /* Figure out how many characters are in the input buffer.
     * If this would decode into more bytes than would fit into
     * the output buffer, adjust the number of input bytes downwards.
     */

    while(pr2six[*(bufin++)] <= 63);
    nprbytes = DIFF(bufin - bufcoded) - 1;
    nbytesdecoded = ((nprbytes+3)/4) * 3;

    bufin  = bufcoded;

    while (nprbytes > 0) {
        *(bufout++) =
            (unsigned char) (pr2six[*bufin] << 2 | pr2six[bufin[1]] >> 4);
        *(bufout++) =
            (unsigned char) (pr2six[bufin[1]] << 4 | pr2six[bufin[2]] >> 2);
        *(bufout++) =
            (unsigned char) (pr2six[bufin[2]] << 6 | pr2six[bufin[3]]);
        bufin += 4;
        nprbytes -= 4;
    }

    if(nprbytes & 03) {
        if(pr2six[bufin[-2]] > 63)
            nbytesdecoded -= 2;
        else
            nbytesdecoded -= 1;
    }

    /*
    //
    //  Now we need to add a new wrapper sequence around the certificate
    //  indicating this is a certificate
    //

    memmove( beginbuf + sizeof(abCertHeader),
             beginbuf,
             nbytesdecoded );

    memcpy( beginbuf,
            abCertHeader,
            sizeof(abCertHeader) );

    //
    //  The beginning record size is the total number of bytes decoded plus
    //  the number of bytes in the certificate header
    //

    beginbuf[CERT_SIZE_HIBYTE] = (BYTE) (((USHORT)nbytesdecoded+CERT_RECORD) >> 8);
    beginbuf[CERT_SIZE_LOBYTE] = (BYTE) ((USHORT)nbytesdecoded+CERT_RECORD);

    nbytesdecoded += sizeof(abCertHeader);
*/

    if ( pcbDecoded )
        *pcbDecoded = nbytesdecoded;
}
// ============ END BASED ON SETKEY

//#endif /* WE_ARE_USING_THE_VERSION_IN__CKey_cpp__NOT_THIS_ONE__ITS_JUST_LIKE_THIS_ONE_WITH_1SMALL_CHANGE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\tests\qstest\main.cpp ===
/*===================================================================
Microsoft

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: qstest

File: main.cpp

Owner: brentmid

Note:
===================================================================*/

#include <stdio.h>
#include <objbase.h>
#include <atlbase.h>
#include <iads.h>
#include <adshlp.h>

DWORD QuerySMTPState() {

    HRESULT			hr = NOERROR;

    CComPtr<IADsServiceOperations>	pADsIisService;
    DWORD				dwState;

    // Get virtual server instance on metabase
    hr = ADsGetObject (L"IIS://localhost/smtpsvc/1", IID_IADsServiceOperations, (void**)&pADsIisService );
    if (FAILED(hr)) goto Exit;

    printf("Successful ADsGetObject...\n");

    // Get state
    hr = pADsIisService->get_Status ( (long*)&dwState );
 
    if (FAILED(hr)) goto Exit;

    printf("Successful get_Status...\n");

    Exit:
    
    return dwState;
}

int _cdecl main (int argc, char **argv)
{
	char s;
    DWORD status;

    CoInitialize(NULL);

	printf("Beginning qstest...\n");

    printf("Querying SMTP service state - 1st time...\n");

    status = QuerySMTPState();
    printf("Status = %x\n", status);

    printf("Stop/restart iisadmin, then hit enter...");
    scanf("%c",&s);
    
    printf("Querying SMTP service state - 2nd time...\n");

    status = QuerySMTPState();
    printf("Status = %x\n", status);

    CoUninitialize();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\oleds2.0\win95\win95reg.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    win95reg.h

Abstract:

    Contains some thunking for Unicode Registry APIs (Local Calls only)

Author:

    Danilo Almeida  (t-danal)  07-01-96

Revision History:

--*/

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _WINREG_
#ifndef __WIN95REG__
#define __WIN95REG__

#define RegOpenKeyExW     Win95RegOpenKeyExW
#define RegQueryValueExW  Win95RegQueryValueExW
#define RegSetValueExW    Win95RegSetValueExW
#define RegEnumKeyExW     Win95RegEnumKeyExW
#define RegCreateKeyExW   Win95RegCreateKeyExW

LONG
APIENTRY
RegOpenKeyExW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD ulOptions,
    REGSAM samDesired,
    PHKEY phkResult
    );

LONG
APIENTRY
RegQueryValueExW (
    HKEY hKey,
    LPCWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );

LONG
APIENTRY
RegSetValueExW (
    HKEY hKey,
    LPCWSTR lpValueName,
    DWORD Reserved,
    DWORD dwType,
    CONST BYTE* lpData,
    DWORD cbData
    );

LONG
APIENTRY
RegEnumKeyExW (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime
    );

LONG
APIENTRY
RegCreateKeyExW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD Reserved,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    );

#endif // __WIN95REG__
#endif // _WINREG_

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\amapctl.h ===
// AMapCtl.h : Declaration of the CAccountMapperCtrl OLE control class.

/////////////////////////////////////////////////////////////////////////////
// CAccountMapperCtrl : See AMapCtl.cpp for implementation.

class CAccountMapperCtrl : public COleControl
{
    DECLARE_DYNCREATE(CAccountMapperCtrl)

// Constructor
public:
    CAccountMapperCtrl();

// Overrides

    // Drawing function
    virtual void OnDraw(
                CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);

    // Persistence
    virtual void DoPropExchange(CPropExchange* pPX);

    // Reset control state
    virtual void OnResetState();

// Implementation
protected:
    // run the mapping dialog - the whole purpose of this control!
    void    RunMappingDialog();

    ~CAccountMapperCtrl();

    DECLARE_OLECREATE_EX(CAccountMapperCtrl)    // Class factory and guid
    DECLARE_OLETYPELIB(CAccountMapperCtrl)      // GetTypeInfo
    DECLARE_PROPPAGEIDS(CAccountMapperCtrl)     // Property page IDs
    DECLARE_OLECTLTYPE(CAccountMapperCtrl)      // Type name and misc status

    // Subclassed control support
    BOOL PreCreateWindow(CREATESTRUCT& cs);
    BOOL IsSubclassedControl();
    LRESULT OnOcmCommand(WPARAM wParam, LPARAM lParam);

// Message maps
    //{{AFX_MSG(CAccountMapperCtrl)
        // NOTE - ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

// Dispatch maps
    //{{AFX_DISPATCH(CAccountMapperCtrl)
    afx_msg void ShowMappingDialog();
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()

// Event maps
    //{{AFX_EVENT(CAccountMapperCtrl)
    void FireClick()
        {FireEvent(DISPID_CLICK,EVENT_PARAM(VTS_NONE));}
    //}}AFX_EVENT
    DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
    enum {
    //{{AFX_DISP_ID(CAccountMapperCtrl)
    dispidShowMappingDialog = 1L,
    //}}AFX_DISP_ID
    };

private:
    BOOL fInitialized;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\amapppg.h ===
// AMapPpg.h : Declaration of the CAccountMapperPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CAccountMapperPropPage : See AMapPpg.cpp.cpp for implementation.

class CAccountMapperPropPage : public COlePropertyPage
{
    DECLARE_DYNCREATE(CAccountMapperPropPage)
    DECLARE_OLECREATE_EX(CAccountMapperPropPage)

// Constructor
public:
    CAccountMapperPropPage();

// Dialog Data
    //{{AFX_DATA(CAccountMapperPropPage)
    enum { IDD = IDD_PROPPAGE_MAPR1 };
    CString m_Caption;
    //}}AFX_DATA

// Implementation
protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
    //{{AFX_MSG(CAccountMapperPropPage)
        // NOTE - ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\authctl.cpp ===
#include "stdafx.h"
#include "certmap.h"
#include "AuthCtl.h"
#include "AuthPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CCertAuthCtrl, COleControl)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CCertAuthCtrl, COleControl)
    //{{AFX_MSG_MAP(CCertAuthCtrl)
    // NOTE - ClassWizard will add and remove message map entries
    //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG_MAP
    ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CCertAuthCtrl, COleControl)
    //{{AFX_DISPATCH_MAP(CCertAuthCtrl)
    DISP_FUNCTION(CCertAuthCtrl, "SetMachineName", SetMachineName, VT_EMPTY, VTS_BSTR)
    DISP_FUNCTION(CCertAuthCtrl, "SetServerInstance", SetServerInstance, VT_EMPTY, VTS_BSTR)
    DISP_STOCKPROP_FONT()
    DISP_STOCKPROP_BORDERSTYLE()
    DISP_STOCKPROP_ENABLED()
    DISP_STOCKPROP_CAPTION()
    DISP_FUNCTION_ID(CCertAuthCtrl, "DoClick", DISPID_DOCLICK, DoClick, VT_EMPTY, VTS_I4)
    //}}AFX_DISPATCH_MAP
    DISP_FUNCTION_ID(CCertAuthCtrl, "AboutBox", DISPID_ABOUTBOX, AboutBox, VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CCertAuthCtrl, COleControl)
    //{{AFX_EVENT_MAP(CCertAuthCtrl)
    EVENT_STOCK_CLICK()
    //}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

// TODO: Add more property pages as needed.  Remember to increase the count!
BEGIN_PROPPAGEIDS(CCertAuthCtrl, 2)
    PROPPAGEID(CCertAuthPropPage::guid)
    PROPPAGEID(CLSID_CFontPropPage)
END_PROPPAGEIDS(CCertAuthCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CCertAuthCtrl, "CERTMAP.CertmapCtrl.2",
    0x996ff6f, 0xb6a1, 0x11d0, 0x92, 0x92, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CCertAuthCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DCertAuth =
        { 0x996ff6d, 0xb6a1, 0x11d0, { 0x92, 0x92, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b } };
const IID BASED_CODE IID_DCertAuthEvents =
        { 0x996ff6e, 0xb6a1, 0x11d0, { 0x92, 0x92, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwCertAuthOleMisc =
    OLEMISC_ACTIVATEWHENVISIBLE |
    OLEMISC_SETCLIENTSITEFIRST |
    OLEMISC_INSIDEOUT |
    OLEMISC_CANTLINKINSIDE |
    OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CCertAuthCtrl, IDS_CERTAUTH, _dwCertAuthOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CCertAuthCtrl::CCertAuthCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CCertAuthCtrl

BOOL CCertAuthCtrl::CCertAuthCtrlFactory::UpdateRegistry(BOOL bRegister)
    {
    if (bRegister)
        return AfxOleRegisterControlClass(
            AfxGetInstanceHandle(),
            m_clsid,
            m_lpszProgID,
            IDS_CERTAUTH,
            IDB_CERTAUTH,
            afxRegApartmentThreading,
            _dwCertAuthOleMisc,
            _tlid,
            _wVerMajor,
            _wVerMinor);
    else
        return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
    }


/////////////////////////////////////////////////////////////////////////////
// CCertAuthCtrl::CCertAuthCtrl - Constructor

CCertAuthCtrl::CCertAuthCtrl():
    m_fUpdateFont( FALSE ),
    m_hAccel( NULL ),
    m_cAccel( 0 )
    {
    InitializeIIDs(&IID_DCertAuth, &IID_DCertAuthEvents);
    }


/////////////////////////////////////////////////////////////////////////////
// CCertAuthCtrl::~CCertAuthCtrl - Destructor

CCertAuthCtrl::~CCertAuthCtrl()
    {
     if ( m_hAccel )
        DestroyAcceleratorTable( m_hAccel );

        m_hAccel = NULL;

    }


/////////////////////////////////////////////////////////////////////////////
// CCertAuthCtrl::OnDraw - Drawing function

void CCertAuthCtrl::OnDraw(
            CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
    {
    CFont* pOldFont;
    pOldFont = SelectStockFont( pdc );
    DoSuperclassPaint(pdc, rcBounds);
    pOldFont = pdc->SelectObject(pOldFont);
    if ( m_fUpdateFont )
        {
        m_fUpdateFont = FALSE;
        CWnd::SetFont( pOldFont );
        }
    }


/////////////////////////////////////////////////////////////////////////////
// CCertAuthCtrl::DoPropExchange - Persistence support

void CCertAuthCtrl::DoPropExchange(CPropExchange* pPX)
    {
    ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
    COleControl::DoPropExchange(pPX);
    }


/////////////////////////////////////////////////////////////////////////////
// CCertAuthCtrl::OnResetState - Reset control to default state

void CCertAuthCtrl::OnResetState()
    {
    COleControl::OnResetState();  // Resets defaults found in DoPropExchange
    }


/////////////////////////////////////////////////////////////////////////////
// CCertAuthCtrl::AboutBox - Display an "About" box to the user

void CCertAuthCtrl::AboutBox()
    {
    }


/////////////////////////////////////////////////////////////////////////////
// CCertAuthCtrl message handlers

//---------------------------------------------------------------------------
BOOL CCertAuthCtrl::PreCreateWindow(CREATESTRUCT& cs) 
    {
    if ( cs.style & WS_CLIPSIBLINGS )
        cs.style ^= WS_CLIPSIBLINGS;
    cs.lpszClass = _T("BUTTON");
    return COleControl::PreCreateWindow(cs);
    }



/////////////////////////////////////////////////////////////////////////////
// CAppsCtrl::IsSubclassedControl - This is a subclassed control

BOOL CCertAuthCtrl::IsSubclassedControl()
    {
    return TRUE;
    }



/////////////////////////////////////////////////////////////////////////////
// OnOcmCommand - Handle command messages

LRESULT CCertAuthCtrl::OnOcmCommand(WPARAM wParam, LPARAM lParam)
{
#ifdef _WIN32
    WORD wNotifyCode = HIWORD(wParam);
#else
    WORD wNotifyCode = HIWORD(lParam);
#endif
    return 0;
}


extern void test__non2Rons_WizClasses();

void CCertAuthCtrl::OnClick(USHORT iButton) 
{

    COleControl::OnClick(iButton);
}

//---------------------------------------------------------------------------
void CCertAuthCtrl::SetServerInstance(LPCTSTR szServerInstance) 
    {
    m_szServerInstance = szServerInstance;
    }

//---------------------------------------------------------------------------
void CCertAuthCtrl::SetMachineName(LPCTSTR szMachine) 
    {
    m_szMachineName = szMachine;
    }


//---------------------------------------------------------------------------
void CCertAuthCtrl::OnFontChanged() 
    {
    m_fUpdateFont = TRUE;
    COleControl::OnFontChanged();
    }
//---------------------------------------------------------------------------
void CCertAuthCtrl::OnAmbientPropertyChange(DISPID dispid) 
    {
    BOOL    flag;
    UINT    style;

    switch ( dispid )
        {
        case DISPID_AMBIENT_DISPLAYASDEFAULT:
            if ( GetAmbientProperty( DISPID_AMBIENT_DISPLAYASDEFAULT, VT_BOOL, &flag ) )
                {
                style = GetWindowLong(
                        GetSafeHwnd(), // handle of window 
                        GWL_STYLE  // offset of value to retrieve 
                        );
                if ( flag )
                    style |= BS_DEFPUSHBUTTON;
                else
                    style ^= BS_DEFPUSHBUTTON;
                SetWindowLong(
                        GetSafeHwnd(), // handle of window 
                        GWL_STYLE,  // offset of value to retrieve 
                        style
                        );
                Invalidate(TRUE);
                }
            break;
        };

    COleControl::OnAmbientPropertyChange(dispid);
    }

void CCertAuthCtrl::OnGetControlInfo(LPCONTROLINFO pControlInfo) 
    {
    if ( !pControlInfo || pControlInfo->cb < sizeof(CONTROLINFO) )
        return;

    pControlInfo->hAccel = m_hAccel;
    pControlInfo->cAccel = m_cAccel;

    pControlInfo->dwFlags = CTRLINFO_EATS_RETURN;
    }

void CCertAuthCtrl::OnKeyUpEvent(USHORT nChar, USHORT nShiftState) 
    {
    if ( nChar == _T(' ') )
        {
        OnClick((USHORT)GetDlgCtrlID());
        }
    COleControl::OnKeyUpEvent(nChar, nShiftState);
    }

//---------------------------------------------------------------------------
void CCertAuthCtrl::OnMnemonic(LPMSG pMsg) 
    {
    OnClick((USHORT)GetDlgCtrlID());
    COleControl::OnMnemonic(pMsg);
    }

//---------------------------------------------------------------------------
void CCertAuthCtrl::OnTextChanged() 
    {
    DWORD   i;
    ACCEL   accel;
    BOOL    f;
    BOOL    flag;
    int     iAccel;

    // get the new text
    CString sz = InternalGetText();
    sz.MakeLower();

    if ( m_hAccel )
        {
        DestroyAcceleratorTable( m_hAccel );
        m_hAccel = NULL;
        m_cAccel = 0;
        }

    iAccel = sz.Find(_T('&'));
    if ( iAccel >= 0 )
        {
        accel.fVirt = FALT;
        accel.key = sz.GetAt(iAccel + 1);
        accel.cmd = (WORD)GetDlgCtrlID();

        m_hAccel = CreateAcceleratorTable( &accel, 1 );
        if ( m_hAccel )
            m_cAccel = 1;
        }

    COleControl::OnTextChanged();
    }

void CCertAuthCtrl::DoClick(IN  long dwButtonNumber) 
{
    OnClick( (short) dwButtonNumber );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\authppg.h ===
// CertAuthPpg.h : Declaration of the CCertAuthPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CCertAuthPropPage : See CertAuthPpg.cpp.cpp for implementation.

class CCertAuthPropPage : public COlePropertyPage
{
    DECLARE_DYNCREATE(CCertAuthPropPage)
    DECLARE_OLECREATE_EX(CCertAuthPropPage)

// Constructor
public:
    CCertAuthPropPage();

// Dialog Data
    //{{AFX_DATA(CCertAuthPropPage)
    enum { IDD = IDD_PROPPAGE_CERTAUTH };
    CString m_sz_caption;
    //}}AFX_DATA

// Implementation
protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
    //{{AFX_MSG(CCertAuthPropPage)
        // NOTE - ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\authctl.h ===
// AuthCtl.h : Declaration of the CCertAuthCtrl OLE control class.

#ifndef  _AuthCtl_h_12375_
#define  _AuthCtl_h_12375_

//#include "NKChseCA.h"

//#include <wincrypt.h>
// #include "Certifct.h"
// #include "dlgs.h"
// #include "SelAcct.h"
// #include "FindDlg.h"
// #include "wintrust.h"
//#include <cryptui.h>

/////////////////////////////////////////////////////////////////////////////
// CCertAuthCtrl : See AuthCtl.cpp for implementation.

class CCertAuthCtrl : public COleControl
{
    DECLARE_DYNCREATE(CCertAuthCtrl)

// Constructor
public:
    CCertAuthCtrl();

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CCertAuthCtrl)
    public:
    virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
    virtual void DoPropExchange(CPropExchange* pPX);
    virtual void OnResetState();
    virtual void OnClick(USHORT iButton);
    virtual void OnFontChanged();

#ifdef FUTURE_USE
    // tompop: some experimental code for testing
    virtual HRESULT LaunchCommonCTLDialog (CCTL* pCTL);
#endif /* FUTURE_USE */

    protected:
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    //}}AFX_VIRTUAL

// Implementation
protected:
    ~CCertAuthCtrl();

    DECLARE_OLECREATE_EX(CCertAuthCtrl)    // Class factory and guid
    DECLARE_OLETYPELIB(CCertAuthCtrl)      // GetTypeInfo
    DECLARE_PROPPAGEIDS(CCertAuthCtrl)     // Property page IDs
    DECLARE_OLECTLTYPE(CCertAuthCtrl)       // Type name and misc status

// Message maps
    //{{AFX_MSG(CCertAuthCtrl)
        // NOTE - ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

// Dispatch maps
    //{{AFX_DISPATCH(CCertAuthCtrl)
    afx_msg void SetMachineName(LPCTSTR szMachineName);
    afx_msg void SetServerInstance(LPCTSTR szServerInstance);
    afx_msg void DoClick(long dwButtonNumber);
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()

    afx_msg void AboutBox();

// Event maps
    //{{AFX_EVENT(CCertAuthCtrl)
    //}}AFX_EVENT
    DECLARE_EVENT_MAP()
    
    // Subclassed control support
    BOOL IsSubclassedControl();
    LRESULT OnOcmCommand(WPARAM wParam, LPARAM lParam);


//    void NKAddPageToWizard(IN ADMIN_INFO& info, IN CNKPages* nkpg2Add, IN OUT CPropertySheet* psWizard);

// Dispatch and event IDs
public:
    enum {
    //{{AFX_DISP_ID(CCertAuthCtrl)
    dispidSetMachineName = 1L,
    dispidSetServerInstance = 2L,
    //}}AFX_DISP_ID
    };
    
    ////////////////////////////////////////////////////////////////////////
    // run the dialogs used in this active X control.
    //  Big picture:  OnClick(USHORT iButton) will do all the setup for
    //  activeX controls and then call RunDialogs4OnClick that has the
    // tasks of setting up the MetaBase ptr and call the _RunDialogs4OnClick
    // routine that does all the work...
    //
    // The above 'RunDialogs4OnClick()' calls us inside of a try/catch
    // block to protect the metabase
    ////////////////////////////////////////////////////////////////////////
//    BOOL RunDialogs4OnClick(USHORT iButton);
    
    ////////////////////////////////////////////////////////////////////////
    //  _RunDialogs4OnClick -- main handler for our dialogs
    //
    //  Parms:  info:    holds the information database for out ActiveX cntrol
    //                   By this time its member m_mbWrap holds the MetaBase Wrapper
    //                   that is properly initialized
    //                   and points to the SERVER node that we are operating in.
    //          iButton: tells what "logical button" fired our control:
    //                   0=Get-Cert     1=Edit
    ////////////////////////////////////////////////////////////////////////
//    BOOL  _RunDialogs4OnClick(ADMIN_INFO& info, USHORT iButton);

    /////////////////////////////////////////////////////////////////////
    // Automation defined methods
    /////////////////////////////////////////////////////////////////////
    void OnAmbientPropertyChange(DISPID dispid) ;
    void OnTextChanged();
    void OnMnemonic(LPMSG pMsg); 
    void OnGetControlInfo(LPCONTROLINFO pControlInfo); 
    void OnKeyUpEvent(USHORT nChar, USHORT nShiftState); 
    
    CString     m_szServerInstance;
    CString     m_szMachineName;
    BOOL        m_fUpdateFont;
    CString     m_szOurApplicationTitle; // set in OnClick()
 
        // the accelerator table
    HACCEL  m_hAccel;
    WORD    m_cAccel;

};


#endif /* _AuthCtl_h_12375_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\brwsdlg.cpp ===
/*++

Module Name:

    brwsdlg.cpp

Abstract:

    Intermediate dialog class that provides basic NT user account browsing.
    It assumes that the dialog resource contains BOTH a IDC_BROWSE button
    and a IDC_ACCOUNT_NAME edit field. It maintains both of these items.

Author:

   Boyd Multerer boydm

--*/

#include "stdafx.h"
#include "certmap.h"
#include "brwsdlg.h"
#include "cnfrmpsd.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEditOne11MapDlg dialog

//---------------------------------------------------------------------------
CNTBrowsingDialog::CNTBrowsingDialog( UINT nIDTemplate, CWnd* pParentWnd )
    : CDialog( nIDTemplate, pParentWnd )
    {
    //{{AFX_DATA_INIT(CNTBrowsingDialog)
    m_sz_accountname = _T("");
    m_sz_password = _T("");
    //}}AFX_DATA_INIT
    }

//---------------------------------------------------------------------------
void CNTBrowsingDialog::DoDataExchange(CDataExchange* pDX)
    {
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CNTBrowsingDialog)
    DDX_Control(pDX, IDC_PASSWORD, m_cedit_password);
    DDX_Control(pDX, IDC_NTACCOUNT, m_cedit_accountname);
    DDX_Text(pDX, IDC_NTACCOUNT, m_sz_accountname);
    DDX_Text_SecuredString(pDX, IDC_PASSWORD, m_sz_password);
    //}}AFX_DATA_MAP
//  DDX_Control(pDX, IDC_PASSWORD, m_cedit_password);
    }

//---------------------------------------------------------------------------
BEGIN_MESSAGE_MAP(CNTBrowsingDialog, CDialog)
    //{{AFX_MSG_MAP(CNTBrowsingDialog)
    ON_BN_CLICKED(IDC_BROWSE, OnBrowse)
    ON_EN_CHANGE(IDC_PASSWORD, OnChangePassword)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNTBrowsingDialog message handlers


//---------------------------------------------------------------------------
BOOL CNTBrowsingDialog::OnInitDialog()
  {
    m_bPassTyped = FALSE;
    m_szOrigPass = m_sz_password;
    if ( !m_sz_password.IsEmpty() ) 
    {
        CString csTempPassword;
        csTempPassword.LoadString( IDS_SHOWN_PASSWORD );
        m_sz_password = csTempPassword;
    }
    return CDialog::OnInitDialog();
  }

//---------------------------------------------------------------------------
// run the user browser
void CNTBrowsingDialog::OnBrowse() 
{
   UpdateData(TRUE);
   TCHAR * pUser = m_sz_accountname.GetBuffer(MAX_PATH);
   GetIUsrAccount(NULL, this, pUser, MAX_PATH);
   m_sz_accountname.ReleaseBuffer(-1);
   UpdateData(FALSE);
}

//---------------------------------------------------------------------------
// make sure that the selected NT acount is, in fact, a valid account
// 
void CNTBrowsingDialog::OnOK() 
    {
    // update the data
    UpdateData( TRUE );

    // see if the account name is empty
    if ( m_sz_accountname.IsEmpty() )
        {
        AfxMessageBox( IDS_WANTACCOUNT );
        m_cedit_accountname.SetFocus();
        m_cedit_accountname.SetSel(0, -1);
        return;
        }

    // validate the password
    if ( m_bPassTyped )
        {
        CConfirmPassDlg dlgPass;
        dlgPass.m_szOrigPass = m_sz_password;
        if ( dlgPass.DoModal() != IDOK )
            {
            m_cedit_password.SetFocus();
            m_cedit_password.SetSel(0, -1);
            return;
            }
        }
    else
        {
        // restore the original password instead of the
        // standard ****** string
        m_sz_password = m_szOrigPass;
        UpdateData( FALSE );
        }


    // although it would seem to be a nice thing to do to verify the password and
    // account - it is VERY difficult, if not impossible, to do on a remote machine

    // it is valid
    CDialog::OnOK();
    }

//---------------------------------------------------------------------------
void CNTBrowsingDialog::OnChangePassword() 
    {
    // TODO: If this is a RICHEDIT control, the control will not
    // send this notification unless you override the CNTBrowsingDialog::OnInitDialog()
    // function to send the EM_SETEVENTMASK message to the control
    // with the ENM_CHANGE flag ORed into the lParam mask.
    m_bPassTyped = TRUE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\authppg.cpp ===
// CertAuthPpg.cpp : Implementation of the CCertAuthPropPage property page class.

#include "stdafx.h"
#include "certmap.h"
#include "AuthPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CCertAuthPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CCertAuthPropPage, COlePropertyPage)
    //{{AFX_MSG_MAP(CCertAuthPropPage)
    // NOTE - ClassWizard will add and remove message map entries
    //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CCertAuthPropPage, "CERTMAP.CertmapCtrl.2",
    0x996ff70, 0xb6a1, 0x11d0, 0x92, 0x92, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b)


/////////////////////////////////////////////////////////////////////////////
// CCertAuthPropPage::CCertAuthPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CCertAuthPropPage

BOOL CCertAuthPropPage::CCertAuthPropPageFactory::UpdateRegistry(BOOL bRegister)
{
    if (bRegister)
        return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
            m_clsid, IDS_CERTAUTH_PPG);
    else
        return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CCertAuthPropPage::CCertAuthPropPage - Constructor

CCertAuthPropPage::CCertAuthPropPage() :
    COlePropertyPage(IDD, IDS_CERTAUTH_PPG_CAPTION)
{
    //{{AFX_DATA_INIT(CCertAuthPropPage)
    m_sz_caption = _T("");
    //}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CCertAuthPropPage::DoDataExchange - Moves data between page and properties

void CCertAuthPropPage::DoDataExchange(CDataExchange* pDX)
{
    //{{AFX_DATA_MAP(CCertAuthPropPage)
    DDP_Text(pDX, IDC_CAPTIONEDIT, m_sz_caption, _T("Caption") );
    DDX_Text(pDX, IDC_CAPTIONEDIT, m_sz_caption);
    //}}AFX_DATA_MAP
    DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CCertAuthPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\brwsdlg.h ===
//--------------------------------------------------------
class CNTBrowsingDialog : public CDialog
    {
    public:

    // construct / deconstruct
    CNTBrowsingDialog( UINT nIDTemplate, CWnd* pParentWnd = NULL );

    // overrides
    virtual void OnOK();
    virtual BOOL OnInitDialog();

// Dialog Data
    //{{AFX_DATA(CEditOne11MapDlg)
    CEdit   m_cedit_password;
    CEdit   m_cedit_accountname;
    CString m_sz_accountname;
    CStrPassword m_sz_password;
    //}}AFX_DATA

//  CEdit   m_cedit_password;

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CNTBrowsingDialog)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CNTBrowsingDialog)
    afx_msg void OnBrowse();
    afx_msg void OnChangePassword();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    CStrPassword m_szOrigPass;
    BOOL    m_bPassTyped;
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\cauthctl.h ===
// CAuthCtl.h : Declaration of the CCertAuthorityCtrl OLE control class.

/////////////////////////////////////////////////////////////////////////////
// CCertAuthorityCtrl : See CAuthCtl.cpp for implementation.

class CCertAuthorityCtrl : public COleControl
{
    DECLARE_DYNCREATE(CCertAuthorityCtrl)

// Constructor
public:
    CCertAuthorityCtrl();

// Overrides

    // Drawing function
    virtual void OnDraw(
                CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);

    // Persistence
    virtual void DoPropExchange(CPropExchange* pPX);

    // Reset control state
    virtual void OnResetState();

// Implementation
protected:
    ~CCertAuthorityCtrl();

    DECLARE_OLECREATE_EX(CCertAuthorityCtrl)    // Class factory and guid
    DECLARE_OLETYPELIB(CCertAuthorityCtrl)      // GetTypeInfo
    DECLARE_PROPPAGEIDS(CCertAuthorityCtrl)     // Property page IDs
    DECLARE_OLECTLTYPE(CCertAuthorityCtrl)      // Type name and misc status

    // Subclassed control support
    BOOL PreCreateWindow(CREATESTRUCT& cs);
    BOOL IsSubclassedControl();
    LRESULT OnOcmCommand(WPARAM wParam, LPARAM lParam);

// Message maps
    //{{AFX_MSG(CCertAuthorityCtrl)
        // NOTE - ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

// Dispatch maps
    //{{AFX_DISPATCH(CCertAuthorityCtrl)
        // NOTE - ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()

// Event maps
    //{{AFX_EVENT(CCertAuthorityCtrl)
        // NOTE - ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_EVENT
    DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
    enum {
    //{{AFX_DISP_ID(CCertAuthorityCtrl)
        // NOTE: ClassWizard will add and remove enumeration elements here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_DISP_ID
    };

private:
    BOOL fInitialized;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\certctl.h ===
// CertCtl.h : Declaration of the CCertmapCtrl OLE control class.

/////////////////////////////////////////////////////////////////////////////
// CCertmapCtrl : See CertCtl.cpp for implementation.

class CCertmapCtrl : public COleControl
{
    DECLARE_DYNCREATE(CCertmapCtrl)

// Constructor
public:
    CCertmapCtrl();

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CCertmapCtrl)
    public:
    virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
    virtual void DoPropExchange(CPropExchange* pPX);
    virtual void OnResetState();
    virtual void OnClick(USHORT iButton);
    virtual void OnFontChanged();
    virtual void OnAmbientPropertyChange(DISPID dispid);
    virtual void OnGetControlInfo(LPCONTROLINFO pControlInfo);
    virtual void OnKeyUpEvent(USHORT nChar, USHORT nShiftState);
    virtual void OnMnemonic(LPMSG pMsg);
    virtual void OnTextChanged();
    protected:
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    //}}AFX_VIRTUAL

// Implementation
protected:
    ~CCertmapCtrl();

    // the whole point of the control
    void RunMappingDialog();


    DECLARE_OLECREATE_EX(CCertmapCtrl)    // Class factory and guid
    DECLARE_OLETYPELIB(CCertmapCtrl)      // GetTypeInfo
    DECLARE_PROPPAGEIDS(CCertmapCtrl)     // Property page IDs
    DECLARE_OLECTLTYPE(CCertmapCtrl)        // Type name and misc status

// Message maps
    //{{AFX_MSG(CCertmapCtrl)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

// Dispatch maps
    //{{AFX_DISPATCH(CCertmapCtrl)
    afx_msg void SetServerInstance(LPCTSTR szServerInstance);
    afx_msg void SetMachineName(LPCTSTR szMachineName);
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()

// Event maps
    //{{AFX_EVENT(CCertmapCtrl)
    //}}AFX_EVENT
    DECLARE_EVENT_MAP()

    // Subclassed control support
    BOOL IsSubclassedControl();
    LRESULT OnOcmCommand(WPARAM wParam, LPARAM lParam);

// Dispatch and event IDs
public:
    enum {
    //{{AFX_DISP_ID(CCertmapCtrl)
    dispidSetServerInstance = 1L,
    dispidSetMachineName = 2L,
    //}}AFX_DISP_ID
    };

    CString     m_szServerInstance;
    CString     m_szMachineName;
    BOOL        m_fUpdateFont;

        // the accelerator table
    HACCEL  m_hAccel;
    WORD    m_cAccel;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\certppg.cpp ===
// CertPpg.cpp : Implementation of the CCertmapPropPage property page class.

#include "stdafx.h"
#include "certmap.h"
#include "CertPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CCertmapPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CCertmapPropPage, COlePropertyPage)
    //{{AFX_MSG_MAP(CCertmapPropPage)
    // NOTE - ClassWizard will add and remove message map entries
    //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CCertmapPropPage, "CERTMAP.CertmapPropPage.1",
    0xbbd8f29c, 0x6f61, 0x11d0, 0xa2, 0x6e, 0x8, 0, 0x2b, 0x2c, 0x6f, 0x32)


/////////////////////////////////////////////////////////////////////////////
// CCertmapPropPage::CCertmapPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CCertmapPropPage

BOOL CCertmapPropPage::CCertmapPropPageFactory::UpdateRegistry(BOOL bRegister)
{
    if (bRegister)
        return AfxOleRegisterPropertyPageClass(
            AfxGetInstanceHandle(),
            m_clsid, 
            IDS_CERTMAP_PPG,
            afxRegApartmentThreading
            );
    else
        return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CCertmapPropPage::CCertmapPropPage - Constructor

CCertmapPropPage::CCertmapPropPage() :
    COlePropertyPage(IDD, IDS_CERTMAP_PPG_CAPTION)
{
    //{{AFX_DATA_INIT(CCertmapPropPage)
    m_Caption = _T("");
    m_szPath = _T("");
    //}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CCertmapPropPage::DoDataExchange - Moves data between page and properties

void CCertmapPropPage::DoDataExchange(CDataExchange* pDX)
{
    //{{AFX_DATA_MAP(CCertmapPropPage)
    DDP_Text(pDX, IDC_CAPTIONEDIT, m_Caption, _T("Caption") );
    DDX_Text(pDX, IDC_CAPTIONEDIT, m_Caption);
    DDP_Text(pDX, IDC_MB_PATH, m_szPath, _T("MBPath") );
    DDX_Text(pDX, IDC_MB_PATH, m_szPath);
    //}}AFX_DATA_MAP
    DDP_PostProcessing(pDX);
}




/////////////////////////////////////////////////////////////////////////////
// CCertmapPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\cauthdlg.h ===
// CAuthDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CClientAuthoritiesDialog dialog

class CClientAuthoritiesDialog : public CDialog
{
// Construction
public:
    CClientAuthoritiesDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CClientAuthoritiesDialog)
    enum { IDD = IDD_CLIENT_AUTHORITIES };
        // NOTE: the ClassWizard will add data members here
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CClientAuthoritiesDialog)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CClientAuthoritiesDialog)
    afx_msg void OnViewCertificate();
    afx_msg void OnDelete();
    afx_msg void OnAdd();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\certmap.h ===
// certmap.h : main header file for CERTMAP.DLL

#if !defined( __AFXCTL_H__ )
    #error include 'afxctl.h' before including this file
#endif

#ifndef  _certmap_h_1234_
#define  _certmap_h_1234_


#include <iadmw.h>           // MetaBase Wrapper
#include <iis64.h>           // 64-bit helper stuff
#include "Wrapmb.h"          // CWrapMetaBase -- see below we also use CAFX_MetaWrapper
#include <iiscnfgp.h>        // IIS config parameters like the MetaBase
#include "strpass.h"

// Check if legacy metabase format (before iis6)
BOOL IsLegacyMetabase(IMSAdminBase* pMB);

// Boyd put a lot of efforts to make it hard to use iisui. Therefore I should
// put this declaration here instead of including the file
BOOL __declspec(dllimport)
GetIUsrAccount(
    IN  LPCTSTR lpstrServer,
    IN  CWnd * pParent,
	LPTSTR buf,
	int size
    );


/*
#include "Easy.h"           // do this before the "using namespace" decl

#include "Debug.h"           // Are we building a debugging build?
#include  "admin.h"         // defines the ADMIN_INFO an some handley #defines for the CN= strings


#include "Easy.h"           // do this before the "using namespace" decl
#include "Cookie.h"         // CCertmapCookie
#include "CTL.h"
#include "Certifct.h"

#include "WrpMBwrp.h"        // CAFX_MetaWrapper  derives from CWrapMetaBase
                             //  and provides a handy GetString method to set
                             //  strings directly.  Otherwise its CWrapMetaBase.

                            // property definitions and keywords
#include  "Meta.h"  // for general MetaBase constant definitions and error values


#include <wincrypt.h>
#include <cryptui.h>

//SkipThis// // We can not simply say:
//SkipThis// //    using namespace Easy;        // use the Easier to use
//SkipThis// // since the "less able" C++ compiler can not differentiate
//SkipThis// // between '::CString' and our Easier to use Easy::CString.  I wanted
//SkipThis// // Easy::CString to be used always and just say look in Easy first...
//SkipThis// //  This is easy to do w/ java by declaring a package and preInserting
//SkipThis// //  it in the class path ahead of the std libraries...
//SkipThis// 
//SkipThis// "#define  CString   Easy::CString"


        

//  Define  'USE_NEW_REG_METHOD'  if you  want us to use our new Reg::
//  methods to read and write strings to the registry...  The old code
//  that straight lines the calls to do this have sections like:
//   #ifdef  USE_NEW_REG_METHOD
//
//     //     Get entry in      ==path===      ==w/ name==    ==place here==
//     return Reg::GetNameValueIn(SZ_PARAMETERS, szValueName, sz,
//                               HKEY_CURRENT_USER);
//
//   #else   ////////////////////////////// use the old method ///////////////
//
//  so that you can choose whether to use the new method of the old one...
#define  USE_NEW_REG_METHOD



#include "Util.h"           // various utilites to help debug
*/

#include "resource.h"       // main symbols
#include "helpmap.h"       // main symbols


//#include "certcli.h"        // has ICertRequest COM interface definitions

/////////////////////////////////////////////////////////////////////////////
// CCertmapApp : See certmap.cpp for implementation.

class CCertmapApp : public COleControlModule
{
public:
    BOOL InitInstance();
    int ExitInstance();
    virtual void WinHelp(DWORD dwData, UINT nCmd = HELP_CONTEXT);
};



extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;
/*

#define _EXE_                //  We are building the EXE!
                             //  this is used in  "KeyObjs.h"  to
                             //  decide if we are importing or exporting
                             //  "KeyObjs.h" Classes.  We are the EXE,
                             //  aka the guy implementing the CService/etc objs.
#include "KeyObjs.h"
*/
#define         SZ_NAMESPACE_EXTENTION  "/<nsepm>"

/*
 extern void DisplaySystemError (HWND hParent, DWORD dwErr);  // see CTL.cpp
 extern BOOL MyGetOIDInfo (CString & string, LPCSTR pszObjId);
 extern HRESULT FormatDate (FILETIME utcDateTime, CString & pszDateTime);

 // the following fnct is used to move GUID strings out of the registry
 // and into the metabase.  Its called in the OnClick event for our OCX cntrl
 extern BOOL  MigrateGUIDS( ADMIN_INFO& info );

 #define   IDS_CERTIFICATE_MANAGER    IDS_CERTMAP
*/


#endif   /* _certmap_h_1234_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\certmap.cpp ===
// certmap.cpp : Implementation of CCertmapApp and DLL registration.
                           
#include "stdafx.h"
#include "certmap.h"
#include "iishelp.h"

#include <iiscnfgp.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CCertmapApp /*NEAR*/ theApp;    // tompop: does this have to be near?  We are now getting errors when we finish refering to this var's addr

const GUID CDECL BASED_CODE _tlid =
        { 0xbbd8f298, 0x6f61, 0x11d0, { 0xa2, 0x6e, 0x8, 0, 0x2b, 0x2c, 0x6f, 0x32 } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;

//--------------------------------------------------------------------------
void CCertmapApp::WinHelp(DWORD dwData, UINT nCmd )
    {
    WinHelpDebug(dwData);
    COleControlModule::WinHelp(dwData,nCmd);
    }

////////////////////////////////////////////////////////////////////////////
// CCertmapApp::InitInstance - DLL initialization

BOOL CCertmapApp::InitInstance()
    {
    BOOL bInit = COleControlModule::InitInstance();

    // init ole stuff
    HRESULT hRes = CoInitialize(NULL);

    // finally, we need to redirect the winhelp file location to something more desirable
    CString sz;
    CString szHelpLocation;
    sz.LoadString( IDS_HELPLOC_PWSHELP );
    
    // expand the path
    ExpandEnvironmentStrings(
        sz,                                     // pointer to string with environment variables 
        szHelpLocation.GetBuffer(MAX_PATH + 1), // pointer to string with expanded environment variables  
        MAX_PATH                                // maximum characters in expanded string 
       );
    szHelpLocation.ReleaseBuffer();

    // free the existing path, and copy in the new one
    if ( m_pszHelpFilePath )
        free((void*)m_pszHelpFilePath);
    m_pszHelpFilePath = _tcsdup(szHelpLocation);

	// get debug flag
	GetOutputDebugFlag();

    return bInit;
    }


////////////////////////////////////////////////////////////////////////////
// CCertmapApp::ExitInstance - DLL termination
// tjp:  note that in 'CCertmapApp::InitInstance()' we add our help file to the
//       help path.  do we need to remove it on clean up here?
int CCertmapApp::ExitInstance()
    {
    CoUninitialize();
    return COleControlModule::ExitInstance();
    }


/////////////////////////////////////////////////////////////////////////////
// MigrateGUIDS - does all the GUID migration work. We pass back the
// return value of True iff we find GUIDs in the registry and migrate
// them to the metabase.
//
// We are called by top level fnct: InstallCertServerGUIDs that creates
// our 'info' structure and handles all the metabase init work.
/////////////////////////////////////////////////////////////////////////////
//  This code is written in response to bug # 167410.
//
//  This fix will handle all the GUID migration work, moving GUIDS that
//  CertServer placed in the registry into the metabase for Beta2. 
//  A more general install/deinstall mechanism for products that
//  work with IIS will be come post-Beta2.
//
//  DETAILS:
//  --------
//  
//   We look for evidence of CertServer by examing the Registry because
//   CertServer will write some entries under:
//   HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\KeyRing\Parameters\Certificate 
//         Authorities\Microsoft Certificate Server
//  
//    CertServer currently outputs:
//         CertGetConfig   "{C6CC49B0-CE17-11D0-8833-00A0C903B83C}"
//         CertRequest "{98AFF3F0-5524-11D0-8812-00A0C903B83C}"
//  
//    If we see the manditory 'CertRequest' entry, we will load as many strings
//    as we find, while defaulting the ones that are missing. See below
//    for the equivalent mdutil commands for what defaults are used
//  
//        => if we dont find  'CertRequest' we give up [meaning remove
//          any present MB GUID string entries]
//  
//   When we find that CertServer is installed, we dont fully believe that
//   certserver is still there.  To prove that its there we will do a
//   CoCreateInstance on CertConfig. If that works we install metabase
//   entries that are the equivalent of the following mdutil commands:
//  
//   ## ICERTGETCONFIG default setting:
//   mdutil SET "w3svc/CertServers/Microsoft Certificate Server" -dtype:STRING -
//    -utype:UT_SERVER -prop 5571 -value "{C6CC49B0-CE17-11D0-8833-00A0C903B83C}"
//   
//   ## ICERTREQUEST default setting:
//   mdutil SET "w3svc/CertServers/Microsoft Certificate Server" -dtype:STRING 
//    -utype:UT_SERVER -prop 5572 -value "{98AFF3F0-5524-11D0-8812-00A0C903B83C}"
//   
//   ## ICERTCONFIG default setting:
//   mdutil SET "w3svc/CertServers/Microsoft Certificate Server" -dtype:STRING 
//    -utype:UT_SERVER -prop 5574 -value "{372fce38-4324-11d0-8810-00a0c903b83c}"
//  
//   If the CoCreateInstance fails, we give up and remove MB GUID entries.
//  
//  ---------------------------------------------------------------
//   NOTE that we will either install or DE-install the metabase
//        GUID strings based on its decision that CertServer is present.
//        If we find GUID strings in the metabase but can not do a 
//        CoCreateInstance on CertConfig:
//          we remove them so that the rest of CertWizard will see CertServer
//          Guids iff we can use CertServer.
//  ---------------------------------------------------------------
//  NOTE also that if we make a decision to install GUID strings
//       into the metabase, we honor/preserve any present GUID strings that
//       are present in the metabase.
//  ---------------------------------------------------------------
//
/////////////////////////////////////////////////////////////////////////////


/*ddddddddddddddd
BOOL  MigrateGUIDS( ADMIN_INFO& info )
{
    BOOL   bRet = FALSE;                          // value to return, set to F
                                                  //  for defensive reasons.
    BOOL   bFoundCertSrvRegistryEntries = FALSE;  // assume false for now

    TCHAR* szRegPath = _T("SOFTWARE\\Microsoft\\KeyRing\\Parameters\\Certificate Authorities\\Microsoft Certificate Server");

    //-----------------------------------------------------------------------
    // In each of the following 3 sets of parameters, we have (1) a string
    // like "CertRequest" that CertServer uses in the registry, (2) a default
    // value to use like  "{98AFF3F0-5524-11D0-8812-00A0C903B83C}"  that we
    // use if we can not find anything in the registry, and (3) a CString
    // to hold the GUID.   The value in the CString will be stored in the MB.
    //-----------------------------------------------------------------------

    // CertRequest - variables
    TCHAR* szCertRequest = _T("CertRequest");
    TCHAR* szCertRequestGUIDdefault = _T( "{98AFF3F0-5524-11D0-8812-00A0C903B83C}" );
    CString szCertRequestGUID;

    // CertConfig - variables
    TCHAR* szCertConfig = _T("CertConfig");
    TCHAR* szCertConfigGUIDdefault = _T( "{372fce38-4324-11d0-8810-00a0c903b83c}" );
    CString szCertConfigGUID;

    // CertGetConfig - variables
    TCHAR* szCertGetConfig = _T("CertGetConfig");
    TCHAR* szCertGetConfigGUIDdefault = _T( "{C6CC49B0-CE17-11D0-8833-00A0C903B83C}");
    CString szCertGetConfigGUID;


    CString  szCertServerMetabaseRoot( SZ_ROOT_CERT_SERV_MB_PATH );
                // SZ_ROOT_CERT_SERV_MB_PATH = "/LM/W3SVC/CertServers"

    szCertServerMetabaseRoot += _T("/Microsoft Certificate Server");

#ifdef  DEBUGGING
    CEditDialog  dlg(szCertServerMetabaseRoot,
                _T("use this to test adding new CertServer entries."
                   " In order for us to install a new key you have to change the path"
                   " below to something [strange] and not already in the metabase."));
    dlg.DoModal();
#endif    
    
    // the following string will be restored into info.szMetaBasePath before
    // we exit this fnct.  We switch out the [info.szMetaBasePath] so that
    // we can use our native Set/Get metabase string fncts.
    // We switch it to: "/LM/W3SVC/CertServers/Microsoft Certificate Server" 
    //
    CString  szSaved_info_szMetaBasePath( info.szMetaBasePath  );
    
    info.szMetaBasePath =   szCertServerMetabaseRoot;


    // if we dont find HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\KeyRing\Parameters\
    // Certificate Authorities\Microsoft Certificate Server"
    // with key: CertRequest  quit!   CertServer should have installed this.
    // We are forgiving about the other 2 Registry GUID strings
    //-------------------------------------------------------------------------
    if (   Reg::GetNameValueIn( szRegPath,      szCertRequest,
                                szCertRequestGUID,  HKEY_LOCAL_MACHINE )) {
           bFoundCertSrvRegistryEntries = TRUE;
    }
    if (!  Reg::GetNameValueIn( szRegPath,      szCertConfig,
                                szCertConfigGUID,  HKEY_LOCAL_MACHINE )) {
           szCertConfigGUID = szCertConfigGUIDdefault; // assign default
    }
    if (!  Reg::GetNameValueIn( szRegPath,      szCertGetConfig,
                                szCertGetConfigGUID,  HKEY_LOCAL_MACHINE )) {
           szCertGetConfigGUID = szCertGetConfigGUIDdefault; // assign default
    }

    //------------------------------------------------------------------------
    // First lets try to create the directory path: the user might have
    // deleted it or this might be a virgin machine.
    //------------------------------------------------------------------------
    {
        CWrapMetaBase& MB = info.meta.m_mbWrap; // this is the MetaBase Wrapper
                                                // its already been openned by
                                                // openMetaDataForWrite

        if ( FALSE == openMetaDataForWrite(info,  FALSE) ) {

           if (ERROR_PATH_NOT_FOUND == HRESULT_CODE( MB.getHRESULT() )) {
            // lets create the path in the metabase, using AddObject.
            // recursively creates a "pathway in the metabase". E.g. assume that you
            // want to make sure that "/LM/W3SVC/CertServers/Microsoft Certificate Server"
            // is in the metabase.  you can open /LM/W3SVC and do a AddKey() on
            // "CertServers/Microsoft Certificate Server" to create that stub.

            // above we set:  info.szMetaBasePath =   szCertServerMetabaseRoot
            // here we will temporarily pretend that our root is at level
            // /LM/W3SVC  which we assume is at the top of szCertServerMetabaseRoot
            // and then call AddKey

            TCHAR  szPath[400];
            TCHAR* szRootPrefix = _T("/LM/W3SVC");
            UINT   nRootPrefixLen = STRLEN(szRootPrefix);
            
            STRCPY(szPath, szCertServerMetabaseRoot);

            if (STRNICMP(szRootPrefix, szPath, nRootPrefixLen) != 0) 
               goto returnFALSE;    // we could not figure out a common Root

            info.szMetaBasePath = szRootPrefix;
            if ( FALSE == openMetaDataForWrite(info) )
               goto returnFALSE;    // we could not open the metabase

            // the metabase path is already position to the proper directory
            // in the MB object.  MB will prepend that path to the subDirectory
            // that we want to create, the following will jump past the trailing
            // '/' separating the root and the rest of the sub-directory
            // e.g. "/CertServers/Microsoft Certificate Server"
            //
            // We dont do any other error checking besides notifying and
            // returning FALSE.
            
            if (FALSE == MB.AddObject( &szPath[nRootPrefixLen] )) {
                NotifyUsers_CouldNotAccessMetaBase( MB.getHRESULT() );
                goto returnFALSE;    // we could not create required path
            }

            // since we are continuing, we reset back our proper path.
            info.szMetaBasePath =   szCertServerMetabaseRoot;
               
           } else {
           
               goto returnFALSE;    // we could not open the metabase
           }
        }



    }

    //------------------------------------------------------------------------
    // Below we dont deal with the XENROLL GUID setting that is for future usage
    // PLUS its not CertServer Related, its Xenroll related.  We dont touch it.
    //------------------------------------------------------------------------
    {

        // lets see if we can do a CoCreateInstance on CertRequest.  If we can not
        // we believe that certServer is not installed and set/clear MB entries
        // The following values are set or cleared:
        //
        //  # define MD_SSL_CERT_WIZGUID_ICERTGETCONFIG ( IIS_MD_SSL_BASE+71 )
        //  # define MD_SSL_CERT_WIZGUID_ICERTREQUEST   ( IIS_MD_SSL_BASE+72 )
        //  # define MD_SSL_CERT_WIZGUID_XENROLL        ( IIS_MD_SSL_BASE+73 ) FUTURE USAGE
        //  # define MD_SSL_CERT_WIZGUID_ICERTCONFIG    ( IIS_MD_SSL_BASE+74 )
        //------------------------------------------------------------------------

        IPtr<ICertConfig, &IID_ICertConfig>  iptr;
        CString  szRemoteDCOMTargetMachine;
       
        // REMEMBER  bRet  returns whether we were able to delete everything
        //                 or set everything that we were wanting to set
        // in both cases assume now that we have success and update bRet when
        // we find errors, we continue as long as possible.  E.g. we add or delete
        // as many entries as possible and return our status value to the caller.

        bRet = TRUE;

           
        if ( (FALSE == bFoundCertSrvRegistryEntries)  ||

             (FALSE == GetICertConfigIPtrFromGuid( iptr, szCertConfigGUID,
                        &szRemoteDCOMTargetMachine)) )
        {
            // remove MB entries!

#ifdef  DEBUGGING
            DODBG  MsgBox( _T("adding CertServer MB entries"));
#endif

            if ( FALSE == openMetaDataForWrite(info) ) {
               goto returnFALSE;    // we could not open the metabase
            }

            //  We just need to blow away the cert info in the metabase
            //  which we do using the meta data wrapper
            // deleting values
            CWrapMetaBase& MB = info.meta.m_mbWrap; // this is the MetaBase Wrapper
                                                    // its already been openned by
                                                    // openMetaDataForWrite
            // try deletes once
            

            // In C++ &&= does not exist. However [bRet &= FALSE;] is OK, but we dont
            // have a uniform single value of TRUE in C/C++ so its not safe to use &=
            // to chain a set of TRUE-value
            //   so we can not do:
            //   bRet &&= MB.DeleteData(  _T(""),
            //                  MD_SSL_CERT_WIZGUID_ICERTGETCONFIG, STRING_METADATA);
            // so we will use a [if (! xxx) bRet=FALSE;]  construct below

            if (! MB.DeleteData(  _T(""),
                      MD_SSL_CERT_WIZGUID_ICERTGETCONFIG, STRING_METADATA))  bRet=FALSE;
            if (! MB.DeleteData(  _T(""),
                      MD_SSL_CERT_WIZGUID_ICERTREQUEST, STRING_METADATA))    bRet=FALSE;
            if (! MB.DeleteData(  _T(""),
                      MD_SSL_CERT_WIZGUID_ICERTCONFIG, STRING_METADATA))     bRet=FALSE;

            MB.Close();

        } else {
            
            CString   szPresentValue;        // used to read the present value
                                             // any metabase value so that we
                                             // can preserve it.

#ifdef  DEBUGGING
            DODBG MsgBox( _T("adding CertServer MB entries"));
#endif

            // add MB entries!   If an entry already exists, leave it alone.

            if (!  GetMetaBaseString ( info, 
                          IN  MD_SSL_CERT_WIZGUID_ICERTREQUEST,
                          IN       szPresentValue ) )
            {
              if (!SetMetaBaseString ( info,
                          IN  MD_SSL_CERT_WIZGUID_ICERTREQUEST,
                          IN       szCertRequestGUID ) )     bRet=FALSE;
            }

            if (!  GetMetaBaseString ( info, 
                          IN  MD_SSL_CERT_WIZGUID_ICERTCONFIG,
                          IN       szPresentValue ) )
            {
              if (!SetMetaBaseString ( info,
                          IN  MD_SSL_CERT_WIZGUID_ICERTCONFIG,
                          IN       szCertConfigGUID ) )      bRet=FALSE;
            }

            if (!  GetMetaBaseString ( info,  
                          IN  MD_SSL_CERT_WIZGUID_ICERTGETCONFIG,
                          IN       szPresentValue ) )
            {
              if (!SetMetaBaseString ( info,
                          IN  MD_SSL_CERT_WIZGUID_ICERTGETCONFIG,
                          IN       szCertGetConfigGUID ) )   bRet=FALSE;
            }

        }

    }
    
  commonReturn:         // this is the common return so that we an set
                        // back the metabase path.  We saved it so that
                        // we can switch to where the GUIDs live: 

    // the following will restore the original [info.szMetaBasePath] value
    // before we switched it to: "/LM/W3SVC/CertServers/..." 
    //
    info.szMetaBasePath =   szSaved_info_szMetaBasePath;

    return(bRet);


  returnFALSE:          // this will cause a FALSE return and do all things
                        // required in our "common return"

    bRet = FALSE;
    goto  commonReturn;   
}
*/

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);

    if (!AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid))
        return ResultFromScode(SELFREG_E_TYPELIB);

    if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))
        return ResultFromScode(SELFREG_E_CLASS);

    return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);

    if (!AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor))
        return ResultFromScode(SELFREG_E_TYPELIB);

    if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
        return ResultFromScode(SELFREG_E_CLASS);

    return NOERROR;
}

BOOL IsLegacyMetabase(IMSAdminBase* pMB)
{
    BOOL bReturn = FALSE;
    CWrapMetaBase mbBase;
    CString szObjectPath = _T("LM/W3SVC/Info");
    DWORD dwMajorVersion = 0;

    BOOL f = mbBase.FInit(pMB);
    if ( !f ) return FALSE;
    
    // open the base object
    f = mbBase.Open( szObjectPath, METADATA_PERMISSION_READ);
    if ( !f )
    {
        return FALSE;
    }

    DWORD dwFlags = METADATA_NO_ATTRIBUTES;
    if (mbBase.GetDword( _T(""), MD_SERVER_VERSION_MAJOR, IIS_MD_UT_SERVER, &dwMajorVersion) )
    {
        if (dwMajorVersion < 6)
        {
            bReturn = TRUE;
        }
    }

    mbBase.Close();
    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\certppg.h ===
// CertPpg.h : Declaration of the CCertmapPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CCertmapPropPage : See CertPpg.cpp.cpp for implementation.

class CCertmapPropPage : public COlePropertyPage
{
    DECLARE_DYNCREATE(CCertmapPropPage)
    DECLARE_OLECREATE_EX(CCertmapPropPage)

// Constructor
public:
    CCertmapPropPage();

// Dialog Data
    //{{AFX_DATA(CCertmapPropPage)
    enum { IDD = IDD_PROPPAGE_CERTMAP };
    CString m_Caption;
    CString m_szPath;
    //}}AFX_DATA

// Implementation
protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
    //{{AFX_MSG(CCertmapPropPage)
        // NOTE - ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\cauthppg.h ===
// CAuthPpg.h : Declaration of the CCertAuthPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CCertAuthPropPage : See CAuthPpg.cpp.cpp for implementation.

class CCertAuthPropPage : public COlePropertyPage
{
    DECLARE_DYNCREATE(CCertAuthPropPage)
    DECLARE_OLECREATE_EX(CCertAuthPropPage)

// Constructor
public:
    CCertAuthPropPage();

// Dialog Data
    //{{AFX_DATA(CCertAuthPropPage)
    enum { IDD = IDD_PROPPAGE_MAPR2 };
        // NOTE - ClassWizard will add data members here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_DATA

// Implementation
protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
    //{{AFX_MSG(CCertAuthPropPage)
        // NOTE - ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\certctl.cpp ===
// CertCtl.cpp : Implementation of the CCertmapCtrl OLE control class.

#include "stdafx.h"
#include "certmap.h"
#include "CertCtl.h"
#include "CertPpg.h"

extern "C"
{
    #include <wincrypt.h>
    #include <schannel.h>
}

// persistence and mapping includes
#include "Iismap.hxx"
#include "Iiscmr.hxx"
#include "WrapMaps.h"

#include "ListRow.h"
#include "ChkLstCt.h"

#include "wrapmb.h"

#include "Map11Pge.h"
#include "MapWPge.h"

//#include <iiscnfg.h>


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CCertmapCtrl, COleControl)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CCertmapCtrl, COleControl)
    //{{AFX_MSG_MAP(CCertmapCtrl)
    //}}AFX_MSG_MAP
    ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CCertmapCtrl, COleControl)
    //{{AFX_DISPATCH_MAP(CCertmapCtrl)
    DISP_FUNCTION(CCertmapCtrl, "SetServerInstance", SetServerInstance, VT_EMPTY, VTS_BSTR)
    DISP_FUNCTION(CCertmapCtrl, "SetMachineName", SetMachineName, VT_EMPTY, VTS_BSTR)
    DISP_STOCKFUNC_DOCLICK()
    DISP_STOCKPROP_FONT()
    DISP_STOCKPROP_ENABLED()
    DISP_STOCKPROP_BORDERSTYLE()
    DISP_STOCKPROP_CAPTION()
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CCertmapCtrl, COleControl)
    //{{AFX_EVENT_MAP(CCertmapCtrl)
    EVENT_STOCK_CLICK()
    EVENT_STOCK_KEYUP()
    //}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

// TODO: Add more property pages as needed.  Remember to increase the count!
BEGIN_PROPPAGEIDS(CCertmapCtrl, 2)
    PROPPAGEID(CCertmapPropPage::guid)
    PROPPAGEID(CLSID_CFontPropPage)
END_PROPPAGEIDS(CCertmapCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CCertmapCtrl, "CERTMAP.CertmapCtrl.1",
    0xbbd8f29b, 0x6f61, 0x11d0, 0xa2, 0x6e, 0x8, 0, 0x2b, 0x2c, 0x6f, 0x32)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CCertmapCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DCertmap =
    { 0xbbd8f299, 0x6f61, 0x11d0, { 0xa2, 0x6e, 0x8, 0, 0x2b, 0x2c, 0x6f, 0x32 } };
const IID BASED_CODE IID_DCertmapEvents =
    { 0xbbd8f29a, 0x6f61, 0x11d0, { 0xa2, 0x6e, 0x8, 0, 0x2b, 0x2c, 0x6f, 0x32 } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwCertmapOleMisc =
    OLEMISC_ACTIVATEWHENVISIBLE |
    OLEMISC_SETCLIENTSITEFIRST  |
    OLEMISC_INSIDEOUT           |
    OLEMISC_CANTLINKINSIDE      |
    OLEMISC_ACTSLIKEBUTTON      |
    OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CCertmapCtrl, IDS_CERTMAP, _dwCertmapOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CCertmapCtrl::CCertmapCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CCertmapCtrl

BOOL CCertmapCtrl::CCertmapCtrlFactory::UpdateRegistry(BOOL bRegister)
    {
    // TODO: Verify that your control follows apartment-model threading rules.
    // Refer to MFC TechNote 64 for more information.
    // If your control does not conform to the apartment-model rules, then
    // you must modify the code below, changing the 6th parameter from
    // afxRegApartmentThreading to 0.

    if (bRegister)
        return AfxOleRegisterControlClass(
            AfxGetInstanceHandle(),
            m_clsid,
            m_lpszProgID,
            IDS_CERTMAP,
            IDB_CERTMAP,
            afxRegApartmentThreading,
            _dwCertmapOleMisc,
            _tlid,
            _wVerMajor,
            _wVerMinor);
    else
        return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
    }


/////////////////////////////////////////////////////////////////////////////
// CCertmapCtrl::CCertmapCtrl - Constructor

CCertmapCtrl::CCertmapCtrl():
    m_fUpdateFont( FALSE ),
    m_hAccel( NULL ),
    m_cAccel( 0 )
    {
    InitializeIIDs(&IID_DCertmap, &IID_DCertmapEvents);
    }


/////////////////////////////////////////////////////////////////////////////
// CCertmapCtrl::~CCertmapCtrl - Destructor

CCertmapCtrl::~CCertmapCtrl()
    {
    if ( m_hAccel )
        DestroyAcceleratorTable( m_hAccel );
    m_hAccel = NULL;
    }


/////////////////////////////////////////////////////////////////////////////
// CCertmapCtrl::OnDraw - Drawing function

void CCertmapCtrl::OnDraw( CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid )
    {
    DoSuperclassPaint(pdc, rcBounds);
/*
    CFont* pOldFont;

    // select the stock font, recording the old one
    pOldFont = SelectStockFont( pdc );

    // do the superclass draw
    DoSuperclassPaint(pdc, rcBounds);

    // restore the old font - sneakily getting the correct font object
    pOldFont = pdc->SelectObject(pOldFont);
    
    // we want the button window to continue drawing in the correct font even
    // when we are not using OnDraw. i.e. when it is being pushed down. This
    // means we need to set the CWnd::SetFont() method.
    if ( m_fUpdateFont )
        {
        m_fUpdateFont = FALSE;
        CWnd::SetFont( pOldFont );
        }

    DoSuperclassPaint(pdc, rcBounds);
*/
    }

/////////////////////////////////////////////////////////////////////////////
// CCertmapCtrl::DoPropExchange - Persistence support

void CCertmapCtrl::DoPropExchange( CPropExchange* pPX )
    {
    ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
    COleControl::DoPropExchange(pPX);
    }


/////////////////////////////////////////////////////////////////////////////
// CCertmapCtrl::OnResetState - Reset control to default state

void CCertmapCtrl::OnResetState()
    {
    COleControl::OnResetState();  // Resets defaults found in DoPropExchange
    }


/////////////////////////////////////////////////////////////////////////////
// CCertmapCtrl message handlers

//---------------------------------------------------------------------------
BOOL CCertmapCtrl::PreCreateWindow(CREATESTRUCT& cs)
    {
    if ( cs.style & WS_CLIPSIBLINGS )
        cs.style ^= WS_CLIPSIBLINGS;
    cs.lpszClass = _T("BUTTON");
    return COleControl::PreCreateWindow(cs);
    }

/////////////////////////////////////////////////////////////////////////////
// CAppsCtrl::IsSubclassedControl - This is a subclassed control

BOOL CCertmapCtrl::IsSubclassedControl()
    {
    return TRUE;
    }


/////////////////////////////////////////////////////////////////////////////
// CAppsCtrl::OnOcmCommand - Handle command messages

LRESULT CCertmapCtrl::OnOcmCommand(WPARAM wParam, LPARAM lParam)
    {
#ifdef _WIN32
    WORD wNotifyCode = HIWORD(wParam);
#else
    WORD wNotifyCode = HIWORD(lParam);
#endif

    return 0;
    }

//---------------------------------------------------------------------------
void CCertmapCtrl::OnClick(USHORT iButton)
    {
    // in case there are any errors, prepare the error string
    CString sz;

    sz.LoadString( IDS_ERR_CERTMAP_TITLE );
    
    // free the existing name, and copy in the new one
    //  tjp:  you should compare if the old name matches the current name
    //        and only then free and malloc the new name -- chances are that
    //        the names are the same +++ all the free/malloc can fragment mem.
    free((void*)AfxGetApp()->m_pszAppName);
    AfxGetApp()->m_pszAppName = _tcsdup(sz);

    // this is the whole purpose of the control
    RunMappingDialog();

    // we are not in the business of telling the host to do
    // something here, so just don't fire anything off.
    COleControl::OnClick(iButton);
    }

//---------------------------------------------------------------------------
void CCertmapCtrl::RunMappingDialog()
    {
    //
    // UNICODE/ANSI conversion - RonaldM
    //
    // prepare the machine name pointer
    USES_CONVERSION;

    OLECHAR * poch = NULL;

    if ( !m_szMachineName.IsEmpty() )
    {
        // allocate the name buffer, no need to free

        poch = T2OLE((LPTSTR)(LPCTSTR)m_szMachineName);

        if ( !poch )
        {
            MessageBeep(0);

            return;
        }
    }
        
    // initialize the metabase wrappings - pass in the name of the target machine
    // if one has been specified

    //
    // Changed to generic metabase wrapper class - RonaldM
    //
    //IMSAdminBase * pMB = FInitMetabaseWrapper( poch );
    //if ( !pMB )

    IMSAdminBase * pMB = NULL;
    if (!FInitMetabaseWrapperEx( poch, &pMB ))
    {
        MessageBeep(0);

        return;
    }

    // the 1:1 mapping and rule-based mapping are panes in a single dialog window.
    // first we must build the propertysheet dialog and add the panes

    // pointers to the pages (construction may throw, so we need to be careful)
    CMap11Page       page11mapping;
    CMapWildcardsPge pageWildMapping;

    // declare the property sheet
    CPropertySheet   propsheet( IDS_MAP_SHEET_TITLE );

    // Things could throw here, so better protect it.
    try
        {
        // if there is nothing in the MB_Path, default to the first instance
        if ( m_szServerInstance.IsEmpty() )
            m_szServerInstance = _T("/LM/W3SVC/1");

        // I am assuming that the last character is NOT a '/' Thus, if that is what is
        // there, we need to remove it. Otherwise, the path gets messed up later
        if ( m_szServerInstance.Right(1) == _T('/') )
            m_szServerInstance = m_szServerInstance.Left( m_szServerInstance.GetLength()-1 );

        // tell the pages about the metabase path property
        page11mapping.m_szMBPath   = m_szServerInstance;
        pageWildMapping.m_szMBPath = m_szServerInstance;

        // do any other initializing of the pages
        page11mapping.FInit(pMB);
        pageWildMapping.FInit(pMB);
        }
    catch ( CException * pException )
        {
        pException->Delete();
        }

    // add the pages to the sheet
    propsheet.AddPage( &page11mapping );
    propsheet.AddPage( &pageWildMapping );

    // turn on help
    propsheet.m_psh.dwFlags |= PSH_HASHELP;
    page11mapping.m_psp.dwFlags |= PSP_HASHELP;
    pageWildMapping.m_psp.dwFlags |= PSP_HASHELP;

    // Things could (potentially maybe) throw here, so better protect it.
    try
        {
        // run the propdsheet dialog
        // let the host container know that we are putting up a modal dialog
        PreModalDialog();
        // run the dialog
        //  tjp:   should we not test the outcome of the dialog?
        //         could the user ESCAPE out of it w/o doing anything?
        propsheet.DoModal();
        // let the host container know we are done with the modality
        PostModalDialog();
        }
    catch ( CException * pException )
        {
        pException->Delete();
        }

    // close the metabase wrappings
    //
    // Changed to generic wrapper -- RonaldM
    FCloseMetabaseWrapperEx(&pMB);
    }

//---------------------------------------------------------------------------
void CCertmapCtrl::SetServerInstance(LPCTSTR szServerInstance)
    {
    m_szServerInstance = szServerInstance;
    }

//---------------------------------------------------------------------------
void CCertmapCtrl::SetMachineName(LPCTSTR szMachine)
    {
    m_szMachineName = szMachine;
    }

//---------------------------------------------------------------------------
void CCertmapCtrl::OnFontChanged()
    {
    m_fUpdateFont = TRUE;
    COleControl::OnFontChanged();
    }


//---------------------------------------------------------------------------
void CCertmapCtrl::OnAmbientPropertyChange(DISPID dispid)
    {
    BOOL    flag;
    UINT    style;

    // do the right thing depending on the dispid
    switch ( dispid )
    {
    case DISPID_AMBIENT_DISPLAYASDEFAULT:
        if ( GetAmbientProperty( DISPID_AMBIENT_DISPLAYASDEFAULT, VT_BOOL, &flag ) )
            {
            style = GetWindowLong(
                    GetSafeHwnd(), // handle of window
                    GWL_STYLE  // offset of value to retrieve
                    );
            if ( flag )
                style |= BS_DEFPUSHBUTTON;
            else
                style ^= BS_DEFPUSHBUTTON;
            SetWindowLong(
                    GetSafeHwnd(), // handle of window
                    GWL_STYLE,  // offset of value to retrieve
                    style
                    );
            Invalidate(TRUE);
            }
        break;
    };

    COleControl::OnAmbientPropertyChange(dispid);
    }

//---------------------------------------------------------------------------
// an important method where we tell the container how to deal with us.
// pControlInfo is passed in by the container, although we are responsible
// for maintining the hAccel structure
void CCertmapCtrl::OnGetControlInfo(LPCONTROLINFO pControlInfo)
    {
    // do a rudimentary check to see if we understand pControlInfo
    if ( !pControlInfo || pControlInfo->cb < sizeof(CONTROLINFO) )
        return;

    // set the accelerator handle into place
    pControlInfo->hAccel = m_hAccel;
    pControlInfo->cAccel = m_cAccel;

    // when we have focus, we do want the enter key
    pControlInfo->dwFlags = CTRLINFO_EATS_RETURN;
    }

//---------------------------------------------------------------------------
// the ole control container object specifically filters out the space
// key so we do not get it as a OnMnemonic call. Thus we need to look
// for it ourselves
void CCertmapCtrl::OnKeyUpEvent(USHORT nChar, USHORT nShiftState)
    {
    if ( nChar == _T(' ') )
        {
        OnClick((USHORT)GetDlgCtrlID());
        }
    COleControl::OnKeyUpEvent(nChar, nShiftState);
    }

//---------------------------------------------------------------------------
void CCertmapCtrl::OnMnemonic(LPMSG pMsg)
    {
    OnClick((USHORT)GetDlgCtrlID());
    COleControl::OnMnemonic(pMsg);
    }

//---------------------------------------------------------------------------
void CCertmapCtrl::OnTextChanged()
    {
    DWORD   i;
    ACCEL   accel;
    BOOL    f;
    BOOL    flag;
    int     iAccel;

    // get the new text
    CString sz = InternalGetText();
    sz.MakeLower();

    // if the handle has already been allocated, free it
    if ( m_hAccel )
        {
        DestroyAcceleratorTable( m_hAccel );
        m_hAccel = NULL;
        m_cAccel = 0;
        }

    // if there is a & character, then declare the accelerator
    iAccel = sz.Find(_T('&'));
    if ( iAccel >= 0 )
        {
        // fill in the accererator record
        accel.fVirt = FALT;
        accel.key = sz.GetAt(iAccel + 1);
        accel.cmd = (USHORT)GetDlgCtrlID();

        m_hAccel = CreateAcceleratorTable( &accel, 1 );
        if ( m_hAccel )
            m_cAccel = 1;
        }

    // finish with the default handling.
    COleControl::OnTextChanged();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\cnfrmpsd.h ===
// CnfrmPsD.h : header file
//
// NOTE that file Passdlg.h is very similar to this
//      file!
//
//       CnfrmPsD class has an OnOK that will complain
//       to the user if the passwds dont match
//       This is above whats in PassDlg class
//
//       And class PassDlg has an OnInitDialog that Cnfrmpsd
//       does not have. This simply puts focus on the edit
//       field for the passwd
//
//
// DConfirmPassDlg.h : header file
//
#ifndef   _CnfrmPsdConfirmPassDlg_h_file_1287_
#define   _CnfrmPsdConfirmPassDlg_h_file_1287_



/////////////////////////////////////////////////////////////////////////////
// CConfirmPassDlg dialog

class CConfirmPassDlg : public CDialog
{
// Construction
public:
    CConfirmPassDlg(CWnd* pParent = NULL);   // standard constructor

    // the original password that we are confirming
    CStrPassword m_szOrigPass;

// Dialog Data
    //{{AFX_DATA(CConfirmPassDlg)
    enum { IDD = IDD_CONFIRM_PASSWORD };
    CStrPassword m_sz_password_new;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CConfirmPassDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CConfirmPassDlg)
    virtual void OnOK();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\crackcrt.cpp ===
// implements the exported CKeyCrackedData

#include "stdafx.h"
#include "CrackCrt.h"

#define CF_CERT_FROM_FILE 2

extern "C"
{
    #include <wincrypt.h>
    #include <schannel.h>
}

//-------------------------------------------------
CCrackedCert:: CCrackedCert()
        : m_pData(NULL)
    {}

//-------------------------------------------------
CCrackedCert::~CCrackedCert()
    {
    PX509Certificate    p509 = (PX509Certificate)m_pData;

    // if the cracked data is there, free it
    if ( p509 ) 
        SslFreeCertificate( (PX509Certificate)m_pData );
    }

//-------------------------------------------------
// adds a key to the service. They CKey object is added to the
// array object below. If this Service is connected to a machine,
// then the key is also added to the tree view below the service.
//-------------------------------------------------
BOOL CCrackedCert::CrackCert( PUCHAR pCert, DWORD cbCert )
    {
    PX509Certificate    p509 = NULL;
    BOOL                f;

    // if there already is a cracked cert, get rid of it
    if ( m_pData )
        {
        SslFreeCertificate( (PX509Certificate)m_pData );
        m_pData = NULL;
        }

    // crack the certificate
    f = SslCrackCertificate( pCert, cbCert, CF_CERT_FROM_FILE, &p509 );

    m_pData = (PVOID)p509;
    return f;
    }

//-------------------------------------------------
// The rest of the methods access the data in the cracked certificate
//-------------------------------------------------
DWORD CCrackedCert::GetVersion()
    {
    ASSERT(m_pData);
    PX509Certificate pCert = (PX509Certificate)m_pData;
    return pCert->Version;
    }

//-------------------------------------------------
// returns a pointer to a DWORD[4]
DWORD* CCrackedCert::PGetSerialNumber()
    {
    ASSERT(m_pData);
    PX509Certificate pCert = (PX509Certificate)m_pData;
    return (DWORD*)&pCert->SerialNumber;
    }

//-------------------------------------------------
int CCrackedCert::GetSignatureAlgorithm()
    {
    ASSERT(m_pData);
    PX509Certificate pCert = (PX509Certificate)m_pData;
    return pCert->SignatureAlgorithm;
    }

//-------------------------------------------------
FILETIME CCrackedCert::GetValidFrom()
    {
    PX509Certificate pCert = (PX509Certificate)m_pData;
    ASSERT(m_pData);
    return pCert->ValidFrom;
    }

//-------------------------------------------------
FILETIME CCrackedCert::GetValidUntil()
    {
    PX509Certificate pCert = (PX509Certificate)m_pData;
    ASSERT(m_pData);
    return pCert->ValidUntil;
    }

//-------------------------------------------------
PVOID CCrackedCert::PSafePublicKey()
    {
    PX509Certificate pCert = (PX509Certificate)m_pData;
    ASSERT(m_pData);
    return pCert->pPublicKey;
    }

//-------------------------------------------------
void CCrackedCert::GetIssuer( CString &sz )
    {
    PX509Certificate pCert = (PX509Certificate)m_pData;
    ASSERT(m_pData);
    sz = pCert->pszIssuer;
    }

//-------------------------------------------------
void CCrackedCert::GetSubject( CString &sz )
    {
    PX509Certificate pCert = (PX509Certificate)m_pData;
    ASSERT(m_pData);
    sz = pCert->pszSubject;
    }

//-------------------------------------------------
// gets a part of the subject's distinguishing information
void CCrackedCert::GetSubjectDN( CString &szDN, LPCTSTR szKey )
    {
    // clear the szDN
    szDN.Empty();

    // start with the dn (aka subject) string
    CString     szSubject;
    GetSubject( szSubject );

    // find the position of the key in the subject
    int cPos = szSubject.Find( szKey );

    // if we got it, get it
    if ( cPos >= 0 )
        {
        szDN = szKey;
        // get the string
        szDN = szSubject.Mid( cPos + szDN.GetLength() );
        // get the comma
        cPos = szDN.Find( _T(',') );
        // truncate at the comma
        if ( cPos >=0 )
            szDN = szDN.Left( cPos );
        }
    }

//-------------------------------------------------
// gets a part of the issuer's distinguishing information
void CCrackedCert::GetIssuerDN( CString &szDN, LPCTSTR szKey )
    {
    // clear the szDN
    szDN.Empty();

    // start with the dn (aka subject) string
    CString     szIssuer;
    GetIssuer( szIssuer );

    // find the position of the key in the subject
    int cPos = szIssuer.Find( szKey );

    // if we got it, get it
    if ( cPos >= 0 )
        {
        szDN = szKey;
        // get the string
        szDN = szIssuer.Mid( cPos + szDN.GetLength() );
        // get the comma
        cPos = szDN.Find( _T(',') );
        // truncate at the comma
        if ( cPos >=0 )
            szDN = szDN.Left( cPos );
        }
    }

//-------------------------------------------------
void CCrackedCert::GetSubjectCountry( CString &sz )
    {
    GetSubjectDN( sz, SZ_KEY_COUNTRY );
    }

//-------------------------------------------------
void CCrackedCert::GetSubjectState( CString &sz )
    {
    GetSubjectDN( sz, SZ_KEY_STATE );
    }

//-------------------------------------------------
void CCrackedCert::GetSubjectLocality( CString &sz )
    {
    GetSubjectDN( sz, SZ_KEY_LOCALITY );
    }

//-------------------------------------------------
void CCrackedCert::GetSubjectCommonName( CString &sz )
    {
    GetSubjectDN( sz, SZ_KEY_COMNAME );
    }

//-------------------------------------------------
void CCrackedCert::GetSubjectOrganization( CString &sz )
    {
    GetSubjectDN( sz, SZ_KEY_ORGANIZATION );
    }

//-------------------------------------------------
void CCrackedCert::GetSubjectUnit( CString &sz )
    {
    GetSubjectDN( sz, SZ_KEY_ORGUNIT );
    }


//-------------------------------------------------
void CCrackedCert::GetIssuerCountry( CString &sz )
    {
    GetIssuerDN( sz, SZ_KEY_COUNTRY );
    }

//-------------------------------------------------
void CCrackedCert::GetIssuerOrganization( CString &sz )
    {
    GetIssuerDN( sz, SZ_KEY_ORGANIZATION );
    }

//-------------------------------------------------
void CCrackedCert::GetIssuerUnit( CString &sz )
    {
    GetIssuerDN( sz, SZ_KEY_ORGUNIT );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\chklstct.cpp ===
// ChkLstCt.cpp : implementation file
//

#include "stdafx.h"
#include "certmap.h"
#include "ListRow.h"
#include "ChkLstCt.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCheckListCtrl

//-----------------------------------------------------------------------------------
CCheckListCtrl::CCheckListCtrl()
    {
    // set the correct start drawing column
    m_StartDrawingCol = 1;
    }

//-----------------------------------------------------------------------------------
CCheckListCtrl::~CCheckListCtrl()
    {
    }


//-----------------------------------------------------------------------------------
BEGIN_MESSAGE_MAP(CCheckListCtrl, CListSelRowCtrl)
    //{{AFX_MSG_MAP(CCheckListCtrl)
        // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCheckListCtrl message handlers

//-----------------------------------------------------------------------------------
void CCheckListCtrl::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct)
    {
    CRect       rcItem = lpDrawItemStruct->rcItem;
    CRect       rcSection;
    UINT        itemID = lpDrawItemStruct->itemID;
    BOOL        f;
    CString     sz;
    LV_COLUMN   colData;

    // setup the CDC object
    CDC         cdc;
    cdc.Attach( lpDrawItemStruct->hDC );

    // clear the columnd buffer
    ZeroMemory( &colData, sizeof(colData) );
    colData.mask = LVCF_WIDTH;


    // get the checkmark bitmap
//  f = m_bitmapCheck.LoadBitmap( IDB_CHECK );


    // First, we draw the "enabled" column Get the data
    // for it first. If there is none, then we can skip it.
    sz = GetItemText( itemID, 0 );
    f = GetColumn( 0, &colData );

    if ( !sz.IsEmpty() )
        {
        // figure out the sectional rect
        rcSection = rcItem;
        rcSection.left += 4;
        rcSection.top += 3;

        rcSection.right = rcSection.left + 9;
        rcSection.bottom = rcSection.top + 9;

        // draw the circle
        cdc.Ellipse( &rcSection );
        rcSection.DeflateRect(1, 1);
        cdc.Ellipse( &rcSection );
        }
    
    cdc.Detach();

    // draw the rest of it
    CListSelRowCtrl::DrawItem( lpDrawItemStruct );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\crackcrt.h ===
class CCrackedCert
    {
    public:
    // constructor
    CCrackedCert();
    ~CCrackedCert();

    // give it a cert to crack. If this object was previously used to
    // crack a key, cleanup is automatically done and the new key is
    // cracked. - NOTE: The target key MUST have either a certificate
    // or a certificate request. Those are what get cracked. A return
    // value of 0 indicates success
    BOOL CrackCert( PUCHAR pCert, DWORD cbCert );

    // The rest of the methods access the data in the cracked certificate
    DWORD       GetVersion();
    DWORD*      PGetSerialNumber(); // returns a pointer to a DWORD[4]
    int         GetSignatureAlgorithm();
    FILETIME    GetValidFrom();
    FILETIME    GetValidUntil();
    PVOID       PSafePublicKey();

    void        GetIssuer( CString &sz );
    void        GetIssuerCountry( CString &sz );
    void        GetIssuerOrganization( CString &sz );
    void        GetIssuerUnit( CString &sz );

    void        GetSubject( CString &sz );
    void        GetSubjectCountry( CString &sz );
    void        GetSubjectState( CString &sz );
    void        GetSubjectLocality( CString &sz );
    void        GetSubjectCommonName( CString &sz );
    void        GetSubjectOrganization( CString &sz );
    void        GetSubjectUnit( CString &sz );

    protected:

    // string constants for distinguishing names. Not to be localized
    #define     SZ_KEY_COUNTRY          _T("C=")
    #define     SZ_KEY_STATE            _T("S=")
    #define     SZ_KEY_LOCALITY         _T("L=")
    #define     SZ_KEY_ORGANIZATION     _T("O=")
    #define     SZ_KEY_ORGUNIT          _T("OU=")
    #define     SZ_KEY_COMNAME          _T("CN=")

    private:
    void        GetSubjectDN( CString &szDN, LPCTSTR szKey );
    void        GetIssuerDN( CString &szDN, LPCTSTR szKey );


    // declare the x509 pointer as void so that the
    // files instantiating this don't have to include wincrypt
    PVOID       m_pData;
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\crtmapd.h ===
// CrtMapD.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// C1To1CertMappingDlg dialog

class C1To1CertMappingDlg : public CPropertyPage
{
// Construction
public:
    C1To1CertMappingDlg(CWnd* pParent = NULL);  // standard constructor
    ~C1To1CertMappingDlg();                     // standard desstructor

    BOOL    FInitMapper();

    virtual BOOL OnApply();
    virtual BOOL OnInitDialog();

// Dialog Data
    //{{AFX_DATA(C1To1CertMappingDlg)
    enum { IDD = IDD_11CERT_MAPPING };
    CComboBox   m_ccombo_authorities;
    CButton m_cbutton_chooseaccnt;
    CButton m_cbutton_delete;
    CListCtrl   m_clistctrl_list;
    int     m_int_authorities;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(C1To1CertMappingDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(C1To1CertMappingDlg)
    afx_msg void OnChooseAccount();
    afx_msg void OnAdd();
    afx_msg void OnDelete();
    afx_msg void OnItemchangedList(NMHDR* pNMHDR, LRESULT* pResult);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    // internal utilities
    BOOL FInitMappingList();
    BOOL FInitAuthorityComboBox();

    // iMap is the mapping's index into the main mapper object. It gets saved as the private
    // data in the list item. Returns success or failure
    BOOL FAddMappingToList( CCert11Mapping* pMap, DWORD iMap );

    BOOL FEditOneMapping( CCert11Mapping* pMap );
    void EditManyMappings();
    void UpdateMappingInDispList( DWORD iList, CCert11Mapping* pMap );

    // reads a named certificate file from the disk. This is the same sort of cert file
    // that is passed around by the keyring application. In fact, this routine is defined
    // in its own source file and is largly lifted from the keyring app. AddCert.cpp
    BOOL FAddCertificateFile( CString szFile );
    BOOL FAddCertificate( PUCHAR pCertificate, DWORD cbCertificate );

    // convert a binary data thing to a distinguished name
    BOOL FBuildNameString( PUCHAR pBData, DWORD cbBData, CString &szDN );
    BOOL BuildRdnList( PNAME_INFO pNameInfo, CString &szDN );
    LPSTR MapAsnName( LPSTR pAsnName );



    // state utilities
    void EnableDependantButtons();

    // its mapper
    CIisCert11Mapper    m_mapper;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\ddxvlocal.cpp ===
#include "stdafx.h"
#include "strpass.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif
#define new DEBUG_NEW

void AFXAPI 
DDX_Text_SecuredString(CDataExchange * pDX, int nIDC, CStrPassword & value)
{
    HWND hWndCtrl = pDX->PrepareEditCtrl(nIDC);

    if (pDX->m_bSaveAndValidate)
    {
        // get the value from the UI if we need to
        if (!::SendMessage(hWndCtrl, EM_GETMODIFY, 0, 0))
        {
            return;
        }

        CString strNew;
        int nLen = ::GetWindowTextLength(hWndCtrl);
        ::GetWindowText(hWndCtrl, strNew.GetBufferSetLength(nLen), nLen + 1);
        strNew.ReleaseBuffer();

        value = (LPCTSTR) strNew;
    }
    else
    {
        //
        // set the value in the UI if we need to
        //
        if (!value.IsEmpty())
        {
            TCHAR * pszPassword = NULL;
            pszPassword = value.GetClearTextPassword();
            if (pszPassword)
            {
                ::SetWindowText(hWndCtrl,pszPassword);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\cnfrmpsd.cpp ===
// CnfrmPsD.cpp : implementation file
//
// NOTE that file Passdlg.h/cpp is very similar to this
//      file!
//
//       CnfrmPsD class has an OnOK that will complain
//       to the user if the passwds dont match
//       This is above whats in PassDlg class
//
//       And class PassDlg has an OnInitDialog that Cnfrmpsd
//       does not have. This simply puts focus on the edit
//       field for the passwd
//
#include "stdafx.h"
#include "certmap.h"
#include "CnfrmPsD.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CConfirmPassDlg dialog

CConfirmPassDlg::CConfirmPassDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CConfirmPassDlg::IDD, pParent)
    {
    //{{AFX_DATA_INIT(CConfirmPassDlg)
    m_sz_password_new = _T("");
    //}}AFX_DATA_INIT
    }

void CConfirmPassDlg::DoDataExchange(CDataExchange* pDX)
    {
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CConfirmPassDlg)
    //DDX_Text(pDX, IDC_CONFIRM_PASSWORD, m_sz_password_new);
    DDX_Text_SecuredString(pDX, IDC_CONFIRM_PASSWORD, m_sz_password_new);
    //}}AFX_DATA_MAP
    }

BEGIN_MESSAGE_MAP(CConfirmPassDlg, CDialog)
    //{{AFX_MSG_MAP(CConfirmPassDlg)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConfirmPassDlg message handlers

void CConfirmPassDlg::OnOK() 
    {
    UpdateData( TRUE );

    // confirm it
    if ( m_sz_password_new != m_szOrigPass )
        {
        AfxMessageBox( IDS_PASS_CONFIRM_FAIL );
        return;
        }

    CDialog::OnOK();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\chklstct.h ===
// ChkLstCt.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCheckListCtrl window

class CCheckListCtrl : public CListSelRowCtrl
{
// Construction
public:
    CCheckListCtrl();

    virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CCheckListCtrl)
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CCheckListCtrl();

    // Generated message map functions
protected:
    //{{AFX_MSG(CCheckListCtrl)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\ddxvlocal.h ===
#include "strpass.h"

#ifndef _DDXV_LOCAL_H_
#define _DDXV_LOCAL_H_

void AFXAPI 
DDX_Text_SecuredString(CDataExchange * pDX, int nIDC, CStrPassword & value);


#endif // _DDXV_LOCAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\ed11maps.h ===
// Ed11Maps.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CEdit11Mappings dialog

class CEdit11Mappings : public CNTBrowsingDialog
{
// Construction
public:
    CEdit11Mappings(CWnd* pParent = NULL);   // standard constructor

    // overrides
    virtual void OnOK();

// Dialog Data
    //{{AFX_DATA(CEdit11Mappings)
    enum { IDD = IDD_MAP_TO_ACCNT };
    int     m_int_enable;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CEdit11Mappings)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CEdit11Mappings)
    afx_msg void OnBtnHelp();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\editruld.h ===
// EditRulD.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CEditWildcardRuleDlg dialog

class CEditWildcardRuleDlg : public CDialog
{
// Construction
public:
    CEditWildcardRuleDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CEditWildcardRuleDlg)
    enum { IDD = IDD_WILDCARDS_2 };
        // NOTE: the ClassWizard will add data members here
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CEditWildcardRuleDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CEditWildcardRuleDlg)
    afx_msg void OnSelectIssuer();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\edtone11.cpp ===
// EdtOne11.cpp : implementation file
//

#include "stdafx.h"
#include "certmap.h"

#include "brwsdlg.h"
#include "EdtOne11.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CEditOne11MapDlg dialog

CEditOne11MapDlg::CEditOne11MapDlg(CWnd* pParent /*=NULL*/)
        : CNTBrowsingDialog(CEditOne11MapDlg::IDD, pParent)
        {
        //{{AFX_DATA_INIT(CEditOne11MapDlg)
        m_sz_mapname = _T("");
        m_bool_enable = FALSE;
        //}}AFX_DATA_INIT
        }

void CEditOne11MapDlg::DoDataExchange(CDataExchange* pDX)
        {
        //{{AFX_DATA_MAP(CEditOne11MapDlg)
        DDX_Text(pDX, IDC_MAPNAME, m_sz_mapname);
        DDV_MaxChars(pDX, m_sz_mapname, 60);
        DDX_Check(pDX, IDC_ENABLE, m_bool_enable);
    //}}AFX_DATA_MAP
        CNTBrowsingDialog::DoDataExchange(pDX);
        }

BEGIN_MESSAGE_MAP(CEditOne11MapDlg, CNTBrowsingDialog)
        //{{AFX_MSG_MAP(CEditOne11MapDlg)
    ON_BN_CLICKED(IDC_BTN_HELP, OnBtnHelp)
    //}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,  OnBtnHelp)
    ON_COMMAND(ID_HELP,         OnBtnHelp)
    ON_COMMAND(ID_CONTEXT_HELP, OnBtnHelp)
    ON_COMMAND(ID_DEFAULT_HELP, OnBtnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEditOne11MapDlg message handlers

//---------------------------------------------------------------------------
// make sure that the selected NT acount is, in fact, a valid account
//
void CEditOne11MapDlg::OnOK()
        {
        // update the data
        UpdateData( TRUE );

        // it is valid
        CNTBrowsingDialog::OnOK();
        }

//---------------------------------------------------------------------------
void CEditOne11MapDlg::OnBtnHelp() 
    {
    WinHelpDebug(HIDD_CERTMAP_BASIC_MAP_ONE);
    WinHelp( HIDD_CERTMAP_BASIC_MAP_ONE );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\ed11maps.cpp ===
// Ed11Maps.cpp : implementation file
//

#include "stdafx.h"
#include "certmap.h"
#include "brwsdlg.h"
#include "Ed11Maps.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEdit11Mappings dialog
CEdit11Mappings::CEdit11Mappings(CWnd* pParent /*=NULL*/)
    : CNTBrowsingDialog(CEdit11Mappings::IDD, pParent)
    {
    //{{AFX_DATA_INIT(CEdit11Mappings)
    m_int_enable = FALSE;
    //}}AFX_DATA_INIT
    }


void CEdit11Mappings::DoDataExchange(CDataExchange* pDX)
    {
    CNTBrowsingDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CEdit11Mappings)
    DDX_Check(pDX, IDC_ENABLE, m_int_enable);
    //}}AFX_DATA_MAP
    }


BEGIN_MESSAGE_MAP(CEdit11Mappings, CNTBrowsingDialog)
    //{{AFX_MSG_MAP(CEdit11Mappings)
    ON_BN_CLICKED(IDC_BTN_HELP, OnBtnHelp)
    //}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,  OnBtnHelp)
    ON_COMMAND(ID_HELP,         OnBtnHelp)
    ON_COMMAND(ID_CONTEXT_HELP, OnBtnHelp)
    ON_COMMAND(ID_DEFAULT_HELP, OnBtnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEdit11Mappings message handlers


//---------------------------------------------------------------------------
void CEdit11Mappings::OnOK()
    {
    UpdateData( TRUE ); 
    // call the superclass ok
    CNTBrowsingDialog::OnOK();
    }

//---------------------------------------------------------------------------
void CEdit11Mappings::OnBtnHelp() 
    {
    WinHelpDebug(HIDD_CERTMAP_BASIC_MAP_MANY);
    WinHelp( HIDD_CERTMAP_BASIC_MAP_MANY );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\edtrulel.cpp ===
// EdtRulEl.cpp : implementation file
//

#include "stdafx.h"
#include "certmap.h"
#include "EdtRulEl.h"

extern "C"
{
    #include <wincrypt.h>
    #include <schannel.h>
}

#include "Iismap.hxx"
#include "Iiscmr.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEditRuleElement dialog


//---------------------------------------------------------------------------
CEditRuleElement::CEditRuleElement(CWnd* pParent /*=NULL*/)
    : CDialog(CEditRuleElement::IDD, pParent)
    {
    //{{AFX_DATA_INIT(CEditRuleElement)
    m_sz_criteria = _T("");
    m_int_field = -1;
    m_sz_subfield = _T("");
    m_bool_match_case = FALSE;
    //}}AFX_DATA_INIT
    }


//---------------------------------------------------------------------------
void CEditRuleElement::DoDataExchange(CDataExchange* pDX)
    {
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CEditRuleElement)
    DDX_Control(pDX, IDC_SUBFIELD, m_ccombobox_subfield);
    DDX_Control(pDX, IDC_FIELDS, m_ccombobox_field);
    DDX_Text(pDX, IDC_CRITERIA, m_sz_criteria);
    DDX_CBIndex(pDX, IDC_FIELDS, m_int_field);
    DDX_CBString(pDX, IDC_SUBFIELD, m_sz_subfield);
    DDX_Check(pDX, IDC_CHK_CAPITALIZATION, m_bool_match_case);
    //}}AFX_DATA_MAP
    }


//---------------------------------------------------------------------------
BEGIN_MESSAGE_MAP(CEditRuleElement, CDialog)
    //{{AFX_MSG_MAP(CEditRuleElement)
    ON_CBN_SELCHANGE(IDC_FIELDS, OnSelchangeFields)
    ON_EN_CHANGE(IDC_SUBFIELD, OnChangeSubfield)
    ON_BN_CLICKED(IDC_BTN_HELP, OnBtnHelp)
    //}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,  OnBtnHelp)
    ON_COMMAND(ID_HELP,         OnBtnHelp)
    ON_COMMAND(ID_CONTEXT_HELP, OnBtnHelp)
    ON_COMMAND(ID_DEFAULT_HELP, OnBtnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEditRuleElement message handlers

//---------------------------------------------------------------------------
BOOL CEditRuleElement::OnInitDialog()
    {
    CString     sz;

    // call the parental oninitdialog
    BOOL f = CDialog::OnInitDialog();

    // initialize the elements in the drop-list
    // loop the list of CERT_FIELD_IDs, adding each to the drop-list
    for ( UINT id = CERT_FIELD_ISSUER; id < CERT_FIELD_LAST; id++ )
        {
        // bug 154957 requests that we no longer support mapping on the
        // serial number. This makes sense anyway as mapping to the serial
        // numbers is better off done as 1::1 mapping. If the bug doesn't
        // make this conclusion clear enough upon reading, it is the
        // interpretation that MikeHow has handed down.
        if ( id == CERT_FIELD_SERIAL_NUMBER )
            continue;

        // get the string associated with the id
        sz = MapIdToField( (CERT_FIELD_ID)id );
        m_ccombobox_field.AddString( sz );
        }

    // initialize the list of known subfields

    id = 0;

    //
    // UNICODE conversion -- RonaldM
    //
    LPCSTR  psz;
    while ( psz = EnumerateKnownSubFields(id) )
        {
        CString str(psz);
        // append it to the drop-list
        m_ccombobox_subfield.AddString( str );

        // increment id
        id++;
        }

    UpdateData( FALSE );

    // store the initial value of the sub-field
    m_szTempSubStorage = m_sz_subfield;

    // make sure to check the subfields
    OnSelchangeFields();
    
    // return the answer
    return f;
    }

//---------------------------------------------------------------------------
// make sure that, if there is a sub-field, that it is valid
// 
void CEditRuleElement::OnOK() 
    {
    UpdateData( TRUE );

    //
    // UNICODE/ANSI conversion - RonaldM
    //
    USES_CONVERSION;

    // test the sub-field flag for the newly selected field type
    DWORD   flags = GetIdFlags( (CERT_FIELD_ID)m_int_field );
    BOOL    fSubs = flags & CERT_FIELD_FLAG_CONTAINS_SUBFIELDS;

    // if there are sub-fields, test their validity
    if ( fSubs )
        {
        CString szTest(MapSubFieldToAsn1( T2A((LPTSTR)(LPCTSTR)m_sz_subfield) ));
        // if there is NO match, tell the user
        if ( szTest.IsEmpty() )
            {
            AfxMessageBox( IDS_INVALID_SUBFIELD );
            return;
            }
        }

    // it is valid
    CDialog::OnOK();
    }

//---------------------------------------------------------------------------
void CEditRuleElement::OnSelchangeFields() 
    {
    UpdateData( TRUE );

    // test the sub-field flag for the newly selected field type
    DWORD   flags = GetIdFlags( (CERT_FIELD_ID)m_int_field );
    BOOL    fSubs = flags & CERT_FIELD_FLAG_CONTAINS_SUBFIELDS;

    // set the correct enable state
    BOOL    fWasEnabled = m_ccombobox_subfield.EnableWindow( fSubs );

    // restore the value if necessary
    if ( fSubs )
        {
        m_sz_subfield = m_szTempSubStorage;
        UpdateData( FALSE );
        }
    else
        {
        m_szTempSubStorage = m_sz_subfield;
        m_sz_subfield.Empty();
        UpdateData( FALSE );
        }
    }

//---------------------------------------------------------------------------
void CEditRuleElement::OnChangeSubfield() 
    {
    m_szTempSubStorage = m_sz_subfield;
    }

//---------------------------------------------------------------------------
void CEditRuleElement::OnBtnHelp() 
    {
    WinHelpDebug( HIDD_CERTMAP_RUL_ELEMENT );
    WinHelp( HIDD_CERTMAP_RUL_ELEMENT );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\edtone11.h ===
// EdtOne11.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CEditOne11MapDlg dialog

class CEditOne11MapDlg : public CNTBrowsingDialog
{
// Construction
public:
    CEditOne11MapDlg(CWnd* pParent = NULL);   // standard constructor
    virtual void OnOK();


// Dialog Data
    //{{AFX_DATA(CEditOne11MapDlg)
    enum { IDD = IDD_MAP_ONE_TO_ACCNT };
    CString m_sz_mapname;
    BOOL    m_bool_enable;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CEditOne11MapDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CEditOne11MapDlg)
    afx_msg void OnBtnHelp();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\helpmap.h ===
// header file that equates to the helpmap file.
// these mappings are hand-made so as not to collide
// with other mappings made in other projects that
// all use the main help file

#define HIDD_CERTMAP_MAIN_BASIC                 0x50100
#define HIDD_CERTMAP_BASIC_MAP_ONE              0x50101
#define HIDD_CERTMAP_BASIC_MAP_MANY             0x50102

#define HIDD_CERTMAP_MAIN_ADVANCED              0x50110
#define HIDD_CERTMAP_ADV_RUL_GENERAL            0x50111
#define HIDD_CERTMAP_ADV_RUL_RULES              0x50112
#define HIDD_CERTMAP_ADV_RUL_MAPPING            0x50113
#define HIDD_CERTMAP_RUL_ELEMENT                0x50114
#define HIDD_CERTMAP_SELECT_ISSUERS             0x50115
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\edwldrul.cpp ===
// EdWldRul.cpp : implementation file
//

#include "stdafx.h"
#include <iadmw.h>

#include "ListRow.h"
#include "ChkLstCt.h"
extern "C"
    {
    #include <wincrypt.h>
    #include <schannel.h>
    }
#include "Iismap.hxx"
#include "Iiscmr.hxx"

#include "brwsdlg.h"
#include "certmap.h"
#include "EdWldRul.h"
#include "EdtRulEl.h"
#include "IssueDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#define ACCESS_DENY         0
#define ACCESS_ACCEPT       1

#define MATCH_ISSUER_ALL    0
#define MATCH_ISSUER_SOME   1


#define COL_CERT_FIELD          0
#define COL_SUB_FIELD           1
#define COL_MATCH_CRITERIA      2


// notes on the list:
// the list is the only source of current data for the rule elements. The actual
// rule object is not updated with changes in the list until the user hits IDOK.
// that way we can cancel without changing the object. All mapping between the
// text in the list and the binary formats used by the server are done at the
// beginning and end of the dialog


/////////////////////////////////////////////////////////////////////////////
// CEditWildcardRule dialog

//---------------------------------------------------------------------------
CEditWildcardRule::CEditWildcardRule(IMSAdminBase* pMB, CWnd* pParent /*=NULL*/)
    : CNTBrowsingDialog(CEditWildcardRule::IDD, pParent),
    m_pMB(pMB)
    {
    //{{AFX_DATA_INIT(CEditWildcardRule)
    m_sz_description = _T("");
    m_bool_enable = FALSE;
    m_int_MatchAllIssuers = -1;
    m_int_DenyAccess = -1;
    //}}AFX_DATA_INIT
    }

//---------------------------------------------------------------------------
void CEditWildcardRule::DoDataExchange(CDataExchange* pDX)
    {
    CNTBrowsingDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CEditWildcardRule)
    DDX_Control(pDX, IDC_EDIT, m_cbutton_edit);
    DDX_Control(pDX, IDC_DELETE, m_cbutton_delete);
    DDX_Control(pDX, IDC_NEW, m_cbutton_new);
    DDX_Control(pDX, IDC_LIST, m_clistctrl_list);
    DDX_Text(pDX, IDC_DESCRIPTION, m_sz_description);
    DDX_Check(pDX, IDC_ENABLE_RULE, m_bool_enable);
    DDX_Radio(pDX, IDC_ALL_ISSUERS, m_int_MatchAllIssuers);
    DDX_Radio(pDX, IDC_REFUSE_LOGON, m_int_DenyAccess);
    //}}AFX_DATA_MAP
    }

//---------------------------------------------------------------------------
BEGIN_MESSAGE_MAP(CEditWildcardRule, CNTBrowsingDialog)
    //{{AFX_MSG_MAP(CEditWildcardRule)
    ON_NOTIFY(NM_DBLCLK, IDC_LIST, OnDblclkList)
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST, OnItemchangedList)
    ON_BN_CLICKED(IDC_EDIT, OnEdit)
    ON_BN_CLICKED(IDC_NEW, OnNew)
    ON_BN_CLICKED(IDC_DELETE, OnDelete)
    ON_BN_CLICKED(IDC_SELECT_ISSUER, OnSelectIssuer)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//---------------------------------------------------------------------------
BOOL CEditWildcardRule::FInitRulesList()
    {
    CString sz;
    int     i;

    // setup the main field
    sz.LoadString( IDS_CERT_FIELD );

    i = m_clistctrl_list.InsertColumn( COL_CERT_FIELD, sz, LVCFMT_LEFT, 100 );

    // setup the sub field
    sz.LoadString( IDS_SUB_FIELD );

    i = m_clistctrl_list.InsertColumn( COL_SUB_FIELD, sz, LVCFMT_LEFT, 70 );

    // setup the match criteria column
    sz.LoadString( IDS_MATCH_CRITERIA );

    i = m_clistctrl_list.InsertColumn( COL_MATCH_CRITERIA, sz, LVCFMT_LEFT, 255 );

    return TRUE;
    }

//---------------------------------------------------------------------------
BOOL CEditWildcardRule::FillRulesList()
    {
    CERT_FIELD_ID   idCertField;
    LPBYTE          pContent;
    DWORD           cbContent;
    LPSTR           psz;

    CString         sz;
    int             i;

    // get the number of subfield rules
    DWORD cbRules = m_pRule->GetRuleElemCount();

    // loop the elements, adding each to the list
    for ( DWORD j = 0; j < cbRules; j++ )
        {
        // get the raw data for the rule element
        if ( !m_pRule->GetRuleElem( j, &idCertField, (PCHAR*)&pContent, &cbContent, &psz ) )
            continue;       // the call failed - try the next

        // start converting the data into readable form and adding it to the list
        sz = MapIdToField( idCertField );
        // create the new entry in the list box.
        i = m_clistctrl_list.InsertItem( j, sz );

        // add the subfield data
        sz = MapAsn1ToSubField( psz );
        m_clistctrl_list.SetItemText( i, COL_SUB_FIELD, sz );

        // add the content data - reuse the psz pointer
        if ( BinaryToMatchRequest( pContent, cbContent, &psz ) )
            m_clistctrl_list.SetItemText( i, COL_MATCH_CRITERIA, psz );

        // finally, attach the id cert field as user data to the item
        m_clistctrl_list.SetItemData( i, idCertField );
        }

        return TRUE;
    }

// editing and updating

//---------------------------------------------------------------------------
void CEditWildcardRule::EnableDependantButtons()
    {
    // the whole purpose of this routine is to gray or activate
    // the edit and delete buttons depending on whether or not anything
    // is selected. So start by getting the selection count
    UINT    cItemsSel = m_clistctrl_list.GetSelectedCount();

    if ( cItemsSel > 0 )
        {
        // there are items selected
        m_cbutton_edit.EnableWindow( TRUE );
        m_cbutton_delete.EnableWindow( TRUE );
        }
    else
        {
        // nope. Nothing selected
        m_cbutton_edit.EnableWindow( FALSE );
        m_cbutton_delete.EnableWindow( FALSE );
        }

    // always enable the new button
    m_cbutton_new.EnableWindow( TRUE );
}

//---------------------------------------------------------------------------
BOOL CEditWildcardRule::EditRule( DWORD iList )
    {
    // declare the editing dialog
    CEditRuleElement    editDlg;

    // fill in its data
    editDlg.m_int_field = m_clistctrl_list.GetItemData( iList );
    editDlg.m_sz_subfield = m_clistctrl_list.GetItemText( iList, COL_SUB_FIELD );
    editDlg.m_sz_criteria = m_clistctrl_list.GetItemText( iList, COL_MATCH_CRITERIA );

    // run the dialog
    if ( editDlg.DoModal() == IDOK )
        {
        // must convert the field into a string too
        CERT_FIELD_ID id = (CERT_FIELD_ID)editDlg.m_int_field;
        CString sz = MapIdToField( id );
        m_clistctrl_list.SetItemText( iList, COL_CERT_FIELD, sz );

        m_clistctrl_list.SetItemData( iList, id );
        m_clistctrl_list.SetItemText( iList, COL_SUB_FIELD, editDlg.m_sz_subfield );
        m_clistctrl_list.SetItemText( iList, COL_MATCH_CRITERIA, editDlg.m_sz_criteria );
        }
    return TRUE;
    }

/////////////////////////////////////////////////////////////////////////////
// CEditWildcardRule message handlers

//---------------------------------------------------------------------------
BOOL CEditWildcardRule::OnInitDialog()
    {
    // call the parental oninitdialog
    BOOL f = CNTBrowsingDialog::OnInitDialog();

    // set the easy default strings 
    m_sz_accountname = m_pRule->GetRuleAccount();   // managed by CNTBrowsingDialog from here on
    m_sz_description = m_pRule->GetRuleName();
    m_bool_enable = m_pRule->GetRuleEnabled();

    // set up the deny access radio buttons
    if ( m_pRule->GetRuleDenyAccess() )
        m_int_DenyAccess = ACCESS_DENY;
    else
        m_int_DenyAccess = ACCESS_ACCEPT;

    // set up the match issuer buttons
    if ( m_pRule->GetMatchAllIssuer() )
        m_int_MatchAllIssuers = MATCH_ISSUER_ALL;
    else
        m_int_MatchAllIssuers = MATCH_ISSUER_SOME;

    // initialize the list
    FInitRulesList();
    FillRulesList();
    EnableDependantButtons();

    // initialize the password
    CString csTempPassword;
    csTempPassword = m_pRule->GetRulePassword();
    m_sz_password = csTempPassword;

    // exchange the data
    UpdateData( FALSE );

    // return the answer
    return f;
    }

//---------------------------------------------------------------------------
// this is the part where we fill in most of the items
void CEditWildcardRule::OnOK() 
    {
    CERT_FIELD_ID   id;
    CString         szSub, sz;
    LPBYTE          pbBin;
    DWORD           cbBin;
    UINT            cItems;
    UINT            iItem;


    // update the data
    UpdateData( TRUE );

    //======== store the rule elements
    // start by resetting the entire rule - that way we don't have to
    // mess with individual elements in the list, allowing us to cancel. 
    // But that is ok, because we can just spin through
    // the ones in the list very quickly and re-add them

    // remove the existing elements from the list.
    cItems = m_pRule->GetRuleElemCount();
    for ( iItem = 0; iItem < cItems; iItem++ )
        m_pRule->DeleteRuleElem( 0 );

    // add all the items in the list
    cItems = m_clistctrl_list.GetItemCount();
    for ( iItem = 0; iItem < cItems; iItem++ )
        {
        // prepare the field id
        id = (CERT_FIELD_ID)m_clistctrl_list.GetItemData( iItem );

        // prepare the subfield
        sz = m_clistctrl_list.GetItemText(iItem, COL_SUB_FIELD);
        szSub = MapSubFieldToAsn1( (PCHAR)(LPCSTR)sz );

        // prepare the data
        sz = m_clistctrl_list.GetItemText(iItem, COL_MATCH_CRITERIA);
        if ( !MatchRequestToBinary((PCHAR)(LPCSTR)sz, &pbBin, &cbBin) )
            continue;

        // add the element to the rule
        m_pRule->AddRuleElem( 0xffffffff, id, (PCHAR)(LPCSTR)szSub, pbBin, cbBin );

        // free the binary match data
        FreeMatchConversion( pbBin );
        }

    // set the easy data
    m_pRule->SetRuleName( (PCHAR)(LPCSTR)m_sz_description );
    m_pRule->SetRuleEnabled( m_bool_enable );

    // store the deny access radio buttons
    m_pRule->SetRuleDenyAccess( m_int_DenyAccess == ACCESS_DENY );

    // store the match issuer buttons
    m_pRule->SetMatchAllIssuer( m_int_MatchAllIssuers == MATCH_ISSUER_ALL );

    
    // we have to set the account name into place here
    m_pRule->SetRuleAccount( (PCHAR)(LPCSTR)m_sz_accountname );

    // store the password
    CString csTempPassword;
    m_sz_password.CopyTo(csTempPassword);
    m_pRule->SetRulePassword( (PCHAR)(LPCSTR)csTempPassword );

    // it is valid
    CNTBrowsingDialog::OnOK();
    }

//---------------------------------------------------------------------------
void CEditWildcardRule::OnDblclkList(NMHDR* pNMHDR, LRESULT* pResult) 
    {
    *pResult = 0;
    // if something in the list was double clicked, edit it
    if ( m_clistctrl_list.GetSelectedCount() > 0 )
        OnEdit();
    }

//---------------------------------------------------------------------------
void CEditWildcardRule::OnItemchangedList(NMHDR* pNMHDR, LRESULT* pResult) 
    {
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
    *pResult = 0;

    // enable the correct items
    EnableDependantButtons();
    }

//---------------------------------------------------------------------------
void CEditWildcardRule::OnEdit() 
    {
    ASSERT( m_clistctrl_list.GetSelectedCount() == 1 );
    DWORD           iList;

    // get index of the selected list item
    iList = m_clistctrl_list.GetNextItem( -1, LVNI_SELECTED );
    ASSERT( iList >= 0 );

    // edit the item
    EditRule( iList );
    }

//---------------------------------------------------------------------------
// actually very similar to editing an existing element
void CEditWildcardRule::OnNew() 
    {
    // declare the editing dialog
    CEditRuleElement    editDlg;

    // fill in its data
    editDlg.m_int_field = CERT_FIELD_SUBJECT;
//  editDlg.m_sz_subfield = MapAsn1ToSubField( "O" );
    editDlg.m_sz_subfield = "O";
    
    editDlg.m_sz_criteria.LoadString( IDS_WILDSTRING );

    // run the dialog
    if ( editDlg.DoModal() == IDOK )
        {
        // get the index for adding to the end of the list
        int iEnd = m_clistctrl_list.GetItemCount();

        // Start with the cert field
        CERT_FIELD_ID id = (CERT_FIELD_ID)editDlg.m_int_field;
        CString sz = MapIdToField( id );
        int i = m_clistctrl_list.InsertItem( iEnd, sz );

        m_clistctrl_list.SetItemData( i, id );
        m_clistctrl_list.SetItemText( i, COL_SUB_FIELD, editDlg.m_sz_subfield );
        m_clistctrl_list.SetItemText( i, COL_MATCH_CRITERIA, editDlg.m_sz_criteria );
        }
    }

//---------------------------------------------------------------------------
void CEditWildcardRule::OnDelete() 
    {
    ASSERT( m_clistctrl_list.GetSelectedCount() == 1 );
    DWORD           iList;

    // get index of the selected list item
    iList = m_clistctrl_list.GetNextItem( -1, LVNI_SELECTED );
    ASSERT( iList >= 0 );

    // delete the item from the display list
    m_clistctrl_list.DeleteItem ( iList );
    }

//---------------------------------------------------------------------------
// simple - just run the issuer dialog
void CEditWildcardRule::OnSelectIssuer() 
    {
    CSelectIssuersDlg   dlg(m_pMB);

    // prep the dialog
    dlg.m_pRule = m_pRule;
    dlg.m_szMBPath = m_szMBPath;

    dlg.m_sz_caption.LoadString( IDS_MATCH_ON_ISSUERS );

    // run it
    if ( dlg.DoModal() == IDOK )
        {
        UpdateData( TRUE );
        m_int_MatchAllIssuers = MATCH_ISSUER_SOME;
        UpdateData( FALSE );
        }
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\edwldrul.h ===
// EdWldRul.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CEditWildcardRule dialog

class CEditWildcardRule : public CNTBrowsingDialog
{
// Construction
public:
    CEditWildcardRule(IMSAdminBase* pMB, CWnd* pParent = NULL);   // standard constructor
    virtual void OnOK();
    virtual BOOL OnInitDialog();

    // the only public member
    CCertMapRule*   m_pRule;

    // base path to the metabase
    CString m_szMBPath;


// Dialog Data
    //{{AFX_DATA(CEditWildcardRule)
    enum { IDD = IDD_WILDCARDS_2 };
    CListSelRowCtrl m_clistctrl_list;
    CButton m_cbutton_edit;
    CButton m_cbutton_delete;
    CButton m_cbutton_new;
    CString m_sz_description;
    BOOL    m_bool_enable;
    int     m_int_MatchAllIssuers;
    int     m_int_DenyAccess;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CEditWildcardRule)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL



// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CEditWildcardRule)
    afx_msg void OnDblclkList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnItemchangedList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnEdit();
    afx_msg void OnNew();
    afx_msg void OnDelete();
    afx_msg void OnSelectIssuer();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    // more initialization methods
    BOOL FInitRulesList();
    BOOL FillRulesList();

    // editing and updating
    void EnableDependantButtons();
    BOOL EditRule( DWORD iList );

    IMSAdminBase*   m_pMB;
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\edtrulel.h ===
// EdtRulEl.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CEditRuleElement dialog

class CEditRuleElement : public CDialog
{
// Construction
public:
    CEditRuleElement(CWnd* pParent = NULL);   // standard constructor
    virtual BOOL OnInitDialog();

    // overrides
    virtual void OnOK();

// Dialog Data
    //{{AFX_DATA(CEditRuleElement)
    enum { IDD = IDD_EDIT_RULE_ELEMENT };
    CComboBox   m_ccombobox_subfield;
    CComboBox   m_ccombobox_field;
    CString m_sz_criteria;
    int     m_int_field;
    CString m_sz_subfield;
    BOOL    m_bool_match_case;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CEditRuleElement)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CEditRuleElement)
    afx_msg void OnSelchangeFields();
    afx_msg void OnChangeSubfield();
    afx_msg void OnBtnHelp();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    
    // temporary storage in the event of a disabled subfield
    CString m_szTempSubStorage;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\iishelp.cpp ===
#include "stdafx.h"

INT g_iDebugOutputLevel = 0;

void GetOutputDebugFlag(void)
{
    DWORD rc, err, size, type;
    HKEY  hkey;
    err = RegOpenKey(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\InetMgr"), &hkey);
    if (err != ERROR_SUCCESS) {return;}
    size = sizeof(DWORD);
    err = RegQueryValueEx(hkey,_T("OutputDebugFlag"),0,&type,(LPBYTE)&rc,&size);
    if (err != ERROR_SUCCESS || type != REG_DWORD) {rc = 0;}
    RegCloseKey(hkey);

	if (rc < 0xffffffff)
	{
		g_iDebugOutputLevel = rc;
	}
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\hotlink.h ===
// HotLink.h : header file
//
#ifndef   _HotLink_h_file_123987_
#define   _HotLink_h_file_123987_



/////////////////////////////////////////////////////////////////////////////
// CHotLink window

class CHotLink : public CButton
{
// Construction
public:
    CHotLink();

// Attributes
public:
    BOOL    m_fBrowse;
    BOOL    m_fExplore;
    BOOL    m_fOpen;

// Operations
public:
    void Browse();
    void Explore();
    void Open();

    virtual void DrawItem( LPDRAWITEMSTRUCT lpDrawItemStruct );

    // set the title string
    void SetTitle( CString sz );

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CHotLink)
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CHotLink();

    // Generated message map functions
protected:
    //{{AFX_MSG(CHotLink)
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
    afx_msg void OnMouseMove(UINT nFlags, CPoint point);
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    // height and width of the displayed text
    void GetTextRect( CRect &rect );
    CSize   m_cpTextExtents;

    // tracking the mouse flag
    BOOL    m_CapturedMouse;

    // init the font
    BOOL    m_fInitializedFont;
};

/////////////////////////////////////////////////////////////////////////////
#endif   /*_HotLink_h_file_123987_*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\hotlink.cpp ===
// HotLink.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "HotLink.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define COLOR_BLUE          RGB(0, 0, 0xFF)

/////////////////////////////////////////////////////////////////////////////
// CHotLink

CHotLink::CHotLink():
    m_CapturedMouse( FALSE ),
    m_fBrowse( FALSE ),
    m_fExplore( FALSE ),
    m_fOpen( FALSE ),
    m_fInitializedFont( FALSE )
{
}

CHotLink::~CHotLink()
{
}

BEGIN_MESSAGE_MAP(CHotLink, CButton)
    //{{AFX_MSG_MAP(CHotLink)
    ON_WM_LBUTTONDOWN()
    ON_WM_LBUTTONUP()
    ON_WM_MOUSEMOVE()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//------------------------------------------------------------------------
// set the title string
void CHotLink::SetTitle( CString sz )
    {
    // set the title
    SetWindowText( sz );
    // force the window to redraw
    Invalidate( TRUE );
    }

/////////////////////////////////////////////////////////////////////////////
// CHotLink message handlers

//------------------------------------------------------------------------
void CHotLink::DrawItem( LPDRAWITEMSTRUCT lpDrawItemStruct )
    {
    // prep the device context
    CDC* pdc = CDC::FromHandle(lpDrawItemStruct->hDC);

    // get the drawing rect
    CRect rect = lpDrawItemStruct->rcItem;

    if ( ! m_fInitializedFont )
        {
        // get the window font
        CFont* pfont = GetFont();
        LOGFONT logfont;
        pfont->GetLogFont( &logfont );

        // modify the font  - add underlining
        logfont.lfUnderline = TRUE;

        // set the font back
        pfont->CreateFontIndirect( &logfont );
        SetFont( pfont, TRUE );

        m_fInitializedFont = TRUE;
        }

    // draw the text in blue
    pdc->SetTextColor( COLOR_BLUE );

    // draw the text
    CString sz;
    GetWindowText( sz );
    pdc->DrawText( sz, &rect, DT_LEFT|DT_SINGLELINE|DT_VCENTER );

    // get the extents fo the text for later reference
    m_cpTextExtents = pdc->GetOutputTextExtent( sz );
    }

//------------------------------------------------------------------------
// calculate the rectangle that surrounds the text
void CHotLink::GetTextRect( CRect &rect )
    {
    // get the main rect
    GetClientRect( rect );

    // reduce it by the width of the text
    rect.right = rect.left + m_cpTextExtents.cx;
    }

//------------------------------------------------------------------------
void CHotLink::OnLButtonDown(UINT nFlags, CPoint point)
    {
    // don't do the hotlink thing if there is no text
    CString sz;
    GetWindowText( sz );
    if ( sz.IsEmpty() )
        return;

    CRect   rect;
    GetTextRect( rect );
    if ( !m_CapturedMouse && rect.PtInRect(point) )
        {
        SetCapture( );
        m_CapturedMouse = TRUE;
        }
    }

//------------------------------------------------------------------------
void CHotLink::OnLButtonUp(UINT nFlags, CPoint point)
    {
    // only bother if we have the capture
    if ( m_CapturedMouse )
        {
        ReleaseCapture();
        if ( m_fBrowse )
            Browse();
        if ( m_fExplore )
            Explore();
        if ( m_fOpen )
            Open();
        }
    }

//------------------------------------------------------------------------
void CHotLink::Browse()
    {
    // get the window text
    CString sz;
    GetWindowText( sz );

    // and do it to it!
    ShellExecute(
        NULL,     // handle to parent window
        NULL,     // pointer to string that specifies operation to perform
        sz,       // pointer to filename or folder name string
        NULL,     // pointer to string that specifies executable-file parameters
        NULL,     // pointer to string that specifies default directory
        SW_SHOW   // whether file is shown when opened
       );
    }

//------------------------------------------------------------------------
void CHotLink::Explore()
    {
    // get the window text
    CString sz;
    GetWindowText( sz );

    // and do it to it!
    ShellExecute(
        NULL,          // handle to parent window
        _T("explore"), // pointer to string that specifies operation to perform
        sz,            // pointer to filename or folder name string
        NULL,          // pointer to string that specifies executable-file parameters
        NULL,          // pointer to string that specifies default directory
        SW_SHOW        // whether file is shown when opened
       );
    }

//------------------------------------------------------------------------
void CHotLink::Open()
    {
    // get the window text
    CString sz;
    GetWindowText(sz);

    // and do it to it!
    ShellExecute(
        NULL,          // handle to parent window
        _T("open"),    // pointer to string that specifies operation to perform
        sz,            // pointer to filename or folder name string
        NULL,          // pointer to string that specifies executable-file parameters
        NULL,          // pointer to string that specifies default directory
        SW_SHOW        // whether file is shown when opened
        );
    }

//------------------------------------------------------------------------
void CHotLink::OnMouseMove(UINT nFlags, CPoint point)
    {
    CRect   rect;
    GetTextRect( rect );
    // if the mouse is over the hot area, show the right cursor
    if ( rect.PtInRect(point) )
        ::SetCursor(AfxGetApp()->LoadCursor( IDC_BROWSE ));

//  CButton::OnMouseMove(nFlags, point);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\iishelp.h ===
#include "debugdefs.h"

#ifndef  _IISHELP_H_
#define  _IISHELP_H_

#if defined(_DEBUG) || DBG
    #define DEBUG_WINHELP_FLAG
#else
    // set this to debug on fre build
    //#define DEBUG_WINHELP_FLAG
#endif

extern INT g_iDebugOutputLevel;

#ifdef DEBUG_WINHELP_FLAG
    inline void _cdecl DebugTraceHelp(DWORD_PTR dwWinHelpID)
    {
        // Only do this if the flag is set.
        if (0 != g_iDebugOutputLevel)
        {
			if (DEBUG_FLAG_HELP & g_iDebugOutputLevel)
			{
				TCHAR szBuffer[30];
				_stprintf(szBuffer,_T("WinHelp:0x%x,%d\r\n"),dwWinHelpID,dwWinHelpID);
				OutputDebugString(szBuffer);
			}
		}
        return;
    }

    inline void _cdecl DebugTrace(LPTSTR lpszFormat, ...)
    {
        // Only do this if the flag is set.
        if (0 != g_iDebugOutputLevel)
        {
			if (DEBUG_FLAG_MODULE_CERTMAP & g_iDebugOutputLevel)
			{
				int nBuf;
				TCHAR szBuffer[_MAX_PATH];
				va_list args;
				va_start(args, lpszFormat);

				nBuf = _vsntprintf(szBuffer, sizeof(szBuffer)/sizeof(szBuffer[0]), lpszFormat, args);

				OutputDebugString(szBuffer);
				va_end(args);

				// if it does not end if '\r\n' then make one.
				int nLen = _tcslen(szBuffer);
				if (szBuffer[nLen-1] != _T('\n')){OutputDebugString(_T("\r\n"));}
			}
        }
    }
#else
    inline void _cdecl DebugTraceHelp(DWORD_PTR dwWinHelpID){}
#endif

#define WinHelpDebug DebugTraceHelp

void GetOutputDebugFlag(void);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\listrow.cpp ===
// ListRow.cpp : implementation file
//

#include "stdafx.h"
#include "certmap.h"
#include "ListRow.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#define SZ_RES_COLOR_PREFS      "Control Panel\\Colors"
#define SZ_RES_COLOR_HILITE     "Hilight"
#define SZ_RES_COLOR_HILITETEXT "HilightText"


/////////////////////////////////////////////////////////////////////////////
// CListSelRowCtrl
//-----------------------------------------------------------------------------------
CListSelRowCtrl::CListSelRowCtrl():
        m_StartDrawingCol( 0 )
    {
    }

//-----------------------------------------------------------------------------------
CListSelRowCtrl::~CListSelRowCtrl()
    {
    }


//-----------------------------------------------------------------------------------
BEGIN_MESSAGE_MAP(CListSelRowCtrl, CListCtrl)
    //{{AFX_MSG_MAP(CListSelRowCtrl)
    ON_WM_LBUTTONDOWN()
    ON_WM_LBUTTONDBLCLK()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//-----------------------------------------------------------------------------------
void CListSelRowCtrl::GetHiliteColors()
    {
    // get the hilite color
    m_colorHilite = GetSysColor( COLOR_HIGHLIGHT );

    // get the hilited text color
    m_colorHiliteText = GetSysColor( COLOR_HIGHLIGHTTEXT );
    }



/////////////////////////////////////////////////////////////////////////////
// CListSelRowCtrl message handlers

//-----------------------------------------------------------------------------------
void CListSelRowCtrl::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct)
    {
    CRect       rcItem = lpDrawItemStruct->rcItem;
    CRect       rcSection;
    UINT        itemID = lpDrawItemStruct->itemID;
    UINT        cpLeft = rcItem.left;
    CString     sz;
    LV_COLUMN   colData;
    COLORREF    colorTextOld;
    COLORREF    colorBackOld;

    // setup the CDC object
    CDC         cdc;
    cdc.Attach( lpDrawItemStruct->hDC );

#ifdef _DEBUG
    if ( m_StartDrawingCol == 0 )
        sz.Empty();
#endif

    // clear the columnd buffer
    ZeroMemory( &colData, sizeof(colData) );
    colData.mask = LVCF_WIDTH;

    // if this is the selected item, prepare the background and the text color
    BOOL fSelected = lpDrawItemStruct->itemState & ODS_SELECTED;
    if ( fSelected )
        {
        GetHiliteColors();
        colorTextOld = cdc.SetTextColor( m_colorHiliteText );
        colorBackOld = cdc.SetBkColor( m_colorHilite );
        }

    // starting with the m_StartDrawingCol column, draw the columns
    // do it in a loop, just skipping until we hit m_StartDrawingCol
    DWORD iCol = 0;
    while ( GetColumn(iCol, &colData) )
        {
        // see if we are ready yet
        if ( iCol < m_StartDrawingCol )
            {
            // set the new left.
            cpLeft += colData.cx;
            // increment the column counter
            iCol++;
            continue;
            }

        // prepare the background but once
        if ( iCol == m_StartDrawingCol )
            {
            // prepare the background
            rcSection = rcItem;
            rcSection.left = cpLeft;
            rcSection.right--;
            CBrush  brush;
            if ( lpDrawItemStruct->itemState & ODS_SELECTED )
                brush.CreateSolidBrush( m_colorHilite );
            else
                brush.CreateSolidBrush( GetSysColor( COLOR_WINDOW ) );
            cdc.FillRect( &rcSection, &brush );
            }


        // display the name
        sz = GetItemText( itemID, iCol );
        if ( !sz.IsEmpty() )
            {
            // figure out the sectional rect
            rcSection = rcItem;
            rcSection.left = cpLeft + 2;
            rcSection.right = cpLeft + colData.cx - 1;
            
            // fit the string into the required space
            FitString( sz, rcSection.right - rcSection.left, &cdc );

            //draw the string
            cdc.DrawText( sz, &rcSection, DT_SINGLELINE|DT_LEFT|DT_BOTTOM|DT_NOPREFIX );
            }

        // set the new left.
        cpLeft += colData.cx;
        // increment the column counter
        iCol++;
        }

    // if this is the selected item, restore the colors
    if ( fSelected )
        {
        cdc.SetTextColor( colorTextOld );
        cdc.SetBkColor( colorBackOld );
        }

    // cleanup the CDC object
    cdc.Detach();
    }


//------------------------------------------------------------------------
void CListSelRowCtrl::FitString( CString &sz, int cpWidth, CDC* pcdc )
    {
    CSize       size;
    UINT        cch;
    CString     szEllipsis;

    // start by testing the existing width
    size = pcdc->GetTextExtent( sz );
    if ( size.cx <= cpWidth ) return;

    // initialize szTrunc and szEllipsis
    cch = sz.GetLength();

    szEllipsis.LoadString(IDS_ELLIPSIS);

    // while we are too big, truncate one letter and add an ellipsis
    while( (size.cx > cpWidth) && (cch > 1) )
        {
        // chop off the last letter of the string - not counting the ...
        cch--;
        sz = sz.Left( cch );

        // add the elipsis (spelling?)
        sz += szEllipsis;

        // get the length
        size = pcdc->GetTextExtent( sz );
        }
    }







//------------------------------------------------------------------------
void CListSelRowCtrl::HiliteSelectedCells()
    {
    int iList = -1;
    while( (iList = GetNextItem( iList, LVNI_SELECTED )) >= 0 )
        HiliteSelectedCell( iList );
    }

//------------------------------------------------------------------------
void CListSelRowCtrl::HiliteSelectedCell( int iCell, BOOL fHilite )
    {
    // if there is no selected cell, do nothing
    if ( iCell < 0 )
        return;

    // get the rect to draw
    CRect   rect;
    if ( !FGetCellRect(iCell, -1, &rect) )
        {
        ASSERT(FALSE);
        return;
        }

    // get the client rect
    CRect   rectClient;
    GetClientRect( rectClient );

    // make sure it fits ok (problems can occur here when scrolled)
    // don't want it to draw in the column titles
    if ( rect.top < (rect.bottom - rect.top) )
        return;

    // now prepare to draw
    CDC *pdc = GetDC();

    // clip to the client area
    pdc->IntersectClipRect( rectClient );

    // set up the brush
    CBrush  cbrush;
    if ( fHilite )
        cbrush.CreateSolidBrush( RGB(192,192,192) );
    else
        cbrush.CreateSolidBrush( RGB(0xFF,0xFF,0xFF) );

    // draw the hilite rect
    pdc->FrameRect( rect, &cbrush );

    // cleanup
    ReleaseDC( pdc );
    }

//------------------------------------------------------------------------
BOOL    CListSelRowCtrl::FGetCellRect( LONG iRow, LONG iCol, CRect *pcrect )
    {
    // first, get the rect that the list thinks is appropriate
    if ( !GetItemRect(iRow, pcrect, LVIR_BOUNDS) )
        return FALSE;

    // if iCol < 0, then return the total size of the row
    if ( iCol < 0 )
        return TRUE;

    // trim the horizontal dimension to the correct column positioning
    LONG    cpLeft;
    LONG    cpRight = 0;
    for ( WORD i = 0; i <= iCol; i++ )
        {
        // set the left side
        cpLeft = cpRight;

        // get the right
        LONG cpWidth = GetColumnWidth(i);
        if ( cpWidth < 0 ) return FALSE;
        cpRight += cpWidth;
        }

    // well, now trim it seeing as we have the right values
    pcrect->left = cpLeft;
    pcrect->right = cpRight;
    
    // success!
    return TRUE;
    }

#define MAKE_LPARAM(x,y) ( ((unsigned long)(y)<<16) | ((unsigned long)(x)) )

//------------------------------------------------------------------------
void CListSelRowCtrl::OnLButtonDblClk(UINT nFlags, CPoint point) 
    {
    // force the point to be in the right place
    point.x = 6;
    LPARAM lp = MAKE_LPARAM(point.x, point.y);
//  DefWindowProc(WM_LBUTTONDBLCLK, nFlags, lp );
    CListCtrl::OnLButtonDblClk( nFlags, point);
    }

//------------------------------------------------------------------------
void CListSelRowCtrl::OnLButtonDown(UINT nFlags, CPoint point) 
    {
    point.x = 6;
    LPARAM lp = MAKE_LPARAM(point.x, point.y);
//  DefWindowProc(WM_LBUTTONDOWN, nFlags, lp );
    CListCtrl::OnLButtonDown( nFlags, point);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\keyring.h ===
#include "certmap.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\map11pge.cpp ===
// Map11Pge.cpp : implementation file
//

//    Certificate mappings storage has changed for IIS6. 
//    CERTMAP.OCX however has to support downlevel admin
//    of IIS5, IIS5.1
//
//    NSEPM support was removed from IIS6 and 1to1 client certificate
//    mapping information is now stored under <site>/Cert11/Mappings
//    node directly in the metabase
//    Functions with IIS6 postfix access new location
//    for 1to1 client certificate mappings storage


#include "stdafx.h"
#include <iadmw.h>
#include "certmap.h"

// persistence and mapping includes
#include "WrapMaps.h"
//#include "wrpprsis.h"
//#include "admutil.h"

#include "ListRow.h"
#include "ChkLstCt.h"

#include "wrapmb.h"

// mapping page includes
#include "brwsdlg.h"
#include "EdtOne11.h"
#include "Ed11Maps.h"
#include "Map11Pge.h"

#include "CrackCrt.h"

#include <iiscnfgp.h>
//#include "WrpMBWrp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#define COL_NUM_ENABLED         0
#define COL_NUM_NAME            1
#define COL_NUM_NTACCOUNT       2

#define MB_EXTEND_KEY           _T("Cert11")
#define MB_EXTEND_KEY_MAPS      _T("Cert11/Mappings")


/////////////////////////////////////////////////////////////////////////////
// CMap11Page property page

IMPLEMENT_DYNCREATE(CMap11Page, CPropertyPage)

CMap11Page::CMap11Page() : CPropertyPage(CMap11Page::IDD),
                m_MapsInMetabase( 0 )
    {
    //{{AFX_DATA_INIT(CMap11Page)
    m_csz_i_c = _T("");
    m_csz_i_o = _T("");
    m_csz_i_ou = _T("");
    m_csz_s_c = _T("");
    m_csz_s_cn = _T("");
    m_csz_s_l = _T("");
    m_csz_s_o = _T("");
    m_csz_s_ou = _T("");
    m_csz_s_s = _T("");
    m_fIsIIS6 = TRUE;
    //}}AFX_DATA_INIT
    }

CMap11Page::~CMap11Page()
    {
    ResetMappingList();
    }

void CMap11Page::DoDataExchange(CDataExchange* pDX)
    {
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CMap11Page)
    DDX_Control(pDX, IDC_ADD, m_cbutton_add);
    DDX_Control(pDX, IDC_ISSUER, m_cbutton_grp_issuer);
    DDX_Control(pDX, IDC_ISSUED_TO, m_cbutton_grp_issuedto);
    DDX_Control(pDX, IDC_LIST, m_clistctrl_list);
    DDX_Control(pDX, IDC_EDIT_11MAP, m_cbutton_editmap);
    DDX_Control(pDX, IDC_DELETE, m_cbutton_delete);
    DDX_Text(pDX, IDC_I_C, m_csz_i_c);
    DDX_Text(pDX, IDC_I_O, m_csz_i_o);
    DDX_Text(pDX, IDC_I_OU, m_csz_i_ou);
    DDX_Text(pDX, IDC_S_C, m_csz_s_c);
    DDX_Text(pDX, IDC_S_CN, m_csz_s_cn);
    DDX_Text(pDX, IDC_S_L, m_csz_s_l);
    DDX_Text(pDX, IDC_S_O, m_csz_s_o);
    DDX_Text(pDX, IDC_S_OU, m_csz_s_ou);
    DDX_Text(pDX, IDC_S_S, m_csz_s_s);
    //}}AFX_DATA_MAP
    }


BEGIN_MESSAGE_MAP(CMap11Page, CPropertyPage)
    //{{AFX_MSG_MAP(CMap11Page)
    ON_BN_CLICKED(IDC_ADD, OnAdd)
    ON_BN_CLICKED(IDC_DELETE, OnDelete)
    ON_BN_CLICKED(IDC_EDIT_11MAP, OnEdit11map)
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST, OnItemchangedList)
    ON_NOTIFY(NM_DBLCLK, IDC_LIST, OnDblclkList)
    //}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,  DoHelp)
    ON_COMMAND(ID_HELP,         DoHelp)
    ON_COMMAND(ID_CONTEXT_HELP, DoHelp)
    ON_COMMAND(ID_DEFAULT_HELP, DoHelp)
END_MESSAGE_MAP()

//---------------------------------------------------------------------------
void CMap11Page::DoHelp()
    {
    WinHelpDebug(HIDD_CERTMAP_MAIN_BASIC);
    WinHelp( HIDD_CERTMAP_MAIN_BASIC );
    }

/////////////////////////////////////////////////////////////////////////////
// initialization routines

//---------------------------------------------------------------------------
// FInitMapper is called by the routine instantiating this page. After the object
// is first created is when it is called. It allows us to fail gracefully.
BOOL    CMap11Page::FInit(IMSAdminBase* pMB)
        {
        m_pMB = pMB;

        // check if it's for older than iis6 version
		m_fIsIIS6 = TRUE;
		if (IsLegacyMetabase(pMB)){m_fIsIIS6 = FALSE;}
       
        if ( !m_fIsIIS6 )
            {
            // IIS5.1 and older saved cert mappings through NSEPM
            m_szMBPath = m_szMBPath + SZ_NAMESPACE_EXTENTION;
            }
            

        // this has become a simple place
        return TRUE;
        }

//---------------------------------------------------------------------------
BOOL CMap11Page::OnInitDialog()
    {
    //call the parental oninitdialog
    BOOL f = CPropertyPage::OnInitDialog();

    // if the initinalization (sp?) succeeded, init the list and other items
    if ( f )
        {
        // init the contents of the list
        FInitMappingList();

        // Fill the mapping list with the stored items
        FillMappingList();

        // set the initial button states
        EnableDependantButtons();
        }

    // set any changes in the info into place
    UpdateData(FALSE);

    // return the answer
    return f;
    }

//---------------------------------------------------------------------------
BOOL    CMap11Page::FInitMappingList()
    {
    CString sz;
    int             i;

    // setup the friendly name column
    sz.Empty();
    i = m_clistctrl_list.InsertColumn( COL_NUM_ENABLED, sz, LVCFMT_LEFT, 20 );

    // setup the friendly name column
    sz.LoadString( IDS_LIST11_NAME );

    i = m_clistctrl_list.InsertColumn( COL_NUM_NAME, sz, LVCFMT_LEFT, 105 );

    // setup the account column
    sz.LoadString( IDS_LIST11_ACCOUNT );

    i = m_clistctrl_list.InsertColumn( COL_NUM_NTACCOUNT, sz, LVCFMT_LEFT, 195 );

    return TRUE;
    }

//---------------------------------------------------------------------------
BOOL    CMap11Page::FillMappingList()
    {
    // reset the mapping list - get rid of anything in there now
    ResetMappingList();

    // read in the mappings - it adds them to the list
    FReadMappings();

    return TRUE;
    }

//---------------------------------------------------------------------------
//BOOL CMap11Page::FAddMappingToList( C11Mapping* pMap, DWORD iList )
BOOL CMap11Page::FAddMappingToList( C11Mapping* pMap )
    {
    CString sz;
    int     i;
    DWORD   iList;

    // if requested, make sure the mapping is added to the end of the list
    iList = m_clistctrl_list.GetItemCount();

    // get the appropriate "enabled" string
    BOOL fEnabled;
    pMap->GetMapEnabled( &fEnabled );
    if ( fEnabled )
         sz.LoadString( IDS_ENABLED );
    else
        sz.Empty();

    // add the friendly name of the mapping
    // create the new entry in the list box. Do not sort on this entry - yet
    i = m_clistctrl_list.InsertItem( iList, sz );

    // add the friendly name of the mapping
    pMap->GetMapName( sz );
    // create the new entry in the list box. Do not sort on this entry - yet
    m_clistctrl_list.SetItemText( i, COL_NUM_NAME, sz );

    // add the account name of the mapping
    pMap->GetNTAccount( sz );
    m_clistctrl_list.SetItemText( i, COL_NUM_NTACCOUNT, sz );

    // attach the pointer to the mapping as the private data in the list.
    m_clistctrl_list.SetItemData( i, (UINT_PTR)pMap );

    // return whether or not the insertion succeeded
    return TRUE;
    }

//---------------------------------------------------------------------------
void CMap11Page::EnableDependantButtons()
    {
    // the whole purpose of this routine is to gray or activate
    // the edit and delete buttons depending on whether or not anything
    // is selected. So start by getting the selection count
    if ( m_clistctrl_list.GetSelectedCount() > 0 )
        {
        // there are items selected
        m_cbutton_editmap.EnableWindow( TRUE );
        m_cbutton_delete.EnableWindow( TRUE );
        EnableCrackDisplay( TRUE );
        }
    else
        {
        // nope. Nothing selected
        m_cbutton_editmap.EnableWindow( FALSE );
        m_cbutton_delete.EnableWindow( FALSE );
        }

    // always enable the add button
    m_cbutton_add.EnableWindow( TRUE );
    }

//---------------------------------------------------------------------------
BOOL CMap11Page::EditOneMapping( C11Mapping* pUpdateMap )
    {
    CEditOne11MapDlg        mapdlg;

    // prepare the mapping dialog
    pUpdateMap->GetMapName( mapdlg.m_sz_mapname );
    pUpdateMap->GetMapEnabled( &mapdlg.m_bool_enable );
    pUpdateMap->GetNTAccount( mapdlg.m_sz_accountname );
    pUpdateMap->GetNTPassword( mapdlg.m_sz_password );

    // run the mapping dialog
    if ( mapdlg.DoModal() == IDOK )
        {
        // update its friendly name
        pUpdateMap->SetMapName( mapdlg.m_sz_mapname );

        // set the NT account field of the mapping object
        pUpdateMap->SetNTAccount( mapdlg.m_sz_accountname );

        // set the NT account password field of the mapping object
        CString csTempString;
        mapdlg.m_sz_password.CopyTo(csTempString);
        pUpdateMap->SetNTPassword( csTempString );

        // set whether or not the mapping is enabled
        pUpdateMap->SetMapEnabled( mapdlg.m_bool_enable );

        // NOTE: the caller is resposible for calling UpdateMappingInDispList
        // as the mapping in question may not yet be in the display list

        // this mapping has changed. Mark it to be saved
        MarkToSave( pUpdateMap );

        // return true because the user said "OK"
        return TRUE;
        }

    // return FALSE because the user did not say "OK"
    return FALSE;
    }

//---------------------------------------------------------------------------
BOOL CMap11Page::EditMultipleMappings()
        {
        CEdit11Mappings mapdlg;
        C11Mapping*             pUpdate11Map;
        BOOL                    fSetInitialState = FALSE;
        BOOL                    fEnable;


        // scan the list of seleted items for the proper initial enable button state
                // loop through the selected items, setting each one's mapping
                int     iList = -1;
                while( (iList = m_clistctrl_list.GetNextItem( iList, LVNI_SELECTED )) >= 0 )
                        {
                        // get the mapping item for updating purposes
                        pUpdate11Map = GetMappingInDisplay( iList );
                        ASSERT( pUpdate11Map );
                        if ( !pUpdate11Map )
                                {
                                AfxMessageBox( IDS_ERR_ACCESS_MAPPING );
                                break;
                                }

                        // get the enable state of the mapping
                        pUpdate11Map->GetMapEnabled( &fEnable );

                        // if this is the first time, just set the initial state
                        if ( !fSetInitialState )
                                {
                                mapdlg.m_int_enable = fEnable;
                                fSetInitialState = TRUE;
                                }
                        else
                                {
                                // if it is different, then go indeterminate and break
                                if ( fEnable != mapdlg.m_int_enable )
                                        {
                                        mapdlg.m_int_enable = 2;
                                        break;
                                        }
                                }
                        }

        // run the mapping dialog
        if ( mapdlg.DoModal() == IDOK )
                {
                // loop through the selected items, setting each one's mapping
                int     iList = -1;
                while( (iList = m_clistctrl_list.GetNextItem( iList, LVNI_SELECTED )) >= 0 )
                        {
                        // get the mapping item for updating purposes
                        pUpdate11Map = GetMappingInDisplay( iList );
                        if ( !pUpdate11Map )
                                {
                                AfxMessageBox( IDS_ERR_ACCESS_MAPPING );
                                break;
                                }

                        // set the enable flag if requested
                        switch ( mapdlg.m_int_enable )
                                {
                                case 0:         // disable
                                        pUpdate11Map->SetMapEnabled( FALSE );
                                        break;
                                case 1:         // enable
                                        pUpdate11Map->SetMapEnabled( TRUE );
                                        break;
                                }

                        // set the NT account field of the mapping object
                        pUpdate11Map->SetNTAccount( mapdlg.m_sz_accountname );

                        // set the NT account password field of the mapping object
                        CString csTempString;
                        mapdlg.m_sz_password.CopyTo(csTempString);
                        pUpdate11Map->SetNTPassword( csTempString );

                        // update it in the list control too
                        UpdateMappingInDispList( iList, pUpdate11Map );

                        // this mapping has changed. Mark it to be saved
                        MarkToSave( pUpdate11Map );
                        }

                // activate the apply button
                SetModified();

                // return true because the user said "OK"
                return TRUE;
                }

        // return FALSE because the user did not say "OK"
        return FALSE;
        }


//---------------------------------------------------------------------------
void CMap11Page::UpdateMappingInDispList( DWORD iList, C11Mapping* pMap )
    {
    CString sz;

    // verify the index and the pointer!
    ASSERT( pMap == GetMappingInDisplay(iList) );

    // get the appropriate "enabled" string
    BOOL fEnabled;
    pMap->GetMapEnabled( &fEnabled );
    if ( fEnabled )
        sz.LoadString( IDS_ENABLED );
    else
        sz.Empty();

    // update the "Enabled" indicator
    m_clistctrl_list.SetItemText( iList, COL_NUM_ENABLED, sz );

    // update the mapping name
    pMap->GetMapName( sz );
    m_clistctrl_list.SetItemText( iList, COL_NUM_NAME, sz );

    // update the account name
    pMap->GetNTAccount( sz );
    m_clistctrl_list.SetItemText( iList, COL_NUM_NTACCOUNT, sz );
    }

//---------------------------------------------------------------------------
void CMap11Page::ResetMappingList()
    {
    // first, delete all the mapping objects in the list
    DWORD cbList = m_clistctrl_list.GetItemCount();
    for ( DWORD iList = 0; iList < cbList; iList++ )
        DeleteMapping( GetMappingInDisplay(iList) );

    // reset the mapping list - get rid of anything in there now
    m_clistctrl_list.DeleteAllItems();
    }

//---------------------------------------------------------------------------
void CMap11Page::MarkToSave( C11Mapping* pSaveMap, BOOL fSave )
        {
        // first, we see if it is already in the list. If it is, we have nothing to do
        // unless fSave is set to false, then we remove it from the list
        DWORD cbItemsInList = (DWORD)m_rgbSave.GetSize();
        for ( DWORD i = 0; i < cbItemsInList; i++ )
            {
            if ( pSaveMap == (C11Mapping*)m_rgbSave[i] )
                {
                // go away if fSave, otherwise, double check it isn't
                // anywhere else in the list
                if ( fSave )
                    {
                    return;
                    }
                else
                    {
                    // remove the item from the list
                    m_rgbSave.RemoveAt(i);
                    // don't skip now as the list slid down
                    cbItemsInList--;
                    i--;
                    }
                }
            }

        // since it is not there, we should add it, if fSave is true
        if ( fSave )
            m_rgbSave.Add( (CObject*)pSaveMap );
        }

/////////////////////////////////////////////////////////////////////////////
// CMap11Page message handlers


//---------------------------------------------------------------------------
void CMap11Page::OnOK()
    {
    // this has gotten much simpler
    FWriteMappings();
    CPropertyPage::OnOK();
    }

//---------------------------------------------------------------------------
BOOL CMap11Page::OnApply()
    {
    // this has gotten much simpler
    BOOL f = FWriteMappings();
    // rebuild the display
    FillMappingList();
    return f;
    }


//---------------------------------------------------------------------------
// when the user pushes the add button, ask them to load a certificate, then
// add it to the list as a mapping
    void CMap11Page::OnAdd()
    {

    // put this in a try/catch to make errors easier to deal with
    try {
        CString     szFilter;
        szFilter.LoadString( IDS_KEY_OR_CERT_FILE_FILTER );

        // prepare the file dialog variables
        CFileDialog cfdlg(TRUE, NULL, NULL,
                    OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY,
                    (LPCTSTR)szFilter);
		// Disable hook to get Windows 2000 style dialog
		cfdlg.m_ofn.Flags &= ~(OFN_ENABLEHOOK);
        // run the dialog
        if ( cfdlg.DoModal() == IDOK )
            {
            // add the certificate to the mapping list
            if ( FAddCertificateFile( cfdlg.GetPathName() ) )
                {
                // activate the apply button
                SetModified();
                }
            }
        }
    catch ( CException * pException )
        {
        pException->Delete();
        }
    }

//---------------------------------------------------------------------------
void CMap11Page::OnDelete()
    {
    C11Mapping* pKillMap;

    // ask the user to confirm this decision
    if ( AfxMessageBox(IDS_CONFIRM_DELETE, MB_OKCANCEL) != IDOK )
        return;

    // loop through the selected items. Remove each from the list,
    // then mark it to be deleted.
    int     iList = -1;
    while( (iList = m_clistctrl_list.GetNextItem( -1, LVNI_SELECTED )) >= 0 )
        {
        // get the mapping
        pKillMap = GetMappingInDisplay( iList );

        // remove it from the list
        m_clistctrl_list.DeleteItem( iList );

        // if it has not yet been applied to the metabase, continue
        
        if ( (!m_fIsIIS6 && pKillMap->iMD == NEW_OBJECT ) ||
             ( m_fIsIIS6 && pKillMap->QueryNodeName() == "" /*NEW_OBJECT*/ ) )
            {
            // since this mapping never existed, we can just remove it from the add/edit lists
            MarkToSave( pKillMap, FALSE );

            // go to the next selected object
            continue;
            }

        // mark the item to be deleted from the metabase
        m_rgbDelete.Add( (CObject*)pKillMap );
        }

    // activate the apply button
    SetModified();
    }

//---------------------------------------------------------------------------
void CMap11Page::OnEdit11map()
    {
    int             iList;
    C11Mapping*     pUpdateMap;

    // what happens here depends on if just one mapping is selected, or many
    switch( m_clistctrl_list.GetSelectedCount() )
        {
        case 0:         // do nothing - should not get here because button grays out
            ASSERT( FALSE );
            break;

        case 1:         // get the mapping for update and run single edit dialog
            // get index of the selected list item
            iList = m_clistctrl_list.GetNextItem( -1, LVNI_SELECTED );
            ASSERT( iList >= 0 );


            // get the mapping item for updating purposes
            pUpdateMap = GetMappingInDisplay( iList );
            if ( !pUpdateMap )
                {
                AfxMessageBox( IDS_ERR_ACCESS_MAPPING );
                break;
                }

            // edit the mapping, update it if successful, delete if not
            if ( EditOneMapping(pUpdateMap) )
                {
                UpdateMappingInDispList( iList, pUpdateMap );
                // activate the apply button
                SetModified();
                }
            break;

        default:        // run the multi edit dialog
            EditMultipleMappings();
            break;
        }
    }

//---------------------------------------------------------------------------
void CMap11Page::OnDblclkList(NMHDR* pNMHDR, LRESULT* pResult)
    {
    *pResult = 0;

    // if something in the list was double clicked, edit it
    if ( m_clistctrl_list.GetSelectedCount() > 0 )
        OnEdit11map();
    }

//---------------------------------------------------------------------------
void CMap11Page::OnItemchangedList(NMHDR* pNMHDR, LRESULT* pResult)
    {
    C11Mapping*     pSelMap;
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
    *pResult = 0;

    // enable the correct items
    EnableDependantButtons();

    // fill in the cracked information for the selected mapping - if there is only one
    if ( m_clistctrl_list.GetSelectedCount() == 1 )
        {
        // get index of the selected list item
        int i = m_clistctrl_list.GetNextItem( -1, LVNI_SELECTED );
        ASSERT( i >= 0 );

        // get the mapper index for the item
        pSelMap = GetMappingInDisplay( i );
        if ( pSelMap )
            {
            DisplayCrackedMap( pSelMap );
            }
        }
    else
        {
        // either multiple, or no mappings selected
        EnableCrackDisplay( FALSE );
        }
    }


//================================================================================
// special display
//---------------------------------------------------------------------------
BOOL CMap11Page::DisplayCrackedMap( C11Mapping* pMap )
    {
    PUCHAR                          pCert;
    DWORD                           cbCert;
    CString                         sz;

    // obtain a reference to the certificate
    if ( !pMap->GetCertificate( &pCert, &cbCert ) )
            return FALSE;

    // crack the certificate
    CCrackedCert    cracker;
    if ( !cracker.CrackCert( pCert, cbCert ) )
            return FALSE;

    // fill in all the fields
    cracker.GetIssuerCountry( sz );
    m_csz_i_c = sz;

    cracker.GetIssuerOrganization( sz );
    m_csz_i_o = sz;

    cracker.GetIssuerUnit( sz );
    m_csz_i_ou = sz;

    cracker.GetSubjectCountry( sz );
    m_csz_s_c = sz;

    cracker.GetSubjectCommonName( sz );
    m_csz_s_cn = sz;

    cracker.GetSubjectLocality( sz );
    m_csz_s_l = sz;

    cracker.GetSubjectOrganization( sz );
    m_csz_s_o = sz;

    cracker.GetSubjectUnit( sz );
    m_csz_s_ou = sz;

    cracker.GetSubjectState( sz );
    m_csz_s_s = sz;

    UpdateData( FALSE );

    // return success
    return TRUE;
    }

//---------------------------------------------------------------------------
void CMap11Page::ClearCrackDisplay()
    {
    m_csz_i_c.Empty();
    m_csz_i_o.Empty();
    m_csz_i_ou.Empty();
    m_csz_s_c.Empty();
    m_csz_s_cn.Empty();
    m_csz_s_l.Empty();
    m_csz_s_o.Empty();
    m_csz_s_ou.Empty();
    m_csz_s_s.Empty();
    UpdateData( FALSE );
    }

//---------------------------------------------------------------------------
void CMap11Page::EnableCrackDisplay( BOOL fEnable )
    {
    if ( !fEnable )
            ClearCrackDisplay();
    m_cbutton_grp_issuer.EnableWindow( fEnable );
    m_cbutton_grp_issuedto.EnableWindow( fEnable );
    }

//---------------------------------------------------------------------------
BOOL CMap11Page::FReadMappings()
    {

    if ( m_fIsIIS6 )
        {
        return FReadMappingsIIS6();
        }
    BOOL                    f;
    C11Mapping*             pMap;
    DWORD                   cbData;
    PVOID                   pData;
    DWORD                   fEnabled;
    CString                 sz;
    BOOL                    fRet = TRUE;

    // before messing with the metabase, prepare the strings we will need
    CString                 szBasePath = m_szMBPath + _T('/');
    CString                 szRelativePath = MB_EXTEND_KEY_MAPS;
    CString                 szObjectPath = m_szMBPath + _T('/') + szRelativePath;
    CString                 szMapPath;

    // prepare the metabase wrappers
    CWrapMetaBase   mbWrap;
    f = mbWrap.FInit(m_pMB);

    // open the base object
    f = mbWrap.Open( szObjectPath, METADATA_PERMISSION_READ );
    ASSERT( f );
    if ( !f )
        {
        return FALSE;
        }

    // for now, at least, we are reading in all the mappings. reset the m_nNamer counter
    // so that we end up with a somewhat accurate reading of the last number-name in the list.
    m_MapsInMetabase = 0;

    // Loop the items in the metabase, adding each to the napper.
    DWORD index = 0;
    CString     szEnum;
    while ( mbWrap.EnumObjects(_T(""), szEnum.GetBuffer(MAX_PATH*sizeof(WCHAR)),
                        MAX_PATH*sizeof(WCHAR), index) )
        {
        szEnum.ReleaseBuffer();

        // keep track of the number of mappings we encounter
        m_MapsInMetabase++;

        // build the final mapping object path
        szMapPath.Format( _T("/%s"), szEnum );

        // make a new mapping object
        pMap = PNewMapping();

        if (pMap == NULL) {
            SetLastError(E_OUTOFMEMORY);
            fRet = FALSE;
            break;
        }

        // install the object name into the mapping
        pMap->iMD = m_MapsInMetabase;

        // get the certificate
        pData = mbWrap.GetData( szMapPath, MD_MAPCERT, IIS_MD_UT_SERVER, BINARY_METADATA, &cbData );
        if ( pData )
            {
            // set the data into place
            pMap->SetCertificate( (PUCHAR)pData, cbData );
            // free the buffer
            mbWrap.FreeWrapData( pData );
            }

        // get the NT Account - a string
        cbData = METADATA_MAX_NAME_LEN;
        if ( Get11String( &mbWrap, szMapPath, MD_MAPNTACCT, sz) )
            {
            pMap->SetNTAccount( sz );
            }

        // get the NT Password
        cbData = METADATA_MAX_NAME_LEN;
        if ( Get11String( &mbWrap, szMapPath, MD_MAPNTPWD, sz) )
            {
            pMap->SetNTPassword( sz );
            }

        // get the Enabled flag
        if ( mbWrap.GetDword( szMapPath, MD_MAPENABLED, IIS_MD_UT_SERVER, &fEnabled) )
            pMap->SetMapEnabled( (fEnabled > 0) );

        // get the mapping name
        cbData = METADATA_MAX_NAME_LEN;
        if ( Get11String( &mbWrap, szMapPath, MD_MAPNAME, sz) )
            {
            pMap->SetMapName( sz );
            }

        // add the mapping to the list
        FAddMappingToList( pMap );

        // increment the index
        index++;
        }
    szEnum.ReleaseBuffer();

    // close the mapping object
    mbWrap.Close();

    // return success
    return fRet;
    }

//---------------------------------------------------------------------------
// IMPORTANT: There is a bug in the mapping namespace extension where, even
// though we are using the unicode metabase interface, all the strings are
// expected to be ansi. This means that we cannont use the wrapmb getstring
// and setstring calls with regards to the nsmp extetention. That is why
// there are these two string wrapper classes that

// also, all the strings used here are IIS_MD_UT_SERVER, so we can elimiate that parameter.
BOOL CMap11Page::Get11String(CWrapMetaBase* pmb, LPCTSTR pszPath, DWORD dwPropID, CString& sz)
    {
    DWORD   dwcb;
    BOOL    fAnswer = FALSE;

    // get the string using the self-allocating get data process
    // that that it is cast as ANSI so the sz gets it right.
    // NOTE: This must be gotten as an ANSI string!
    PCHAR  pchar = (PCHAR)pmb->GetData( pszPath, dwPropID, IIS_MD_UT_SERVER, STRING_METADATA, &dwcb );
    if ( pchar )
        {
        // set the answer
        sz = pchar;

        fAnswer = TRUE;
        // clean up
        pmb->FreeWrapData( pchar );
        }

    // return the answer
    return fAnswer;
    }

//---------------------------------------------------------------------------
/* INTRINSA suppress=null_pointers, uninitialized */
BOOL CMap11Page::Set11String(CWrapMetaBase* pmb, LPCTSTR pszPath, DWORD dwPropID, CString& sz, DWORD dwFlags )
    {
    USES_CONVERSION;
    // Easy. Just set it as data
    // Make sure it is set back as an ANSI string though
    LPSTR pA = T2A((LPTSTR)(LPCTSTR)sz);
    return pmb->SetData( pszPath, dwPropID, IIS_MD_UT_SERVER, STRING_METADATA,
                            (PVOID)pA, strlen(pA)+1, dwFlags );
    }

//---------------------------------------------------------------------------
// we only need to write out the mappings that have been either changed or added.

// Thoughts on further optimizations: The bare minimum info about where to find
// a mapping in the metabase could be stored in the metabase. Then, the mappings
// would only be loaded when they were added to be edited or displayed in the
// cracked list. The private data for each item in the list would have to have
// some sort of reference to a position in the metabase.

BOOL CMap11Page::FWriteMappings()
    {
    if ( m_fIsIIS6 )
        {
        return FWriteMappingsIIS6();
        }

    BOOL                            f;
    DWORD                           i,j;
    DWORD                           cMappings;
    C11Mapping*                     pMap;
    C11Mapping*                     pMapTemp;

    CString                         sz;
    DWORD                           dwEnabled;
    PUCHAR                          pCert;
    DWORD                           cbCert;
    DWORD                           iList;
    CStrPassword                    cspTempPassword;

    // before messing with the metabase, prepare the strings we will need
    CString         szTempPath;
    CString         szBasePath = m_szMBPath + _T("/Cert11");
    CString         szRelativePath = _T("/Mappings");
    CString         szObjectPath = szRelativePath + _T('/');

    // prepare the base metabase wrapper
    CWrapMetaBase   mbBase;
    f = mbBase.FInit(m_pMB);
    if ( !f )
        {
        AfxMessageBox( IDS_ERR_ACCESS_MAPPING );
        return FALSE;
        }

        // first, we have to open the Cert11 object. If it doesn't exist
        // then we have to add it tothe metabase
        if ( !mbBase.Open( szBasePath, METADATA_PERMISSION_READ|METADATA_PERMISSION_WRITE ) )
            {
            // Cert11 does not exist - open the namespace base and add it
            szTempPath = m_szMBPath + _T('/');
            if ( !mbBase.Open( szTempPath, METADATA_PERMISSION_READ|METADATA_PERMISSION_WRITE ) )
                {
                AfxMessageBox( IDS_ERR_ACCESS_MAPPING );
                return FALSE;   // serious problems if we can't open the base
                }

            // add the Cert11 object
            szTempPath = _T("Cert11");
            f = mbBase.AddObject( szTempPath );
            mbBase.Close();
            if ( !f )
                {
                AfxMessageBox( IDS_ERR_CANTADD );
                return FALSE;
                }

            // try again to open the Cert11. Fail if it doesn't work
            if ( !mbBase.Open( szBasePath, METADATA_PERMISSION_READ|METADATA_PERMISSION_WRITE ) )
                {
                AfxMessageBox( IDS_ERR_ACCESS_MAPPING );
                return FALSE;
                }
            }

    //==========
    // start by deleting all the mappings in the to-be-deleted list
    cMappings = (DWORD)m_rgbDelete.GetSize();

    // only bother if there are items waiting to be deleted
    if ( cMappings > 0 )
        {
        // get the count of mappings in the display list
        DWORD   cList = m_clistctrl_list.GetItemCount();

        // sort the mappings, in decending order
        for ( i = 0; i < cMappings-1; i++ )
            {
            pMap = (C11Mapping*)m_rgbDelete[i];
            for ( j = i; j < cMappings; j++ )
                {
                pMapTemp = (C11Mapping*)m_rgbDelete[j];
                if ( pMap->iMD < pMapTemp->iMD )
                    {
                    m_rgbDelete.SetAt( i, (CObject*)pMapTemp );
                    m_rgbDelete.SetAt( j, (CObject*)pMap );
                    pMap = pMapTemp;
                    }
                }
            }

        // loop the mappings, deleting each from the metabase
        for ( i = 0; i < cMappings; i++ )
            {
            // get the mapping object
            pMap = (C11Mapping*)m_rgbDelete[i];
            if ( !pMap || (pMap->iMD == NEW_OBJECT) )
                continue;

            // build the relative path to the object in question.
            szObjectPath.Format( _T("%s/%d"), szRelativePath, pMap->iMD );

            // delete that mapping's object from the metabase
            f = mbBase.DeleteObject( szObjectPath );

            // decrement the number of maps in the metabase
            m_MapsInMetabase--;

            // loop the items in the list, decrementing the index of those
            // that are above it. Yes - this is non-optimal, but its what
            // has to be done for now
            for ( iList = 0; iList < cList; iList++ )
                {
                pMapTemp = GetMappingInDisplay(iList);
                if ( (pMapTemp->iMD > pMap->iMD) && (pMapTemp->iMD != NEW_OBJECT) )
                    pMapTemp->iMD--;
                }

            // since we will no longer be needing this mapping, delete it
            DeleteMapping( pMap );
            }

        // reset the to-be-deleted list
        m_rgbDelete.RemoveAll();
        }

    //==========
    // get the number mappings in the to-be-saved list
    cMappings = (DWORD)m_rgbSave.GetSize();

    // loop the mappings, adding each to the metabase
    for ( i = 0; i < cMappings; i++ )
        {
        // get the mapping object
        pMap = (C11Mapping*)m_rgbSave[i];
        ASSERT( pMap );

        // if the object is already in the metabase, just open it.
        if ( pMap->iMD != NEW_OBJECT )
            {
            // build the relative path to the object
            szObjectPath.Format( _T("%s/%d"), szRelativePath, pMap->iMD );
            }
        else
            {
            // set up the name of the new mapping as one higher
            // than the number of mappings in the metabase
            pMap->iMD = m_MapsInMetabase + 1;

            // build the relative path to the object
            szObjectPath.Format( _T("%s/%d"), szRelativePath, pMap->iMD );

            // add the mapping object to the base
            f = mbBase.AddObject( szObjectPath );
            if ( f )
                {
                // increment the number of maps in the metabase
                m_MapsInMetabase++;
                }
            }

        // write the object's parameters
        if ( f )
            {
            // save the certificate
            if ( pMap->GetCertificate(&pCert, &cbCert) )
                {
                // set the data into place in the object
                f = mbBase.SetData( szObjectPath, MD_MAPCERT, IIS_MD_UT_SERVER, BINARY_METADATA,
                pCert, cbCert, METADATA_SECURE | METADATA_INHERIT );
                }

            // save the NTAccount
            if ( pMap->GetNTAccount(sz) )
                {
                // set the data into place in the object
                f = Set11String(&mbBase, szObjectPath, MD_MAPNTACCT, sz, METADATA_SECURE);
                }

            // save the password - secure
            if ( pMap->GetNTPassword(cspTempPassword) )
                {
                // set the data into place in the object
                CString csTempPassword;
                cspTempPassword.CopyTo(csTempPassword);
                f = Set11String(&mbBase, szObjectPath, MD_MAPNTPWD, csTempPassword, METADATA_SECURE);
                }

            // save the map's name
            if ( pMap->GetMapName(sz) )
                {
                // set the data into place in the object
                f = Set11String(&mbBase, szObjectPath, MD_MAPNAME, sz);
                }

            // save the Enabled flag
            // server reads the flag as the value of the dword
            if ( pMap->GetMapEnabled(&f) )
                {
                dwEnabled = (DWORD)f;
                f = mbBase.SetDword( szObjectPath, MD_MAPENABLED, IIS_MD_UT_SERVER, dwEnabled );
                }
            }
        }

    // close the base object
    mbBase.Close();

    // save the metabase
    mbBase.Save();

    // reset the to-be-saved list
    m_rgbSave.RemoveAll();

    // return success
    return TRUE;
    }

//---------------------------------------------------------------------------
BOOL CMap11Page::FReadMappingsIIS6()
    {
    BOOL                    f;
    C11Mapping*             pMap;
    DWORD                   cbData;
    PVOID                   pData;
    DWORD                   fEnabled;
    WCHAR *                 pChar = NULL;
    BOOL                    fRet = TRUE;

    // before messing with the metabase, prepare the strings we will need
    CString                 szBasePath = m_szMBPath + _T('/');
    CString                 szRelativePath = MB_EXTEND_KEY_MAPS;
    CString                 szObjectPath = m_szMBPath + _T('/') + szRelativePath;
    CString                 szMapPath;

    // prepare the metabase wrappers
    CWrapMetaBase   mbWrap;
    f = mbWrap.FInit(m_pMB);

    // open the base object
    f = mbWrap.Open( szObjectPath, METADATA_PERMISSION_READ );
    ASSERT( f );
    if ( !f )
        {
        return FALSE;
        }

    // for now, at least, we are reading in all the mappings. reset the m_nNamer counter
    // so that we end up with a somewhat accurate reading of the last number-name in the list.
    m_MapsInMetabase = 0;

    // Loop the items in the metabase, adding each to the napper.
    DWORD index = 0;
    CString     szEnum;
    while ( mbWrap.EnumObjects(_T(""), szEnum.GetBuffer(MAX_PATH*sizeof(WCHAR)),
                        MAX_PATH*sizeof(WCHAR), index) )
        {
        szEnum.ReleaseBuffer();

        // keep track of the number of mappings we encounter
        m_MapsInMetabase++;

        // build the final mapping object path
        szMapPath.Format( _T("/%s"), szEnum );

        // make a new mapping object
        pMap = PNewMapping();

        if (pMap == NULL) {
            SetLastError(E_OUTOFMEMORY);
            fRet = FALSE;
            break;
        }

        // install the object name into the mapping
        pMap->SetNodeName( szEnum );

        // get the certificate
        pData = mbWrap.GetData( szMapPath, MD_MAPCERT, IIS_MD_UT_SERVER, BINARY_METADATA, &cbData );
        if ( pData )
            {
            // set the data into place
            pMap->SetCertificate( (PUCHAR)pData, cbData );
            // free the buffer
            mbWrap.FreeWrapData( pData );
            }

        // get the NT Account - a string
        cbData = METADATA_MAX_NAME_LEN;
        
        if ( pChar = (WCHAR *) mbWrap.GetData( szMapPath, MD_MAPNTACCT, IIS_MD_UT_SERVER, STRING_METADATA, &cbData ) )
            {
            pMap->SetNTAccount( pChar );
            // free the buffer
            mbWrap.FreeWrapData( pChar );
            }

        // get the NT Password
        cbData = METADATA_MAX_NAME_LEN;
        if ( pChar = (WCHAR *) mbWrap.GetData( szMapPath, MD_MAPNTPWD, IIS_MD_UT_SERVER, STRING_METADATA, &cbData ) )
            {
            pMap->SetNTPassword( pChar );
            // free the buffer
            mbWrap.FreeWrapData( pChar );
            }


        // get the Enabled flag
        if ( mbWrap.GetDword( szMapPath, MD_MAPENABLED, IIS_MD_UT_SERVER, &fEnabled) )
            pMap->SetMapEnabled( (fEnabled > 0) );

        // get the mapping name
        cbData = METADATA_MAX_NAME_LEN;
        if ( pChar = (WCHAR *) mbWrap.GetData( szMapPath, MD_MAPNAME, IIS_MD_UT_SERVER, STRING_METADATA, &cbData ) )
            {
            pMap->SetMapName( pChar );
            // free the buffer
            mbWrap.FreeWrapData( pChar );
            }

        // add the mapping to the list
        FAddMappingToList( pMap );

        // increment the index
        index++;
        }
    szEnum.ReleaseBuffer();

    // close the mapping object
    mbWrap.Close();

    // return success
    return fRet;
    }


//---------------------------------------------------------------------------
// we only need to write out the mappings that have been either changed or added.
// This function is based on FWriteMappings() function. Minimum changes were made
// to support IIS6 format of IIS 1to1 client certificate mappings


BOOL CMap11Page::FWriteMappingsIIS6()
    {
    BOOL                            f;
    DWORD                           i,j;
    DWORD                           cMappings;
    C11Mapping*                     pMap;
    C11Mapping*                     pMapTemp;

    CString                         sz;
    DWORD                           dwEnabled;
    PUCHAR                          pCert;
    DWORD                           cbCert;
    DWORD                           iList;
    CStrPassword                    cspTempPassword;

    // before messing with the metabase, prepare the strings we will need
    CString         szTempPath;
    CString         szBasePath = m_szMBPath + _T('/')+ MB_EXTEND_KEY_MAPS;
    CString         szObjectPath = "";
    
    // prepare the base metabase wrapper
    CWrapMetaBase   mbBase;
    f = mbBase.FInit(m_pMB);
    if ( !f )
        {
        AfxMessageBox( IDS_ERR_ACCESS_MAPPING );
        return FALSE;
        }

        // first, we have to open the Cert11Mappings object. If it doesn't exist
        // then we have to add it to the metabase
        if ( !mbBase.Open( szBasePath, METADATA_PERMISSION_READ|METADATA_PERMISSION_WRITE ) )
            {
            // Cert11Mappings does not exist - open the namespace base and add it
            szTempPath = m_szMBPath + _T('/');
            if ( !mbBase.Open( szTempPath, METADATA_PERMISSION_READ|METADATA_PERMISSION_WRITE ) )
                {
                AfxMessageBox( IDS_ERR_ACCESS_MAPPING );
                return FALSE;   // serious problems if we can't open the base
                }

            // add the Cert11Mappings object
            szTempPath = MB_EXTEND_KEY_MAPS;
            f = mbBase.AddObject( szTempPath );
            mbBase.Close();
            if ( !f )
                {
                AfxMessageBox( IDS_ERR_CANTADD );
                return FALSE;
                }

            // try again to open the Cert11Mappings. Fail if it doesn't work
            if ( !mbBase.Open( szBasePath, METADATA_PERMISSION_READ|METADATA_PERMISSION_WRITE ) )
                {
                AfxMessageBox( IDS_ERR_ACCESS_MAPPING );
                return FALSE;
                }
            }

    //==========
    // start by deleting all the mappings in the to-be-deleted list
    cMappings = (DWORD)m_rgbDelete.GetSize();

    // only bother if there are items waiting to be deleted
    if ( cMappings > 0 )
        {
        // get the count of mappings in the display list
        DWORD   cList = m_clistctrl_list.GetItemCount();


        // loop the mappings, deleting each from the metabase
        for ( i = 0; i < cMappings; i++ )
            {
            // get the mapping object
            pMap = (C11Mapping*)m_rgbDelete[i];
            if ( !pMap || (pMap->QueryNodeName() == "" /*NEW_OBJECT*/) )
                continue;

            // build the relative path to the object in question.
            szObjectPath.Format( _T("%s"), pMap->QueryNodeName() );

            // delete that mapping's object from the metabase
            f = mbBase.DeleteObject( szObjectPath );

            // decrement the number of maps in the metabase
            m_MapsInMetabase--;

            // since we will no longer be needing this mapping, delete it
            DeleteMapping( pMap );
            }

        // reset the to-be-deleted list
        m_rgbDelete.RemoveAll();
        }

    //==========
    // get the number mappings in the to-be-saved list
    cMappings = (DWORD)m_rgbSave.GetSize();

    // loop the mappings, adding each to the metabase
    for ( i = 0; i < cMappings; i++ )
        {
        // get the mapping object
        pMap = (C11Mapping*)m_rgbSave[i];
        ASSERT( pMap );

        // if the object is already in the metabase, just open it.
        if ( pMap->QueryNodeName() != "" /*NEW_OBJECT*/ )
            {
            // build the relative path to the object
            szObjectPath.Format( _T("%s"), pMap->QueryNodeName() );
            }
        else
            {
            // set up the name of the new mapping node to be equal
            // to SHA1 hash of the certificate

            pMap->SetNodeName( pMap->QueryCertHash() );
            // build the relative path to the object
            szObjectPath.Format( _T("%s"), pMap->QueryNodeName() );
            
            if ( !szObjectPath.IsEmpty() )    
                {
                // add the mapping object to the base
                f = mbBase.AddObject( szObjectPath );
                if ( f )
                    {
                    // increment the number of maps in the metabase
                    m_MapsInMetabase++;
                    }
                // reset error of Adding object 
                // most likely node already exists
                // CODEWORK: 04/08/02 jaroslad - this function is very optimistic
                // it ignores errors that happen during process of saving mapping data
                f = TRUE; 
                }
            }
        // write the object's parameters
        if ( f && !szObjectPath.IsEmpty() )
            {
            // save the certificate
            if ( pMap->GetCertificate(&pCert, &cbCert) )
                {
                // set the data into place in the object
                f = mbBase.SetData( szObjectPath, MD_MAPCERT, IIS_MD_UT_SERVER, BINARY_METADATA,
                pCert, cbCert, 0 );
                }

            // save the NTAccount
            if ( pMap->GetNTAccount(sz) )
                {
                // set the data into place in the object
                f = mbBase.SetString(szObjectPath, MD_MAPNTACCT, IIS_MD_UT_SERVER, sz, 0 );
                }

            // save the password - secure
            if ( pMap->GetNTPassword(cspTempPassword) )
                {
                // set the data into place in the object
                CString csTempPassword;
                cspTempPassword.CopyTo(csTempPassword);
                f = mbBase.SetString(szObjectPath, MD_MAPNTPWD, IIS_MD_UT_SERVER, 
                                      csTempPassword, METADATA_SECURE);
                }

            // save the map's name
            if ( pMap->GetMapName(sz) )
                {
                // set the data into place in the object
                f = mbBase.SetString(szObjectPath, MD_MAPNAME, IIS_MD_UT_SERVER, sz, 0);
                }

            // save the Enabled flag
            // server reads the flag as the value of the dword
            if ( pMap->GetMapEnabled(&f) )
                {
                dwEnabled = (DWORD)f;
                f = mbBase.SetDword( szObjectPath, MD_MAPENABLED, IIS_MD_UT_SERVER, dwEnabled, 0 );
                }
            }
        }

    // close the base object
    mbBase.Close();

    // save the metabase
    mbBase.Save();

    // reset the to-be-saved list
    m_rgbSave.RemoveAll();

    // return success
    return TRUE;
    }

//---------------------------------------------------------------------------
C11Mapping*     CMap11Page::PNewMapping()
    {
    // the way it should be
    return new C11Mapping();
    }

//---------------------------------------------------------------------------
void CMap11Page::DeleteMapping( C11Mapping* pMap )
    {
    // the way it should be
    delete pMap;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\listrow.h ===
// ListRow.h : header file
//


#ifndef _LISTROW_
#define _LISTROW_

/////////////////////////////////////////////////////////////////////////////
// CListSelRowCtrl window

class CListSelRowCtrl : public CListCtrl
{
// Construction
public:
    CListSelRowCtrl();

    virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CListSelRowCtrl)
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CListSelRowCtrl();

    // Generated message map functions
protected:
    //{{AFX_MSG(CListSelRowCtrl)
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void GetHiliteColors();

    void HiliteSelectedCells();
    void HiliteSelectedCell( int iCell, BOOL fHilite = TRUE );
    BOOL FGetCellRect( LONG iRow, LONG iCol, CRect *pcrect );

    void FitString( CString &sz, int cpWidth, CDC* pcdc );

    CBitmap     m_bitmapCheck;
    COLORREF    m_colorHiliteText;
    COLORREF    m_colorHilite;

    DWORD       m_StartDrawingCol;

};

/////////////////////////////////////////////////////////////////////////////
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\mapwpge.cpp ===
// MapWPge.cpp : implementation file
//

#include "stdafx.h"
#include <iadmw.h>
#include "certmap.h"

extern "C"
    {
    #include <wincrypt.h>
    #include <schannel.h>
    }

#include "Iismap.hxx"
#include "Iiscmr.hxx"

#include "brwsdlg.h"
#include "ListRow.h"
#include "ChkLstCt.h"

#include "MapWPge.h"
#include "Ed11Maps.h"
#include "EdWldRul.h"

#include <iiscnfgp.h>
#include "wrapmb.h"

#include "WWzOne.h"
#include "WWzTwo.h"
#include "WWzThree.h"

#include <lmcons.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#define COL_NUM_ENABLED                 0
#define COL_NUM_DESCRIPTION             1
#define COL_NUM_NTACCOUNT               2


//
// valid only when accessing IIS5.1 or IIS5
//
#define MB_EXTEND_KEY   "CertW"

/////////////////////////////////////////////////////////////////////////////
// CMapWildcardsPge property page

IMPLEMENT_DYNCREATE(CMapWildcardsPge, CPropertyPage)

//---------------------------------------------------------------------------
CMapWildcardsPge::CMapWildcardsPge() : CPropertyPage(CMapWildcardsPge::IDD),
    m_fDirty(FALSE)
    {
    //{{AFX_DATA_INIT(CMapWildcardsPge)
    m_bool_enable = FALSE;
    //}}AFX_DATA_INIT
    m_fIsIIS6 = TRUE;
    }

//---------------------------------------------------------------------------
CMapWildcardsPge::~CMapWildcardsPge()
    {
    }

//---------------------------------------------------------------------------
void CMapWildcardsPge::DoDataExchange(CDataExchange* pDX)
    {
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CMapWildcardsPge)
    DDX_Control(pDX, IDC_LIST, m_clistctrl_list);
    DDX_Control(pDX, IDC_MOVE_UP, m_cbutton_up);
    DDX_Control(pDX, IDC_MOVE_DOWN, m_cbutton_down);
    DDX_Control(pDX, IDC_ADD, m_cbutton_add);
    DDX_Control(pDX, IDC_DELETE, m_cbutton_delete);
    DDX_Control(pDX, IDC_EDIT, m_cbutton_editrule);
    DDX_Check(pDX, IDC_ENABLE, m_bool_enable);
    //}}AFX_DATA_MAP
    }


//---------------------------------------------------------------------------
BEGIN_MESSAGE_MAP(CMapWildcardsPge, CPropertyPage)
    //{{AFX_MSG_MAP(CMapWildcardsPge)
    ON_BN_CLICKED(IDC_MOVE_DOWN, OnMoveDown)
    ON_BN_CLICKED(IDC_MOVE_UP, OnMoveUp)
    ON_BN_CLICKED(IDC_ADD, OnAdd)
    ON_BN_CLICKED(IDC_DELETE, OnDelete)
    ON_BN_CLICKED(IDC_EDIT, OnEdit)
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST, OnItemchangedList)
    ON_NOTIFY(NM_DBLCLK, IDC_LIST, OnDblclkList)
    ON_BN_CLICKED(IDC_ENABLE, OnEnable)
    //}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,  DoHelp)
    ON_COMMAND(ID_HELP,         DoHelp)
    ON_COMMAND(ID_CONTEXT_HELP, DoHelp)
    ON_COMMAND(ID_DEFAULT_HELP, DoHelp)
END_MESSAGE_MAP()

//---------------------------------------------------------------------------
void CMapWildcardsPge::DoHelp()
    {
    WinHelpDebug(HIDD_CERTMAP_MAIN_ADVANCED);
    WinHelp( HIDD_CERTMAP_MAIN_ADVANCED );
    }

/////////////////////////////////////////////////////////////////////////////
// initialization routines

//---------------------------------------------------------------------------
// FInitMapper is called by the routine instantiating this page. After the object
// is first created is when it is called. It allows us to fail gracefully.
BOOL CMapWildcardsPge::FInit(IMSAdminBase* pMB)
    {
    BOOL            fAnswer = FALSE;
    PVOID           pData = NULL;
    DWORD           cbData = 0;
    BOOL            f;

    m_pMB = pMB;

    // before messing with the metabase, prepare the strings we will need
    CString         szObjectPath;

    // check if it's for older than iis6 version
	m_fIsIIS6 = TRUE;
	if (IsLegacyMetabase(pMB)){m_fIsIIS6 = FALSE;}

    if ( !m_fIsIIS6 )
    {
        szObjectPath = m_szMBPath + SZ_NAMESPACE_EXTENTION +
                       _T('/') + MB_EXTEND_KEY;
    }
    else
    {
        szObjectPath = m_szMBPath;
    }
        

    // prepare the metabase wrapper
    CWrapMetaBase   mbWrap;
    f = mbWrap.FInit(m_pMB);
    if ( !f ) return FALSE;

    // attempt to open the object we want to store into
    f = mbWrap.Open( szObjectPath, METADATA_PERMISSION_READ );

    // if that worked, load the data
    if ( f )
        {
        // first, get the size of the data that we are looking for
        pData = mbWrap.GetData( _T(""), MD_SERIAL_CERTW, IIS_MD_UT_SERVER, BINARY_METADATA, &cbData );

        // if we successfully got the data, unserialize it
        // WARNING: m_mapper.Unserialize changes the value of the pointer that is passed in. Pass
        // in a copy of the pointer
        PUCHAR  pDataCopy = (PUCHAR)pData;
        if ( pData && (cbData > 0))
            fAnswer = m_mapper.Unserialize( (PUCHAR*)&pDataCopy, &cbData );

        // close the object
        f = mbWrap.Close();

        // cleanup
        if ( pData )
            mbWrap.FreeWrapData( pData );
        }

    // return the answer
    return fAnswer;
    }

//---------------------------------------------------------------------------
BOOL CMapWildcardsPge::OnInitDialog()
    {
    //call the parental oninitdialog
    BOOL f = CPropertyPage::OnInitDialog();

    // if the initinalization (sp?) succeeded, init the list and other items
    if ( f )
        {
        // init the contents of the list
        FInitRulesList();

        // Fill the mapping list with the stored items
        FillRulesList();

        // set the initial button states
        EnableDependantButtons();
        }

    // set the initial state of the enable button
    // get the globals object
    CCertGlobalRuleInfo* pGlob = m_mapper.GetGlobalRulesInfo();
    m_bool_enable = pGlob->GetRulesEnabled();

    // set any changes in the info into place
    UpdateData(FALSE);

    // return the answer
    return f;
    }

//---------------------------------------------------------------------------
BOOL CMapWildcardsPge::FInitRulesList()
    {
    CString sz;
    int             i;

    // setup the friendly name column
    sz.Empty();
    i = m_clistctrl_list.InsertColumn( COL_NUM_ENABLED, sz, LVCFMT_LEFT, 20 );

    // setup the description column
    sz.LoadString( IDS_WILD_DESCRIPTION );
    i = m_clistctrl_list.InsertColumn( COL_NUM_DESCRIPTION, sz, LVCFMT_LEFT, 238 );

    // setup the account column
    sz.LoadString( IDS_WILD_ACCOUNT );
    i = m_clistctrl_list.InsertColumn( COL_NUM_NTACCOUNT, sz, LVCFMT_LEFT, 220 );

    return TRUE;
    }

//---------------------------------------------------------------------------
// fill in the rules. Get the order for the rules from the globals object. That
// way there is no need to sort them later
BOOL CMapWildcardsPge::FillRulesList()
    {
    // get the globals object
    CCertGlobalRuleInfo* pGlob = m_mapper.GetGlobalRulesInfo();

    // get the number of rules (actually its a number of rule order - but they are the same thing)
    DWORD   cbRules = m_mapper.GetRuleCount();

    // get the pointer to the order array
    DWORD*  pOrder = pGlob->GetRuleOrderArray();

    // for each item in the mapper object, add it to the list control
    for ( DWORD j = 0; j < cbRules; j++ )
        {
        CCertMapRule*   pRule;
        DWORD                   iRule = pOrder[j];

        // get the mapping
        pRule = m_mapper.GetRule( iRule );

        // if that worked, add it to the list
        if ( pRule )
            {
            // add it to the list
            AddRuleToList( pRule, iRule, 0xffffffff );
            }
        }

    // it worked - so ok.
    return TRUE;
    }

//---------------------------------------------------------------------------
int CMapWildcardsPge::AddRuleToList( CCertMapRule* pRule, DWORD iRule, int iInsert )
    {
    CString sz;
    int             i;

    if ( !pRule )
        return -1;

    // if the item to be inserted is to be the last, set it up
    if ( iInsert == 0xffffffff )
        iInsert = m_clistctrl_list.GetItemCount();

    // get the appropriate "enabled" string
    BOOL fEnabled = pRule->GetRuleEnabled();
    if ( fEnabled )
        sz.LoadString( IDS_ENABLED );
    else
        sz.Empty();

    // add the friendly name of the mapping
    // create the new entry in the list box. Do not sort on this entry - yet
    i = m_clistctrl_list.InsertItem( iInsert, sz );

    // add the friendly name of the rule
    sz = pRule->GetRuleName();
    // create the new entry in the list box. Do not sort on this entry - yet
    m_clistctrl_list.SetItemText( i, COL_NUM_DESCRIPTION, sz );

    // add the account name of the mapping
    if ( pRule->GetRuleDenyAccess() )
        sz.LoadString( IDS_DENYACCESS );
    else
        sz = pRule->GetRuleAccount();
    m_clistctrl_list.SetItemText( i, COL_NUM_NTACCOUNT, sz );

    // attach the mapper index to the item in the list - it may have a different
    // list index after the list has been sorted.
    m_clistctrl_list.SetItemData( i, iRule );

    // return whether or not the insertion succeeded
    return i;
    }

//---------------------------------------------------------------------------
// Note: supposedly, the order of the items in the list and the odrder
// of the items in the globals object should be the same
void CMapWildcardsPge::UpdateRuleInDispList( DWORD iList, CCertMapRule* pRule )
    {
    CString sz;

    // get the appropriate "enabled" string
    BOOL fEnabled = pRule->GetRuleEnabled();
    if ( fEnabled )
        sz.LoadString( IDS_ENABLED );
    else
        sz.Empty();

    // update the "Enabled" indicator
    m_clistctrl_list.SetItemText( iList, COL_NUM_ENABLED, sz );

    // update the mapping name
    sz = pRule->GetRuleName();
    m_clistctrl_list.SetItemText( iList, COL_NUM_DESCRIPTION, sz );

    // update the account name
    if ( pRule->GetRuleDenyAccess() )
        sz.LoadString( IDS_DENYACCESS );
    else
        sz = pRule->GetRuleAccount();
    m_clistctrl_list.SetItemText( iList, COL_NUM_NTACCOUNT, sz );
    }


//---------------------------------------------------------------------------
// editing a wildcard rule is rather complex, thus I am seperating that code
// out into that for the dialog itself. All we do is pass in the rule pointer
// and let it go at that.
BOOL CMapWildcardsPge::EditOneRule( CCertMapRule* pRule, BOOL fAsWizard )
    {
    // edit the item using a tabbed dialog / wizard
    CPropertySheet  propSheet;
    CWildWizOne     wwOne;
    CWildWizTwo     wwTwo;
    CWildWizThree   wwThree;

    // set the params
    wwOne.m_pMB = m_pMB;

    // fill in the data for the pages
    wwOne.m_pRule = pRule;
    wwOne.m_szMBPath = m_szMBPath;
    wwOne.m_fIsWizard = fAsWizard;
    wwOne.m_pPropSheet = &propSheet;

    wwTwo.m_pRule = pRule;
    wwTwo.m_szMBPath = m_szMBPath;
    wwTwo.m_fIsWizard = fAsWizard;
    wwTwo.m_pPropSheet = &propSheet;

    wwThree.m_pRule = pRule;
    wwThree.m_szMBPath = m_szMBPath;
    wwThree.m_fIsWizard = fAsWizard;
    wwThree.m_pPropSheet = &propSheet;

    // add the pages
    propSheet.AddPage( &wwOne );
    propSheet.AddPage( &wwTwo );
    propSheet.AddPage( &wwThree );

    // turn it into a wizard if necessary
    if ( fAsWizard )
        propSheet.SetWizardMode();

    // set the title of the wizard/tabbed dialog thing
    CString   szTitle;

    szTitle.LoadString( IDS_WILDWIZ_TITLE );

    propSheet.SetTitle( szTitle );

    // turn on help
    propSheet.m_psh.dwFlags |= PSH_HASHELP;
    wwOne.m_psp.dwFlags |= PSP_HASHELP;
    wwTwo.m_psp.dwFlags |= PSP_HASHELP;
    wwThree.m_psp.dwFlags |= PSP_HASHELP;

    // run the wizard and return if it ended with IDOK
    INT_PTR id = propSheet.DoModal();
    return ( (id == IDOK) || (id == ID_WIZFINISH) );

 /*
   CEditWildcardRule       ruleDlg;

    // prepare
    ruleDlg.m_pRule = pRule;
    ruleDlg.m_szMBPath = m_szMBPath;

    // run the dialog and return if it ended with IDOK
    return (ruleDlg.DoModal() == IDOK);
*/
    }

//---------------------------------------------------------------------------
// Yeah! the CEdit11Mappings works equally well for multiple rules! - just
// some modifications in this routine!
BOOL CMapWildcardsPge::EditMultipleRules()
    {
    CEdit11Mappings mapdlg;
    CCertMapRule*   pRule;
    BOOL                    fSetInitialState = FALSE;
    BOOL                    fEnable;


    // scan the list of seleted items for the proper initial enable button state
    // loop through the selected items, setting each one's mapping
    int     iList = -1;
    while( (iList = m_clistctrl_list.GetNextItem( iList, LVNI_SELECTED )) >= 0 )
        {
        // get the mapper index for the item
        // IA64 - this is OK to cast to DWORD as it is just an index
        DWORD iMapper = (DWORD)m_clistctrl_list.GetItemData( iList );

        // get the mapping item for updating purposes
        pRule = m_mapper.GetRule( iMapper );
        if ( !pRule )
            {
            AfxMessageBox( IDS_ERR_ACCESS_MAPPING );
            break;
            }

        // get the enable state of the mapping
        fEnable = pRule->GetRuleEnabled();

        // if this is the first time, just set the initial state
        if ( !fSetInitialState )
            {
            mapdlg.m_int_enable = fEnable;
            fSetInitialState = TRUE;
            }
        else
            {
            // if it is different, then go indeterminate and break
            if ( fEnable != mapdlg.m_int_enable )
                {
                mapdlg.m_int_enable = 2;
                break;
                }
            }
        }

    //
    // ANSI/UNICODE conversion - RonaldM
    //
    USES_CONVERSION;

    // run the mapping dialog
    if ( mapdlg.DoModal() == IDOK )
        {
        // loop through the selected items, setting each one's mapping
        int     iList = -1;
        while( (iList = m_clistctrl_list.GetNextItem( iList, LVNI_SELECTED )) >= 0 )
            {
            // get the mapper index for the item
            // IA64 - this is OK to cast to DWORD as it is just an index
            DWORD iMapper = (DWORD)m_clistctrl_list.GetItemData( iList );

            // get the mapping item for updating purposes
            pRule = m_mapper.GetRule( iMapper );
            if ( !pRule )
                {
                AfxMessageBox( IDS_ERR_ACCESS_MAPPING );
                break;
                }

            // set the enable flag if requested
            switch ( mapdlg.m_int_enable )
                {
                case 0:         // disable
                    pRule->SetRuleEnabled( FALSE );
                    break;
                case 1:         // enable
                    pRule->SetRuleEnabled( TRUE );
                    break;
                }

            // set the NT account field of the mapping object
            pRule->SetRuleAccount( T2A ((LPTSTR)(LPCTSTR)mapdlg.m_sz_accountname) );

            // update it in the list control too
            UpdateRuleInDispList( iList, pRule );
            }

        // activate the apply button
        SetModified();
        m_fDirty = TRUE;

        // return true because the user said "OK"
        return TRUE;
        }

    // return FALSE because the user did not say "OK"
    return FALSE;
    }

//---------------------------------------------------------------------------
void CMapWildcardsPge::EnableDependantButtons()
    {
    // the whole purpose of this routine is to gray or activate
    // the edit and delete buttons depending on whether or not anything
    // is selected. So start by getting the selection count
    UINT    cItemsSel = m_clistctrl_list.GetSelectedCount();

    // if there is only one item selected, then possibly activate the up/down buttons
    if ( cItemsSel == 1 )
        {
        m_cbutton_up.EnableWindow( TRUE );
        m_cbutton_down.EnableWindow( TRUE );
        }
    else
        {
        m_cbutton_up.EnableWindow( FALSE );
        m_cbutton_down.EnableWindow( FALSE );
        }

    // now the more general case of multiple selections
    if ( cItemsSel > 0 )
        {
        // there are items selected
        m_cbutton_editrule.EnableWindow( TRUE );
        m_cbutton_delete.EnableWindow( TRUE );
        }
    else
        {
        // nope. Nothing selected
        m_cbutton_editrule.EnableWindow( FALSE );
        m_cbutton_delete.EnableWindow( FALSE );
        }

    // always enable the add button
    m_cbutton_add.EnableWindow( TRUE );
    }


/////////////////////////////////////////////////////////////////////////////
// CMapWildcardsPge message handlers

//---------------------------------------------------------------------------
BOOL CMapWildcardsPge::OnApply()
    {
    BOOL                            f;
    CStoreXBF                       xbf;
    METADATA_HANDLE         hm;

    // if no changes have been made, then don't do anything
    if ( !m_fDirty )
        return TRUE;

    UpdateData( TRUE );

    CWaitCursor wait;

    // set the current value of enable into place
    // get the globals object
    CCertGlobalRuleInfo* pGlob = m_mapper.GetGlobalRulesInfo();
    pGlob->SetRulesEnabled( m_bool_enable );

    // serialize the reference to the mapper itself
    f = m_mapper.Serialize( &xbf );

    // before messing with the metabase, prepare the strings we will need
    CString         szBasePath;
    CString         szRelativePath;
    CString         szObjectPath;

    if( !m_fIsIIS6 )
    {
        szBasePath = m_szMBPath;
        szRelativePath = MB_EXTEND_KEY;
        szObjectPath = m_szMBPath + _T('/') + szRelativePath;
    }
    else
    {
        //
        // On IIS6 and higher the CertW mapping info is saved
        // directly under the site node
        //
        szBasePath = m_szMBPath;
        szRelativePath = "";
        szObjectPath = m_szMBPath; 
    }

    // prepare the metabase wrapper
    CWrapMetaBase   mbWrap;
    f = mbWrap.FInit(m_pMB);


    // attempt to open the object we want to store into
    f = mbWrap.Open( szObjectPath, METADATA_PERMISSION_WRITE );

    // if that did not work, we need to add the object
    if ( !f )
        {
        // if szRelativePath is empty then fail right away
        // because there is no new node to be added
        if ( szRelativePath.IsEmpty() )
            {
            if ( !f )
                {
                AfxMessageBox(IDS_ERR_ACCESS_MAPPING);
                return FALSE;
                }
            }
        // need a slash after the namespace extention now
        szBasePath += _T('/');

        // open the base object
        f = mbWrap.Open( szBasePath, METADATA_PERMISSION_WRITE );

        if ( !f )
            {
            AfxMessageBox(IDS_ERR_ACCESS_MAPPING);
            return FALSE;
            }

        // add the object we want
        f = mbWrap.AddObject( szRelativePath );
        if ( !f )
            {
            AfxMessageBox(IDS_ERR_ACCESS_MAPPING);
            mbWrap.Close();
            return FALSE;
            }

        // close the base object
        f = mbWrap.Close();

        // attempt to open the object we want to store into
        f = mbWrap.Open( szObjectPath, METADATA_PERMISSION_WRITE );
        }

    // set the data into place in the object - If we were able to open it
    if ( f )
    {
        mbWrap.SetData( _T(""), MD_SERIAL_CERTW, IIS_MD_UT_SERVER, BINARY_METADATA, xbf.GetBuff(), xbf.GetUsed(), METADATA_SECURE );
    } 
    // close the object
    f = mbWrap.Close();

    // save the changes to the metabase
    f = mbWrap.Save();

    // tell the persistence object to tuck away the reference so that we may find it later
    // f = m_persist.FSave( xbf.GetBuff(), xbf.GetUsed() );

    // deactivate the apply button
    SetModified( FALSE );
    m_fDirty = FALSE;

    //  return f;
    return TRUE;
    }

//---------------------------------------------------------------------------
void CMapWildcardsPge::OnMove( int delta )
    {
    int    iList;

    ASSERT( delta != 0 );

    // make sure there is only one item selected
    ASSERT( m_clistctrl_list.GetSelectedCount() == 1 );

    // Get the list index of the item in question.
    // this is also the index into the rule order array
    iList = m_clistctrl_list.GetNextItem( -1, LVNI_SELECTED );

    // get the globals object
    CCertGlobalRuleInfo* pGlob = m_mapper.GetGlobalRulesInfo();

    // get the number of rules (actually its a number of rule order - but they are the same thing)
    int     cbRules = pGlob->GetRuleOrderCount();

    // test against the edge conditions
    if ( ((iList == 0) && (delta < 0)) | ((iList == (cbRules - 1)) && (delta > 0)) )
        return;

    // get the pointer to the order array
    DWORD * pOrder = pGlob->GetRuleOrderArray();

    // calculate the new position in the array
    int iNewPosition = iList + delta;

    // store away the mapper's iIndex (not the position) of the item
    UINT iIndex = pOrder[iList];

    // swap the positions
    DWORD itemp = pOrder[iNewPosition];
    pOrder[iNewPosition] = pOrder[iList];
    pOrder[iList] = itemp;

    ASSERT( pOrder[iNewPosition] == iIndex );

    // unfortunately, we can't just do that with the display list. We have to remove the
    // the item, then re-insert it. Its a flaw in the CListCtrl object. Arg.
    // we have to get the item too
    CCertMapRule* pRule = m_mapper.GetRule( iIndex );

    // delete the item from the display list
    m_clistctrl_list.DeleteItem( iList );

    // re-insert it
    int iNew = AddRuleToList( pRule, iIndex, iNewPosition );

    // make sure it is visible in the list
    m_clistctrl_list.EnsureVisible( iNew, FALSE );

    // finally, because its been removed and re-inserted, we need to
    // re-select it as well - CListCtrl is such a pain at this
    LV_ITEM         lv;
    ZeroMemory( &lv, sizeof(lv) );
    lv.mask = LVIF_STATE;
    lv.iItem = iNew;
    lv.state = LVIS_SELECTED;
    lv.stateMask = LVIS_SELECTED;
    m_clistctrl_list.SetItem( &lv );

    // activate the apply button
    SetModified();
    m_fDirty = TRUE;
    }

//---------------------------------------------------------------------------
void CMapWildcardsPge::OnMoveDown()
    {
    OnMove( 1 );
    }

//---------------------------------------------------------------------------
void CMapWildcardsPge::OnMoveUp()
    {
    OnMove( -1 );
    }

//---------------------------------------------------------------------------
void CMapWildcardsPge::OnAdd()
    {
    CHAR sz[256];

    // create the new rule
    CCertMapRule * pNewRule = new CCertMapRule();

    if (pNewRule == NULL)
        return;

    // give the new rule some defaults
    LoadStringA(::AfxGetInstanceHandle(), IDS_DEFAULT_RULE, sz, 255 );

    pNewRule->SetRuleName( sz );
    pNewRule->SetRuleEnabled( TRUE );

    // Edit the rule. If it fails, remove it from the list
    if ( !EditOneRule( pNewRule, TRUE ) )
        {
        // kill the rule and return
        delete pNewRule;
        return;
        }

    // make a new mapper & get its index
    DWORD iNewRule = m_mapper.AddRule( pNewRule );

    // add the rule to the end of the display list. - It is added to the
    // end of the rule list by default
    AddRuleToList( pNewRule, iNewRule );

    // make sure it is visible in the list
    m_clistctrl_list.EnsureVisible( iNewRule, FALSE );

    // activate the apply button
    SetModified();
    m_fDirty = TRUE;
    }

//---------------------------------------------------------------------------
void CMapWildcardsPge::OnDelete()
    {
    // ask the user to confirm this decision
    if ( AfxMessageBox(IDS_CONFIRM_DELETE, MB_OKCANCEL) != IDOK )
        return;

    CWaitCursor wait;

    // loop through the selected items, setting each one's mapping
    int     iList = -1;
    while( (iList = m_clistctrl_list.GetNextItem( -1, LVNI_SELECTED )) >= 0 )
        {
        // get the mapper index for the item
        // IA64 - this is OK to cast to DWORD as it is just an index
        DWORD iMapper = (DWORD)m_clistctrl_list.GetItemData( iList );

        // delete the mapping from the mapper
        m_mapper.DeleteRule( iMapper );

        // delete the entry from the list box
        m_clistctrl_list.DeleteItem( iList );


        // because the index in the mapper for all the items below this
        // one changes when it is deleted, we must go and fix them all.
        DWORD numItems = m_clistctrl_list.GetItemCount();
        for ( DWORD iFix = iList; iFix < numItems; iFix++ )
            {
            // get the mapper index for the item to be fixed
            // IA64 - this is OK to cast to DWORD as it is just an index
            iMapper = (DWORD)m_clistctrl_list.GetItemData( iFix );

            // decrement it to reflect the change
            iMapper--;

            // put it back.
            m_clistctrl_list.SetItemData( iFix, iMapper );
            }
        }

    // activate the apply button
    SetModified();
    m_fDirty = TRUE;
    }

//---------------------------------------------------------------------------
void CMapWildcardsPge::OnEdit()
    {
    int             iList;
    DWORD           iRule;
    CCertMapRule*   pUpdateRule;

    // what happens here depends on if just one mapping is selected, or many
    switch( m_clistctrl_list.GetSelectedCount() )
        {
        case 0:         // do nothing - should not get here because button grays out
            ASSERT( FALSE );
            break;

        case 1:         // get the mapping for update and run single edit dialog
            // get index of the selected list item
            iList = m_clistctrl_list.GetNextItem( -1, LVNI_SELECTED );
            ASSERT( iList >= 0 );

            // get the mapper index for the item
            // IA64 - this is OK to cast to DWORD as it is just an index
            iRule = (DWORD)m_clistctrl_list.GetItemData( iList );

            // get the mapping item for updating purposes
            pUpdateRule = m_mapper.GetRule( iRule );

            if ( !pUpdateRule )
                {
                AfxMessageBox( IDS_ERR_ACCESS_MAPPING );
                break;
                }

            // edit the mapping, update it if successful, delete if not
            if ( EditOneRule(pUpdateRule) )
                {
                UpdateRuleInDispList( iList, pUpdateRule );
                // activate the apply button
                SetModified();
                m_fDirty = TRUE;
                }
            break;

        default:        // run the multi edit dialog
            EditMultipleRules();
            break;
        }
    }

//---------------------------------------------------------------------------
void CMapWildcardsPge::OnItemchangedList(NMHDR* pNMHDR, LRESULT* pResult)
    {
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
    *pResult = 0;

    // enable the correct items
    EnableDependantButtons();
    }

//---------------------------------------------------------------------------
void CMapWildcardsPge::OnDblclkList(NMHDR* pNMHDR, LRESULT* pResult)
    {
    *pResult = 0;

    // if something in the list was double clicked, edit it
    if ( m_clistctrl_list.GetSelectedCount() > 0 )
       OnEdit();
    }

//---------------------------------------------------------------------------
void CMapWildcardsPge::OnEnable()
    {
    // activate the apply button
    SetModified();
    m_fDirty = TRUE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\map11pge.h ===
// Map11Pge.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CMap11Page dialog

class CMap11Page : public CPropertyPage
{
    DECLARE_DYNCREATE(CMap11Page)

// Construction
public:
    CMap11Page();
    ~CMap11Page();

    BOOL    FInit(IMSAdminBase* pMB);

    virtual BOOL OnApply();
    virtual BOOL OnInitDialog();

    // base path for to the metabase
    CString m_szMBPath;

// Dialog Data
    //{{AFX_DATA(CMap11Page)
    enum { IDD = IDD_11CERT_MAPPING };
    CCheckListCtrl  m_clistctrl_list;
    CButton m_cbutton_add;
    CButton m_cbutton_grp_issuer;
    CButton m_cbutton_grp_issuedto;
    CButton m_cbutton_editmap;
    CButton m_cbutton_delete;
    CString m_csz_i_c;
    CString m_csz_i_o;
    CString m_csz_i_ou;
    CString m_csz_s_c;
    CString m_csz_s_cn;
    CString m_csz_s_l;
    CString m_csz_s_o;
    CString m_csz_s_ou;
    CString m_csz_s_s;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CMap11Page)
    public:
    virtual void OnOK();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CMap11Page)
    afx_msg void OnAdd();
    afx_msg void OnDelete();
    afx_msg void OnEdit11map();
    afx_msg void OnItemchangedList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnDblclkList(NMHDR* pNMHDR, LRESULT* pResult);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    afx_msg void DoHelp();

    // more initialization methods
    BOOL FInitMappingList();
    BOOL FillMappingList();

    // more initialization methods
    BOOL FReadMappings();
    BOOL FWriteMappings();

    BOOL FReadMappingsIIS6();
    BOOL FWriteMappingsIIS6();

    // control the maps in the list
//  BOOL FAddMappingToList( C11Mapping* pMap, DWORD iMap );
//  BOOL FAddMappingToList( C11Mapping* pMap, DWORD iList = 0xFFFFFFFF );
    // always adds to the end of the list
    BOOL FAddMappingToList( C11Mapping* pMap );

    // editing and updating
    BOOL EditOneMapping( C11Mapping* pUpdateMap );
    BOOL EditMultipleMappings();
    void EnableDependantButtons();
    void UpdateMappingInDispList( DWORD iList, C11Mapping* pUpdateMap );

    // adding a new certificate
    BOOL FAddCertificateFile( CString szFile );
    BOOL FAddCertificate( PUCHAR pCertificate, DWORD cbCertificate );

    // special display
    BOOL DisplayCrackedMap( C11Mapping* pUpdateMap );
    void ClearCrackDisplay();
    void EnableCrackDisplay( BOOL fEnable = TRUE );

    void ResetMappingList();
    C11Mapping* GetMappingInDisplay( DWORD iList ) {return (C11Mapping*)m_clistctrl_list.GetItemData(iList);}
    void MarkToSave( C11Mapping* pSaveMap, BOOL fSave = TRUE );

    C11Mapping* PNewMapping();
    void DeleteMapping( C11Mapping* pMap );

    BOOL Get11String(CWrapMetaBase* pmb, LPCTSTR pszPath, DWORD dwPropID, CString& sz);
    BOOL Set11String(CWrapMetaBase* pmb, LPCTSTR pszPath, DWORD dwPropID, CString& sz, DWORD dwFlags = METADATA_INHERIT);

    // list of names of objects to be deleted
    CObArray    m_rgbDelete;

    // list of objects to be saved
    CObArray    m_rgbSave;

    // number of objects in the etabase
    DWORD   m_MapsInMetabase;

    IMSAdminBase*   m_pMB;

    // flag to determine IIS version. In IIS6 new way 
    // of persisting mappings is used
    BOOL m_fIsIIS6;
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\mapwpge.h ===
// MapWPge.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CMapWildcardsPge dialog

class CMapWildcardsPge : public CPropertyPage
{
    DECLARE_DYNCREATE(CMapWildcardsPge)

// Construction
public:
    CMapWildcardsPge();
    ~CMapWildcardsPge();

    BOOL    FInit(IMSAdminBase* pMB);

    virtual BOOL OnApply();
    virtual BOOL OnInitDialog();

    // base path for to the metabase
    CString m_szMBPath;


// Dialog Data
    //{{AFX_DATA(CMapWildcardsPge)
    enum { IDD = IDD_WILDCARDS_1 };
    CCheckListCtrl  m_clistctrl_list;
    CButton m_cbutton_up;
    CButton m_cbutton_down;
    CButton m_cbutton_add;
    CButton m_cbutton_delete;
    CButton m_cbutton_editrule;
    BOOL    m_bool_enable;
    BOOL    m_fIsIIS6;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CMapWildcardsPge)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CMapWildcardsPge)
    afx_msg void OnMoveDown();
    afx_msg void OnMoveUp();
    afx_msg void OnAdd();
    afx_msg void OnDelete();
    afx_msg void OnEdit();
    afx_msg void OnItemchangedList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnDblclkList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnEnable();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void DoHelp();


    // more initialization methods
    BOOL FInitRulesList();
    BOOL FillRulesList();

    // editing and updating
    void EnableDependantButtons();

    int AddRuleToList( CCertMapRule* pRule, DWORD iRule, int iInsert = 0xffffffff );
    void UpdateRuleInDispList( DWORD iList, CCertMapRule* pRule );

    BOOL EditOneRule( CCertMapRule* pRule, BOOL fAsWizard = FALSE );
    BOOL EditMultipleRules();

    void OnMove( int delta );


    // its storage/persistance object
//  CMBWrap             m_mbWrap;

    // its mapper
    CIisRuleMapper      m_mapper;

    CString             m_szMetaPath;
    IMSAdminBase*       m_pMB;

    // flag indicating if changes have been made
    BOOL                m_fDirty;
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently


 
#ifndef   _stdafx_h__2_12_98_
#define   _stdafx_h__2_12_98_

#define VC_EXTRALEAN        // Exclude rarely-used stuff from Windows headers
//
//
//Its never a good idea to hack the following since this will cause problems
//with MFC.
//
//Mail note on the subject:
// We orginally thought that we needed to build with WIN32_IE=0x0400 
// to pick up the new WIZARD97 stuff. MFC42.DLL was built with WIN32_IE=0x0300. 
// Unfortunately, the PROPSHEETPAGE and PROPSHEETHEADER structures (defined in 
// public\sdk\inc\prsht.h) grow between versions 0x0300 and 0x0400. This causes 
// MFC classes to grow, so there is a disconnect between classes in the IIS 
// components and within MFC, and everything quickly goes crazy. So crazy that
// even though some parts of IIS can use it we can not since GetPage(int i)
// from MFC's CPropertySheet will AV.
///////////////////////////
//#define HACK_WIN32IE
///////////////////////////

#ifdef HACK_WIN32IE
// we need to define _WIN32_IE for the new Wizard97 styles
#ifdef _WIN32_IE
# if (_WIN32_IE < 0x0400)
//#pragma warning("we are redefining _WIN32_IE  0x0500 because NT5 headers dont do it")
#  undef  _WIN32_IE
#  define _WIN32_IE  0x0500
# endif
#else
# define _WIN32_IE  0x0500
#endif
#endif /* HACK_WIN32IE */




//#ifndef _WIN32_WINNT
//  #define _WIN32_WINNT 0x0400
//#endif
#include <afxctl.h>         // MFC support for OLE Controls
#include <afxcmn.h>


// Delete the two includes below if you do not wish to use the MFC
//  database classes
#ifndef _UNICODE
#include <afxdb.h>          // MFC database classes
#include <afxdao.h>         // MFC DAO database classes
#endif //_UNICODE

//#include "Global.h"

#define NOT_COMPILING_COMPROP       // we dont want comprop to use
                    // comprop/resource.h -- use our
                    // certmap/resource.h file

//  ../comprop/comprop.h  defines COMDLL and sets it as the following, we want
//  to use '_COMSTATIC' in certmap.   So we define it here.  We included
//  a copy of how comprop will define COMDLL as FYI.
//  We define _MDKEYS_H_ so that ./comprop/comprop.h can be included w/o
//  trouble.  It defines many Unicode string assignments that do not compile
//  in ANSI mode.
//-----------------------------------------------------------------
#ifdef  COMDLL
# undef COMDLL
# define _COMSTATIC
#endif

#ifndef _MDKEYS_H_
#define _MDKEYS_H_
#endif

// #ifdef _COMEXPORT
//     #define COMDLL __declspec(dllexport)
// #elif defined(_COMIMPORT)
//     #define COMDLL __declspec(dllimport)
// #elif defined(_COMSTATIC)
//     #define COMDLL
// #else
//     #error "Must define either _COMEXPORT, _COMIMPORT or _COMSTATIC"
// #endif // _COMEXPORT




//list templates and such
#include <afxtempl.h>
#include <atlconv.h>



#include "resource.h"

/*
#include "Debug.h"
#include "Util.h"
*/

#include "iishelp.h"
#include "ddxvlocal.h"


#endif  /* _stdafx_h__2_12_98_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\wrapmaps.cpp ===
/*++

Module Name:

    wrapmaps.cpp

Abstract:

    wrapper classes for the mapper classes provided by phillich. See the headers in iismap.hxx
    These wrappers simplify the code interfaces for accessing the data.

Author:

   Boyd Multerer        boydm
   Boyd Multerer        boydm       4/16/97

--*/

//C:\nt\public\sdk\lib\i386

#include "stdafx.h"
#include "WrapMaps.h"
#include <wincrypt.h>


//#define IISMDB_INDEX_CERT11_CERT        0
//#define IISMDB_INDEX_CERT11_NT_ACCT     1
//#define IISMDB_INDEX_CERT11_NAME        2
//#define IISMDB_INDEX_CERT11_ENABLED     3
//#define IISMDB_INDEX_CERT11_NB          4


//----------------------------------------------------------------
BOOL C11Mapping::GetCertificate( PUCHAR* ppCert, DWORD* pcbCert )
    {
    *ppCert = (PUCHAR)m_pCert;
    *pcbCert = m_cbCert;
    return TRUE;
    }

//----------------------------------------------------------------
BOOL C11Mapping::SetCertificate( PUCHAR pCert, DWORD cbCert )
    {
    // we want to store a copy of the certificate - first free any existing cert
    if ( m_pCert )
        {
        GlobalFree( m_pCert );
        cbCert = 0;
        m_pCert = NULL;
        }
    // copy in the new one
    m_pCert = (PVOID)GlobalAlloc( GPTR, cbCert );
    if ( !m_pCert ) return FALSE;
    CopyMemory( m_pCert, pCert, cbCert );
    m_cbCert = cbCert;
    return TRUE;
    }

//----------------------------------------------------------------
BOOL C11Mapping::GetNTAccount( CString &szAccount )
    {
    szAccount = m_szAccount;
    return TRUE;
    }

//----------------------------------------------------------------
BOOL C11Mapping::SetNTAccount( CString szAccount )
    {
    m_szAccount = szAccount;
    return TRUE;
    }

//----------------------------------------------------------------
BOOL C11Mapping::GetNTPassword( CStrPassword &szPassword )
    {
    szPassword = m_szPassword;
    return TRUE;
    }

//----------------------------------------------------------------
BOOL C11Mapping::SetNTPassword( CString szPassword )
    {
    m_szPassword = szPassword;
    return TRUE;
    }

//----------------------------------------------------------------
BOOL C11Mapping::GetMapName( CString &szName )
    {
    szName = m_szName;
    return TRUE;
    }

//----------------------------------------------------------------
BOOL C11Mapping::SetMapName( CString szName )
    {
    m_szName = szName;
    return TRUE;
    }

//----------------------------------------------------------------
CString& C11Mapping::QueryNodeName()
    {
    return m_szNodeName;
    }

//----------------------------------------------------------------
BOOL C11Mapping::SetNodeName( CString szName )
    {
    m_szNodeName = szName;
    return TRUE;
    }

// QueryCertHash is used only when accessing IIS6 and higher
// it will return Hash of the cert in the hex string form
CString& C11Mapping::QueryCertHash()
{
    HRESULT         hr = E_FAIL;
    const int       SHA1_HASH_SIZE = 20;
    BYTE            rgbHash[ SHA1_HASH_SIZE ];
    DWORD           cbSize = SHA1_HASH_SIZE;

    #ifndef HEX_DIGIT
    #define HEX_DIGIT( nDigit )                            \
    (CHAR)((nDigit) > 9 ?                              \
          (nDigit) - 10 + 'a'                          \
        : (nDigit) + '0')
    #endif

    if ( m_szCertHash.IsEmpty() )
    {
        PCCERT_CONTEXT pCertContext = NULL;
        pCertContext= CertCreateCertificateContext(X509_ASN_ENCODING, (const BYTE *)m_pCert, m_cbCert);
        
        if ( pCertContext == NULL )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            return m_szCertHash; // return empty cert hash
        }

        //
        // get hash of the certificate to be verified
        //
        if ( !CertGetCertificateContextProperty( pCertContext,
                                                 CERT_SHA1_HASH_PROP_ID,
                                                 rgbHash,
                                                 &cbSize ) )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            CertFreeCertificateContext( pCertContext );
            pCertContext = NULL;
            return m_szCertHash; // return empty cert hash
        }
        CertFreeCertificateContext( pCertContext );
        pCertContext = NULL;
        
        //
        // convert to text
        //
        for (int i = 0; i < sizeof(rgbHash); i ++ )
        {
            m_szCertHash += HEX_DIGIT( ( rgbHash[ i ] >> 4 ) );
            m_szCertHash += HEX_DIGIT( ( rgbHash[ i ] & 0x0F ) );
        }
    }

    return m_szCertHash;
}
//----------------------------------------------------------------
// the enabled flag is considered try if the SIZE of data is greater
// than zero. Apparently the content doesn't matter.
BOOL C11Mapping::GetMapEnabled( BOOL* pfEnabled )
    {
    *pfEnabled = m_fEnabled;
    return TRUE;
    }

//----------------------------------------------------------------
// the enabled flag is considered try if the SIZE of data is greater
// than zero. Apparently the content doesn't matter.
BOOL C11Mapping::SetMapEnabled( BOOL fEnabled )
    {
    m_fEnabled = fEnabled;
    return TRUE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\wrpmbwrp.cpp ===
/*++

Module Name:

    WrpMBWrp.cpp

Abstract:

    A wrapper for my metabase wrapper wrapper. Why? All it does is provide
        AFX support for CString classes. Everything else is passed on to the parent

Author:

   Boyd Multerer bmulterer@accessone.com

--*/

//C:\nt\public\sdk\lib\i386

#include "stdafx.h"
#include <iiscnfgp.h>
#include "wrapmb.h"

#include "WrpMBWrp.h"


//-----------------------------------------------------------------------------
BOOL CAFX_MetaWrapper::GetString( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType,
                                                                 CString &sz, DWORD dwFlags )
        {
        PCHAR           pData = NULL;
        DWORD           cbData = 0;
        DWORD           err = 0;
        BOOL            f;

        // first, get the size of the data that we are looking for - it will fail because of the NULL,
        // but, the size we need should be in cbData;
        f = GetData( pszPath, dwPropID, dwUserType, STRING_METADATA, NULL, &cbData );

        // check the error - it should be some sort of memory error
        err = GetLastError();

        // it is ok that the GetData failed, but the reason had better be ERROR_INSUFFICIENT_BUFFER
        // otherwise, it is something we can't handle
        if ( err != ERROR_INSUFFICIENT_BUFFER )
                return FALSE;

        // allocate the buffer
        pData = (PCHAR)GlobalAlloc( GPTR, cbData + 1 );
        if ( !pData ) return FALSE;

        // zero out the buffer
        ZeroMemory( pData, cbData + 1 );

        // first, get the size of the data that we are looking for
        f = GetData( pszPath, dwPropID, dwUserType, STRING_METADATA, pData, &cbData );

        // if that getting failed, we need to cleanup
        if ( !f )
                {
                GlobalFree( pData );
                return FALSE;
                }

        // set the answer
        sz = pData;

        // clean up
        GlobalFree( pData );

        // return the allocated buffer
        return TRUE;
        }

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\wwzone.cpp ===
// WildWizOne.cpp : implementation file
//

#include "stdafx.h"
#include <iadmw.h>
#include "certmap.h"

#include "ListRow.h"
#include "ChkLstCt.h"
extern "C"
    {
    #include <wincrypt.h>
    #include <schannel.h>
    }
#include "Iismap.hxx"
#include "Iiscmr.hxx"

#include "brwsdlg.h"
#include "EdWldRul.h"
#include "EdtRulEl.h"

#include "WWzOne.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CWildWizOne property page

IMPLEMENT_DYNCREATE(CWildWizOne, CPropertyPage)

CWildWizOne::CWildWizOne() : CPropertyPage(CWildWizOne::IDD)
{
    //{{AFX_DATA_INIT(CWildWizOne)
    m_sz_description = _T("");
    m_bool_enable = FALSE;
    //}}AFX_DATA_INIT
}

CWildWizOne::~CWildWizOne()
{
}

void CWildWizOne::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CWildWizOne)
    DDX_Text(pDX, IDC_DESCRIPTION, m_sz_description);
    DDV_MaxChars(pDX, m_sz_description, 120);
    DDX_Check(pDX, IDC_ENABLE_RULE, m_bool_enable);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWildWizOne, CPropertyPage)
    //{{AFX_MSG_MAP(CWildWizOne)
    ON_EN_CHANGE(IDC_DESCRIPTION, OnChangeDescription)
    ON_BN_CLICKED(IDC_ENABLE_RULE, OnEnableRule)
    //}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,  DoHelp)
    ON_COMMAND(ID_HELP,         DoHelp)
    ON_COMMAND(ID_CONTEXT_HELP, DoHelp)
    ON_COMMAND(ID_DEFAULT_HELP, DoHelp)
END_MESSAGE_MAP()

//---------------------------------------------------------------------------
void CWildWizOne::DoHelp()
    {
    WinHelpDebug(HIDD_CERTMAP_ADV_RUL_GENERAL);
    WinHelp( HIDD_CERTMAP_ADV_RUL_GENERAL );
    }

/////////////////////////////////////////////////////////////////////////////
// CWildWizOne message handlers

//---------------------------------------------------------------------------
BOOL CWildWizOne::OnInitDialog()
    {
    // call the parental oninitdialog
    BOOL f = CPropertyPage::OnInitDialog();

    // set the easy default strings 
    m_sz_description = m_pRule->GetRuleName();
    m_bool_enable = m_pRule->GetRuleEnabled();

    // exchange the data
    UpdateData( FALSE );

    // return the answer
    return f;
    }

//---------------------------------------------------------------------------
BOOL CWildWizOne::OnApply()
    {
    CERT_FIELD_ID   id;
    CString         szSub, sz;
    LPBYTE          pbBin;
    DWORD           cbBin;
    UINT            cItems;
    UINT            iItem;

    USES_CONVERSION;

    // update the data
    UpdateData( TRUE );

    // set the easy data

    m_pRule->SetRuleName( T2A((LPTSTR)(LPCTSTR)m_sz_description) );
    m_pRule->SetRuleEnabled( m_bool_enable );

    // it is valid
    SetModified( FALSE );
    return TRUE;
    }

//---------------------------------------------------------------------------
BOOL CWildWizOne::OnSetActive() 
    {
    // if this is a wizard, gray out the back button
    if ( m_fIsWizard )
        m_pPropSheet->SetWizardButtons( PSWIZB_NEXT );
    return CPropertyPage::OnSetActive();
    }

//---------------------------------------------------------------------------
void CWildWizOne::OnChangeDescription() 
    {
    // we can now apply
    SetModified();
    }

//---------------------------------------------------------------------------
void CWildWizOne::OnEnableRule() 
    {
    // we can now apply
    SetModified();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\wrpmbwrp.h ===
//-------------------------------
class CAFX_MetaWrapper : public CWrapMetaBase
    {
    public:
    BOOL GetString( LPCTSTR, DWORD dwPropID, DWORD dwUserType, CString &sz, DWORD dwFlags = METADATA_INHERIT );
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\wwzone.h ===
// WildWizOne.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CWildWizOne dialog

class CWildWizOne : public CPropertyPage
{
    DECLARE_DYNCREATE(CWildWizOne)

// Construction
public:
    CWildWizOne();
    ~CWildWizOne();

    // to make the buttons behave right
    BOOL            m_fIsWizard;
    CPropertySheet* m_pPropSheet;

    // the only public member
    CCertMapRule*   m_pRule;
    IMSAdminBase*   m_pMB;

    // base path to the metabase
    CString m_szMBPath;

    virtual BOOL OnApply();
    virtual BOOL OnInitDialog();

// Dialog Data
    //{{AFX_DATA(CWildWizOne)
    enum { IDD = IDD_WILDWIZ_1 };
    CString m_sz_description;
    BOOL    m_bool_enable;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CWildWizOne)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CWildWizOne)
    afx_msg void OnChangeDescription();
    afx_msg void OnEnableRule();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void DoHelp();

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\wrapmaps.h ===
// wrapmaps.h  -- 

 
#ifndef   _wrapmaps_h__31598_
#define   _wrapmaps_h__31598_

// see iismap.hxx for the parental classes
#include "strpass.h"


//--------------------------------------------------------
class C11Mapping
    {
    public:
    #define NEW_OBJECT  0xFFFFFFFF
    C11Mapping() : 
          m_fEnabled(TRUE),
          m_pCert(NULL),
          m_cbCert(0),
          iMD(NEW_OBJECT)

        {;}
    ~C11Mapping()
        {
        if ( m_pCert )
            GlobalFree( m_pCert );
        }

    BOOL GetCertificate( PUCHAR* ppCert, DWORD* pcbCert );
    BOOL SetCertificate( PUCHAR pCert, DWORD cbCert );

    BOOL GetNTAccount( CString &szAccount );
    BOOL SetNTAccount( CString szAccount );

    BOOL GetNTPassword( CStrPassword &szAccount );
    BOOL SetNTPassword( CString szAccount );

    BOOL GetMapName( CString &szName );
    BOOL SetMapName( CString szName );


    BOOL SetNodeName( CString szNodeName );
    CString& QueryNodeName();
    CString& QueryCertHash();

    BOOL GetMapEnabled( BOOL* pfEnabled );
    BOOL SetMapEnabled( BOOL fEnabled );

//  BOOL GetMapIndex( DWORD* pIndex );
//  BOOL SetMapIndex( DWORD index );

    // name of this mapping's name in the metabase. If it is not in the metabase
    // (its new), then value is NEW_OBJECT
    // iMD is used only when accessing IIS5, IIS5.1
    DWORD       iMD;


    // name of the node in the metabase
    // (typically the certificate hash)
    // storing this mapping (m_szName is not enforced to be unique)
    // m_szModeName is used only when accessing IIS6 or higher
    CString m_szNodeName;

    protected:
    #define BUFF_SIZE   MAX_PATH
        
        CString m_szAccount;
        CStrPassword m_szPassword;
        CString m_szName;
        BOOL    m_fEnabled;
        PVOID   m_pCert;
        DWORD   m_cbCert;
        CString m_szCertHash;
    };

#endif  /* _wrapmaps_h__31598_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by certmap.rc
//
#define IDS_CERTMAP                     1
#define IDB_CERTMAP                     1
#define IDS_CERTMAP_PPG                 2
#define IDS_KEY_OR_CERT_FILE_FILTER     3
#define IDS_TITLE_CTL_WIZARD            4
#define IDS_OLD_KEYRING_BACKUP_FILE_IMPORT_FILTER 5
#define IDD_MIME_TYPES                  11
#define IDS_DDX_MINIMUM                 28
#define IDS_CERTMAP_PPG_CAPTION         100
#define IDD_PROPPAGE_CERTMAP            100
#define IDS_MAP_SHEET_TITLE             101
#define IDS_INIT_META_ERROR             102
#define IDS_LIST11_NAME                 103
#define IDS_LIST11_ACCOUNT              104
#define IDS_CONFIRM_DELETE              105
#define IDS_ERR_ACCESS_MAPPING          106
#define IDS_NTBROWSE_TITLE              107
#define IDD_PROPPAGE_LARGE_SAMPLE       107
#define IDS_INVALID_ACCOUNT             108
#define IDS_CERTIFICATE_FILTER          109
#define IDS_ERR_INVALID_CERTIFICATE     110
#define IDS_DEFAULT_11MAP               111
#define IDS_ENABLED                     112
#define IDS_ELLIPSIS                    113
#define IDS_WILD_DESCRIPTION            114
#define IDS_WILD_ACCOUNT                115
#define IDS_DEFAULT_RULE                116
#define IDS_CERT_FIELD                  117
#define IDS_MATCH_CRITERIA              118
#define IDS_SUB_FIELD                   119
#define IDS_WILDSTRING                  120
#define IDS_INVALID_SUBFIELD            121
#define IDS_ISSUE_AUTH                  122
#define IDS_ERR_NO_ISSUERS              123
#define IDS_ERR_CANTADD                 124
#define IDS_MATCH_ON_ISSUERS            125
#define IDS_CERTAUTH                    126
#define IDS_CERTAUTH_PPG                127
#define IDS_CERTAUTH_PPG_CAPTION        128
#define IDD_CLEARTEXTWARNING            128
#define IDS_TRUSTED_AUTHORITIES         129
#define IDS_WILDWIZ_TITLE               130
#define IDS_PASS_CONFIRM_FAIL           131
#define IDS_HELPLOC_PWSHELP             132
#define IDD_WZ_CERTGET_1_WELCOME        132
#define IDS_ERR_CERTMAP_TITLE           133
#define IDD_MIME_PROPERTY               133
#define IDS_SHOWN_PASSWORD              134
#define IDS_WANTACCOUNT                 135
#define IDS_DENYACCESS                  136
#define IDD_KEY_VIEWEDIT                137
#define IDR_KEYPROP                     138
#define IDD_CONFIRM_PASSWORD            139
#define IDD_KEY_DATA_VIEW               140
#define IDD_CHOOSE_IPADDRESS            141
#define IDD_NEW_KEY_INFO                142
#define IDI_ICONINFORMATION             143
#define IDD_DIALOG1                     145
#define IDD_CREATING_NEW_KEY            145
#define IDD_ADNIM_INFO                  146
#define IDD_DEFAULT_CONFIRM             147
#define IDR_AVI_CREATING_KEY            149
#define IDD_IMPORT_KEY_PAIR             151
#define IDD_NK_CHOOSE_CA                153
#define IDD_NK_FILE_INFO                154
#define IDD_NK_DN1                      155
#define IDD_NK_KEY_INFO                 157
#define IDD_NK_USER_INFO                158
#define IDD_NK_DN2                      159
#define IDD_CERT_MISMATCH               161
#define IDD_CTL_CREATE_GET_INFO_FROM_USER 188
#define IDD_WZ_CTL_CREATE_GETINFO2      188
#define IDD_WZ_IMPORT_USE_PREEXISTING   198
#define IDC_CAPTIONEDIT                 201
#define IDC_LIST                        202
#define IDD_11CERT_MAPPING              202
#define IDB_CHECK                       202
#define IDC_DELETE                      203
#define IDD_WILDCARDS_1                 203
#define IDD_WILDCARDS_2                 204
#define IDC_ADD                         205
#define IDD_EDIT_RULE_ELEMENT           205
#define IDC_S_O                         206
#define IDC_BTN_HELP                    206
#define IDD_PROPPAGE_CERTAUTH           206
#define IDC_S_OU                        207
#define IDB_CERTAUTH                    207
#define IDC_COMBO1                      208
#define IDC_S_CN                        208
#define IDD_MAP_TO_ACCNT                208
#define IDC_LIST1                       209
#define IDC_COMBO2                      209
#define IDC_S_C                         209
#define IDD_MAP_ONE_TO_ACCNT            209
#define IDC_COMBO3                      210
#define IDC_S_S                         210
#define IDD_WILDCARDS_stored            210
#define IDD_WILDWIZ_1                   210
#define IDC_COMBO4                      211
#define IDC_EDIT_11MAP                  211
#define IDD_SELECT_ISSUERS              211
#define IDC_BUTTON3                     212
#define IDC_S_L                         212
#define IDD_WILDCARDS_Storage           212
#define IDC_I_O                         213
#define IDD_WILDWIZ_2                   213
#define IDC_I_OU                        214
#define IDD_WILDWIZ_3                   214
#define IDC_CHECK1                      215
#define IDC_I_C                         215
#define IDC_CHK_CAPITALIZATION          215
#define IDD_WZ_CERTGET_2_WHAT_TASK      215
#define IDC_CHECK_REMOTE_ONLINE_AUTHORITY 215
#define IDC_ISSUED_TO                   216
#define IDD_WZ_CERTGET_3A_CERT_REQ_INFO 216
#define IDD_WZ_CERTGET_A3_REQ_SHOW_CERTINFO 216
#define IDC_EDIT                        217
#define IDC_ISSUER                      217
#define IDD_WZ_CERTGET_A4_REQ_HOW2CREATE 217
#define IDC_MOVE_UP                     218
#define IDC_MAPNAME                     218
#define IDD_WZ_CERTGET_A5_REQ_WHERE_REQ_GOES 218
#define IDC_MOVE_DOWN                   219
#define IDD_PROPPAGE__FAKE__USED_BY_WixPropPage 219
#define IDC_EDIT1                       220
#define IDC_DESCRIPTION                 220
#define IDC_SUBFIELD                    220
#define IDC_MB_PATH                     220
#define IDC_RADIO1                      221
#define IDC_ALL_ISSUERS                 221
#define IDB_BITMAP_MMC_CTL_4color       221
#define IDC_RADIO2                      222
#define IDC_ENABLE                      222
#define IDC_SOME_ISSUERS                222
#define IDD_MMC_CTL_FYI                 222
#define IDB_BITMAP_TJP2                 222
#define IDC_SELECT_ISSUER               223
#define IDC_EDIT2                       224
#define IDC_PASSWORD2                   224
#define IDD_EDITDIALOG                  224
#define IDC_RADIO5                      225
#define IDC_EDIT3                       225
#define IDC_EDIT4                       226
#define IDB_FYI_MMC_EMPT                226
#define IDD_DIALOG2                     226
#define IDC_RADIO6                      226
#define IDC_EDIT5                       227
#define IDB_FYI_MMC_ADD1                227
#define IDC_CHECK2                      228
#define IDC_ENABLE_RULE                 228
#define IDB_FYI_MMC_ADD2                228
#define IDC_CHECK3                      229
#define IDB_FYI_MMC_ADD3                229
#define IDC_EDIT6                       230
#define IDC_RADIO3                      230
#define IDC_REFUSE_LOGON                230
#define IDB_FYI_MMC_ADD4                230
#define IDC_BROWSE                      231
#define IDB_FYI_MMC_ADD5                231
#define IDC_RADIO4                      232
#define IDC_ACCEPT_LOGON                232
#define IDB_FYI_MMC_ADD6                232
#define IDC_DO_NOT_MATCH                233
#define IDB_FYI_MMC_MCH1                233
#define IDC_NEW                         234
#define IDB_FYI_MMC_MCH2                234
#define IDB_BITMAP_CTL_LEFT             236
#define IDC_FIELDS                      237
#define IDB_BITMAP1                     237
#define IDC_CRITERIA                    238
#define IDC_PASSWORD                    239
#define IDD_PROGRESS_BAR                239
#define IDC_TOGGLE                      240
#define IDD_WZ_INCORRECT_OOB_SAVED      240
#define IDC_CAPTION                     241
#define IDC_STATIC_ACCOUNT              242
#define IDC_STATIC_PASSWORD             243
#define IDC_STATIC_DESC                 244
#define IDC_NK_CA_OFFLINE_COMBO         245
#define IDC_STATIC_DESC_WHERE2MAIL_CERT 246
#define IDC_NTACCOUNT                   248
#define IDC_NK_CA_REMOTE_HOSTNAME       248
#define IDC_LABEL_ERROR_PARAGRAPH1      250
#define IDC_LABEL_ERROR_PARAGRAPH2      251
#define IDC_LABEL_ERROR_PARAGRAPH3      252
#define IDC_LABEL_ERROR_NUMBER          253
#define IDC_PROGRESS1                   254
#define IDB_UP                          505
#define IDB_UPFOC                       506
#define IDB_UPDIS                       507
#define IDB_UPINV                       508
#define IDB_DOWN                        509
#define IDB_DOWNFOC                     510
#define IDB_DOWNDIS                     511
#define IDB_DOWNINV                     512
#define IDC_CONNECT_ServerName          1000
#define IDC_NEW_KEY_NAME                1002
#define IDC_NEW_KEY_REQUEST_FILE        1003
#define IDC_NEW_KEY_BROWSE              1004
#define IDC_STATIC_BOLD                 1006
#define IDC_STATIC_BIGBOLD              1007
#define IDC_NEW_KEY_BITS                1015
#define IDC_NEW_KEY_ORGANIZATION        1017
#define IDC_NEWKEY_COUNTRY              1017
#define IDC_NEW_KEY_UNIT                1018
#define IDC_NEWKEY_ORG                  1018
#define IDC_NEW_KEY_NETADDRESS          1019
#define IDC_NEWKEY_STATE                1019
#define IDC_NEW_KEY_COUNTRY             1020
#define IDC_NEWKEY_ORGUNIT              1020
#define IDC_NEW_KEY_PASSWORD            1021
#define IDC_NEW_NKKI_PASSWORD           1021
#define IDC_INSTALL_PASSWORD            1022
#define IDC_NEWKEY_LOCALITY             1022
#define IDC_NEW_NKKI_PASSWORD2          1022
#define IDC_NEWKEY_COMMONNAME           1023
#define IDC_CONFIRM_PASSWORD            1032
#define IDC_VIEWKEY_STATEPROVINCE       1032
#define IDC_VIEWKEY_LOCALITY            1033
#define IDC_BTN_KEYVIEW_NONE            1034
#define IDC_BTN_KEYVIEW_DEFAULT         1035
#define IDC_BTN_KEYVIEW_IPADDR          1036
#define IDC_KEYDATAVIEW_IPADDRESS       1037
#define IDC_BTN_SELECT_IPADDRESS        1039
#define IDC_GROUP_DN                    1040
#define IDC_GROUP_CONNECTION            1041
#define IDC_STATIC_BITS                 1042
#define IDC_STATIC_ORG                  1043
#define IDC_STATIC_UNIT                 1044
#define IDC_STATIC_NETADDR              1045
#define IDC_STATIC_COUNTRY              1046
#define IDC_STATIC_NAME                 1047
#define IDC_CHOOSER_SERVER_DLG_HELP     1048
#define IDC_STATIC_STATEPROVICE         1048
#define IDC_CHOOSER_HELP_CHOOSE_IP      1048
#define IDC_LIST_IPADDRESSES            1049
#define IDC_STATIC_LOCALITY             1049
#define IDC_HELP_INSTALL_CERTIFICATE    1051
#define IDC_HELP_MORE_NEW_KEY_HELP      1051
#define IDC_BUTTON1                     1052
#define IDC_HELP_CONNECT_SERVER         1052
#define IDC_BROWSE_PRIVATE              1052
#define IDC_BK_CA_PROPERTIES            1052
#define IDC_HOTLINK_CCODES              1052
#define IDC_NEW_KEY_INFO_FILE_PART      1053
#define IDC_DISK_SPACE                  1056
#define IDC_PHYSICAL_MEM                1057
#define IDC_REPDEF_CURRENT              1059
#define IDC_REPDEF_NEW                  1060
#define IDC_STATIC_CREATED              1061
#define IDC_STATIC_EXPIRES              1062
#define IDC_VIEWKEY_CREATED             1063
#define IDC_STATIC_STARTS               1063
#define IDC_VIEWKEY_EXPIRES             1064
#define IDC_VIEWKEY_STARTS              1065
#define IDC_INFO_BASE                   1066
#define IDC_GRINDER_ANIMATION           1067
#define IDC_STATIC_VERIFIER             1068
#define IDC_HELP_CREATE_KEY             1069
#define IDC_BROWSE_CERT                 1070
#define IDC_NK_CA_FILE_RADIO            1070
#define IDC_CERT_FILE                   1071
#define IDC_NK_CA_ONLINE_RADIO          1071
#define IDC_PRIVATE_FILE                1072
#define IDC_NK_CA_ONLINE                1072
#define IDC_NKUI_USER_NAME              1073
#define IDC_BUTTON2                     1074
#define IDC_NK_CA_BROWSE                1074
#define IDC_EDIT_ALIAS                  1079
#define IDC_NK_INFO_FILENAME            1080
#define IDC_NK_CA_FILE                  1082
#define IDC_NKUI_EMAIL_ADDRESS          1083
#define IDC_NKUI_PHONE_NUMBER           1084
#define IDC_NKKI_NAME                   1085
#define IDC_NKKI_BITS                   1086
#define IDC_MESSAGE                     1087
#define IDC_LIST_REQUEST                1088
#define IDC_LIST_CERTIFICATE            1089
#define IDC_IPA_IPADDRESS               1107
#define IDC_EMAIL_ADDRESS               1108
#define IDC_PHONE_NUMBER                1109
#define IDD_FYI_MMC_EMPT                1222
#define IDD_FYI_MMC_ADD1                1223
#define IDD_FYI_MMC_ADD2                1224
#define IDD_FYI_MMC_ADD3                1225
#define IDD_FYI_MMC_ADD4                1226
#define IDD_FYI_MMC_ADD5                1227
#define IDD_FYI_MMC_ADD6                1228
#define IDD_FYI_MMC_MCH1                1229
#define IDD_FYI_MMC_MCH2                1230
#define IDS_ERR_CONNECT                 1446
#define IDS_MACHINE_LOCAL               1447
#define IDS_SERVER_NONE                 1448
#define IDS_CREATE_KEY_NEW_NAME         1449
#define IDS_CREATE_KEY_YOUR_COMPANY     1450
#define IDS_CREATE_KEY_YOUR_UNIT        1451
#define IDS_CREATE_KEY_YOUR_ADDRESS     1453
#define IDS_KEY_DELETE_WARNING          1454
#define IDS_SERVER_COMMIT               1455
#define IDS_ERR_GENERATEPAIR            1456
#define IDS_ERR_WRITEREQUEST            1457
#define IDS_ERR_WRITEKEYS               1458
#define IDS_KEY_STATUS_COMPLETE         1459
#define IDS_KEY_STATUS_INCOMPLETE       1460
#define IDS_KEY_UNKNOWN                 1461
#define IDS_CREATE_KEY_PASSREQUIRED     1462
#define IDS_INCORRECT_PASSWORD          1463
#define IDS_CERT_FILE_EXISTS            1464
#define IDS_REG_SERVER_STORAGE          1465
#define IDS_COMMIT_ERROR                1466
#define IDS_MACHINE_DEFAULT             1467
#define IDS_MACHINE_SELECTED            1468
#define IDS_NEW_KEY_INFO_1              1470
#define IDS_NEW_KEY_INFO_2              1471
#define IDS_ABOUT_MAIN                  1472
#define IDS_ABOUT_SECONDARY             1473
#define IDS_HTTP_COMM_ERROR             1474
#define IDS_NO_VIRT_ROOTS               1475
#define IDS_FOUND_KEYSET_KEYS           1476
#define IDS_UNTITLED                    1477
#define IDS_IMPORT_KEYSET_ERROR         1478
#define IDS_LOCALIZED_DEFAULT_COUNTRY_CODE 1479
#define IDS_GENERATE_KEY_ERROR          1480
#define IDS_INVALID_KEY                 1481
#define IDS_CREATE_KEY_YOUR_STATE       1482
#define IDS_CREATE_KEY_YOUR_LOCALITY    1483
#define IDS_CRED_PASS_ERROR             1484
#define IDS_CRED_PACK_ERROR             1485
#define IDS_KEY_STATUS_EXPIRED          1486
#define IDS_KEY_STATUS_EXPIRES_SOON     1487
#define IDS_EXPIRETIME_FORMAT           1488
#define IDS_RENEW_KEY_INFO_2            1489
#define IDS_NEW_KEY_INFO_BASE           1490
#define IDS_RENEW_KEY_INFO_BASE         1491
#define IDS_CREATING_ANIMATION          1492
#define IDS_CRACKING_ERROR              1493
#define IDS_IMPORT_KEYSET_PRIV_ERROR    1494
#define IDS_IMPORT_KEYSET_PUB_ERROR     1495
#define IDS_IMPORT_KEYSET_PASS_ERROR    1496
#define IDS_KEY_FILE_TYPE               1497
#define IDS_KEY_FILE_INVALID            1498
#define IDS_CERT_FILE_TYPE              1499
#define IDS_REG_USER_INFO               1499
#define IDS_KEYFILE_WARNING             1500
#define IDS_PRIVATE_FILE_TYPE           1501
#define IDD_USER_ACCOUNT                2029
#define IDD_NEW_DIR_ALIAS               2044
#define IDB_WELCOME_COMPLETION          2058
#define IDB_WELCOME_COMPLETION_LEFT     2059
#define ID_SERVER_COMMIT_NOW            2771
#define ID_KEY_CREATE_REQUEST           2772
#define ID_KEY_INSTALL_NEW              2773
#define ID_KEY_DELETE                   2774
#define ID_SERVER_CONNECT               2775
#define ID_KEY_ACTIVATE                 2776
#define IDD_WZwo_CERTSEL_3_CHOOSE_CERT  2776
#define ID_KEY_DEACTIVATE               2777
#define ID_KEY_INSTALL_CERTIFICATE      2778
#define ID_KEY_PROPERTIES               2780
#define ID_KEYPROP_PASTE                2781
#define ID_MAIN_HELP                    2784
#define ID_SERVER_DISCONNECT            2786
#define ID_KEY_SAVE_REQUEST             2787
#define ID_KEYPROP_WRITEKEYREQUEST      2788
#define ID_KEY_CREATE_RENEWAL           2789
#define ID_KEY_IMPORT                   2791
#define ID_KEY_EXPORT                   2792
#define ID_KEY_EXPORT_BACKUP            2793
#define ID_KEY_EXPORT_KEYSET            2794
#define ID_KEY_IMPORT_BACKUP            2795
#define ID_KEY_IMPORT_KEYSET            2796
#define ID_TEST_DATA                    2797
#define ID_SERVPROP_CUT                 2798
#define ID_PROPERTIES                   2799
#define IDS_NEW_CREATE_NEW              2801
#define IDS_ADDONS_LOCATION             2803
#define ID_HELPTOPICS                   2803
#define IDS_NO_SERVICE_MODS             2804
#define IDS_SERVER_INFO_STRING          2806
#define IDS_CA_LOCATION                 2807
#define IDS_LOAD_CA_ERR                 2808
#define IDS_DEFAULT_REQUEST_FILE        2809
#define IDS_GEN_KEYPAIR_ERR             2810
#define IDS_GRIND_GENERATING            2811
#define IDS_GRIND_SUBMITTING            2812
#define IDS_GRIND_SUCCESS               2813
#define IDS_GRIND_DELAYED               2814
#define IDS_GRIND_FILE                  2815
#define IDS_GRIND_ONLINE_FAILURE        2816
#define IDS_GRIND_RESUBMITTING          2818
#define IDS_ILLEGAL_DN_CHARS            2819
#define IDS_BADCHARMSG                  2820
#define IDS_GENERATE_KEY_TITLE          2821
#define IDS_RESTART_PROMPT              2822
#define IDS_IO_ERROR                    2823
#define IDS_BAD_FILE_NAME               2824
#define IDS_FILE_EXISTS                 2825
#define IDS_CHOOSE_COMPUTER             2826
#define IDS_TITLE_CREATE_WIZ            2827
#define IDS_TITLE_RENEW                 2828
#define IDS_INVALID_CA_REQUEST_OLD      2829
#define IDS_CA_NO_INTERFACE             2830
#define IDS_CA_INVALID                  2831
#define IDS_CA_FACTORY_ERR              2832
#define IDS_CA_DENIED                   2833
#define IDS_CA_ERROR                    2834
#define IDS_HELPLOC_KEYRINGHELP         2835
#define IDS_TOTALLY_ILLEGAL_CHARS       2837
#define IDS_CERTERR_INVALID_CERTIFICATE 2838
#define IDS_CERTERR_SCHANNEL_ERR        2840
#define IDS_CERTERROR_PACKAGELOAD_ERROR 2841
#define IDS_CERTERROR_BADPASSWORD       2842
#define IDS_CERTERR_LOMEM               2843
#define IDS_CERTERR_SCHNL_GENERIC       2844
#define EDS_CERTERR_SCHNL_BAD_INIT      2845
#define IDS_OPEN_PRIVATE_KEY            2846
#define IDS_OPEN_PUBLIC_KEY             2847
#define IDS_APP_EXTENSION               2848
#define IDS_APP_EXE_PATH                2849
#define IDS_ERR_GENERIC_ERRCODE         2850
#define IDC_STATIC_WZ_WELCOME           4000
#define IDC_STATIC_WZ_TITLE             4001
#define IDC_STATIC_WZ_SUBTITLE          4002
#define IDS_TRUE                        4003
#define IDS_FALSE                       4004
#define IDS_NOT_AVAILABLE               4005
#define IDS_NONE                        4006
#define IDS_CR_DISP_INCOMPLETE          4007
#define IDS_CR_DISP_ERROR               4008
#define IDS_CR_DISP_DENIED              4009
#define IDS_CR_DISP_ISSUED              4010
#define IDS_CR_DISP_ISSUED_OUT_OF_BAND  4011
#define IDC_ED_BOLD1                    4011
#define IDS_CR_DISP_UNDER_SUBMISSION    4012
#define IDC_ED_BOLD2                    4012
#define IDS_DUPLICATE_CERT              4013
#define IDC_ED_BOLD3                    4013
#define IDS_DESC_CERTMGROBJ             4014
#define IDC_ED_BOLD4                    4014
#define IDS_DESC_CERTIFICATE_STORE      4015
#define IDC_ED_BOLD5                    4015
#define IDS_DESC_CONTAINER              4016
#define IDS_DESC_USAGE                  4017
#define IDS_DESC_CTL                    4018
#define IDS_DESC_CERTIFICATE            4019
#define IDS_ERR_INVALID_FILENAME        4020
#define IDS_ERR_INVALID_FILENAME_0_LEN  4021
#define IDS_CLSID_REGPATH_XENROLL_NONLOCALIZED 4032
#define IDS_MICROSOFT_CERTIFICATE_SERVER_LOCALIZED_DESC_NAME 4033
#define IDS_CertGetConfig_REGPATH_NONLOCALIZED 4035
#define IDS_CertRequest_REGPATH_NONLOCALIZED 4036
#define IDS_XEnroll_REGPATH_NONLOCALIZED 4037
#define IDS_ERR_UNABLE_TO_GET_REQUIRED_CLSID 4038
#define IDS_ERR_UNABLE_TO_BUILD_CLASS_FROM_READ_IN_CLSID 4039
#define IDS_ERR_HAPPENED_DISPLAY_HRESULT 4040
#define IDS_ERR_DISPLAY__HRESULT__S_OK  4041
#define IDS_ERR_DISPLAY__HRESULT__S_FALSE 4042
#define IDS_ERR_DISPLAY__HRESULT__E_FAIL 4043
#define IDS_ERR_DISPLAY__HRESULT__NOERROR 4044
#define IDS_ERR_DISPLAY__HRESULT__CO_E_CLASSSTRING 4045
#define IDS_ERR_DISPLAY__HRESULT__REGDB_E_WRITEREGDB 4046
#define IDS_ERR_DISPLAY__HRESULT__MAYBE_WIN32_ERR 4047
#define IDS_ERR_DISPLAY__HRESULT__CRYPT_E_INVALID_X500_STRING 4048
#define IDS_ERR_DISPLAY__HRESULT__REGDB_E_IIDNOTREG 4049
#define IDS_ERR_DISPLAY__HRESULT__REGDB_E_CLASSNOTREG 4050
#define IDS_ERR_DISPLAY__HRESULT__CLSID_INIT_ERROR 4060
#define IDS_ERR_DISPLAY__HRESULT__CANT_CREATE_XENROLL 4061
#define IDS_ERR_DISPLAY__HRESULT__CANT_CREATE_ICERTREQUEST 4062
#define IDS_ERR_DISPLAY__HRESULT__CANT_CREATE_ICERTGETCONFIG 4063
#define IDS_ERR_DISPLAY__HRESULT__ICERTGETCONFIG_CALL_FAILED 4064
#define IDS_ERR_DISPLAY__HRESULT__EXPORTABLE_KEYS_CALL_FAILED 4065
#define IDS_IISSERVERNAME               4066
#define IDS_ERR_DISPLAY__HRESULT__CREATEPKCS10_CALL_FAILED 4067
#define IDS_ERR_DISPLAY__HRESULT__ACCEPTFILEPKCS7_CALL_FAILED 4068
#define IDS_ERR_DISPLAY__HRESULT__ACCEPTPKCS7_CALL_FAILED 4069
#define IDS_ERR_DISPLAY__HRESULT__PKCS10_ZERO_SIZED 4070
#define IDS_ERR_DISPLAY__HRESULT__ICERTREQUEST_SUBMIT_FAILED 4072
#define IDS_ERR_DISPLAY__HRESULT__ICERTREQUESTGETCERTIFICATE_FAILED 4074
#define IDS_ERR_DISPLAY__HRESULT__CERTAUTH_PLEASE_CALL 4075
#define IDS_ERR_DISPLAY__HRESULT__CERTAUTH_NOT_STARTED 4076
#define IDS_ERR_DISPLAY__HRESULT__CERTAUTH_KEY_NOT_FOUND 4077
#define IDS_ERR_DISPLAY__HRESULT__CERTAUTH_WAS_GIVEN_INVALID_DATA 4078
#define IDS_ERR_DISPLAY__HRESULT__CERTAUTH_REQ_TOO_BIG 4079
#define IDS_ERR_DISPLAY__HRESULT__CERTAUTH_INVALID_REQUEST 4080
#define IDS_ERR_DISPLAY__HRESULT__MYSTOREFLAGS_ACCESS_FAILED 4081
#define IDS_ERR_DISPLAY__HRESULT__ACCEPTPKCS7_ROOTSTORE_NM_SET 4082
#define IDS_INCOMPLETE_BECAUSE_OF_LOW_MEMORY_AVAILABILITY 5001
#define IDS_FILE_PICK_KEYRING_BCKUP     5002
#define IDS_FILE_PICK_CERTFILE2WRITE    5003
#define IDS_MD_CERT_ENROLL_NONE         5005
#define IDS_MD_CERT_ENROLL_ENTERING_DATA_ERROR 5006
#define IDS_MD_CERT_ERROR_DURING_ENROLL_BEFORE_SENDING_TO_CA 5007
#define IDS_MD_CERT_ENROLL_ERR_PROCESSING_PKCS7_OUTOFBAND_B4_XENROLL 5008
#define IDS_MD_CERT_ENROLL_RECVED_ERR_FROM_CA 5009
#define IDS_MD_CERT_ENROLL_RECVED_ERR_FROM_ENROLL 5010
#define IDS_MD_CERT_ENROLL_BAD_PKCS7_RECVED_OUTOFBAND 5011
#define IDS_MD_CERT_ENROLL_RENEWAL_REQ_ERROR 5012
#define IDS_MD_CERT_ENROLL_ENTERING_DATA 5013
#define IDS_MD_CERT_ENROLL_PROCESSING_PKCS7_OUTOFBAND 5014
#define IDS_MD_CERT_ENROLL_SENT_TO_CA   5015
#define IDS_MD_CERT_ENROLL_RECVED_OK_FROM_CA_WAITING4ENROLL 5016
#define IDS_MD_CERT_ENROLL_ENROLL_SUCCESS 5017
#define IDS_MD_CERT_ENROLL_RENEWAL_REQ_STARTED 5018
#define IDS_MD_CERT_ENROLL_IMPORT_OF_KEYRING_BACKUP_FAILED 5019
#define IDS_YOU_ALREADY_HAVE_AN_OOB_CERTIFICATE_REQ 5020
#define IDS_YOU_DONT_HAVE_ANY_OUTSTANDING_OFFLINE_CERTIFICATE_REQUESTS 5021
#define IDS_YOU_CURRENTLY_HAVE_A_CERTIFICATE_INSTALLED_ON_THIS_VIRUTAL_SERVER 5022
#define IDS_WOULD_YOU_LIKE_TO_VIEW_THE_CERTIFICATE_THAT_YOU_JUST_IMPORTED 5023
#define IDS_YOUR_IMPORT_OF_THE_KEYRING_BACKUP_FILE_FAILED 5024
#define IDS_WOULD_YOU_LIKE_TO_VIEW_THE_CERTIFICATE 5025
#define IDS_YOU_ALREADY_HAVE_A_CERTIFICATE 5026
#define IDS_YOU_DO_NOT_CURRENTLY_HAVE_A_CERTIFICATE_TO_RENEW 5027
#define IDS_INTERNAL_ERROR_COULD_NOT_RETRIEVE_CERTIFICATE 5028
#define IDS_INTERNAL_ERROR_COULD_NOT_STORE_CERTIFICATE 5029
#define IDS_CONSTRUCTING_A_NEW_CTL_FOR_YOUR_VIRTUAL_WEB_SERVER 5030
#define IDS_USER_INPUT_CONTAINS_CHARACTERS_THAT_ARE_NOT_ALLOWED 5031
#define IDS_TITLE_CREATE_CTL_WIZ        5032
#define IDS_REVERSE_DNS_NAME_BASED_ON_YOUR_VSERVER_DIFFERS_FROM_REG 5033
#define IDS_CAN_NOT_OPEN_SYSTEM_CERTIFICATE_STORES 5034
#define IDS_CAN_NOT_CLOSE_SYSTEM_CERTIFICATE_STORES 5035
#define IDS_INTERNAL_ERROR_PLEASE_CONTACT_CUSTOMER_HELP 5036
#define IDS_COULD_NOT_ACCESS_THE_METABASE 5037
#define IDS_ERR_CERTWIZ_TITLE           5038
#define IDS_ERR_DISPLAY__OOB_INVALID_FILE_WAS_GIVEN 5039
#define IDS_CHOOSE_PREEXISTING_CERT4THIS_SERVER 5040
#define IDS_ARE_YOU_SURE_YOU_WANT_TO_CANCEL 5041
#define IDS_KEYRING_BACKUP_FILE_IMPORT  5042
#define IDS_SETTING_CONTAINER_NAME_FAILED_IN_XENROLL 5046
#define IDS_YOU_DO_NOT_CURRENTLY_HAVE_A_CERTIFICATE_NEED_ONE4CTL 5048
#define IDS_YOU_ALREADY_HAVE_A_CTL      5049
#define IDS_YOU_DO_NOT_CURRENTLY_HAVE_A_CERTIFICATE_TO_DELETE 5050
#define IDS_ERR_DISPLAY__HRESULT__ACCEPTFILEPKCS7WORKED_BUT_FETCHING_CERT_FAILED 5051
#define IDS_OVERWRITEFILE               5052
#define IDS_WE_COULD_NOT_CREATE_FILE_WS 5053
#define IDS_ERR_DISPLAY__HRESULT__PUT_RENEWALCERTIFICATE_CALL_FAILED 5054
#define IDS_NO_SERVER_INSTANCE_SET      5055
#define IDD_TIPS_BEFORE__CTL_WIZARD     30131
#define IDD_COMPLETION_PAGE             30132
#define IDD_IMP_KEYRING_GET_PASSWD      30133
#define IDD_NK_KEYR_IMPORTFILE_INFO     30134
#define IDD_WZ_CTLADMIN_1_WELCOME       30135
#define IDD_NK_FINCERT_1_GETFILENM      30136
#define IDD_NK_FINCERT_2_FILEDATA       30137
#define IDD_WZ_CTLGET_2_WHAT_TASK       30138
#define IDD_WZ_CTL_CREATE_GETINFO1      30139
#define IDD_WZwo_CERTGET_2_WHAT_TASK    30140
#define IDD_WZwo_CERTGET_3_CHOOSE_CA    30141
#define IDD_WZwo_CERTGET_4_KEY_LENGTH   30142
#define IDD_WZwo_CERTGET_5_ORG_INFO     30143
#define IDD_WZwo_CERTGET_6_DN_INFO      30144
#define IDD_WZwo_CERTGET_7_COUNTRY_INFO 30145
#define IDD_WZwo_CERTGET_8_CONTACT_INFO 30146
#define IDD_WZwo_CERTGET_9_FILE_INFO    30147
#define IDD_WZwo_CERTOOB_1_FINCERT_GETFILENM 30148
#define IDD_WZwo_CERTGET_10_CONGRADS_CERT_INSTALLED 30149
#define IDD_WZerr_CERTWIZ_GENERAL_ERROR_PAGE 30150
#define IDS_DONE                        30151
#define IDD_WZwo_CERTGET_2_WHAT_TASK2   30151
#define IDD_WZw_CERTMOD_2_WHAT_TASK3    30152
#define IDD_WZw_CERTMOD_3_REMOVE_CERT   30153
#define IDS_DONT_HAVE_A_PENDING_CERT_REQUEST 30154
#define IDD_WZ_PROMPT_FOR_FRIENDLY_NAME 30154
#define IDS_ERROR_RESULT_PHRASE         30155
#define IDS_UNKNOWN_ERROR               30156
#define IDS_CAUGHT_AN_UNKNOWN_EXCEPTION 30157
#define IDS_CERTIFICATE_WIZARD_CHOOSE_A_CERTIFICATE 30158
#define IDS_YES                         30159
#define IDS_OK                          30160
#define IDS_CERT_HAS_BEEN_REMOVED       30161
#define IDS_COULDNT_MAP_CERT_TO_VALID_CERT_STORE_NAME 30162
#define IDS_SETTING_CONTAINER_NAME_FAILED 30163
#define IDS_ERR_DISPLAY__HRESULT__USE_MD5_CALL_FAILED 30164
#define IDS_ERROR_GETTING_KEY_CONTAINER_NAME_FOR_THE_CERT 30166
#define IDS_ERROR_STORING_EITHER_THE_KEY_CONTAINER_OR_STORE_NAME_FOR_CERT 30167
#define IDS_COMMON_NAME                 30168
#define IDS_FRIENDLY_NAME               30169
#define IDS_EXPIRATION                  30170
#define IDS_PURPOSE                     30171
#define IDS_ISSUED_BY                   30172
#define IDS_STORE_NAME                  30173
#define IDS_EXPIRED                     30174
#define IDS_NOT_YET_VALID               30175
#define IDS_YOU_MUST_SELECT_A_CERT_THEN_PRESS_FINISH 30176
#define IDS_ANY_PURPOSE                 30177
#define IDS_SERVERCERT__PLUS__CTL_SIGNING 30178
#define IDS_CLOCK_SKEW_PART1            30179
#define IDS_CLOCK_SKEW_PART2            30180
#define IDS_GETHOSTNAME_FAILED_RETURNING_SOCKET 30182
#define IDS_WSAEFAULT                   30183
#define IDS_WSAEFAULT_NAMED_PARAM_NOT_VALID 30184
#define IDS_WSANOTINITIALISED           30185
#define IDS_WSAEINPROGRESS              30186
#define IDS_WE_COULD_NOT_OPEN_FILE_FOR_READING 30187
#define IDS_ERROR_WHILE_READING_FILE__S__ERROR_CODE__D 30188
#define IDS_INSUFFICIENT_MEMORY_WHILE_READING_FILE_S 30189
#define IDS_ERR_DISPLAY__HRESULT__USE_PROV_RSA_SCHANNEL_CALL_FAILED 30191
#define IDS_LOCALHOST                   30193
#define IDS_HRESULT_ERROR_CODE          30194
#define IDS_ERR_DISPLAY__HRESULT__CREATEPKCS10_CALL_FAILED__NTE_EXISTS 30195
#define IDS_NO_SPECIFIC_ERROR_STRING_WAS_FOUND_IN_THE_INTERNATIONALIZED_STRING_TABLE 30196
#define IDS_WE_CURRENTLY_DONT_SUPPORT_REMOTE_CERTSERVER_ONLINE_INTERFACES 30197
#define IDS_WE_CURRENTLY_DONT_SUPPORT_REMOTE_ADMIN_OF_SERVERS 30198
#define IDS_GET_COMPUTER_NAME_FAILED    30199
#define IDS_ERROR_LOADING_RESOURCE_STRING_HAVING_ID 30200
#define IDS_UNKNOWN_ERROR_CODE          30201
#define IDS_ENCRYPTION_NOT_ALLOWED_BASED_ON_THE_MACHINE_CONFIG_DATA 30202
#define IDS__NTE_BAD_FLAGS__ERROR       30203
#define IDS__NTE_BAD_ALGID__ERROR       30204
#define IDS__RPC_E_DISCONNECTED         30205
#define IDS__RPC_E_RETRY                30206
#define IDS_FILE_PICK_CERTFILE2READ     30207
#define IDS_ENTER_COMPUTER_NAME_HERE    30208
#define IDS_AN_ERROR_WAS_ENCOUNTERED_IN_CALL_xxx_PRODUCING_AN_ERROR_CODE_OF 30209
#define IDS_LIMIT_THE_LENGTH_OF_THIS_FIELD 30210
#define IDS_CERTSERVER_IS_PROBABLY_NOT_INSTALLED 30211
#define IDS_PROBLEM_WHEN_RUNNING_X_Y_OPERATION 30212
#define IDS_REGISTER                    30213
#define IDS_UNREGISTER                  30214
#define IDS_PROBLEM_WRITING_TO_FILE_WS_ERROR_D 30215
#define IDS_GETTEMPPATH_FOR_S_PRODUCED_ERROR_D 30216
#define IDS_GETTEMPFILENAME_FOR_S_GAVE_ERROR_D 30217
#define IDS_CREATEFILE_FOR_S_GAVE_ERROR_D 30218
#define IDS_TEMP_FILE_S_NOT_EMPTY_AFTER_WE_CREATED_IT 30219
#define IDS_WRITING_FILE_S_PRODUCED_ERROR_D 30220
#define IDS_CLOSE_FILEHANDLE_FOR_S_GAVE_ERROR_D 30221
#define IDS_CERT_ATTEMPTING_TO_RENEW_VIA_OOB_DOES_NOT_MATCH_CURRENT 30222
#define IDS_PLEASE_CONFIRM__RENEW_CERT_NOT_CURRENTLY_ASSIGNED 30223
#define IDS_CANCELLING_THE_RENEW_OPERATION 30224
#define IDS_WE_COULDNT_FIND_SAVED_OFFLINE_INFO_ABOUT_THIS_CERT_USING_PKCS7 30225
#define IDS_COUNTRY_CODES_ARE_2_LETTERS_LONG 30226
#define IDS_RENEWAL_INFORMATION_FOR_CERT_NOT_AVAILABLE                30227
#define IDS_INTERNAL_ERROR_PLEASE_CONTACT_YOUR_SYSTEM_ADMIN           30228
#define IDS_INTERNAL_ERROR_PLEASE_CONTACT_YOUR_SYSTEM_ADMIN_ERROR__D  30229 
#define IDS_EMPTY_STRING                                              30231

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        241
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         256
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certobj\base64.h ===
//
// base64.h
//
#ifndef _BASE64_H
#define _BASE64_H

DWORD Base64DecodeA(const char * pchIn, DWORD cchIn, BYTE * pbOut, DWORD * pcbOut);
DWORD Base64EncodeA(const BYTE * pbIn, DWORD cbIn, char * pchOut, DWORD * pcchOut);
DWORD Base64EncodeW(BYTE const *pbIn, DWORD cbIn, WCHAR *wszOut, DWORD *pcchOut);
DWORD Base64DecodeW(const WCHAR * wszIn, DWORD cch, BYTE *pbOut, DWORD *pcbOut);

#endif	//_BASE64_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\wwztwo.h ===
// WWzTwo.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CWildWizTwo dialog

class CWildWizTwo : public CPropertyPage
{
    DECLARE_DYNCREATE(CWildWizTwo)

// Construction
public:
    CWildWizTwo();
    ~CWildWizTwo();

    // to make the buttons behave right
    BOOL            m_fIsWizard;
    CPropertySheet* m_pPropSheet;

    // the only public member
    CCertMapRule*   m_pRule;

    // base path to the metabase
    CString m_szMBPath;

    virtual BOOL OnWizardFinish();
    virtual BOOL OnApply();
    virtual BOOL OnInitDialog();

// Dialog Data
    //{{AFX_DATA(CWildWizTwo)
    enum { IDD = IDD_WILDWIZ_2 };
    CListSelRowCtrl m_clistctrl_list;
    CButton m_cbutton_new;
    CButton m_cbutton_edit;
    CButton m_cbutton_delete;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CWildWizTwo)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CWildWizTwo)
    afx_msg void OnDelete();
    afx_msg void OnEdit();
    afx_msg void OnDblclkList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnItemchangedList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnNew();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void DoHelp();

    BOOL FInitRulesList();
    BOOL FillRulesList();

    // editing and updating
    void EnableDependantButtons();
    BOOL EditRule( DWORD iList );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certobj\certlog.h ===
#include "stdafx.h"


BOOL EventlogRegistryInstall(void);
void EventlogRegistryUnInstall(void);
void ReportIt(DWORD dwEventID, LPCTSTR szMetabasePath);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\wwzthree.h ===
// WWzThree.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CWildWizThree dialog

class CWildWizThree : public CPropertyPage
{
    DECLARE_DYNCREATE(CWildWizThree)

// Construction
public:
    CWildWizThree();
    ~CWildWizThree();

    // to make the buttons behave right
    BOOL            m_fIsWizard;
    CPropertySheet* m_pPropSheet;

    // the only public member
    CCertMapRule*   m_pRule;

    // base path to the metabase
    CString m_szMBPath;

    virtual BOOL OnWizardFinish();
    virtual BOOL OnApply();
    virtual BOOL OnInitDialog();

    // Dialog Data
    //{{AFX_DATA(CWildWizThree)
    enum { IDD = IDD_WILDWIZ_3 };
    CStatic m_static_password;
    CStatic m_static_account;
    CButton m_btn_browse;
    CEdit   m_cedit_password;
    CEdit   m_cedit_accountname;
    int     m_int_DenyAccess;
    CString m_sz_accountname;
    CStrPassword m_sz_password;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CWildWizThree)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CWildWizThree)
    afx_msg void OnBrowse();
    afx_msg void OnChangeNtaccount();
    afx_msg void OnChangePassword();
    afx_msg void OnAcceptLogon();
    afx_msg void OnRefuseLogon();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void DoHelp();
    void EnableButtons();

    CStrPassword m_szOrigPass;
    BOOL    m_bPassTyped;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\wwztwo.cpp ===
// WWzTwo.cpp : implementation file
//

#include "stdafx.h"
#include <iadmw.h>
#include "certmap.h"

#include "ListRow.h"
#include "ChkLstCt.h"
extern "C"
    {
    #include <wincrypt.h>
    #include <schannel.h>
    }
#include "Iismap.hxx"
#include "Iiscmr.hxx"

#include "brwsdlg.h"
#include "EdWldRul.h"
#include "EdtRulEl.h"

#include "WWzTwo.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define COL_CERT_FIELD          0
#define COL_SUB_FIELD           1
#define COL_MATCH_CRITERIA      2

/////////////////////////////////////////////////////////////////////////////
// CWildWizTwo property page

IMPLEMENT_DYNCREATE(CWildWizTwo, CPropertyPage)

CWildWizTwo::CWildWizTwo() : CPropertyPage(CWildWizTwo::IDD)
{
    //{{AFX_DATA_INIT(CWildWizTwo)
    //}}AFX_DATA_INIT
}

CWildWizTwo::~CWildWizTwo()
{
}

void CWildWizTwo::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CWildWizTwo)
    DDX_Control(pDX, IDC_LIST, m_clistctrl_list);
    DDX_Control(pDX, IDC_NEW, m_cbutton_new);
    DDX_Control(pDX, IDC_EDIT, m_cbutton_edit);
    DDX_Control(pDX, IDC_DELETE, m_cbutton_delete);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWildWizTwo, CPropertyPage)
    //{{AFX_MSG_MAP(CWildWizTwo)
    ON_BN_CLICKED(IDC_DELETE, OnDelete)
    ON_BN_CLICKED(IDC_EDIT, OnEdit)
    ON_NOTIFY(NM_DBLCLK, IDC_LIST, OnDblclkList)
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST, OnItemchangedList)
    ON_BN_CLICKED(IDC_NEW, OnNew)
    //}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,  DoHelp)
    ON_COMMAND(ID_HELP,         DoHelp)
    ON_COMMAND(ID_CONTEXT_HELP, DoHelp)
    ON_COMMAND(ID_DEFAULT_HELP, DoHelp)
END_MESSAGE_MAP()

//---------------------------------------------------------------------------
void CWildWizTwo::DoHelp()
    {
    WinHelpDebug(HIDD_CERTMAP_ADV_RUL_RULES);
    WinHelp( HIDD_CERTMAP_ADV_RUL_RULES );
    }

//---------------------------------------------------------------------------
BOOL CWildWizTwo::FInitRulesList()
    {
    CString sz;
    int     i;

    // setup the main field
    sz.LoadString( IDS_CERT_FIELD );

    i = m_clistctrl_list.InsertColumn( COL_CERT_FIELD, sz, LVCFMT_LEFT, 100 );

    // setup the sub field
    sz.LoadString( IDS_SUB_FIELD );
    i = m_clistctrl_list.InsertColumn( COL_SUB_FIELD, sz, LVCFMT_LEFT, 70 );

    // setup the match criteria column
    sz.LoadString( IDS_MATCH_CRITERIA );
    i = m_clistctrl_list.InsertColumn( COL_MATCH_CRITERIA, sz, LVCFMT_LEFT, 226 );

    return TRUE;
    }

//---------------------------------------------------------------------------
BOOL CWildWizTwo::FillRulesList()
    {
    CERT_FIELD_ID   idCertField;
    LPBYTE          pContent;
    DWORD           cbContent;
    LPSTR           psz;

    DWORD           flags;

    CString         sz;
    int             i;

    //
    // UNICODE/ANSI conversion -- RonaldM
    //
    USES_CONVERSION;

    // get the number of subfield rules
    DWORD cbRules = m_pRule->GetRuleElemCount();

    // loop the elements, adding each to the list
    for ( DWORD j = 0; j < cbRules; j++ )
        {
        // get the raw data for the rule element
        if ( !m_pRule->GetRuleElem( j, &idCertField, (PCHAR*)&pContent, &cbContent, &psz, &flags ) )
            continue;       // the call failed - try the next

        // start converting the data into readable form and adding it to the list
        sz = MapIdToField( idCertField );
        // create the new entry in the list box.
        i = m_clistctrl_list.InsertItem( j, sz );

        // add the subfield data
        sz = MapAsn1ToSubField( psz );
        m_clistctrl_list.SetItemText( i, COL_SUB_FIELD, sz );

        // add the content data - reuse the psz pointer
        if ( BinaryToMatchRequest( pContent, cbContent, &psz ) )
            m_clistctrl_list.SetItemText( i, COL_MATCH_CRITERIA, A2T(psz) );

        // finally, attach the id cert field as user data to the item
        DWORD   dw;
        BOOL    fMatchCapitalization = !(flags & CMR_FLAGS_CASE_INSENSITIVE);
        dw = ( (fMatchCapitalization << 16) | idCertField );
        m_clistctrl_list.SetItemData( i, dw );
        }

        return TRUE;
    }


//CMR_FLAGS_CASE_INSENSITIVE

// editing and updating

//---------------------------------------------------------------------------
void CWildWizTwo::EnableDependantButtons()
    {
    // the whole purpose of this routine is to gray or activate
    // the edit and delete buttons depending on whether or not anything
    // is selected. So start by getting the selection count
    UINT    cItemsSel = m_clistctrl_list.GetSelectedCount();

    if ( cItemsSel > 0 )
        {
        // there are items selected
        m_cbutton_edit.EnableWindow( TRUE );
        m_cbutton_delete.EnableWindow( TRUE );
        }
    else
        {
        // nope. Nothing selected
        m_cbutton_edit.EnableWindow( FALSE );
        m_cbutton_delete.EnableWindow( FALSE );
        }

    // always enable the new button
    m_cbutton_new.EnableWindow( TRUE );
    }

//---------------------------------------------------------------------------
BOOL CWildWizTwo::EditRule( DWORD iList )
    {
    // declare the editing dialog
    CEditRuleElement    editDlg;
    DWORD               dw;

    // fill in its data
    // IA64 - OK to cast as the data really is just a DWORD
    dw = (DWORD)m_clistctrl_list.GetItemData( iList );
    editDlg.m_bool_match_case = HIWORD( dw );
    editDlg.m_int_field = LOWORD( dw );
    editDlg.m_sz_subfield = m_clistctrl_list.GetItemText( iList, COL_SUB_FIELD );
    editDlg.m_sz_criteria = m_clistctrl_list.GetItemText( iList, COL_MATCH_CRITERIA );

    // run the dialog
    if ( editDlg.DoModal() == IDOK )
        {
        // must convert the field into a string too
        CERT_FIELD_ID id = (CERT_FIELD_ID)editDlg.m_int_field;
        CString sz = MapIdToField( id );
        m_clistctrl_list.SetItemText( iList, COL_CERT_FIELD, sz );

        dw = ( (editDlg.m_bool_match_case << 16) | id);
        m_clistctrl_list.SetItemData( iList, dw );
        m_clistctrl_list.SetItemText( iList, COL_SUB_FIELD, editDlg.m_sz_subfield );
        m_clistctrl_list.SetItemText( iList, COL_MATCH_CRITERIA, editDlg.m_sz_criteria );
 
        // we can now apply
        SetModified();
        }
    return TRUE;
    }


/////////////////////////////////////////////////////////////////////////////
// CWildWizTwo message handlers

//---------------------------------------------------------------------------
BOOL CWildWizTwo::OnInitDialog()
    {
    // call the parental oninitdialog
    BOOL f = CPropertyPage::OnInitDialog();

    // initialize the list
    FInitRulesList();
    FillRulesList();
    EnableDependantButtons();

    // return the answer
    return f;
    }

//---------------------------------------------------------------------------
BOOL CWildWizTwo::OnWizardFinish()
    {
    return OnApply();
    }

//---------------------------------------------------------------------------
BOOL CWildWizTwo::OnApply()
    {
    CERT_FIELD_ID   id;
    CString         szSub, sz;
    LPBYTE          pbBin;
    DWORD           cbBin;
    UINT            cItems;
    UINT            iItem;

    USES_CONVERSION;

    // update the data
    UpdateData( TRUE );

    //======== store the rule elements
    // start by resetting the entire rule - that way we don't have to
    // mess with individual elements in the list, allowing us to cancel. 
    // But that is ok, because we can just spin through
    // the ones in the list very quickly and re-add them

    // remove the existing elements from the list.
    cItems = m_pRule->GetRuleElemCount();
    for ( iItem = 0; iItem < cItems; iItem++ )
        m_pRule->DeleteRuleElem( 0 );

    // add all the items in the list
    cItems = m_clistctrl_list.GetItemCount();
    for ( iItem = 0; iItem < cItems; iItem++ )
        {
        // prepare the field id
        id = (CERT_FIELD_ID)LOWORD(m_clistctrl_list.GetItemData( iItem ));

        // prepare the caps flag
        BOOL    fCaps = HIWORD(m_clistctrl_list.GetItemData( iItem ));
        DWORD   flags = 0;
        if ( !fCaps )
            flags = CMR_FLAGS_CASE_INSENSITIVE;


        // prepare the subfield
        sz = m_clistctrl_list.GetItemText(iItem, COL_SUB_FIELD);

        LPSTR szA = T2A((LPTSTR)(LPCTSTR)sz);
        szSub = MapSubFieldToAsn1( szA );

        // prepare the data
        sz = m_clistctrl_list.GetItemText(iItem, COL_MATCH_CRITERIA);
        szA = T2A((LPTSTR)(LPCTSTR)sz);
        if ( !MatchRequestToBinary( szA, &pbBin, &cbBin) )
            continue;

        // add the element to the rule
        m_pRule->AddRuleElem( 0xffffffff, id, T2A((LPTSTR)(LPCTSTR)szSub), pbBin, cbBin, flags );

        // free the binary match data
        FreeMatchConversion( pbBin );
        }

    // return success
    SetModified( FALSE );
    return TRUE;
    }

//---------------------------------------------------------------------------
void CWildWizTwo::OnDelete() 
    {
    ASSERT( m_clistctrl_list.GetSelectedCount() == 1 );
    DWORD           iList;

    // get index of the selected list item
    iList = m_clistctrl_list.GetNextItem( -1, LVNI_SELECTED );
    ASSERT( iList >= 0 );

    // delete the item from the display list
    m_clistctrl_list.DeleteItem ( iList );

    // we can now apply
    SetModified();
    }

//---------------------------------------------------------------------------
void CWildWizTwo::OnEdit() 
    {
    ASSERT( m_clistctrl_list.GetSelectedCount() == 1 );
    DWORD           iList;

    // get index of the selected list item
    iList = m_clistctrl_list.GetNextItem( -1, LVNI_SELECTED );
    ASSERT( iList >= 0 );

    // edit the item
    EditRule( iList );
    }

//---------------------------------------------------------------------------
void CWildWizTwo::OnNew() 
    {
    // declare the editing dialog
    CEditRuleElement    editDlg;

    // fill in its data
    editDlg.m_bool_match_case = TRUE;
    editDlg.m_int_field = CERT_FIELD_SUBJECT;
    editDlg.m_sz_subfield = "O";

    editDlg.m_sz_criteria.LoadString( IDS_WILDSTRING );

    // run the dialog
    if ( editDlg.DoModal() == IDOK )
        {
        // get the index for adding to the end of the list
        int iEnd = m_clistctrl_list.GetItemCount();

        // Start with the cert field
        CERT_FIELD_ID id = (CERT_FIELD_ID)editDlg.m_int_field;
        CString sz = MapIdToField( id );
        int i = m_clistctrl_list.InsertItem( iEnd, sz );

        DWORD dw = ( (editDlg.m_bool_match_case << 16) | id);
        m_clistctrl_list.SetItemData( i, dw );
//      m_clistctrl_list.SetItemData( i, id );
        m_clistctrl_list.SetItemText( i, COL_SUB_FIELD, editDlg.m_sz_subfield );
        m_clistctrl_list.SetItemText( i, COL_MATCH_CRITERIA, editDlg.m_sz_criteria );

        // we can now apply
        SetModified();
        }
    }

//---------------------------------------------------------------------------
void CWildWizTwo::OnDblclkList(NMHDR* pNMHDR, LRESULT* pResult) 
    {
    *pResult = 0;
    // if something in the list was double clicked, edit it
    if ( m_clistctrl_list.GetSelectedCount() > 0 )
        OnEdit();
    }

//---------------------------------------------------------------------------
void CWildWizTwo::OnItemchangedList(NMHDR* pNMHDR, LRESULT* pResult) 
    {
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
    *pResult = 0;

    // enable the correct items
    EnableDependantButtons();
    }

//---------------------------------------------------------------------------
BOOL CWildWizTwo::OnSetActive() 
    {
    // if this is a wizard, gray out the back button
    if ( m_fIsWizard )
        m_pPropSheet->SetWizardButtons( PSWIZB_BACK | PSWIZB_NEXT );
    return CPropertyPage::OnSetActive();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certobj\base64.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1996
//
// File:        base64.cpp
//
// Contents:    base64 encode/decode implementation
//
// History:     25-Jul-96       vich created
//
//---------------------------------------------------------------------------
//                3-Mar-98   tompop took and modified it.  Building
//                           both Ansi and Wchar versions of Encode/Decode
//                           base 64 for CertWizard, that is in IIS5's UI.
//                           We merged the examples from NT5's base64.cpp
//                           and ubase64.cpp files into this single file.
//					   5-Aug-98	  Sergei Antonov removed above mentioned stuff after tompop
//---------------------------------------------------------------------------
#include "stdafx.h"
#include <malloc.h>
#include <windows.h>
#include "base64.h"
#include <strsafe.h>

// The following table translates an ascii subset to 6 bit values as follows
// (see rfc 1521):
//
//  input    hex (decimal)
//  'A' --> 0x00 (0)
//  'B' --> 0x01 (1)
//  ...
//  'Z' --> 0x19 (25)
//  'a' --> 0x1a (26)
//  'b' --> 0x1b (27)
//  ...
//  'z' --> 0x33 (51)
//  '0' --> 0x34 (52)
//  ...
//  '9' --> 0x3d (61)
//  '+' --> 0x3e (62)
//  '/' --> 0x3f (63)
//
// Encoded lines must be no longer than 76 characters.
// The final "quantum" is handled as follows:  The translation output shall
// always consist of 4 characters.  'x', below, means a translated character,
// and '=' means an equal sign.  0, 1 or 2 equal signs padding out a four byte
// translation quantum means decoding the four bytes would result in 3, 2 or 1
// unencoded bytes, respectively.
//
//  unencoded size    encoded data
//  --------------    ------------
//     1 byte       "xx=="
//     2 bytes      "xxx="
//     3 bytes      "xxxx"

#define CB_BASE64LINEMAX    64  // others use 64 -- could be up to 76

// Any other (invalid) input character value translates to 0x40 (64)

const BYTE abDecode[256] =
{
    /* 00: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* 10: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* 20: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 62, 64, 64, 64, 63,
    /* 30: */ 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 64, 64, 64, 64, 64, 64,
    /* 40: */ 64,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
    /* 50: */ 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 64, 64, 64, 64, 64,
    /* 60: */ 64, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
    /* 70: */ 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 64, 64, 64, 64, 64,
    /* 80: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* 90: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* a0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* b0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* c0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* d0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* e0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* f0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
};


const UCHAR abEncode[] =
    /*  0 thru 25: */ "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    /* 26 thru 51: */ "abcdefghijklmnopqrstuvwxyz"
    /* 52 thru 61: */ "0123456789"
    /* 62 and 63: */  "+/";


DWORD
Base64DecodeA(const char * pchIn, DWORD cchIn, BYTE * pbOut, DWORD * pcbOut)
{
   DWORD err = ERROR_SUCCESS;
   DWORD cchInDecode, cbOutDecode;
   CHAR const *pchInEnd = NULL;
   CHAR const *pchInT = NULL;
   BYTE *pbOutT = NULL;

   // Check for bad pointers passed in...
   if (!pchIn || !*pchIn)
   {
       err = E_POINTER;
       goto error;
   }

   // Count the translatable characters, skipping whitespace & CR-LF chars.
   cchInDecode = 0;
   pchInEnd = &pchIn[cchIn];
   for (pchInT = pchIn; pchInT < pchInEnd; pchInT++)
   {
		if (sizeof(abDecode) < (unsigned) *pchInT || abDecode[*pchInT] > 63)
		{
			// skip all whitespace
			if (	*pchInT == ' ' 
				||	*pchInT == '\t' 
				||	*pchInT == '\r' 
				||	*pchInT == '\n'
				)
			{
				continue;
			}

			if (0 != cchInDecode)
			{
				if ((cchInDecode % 4) == 0)
				{
					break;          // ends on quantum boundary
			}

			// The length calculation may stop in the middle of the last
			// translation quantum, because the equal sign padding
			// characters are treated as invalid input.  If the last
			// translation quantum is not 4 bytes long, it must be 2 or 3
			// bytes long.

			if (*pchInT == '=' && (cchInDecode % 4) != 1)
			{
				break;              // normal termination
			}
		}
      err = ERROR_INVALID_DATA;
      goto error;
	}
   cchInDecode++;
   }
    ATLASSERT(pchInT <= pchInEnd);
    pchInEnd = pchInT;      // don't process any trailing stuff again

    // We know how many translatable characters are in the input buffer, so now
    // set the output buffer size to three bytes for every four (or fraction of
    // four) input bytes.

    cbOutDecode = ((cchInDecode + 3) / 4) * 3;

    pbOutT = pbOut;

    if (NULL == pbOut)
    {
    pbOutT += cbOutDecode;
    }
    else
    {
    // Decode one quantum at a time: 4 bytes ==> 3 bytes

    ATLASSERT(cbOutDecode <= *pcbOut);
    pchInT = pchIn;
    while (cchInDecode > 0)
    {
        DWORD i;
        BYTE ab4[4];

        memset(ab4, 0, sizeof(ab4));
        for (i = 0; i < min(sizeof(ab4)/sizeof(ab4[0]), cchInDecode); i++)
        {
        while (
            sizeof(abDecode) > (unsigned) *pchInT &&
            63 < abDecode[*pchInT])
        {
            pchInT++;
        }
        ATLASSERT(pchInT < pchInEnd);
        ab4[i] = (BYTE) *pchInT++;
        }

        // Translate 4 input characters into 6 bits each, and deposit the
        // resulting 24 bits into 3 output bytes by shifting as appropriate.

        // out[0] = in[0]:in[1] 6:2
        // out[1] = in[1]:in[2] 4:4
        // out[2] = in[2]:in[3] 2:6

        *pbOutT++ =
        (BYTE) ((abDecode[ab4[0]] << 2) | (abDecode[ab4[1]] >> 4));

        if (i > 2)
        {
        *pbOutT++ =
          (BYTE) ((abDecode[ab4[1]] << 4) | (abDecode[ab4[2]] >> 2));
        }
        if (i > 3)
        {
        *pbOutT++ = (BYTE) ((abDecode[ab4[2]] << 6) | abDecode[ab4[3]]);
        }
        cchInDecode -= i;
    }
    ATLASSERT((DWORD) (pbOutT - pbOut) <= cbOutDecode);
    }
    *pcbOut = (DWORD)(pbOutT - pbOut);

error:
    return(err);
}

// Base64EncodeA 
//
// RETURNS  0 (i.e. ERROR_SUCCESS) on success
//


DWORD
Base64EncodeA(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT CHAR *pchOut,
    OUT DWORD *pcchOut)
{
    CHAR *pchOutT;
    DWORD cchOutEncode;

    // Allocate enough memory for full final translation quantum.
    cchOutEncode = ((cbIn + 2) / 3) * 4;

    // and enough for CR-LF pairs for every CB_BASE64LINEMAX character line.
    cchOutEncode +=
		2 * ((cchOutEncode + CB_BASE64LINEMAX - 1) / CB_BASE64LINEMAX);

    pchOutT = pchOut;
	if (NULL == pchOut)
   {
		pchOutT += cchOutEncode;
   }
   else
   {
		DWORD cCol;

      ATLASSERT(cchOutEncode <= *pcchOut);
      cCol = 0;
      while ((long) cbIn > 0) // signed comparison -- cbIn can wrap
      {
         BYTE ab3[3];

         if (cCol == CB_BASE64LINEMAX/4)
         {
            cCol = 0;
            *pchOutT++ = '\r';
            *pchOutT++ = '\n';
         }
         cCol++;
         memset(ab3, 0, sizeof(ab3));

         ab3[0] = *pbIn++;
         if (cbIn > 1)
         {
           ab3[1] = *pbIn++;
           if (cbIn > 2)
           {
               ab3[2] = *pbIn++;
           }
         }

         *pchOutT++ = abEncode[ab3[0] >> 2];
         *pchOutT++ = abEncode[((ab3[0] << 4) | (ab3[1] >> 4)) & 0x3f];
         *pchOutT++ = (cbIn > 1)?
            abEncode[((ab3[1] << 2) | (ab3[2] >> 6)) & 0x3f] : '=';
         *pchOutT++ = (cbIn > 2)? abEncode[ab3[2] & 0x3f] : '=';

         cbIn -= 3;
      }
      *pchOutT++ = '\r';
      *pchOutT++ = '\n';
      ATLASSERT((DWORD) (pchOutT - pchOut) <= cchOutEncode);
   }
   *pcchOut = (DWORD)(pchOutT - pchOut);
   return(ERROR_SUCCESS);
}

// Base64EncodeW 
//
// RETURNS  0 (i.e. ERROR_SUCCESS) on success
//

DWORD Base64EncodeW(
    BYTE const *pbIn,
    DWORD cbIn,
    WCHAR *wszOut,
    DWORD *pcchOut)

{

    DWORD   cchOut;
    char   *pch = NULL;
    DWORD   cch;
    DWORD   err;

    ATLASSERT(pcchOut != NULL);

    // only want to know how much to allocate
    // we know all base64 char map 1-1 with unicode
    if( wszOut == NULL ) {

        // get the number of characters
        *pcchOut = 0;
        err = Base64EncodeA(
                pbIn,
                cbIn,
                NULL,
                pcchOut);
    }

    // otherwise we have an output buffer
    else {

        // char count is the same be it ascii or unicode,
        cchOut = *pcchOut;
        cch = 0;
        err = ERROR_OUTOFMEMORY;
        if( (pch = (char *) malloc(cchOut)) != NULL  &&
        
            (err = Base64EncodeA(
                pbIn,
                cbIn,
                pch,
                &cchOut)) == ERROR_SUCCESS      ) {

            // should not fail!
            cch = MultiByteToWideChar(0, 
                            0, 
                            pch, 
                            cchOut, 
                            wszOut, 
                            *pcchOut);

            // check to make sure we did not fail                            
            ATLASSERT(*pcchOut == 0 || cch != 0);                            
        }
    }

    if(pch != NULL)
        free(pch);

    return(err);
}

// Base64DecodeW 
//
// RETURNS  0 (i.e. ERROR_SUCCESS) on success
//

DWORD Base64DecodeW(
    const WCHAR * wszIn,
    DWORD cch,
    BYTE *pbOut,
    DWORD *pcbOut)
{

    char *pch;
    DWORD err = ERROR_SUCCESS;
    
    if( (pch = (char *) malloc(cch)) == NULL ) 
	 {
        err = ERROR_OUTOFMEMORY;
    }
    else if( WideCharToMultiByte(0, 0, wszIn, cch, pch, cch, 
                        NULL, NULL) == 0 ) 
	 {
        err = ERROR_NO_DATA;
    }
    else if( pbOut == NULL ) 
	 {
        *pcbOut = 0;
        err = Base64DecodeA(pch, cch, NULL, pcbOut);
    }
    else 
	 {
        err = Base64DecodeA(pch, cch, pbOut, pcbOut);
    }
    if(pch != NULL)
        free(pch);
    return(err);
}

#if 0
// sanity tests...  Lets make sure that the encode and decode
//                  works...

BOOL test_Base64EncodeW()
{
    BYTE  pbIn[120];            // for the test we just use the random stack data
    DWORD cbIn = sizeof( pbIn );
    
    WCHAR *wszB64Out;
    DWORD pcchB64Out;

    DWORD  err;
    
    // BASE64 encode pkcs 10
    if( (err = Base64EncodeW(
                pbIn,
                cbIn,
                NULL,
                &pcchB64Out)) != ERROR_SUCCESS     ||
        (wszB64Out = (WCHAR *) _alloca(pcchB64Out * sizeof(WCHAR))) == NULL  ||
        (err = Base64EncodeW(
                pbIn,
                cbIn,
                wszB64Out,
                &pcchB64Out)) != ERROR_SUCCESS ) 
    {
        SetLastError(err);
        return FALSE;  //goto ErrorBase64Encode;
    }


    // well the encode worked lets test the decode
    //
    // pcchB64Out holds the B64 data length
    // wszB64Out  holds the actual data

     DWORD blob_cbData;     // we store in these variables what
     BYTE* blob_pbData;     //  we read in..

    // They should match the stuff stored in:
    //    BYTE  pbIn[120];
    //    DWORD cbIn = sizeof( pbIn );
    // This we be tested after the decode.

    // base64 decode
    if( (err = Base64DecodeW(
            wszB64Out,
            pcchB64Out,
            NULL,
            &blob_cbData)) != ERROR_SUCCESS                    ||
        (blob_pbData = (BYTE *) _alloca(blob_cbData)) == NULL      ||
        (err = Base64DecodeW(
            wszB64Out,
            pcchB64Out,
            blob_pbData,
            &blob_cbData)) != ERROR_SUCCESS ) 
    {
        
        SetLastError(err);
        return(FALSE);  //goto ErrorBase64Decode;
    }



    //do compare

    
    return( (blob_cbData==cbIn)
            &&  (memcmp(blob_pbData, pbIn,cbIn)==0) );
    

 }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certmap\wwzthree.cpp ===
// WWzThree.cpp : implementation file
//

#include "stdafx.h"
#include <iadmw.h>
#include "certmap.h"

#include "ListRow.h"
#include "ChkLstCt.h"
extern "C"
    {
    #include <wincrypt.h>
    #include <schannel.h>
    }
#include "Iismap.hxx"
#include "Iiscmr.hxx"

#include "brwsdlg.h"
#include "EdWldRul.h"
#include "EdtRulEl.h"

#include "WWzThree.h"

#include "cnfrmpsd.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define ACCESS_DENY         0
#define ACCESS_ACCEPT       1

/////////////////////////////////////////////////////////////////////////////
// CWildWizThree property page

IMPLEMENT_DYNCREATE(CWildWizThree, CPropertyPage)

CWildWizThree::CWildWizThree() : CPropertyPage(CWildWizThree::IDD)
{
    //{{AFX_DATA_INIT(CWildWizThree)
    m_int_DenyAccess = -1;
    m_sz_accountname = _T("");
    m_sz_password = _T("");
    //}}AFX_DATA_INIT
    m_bPassTyped = FALSE;
}

CWildWizThree::~CWildWizThree()
{
}

void CWildWizThree::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CWildWizThree)
    DDX_Control(pDX, IDC_STATIC_PASSWORD, m_static_password);
    DDX_Control(pDX, IDC_STATIC_ACCOUNT, m_static_account);
    DDX_Control(pDX, IDC_BROWSE, m_btn_browse);
    DDX_Control(pDX, IDC_PASSWORD, m_cedit_password);
    DDX_Control(pDX, IDC_NTACCOUNT, m_cedit_accountname);
    DDX_Radio(pDX, IDC_REFUSE_LOGON, m_int_DenyAccess);
    DDX_Text(pDX, IDC_NTACCOUNT, m_sz_accountname);
    //DDX_Text(pDX, IDC_PASSWORD, m_sz_password);
    DDX_Text_SecuredString(pDX, IDC_PASSWORD, m_sz_password);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWildWizThree, CPropertyPage)
    //{{AFX_MSG_MAP(CWildWizThree)
    ON_BN_CLICKED(IDC_BROWSE, OnBrowse)
    ON_EN_CHANGE(IDC_NTACCOUNT, OnChangeNtaccount)
    ON_EN_CHANGE(IDC_PASSWORD, OnChangePassword)
    ON_BN_CLICKED(IDC_ACCEPT_LOGON, OnAcceptLogon)
    ON_BN_CLICKED(IDC_REFUSE_LOGON, OnRefuseLogon)
    //}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,  DoHelp)
    ON_COMMAND(ID_HELP,         DoHelp)
    ON_COMMAND(ID_CONTEXT_HELP, DoHelp)
    ON_COMMAND(ID_DEFAULT_HELP, DoHelp)
END_MESSAGE_MAP()

//---------------------------------------------------------------------------
void CWildWizThree::DoHelp()
    {
    WinHelpDebug(HIDD_CERTMAP_ADV_RUL_MAPPING);
    WinHelp( HIDD_CERTMAP_ADV_RUL_MAPPING );
    }


//---------------------------------------------------------------------------
void CWildWizThree::EnableButtons()
    {
    UpdateData( TRUE );
    
    // if the access is set to refuse access, then disable the account
    // and password stuff.
    if ( m_int_DenyAccess == 0 )
        {
        // deny access
        m_static_password.EnableWindow( FALSE );
        m_static_account.EnableWindow( FALSE );
        m_btn_browse.EnableWindow( FALSE );
        m_cedit_password.EnableWindow( FALSE );
        m_cedit_accountname.EnableWindow( FALSE );
        }
    else
        {
        // give access
        m_static_password.EnableWindow( TRUE );
        m_static_account.EnableWindow( TRUE );
        m_btn_browse.EnableWindow( TRUE );
        m_cedit_password.EnableWindow( TRUE );
        m_cedit_accountname.EnableWindow( TRUE );
        }
    }

/////////////////////////////////////////////////////////////////////////////
// CWildWizThree message handlers

//---------------------------------------------------------------------------
BOOL CWildWizThree::OnApply()
    {
    //
    // UNICODE/ANSI Conversion -- RonaldM
    //
    USES_CONVERSION;

    // update the data
    UpdateData( TRUE );

    // only do the account checks if the option is set to accept
    if ( m_int_DenyAccess == ACCESS_ACCEPT )
        {
        // see if the account name is empty
        if ( m_sz_accountname.IsEmpty() )
            {
            AfxMessageBox( IDS_WANTACCOUNT );
            m_cedit_accountname.SetFocus();
            m_cedit_accountname.SetSel(0, -1);
            return FALSE;
            }
        }

    // confirm the password
    if ( m_bPassTyped && (m_int_DenyAccess == ACCESS_ACCEPT) )
        {
        CConfirmPassDlg dlgPass;
        dlgPass.m_szOrigPass = m_sz_password;
        if ( dlgPass.DoModal() != IDOK )
            {
            m_cedit_password.SetFocus();
            m_cedit_password.SetSel(0, -1);
            return FALSE;
            }
        }
    else
        {
        // restore the original password instead of the
        // standard ****** string
        m_sz_password = m_szOrigPass;
        UpdateData( FALSE );
        }

    // store the deny access radio buttons
    m_pRule->SetRuleDenyAccess( m_int_DenyAccess == ACCESS_DENY );

    // we have to set the account name into place here
    m_pRule->SetRuleAccount( T2A((LPTSTR)(LPCTSTR)m_sz_accountname) );

    // store the password
    CString csTempPassword;
    m_sz_password.CopyTo(csTempPassword);
    m_pRule->SetRulePassword( T2A((LPTSTR)(LPCTSTR)csTempPassword) );

    // reset the password flags
    m_szOrigPass = m_sz_password;
    m_bPassTyped = FALSE;

    SetModified( FALSE );
    return TRUE;
    }

//---------------------------------------------------------------------------
BOOL CWildWizThree::OnInitDialog()
    {
    // call the parental oninitdialog
    BOOL f = CPropertyPage::OnInitDialog();

    // set the easy default strings 
    m_sz_accountname = m_pRule->GetRuleAccount();   // managed by CNTBrowsingDialog from here on

    // set up the deny access radio buttons
    if ( m_pRule->GetRuleDenyAccess() )
        m_int_DenyAccess = ACCESS_DENY;
    else
        m_int_DenyAccess = ACCESS_ACCEPT;

    // initialize the password
    CString csTempPassword;
    csTempPassword = m_pRule->GetRulePassword();
    m_sz_password = csTempPassword;

    m_szOrigPass = m_sz_password;
    if ( !m_sz_password.IsEmpty() )
    {
        CString csTempPassword;
        csTempPassword.LoadString( IDS_SHOWN_PASSWORD );
        m_sz_password = csTempPassword;
    }

    // exchange the data
    UpdateData( FALSE );
    EnableButtons();

    // success
    return TRUE;
    }

//---------------------------------------------------------------------------
BOOL CWildWizThree::OnSetActive() 
    {
    // if this is a wizard, gray out the back button
    if ( m_fIsWizard )
        m_pPropSheet->SetWizardButtons( PSWIZB_BACK | PSWIZB_FINISH );
    return CPropertyPage::OnSetActive();
    }

//---------------------------------------------------------------------------
BOOL CWildWizThree::OnWizardFinish()
    {
    for ( int i = 0; i < m_pPropSheet->GetPageCount( ); i++ )
        {
        if ( !m_pPropSheet->GetPage(i)->OnApply() )
            return FALSE;
        }
    return TRUE;
    }

//---------------------------------------------------------------------------
// run the user browser
void CWildWizThree::OnBrowse() 
{
   UpdateData(TRUE);
   LPTSTR buf = m_sz_accountname.GetBuffer(MAX_PATH);
   GetIUsrAccount(NULL, this, buf, MAX_PATH);
   m_sz_accountname.ReleaseBuffer(-1);
   SetModified();
   UpdateData(FALSE);
}

//---------------------------------------------------------------------------
void CWildWizThree::OnChangeNtaccount() 
    {
    // we can now apply
    SetModified();
    }

//---------------------------------------------------------------------------
void CWildWizThree::OnChangePassword() 
    {
    m_bPassTyped = TRUE;
    // we can now apply
    SetModified();
    }

//---------------------------------------------------------------------------
void CWildWizThree::OnAcceptLogon() 
    {
    EnableButtons();
    // we can now apply
    SetModified();
    }

//---------------------------------------------------------------------------
void CWildWizThree::OnRefuseLogon() 
    {
    EnableButtons();
    // we can now apply
    SetModified();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certobj\certobj.cpp ===
// CertObj.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for CertObj.idl by adding the following 
//      files to the Outputs.
//          CertObj_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f CertObjps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "dlldatax.h"
#include "common.h"
#include "CertObj.h"
#include "CertObj_i.c"
#include "IISCertObj.h"
#include "certlog.h"
#include "dcomperm.h"
#include "IISCertRequest.h"
#include <strsafe.h>

#ifdef _MERGE_PROXYSTUB
    extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

#ifdef USE_CERT_REQUEST_OBJECT

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_IISCertObj, CIISCertObj)
    OBJECT_ENTRY(CLSID_IISCertRequest, CIISCertRequest)
END_OBJECT_MAP()

#else

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_IISCertObj, CIISCertObj)
END_OBJECT_MAP()

#endif

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_CERTOBJLib);
        DisableThreadLibraryCalls(hInstance);
		GetOutputDebugFlag();
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif

	IISDebugOutput(_T("DllCanUnloadNow?:%s\r\n"),_Module.GetLockCount()==0 ? _T("Yes") : _T("No"));

    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
	IISDebugOutput(_T("DllGetClassObject\r\n"));
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HRESULT hRes = E_FAIL;

#ifdef _MERGE_PROXYSTUB
    hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    if (RunningAsAdministrator())
    {
        // Add the event log entry
        EventlogRegistryInstall();

        // registers object, typelib and all interfaces in typelib
        hRes = _Module.RegisterServer(TRUE);
        if (SUCCEEDED(hRes))
        {
            if (ERROR_SUCCESS != ChangeAppIDLaunchACL(TEXT("{62B8CCBE-5A45-4372-8C4A-6A87DD3EDD60}"),TEXT("Administrators"),TRUE,TRUE))
            {
                _Module.UnregisterServer(TRUE);
                hRes = E_FAIL;
            }
            else
            {
                if (ERROR_SUCCESS != ChangeAppIDAccessACL(TEXT("{62B8CCBE-5A45-4372-8C4A-6A87DD3EDD60}"),TEXT("Administrators"),TRUE,TRUE))
                {
                    _Module.UnregisterServer(TRUE);
                    hRes = E_FAIL;
                }
                else
                {
                    // make sure only the highest level of authentication is accepted.
                    if (ERROR_SUCCESS != ChangeAppIDAuthenticationLevel(TEXT("{62B8CCBE-5A45-4372-8C4A-6A87DD3EDD60}"),RPC_C_AUTHN_LEVEL_PKT_PRIVACY))
                    {
                        _Module.UnregisterServer(TRUE);
                        hRes = E_FAIL;
                    }
                    else
                    {
                        hRes = S_OK;
                    }
                }
            }

#ifdef USE_CERT_REQUEST_OBJECT
            if (ERROR_SUCCESS != ChangeAppIDLaunchACL(TEXT("{2B024027-594E-4D11-88EE-15F5AE28AC61}"),TEXT("Administrators"),TRUE,TRUE))
            {
                _Module.UnregisterServer(TRUE);
                hRes = E_FAIL;
            }
            else
            {
                if (ERROR_SUCCESS != ChangeAppIDAccessACL(TEXT("{2B024027-594E-4D11-88EE-15F5AE28AC61}"),TEXT("Administrators"),TRUE,TRUE))
                {
                    _Module.UnregisterServer(TRUE);
                    hRes = E_FAIL;
                }
                else
                {
                    hRes = S_OK;
                }
            }
#endif

        }
    }
    else
    {
        hRes = E_FAIL;
    }
   
    return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    HRESULT hRes = E_FAIL;

#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    if (RunningAsAdministrator())
    {
        EventlogRegistryUnInstall();
        ChangeAppIDLaunchACL(TEXT("{62B8CCBE-5A45-4372-8C4A-6A87DD3EDD60}"),TEXT("Administrators"),FALSE,FALSE);
        ChangeAppIDLaunchACL(TEXT("{62B8CCBE-5A45-4372-8C4A-6A87DD3EDD60}"),TEXT("everyone"),FALSE,FALSE);
        ChangeAppIDAccessACL(TEXT("{62B8CCBE-5A45-4372-8C4A-6A87DD3EDD60}"),TEXT("Administrators"),FALSE,FALSE);
        ChangeAppIDAccessACL(TEXT("{62B8CCBE-5A45-4372-8C4A-6A87DD3EDD60}"),TEXT("everyone"),FALSE,FALSE);
#ifdef USE_CERT_REQUEST_OBJECT
        ChangeAppIDLaunchACL(TEXT("{2B024027-594E-4D11-88EE-15F5AE28AC61}"),TEXT("Administrators"),FALSE,FALSE);
        ChangeAppIDLaunchACL(TEXT("{2B024027-594E-4D11-88EE-15F5AE28AC61}"),TEXT("everyone"),FALSE,FALSE);
        ChangeAppIDAccessACL(TEXT("{2B024027-594E-4D11-88EE-15F5AE28AC61}"),TEXT("Administrators"),FALSE,FALSE);
        ChangeAppIDAccessACL(TEXT("{2B024027-594E-4D11-88EE-15F5AE28AC61}"),TEXT("everyone"),FALSE,FALSE);
#endif
        hRes = _Module.UnregisterServer(TRUE);
    }
    else
    {
        hRes = E_FAIL;
    }
    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certobj\dcomperm.h ===
#include "stdafx.h"

BOOL RunningAsAdministrator(void);
DWORD ChangeAppIDLaunchACL (LPTSTR AppID,LPTSTR Principal,BOOL SetPrincipal,BOOL Permit);
DWORD ChangeAppIDAccessACL (LPTSTR AppID,LPTSTR Principal,BOOL SetPrincipal,BOOL Permit);
DWORD ChangeAppIDAuthenticationLevel(LPTSTR AppID,DWORD dwAuthenticationLevel);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certobj\dcomperm.cpp ===
#include "stdafx.h"
#include "dcomperm.h"
#include <strsafe.h>


//
// Check whether we are running as administrator on the machine
// or not
//
BOOL RunningAsAdministrator(void)
{
    BOOL   fReturn = FALSE;
    PSID   psidAdmin;
    DWORD  err;
    
    SID_IDENTIFIER_AUTHORITY SystemSidAuthority= SECURITY_NT_AUTHORITY;
    
    if ( AllocateAndInitializeSid ( &SystemSidAuthority, 2, 
            SECURITY_BUILTIN_DOMAIN_RID, 
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0, &psidAdmin) )
    {
        if (!CheckTokenMembership( NULL, psidAdmin, &fReturn )) 
        {
            err = GetLastError();
        }

        FreeSid ( psidAdmin);
    }
   
    return ( fReturn );
}

DWORD
CopyACL (
    PACL OldACL,
    PACL NewACL
    )
{
    ACL_SIZE_INFORMATION  aclSizeInfo;
    LPVOID                ace;
    ACE_HEADER            *aceHeader;
    ULONG                 i;
    DWORD                 returnValue = ERROR_SUCCESS;

    if (0 == IsValidAcl(OldACL))
    {
        returnValue = ERROR_INVALID_ACL;
        return returnValue;
    }

    if (0 == GetAclInformation (OldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof (aclSizeInfo), AclSizeInformation))
    {
        returnValue = GetLastError();
        return returnValue;
    }

    //
    // Copy all of the ACEs to the new ACL
    //

    for (i = 0; i < aclSizeInfo.AceCount; i++)
    {
        //
        // Get the ACE and header info
        //

        if (!GetAce (OldACL, i, &ace))
        {
            returnValue = GetLastError();
            return returnValue;
        }

        aceHeader = (ACE_HEADER *) ace;

        //
        // Add the ACE to the new list
        //

        if (!AddAce (NewACL, ACL_REVISION, 0xffffffff, ace, aceHeader->AceSize))
        {
            returnValue = GetLastError();
            return returnValue;
        }
    }

    return returnValue;
}


DWORD
GetPrincipalSID (
    LPCTSTR Principal,
    PSID *Sid,
    BOOL *pbWellKnownSID
    )
{

    DWORD returnValue=ERROR_SUCCESS;
    SID_IDENTIFIER_AUTHORITY SidIdentifierNTAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY SidIdentifierWORLDAuthority = SECURITY_WORLD_SID_AUTHORITY;
    PSID_IDENTIFIER_AUTHORITY pSidIdentifierAuthority;
    BYTE Count;
    DWORD dwRID[8];
    TCHAR pszPrincipal[MAX_PATH];

    *pbWellKnownSID = TRUE;
    memset(&(dwRID[0]), 0, 8 * sizeof(DWORD));

	StringCbCopy(pszPrincipal,sizeof(pszPrincipal),Principal);
    _wcslwr(pszPrincipal);
    if ( wcsstr(pszPrincipal, TEXT("administrators")) != NULL ) {
        // Administrators group
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 2;
        dwRID[0] = SECURITY_BUILTIN_DOMAIN_RID;
        dwRID[1] = DOMAIN_ALIAS_RID_ADMINS;
    } else if ( wcsstr(pszPrincipal, TEXT("system")) != NULL) {
        // SYSTEM
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 1;
        dwRID[0] = SECURITY_LOCAL_SYSTEM_RID;
    } else if ( wcsstr(pszPrincipal, TEXT("interactive")) != NULL) {
        // INTERACTIVE
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 1;
        dwRID[0] = SECURITY_INTERACTIVE_RID;
    } else if ( wcsstr(pszPrincipal, TEXT("everyone")) != NULL) {
        // Everyone
        pSidIdentifierAuthority = &SidIdentifierWORLDAuthority;
        Count = 1;
        dwRID[0] = SECURITY_WORLD_RID;
    } else {
        *pbWellKnownSID = FALSE;
    }

    if (*pbWellKnownSID) {
        if ( !AllocateAndInitializeSid(pSidIdentifierAuthority,
                                    (BYTE)Count,
                                            dwRID[0],
                                            dwRID[1],
                                            dwRID[2],
                                            dwRID[3],
                                            dwRID[4],
                                            dwRID[5],
                                            dwRID[6],
                                            dwRID[7],
                                    Sid) ) {
            returnValue = GetLastError();
        }
    } else {
        // get regular account sid
        DWORD        sidSize;
        TCHAR        refDomain [256];
        DWORD        refDomainSize;
        SID_NAME_USE snu;

        sidSize = 0;
        refDomainSize = 255;

        LookupAccountName (NULL,
                           pszPrincipal,
                           *Sid,
                           &sidSize,
                           refDomain,
                           &refDomainSize,
                           &snu);

        returnValue = GetLastError();

        if (returnValue == ERROR_INSUFFICIENT_BUFFER) {
            *Sid = (PSID) malloc (sidSize);
            if (!*Sid)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return GetLastError();
            }
            refDomainSize = 255;

            if (!LookupAccountName (NULL,
                                    pszPrincipal,
                                    *Sid,
                                    &sidSize,
                                    refDomain,
                                    &refDomainSize,
                                    &snu))
            {
                returnValue = GetLastError();
            } else {
                returnValue = ERROR_SUCCESS;
            }
        }
    }

    return returnValue;
}


DWORD
AddAccessDeniedACEToACL (
    PACL *Acl,
    DWORD PermissionMask,
    LPTSTR Principal
    )
{
    ACL_SIZE_INFORMATION  aclSizeInfo;
    int                   aclSize;
    DWORD                 returnValue = ERROR_SUCCESS;
    PSID                  principalSID = NULL;
    PACL                  oldACL, newACL;
    BOOL                  bWellKnownSID = FALSE;
    oldACL = *Acl;

    returnValue = GetPrincipalSID (Principal, &principalSID, &bWellKnownSID);
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    GetAclInformation (oldACL,
                       (LPVOID) &aclSizeInfo,
                       (DWORD) sizeof (ACL_SIZE_INFORMATION),
                       AclSizeInformation);

    aclSize = aclSizeInfo.AclBytesInUse +
              sizeof (ACL) + sizeof (ACCESS_DENIED_ACE) +
              GetLengthSid (principalSID) - sizeof (DWORD);

    newACL = (PACL) new BYTE [aclSize];

    if (!InitializeAcl (newACL, aclSize, ACL_REVISION))
    {
        returnValue = GetLastError();
        goto cleanup;
    }

    if (!AddAccessDeniedAce (newACL, ACL_REVISION2, PermissionMask, principalSID))
    {
        returnValue = GetLastError();
        goto cleanup;
    }

    returnValue = CopyACL (oldACL, newACL);
    if (returnValue != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    *Acl = newACL;
	newACL = NULL;

cleanup:

	// BugFix: 57654 Whistler
	//         Prefix bug leaking memory in error condition.
	//         By setting the newACL to NULL above if we have
	//         relinquished the memory to *Acl, we avoid releasing
	//         memory we have passed back to the caller.
	//         EBK 5/5/2000		
	if (newACL)
	{
		delete[] newACL;
		newACL = NULL;
	}

    if (principalSID) {
        if (bWellKnownSID)
            FreeSid (principalSID);
        else
            free (principalSID);
    }

    return returnValue;
}



DWORD
AddAccessAllowedACEToACL (
    PACL *Acl,
    DWORD PermissionMask,
    LPTSTR Principal
    )
{
    ACL_SIZE_INFORMATION  aclSizeInfo;
    int                   aclSize;
    DWORD                 returnValue = ERROR_SUCCESS;
    PSID                  principalSID = NULL;
    PACL                  oldACL = NULL;
    PACL                  newACL = NULL;
    BOOL                  bWellKnownSID = FALSE;

    oldACL = *Acl;

    // check if the acl we got passed in is valid!
    if (0 == IsValidAcl(oldACL))
    {
        returnValue = ERROR_INVALID_ACL;
        goto cleanup;
    }

    returnValue = GetPrincipalSID (Principal, &principalSID, &bWellKnownSID);
    if (returnValue != ERROR_SUCCESS)
    {
        return returnValue;
    }

    if (0 == GetAclInformation (oldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof (ACL_SIZE_INFORMATION), AclSizeInformation))
    {
        returnValue = GetLastError();
        goto cleanup;
    }

    aclSize = aclSizeInfo.AclBytesInUse +
              sizeof (ACL) + sizeof (ACCESS_ALLOWED_ACE) +
              GetLengthSid (principalSID) - sizeof (DWORD);

    newACL = (PACL) new BYTE [aclSize];

    if (!InitializeAcl (newACL, aclSize, ACL_REVISION))
    {
        returnValue = GetLastError();
        goto cleanup;
    }

    returnValue = CopyACL (oldACL, newACL);
    if (returnValue != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    //if (!AddAccessAllowedAce (newACL, ACL_REVISION2, PermissionMask, principalSID))
    if (!AddAccessAllowedAce (newACL, ACL_REVISION, PermissionMask, principalSID))
    {
        returnValue = GetLastError();
        goto cleanup;
    }

    // check if the acl is valid!
    /*
    if (0 == IsValidAcl(newACL))
    {
        returnValue = ERROR_INVALID_ACL;
        goto cleanup;
    }
    */

    // cleanup old memory whose pointer we're replacing
    // okay to leak in setup... (need to comment out or else av's)
    //if (*Acl) {delete(*Acl);}
    *Acl = newACL;
    newACL = NULL;

cleanup:
    if (principalSID) {
        if (bWellKnownSID)
            FreeSid (principalSID);
        else
            free (principalSID);
    }
    if (newACL)
    {
		delete [] newACL;
		newACL = NULL;
    }

    return returnValue;
}

DWORD
RemovePrincipalFromACL (
    PACL Acl,
    LPTSTR Principal
    )
{
    ACL_SIZE_INFORMATION    aclSizeInfo;
    ULONG                   i;
    LPVOID                  ace;
    ACCESS_ALLOWED_ACE      *accessAllowedAce;
    ACCESS_DENIED_ACE       *accessDeniedAce;
    SYSTEM_AUDIT_ACE        *systemAuditAce;
    PSID                    principalSID = NULL;
    DWORD                   returnValue = ERROR_SUCCESS;
    ACE_HEADER              *aceHeader;
    BOOL                    bWellKnownSID = FALSE;

    returnValue = GetPrincipalSID (Principal, &principalSID, &bWellKnownSID);
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    GetAclInformation (Acl,
                       (LPVOID) &aclSizeInfo,
                       (DWORD) sizeof (ACL_SIZE_INFORMATION),
                       AclSizeInformation);

    for (i = 0; i < aclSizeInfo.AceCount; i++)
    {
        if (!GetAce (Acl, i, &ace))
        {
            returnValue = GetLastError();
            break;
        }

        aceHeader = (ACE_HEADER *) ace;

        if (aceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
        {
            accessAllowedAce = (ACCESS_ALLOWED_ACE *) ace;

            if (EqualSid (principalSID, (PSID) &accessAllowedAce->SidStart))
            {
                DeleteAce (Acl, i);
                break;
            }
        } else

        if (aceHeader->AceType == ACCESS_DENIED_ACE_TYPE)
        {
            accessDeniedAce = (ACCESS_DENIED_ACE *) ace;

            if (EqualSid (principalSID, (PSID) &accessDeniedAce->SidStart))
            {
                DeleteAce (Acl, i);
                break;
            }
        } else

        if (aceHeader->AceType == SYSTEM_AUDIT_ACE_TYPE)
        {
            systemAuditAce = (SYSTEM_AUDIT_ACE *) ace;

            if (EqualSid (principalSID, (PSID) &systemAuditAce->SidStart))
            {
                DeleteAce (Acl, i);
                break;
            }
        }
    }

    if (principalSID) {
        if (bWellKnownSID)
            FreeSid (principalSID);
        else
            free (principalSID);
    }

    return returnValue;
}

DWORD
GetCurrentUserSID (
    PSID *Sid
    )
{
    DWORD dwReturn = ERROR_SUCCESS;
    TOKEN_USER  *tokenUser = NULL;
    HANDLE      tokenHandle = NULL;
    DWORD       tokenSize;
    DWORD       sidLength;

    if (OpenProcessToken (GetCurrentProcess(), TOKEN_QUERY, &tokenHandle))
    {
        GetTokenInformation (tokenHandle, TokenUser, tokenUser, 0, &tokenSize);

        tokenUser = (TOKEN_USER *) malloc (tokenSize);
        if (!tokenUser)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return GetLastError();
        }

        if (GetTokenInformation (tokenHandle, TokenUser, tokenUser, tokenSize, &tokenSize))
        {
            sidLength = GetLengthSid (tokenUser->User.Sid);
            *Sid = (PSID) malloc (sidLength);
            if (*Sid)
            {
                memcpy (*Sid, tokenUser->User.Sid, sidLength);
            }
            CloseHandle (tokenHandle);
        } else
            dwReturn = GetLastError();

        if (tokenUser)
            free(tokenUser);

    } else
        dwReturn = GetLastError();

    return dwReturn;
}

DWORD
CreateNewSD (
    SECURITY_DESCRIPTOR **SD
    )
{
    PACL    dacl = NULL;
    DWORD   sidLength;
    PSID    sid = NULL;
    PSID    groupSID = NULL;
    PSID    ownerSID = NULL;
    DWORD   returnValue = 0;

    *SD = NULL;

    returnValue = GetCurrentUserSID (&sid);
    if (returnValue != ERROR_SUCCESS) {
        if (sid)
            free(sid);

        return returnValue;
    }

    if (!sid)
    {
        return E_FAIL;
    }

    sidLength = GetLengthSid (sid);

    *SD = (SECURITY_DESCRIPTOR *) malloc (
        (sizeof (ACL)+sizeof (ACCESS_ALLOWED_ACE)+sidLength) +
        (2 * sidLength) +
        sizeof (SECURITY_DESCRIPTOR));

    if (!*SD)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        returnValue = GetLastError();
        return returnValue;
    }

    groupSID = (SID *) (*SD + 1);
    ownerSID = (SID *) (((BYTE *) groupSID) + sidLength);
    dacl = (ACL *) (((BYTE *) ownerSID) + sidLength);

    if (!InitializeSecurityDescriptor (*SD, SECURITY_DESCRIPTOR_REVISION))
    {
        free (*SD);
        free (sid);
        returnValue = GetLastError();
        return returnValue;
    }

    if (!InitializeAcl (dacl,
                        sizeof (ACL)+sizeof (ACCESS_ALLOWED_ACE)+sidLength,
                        ACL_REVISION2))
    {
        free (*SD);
        free (sid);
        returnValue = GetLastError();
        return returnValue;
    }

    if (!AddAccessAllowedAce (dacl,
                              ACL_REVISION2,
                              COM_RIGHTS_EXECUTE,
                              sid))
    {
        free (*SD);
        free (sid);
        returnValue = GetLastError();
        return returnValue;
    }

    if (!SetSecurityDescriptorDacl (*SD, TRUE, dacl, FALSE))
    {
        free (*SD);
        free (sid);
        returnValue = GetLastError();
        return returnValue;
    }

    memcpy (groupSID, sid, sidLength);
    if (!SetSecurityDescriptorGroup (*SD, groupSID, FALSE))
    {
        free (*SD);
        free (sid);
        returnValue = GetLastError();
        return returnValue;
    }

    memcpy (ownerSID, sid, sidLength);
    if (!SetSecurityDescriptorOwner (*SD, ownerSID, FALSE))
    {
        free (*SD);
        free (sid);
        returnValue = GetLastError();
        return returnValue;
    }

    // check if everything went ok 
    if (!IsValidSecurityDescriptor(*SD)) 
    {
        free (*SD);
        free (sid);
        returnValue = ERROR_INVALID_SECURITY_DESCR;
        return returnValue;
    }
    
    
    if (sid)
        free(sid);
    return ERROR_SUCCESS;
}


DWORD
MakeSDAbsolute (
    PSECURITY_DESCRIPTOR OldSD,
    PSECURITY_DESCRIPTOR *NewSD
    )
{
    PSECURITY_DESCRIPTOR  sd = NULL;
    DWORD                 descriptorSize;
    DWORD                 daclSize;
    DWORD                 saclSize;
    DWORD                 ownerSIDSize;
    DWORD                 groupSIDSize;
    PACL                  dacl = NULL;
    PACL                  sacl = NULL;
    PSID                  ownerSID = NULL;
    PSID                  groupSID = NULL;
    BOOL                  present;
    BOOL                  systemDefault;

    //
    // Get SACL
    //

    if (!GetSecurityDescriptorSacl (OldSD, &present, &sacl, &systemDefault))
        return GetLastError();

    if (sacl && present)
    {
        saclSize = sacl->AclSize;
    } else saclSize = 0;

    //
    // Get DACL
    //

    if (!GetSecurityDescriptorDacl (OldSD, &present, &dacl, &systemDefault))
        return GetLastError();


    if (dacl && present)
    {
        daclSize = dacl->AclSize;
    } else daclSize = 0;

    //
    // Get Owner
    //

    if (!GetSecurityDescriptorOwner (OldSD, &ownerSID, &systemDefault))
        return GetLastError();

    ownerSIDSize = GetLengthSid (ownerSID);

    //
    // Get Group
    //

    if (!GetSecurityDescriptorGroup (OldSD, &groupSID, &systemDefault))
        return GetLastError();

    groupSIDSize = GetLengthSid (groupSID);

    //
    // Do the conversion
    //

    descriptorSize = 0;

    MakeAbsoluteSD (OldSD, sd, &descriptorSize, dacl, &daclSize, sacl,
                    &saclSize, ownerSID, &ownerSIDSize, groupSID,
                    &groupSIDSize);

    sd = (PSECURITY_DESCRIPTOR) new BYTE [SECURITY_DESCRIPTOR_MIN_LENGTH];
    if (!sd)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return GetLastError();
    }
    if (!InitializeSecurityDescriptor (sd, SECURITY_DESCRIPTOR_REVISION))
        return GetLastError();

    if (!MakeAbsoluteSD (OldSD, sd, &descriptorSize, dacl, &daclSize, sacl,
                         &saclSize, ownerSID, &ownerSIDSize, groupSID,
                         &groupSIDSize))
        return GetLastError();

    *NewSD = sd;
    return ERROR_SUCCESS;
}

DWORD
SetNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    SECURITY_DESCRIPTOR *SD
    )
{
    DWORD   returnValue;
    DWORD   disposition;
    HKEY    registryKey;

    //
    // Create new key or open existing key
    //

    returnValue = RegCreateKeyEx (RootKey, KeyName, 0, _T(""), 0, KEY_ALL_ACCESS, NULL, &registryKey, &disposition);
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    //
    // Write the security descriptor
    //

    returnValue = RegSetValueEx (registryKey, ValueName, 0, REG_BINARY, (LPBYTE) SD, GetSecurityDescriptorLength (SD));
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    RegCloseKey (registryKey);

    return ERROR_SUCCESS;
}

DWORD
GetNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    SECURITY_DESCRIPTOR **SD,
    BOOL *NewSD
    )
{
    DWORD               returnValue;
    HKEY                registryKey;
    DWORD               valueType;
    DWORD               valueSize = 0;

    *NewSD = FALSE;

    //
    // Get the security descriptor from the named value. If it doesn't
    // exist, create a fresh one.
    //

    returnValue = RegOpenKeyEx (RootKey, KeyName, 0, KEY_ALL_ACCESS, &registryKey);

    if (returnValue != ERROR_SUCCESS)
    {
        if (returnValue == ERROR_FILE_NOT_FOUND)
        {
            *SD = NULL;
            returnValue = CreateNewSD (SD);
            if (returnValue != ERROR_SUCCESS) {
                if (*SD)
                    free(*SD);
                return returnValue;
            }

            *NewSD = TRUE;
            return ERROR_SUCCESS;
        } else
            return returnValue;
    }

    returnValue = RegQueryValueEx (registryKey, ValueName, NULL, &valueType, NULL, &valueSize);

    if (returnValue && returnValue != ERROR_INSUFFICIENT_BUFFER)
    {
        *SD = NULL;
        returnValue = CreateNewSD (SD);
        if (returnValue != ERROR_SUCCESS) {
            if (*SD)
                free(*SD);
            return returnValue;
        }

        *NewSD = TRUE;
    } else
    {
        *SD = (SECURITY_DESCRIPTOR *) malloc (valueSize);
        if (!*SD)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return GetLastError();
        }

        returnValue = RegQueryValueEx (registryKey,
                                       ValueName,
                                       NULL,
                                       &valueType,
                                       (LPBYTE) *SD,
                                       &valueSize);
        if (returnValue)
        {
            if (*SD)
                free (*SD);

            *SD = NULL;
            returnValue = CreateNewSD (SD);
            if (returnValue != ERROR_SUCCESS) {
                if (*SD){
					free(*SD);
				}
				if( NULL != registryKey ) {
					RegCloseKey(registryKey);
				}
                return returnValue;
            }

            *NewSD = TRUE;
        }
    }

	if( NULL != registryKey ) {
		RegCloseKey(registryKey);
	}
    return ERROR_SUCCESS;
}

DWORD
AddPrincipalToNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    LPTSTR Principal,
    BOOL Permit
    )
{
    DWORD               returnValue = ERROR_SUCCESS;
    SECURITY_DESCRIPTOR *sd = NULL;
    SECURITY_DESCRIPTOR *sdSelfRelative = NULL;
    SECURITY_DESCRIPTOR *sdAbsolute = NULL;
    DWORD               secDescSize;
    BOOL                present;
    BOOL                defaultDACL;
    PACL                dacl;
    BOOL                newSD = FALSE;
    BOOL                fFreeAbsolute = TRUE;


    returnValue = GetNamedValueSD (RootKey, KeyName, ValueName, &sd, &newSD);

    //
    // Get security descriptor from registry or create a new one
    //

    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    if (!GetSecurityDescriptorDacl (sd, &present, &dacl, &defaultDACL)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    if (newSD)
    {
        AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, TEXT("SYSTEM"));
        AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, TEXT("INTERACTIVE"));
    }

    //
    // Add the Principal that the caller wants added
    //

    if (Permit)
        returnValue = AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, Principal);
    else
        returnValue = AddAccessDeniedACEToACL (&dacl, GENERIC_ALL, Principal);

    if (returnValue != ERROR_SUCCESS)
        goto Cleanup;

    //
    // Make the security descriptor absolute if it isn't new
    //

    if (!newSD) {
        MakeSDAbsolute ((PSECURITY_DESCRIPTOR) sd, (PSECURITY_DESCRIPTOR *) &sdAbsolute);
        fFreeAbsolute = TRUE;
    } else {
        sdAbsolute = sd;
        fFreeAbsolute = FALSE;
    }

    //
    // Set the discretionary ACL on the security descriptor
    //

    if (!SetSecurityDescriptorDacl (sdAbsolute, TRUE, dacl, FALSE)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // Make the security descriptor self-relative so that we can
    // store it in the registry
    //

    secDescSize = 0;
    MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize);
    sdSelfRelative = (SECURITY_DESCRIPTOR *) malloc (secDescSize);
    if (!sdSelfRelative)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        returnValue = GetLastError();
        goto Cleanup;
    }


    if (!MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // Store the security descriptor in the registry
    //

    SetNamedValueSD (RootKey, KeyName, ValueName, sdSelfRelative);

Cleanup:
    if (sd)
        free (sd);
    if (sdSelfRelative)
        free (sdSelfRelative);
    if (fFreeAbsolute && sdAbsolute)
        free (sdAbsolute);

    return returnValue;
}

DWORD
RemovePrincipalFromNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    LPTSTR Principal
    )
{
    DWORD               returnValue = ERROR_SUCCESS;
    SECURITY_DESCRIPTOR *sd = NULL;
    SECURITY_DESCRIPTOR *sdSelfRelative = NULL;
    SECURITY_DESCRIPTOR *sdAbsolute = NULL;
    DWORD               secDescSize;
    BOOL                present;
    BOOL                defaultDACL;
    PACL                dacl = NULL;
    BOOL                newSD = FALSE;
    BOOL                fFreeAbsolute = TRUE;

    returnValue = GetNamedValueSD (RootKey, KeyName, ValueName, &sd, &newSD);

    //
    // Get security descriptor from registry or create a new one
    //

    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    if (!GetSecurityDescriptorDacl (sd, &present, &dacl, &defaultDACL)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // If the security descriptor is new, add the required Principals to it
    //

    if (newSD)
    {
        AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, TEXT("SYSTEM"));
        AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, TEXT("INTERACTIVE"));
    }

    //
    // Remove the Principal that the caller wants removed
    //

    returnValue = RemovePrincipalFromACL (dacl, Principal);
    if (returnValue != ERROR_SUCCESS)
        goto Cleanup;

    //
    // Make the security descriptor absolute if it isn't new
    //

    if (!newSD) {
        MakeSDAbsolute ((PSECURITY_DESCRIPTOR) sd, (PSECURITY_DESCRIPTOR *) &sdAbsolute);
        fFreeAbsolute = TRUE;
    } else {
        sdAbsolute = sd;
        fFreeAbsolute = FALSE;
    }

    //
    // Set the discretionary ACL on the security descriptor
    //

    if (!SetSecurityDescriptorDacl (sdAbsolute, TRUE, dacl, FALSE)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // Make the security descriptor self-relative so that we can
    // store it in the registry
    //

    secDescSize = 0;
    MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize);
    sdSelfRelative = (SECURITY_DESCRIPTOR *) malloc (secDescSize);
    if (!sdSelfRelative)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        returnValue = GetLastError();
        goto Cleanup;
    }

    if (!MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // Store the security descriptor in the registry
    //

    SetNamedValueSD (RootKey, KeyName, ValueName, sdSelfRelative);

Cleanup:
    if (sd)
        free (sd);
    if (sdSelfRelative)
        free (sdSelfRelative);
    if (fFreeAbsolute && sdAbsolute)
        free (sdAbsolute);

    return returnValue;
}

DWORD
ChangeAppIDAccessACL (
    LPTSTR AppID,
    LPTSTR Principal,
    BOOL SetPrincipal,
    BOOL Permit
    )
{
    TCHAR   keyName [256];
    DWORD   err;

	StringCbCopy(keyName,sizeof(keyName),TEXT("APPID\\"));
	StringCbCat(keyName,sizeof(keyName),AppID);

    if (SetPrincipal)
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT,
                                               keyName,
                                               TEXT("AccessPermission"),
                                               Principal);
        err = AddPrincipalToNamedValueSD (HKEY_CLASSES_ROOT,
                                          keyName,
                                          TEXT("AccessPermission"),
                                          Principal,
                                          Permit);
    }
    else
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT,
                                               keyName,
                                               TEXT("AccessPermission"),
                                               Principal);
    }

    return err;
}

DWORD
ChangeAppIDLaunchACL (
    LPTSTR AppID,
    LPTSTR Principal,
    BOOL SetPrincipal,
    BOOL Permit
    )
{

    TCHAR   keyName [256];
    DWORD   err;

	StringCbCopy(keyName,sizeof(keyName),TEXT("APPID\\"));
	StringCbCat(keyName,sizeof(keyName),AppID);

    if (SetPrincipal)
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT,
                                               keyName,
                                               TEXT("LaunchPermission"),
                                               Principal);
        err = AddPrincipalToNamedValueSD (HKEY_CLASSES_ROOT,
                                          keyName,
                                          TEXT("LaunchPermission"),
                                          Principal,
                                          Permit);
    }
    else
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT,
                                               keyName,
                                               TEXT("LaunchPermission"),
                                               Principal);
    }

    return err;
}

DWORD
ChangeAppIDAuthenticationLevel(
    LPTSTR AppID,
    DWORD dwAuthenticationLevel
    )
{
    // Simply set the registry setting for Authentication Level
    DWORD dwRetVal = ERROR_SUCCESS;
    TCHAR keyName[256];

    if( NULL == AppID )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    if( AppID[0] == '{' )
    {
        StringCbPrintf(keyName,sizeof(keyName),_T("APPID\\%s"),AppID); 
    }
    else
    {
        StringCbPrintf(keyName,sizeof(keyName),_T("APPID\\(%s)"),AppID); 
    }

    // Now set the registry
    HKEY hKey = NULL;

    dwRetVal = RegOpenKeyEx( HKEY_CLASSES_ROOT, keyName, 0, KEY_WRITE, &hKey );
    if( ERROR_SUCCESS == dwRetVal )
    {
        dwRetVal = RegSetValueEx( hKey, _T("AuthenticationLevel"), 0, REG_DWORD, (BYTE *) &dwAuthenticationLevel, sizeof( DWORD ) );
    }

    if( NULL != hKey )
    {
        RegCloseKey( hKey );
        hKey = NULL;
    }

    return( dwRetVal );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certobj\certutil.cpp ===
#include "stdafx.h"
#include "CertObj.h"
#include "common.h"
#include "certutil.h"
#include "base64.h"
#include <strsafe.h>

//////////////////////////////////////////////////////////////////

CString ReturnGoodMetabasePath(CString csInstanceName)
{
    CString key_path_lm = _T("");
    CString key_path = _T("");
    // csInstanceName will come in looking like
    // w3svc/1
    // or /lm/w3svc/1
    //
    // we want to it to go out as /lm/w3svc/1
    key_path_lm = SZ_MBN_SEP_STR SZ_MBN_MACHINE SZ_MBN_SEP_STR;// SZ_MBN_WEB SZ_MBN_SEP_STR;

    if (csInstanceName.GetLength() >= 4)
    {
        if (csInstanceName.Left(4) == key_path_lm)
        {
            key_path = csInstanceName;
        }
        else
        {
            key_path_lm = SZ_MBN_MACHINE SZ_MBN_SEP_STR;
            if (csInstanceName.Left(3) == key_path_lm)
            {
                key_path = csInstanceName;
            }
            else
            {
                key_path = key_path_lm;
                key_path += csInstanceName;
            }
        }
    }
    else
    {
        key_path = key_path_lm;
        key_path += csInstanceName;
    }

    return key_path;
}

//
// will come in as /W3SVC/1
//
// need to make sure to remove from these nodes
//[/W3SVC/1/ROOT]
//[/W3SVC/1/ROOT/Printers]
//
HRESULT ShutdownSSL(CString& server_name)
{
    CComAuthInfo auth;
    CString str = ReturnGoodMetabasePath(server_name);
    str += _T("/root");
    CMetaKey key(&auth, str, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);
    DWORD dwSslAccess;

    if (!key.Succeeded())
    {
        return key.QueryResult();
    }

    if (SUCCEEDED(key.QueryValue(MD_SSL_ACCESS_PERM, dwSslAccess)) && dwSslAccess > 0)
    {
        key.SetValue(MD_SSL_ACCESS_PERM, 0);
    }

    // Now we need to remove SSL setting from any virtual directory below
    CError err;
    CStringListEx data_paths;
    DWORD dwMDIdentifier, dwMDAttributes, dwMDUserType,dwMDDataType;

    VERIFY(CMetaKey::GetMDFieldDef(MD_SSL_ACCESS_PERM, dwMDIdentifier, dwMDAttributes, dwMDUserType,dwMDDataType));

    err = key.GetDataPaths( data_paths,dwMDIdentifier,dwMDDataType);
    if (err.Succeeded() && !data_paths.empty())
    {
        CStringListEx::iterator it = data_paths.begin();
        while (it != data_paths.end())
        {
            CString& str2 = (*it++);
            if (SUCCEEDED(key.QueryValue(MD_SSL_ACCESS_PERM, dwSslAccess, NULL, str2)) && dwSslAccess > 0)
            {
                key.SetValue(MD_SSL_ACCESS_PERM, 0, NULL, str2);
            }
        }
    }
    return key.QueryResult();
}

BOOL
GetKeyUsageProperty(PCCERT_CONTEXT pCertContext, 
						  CERT_ENHKEY_USAGE ** pKeyUsage, 
						  BOOL fPropertiesOnly, 
						  HRESULT * phRes)
{
	DWORD cb = 0;
	BOOL bRes = FALSE;
   if (!CertGetEnhancedKeyUsage(pCertContext,
                                fPropertiesOnly ? CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG : 0,
                                NULL,
                                &cb))
   {
		*phRes = HRESULT_FROM_WIN32(GetLastError());
		goto ErrExit;
   }
   if (NULL == (*pKeyUsage = (CERT_ENHKEY_USAGE *)malloc(cb)))
   {
		*phRes = E_OUTOFMEMORY;
		goto ErrExit;
   }
   if (!CertGetEnhancedKeyUsage (pCertContext,
                                 fPropertiesOnly ? CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG : 0,
                                 *pKeyUsage,
                                 &cb))
   {
		free(*pKeyUsage);*pKeyUsage = NULL;
		*phRes = HRESULT_FROM_WIN32(GetLastError());
		goto ErrExit;
   }
	*phRes = S_OK;
	bRes = TRUE;
ErrExit:
	return bRes;
}

// Return:
// 0 = The CertContext does not have a EnhancedKeyUsage (EKU) field
// 1 = The CertContext has EnhancedKeyUsage (EKU) and contains the uses we want.
//     This is also returned when The UsageIdentifier that depics "all uses" is true
// 2 = The CertContext has EnhancedKeyUsage (EKU) but does NOT contain the uses we want.
//     This is also returned when The UsageIdentifier that depics "no uses" is true
INT ContainsKeyUsageProperty(PCCERT_CONTEXT pCertContext,LPCSTR rgbpszUsageArray[],DWORD dwUsageArrayCount,HRESULT * phRes)
{
    // Default it with "No EnhancedKeyUsage (EKU) Exist"
    INT iReturn = 0;
	CERT_ENHKEY_USAGE * pKeyUsage = NULL;
	if (	dwUsageArrayCount > 0
		&&	GetKeyUsageProperty(pCertContext, &pKeyUsage, FALSE, phRes)
		)
	{
		if (pKeyUsage->cUsageIdentifier == 0)
		{
            /*
            But in MSDN article about SR
            (see: ms-help://MS.MSDNQTR.2002APR.1033/security/security/certgetenhancedkeyusage.htm)

            In Windows Me and Windows 2000 and later, if the cUsageIdentifier member is zero (0), 
            the certificate might be valid for ALL uses or the certificate might have no valid uses. 
            The return from a call to GetLastError can be used to determine whether the certificate 
            is good for all uses or for none. If GetLastError returns CRYPT_E_NOT_FOUND, the certificate 
            is good for all uses. If it returns zero (0), the certificate has no valid uses.
            */

            // Default it with "has EnhancedKeyUsage (EKU), but doesn't have what we want"
            iReturn = 2;
            if (GetLastError() == CRYPT_E_NOT_FOUND)
            {
                // All uses!
                iReturn = 1;
            }
		}
		else
		{
            // Default it with "has EnhancedKeyUsage (EKU), but doesn't have what we want"
            iReturn = 2;

			for (DWORD i = 0; i < pKeyUsage->cUsageIdentifier; i++)
			{
				// Our friends from CAPI made this property ASCII even for 
				// UNICODE program
                for (DWORD j = 0; j < dwUsageArrayCount; j++)
                {
                    if (strstr(pKeyUsage->rgpszUsageIdentifier[i], rgbpszUsageArray[j]) != NULL)
                    {
                        iReturn = 1;
                        break;
                    }
                }
			}
		}
		free(pKeyUsage);
	}
	return iReturn;
}

BOOL CanIISUseThisCertForServerAuth(PCCERT_CONTEXT pCC)
{
	BOOL bReturn = FALSE;
	HRESULT hr = E_FAIL; 
	if (!pCC)
	{
		return FALSE;
	}

    LPCSTR rgbpszUsageArray[3];
    SecureZeroMemory( &rgbpszUsageArray, sizeof(rgbpszUsageArray) );
    rgbpszUsageArray[0] = szOID_PKIX_KP_SERVER_AUTH;
    rgbpszUsageArray[1] = szOID_SERVER_GATED_CRYPTO;
	rgbpszUsageArray[2] = szOID_SGC_NETSCAPE;

    DWORD dwCount=sizeof(rgbpszUsageArray)/sizeof(rgbpszUsageArray[0]);
	if (pCC)
	{
        INT iEnhancedKeyUsage = ContainsKeyUsageProperty(pCC,rgbpszUsageArray,dwCount,&hr);
        switch (iEnhancedKeyUsage)
        {
            case 0:
                // BUG:683489:remove check for basic constraint "subjecttype=ca"
                // Per bug 683489, accept it
                bReturn = TRUE;

                /*
                IISDebugOutput(_T("CanIISUseThisCertForServerAuth:Line=%d:No Server_Auth\r\n"),__LINE__);
                // check other stuff
                if (DID_NOT_FIND_CONSTRAINT == CheckCertConstraints(pCC) || FOUND_CONSTRAINT == CheckCertConstraints(pCC))
                {
                    // it's okay, add it to the list
				    // and can be used as server auth.
				    bReturn = TRUE;
                }
                else 
                {
				    IISDebugOutput(_T("CanIISUseThisCertForServerAuth:Line=%d:Contains Constraints\r\n"),__LINE__);
				    bReturn = FALSE;
                }
                */
                break;
            case 1:
                // yes!
                bReturn = TRUE;
                break;
            case 2:
                // no!
                bReturn = FALSE;
                break;
            default:
                break;
        }
	}

	return bReturn;
}

/*

  -----Original Message-----
From: 	Helle Vu (SPECTOR)  
Sent:	Friday, April 27, 2001 6:02 PM
To:	Aaron Lee; Trevor Freeman
Cc:	Sergei Antonov
Subject:	RE: bug 31010

Perfect timing, I was just about to send you an update on this:

I talked to Trevor about this, and he suggested the best thing to do for IIS would be the following (Trevor, please double-check I got this right):
If there is an EKU, and it has serverauth, display it in the list to pick web server certs from
If no EKU, look at basic constraints:
    * If we do not have basic constraints, do display it in the list to pick web server certs from
    * If we do have basic constraints with Subject Type =CA, don't display it in the list to pick web server certs from (this will filter out CA certs)
    * If we do have basic constraints with SubectType !=CA, do display it in the list to pick web server certs from 
*/

/*
===== Opened by kshenoy on 11/13/2000 02:26PM =====
Add Existing certificate option in "Web Server Certificate Request wizard"  should not list CA certificates in the filter
but only End entity certificates with "Server Authentication" EKU

Since CA certificates by default have all the EKUs the filter will list CA certificates apart from 
end entity certificates with "Server Auth" EKU.

In order to check if a given certificate is a CA or end entity you can look at the Basic Constraints 
extension of the certificate if present. This will be present in CA certificates and set to SubjectType=CA.
If present in end entity certificates it will be set to "ServerAuth"
*/

int CheckCertConstraints(PCCERT_CONTEXT pCC)
{
    PCERT_EXTENSION pCExt;
    LPCSTR pszObjId;
    DWORD i;
    CERT_BASIC_CONSTRAINTS_INFO *pConstraints=NULL;
    CERT_BASIC_CONSTRAINTS2_INFO *p2Constraints=NULL;
    DWORD ConstraintSize=0;
    int ReturnValue = FAILURE;
    BOOL Using2=FALSE;
    void* ConstraintBlob=NULL;

    pszObjId = szOID_BASIC_CONSTRAINTS;

    pCExt = CertFindExtension(pszObjId,pCC->pCertInfo->cExtension,pCC->pCertInfo->rgExtension);
    if (pCExt == NULL) 
    {
        pszObjId = szOID_BASIC_CONSTRAINTS2;
        pCExt = CertFindExtension(pszObjId,pCC->pCertInfo->cExtension,pCC->pCertInfo->rgExtension);
        Using2=TRUE;
    }
    
    if (pCExt == NULL) 
    {
		IISDebugOutput(_T("CheckCertConstraints:Line=%d:DID_NOT_FIND_CONSTRAINT\r\n"),__LINE__);
        ReturnValue = DID_NOT_FIND_CONSTRAINT;
        goto CheckCertConstraints_Exit;
    }

    // Decode extension
    if (!CryptDecodeObject(X509_ASN_ENCODING,pCExt->pszObjId,pCExt->Value.pbData,pCExt->Value.cbData,0,NULL,&ConstraintSize)) 
    {
		IISDebugOutput(_T("CheckCertConstraints:Line=%d:FAIL\r\n"),__LINE__);
        goto CheckCertConstraints_Exit;
    }

    ConstraintBlob = malloc(ConstraintSize);
    if (ConstraintBlob == NULL) 
    {
		IISDebugOutput(_T("CheckCertConstraints:Line=%d:FAIL\r\n"),__LINE__);
        goto CheckCertConstraints_Exit;
    }

    if (!CryptDecodeObject(X509_ASN_ENCODING,pCExt->pszObjId,pCExt->Value.pbData,pCExt->Value.cbData,0,(void*)ConstraintBlob,&ConstraintSize)) 
    {
		IISDebugOutput(_T("CheckCertConstraints:Line=%d:FAIL\r\n"),__LINE__);
		goto CheckCertConstraints_Exit;
	}

    if (Using2) 
    {
        p2Constraints=(CERT_BASIC_CONSTRAINTS2_INFO*)ConstraintBlob;
        if (!p2Constraints->fCA) 
        {
            // there is a constraint, and it's not a CA
            ReturnValue = FOUND_CONSTRAINT;
			IISDebugOutput(_T("CheckCertConstraints:Line=%d:FOUND_CONSTRAINT:there is a constraint, and it's not a CA\r\n"),__LINE__);
        }
        else
        {
            // This is a CA.  CA cannot be used as a 'server auth'
            ReturnValue = FOUND_CONSTRAINT_BUT_THIS_IS_A_CA_OR_ITS_NOT_AN_END_ENTITY;
			IISDebugOutput(_T("CheckCertConstraints:Line=%d:FOUND_CONSTRAINT:This is a CA.  CA cannot be used as a 'server auth'\r\n"),__LINE__);
        }
    }
    else 
    {
        pConstraints=(CERT_BASIC_CONSTRAINTS_INFO*)ConstraintBlob;
        if (((pConstraints->SubjectType.cbData * 8) - pConstraints->SubjectType.cUnusedBits) >= 2) 
        {
            if ((*pConstraints->SubjectType.pbData) & CERT_END_ENTITY_SUBJECT_FLAG) 
            {
                // there is a valid constraint
                ReturnValue = FOUND_CONSTRAINT;
				IISDebugOutput(_T("CheckCertConstraints:Line=%d:FOUND_CONSTRAINT:there is a valid constraint\r\n"),__LINE__);
            }
            else
            {
                // this is not an 'end entity' so hey -- we can't use it.
                ReturnValue = FOUND_CONSTRAINT_BUT_THIS_IS_A_CA_OR_ITS_NOT_AN_END_ENTITY;
				IISDebugOutput(_T("CheckCertConstraints:Line=%d:this is not an 'end entity' so hey -- we can't use it\r\n"),__LINE__);
            }
        }
    }
        
CheckCertConstraints_Exit:
    if (ConstraintBlob){free(ConstraintBlob);}
    return (ReturnValue);

}

BOOL AddChainToStore(HCERTSTORE hCertStore,PCCERT_CONTEXT pCertContext,DWORD cStores,HCERTSTORE * rghStores,BOOL fDontAddRootCert,CERT_TRUST_STATUS * pChainTrustStatus)
{
    DWORD	i;
    CERT_CHAIN_ENGINE_CONFIG CertChainEngineConfig;
    HCERTCHAINENGINE hCertChainEngine = NULL;
    PCCERT_CHAIN_CONTEXT pCertChainContext = NULL;
    CERT_CHAIN_PARA CertChainPara;
    BOOL fRet = TRUE;
    PCCERT_CONTEXT pTempCertContext = NULL;

    //
    // create a new chain engine, then build the chain
    //
    memset(&CertChainEngineConfig, 0, sizeof(CertChainEngineConfig));
    CertChainEngineConfig.cbSize = sizeof(CertChainEngineConfig);
    CertChainEngineConfig.cAdditionalStore = cStores;
    CertChainEngineConfig.rghAdditionalStore = rghStores;
    CertChainEngineConfig.dwFlags = CERT_CHAIN_USE_LOCAL_MACHINE_STORE;

    if (!CertCreateCertificateChainEngine(&CertChainEngineConfig, &hCertChainEngine))
    {
        goto AddChainToStore_Error;
    }

	memset(&CertChainPara, 0, sizeof(CertChainPara));
	CertChainPara.cbSize = sizeof(CertChainPara);

	if (!CertGetCertificateChain(hCertChainEngine,pCertContext,NULL,NULL,&CertChainPara,0,NULL,&pCertChainContext))
	{
		goto AddChainToStore_Error;
	}

    //
    // make sure there is atleast 1 simple chain
    //
    if (pCertChainContext->cChain != 0)
	{
		i = 0;
		while (i < pCertChainContext->rgpChain[0]->cElement)
		{
			//
			// if we are supposed to skip the root cert,
			// and we are on the root cert, then continue
			//
			if (fDontAddRootCert && (pCertChainContext->rgpChain[0]->rgpElement[i]->TrustStatus.dwInfoStatus & CERT_TRUST_IS_SELF_SIGNED))
			{
                i++;
                continue;
			}

			CertAddCertificateContextToStore(hCertStore,pCertChainContext->rgpChain[0]->rgpElement[i]->pCertContext,CERT_STORE_ADD_REPLACE_EXISTING,&pTempCertContext);
            //
            // remove any private key property the certcontext may have on it.
            //
            if (pTempCertContext)
            {
                CertSetCertificateContextProperty(pTempCertContext, CERT_KEY_PROV_INFO_PROP_ID, 0, NULL);
                CertFreeCertificateContext(pTempCertContext);
            }

			i++;
		}
	}
	else
	{
		goto AddChainToStore_Error;
	}

	//
	// if the caller wants the status, then set it
	//
	if (pChainTrustStatus != NULL)
	{
		pChainTrustStatus->dwErrorStatus = pCertChainContext->TrustStatus.dwErrorStatus;
		pChainTrustStatus->dwInfoStatus = pCertChainContext->TrustStatus.dwInfoStatus;
	}

	
AddChainToStore_Exit:
	if (pCertChainContext != NULL)
	{
		CertFreeCertificateChain(pCertChainContext);
	}

	if (hCertChainEngine != NULL)
	{
		CertFreeCertificateChainEngine(hCertChainEngine);
	}
	return fRet;

AddChainToStore_Error:
	fRet = FALSE;
	goto AddChainToStore_Exit;
}


// This function is borrowed from trustapi.cpp
BOOL TrustIsCertificateSelfSigned(PCCERT_CONTEXT pContext,DWORD dwEncoding, DWORD dwFlags)
{
    if (!(pContext) || (dwFlags != 0))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (!(CertCompareCertificateName(dwEncoding,&pContext->pCertInfo->Issuer,&pContext->pCertInfo->Subject)))
    {
        return(FALSE);
    }

    DWORD   dwFlag;

    dwFlag = CERT_STORE_SIGNATURE_FLAG;

    if (!(CertVerifySubjectCertificateContext(pContext, pContext, &dwFlag)) || 
        (dwFlag & CERT_STORE_SIGNATURE_FLAG))
    {
        return(FALSE);
    }

    return(TRUE);
}


HRESULT UninstallCert(CString csInstanceName)
{
    CComAuthInfo auth;
    CString key_path = ReturnGoodMetabasePath(csInstanceName);
    CMetaKey key(&auth, key_path, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);
    if (key.Succeeded())
    {
        CString store_name;
        key.QueryValue(MD_SSL_CERT_STORE_NAME, store_name);
        if (SUCCEEDED(key.DeleteValue(MD_SSL_CERT_HASH)))
        {
            key.DeleteValue(MD_SSL_CERT_STORE_NAME);
        }
    }
    return key.QueryResult();
}

CERT_CONTEXT * GetInstalledCert(HRESULT * phResult, CString csKeyPath)
{
    //	ATLASSERT(GetEnroll() != NULL);
    ATLASSERT(phResult != NULL);
    CERT_CONTEXT * pCert = NULL;
    *phResult = S_OK;
    CComAuthInfo auth;
    CString key_path = ReturnGoodMetabasePath(csKeyPath);

    CMetaKey key(&auth, key_path, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);
    if (key.Succeeded())
    {
        CString store_name;
        CBlob hash;
        if (SUCCEEDED(*phResult = key.QueryValue(MD_SSL_CERT_STORE_NAME, store_name)) &&
            SUCCEEDED(*phResult = key.QueryValue(MD_SSL_CERT_HASH, hash)))
        {
            // Open MY store. We assume that store type and flags
            // cannot be changed between installation and unistallation
            // of the sertificate.
            HCERTSTORE hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM,PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,NULL,CERT_SYSTEM_STORE_LOCAL_MACHINE,store_name);
            ASSERT(hStore != NULL);
            if (hStore != NULL)
            {
                // Now we need to find cert by hash
                CRYPT_HASH_BLOB crypt_hash;
                crypt_hash.cbData = hash.GetSize();
                crypt_hash.pbData = hash.GetData();
                pCert = (CERT_CONTEXT *)CertFindCertificateInStore(hStore,X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,0,CERT_FIND_HASH,(LPVOID)&crypt_hash,NULL);
                if (pCert == NULL)
                {
                    *phResult = HRESULT_FROM_WIN32(GetLastError());
                }
                VERIFY(CertCloseStore(hStore, 0));
            }
            else
            {
                *phResult = HRESULT_FROM_WIN32(GetLastError());
            }
        }
    }
    else
    {
        *phResult = key.QueryResult();
    }
    return pCert;
}


CERT_CONTEXT * GetInstalledCert(HRESULT * phResult,DWORD cbHashBlob, char * pHashBlob)
{
    ATLASSERT(phResult != NULL);
    CERT_CONTEXT * pCert = NULL;
    *phResult = S_OK;
    CString store_name = _T("MY");

    HCERTSTORE hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM,PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,NULL,CERT_SYSTEM_STORE_LOCAL_MACHINE,store_name);
    ASSERT(hStore != NULL);
    if (hStore != NULL)
    {
        // Now we need to find cert by hash
        CRYPT_HASH_BLOB crypt_hash;
        crypt_hash.cbData = cbHashBlob;
        crypt_hash.pbData = (BYTE *) pHashBlob;
        pCert = (CERT_CONTEXT *)CertFindCertificateInStore(hStore,X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,0,CERT_FIND_HASH,(LPVOID)&crypt_hash,NULL);
        if (pCert == NULL)
        {
            *phResult = HRESULT_FROM_WIN32(GetLastError());
        }
        VERIFY(CertCloseStore(hStore, 0));
    }
    else
    {
        *phResult = HRESULT_FROM_WIN32(GetLastError());
    }

    return pCert;
}



/*
	InstallHashToMetabase

	Function writes hash array to metabase. After that IIS 
	could use certificate with that hash from MY store.
	Function expects server_name in format lm\w3svc\<number>,
	i.e. from root node down to virtual server
*/
BOOL InstallHashToMetabase(CRYPT_HASH_BLOB * pHash,BSTR InstanceName,HRESULT * phResult)
{
    BOOL bRes = FALSE;
    CComAuthInfo auth;
    CString key_path = ReturnGoodMetabasePath(InstanceName);
    CMetaKey key(&auth, key_path, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);
	if (key.Succeeded())
	{
		CBlob blob;
		blob.SetValue(pHash->cbData, pHash->pbData, TRUE);
		bRes = SUCCEEDED(*phResult = key.SetValue(MD_SSL_CERT_HASH, blob))
			&& SUCCEEDED(*phResult = key.SetValue(MD_SSL_CERT_STORE_NAME, CString(L"MY")));
	}
	else
	{
        *phResult = key.QueryResult();
	}
	return bRes;
}


HRESULT HereIsBinaryGimmieVtArray(DWORD cbBinaryBufferSize,char *pbBinaryBuffer,VARIANT * lpVarDestObject,BOOL bReturnBinaryAsVT_VARIANT)
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    CHAR HUGEP *pArray = NULL;

    aBound.lLbound = 0;
    aBound.cElements = cbBinaryBufferSize;

    if (bReturnBinaryAsVT_VARIANT)
    {
       aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );
    }
    else
    {
       aList = SafeArrayCreate( VT_UI1, 1, &aBound );
    }

    aList = SafeArrayCreate( VT_UI1, 1, &aBound );
    if ( aList == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto HereIsBinaryGimmieVtArray_Exit;
    }

    hr = SafeArrayAccessData( aList, (void HUGEP * FAR *) &pArray );
    if (FAILED(hr))
    {
        goto HereIsBinaryGimmieVtArray_Exit;
    }

    memcpy( pArray, pbBinaryBuffer, aBound.cElements );
    SafeArrayUnaccessData( aList );

    if (bReturnBinaryAsVT_VARIANT)
    {
       V_VT(lpVarDestObject) = VT_ARRAY | VT_VARIANT;
    }
    else
    {
       V_VT(lpVarDestObject) = VT_ARRAY | VT_UI1;
    }

    V_ARRAY(lpVarDestObject) = aList;

    return hr;

HereIsBinaryGimmieVtArray_Exit:
    if (aList)
        {SafeArrayDestroy( aList );}

    return hr;
}


HRESULT
HereIsVtArrayGimmieBinary(
    VARIANT * lpVarSrcObject,
    DWORD * cbBinaryBufferSize,
    char **pbBinaryBuffer,
    BOOL bReturnBinaryAsVT_VARIANT
    )
{
    HRESULT hr = S_OK;
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    CHAR HUGEP *pArray = NULL;

    if (NULL == cbBinaryBufferSize || NULL == pbBinaryBuffer)
    {
        hr = E_INVALIDARG;
        goto HereIsVtArrayGimmieBinary_Exit;
    }

    if (bReturnBinaryAsVT_VARIANT)
    {
        hr = VariantChangeType(lpVarSrcObject,lpVarSrcObject,0,VT_ARRAY | VT_VARIANT);
    }
    else
    {
        hr = VariantChangeType(lpVarSrcObject,lpVarSrcObject,0,VT_ARRAY | VT_UI1);
    }

    if (FAILED(hr)) 
    {
        if (hr != E_OUTOFMEMORY) 
        {
            hr = OLE_E_CANTCONVERT;
        }
        goto HereIsVtArrayGimmieBinary_Exit;
    }

    if (bReturnBinaryAsVT_VARIANT)
    {
        if( lpVarSrcObject->vt != (VT_ARRAY | VT_VARIANT)) 
        {
            hr = OLE_E_CANTCONVERT;
            goto HereIsVtArrayGimmieBinary_Exit;
        }
    }
    else
    {
        if( lpVarSrcObject->vt != (VT_ARRAY | VT_UI1)) 
        {
            hr = OLE_E_CANTCONVERT;
            goto HereIsVtArrayGimmieBinary_Exit;
        }
    }

    hr = SafeArrayGetLBound(V_ARRAY(lpVarSrcObject),1,(long FAR *) &dwSLBound );
    if (FAILED(hr))
        {goto HereIsVtArrayGimmieBinary_Exit;}

    hr = SafeArrayGetUBound(V_ARRAY(lpVarSrcObject),1,(long FAR *) &dwSUBound );
    if (FAILED(hr))
        {goto HereIsVtArrayGimmieBinary_Exit;}

    //*pbBinaryBuffer = (LPBYTE) AllocADsMem(dwSUBound - dwSLBound + 1);
    *pbBinaryBuffer = (char *) ::CoTaskMemAlloc(dwSUBound - dwSLBound + 1);
    if (*pbBinaryBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto HereIsVtArrayGimmieBinary_Exit;
    }

    *cbBinaryBufferSize = dwSUBound - dwSLBound + 1;

    hr = SafeArrayAccessData( V_ARRAY(lpVarSrcObject),(void HUGEP * FAR *) &pArray );
    if (FAILED(hr))
        {goto HereIsVtArrayGimmieBinary_Exit;}

    memcpy(*pbBinaryBuffer,pArray,dwSUBound-dwSLBound+1);
    SafeArrayUnaccessData( V_ARRAY(lpVarSrcObject) );

HereIsVtArrayGimmieBinary_Exit:
    return hr;
}

BOOL IsCertExportable(PCCERT_CONTEXT pCertContext)
{
    HCRYPTPROV  hCryptProv = NULL;
    DWORD       dwKeySpec = 0;
    BOOL        fCallerFreeProv = FALSE;
    BOOL        fReturn = FALSE;
    HCRYPTKEY   hKey = NULL;
    DWORD       dwPermissions = 0;
    DWORD       dwSize = 0;

    if (!pCertContext)
    {
        fReturn = FALSE;
        goto IsCertExportable_Exit;
    }

    //
    // first get the private key context
    //
    if (!CryptAcquireCertificatePrivateKey(
            pCertContext,
            CRYPT_ACQUIRE_USE_PROV_INFO_FLAG | CRYPT_ACQUIRE_COMPARE_KEY_FLAG,
            NULL,
            &hCryptProv,
            &dwKeySpec,
            &fCallerFreeProv))
    {
        fReturn = FALSE;
        goto IsCertExportable_Exit;
    }

    //
    // get the handle to the key
    //
    if (!CryptGetUserKey(hCryptProv, dwKeySpec, &hKey))
    {
        fReturn = FALSE;
        goto IsCertExportable_Exit;
    }

    //
    // finally, get the permissions on the key and check if it is exportable
    //
    dwSize = sizeof(dwPermissions);
    if (!CryptGetKeyParam(hKey, KP_PERMISSIONS, (PBYTE)&dwPermissions, &dwSize, 0))
    {
        fReturn = FALSE;
        goto IsCertExportable_Exit;
    }

    fReturn = (dwPermissions & CRYPT_EXPORT) ? TRUE : FALSE;

IsCertExportable_Exit:
    if (hKey != NULL){CryptDestroyKey(hKey);}
    if (fCallerFreeProv){CryptReleaseContext(hCryptProv, 0);}
    return fReturn;
}

BOOL FormatDateString(CString& str, FILETIME ft, BOOL fIncludeTime, BOOL fLongFormat)
{
    BOOL bReturn = FALSE;
    LPWSTR pwReturnedString = NULL;
    bReturn = FormatDateString(&pwReturnedString,ft,fIncludeTime,fLongFormat);
    if (pwReturnedString)
    {
        str = pwReturnedString;
        free(pwReturnedString);pwReturnedString = NULL;
    }
    return bReturn;
}

BOOL FormatDateString(LPWSTR * pszReturn, FILETIME ft, BOOL fIncludeTime, BOOL fLongFormat)
{
   int cch;
   int cch2;
   SYSTEMTIME st;
   FILETIME localTime;
   LPWSTR psz = NULL;
    
   if (!FileTimeToLocalFileTime(&ft, &localTime))
   {
		return FALSE;
   }
    
   if (!FileTimeToSystemTime(&localTime, &st)) 
   {
		//
      // if the conversion to local time failed, then just use the original time
      //
      if (!FileTimeToSystemTime(&ft, &st)) 
      {
			return FALSE;
      }
   }

   cch = (GetTimeFormat(LOCALE_SYSTEM_DEFAULT, 0, &st, NULL, NULL, 0) +
          GetDateFormat(LOCALE_SYSTEM_DEFAULT, fLongFormat ? DATE_LONGDATE : 0, &st, NULL, NULL, 0) + 5);

   if (NULL == (psz = (LPWSTR) malloc((cch+5) * sizeof(WCHAR))))
   {
		return FALSE;
   }
    
   cch2 = GetDateFormat(LOCALE_SYSTEM_DEFAULT, fLongFormat ? DATE_LONGDATE : 0, &st, NULL, psz, cch);
   if (fIncludeTime)
   {
      psz[cch2-1] = ' ';
      GetTimeFormat(LOCALE_SYSTEM_DEFAULT, TIME_NOSECONDS, &st, NULL, &psz[cch2], cch-cch2);
   }

   if (psz)
   {
      *pszReturn = psz;
      return TRUE;
   }
   else
   {
      return FALSE;
   }
}


const WCHAR     RgwchHex[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
BOOL FormatMemBufToString(LPWSTR *ppString, LPBYTE pbData, DWORD cbData)
{   
    DWORD   i = 0;
    LPBYTE  pb;
    DWORD   numCharsInserted = 0;

    //
    // calculate the size needed
    //
    pb = pbData;
    while (pb <= &(pbData[cbData-1]))
    {   
        if (numCharsInserted == 4)
        {
            i += sizeof(WCHAR);
            numCharsInserted = 0;
        }
        else
        {
            i += 2 * sizeof(WCHAR);
            pb++;
            numCharsInserted += 2;  
        }
    }

    if (NULL == (*ppString = (LPWSTR) malloc(i+sizeof(WCHAR))))
    {
        return FALSE;
    }

    //
    // copy to the buffer
    //
    i = 0;
    numCharsInserted = 0;
    pb = pbData;
    while (pb <= &(pbData[cbData-1]))
    {   
        if (numCharsInserted == 4)
        {
            (*ppString)[i++] = L' ';
            numCharsInserted = 0;
        }
        else
        {
            (*ppString)[i++] = RgwchHex[(*pb & 0xf0) >> 4];
            (*ppString)[i++] = RgwchHex[*pb & 0x0f];
            pb++;
            numCharsInserted += 2;  
        }
    }
    (*ppString)[i] = 0;
    return TRUE;
}

BOOL MyGetOIDInfo(LPWSTR string, DWORD stringSize, LPSTR pszObjId,BOOL bReturnBackNumericOID)
{   
    PCCRYPT_OID_INFO pOIDInfo;
    if (bReturnBackNumericOID)
    {
        return (MultiByteToWideChar(CP_ACP, 0, pszObjId, -1, string, stringSize) != 0);
    }
    else
    {
        pOIDInfo = CryptFindOIDInfo(CRYPT_OID_INFO_OID_KEY, pszObjId, 0);
        if (pOIDInfo != NULL)
        {
            if ((DWORD)wcslen(pOIDInfo->pwszName)+1 <= stringSize)
            {
				StringCbCopyW(string,stringSize * sizeof(WCHAR),pOIDInfo->pwszName);
            }
            else
            {
                return FALSE;
            }
        }
        else
        {
            return (MultiByteToWideChar(CP_ACP, 0, pszObjId, -1, string, stringSize) != 0);
        }
    }
    return TRUE;
}

#define CRYPTUI_MAX_STRING_SIZE         768
#define ARRAYSIZE(x) (sizeof(x)/sizeof(x[0]))
BOOL FormatEnhancedKeyUsageString(LPWSTR * pszReturn, PCCERT_CONTEXT pCertContext, BOOL fPropertiesOnly)
{
	CERT_ENHKEY_USAGE * pKeyUsage = NULL;
	WCHAR szText[CRYPTUI_MAX_STRING_SIZE];
	BOOL bRes = FALSE;
    HRESULT hRes = 0;
    LPWSTR pwszTempString = NULL;
    void *pTemp = NULL;

    DWORD numChars = 128 + 1; // 1 is the terminating null
    pwszTempString = (LPWSTR) malloc(numChars * sizeof(WCHAR));
    if (pwszTempString == NULL)
    {
        goto FormatEnhancedKeyUsageString_Exit;
    }
	ZeroMemory(pwszTempString,numChars * sizeof(WCHAR));

	if (GetKeyUsageProperty(pCertContext, &pKeyUsage, fPropertiesOnly, &hRes))
	{
		// loop for each usage and add it to the display string
		for (DWORD i = 0; i < pKeyUsage->cUsageIdentifier; i++)
		{
			if (!(bRes = MyGetOIDInfo(szText, ARRAYSIZE(szText), pKeyUsage->rgpszUsageIdentifier[i], FALSE)))
				break;

			// add delimeter if not first iteration
			if (i != 0)
			{
                numChars = numChars + 2;
                if ( wcslen(pwszTempString) <= (numChars * sizeof(WCHAR)))
                {
                    pTemp = realloc(pwszTempString, (numChars * sizeof(WCHAR)));
                    if (pTemp == NULL)
                    {
                        free(pwszTempString);pwszTempString = NULL;
                    }
                    pwszTempString = (LPWSTR) pTemp;

                }
				StringCbCatW(pwszTempString,numChars * sizeof(WCHAR),L", ");
			}

			// add the enhanced key usage string
            if ((wcslen(szText) + 1) <= (numChars * sizeof(WCHAR)))
            {
                numChars = numChars + wcslen(szText) + 1;
                pTemp = realloc(pwszTempString, (numChars * sizeof(WCHAR)));
                if (pTemp == NULL)
                {
                    free(pwszTempString);pwszTempString = NULL;
                }
                pwszTempString = (LPWSTR) pTemp;
            }
			StringCbCatW(pwszTempString,numChars * sizeof(WCHAR),szText);
		}
		free(pKeyUsage);
	}

FormatEnhancedKeyUsageString_Exit:
    *pszReturn = pwszTempString;
	return bRes;
}

BOOL FormatEnhancedKeyUsageString(CString& str,PCCERT_CONTEXT pCertContext,BOOL fPropertiesOnly,BOOL fMultiline,HRESULT * phRes)
{
	CERT_ENHKEY_USAGE * pKeyUsage = NULL;
	WCHAR szText[CRYPTUI_MAX_STRING_SIZE];
	BOOL bRes = FALSE;

	if (GetKeyUsageProperty(pCertContext, &pKeyUsage, fPropertiesOnly, phRes))
	{
		// loop for each usage and add it to the display string
		for (DWORD i = 0; i < pKeyUsage->cUsageIdentifier; i++)
		{
			if (!(bRes = MyGetOIDInfo(szText, ARRAYSIZE(szText), pKeyUsage->rgpszUsageIdentifier[i],FALSE)))
				break;
			// add delimeter if not first iteration
			if (i != 0)
			{
				str += fMultiline ? L"\n" : L", ";
			}
			// add the enhanced key usage string
			str += szText;
		}
		free (pKeyUsage);
	}
	else
	{
		str.LoadString(_Module.GetResourceInstance(),IDS_ANY);
		bRes = TRUE;
	}
	return bRes;
}

#define ARRAYSIZE(x) (sizeof(x)/sizeof(x[0]))
#define STRING_ALLOCATION_SIZE 128
BOOL GetCertDescriptionForRemote(PCCERT_CONTEXT pCert, LPWSTR *ppString, DWORD * cbReturn, BOOL fMultiline)
{
    CERT_NAME_INFO  *pNameInfo;
    DWORD           cbNameInfo;
    WCHAR           szText[256];
    LPWSTR          pwszText;
    int             i,j;
    DWORD           numChars = 1; // 1 for the terminating 0
    DWORD           numAllocations = 1;
    void            *pTemp;

    //
    // decode the dnname into a CERT_NAME_INFO struct
    //
    if (!CryptDecodeObject(
                X509_ASN_ENCODING,
                X509_UNICODE_NAME,
                pCert->pCertInfo->Subject.pbData,
                pCert->pCertInfo->Subject.cbData,
                0,
                NULL,
                &cbNameInfo))
    {
        return FALSE;
    }
    if (NULL == (pNameInfo = (CERT_NAME_INFO *) malloc(cbNameInfo)))
    {
        return FALSE;
    }
    if (!CryptDecodeObject(
                X509_ASN_ENCODING,
                X509_UNICODE_NAME,
                pCert->pCertInfo->Subject.pbData,
                pCert->pCertInfo->Subject.cbData,
                0,
                pNameInfo,
                &cbNameInfo))
    {
        free(pNameInfo);
        return FALSE;
    }

    //
    // allocate an initial buffer for the DN name string, then if it grows larger
    // than the initial amount just grow as needed
    //
    *ppString = (LPWSTR) malloc(STRING_ALLOCATION_SIZE * sizeof(WCHAR));
    if (*ppString == NULL)
    {
        free(pNameInfo);
        return FALSE;
    }

    (*ppString)[0] = 0;


    //
    // loop for each rdn and add it to the string
    //
    for (i=pNameInfo->cRDN-1; i>=0; i--)
    {
        // if this is not the first iteration, then add a eol or a ", "
        if (i != (int)pNameInfo->cRDN-1)
        {
            if (numChars+2 >= (numAllocations * STRING_ALLOCATION_SIZE))
            {
                pTemp = realloc(*ppString, ++numAllocations * STRING_ALLOCATION_SIZE * sizeof(WCHAR));
                if (pTemp == NULL)
                {
                    free (pNameInfo);
                    free (*ppString);
                    return FALSE;
                }
                *ppString = (LPWSTR) pTemp;
            }
            
            if (fMultiline)
			{
				StringCbCatW(*ppString,numAllocations * STRING_ALLOCATION_SIZE * sizeof(WCHAR),L"\n");
			}
            else
			{
				StringCbCatW(*ppString,numAllocations * STRING_ALLOCATION_SIZE * sizeof(WCHAR),L", ");
			}

            numChars += 2;
        }

        for (j=pNameInfo->rgRDN[i].cRDNAttr-1; j>=0; j--)
        {
            // if this is not the first iteration, then add a eol or a ", "
            if (j != (int)pNameInfo->rgRDN[i].cRDNAttr-1)
            {
                if (numChars+2 >= (numAllocations * STRING_ALLOCATION_SIZE))
                {
                    pTemp = realloc(*ppString, ++numAllocations * STRING_ALLOCATION_SIZE * sizeof(WCHAR));
                    if (pTemp == NULL)
                    {
                        free (pNameInfo);
                        free (*ppString);
                        return FALSE;
                    }
                    *ppString = (LPWSTR) pTemp;
                }
                
                if (fMultiline)
				{
					StringCbCatW(*ppString,numAllocations * STRING_ALLOCATION_SIZE * sizeof(WCHAR),L"\n");
				}
                else
				{
					StringCbCatW(*ppString,numAllocations * STRING_ALLOCATION_SIZE * sizeof(WCHAR),L", ");
				}

                numChars += 2;  
            }
            
            //
            // add the field name to the string if it is Multiline display
            //

            if (fMultiline)
            {
                if (!MyGetOIDInfo(szText, ARRAYSIZE(szText), pNameInfo->rgRDN[i].rgRDNAttr[j].pszObjId,TRUE))
                {
                    free (pNameInfo);
                    return FALSE;
                }

                if ((numChars + wcslen(szText) + 3) >= (numAllocations * STRING_ALLOCATION_SIZE))
                {
                    // increment the number of allocation blocks until it is large enough
                    while ((numChars + wcslen(szText) + 3) >= (++numAllocations * STRING_ALLOCATION_SIZE));

                    pTemp = realloc(*ppString, numAllocations * STRING_ALLOCATION_SIZE * sizeof(WCHAR));
                    if (pTemp == NULL)
                    {
                        free (pNameInfo);
                        free (*ppString);
                        return FALSE;
                    }
                    *ppString = (LPWSTR) pTemp;
                }

                numChars += wcslen(szText) + 1;

				StringCbCatW(*ppString,numAllocations * STRING_ALLOCATION_SIZE * sizeof(WCHAR),szText);
				StringCbCatW(*ppString,numAllocations * STRING_ALLOCATION_SIZE * sizeof(WCHAR),L"=");
            }

            //
            // add the value to the string
            //
            if (CERT_RDN_ENCODED_BLOB == pNameInfo->rgRDN[i].rgRDNAttr[j].dwValueType ||
                        CERT_RDN_OCTET_STRING == pNameInfo->rgRDN[i].rgRDNAttr[j].dwValueType)
            {
                // translate the buffer to a text string and display it that way
                if (FormatMemBufToString(
                        &pwszText, 
                        pNameInfo->rgRDN[i].rgRDNAttr[j].Value.pbData,
                        pNameInfo->rgRDN[i].rgRDNAttr[j].Value.cbData))
                {
                    if ((numChars + wcslen(pwszText)) >= (numAllocations * STRING_ALLOCATION_SIZE))
                    {
                        // increment the number of allocation blocks until it is large enough
                        while ((numChars + wcslen(pwszText)) >= (++numAllocations * STRING_ALLOCATION_SIZE));

                        pTemp = realloc(*ppString, numAllocations * STRING_ALLOCATION_SIZE * sizeof(WCHAR));
                        if (pTemp == NULL)
                        {
                            free (pwszText);
                            free (pNameInfo);
                            free (*ppString);
                            return FALSE;
                        }
                        *ppString = (LPWSTR) pTemp;
                    }
                    
					StringCbCatW(*ppString,numAllocations * STRING_ALLOCATION_SIZE * sizeof(WCHAR),pwszText);
                    numChars += wcslen(pwszText);

                    free (pwszText);
                }
            }
            else 
            {
                // buffer is already a string so just copy it
                
                if ((numChars + (pNameInfo->rgRDN[i].rgRDNAttr[j].Value.cbData/sizeof(WCHAR))) 
                        >= (numAllocations * STRING_ALLOCATION_SIZE))
                {
                    // increment the number of allocation blocks until it is large enough
                    while ((numChars + (pNameInfo->rgRDN[i].rgRDNAttr[j].Value.cbData/sizeof(WCHAR))) 
                            >= (++numAllocations * STRING_ALLOCATION_SIZE));

                    pTemp = realloc(*ppString, numAllocations * STRING_ALLOCATION_SIZE * sizeof(WCHAR));
                    if (pTemp == NULL)
                    {
                        free (pNameInfo);
                        free (*ppString);
                        return FALSE;
                    }
                    *ppString = (LPWSTR) pTemp;
                }

				StringCbCatW(*ppString,numAllocations * STRING_ALLOCATION_SIZE * sizeof(WCHAR),(LPWSTR) pNameInfo->rgRDN[i].rgRDNAttr[j].Value.pbData);
                numChars += (pNameInfo->rgRDN[i].rgRDNAttr[j].Value.cbData/sizeof(WCHAR));
            }
        }
    }


    {
        // issued to
        LPWSTR pwName = NULL;
	    DWORD cchName = CertGetNameString(pCert, CERT_NAME_SIMPLE_DISPLAY_TYPE, CERT_NAME_ISSUER_FLAG, NULL, NULL, 0);
	    if (cchName > 1 && (NULL != ( pwName = (LPWSTR) malloc (cchName * sizeof(WCHAR) ))))
	    {
            BOOL bRes = FALSE;
		    bRes = (1 != CertGetNameString(pCert, CERT_NAME_SIMPLE_DISPLAY_TYPE, CERT_NAME_ISSUER_FLAG, NULL, pwName, cchName));
            if (bRes)
            {
                if ((numChars + 4) >= (numAllocations * STRING_ALLOCATION_SIZE))
                {
                    // increment the number of allocation blocks until it is large enough
                    while ((numChars + 4) >= (++numAllocations * STRING_ALLOCATION_SIZE));

                    pTemp = realloc(*ppString, numAllocations * STRING_ALLOCATION_SIZE * sizeof(WCHAR));
                    if (pTemp == NULL)
                    {
                        free (pwszText);
                        free (pNameInfo);
                        free (*ppString);
                        return FALSE;
                    }
                    *ppString = (LPWSTR) pTemp;
                }

				StringCbCatW(*ppString,numAllocations * STRING_ALLOCATION_SIZE * sizeof(WCHAR),L"\n");
                numChars += 2;
                // append it on to the string.
                //#define CERT_INFO_ISSUER_FLAG   
				StringCbCatW(*ppString,numAllocations * STRING_ALLOCATION_SIZE * sizeof(WCHAR),L"4=");
                numChars += 2;
                // append it on to the string.
                if (wcslen(pwName) > 0)
                {
					if ((numChars + wcslen(pwName)) >= (numAllocations * STRING_ALLOCATION_SIZE))
					{
						// increment the number of allocation blocks until it is large enough
						while ((numChars + wcslen(pwName)) >= (++numAllocations * STRING_ALLOCATION_SIZE));

						pTemp = realloc(*ppString, numAllocations * STRING_ALLOCATION_SIZE * sizeof(WCHAR));
						if (pTemp == NULL)
						{
							free (pwszText);
							free (pNameInfo);
							free (*ppString);
							return FALSE;
						}
						*ppString = (LPWSTR) pTemp;
					}

					StringCbCatW(*ppString,numAllocations * STRING_ALLOCATION_SIZE * sizeof(WCHAR),(LPWSTR) pwName);
                    numChars += (cchName);
                }
            }
            if (pwName) {free(pwName);pwName=NULL;}
	    }

	    // expiration date
	    if (FormatDateString(&pwName, pCert->pCertInfo->NotAfter, FALSE, FALSE))
	    {
            if ((numChars + 4) >= (numAllocations * STRING_ALLOCATION_SIZE))
            {
                // increment the number of allocation blocks until it is large enough
                while ((numChars + 4) >= (++numAllocations * STRING_ALLOCATION_SIZE));

                pTemp = realloc(*ppString, numAllocations * STRING_ALLOCATION_SIZE * sizeof(WCHAR));
                if (pTemp == NULL)
                {
                    free (pwszText);
                    free (pNameInfo);
                    free (*ppString);
                    return FALSE;
                }
                *ppString = (LPWSTR) pTemp;
            }

			StringCbCatW(*ppString,numAllocations * STRING_ALLOCATION_SIZE * sizeof(WCHAR),(LPWSTR) L"\n");
            numChars += 2;
            // append it on to the string.
            //#define CERT_INFO_NOT_AFTER_FLAG                    6
			StringCbCatW(*ppString,numAllocations * STRING_ALLOCATION_SIZE * sizeof(WCHAR),(LPWSTR) L"6=");
            numChars += 2;
            // append it on to the string.
            if (wcslen(pwName) > 0)
            {
				if ((numChars + wcslen(pwName)) >= (numAllocations * STRING_ALLOCATION_SIZE))
				{
					// increment the number of allocation blocks until it is large enough
					while ((numChars + wcslen(pwName)) >= (++numAllocations * STRING_ALLOCATION_SIZE));

					pTemp = realloc(*ppString, numAllocations * STRING_ALLOCATION_SIZE * sizeof(WCHAR));
					if (pTemp == NULL)
					{
						free (pwszText);
						free (pNameInfo);
						free (*ppString);
						return FALSE;
					}
					*ppString = (LPWSTR) pTemp;
				}

				StringCbCatW(*ppString,numAllocations * STRING_ALLOCATION_SIZE * sizeof(WCHAR),(LPWSTR) pwName);
                numChars += wcslen(pwName);
            }
            if (pwName) {free(pwName);pwName = NULL;}
	    }

	    // purpose
	    if (FormatEnhancedKeyUsageString(&pwName, pCert, FALSE))
	    {
            if ((numChars + 12) >= (numAllocations * STRING_ALLOCATION_SIZE))
            {
                // increment the number of allocation blocks until it is large enough
                while ((numChars + 12) >= (++numAllocations * STRING_ALLOCATION_SIZE));

                pTemp = realloc(*ppString, numAllocations * STRING_ALLOCATION_SIZE * sizeof(WCHAR));
                if (pTemp == NULL)
                {
                    free (pwszText);
                    free (pNameInfo);
                    free (*ppString);
                    return FALSE;
                }
                *ppString = (LPWSTR) pTemp;
            }

			StringCbCatW(*ppString,numAllocations * STRING_ALLOCATION_SIZE * sizeof(WCHAR),(LPWSTR) L"\n");
            numChars += 2;
            // append it on to the string.
            //#define szOID_ENHANCED_KEY_USAGE        "2.5.29.37"
			StringCbCatW(*ppString,numAllocations * STRING_ALLOCATION_SIZE * sizeof(WCHAR),(LPWSTR) L"2.5.29.37=");
            numChars += 10;
            // append it on to the string.
            if (wcslen(pwName) > 0)
            {
				if ((numChars + wcslen(pwName)) >= (numAllocations * STRING_ALLOCATION_SIZE))
				{
					// increment the number of allocation blocks until it is large enough
					while ((numChars + wcslen(pwName)) >= (++numAllocations * STRING_ALLOCATION_SIZE));

					pTemp = realloc(*ppString, numAllocations * STRING_ALLOCATION_SIZE * sizeof(WCHAR));
					if (pTemp == NULL)
					{
						free (pwszText);
						free (pNameInfo);
						free (*ppString);
						return FALSE;
					}
					*ppString = (LPWSTR) pTemp;
				}
				StringCbCatW(*ppString,numAllocations * STRING_ALLOCATION_SIZE * sizeof(WCHAR),(LPWSTR) pwName);
                numChars += wcslen(pwName);
            }
            if (pwName) {free(pwName);pwName = NULL;}
	    }

    }

    *cbReturn = numChars;
    free (pNameInfo);
    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:   CreateFolders
//
//  Synopsis:   Creates any missing  directories for any slash delimited folder
//              names in the path.
//
//  Arguments:  [ptszPathName] - the path name
//              [fHasFileName] - if true, the path name includes a file name.
//
//  Returns:    HRESULTS
//
//  Notes:      ptszPathName should never end in a slash.
//              Treats forward and back slashes identically.
//-----------------------------------------------------------------------------

#define s_isDriveLetter(c)  ((c >= TEXT('a') && c <= TEXT('z')) || (c >= TEXT('A') && c <= TEXT('Z')))
HRESULT
CreateFolders(LPCTSTR ptszPathName, BOOL fHasFileName)
{
	DWORD dwLen = 0;

    //
    // Copy the string so we can munge it
    //
	dwLen = lstrlen(ptszPathName) + 2;
    TCHAR * ptszPath = new TCHAR[dwLen];
    if (!ptszPath)
    {
        return E_OUTOFMEMORY;
    }
	StringCbCopy(ptszPath,dwLen * sizeof(TCHAR),ptszPathName);

    if (!fHasFileName)
    {
        //
        // If no file name, append a slash so the following logic works
        // correctly.
        //
		StringCbCat(ptszPath,dwLen * sizeof(TCHAR),TEXT("\\"));
    }

    //
    // Get a pointer to the last slash in the name.
    //

    TCHAR * ptszSlash = _tcsrchr(ptszPath, TEXT('\\'));

    if (ptszSlash == NULL)
    {
        //
        // no slashes found, so nothing to do
        //
        delete [] ptszPath;
        return S_OK;
    }

    if (fHasFileName)
    {
        //
        // Chop off the file name, leaving the slash as the last char.
        //
        ptszSlash[1] = TEXT('\0');
    }

    BOOL fFullPath = (lstrlen(ptszPath) > 2        &&
                      s_isDriveLetter(ptszPath[0]) &&
                      ptszPath[1] == TEXT(':'));

    //
    // Walk the string looking for slashes. Each found slash is temporarily
    // replaced with a null and that substring passed to CreateDir.
    //
    TCHAR * ptszTail = ptszPath;
    while (ptszSlash = _tcspbrk(ptszTail, TEXT("\\/")))
    {
        //
        // If the path name starts like C:\ then the first slash will be at
        // the third character
        //

        if (fFullPath && (ptszSlash - ptszTail == 2))
        {
            //
            // We are looking at the root of the drive, so don't try to create
            // a root directory.
            //
            ptszTail = ptszSlash + 1;
            continue;
        }
        *ptszSlash = TEXT('\0');
        if (!CreateDirectory(ptszPath, NULL))
        {
            DWORD dwErr = GetLastError();
            if (dwErr != ERROR_ALREADY_EXISTS)
            {
                delete [] ptszPath;
                return (HRESULT_FROM_WIN32(dwErr));
            }
        }
        *ptszSlash = TEXT('\\');
        ptszTail = ptszSlash + 1;
    }
    delete [] ptszPath;
    return S_OK;
}

#ifdef USE_CERT_REQUEST_OBJECT
HRESULT
CreateRequest_Base64(const BSTR bstr_dn, 
                     IEnroll * pEnroll, 
                     BSTR csp_name,
                     DWORD csp_type,
                     BSTR * pOut)
{
	ASSERT(pOut != NULL);
	ASSERT(bstr_dn != NULL);
	HRESULT hRes = S_OK;
	CString strUsage(szOID_PKIX_KP_SERVER_AUTH);
	CRYPT_DATA_BLOB request = {0, NULL};
    pEnroll->put_ProviderType(csp_type);
    pEnroll->put_ProviderNameWStr(csp_name);
    if (csp_type == PROV_DH_SCHANNEL)
    {
       pEnroll->put_KeySpec(AT_SIGNATURE);
    }
    else if (csp_type == PROV_RSA_SCHANNEL)
    {
       pEnroll->put_KeySpec(AT_KEYEXCHANGE);
    }
    
	if (SUCCEEDED(hRes = pEnroll->createPKCS10WStr(
									bstr_dn, 
									(LPTSTR)(LPCTSTR)strUsage, 
									&request)))
	{
		WCHAR * wszRequestB64 = NULL;
		DWORD cch = 0;
		DWORD err = ERROR_SUCCESS;
		// BASE64 encode pkcs 10
		if ((err = Base64EncodeW(request.pbData, request.cbData, NULL, &cch)) == ERROR_SUCCESS )
		{
				wszRequestB64 = (WCHAR *) LocalAlloc(cch * sizeof(WCHAR));;
				if (NULL != wszRequestB64)
				{
					if ((err = Base64EncodeW(request.pbData, request.cbData, wszRequestB64, &cch)) == ERROR_SUCCESS)
					{
						if ((*pOut = SysAllocStringLen(wszRequestB64, cch)) == NULL ) 
						{
							hRes = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
						}
					}
					else
					{
						hRes = HRESULT_FROM_WIN32(err);
					}
				}
				else
				{
					hRes = HRESULT_FROM_WIN32(err);
				}
				if (wszRequestB64)
				{
					LocalFree(wszRequestB64);
					wszRequestB64 = NULL;
				}
		}
		else
		{
			hRes = HRESULT_FROM_WIN32(err);
		}

		if (request.pbData != NULL)
         CoTaskMemFree(request.pbData);
	}

	return hRes;	
}

PCCERT_CONTEXT GetCertContextFromPKCS7(const BYTE * pbData,DWORD cbData,CERT_PUBLIC_KEY_INFO * pKeyInfo,HRESULT * phResult)
{
	ASSERT(phResult != NULL);
	PCCERT_CONTEXT pRes = NULL;
	CRYPT_DATA_BLOB blob;
	memset(&blob, 0, sizeof(CRYPT_DATA_BLOB));
	blob.cbData = cbData;
	blob.pbData = (BYTE *)pbData;

   HCERTSTORE hStoreMsg = NULL;

	if(CryptQueryObject(CERT_QUERY_OBJECT_BLOB, 
            &blob,
            (CERT_QUERY_CONTENT_FLAG_CERT |
            CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED |
            CERT_QUERY_CONTENT_FLAG_SERIALIZED_STORE |
            CERT_QUERY_CONTENT_FLAG_PKCS7_UNSIGNED) ,
            CERT_QUERY_FORMAT_FLAG_ALL,
            0, 
            NULL, 
            NULL, 
            NULL, 
            &hStoreMsg, 
            NULL, 
            NULL))
	{
		if (pKeyInfo != NULL)
			pRes = CertFindCertificateInStore(hStoreMsg, 
                        X509_ASN_ENCODING,
								0, 
                        CERT_FIND_PUBLIC_KEY, 
                        pKeyInfo, 
                        NULL);
		else
			pRes = CertFindCertificateInStore(hStoreMsg, 
                        X509_ASN_ENCODING,
								0, 
                        CERT_FIND_ANY, 
                        NULL, 
                        NULL);
		if (pRes == NULL)
			*phResult = HRESULT_FROM_WIN32(GetLastError());
		CertCloseStore(hStoreMsg, CERT_CLOSE_STORE_CHECK_FLAG);
	}
	else
		*phResult = HRESULT_FROM_WIN32(GetLastError());
	return pRes;
}

BOOL
AttachFriendlyName(PCCERT_CONTEXT pContext, 
						 const CString& name,
						 HRESULT * phRes)
{
	BOOL bRes = TRUE;
	CRYPT_DATA_BLOB blob_name;

    // Check if friendlyname is empty
    // if it is then don't try to set the friendly name
    if (!name.IsEmpty())
    {
	    blob_name.pbData = (LPBYTE)(LPCTSTR)name;
	    blob_name.cbData = (name.GetLength() + 1) * sizeof(WCHAR);
	    if (!(bRes = CertSetCertificateContextProperty(pContext,
						    CERT_FRIENDLY_NAME_PROP_ID, 0, &blob_name)))
	    {
		    ASSERT(phRes != NULL);
		    *phRes = HRESULT_FROM_WIN32(GetLastError());
	    }
    }

	return bRes;
}

/*
	InstallHashToMetabase

	Function writes hash array to metabase. After that IIS 
	could use certificate with that hash from MY store.
	Function expects server_name in format lm\w3svc\<number>,
	i.e. from root node down to virtual server

*/
BOOL InstallHashToMetabase(CRYPT_HASH_BLOB * pHash,const CString& machine_name, const CString& server_name,HRESULT * phResult)
{
	BOOL bRes = FALSE;
    CComAuthInfo auth(machine_name);
	CMetaKey key(&auth, server_name,
						METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE
						);
	if (key.Succeeded())
	{
		CBlob blob;
		blob.SetValue(pHash->cbData, pHash->pbData, TRUE);
		bRes = SUCCEEDED(*phResult = key.SetValue(MD_SSL_CERT_HASH, blob)) 
			&& SUCCEEDED(*phResult = key.SetValue(MD_SSL_CERT_STORE_NAME, CString(L"MY")));
	}
	else
	{
		TRACE(_T("Failed to open metabase key. Error 0x%x\n"), key.QueryResult());
		*phResult = key.QueryResult();
	}
	return bRes;
}

HCERTSTORE
OpenMyStore(IEnroll * pEnroll, HRESULT * phResult)
{
	ASSERT(NULL != phResult);
	HCERTSTORE hStore = NULL;
	BSTR bstrStoreName, bstrStoreType;
	long dwStoreFlags;
	VERIFY(SUCCEEDED(pEnroll->get_MyStoreNameWStr(&bstrStoreName)));
	VERIFY(SUCCEEDED(pEnroll->get_MyStoreTypeWStr(&bstrStoreType)));
	VERIFY(SUCCEEDED(pEnroll->get_MyStoreFlags(&dwStoreFlags)));
	size_t store_type_len = _tcslen(bstrStoreType);
	char * szStoreProvider = (char *)_alloca(store_type_len + 1);
	ASSERT(szStoreProvider != NULL);
	size_t n = wcstombs(szStoreProvider, bstrStoreType, store_type_len);
	ASSERT(n != -1);
	// this converter doesn't set zero byte!!!
	szStoreProvider[n] = '\0';
	hStore = CertOpenStore(
		szStoreProvider,
      PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
		NULL,
		dwStoreFlags,
		bstrStoreName
		);
	CoTaskMemFree(bstrStoreName);
	CoTaskMemFree(bstrStoreType);
	if (hStore == NULL)
		*phResult = HRESULT_FROM_WIN32(GetLastError());
	return hStore;
}

/*
		GetInstalledCert

		Function reads cert hash attribute from metabase
		using machine_name and server name as server instance
		description, then looks in MY store for a certificate
		with hash equal found in metabase.
		Return is cert context pointer or NULL, if cert wasn't
		found or certificate store wasn't opened.
		On return HRESULT * is filled by error code.
 */
PCCERT_CONTEXT GetInstalledCert(const CString& machine_name, const CString& server_name,IEnroll * pEnroll,HRESULT * phResult)
{
	ASSERT(pEnroll != NULL);
	ASSERT(phResult != NULL);
	ASSERT(!machine_name.IsEmpty());
	ASSERT(!server_name.IsEmpty());
	PCCERT_CONTEXT pCert = NULL;
	*phResult = S_OK;
    CComAuthInfo auth(machine_name);
	CMetaKey key(&auth, server_name,
				METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE
				);
	if (key.Succeeded())
	{
		CString store_name;
		CBlob hash;
		if (	SUCCEEDED(*phResult = key.QueryValue(MD_SSL_CERT_STORE_NAME, store_name))
			&&	SUCCEEDED(*phResult = key.QueryValue(MD_SSL_CERT_HASH, hash))
			)
		{
			// Open MY store. We assume that store type and flags
			// cannot be changed between installation and unistallation
			// of the sertificate.
			HCERTSTORE hStore = OpenMyStore(pEnroll, phResult);
			ASSERT(hStore != NULL);
			if (hStore != NULL)
			{
				// Now we need to find cert by hash
				CRYPT_HASH_BLOB crypt_hash;
                SecureZeroMemory(&crypt_hash, sizeof(CRYPT_HASH_BLOB));

				crypt_hash.cbData = hash.GetSize();
				crypt_hash.pbData = hash.GetData();
				pCert = CertFindCertificateInStore(hStore, 
												X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 
												0, CERT_FIND_HASH, (LPVOID)&crypt_hash, NULL);
				if (pCert == NULL)
					*phResult = HRESULT_FROM_WIN32(GetLastError());
				VERIFY(CertCloseStore(hStore, 0));
			}
		}
	}
	else
    {
		*phResult = key.QueryResult();
    }
	return pCert;
}

void FormatRdnAttr(CString& str, DWORD dwValueType, CRYPT_DATA_BLOB& blob, BOOL fAppend)
{
    if (CERT_RDN_ENCODED_BLOB == dwValueType ||	CERT_RDN_OCTET_STRING == dwValueType)
    {
        // translate the buffer to a text string
        LPWSTR pString = NULL;
        FormatMemBufToString(&pString, blob.pbData, blob.cbData);
        if (pString)
        {
            str = pString;
            free(pString);
        }
    }
    else 
    {
        // buffer is already a string so just copy/append to it
        if (fAppend)
        {
            str += (LPTSTR)blob.pbData;
        }
        else
        {
            // don't concatenate these entries...
            str = (LPTSTR)blob.pbData;
        }
    }
}

BOOL GetNameString(PCCERT_CONTEXT pCertContext,DWORD type,DWORD flag,CString& name,HRESULT * phRes)
{
	BOOL bRes = FALSE;
	LPTSTR pName = NULL;
	DWORD cchName = CertGetNameString(pCertContext, type, flag, NULL, NULL, 0);
    if (cchName > 1)
	{
        pName = (LPTSTR) LocalAlloc(LPTR, cchName*sizeof(TCHAR));
        if (!pName) 
            {
            *phRes = HRESULT_FROM_WIN32(GetLastError());
            return FALSE;
            }

		bRes = (1 != CertGetNameString(pCertContext, type, flag, NULL, pName, cchName));
        if (pName)
        {
            // assign it to the cstring
            name = pName;
        }
        if (pName)
        {
            LocalFree(pName);pName=NULL;
        }
	}
	else
	{
		*phRes = HRESULT_FROM_WIN32(GetLastError());
	}
	return bRes;
}

BOOL GetFriendlyName(PCCERT_CONTEXT pCertContext,CString& name,HRESULT * phRes)
{
	BOOL bRes = FALSE;
	DWORD cb;
	LPTSTR pName = NULL;

    if (!CertGetCertificateContextProperty(pCertContext, CERT_FRIENDLY_NAME_PROP_ID, NULL, &cb))
    {
        *phRes = HRESULT_FROM_WIN32(GetLastError());
        return FALSE;
    }

    if (cb > 1)
	{
        pName = (LPTSTR) LocalAlloc(LPTR, cb * sizeof(TCHAR));
        if (!pName) 
            {
            *phRes = HRESULT_FROM_WIN32(GetLastError());
            return FALSE;
            }

	    if (CertGetCertificateContextProperty(pCertContext, CERT_FRIENDLY_NAME_PROP_ID, pName, &cb))
	    {
		    pName[cb] = 0;
		    bRes = TRUE;
	    }
	    else
	    {
		    *phRes = HRESULT_FROM_WIN32(GetLastError());
	    }

        if (pName)
        {
            LocalFree(pName);pName=NULL;
        }
    }

	return bRes;
}

BOOL GetAlternateSubjectName(PCCERT_CONTEXT pCertContext,TCHAR ** cwszOut)
{
    BOOL bRet = FALSE;
    PCERT_ALT_NAME_INFO pAltNameInfo = NULL;
    *cwszOut = NULL;

    pAltNameInfo = AllocAndGetAltSubjectInfo(pCertContext);
    if (pAltNameInfo)
    {
        if (!GetAltNameUnicodeStringChoiceW(CERT_ALT_NAME_RFC822_NAME,pAltNameInfo,cwszOut))
        {
            if (!GetAltNameUnicodeStringChoiceW(CERT_ALT_NAME_DNS_NAME,pAltNameInfo,cwszOut))
            {
                cwszOut = NULL;
                bRet = TRUE;
            }
        }
    }

    if (pAltNameInfo){LocalFree(pAltNameInfo);pAltNameInfo=NULL;}
    return bRet;
}

BOOL GetRequestInfoFromPKCS10(CCryptBlob& pkcs10, PCERT_REQUEST_INFO * pReqInfo,HRESULT * phRes)
{
	ASSERT(pReqInfo != NULL);
	ASSERT(phRes != NULL);
	BOOL bRes = FALSE;
	DWORD req_info_size;
	if (!(bRes = CryptDecodeObjectEx(
							X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 
							X509_CERT_REQUEST_TO_BE_SIGNED,
							pkcs10.GetData(), 
							pkcs10.GetSize(), 
							CRYPT_DECODE_ALLOC_FLAG,
							NULL,
							pReqInfo, 
							&req_info_size)))
	{
		TRACE(_T("Error from CryptDecodeObjectEx: %xd\n"), GetLastError());
		*phRes = HRESULT_FROM_WIN32(GetLastError());
	}
	return bRes;
}

BOOL EncodeString(CString& str,CCryptBlob& blob,HRESULT * phRes)
{
	BOOL bRes = FALSE;
	DWORD cb;
	CERT_NAME_VALUE name_value;
	name_value.dwValueType = CERT_RDN_BMP_STRING;
	name_value.Value.cbData = 0;
	name_value.Value.pbData = (LPBYTE)(LPCTSTR)str;
	if (	CryptEncodeObject(CRYPT_ASN_ENCODING, X509_UNICODE_ANY_STRING,
										&name_value, NULL, &cb) 
		&&	blob.Resize(cb)
		&&	CryptEncodeObject(CRYPT_ASN_ENCODING, X509_UNICODE_ANY_STRING,
										&name_value, blob.GetData(), &cb) 
		)
	{
		bRes = TRUE;
	}
	else
		*phRes = HRESULT_FROM_WIN32(GetLastError());
	return bRes;
}

BOOL EncodeInteger(int number,CCryptBlob& blob,HRESULT * phRes)
{
	BOOL bRes = FALSE;
	DWORD cb;
	if (	CryptEncodeObject(CRYPT_ASN_ENCODING, X509_INTEGER,
										&number, NULL, &cb) 
		&&	blob.Resize(cb)
		&&	CryptEncodeObject(CRYPT_ASN_ENCODING, X509_INTEGER,
										&number, blob.GetData(), &cb) 
		)
	{
		bRes = TRUE;
	}
	else
		*phRes = HRESULT_FROM_WIN32(GetLastError());
	return bRes;
}

HCERTSTORE OpenRequestStore(IEnroll * pEnroll, HRESULT * phResult)
{
	ASSERT(NULL != phResult);
	HCERTSTORE hStore = NULL;
	WCHAR * bstrStoreName, * bstrStoreType;
	long dwStoreFlags;
	VERIFY(SUCCEEDED(pEnroll->get_RequestStoreNameWStr(&bstrStoreName)));
	VERIFY(SUCCEEDED(pEnroll->get_RequestStoreTypeWStr(&bstrStoreType)));
	VERIFY(SUCCEEDED(pEnroll->get_RequestStoreFlags(&dwStoreFlags)));
	size_t store_type_len = _tcslen(bstrStoreType);
	char * szStoreProvider = (char *)_alloca(store_type_len + 1);
	ASSERT(szStoreProvider != NULL);
	size_t n = wcstombs(szStoreProvider, bstrStoreType, store_type_len);
	szStoreProvider[n] = '\0';
	hStore = CertOpenStore(
		szStoreProvider,
      PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
		NULL,
		dwStoreFlags,
		bstrStoreName
		);
	CoTaskMemFree(bstrStoreName);
	CoTaskMemFree(bstrStoreType);
	if (hStore == NULL)
		*phResult = HRESULT_FROM_WIN32(GetLastError());
	return hStore;
}

BOOL CreateDirectoryFromPath(LPCTSTR szPath, LPSECURITY_ATTRIBUTES lpSA)
/*++

Routine Description:

    Creates the directory specified in szPath and any other "higher"
        directories in the specified path that don't exist.

Arguments:

    IN  LPCTSTR szPath
        directory path to create (assumed to be a DOS path, not a UNC)

    IN  LPSECURITY_ATTRIBUTES   lpSA
        pointer to security attributes argument used by CreateDirectory


Return Value:

    TRUE    if directory(ies) created
    FALSE   if error (GetLastError to find out why)

--*/
{
	LPTSTR pLeftHalf, pNext;
	CString RightHalf;
	// 1. We are supporting only absolute paths. Caller should decide which
	//		root to use and build the path
	if (PathIsRelative(szPath))
	{
		ASSERT(FALSE);
		return FALSE;
	}

	pLeftHalf = (LPTSTR)szPath;
	pNext = PathSkipRoot(pLeftHalf);

	do {
		// copy the chunk between pLeftHalf and pNext to the
		// local buffer
		while (pLeftHalf < pNext)
			RightHalf += *pLeftHalf++;
		// check if new path exists
		int index = RightHalf.GetLength() - 1;
		BOOL bBackslash = FALSE, bContinue = FALSE;
		if (bBackslash = (RightHalf[index] == L'\\'))
		{
			RightHalf.SetAt(index, 0);
		}
		bContinue = PathIsUNCServerShare(RightHalf);
		if (bBackslash)
			RightHalf.SetAt(index, L'\\');
		if (bContinue || PathIsDirectory(RightHalf))
			continue;
		else if (PathFileExists(RightHalf))
		{
			// we cannot create this directory 
			// because file with this name already exists
			SetLastError(ERROR_ALREADY_EXISTS);
			return FALSE;
		}
		else
		{
			// no file no directory, create
			if (!CreateDirectory(RightHalf, lpSA))
				return FALSE;
		}
	}
   while (NULL != (pNext = PathFindNextComponent(pLeftHalf)));
	return TRUE;
}

//+-------------------------------------------------------------------------
//  Returns pointer to allocated CERT_ALT_NAME_INFO by decoding either the
//  Subject or Issuer Alternative Extension. CERT_NAME_ISSUER_FLAG is
//  set to select the Issuer.
//
//  Returns NULL if extension not found or cAltEntry == 0
//--------------------------------------------------------------------------
static const LPCSTR rgpszSubjectAltOID[] = 
{
    szOID_SUBJECT_ALT_NAME2,
    szOID_SUBJECT_ALT_NAME
};
#define NUM_SUBJECT_ALT_OID (sizeof(rgpszSubjectAltOID) / sizeof(rgpszSubjectAltOID[0]))

void *AllocAndDecodeObject(
    IN DWORD dwCertEncodingType,
    IN LPCSTR lpszStructType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN DWORD dwFlags,
    OUT OPTIONAL DWORD *pcbStructInfo = NULL
    )
{
    DWORD cbStructInfo;
    void *pvStructInfo;

    if (!CryptDecodeObjectEx(
            dwCertEncodingType,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            dwFlags | CRYPT_DECODE_ALLOC_FLAG | CRYPT_DECODE_NOCOPY_FLAG,
            NULL,
            (void *) &pvStructInfo,
            &cbStructInfo
            ))
        goto ErrorReturn;

CommonReturn:
    if (pcbStructInfo)
    {
        *pcbStructInfo = cbStructInfo;
    }
    return pvStructInfo;

ErrorReturn:
    pvStructInfo = NULL;
    cbStructInfo = 0;
    goto CommonReturn;
}

PCERT_ALT_NAME_INFO AllocAndGetAltSubjectInfo(IN PCCERT_CONTEXT pCertContext)
{
    DWORD cAltOID;
    const LPCSTR *ppszAltOID;

    PCERT_EXTENSION pExt;
    PCERT_ALT_NAME_INFO pInfo;

    cAltOID = NUM_SUBJECT_ALT_OID;
    ppszAltOID = rgpszSubjectAltOID;
    
    // Try to find an alternative name extension
    pExt = NULL;
    for ( ; cAltOID > 0; cAltOID--, ppszAltOID++) 
    {
        if (pExt = CertFindExtension(*ppszAltOID,pCertContext->pCertInfo->cExtension,pCertContext->pCertInfo->rgExtension))
        {
            break;
        }
    }

    if (NULL == pExt)
    {
        return NULL;
    }

    if (NULL == (pInfo = (PCERT_ALT_NAME_INFO) AllocAndDecodeObject(pCertContext->dwCertEncodingType,X509_ALTERNATE_NAME,pExt->Value.pbData,pExt->Value.cbData,0)))
    {
        return NULL;
    }
    if (0 == pInfo->cAltEntry) 
    {
        LocalFree(pInfo);
        pInfo = NULL;
        return NULL;
    }
    else
    {
        return pInfo;
    }
}

//+-------------------------------------------------------------------------
//  Attempt to find the specified choice in the decoded alternative name
//  extension.
//--------------------------------------------------------------------------
BOOL GetAltNameUnicodeStringChoiceW(IN DWORD dwAltNameChoice,IN PCERT_ALT_NAME_INFO pAltNameInfo,OUT TCHAR **pcwszOut)
{
    DWORD cEntry;
    PCERT_ALT_NAME_ENTRY pEntry;

    if (NULL == pAltNameInfo)
    {
        return FALSE;
    }

    cEntry = pAltNameInfo->cAltEntry;
    pEntry = pAltNameInfo->rgAltEntry;
    for ( ; cEntry > 0; cEntry--, pEntry++) 
    {
        if (dwAltNameChoice == pEntry->dwAltNameChoice) 
        {
            // pwszRfc822Name union choice is the same as
            // pwszDNSName and pwszURL.

            // This is it, copy it out to a new allocation
            if (pEntry->pwszRfc822Name)
            {
                *pcwszOut = NULL;
				DWORD cbLen = sizeof(TCHAR) * (lstrlen(pEntry->pwszRfc822Name)+1);
                if(*pcwszOut = (TCHAR *) LocalAlloc(LPTR, cbLen))
                {
					StringCbCopy(*pcwszOut,cbLen,pEntry->pwszRfc822Name);
                    return TRUE;
                }
            }
        }
    }

    return FALSE;
}

BOOL GetStringProperty(PCCERT_CONTEXT pCertContext,DWORD propId,CString& str,HRESULT * phRes)
{
	BOOL bRes = FALSE;
	DWORD cb;
	BYTE * prop;
	// compare property value
	if (CertGetCertificateContextProperty(pCertContext, propId, NULL, &cb))
	{
		prop = (BYTE *) LocalAlloc(cb);
		if(NULL != prop)
		{
			if (CertGetCertificateContextProperty(pCertContext, propId, prop, &cb))
			{
				// decode this instance name property
				DWORD cbData = 0;
				void * pData = NULL;
				if (CryptDecodeObject(CRYPT_ASN_ENCODING, X509_UNICODE_ANY_STRING,prop, cb, 0, NULL, &cbData))
				{
					pData = LocalAlloc(cbData);
					if (NULL != pData)
					{
						if (CryptDecodeObject(CRYPT_ASN_ENCODING, X509_UNICODE_ANY_STRING,prop, cb, 0, pData, &cbData))
						{
							CERT_NAME_VALUE * pName = (CERT_NAME_VALUE *)pData;
							DWORD cch = pName->Value.cbData/sizeof(TCHAR);

							LPTSTR pValue = (LPTSTR) LocalAlloc(LPTR, (cch+1) * sizeof(TCHAR));
							memcpy(pValue, pName->Value.pbData, pName->Value.cbData);

							str = pValue;
							/*
							void * p = str.GetBuffer(cch);
							memcpy(p, pName->Value.pbData, pName->Value.cbData);
							str.ReleaseBuffer(cch);
							*/
							if (pValue)
							{
								LocalFree(pValue);pValue=NULL;
							}
							bRes = TRUE;
						}
						if (pData)
						{
							LocalFree(pData);
							pData = NULL;
						}
					}
				}
			}
			if (prop)
			{
				LocalFree(prop);
				prop=NULL;
			}
		}
	}
	if (!bRes)
	{
		*phRes = HRESULT_FROM_WIN32(GetLastError());
	}
	return bRes;
}

PCCERT_CONTEXT GetPendingDummyCert(const CString& inst_name,IEnroll * pEnroll,HRESULT * phRes)
{
	PCCERT_CONTEXT pRes = NULL;
	HCERTSTORE hStore = OpenRequestStore(pEnroll, phRes);
	if (hStore != NULL)
	{
		DWORD dwPropId = CERTWIZ_INSTANCE_NAME_PROP_ID;
		PCCERT_CONTEXT pDummyCert = NULL;
		while (NULL != (pDummyCert = CertFindCertificateInStore(hStore, 
													X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
													0, CERT_FIND_PROPERTY, 
													(LPVOID)&dwPropId, pDummyCert)))
		{
			CString str;
			if (GetStringProperty(pDummyCert, dwPropId, str, phRes))
			{
				if (str.CompareNoCase(inst_name) == 0)
				{
					pRes = pDummyCert;
					break;
				}
			}
		}
		CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
	}
	return pRes;
}


BOOL GetOnlineCAList(LISTCSTRING& list, const CString& certType, HRESULT * phRes)
{
    BOOL bRes = TRUE;
    HRESULT hr = S_OK;
    DWORD errBefore = GetLastError();
    DWORD dwCACount = 0;

    HCAINFO hCurCAInfo = NULL;
    HCAINFO hPreCAInfo = NULL;
   
    if(certType.IsEmpty())
    {
        return FALSE;
    }

    *phRes = CAFindByCertType(certType, NULL, 0, &hCurCAInfo);
    if (FAILED(*phRes) || NULL == hCurCAInfo)
    {
        if (S_OK == hr)
        {
            hr=E_FAIL;
        }
        return FALSE;
    }

    //get the CA count
    if (0 == (dwCACount = CACountCAs(hCurCAInfo)))
    {
        *phRes = E_FAIL;
        return FALSE;
    }
    WCHAR ** ppwstrName, ** ppwstrMachine;

    while (hCurCAInfo)
    {
        //get the CA information
        if (SUCCEEDED(CAGetCAProperty(hCurCAInfo, CA_PROP_DISPLAY_NAME, &ppwstrName))
            && SUCCEEDED(CAGetCAProperty(hCurCAInfo, CA_PROP_DNSNAME, &ppwstrMachine)))
        {
            CString config;
            config = *ppwstrMachine;
            config += L"\\";
            config += *ppwstrName;
            //list.AddTail(config);
            list.insert(list.end(),config);

            CAFreeCAProperty(hCurCAInfo, ppwstrName);
            CAFreeCAProperty(hCurCAInfo, ppwstrMachine);
        }
        else
        {
            bRes = FALSE;
            break;
        }

        hPreCAInfo = hCurCAInfo;
        if (FAILED(*phRes = CAEnumNextCA(hPreCAInfo, &hCurCAInfo)))
        {
            bRes = FALSE;
            break;
        }
        CACloseCA(hPreCAInfo);
        hPreCAInfo = NULL;
    }
   
   if (hPreCAInfo)
   {
      CACloseCA(hPreCAInfo);
   }
   if (hCurCAInfo)
   {
      CACloseCA(hCurCAInfo);
   }

   SetLastError(errBefore);

	return bRes;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certobj\certutil.h ===
#include "stdafx.h"
#include <certca.h>

#define CERTWIZ_INSTANCE_NAME_PROP_ID   (CERT_FIRST_USER_PROP_ID + 0x1000)
#define CERTWIZ_REQUEST_FLAG_PROP_ID   (CERT_FIRST_USER_PROP_ID + 0x1001)
#define CERTWIZ_REQUEST_TEXT_PROP_ID   (CERT_FIRST_USER_PROP_ID + 0x1002)


CERT_CONTEXT * GetInstalledCert(HRESULT * phResult, CString csKeyPath);
HRESULT ShutdownSSL(CString& server_name);
BOOL    InstallHashToMetabase(CRYPT_HASH_BLOB * pHash,BSTR InstanceName,HRESULT * phResult);
BOOL    AddChainToStore(HCERTSTORE hCertStore,PCCERT_CONTEXT pCertContext,DWORD cStores,HCERTSTORE * rghStores,BOOL fDontAddRootCert,CERT_TRUST_STATUS * pChainTrustStatus);
HRESULT UninstallCert(CString csInstanceName);
BOOL    TrustIsCertificateSelfSigned(PCCERT_CONTEXT pContext,DWORD dwEncoding, DWORD dwFlags);
HRESULT HereIsBinaryGimmieVtArray(DWORD cbBinaryBufferSize,char *pbBinaryBuffer,VARIANT * lpVarDestObject,BOOL bReturnBinaryAsVT_VARIANT);
HRESULT HereIsVtArrayGimmieBinary(VARIANT * lpVarSrcObject,DWORD * cbBinaryBufferSize,char **pbBinaryBuffer,BOOL bReturnBinaryAsVT_VARIANT);
void CertObj_LogError(void);
BOOL IsCertExportable(PCCERT_CONTEXT pCertContext);
BOOL GetCertDescriptionForRemote(PCCERT_CONTEXT pCert, LPWSTR *ppString, DWORD * cbReturn, BOOL fMultiline);
HRESULT CreateFolders(LPCTSTR ptszPathName, BOOL fHasFileName);
BOOL FormatDateString(LPWSTR * pszReturn, FILETIME ft, BOOL fIncludeTime, BOOL fLongFormat);
#define FAILURE                                                     0
#define DID_NOT_FIND_CONSTRAINT                                     1
#define FOUND_CONSTRAINT_BUT_THIS_IS_A_CA_OR_ITS_NOT_AN_END_ENTITY  2
#define FOUND_CONSTRAINT                                            3
int CheckCertConstraints(PCCERT_CONTEXT pCC);
INT ContainsKeyUsageProperty(PCCERT_CONTEXT pCertContext,LPCSTR rgbpszUsageArray[],DWORD dwUsageArrayCount,HRESULT * phRes);
BOOL CanIISUseThisCertForServerAuth(PCCERT_CONTEXT pCC);

#ifdef USE_CERT_REQUEST_OBJECT
    using namespace std ;
    typedef list<CString> LISTCSTRING;

    HRESULT CreateRequest_Base64(const BSTR bstr_dn, IEnroll * pEnroll, BSTR csp_name,DWORD csp_type,BSTR * pOut);
    PCCERT_CONTEXT GetCertContextFromPKCS7(const BYTE * pbData,DWORD cbData,CERT_PUBLIC_KEY_INFO * pKeyInfo,HRESULT * phResult);
    BOOL AttachFriendlyName(PCCERT_CONTEXT pContext, const CString& name,HRESULT * phRes);
    BOOL InstallHashToMetabase(CRYPT_HASH_BLOB * pHash,const CString& machine_name, const CString& server_name,HRESULT * phResult);
    PCCERT_CONTEXT GetInstalledCert(const CString& machine_name, const CString& server_name,IEnroll * pEnroll,HRESULT * phResult);
    void FormatRdnAttr(CString& str, DWORD dwValueType, CRYPT_DATA_BLOB& blob, BOOL fAppend);
    BOOL GetNameString(PCCERT_CONTEXT pCertContext,DWORD type,DWORD flag,CString& name,HRESULT * phRes);
    BOOL FormatDateString(CString& str,FILETIME ft,BOOL fIncludeTime,BOOL fLongFormat);
    BOOL FormatEnhancedKeyUsageString(CString& str,PCCERT_CONTEXT pCertContext,BOOL fPropertiesOnly,BOOL fMultiline,HRESULT * phRes);
    BOOL FormatEnhancedKeyUsageString(LPWSTR * pszReturn, PCCERT_CONTEXT pCertContext, BOOL fPropertiesOnly);
    BOOL GetFriendlyName(PCCERT_CONTEXT pCertContext,CString& name,HRESULT * phRes);
    BOOL GetAlternateSubjectName(PCCERT_CONTEXT pCertContext,TCHAR ** cwszOut);
    BOOL GetRequestInfoFromPKCS10(CCryptBlob& pkcs10, PCERT_REQUEST_INFO * pReqInfo,HRESULT * phRes);
    BOOL EncodeString(CString& str,CCryptBlob& blob,HRESULT * phRes);
    BOOL EncodeInteger(int number,CCryptBlob& blob,HRESULT * phRes);
    HCERTSTORE OpenRequestStore(IEnroll * pEnroll, HRESULT * phResult);
    BOOL CreateDirectoryFromPath(LPCTSTR szPath, LPSECURITY_ATTRIBUTES lpSA);
    PCERT_ALT_NAME_INFO AllocAndGetAltSubjectInfo(IN PCCERT_CONTEXT pCertContext);
    BOOL GetAltNameUnicodeStringChoiceW(IN DWORD dwAltNameChoice,IN PCERT_ALT_NAME_INFO pAltNameInfo,OUT TCHAR **pcwszOut);
    BOOL GetAlternateSubjectName(PCCERT_CONTEXT pCertContext,TCHAR ** cwszOut);
    PCCERT_CONTEXT GetPendingDummyCert(const CString& inst_name,IEnroll * pEnroll,HRESULT * phRes);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certobj\certobjlog.cpp ===
#include "stdafx.h"
#include "CertObj.h"
#include "common.h"
#include "certobjlog.h"
#include <strsafe.h>

HANDLE g_hEventLog = NULL;

// #define EVENTLOG_SUCCESS                0x0000
// #define EVENTLOG_ERROR_TYPE             0x0001
// #define EVENTLOG_WARNING_TYPE           0x0002
// #define EVENTLOG_INFORMATION_TYPE       0x0004
// #define EVENTLOG_AUDIT_SUCCESS          0x0008
// #define EVENTLOG_AUDIT_FAILURE          0x0010

void EventlogReportEvent
(
    WORD wType, 
    DWORD dwEventID, 
    LPCTSTR pFormat, 
    ...
)
{
    TCHAR    chMsg[256];
    HANDLE  hEventSource;
    LPTSTR  lpszStrings[1];
    va_list	pArg;

    va_start(pArg, pFormat);
    //_vstprintf(chMsg, pFormat, pArg);
	StringCbVPrintf(chMsg,sizeof(chMsg),pFormat, pArg);
    va_end(pArg);

    lpszStrings[0] = chMsg;

    if (g_hEventLog != NULL)
    {
        ReportEvent(g_hEventLog, wType, 0, dwEventID, NULL, 1, 0, (LPCTSTR*) &lpszStrings[0], NULL);
    }
}

BOOL EventlogRegistryInstall(void)
{
    HKEY    hKey;
    int     err;
    DWORD   disp;

    //
    // Create registry entries, whether event logging is currently
    // enabled or not.
    //
    err = RegCreateKeyEx(   HKEY_LOCAL_MACHINE,
                            TEXT("System\\CurrentControlSet\\Services\\EventLog\\System\\CertObj"),
                            0,
                            TEXT(""),
                            REG_OPTION_NON_VOLATILE,
                            KEY_WRITE,
                            NULL,
                            &hKey,
                            &disp);
    if (err)
    {
        return(FALSE);
    }

    if (disp == REG_CREATED_NEW_KEY)
    {
        RegSetValueEx(  hKey,
                        TEXT("EventMessageFile"),
                        0,
                        REG_EXPAND_SZ,
                        (PBYTE) TEXT("%SystemRoot%\\system32\\inetsrv\\certobj.dll"),
                        sizeof(TEXT("%SystemRoot%\\system32\\inetsrv\\certobj.dll")));

        // disp = 7;
        disp = EVENTLOG_ERROR_TYPE          |
                    EVENTLOG_WARNING_TYPE   |
                    EVENTLOG_INFORMATION_TYPE ;
        
        RegSetValueEx(  hKey,
                        TEXT("TypesSupported"),
                        0,
                        REG_DWORD,
                        (PBYTE) &disp,
                        sizeof(DWORD) );

        RegFlushKey(hKey);
    }

    RegCloseKey(hKey);

    return(TRUE);
}

void EventlogRegistryUnInstall(void)
{
    HKEY hKey;
    DWORD dwStatus;
    TCHAR szBuf[MAX_PATH*2+1];

    // remove event source out of application and system
	StringCbPrintf(szBuf,sizeof(szBuf),_TEXT("SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application"));
    if((dwStatus=RegOpenKeyEx(HKEY_LOCAL_MACHINE, szBuf, 0, KEY_ALL_ACCESS, &hKey)) != ERROR_SUCCESS)
    {
        return;
    }

    RegDeleteKey(hKey, _T("CertObj"));
    RegCloseKey(hKey);

	StringCbPrintf(szBuf,sizeof(szBuf),_TEXT("SYSTEM\\CurrentControlSet\\Services\\EventLog\\System"));
    if((dwStatus=RegOpenKeyEx(HKEY_LOCAL_MACHINE, szBuf, 0, KEY_ALL_ACCESS, &hKey)) != ERROR_SUCCESS)
    {
        return;
    }

    RegDeleteKey(hKey, _T("CertObj"));
    RegCloseKey(hKey);

    return;
}

void EventLogInit(void)
{
    g_hEventLog = RegisterEventSource( NULL, L"CertObj" );
    return;
}

void EventLogCleanup(void)
{
    if ( g_hEventLog != NULL )
    {
        DeregisterEventSource( g_hEventLog );
        g_hEventLog = NULL;
    }
    return;
}

void ReportIt(DWORD dwEventID, LPCTSTR szMetabasePath)
{
    if (!g_hEventLog){EventLogInit();}

    switch (dwEventID) 
    {
        case CERTOBJ_CERT_EXPORT_SUCCEED:
            EventlogReportEvent(EVENTLOG_INFORMATION_TYPE, dwEventID, szMetabasePath);
            break;
        case CERTOBJ_CERT_EXPORT_FAILED:
            EventlogReportEvent(EVENTLOG_INFORMATION_TYPE, dwEventID, szMetabasePath);
            break;

        case CERTOBJ_CERT_IMPORT_SUCCEED:
            EventlogReportEvent(EVENTLOG_INFORMATION_TYPE, dwEventID, szMetabasePath);
            break;
        case CERTOBJ_CERT_IMPORT_FAILED:
            EventlogReportEvent(EVENTLOG_INFORMATION_TYPE, dwEventID, szMetabasePath);
            break;

        case CERTOBJ_CERT_IMPORT_CERT_STORE_SUCCEED:
            EventlogReportEvent(EVENTLOG_INFORMATION_TYPE, dwEventID, szMetabasePath);
            break;
        case CERTOBJ_CERT_IMPORT_CERT_STORE_FAILED:
            EventlogReportEvent(EVENTLOG_INFORMATION_TYPE, dwEventID, szMetabasePath);
            break;

        case CERTOBJ_CERT_REMOVE_SUCCEED:
            EventlogReportEvent(EVENTLOG_INFORMATION_TYPE, dwEventID, szMetabasePath);
            break;
        case CERTOBJ_CERT_REMOVE_FAILED:
            EventlogReportEvent(EVENTLOG_INFORMATION_TYPE, dwEventID, szMetabasePath);
            break;

        default:
             break;

    }
    if (g_hEventLog) {EventLogCleanup();}
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certobj\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__89EF842D_58E5_4014_9FF4_3C845E2C78F3__INCLUDED_)
#define AFX_DLLDATAX_H__89EF842D_58E5_4014_9FF4_3C845E2C78F3__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__89EF842D_58E5_4014_9FF4_3C845E2C78F3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certobj\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "CertObj_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certobj\iisdebug.cpp ===
#include "stdafx.h"

INT g_iDebugOutputLevel = 0;

void GetOutputDebugFlag(void)
{
    DWORD rc, err, size, type;
    HKEY  hkey;
    err = RegOpenKey(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\InetMgr"), &hkey);
    if (err != ERROR_SUCCESS) {return;}
    size = sizeof(DWORD);
    err = RegQueryValueEx(hkey,_T("OutputDebugFlag"),0,&type,(LPBYTE)&rc,&size);
    if (err != ERROR_SUCCESS || type != REG_DWORD) {rc = 0;}
    RegCloseKey(hkey);

	if (rc < 0xffffffff)
	{
		g_iDebugOutputLevel = rc;
	}
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certobj\iisdebug.h ===
#include "stdafx.h"
#include "debugdefs.h"

extern g_iDebugOutputLevel;

#if defined(_DEBUG) || DBG
	#define DEBUG_FLAG
#endif

#ifdef DEBUG_FLAG
    inline void _cdecl DebugTrace(LPTSTR lpszFormat, ...)
    {
        // Only do this if the flag is set.
        if (0 != g_iDebugOutputLevel)
        {
			if (DEBUG_FLAG_MODULE_CERTOBJ & g_iDebugOutputLevel)
			{
				int nBuf;
				TCHAR szBuffer[_MAX_PATH];
				va_list args;
				va_start(args, lpszFormat);

				nBuf = _vsntprintf(szBuffer, sizeof(szBuffer)/sizeof(szBuffer[0]), lpszFormat, args);

				OutputDebugString(szBuffer);
				va_end(args);

				// if it does not end if '\r\n' then make one.
				int nLen = _tcslen(szBuffer);
				if (szBuffer[nLen-1] != _T('\n')){OutputDebugString(_T("\r\n"));}
			}
        }
    }
#else
    inline void _cdecl DebugTrace(LPTSTR , ...){}
	inline void _cdecl DebugTraceA(LPTSTR , ...){}
#endif

void GetOutputDebugFlag(void);

#define IISDebugOutput DebugTrace
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certobj\password.h ===
#include "stdafx.h"

DWORD  CreateGoodPassword(BYTE *szPwd,DWORD dwLen);
LPTSTR CreatePassword(int iSize);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certobj\iiscertrequest.h ===
// IISCertRequest.h : Declaration of the CIISCertRequest

#ifndef __IISCERTREQUEST_H_
#define __IISCERTREQUEST_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CIISCertRequest
#ifdef USE_CERT_REQUEST_OBJECT


#define CERT_HASH_LENGTH		40

typedef struct _CERT_DESCRIPTION
{
    int iStructVersion;
	CString m_Info_CommonName;
	CString m_Info_FriendlyName;
	CString m_Info_Country;
	CString m_Info_State;
	CString m_Info_Locality;
	CString m_Info_Organization;
	CString m_Info_OrganizationUnit;
	CString m_Info_CAName;
	CString m_Info_ExpirationDate;
	CString m_Info_Usage;
    CString m_Info_AltSubject;
	BYTE m_Info_hash[CERT_HASH_LENGTH];
	DWORD m_Info_hash_length;
} CERT_DESCRIPTION;

class ATL_NO_VTABLE CIISCertRequest : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CIISCertRequest, &CLSID_IISCertRequest>,
	public IDispatchImpl<IIISCertRequest, &IID_IIISCertRequest, &LIBID_CERTOBJLib>
{
public:
	CIISCertRequest();
	~CIISCertRequest();


DECLARE_REGISTRY_RESOURCEID(IDR_IISCERTREQUEST)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CIISCertRequest)
	COM_INTERFACE_ENTRY(IIISCertRequest)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IIISCertRequest
public:
	STDMETHOD(Info_Dump)();
	STDMETHOD(put_ServerName)(/*[in]*/ BSTR newVal);
    STDMETHOD(put_UserName)(/*[in]*/ BSTR newVal);
    STDMETHOD(put_UserPassword)(/*[in]*/ BSTR newVal);
    STDMETHOD(put_InstanceName)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Info_CommonName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Info_CommonName)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Info_FriendlyName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Info_FriendlyName)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Info_Country)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Info_Country)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Info_State)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Info_State)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Info_Locality)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Info_Locality)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Info_Organization)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Info_Organization)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Info_OrganizationUnit)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Info_OrganizationUnit)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Info_CAName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Info_CAName)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Info_ExpirationDate)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Info_ExpirationDate)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Info_Usage)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Info_Usage)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Info_AltSubject)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Info_AltSubject)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_DispositionMessage)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_DispositionMessage)(/*[in]*/ BSTR newVal);
    STDMETHOD(SubmitRequest)();
    STDMETHOD(SubmitRenewalRequest)();
    STDMETHOD(SaveRequestToFile)();

private:
    // Connection Info
    CString m_ServerName;
    CString m_UserName;
    CString m_UserPassword;
    CString m_InstanceName;

    // Certificate Request Info
	CString m_Info_CommonName;
	CString m_Info_FriendlyName;
	CString m_Info_Country;
	CString m_Info_State;
	CString m_Info_Locality;
	CString m_Info_Organization;
	CString m_Info_OrganizationUnit;
	CString m_Info_CAName;
	CString m_Info_ExpirationDate;
	CString m_Info_Usage;
    CString m_Info_AltSubject;

    // other
    CString	m_Info_ConfigCA;
    CString	m_Info_CertificateTemplate;
    DWORD   m_Info_DefaultProviderType;
    DWORD   m_Info_CustomProviderType;
    BOOL    m_Info_DefaultCSP;
    CString m_Info_CspName;

    DWORD   m_KeyLength;
    BOOL m_SGCcertificat;

    // other
    PCCERT_CONTEXT m_pInstalledCert;
    CString m_ReqFileName;

    // holds last hresult
    HRESULT m_hResult;
    CString m_DispositionMessage;

    //
    BOOL LoadRenewalData();
    BOOL GetCertDescription(PCCERT_CONTEXT pCert,CERT_DESCRIPTION& desc);
    BOOL SetSecuritySettings();

    BOOL PrepareRequestString(CString& request_text, CCryptBlob& request_blob, BOOL bLoadFromRenewalData);
    BOOL WriteRequestString(CString& request);

    PCCERT_CONTEXT GetInstalledCert();
    PCCERT_CONTEXT GetPendingRequest();
    HRESULT CreateDN(CString& str);
    void GetCertificateTemplate(CString& str);
    CComPtr<IIISCertRequest> m_pObj;
    IIISCertRequest * GetObject(HRESULT * phr);
    IIISCertRequest * GetObject(HRESULT * phr, CString csServerName,CString csUserName OPTIONAL,CString csUserPassword OPTIONAL);
    IEnroll * GetEnrollObject();

protected:
    PCCERT_CONTEXT m_pPendingRequest;
    IEnroll * m_pEnroll;
    int m_status_code;				// what we are doing in this session
};

#endif
#endif //__IISCERTREQUEST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certobj\iiscertobj.cpp ===
// IISCertObj.cpp : Implementation of CIISCertObj
#include "stdafx.h"
#include "common.h"
#include "CertObj.h"
#include "IISCertObj.h"
#include "base64.h"
#include "password.h"
#include "certutil.h"
#include "certobjlog.h"
#include "certlog.h"
#include "cryptpass.h"
#include "process.h"
#include <Sddl.h> // ConvertStringSecurityDescriptorToSecurityDescriptor
#include <strsafe.h>
#include <memory>

#define TEMP_PASSWORD_LENGTH          50
#define MAX_CERTIFICATE_BYTE_SIZE 500000

// Checks a pointer which should be non NULL - can be used as follows.
#define CheckPointer(p,ret){if((p)==NULL) return (ret);}
//
//   HRESULT Foo(VOID *pBar)
//   {
//       CheckPointer(pBar,E_INVALIDARG)
//   }
//
//   Or if the function returns a boolean
//
//   BOOL Foo(VOID *pBar)
//   {
//       CheckPointer(pBar,FALSE)
//   }

HRESULT ValidateBSTRIsntNULL(BSTR pbstrString)
{
    if( !pbstrString ) return E_INVALIDARG;
    if( pbstrString[0] == 0 ) return E_INVALIDARG;
    return NOERROR;
}

void CIISCertObj::AddRemoteInterface(IIISCertObj * pAddMe)
{
	// Increment count so we can release if we get unloaded...
	for (int i = 0; i < NUMBER_OF_AUTOMATION_INTERFACES; i++)
	{
		if (NULL == m_ppRemoteInterfaces[i])
		{
			m_ppRemoteInterfaces[i] = pAddMe;
			m_RemoteObjCoCreateCount++;
			break;
		}
	}
	return;
}

void CIISCertObj::DelRemoteInterface(IIISCertObj * pRemoveMe)
{
	// Increment count so we can release if we get unloaded...
	for (int i = 0; i < NUMBER_OF_AUTOMATION_INTERFACES; i++)
	{
		if (pRemoveMe == m_ppRemoteInterfaces[i])
		{
			m_ppRemoteInterfaces[i] = NULL;
			m_RemoteObjCoCreateCount--;
			break;
		}
	}
}

void CIISCertObj::FreeRemoteInterfaces(void)
{
	ASSERT(m_RemoteObjCoCreateCount == 0);
	if (m_RemoteObjCoCreateCount > 0)
	{
		// We should really never get here...
		// Uh, this should be 0, otherwise we probably
		// faild to Release a CoCreated interface..
		IISDebugOutput(_T("FreeRemoteInterfaces:WARNING:m_RemoteObjCoCreateCount=%d\r\n"),m_RemoteObjCoCreateCount);
		for (int i = 0; i < NUMBER_OF_AUTOMATION_INTERFACES; i++)
		{
			if (m_ppRemoteInterfaces[i])
			{
				if (m_ppRemoteInterfaces[i] != this)
				{
					m_ppRemoteInterfaces[i]->Release();
					m_ppRemoteInterfaces[i] = NULL;
				}
			}
		}
		delete[] m_ppRemoteInterfaces;
		m_RemoteObjCoCreateCount = 0;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CIISCertObj
STDMETHODIMP CIISCertObj::put_ServerName(BSTR newVal)
{
	IISDebugOutput(_T("put_ServerName\r\n"));
	HRESULT hr = S_OK;
    if(FAILED(hr = ValidateBSTRIsntNULL(newVal))){return hr;}
    
	// buffer overflow paranoia, make sure it's less than 255 characters long
    if (wcslen(newVal) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}

	m_ServerName = newVal;

	if (m_ServerName.m_str)
	{
		if (IsServerLocal(m_ServerName))
			{m_ServerName.Empty();}
	}
	else
	{
		// make sure it's empty
		m_ServerName.Empty();
	}

    return S_OK;
}

STDMETHODIMP CIISCertObj::put_UserName(BSTR newVal)
{
	IISDebugOutput(_T("put_UserName\r\n"));
	HRESULT hr = S_OK;
    if(FAILED(hr = ValidateBSTRIsntNULL(newVal))){return hr;}

    // buffer overflow paranoia, make sure it's less than 255 characters long
    if (wcslen(newVal) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}

	m_UserName = newVal;
    return S_OK;
}

STDMETHODIMP CIISCertObj::put_UserPassword(BSTR newVal)
{
	IISDebugOutput(_T("put_UserPassword\r\n"));
	HRESULT hr = S_OK;
    if(FAILED(hr = ValidateBSTRIsntNULL(newVal))){return hr;}

    // buffer overflow paranoia, make sure it's less than 255 characters long
    if (wcslen(newVal) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}

	// check if there was a previous value
	// if there was, then free it.
	if (m_lpwszUserPasswordEncrypted)
	{
		if (m_cbUserPasswordEncrypted > 0)
		{
			SecureZeroMemory(m_lpwszUserPasswordEncrypted,m_cbUserPasswordEncrypted);
		}
		LocalFree(m_lpwszUserPasswordEncrypted);
	}

	m_lpwszUserPasswordEncrypted = NULL;
	m_cbUserPasswordEncrypted = 0;

	// encrypt the password in memory (CryptProtectMemory)
	// this way if the process get's paged out to the swapfile,
	// the password won't be in clear text.
	if (FAILED(EncryptMemoryPassword(newVal,&m_lpwszUserPasswordEncrypted,&m_cbUserPasswordEncrypted)))
	{
		return E_FAIL;
	}

	return S_OK;
}

STDMETHODIMP CIISCertObj::put_InstanceName(BSTR newVal)
{
	IISDebugOutput(_T("put_InstanceName\r\n"));
	HRESULT hr = S_OK;
    if(FAILED(hr = ValidateBSTRIsntNULL(newVal))){return hr;}

    // buffer overflow paranoia, make sure it's less than 255 characters long
    if (wcslen(newVal) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}

	m_InstanceName = newVal;
	return S_OK;
}

IIISCertObj * 
CIISCertObj::GetObject(HRESULT * phr)
{
	IIISCertObj * pObj = NULL;
	if (NULL == phr){return NULL;}

	// decrypt before sending to this function...
	LPWSTR p = NULL;
	if (m_lpwszUserPasswordEncrypted)
	{
		*phr = DecryptMemoryPassword((LPWSTR) m_lpwszUserPasswordEncrypted,
			&p, m_cbUserPasswordEncrypted);
		if (FAILED(*phr))
		{
			return NULL;
		}
		pObj = GetObject(phr,m_ServerName,m_UserName,p);
	}
	else
	{
		pObj = GetObject(phr,m_ServerName,m_UserName,_T(""));
	}
    

	// clean up temporary password
	if (p)
	{
		// security percaution:Make sure to zero out memory that temporary password was used for.
		SecureZeroMemory(p, m_cbUserPasswordEncrypted);
		LocalFree(p);
		p = NULL;
	}
    return pObj;
}

IIISCertObj * 
CIISCertObj::GetObject(
	HRESULT * phr,
	CComBSTR csServerName,
	CComBSTR csUserName,
	CComBSTR csUserPassword
	)
{
	IISDebugOutput(_T("GetObject\r\n"));
	IIISCertObj * pObjRemote = NULL;
	
	pObjRemote = this;

    if (0 == csServerName.Length())
    {
        // object is null, but it's the local machine, so just return back this pointer
        return this;
    }

    // There is a servername specified...
    // check if it's the local machine that was specified!
    if (IsServerLocal(csServerName))
    {
		return this;
    }
    else
    {
        // there is a remote servername specified

		// Check if we are already remoted.
		// cannot allow remotes to remote to other machines, this
		// could be some kind of security hole.
		if (AmIAlreadyRemoted())
		{
			IISDebugOutput(_T("GetObject:FAIL:Line=%d,Remote object cannot create another remote object\r\n"),__LINE__);
			*phr = HRESULT_FROM_WIN32(ERROR_REMOTE_SESSION_LIMIT_EXCEEDED);
			return NULL;
		}

        // let's see if the machine has the com object that we want....
        // we are using the user/name password that are in this object
        // so were probably on the local machine
        CComAuthInfo auth(csServerName,csUserName,csUserPassword);
        // RPC_C_AUTHN_LEVEL_DEFAULT       0 
        // RPC_C_AUTHN_LEVEL_NONE          1 
        // RPC_C_AUTHN_LEVEL_CONNECT       2 
        // RPC_C_AUTHN_LEVEL_CALL          3 
        // RPC_C_AUTHN_LEVEL_PKT           4 
        // RPC_C_AUTHN_LEVEL_PKT_INTEGRITY 5 
        // RPC_C_AUTHN_LEVEL_PKT_PRIVACY   6 
        COSERVERINFO * pcsiName = auth.CreateServerInfoStruct(RPC_C_AUTHN_LEVEL_PKT_PRIVACY);

        MULTI_QI res[1] = 
        {
            {&__uuidof(IIISCertObj), NULL, 0}
        };

        // Try to instantiante the object on the remote server...
        // with the supplied authentication info (pcsiName)
        //#define CLSCTX_SERVER    (CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER)
        //#define CLSCTX_ALL       (CLSCTX_INPROC_HANDLER | CLSCTX_SERVER)
        //if (NULL == pcsiName){IISDebugOutput(_T("CIISCertObj::GetObject:pcsiName=NULL failed!!!\n"));}
 
        // this one seems to work with surrogates..
        *phr = CoCreateInstanceEx(CLSID_IISCertObj,NULL,CLSCTX_LOCAL_SERVER,pcsiName,1,res);
        if (FAILED(*phr))
        {
            IISDebugOutput(_T("CIISCertObj::GetObject:CoCreateInstanceEx failed:0x%x, csServerName=%s,csUserName=%s\n"),
				*phr,(LPCTSTR) csServerName,(LPCTSTR) csUserName);
            goto GetObject_Exit;
        }

        // at this point we were able to instantiate the com object on the server (local or remote)
        pObjRemote = (IIISCertObj *)res[0].pItf;

        if (auth.UsesImpersonation())
        {
            *phr = auth.ApplyProxyBlanket(pObjRemote,RPC_C_AUTHN_LEVEL_PKT_PRIVACY);

            // There is a remote IUnknown Interface that lurks behind IUnknown.
            // If that is not set, then the Release call can return access denied.
            IUnknown * pUnk = NULL;
            if(FAILED(pObjRemote->QueryInterface(IID_IUnknown, (void **)&pUnk)))
            {
				// Don't pass back an invalid pointer
				IISDebugOutput(_T("GetObject:FAIL:Line=%d\r\n"),__LINE__);
				pObjRemote->Release();pObjRemote=NULL;
                goto GetObject_Exit;
            }
            if (FAILED(auth.ApplyProxyBlanket(pUnk,RPC_C_AUTHN_LEVEL_PKT_PRIVACY)))
            {
				// Don't pass back an invalid pointer
				pObjRemote->Release();pObjRemote=NULL;
				if (pUnk)
				{
					pUnk->Release();pUnk = NULL;
				}
				IISDebugOutput(_T("GetObject:FAIL:Line=%d\r\n"),__LINE__);
                goto GetObject_Exit;
            }
            pUnk->Release();pUnk = NULL;
        }
        auth.FreeServerInfoStruct(pcsiName);

		if (pObjRemote)
		{
			AddRemoteInterface(pObjRemote);
		}
    }

GetObject_Exit:
    return pObjRemote;
}


STDMETHODIMP 
CIISCertObj::IsInstalled(VARIANT_BOOL * retval)
{
	IISDebugOutput(_T("IsInstalled\r\n"));
	CheckPointer(retval, E_POINTER);
    HRESULT hr = S_OK;

	if (0 == m_ServerName.Length())
    {
        hr = IsInstalledRemote(retval);
    }
    else
    {
		if (!m_InstanceName)
		{
			return E_INVALIDARG;
		}

        //ASSERT(GetObject(&hr) != NULL);
        IIISCertObj * pObj;
        if (NULL != (pObj = GetObject(&hr)))
        {
			// For some reason we need to SysAllocString these instance names
			// if not com will AV when marshalling...

			// don't need to free _bstr_t
			_bstr_t bstrInstName(m_InstanceName);
            if (SUCCEEDED(hr = pObj->put_InstanceName(bstrInstName)))
            {
                hr = pObj->IsInstalledRemote(retval);
            }

			// release remote object
			if (pObj != NULL)
			{
				if (pObj != this)
				{
					DelRemoteInterface(pObj);
					pObj->Release();pObj=NULL;
				}
			}
        }
    }
    return hr;
}


STDMETHODIMP 
CIISCertObj::IsInstalledRemote(VARIANT_BOOL * retval)
{
	IISDebugOutput(_T("IsInstalledRemote\r\n"));
	CheckPointer(retval, E_POINTER);
    CERT_CONTEXT * pCertContext = NULL;
    HRESULT hr = S_OK;

	if (!m_InstanceName)
	{
		return E_INVALIDARG;
	}

    pCertContext = GetInstalledCert(&hr, m_InstanceName);
    if (FAILED(hr) || NULL == pCertContext)
    {
        *retval = VARIANT_FALSE;
    }
    else
    {
        *retval = VARIANT_TRUE;
        CertFreeCertificateContext(pCertContext);
    }
    return S_OK;
}

STDMETHODIMP 
CIISCertObj::IsExportable(VARIANT_BOOL * retval)
{
	IISDebugOutput(_T("IsExportable\r\n"));
	CheckPointer(retval, E_POINTER);
    HRESULT hr = S_OK;

    if (0 == m_ServerName.Length())
    {
        hr = IsExportableRemote(retval);
    }
    else
    {
		if (!m_InstanceName)
		{
			return E_INVALIDARG;
		}

        //ASSERT(GetObject(&hr) != NULL);
        IIISCertObj * pObj = NULL;

        if (NULL != (pObj = GetObject(&hr)))
        {
			// For some reason we need to SysAllocString these instance names
			// if not com will AV when marshalling...
			// don't need to free _bstr_t
			_bstr_t bstrInstName(m_InstanceName);
            hr = pObj->put_InstanceName(bstrInstName);
            if (SUCCEEDED(hr))
            {
                hr = pObj->IsExportableRemote(retval);
            }

			// release remote object
			if (pObj != NULL)
			{
				if (pObj != this)
				{
					DelRemoteInterface(pObj);
					pObj->Release();pObj=NULL;
				}
			}
        }
    }
    return hr;
}

STDMETHODIMP 
CIISCertObj::IsExportableRemote(VARIANT_BOOL * retval)
{
	IISDebugOutput(_T("IsExportableRemote\r\n"));
	CheckPointer(retval, E_POINTER);
    HRESULT hr = S_OK;

	if (!m_InstanceName)
	{
		return E_INVALIDARG;
	}

    CERT_CONTEXT * pCertContext = GetInstalledCert(&hr, m_InstanceName);
    if (FAILED(hr) || NULL == pCertContext)
    {
        *retval = VARIANT_FALSE;
    }
    else
    {
        // check if it's exportable!
        if (IsCertExportable(pCertContext))
        {
            *retval = VARIANT_TRUE;
        }
        else
        {
            *retval = VARIANT_FALSE;
        }
        
    }
    if (pCertContext) 
    {
        CertFreeCertificateContext(pCertContext);
    }
    return S_OK;
}

STDMETHODIMP 
CIISCertObj::GetCertInfo(VARIANT * pVtArray)
{
	IISDebugOutput(_T("GetCertInfo\r\n"));
	CheckPointer(pVtArray, E_POINTER);
    HRESULT hr = S_OK;

    if (0 == m_ServerName.Length())
    {
        hr = GetCertInfoRemote(pVtArray);
    }
    else
    {
		if (!m_InstanceName)
		{
			return E_INVALIDARG;
		}

        //ASSERT(GetObject(&hr) != NULL);
        IIISCertObj * pObj;

        if (NULL != (pObj = GetObject(&hr)))
        {
			// For some reason we need to SysAllocString these instance names
			// if not com will AV when marshalling...
			// don't need to free _bstr_t
			_bstr_t bstrInstName(m_InstanceName);
            hr = pObj->put_InstanceName(bstrInstName);
            if (SUCCEEDED(hr))
            {
                hr = pObj->GetCertInfoRemote(pVtArray);
            }

			// release remote object
			if (pObj != NULL)
			{
				if (pObj != this)
				{
					DelRemoteInterface(pObj);
					pObj->Release();pObj=NULL;
				}
			}
        }
    }
    return hr;
}

STDMETHODIMP 
CIISCertObj::GetCertInfoRemote(
	VARIANT * pVtArray
	)
{
	IISDebugOutput(_T("GetCertInfoRemote\r\n"));
	CheckPointer(pVtArray, E_POINTER);
    HRESULT hr = S_OK;

	if (!m_InstanceName)
	{
		return E_INVALIDARG;
	}

    CERT_CONTEXT * pCertContext = GetInstalledCert(&hr, m_InstanceName);
    if (FAILED(hr) || NULL == pCertContext)
    {
        hr = S_FALSE;
    }
    else
    {
        DWORD cb = 0;
        LPWSTR pwszText = NULL;
        if (TRUE == GetCertDescriptionForRemote(pCertContext,&pwszText,&cb,TRUE))
        {
            hr = S_OK;
            hr = HereIsBinaryGimmieVtArray(cb * sizeof(WCHAR),(char *) pwszText,pVtArray,FALSE);
        }
        else
        {
            hr = S_FALSE;
        }
    }
    if (pCertContext) 
    {
        CertFreeCertificateContext(pCertContext);
    }
    return hr;
}

STDMETHODIMP 
CIISCertObj::RemoveCert(
	VARIANT_BOOL bRemoveFromCertStore, 
	VARIANT_BOOL bPrivateKey
	)
{
	IISDebugOutput(_T("RemoveCert\r\n"));
    HRESULT hr = E_FAIL;
    PCCERT_CONTEXT pCertContext = NULL;
    DWORD cbKpi = 0;
    PCRYPT_KEY_PROV_INFO pKpi = NULL ;
    HCRYPTPROV hCryptProv = NULL;
    BOOL bPleaseLogFailure = FALSE;

	if (!m_InstanceName)
	{
		return E_INVALIDARG;
	}

    // get the certificate from the server
    if (NULL != (pCertContext = GetInstalledCert(&hr, m_InstanceName)))
    {
        do
        {
            // VARIANT_TRUE is passed when invoked from VB!  Make sure to check that too!
            if (TRUE == bRemoveFromCertStore || VARIANT_TRUE == bRemoveFromCertStore )
            {
                bPleaseLogFailure = TRUE;
                if (!CertGetCertificateContextProperty(pCertContext, 
					    CERT_KEY_PROV_INFO_PROP_ID, NULL, &cbKpi)
				    ) 
                {
                    break;
                }
                PCRYPT_KEY_PROV_INFO pKpi = (PCRYPT_KEY_PROV_INFO)malloc(cbKpi);
                if (NULL == pKpi)
                {
                    ::SetLastError(ERROR_NOT_ENOUGH_MEMORY);
					IISDebugOutput(_T("RemoveCert:FAIL:Line=%d,0x%x\r\n"),__LINE__,ERROR_NOT_ENOUGH_MEMORY);
                    break;
                }
                if (    !CertGetCertificateContextProperty(pCertContext, 
						    CERT_KEY_PROV_INFO_PROP_ID, pKpi, &cbKpi)
                    ||  !CryptAcquireContext(&hCryptProv,
                            pKpi->pwszContainerName,
						    pKpi->pwszProvName,
                            pKpi->dwProvType,
						    pKpi->dwFlags | CRYPT_DELETEKEYSET | CRYPT_MACHINE_KEYSET)
                    ||  !CertSetCertificateContextProperty(pCertContext, 
						    CERT_KEY_PROV_INFO_PROP_ID, 0, NULL)
					) 
                {
                    free(pKpi);
                    break;
                }
                free(pKpi);
            }

            //    uninstall the certificate from the site, reset SSL flag
            //    if we are exporting the private key, remove the cert from the storage
            //    and delete private key
            UninstallCert(m_InstanceName);
            // remove ssl key from metabase
//            ShutdownSSL(m_InstanceName);

            // VARIANT_TRUE is passed when invoked from VB!  Make sure to check that too!
            if (TRUE == bRemoveFromCertStore || VARIANT_TRUE == bRemoveFromCertStore )
            {
                // delete the private key
                if (TRUE == bPrivateKey || VARIANT_TRUE == bPrivateKey)
                {
                    PCCERT_CONTEXT pcDup = NULL ;
                    pcDup = CertDuplicateCertificateContext(pCertContext);
                    if (pcDup)
                    {
                        if (!CertDeleteCertificateFromStore(pcDup))
                        {
                            break;
                        }
                    }
                }
            }
            ::SetLastError(ERROR_SUCCESS);
            ReportIt(CERTOBJ_CERT_REMOVE_SUCCEED, m_InstanceName);
            bPleaseLogFailure = FALSE;

        } while (FALSE);
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    if (bPleaseLogFailure)
    {
        ReportIt(CERTOBJ_CERT_REMOVE_FAILED, m_InstanceName);
    }
    if (pCertContext) 
	{
		CertFreeCertificateContext(pCertContext);
	}
    return hr;
}

STDMETHODIMP 
CIISCertObj::Import(
	BSTR FileName, 
	BSTR Password, 
	VARIANT_BOOL bAllowExport, 
	VARIANT_BOOL bOverWriteExisting
	)
{
	IISDebugOutput(_T("Import\r\n"));
    HRESULT hr = S_OK;
    BYTE * pbData = NULL;
    DWORD actual = 0, cbData = 0;
    BOOL bPleaseLogFailure = FALSE;

    // Check mandatory properties
    if (  FileName == NULL || *FileName == 0
        || Password == NULL || *Password == 0
        )
    {
        return E_INVALIDARG;
    }

	if (!m_InstanceName)
	{
		return E_INVALIDARG;
	}

    // ------------------------
    // buffer overflow paranoia
    // check all parameters...
    // ------------------------
	// no need to check FileName size, CreateFile will handle...
    //if (wcslen(FileName) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}
    if (wcslen(Password) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}

    HANDLE hFile = CreateFile(FileName, GENERIC_READ, FILE_SHARE_READ, NULL, 
		OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        hFile = NULL;
		IISDebugOutput(_T("Import:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
        goto Import_Exit;
    }

    if (-1 == (cbData = ::GetFileSize(hFile, NULL)))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
		IISDebugOutput(_T("Import:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
        goto Import_Exit;
    }

	if (cbData > MAX_CERTIFICATE_BYTE_SIZE)
	{
		hr = E_OUTOFMEMORY;
		IISDebugOutput(_T("Import:FAIL:Line=%d,Cert Size > Max=%d\r\n"),__LINE__,MAX_CERTIFICATE_BYTE_SIZE);
		goto Import_Exit;
	}

    if (NULL == (pbData = (BYTE *)::CoTaskMemAlloc(cbData)))
    {
        hr = E_OUTOFMEMORY;
		IISDebugOutput(_T("Import:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
        goto Import_Exit;
    }
    if (ReadFile(hFile, pbData, cbData, &actual, NULL))
    {
        IIISCertObj * pObj = GetObject(&hr);
        if (SUCCEEDED(hr))
        {
            bPleaseLogFailure = TRUE;

            // don't need to free _bstr_t
            try
            {
                _bstr_t bstrInstName(m_InstanceName);
                hr = ImportFromBlobProxy(pObj, bstrInstName, Password, VARIANT_TRUE, 
                        bAllowExport, bOverWriteExisting, actual, pbData, 0, NULL);
                if (SUCCEEDED(hr))
                {
                    ReportIt(CERTOBJ_CERT_IMPORT_SUCCEED, m_InstanceName);
                    bPleaseLogFailure = FALSE;
                }
            }
            catch(...)
            {
            }
        }

		// release remote object
		if (pObj != NULL)
		{
			if (pObj != this)
			{
				DelRemoteInterface(pObj);
				pObj->Release();pObj=NULL;
			}
		}
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
		IISDebugOutput(_T("Import:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
        goto Import_Exit;
    }

    if (bPleaseLogFailure)
    {
        ReportIt(CERTOBJ_CERT_EXPORT_FAILED, m_InstanceName);
    }

Import_Exit:
    if (pbData != NULL)
    {
        SecureZeroMemory(pbData, cbData);
        ::CoTaskMemFree(pbData);
    }
    if (hFile != NULL)
    {
        CloseHandle(hFile);
    }
    return hr;
}


STDMETHODIMP 
CIISCertObj::ImportToCertStore(
	BSTR FileName, 
	BSTR Password, 
	VARIANT_BOOL bAllowExport, 
	VARIANT_BOOL bOverWriteExisting, 
	VARIANT * pVtArray
	)
{
    IISDebugOutput(_T("ImportToCertStore\r\n"));
	HRESULT hr = S_OK;
    BYTE * pbData = NULL;
    DWORD actual = 0, cbData = 0;
    BOOL bPleaseLogFailure = FALSE;

    // Check mandatory properties
    if (  FileName == NULL || *FileName == 0
        || Password == NULL || *Password == 0)
    {
        return E_INVALIDARG;
    }

    // ------------------------
    // buffer overflow paranoia
    // check all parameters...
    // ------------------------
    if (wcslen(FileName) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}
    if (wcslen(Password) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}


    HANDLE hFile = CreateFile(FileName, GENERIC_READ, FILE_SHARE_READ, NULL, 
		OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        hFile = NULL;
		IISDebugOutput(_T("ImportToCertStore:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
        goto Import_Exit;
    }

    if (-1 == (cbData = ::GetFileSize(hFile, NULL)))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
		IISDebugOutput(_T("ImportToCertStore:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
        goto Import_Exit;
    }

    if (NULL == (pbData = (BYTE *)::CoTaskMemAlloc(cbData)))
    {
        hr = E_OUTOFMEMORY;
		IISDebugOutput(_T("ImportToCertStore:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
        goto Import_Exit;
    }

    if (ReadFile(hFile, pbData, cbData, &actual, NULL))
    {
        IIISCertObj * pObj = GetObject(&hr);
        if (SUCCEEDED(hr))
        {
            DWORD  cbHashBufferSize = 0;
            char * pszHashBuffer = NULL;

            bPleaseLogFailure = TRUE;

            hr = ImportFromBlobProxy(pObj, _T("none"), Password, VARIANT_FALSE, 
				bAllowExport, bOverWriteExisting, actual, pbData, 
				&cbHashBufferSize, &pszHashBuffer);
            if (SUCCEEDED(hr))
            {
                //ReportIt(CERTOBJ_CERT_IMPORT_CERT_STORE_SUCCEED, bstrInstanceName);
                bPleaseLogFailure = FALSE;
                hr = HereIsBinaryGimmieVtArray(cbHashBufferSize,pszHashBuffer,
					pVtArray,FALSE);
            }
            // free the memory that was alloced for us
            if (0 != cbHashBufferSize)
            {
                if (pszHashBuffer)
                {
                    ::CoTaskMemFree(pszHashBuffer);
                }
            }
        }

		// release remote object
		if (pObj != NULL)
		{
			if (pObj != this)
			{
				DelRemoteInterface(pObj);
				pObj->Release();pObj=NULL;
			}
		}
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
		IISDebugOutput(_T("ImportToCertStore:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
        goto Import_Exit;
    }

Import_Exit:
    if (bPleaseLogFailure)
    {
        //ReportIt(CERTOBJ_CERT_IMPORT_CERT_STORE_FAILED, bstrInstanceName);
    }
    if (pbData != NULL)
    {
        SecureZeroMemory(pbData, cbData);
        ::CoTaskMemFree(pbData);
    }
    if (hFile != NULL){CloseHandle(hFile);}
    return hr;
}

static HRESULT 
ImportFromBlobWork(
	BSTR InstanceName,
	BSTR Password,
	VARIANT_BOOL bInstallToMetabase,
	VARIANT_BOOL bAllowExport,
	VARIANT_BOOL bOverWriteExisting,
	DWORD count,
	char *pData,
	DWORD *pcbHashBufferSize,
	char **pbHashBuffer
	)
{
    HRESULT hr = S_OK;
    CRYPT_DATA_BLOB blob;
    SecureZeroMemory(&blob, sizeof(CRYPT_DATA_BLOB));
    LPTSTR pPass = Password;
    int err;
    DWORD dwAddDisposition = CERT_STORE_ADD_NEW;
	CheckPointer(pData, E_POINTER);

	BOOL bCertIsForServiceAuthentication = TRUE;
	
    // VARIANT_TRUE is passed when invoked from VB!  Make sure to check that too!
    if (TRUE == bOverWriteExisting || VARIANT_TRUE == bOverWriteExisting)
    {
        dwAddDisposition = CERT_STORE_ADD_REPLACE_EXISTING;
    }

    // The data we got back was Base64 encoded to remove nulls.
    // we need to decode it back to it's original format.
    if ((err = Base64DecodeA(pData,count,NULL,&blob.cbData)) != ERROR_SUCCESS)
    {
        SetLastError(err);
        hr = HRESULT_FROM_WIN32(err);
		IISDebugOutput(_T("ImportFromBlobWork:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
        goto ImportFromBlobWork_Exit;
    }

    blob.pbData = (BYTE *) malloc(blob.cbData);
    if (NULL == blob.pbData)
    {
        hr = E_OUTOFMEMORY;
		IISDebugOutput(_T("ImportFromBlobWork:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
        goto ImportFromBlobWork_Exit;
    }
    
    if ((err = Base64DecodeA(pData,count,blob.pbData,&blob.cbData)) != ERROR_SUCCESS )
    {
        SetLastError(err);
        hr = HRESULT_FROM_WIN32(err);
		IISDebugOutput(_T("ImportFromBlobWork:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
        goto ImportFromBlobWork_Exit;
    }

    if (!PFXVerifyPassword(&blob, pPass, 0))
    {
        // Try empty password
        if (pPass == NULL)
        {
            if (!PFXVerifyPassword(&blob, pPass = L'\0', 0))
            {
                hr = E_INVALIDARG;
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    if (SUCCEEDED(hr))
    {
        //  CRYPT_EXPORTABLE - which would then specify that any imported keys should 
        //     be marked as exportable (see documentation on CryptImportKey)
        //  CRYPT_USER_PROTECTED - (see documentation on CryptImportKey)
        //  PKCS12_NO_DATA_COMMIT - will unpack the pfx blob but does not persist its contents.
        //                       In this case, returns BOOL indicating successful unpack.
        //  CRYPT_MACHINE_KEYSET - used to force the private key to be stored in the
        //                        the local machine and not the current user.
        //  CRYPT_USER_KEYSET - used to force the private key to be stored in the
        //                      the current user and not the local machine, even if
        //                      the pfx blob specifies that it should go into local machine.
        HCERTSTORE hStore = PFXImportCertStore(&blob, pPass, 
			(bAllowExport ? CRYPT_MACHINE_KEYSET|CRYPT_EXPORTABLE : CRYPT_MACHINE_KEYSET));
        if (hStore != NULL)
        {
            //add the certificate with private key to my store; and the rest
            //to the ca store
            PCCERT_CONTEXT	pCertContext = NULL;
            PCCERT_CONTEXT	pCertPre = NULL;
            while (SUCCEEDED(hr)
                   && NULL != (pCertContext = CertEnumCertificatesInStore(hStore, pCertPre)
                   )
            )
            {
                //check if the certificate has the property on it
                //make sure the private key matches the certificate
                //search for both machine key and user keys
                DWORD dwData = 0;
                if (    CertGetCertificateContextProperty(pCertContext,
                            CERT_KEY_PROV_INFO_PROP_ID, NULL, &dwData) 
					&&  CryptFindCertificateKeyProvInfo(pCertContext, 0, NULL)
					)
                {
					// Check if this cert can even be used for SeverAuthentication.
					// if it can't then don't let them assign it.
					if (!CanIISUseThisCertForServerAuth(pCertContext))
					{
						hr = SEC_E_CERT_WRONG_USAGE;
						IISDebugOutput(_T("ImportFromBlobWork:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
						bCertIsForServiceAuthentication = FALSE;
						break;
					}

					if (bCertIsForServiceAuthentication)
					{
						// This certificate should go to the My store
						HCERTSTORE hDestStore = CertOpenStore(
							CERT_STORE_PROV_SYSTEM,PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
							NULL, CERT_SYSTEM_STORE_LOCAL_MACHINE, L"MY");
						if (hDestStore != NULL)
						{
							// Put it to store
							BOOL bTemp = CertAddCertificateContextToStore(hDestStore, pCertContext, dwAddDisposition, NULL);
							if (!bTemp)
							{
								// check if it failed with CRYPT_E_EXISTS
								// if it did then gee, it already exists...
								// check if we want to overwrite anyways...
								if (CRYPT_E_EXISTS == GetLastError())
								{
									// it's okay if it already exists
									// we don't need to warn user since they want to overwrite it
									bTemp = TRUE;
								}
							}

							if (bTemp)
							{
								// Succeeded to put it to the storage
								hr = S_OK;

								// Install to metabase
								CRYPT_HASH_BLOB hash;
								if (CertGetCertificateContextProperty(pCertContext,
										CERT_SHA1_HASH_PROP_ID, NULL, &hash.cbData))
								{
									hash.pbData = (BYTE *) LocalAlloc(LPTR, hash.cbData);
									if (NULL != hash.pbData)
									{
										if (CertGetCertificateContextProperty(pCertContext, 
												CERT_SHA1_HASH_PROP_ID, hash.pbData, &hash.cbData))
										{
											BOOL bSomethingFailed = FALSE;
											// VARIANT_TRUE is passed when invoked from VB!  Make sure to check that too!
											if (TRUE == bInstallToMetabase || VARIANT_TRUE == bInstallToMetabase)
											{
												// returns error code in hr
												if (!InstallHashToMetabase(&hash, InstanceName, &hr))
												{
													// failed for some reason.
													bSomethingFailed = TRUE;
													IISDebugOutput(_T("ImportFromBlobWork:FAIL:Line=%d (InstallHashToMetabase)\r\n"),__LINE__);
												}
											}
				
											if (!bSomethingFailed)
											{
												// check if we need to return back the hash
												if (NULL != pbHashBuffer)
												{
													*pbHashBuffer = (char *) ::CoTaskMemAlloc(hash.cbData);
													if (NULL == *pbHashBuffer)
													{
														hr = E_OUTOFMEMORY;
														*pbHashBuffer = NULL;
														if (pcbHashBufferSize)
															{*pcbHashBufferSize = 0;}
														IISDebugOutput(_T("ImportFromBlobWork:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
													}
													else
													{
														if (pcbHashBufferSize)
															{*pcbHashBufferSize = hash.cbData;}
														memcpy(*pbHashBuffer,hash.pbData,hash.cbData);
													}
												}
											}
										} //CertGetCertificateContextProperty
										else
										{
											hr = HRESULT_FROM_WIN32(GetLastError());
											IISDebugOutput(_T("ImportFromBlobWork:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
										}
										// free the memory we used
										if (hash.pbData)
										{
											LocalFree(hash.pbData);
											hash.pbData=NULL;
										}
									} // hash.pbData
									else
									{
										hr = HRESULT_FROM_WIN32(GetLastError());
										IISDebugOutput(_T("ImportFromBlobWork:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
									}
								} // CertGetCertificateContextProperty
								else
								{
									hr = HRESULT_FROM_WIN32(GetLastError());
									IISDebugOutput(_T("ImportFromBlobWork:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
								}
							} // bTemp
							else
							{
								hr = HRESULT_FROM_WIN32(GetLastError());
								IISDebugOutput(_T("ImportFromBlobWork:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
							}
							CertCloseStore(hDestStore, 0);
						}
						else
						{
							hr = HRESULT_FROM_WIN32(GetLastError());
							IISDebugOutput(_T("ImportFromBlobWork:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
						}
					}
                }  // my store certificate
                //see if the certificate is self-signed.
                //if it is selfsigned, goes to the root store
                else if (TrustIsCertificateSelfSigned(pCertContext,pCertContext->dwCertEncodingType, 0))
                {
					if (bCertIsForServiceAuthentication)
					{
						//Put it to the root store
						HCERTSTORE hDestStore=CertOpenStore(
							CERT_STORE_PROV_SYSTEM,PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
							NULL, CERT_SYSTEM_STORE_LOCAL_MACHINE, L"ROOT");
						if (hDestStore != NULL)
						{
							// Put it to store
							BOOL bTemp = CertAddCertificateContextToStore(hDestStore,pCertContext,dwAddDisposition,NULL);
							if (!bTemp)
							{
								// check if it failed with CRYPT_E_EXISTS
								// if it did then gee, it already exists...
								// check if we want to overwrite anyways...
								if (CRYPT_E_EXISTS == GetLastError())
								{
									if (TRUE == bOverWriteExisting || VARIANT_TRUE == bOverWriteExisting)
									{
										// it's okay if it already exists
										// we don't need to warn user since they want to overwrite it
										bTemp = TRUE;
										hr = S_OK;
									}
								}
							}

							if (!bTemp)
							{
								hr = HRESULT_FROM_WIN32(GetLastError());
								IISDebugOutput(_T("ImportFromBlobWork:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
							}
							CertCloseStore(hDestStore, 0);
						}
						else
						{
							hr = HRESULT_FROM_WIN32(GetLastError());
							IISDebugOutput(_T("ImportFromBlobWork:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
						}
					}
                }
                else
                {
					if (bCertIsForServiceAuthentication)
					{
						//Put it to the CA store
						HCERTSTORE hDestStore=CertOpenStore(
							CERT_STORE_PROV_SYSTEM,PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
							NULL, CERT_SYSTEM_STORE_LOCAL_MACHINE, L"CA");
						if (hDestStore != NULL)
						{
							// Put it to store
							BOOL bTemp = CertAddCertificateContextToStore(hDestStore,pCertContext,dwAddDisposition,NULL);
							if (!bTemp)
							{
								// check if it failed with CRYPT_E_EXISTS
								// if it did then gee, it already exists...
								// check if we want to overwrite anyways...
								if (CRYPT_E_EXISTS == GetLastError())
								{
									if (TRUE == bOverWriteExisting || VARIANT_TRUE == bOverWriteExisting)
									{
										// it's okay if it already exists
										// we don't need to warn user since they want to overwrite it
										bTemp = TRUE;
										hr = S_OK;
									}
								}
							}
							if (!bTemp)
							{
								hr = HRESULT_FROM_WIN32(GetLastError());
								IISDebugOutput(_T("ImportFromBlobWork:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
							}
							CertCloseStore(hDestStore, 0);
						}
						else
						{
							hr = HRESULT_FROM_WIN32(GetLastError());
							IISDebugOutput(_T("ImportFromBlobWork:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
						}
					}
                }
                pCertPre = pCertContext;
            } //while

            CertCloseStore(hStore, 0);
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
			IISDebugOutput(_T("ImportFromBlobWork:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
        }
    }

ImportFromBlobWork_Exit:
    if (blob.pbData != NULL)
    {
        SecureZeroMemory(blob.pbData, blob.cbData);
        free(blob.pbData);
        blob.pbData=NULL;
    }
    return hr;
}


HRESULT 
CIISCertObj::ImportFromBlob(
	BSTR InstanceName,
	BSTR Password,
	VARIANT_BOOL bInstallToMetabase,
	VARIANT_BOOL bAllowExport,
	VARIANT_BOOL bOverWriteExisting,
	DWORD count,
	char *pData
	)
{
    HRESULT hr;

    // Check mandatory properties
    if (   Password == NULL 
		|| *Password == 0
        || InstanceName == NULL 
		|| *InstanceName == 0
		)
    {
        return E_INVALIDARG;
    }

    // ------------------------
    // buffer overflow paranoia
    // check all parameters...
    // ------------------------
    if (wcslen(InstanceName) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}
    if (wcslen(Password) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}

    hr = ImportFromBlobWork(InstanceName,Password,bInstallToMetabase,bAllowExport,
		bOverWriteExisting,count,pData,0,NULL);
    return hr;
}


HRESULT 
CIISCertObj::ImportFromBlobGetHash(
	BSTR InstanceName,
	BSTR Password,
	VARIANT_BOOL bInstallToMetabase,
	VARIANT_BOOL bAllowExport,
	VARIANT_BOOL bOverWriteExisting,
	DWORD count,
	char *pData,
	DWORD *pcbHashBufferSize,
	char **pbHashBuffer
	)
{
    HRESULT hr;

    // Check mandatory properties
    if (   Password == NULL || *Password == 0
        || InstanceName == NULL || *InstanceName == 0)
    {
        return E_INVALIDARG;
    }

    // ------------------------
    // buffer overflow paranoia
    // check all parameters...
    // ------------------------
    if (wcslen(InstanceName) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}
    if (wcslen(Password) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}

    hr = ImportFromBlobWork(InstanceName,Password,bInstallToMetabase,bAllowExport,
		bOverWriteExisting,count,pData,pcbHashBufferSize,pbHashBuffer);
    return hr;
}


STDMETHODIMP 
CIISCertObj::Export(
	BSTR FileName,
	BSTR Password,
	VARIANT_BOOL bPrivateKey,
	VARIANT_BOOL bCertChain,
	VARIANT_BOOL bRemoveCert)
{
	IISDebugOutput(_T("Export\r\n"));
    HRESULT hr = S_OK;
    DWORD  cbEncodedSize = 0;
    char * pszEncodedString = NULL;
    DWORD  blob_cbData = 0;
    BYTE * blob_pbData = NULL;
    BOOL   bPleaseLogFailure = FALSE;

    // Check mandatory properties
    if (  FileName == NULL || *FileName == 0
        || Password == NULL || *Password == 0
        )
    {
        return E_INVALIDARG;
    }

    // ------------------------
    // buffer overflow paranoia
    // check all parameters...
    // ------------------------
    if (wcslen(FileName) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}
    if (wcslen(Password) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}

    IIISCertObj * pObj = GetObject(&hr);
    if (FAILED(hr))
    {
		IISDebugOutput(_T("Export:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
        goto Export_Exit;
    }

    // Call function go get data from the remote/local iis store
    // and return it back as a blob.  the blob could be returned back as Base64 encoded
    // so check that flag
	// don't need to free _bstr_t
	{
		_bstr_t bstrInstName(m_InstanceName);
		hr = ExportToBlobProxy(pObj, bstrInstName, Password, bPrivateKey, 
			bCertChain, &cbEncodedSize, &pszEncodedString);
	}
    if (FAILED(hr))
    {
		IISDebugOutput(_T("Export:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
        goto Export_Exit;
    }

    // check if things are kool
    // VARIANT_TRUE is passed when invoked from VB!  Make sure to check that too!
    if (TRUE == bRemoveCert || VARIANT_TRUE == bRemoveCert)
    {
		// don't need to free _bstr_t
		_bstr_t bstrInstName2(m_InstanceName);
        hr = RemoveCertProxy(pObj, bstrInstName2, bPrivateKey);
        if (FAILED(hr))
        {
			IISDebugOutput(_T("Export:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
            goto Export_Exit;
        }
    }

    if (SUCCEEDED(hr))
    {
        int err;

        bPleaseLogFailure = TRUE;

        // The data we got back was Base64 encoded to remove nulls.
        // we need to decode it back to it's original format.

        if((err = Base64DecodeA(pszEncodedString,cbEncodedSize,NULL,&blob_cbData)) != ERROR_SUCCESS)
        {
            SetLastError(err);
            hr = HRESULT_FROM_WIN32(err);
			IISDebugOutput(_T("Export:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
            goto Export_Exit;
        }

        blob_pbData = (BYTE *) malloc(blob_cbData);
        if (NULL == blob_pbData)
        {
            hr = E_OUTOFMEMORY;
			IISDebugOutput(_T("Export:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
            goto Export_Exit;
        }

        if ((err = Base64DecodeA(pszEncodedString,cbEncodedSize,blob_pbData,&blob_cbData)) != ERROR_SUCCESS ) 
        {
            SetLastError(err);
            hr = HRESULT_FROM_WIN32(err);
			IISDebugOutput(_T("Export:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
            goto Export_Exit;
        }
        
		//
		// Set up and ACL Full access for system, admin and creator, no access for anyone else
		// We're the owner so we're good...
		//
		SECURITY_ATTRIBUTES SA;
		// don't use this one -- it has OICI which inherits from above
		//WCHAR *pwszSD=L"D:(A;OICI;GA;;;SY)(A;OICI;GA;;;BA)(A;OICI;GA;;;CO)";
		//
		// This is the right one without inheritance -- we don't want to inherit an everyone readonly ACE
		WCHAR *pwszSD=L"D:(A;;GA;;;SY)(A;;GA;;;BA)(A;;GA;;;CO)";
		SA.nLength = sizeof(SECURITY_ATTRIBUTES);
		SA.bInheritHandle = TRUE;
		// Caller will delete the SD w/ LocalFree 
		if (!ConvertStringSecurityDescriptorToSecurityDescriptor(
				pwszSD,
				SDDL_REVISION_1,
				&(SA.lpSecurityDescriptor),
				NULL) ) 
		{
			IISDebugOutput(_T("Export:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
			return E_FAIL;
		}

        // Create the dir if it doesn't exist..
        HANDLE hFile = CreateFile(FileName, GENERIC_WRITE, 0, &SA, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (INVALID_HANDLE_VALUE == hFile)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            if (hr == ERROR_PATH_NOT_FOUND || hr == ERROR_FILE_NOT_FOUND || hr == 0x80070003)
            {
                //
                // Create folders as needed
                //
                hr = CreateFolders(FileName, TRUE);
                if (FAILED(hr))
                {
					LocalFree(SA.lpSecurityDescriptor);
					IISDebugOutput(_T("Export:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
                    return hr;
                }
                //
                // Try again
                //
                hFile = CreateFile(FileName, 
                    GENERIC_WRITE, 0, &SA, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
                if (INVALID_HANDLE_VALUE == hFile)
                {
					LocalFree(SA.lpSecurityDescriptor);
                    hr = HRESULT_FROM_WIN32(GetLastError());
					IISDebugOutput(_T("Export:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
                    return hr;
                }
            }
            else
            {
				LocalFree(SA.lpSecurityDescriptor);
				IISDebugOutput(_T("Export:FAIL:Line=%d,0x%x,FileName=%s\r\n"),__LINE__,hr,FileName);
                return hr;
            }
        }

        DWORD written = 0;
        if (!WriteFile(hFile, blob_pbData, blob_cbData, &written, NULL))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
			IISDebugOutput(_T("Export:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
        }
        else
        {
            hr = S_OK;
            ReportIt(CERTOBJ_CERT_EXPORT_SUCCEED, m_InstanceName);
            bPleaseLogFailure = FALSE;
        }
        CloseHandle(hFile);
		LocalFree(SA.lpSecurityDescriptor);
    }

Export_Exit:
    if (bPleaseLogFailure)
    {
        ReportIt(CERTOBJ_CERT_EXPORT_FAILED, m_InstanceName);
    }

	// release remote object
	if (pObj != NULL)
	{
		if (pObj != this)
		{
			DelRemoteInterface(pObj);
			pObj->Release();pObj=NULL;
		}
	}

    if (blob_pbData != NULL)
    {
        // Erase the memory that the private key used to be in!!!
        SecureZeroMemory(blob_pbData, blob_cbData);
        free(blob_pbData);blob_pbData=NULL;
    }

    if (pszEncodedString != NULL)
    {
        // Erase the memory that the private key used to be in!!!
        SecureZeroMemory(pszEncodedString, cbEncodedSize);
        CoTaskMemFree(pszEncodedString);pszEncodedString=NULL;
    }
    return hr;
}

STDMETHODIMP 
CIISCertObj::ExportToBlob(
	BSTR InstanceName,
	BSTR Password,
	VARIANT_BOOL bPrivateKey,
	VARIANT_BOOL bCertChain,
	DWORD *cbBufferSize,
	char **pbBuffer
	)
{
    HRESULT hr = E_FAIL;
    PCCERT_CONTEXT pCertContext = NULL;
    HCERTSTORE hStore = NULL;
    DWORD dwOpenFlags = CERT_STORE_READONLY_FLAG | CERT_STORE_ENUM_ARCHIVED_FLAG;
    CRYPT_DATA_BLOB DataBlob;
    SecureZeroMemory(&DataBlob, sizeof(CRYPT_DATA_BLOB));

    char *pszB64Out = NULL;
    DWORD pcchB64Out = 0;
    DWORD  err;
    DWORD dwExportFlags = EXPORT_PRIVATE_KEYS | REPORT_NO_PRIVATE_KEY;
	DWORD dwFlags = REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY;

    // Check mandatory properties
    if (   Password == NULL || *Password == 0
        || InstanceName == NULL || *InstanceName == 0)
    {
        return E_INVALIDARG;
    }

    // ------------------------
    // buffer overflow paranoia
    // check all parameters...
    // ------------------------
    if (wcslen(Password) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}
    if (wcslen(InstanceName) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}

    //
    // get the certificate from the server
    //
    pCertContext = GetInstalledCert(&hr,InstanceName);
    if (NULL == pCertContext)
    {
        *cbBufferSize = 0;
        pbBuffer = NULL;
		IISDebugOutput(_T("ExportToBlob:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
        goto ExportToBlob_Exit;
    }

	// Check if this cert can even be used for SeverAuthentication.
	// if it can't then don't let them export it.
	if (!CanIISUseThisCertForServerAuth(pCertContext))
	{
		hr = SEC_E_CERT_WRONG_USAGE;
		IISDebugOutput(_T("ExportToBlob:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
        goto ExportToBlob_Exit;
	}

    //
    // Export cert
    //
    // Open a temporary store to stick the cert in.
    hStore = CertOpenStore(CERT_STORE_PROV_MEMORY,X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
		0,dwOpenFlags,NULL);
    if(NULL == hStore)
    {
        *cbBufferSize = 0;
        pbBuffer = NULL;
        hr = HRESULT_FROM_WIN32(GetLastError());
		IISDebugOutput(_T("ExportToBlob:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
        goto ExportToBlob_Exit;
    }

    //
    // get all the certs in the chain if we need to
    //
    // VARIANT_TRUE is passed when invoked from VB!  Make sure to check that too!
    if (TRUE == bCertChain || VARIANT_TRUE == bCertChain)
    {
        AddChainToStore(hStore, pCertContext, 0, 0, FALSE, NULL);
    }

    if(!CertAddCertificateContextToStore(hStore,pCertContext,
		CERT_STORE_ADD_REPLACE_EXISTING,NULL))
    {
        *cbBufferSize = 0;
        pbBuffer = NULL;
        hr = HRESULT_FROM_WIN32(GetLastError());
		IISDebugOutput(_T("ExportToBlob:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
        goto ExportToBlob_Exit;
    }

    // free cert context since we no longer need to hold it
    if (pCertContext) 
    {
        CertFreeCertificateContext(pCertContext);pCertContext=NULL;
    }

    DataBlob.cbData = 0;
    DataBlob.pbData = NULL;

	if (TRUE == bPrivateKey || VARIANT_TRUE == bPrivateKey)
	{
		dwFlags = dwFlags | dwExportFlags;
	}
	if (TRUE == bCertChain || VARIANT_TRUE == bCertChain)
	{
		// make sure to remove REPORT_NO_PRIVATE_KEY
		// since something on the chain will not have a private key
		// and will produce an error in PFXExportCertStoreEx
		dwFlags &= ~REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY;
		dwFlags &= ~REPORT_NO_PRIVATE_KEY;
	}

    if (!PFXExportCertStoreEx(hStore,&DataBlob,Password,NULL,dwFlags))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
		IISDebugOutput(_T("ExportToBlob:FAIL:Line=%d,0x%x,dwFlags=0x%x\r\n"),__LINE__,hr,dwFlags);
        goto ExportToBlob_Exit;
    }
    if (DataBlob.cbData <= 0)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
		IISDebugOutput(_T("ExportToBlob:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
        goto ExportToBlob_Exit;
    }

    if (NULL == (DataBlob.pbData = (PBYTE) ::CoTaskMemAlloc(DataBlob.cbData)))
    {
        hr = E_OUTOFMEMORY;
		IISDebugOutput(_T("ExportToBlob:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
        goto ExportToBlob_Exit;
    }

    //
    // at this point they have allocated enough memory
    // let's go and get the cert and put it into DataBlob
    //
    if(!PFXExportCertStoreEx(hStore,&DataBlob,Password,NULL,dwFlags))
    {
        if (DataBlob.pbData){CoTaskMemFree(DataBlob.pbData);DataBlob.pbData = NULL;}
        hr = HRESULT_FROM_WIN32(GetLastError());
		IISDebugOutput(_T("ExportToBlob:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
        goto ExportToBlob_Exit;
    }

    // Encode it so that it can be passed back as a string (there are no Nulls in it)
    err = Base64EncodeA(DataBlob.pbData,DataBlob.cbData,NULL,&pcchB64Out);
    if (err != ERROR_SUCCESS)
    {
        hr = E_FAIL;
		IISDebugOutput(_T("ExportToBlob:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
        goto ExportToBlob_Exit;
    }

    // allocate some space and then try it.
    pcchB64Out = pcchB64Out * sizeof(char);
    pszB64Out = (char *) ::CoTaskMemAlloc(pcchB64Out);
    if (NULL == pszB64Out)
    {
        hr = E_OUTOFMEMORY;
		IISDebugOutput(_T("ExportToBlob:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
        goto ExportToBlob_Exit;
    }

    err = Base64EncodeA(DataBlob.pbData,DataBlob.cbData,pszB64Out,&pcchB64Out);
    if (err != ERROR_SUCCESS)
    {
        if (NULL != pszB64Out){CoTaskMemFree(pszB64Out);pszB64Out = NULL;}
        hr = E_FAIL;
		IISDebugOutput(_T("ExportToBlob:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
        goto ExportToBlob_Exit;
    }

    // copy the new memory to pass back
    *cbBufferSize = pcchB64Out;
    *pbBuffer = pszB64Out;

    hr = ERROR_SUCCESS;

ExportToBlob_Exit:
    if (NULL != DataBlob.pbData)
    {
        // perhaspse will this up with zeros...
        SecureZeroMemory(DataBlob.pbData, DataBlob.cbData);
        ::CoTaskMemFree(DataBlob.pbData);DataBlob.pbData = NULL;
    }
    if (NULL != hStore){CertCloseStore(hStore, 0);hStore=NULL;}
    if (NULL != pCertContext) {CertFreeCertificateContext(pCertContext);pCertContext=NULL;}
    return hr;
}

STDMETHODIMP 
CIISCertObj::Copy(
	VARIANT_BOOL bAllowExport,
	VARIANT_BOOL bOverWriteExisting,
	BSTR bstrDestinationServerName,
	BSTR bstrDestinationServerInstance,
	VARIANT varDestinationServerUserName, 
	VARIANT varDestinationServerPassword
	)
{
	IISDebugOutput(_T("Copy\r\n"));
    VARIANT VtArray;

    // Check mandatory properties
    if (   bstrDestinationServerName == NULL || *bstrDestinationServerName == 0
        || bstrDestinationServerInstance == NULL || *bstrDestinationServerInstance == 0)
    {
        return E_INVALIDARG;
    }

    // ------------------------
    // buffer overflow paranoia
    // check all parameters...
    // ------------------------
    if (wcslen(bstrDestinationServerName) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}
    if (wcslen(bstrDestinationServerInstance) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}

    return CopyOrMove(VARIANT_FALSE,VARIANT_FALSE,bAllowExport,bOverWriteExisting,&VtArray,
		bstrDestinationServerName,bstrDestinationServerInstance,
		varDestinationServerUserName,varDestinationServerPassword);
}

STDMETHODIMP 
CIISCertObj::Move(
	VARIANT_BOOL bAllowExport,
	VARIANT_BOOL bOverWriteExisting,
	BSTR bstrDestinationServerName,
	BSTR bstrDestinationServerInstance,
	VARIANT varDestinationServerUserName, 
	VARIANT varDestinationServerPassword
	)
{
	IISDebugOutput(_T("Move\r\n"));
    VARIANT VtArray;

    // Check mandatory properties
    if (   bstrDestinationServerName == NULL || *bstrDestinationServerName == 0
        || bstrDestinationServerInstance == NULL || *bstrDestinationServerInstance == 0)
    {
        return E_INVALIDARG;
    }

    // ------------------------
    // buffer overflow paranoia
    // check all parameters...
    // ------------------------
    if (wcslen(bstrDestinationServerName) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}
    if (wcslen(bstrDestinationServerInstance) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}

    return CopyOrMove(VARIANT_TRUE,VARIANT_FALSE,bAllowExport,bOverWriteExisting,&VtArray,
		bstrDestinationServerName,bstrDestinationServerInstance,
		varDestinationServerUserName,varDestinationServerPassword);
}

static BOOL
CreateCompletePath(const CString& inst, CString& res)
{
    CString str;
    if (NULL != CMetabasePath::GetLastNodeName(inst, str))
    {
        CMetabasePath path(TRUE, SZ_MBN_WEB, str);
        res = path;
        return TRUE;
    }
    return FALSE;
}

HRESULT 
CIISCertObj::CopyOrMove(
	VARIANT_BOOL bMove,
	VARIANT_BOOL bCopyCertDontInstallRetHash,
	VARIANT_BOOL bAllowExport,
	VARIANT_BOOL bOverWriteExisting,
	VARIANT * pVtArray, 
	BSTR bstrDestinationServerName,
	BSTR bstrDestinationServerInstance,
	VARIANT varDestinationServerUserName, 
	VARIANT varDestinationServerPassword
	)
{
	IISDebugOutput(_T("CopyOrMove\r\n"));
    HRESULT hr = E_FAIL;
    DWORD  cbEncodedSize = 0;
    char * pszEncodedString = NULL;
    BOOL   bGuessingUserNamePass = FALSE;
    
    DWORD  blob_cbData;
    BYTE * blob_pbData = NULL;

    VARIANT_BOOL bPrivateKey = VARIANT_TRUE;
    VARIANT_BOOL bCertChain = VARIANT_FALSE;

    CComBSTR csDestinationServerName = bstrDestinationServerName;
    CComBSTR csDestinationServerUserName;
    CComBSTR csDestinationServerUserPassword;
    CComBSTR csTempPassword;

	WCHAR * pwszPassword = NULL;
	BSTR bstrPassword = NULL;

    IIISCertObj * pObj = NULL;
    IIISCertObj * pObj2 = NULL;

    // Check mandatory properties
    if (   bstrDestinationServerName == NULL || *bstrDestinationServerName == 0
        || bstrDestinationServerInstance == NULL || *bstrDestinationServerInstance == 0)
    {
        return E_INVALIDARG;
    }

	// We could have local dest case, when both destination and source servers
	// are the same machine
	BOOL bLocal = FALSE;

	if (0 == m_ServerName.Length())
	{
		// then this side is local that's for sure.
		if (IsServerLocal(bstrDestinationServerName))
		{
			bLocal = TRUE;
		}
	}
	else
	{
		if (0 == _tcsicmp(m_ServerName,bstrDestinationServerName))
		{
			if (IsServerLocal(m_ServerName))
			{
				bLocal = TRUE;
			}
			else
			{
				bLocal = FALSE;
			}
		}
	}
	if (bLocal)
	{
		// All we need to do here is to add hash and store name to the destination instance
		// and optionally remove it from the source instance
		LPWSTR pwd = NULL;
		if (m_lpwszUserPasswordEncrypted)
		{
			hr = DecryptMemoryPassword((LPWSTR) m_lpwszUserPasswordEncrypted,
					&pwd, m_cbUserPasswordEncrypted);
			if (FAILED(hr))
			{
				IISDebugOutput(_T("CopyOrMove:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
				goto Copy_Exit;
			}
		}
		CComAuthInfo auth(m_ServerName, m_UserName, pwd);
		//COSERVERINFO * pcsiName = auth.CreateServerInfoStruct(RPC_C_AUTHN_LEVEL_PKT_PRIVACY);

		CMetaKey key(&auth);
        CString src;
        CreateCompletePath(m_InstanceName, src);
		if (FAILED(hr = key.Open(METADATA_PERMISSION_READ|METADATA_PERMISSION_WRITE, src)))
		{
			IISDebugOutput(_T("CopyOrMove:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
			goto Copy_Exit;
		}
		CString store_name;
		CBlob hash;
		if (	FAILED(hr = key.QueryValue(MD_SSL_CERT_STORE_NAME, store_name))
			||	FAILED(hr = key.QueryValue(MD_SSL_CERT_HASH, hash))
			)
		{
			IISDebugOutput(_T("CopyOrMove:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
			goto Copy_Exit;
		}
		if (bMove)
		{
			// The user could have specified to move the
			// certificate to and from the same site
			// if this is the case, then don't delete the metabase entries...
			BOOL bSameNode = FALSE;
			CString dst;
			CreateCompletePath(bstrDestinationServerInstance, dst);
			if (!src.IsEmpty() && !dst.IsEmpty())
			{
				if (0 == src.CompareNoCase(dst))
				{
					bSameNode = TRUE;
				}
			}
			
			if (!bSameNode)
			{
				VERIFY((SUCCEEDED(key.DeleteValue(MD_SSL_CERT_HASH))));
				VERIFY((SUCCEEDED(key.DeleteValue(MD_SSL_CERT_STORE_NAME))));
				DWORD dwSSL = 0;
				CString root = _T("root");
				if (SUCCEEDED(key.QueryValue(MD_SSL_ACCESS_PERM, dwSSL, NULL, root)) && dwSSL > 0)
				{
					VERIFY(SUCCEEDED(key.SetValue(MD_SSL_ACCESS_PERM, 0, NULL, root)));
				}
				CStringListEx sl;
				if (SUCCEEDED(key.QueryValue(MD_SECURE_BINDINGS, sl, NULL, root)))
				{
					VERIFY(SUCCEEDED(key.DeleteValue(MD_SECURE_BINDINGS, root)));
				}

				DWORD dwMDIdentifier, dwMDAttributes, dwMDUserType,dwMDDataType;
				VERIFY(CMetaKey::GetMDFieldDef(MD_SSL_ACCESS_PERM, dwMDIdentifier, dwMDAttributes, 
					dwMDUserType, dwMDDataType));
				hr = key.GetDataPaths(sl, dwMDIdentifier,dwMDDataType);
				if (SUCCEEDED(hr) && !sl.empty())
				{
					CStringListEx::iterator it = sl.begin();
					while (it != sl.end())
					{
						CString& str2 = (*it++);
						if (SUCCEEDED(key.QueryValue(MD_SSL_ACCESS_PERM, dwSSL, NULL, str2)) && dwSSL > 0)
						{
							key.SetValue(MD_SSL_ACCESS_PERM, 0, NULL, str2);
						}
					}
				}
			}
		}
		key.Close();

        CString dst;
        CreateCompletePath(bstrDestinationServerInstance, dst);
		if (FAILED(hr = key.Open(METADATA_PERMISSION_READ|METADATA_PERMISSION_WRITE, dst)))
		{
			IISDebugOutput(_T("CopyOrMove:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
			goto Copy_Exit;
		}
		// Overwrite should be set, or it doesn't make any sence
//		ASSERT(bOverWriteExisting);
		if (FAILED(hr = key.SetValue(MD_SSL_CERT_HASH, hash)))
		{
			IISDebugOutput(_T("CopyOrMove:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
			goto Copy_Exit;
		}

		if (FAILED(hr = key.SetValue(MD_SSL_CERT_STORE_NAME, store_name)))
		{
			IISDebugOutput(_T("CopyOrMove:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
			goto Copy_Exit;
		}

		if (pwd)
		{
			// security percaution:Make sure to zero out memory that temporary password was used for.
			SecureZeroMemory(pwd, m_cbUserPasswordEncrypted);
			LocalFree(pwd);pwd = NULL;
		}

		goto Copy_Exit;
	}

	// if the optional parameter serverusername isn't empty, use that; otherwise, use...
	if (V_VT(&varDestinationServerUserName) != VT_ERROR)
	{
		VARIANT varBstrUserName;
		VariantInit(&varBstrUserName);
		if (FAILED(VariantChangeType(&varBstrUserName, &varDestinationServerUserName, 0, VT_BSTR)))
			{
				IISDebugOutput(_T("CopyOrMove:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
				goto Copy_Exit;
			}
		csDestinationServerUserName = V_BSTR(&varBstrUserName);
		VariantClear(&varBstrUserName);
	}
	else
	{
		// it's empty so don't use it
		//csDestinationServerUserName = varDestinationServerUserName;
		bGuessingUserNamePass = TRUE;
		csDestinationServerUserName = m_UserName;
	}

	// if the optional parameter serverusername isn't empty, use that; otherwise, use...
	if (V_VT(&varDestinationServerPassword) != VT_ERROR)
	{
		VARIANT varBstrUserPassword;
		VariantInit(&varBstrUserPassword);
		if (FAILED(VariantChangeType(&varBstrUserPassword, 
				&varDestinationServerPassword, 0, VT_BSTR)))
			{
				IISDebugOutput(_T("CopyOrMove:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
				goto Copy_Exit;
			}
		csDestinationServerUserPassword = V_BSTR(&varBstrUserPassword);
		VariantClear(&varBstrUserPassword);
	}
	else
	{
		if (bGuessingUserNamePass)
		{
			LPWSTR lpwstrTempPassword = NULL;
			if (m_lpwszUserPasswordEncrypted)
			{
				hr = DecryptMemoryPassword((LPWSTR) m_lpwszUserPasswordEncrypted,
					&lpwstrTempPassword,m_cbUserPasswordEncrypted);
				if (FAILED(hr))
				{
					IISDebugOutput(_T("CopyOrMove:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
					goto Copy_Exit;
				}
			}

			// set password from decrypted value
			csDestinationServerUserPassword = lpwstrTempPassword;

			// clean up temporary password
			if (lpwstrTempPassword)
			{
				// security percaution:Make sure to zero out memory that temporary password was used for.
				SecureZeroMemory(lpwstrTempPassword,m_cbUserPasswordEncrypted);
				LocalFree(lpwstrTempPassword);
				lpwstrTempPassword = NULL;
			}
		}
		else
		{
			// maybe the password was intended to be empty!
		}
	}

	// --------------------------
	// step 1.
	// 1st of all check if we have access to
	// both the servers!!!!
	// --------------------------

	// 1st we have to get the certblob from the Server#1
	// so call export to get the data
	hr = S_OK;
	pObj = GetObject(&hr);
	if (FAILED(hr))
	{
		IISDebugOutput(_T("CopyOrMove:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
		goto Copy_Exit;
	}

	// Logon to that server's CertObj.dll with the credentials supplied...
	//
	// if there were no credential's supplied then just use the ones that are in our object....
	//
	// if that doesn't work then try just the logged on user.
	pObj2 = GetObject(&hr,csDestinationServerName,csDestinationServerUserName,
		csDestinationServerUserPassword);
	if (FAILED(hr))
	{
		IISDebugOutput(_T("CIISCertObj::CopyOrMove:Copy csDestinationServerName=%s,csDestinationServerUserName=%s\n"),
			(LPCTSTR) csDestinationServerName,(LPCTSTR) csDestinationServerUserName);
		if (bGuessingUserNamePass)
		{
			// try something else.
		}
		IISDebugOutput(_T("CopyOrMove:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
		goto Copy_Exit;
	}
	//
	// Create a unique password
	//
	// use the new secure password generator
	// unfortunately this baby doesn't use unicode.
	// so we'll call it and then convert it to unicode afterwards.
	pwszPassword = CreatePassword(TEMP_PASSWORD_LENGTH);
	// if its null -- ah, we can still use that...
	bstrPassword = SysAllocString(pwszPassword);

	// -----------------------------------
	// step 2.
	// okay we have access to both servers
	// Grab the cert from server #1
	// -----------------------------------
	// Get data from the remote/local iis store return it back as a blob.
	// The blob could be returned back as Base64 encoded so check that flag
	// don't need to free _bstr_t
	{
	_bstr_t bstrInstName(m_InstanceName);
	hr = ExportToBlobProxy(pObj, bstrInstName, bstrPassword, 
    	bPrivateKey, bCertChain, &cbEncodedSize, &pszEncodedString);
	}
	if (FAILED(hr))
	{
		IISDebugOutput(_T("CopyOrMove:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
		goto Copy_Exit;
	}

	int err;
	// The data we got back was Base64 encoded to remove nulls.
	// we need to decode it back to it's original format.
	if ((err = Base64DecodeA(pszEncodedString,cbEncodedSize,NULL,&blob_cbData)) != ERROR_SUCCESS)
	{
		SetLastError(err);
		hr = HRESULT_FROM_WIN32(err);
		IISDebugOutput(_T("CopyOrMove:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
		goto Copy_Exit;
	}

	blob_pbData = (BYTE *) malloc(blob_cbData);
	if (NULL == blob_pbData)
	{
		hr = E_OUTOFMEMORY;
		IISDebugOutput(_T("CopyOrMove:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
		goto Copy_Exit;
	}

	if ((err = Base64DecodeA(pszEncodedString,cbEncodedSize,blob_pbData,&blob_cbData)) != ERROR_SUCCESS) 
	{
		SetLastError(err);
		hr = HRESULT_FROM_WIN32(err);
		IISDebugOutput(_T("CopyOrMove:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
		goto Copy_Exit;
	}

	// -----------------------------------
	// step 3.
	// okay we have access to both servers
	// we have the cert blob from server#1 in memory
	// now we need to push this blob into the server#2
	// -----------------------------------
	if (bCopyCertDontInstallRetHash)
	{
		DWORD  cbHashBufferSize = 0;
		char * pszHashBuffer = NULL;

		hr = ImportFromBlobProxy(pObj2, _T("none"), bstrPassword, 
					VARIANT_FALSE, bAllowExport, bOverWriteExisting, blob_cbData, 
					blob_pbData, &cbHashBufferSize, &pszHashBuffer);
		if (SUCCEEDED(hr))
		{
			hr = HereIsBinaryGimmieVtArray(cbHashBufferSize,pszHashBuffer,pVtArray,FALSE);
		}
		// free the memory that was alloced for us
		if (0 != cbHashBufferSize)
		{
			if (pszHashBuffer)
			{
				::CoTaskMemFree(pszHashBuffer);
			}
		}
	}
	else
	{
		hr = ImportFromBlobProxy(pObj2, bstrDestinationServerInstance, bstrPassword, 
					VARIANT_TRUE, bAllowExport, bOverWriteExisting, blob_cbData, 
					blob_pbData, 0, NULL);
	}
	if (FAILED(hr))
	{
		// This could have failed with CRYPT_E_EXISTS
		// if the certificate already exists in the cert store.
		if (CRYPT_E_EXISTS == hr)
		{
			if (TRUE == bOverWriteExisting || VARIANT_TRUE == bOverWriteExisting)
			{
				hr = S_OK;
			}
			else
			{
				IISDebugOutput(_T("CopyOrMove:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
				goto Copy_Exit;
			}
		}
		else
		{
			IISDebugOutput(_T("CopyOrMove:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
			goto Copy_Exit;
		}
	}

	// we successfully copied the cert from machine #1 to machine #2.
	// lets see if we need to delete the original cert!.
	// VARIANT_TRUE is passed when invoked from VB!  Make sure to check that too!
	if (TRUE == bMove || VARIANT_TRUE == bMove)
	{
		//  Do not delete the cert if it was moved to the same machine!!!!!!!!!!!!!!
		// For some reason we need to SysAllocString these instance names
		// if not com will AV when marshalling...
		// don't need to free _bstr_t
		_bstr_t bstrInstName2(m_InstanceName);
		hr = pObj->put_InstanceName(bstrInstName2);
		if (SUCCEEDED(hr))
		{
			hr = pObj->RemoveCert(pObj != pObj2, bPrivateKey);
			if (FAILED(hr))
				{
					IISDebugOutput(_T("CopyOrMove:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
					goto Copy_Exit;
				}
		}
	}

	hr = S_OK;
   
Copy_Exit:
    if (pwszPassword) 
    {
    	LocalFree(pwszPassword);
    }
	if (NULL != bstrPassword)
	{
		SysFreeString(bstrPassword);
	}
    if (blob_pbData != NULL)
    {
        SecureZeroMemory(blob_pbData, blob_cbData);
        free(blob_pbData);blob_pbData=NULL;
    }
    if (pszEncodedString != NULL)
    {
        SecureZeroMemory(pszEncodedString,cbEncodedSize);
        CoTaskMemFree(pszEncodedString);pszEncodedString=NULL;
    }

	// release remote object
	if (pObj != NULL)
	{
		if (pObj != this)
		{
			DelRemoteInterface(pObj);
			pObj->Release();pObj=NULL;
		}
	}
	// release remote object
	if (pObj2 != NULL)
	{
		if (pObj2 != this)
		{
			DelRemoteInterface(pObj2);
			pObj2->Release();pObj2=NULL;
		}
	}
    return hr;
}


//////////////////////////////////////////////////
// These are not part of the class


HRESULT 
RemoveCertProxy(
	IIISCertObj * pObj,
	BSTR bstrInstanceName, 
	VARIANT_BOOL bPrivateKey
	)
{
	CheckPointer(pObj, E_POINTER);
    HRESULT hr = E_FAIL;

    // Check mandatory properties
    if (bstrInstanceName == NULL || *bstrInstanceName == 0)
    {
        return E_INVALIDARG;
    }
    
    // ------------------------
    // buffer overflow paranoia
    // check all parameters...
    // ------------------------
    if (wcslen(bstrInstanceName) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}

    if (pObj)
    {
        hr = pObj->put_InstanceName(bstrInstanceName);
        if (SUCCEEDED(hr))
        {
            hr = pObj->RemoveCert(VARIANT_TRUE, bPrivateKey);
        }
    }
    return hr;
}


HRESULT 
ImportFromBlobProxy(
	IIISCertObj * pObj,
	BSTR InstanceName,
	BSTR Password,
	VARIANT_BOOL bInstallToMetabase,
	VARIANT_BOOL bAllowExport,
	VARIANT_BOOL bOverWriteExisting,
	DWORD actual,
	BYTE *pData,
	DWORD *pcbHashBufferSize,
	char **pbHashBuffer
	)
{
	CheckPointer(pObj, E_POINTER);
	CheckPointer(pData, E_POINTER);

	HRESULT hr = E_FAIL;
	char *pszB64Out = NULL;
	DWORD pcchB64Out = 0;

	// base64 encode the data for transfer to the remote machine
	DWORD  err;
	pcchB64Out = 0;

	// Check mandatory properties
	if (InstanceName == NULL || *InstanceName == 0)
	{
		return E_INVALIDARG;
	}

	// ------------------------
	// buffer overflow paranoia
	// check all parameters...
	// ------------------------
	if (wcslen(InstanceName) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}


	// Encode it so that it can be passed back as a string (there are no Nulls in it)
	err = Base64EncodeA(pData,actual,NULL,&pcchB64Out);
	if (err != ERROR_SUCCESS)
	{
		hr = E_FAIL;
		IISDebugOutput(_T("ImportFromBlobProxy:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
		goto ImportFromBlobProxy_Exit;
	}

	// allocate some space and then try it.
	pcchB64Out = pcchB64Out * sizeof(char);
	pszB64Out = (char *) ::CoTaskMemAlloc(pcchB64Out);
	if (NULL == pszB64Out)
	{
		hr = E_OUTOFMEMORY;
		IISDebugOutput(_T("ImportFromBlobProxy:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
		goto ImportFromBlobProxy_Exit;
	}

	err = Base64EncodeA(pData,actual,pszB64Out,&pcchB64Out);
	if (err != ERROR_SUCCESS)
	{
		hr = E_FAIL;
		IISDebugOutput(_T("ImportFromBlobProxy:FAIL:Line=%d,0x%x\r\n"),__LINE__,hr);
		goto ImportFromBlobProxy_Exit;
	}

	// the data to send are now in these variables
	// pcchB64Out
	// pszB64Out
	if (NULL == pbHashBuffer)
	{
		hr = pObj->ImportFromBlob(InstanceName, Password, bInstallToMetabase, 
					bAllowExport, bOverWriteExisting, pcchB64Out, pszB64Out);
	}
	else
	{
		hr = pObj->ImportFromBlobGetHash(InstanceName, Password, 
					bInstallToMetabase, bAllowExport, bOverWriteExisting, pcchB64Out, 
					pszB64Out, pcbHashBufferSize, pbHashBuffer);
	}
	if (SUCCEEDED(hr))
	{
		// otherwise hey, The data was imported!
		hr = S_OK;
	}

ImportFromBlobProxy_Exit:
	if (NULL != pszB64Out)
	{
		SecureZeroMemory(pszB64Out,pcchB64Out);
		CoTaskMemFree(pszB64Out);
	}
	return hr;
}


//
// Proxy to the real call ExportToBlob()
// this function figures out how much space to allocate, and then calls ExportToBlob().
//
// if succeeded and they get the blob back,
// and the caller must call CoTaskMemFree()
//
HRESULT 
ExportToBlobProxy(
	IIISCertObj * pObj,
	BSTR InstanceName,
	BSTR Password,
	VARIANT_BOOL bPrivateKey,
	VARIANT_BOOL bCertChain,
	DWORD * pcbSize,
	char ** pBlobBinary
	)
{
	CheckPointer(pObj, E_POINTER);

    HRESULT hr = E_FAIL;
    DWORD  cbEncodedSize = 0;
    char * pszEncodedString = NULL;
    *pBlobBinary = NULL;

    // Check mandatory properties
    if (   InstanceName == NULL || *InstanceName == 0
        || Password == NULL || *Password == 0
        )
    {
        return E_INVALIDARG;
    }
    
    // ------------------------
    // buffer overflow paranoia
    // check all parameters...
    // ------------------------
    if (wcslen(InstanceName) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}
    if (wcslen(Password) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}

    // call the remote function that will run on the remote/local machine
    // and grab it's certificate from iis and send it back to us
    hr = pObj->ExportToBlob(InstanceName, Password, bPrivateKey, bCertChain, 
				&cbEncodedSize, (char **) &pszEncodedString);
    if (ERROR_SUCCESS == hr)
    {
        // otherwise hey, we've got our data!
        // copy it back
        *pcbSize = cbEncodedSize;
        *pBlobBinary = pszEncodedString;
        hr = S_OK;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certobj\iiscertrequest.cpp ===
// IISCertRequest.cpp : Implementation of CIISCertRequest
#include "stdafx.h"
#include "common.h"
#include "CertObj.h"
#include "IISCertRequest.h"
#include "base64.h"
#include "certca.h"
#include "certcli.h"
#include "certutil.h"
#include <strsafe.h>

#ifdef USE_CERT_REQUEST_OBJECT

const CLSID CLSID_CEnroll = 
	{0x43F8F289, 0x7A20, 0x11D0, {0x8F, 0x06, 0x00, 0xC0, 0x4F, 0xC2, 0x95, 0xE1}};
const IID IID_IEnroll = 
	{0xacaa7838, 0x4585, 0x11d1, {0xab, 0x57, 0x00, 0xc0, 0x4f, 0xc2, 0x95, 0xe1}};
const IID IID_ICEnroll2 = 
	{0x704ca730, 0xc90b, 0x11d1, {0x9b, 0xec, 0x00, 0xc0, 0x4f, 0xc2, 0x95, 0xe1}};
const CLSID CLSID_CCertRequest = 
	{0x98aff3f0, 0x5524, 0x11d0, {0x88, 0x12, 0x00, 0xa0, 0xc9, 0x03, 0xb8, 0x3c}};
const IID IID_ICertRequest = 
	{0x014e4840, 0x5523, 0x11d0, {0x88, 0x12, 0x00, 0xa0, 0xc9, 0x03, 0xb8, 0x3c}};

// defines taken from the old KeyGen utility
#define MESSAGE_HEADER  _T("-----BEGIN NEW CERTIFICATE REQUEST-----\r\n")
#define MESSAGE_TRAILER _T("-----END NEW CERTIFICATE REQUEST-----\r\n")

/////////////////////////////////////////////////////////////////////////////
// CIISCertRequest

CIISCertRequest::CIISCertRequest()
{
    m_ServerName = _T("");
    m_UserName = _T("");
    m_UserPassword = _T("");
    m_InstanceName = _T("");

	m_Info_CommonName = _T("");
	m_Info_FriendlyName = _T("");
	m_Info_Country = _T("");
	m_Info_State = _T("");
	m_Info_Locality = _T("");
	m_Info_Organization = _T("");
	m_Info_OrganizationUnit = _T("");
	m_Info_CAName = _T("");
	m_Info_ExpirationDate = _T("");
	m_Info_Usage = _T("");
    m_Info_AltSubject = _T("");

    // other
    m_Info_ConfigCA = _T("");
    m_Info_CertificateTemplate = wszCERTTYPE_WEBSERVER;
    m_Info_DefaultProviderType = PROV_RSA_SCHANNEL;
    m_Info_CustomProviderType = PROV_RSA_SCHANNEL;
    m_Info_DefaultCSP = TRUE;
    m_Info_CspName = _T("");

    m_KeyLength = 512;
    m_SGCcertificat = FALSE;
    m_pEnroll = NULL;
    return;
}

CIISCertRequest::~CIISCertRequest()
{
    return;
}

IIISCertRequest * CIISCertRequest::GetObject(HRESULT * phr)
{
    IIISCertRequest * pObj = NULL;
    pObj = GetObject(phr,m_ServerName,m_UserName,m_UserPassword);
    return pObj;
}

IIISCertRequest * CIISCertRequest::GetObject(HRESULT * phr,CString csServerName,CString csUserName,CString csUserPassword)
{
    if (csServerName.IsEmpty())
    {
        // object is null, but it's the local machine, so just return back this pointer
        m_pObj = this;
        goto GetObject_Exit;
    }

    // There is a servername specified...
    // check if it's the local machine that was specified!
    if (IsServerLocal(csServerName))
    {
        m_pObj = this;
        goto GetObject_Exit;
    }
    else
    {
        // there is a remote servername specified

        // let's see if the machine has the com object that we want....
        // we are using the user/name password that are in this object
        // so were probably on the local machine
        CComAuthInfo auth(csServerName,csUserName,csUserPassword);
        // RPC_C_AUTHN_LEVEL_DEFAULT       0 
        // RPC_C_AUTHN_LEVEL_NONE          1 
        // RPC_C_AUTHN_LEVEL_CONNECT       2 
        // RPC_C_AUTHN_LEVEL_CALL          3 
        // RPC_C_AUTHN_LEVEL_PKT           4 
        // RPC_C_AUTHN_LEVEL_PKT_INTEGRITY 5 
        // RPC_C_AUTHN_LEVEL_PKT_PRIVACY   6 
        COSERVERINFO * pcsiName = auth.CreateServerInfoStruct(RPC_C_AUTHN_LEVEL_PKT_PRIVACY);
        
        MULTI_QI res[1] = 
        {
            {&__uuidof(IIISCertRequest), NULL, 0}
        };

        // this one seems to work with surrogates..
        *phr = CoCreateInstanceEx(CLSID_IISCertRequest,NULL,CLSCTX_LOCAL_SERVER,pcsiName,1,res);
        if (FAILED(*phr))
        {
            IISDebugOutput(_T("CIISCertRequest::GetObject:CoCreateInstanceEx failed:0x%x, csServerName=%s,csUserName=%s\n"),*phr,(LPCTSTR) csServerName,(LPCTSTR) csUserName);
            goto GetObject_Exit;
        }

        // at this point we were able to instantiate the com object on the server (local or remote)
        m_pObj = (IIISCertRequest *)res[0].pItf;
        if (auth.UsesImpersonation())
        {
            *phr = auth.ApplyProxyBlanket(m_pObj);

            // There is a remote IUnknown interface that lurks behind IUnknown.
            // If that is not set, then the Release call can return access denied.
            IUnknown * pUnk = NULL;
            if(FAILED(m_pObj->QueryInterface(IID_IUnknown, (void **)&pUnk)))
            {
                goto GetObject_Exit;
            }
            if (FAILED(auth.ApplyProxyBlanket(pUnk)))
            {
                goto GetObject_Exit;
            }
            pUnk->Release();pUnk = NULL;

        }
        auth.FreeServerInfoStruct(pcsiName);
    }

GetObject_Exit:
    //ASSERT(m_pObj != NULL);
    return m_pObj;
}

STDMETHODIMP CIISCertRequest::put_ServerName(BSTR newVal)
{
    // buffer overflow paranoia, make sure it's less than 255 characters long
    if (wcslen(newVal) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}
    m_ServerName = newVal;
    return S_OK;
}

STDMETHODIMP CIISCertRequest::put_UserName(BSTR newVal)
{
    // buffer overflow paranoia, make sure it's less than 255 characters long
    if (wcslen(newVal) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}
    m_UserName = newVal;
	return S_OK;
}

STDMETHODIMP CIISCertRequest::put_UserPassword(BSTR newVal)
{
    // buffer overflow paranoia, make sure it's less than 255 characters long
    if (wcslen(newVal) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}
    m_UserPassword = newVal;
	return S_OK;
}

STDMETHODIMP CIISCertRequest::put_InstanceName(BSTR newVal)
{
    // buffer overflow paranoia, make sure it's less than 255 characters long
    if (wcslen(newVal) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}
    m_InstanceName = newVal;
	return S_OK;
}

STDMETHODIMP CIISCertRequest::get_Info_CommonName(BSTR *pVal)
{
	_bstr_t bstrTempName = (LPCTSTR) m_Info_CommonName;
	*pVal = bstrTempName.copy();
	return S_OK;
}

STDMETHODIMP CIISCertRequest::put_Info_CommonName(BSTR newVal)
{
    // buffer overflow paranoia, make sure it's less than 255 characters long
    if (wcslen(newVal) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}
    m_Info_CommonName = newVal;
	return S_OK;
}

STDMETHODIMP CIISCertRequest::get_Info_FriendlyName(BSTR *pVal)
{
	_bstr_t bstrTempName = (LPCTSTR) m_Info_FriendlyName;
	*pVal = bstrTempName.copy();
	return S_OK;
}

STDMETHODIMP CIISCertRequest::put_Info_FriendlyName(BSTR newVal)
{
    // buffer overflow paranoia, make sure it's less than 255 characters long
    if (wcslen(newVal) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}
    m_Info_FriendlyName = newVal;
	return S_OK;
}

STDMETHODIMP CIISCertRequest::get_Info_Country(BSTR *pVal)
{
	_bstr_t bstrTempName = (LPCTSTR) m_Info_Country;
	*pVal = bstrTempName.copy();
	return S_OK;
}

STDMETHODIMP CIISCertRequest::put_Info_Country(BSTR newVal)
{
    // buffer overflow paranoia, make sure it's less than 255 characters long
    if (wcslen(newVal) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}
    m_Info_Country = newVal;
	return S_OK;
}

STDMETHODIMP CIISCertRequest::get_Info_State(BSTR *pVal)
{
	_bstr_t bstrTempName = (LPCTSTR) m_Info_State;
	*pVal = bstrTempName.copy();
	return S_OK;
}

STDMETHODIMP CIISCertRequest::put_Info_State(BSTR newVal)
{
    // buffer overflow paranoia, make sure it's less than 255 characters long
    if (wcslen(newVal) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}
    m_Info_State = newVal;
	return S_OK;
}

STDMETHODIMP CIISCertRequest::get_Info_Locality(BSTR *pVal)
{
	_bstr_t bstrTempName = (LPCTSTR) m_Info_Locality;
	*pVal = bstrTempName.copy();
	return S_OK;
}

STDMETHODIMP CIISCertRequest::put_Info_Locality(BSTR newVal)
{
    // buffer overflow paranoia, make sure it's less than 255 characters long
    if (wcslen(newVal) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}
    m_Info_Locality = newVal;
	return S_OK;
}

STDMETHODIMP CIISCertRequest::get_Info_Organization(BSTR *pVal)
{
	_bstr_t bstrTempName = (LPCTSTR) m_Info_Organization;
	*pVal = bstrTempName.copy();
	return S_OK;
}

STDMETHODIMP CIISCertRequest::put_Info_Organization(BSTR newVal)
{
    // buffer overflow paranoia, make sure it's less than 255 characters long
    if (wcslen(newVal) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}
    m_Info_Organization = newVal;
	return S_OK;
}

STDMETHODIMP CIISCertRequest::get_Info_OrganizationUnit(BSTR *pVal)
{
	_bstr_t bstrTempName = (LPCTSTR) m_Info_OrganizationUnit;
	*pVal = bstrTempName.copy();
	return S_OK;
}

STDMETHODIMP CIISCertRequest::put_Info_OrganizationUnit(BSTR newVal)
{
    // buffer overflow paranoia, make sure it's less than 255 characters long
    if (wcslen(newVal) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}
    m_Info_OrganizationUnit = newVal;
	return S_OK;
}

STDMETHODIMP CIISCertRequest::get_Info_CAName(BSTR *pVal)
{
	_bstr_t bstrTempName = (LPCTSTR) m_Info_CAName;
	*pVal = bstrTempName.copy();
	return S_OK;
}

STDMETHODIMP CIISCertRequest::put_Info_CAName(BSTR newVal)
{
    // buffer overflow paranoia, make sure it's less than 255 characters long
    if (wcslen(newVal) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}
    m_Info_CAName = newVal;
	return S_OK;
}

STDMETHODIMP CIISCertRequest::get_Info_ExpirationDate(BSTR *pVal)
{
	_bstr_t bstrTempName = (LPCTSTR) m_Info_ExpirationDate;
	*pVal = bstrTempName.copy();
	return S_OK;
}

STDMETHODIMP CIISCertRequest::put_Info_ExpirationDate(BSTR newVal)
{
    // buffer overflow paranoia, make sure it's less than 255 characters long
    if (wcslen(newVal) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}
    m_Info_ExpirationDate = newVal;
	return S_OK;
}

STDMETHODIMP CIISCertRequest::get_Info_Usage(BSTR *pVal)
{
	_bstr_t bstrTempName = (LPCTSTR) m_Info_Usage;
	*pVal = bstrTempName.copy();
	return S_OK;
}

STDMETHODIMP CIISCertRequest::put_Info_Usage(BSTR newVal)
{
    // buffer overflow paranoia, make sure it's less than 255 characters long
    if (wcslen(newVal) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}
    m_Info_Usage = newVal;
	return S_OK;
}

STDMETHODIMP CIISCertRequest::get_Info_AltSubject(BSTR *pVal)
{
	_bstr_t bstrTempName = (LPCTSTR) m_Info_AltSubject;
	*pVal = bstrTempName.copy();
	return S_OK;
}

STDMETHODIMP CIISCertRequest::put_Info_AltSubject(BSTR newVal)
{
    // buffer overflow paranoia, make sure it's less than 255 characters long
    if (wcslen(newVal) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}
    m_Info_Usage = newVal;
	return S_OK;
}

STDMETHODIMP CIISCertRequest::get_DispositionMessage(BSTR *pVal)
{
	_bstr_t bstrTempName = (LPCTSTR) m_DispositionMessage;
	*pVal = bstrTempName.copy();
	return S_OK;
}

STDMETHODIMP CIISCertRequest::put_DispositionMessage(BSTR newVal)
{
    // buffer overflow paranoia, make sure it's less than 255 characters long
    if (wcslen(newVal) > _MAX_PATH){return RPC_S_STRING_TOO_LONG;}
    m_DispositionMessage = newVal;
	return S_OK;
}

HRESULT CIISCertRequest::CreateDN(CString& str)
{
	str.Empty();
	str += _T("CN=") + m_Info_CommonName;
	str += _T("\n,OU=") + m_Info_OrganizationUnit;
	str += _T("\n,O=") + m_Info_Organization;
	str += _T("\n,L=") + m_Info_Locality;
	str += _T("\n,S=") + m_Info_State;
	str += _T("\n,C=") + m_Info_Country;
    return S_OK;
}

void CIISCertRequest::GetCertificateTemplate(CString& str)
{
	str = _T("CertificateTemplate:");
	str += m_Info_CertificateTemplate;
}

IEnroll * CIISCertRequest::GetEnrollObject()
{
	if (m_pEnroll == NULL)
	{
		m_hResult = CoCreateInstance(CLSID_CEnroll,NULL,CLSCTX_INPROC_SERVER,IID_IEnroll,(void **)&m_pEnroll);
		// now we need to change defaults for this
		// object to LOCAL_MACHINE
		if (m_pEnroll != NULL)
		{
			long dwFlags;
			VERIFY(SUCCEEDED(m_pEnroll->get_MyStoreFlags(&dwFlags)));
			dwFlags &= ~CERT_SYSTEM_STORE_LOCATION_MASK;
			dwFlags |= CERT_SYSTEM_STORE_LOCAL_MACHINE;
			// following call will change Request store flags also
			VERIFY(SUCCEEDED(m_pEnroll->put_MyStoreFlags(dwFlags)));
			VERIFY(SUCCEEDED(m_pEnroll->get_GenKeyFlags(&dwFlags)));
			dwFlags |= CRYPT_EXPORTABLE;
			VERIFY(SUCCEEDED(m_pEnroll->put_GenKeyFlags(dwFlags)));
			VERIFY(SUCCEEDED(m_pEnroll->put_KeySpec(AT_KEYEXCHANGE)));
			VERIFY(SUCCEEDED(m_pEnroll->put_ProviderType(m_Info_DefaultProviderType)));
			VERIFY(SUCCEEDED(m_pEnroll->put_DeleteRequestCert(TRUE)));
		}
	}
	ASSERT(m_pEnroll != NULL);
	return m_pEnroll;
}

PCCERT_CONTEXT CIISCertRequest::GetInstalledCert()
{
	if (m_pInstalledCert == NULL)
	{
		m_pInstalledCert = ::GetInstalledCert(m_ServerName,m_InstanceName,GetEnrollObject(),&m_hResult);
	}
	return m_pInstalledCert;
}

PCCERT_CONTEXT CIISCertRequest::GetPendingRequest()
{
	if (m_pPendingRequest == NULL)
	{
		ASSERT(!m_InstanceName.IsEmpty());
		m_pPendingRequest = GetPendingDummyCert(m_InstanceName, GetEnrollObject(), &m_hResult);
	}
	return m_pPendingRequest;
}

STDMETHODIMP CIISCertRequest::SubmitRequest()
{
    HRESULT hRes = E_INVALIDARG;
    BOOL bTryToGetDispositionErrorString = FALSE;
	ICertRequest * pCertRequest = NULL;
    LONG ldisposition;
    BSTR bstrRequest = NULL;
    BSTR bstrOutCert = NULL;
    CString strAttrib;
    CString strDN;

    // validate input to see that we have everything we need...
    if (m_Info_ConfigCA.IsEmpty())
    {
        hRes = E_INVALIDARG;
        goto SubmitRequest_Exit;
    }

    if (FAILED(hRes = CoCreateInstance(CLSID_CCertRequest, NULL, CLSCTX_INPROC_SERVER, IID_ICertRequest, (void **)&pCertRequest)))
    {
        goto SubmitRequest_Exit;
    }

    if (!pCertRequest)
    {
        hRes = E_FAIL;
        goto SubmitRequest_Exit;
    }

    if (FAILED(hRes = CreateDN(strDN)))
    {
        goto SubmitRequest_Exit;
    }

    if (FAILED(hRes = CreateRequest_Base64((BSTR)(LPCTSTR)strDN, GetEnrollObject(), 
                            m_Info_DefaultCSP ? NULL : (LPTSTR)(LPCTSTR)m_Info_CspName,
                            m_Info_DefaultCSP ? m_Info_DefaultProviderType : m_Info_CustomProviderType,
                            &bstrRequest)))
    {
        goto SubmitRequest_Exit;
    }

    bTryToGetDispositionErrorString = TRUE;
    GetCertificateTemplate(strAttrib);
	if (FAILED(hRes = pCertRequest->Submit(CR_IN_BASE64 | CR_IN_PKCS10, bstrRequest, (BSTR)(LPCTSTR)strAttrib, (LPTSTR)(LPCTSTR)m_Info_ConfigCA, &ldisposition)))
    {
		IISDebugOutput(_T("Submit bstrRequest returned HRESULT 0x%x; Disposition %x\n"), hRes, ldisposition);
        goto SubmitRequest_Exit;
    }

	if (ldisposition != CR_DISP_ISSUED)
	{
		switch (ldisposition) 
		{
			case CR_DISP_INCOMPLETE:
			case CR_DISP_ERROR:
			case CR_DISP_DENIED:
			case CR_DISP_ISSUED_OUT_OF_BAND:
			case CR_DISP_UNDER_SUBMISSION:
                {
                    HRESULT hrLastStatus = 0;
                    if (SUCCEEDED(pCertRequest->GetLastStatus(&hrLastStatus)))
                    {
                        hRes = hrLastStatus;
                    }
				}
				break;
			default:
                {
                    if (SUCCEEDED(hRes))
                    {
                        hRes = E_FAIL;
                    }
                    break;
                }
		}
        goto SubmitRequest_Exit;
    }

	if (FAILED(hRes = pCertRequest->GetCertificate(CR_OUT_BASE64 /*| CR_OUT_CHAIN */, &bstrOutCert)))
	{
        goto SubmitRequest_Exit;
    }
	
    CRYPT_DATA_BLOB blob;
	blob.cbData = SysStringByteLen(bstrOutCert);
	blob.pbData = (BYTE *)bstrOutCert;
	if (FAILED(hRes = GetEnrollObject()->acceptPKCS7Blob(&blob)))
	{
        goto SubmitRequest_Exit;
	}

	PCCERT_CONTEXT pContext = GetCertContextFromPKCS7(blob.pbData, blob.cbData, NULL, &hRes);
	ASSERT(pContext != NULL);
	if (pContext != NULL)
	{
		BYTE HashBuffer[40];                // give it some extra size
		DWORD dwHashSize = sizeof(HashBuffer);
		if (CertGetCertificateContextProperty(pContext,CERT_SHA1_HASH_PROP_ID,(VOID *) HashBuffer,&dwHashSize))
		{
			CRYPT_HASH_BLOB hash_blob = {dwHashSize, HashBuffer};
            InstallHashToMetabase(&hash_blob,m_ServerName,m_InstanceName,&hRes);
		}
		CertFreeCertificateContext(pContext);
	}

	// now put extra properties to the installed cert
	if (NULL != (pContext = GetInstalledCert()))
	{
		if (!(AttachFriendlyName(pContext, m_Info_FriendlyName, &hRes)))
		{
            // forget the error if we can't attach the friendly name..
		}
	}
	

SubmitRequest_Exit:
    if (FAILED(hRes))
    {
        // CreateRequest_Base64 failed.
        // likely with "NTE_BAD_ALGID _HRESULT_TYPEDEF_(0x80090008L)"
        LPTSTR lpBuffer = NULL;
        if (0 != FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,NULL,hRes,MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT),(LPTSTR)&lpBuffer,0,NULL))
        {
            if (lpBuffer)
            {
                m_DispositionMessage = lpBuffer;
            }
        }

        if (bTryToGetDispositionErrorString)
        {
            if (NULL == lpBuffer)
            {
                BSTR bstr = NULL;
                if (SUCCEEDED(pCertRequest->GetDispositionMessage(&bstr)))
                {
                    m_DispositionMessage = bstr;
                    if (bstr) {SysFreeString(bstr);}
                }
            }
        }

        if (lpBuffer) {LocalFree (lpBuffer);}
    }
    if (bstrOutCert)
    {
        SysFreeString(bstrOutCert);bstrOutCert=NULL;
    }
    if (bstrRequest)
    {
        SysFreeString(bstrRequest);bstrRequest=NULL;
    }
    if (pCertRequest)
    {
        pCertRequest->Release();pCertRequest=NULL;
    }
    IISDebugOutput(_T("SubmitRequest:end:hres=0x%x;\n"), hRes);

    m_hResult = hRes;
	return hRes;
}

// Instead of renewal we create new certificate based on parameters
// from the current one. After creation we install this certificate in place
// of current one and deleting the old one from store. Even if IIS has an
// opened SSL connection it should get a notification and update the certificate
// data.
//
STDMETHODIMP CIISCertRequest::SubmitRenewalRequest()
{
    HRESULT hRes = E_FAIL;
    if (LoadRenewalData())
    {
        if (SetSecuritySettings())
        {
            PCCERT_CONTEXT pCurrent = GetInstalledCert();
            m_pInstalledCert = NULL;
            hRes = SubmitRequest();
            if (SUCCEEDED(hRes))
            {
                CertDeleteCertificateFromStore(pCurrent);
            }
        }
    }
    return hRes;
}

BOOL CIISCertRequest::SetSecuritySettings()
{
	long dwGenKeyFlags;
	if (SUCCEEDED(GetEnrollObject()->get_GenKeyFlags(&dwGenKeyFlags)))
	{
		dwGenKeyFlags &= 0x0000FFFF;
		dwGenKeyFlags |= (m_KeyLength << 16);
		if (m_SGCcertificat)
        {
			dwGenKeyFlags |= CRYPT_SGCKEY;
        }
		return (SUCCEEDED(GetEnrollObject()->put_GenKeyFlags(dwGenKeyFlags)));
	}
	return FALSE;
}

BOOL CIISCertRequest::GetCertDescription(PCCERT_CONTEXT pCert,CERT_DESCRIPTION& desc)
{
	BOOL bRes = FALSE;
	DWORD cb;
	UINT i, j;
	CERT_NAME_INFO * pNameInfo;

	if (pCert == NULL)
		goto ErrExit;

	if (	!CryptDecodeObject(X509_ASN_ENCODING, X509_UNICODE_NAME,
					pCert->pCertInfo->Subject.pbData,
					pCert->pCertInfo->Subject.cbData,
					0, NULL, &cb)
		||	NULL == (pNameInfo = (CERT_NAME_INFO *)_alloca(cb))
		|| !CryptDecodeObject(X509_ASN_ENCODING, X509_UNICODE_NAME,
					pCert->pCertInfo->Subject.pbData,
					pCert->pCertInfo->Subject.cbData,
					0, 
					pNameInfo, &cb)
					)
	{
		goto ErrExit;
	}

	for (i = 0; i < pNameInfo->cRDN; i++)
	{
		CERT_RDN rdn = pNameInfo->rgRDN[i];
		for (j = 0; j < rdn.cRDNAttr; j++)
		{
			CERT_RDN_ATTR attr = rdn.rgRDNAttr[j];
			if (strcmp(attr.pszObjId, szOID_COMMON_NAME) == 0)
			{
				FormatRdnAttr(desc.m_Info_CommonName, attr.dwValueType, attr.Value, FALSE);
			}
			else if (strcmp(attr.pszObjId, szOID_COUNTRY_NAME) == 0)
			{
				FormatRdnAttr(desc.m_Info_Country, attr.dwValueType, attr.Value, TRUE);
			}
			else if (strcmp(attr.pszObjId, szOID_LOCALITY_NAME) == 0)
			{
				FormatRdnAttr(desc.m_Info_Locality, attr.dwValueType, attr.Value, TRUE);
			}
			else if (strcmp(attr.pszObjId, szOID_STATE_OR_PROVINCE_NAME) == 0)
			{
				FormatRdnAttr(desc.m_Info_State, attr.dwValueType, attr.Value, TRUE);
			}
			else if (strcmp(attr.pszObjId, szOID_ORGANIZATION_NAME) == 0)
			{
				FormatRdnAttr(desc.m_Info_Organization, attr.dwValueType, attr.Value, TRUE);
			}
			else if (strcmp(attr.pszObjId, szOID_ORGANIZATIONAL_UNIT_NAME) == 0)
			{
				FormatRdnAttr(desc.m_Info_OrganizationUnit, attr.dwValueType, attr.Value, TRUE);
			}
		}
	}

	// issued to
	if (!GetNameString(pCert, CERT_NAME_SIMPLE_DISPLAY_TYPE, CERT_NAME_ISSUER_FLAG, desc.m_Info_CAName, &m_hResult))
    {
		goto ErrExit;
    }

	// expiration date
	if (!FormatDateString(desc.m_Info_ExpirationDate, pCert->pCertInfo->NotAfter, FALSE, FALSE))
	{
		goto ErrExit;
	}

	// purpose
	if (!FormatEnhancedKeyUsageString(desc.m_Info_Usage, pCert, FALSE, FALSE, &m_hResult))
	{
		// According to local experts, we should also use certs without this property set
		ASSERT(FALSE);
		//goto ErrExit;
	}

	// friendly name
	if (!GetFriendlyName(pCert, desc.m_Info_FriendlyName, &m_hResult))
	{
		//desc.m_Info_FriendlyName.LoadString(IDS_FRIENDLYNAME_NONE);
        desc.m_Info_FriendlyName = _T("<>");
	}

    // get the alternate subject name if subject is empty
    // will use this as display only if subject name does not exist.
    if (desc.m_Info_CommonName.IsEmpty())
    {
        TCHAR * pwszOut = NULL;
        GetAlternateSubjectName(pCert,&pwszOut);
        if (pwszOut)
        {
            desc.m_Info_AltSubject = pwszOut;
            LocalFree(pwszOut);pwszOut = NULL;
        }
    }

    bRes = TRUE;

ErrExit:
	return bRes;
}

BOOL CIISCertRequest::LoadRenewalData()
{
    // we need to obtain data from the installed cert
    CERT_DESCRIPTION desc;
    ASSERT(GetInstalledCert() != NULL);
    BOOL res = FALSE;
	DWORD cbData;
	BYTE * pByte = NULL;
    DWORD len = 0;

    if (!GetCertDescription(GetInstalledCert(), desc))
    {
        res = FALSE;
        goto ErrorExit;
    }

	m_Info_CommonName = desc.m_Info_CommonName;
	m_Info_FriendlyName = desc.m_Info_FriendlyName;
	m_Info_Country = desc.m_Info_Country;
	m_Info_State = desc.m_Info_State;
	m_Info_Locality = desc.m_Info_Locality;
	m_Info_Organization = desc.m_Info_Organization;
	m_Info_OrganizationUnit = desc.m_Info_OrganizationUnit;

    len = CertGetPublicKeyLength(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, &GetInstalledCert()->pCertInfo->SubjectPublicKeyInfo);
    if (len == 0)
    {
        m_hResult = HRESULT_FROM_WIN32(GetLastError());
        goto ErrorExit;
    }
    //
    m_KeyLength = len;

	// compare property value
	if (CertGetCertificateContextProperty(GetInstalledCert(), CERT_KEY_PROV_INFO_PROP_ID, NULL, &cbData)
		&& (NULL != (pByte = (BYTE *)_alloca(cbData)))
		&& CertGetCertificateContextProperty(GetInstalledCert(), CERT_KEY_PROV_INFO_PROP_ID, pByte, &cbData)
        )
    {
        CRYPT_KEY_PROV_INFO * pProvInfo = (CRYPT_KEY_PROV_INFO *)pByte;

        if (pProvInfo->dwProvType != m_Info_DefaultProviderType)
        {
            m_Info_DefaultCSP = FALSE;
            m_Info_CustomProviderType = pProvInfo->dwProvType;
            m_Info_CspName = pProvInfo->pwszProvName;
        }

        LPCSTR rgbpszUsageArray[2];
        SecureZeroMemory( &rgbpszUsageArray, sizeof(rgbpszUsageArray) );
        rgbpszUsageArray[0] = szOID_SERVER_GATED_CRYPTO;
        rgbpszUsageArray[1] = szOID_SGC_NETSCAPE;
        DWORD dwCount=sizeof(rgbpszUsageArray)/sizeof(rgbpszUsageArray[0]);

        m_SGCcertificat = FALSE;
        if (1 == ContainsKeyUsageProperty(GetInstalledCert(),rgbpszUsageArray,dwCount,&m_hResult))
        {
            m_SGCcertificat = TRUE;
        }
        res = TRUE;
    }
    else
    {
         m_hResult = HRESULT_FROM_WIN32(GetLastError());
         goto ErrorExit;
    }

ErrorExit:
    return res;
}

BOOL CIISCertRequest::PrepareRequestString(CString& request_text, CCryptBlob& request_blob, BOOL bLoadFromRenewalData)
{
    BOOL bReturn = FALSE;
	CString strDN;
    LPSTR pNewMessage = NULL;
	TCHAR szUsage[] = _T(szOID_PKIX_KP_SERVER_AUTH);

    if (TRUE == bLoadFromRenewalData)
    {
        if (FALSE == LoadRenewalData())
        {
            goto PrepareRequestString_Exit;
        }
        if (FALSE == SetSecuritySettings())
        {
            goto PrepareRequestString_Exit;
        }
    }

    CreateDN(strDN);
    ASSERT(!strDN.IsEmpty());

    GetEnrollObject()->put_ProviderType(m_Info_DefaultCSP ? m_Info_DefaultProviderType : m_Info_CustomProviderType);
    if (!m_Info_DefaultCSP)
    {
        GetEnrollObject()->put_ProviderNameWStr((LPTSTR)(LPCTSTR)m_Info_CspName);
        // We are supporting only these two types of CSP, it is pretty safe to
        // have just two options, because we are using the same two types when
        // we are populating CSP selection list.
        if (m_Info_CustomProviderType == PROV_DH_SCHANNEL)
        {
            GetEnrollObject()->put_KeySpec(AT_SIGNATURE);
        }
        else if (m_Info_CustomProviderType == PROV_RSA_SCHANNEL)
        {
            GetEnrollObject()->put_KeySpec(AT_KEYEXCHANGE);
        }
    }

	if (FAILED(m_hResult = GetEnrollObject()->createPKCS10WStr((LPTSTR)(LPCTSTR)strDN,szUsage,request_blob)))
	{
		goto PrepareRequestString_Exit;
	}

	// BASE64 encode pkcs 10
	DWORD cch = 0;
	TCHAR * psz = NULL;
    if (FAILED(Base64EncodeW(request_blob.GetData(), request_blob.GetSize(), NULL, &cch)))
    {
        goto PrepareRequestString_Exit;
    }

    psz = (TCHAR *) LocalAlloc(LPTR, (cch+1) * sizeof(TCHAR));
    if (NULL == psz)
    {
        goto PrepareRequestString_Exit;
    }

    if (FAILED(Base64EncodeW(request_blob.GetData(), request_blob.GetSize(), psz, &cch)))
	{
        goto PrepareRequestString_Exit;
	}
    psz[cch] = '\0';

    request_text = MESSAGE_HEADER;
    request_text += psz;
    request_text += MESSAGE_TRAILER;

    bReturn = TRUE;

PrepareRequestString_Exit:
    if (psz){LocalFree(psz);psz=NULL;}
	return bReturn;
}

BOOL CIISCertRequest::WriteRequestString(CString& request)
{
	ASSERT(!PathIsRelative(m_ReqFileName));
	BOOL bRes = FALSE;
    TCHAR szPath[_MAX_PATH];

    if (m_ReqFileName.GetLength() > _MAX_PATH)
    {
        m_hResult = E_INVALIDARG;
        return FALSE;
    }
	StringCbCopy(szPath,sizeof(szPath),m_ReqFileName);
   
	PathRemoveFileSpec(szPath);
	if (!PathIsDirectory(szPath))
	{
		if (!CreateDirectoryFromPath(szPath, NULL))
		{
			m_hResult = HRESULT_FROM_WIN32(GetLastError());
			return FALSE;
		}
	}

	HANDLE hFile = ::CreateFile(m_ReqFileName,GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile != INVALID_HANDLE_VALUE)
	{
		DWORD cb = request.GetLength();
        char * ascii_buf = (char *) LocalAlloc(LPTR,cb);
        if (ascii_buf)
        {
		    wcstombs(ascii_buf, request, cb);
		    bRes = ::WriteFile(hFile, ascii_buf, cb, &cb, NULL);
		    ::CloseHandle(hFile);
            LocalFree(ascii_buf);ascii_buf=NULL;
        }
        else
        {
            m_hResult = HRESULT_FROM_WIN32(GetLastError());
        }
	}
	else
	{
		m_hResult = HRESULT_FROM_WIN32(GetLastError());
	}

	return bRes;
}

STDMETHODIMP CIISCertRequest::SaveRequestToFile()
{
    HRESULT hRes = E_FAIL;
	CString request_text;
	CCryptBlobIMalloc request_blob;
    CCryptBlobLocal name_blob, request_store_blob, status_blob;
    PCERT_REQUEST_INFO pReqInfo = NULL;
    HCERTSTORE hStore = NULL;
    PCCERT_CONTEXT pDummyCert = NULL;

    // AARONL CHANGED
    BOOL bLoadFromRenewalData = FALSE;
    
    IISDebugOutput(_T("SaveRequestToFile:start\r\n"));

	if (!PrepareRequestString(request_text,request_blob,bLoadFromRenewalData))
	{
        goto SaveRequestToFile_Exit;
    }

	if (!WriteRequestString(request_text))
	{
        goto SaveRequestToFile_Exit;
    }
	
	// prepare data we want to attach to dummy request
	if (!EncodeString(m_InstanceName, name_blob, &hRes))
    {
        goto SaveRequestToFile_Exit;
    }
    
    if (!EncodeInteger(m_status_code, status_blob, &hRes))
    {
        goto SaveRequestToFile_Exit;
    }

    // get back request from encoded data
    if (!GetRequestInfoFromPKCS10(request_blob, &pReqInfo, &hRes))
	{
        goto SaveRequestToFile_Exit;
    }

	// find dummy cert put to request store by createPKCS10 call
	hStore = OpenRequestStore(GetEnrollObject(), &hRes);
	if (NULL == hStore)
	{
        goto SaveRequestToFile_Exit;
    }

	pDummyCert = CertFindCertificateInStore(hStore,CRYPT_ASN_ENCODING,0,CERT_FIND_PUBLIC_KEY,(void *)&pReqInfo->SubjectPublicKeyInfo,NULL);
	if (NULL == pDummyCert)
	{
        goto SaveRequestToFile_Cleanup;
    }

    if (!CertSetCertificateContextProperty(pDummyCert,CERTWIZ_INSTANCE_NAME_PROP_ID, 0, name_blob))
    {
        hRes = HRESULT_FROM_WIN32(GetLastError());
        goto SaveRequestToFile_Cleanup;
    }

	if (!CertSetCertificateContextProperty(pDummyCert,CERTWIZ_REQUEST_FLAG_PROP_ID, 0, status_blob))
    {
        hRes = HRESULT_FROM_WIN32(GetLastError());
        goto SaveRequestToFile_Cleanup;
    }

	// put friendly name to dummy cert -- we will reuse it later
	if (!AttachFriendlyName(pDummyCert, m_Info_FriendlyName, &hRes))
    {
        hRes = HRESULT_FROM_WIN32(GetLastError());
        goto SaveRequestToFile_Cleanup;
    }

    hRes = S_OK;

    // put certificate text to the clipboard
    if (OpenClipboard(GetFocus()))
    {
        size_t len = request_text.GetLength() + 1;
        HANDLE hMem = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, len);
        LPSTR pMem = (LPSTR)GlobalLock(hMem);
        if (pMem != NULL)
        {
            wcstombs(pMem, request_text, len);
            GlobalUnlock(hMem);
            SetClipboardData(CF_TEXT, hMem);
        }
        CloseClipboard();
    }
	
SaveRequestToFile_Cleanup:
    if (NULL != pDummyCert)
    {
        CertFreeCertificateContext(pDummyCert);pDummyCert = NULL;
    }
    if (NULL != hStore)
    {
	    CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);hStore = NULL;
    }
    
SaveRequestToFile_Exit:
    if (pReqInfo)
    {
        LocalFree(pReqInfo);pReqInfo = NULL;
    }
    m_hResult = hRes;
    IISDebugOutput(_T("SaveRequestToFile:end ret=0x%x\r\n"),m_hResult);
    return hRes;
}

STDMETHODIMP CIISCertRequest::Info_Dump()
{
    m_ReqFileName = _T("c:\\reqtest1.txt");

    IISDebugOutput(_T("m_ServerName:%s\r\n"),(LPCTSTR) m_ServerName);
    IISDebugOutput(_T("m_UserName:%s\r\n"),(LPCTSTR) m_UserName);
    //IISDebugOutput(_T("m_UserPassword:%s\r\n"),(LPCTSTR) m_UserPassword);
    IISDebugOutput(_T("m_InstanceName:%s\r\n"),(LPCTSTR) m_InstanceName);

    // Certificate Request Info
	IISDebugOutput(_T("m_Info_CommonName=:%s\r\n"),(LPCTSTR) m_Info_CommonName);
	IISDebugOutput(_T("m_Info_FriendlyName:%s\r\n"),(LPCTSTR) m_Info_FriendlyName);
	IISDebugOutput(_T("m_Info_Country:%s\r\n"),(LPCTSTR) m_Info_Country);
	IISDebugOutput(_T("m_Info_State:%s\r\n"),(LPCTSTR) m_Info_State);
	IISDebugOutput(_T("m_Info_Locality:%s\r\n"),(LPCTSTR) m_Info_Locality);
	IISDebugOutput(_T("m_Info_Organization:%s\r\n"),(LPCTSTR) m_Info_Organization);
	IISDebugOutput(_T("m_Info_OrganizationUnit:%s\r\n"),(LPCTSTR) m_Info_OrganizationUnit);
	IISDebugOutput(_T("m_Info_CAName:%s\r\n"),(LPCTSTR) m_Info_CAName);
	IISDebugOutput(_T("m_Info_ExpirationDate:%s\r\n"),(LPCTSTR) m_Info_ExpirationDate);
	IISDebugOutput(_T("m_Info_Usage:%s\r\n"),(LPCTSTR) m_Info_Usage);
    IISDebugOutput(_T("m_Info_AltSubject:%s\r\n"),(LPCTSTR) m_Info_AltSubject);

    // other
    IISDebugOutput(_T("m_Info_ConfigCA:%s\r\n"),(LPCTSTR) m_Info_ConfigCA);
    IISDebugOutput(_T("m_Info_CertificateTemplate:%s\r\n"),(LPCTSTR) m_Info_CertificateTemplate);

    IISDebugOutput(_T("m_Info_DefaultProviderType:%d\r\n"),m_Info_DefaultProviderType);
    IISDebugOutput(_T("m_Info_CustomProviderType:%d\r\n"),m_Info_CustomProviderType);
    IISDebugOutput(_T("m_Info_DefaultCSP:%d\r\n"), m_Info_DefaultCSP);
    IISDebugOutput(_T("m_Info_CspName:%s\r\n"),(LPCTSTR) m_Info_CspName);

    IISDebugOutput(_T("m_pInstalledCert:%p\r\n"), m_pInstalledCert);
    IISDebugOutput(_T("m_ReqFileName:%s\r\n"),(LPCTSTR) m_ReqFileName);

    IISDebugOutput(_T("m_hResult:0x%x\r\n"), m_hResult);
    IISDebugOutput(_T("m_DispositionMessage:%s\r\n"),(LPCTSTR) m_DispositionMessage);
	return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certobj\password.cpp ===
#include "stdafx.h"
#include "password.h"
#include <strsafe.h>

// password categories
enum {STRONG_PWD_UPPER=0,STRONG_PWD_LOWER,STRONG_PWD_NUM,STRONG_PWD_PUNC};
#define STRONG_PWD_CATS (STRONG_PWD_PUNC + 1)
#define NUM_LETTERS 26
#define NUM_NUMBERS 10
#define MIN_PWD_LEN 8

// password must contain at least one each of: 
// uppercase, lowercase, punctuation and numbers
DWORD CreateGoodPassword(BYTE *szPwd, DWORD dwLen) 
{
    if (dwLen-1 < MIN_PWD_LEN)
    {
        return ERROR_PASSWORD_RESTRICTION;
    }

    HCRYPTPROV hProv;
    DWORD dwErr = 0;

    if (CryptAcquireContext(&hProv,NULL,NULL,PROV_RSA_FULL,CRYPT_VERIFYCONTEXT) == FALSE) 
    {
        return GetLastError();
    }

    // zero it out and decrement the size to allow for trailing '\0'
    SecureZeroMemory(szPwd,dwLen);
    dwLen--;

    // generate a pwd pattern, each byte is in the range 
    // (0..255) mod STRONG_PWD_CATS
    // this indicates which character pool to take a char from
    BYTE *pPwdPattern = new BYTE[dwLen];
    BOOL fFound[STRONG_PWD_CATS];
    do 
    {
        // bug!bug! does CGR() ever fail?
        CryptGenRandom(hProv,dwLen,pPwdPattern);

        fFound[STRONG_PWD_UPPER] = 
        fFound[STRONG_PWD_LOWER] =
        fFound[STRONG_PWD_PUNC] =
        fFound[STRONG_PWD_NUM] = FALSE;

        for (DWORD i=0; i < dwLen; i++)
        {
            fFound[pPwdPattern[i] % STRONG_PWD_CATS] = TRUE;
        }
        // check that each character category is in the pattern
    } while (!fFound[STRONG_PWD_UPPER] || !fFound[STRONG_PWD_LOWER] || !fFound[STRONG_PWD_PUNC] || !fFound[STRONG_PWD_NUM]);

    // populate password with random data 
    // this, in conjunction with pPwdPattern, is
    // used to determine the actual data
    CryptGenRandom(hProv,dwLen,szPwd);

    for (DWORD i=0; i < dwLen; i++) 
    {
        BYTE bChar = 0;

        // there is a bias in each character pool because of the % function
        switch (pPwdPattern[i] % STRONG_PWD_CATS) 
        {
            case STRONG_PWD_UPPER : bChar = 'A' + szPwd[i] % NUM_LETTERS;
                break;
            case STRONG_PWD_LOWER : bChar = 'a' + szPwd[i] % NUM_LETTERS;
                break;
            case STRONG_PWD_NUM :   bChar = '0' + szPwd[i] % NUM_NUMBERS;
                break;
            case STRONG_PWD_PUNC :
            default:
                char *szPunc="!@#$%^&*()_-+=[{]};:\'\"<>,./?\\|~`";
                DWORD dwLenPunc = lstrlenA(szPunc);
                bChar = szPunc[szPwd[i] % dwLenPunc];
                break;
        }
        szPwd[i] = bChar;
    }

	if (pPwdPattern)
	{
		delete [] pPwdPattern;
	}

    if (hProv != NULL) 
    {
        CryptReleaseContext(hProv,0);
    }
    return dwErr;
}


// Creates a secure password
// caller must LocalFree Return pointer
// iSize = size of password to create
LPTSTR CreatePassword(int iSize)
{
    LPTSTR pszPassword =  NULL;
    BYTE *szPwd = new BYTE[iSize];
    DWORD dwPwdLen = iSize;
    int i = 0;

    // use the new secure password generator
    // unfortunately this baby doesn't use unicode.
    // so we'll call it and then convert it to unicode afterwards.
    if (0 == CreateGoodPassword(szPwd,dwPwdLen))
    {
#if defined(UNICODE) || defined(_UNICODE)
        // convert it to unicode and copy it back into our unicode buffer.
        // compute the length
        i = MultiByteToWideChar(CP_ACP, 0, (LPSTR) szPwd, -1, NULL, 0);
        if (i <= 0) 
            {goto CreatePassword_Exit;}
        pszPassword = (LPTSTR) LocalAlloc(LPTR, i * sizeof(TCHAR));
        if (!pszPassword)
            {goto CreatePassword_Exit;}
        i =  MultiByteToWideChar(CP_ACP, 0, (LPSTR) szPwd, -1, pszPassword, i);
        if (i <= 0) 
            {
            LocalFree(pszPassword);
            pszPassword = NULL;
            goto CreatePassword_Exit;
            }
        // make sure ends with null
        pszPassword[i - 1] = 0;
#else
        pszPassword = (LPSTR) LocalAlloc(GPTR, _tcslen((LPTSTR) szPwd) * sizeof(TCHAR));
#endif

    }

CreatePassword_Exit:
    if (szPwd){delete [] szPwd;szPwd=NULL;}
    return pszPassword;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certobj\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certobj\process.cpp ===
#include "stdafx.h"
#include "CertObj.h"
#include "common.h"
#include "process.h"

//////////////////////////////////////////////////////////////////

BOOL GetProcessName(LPTSTR szProcname, DWORD dwSize)
{
	TCHAR szPath[MAX_PATH], szFilename[MAX_PATH], *ptr;

	// Get the path to the calling process
	if (!GetModuleFileName(NULL, szPath, MAX_PATH))
		return FALSE;

	// Get the filename of the process without the extension
	ptr = _tcsrchr(szPath, '\\');
	if (ptr)
		_tcscpy(szFilename, ++ptr);
	else
		_tcscpy(szFilename, szPath);

	ptr = _tcsrchr(szFilename, '.');
	if (ptr)
		*ptr = 0;

	// Convert the name to all caps
	_tcsupr(szFilename);

	// Return the information
	if (_tcslen(szFilename) > dwSize)
		return FALSE;

	_tcscpy(szProcname, szFilename);

	return TRUE;
}

BOOL AmIAlreadyRemoted()
{
	BOOL bReturn = FALSE;

	// check if the process i'm in is inside a Dllhost.exe
	TCHAR szProcName[MAX_PATH];;
	GetProcessName(szProcName, MAX_PATH);

	if (!_tcsicmp(szProcName, _T("DLLHOST")))
	{
		IISDebugOutput(_T("Remoted in Dllhost\r\n"));
		bReturn = TRUE;
	}
	else
	{
		IISDebugOutput(_T("InProcess\r\n"));
	}

	return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certobj\iiscertobj.h ===
// IISCertObj.h : Declaration of the CIISCertObj

#ifndef __IISCERTOBJ_H_
#define __IISCERTOBJ_H_

#include "resource.h"       // main symbols

#define NUMBER_OF_AUTOMATION_INTERFACES 20
/////////////////////////////////////////////////////////////////////////////
// CIISCertObj
class ATL_NO_VTABLE CIISCertObj : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CIISCertObj, &CLSID_IISCertObj>,
    public IDispatchImpl<IIISCertObj, &IID_IIISCertObj, &LIBID_CERTOBJLib>
{
public:
    CIISCertObj()
	{
		m_lpwszUserPasswordEncrypted = NULL;
		m_cbUserPasswordEncrypted = 0;
		m_RemoteObjCoCreateCount = 0;

		m_ServerName.Empty();
		m_UserName.Empty();
		m_InstanceName.Empty();

		IISDebugOutput(_T("CIISCertObj::CIISCertObj\r\n"));

		m_ppRemoteInterfaces = new IIISCertObj * [NUMBER_OF_AUTOMATION_INTERFACES];
		for (int i = 0; i < NUMBER_OF_AUTOMATION_INTERFACES; i++)
		{
			m_ppRemoteInterfaces[i] = NULL;
		}
	}
    ~CIISCertObj()
	{
		if (m_lpwszUserPasswordEncrypted)
		{
			if (m_cbUserPasswordEncrypted > 0)
			{
				SecureZeroMemory(m_lpwszUserPasswordEncrypted,m_cbUserPasswordEncrypted);
			}
			LocalFree(m_lpwszUserPasswordEncrypted);
			m_lpwszUserPasswordEncrypted = NULL;
			m_cbUserPasswordEncrypted = 0;
		}

		// Release any opened remotes we might have.
		FreeRemoteInterfaces();
	}

DECLARE_REGISTRY_RESOURCEID(IDR_IISCERTOBJ)
DECLARE_NOT_AGGREGATABLE(CIISCertObj)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CIISCertObj)
	COM_INTERFACE_ENTRY(IIISCertObj)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IIISCertObj
public:
    STDMETHOD(put_InstanceName)(BSTR newVal);
    STDMETHOD(put_UserName)(BSTR newVal);
    STDMETHOD(put_UserPassword)(BSTR newVal);
    STDMETHOD(put_ServerName)(BSTR newVal);
    STDMETHOD(IsInstalled)(VARIANT_BOOL * retval);
    STDMETHOD(IsInstalledRemote)(VARIANT_BOOL * retval);
    STDMETHOD(IsExportable)(VARIANT_BOOL * retval);
    STDMETHOD(IsExportableRemote)(VARIANT_BOOL * retval);
    STDMETHOD(GetCertInfo)(VARIANT * pVtArray);
    STDMETHOD(GetCertInfoRemote)(VARIANT * pVtArray);
    STDMETHOD(Copy)(
        VARIANT_BOOL bAllowExport,
        VARIANT_BOOL bOverWriteExisting,
        BSTR DestinationServerName, 
        BSTR DestinationServerInstance, 
        VARIANT DestinationServerUserName OPTIONAL, 
        VARIANT DestinationServerPassword OPTIONAL);
    STDMETHOD(Move)(
        VARIANT_BOOL bAllowExport,
        VARIANT_BOOL bOverWriteExisting,
        BSTR DestinationServerName, 
        BSTR DestinationServerInstance, 
        VARIANT DestinationServerUserName OPTIONAL, 
        VARIANT DestinationServerPassword OPTIONAL);
    STDMETHOD(RemoveCert)(
        VARIANT_BOOL bRemoveFromCertStore,
        VARIANT_BOOL bPrivateKey);
    STDMETHOD(Import)(
        BSTR FileName, 
        BSTR Password, 
        VARIANT_BOOL bAllowExport,
        VARIANT_BOOL bOverWriteExisting);
    STDMETHOD(ImportToCertStore)(
        BSTR FileName, 
        BSTR Password, 
        VARIANT_BOOL bAllowExport, 
        VARIANT_BOOL bOverWriteExisting, 
        VARIANT* BinaryVariant);
    STDMETHOD(ImportFromBlob)(
        BSTR InstanceName, 
        BSTR Password, 
        VARIANT_BOOL bInstallToMetabase, 
        VARIANT_BOOL bAllowExport, 
        VARIANT_BOOL bOverWriteExisting, 
        DWORD pcbSize, 
        char * pBlobBinary);
    STDMETHOD(ImportFromBlobGetHash)(
        BSTR InstanceName, 
        BSTR Password, 
        VARIANT_BOOL bInstallToMetabase, 
        VARIANT_BOOL bAllowExport, 
        VARIANT_BOOL bOverWriteExisting, 
        DWORD pcbSize, 
        char * pBlobBinary, 
        DWORD * pcbCertHashSize, 
        char ** bCertHash);
    STDMETHOD(Export)(
        BSTR FileName, 
        BSTR Password, 
        VARIANT_BOOL bPrivateKey, 
        VARIANT_BOOL bCertChain, 
        VARIANT_BOOL bRemoveCert);
    STDMETHOD(ExportToBlob)(
        BSTR InstanceName, 
        BSTR Password, 
        VARIANT_BOOL bPrivateKey, 
        VARIANT_BOOL bCertChain, 
        DWORD * pcbSize, 
        char ** pBlobBinary);

private:
    CComBSTR m_ServerName;
    CComBSTR m_UserName;
	LPWSTR  m_lpwszUserPasswordEncrypted;
	DWORD   m_cbUserPasswordEncrypted;

    CComBSTR m_InstanceName;
	int     m_RemoteObjCoCreateCount;
	IIISCertObj ** m_ppRemoteInterfaces;

    IIISCertObj * GetObject(HRESULT * phr);
    IIISCertObj * GetObject(HRESULT * phr, CComBSTR csServerName,CComBSTR csUserName OPTIONAL,CComBSTR csUserPassword OPTIONAL);
    HRESULT CopyOrMove(VARIANT_BOOL bRemoveFromCertAfterCopy,VARIANT_BOOL bCopyCertDontInstallRetHash,VARIANT_BOOL bAllowExport,VARIANT_BOOL bOverWriteExisting,VARIANT * pVtArray,BSTR bstrDestinationServerName,BSTR bstrDestinationServerInstance,VARIANT varDestinationServerUserName, VARIANT varDestinationServerPassword);
	void AddRemoteInterface(IIISCertObj * pAddMe);
	void DelRemoteInterface(IIISCertObj * pRemoveMe);
	void FreeRemoteInterfaces(void);
};
HRESULT RemoveCertProxy(IIISCertObj * pObj,BSTR InstanceName, VARIANT_BOOL bPrivateKey);
HRESULT ImportFromBlobProxy(IIISCertObj * pObj,BSTR InstanceName,BSTR Password,VARIANT_BOOL bInstallToMetabase,VARIANT_BOOL bAllowExport,VARIANT_BOOL bOverWriteExisting,DWORD actual,BYTE *pData,DWORD *cbHashBufferSize,char **pbHashBuffer);
HRESULT ExportToBlobProxy(IIISCertObj * pObj,BSTR InstanceName,BSTR Password,VARIANT_BOOL bPrivateKey,VARIANT_BOOL bCertChain,DWORD * pcbSize,char ** pBlobBinary);

#endif //__IISCERTOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\base64.h ===
//
// base64.h
//
#ifndef _BASE64_H
#define _BASE64_H

DWORD Base64DecodeA(const char * pchIn, DWORD cchIn, BYTE * pbOut, DWORD * pcbOut);
DWORD Base64EncodeA(const BYTE * pbIn, DWORD cbIn, char * pchOut, DWORD * pcchOut);
DWORD Base64EncodeW(BYTE const *pbIn, DWORD cbIn, WCHAR *wszOut, DWORD *pcchOut);
DWORD Base64DecodeW(const WCHAR * wszIn, DWORD cch, BYTE *pbOut, DWORD *pcbOut);

#endif	//_BASE64_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certobj\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by CertObj.rc
//
#define IDS_PROJNAME                    100
#define IDR_IISCERTOBJ                  101
#define IDS_ANY                         101
#define IDR_IISCERTREQUEST              102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certobj\process.h ===
#include "stdafx.h"

BOOL AmIAlreadyRemoted();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certobjt\iisdebug.h ===
#include <windows.h>
#include <tchar.h>

#define DEBUG_FLAG

#ifdef DEBUG_FLAG
    inline void _cdecl DebugTrace(LPTSTR lpszFormat, ...)
    {
	    int nBuf;
	    TCHAR szBuffer[512];
	    va_list args;
	    va_start(args, lpszFormat);

	    nBuf = _vsntprintf(szBuffer, sizeof(szBuffer), lpszFormat, args);
	    //ASSERT(nBuf < sizeof(szBuffer)); //Output truncated as it was > sizeof(szBuffer)

	    OutputDebugString(szBuffer);
	    va_end(args);
    }
#else
    inline void _cdecl DebugTrace(LPTSTR , ...){}
#endif

#define IISDebugOutput DebugTrace
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certobjt\main.cpp ===
#include <stdio.h>

#define INITGUID // must be before guid stuff

#include "iisdebug.h"

#include "certobj.h"      // Interface header
#include "certobj_i.c"

BOOL TestCertObj(void);

LPSTR StripWhitespace( LPSTR pszString )
{
    LPSTR pszTemp = NULL;

    if ( pszString == NULL ) {
        return NULL;
    }

    while ( *pszString == ' ' || *pszString == '\t' ) {
        pszString += 1;
    }

    // Catch case where string consists entirely of whitespace or empty string.
    if ( *pszString == '\0' ) {
        return pszString;
    }

    pszTemp = pszString;

    pszString += lstrlenA(pszString) - 1;

    while ( *pszString == ' ' || *pszString == '\t' ) {
        *pszString = '\0';
        pszString -= 1;
    }

    return pszTemp;
}

void
ShowHelp()
{
    wprintf(L"tests the CertObj control\n\n");
    return;
}

int __cdecl 
main(
     int argc,
     char *argv[]
)
{
    BOOL fRet = FALSE;
    int argno;
	char * pArg = NULL;
	char * pCmdStart = NULL;
    char szTempString[MAX_PATH];

    int iGotParamS = FALSE;
    int iGotParamP = FALSE;
    int iDoA  = FALSE;

    WCHAR wszDirPath[MAX_PATH];
    WCHAR wszTempString_S[MAX_PATH];
    WCHAR wszTempString_P[MAX_PATH];
    
    wszDirPath[0] = '\0';
    wszTempString_S[0] = '\0';
    wszTempString_P[0] = '\0';

    for(argno=1; argno<argc; argno++) {
        if ( argv[argno][0] == '-'  || argv[argno][0] == '/' ) {
            switch (argv[argno][1]) {
                case 'a':
                case 'A':
                    iDoA = TRUE;
                    break;
                case 's':
                case 'S':
					// Get the string for this flag
					pArg = CharNextA(argv[argno]);
					pArg = CharNextA(pArg);
					if (*pArg == ':') {
						pArg = CharNextA(pArg);

						// Check if it's quoted
						if (*pArg == '\"') {
							pArg = CharNextA(pArg);
							pCmdStart = pArg;
							while ((*pArg) && (*pArg != '\"')){pArg = CharNextA(pArg);}
                        } else {
							pCmdStart = pArg;
							while (*pArg){pArg = CharNextA(pArg);}
						}
						*pArg = '\0';
						lstrcpyA(szTempString, StripWhitespace(pCmdStart));

						// Convert to unicode
						MultiByteToWideChar(CP_ACP, 0, (LPCSTR)szTempString, -1, (LPWSTR) wszTempString_S, 50);

                        iGotParamS = TRUE;
					}
                    break;
                case 'p':
                case 'P':
					// Get the string for this flag
					pArg = CharNextA(argv[argno]);
					pArg = CharNextA(pArg);
					if (*pArg == ':') {
						pArg = CharNextA(pArg);

						// Check if it's quoted
						if (*pArg == '\"') {
							pArg = CharNextA(pArg);
							pCmdStart = pArg;
							while ((*pArg) && (*pArg != '\"')){pArg = CharNextA(pArg);}
                        } else {
							pCmdStart = pArg;
							while (*pArg){pArg = CharNextA(pArg);}
						}
						*pArg = '\0';
						lstrcpyA(szTempString, StripWhitespace(pCmdStart));

						// Convert to unicode
						MultiByteToWideChar(CP_ACP, 0, (LPCSTR)szTempString, -1, (LPWSTR) wszTempString_P, 50);

                        iGotParamP = TRUE;
					}
                    break;
                case '?':
                    goto main_exit_with_help;
                    break;
                }
        } else {
            if ( *wszDirPath == '\0' ) {
                // if no arguments, then get the filename portion
                MultiByteToWideChar(CP_ACP, 0, argv[argno], -1, (LPWSTR) wszDirPath, 50);
            }
        }
    }

    fRet = TestCertObj();
    goto main_exit_gracefully;


main_exit_gracefully:
    exit(fRet);

main_exit_with_help:
    ShowHelp();
    exit(fRet);
}

HRESULT
HereIsVtArrayGimmieBinary(
    VARIANT * lpVarSrcObject,
    DWORD * cbBinaryBufferSize,
    char **pbBinaryBuffer,
    BOOL bReturnBinaryAsVT_VARIANT
    )
{
    HRESULT hr = S_OK;
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    CHAR HUGEP *pArray = NULL;

    if (NULL == cbBinaryBufferSize || NULL == pbBinaryBuffer)
    {
        hr = E_INVALIDARG;
        goto HereIsVtArrayGimmieBinary_Exit;
    }

    if (bReturnBinaryAsVT_VARIANT)
    {
        hr = VariantChangeType(lpVarSrcObject,lpVarSrcObject,0,VT_ARRAY | VT_VARIANT);
    }
    else
    {
        hr = VariantChangeType(lpVarSrcObject,lpVarSrcObject,0,VT_ARRAY | VT_UI1);
    }

    if (FAILED(hr)) 
    {
        if (hr != E_OUTOFMEMORY) 
        {
            IISDebugOutput(_T("OLE_E_CANTCONVERT 1,hr=0x%x\n"),hr);
            hr = OLE_E_CANTCONVERT;
        }
        goto HereIsVtArrayGimmieBinary_Exit;
    }

    if (bReturnBinaryAsVT_VARIANT)
    {
        if( lpVarSrcObject->vt != (VT_ARRAY | VT_VARIANT)) 
        {
            hr = OLE_E_CANTCONVERT;
            goto HereIsVtArrayGimmieBinary_Exit;
        }
    }
    else
    {
        if( lpVarSrcObject->vt != (VT_ARRAY | VT_UI1)) 
        {
            hr = OLE_E_CANTCONVERT;
            IISDebugOutput(_T("OLE_E_CANTCONVERT 2\n"));
            goto HereIsVtArrayGimmieBinary_Exit;
        }
    }

    hr = SafeArrayGetLBound(V_ARRAY(lpVarSrcObject),1,(long FAR *) &dwSLBound );
    if (FAILED(hr))
        {goto HereIsVtArrayGimmieBinary_Exit;}

    hr = SafeArrayGetUBound(V_ARRAY(lpVarSrcObject),1,(long FAR *) &dwSUBound );
    if (FAILED(hr))
        {goto HereIsVtArrayGimmieBinary_Exit;}

    //*pbBinaryBuffer = (LPBYTE) AllocADsMem(dwSUBound - dwSLBound + 1);
    *pbBinaryBuffer = (char *) ::CoTaskMemAlloc(dwSUBound - dwSLBound + 1);
    if (*pbBinaryBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto HereIsVtArrayGimmieBinary_Exit;
    }

    *cbBinaryBufferSize = dwSUBound - dwSLBound + 1;

    hr = SafeArrayAccessData( V_ARRAY(lpVarSrcObject),(void HUGEP * FAR *) &pArray );
    if (FAILED(hr))
        {goto HereIsVtArrayGimmieBinary_Exit;}

    memcpy(*pbBinaryBuffer,pArray,dwSUBound-dwSLBound+1);
    SafeArrayUnaccessData( V_ARRAY(lpVarSrcObject) );

HereIsVtArrayGimmieBinary_Exit:
    return hr;
}


BOOL
TestCertObj(void)
{
    BOOL fRet = FALSE;
    HRESULT hr;
    IIISCertObj *pTheObject = NULL;

    BSTR bstrFileName = SysAllocString(L"c:\\test.pfx");
    BSTR bstrFilePassword = SysAllocString(L"www");
    VARIANT VtArray;
    DWORD cbBinaryBufferSize = 0;
    char * pbBinaryBuffer = NULL;


    IISDebugOutput(_T("TestCertObj: Start\n"));

    if( FAILED (CoInitializeEx( NULL, COINIT_MULTITHREADED )))
    {
        return FALSE;
    }

    // Try to instantiante the object on the remote server...
    // with the supplied authentication info (pcsiName)
    //#define CLSCTX_SERVER    (CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER)
    //#define CLSCTX_ALL       (CLSCTX_INPROC_HANDLER | CLSCTX_SERVER)

    // this one seems to work with surrogates..
    hr = CoCreateInstance(CLSID_IISCertObj,NULL,CLSCTX_SERVER,IID_IIISCertObj,(void **)&pTheObject);
    if (FAILED(hr))
    {
        IISDebugOutput(_T("CoCreateInstanceEx on CLSID_IISCertObj failed! code=0x%x\n"),hr);
        goto TestCertObj_Exit;
    }

    // at this point we were able to instantiate the com object on the server (local or remote)
    hr = pTheObject->ImportToCertStore(bstrFileName, bstrFilePassword,&VtArray);
    IISDebugOutput(_T("returned ImportToCertStore, code=0x%x\n"),hr);

    // we have a VtArray now.
    // change it back to a binary blob
    hr = HereIsVtArrayGimmieBinary(&VtArray,&cbBinaryBufferSize,&pbBinaryBuffer,FALSE);
    IISDebugOutput(_T("returned HereIsVtArrayGimmieBinary, code=0x%x\n"),hr);

    IISDebugOutput(_T("Blob=%d,%p\n"),cbBinaryBufferSize,pbBinaryBuffer);
    DebugBreak();


TestCertObj_Exit:
    if (pTheObject)
    {
        pTheObject->Release();
        pTheObject = NULL;
    }
    CoUninitialize();
    IISDebugOutput(_T("TestCertObj: End\n"));
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\base64.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1996
//
// File:        base64.cpp
//
// Contents:    base64 encode/decode implementation
//
// History:     25-Jul-96       vich created
//
//---------------------------------------------------------------------------
//               3-Mar-98   tompop took and modified it.  Building
//                          both Ansi and Wchar versions of Encode/Decode
//                          base 64 for CertWizard, that is in IIS5's UI.
//                          We merged the examples from NT5's base64.cpp
//                          and ubase64.cpp files into this single file.
//						5-Aug-98	 Sergei Antonov removed above mentioned stuff after tompop
//---------------------------------------------------------------------------
#include "stdafx.h"
#include <malloc.h>
#include <windows.h>
#include "base64.h"

// The following table translates an ascii subset to 6 bit values as follows
// (see rfc 1521):
//
//  input    hex (decimal)
//  'A' --> 0x00 (0)
//  'B' --> 0x01 (1)
//  ...
//  'Z' --> 0x19 (25)
//  'a' --> 0x1a (26)
//  'b' --> 0x1b (27)
//  ...
//  'z' --> 0x33 (51)
//  '0' --> 0x34 (52)
//  ...
//  '9' --> 0x3d (61)
//  '+' --> 0x3e (62)
//  '/' --> 0x3f (63)
//
// Encoded lines must be no longer than 76 characters.
// The final "quantum" is handled as follows:  The translation output shall
// always consist of 4 characters.  'x', below, means a translated character,
// and '=' means an equal sign.  0, 1 or 2 equal signs padding out a four byte
// translation quantum means decoding the four bytes would result in 3, 2 or 1
// unencoded bytes, respectively.
//
//  unencoded size    encoded data
//  --------------    ------------
//     1 byte       "xx=="
//     2 bytes      "xxx="
//     3 bytes      "xxxx"

#define CB_BASE64LINEMAX    64  // others use 64 -- could be up to 76

// Any other (invalid) input character value translates to 0x40 (64)

const BYTE abDecode[256] =
{
    /* 00: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* 10: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* 20: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 62, 64, 64, 64, 63,
    /* 30: */ 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 64, 64, 64, 64, 64, 64,
    /* 40: */ 64,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
    /* 50: */ 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 64, 64, 64, 64, 64,
    /* 60: */ 64, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
    /* 70: */ 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 64, 64, 64, 64, 64,
    /* 80: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* 90: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* a0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* b0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* c0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* d0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* e0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* f0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
};


const UCHAR abEncode[] =
    /*  0 thru 25: */ "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    /* 26 thru 51: */ "abcdefghijklmnopqrstuvwxyz"
    /* 52 thru 61: */ "0123456789"
    /* 62 and 63: */  "+/";


DWORD
Base64DecodeA(const char * pchIn, DWORD cchIn, BYTE * pbOut, DWORD * pcbOut)
{
	DWORD err = ERROR_SUCCESS;
   DWORD cchInDecode, cbOutDecode;
   CHAR const *pchInEnd;
   CHAR const *pchInT;
   BYTE *pbOutT;

   // Count the translatable characters, skipping whitespace & CR-LF chars.
   cchInDecode = 0;
   pchInEnd = &pchIn[cchIn];
   for (pchInT = pchIn; pchInT < pchInEnd; pchInT++)
   {
		if (sizeof(abDecode) < (unsigned) *pchInT || abDecode[*pchInT] > 63)
		{
			// skip all whitespace
			if (	*pchInT == ' ' 
				||	*pchInT == '\t' 
				||	*pchInT == '\r' 
				||	*pchInT == '\n'
				)
			{
				continue;
			}

			if (0 != cchInDecode)
			{
				if ((cchInDecode % 4) == 0)
				{
					break;          // ends on quantum boundary
			}

			// The length calculation may stop in the middle of the last
			// translation quantum, because the equal sign padding
			// characters are treated as invalid input.  If the last
			// translation quantum is not 4 bytes long, it must be 2 or 3
			// bytes long.

			if (*pchInT == '=' && (cchInDecode % 4) != 1)
			{
				break;              // normal termination
			}
		}
      err = ERROR_INVALID_DATA;
      goto error;
	}
   cchInDecode++;
   }
    ASSERT(pchInT <= pchInEnd);
    pchInEnd = pchInT;      // don't process any trailing stuff again

    // We know how many translatable characters are in the input buffer, so now
    // set the output buffer size to three bytes for every four (or fraction of
    // four) input bytes.

    cbOutDecode = ((cchInDecode + 3) / 4) * 3;

    pbOutT = pbOut;

    if (NULL == pbOut)
    {
    pbOutT += cbOutDecode;
    }
    else
    {
    // Decode one quantum at a time: 4 bytes ==> 3 bytes

    ASSERT(cbOutDecode <= *pcbOut);
    pchInT = pchIn;
    while (cchInDecode > 0)
    {
        DWORD i;
        BYTE ab4[4];

        memset(ab4, 0, sizeof(ab4));
        for (i = 0; i < min(sizeof(ab4)/sizeof(ab4[0]), cchInDecode); i++)
        {
        while (
            sizeof(abDecode) > (unsigned) *pchInT &&
            63 < abDecode[*pchInT])
        {
            pchInT++;
        }
        ASSERT(pchInT < pchInEnd);
        ab4[i] = (BYTE) *pchInT++;
        }

        // Translate 4 input characters into 6 bits each, and deposit the
        // resulting 24 bits into 3 output bytes by shifting as appropriate.

        // out[0] = in[0]:in[1] 6:2
        // out[1] = in[1]:in[2] 4:4
        // out[2] = in[2]:in[3] 2:6

        *pbOutT++ =
        (BYTE) ((abDecode[ab4[0]] << 2) | (abDecode[ab4[1]] >> 4));

        if (i > 2)
        {
        *pbOutT++ =
          (BYTE) ((abDecode[ab4[1]] << 4) | (abDecode[ab4[2]] >> 2));
        }
        if (i > 3)
        {
        *pbOutT++ = (BYTE) ((abDecode[ab4[2]] << 6) | abDecode[ab4[3]]);
        }
        cchInDecode -= i;
    }
    ASSERT((DWORD) (pbOutT - pbOut) <= cbOutDecode);
    }
    *pcbOut = (DWORD)(pbOutT - pbOut);
error:
    return(err);
}

// Base64EncodeA 
//
// RETURNS  0 (i.e. ERROR_SUCCESS) on success
//


DWORD
Base64EncodeA(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT CHAR *pchOut,
    OUT DWORD *pcchOut)
{
    CHAR *pchOutT;
    DWORD cchOutEncode;

    // Allocate enough memory for full final translation quantum.
    cchOutEncode = ((cbIn + 2) / 3) * 4;

    // and enough for CR-LF pairs for every CB_BASE64LINEMAX character line.
    cchOutEncode +=
		2 * ((cchOutEncode + CB_BASE64LINEMAX - 1) / CB_BASE64LINEMAX);

    pchOutT = pchOut;
	if (NULL == pchOut)
   {
		pchOutT += cchOutEncode;
   }
   else
   {
		DWORD cCol;

    ASSERT(cchOutEncode <= *pcchOut);
    cCol = 0;
    while ((long) cbIn > 0) // signed comparison -- cbIn can wrap
    {
        BYTE ab3[3];

        if (cCol == CB_BASE64LINEMAX/4)
        {
        cCol = 0;
        *pchOutT++ = '\r';
        *pchOutT++ = '\n';
        }
        cCol++;
        memset(ab3, 0, sizeof(ab3));

        ab3[0] = *pbIn++;
        if (cbIn > 1)
        {
        ab3[1] = *pbIn++;
        if (cbIn > 2)
        {
            ab3[2] = *pbIn++;
        }
        }

        *pchOutT++ = abEncode[ab3[0] >> 2];
        *pchOutT++ = abEncode[((ab3[0] << 4) | (ab3[1] >> 4)) & 0x3f];
        *pchOutT++ = (cbIn > 1)?
            abEncode[((ab3[1] << 2) | (ab3[2] >> 6)) & 0x3f] : '=';
        *pchOutT++ = (cbIn > 2)? abEncode[ab3[2] & 0x3f] : '=';

        cbIn -= 3;
    }
    *pchOutT++ = '\r';
    *pchOutT++ = '\n';
    ASSERT((DWORD) (pchOutT - pchOut) <= cchOutEncode);
    }
    *pcchOut = (DWORD)(pchOutT - pchOut);
    return(ERROR_SUCCESS);
}

// Base64EncodeW 
//
// RETURNS  0 (i.e. ERROR_SUCCESS) on success
//

DWORD Base64EncodeW(
    BYTE const *pbIn,
    DWORD cbIn,
    WCHAR *wszOut,
    DWORD *pcchOut)

{

    DWORD   cchOut;
    char   *pch = NULL;
    DWORD   cch;
    DWORD   err;

    ASSERT(pcchOut != NULL);

    // only want to know how much to allocate
    // we know all base64 char map 1-1 with unicode
    if( wszOut == NULL ) {

        // get the number of characters
        *pcchOut = 0;
        err = Base64EncodeA(
                pbIn,
                cbIn,
                NULL,
                pcchOut);
    }

    // otherwise we have an output buffer
    else {

        // char count is the same be it ascii or unicode,
        cchOut = *pcchOut;
        cch = 0;
        err = ERROR_OUTOFMEMORY;
        if( (pch = (char *) malloc(cchOut)) != NULL  &&
        
            (err = Base64EncodeA(
                pbIn,
                cbIn,
                pch,
                &cchOut)) == ERROR_SUCCESS      ) {

            // should not fail!
            cch = MultiByteToWideChar(0, 
                            0, 
                            pch, 
                            cchOut, 
                            wszOut, 
                            *pcchOut);

            // check to make sure we did not fail                            
            ASSERT(*pcchOut == 0 || cch != 0);                            
        }
    }

    if(pch != NULL)
        free(pch);

    return(err);
}

// Base64DecodeW 
//
// RETURNS  0 (i.e. ERROR_SUCCESS) on success
//

DWORD Base64DecodeW(
    const WCHAR * wszIn,
    DWORD cch,
    BYTE *pbOut,
    DWORD *pcbOut)
{

    char *pch;
    DWORD err = ERROR_SUCCESS;
    
    if( (pch = (char *) malloc(cch)) == NULL ) 
	 {
        err = ERROR_OUTOFMEMORY;
    }
    else if( WideCharToMultiByte(0, 0, wszIn, cch, pch, cch, 
                        NULL, NULL) == 0 ) 
	 {
        err = ERROR_NO_DATA;
    }
    else if( pbOut == NULL ) 
	 {
        *pcbOut = 0;
        err = Base64DecodeA(pch, cch, NULL, pcbOut);
    }
    else 
	 {
        err = Base64DecodeA(pch, cch, pbOut, pcbOut);
    }
    if(pch != NULL)
        free(pch);
    return(err);
}

#if 0
// sanity tests...  Lets make sure that the encode and decode
//                  works...

BOOL test_Base64EncodeW()
{
    BYTE  pbIn[120];            // for the test we just use the random stack data
    DWORD cbIn = sizeof( pbIn );
    
    WCHAR *wszB64Out;
    DWORD pcchB64Out;

    DWORD  err;
    
    // BASE64 encode pkcs 10
    if( (err = Base64EncodeW(
                pbIn,
                cbIn,
                NULL,
                &pcchB64Out)) != ERROR_SUCCESS     ||
        (wszB64Out = (WCHAR *) _alloca(pcchB64Out * sizeof(WCHAR))) == NULL  ||
        (err = Base64EncodeW(
                pbIn,
                cbIn,
                wszB64Out,
                &pcchB64Out)) != ERROR_SUCCESS ) 
    {
        SetLastError(err);
        return FALSE;  //goto ErrorBase64Encode;
    }


    // well the encode worked lets test the decode
    //
    // pcchB64Out holds the B64 data length
    // wszB64Out  holds the actual data

     DWORD blob_cbData;     // we store in these variables what
     BYTE* blob_pbData;     //  we read in..

    // They should match the stuff stored in:
    //    BYTE  pbIn[120];
    //    DWORD cbIn = sizeof( pbIn );
    // This we be tested after the decode.

    // base64 decode
    if( (err = Base64DecodeW(
            wszB64Out,
            pcchB64Out,
            NULL,
            &blob_cbData)) != ERROR_SUCCESS                    ||
        (blob_pbData = (BYTE *) _alloca(blob_cbData)) == NULL      ||
        (err = Base64DecodeW(
            wszB64Out,
            pcchB64Out,
            blob_pbData,
            &blob_cbData)) != ERROR_SUCCESS ) 
    {
        
        SetLastError(err);
        return(FALSE);  //goto ErrorBase64Decode;
    }



    //do compare

    
    return( (blob_cbData==cbIn)
            &&  (memcmp(blob_pbData, pbIn,cbIn)==0) );
    

 }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certobj\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(_STDAFX_H)
#define _STDAFX_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif
#define _ATL_APARTMENT_THREADED

#include <windows.h>

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <comdef.h>
#include <xenroll.h>
#define _WTL_NO_CSTRING
//#include <atlwin.h>
//#include <atlapp.h>
//#include <atldlgs.h>
//#include <atlmisc.h>
//#include <atlctrls.h>
//#include <atlddx.h>
//#include <atlcrack.h>

#define _FILE_CHOOSER_H

#include <list>
#include <map>
#include <stack>
//#include <set>
//#include <memory>
//#include <shlwapi.h>

#include "iisdebug.h"
#include "resource.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(_STDAFX)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\bookendpage.cpp ===
//
// BookEndPage.cpp
//
#include "stdafx.h"
#include "BookEndPage.h"

IMPLEMENT_DYNCREATE(CIISWizardBookEnd2, CIISWizardPage)

CIISWizardBookEnd2::CIISWizardBookEnd2(
		HRESULT * phResult,
		UINT nIDWelcomeTxtSuccess,
		UINT nIDWelcomeTxtFailure,
		UINT nIDCaption,
		UINT * pnIDBodyTxtSuccess,
		CString * pBodyTxtSuccess,
		UINT * pnIDBodyTxtFailure,
		CString * pBodyTxtFailure,
		UINT nIDClickTxt,
		UINT nIDTemplate
		)
	: CIISWizardPage(nIDTemplate ? nIDTemplate : CIISWizardBookEnd2::IDD, nIDCaption),
	m_phResult(phResult),
	m_nIDWelcomeTxtSuccess(nIDWelcomeTxtSuccess),
	m_nIDWelcomeTxtFailure(nIDWelcomeTxtFailure),
	m_pnIDBodyTxtSuccess(pnIDBodyTxtSuccess),
	m_pBodyTxtSuccess(pBodyTxtSuccess),
	m_pnIDBodyTxtFailure(pnIDBodyTxtFailure),
	m_pBodyTxtFailure(pBodyTxtFailure),
	m_nIDClickTxt(nIDClickTxt),
	m_bTemplateAvailable(nIDTemplate != 0)
{
    ASSERT(m_phResult != NULL); // Must know success/failure
}

CIISWizardBookEnd2::CIISWizardBookEnd2(
		UINT nIDTemplate,
		UINT nIDCaption,
		UINT * pnIDBodyTxt,
		CString * pBodyTxt,
		UINT nIDWelcomeTxt,        
		UINT nIDClickTxt
		)
	: CIISWizardPage(nIDTemplate ? nIDTemplate : CIISWizardBookEnd2::IDD, nIDCaption),
   m_phResult(NULL),
	m_nIDWelcomeTxtSuccess(nIDWelcomeTxt),
	m_nIDWelcomeTxtFailure(USE_DEFAULT_CAPTION),
	m_pnIDBodyTxtSuccess(pnIDBodyTxt),
	m_pBodyTxtSuccess(pBodyTxt),
	m_pnIDBodyTxtFailure(NULL),
	m_pBodyTxtFailure(NULL),
	m_nIDClickTxt(nIDClickTxt),
	m_bTemplateAvailable(nIDTemplate != 0)
{
}

BOOL
CIISWizardBookEnd2::OnSetActive()
{
   if (!m_strWelcome.IsEmpty())
		SetDlgItemText(IDC_STATIC_WZ_WELCOME, m_strWelcome);
	if (!m_strBody.IsEmpty())
		SetDlgItemText(IDC_STATIC_WZ_BODY, m_strBody);
	if (!m_strClick.IsEmpty())
		SetDlgItemText(IDC_STATIC_WZ_CLICK, m_strClick);
	
	SetWizardButtons(IsWelcomePage() ? PSWIZB_NEXT : PSWIZB_FINISH);
	
	return CIISWizardPage::OnSetActive();
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CIISWizardBookEnd2, CIISWizardPage)
    //{{AFX_MSG_MAP(CIISWizardBookEnd)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL 
CIISWizardBookEnd2::OnInitDialog() 
{
	CIISWizardPage::OnInitDialog();

   //
   // Make the "Click 'foo' to continue" message bold as well.
   //
//   ApplyFontToControls(this, GetBoldFont(), IDC_STATIC_WZ_CLICK, IDC_STATIC_WZ_CLICK);

	if (m_nIDClickTxt)
	{
		VERIFY(m_strClick.LoadString(m_nIDClickTxt));
	}
   if (IsWelcomePage())
   {
		if (m_nIDWelcomeTxtSuccess)
		{
			VERIFY(m_strWelcome.LoadString(m_nIDWelcomeTxtSuccess));
		}
		if (m_pBodyTxtSuccess != NULL)
		{
			m_strBody = *m_pBodyTxtSuccess;
		}
		else if (m_pnIDBodyTxtSuccess != NULL)
		{
			VERIFY(m_strBody.LoadString(*m_pnIDBodyTxtSuccess));
		}
   }
   else
   {
		CError err(*m_phResult);
		if (err.Succeeded())		
		{
			if (m_nIDWelcomeTxtSuccess)
			{
				VERIFY(m_strWelcome.LoadString(m_nIDWelcomeTxtSuccess));
			}
			if (m_pBodyTxtSuccess != NULL && !m_pBodyTxtSuccess->IsEmpty())
			{
				m_strBody = *m_pBodyTxtSuccess;
			}
			else if (m_pnIDBodyTxtSuccess != NULL && *m_pnIDBodyTxtSuccess != USE_DEFAULT_CAPTION)
			{
				VERIFY(m_strBody.LoadString(*m_pnIDBodyTxtSuccess));
			}
		}
		else
		{
			if (m_nIDWelcomeTxtFailure)
			{
				VERIFY(m_strWelcome.LoadString(m_nIDWelcomeTxtFailure));
			}
			if (m_pBodyTxtFailure != NULL && !m_pBodyTxtFailure->IsEmpty())
			{
				m_strBody = *m_pBodyTxtFailure;
			}
			else if (m_pnIDBodyTxtFailure != NULL && *m_pnIDBodyTxtFailure != USE_DEFAULT_CAPTION)
			{
				VERIFY(m_strBody.LoadString(*m_pnIDBodyTxtFailure));
			}
			else
			{
				// Build body text string and expand error messages
				m_strBody = _T("%h");
				err.TextFromHRESULTExpand(m_strBody);
			}
		}
   }

	SetWizardButtons(IsWelcomePage() ? PSWIZB_NEXT : PSWIZB_FINISH);
	// We don't have documented way to disable Cancel button
   if (!IsWelcomePage())
		GetParent()->GetDlgItem(IDCANCEL)->EnableWindow(FALSE);

   return TRUE;  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\bookendpage.h ===
//
// BookEndPage.h
//
#ifndef _BOOKENDPAGE_H
#define _BOOKENDPAGE_H

#include "Wizard.h"

class CIISWizardBookEnd2 : public CIISWizardPage
/*++

Class Description:

    Welcome / Completion Page

Public Interface:

    CIISWizardBookEnd2    : Constructor

Notes:

    The resource template is not required.  If not provided,
    a default template will be used.

    Special control IDs (on the dialog template):
    ---------------------------------------------

        IDC_STATIC_WZ_WELCOME    - Welcome text displayed in bold
        IDC_STATIC_WZ_BODY       - Body text will be placed here
        IDC_STATIC_WZ_CLICK      - Click instructions.

    The click instructions default to something sensible, and body text
    will default to the error text on a failure page and to nothing on 
    success and welcome page.  The body text may include the %h/%H 
    escape sequences for CError on a success/failure page.

--*/
{
    DECLARE_DYNCREATE(CIISWizardBookEnd2)

public:
    //
    // Constructor for success/failure completion page
    //
    CIISWizardBookEnd2(
        HRESULT * phResult,
        UINT nIDWelcomeTxtSuccess	= USE_DEFAULT_CAPTION,
        UINT nIDWelcomeTxtFailure	= USE_DEFAULT_CAPTION,
        UINT nIDCaption					= USE_DEFAULT_CAPTION,
        UINT * nIDBodyTxtSuccess		= NULL,
		  CString * pBodyTxtSuccess	= NULL,
        UINT * nIDBodyTxtFailure		= NULL,
		  CString * pBodyTxtFailure	= NULL,
        UINT nIDClickTxt				= USE_DEFAULT_CAPTION,
        UINT nIDTemplate				= 0
        );

    //
    // Constructor for a welcome page
    //
    CIISWizardBookEnd2(
        UINT nIDTemplate        = 0,
        UINT nIDCaption         = USE_DEFAULT_CAPTION,
        UINT * nIDBodyTxt       = NULL,
		  CString * pBodyTxt		  = NULL,
        UINT nIDWelcomeTxt      = USE_DEFAULT_CAPTION,
        UINT nIDClickTxt        = USE_DEFAULT_CAPTION
        );

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CIISWizardBookEnd2)
    enum { IDD = IDD_WIZARD_BOOKEND };
    //}}AFX_DATA

//
// Overrides
//
protected:
   //{{AFX_VIRTUAL(CIISWizardBookEnd)
   public:
	virtual BOOL OnSetActive();
   //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CPWTemplate)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    BOOL IsWelcomePage() const {return m_phResult == NULL;}
	 BOOL IsTemplateAvailable() const {return m_bTemplateAvailable;}

private:
    HRESULT * m_phResult;
	 UINT m_nIDWelcomeTxtSuccess;
	 UINT m_nIDWelcomeTxtFailure;
	 UINT * m_pnIDBodyTxtSuccess;
	 CString * m_pBodyTxtSuccess;
	 UINT * m_pnIDBodyTxtFailure;
	 CString * m_pBodyTxtFailure;
	 UINT m_nIDClickTxt;
	 BOOL m_bTemplateAvailable;

	 CString m_strWelcome, m_strBody, m_strClick;
};

#endif	//_BOOKENDPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\certcontentspages.cpp ===
//
// CertContentsPages.cpp
//
#include "stdafx.h"
#include "resource.h"
#include "CertContentsPages.h"
#include "Certificat.h"
#include "CertUtil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

////////////////////// Local helper functions ////////////////////////
static void
AppendField(CString& str, UINT id, const CString& text)
{
	CString strName;
	if (!text.IsEmpty())
	{
		if (strName.LoadString(id))
		{
			str += strName;
			str += _T("\t");
			str += text;
			str += _T("\r\n");
		}
	}
}

static void 
FormatCertDescription(CERT_DESCRIPTION& desc, CString& str)
{
	AppendField(str, IDS_ISSUED_TO, desc.m_CommonName);
	AppendField(str, IDS_ISSUED_BY, desc.m_CAName);
	AppendField(str, IDS_EXPIRATION_DATE, desc.m_ExpirationDate);
	AppendField(str, IDS_PURPOSE, desc.m_Usage);
	AppendField(str, IDS_FRIENDLY_NAME, desc.m_FriendlyName);
	AppendField(str, IDS_COUNTRY, desc.m_Country);
	AppendField(str, IDS_STATE, desc.m_State);
	AppendField(str, IDS_LOCALITY, desc.m_Locality);
	AppendField(str, IDS_ORGANIZATION, desc.m_Organization);
	AppendField(str, IDS_ORGANIZATION_UNIT, desc.m_OrganizationUnit);
}

#if 0
static void
FormatCertContactInfo(CCertificate * pCert, CString& str)
{
	AppendField(str, IDS_CONTACT_NAME, pCert->m_ContactName);
	AppendField(str, IDS_CONTACT_ADDRESS, pCert->m_ContactAddress);
	CString strPhone = pCert->m_ContactPhone;
	if (!pCert->m_ContactPhoneExt.IsEmpty())
	{
		strPhone += _T("x");
		strPhone += pCert->m_ContactPhoneExt;
	}
	AppendField(str, IDS_CONTACT_PHONE, strPhone);
}
#endif

static BOOL
ExtractDescription(CCertificate * pCert, CERT_DESCRIPTION& cd)
{
	ASSERT(pCert != NULL);
	cd.m_CommonName = pCert->m_CommonName;
	cd.m_FriendlyName = pCert->m_FriendlyName;
	cd.m_Country = pCert->m_Country;
	cd.m_State = pCert->m_State;
	cd.m_Locality = pCert->m_Locality;
	cd.m_Organization = pCert->m_Organization;
	cd.m_OrganizationUnit = pCert->m_OrganizationUnit;
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CCertContentsPage base property page

IMPLEMENT_DYNCREATE(CCertContentsPage, CIISWizardPage)

CCertContentsPage::CCertContentsPage(UINT id, CCertificate * pCert) 
	: CIISWizardPage(id, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	ASSERT(id != 0);
}

CCertContentsPage::~CCertContentsPage()
{
}

void CCertContentsPage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCertContentsPage)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CCertContentsPage, CIISWizardPage)
	//{{AFX_MSG_MAP(CCertContentsPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// OnSetActive we format cert contents and put it to edit
// control with predefined ID. We should do it here, because
// if user will get back and reselect certificate, text should 
// also be changed
//
BOOL
CCertContentsPage::OnSetActive()
{
	CERT_DESCRIPTION cd;
	if (CIISWizardPage::OnSetActive())
	{
		// If page defines GetCertDescription() then it want this
		// data to be displayed
		if (GetCertDescription(cd))
		{
			ASSERT(NULL != GetDlgItem(IDC_CERT_CONTENTS));
			CString str;
			FormatCertDescription(cd, str);
			GetDlgItem(IDC_CERT_CONTENTS)->SetWindowText(str);
		}
		return TRUE;
	}
	return FALSE;
}

BOOL CCertContentsPage::OnInitDialog() 
{
	ASSERT(m_pCert != NULL);
	CIISWizardPage::OnInitDialog();

    // do this check so that prefix doesn't complain about GetDlgItem
    if ( (this != NULL) && (this->m_hWnd != NULL) )
    {
	    ASSERT(NULL != GetDlgItem(IDC_CERT_CONTENTS));
	    CEdit * pEdit = (CEdit *)CWnd::FromHandle(GetDlgItem(IDC_CERT_CONTENTS)->m_hWnd);
	    CRect rcEdit;
	    pEdit->GetClientRect(&rcEdit);
	    int baseunitX = LOWORD(GetDialogBaseUnits());
	    int width_units = MulDiv(rcEdit.Width(), 4, baseunitX);
	    //pEdit->SetTabStops(MulDiv(45, width_units, 100));
	    pEdit->SetTabStops(width_units/2);
    }
    
	return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////
// CInstallCertPage

IMPLEMENT_DYNCREATE(CInstallCertPage, CCertContentsPage)

BOOL
CInstallCertPage::GetCertDescription(CERT_DESCRIPTION& cd)
{
	return GetCertificate()->GetSelectedCertDescription(cd);
}

LRESULT
CInstallCertPage::OnWizardNext()
{
	GetCertificate()->InstallSelectedCert();
	return IDD_PAGE_NEXT;
}

LRESULT
CInstallCertPage::OnWizardBack()
{
#ifdef ENABLE_W3SVC_SSL_PAGE
    if (IsWebServerType(m_pCert->m_WebSiteInstanceName))
    {
        return IDD_PAGE_PREV_W3SVC_ONLY;
    }
#endif
    return IDD_PAGE_PREV;
}

////////////////////////////////////////////////////////////////////////////////////////
// CReplaceCertPage

IMPLEMENT_DYNCREATE(CReplaceCertPage, CCertContentsPage)

BOOL
CReplaceCertPage::GetCertDescription(CERT_DESCRIPTION& cd)
{
	return GetCertificate()->GetSelectedCertDescription(cd);
}

LRESULT
CReplaceCertPage::OnWizardNext()
{
	GetCertificate()->InstallSelectedCert();

	return IDD_PAGE_NEXT;
}

LRESULT
CReplaceCertPage::OnWizardBack()
{
	return IDD_PAGE_PREV;
}

////////////////////////////////////////////////////////////////////////////////////////
// CInstallKeyPage

IMPLEMENT_DYNCREATE(CInstallKeyPage, CCertContentsPage)

BOOL
CInstallKeyPage::OnSetActive()
{
	ASSERT(NULL != GetDlgItem(IDC_CERT_CONTENTS));
	ASSERT(NULL != GetDlgItem(IDC_FILE_NAME));
	if (CCertContentsPage::OnSetActive())
	{
		CString strPath = GetCertificate()->m_KeyFileName;
		CompactPathToWidth(GetDlgItem(IDC_FILE_NAME), strPath);
		SetDlgItemText(IDC_FILE_NAME, strPath);
		return TRUE;
	}
	return FALSE;
}

BOOL
CInstallKeyPage::GetCertDescription(CERT_DESCRIPTION& cd)
{
	return GetCertificate()->GetKeyCertDescription(cd);
}

LRESULT
CInstallKeyPage::OnWizardNext()
{
	GetCertificate()->InstallKeyRingCert();
	return IDD_PAGE_NEXT;
}

LRESULT
CInstallKeyPage::OnWizardBack()
{
#ifdef ENABLE_W3SVC_SSL_PAGE
    if (IsWebServerType(m_pCert->m_WebSiteInstanceName))
    {
        return IDD_PAGE_PREV_W3SVC_ONLY;
    }
#endif
	return IDD_PAGE_PREV;
}

////////////////////////////////////////////////////////////////////////////////////////
// CInstallImportPFXPage

IMPLEMENT_DYNCREATE(CInstallImportPFXPage, CCertContentsPage)

BOOL
CInstallImportPFXPage::OnSetActive()
{
	ASSERT(NULL != GetDlgItem(IDC_CERT_CONTENTS));
	ASSERT(NULL != GetDlgItem(IDC_FILE_NAME));
	if (CCertContentsPage::OnSetActive())
	{
		CString strPath = GetCertificate()->m_KeyFileName;
		CompactPathToWidth(GetDlgItem(IDC_FILE_NAME), strPath);
		SetDlgItemText(IDC_FILE_NAME, strPath);
		return TRUE;
	}
	return FALSE;
}

BOOL 
CInstallImportPFXPage::GetCertDescription(CERT_DESCRIPTION& cd)
{
	return GetCertificate()->GetPFXFileCertDescription(cd);
}

LRESULT
CInstallImportPFXPage::OnWizardNext()
{
    GetCertificate()->InstallImportPFXCert();
	return IDD_PAGE_NEXT;
}

LRESULT
CInstallImportPFXPage::OnWizardBack()
{
#ifdef ENABLE_W3SVC_SSL_PAGE
    if (IsWebServerType(m_pCert->m_WebSiteInstanceName))
    {
        return IDD_PAGE_PREV_W3SVC_ONLY;
    }
#endif
	return IDD_PAGE_PREV;
}


////////////////////////////////////////////////////////////////////////////////////////
// CInstallExportPFXPage

IMPLEMENT_DYNCREATE(CInstallExportPFXPage, CCertContentsPage)

BOOL
CInstallExportPFXPage::OnSetActive()
{
	ASSERT(NULL != GetDlgItem(IDC_CERT_CONTENTS));
	ASSERT(NULL != GetDlgItem(IDC_FILE_NAME));
	if (CCertContentsPage::OnSetActive())
	{
		CString strPath = GetCertificate()->m_KeyFileName;
		CompactPathToWidth(GetDlgItem(IDC_FILE_NAME), strPath);
		SetDlgItemText(IDC_FILE_NAME, strPath);
		return TRUE;
	}
	return FALSE;
}

BOOL 
CInstallExportPFXPage::GetCertDescription(CERT_DESCRIPTION& cd)
{
    
    //return GetCertificate()->GetKeyCertDescription(cd);
    return GetCertificate()->GetInstalledCertDescription(cd);
}

LRESULT
CInstallExportPFXPage::OnWizardNext()
{
	GetCertificate()->InstallExportPFXCert();
	return IDD_PAGE_NEXT;
}

LRESULT
CInstallExportPFXPage::OnWizardBack()
{
	return IDD_PAGE_PREV;
}

////////////////////////////////////////////////////////////////////////////////////////
// CInstallRespPage

IMPLEMENT_DYNCREATE(CInstallRespPage, CCertContentsPage)

BOOL
CInstallRespPage::OnSetActive()
{
	ASSERT(NULL != GetDlgItem(IDC_CERT_CONTENTS));
	ASSERT(NULL != GetDlgItem(IDC_FILE_NAME));
	if (CCertContentsPage::OnSetActive())
	{
		CString strPath = GetCertificate()->m_RespFileName;
		CompactPathToWidth(GetDlgItem(IDC_FILE_NAME), strPath);
		SetDlgItemText(IDC_FILE_NAME, strPath);
		return TRUE;
	}
	return FALSE;
}

BOOL 
CInstallRespPage::GetCertDescription(CERT_DESCRIPTION& cd)
{
	return GetCertificate()->GetResponseCertDescription(cd);
}

LRESULT
CInstallRespPage::OnWizardNext()
{
	GetCertificate()->InstallResponseCert();

#ifdef ENABLE_W3SVC_SSL_PAGE
	// see if the SSL attribute was set...if it was then set the SSL site for this certificate...
	if (!m_pCert->m_SSLPort.IsEmpty())
	{
		// get the port and write it to the metabase.
		WriteSSLPortToSite(m_pCert->m_MachineName,m_pCert->m_WebSiteInstanceName,m_pCert->m_SSLPort,&m_pCert->m_hResult);
	}
#endif

	return IDD_PAGE_NEXT;
}

LRESULT
CInstallRespPage::OnWizardBack()
{
#ifdef ENABLE_W3SVC_SSL_PAGE
    if (IsWebServerType(m_pCert->m_WebSiteInstanceName))
    {
        return IDD_PAGE_PREV_W3SVC_ONLY;
    }
#endif
	return IDD_PAGE_PREV;
}

////////////////////////////////////////////////////////////////////////////////////////
// CRemoveCertPage

IMPLEMENT_DYNCREATE(CRemoveCertPage, CCertContentsPage)

static BOOL
AnswerIsYes2(UINT id, CString& file)
{
	CString strMessage;
	AfxFormatString1(strMessage, id, file);
	return (IDYES == AfxMessageBox(strMessage, MB_ICONEXCLAMATION | MB_YESNO));
}


BOOL 
CRemoveCertPage::GetCertDescription(CERT_DESCRIPTION& cd)
{
	CCertificate * pCert = GetCertificate();
	ASSERT(NULL != pCert);
	return pCert->GetInstalledCertDescription(cd);
}

LRESULT
CRemoveCertPage::OnWizardNext()
{
	CCertificate * pCert = GetCertificate();
	ASSERT(NULL != pCert);
    int iTheReturn = 1;

#if 0
    CStringList listNodesUsingThisCert;
    int iReallyRemoveCert = FALSE;
    // check if this cert is being used first...
    IsCertUsedBySSLBelowMe(pCert->m_MachineName,pCert->m_WebSiteInstanceName,listNodesUsingThisCert);
    if (listNodesUsingThisCert.IsEmpty())
    {
        iReallyRemoveCert = TRUE;
    }
    else
    {
        // if the cert is being used, then
        // don't let them remove it
        CString csStringCount;
        csStringCount.Format(_T("%d"), listNodesUsingThisCert.GetCount());
        if (TRUE == AnswerIsYes2(IDS_CERT_BEING_USED, csStringCount))
        {
            iReallyRemoveCert = TRUE;
        }
        else
        {
            iTheReturn = 1;
        }
    }

    if (iReallyRemoveCert)
    {
#endif
        // go ahead and remove the cert
	    if (	FAILED(pCert->UninstallCert())
//		    ||	FAILED(ShutdownSSL(pCert->m_MachineName, pCert->m_WebSiteInstanceName))
		    )
        {
		    GetCertificate()->SetBodyTextID(IDS_REMOVE_CERT_FAILED);
        }
        iTheReturn = IDD_PAGE_NEXT;
//    }

    return iTheReturn;
}

LRESULT
CRemoveCertPage::OnWizardBack()
{
	return IDD_PAGE_PREV;
}

////////////////////////////////////////////////////////////////////////////////////////
// CRequestCancelPage

IMPLEMENT_DYNCREATE(CRequestCancelPage, CCertContentsPage)

//
// In this case we should get request from the dummy cert in REQUEST store,
// because we dropping request without any connection to response.
//
BOOL 
CRequestCancelPage::GetCertDescription(CERT_DESCRIPTION& cd)
{
	return FALSE;
}

LRESULT
CRequestCancelPage::OnWizardNext()
{
	GetCertificate()->CancelRequest();
	return IDD_PAGE_NEXT;
}

LRESULT
CRequestCancelPage::OnWizardBack()
{
	return IDD_PAGE_PREV;
}

/////////////////////////////////////////////////////////////////////////////
// CRequestToFilePage property page

IMPLEMENT_DYNCREATE(CRequestToFilePage, CCertContentsPage)

// This page prepares and shows contents itself
// We should format contact info first, then description
// default method could do only description
//
BOOL
CRequestToFilePage::OnSetActive() 
{
	if (CCertContentsPage::OnSetActive())
	{
		ASSERT(GetCertificate() != NULL);
		ASSERT(GetDlgItem(IDC_CERT_CONTENTS) != NULL);
		ASSERT(GetDlgItem(IDC_FILE_NAME) != NULL);

		if (GetCertificate()->GetStatusCode() == CCertificate::REQUEST_RENEW_CERT)
		{
			GetCertificate()->LoadRenewalData();
		}
		
		CString str;
//		FormatCertContactInfo(m_pCert, str);

		CERT_DESCRIPTION cd;
		ExtractDescription(GetCertificate(), cd);
		FormatCertDescription(cd, str);
		
		SetDlgItemText(IDC_CERT_CONTENTS, str);
		
		CString strPath = m_pCert->m_ReqFileName;
		CompactPathToWidth(GetDlgItem(IDC_FILE_NAME), strPath);
		SetDlgItemText(IDC_FILE_NAME, strPath);

		return TRUE;
	}
	return FALSE;
}

LRESULT
CRequestToFilePage::OnWizardNext() 
{
	GetCertificate()->PrepareRequest();
	return IDD_PAGE_NEXT;
}

LRESULT
CRequestToFilePage::OnWizardBack()
{
	return IDD_PAGE_PREV;
}


/////////////////////////////////////////////////////////////////////////////
// CRequestToFilePageRenew property page

IMPLEMENT_DYNCREATE(CRequestToFilePageRenew, CCertContentsPage)

// This page prepares and shows contents itself
// We should format contact info first, then description
// default method could do only description
//
BOOL
CRequestToFilePageRenew::OnSetActive() 
{
	if (CCertContentsPage::OnSetActive())
	{
		ASSERT(GetCertificate() != NULL);
		ASSERT(GetDlgItem(IDC_CERT_CONTENTS) != NULL);
		ASSERT(GetDlgItem(IDC_FILE_NAME) != NULL);

		if (GetCertificate()->GetStatusCode() == CCertificate::REQUEST_RENEW_CERT)
		{
			GetCertificate()->LoadRenewalData();
		}
		
		CString str;
//		FormatCertContactInfo(m_pCert, str);

		CERT_DESCRIPTION cd;
		ExtractDescription(GetCertificate(), cd);
		FormatCertDescription(cd, str);
		
		SetDlgItemText(IDC_CERT_CONTENTS, str);
		
		CString strPath = m_pCert->m_ReqFileName;
		CompactPathToWidth(GetDlgItem(IDC_FILE_NAME), strPath);
		SetDlgItemText(IDC_FILE_NAME, strPath);

		return TRUE;
	}
	return FALSE;
}

LRESULT
CRequestToFilePageRenew::OnWizardNext() 
{
	GetCertificate()->PrepareRequest();
	return IDD_PAGE_NEXT;
}

LRESULT
CRequestToFilePageRenew::OnWizardBack()
{
	return IDD_PAGE_PREV;
}


/////////////////////////////////////////////////////////////////////////////
// COnlineRequestSubmit property page

IMPLEMENT_DYNCREATE(COnlineRequestSubmit, CCertContentsPage)

BOOL 
COnlineRequestSubmit::GetCertDescription(CERT_DESCRIPTION& cd)
{
	// we have all data in CCertificate
	return ExtractDescription(GetCertificate(), cd);
}

LRESULT
COnlineRequestSubmit::OnWizardNext() 
{
	LRESULT id = IDD_PAGE_NEXT;
	BeginWaitCursor();
	if (GetCertificate()->GetStatusCode() == CCertificate::REQUEST_RENEW_CERT)
	{
		GetCertificate()->SubmitRenewalRequest();
	}
	else if (m_pCert->GetStatusCode() == CCertificate::REQUEST_NEW_CERT)
	{
		GetCertificate()->SubmitRequest();
#ifdef ENABLE_W3SVC_SSL_PAGE
		// see if the SSL attribute was set...if it was then set the SSL site for this certificate...
		if (!m_pCert->m_SSLPort.IsEmpty())
		{
			// get the port and write it to the metabase.
			WriteSSLPortToSite(m_pCert->m_MachineName,m_pCert->m_WebSiteInstanceName,m_pCert->m_SSLPort,&m_pCert->m_hResult);
		}
#endif
	}
	else
	{
		id = 1;
	}
	EndWaitCursor();
	return id;
}

LRESULT
COnlineRequestSubmit::OnWizardBack()
{
	return IDD_PAGE_PREV;
}

BOOL
COnlineRequestSubmit::OnSetActive() 
{
	ASSERT(GetCertificate() != NULL);
	ASSERT(GetDlgItem(IDC_CA_NAME) != NULL);
    ASSERT(GetDlgItem(IDC_CA_NAME2) != NULL);
   
	if (CCertContentsPage::OnSetActive())
	{
        CString csTemp1;
        // Make it look good
        csTemp1 = GetCertificate()->m_ConfigCA;
        int iFind = csTemp1.Find(_T("\\"));
        if (iFind != -1)
        {
            int iLength = csTemp1.GetLength();
            CString csTemp2;

            csTemp2 = csTemp1.Left(iFind);
            SetDlgItemText(IDC_CA_NAME, csTemp2);

            csTemp2 = csTemp1.Right(iLength - iFind - 1);
            SetDlgItemText(IDC_CA_NAME2, csTemp2);
        }
        else
        {
            SetDlgItemText(IDC_CA_NAME, csTemp1);
        }

		return TRUE;
	}
	return FALSE;
}


////////////////////////////////////////////////////////////////////////////////////////
// CInstallCopyFromRemotePage

IMPLEMENT_DYNCREATE(CInstallCopyFromRemotePage, CCertContentsPage)

BOOL 
CInstallCopyFromRemotePage::GetCertDescription(CERT_DESCRIPTION& cd)
{
    BOOL bReturn = FALSE;
    bReturn = GetCertificate()->GetRemoteFileCertDescription(cd);
	return bReturn;
}

LRESULT
CInstallCopyFromRemotePage::OnWizardNext()
{
    GetCertificate()->InstallCopyMoveFromRemote();
	return IDD_PAGE_NEXT;
}

LRESULT
CInstallCopyFromRemotePage::OnWizardBack()
{
	return IDD_PAGE_PREV;
}

////////////////////////////////////////////////////////////////////////////////////////
// CInstallMoveFromRemotePage

IMPLEMENT_DYNCREATE(CInstallMoveFromRemotePage, CCertContentsPage)

BOOL 
CInstallMoveFromRemotePage::GetCertDescription(CERT_DESCRIPTION& cd)
{
	return GetCertificate()->GetRemoteFileCertDescription(cd);
}

LRESULT
CInstallMoveFromRemotePage::OnWizardNext()
{
    GetCertificate()->InstallCopyMoveFromRemote();
	return IDD_PAGE_NEXT;
}

LRESULT
CInstallMoveFromRemotePage::OnWizardBack()
{
	return IDD_PAGE_PREV;
}


////////////////////////////////////////////////////////////////////////////////////////
// CInstallCopyFromRemotePage

IMPLEMENT_DYNCREATE(CInstallCopyToRemotePage, CCertContentsPage)

BOOL 
CInstallCopyToRemotePage::GetCertDescription(CERT_DESCRIPTION& cd)
{
	return GetCertificate()->GetInstalledCertDescription(cd);
}

LRESULT
CInstallCopyToRemotePage::OnWizardNext()
{
    GetCertificate()->InstallCopyMoveToRemote();
	return IDD_PAGE_NEXT;
}

LRESULT
CInstallCopyToRemotePage::OnWizardBack()
{
	return IDD_PAGE_PREV;
}


////////////////////////////////////////////////////////////////////////////////////////
// CInstallMoveFromRemotePage

IMPLEMENT_DYNCREATE(CInstallMoveToRemotePage, CCertContentsPage)

BOOL 
CInstallMoveToRemotePage::GetCertDescription(CERT_DESCRIPTION& cd)
{
	return GetCertificate()->GetInstalledCertDescription(cd);
}

LRESULT
CInstallMoveToRemotePage::OnWizardNext()
{
    GetCertificate()->InstallCopyMoveToRemote();
	return IDD_PAGE_NEXT;
}

LRESULT
CInstallMoveToRemotePage::OnWizardBack()
{
	return IDD_PAGE_PREV;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\certcontentspages.h ===
//
// CertContentsPages.h
//
#ifndef _CERT_CONTENTS_PAGES_H
#define _CERT_CONTENTS_PAGES_H

#include "Certificat.h"

class CCertContentsPage : public CIISWizardPage
{
	DECLARE_DYNCREATE(CCertContentsPage)

// Construction
public:
	CCertContentsPage(UINT id = 0, CCertificate * pCert = NULL);
	~CCertContentsPage();

	CCertificate * GetCertificate() {return m_pCert;}

// Dialog Data
	//{{AFX_DATA(CCertContentsPage)
	//}}AFX_DATA
	CCertificate * m_pCert;

// Overrides
	virtual BOOL GetCertDescription(CERT_DESCRIPTION& cd)
	{
		return FALSE;
	}
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CCertContentsPage)
	public:
	virtual LRESULT OnWizardBack() 
	{
		ASSERT(FALSE);
		return 1;
	}
	virtual LRESULT OnWizardNext() 
	{
		ASSERT(FALSE);
		return 1;
	}
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CCertContentsPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

class CInstallCertPage : public CCertContentsPage
{
	enum 
	{
		IDD = IDD_PAGE_WIZ_INSTALL_CERT,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_FINAL_INSTALL,
		IDD_PAGE_PREV = IDD_PAGE_WIZ_CHOOSE_CERT
#ifdef ENABLE_W3SVC_SSL_PAGE
      ,IDD_PAGE_PREV_W3SVC_ONLY = IDD_PAGE_WIZ_GET_SSL_PORT
#endif
	};
	DECLARE_DYNCREATE(CInstallCertPage)

public:
	CInstallCertPage(CCertificate * pCert = NULL)
		: CCertContentsPage(CInstallCertPage::IDD, pCert)
	{
	}

	virtual BOOL GetCertDescription(CERT_DESCRIPTION& cd);
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
};

class CReplaceCertPage : public CCertContentsPage
{
	enum
	{
		IDD = IDD_PAGE_WIZ_REPLACE_CERT,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_FINAL_REPLACE,
		IDD_PAGE_PREV = IDD_PAGE_WIZ_CHOOSE_CERT,
	};
	DECLARE_DYNCREATE(CReplaceCertPage)

public:
	CReplaceCertPage(CCertificate * pCert = NULL)
		: CCertContentsPage(CReplaceCertPage::IDD, pCert)
	{
	}

	virtual BOOL GetCertDescription(CERT_DESCRIPTION& cd);
    virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
};

class CInstallKeyPage : public CCertContentsPage
{
	enum 
	{
		IDD = IDD_PAGE_WIZ_INSTALL_KEYCERT,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_FINAL_INSTALL,
		IDD_PAGE_PREV = IDD_PAGE_WIZ_GET_PASSWORD
#ifdef ENABLE_W3SVC_SSL_PAGE
      ,IDD_PAGE_PREV_W3SVC_ONLY = IDD_PAGE_WIZ_GET_SSL_PORT
#endif
	};
	DECLARE_DYNCREATE(CInstallKeyPage)

public:
	CInstallKeyPage(CCertificate * pCert = NULL)
		: CCertContentsPage(CInstallKeyPage::IDD, pCert)
	{
	}

	virtual BOOL GetCertDescription(CERT_DESCRIPTION& cd);
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
	virtual BOOL OnSetActive();
};


class CInstallImportPFXPage : public CCertContentsPage
{
	enum 
	{
		IDD = IDD_PAGE_WIZ_INSTALL_IMPORT_PFX,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_FINAL_INSTALL_IMPORT_PFX,
		IDD_PAGE_PREV = IDD_PAGE_WIZ_GET_IMPORT_PFX_PASSWORD
#ifdef ENABLE_W3SVC_SSL_PAGE
      ,IDD_PAGE_PREV_W3SVC_ONLY = IDD_PAGE_WIZ_GET_SSL_PORT
#endif
	};
	DECLARE_DYNCREATE(CInstallImportPFXPage)

public:
	CInstallImportPFXPage(CCertificate * pCert = NULL)
		: CCertContentsPage(CInstallImportPFXPage::IDD, pCert)
	{
	}

	virtual BOOL GetCertDescription(CERT_DESCRIPTION& cd);
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
	virtual BOOL OnSetActive();
};

class CInstallExportPFXPage : public CCertContentsPage
{
	enum 
	{
		IDD = IDD_PAGE_WIZ_INSTALL_EXPORT_PFX,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_FINAL_INSTALL_EXPORT_PFX,
		IDD_PAGE_PREV = IDD_PAGE_WIZ_GET_EXPORT_PFX_PASSWORD
	};
	DECLARE_DYNCREATE(CInstallExportPFXPage)

public:
	CInstallExportPFXPage(CCertificate * pCert = NULL)
		: CCertContentsPage(CInstallExportPFXPage::IDD, pCert)
	{
	}

	virtual BOOL GetCertDescription(CERT_DESCRIPTION& cd);
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
	virtual BOOL OnSetActive();
};

class CInstallRespPage : public CCertContentsPage
{
	enum 
	{
		IDD = IDD_PAGE_WIZ_INSTALL_RESP,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_FINAL_INSTALL,
		IDD_PAGE_PREV = IDD_PAGE_WIZ_GETRESP_FILE
#ifdef ENABLE_W3SVC_SSL_PAGE
      ,IDD_PAGE_PREV_W3SVC_ONLY = IDD_PAGE_WIZ_GET_SSL_PORT
#endif
	};
	DECLARE_DYNCREATE(CInstallRespPage)

public:
	CInstallRespPage(CCertificate * pCert = NULL)
		: CCertContentsPage(CInstallRespPage::IDD, pCert)
	{
	}

	virtual BOOL GetCertDescription(CERT_DESCRIPTION& cd);
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
	virtual BOOL OnSetActive();
};

class CRequestCancelPage : public CCertContentsPage
{
	enum
	{
		IDD = IDD_PAGE_WIZ_CANCEL_REQUEST,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_FINAL_CANCEL,
		IDD_PAGE_PREV = IDD_PAGE_WIZ_PENDING_WHAT_TODO
	};
	DECLARE_DYNCREATE(CRequestCancelPage)

public:
	CRequestCancelPage(CCertificate * pCert = NULL)
		: CCertContentsPage(CRequestCancelPage::IDD, pCert)
	{
	}

	virtual BOOL GetCertDescription(CERT_DESCRIPTION& cd);
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
};

class CRemoveCertPage : public CCertContentsPage
{
	enum
	{
		IDD = IDD_PAGE_WIZ_REMOVE_CERT,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_FINAL_REMOVE,
		IDD_PAGE_PREV = IDD_PAGE_WIZ_MANAGE_CERT
	};
	DECLARE_DYNCREATE(CRemoveCertPage)

public:
	CRemoveCertPage(CCertificate * pCert = NULL)
		: CCertContentsPage(CRemoveCertPage::IDD, pCert)
	{
	}

	virtual BOOL GetCertDescription(CERT_DESCRIPTION& cd);
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
};

class CRequestToFilePage : public CCertContentsPage
{
	enum 
	{
		IDD = IDD_PAGE_WIZ_REQUEST_DUMP,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_FINAL_TO_FILE,
		IDD_PAGE_PREV = IDD_PAGE_WIZ_CHOOSE_FILENAME
	};
	DECLARE_DYNCREATE(CRequestToFilePage)

public:
	CRequestToFilePage(CCertificate * pCert = NULL)
		: CCertContentsPage(CRequestToFilePage::IDD, pCert)
	{
	}

	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
};

class CRequestToFilePageRenew : public CCertContentsPage
{
	enum 
	{
		IDD = IDD_PAGE_WIZ_REQUEST_DUMP_RENEW,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_FINAL_TO_FILE,
		IDD_PAGE_PREV = IDD_PAGE_WIZ_CHOOSE_FILENAME_RENEW
	};
	DECLARE_DYNCREATE(CRequestToFilePageRenew)

public:
	CRequestToFilePageRenew(CCertificate * pCert = NULL)
		: CCertContentsPage(CRequestToFilePageRenew::IDD, pCert)
	{
	}

	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
};

class COnlineRequestSubmit : public CCertContentsPage
{
	enum
	{
		IDD = IDD_PAGE_WIZ_ONLINE_DUMP,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_FINAL_INSTALL,
		IDD_PAGE_PREV = IDD_PAGE_WIZ_CHOOSE_ONLINE
	};
	DECLARE_DYNCREATE(COnlineRequestSubmit)
public:
	COnlineRequestSubmit(CCertificate * pCert = NULL)
		: CCertContentsPage(COnlineRequestSubmit::IDD, pCert)
	{
	}

	virtual BOOL GetCertDescription(CERT_DESCRIPTION& cd);
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
	virtual BOOL OnSetActive();
};



class CInstallCopyFromRemotePage : public CCertContentsPage
{
	enum 
	{
		IDD = IDD_PAGE_WIZ_INSTALL_COPY_FROM_REMOTE,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_FINAL_INSTALL_COPY_FROM_REMOTE,
		IDD_PAGE_PREV = IDD_PAGE_WIZ_CHOOSE_SERVER_SITE
	};
	DECLARE_DYNCREATE(CInstallCopyFromRemotePage)

public:
	CInstallCopyFromRemotePage(CCertificate * pCert = NULL)
		: CCertContentsPage(CInstallCopyFromRemotePage::IDD, pCert)
	{
	}

	virtual BOOL GetCertDescription(CERT_DESCRIPTION& cd);
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
};


class CInstallMoveFromRemotePage : public CCertContentsPage
{
	enum 
	{
		IDD = IDD_PAGE_WIZ_INSTALL_MOVE_FROM_REMOTE,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_FINAL_INSTALL_MOVE_FROM_REMOTE,
		IDD_PAGE_PREV = IDD_PAGE_WIZ_CHOOSE_SERVER_SITE
	};
	DECLARE_DYNCREATE(CInstallMoveFromRemotePage)

public:
	CInstallMoveFromRemotePage(CCertificate * pCert = NULL)
		: CCertContentsPage(CInstallMoveFromRemotePage::IDD, pCert)
	{
	}

	virtual BOOL GetCertDescription(CERT_DESCRIPTION& cd);
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
};



class CInstallCopyToRemotePage : public CCertContentsPage
{
	enum 
	{
		IDD = IDD_PAGE_WIZ_INSTALL_COPY_TO_REMOTE,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_FINAL_INSTALL_COPY_TO_REMOTE,
		IDD_PAGE_PREV = IDD_PAGE_WIZ_CHOOSE_SERVER_SITE
	};
	DECLARE_DYNCREATE(CInstallCopyToRemotePage)

public:
	CInstallCopyToRemotePage(CCertificate * pCert = NULL)
		: CCertContentsPage(CInstallCopyToRemotePage::IDD, pCert)
	{
	}

	virtual BOOL GetCertDescription(CERT_DESCRIPTION& cd);
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
};


class CInstallMoveToRemotePage : public CCertContentsPage
{
	enum 
	{
		IDD = IDD_PAGE_WIZ_INSTALL_MOVE_TO_REMOTE,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_FINAL_INSTALL_MOVE_TO_REMOTE,
		IDD_PAGE_PREV = IDD_PAGE_WIZ_CHOOSE_SERVER_SITE
	};
	DECLARE_DYNCREATE(CInstallMoveToRemotePage)

public:
	CInstallMoveToRemotePage(CCertificate * pCert = NULL)
		: CCertContentsPage(CInstallMoveToRemotePage::IDD, pCert)
	{
	}

	virtual BOOL GetCertDescription(CERT_DESCRIPTION& cd);
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
};
#endif	//_CERT_CONTENTS_PAGES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\certexportimport.h ===
#include <wincrypt.h>
#include <CertCli.h>
#include <xenroll.h>

HRESULT ExportCertToFile(BSTR bstrInstanceName, BSTR FileName,BSTR Password,BOOL bPrivateKey,BOOL bCertChain);
HRESULT ImportCertFromFile(BSTR FileName, BSTR Password, BSTR bstrInstanceName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\certificat.cpp ===
//
// Certificat.cpp
//
#include "StdAfx.h"
#include "CertWiz.h"
#include "Certificat.h"
#include "certutil.h"
#include <malloc.h>
#include "base64.h"
#include "resource.h"
#include <certupgr.h>
#include <certca.h>
#include "mru.h"
#include "Shlwapi.h"
#include <cryptui.h>
#include <strsafe.h>

// for certobj object
#include "certobj.h"
#include "certobj_i.c"

const CLSID CLSID_CEnroll = 
	{0x43F8F289, 0x7A20, 0x11D0, {0x8F, 0x06, 0x00, 0xC0, 0x4F, 0xC2, 0x95, 0xE1}};

const IID IID_IEnroll = 
	{0xacaa7838, 0x4585, 0x11d1, {0xab, 0x57, 0x00, 0xc0, 0x4f, 0xc2, 0x95, 0xe1}};

const IID IID_ICEnroll2 = 
	{0x704ca730, 0xc90b, 0x11d1, {0x9b, 0xec, 0x00, 0xc0, 0x4f, 0xc2, 0x95, 0xe1}};
const CLSID CLSID_CCertRequest = 
	{0x98aff3f0, 0x5524, 0x11d0, {0x88, 0x12, 0x00, 0xa0, 0xc9, 0x03, 0xb8, 0x3c}};
const IID IID_ICertRequest = 
	{0x014e4840, 0x5523, 0x11d0, {0x88, 0x12, 0x00, 0xa0, 0xc9, 0x03, 0xb8, 0x3c}};

WCHAR * bstrEmpty = L"";

extern CCertWizApp theApp;

BOOL 
CCryptBlob::Resize(DWORD cb)
{
	if (cb > GetSize())
	{
		if (NULL != 
				(m_blob.pbData = Realloc(m_blob.pbData, cb)))
		{
			m_blob.cbData = cb;
			return TRUE;
		}
		return FALSE;
	}
	return TRUE;
}

IMPLEMENT_DYNAMIC(CCertificate, CObject)

CCertificate::CCertificate()
	: m_CAType(CA_OFFLINE), 
	m_KeyLength(512),
	m_pPendingRequest(NULL),
	m_RespCertContext(NULL),
	m_pInstalledCert(NULL),
	m_pKeyRingCert(NULL),
	m_pEnroll(NULL),
	m_status_code(-1),
	m_CreateDirectory(FALSE),
	m_SGCcertificat(FALSE),
   m_DefaultCSP(TRUE),
   m_DefaultProviderType(PROV_RSA_SCHANNEL),
   m_ExportPFXPrivateKey(FALSE),
   m_CertObjInstalled(FALSE),
   m_OverWriteExisting(FALSE)
{
}

CCertificate::~CCertificate()
{
	if (m_pPendingRequest != NULL)
		CertFreeCertificateContext(m_pPendingRequest);
	if (m_RespCertContext != NULL)
		CertFreeCertificateContext(m_RespCertContext);
	if (m_pInstalledCert != NULL)
		CertFreeCertificateContext(m_pInstalledCert);
	if (m_pKeyRingCert != NULL)
		CertFreeCertificateContext(m_pKeyRingCert);
	if (m_pEnroll != NULL)
		m_pEnroll->Release();
}

const TCHAR szResponseFileName[] = _T("ResponseFileName");
const TCHAR szKeyRingFileName[] = _T("KeyRingFileName");
const TCHAR szRequestFileName[] = _T("RequestFileName");
const TCHAR szCertificateTemplate[] = _T("CertificateTemplate");
const TCHAR szState[] = _T("State");
const TCHAR szStateMRU[] = _T("StateMRU");
const TCHAR szLocality[] = _T("Locality");
const TCHAR szLocalityMRU[] = _T("LocalityMRU");
const TCHAR szOrganization[] = _T("Organization");
const TCHAR szOrganizationMRU[] = _T("OrganizationMRU");
const TCHAR szOrganizationUnit[] = _T("OrganizationUnit");
const TCHAR szOrganizationUnitMRU[] = _T("OrganizationUnitMRU");
const TCHAR szMachineNameRemote[] = _T("MachineNameRemote");
const TCHAR szUserNameRemote[] = _T("UserNameRemote");
const TCHAR szWebSiteInstanceNameRemote[] = _T("WebSiteInstanceNameRemote");


#define QUERY_NAME(x,y)\
	do {\
		if (ERROR_SUCCESS == RegQueryValueEx(hKey, (x), NULL, &dwType, NULL, &cbData))\
		{\
			ASSERT(dwType == REG_SZ);\
			pName = (BYTE *)(y).GetBuffer(cbData);\
			RegQueryValueEx(hKey, (x), NULL, &dwType, pName, &cbData);\
			if (pName != NULL)\
			{\
				(y).ReleaseBuffer();\
				pName = NULL;\
			}\
		}\
	} while (0)


BOOL
CCertificate::Init()
{
	ASSERT(!m_MachineName.IsEmpty());
	ASSERT(!m_WebSiteInstanceName.IsEmpty());
	// get web site description from metabase, it could be empty
	// do not panic in case of error
	if (!GetServerComment(m_MachineName, m_WebSiteInstanceName, m_FriendlyName, &m_hResult))
		m_hResult = S_OK;
	m_CommonName = m_MachineName;
	m_CommonName.MakeLower();
    m_SSLPort.Empty();

    m_MachineName_Remote = m_MachineName;
    m_WebSiteInstanceName_Remote = m_WebSiteInstanceName;

	HKEY hKey = theApp.RegOpenKeyWizard();
	DWORD dwType;
	DWORD cbData;
	if (hKey != NULL)
	{
		BYTE * pName = NULL;
		QUERY_NAME(szRequestFileName, m_ReqFileName);
		QUERY_NAME(szResponseFileName, m_RespFileName);
		QUERY_NAME(szKeyRingFileName, m_KeyFileName);
        QUERY_NAME(szMachineNameRemote, m_MachineName_Remote);
        QUERY_NAME(szUserNameRemote, m_UserName_Remote);
        QUERY_NAME(szWebSiteInstanceNameRemote, m_WebSiteInstanceName_Remote);
		QUERY_NAME(szCertificateTemplate, m_CertificateTemplate);
		QUERY_NAME(szState, m_State);
		QUERY_NAME(szLocality, m_Locality);
		QUERY_NAME(szOrganization, m_Organization);
		QUERY_NAME(szOrganizationUnit, m_OrganizationUnit);
		RegCloseKey(hKey);
	}
#ifdef _DEBUG
	else
	{
		TRACE(_T("Failed to open Registry key for Wizard parameters\n"));
	}
#endif
	if (m_CertificateTemplate.IsEmpty())
	{
		// User didn't defined anything -- use standard name
		m_CertificateTemplate = wszCERTTYPE_WEBSERVER;
	}

    // Set flag to tell if com certobj is installed
    m_CertObjInstalled = IsCertObjInstalled();
	return TRUE;
}

#define SAVE_NAME(x,y)\
		do {\
			if (!(y).IsEmpty())\
			{\
				VERIFY(ERROR_SUCCESS == RegSetValueEx(hKey, (x), 0, REG_SZ, \
						(const BYTE *)(LPCTSTR)(y), \
						sizeof(TCHAR) * ((y).GetLength() + 1)));\
			}\
		} while (0)

BOOL
CCertificate::SaveSettings()
{
	HKEY hKey = theApp.RegOpenKeyWizard();
	if (hKey != NULL)
	{
		switch (GetStatusCode())
		{
		case REQUEST_NEW_CERT:
		case REQUEST_RENEW_CERT:
			SAVE_NAME(szState, m_State);
			AddToMRU(szStateMRU, m_State);
			SAVE_NAME(szLocality, m_Locality);
			AddToMRU(szLocalityMRU, m_Locality);
			SAVE_NAME(szOrganization, m_Organization);
			AddToMRU(szOrganizationMRU, m_Organization);
			SAVE_NAME(szOrganizationUnit, m_OrganizationUnit);
			AddToMRU(szOrganizationUnitMRU, m_OrganizationUnit);
			SAVE_NAME(szRequestFileName, m_ReqFileName);
			break;
		case REQUEST_PROCESS_PENDING:
			SAVE_NAME(szResponseFileName, m_RespFileName);
			break;
		case REQUEST_IMPORT_KEYRING:
			SAVE_NAME(szKeyRingFileName, m_KeyFileName);
			break;
		case REQUEST_IMPORT_CERT:
        case REQUEST_EXPORT_CERT:
			SAVE_NAME(szKeyRingFileName, m_KeyFileName);
			break;
		case REQUEST_COPY_MOVE_FROM_REMOTE:
        case REQUEST_COPY_MOVE_TO_REMOTE:
			SAVE_NAME(szKeyRingFileName, m_KeyFileName);
            SAVE_NAME(szMachineNameRemote, m_MachineName_Remote);
            SAVE_NAME(szUserNameRemote, m_UserName_Remote);
            SAVE_NAME(szWebSiteInstanceNameRemote, m_WebSiteInstanceName_Remote);
			break;
		default:
			break;
		}
		RegCloseKey(hKey);
		return TRUE;
	}
#ifdef _DEBUG
	else
	{
		TRACE(_T("Failed to open Registry key for Wizard parameters\n"));
	}
#endif
	return FALSE;
}

BOOL
CCertificate::SetSecuritySettings()
{
	long dwGenKeyFlags;
	if (SUCCEEDED(GetEnrollObject()->get_GenKeyFlags(&dwGenKeyFlags)))
	{
		dwGenKeyFlags &= 0x0000FFFF;
		dwGenKeyFlags |= (m_KeyLength << 16);
		if (m_SGCcertificat)
			dwGenKeyFlags |= CRYPT_SGCKEY;
		return (SUCCEEDED(GetEnrollObject()->put_GenKeyFlags(dwGenKeyFlags)));
	}
	return FALSE;
}

// defines taken from the old KeyGen utility
#define MESSAGE_HEADER  "-----BEGIN NEW CERTIFICATE REQUEST-----\r\n"
#define MESSAGE_TRAILER "-----END NEW CERTIFICATE REQUEST-----\r\n"

BOOL
CCertificate::WriteRequestString(CString& request)
{
	ASSERT(!PathIsRelative(m_ReqFileName));

	BOOL bRes = FALSE;
	try {
		CString strPath;

		strPath = m_ReqFileName;
		LPTSTR pPath = strPath.GetBuffer(strPath.GetLength());
		PathRemoveFileSpec(pPath);
		if (!PathIsDirectory(pPath))
		{
			if (!CreateDirectoryFromPath(strPath, NULL))
			{
				m_hResult = HRESULT_FROM_WIN32(GetLastError());
				SetBodyTextID(USE_DEFAULT_CAPTION);
				return FALSE;
			}
		}
		strPath.ReleaseBuffer();
		HANDLE hFile = ::CreateFile(m_ReqFileName,
			GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
		if (hFile != INVALID_HANDLE_VALUE)
		{
			DWORD cb = request.GetLength();
			char * ascii_buf = (char *) LocalAlloc(LPTR,cb);
			if (ascii_buf)
			{
				wcstombs(ascii_buf, request, cb);
				bRes = ::WriteFile(hFile, ascii_buf, cb, &cb, NULL);
				::CloseHandle(hFile);
				LocalFree(ascii_buf);ascii_buf=NULL;
			}
			else
			{
				m_hResult = E_OUTOFMEMORY;
				SetBodyTextID(USE_DEFAULT_CAPTION);
			}
		}
		else
		{
			m_hResult = HRESULT_FROM_WIN32(GetLastError());
			SetBodyTextID(USE_DEFAULT_CAPTION);
		}
	}
	catch (CFileException * e)
	{
		TCHAR   szCause[255];
		e->GetErrorMessage(szCause, 255);
		TRACE(_T("Got CFileException with error: %s\n"), szCause);
		m_hResult = HRESULT_FROM_WIN32(e->m_lOsError);
	}
	catch (CException * e)
	{
		TCHAR   szCause[255];
		e->GetErrorMessage(szCause, 255);
		TRACE(_T("Got CException with error: %s\n"), szCause);
		m_hResult = HRESULT_FROM_WIN32(GetLastError());
	}
	return bRes;
}

#define HEADER_SERVER_         _T("Server:\t%s\r\n\r\n")
#define HEADER_COMMON_NAME_    _T("Common-name:\t%s\r\n")
#define HEADER_FRIENDLY_NAME_  _T("Friendly name:\t%s\r\n")
#define HEADER_ORG_UNIT_       _T("Organization Unit:\t%s\r\n")
#define HEADER_ORGANIZATION_   _T("Organization:\t%s\r\n")
#define HEADER_LOCALITY_       _T("Locality:\t%s\r\n")
#define HEADER_STATE_          _T("State:\t%s\r\n")
#define HEADER_COUNTRY_        _T("Country:\t%s\r\n")

static void WRITE_LINE(CString& str, TCHAR * format, CString& data)
{
   CString buf;
   buf.Format(format, data);
	str += buf;
}

void
CCertificate::DumpHeader(CString& str)
{
	DumpOnlineHeader(str);
}

void
CCertificate::DumpOnlineHeader(CString& str)
{
	WRITE_LINE(str, HEADER_SERVER_, m_CommonName);
	WRITE_LINE(str, HEADER_FRIENDLY_NAME_, m_FriendlyName);
	WRITE_LINE(str, HEADER_ORG_UNIT_, m_OrganizationUnit);
	WRITE_LINE(str, HEADER_ORGANIZATION_, m_Organization);
	WRITE_LINE(str, HEADER_LOCALITY_, m_Locality);;
	WRITE_LINE(str, HEADER_STATE_, m_State);
	WRITE_LINE(str, HEADER_COUNTRY_, m_Country);
}

BOOL
CCertificate::GetSelectedCertDescription(CERT_DESCRIPTION& cd)
{
	BOOL bRes = FALSE;
	ASSERT(m_pSelectedCertHash != NULL);
	HCERTSTORE hStore = OpenMyStore(GetEnrollObject(), &m_hResult);
	if (hStore != NULL)
	{
		PCCERT_CONTEXT pCert = CertFindCertificateInStore(hStore,
				CRYPT_ASN_ENCODING,
				0,
				CERT_FIND_HASH,
				m_pSelectedCertHash,
				NULL);
		if (pCert != NULL)
		{
			bRes = GetCertDescription(pCert, cd);
			CertFreeCertificateContext(pCert);
		}
		CertCloseStore(hStore, 0);
	}
	return bRes;
}

void CCertificate::CreateDN(CString& str)
{
	str.Empty();

	// per bug 639398, should be ordered
	// in reverse order:C,S,L,O.OU,CN
	str += _T("C=") + m_Country;
	str += _T("\n,S=") + m_State;
	str += _T("\n,L=") + m_Locality;
	str += _T("\n,O=\"") + m_Organization + _T("\"");
	str += _T("\n,OU=\"") + m_OrganizationUnit + _T("\"");
    str += _T("\n,CN=\"") + m_CommonName + _T("\"");
}

PCCERT_CONTEXT
CCertificate::GetPendingRequest()
{
	if (m_pPendingRequest == NULL)
	{
		ASSERT(!m_WebSiteInstanceName.IsEmpty());
		m_pPendingRequest = GetPendingDummyCert(m_WebSiteInstanceName, 
						GetEnrollObject(), &m_hResult);
	}
	return m_pPendingRequest;
}

PCCERT_CONTEXT
CCertificate::GetInstalledCert()
{
	if (m_pInstalledCert == NULL)
	{
		m_pInstalledCert = ::GetInstalledCert(m_MachineName,
		      m_WebSiteInstanceName,
				GetEnrollObject(),
				&m_hResult);
	}
	return m_pInstalledCert;
}


PCCERT_CONTEXT
CCertificate::GetPFXFileCert()
{
	ASSERT(!m_KeyFileName.IsEmpty());
	ASSERT(!m_KeyPassword.IsEmpty());
    IIISCertObj *pTheObject = NULL;
    DWORD cbBinaryBufferSize = 0;
    char * pbBinaryBuffer = NULL;
    BOOL  bPleaseDoCoUninit = FALSE;
    VARIANT_BOOL bAllowExport = VARIANT_FALSE;
    VARIANT_BOOL bOverWriteExisting = VARIANT_FALSE;

    if (m_MarkAsExportable)
    {
        bAllowExport = VARIANT_TRUE;
    }
    else
    {
        bAllowExport = VARIANT_FALSE;
    }
    if (m_OverWriteExisting)
    {
        bOverWriteExisting = VARIANT_TRUE;
    }
    else
    {
        bOverWriteExisting = VARIANT_FALSE;
    }

    if (FALSE == m_CertObjInstalled)
    {
        m_pKeyRingCert = NULL;
        goto GetPFXFileCert_Exit;
    }

	if (m_pKeyRingCert == NULL)
	{
        BSTR bstrFileName = SysAllocString(m_KeyFileName);
        LPTSTR lpTempPassword = m_KeyPassword.GetClearTextPassword();
        BSTR bstrFilePassword = SysAllocString(lpTempPassword);
        m_KeyPassword.DestroyClearTextPassword(lpTempPassword);
        VARIANT VtArray;

        m_hResult = CoInitialize(NULL);
        if(FAILED(m_hResult))
        {
            return NULL;
        }
        bPleaseDoCoUninit = TRUE;

        // this one seems to work with surrogates..
        m_hResult = CoCreateInstance(CLSID_IISCertObj,NULL,CLSCTX_SERVER,IID_IIISCertObj,(void **)&pTheObject);
        if (FAILED(m_hResult))
        {
            goto GetPFXFileCert_Exit;
        }

        // at this point we were able to instantiate the com object on the server (local or remote)
        m_hResult = pTheObject->ImportToCertStore(bstrFileName,bstrFilePassword,bAllowExport,bOverWriteExisting,&VtArray);
        if (FAILED(m_hResult))
        {
            m_pKeyRingCert = NULL;
            goto GetPFXFileCert_Exit;
        }

        // we have a VtArray now.
        // change it back to a binary blob
        m_hResult = HereIsVtArrayGimmieBinary(&VtArray,&cbBinaryBufferSize,&pbBinaryBuffer,FALSE);
        if (FAILED(m_hResult))
        {
            m_pKeyRingCert = NULL;
            goto GetPFXFileCert_Exit;
        }

        // we have the hash now.
        // we can use it to lookup the cert and get the PCCERT_CONTEXT

        // Get the pointer to the cert...
        m_pKeyRingCert = GetInstalledCertFromHash(&m_hResult,cbBinaryBufferSize,pbBinaryBuffer);
	}

GetPFXFileCert_Exit:
    if (pTheObject)
    {
        pTheObject->Release();
        pTheObject = NULL;
    }
    if (pbBinaryBuffer)
    {
        CoTaskMemFree(pbBinaryBuffer);
    }
    if (bPleaseDoCoUninit)
    {
        CoUninitialize();
    }
	return m_pKeyRingCert;
}

PCCERT_CONTEXT
CCertificate::GetImportCert()
{
    // Warning: you are replacing a certificate which
    // is being referenced by another site. are you sure you want to do this?
    BOOL bOverWrite = TRUE;

	ASSERT(!m_KeyFileName.IsEmpty());
	ASSERT(!m_KeyPassword.IsEmpty());
	if (m_pKeyRingCert == NULL)
	{
        // See if there alrady is a certificat that we are going to over write!!!
		int len = m_KeyPassword.GetByteLength();
		char * ascii_password = (char *) LocalAlloc(LPTR,len);
		if (NULL != ascii_password)
		{
			size_t n;

            LPTSTR lpTempPassword = m_KeyPassword.GetClearTextPassword();
			if (lpTempPassword)
			{
				VERIFY(-1 != (n = wcstombs(ascii_password, lpTempPassword, len)));
				m_KeyPassword.DestroyClearTextPassword(lpTempPassword);
				ascii_password[n] = '\0';

				m_pKeyRingCert = ::ImportKRBackupToCAPIStore(
												(LPTSTR)(LPCTSTR)m_KeyFileName,
												ascii_password,
												_T("MY"),
												bOverWrite);
			}
		}
		if (m_pKeyRingCert == NULL)
		{
			m_hResult = HRESULT_FROM_WIN32(GetLastError());
		}

		if (ascii_password)
		{
			SecureZeroMemory(ascii_password,len);
			LocalFree(ascii_password);ascii_password=NULL;
		}
	}
    return m_pKeyRingCert;
}

PCCERT_CONTEXT
CCertificate::GetKeyRingCert()
{
	ASSERT(!m_KeyFileName.IsEmpty());
	ASSERT(!m_KeyPassword.IsEmpty());
    BOOL bOverWrite = FALSE;
	if (m_pKeyRingCert == NULL)
	{
        int len = m_KeyPassword.GetByteLength();
		char * ascii_password = (char *) LocalAlloc(LPTR,len);
		if (NULL != ascii_password)
		{
			size_t n;

            LPTSTR lpTempPassword = m_KeyPassword.GetClearTextPassword();
			if (lpTempPassword)
			{
				VERIFY(-1 != (n = wcstombs(ascii_password, lpTempPassword, len)));
				m_KeyPassword.DestroyClearTextPassword(lpTempPassword);
				ascii_password[n] = '\0';

				m_pKeyRingCert = ::ImportKRBackupToCAPIStore(
											(LPTSTR)(LPCTSTR)m_KeyFileName,
											ascii_password,
											_T("MY"),
											bOverWrite);
			}
		}
		if (m_pKeyRingCert == NULL)
		{
			m_hResult = HRESULT_FROM_WIN32(GetLastError());
		}
		if (ascii_password)
		{
			SecureZeroMemory(ascii_password,len);
			LocalFree(ascii_password);ascii_password=NULL;
		}
		
	}
	return m_pKeyRingCert;
}

/* INTRINSA suppress=null_pointers, uninitialized */
PCCERT_CONTEXT
CCertificate::GetResponseCert()
{
	if (m_RespCertContext == NULL)
	{
		ASSERT(!m_RespFileName.IsEmpty());
		m_RespCertContext = GetCertContextFromPKCS7File(
					m_RespFileName,
					&GetPendingRequest()->pCertInfo->SubjectPublicKeyInfo,
					&m_hResult);
		ASSERT(SUCCEEDED(m_hResult));
	}
	return m_RespCertContext;
}

BOOL 
CCertificate::GetResponseCertDescription(CERT_DESCRIPTION& cd)
{
	CERT_DESCRIPTION cdReq;
	if (GetCertDescription(GetResponseCert(), cd))
	{
		if (GetCertDescription(GetPendingRequest(), cdReq))
		{
			cd.m_FriendlyName = cdReq.m_FriendlyName;
		}
		return TRUE;
	}
	return FALSE;
}

/*------------------------------------------------------------------------------
	IsResponseInstalled

	Function checks if certificate from the response file
	m_RespFileName was istalled to some server. If possible,
	it returns name of this server in str.
	Returns FALSE if certificate is not found in MY store or
	if this store cannot be opened
*/

BOOL
CCertificate::IsResponseInstalled(
						CString& str				// return server instance name (not yet implemented)
						)
{
	BOOL bRes = FALSE;
	// get cert context from response file
	PCCERT_CONTEXT pContext = GetCertContextFromPKCS7File(
		m_RespFileName, NULL, &m_hResult);
	if (pContext != NULL)
	{
		HCERTSTORE hStore = OpenMyStore(GetEnrollObject(), &m_hResult);
		if (hStore != NULL)
		{
			PCCERT_CONTEXT pCert = NULL;
			while (NULL != (pCert = CertEnumCertificatesInStore(hStore, pCert)))
			{
				// do not include installed cert to the list
				if (CertCompareCertificate(X509_ASN_ENCODING,
								pContext->pCertInfo, pCert->pCertInfo))
				{
					bRes = TRUE;
					// Try to find, where is was installed
					break;
				}
			}
			if (pCert != NULL)
				CertFreeCertificateContext(pCert);
		}
	}
	return bRes;
}

BOOL
CCertificate::FindInstanceNameForResponse(CString& str)
{
	BOOL bRes = FALSE;
	// get cert context from response file
	PCCERT_CONTEXT pContext = GetCertContextFromPKCS7File(m_RespFileName, NULL, &m_hResult);
	if (pContext != NULL)
	{
		// find dummy cert in REQUEST store that has public key
		// the same as in this context
		PCCERT_CONTEXT pReq = GetReqCertByKey(GetEnrollObject(), &pContext->pCertInfo->SubjectPublicKeyInfo, &m_hResult);
		if (pReq != NULL)
		{
			// get friendly name prop from this dummy cert
			if (!GetFriendlyName(pReq, str, &m_hResult))
			{
				// get instance name prop from this dummy cert
				DWORD cb;
				BYTE * prop = NULL;
				if (CertGetCertificateContextProperty(pReq, CERTWIZ_INSTANCE_NAME_PROP_ID, NULL, &cb))
				{
					prop = (BYTE *) LocalAlloc(LPTR,cb);
					if (NULL != prop)
					{
						if (CertGetCertificateContextProperty(pReq, CERTWIZ_INSTANCE_NAME_PROP_ID, prop, &cb))
						{
							// decode this instance name property
							DWORD cbData = 0;
							BYTE * data = NULL;
							if (CryptDecodeObject(CRYPT_ASN_ENCODING, X509_UNICODE_ANY_STRING,prop, cb, 0, NULL, &cbData))
							{
								data = (BYTE *) LocalAlloc(LPTR,cbData);
								if (NULL != data)
								{
									if (CryptDecodeObject(CRYPT_ASN_ENCODING, X509_UNICODE_ANY_STRING,prop, cb, 0, data, &cbData))
									{
										CERT_NAME_VALUE * p = (CERT_NAME_VALUE *)data;
										CString strInstanceName = (LPCTSTR)p->Value.pbData;
										// now try to get comment from this server
										if (GetServerComment(m_MachineName, strInstanceName, str, &m_hResult))
										{
											if (str.IsEmpty())
											{
												// generate something like [Web Site #n]
												str.LoadString(IDS_WEB_SITE_N);
												int len = strInstanceName.GetLength();
												for (int i = len - 1, count = 0; i >= 0; i--, count++)
												{
													if (!_istdigit(strInstanceName.GetAt(i)))
														break;
												}
												ASSERT(count < len);
												AfxFormatString1(str, IDS_WEB_SITE_N, strInstanceName.Right(count));
											}
										}
										m_hResult = S_OK;
										bRes = TRUE;
									}
									if (data)
									{
										LocalFree(data);data=NULL;
									}
								}
							}
						}
					}
				}
				if (prop)
				{
					LocalFree(prop);prop=NULL;
				}
			}
			CertFreeCertificateContext(pReq);
		}
		else
		{
			// probably this request was deleted from the request store
		}
		CertFreeCertificateContext(pContext);
	}
	return bRes;
}

IEnroll * 
CCertificate::GetEnrollObject()
{
	if (m_pEnroll == NULL)
	{
		m_hResult = CoCreateInstance(CLSID_CEnroll,
				NULL,
				CLSCTX_INPROC_SERVER,
				IID_IEnroll,
				(void **)&m_pEnroll);
		// now we need to change defaults for this
		// object to LOCAL_MACHINE
		if (m_pEnroll != NULL)
		{
			long dwFlags;
			VERIFY(SUCCEEDED(m_pEnroll->get_MyStoreFlags(&dwFlags)));
			dwFlags &= ~CERT_SYSTEM_STORE_LOCATION_MASK;
			dwFlags |= CERT_SYSTEM_STORE_LOCAL_MACHINE;
			// following call will change Request store flags also
			VERIFY(SUCCEEDED(m_pEnroll->put_MyStoreFlags(dwFlags)));
			VERIFY(SUCCEEDED(m_pEnroll->get_GenKeyFlags(&dwFlags)));
			dwFlags |= CRYPT_EXPORTABLE;
			VERIFY(SUCCEEDED(m_pEnroll->put_GenKeyFlags(dwFlags)));
			VERIFY(SUCCEEDED(m_pEnroll->put_KeySpec(AT_KEYEXCHANGE)));
			VERIFY(SUCCEEDED(m_pEnroll->put_ProviderType(m_DefaultProviderType)));
			VERIFY(SUCCEEDED(m_pEnroll->put_DeleteRequestCert(TRUE)));
		}
	}
	ASSERT(m_pEnroll != NULL);
	return m_pEnroll;
}

BOOL
CCertificate::HasInstalledCert()
{
	BOOL bResult = FALSE;
   CComAuthInfo auth;
	CMetaKey key(&auth,
				m_WebSiteInstanceName,
				METADATA_PERMISSION_READ,
				METADATA_MASTER_ROOT_HANDLE
            );
	if (key.Succeeded())
	{
		CString store_name;
		CBlob blob;
		if (	S_OK == key.QueryValue(MD_SSL_CERT_HASH, blob)
			&& S_OK == key.QueryValue(MD_SSL_CERT_STORE_NAME, store_name)
			)
		{
			bResult = TRUE;
		}
	}
	return bResult;
}

HRESULT
CCertificate::UninstallCert()
{
   CComAuthInfo auth;
	CMetaKey key(
            &auth,
				m_WebSiteInstanceName,
				METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
				METADATA_MASTER_ROOT_HANDLE
            );
	if (key.Succeeded())
	{
		CString store_name;
		key.QueryValue(MD_SSL_CERT_STORE_NAME, store_name);
		if (SUCCEEDED(key.DeleteValue(MD_SSL_CERT_HASH)))
        {
			key.DeleteValue(MD_SSL_CERT_STORE_NAME);
			// leave this here when uninstalling certificate:
			// bug:612595
            //key.DeleteValue(MD_SECURE_BINDINGS);
        }
	}
	return m_hResult = key.QueryResult();
}

BOOL CCertificate::WriteRequestBody()
{
	ASSERT(!m_ReqFileName.IsEmpty());

	HRESULT hr;
	BOOL bRes = FALSE;
	CString strDN;
	CreateDN(strDN);
	ASSERT(!strDN.IsEmpty());
	CString strUsage(szOID_PKIX_KP_SERVER_AUTH);
	CCryptBlobIMalloc request;
   GetEnrollObject()->put_ProviderType(m_DefaultCSP ? 
      m_DefaultProviderType : m_CustomProviderType);
   if (!m_DefaultCSP)
   {
      GetEnrollObject()->put_ProviderNameWStr((LPTSTR)(LPCTSTR)m_CspName);
      GetEnrollObject()->put_KeySpec(AT_SIGNATURE);
      if (m_CustomProviderType == PROV_DH_SCHANNEL)
      {
          GetEnrollObject()->put_KeySpec(AT_SIGNATURE);
      }
      else if (m_CustomProviderType == PROV_RSA_SCHANNEL)
      {
          GetEnrollObject()->put_KeySpec(AT_KEYEXCHANGE);
      }
   }
	if (SUCCEEDED(hr = GetEnrollObject()->createPKCS10WStr((LPTSTR)(LPCTSTR)strDN,(LPTSTR)(LPCTSTR)strUsage,request)))
	{
		// BASE64 encode pkcs 10
		DWORD err, cch; 
		char * psz = NULL;
		if ((err = Base64EncodeA(request.GetData(), request.GetSize(), NULL, &cch)) == ERROR_SUCCESS)
        {
            psz = (char *) LocalAlloc(LPTR, cch);
            if (NULL != psz)
            {
                if ((err = Base64EncodeA(request.GetData(), request.GetSize(), psz, &cch)) == ERROR_SUCCESS)
		        {
			        HANDLE hFile = ::CreateFile(m_ReqFileName,GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
                    if (hFile == INVALID_HANDLE_VALUE)
                    {
                        return FALSE;
                    }

			        DWORD written;
			        ::SetFilePointer(hFile, 0, NULL, FILE_END);
			        ::WriteFile(hFile, MESSAGE_HEADER, sizeof(MESSAGE_HEADER) - 1, &written, NULL);
			        ::WriteFile(hFile, psz, cch, &written, NULL);
			        ::WriteFile(hFile, MESSAGE_TRAILER, sizeof(MESSAGE_TRAILER) - 1, &written, NULL);
			        ::CloseHandle(hFile);

			        // get back request from encoded data
			        PCERT_REQUEST_INFO req_info;
			        VERIFY(GetRequestInfoFromPKCS10(request, &req_info, &m_hResult));
			        // find dummy cert put to request store by createPKCS10 call
			        HCERTSTORE hStore = OpenRequestStore(GetEnrollObject(), &m_hResult);
			        if (hStore != NULL)
			        {
				        PCCERT_CONTEXT pDummyCert = CertFindCertificateInStore(hStore,
															        CRYPT_ASN_ENCODING,
															        0,
															        CERT_FIND_PUBLIC_KEY,
															        (void *)&req_info->SubjectPublicKeyInfo,
															        NULL);
				        if (pDummyCert != NULL)
				        {
					        // now we need to attach web server instance name to this cert
					        // encode string into data blob
					        CRYPT_DATA_BLOB name;
					        CERT_NAME_VALUE name_value;
					        name_value.dwValueType = CERT_RDN_BMP_STRING;
					        name_value.Value.cbData = 0;
					        name_value.Value.pbData = (LPBYTE)(LPCTSTR)m_WebSiteInstanceName;
					        {
                                name.pbData = NULL;
						        if (!CryptEncodeObject(CRYPT_ASN_ENCODING, X509_UNICODE_ANY_STRING,&name_value, NULL, &name.cbData))
                                {
                                    ASSERT(FALSE);
                                }
                                name.pbData = (BYTE *) LocalAlloc(LPTR,name.cbData);
                                if (NULL == name.pbData)
                                {
                                    ASSERT(FALSE);
                                }
							    if (!CryptEncodeObject(CRYPT_ASN_ENCODING, X509_UNICODE_ANY_STRING,&name_value, name.pbData, &name.cbData))
						        {
                                    ASSERT(FALSE);
						        }
						        VERIFY(bRes = CertSetCertificateContextProperty(pDummyCert, CERTWIZ_INSTANCE_NAME_PROP_ID, 0, &name));
                                if (name.pbData)
                                {
                                    LocalFree(name.pbData);name.pbData=NULL;
                                }
					        }
					        // put friendly name to dummy cert -- we will reuse it later
					        m_FriendlyName.ReleaseBuffer();
					        AttachFriendlyName(pDummyCert, m_FriendlyName, &m_hResult);
					        // we also need to put some flag to show what we are waiting for:
					        //	new sertificate or renewing certificate
					        CRYPT_DATA_BLOB flag;
                            flag.pbData = NULL;
					        if (!CryptEncodeObject(CRYPT_ASN_ENCODING, X509_INTEGER,&m_status_code, NULL, &flag.cbData))
                            {
                                ASSERT(FALSE);
                            }
						    flag.pbData = (BYTE *) LocalAlloc(LPTR,flag.cbData);
                            if (NULL == flag.pbData)
                            {
                                ASSERT(FALSE);
                            }
						    if (!CryptEncodeObject(CRYPT_ASN_ENCODING, X509_INTEGER,&m_status_code, flag.pbData, &flag.cbData))
					        {
						        ASSERT(FALSE);
					        }
					        VERIFY(bRes = CertSetCertificateContextProperty(pDummyCert, CERTWIZ_REQUEST_FLAG_PROP_ID, 0, &flag));
					        CertFreeCertificateContext(pDummyCert);
                            if (flag.pbData)
                            {
                                LocalFree(flag.pbData);flag.pbData=NULL;
                            }
				        }
				        CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
			        }
			        LocalFree(req_info);
                }
                if (psz)
                {
                    LocalFree(psz);psz=NULL;
                }
		    }
        }
		bRes = TRUE;
	}
	return bRes;
}

BOOL
CCertificate::InstallResponseCert()
{
	BOOL bRes = FALSE;
	CCryptBlobLocal blobRequestText;

	// Get all our data attached to dummy cert
	GetFriendlyName(GetPendingRequest(), m_FriendlyName, &m_hResult);
	ASSERT(!m_FriendlyName.IsEmpty());
	GetBlobProperty(GetPendingRequest(), 
		CERTWIZ_REQUEST_TEXT_PROP_ID, blobRequestText, &m_hResult);
	ASSERT(blobRequestText.GetSize() != 0);

	CCryptBlobLocal hash_blob;
	if (::GetHashProperty(GetResponseCert(), hash_blob, &m_hResult))
	{
		if (SUCCEEDED(m_hResult = GetEnrollObject()->acceptFilePKCS7WStr(
				(LPTSTR)(LPCTSTR)m_RespFileName))
		&& InstallCertByHash(hash_blob, m_MachineName, m_WebSiteInstanceName, 
            GetEnrollObject(), &m_hResult)
		)
		{
			// reattach friendly name and request text to installed cert
			m_FriendlyName.ReleaseBuffer();
			AttachFriendlyName(GetInstalledCert(), m_FriendlyName, &m_hResult);
			bRes = CertSetCertificateContextProperty(GetInstalledCert(), 
			   CERTWIZ_REQUEST_TEXT_PROP_ID, 0, blobRequestText);
		}
	}
	if (!bRes)
	{
		SetBodyTextID(USE_DEFAULT_CAPTION);
	}

#ifdef ENABLE_W3SVC_SSL_PAGE
    // see if the SSL attribute was set...if it was then set the SSL site for this certificate...
    if (!m_SSLPort.IsEmpty())
    {
        // get the port and write it to the metabase.
        bRes = WriteSSLPortToSite(m_MachineName,m_WebSiteInstanceName,m_SSLPort,&m_hResult);
	    if (!bRes)
	    {
		    SetBodyTextID(USE_DEFAULT_CAPTION);
	    }
    }
#endif

	return bRes;
}


BOOL
CCertificate::InstallCopyMoveFromRemote()
{
	ASSERT(!m_KeyFileName.IsEmpty());
	ASSERT(!m_KeyPassword.IsEmpty());
    ASSERT(!m_WebSiteInstanceName.IsEmpty());

	BOOL bRes = FALSE;
    BOOL bPleaseDoCoUninit = FALSE;

    IIISCertObj *pTheObject = NULL;

    VARIANT varUserName;
    VARIANT varUserPassword;
    VARIANT * pvarUserName = &varUserName;
    VARIANT * pvarUserPassword = &varUserPassword;
    VariantInit(pvarUserName);
    VariantInit(pvarUserPassword);
    VARIANT_BOOL bAllowExport = VARIANT_FALSE;
    VARIANT_BOOL bOverWriteExisting = VARIANT_TRUE;

    if (m_MarkAsExportable)
    {
        bAllowExport = VARIANT_TRUE;
    }
    else
    {
        bAllowExport = VARIANT_FALSE;
    }

    if (FALSE == m_CertObjInstalled)
    {
        goto InstallCopyMoveFromRemote_Exit;
    }

    pvarUserName->bstrVal = SysAllocString(_T(""));
    pvarUserPassword->bstrVal = SysAllocString(_T(""));
    V_VT(pvarUserName) = VT_BSTR;
    V_VT(pvarUserPassword) = VT_BSTR;

    // set the properties to the remote server's info
    // when we call copy, it will connect to the 
    // remote object and copy it back into our object

    // local machine
    BSTR bstrServerName = SysAllocString(m_MachineName);
    BSTR bstrUserName = SysAllocString(_T(""));
    BSTR bstrUserPassword = SysAllocString(_T(""));
    BSTR bstrInstanceName = SysAllocString(m_WebSiteInstanceName);
    // remote machine
    BSTR bstrUserName_Remote = SysAllocString(m_UserName_Remote);
    LPTSTR pszTempPassword = m_UserPassword_Remote.GetClearTextPassword();
    BSTR bstrUserPassword_Remote = SysAllocString(pszTempPassword);
    m_UserPassword_Remote.DestroyClearTextPassword(pszTempPassword);

    BSTR bstrServerName_Remote = SysAllocString(m_MachineName_Remote);
    BSTR bstrInstanceName_Remote = SysAllocString(m_WebSiteInstanceName_Remote);
   
    m_hResult = CoInitialize(NULL);
    if(FAILED(m_hResult))
    {
        return bRes;
    }
    bPleaseDoCoUninit = TRUE;

    // this one seems to work with surrogates..
    m_hResult = CoCreateInstance(CLSID_IISCertObj,NULL,CLSCTX_SERVER,IID_IIISCertObj,(void **)&pTheObject);
    if (FAILED(m_hResult))
    {
        goto InstallCopyMoveFromRemote_Exit;
    }

    // at this point we were able to instantiate the com object on the server (local or remote)
    pTheObject->put_ServerName(bstrServerName_Remote);
    pTheObject->put_UserName(bstrUserName_Remote);
    pTheObject->put_UserPassword(bstrUserPassword_Remote);
    pTheObject->put_InstanceName(bstrInstanceName_Remote);
    if (m_DeleteAfterCopy)
    {
        m_hResult = pTheObject->Move(bAllowExport,bOverWriteExisting,bstrServerName,bstrInstanceName,varUserName,varUserPassword);
    }
    else
    {
        m_hResult = pTheObject->Copy(bAllowExport,bOverWriteExisting,bstrServerName,bstrInstanceName,varUserName,varUserPassword);
    }
    if (FAILED(m_hResult))
    {
        goto InstallCopyMoveFromRemote_Exit;
    }

    bRes = TRUE;

InstallCopyMoveFromRemote_Exit:
    if (pvarUserName)
    {
        VariantClear(pvarUserName);
    }
    if (pvarUserPassword)
    {
        VariantClear(pvarUserPassword);
    }
	if (!bRes)
	{
		SetBodyTextID(USE_DEFAULT_CAPTION);
	}
    if (pTheObject)
    {
        pTheObject->Release();
        pTheObject = NULL;
    }
    if (bPleaseDoCoUninit)
    {
        CoUninitialize();
    }
	return bRes;
}


BOOL CCertificate::IsCertObjInstalled()
{
    BOOL bReturn = FALSE;
    HRESULT hRes = E_FAIL;
    BOOL bPleaseDoCoUninit = FALSE;
    IIISCertObj *pTheObject = NULL;

    hRes = CoInitialize(NULL);
    if(FAILED(hRes))
    {
        bReturn = FALSE;
        goto IsCertObjInstalled_Exit;
    }
    bPleaseDoCoUninit = TRUE;

    // this one seems to work with surrogates..
    hRes = CoCreateInstance(CLSID_IISCertObj,NULL,CLSCTX_SERVER,IID_IIISCertObj,(void **)&pTheObject);
    if (FAILED(hRes))
    {
        bReturn = FALSE;
        goto IsCertObjInstalled_Exit;
    }
    if (pTheObject)
    {
        bReturn = TRUE;
        pTheObject->Release();
        pTheObject = NULL;

    }

IsCertObjInstalled_Exit:
    if (bPleaseDoCoUninit)
    {
        CoUninitialize();
    }
    return bReturn;
}


BOOL
CCertificate::InstallCopyMoveToRemote()
{
	ASSERT(!m_KeyFileName.IsEmpty());
	ASSERT(!m_KeyPassword.IsEmpty());
    ASSERT(!m_WebSiteInstanceName.IsEmpty());

	BOOL bRes = FALSE;
    BOOL bPleaseDoCoUninit = FALSE;

    IIISCertObj *pTheObject = NULL;

    VARIANT varUserName_Remote;
    VARIANT varUserPassword_Remote;
    VARIANT * pvarUserName_Remote = &varUserName_Remote;
    VARIANT * pvarUserPassword_Remote = &varUserPassword_Remote;
    VariantInit(pvarUserName_Remote);
    VariantInit(pvarUserPassword_Remote);
    VARIANT_BOOL bAllowExport = VARIANT_FALSE;
    VARIANT_BOOL bOverWriteExisting = VARIANT_TRUE;

    if (m_MarkAsExportable)
    {
        bAllowExport = VARIANT_TRUE;
    }
    else
    {
        bAllowExport = VARIANT_FALSE;
    }

    if (FALSE == m_CertObjInstalled)
    {
        goto InstallCopyMoveToRemote_Exit;
    }

    pvarUserName_Remote->bstrVal = SysAllocString(m_UserName_Remote);
    LPTSTR pszTempPassword = m_UserPassword_Remote.GetClearTextPassword();
    pvarUserPassword_Remote->bstrVal = SysAllocString(pszTempPassword);
    m_UserPassword_Remote.DestroyClearTextPassword(pszTempPassword);

    V_VT(pvarUserName_Remote) = VT_BSTR;
    V_VT(pvarUserPassword_Remote) = VT_BSTR;

    // set the properties to the remote server's info
    // when we call copy, it will connect to the 
    // remote object and copy it back into our object

    // local machine
    BSTR bstrServerName = SysAllocString(_T(""));
    BSTR bstrUserName = SysAllocString(_T(""));
    BSTR bstrUserPassword = SysAllocString(_T(""));
    BSTR bstrInstanceName = SysAllocString(m_WebSiteInstanceName);
    // remote machine
    BSTR bstrServerName_Remote = SysAllocString(m_MachineName_Remote);
    BSTR bstrInstanceName_Remote = SysAllocString(m_WebSiteInstanceName_Remote);
   
    m_hResult = CoInitialize(NULL);
    if(FAILED(m_hResult))
    {
        return bRes;
    }
    bPleaseDoCoUninit = TRUE;

    // this one seems to work with surrogates..
    m_hResult = CoCreateInstance(CLSID_IISCertObj,NULL,CLSCTX_SERVER,IID_IIISCertObj,(void **)&pTheObject);
    if (FAILED(m_hResult))
    {
        goto InstallCopyMoveToRemote_Exit;
    }

    // at this point we were able to instantiate the com object on the server (local or remote)
    pTheObject->put_ServerName(bstrServerName);
    pTheObject->put_UserName(bstrUserName);
    pTheObject->put_UserPassword(bstrUserPassword);
    pTheObject->put_InstanceName(bstrInstanceName);
    if (m_DeleteAfterCopy)
    {
        m_hResult = pTheObject->Move(bAllowExport,bOverWriteExisting,bstrServerName_Remote,bstrInstanceName_Remote,varUserName_Remote,varUserPassword_Remote);
    }
    else
    {
        m_hResult = pTheObject->Copy(bAllowExport,bOverWriteExisting,bstrServerName_Remote,bstrInstanceName_Remote,varUserName_Remote,varUserPassword_Remote);
    }
    if (FAILED(m_hResult))
    {
        goto InstallCopyMoveToRemote_Exit;
    }

    m_hResult = S_OK;
    bRes = TRUE;

InstallCopyMoveToRemote_Exit:
    if (pvarUserName_Remote)
    {
        VariantClear(pvarUserName_Remote);
    }
    if (pvarUserPassword_Remote)
    {
        VariantClear(pvarUserPassword_Remote);
    }
	if (!bRes)
	{
		SetBodyTextID(USE_DEFAULT_CAPTION);
	}
    if (pTheObject)
    {
        pTheObject->Release();
        pTheObject = NULL;
    }
    if (bPleaseDoCoUninit)
    {
        CoUninitialize();
    }
	return bRes;
}

// We don't have initial request for KeyRing certificate, therefore we will
// not be able to renew this certificate
//
BOOL
CCertificate::InstallExportPFXCert()
{
	ASSERT(!m_KeyFileName.IsEmpty());
	ASSERT(!m_KeyPassword.IsEmpty());
    ASSERT(!m_WebSiteInstanceName.IsEmpty());

	BOOL bRes = FALSE;
    BOOL bPleaseDoCoUninit = FALSE;

    IIISCertObj *pTheObject = NULL;

    VARIANT_BOOL bExportThePrivateKeyToo = VARIANT_FALSE;

    if (m_ExportPFXPrivateKey)
    {
        bExportThePrivateKeyToo = VARIANT_TRUE;
    }
    else
    {
        bExportThePrivateKeyToo = VARIANT_FALSE;
    }

    if (FALSE == m_CertObjInstalled)
    {
        goto InstallExportPFXCert_Exit;
    }

    // since this is the local machine
    // make sure all this stuff is not set.
    BSTR bstrServerName = SysAllocString(_T(""));
    BSTR bstrUserName = SysAllocString(_T(""));
    BSTR bstrUserPassword = SysAllocString(_T(""));

    // create bstrs for these member cstrings
    BSTR bstrFileName = SysAllocString(m_KeyFileName);
    LPTSTR lpTempPassword = m_KeyPassword.GetClearTextPassword();
    BSTR bstrFilePassword = SysAllocString(lpTempPassword);
    m_KeyPassword.DestroyClearTextPassword(lpTempPassword);
    BSTR bstrInstanceName = SysAllocString(m_WebSiteInstanceName);

    m_hResult = CoInitialize(NULL);
    if(FAILED(m_hResult))
    {
        return bRes;
    }
    bPleaseDoCoUninit = TRUE;

    // this one seems to work with surrogates..
    m_hResult = CoCreateInstance(CLSID_IISCertObj,NULL,CLSCTX_SERVER,IID_IIISCertObj,(void **)&pTheObject);
    if (FAILED(m_hResult))
    {
        goto InstallExportPFXCert_Exit;
    }

    // at this point we were able to instantiate the com object on the server (local or remote)
    pTheObject->put_ServerName(bstrServerName);
    pTheObject->put_UserName(bstrUserName);
    pTheObject->put_UserPassword(bstrUserPassword);
    pTheObject->put_InstanceName(bstrInstanceName);
    m_hResult = pTheObject->Export(bstrFileName,bstrFilePassword,bExportThePrivateKeyToo,VARIANT_FALSE,VARIANT_FALSE);
    if (FAILED(m_hResult))
    {
        goto InstallExportPFXCert_Exit;
    }

    m_hResult = S_OK;
    bRes = TRUE;

InstallExportPFXCert_Exit:
	if (!bRes)
	{
		SetBodyTextID(USE_DEFAULT_CAPTION);
	}
    if (pTheObject)
    {
        pTheObject->Release();
        pTheObject = NULL;
    }
    if (bPleaseDoCoUninit)
    {
        CoUninitialize();
    }
	return bRes;
}

//
BOOL
CCertificate::InstallImportPFXCert()
{
	BOOL bRes = FALSE;

	CCryptBlobLocal hash_blob;
	if (::GetHashProperty(GetImportCert(), hash_blob, &m_hResult))
	{
		HRESULT hr;
		CString name;
		::GetFriendlyName(GetImportCert(), name, &hr);
		if (CRYPT_E_NOT_FOUND == hr || name.IsEmpty())
		{
			CERT_DESCRIPTION desc;
			if (GetCertDescription(GetImportCert(), desc))
            {
				bRes = AttachFriendlyName(GetImportCert(), desc.m_CommonName, &hr);
            }
		}
		ASSERT(bRes);

		bRes = InstallCertByHash(hash_blob, m_MachineName, m_WebSiteInstanceName, 
						GetEnrollObject(), &m_hResult);
	}
	if (!bRes)
	{
		SetBodyTextID(USE_DEFAULT_CAPTION);
	}

#ifdef ENABLE_W3SVC_SSL_PAGE
    // see if the SSL attribute was set...if it was then set the SSL site for this certificate...
    if (!m_SSLPort.IsEmpty())
    {
        // get the port and write it to the metabase.
        bRes = WriteSSLPortToSite(m_MachineName,m_WebSiteInstanceName,m_SSLPort,&m_hResult);
	    if (!bRes)
	    {
		    SetBodyTextID(USE_DEFAULT_CAPTION);
	    }
    }
#endif

	return bRes;
}

// We don't have initial request for KeyRing certificate, therefore we will
// not be able to renew this certificate
//
BOOL
CCertificate::InstallKeyRingCert()
{
	BOOL bRes = FALSE;

	CCryptBlobLocal hash_blob;
	if (::GetHashProperty(GetKeyRingCert(), hash_blob, &m_hResult))
	{
		HRESULT hr;
		CString name;
		::GetFriendlyName(GetKeyRingCert(), name, &hr);
		if (CRYPT_E_NOT_FOUND == hr || name.IsEmpty())
		{
			CERT_DESCRIPTION desc;
			if (GetCertDescription(GetKeyRingCert(), desc))
            {
				bRes = AttachFriendlyName(GetKeyRingCert(), desc.m_CommonName, &hr);
            }
		}
		ASSERT(bRes);
		bRes = InstallCertByHash(hash_blob, m_MachineName, m_WebSiteInstanceName, 
						GetEnrollObject(), &m_hResult);
	}
	if (!bRes)
	{
		SetBodyTextID(USE_DEFAULT_CAPTION);
	}

#ifdef ENABLE_W3SVC_SSL_PAGE
    // see if the SSL attribute was set...if it was then set the SSL site for this certificate...
    if (!m_SSLPort.IsEmpty())
    {
        // get the port and write it to the metabase.
        bRes = WriteSSLPortToSite(m_MachineName,m_WebSiteInstanceName,m_SSLPort,&m_hResult);
	    if (!bRes)
	    {
		    SetBodyTextID(USE_DEFAULT_CAPTION);
	    }
    }
#endif

	return bRes;
}

// Instead of renewal we create new certificate based on parameters
// from the current one. After creation we install this certificate in place
// of current one and deleting the old one from store. Even if IIS has an
// opened SSL connection it should get a notification and update the certificate
// data.
//
BOOL
CCertificate::SubmitRenewalRequest()
{
   BOOL bRes = LoadRenewalData();
   if (bRes)
   {
       bRes = SetSecuritySettings();
       if (bRes)
       {
          PCCERT_CONTEXT pCurrent = GetInstalledCert();
          m_pInstalledCert = NULL;
          if (bRes = SubmitRequest())
          {
             CertDeleteCertificateFromStore(pCurrent);
          }
       }
   }
   return bRes;
}

BOOL CCertificate::SubmitRequest()
{
	ASSERT(!m_ConfigCA.IsEmpty());
	BOOL bRes = FALSE;
	ICertRequest * pRequest = NULL;

	if (SUCCEEDED(m_hResult = CoCreateInstance(CLSID_CCertRequest, NULL, 
					CLSCTX_INPROC_SERVER, IID_ICertRequest, (void **)&pRequest)))
	{
		CString strDN;
		CreateDN(strDN);
		BSTR request = NULL;
		if (SUCCEEDED(m_hResult = CreateRequest_Base64(
                           (BSTR)(LPCTSTR)strDN, 
									GetEnrollObject(), 
                           m_DefaultCSP ? NULL : (LPTSTR)(LPCTSTR)m_CspName,
                           m_DefaultCSP ? m_DefaultProviderType : m_CustomProviderType,
                           &request)))
		{
			ASSERT(pRequest != NULL);
			CString attrib;
			GetCertificateTemplate(attrib);
			LONG disp;
			m_hResult = pRequest->Submit(CR_IN_BASE64 | CR_IN_PKCS10,
						request, 
						(BSTR)(LPCTSTR)attrib, 
						(LPTSTR)(LPCTSTR)m_ConfigCA, 
						&disp);

			if (FAILED(m_hResult))
            {
				IISDebugOutput(_T("Submit request returned HRESULT 0x%x; Disposition %x\n"), m_hResult, disp);
            }

			if (SUCCEEDED(m_hResult))
			{
				if (disp == CR_DISP_ISSUED)
				{
					BSTR bstrOutCert = NULL;
					if (SUCCEEDED(m_hResult = 
							pRequest->GetCertificate(CR_OUT_BASE64 /*| CR_OUT_CHAIN */, &bstrOutCert)))
					{
						CRYPT_DATA_BLOB blob;
						blob.cbData = SysStringByteLen(bstrOutCert);
						blob.pbData = (BYTE *)bstrOutCert;
						m_hResult = GetEnrollObject()->acceptPKCS7Blob(&blob);
						if (SUCCEEDED(m_hResult))
						{
							PCCERT_CONTEXT pContext = GetCertContextFromPKCS7(blob.pbData, blob.cbData, 
																			NULL, &m_hResult);
							ASSERT(pContext != NULL);
							if (pContext != NULL)
							{
								BYTE HashBuffer[40];                // give it some extra size
								DWORD dwHashSize = sizeof(HashBuffer);
								if (CertGetCertificateContextProperty(pContext,
																			CERT_SHA1_HASH_PROP_ID,
																			(VOID *) HashBuffer,
																			&dwHashSize))
								{
									CRYPT_HASH_BLOB hash_blob = {dwHashSize, HashBuffer};
									if (!(bRes = InstallHashToMetabase(&hash_blob, 
													m_MachineName, 
													m_WebSiteInstanceName, 
													&m_hResult)))
									{
										SetBodyTextID(IDS_CERT_INSTALLATION_FAILURE);
									}
								}
								CertFreeCertificateContext(pContext);
							}
							// now put extra properties to the installed cert
							if (NULL != (pContext = GetInstalledCert()))
							{
								if (!(bRes = AttachFriendlyName(pContext, m_FriendlyName, &m_hResult)))
								{
									SetBodyTextID(IDS_CERT_INSTALLATION_FAILURE);
								}
							}
						}
                        if (bstrOutCert){SysFreeString(bstrOutCert);}
					}
				}
				else
				{
					switch (disp) 
					{
						case CR_DISP_INCOMPLETE:           
						case CR_DISP_ERROR:                
						case CR_DISP_DENIED:               
						case CR_DISP_ISSUED_OUT_OF_BAND:   
						case CR_DISP_UNDER_SUBMISSION:
							{
                                BOOL bFailedToGetMsg = TRUE;
                                HRESULT hrLastStatus = 0;
                                if (SUCCEEDED(pRequest ->GetLastStatus(&hrLastStatus)))
                                {
                                    LPTSTR lpBuffer = NULL;
                                    DWORD cChars = FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                                                        NULL,
                                                        hrLastStatus,
                                                        MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                                                        (LPTSTR)&lpBuffer,    0,    NULL);
                                    if (cChars != 0)
                                    {
                                        CString csTemp = lpBuffer;
                                        SetBodyTextString(csTemp);
                                        bFailedToGetMsg = FALSE;
                                    }

                                    if (lpBuffer ) {LocalFree (lpBuffer);}
                                    m_hResult = hrLastStatus;
                                }

                                if (TRUE == bFailedToGetMsg)
                                {
                                    BSTR bstr = NULL;
                                    if (SUCCEEDED(pRequest->GetDispositionMessage(&bstr)))
                                    {
                                        SetBodyTextString(CString(bstr));
                                        if (bstr) {SysFreeString(bstr);}
                                    }
                                    m_hResult = E_FAIL;
                                }
							}
							break;
						default:                           
							SetBodyTextID(IDS_INTERNAL_ERROR);
							break;
					} 
				}
			}
			else	// !SUCCEEDED
			{
				// clear out any error IDs and strings
				// we will use default processing of m_hResult
				SetBodyTextID(USE_DEFAULT_CAPTION);
			}
            if (request){SysFreeString(request);}
		}
        else
        {
            // CreateRequest_Base64 failed.
            // likely with "NTE_BAD_ALGID _HRESULT_TYPEDEF_(0x80090008L)"
            BOOL bFailedToGetMsg = TRUE;
            HRESULT hrLastStatus = m_hResult;
            LPTSTR lpBuffer = NULL;
            DWORD cChars = FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                                NULL,
                                hrLastStatus,
                                MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                                (LPTSTR)&lpBuffer,    0,    NULL);
            if (cChars != 0)
            {
                if (lpBuffer)
                {
                    CString csTemp = lpBuffer;
                    if (!csTemp.IsEmpty())
                    {
                        SetBodyTextString(csTemp);
                    }
                    bFailedToGetMsg = FALSE;
                }
            }
            if (lpBuffer ) {LocalFree (lpBuffer);}
        }
		pRequest->Release();
	}
    IISDebugOutput(_T("SubmitRequest:end:hres=0x%x;\n"), m_hResult);
	return bRes;
}

BOOL 
CCertificate::PrepareRequestString(CString& request_text, CCryptBlob& request_blob)
{
    BOOL bRet = FALSE;
    CString strDN;
    TCHAR szUsage[] = _T(szOID_PKIX_KP_SERVER_AUTH);
    DWORD err, cch;
    char * psz = NULL;

    if (m_status_code == REQUEST_RENEW_CERT)
    {
        if (FALSE == LoadRenewalData())
            {return FALSE;}
        if (FALSE == SetSecuritySettings())
            {return FALSE;}
    }
    CreateDN(strDN);
    ASSERT(!strDN.IsEmpty());
    GetEnrollObject()->put_ProviderType(m_DefaultCSP ? m_DefaultProviderType : m_CustomProviderType);
    if (!m_DefaultCSP)
    {
        GetEnrollObject()->put_ProviderNameWStr((LPTSTR)(LPCTSTR)m_CspName);
        // We are supporting only these two types of CSP, it is pretty safe to
        // have just two options, because we are using the same two types when
        // we are populating CSP selection list.
        if (m_CustomProviderType == PROV_DH_SCHANNEL)
        {
            GetEnrollObject()->put_KeySpec(AT_SIGNATURE);
        }
        else if (m_CustomProviderType == PROV_RSA_SCHANNEL)
        {
            GetEnrollObject()->put_KeySpec(AT_KEYEXCHANGE);
        }
    }
    if (FAILED(m_hResult = GetEnrollObject()->createPKCS10WStr((LPTSTR)(LPCTSTR)strDN, szUsage, request_blob)))
    {
        SetBodyTextID(USE_DEFAULT_CAPTION);
        return FALSE;
    }

    // BASE64 encode pkcs 10
    if (ERROR_SUCCESS != (err = Base64EncodeA(request_blob.GetData(), request_blob.GetSize(), NULL, &cch)))
    {
        return FALSE;
    }

    bRet = FALSE;
    psz = (char *) LocalAlloc(LPTR,cch+1);
    if (NULL == psz)
    {
        goto PrepareRequestString_Exit;
    }
    if (ERROR_SUCCESS != (err = Base64EncodeA(request_blob.GetData(), request_blob.GetSize(), psz, &cch)))
    {
        goto PrepareRequestString_Exit;
    }

    psz[cch] = '\0';
    request_text = MESSAGE_HEADER;
    request_text += psz;
    request_text += MESSAGE_TRAILER;

    bRet = TRUE;

PrepareRequestString_Exit:
    if (psz)
        {LocalFree(psz);psz=NULL;}
    return bRet;
}

BOOL
CCertificate::PrepareRequest()
{
	BOOL bRes = FALSE;
	CString request_text;
	CCryptBlobIMalloc request_blob;
	if (PrepareRequestString(request_text, request_blob))
	{
		if (WriteRequestString(request_text))
		{
			CCryptBlobLocal name_blob, request_store_blob, status_blob;
			// prepare data we want to attach to dummy request
			if (	EncodeString(m_WebSiteInstanceName, name_blob, &m_hResult)
				&& EncodeInteger(m_status_code, status_blob, &m_hResult)
				)
			{
				// get back request from encoded data
            PCERT_REQUEST_INFO pReqInfo;
            bRes = GetRequestInfoFromPKCS10(request_blob, &pReqInfo, &m_hResult);
            if (bRes)
				{
					// find dummy cert put to request store by createPKCS10 call
					HCERTSTORE hStore = OpenRequestStore(GetEnrollObject(), &m_hResult);
					if (hStore != NULL)
					{
						PCCERT_CONTEXT pDummyCert = CertFindCertificateInStore(hStore,
															CRYPT_ASN_ENCODING,
															0,
															CERT_FIND_PUBLIC_KEY,
                                             (void *)&pReqInfo->SubjectPublicKeyInfo,
															NULL);
						if (pDummyCert != NULL)
						{
							if (	CertSetCertificateContextProperty(pDummyCert, 
											CERTWIZ_INSTANCE_NAME_PROP_ID, 0, name_blob)
								&&	CertSetCertificateContextProperty(pDummyCert, 
											CERTWIZ_REQUEST_FLAG_PROP_ID, 0, status_blob)
								// put friendly name to dummy cert -- we will reuse it later
								&&	AttachFriendlyName(pDummyCert, m_FriendlyName, &m_hResult)
								)
							{
								bRes = TRUE;
			               // put certificate text to the clipboard
			               if (OpenClipboard(GetFocus()))
			               {
                           size_t len = request_text.GetLength() + 1;
				               HANDLE hMem = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, len);
				               LPSTR pMem = (LPSTR)GlobalLock(hMem);
                           if (pMem != NULL)
                           {
                              wcstombs(pMem, request_text, len);
				                  GlobalUnlock(hMem);
				                  SetClipboardData(CF_TEXT, hMem);
                           }
				               CloseClipboard();
			               }
							}
							else
							{
								m_hResult = HRESULT_FROM_WIN32(GetLastError());
							}
							CertFreeCertificateContext(pDummyCert);
						}
						CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
					}
               LocalFree(pReqInfo);
				}
			}
		}
	}
   if (!bRes)
		SetBodyTextID(USE_DEFAULT_CAPTION);

	return bRes;
}

BOOL CCertificate::LoadRenewalData()
{
    // we need to obtain data from the installed cert
    CERT_DESCRIPTION desc;
    BOOL res = FALSE;
	DWORD cbData;
	BYTE * pByte = NULL;
    DWORD len = 0;
	
	PCCERT_CONTEXT pCertTemp = GetInstalledCert();
	if (!pCertTemp)
	{
        res = FALSE;
        goto ErrorExit;
	}

    if (!GetCertDescription(pCertTemp, desc))
    {
        res = FALSE;
        goto ErrorExit;
    }

	m_CommonName = desc.m_CommonName;
	m_FriendlyName = desc.m_FriendlyName;
	m_Country = desc.m_Country;
	m_State = desc.m_State;
	m_Locality = desc.m_Locality;
	m_Organization = desc.m_Organization;
	m_OrganizationUnit = desc.m_OrganizationUnit;

    len = CertGetPublicKeyLength(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, &pCertTemp->pCertInfo->SubjectPublicKeyInfo);
    if (len == 0)
    {
        m_hResult = HRESULT_FROM_WIN32(GetLastError());
        goto ErrorExit;
    }
    m_KeyLength = len;

	// compare property value
	if (!CertGetCertificateContextProperty(pCertTemp, CERT_KEY_PROV_INFO_PROP_ID, NULL, &cbData))
    {
         m_hResult = HRESULT_FROM_WIN32(GetLastError());
         goto ErrorExit;
    }

    pByte = (BYTE *)LocalAlloc(LPTR,cbData);
    if (NULL == pByte)
    {
         m_hResult = HRESULT_FROM_WIN32(GetLastError());
         goto ErrorExit;
    }

	if (!CertGetCertificateContextProperty(pCertTemp, CERT_KEY_PROV_INFO_PROP_ID, pByte, &cbData))
    {
         m_hResult = HRESULT_FROM_WIN32(GetLastError());
         goto ErrorExit;
    }
    else
    {
        CRYPT_KEY_PROV_INFO * pProvInfo = (CRYPT_KEY_PROV_INFO *)pByte;

        if (pProvInfo->dwProvType != m_DefaultProviderType)
        {
            m_DefaultCSP = FALSE;
            m_CustomProviderType = pProvInfo->dwProvType;
            m_CspName = pProvInfo->pwszProvName;
        }

        CArray<LPCSTR, LPCSTR> uses;
        uses.Add(szOID_SERVER_GATED_CRYPTO);
        uses.Add(szOID_SGC_NETSCAPE);
        m_SGCcertificat = FALSE;
        INT iEnhancedKeyUsage = ContainsKeyUsageProperty(pCertTemp, uses, &m_hResult);
		switch (iEnhancedKeyUsage)
		{
            case 0:
                {
                    // BUG:683489:remove check for basic constraint "subjecttype=ca"
                    // Per bug 683489, accept it
                    m_SGCcertificat = TRUE;
                    /*

                    // check other stuff
                    if (DID_NOT_FIND_CONSTRAINT == CheckCertConstraints(pCertTemp) || FOUND_CONSTRAINT == CheckCertConstraints(pCertTemp))
                    {
                        // it's good
                        m_SGCcertificat = TRUE;
                    }
                    */
                    break;
                }
            case 1:
                // This Cert has the uses we want...
                m_SGCcertificat = TRUE;
                break;
		    case 2:
                // This Cert does not have the uses we want...
                // skip this cert
                break;
		    default:
                // should never get here.
			    break;
		}

        res = TRUE;
    }

ErrorExit:
    if (pByte)
    {
        LocalFree(pByte);pByte=NULL;
    }
    return res;
}

#if 0
BOOL
CCertificate::WriteRenewalRequest()
{
	BOOL bRes = FALSE;
	if (GetInstalledCert() != NULL)
	{
		BSTR bstrRequest;
		if (	SUCCEEDED(m_hResult = GetEnrollObject()->put_RenewalCertificate(GetInstalledCert()))
			&& SUCCEEDED(m_hResult = CreateRequest_Base64(bstrEmpty, 
                     GetEnrollObject(), 
                     m_DefaultCSP ? NULL : (LPTSTR)(LPCTSTR)m_CspName,
                     m_DefaultCSP ? m_DefaultProviderType : m_CustomProviderType,
                     &bstrRequest))
			)
		{
			CString str = MESSAGE_HEADER;
			str += bstrRequest;
			str += MESSAGE_TRAILER;
			if (WriteRequestString(str))
			{
				CCryptBlobLocal name_blob, status_blob;
				CCryptBlobIMalloc request_blob;
				request_blob.Set(SysStringLen(bstrRequest), (BYTE *)bstrRequest);
				// prepare data we want to attach to dummy request
				if (	EncodeString(m_WebSiteInstanceName, name_blob, &m_hResult)
					&& EncodeInteger(m_status_code, status_blob, &m_hResult)
					)
				{
					// get back request from encoded data
					PCERT_REQUEST_INFO req_info;
					if (GetRequestInfoFromPKCS10(request_blob, &req_info, &m_hResult))
					{
						// find dummy cert put to request store by createPKCS10 call
						HCERTSTORE hStore = OpenRequestStore(GetEnrollObject(), &m_hResult);
						if (hStore != NULL)
						{
							PCCERT_CONTEXT pDummyCert = CertFindCertificateInStore(hStore,
																	CRYPT_ASN_ENCODING,
																	0,
																	CERT_FIND_PUBLIC_KEY,
																	(void *)&req_info->SubjectPublicKeyInfo,
																	NULL);
							if (pDummyCert != NULL)
							{
								if (	CertSetCertificateContextProperty(pDummyCert, 
													CERTWIZ_INSTANCE_NAME_PROP_ID, 0, name_blob)
									&&	CertSetCertificateContextProperty(pDummyCert, 
													CERTWIZ_REQUEST_FLAG_PROP_ID, 0, status_blob)
  									// put friendly name to dummy cert -- we will reuse it later
									&&	AttachFriendlyName(pDummyCert, m_FriendlyName, &m_hResult)
									)
								{
									bRes = TRUE;
								}
								else
								{
									m_hResult = HRESULT_FROM_WIN32(GetLastError());
								}
								CertFreeCertificateContext(pDummyCert);
							}
							CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
						}
						LocalFree(req_info);
					}
				}
			}
		}
	}
	return bRes;
}
#endif

CCertDescList::~CCertDescList()
{
	POSITION pos = GetHeadPosition();
	while (pos != NULL)
	{
		CERT_DESCRIPTION * pDesc = GetNext(pos);
        if (pDesc)
        {
            if (pDesc->m_phash)
            {
                LocalFree(pDesc->m_phash);
                pDesc->m_phash = NULL;
            }
            delete pDesc;
            pDesc = NULL;
        }
	}
}

BOOL
CCertificate::GetCertDescription(PCCERT_CONTEXT pCert,
											CERT_DESCRIPTION& desc)
{
	BOOL bRes = FALSE;
	DWORD cb;
	UINT i, j;
	CERT_NAME_INFO * pNameInfo = NULL;

	desc.m_CommonName = _T("");
	desc.m_FriendlyName = _T("");
	desc.m_Country = _T("");
	desc.m_State = _T("");
	desc.m_Locality = _T("");
	desc.m_Organization = _T("");
	desc.m_OrganizationUnit = _T("");
	desc.m_CAName = _T("");
	desc.m_ExpirationDate = _T("");
	desc.m_Usage = _T("");
    desc.m_AltSubject = _T("");
    desc.m_phash = NULL;
	desc.m_hash_length = 0;

	if (pCert == NULL)
		goto ErrExit;

	if (	!CryptDecodeObject(X509_ASN_ENCODING, X509_UNICODE_NAME,
					pCert->pCertInfo->Subject.pbData,
					pCert->pCertInfo->Subject.cbData,
					0, NULL, &cb))
    {
        goto ErrExit;
    }

	pNameInfo = (CERT_NAME_INFO *) LocalAlloc(LPTR,cb);
    if (NULL == pNameInfo)
    {
        goto ErrExit;
    }

	if (!CryptDecodeObject(X509_ASN_ENCODING, X509_UNICODE_NAME,
					pCert->pCertInfo->Subject.pbData,
					pCert->pCertInfo->Subject.cbData,
					0, 
					pNameInfo, &cb))
	{
		goto ErrExit;
	}

	for (i = 0; i < pNameInfo->cRDN; i++)
	{
		CERT_RDN rdn = pNameInfo->rgRDN[i];
		for (j = 0; j < rdn.cRDNAttr; j++)
		{
			CERT_RDN_ATTR attr = rdn.rgRDNAttr[j];
			if (strcmp(attr.pszObjId, szOID_COMMON_NAME) == 0)
			{
				FormatRdnAttr(desc.m_CommonName, attr.dwValueType, attr.Value, FALSE);
			}
			else if (strcmp(attr.pszObjId, szOID_COUNTRY_NAME) == 0)
			{
				FormatRdnAttr(desc.m_Country, attr.dwValueType, attr.Value, TRUE);
			}
			else if (strcmp(attr.pszObjId, szOID_LOCALITY_NAME) == 0)
			{
				FormatRdnAttr(desc.m_Locality, attr.dwValueType, attr.Value, TRUE);
			}
			else if (strcmp(attr.pszObjId, szOID_STATE_OR_PROVINCE_NAME) == 0)
			{
				FormatRdnAttr(desc.m_State, attr.dwValueType, attr.Value, TRUE);
			}
			else if (strcmp(attr.pszObjId, szOID_ORGANIZATION_NAME) == 0)
			{
				FormatRdnAttr(desc.m_Organization, attr.dwValueType, attr.Value, TRUE);
			}
			else if (strcmp(attr.pszObjId, szOID_ORGANIZATIONAL_UNIT_NAME) == 0)
			{
				if(!lstrlen(desc.m_OrganizationUnit))  // WinSE 30339
					FormatRdnAttr(desc.m_OrganizationUnit, attr.dwValueType, attr.Value, TRUE);
			}
		}
	}

	// issued to
	if (!GetNameString(pCert, CERT_NAME_SIMPLE_DISPLAY_TYPE, CERT_NAME_ISSUER_FLAG, desc.m_CAName, &m_hResult))
    {
		goto ErrExit;
    }

	// expiration date
	if (!FormatDateString(desc.m_ExpirationDate, pCert->pCertInfo->NotAfter, FALSE, FALSE))
	{
		goto ErrExit;
	}

	// purpose
	if (!FormatEnhancedKeyUsageString(desc.m_Usage, pCert, FALSE, FALSE, &m_hResult))
	{
		// According to local experts, we should also use certs without this property set
		//ASSERT(FALSE);
		//goto ErrExit;
	}

	// friendly name
	if (!GetFriendlyName(pCert, desc.m_FriendlyName, &m_hResult))
	{
		desc.m_FriendlyName.LoadString(IDS_FRIENDLYNAME_NONE);
	}

    // get the alternate subject name if subject is empty
    // will use this as display only if subject name does not exist.
    if (desc.m_CommonName.IsEmpty())
    {
        TCHAR * pwszOut = NULL;
        GetAlternateSubjectName(pCert,&pwszOut);
        if (pwszOut)
        {
            desc.m_AltSubject = pwszOut;
            LocalFree(pwszOut);pwszOut = NULL;
        }
    }

    bRes = TRUE;

ErrExit:
    if (pNameInfo)
    {
        LocalFree(pNameInfo);pNameInfo=NULL;
    }
	return bRes;
}

int
CCertificate::MyStoreCertCount()
{
	int count = 0;
	HCERTSTORE hStore = OpenMyStore(GetEnrollObject(), &m_hResult);
	if (hStore != NULL)
	{
		PCCERT_CONTEXT pCert = NULL;
		CArray<LPCSTR, LPCSTR> uses;
		uses.Add(szOID_PKIX_KP_SERVER_AUTH);
		uses.Add(szOID_SERVER_GATED_CRYPTO);
		uses.Add(szOID_SGC_NETSCAPE);
        INT iEnhancedKeyUsage = 0;
		while (NULL != (pCert = CertEnumCertificatesInStore(hStore, pCert)))
		{
			// do not include installed cert to the list
			if (	GetInstalledCert() != NULL 
				&&	CertCompareCertificate(X509_ASN_ENCODING,
							GetInstalledCert()->pCertInfo, pCert->pCertInfo)
				)
            {
				continue;
            }

            //If no EKU, look at basic constraints:
            //If we do not have basic constraints, do display it in the list to pick web server certs from
            //If we do have basic constraints with Subject Type =CA, don't display it in the list to pick web server certs from (this will filter out CA certs)
            //If we do have basic constraints with SubectType !=CA, do display it in the list to pick web server certs from 
            iEnhancedKeyUsage = ContainsKeyUsageProperty(pCert, uses, &m_hResult);
		    switch (iEnhancedKeyUsage)
		    {
                case 0:
                    {
                        // BUG:683489:remove check for basic constraint "subjecttype=ca"
                        // Per bug 683489, accept it

                        /*
                        // check other stuff
                        if (DID_NOT_FIND_CONSTRAINT == CheckCertConstraints(pCert) || FOUND_CONSTRAINT == CheckCertConstraints(pCert))
                        {
                            // add it up.
                        }
                        else if (FOUND_CONSTRAINT_BUT_THIS_IS_A_CA_OR_ITS_NOT_AN_END_ENTITY == CheckCertConstraints(pCert))
                        {
                            // skip this cert
				            continue;
                        }
                        else
                        {
                            // skip this cert
                            continue;
                        }
                        */
                        break;
                    }
                case 1:
                    // This Cert has the uses we want...
                    break;
		        case 2:
                    // This Cert does not have the uses we want...
                    // skip this cert
                    continue;
                    break;
		        default:
                    // should never get here.
                    continue;
			        break;
		    }

			count++;
		}
		if (pCert != NULL)
			CertFreeCertificateContext(pCert);
		VERIFY(CertCloseStore(hStore, 0));
	}
	return count;
}

BOOL
CCertificate::GetCertDescList(CCertDescList& list)
{
	ASSERT(list.GetCount() == 0);
	BOOL bRes = FALSE;

	// we are looking to MY store only
	HCERTSTORE hStore = OpenMyStore(GetEnrollObject(), &m_hResult);
	if (hStore != NULL)
	{
		PCCERT_CONTEXT pCert = NULL;
		// do not include certs with improper usage
		CArray<LPCSTR, LPCSTR> uses;
		uses.Add(szOID_PKIX_KP_SERVER_AUTH);
		uses.Add(szOID_SERVER_GATED_CRYPTO);
		uses.Add(szOID_SGC_NETSCAPE);
        INT iEnhancedKeyUsage = 0;
		while (NULL != (pCert = CertEnumCertificatesInStore(hStore, pCert)))
		{
			// do not include installed cert to the list
			if (	GetInstalledCert() != NULL 
				&&	CertCompareCertificate(X509_ASN_ENCODING,
							GetInstalledCert()->pCertInfo, pCert->pCertInfo)
                            )
            {
                continue;
            }

            //If no EKU, look at basic constraints:
            //If we do not have basic constraints, do display it in the list to pick web server certs from
            //If we do have basic constraints with Subject Type =CA, don't display it in the list to pick web server certs from (this will filter out CA certs)
            //If we do have basic constraints with SubectType !=CA, do display it in the list to pick web server certs from 
            iEnhancedKeyUsage = ContainsKeyUsageProperty(pCert, uses, &m_hResult);
		    switch (iEnhancedKeyUsage)
		    {
                case 0:
                    {
                        // BUG:683489:remove check for basic constraint "subjecttype=ca"
                        // Per bug 683489, display it in the list

                        /*
                        // check other stuff
                        if (DID_NOT_FIND_CONSTRAINT == CheckCertConstraints(pCert) || FOUND_CONSTRAINT == CheckCertConstraints(pCert))
                        {
                            // it's okay, add it to the list
                        }
                        else 
                        {
				            if (SUCCEEDED(m_hResult) || m_hResult == CRYPT_E_NOT_FOUND)
					            continue;
				            else
					            goto ErrExit;
                        }
                        */
                        break;
                    }
                case 1:
                    // This Cert has the uses we want...
                    break;
		        case 2:
                    // This Cert does not have the uses we want...
                    // skip this cert
                    continue;
                    break;
		        default:
                    // should never get here.
                    continue;
			        break;
		    }

			CERT_DESCRIPTION * pDesc = new CERT_DESCRIPTION;
			pDesc->m_hash_length = CERT_HASH_LENGTH;
			if (!GetCertDescription(pCert, *pDesc))
			{
				delete pDesc;
				if (m_hResult == CRYPT_E_NOT_FOUND)
					continue;
				goto ErrExit;
			}

            // Get the size we need to allocate...
            pDesc->m_hash_length = 0;
            pDesc->m_phash = NULL;
			if (CertGetCertificateContextProperty(pCert, 
										CERT_SHA1_HASH_PROP_ID, 
										(VOID *)NULL, 
										&pDesc->m_hash_length))
            {
                pDesc->m_phash = (BYTE *) LocalAlloc(LPTR,pDesc->m_hash_length);
                if (pDesc->m_phash)
                {
			        if (!CertGetCertificateContextProperty(pCert, 
										        CERT_SHA1_HASH_PROP_ID, 
										        (VOID *)pDesc->m_phash, 
										        &pDesc->m_hash_length))
			        {
                        if (pDesc->m_phash)
                        {
                            LocalFree(pDesc->m_phash);
                        }
				        delete pDesc;
				        m_hResult = HRESULT_FROM_WIN32(GetLastError());
				        goto ErrExit;
			        }
                }
                else
                {
				    delete pDesc;
				    m_hResult = HRESULT_FROM_WIN32(GetLastError());
				    goto ErrExit;
                }
            }
            else
            {
                delete pDesc;
				m_hResult = HRESULT_FROM_WIN32(GetLastError());
				goto ErrExit;
            }
			list.AddTail(pDesc);
		}
		bRes = TRUE;
ErrExit:
		if (pCert != NULL)
			CertFreeCertificateContext(pCert);
		VERIFY(CertCloseStore(hStore, 0));
	}
	return bRes;
}

BOOL 
CCertificate::ReplaceInstalled()
{
	// Current cert will be left in the store for next use
	// Selected cert will be installed instead
	return InstallSelectedCert();
}

BOOL 
CCertificate::CancelRequest()
{
	// we are just removing dummy cert from the REQUEST store
	if (NULL != GetPendingRequest())
	{
		BOOL bRes = CertDeleteCertificateFromStore(GetPendingRequest());
		if (!bRes)
		{
			m_hResult = HRESULT_FROM_WIN32(GetLastError());
			SetBodyTextID(USE_DEFAULT_CAPTION);
		}
		else
			m_pPendingRequest = NULL;
		return bRes;
	}
	return FALSE;
}

BOOL 
CCertificate::InstallSelectedCert()
{
	BOOL bRes = FALSE;
	HRESULT hr;
	// local authorities required that cert should have some
	// friendly name. We will put common name when friendly name is not available
	HCERTSTORE hStore = OpenMyStore(GetEnrollObject(), &hr);
	if (hStore != NULL)
	{
		PCCERT_CONTEXT pCert = CertFindCertificateInStore(hStore, 
												X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 
												0, CERT_FIND_HASH, 
												(LPVOID)m_pSelectedCertHash, 
												NULL);
		if (pCert != NULL)
		{
			CString name;
			::GetFriendlyName(pCert, name, &hr);
			if (CRYPT_E_NOT_FOUND == hr || name.IsEmpty())
			{
				CERT_DESCRIPTION desc;
				if (GetCertDescription(pCert, desc))
                {
					bRes = AttachFriendlyName(pCert, desc.m_CommonName, &hr);
                }
			}
		}
		VERIFY(CertCloseStore(hStore, 0));
	}

	// we are just rewriting current settings
	// current cert will be left in MY store
	bRes = ::InstallCertByHash(m_pSelectedCertHash,
							m_MachineName, 
							m_WebSiteInstanceName, 
							GetEnrollObject(),
							&m_hResult);
	if (!bRes)
	{
		SetBodyTextID(USE_DEFAULT_CAPTION);
	}

#ifdef ENABLE_W3SVC_SSL_PAGE
    // see if the SSL attribute was set...if it was then set the SSL site for this certificate...
    if (!m_SSLPort.IsEmpty())
    {
        // get the port and write it to the metabase.
        bRes = WriteSSLPortToSite(m_MachineName,m_WebSiteInstanceName,m_SSLPort,&m_hResult);
	    if (!bRes)
	    {
		    SetBodyTextID(USE_DEFAULT_CAPTION);
	    }
    }
#endif

	return bRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\certificat.h ===
//
// Certificat.h
//
#ifndef _CERTIFICAT_H
#define _CERTIFICAT_H

#include <xenroll.h>

#define CERTWIZ_INSTANCE_NAME_PROP_ID   (CERT_FIRST_USER_PROP_ID + 0x1000)
#define CERTWIZ_REQUEST_FLAG_PROP_ID   (CERT_FIRST_USER_PROP_ID + 0x1001)
#define CERTWIZ_REQUEST_TEXT_PROP_ID   (CERT_FIRST_USER_PROP_ID + 0x1002)

#define CERT_HASH_LENGTH		40
typedef struct _CERT_DESCRIPTION
{
	CString m_CommonName;
	CString m_FriendlyName;
	CString m_Country;
	CString m_State;
	CString m_Locality;
	CString m_Organization;
	CString m_OrganizationUnit;
	CString m_CAName;
	CString m_ExpirationDate;
	CString m_Usage;
    CString m_AltSubject;
	BYTE * m_phash;
	DWORD m_hash_length;
} CERT_DESCRIPTION;

class CCertDescList : public CList<CERT_DESCRIPTION *, CERT_DESCRIPTION *&>
{
public:
	CCertDescList() {}
	~CCertDescList();
};

class CCryptBlob
{
public:
	CCryptBlob()
	{
		m_blob.cbData = 0;
		m_blob.pbData = NULL;
	}
	virtual ~CCryptBlob()
	{
	}
	DWORD GetSize() {return m_blob.cbData;}
	BYTE * GetData() {return m_blob.pbData;}
	void Set(DWORD cb, BYTE * pb)
	{
		Destroy();
		m_blob.cbData = cb;
		m_blob.pbData = pb;
	}
	BOOL Resize(DWORD cb);
	operator CRYPT_DATA_BLOB *()
	{
		return &m_blob;
	}

protected:
	void Destroy()
	{
		if (m_blob.pbData != NULL)
			Free(m_blob.pbData);
	}
	virtual BYTE * Realloc(BYTE * pb, DWORD cb) = 0;
	virtual void Free(BYTE * pb) = 0;
	CRYPT_DATA_BLOB m_blob;
};

class CCryptBlobIMalloc : public CCryptBlob
{
public:
	virtual ~CCryptBlobIMalloc()
	{
		CCryptBlob::Destroy();
	}

protected:
	virtual BYTE * Realloc(BYTE * pb, DWORD cb)
	{
		return (BYTE *)CoTaskMemRealloc(pb, cb);
	}
	virtual void Free(BYTE * pb)
	{
		CoTaskMemFree(pb);
	}
};

class CCryptBlobLocal : public CCryptBlob
{
public:
	virtual ~CCryptBlobLocal()
	{
		CCryptBlob::Destroy();
	}

protected:
	virtual BYTE * Realloc(BYTE * pb, DWORD cb)
	{
		return (BYTE *)realloc(pb, cb);
	}
	virtual void Free(BYTE * pb)
	{
		free(pb);
	}
};

extern const TCHAR szState[];
extern const TCHAR szStateMRU[];
extern const TCHAR szLocality[];
extern const TCHAR szLocalityMRU[];
extern const TCHAR szOrganization[];
extern const TCHAR szOrganizationMRU[];
extern const TCHAR szOrganizationUnit[];
extern const TCHAR szOrganizationUnitMRU[];

class CCertificate : public CObject
{
	DECLARE_DYNCREATE(CCertificate)
public:
	CCertificate();
	~CCertificate();

	enum
	{
		CA_OFFLINE = 0,
		CA_ONLINE = 1
	};
	enum
	{
		REQUEST_UNDEFINED,
		REQUEST_NEW_CERT,				// if we generating fresh new certificate
		REQUEST_RENEW_CERT,			// if we generating cert for renewal
		REQUEST_REPLACE_CERT,		// replace currect cert by someone from MY store
		REQUEST_INSTALL_CERT,		// get existing certificate for empty web server
		REQUEST_PROCESS_PENDING,	// accept and install response from CA
		REQUEST_IMPORT_KEYRING,
        REQUEST_IMPORT_CERT,
        REQUEST_EXPORT_CERT,
        REQUEST_COPY_MOVE_FROM_REMOTE,
        REQUEST_COPY_MOVE_TO_REMOTE,
		STATUS_CODE_LAST
	};
	enum
	{
		USE_ERROR_STRING_PARAM = -2,
		USE_ERROR_STRING_ID = -1,
		USE_ERROR_STRING_DEFAULT = USE_DEFAULT_CAPTION
	};
	BOOL Init();
    BOOL IsCertObjInstalled();
	BOOL SaveSettings();
	BOOL SetSecuritySettings();
	BOOL WriteRequest();
	BOOL PrepareRequest();
	BOOL PrepareRequestString(CString& request_text, CCryptBlob& request_blob);
	BOOL WriteRequestString(CString& request);
	BOOL SubmitRequest();
	BOOL SubmitRenewalRequest();
	BOOL WriteRenewalRequest();
	void DumpHeader(CString& str);
	void DumpOnlineHeader(CString& str);
	BOOL GetSelectedCertDescription(CERT_DESCRIPTION& cd);

	BOOL GetPFXFileCertDescription(CERT_DESCRIPTION& cd)
	{
		return GetCertDescription(GetPFXFileCert(), cd);
	}
	BOOL GetKeyCertDescription(CERT_DESCRIPTION& cd)
	{
		return GetCertDescription(GetKeyRingCert(), cd);
	}
	BOOL GetInstalledCertDescription(CERT_DESCRIPTION& cd)
	{
		return GetCertDescription(GetInstalledCert(), cd);
	}
	BOOL GetResponseCertDescription(CERT_DESCRIPTION& cd);
    BOOL GetRemoteFileCertDescription(CERT_DESCRIPTION& cd)
    {
        cd.m_CommonName = m_CommonName;
        cd.m_Country = m_Country;
        cd.m_Locality = m_Locality;
        cd.m_State = m_State;
        cd.m_Organization = m_Organization;
        cd.m_OrganizationUnit = m_OrganizationUnit;
        cd.m_CAName = m_CAName;
        cd.m_ExpirationDate = m_ExpirationDate;
        cd.m_Usage = m_Usage;
        cd.m_AltSubject = m_AltSubject;
        return TRUE;
    }

	BOOL HasPendingRequest()
	{
		return (NULL != GetPendingRequest());
	}
	BOOL HasInstalledCert();
	BOOL InstallResponseCert();
	HRESULT UninstallCert();
	BOOL InstallSelectedCert();
	BOOL InstallKeyRingCert();
    BOOL InstallImportPFXCert();
    BOOL InstallExportPFXCert();
    BOOL InstallCopyMoveFromRemote();
    BOOL InstallCopyMoveToRemote();
	BOOL ReplaceInstalled();
	BOOL CancelRequest();
	PCCERT_CONTEXT GetPendingRequest();
	PCCERT_CONTEXT GetResponseCert();
	PCCERT_CONTEXT GetInstalledCert();
	PCCERT_CONTEXT GetKeyRingCert();
    PCCERT_CONTEXT GetImportCert();
    PCCERT_CONTEXT GetPFXFileCert();
	void DeleteKeyRingCert()
	{
		if (m_pKeyRingCert != NULL)
		{
			CertFreeCertificateContext(m_pKeyRingCert);
			m_pKeyRingCert = NULL;
		}
	}
	IEnroll * GetEnrollObject();
	int GetStatusCode() 
	{
		switch (m_status_code)
		{
		case REQUEST_UNDEFINED:
			IISDebugOutput(_T("GetStatusCode=REQUEST_UNDEFINED\r\n"));
			break;
		case REQUEST_NEW_CERT:
			IISDebugOutput(_T("GetStatusCode=REQUEST_NEW_CERT\r\n"));
			break;
		case REQUEST_RENEW_CERT:
			IISDebugOutput(_T("GetStatusCode=REQUEST_RENEW_CERT\r\n"));
			break;
		case REQUEST_REPLACE_CERT:
			IISDebugOutput(_T("GetStatusCode=REQUEST_REPLACE_CERT\r\n"));
			break;
		case REQUEST_INSTALL_CERT:
			IISDebugOutput(_T("GetStatusCode=REQUEST_INSTALL_CERT\r\n"));
			break;
		case REQUEST_PROCESS_PENDING:
			IISDebugOutput(_T("GetStatusCode=REQUEST_PROCESS_PENDING\r\n"));
			break;
		case REQUEST_IMPORT_KEYRING:
			IISDebugOutput(_T("GetStatusCode=REQUEST_IMPORT_KEYRING\r\n"));
			break;
        case REQUEST_IMPORT_CERT:
			IISDebugOutput(_T("GetStatusCode=REQUEST_IMPORT_CERT\r\n"));
			break;
        case REQUEST_EXPORT_CERT:
			IISDebugOutput(_T("GetStatusCode=REQUEST_EXPORT_CERT\r\n"));
			break;
        case REQUEST_COPY_MOVE_FROM_REMOTE:
			IISDebugOutput(_T("GetStatusCode=REQUEST_COPY_MOVE_FROM_REMOTE\r\n"));
			break;
        case REQUEST_COPY_MOVE_TO_REMOTE:
			IISDebugOutput(_T("GetStatusCode=REQUEST_COPY_MOVE_TO_REMOTE\r\n"));
			break;
		case STATUS_CODE_LAST:
			IISDebugOutput(_T("GetStatusCode=STATUS_CODE_LAST\r\n"));
			break;
		default:
			IISDebugOutput(_T("GetStatusCode=%d\r\n"),m_status_code);
			break;
		}
		return m_status_code;
	}
	void SetStatusCode(int code) 
	{
		ASSERT(code >= 0 && code < STATUS_CODE_LAST);
		m_status_code = code;
	}
	BOOL FindInstanceNameForResponse(CString& str);
	BOOL IsResponseInstalled(CString& str);
	BOOL GetCertDescList(CCertDescList& list);
	BOOL LoadRenewalData();
	int MyStoreCertCount();

	void SetBodyTextID(int nID)
	{
		m_idErrorText = nID;
		m_strErrorText.Empty();
	}
	void SetBodyTextString(const CString& str)
	{
		m_strErrorText = str;
		m_idErrorText = USE_ERROR_STRING_PARAM;
	}
	void GetCertificateTemplate(CString& str)
	{
		str = _T("CertificateTemplate:");
		str += m_CertificateTemplate;
	}

protected:
	void CreateDN(CString& str);
	BOOL WriteHeader();
	BOOL WriteRequestBody();
	BOOL GetCertDescription(PCCERT_CONTEXT pCert,
									CERT_DESCRIPTION& desc);

public:
	int		m_CAType;
	CString	m_ConfigCA;
	CString	m_CertificateTemplate;

	CString	m_FriendlyName;
	int		m_KeyLength;
	CString	m_CommonName;
	CString	m_OrganizationUnit;
	CString	m_Organization;
	CString	m_Locality;
	CString	m_State;
	CString	m_Country;
    // extra info for remote use
	CString m_CAName;
	CString m_ExpirationDate;
    CString m_Usage;
    CString m_AltSubject;
    CString m_SSLPort;

	CStringList m_OnlineCAList;
	CString	m_MachineName;
	CString	m_WebSiteInstanceName;

    BOOL    m_OverWriteExisting;
    BOOL    m_DeleteAfterCopy;
    CString	m_MachineName_Remote;
    CString	m_UserName_Remote;
    CStrPassword m_UserPassword_Remote;
    CString	m_WebSiteInstanceName_Remote;

	CString	m_ReqFileName;
	CString	m_RespFileName;
	CString	m_KeyFileName;
	CStrPassword m_KeyPassword;

    BOOL    m_DefaultCSP;
    DWORD   m_DefaultProviderType;
    DWORD   m_CustomProviderType;
    CString m_CspName;
	CRYPT_HASH_BLOB * m_pSelectedCertHash;

	UINT	m_idErrorText;
	CString	m_strErrorText;
	CString m_strRenewalRequest;
	HRESULT	m_hResult;

	BOOL m_CreateDirectory;
	BOOL m_SGCcertificat;

    BOOL m_ExportPFXPrivateKey;
    BOOL m_CertObjInstalled;
    BOOL m_MarkAsExportable;

protected:
	PCCERT_CONTEXT m_pPendingRequest;
	PCCERT_CONTEXT m_RespCertContext;
	PCCERT_CONTEXT m_pInstalledCert;
	PCCERT_CONTEXT m_pKeyRingCert;
	IEnroll * m_pEnroll;
	int m_status_code;				// what we are doing in this session
};

#endif	// _CERTIFICAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\certsiteusage.cpp ===
#include "stdafx.h"
#include "certwiz.h"
#include "Certificat.h"
#include "CertUtil.h"
#include "CertSiteUsage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define COL_SITE_INSTANCE     0
#define COL_SITE_DESC         1
#define COL_SITE_INSTANCE_WID 50
#define COL_SITE_DESC_WID     100

/////////////////////////////////////////////////////////////////////////////
// CCertSiteUsage


CCertSiteUsage::CCertSiteUsage(CCertificate * pCert,IN CWnd * pParent OPTIONAL) 
: CDialog(CCertSiteUsage::IDD,pParent)
{
    m_pCert = pCert;
	//{{AFX_DATA_INIT(CCertSiteUsage)
	//}}AFX_DATA_INIT
}

CCertSiteUsage::~CCertSiteUsage()
{
}

void CCertSiteUsage::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCertSiteUsage)
	DDX_Control(pDX, IDC_SITE_LIST, m_ServerSiteList);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CCertSiteUsage, CDialog)
	//{{AFX_MSG_MAP(CCertSiteUsage)
    ON_NOTIFY(NM_DBLCLK, IDC_SITE_LIST, OnDblClickSiteList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCertSiteUsage message handlers

BOOL CCertSiteUsage::OnInitDialog()
{
	CDialog::OnInitDialog();
    /*
    HRESULT hr;
    CString MachineName_Remote;
    CString UserName_Remote;
    CString UserPassword_Remote;
    CString SiteToExclude;
    CMapStringToString MetabaseSiteKeyWithSiteDescValueList;
    CStringListEx strlDataPaths;

	CCertListCtrl* pControl = (CCertListCtrl *)CWnd::FromHandle(GetDlgItem(IDC_SITE_LIST)->m_hWnd);
	CRect rcControl;
	pControl->GetClientRect(&rcControl);

    // make the list have column headers
	CString str;
    str= _T("");

    str.LoadString(IDS_SITE_NUM_COLUMN);
	m_ServerSiteList.InsertColumn(COL_SITE_INSTANCE, str, LVCFMT_LEFT, COL_SITE_INSTANCE_WID);

	str.LoadString(IDS_WEB_SITE_COLUMN);
	m_ServerSiteList.InsertColumn(COL_SITE_DESC, str, LVCFMT_LEFT, rcControl.Width() - COL_SITE_INSTANCE_WID);

	m_ServerSiteList.AdjustStyle();

    // Use machine/username/userpassword
    // to connect to the machine
    // and enumerate all the sites on that machine.
    // return back a string1=string2 pair
    // string1 = /w3svc/1
    // string2 = "site description"

    // present a dialog so the user can choose which one they want...
    // m_ServerSiteInstance = /w3svc/1
    // m_ServerSiteDescription = "site description"

    MachineName_Remote = m_pCert->m_MachineName_Remote;
    UserName_Remote = m_pCert->m_UserName_Remote;
    m_pCert->m_UserPassword_Remote.CopyTo(UserName_Remote);

    SiteToExclude = m_pCert->m_WebSiteInstanceName;

    hr = EnumSites(MachineName_Remote,UserName_Remote,UserPassword_Remote,m_pCert->m_WebSiteInstanceName,SiteToExclude,&strlDataPaths);

    if (!strlDataPaths.IsEmpty())
    {
        POSITION pos;
        CString name;
        CString value = _T("");
        CString SiteInstance;

        int item = 0;
        LV_ITEMW lvi;

    	//
		// set up the fields in the list view item struct that don't change from item to item
		//
		memset(&lvi, 0, sizeof(LV_ITEMW));
		lvi.mask = LVIF_TEXT;

        // loop thru the list and display all the stuff on a dialog box...
        pos = strlDataPaths.GetHeadPosition();
        while (pos) 
        {
            int i = 0;
            name = strlDataPaths.GetAt(pos);

            value = _T("");
            
            SiteInstance.Format(_T("%d"), CMetabasePath::GetInstanceNumber(name));
			lvi.iItem = item;
			lvi.iSubItem = COL_SITE_INSTANCE;
			lvi.pszText = (LPTSTR)(LPCTSTR)SiteInstance;
			lvi.cchTextMax = SiteInstance.GetLength();
			i = m_ServerSiteList.InsertItem(&lvi);
			ASSERT(i != -1);

			lvi.iItem = i;
			lvi.iSubItem = COL_SITE_DESC;
			lvi.pszText = (LPTSTR)(LPCTSTR)value;
			lvi.cchTextMax = value.GetLength();
			VERIFY(m_ServerSiteList.SetItem(&lvi));

            // set item data with the pointer to the Strings
            CString * pDataItemString = new CString(name);
            VERIFY(m_ServerSiteList.SetItemData(item, (LONG_PTR)pDataItemString));

			item++;
            strlDataPaths.GetNext(pos);
        }

        FillListWithMetabaseSiteDesc();
    }
    */

	return TRUE;
}

BOOL CCertSiteUsage::FillListWithMetabaseSiteDesc()
{
	int count = m_ServerSiteList.GetItemCount();
    CString strMetabaseKey;
    CString value = _T("");
    CString strDescription;
    HRESULT hr = E_FAIL;
    CString MachineName_Remote;
    CString UserName_Remote;
    CString UserPassword_Remote;
    MachineName_Remote = m_pCert->m_MachineName_Remote;
    UserName_Remote = m_pCert->m_UserName_Remote;

    m_pCert->m_UserPassword_Remote.CopyTo(UserPassword_Remote);

    CString * pMetabaseKey;

    for (int index = 0; index < count; index++)
    {
        pMetabaseKey = (CString *) m_ServerSiteList.GetItemData(index);
        if (pMetabaseKey)
        {
            strMetabaseKey = *pMetabaseKey;
            // Go get the site's description;
            if (TRUE == GetServerComment(MachineName_Remote,UserName_Remote,UserPassword_Remote,strMetabaseKey,strDescription,&hr))
            {
                value = strDescription;
            }
            else
            {
                value = strMetabaseKey;
            }
            m_ServerSiteList.SetItemText(index, COL_SITE_DESC,value);
        }
    }

    return TRUE;
}

void CCertSiteUsage::OnDblClickSiteList(NMHDR* pNMHDR, LRESULT* pResult)
{
    // Get the hash for the certificate that is clicked on...
    m_Index = m_ServerSiteList.GetSelectedIndex();
    if (m_Index != -1)
    {
        // Get the metabase key..
        CString * pMetabaseKey = NULL;
        pMetabaseKey = (CString *) m_ServerSiteList.GetItemData(m_Index);
        if (pMetabaseKey)
        {
            CString stSiteReturned = *pMetabaseKey;
            // use the metabase key to lookup the hash
	        // find cert in store
            CRYPT_HASH_BLOB * pHash = NULL;
            HRESULT hr;
            // go lookup the certhash from the metabase
            if (0 == _tcsicmp(m_pCert->m_MachineName_Remote,m_pCert->m_MachineName))
            {
		        pHash = GetInstalledCertHash(m_pCert->m_MachineName_Remote,stSiteReturned,m_pCert->GetEnrollObject(),&hr);
                if (pHash)
                {
                    ViewCertificateDialog(pHash,m_hWnd);
                    if (pHash){CoTaskMemFree(pHash);}
                }
            }
        }
    }
    return;
}

void CCertSiteUsage::OnDestroy()
{
	// before dialog will be desroyed we need to delete all
	// the item data pointers
	int count = m_ServerSiteList.GetItemCount();
	for (int index = 0; index < count; index++)
	{
		CString * pData = (CString *) m_ServerSiteList.GetItemData(index);
		delete pData;
	}
	CDialog::OnDestroy();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\certsiteusage.h ===
#if !defined(AFX_CCertSiteUsage_H__25260090_DB36_49E2_9435_7519047DDF49__INCLUDED_)
#define AFX_CCertSiteUsage_H__25260090_DB36_49E2_9435_7519047DDF49__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "Certificat.h"

/////////////////////////////////////////////////////////////////////////////
// CCertSiteUsage window

class CCertificate;

class CCertListCtrl : public CListCtrl
{
public:
	int GetSelectedIndex();
	void AdjustStyle();
};


class CCertSiteUsage : public CDialog
{

// Construction
public:
    CCertSiteUsage(CCertificate * pCert = NULL,IN CWnd * pParent = NULL OPTIONAL);
    ~CCertSiteUsage();

// Dialog Data
    //{{AFX_DATA(CCertSiteUsage)
    enum {IDD = IDD_DIALOG_DISPLAY_SITES};
    CCertListCtrl m_ServerSiteList;
    //}}AFX_DATA
    CCertificate * m_pCert;
    int m_Index;

// Overrides
	//{{AFX_VIRTUAL(CCertSiteUsage)
	protected:
    virtual void DoDataExchange(CDataExchange * pDX);
	//}}AFX_VIRTUAL

	// Generated message map functions
protected:
	//{{AFX_MSG(CCertSiteUsage)
    virtual BOOL OnInitDialog();
    afx_msg void OnDblClickSiteList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnDestroy();
    
	//}}AFX_MSG
    BOOL FillListWithMetabaseSiteDesc();

	DECLARE_MESSAGE_MAP()
private:
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CCertSiteUsage_H__25260090_DB36_49E2_9435_7519047DDF49__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\certexportimport.cpp ===
#include "StdAfx.h"
#include "base64.h"
#include <malloc.h>
#include <wincrypt.h>

#ifndef USE_LOCAL_IMPLEMENTATION
    HRESULT ImportCertFromFile(BSTR FileName, BSTR Password, BSTR bstrInstanceName){return HRESULT_FROM_WIN32(ERROR_CALL_NOT_IMPLEMENTED);}
    HRESULT ExportCertToFile(BSTR bstrInstanceName, BSTR FileName,BSTR Password,BOOL bPrivateKey,BOOL bCertChain){return HRESULT_FROM_WIN32(ERROR_CALL_NOT_IMPLEMENTED);}
#else


CString ReturnGoodMetabasePath(CString csInstanceName)
{
    CString key_path_lm = _T("");
    CString key_path = _T("");
    // csInstanceName will come in looking like
    // w3svc/1
    // or /lm/w3svc/1
    //
    // we want to it to go out as /lm/w3svc/1
    key_path_lm = SZ_MBN_SEP_STR SZ_MBN_MACHINE SZ_MBN_SEP_STR;// SZ_MBN_WEB SZ_MBN_SEP_STR;

    if (csInstanceName.GetLength() >= 4)
    {
        if (csInstanceName.Left(4) == key_path_lm)
        {
            key_path = csInstanceName;
        }
        else
        {
            key_path_lm = SZ_MBN_MACHINE SZ_MBN_SEP_STR;
            if (csInstanceName.Left(3) == key_path_lm)
            {
                key_path = csInstanceName;
            }
            else
            {
                key_path = key_path_lm;
                key_path += csInstanceName;
            }
        }
    }
    else
    {
        key_path = key_path_lm;
        key_path += csInstanceName;
    }

    return key_path;
}


CERT_CONTEXT * GetInstalledCert(HRESULT * phResult, CString csKeyPath)
{
    ATLASSERT(phResult != NULL);
    CERT_CONTEXT * pCert = NULL;
    *phResult = S_OK;
    CComAuthInfo auth;
    CString key_path = ReturnGoodMetabasePath(csKeyPath);

    CMetaKey key(&auth, key_path, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);
    if (key.Succeeded())
    {
        CString store_name;
        CBlob hash;
        if (SUCCEEDED(*phResult = key.QueryValue(MD_SSL_CERT_STORE_NAME, store_name)) &&
            SUCCEEDED(*phResult = key.QueryValue(MD_SSL_CERT_HASH, hash)))
        {
            // Open MY store. We assume that store type and flags
            // cannot be changed between installation and unistallation
            // of the sertificate.
            HCERTSTORE hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM,PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,NULL,CERT_SYSTEM_STORE_LOCAL_MACHINE,store_name);
            ASSERT(hStore != NULL);
            if (hStore != NULL)
            {
                // Now we need to find cert by hash
                CRYPT_HASH_BLOB crypt_hash;
                crypt_hash.cbData = hash.GetSize();
                crypt_hash.pbData = hash.GetData();
                pCert = (CERT_CONTEXT *)CertFindCertificateInStore(hStore,X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,0,CERT_FIND_HASH,(LPVOID)&crypt_hash,NULL);
                if (pCert == NULL)
                {
                    *phResult = HRESULT_FROM_WIN32(GetLastError());
                }
                VERIFY(CertCloseStore(hStore, 0));
            }
            else
            {
                *phResult = HRESULT_FROM_WIN32(GetLastError());
            }
        }
    }
    else
    {
        *phResult = key.QueryResult();
    }
    return pCert;
}


BOOL AddChainToStore(HCERTSTORE hCertStore,PCCERT_CONTEXT pCertContext,DWORD cStores,HCERTSTORE * rghStores,BOOL fDontAddRootCert,CERT_TRUST_STATUS * pChainTrustStatus)
{
    DWORD	i;
    CERT_CHAIN_ENGINE_CONFIG CertChainEngineConfig;
    HCERTCHAINENGINE hCertChainEngine = NULL;
    PCCERT_CHAIN_CONTEXT pCertChainContext = NULL;
    CERT_CHAIN_PARA CertChainPara;
    BOOL fRet = TRUE;
    PCCERT_CONTEXT pTempCertContext = NULL;

    //
    // create a new chain engine, then build the chain
    //
    memset(&CertChainEngineConfig, 0, sizeof(CertChainEngineConfig));
    CertChainEngineConfig.cbSize = sizeof(CertChainEngineConfig);
    CertChainEngineConfig.cAdditionalStore = cStores;
    CertChainEngineConfig.rghAdditionalStore = rghStores;
    CertChainEngineConfig.dwFlags = CERT_CHAIN_USE_LOCAL_MACHINE_STORE;

    if (!CertCreateCertificateChainEngine(&CertChainEngineConfig, &hCertChainEngine))
    {
        goto AddChainToStore_Error;
    }

	memset(&CertChainPara, 0, sizeof(CertChainPara));
	CertChainPara.cbSize = sizeof(CertChainPara);

	if (!CertGetCertificateChain(hCertChainEngine,pCertContext,NULL,NULL,&CertChainPara,0,NULL,&pCertChainContext))
	{
		goto AddChainToStore_Error;
	}

    //
    // make sure there is atleast 1 simple chain
    //
    if (pCertChainContext->cChain != 0)
	{
		i = 0;
		while (i < pCertChainContext->rgpChain[0]->cElement)
		{
			//
			// if we are supposed to skip the root cert,
			// and we are on the root cert, then continue
			//
			if (fDontAddRootCert && (pCertChainContext->rgpChain[0]->rgpElement[i]->TrustStatus.dwInfoStatus & CERT_TRUST_IS_SELF_SIGNED))
			{
                i++;
                continue;
			}

			CertAddCertificateContextToStore(hCertStore,pCertChainContext->rgpChain[0]->rgpElement[i]->pCertContext,CERT_STORE_ADD_REPLACE_EXISTING,&pTempCertContext);
            //
            // remove any private key property the certcontext may have on it.
            //
            if (pTempCertContext)
            {
                CertSetCertificateContextProperty(pTempCertContext, CERT_KEY_PROV_INFO_PROP_ID, 0, NULL);
                CertFreeCertificateContext(pTempCertContext);
            }

			i++;
		}
	}
	else
	{
		goto AddChainToStore_Error;
	}

	//
	// if the caller wants the status, then set it
	//
	if (pChainTrustStatus != NULL)
	{
		pChainTrustStatus->dwErrorStatus = pCertChainContext->TrustStatus.dwErrorStatus;
		pChainTrustStatus->dwInfoStatus = pCertChainContext->TrustStatus.dwInfoStatus;
	}

	
AddChainToStore_Exit:
	if (pCertChainContext != NULL)
	{
		CertFreeCertificateChain(pCertChainContext);
	}

	if (hCertChainEngine != NULL)
	{
		CertFreeCertificateChainEngine(hCertChainEngine);
	}
	return fRet;

AddChainToStore_Error:
	fRet = FALSE;
	goto AddChainToStore_Exit;
}


HRESULT ExportToBlob(BSTR InstanceName,BSTR Password,BOOL bPrivateKey,BOOL bCertChain,DWORD *cbBufferSize,char **pbBuffer)
{
    HRESULT hr = E_FAIL;
    PCCERT_CONTEXT pCertContext = NULL;
    BOOL bStatus = FALSE;
    HCERTSTORE hStore = NULL;
    DWORD dwOpenFlags = CERT_STORE_READONLY_FLAG | CERT_STORE_ENUM_ARCHIVED_FLAG;
    CRYPT_DATA_BLOB DataBlob;
    ZeroMemory(&DataBlob, sizeof(CRYPT_DATA_BLOB));

    char *pszB64Out = NULL;
    DWORD pcchB64Out = 0;
    DWORD  err;

    //
    // get the certificate from the server
    //
    pCertContext = GetInstalledCert(&hr,InstanceName);
    if (NULL == pCertContext)
    {
        *cbBufferSize = 0;
        pbBuffer = NULL;
        goto ExportToBlob_Exit;
    }

    //
    // Export cert
    //
    // Open a temporary store to stick the cert in.
    hStore = CertOpenStore(CERT_STORE_PROV_MEMORY,X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,0,dwOpenFlags,NULL);
    if(NULL == hStore)
    {
        *cbBufferSize = 0;
        pbBuffer = NULL;
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ExportToBlob_Exit;
    }

    //
    // get all the certs in the chain if we need to
    //
    if (bCertChain)
    {
        AddChainToStore(hStore, pCertContext, 0, 0, FALSE, NULL);
    }

    if(!CertAddCertificateContextToStore(hStore,pCertContext,CERT_STORE_ADD_REPLACE_EXISTING,NULL))
    {
        *cbBufferSize = 0;
        pbBuffer = NULL;
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ExportToBlob_Exit;
    }

    // free cert context since we no longer need to hold it
    if (pCertContext) 
    {
        CertFreeCertificateContext(pCertContext);pCertContext=NULL;
    }

    DataBlob.cbData = 0;
    DataBlob.pbData = NULL;
    if (!PFXExportCertStoreEx(hStore,&DataBlob,Password,NULL,bPrivateKey ? EXPORT_PRIVATE_KEYS : 0))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ExportToBlob_Exit;
    }
    if(DataBlob.cbData <= 0)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ExportToBlob_Exit;
    }

    if(NULL == (DataBlob.pbData = (PBYTE) ::CoTaskMemAlloc(DataBlob.cbData)))
    {
        hr = E_OUTOFMEMORY;
        goto ExportToBlob_Exit;
    }

    //
    // at this point they have allocated enough memory
    // let's go and get the cert and put it into DataBlob
    //
    if(!PFXExportCertStoreEx(hStore,&DataBlob,Password,NULL,bPrivateKey ? EXPORT_PRIVATE_KEYS : 0))
    {
        if (DataBlob.pbData){CoTaskMemFree(DataBlob.pbData);DataBlob.pbData = NULL;}
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ExportToBlob_Exit;
    }

    // Encode it so that it can be passed back as a string (there are no Nulls in it)
    err = Base64EncodeA(DataBlob.pbData,DataBlob.cbData,NULL,&pcchB64Out);
    if (err != ERROR_SUCCESS)
    {
        hr = E_FAIL;
        goto ExportToBlob_Exit;
    }

    // allocate some space and then try it.
    pcchB64Out = pcchB64Out * sizeof(char);
    pszB64Out = (char *) ::CoTaskMemAlloc(pcchB64Out);
    if (NULL == pszB64Out)
    {
        hr = E_OUTOFMEMORY;
        goto ExportToBlob_Exit;
    }

    err = Base64EncodeA(DataBlob.pbData,DataBlob.cbData,pszB64Out,&pcchB64Out);
    if (err != ERROR_SUCCESS)
    {
        if (NULL != pszB64Out){CoTaskMemFree(pszB64Out);pszB64Out = NULL;}
        hr = E_FAIL;
        goto ExportToBlob_Exit;
    }

    // copy the new memory to pass back
    *cbBufferSize = pcchB64Out;
    *pbBuffer = pszB64Out;

    hr = ERROR_SUCCESS;

ExportToBlob_Exit:
    if (NULL != DataBlob.pbData)
    {
        // perhaspse will this up with zeros...
        ZeroMemory(DataBlob.pbData, DataBlob.cbData);
        ::CoTaskMemFree(DataBlob.pbData);DataBlob.pbData = NULL;
    }
    if (NULL != hStore){CertCloseStore(hStore, 0);hStore=NULL;}
    if (NULL != pCertContext) {CertFreeCertificateContext(pCertContext);pCertContext=NULL;}
    return hr;
}


HRESULT ExportCertToFile(BSTR bstrInstanceName, BSTR FileName,BSTR Password,BOOL bPrivateKey,BOOL bCertChain)
{
    HRESULT hr = S_OK;
    DWORD  cbEncodedSize = 0;
    char * pszEncodedString = NULL;
    DWORD  blob_cbData = 0;
    BYTE * blob_pbData = NULL;
    BOOL   blob_freeme = FALSE;

    // Check mandatory properties
    if (  FileName == NULL || *FileName == 0
        || Password == NULL || *Password == 0
        || bstrInstanceName == NULL || *bstrInstanceName == 0)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Call function go get data from the remote/local iis store
    // and return it back as a blob.  the blob could be returned back as Base64 encoded
    // so check that flag
    hr = ExportToBlob(bstrInstanceName,Password,bPrivateKey,bCertChain,&cbEncodedSize, &pszEncodedString);
    if (FAILED(hr))
    {
        goto Export_Exit;
    }

    if (SUCCEEDED(hr))
    {
        int err;

        // The data we got back was Base64 encoded to remove nulls.
        // we need to decode it back to it's original format.
        if( (err = Base64DecodeA(pszEncodedString,cbEncodedSize,NULL,&blob_cbData)) != ERROR_SUCCESS ||
            (blob_pbData = (BYTE *) malloc(blob_cbData)) == NULL ||
            (err = Base64DecodeA(pszEncodedString,cbEncodedSize,blob_pbData,&blob_cbData)) != ERROR_SUCCESS ) 
        {
            SetLastError(err);
            hr = HRESULT_FROM_WIN32(err);
            return hr;
        }
        blob_freeme = TRUE;

        HANDLE hFile = CreateFile(FileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (INVALID_HANDLE_VALUE == hFile)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            return hr;
        }

        DWORD written = 0;
        if (!WriteFile(hFile, blob_pbData, blob_cbData, &written, NULL))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        else
        {
            hr = S_OK;
        }
        CloseHandle(hFile);

    }

Export_Exit:
    if (blob_freeme)
    {
        if (blob_pbData != NULL)
        {
            // Erase the memory that the private key used to be in!!!
            ZeroMemory(blob_pbData, blob_cbData);
            free(blob_pbData);blob_pbData=NULL;
        }
    }
    if (pszEncodedString != NULL)
    {
        // Erase the memory that the private key used to be in!!!
        ZeroMemory(pszEncodedString, cbEncodedSize);
        CoTaskMemFree(pszEncodedString);pszEncodedString=NULL;
    }
    return hr;
}


BOOL InstallHashToMetabase(CRYPT_HASH_BLOB * pHash,BSTR InstanceName,HRESULT * phResult)
{
    BOOL bRes = FALSE;
    CComAuthInfo auth;
    CString key_path = ReturnGoodMetabasePath(InstanceName);
    CMetaKey key(&auth, key_path, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);
	if (key.Succeeded())
	{
		CBlob blob;
		blob.SetValue(pHash->cbData, pHash->pbData, TRUE);
		bRes = SUCCEEDED(*phResult = key.SetValue(MD_SSL_CERT_HASH, blob))
			&& SUCCEEDED(*phResult = key.SetValue(MD_SSL_CERT_STORE_NAME, CString(L"MY")));
	}
	else
	{
        *phResult = key.QueryResult();
	}
	return bRes;
}


// This function is borrowed from trustapi.cpp
BOOL TrustIsCertificateSelfSigned(PCCERT_CONTEXT pContext,DWORD dwEncoding, DWORD dwFlags)
{
    if (!(pContext) || (dwFlags != 0))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (!(CertCompareCertificateName(dwEncoding,&pContext->pCertInfo->Issuer,&pContext->pCertInfo->Subject)))
    {
        return(FALSE);
    }

    DWORD   dwFlag;

    dwFlag = CERT_STORE_SIGNATURE_FLAG;

    if (!(CertVerifySubjectCertificateContext(pContext, pContext, &dwFlag)) || 
        (dwFlag & CERT_STORE_SIGNATURE_FLAG))
    {
        return(FALSE);
    }

    return(TRUE);
}


HRESULT ImportFromBlobHash(BSTR InstanceName,BSTR Password,BOOL bInstallToMetabase,DWORD count,char *pData,DWORD *cbHashBufferSize,char **pbHashBuffer)
{
    HRESULT hr = S_OK;
    CRYPT_DATA_BLOB blob;
    ZeroMemory(&blob, sizeof(CRYPT_DATA_BLOB));
    LPTSTR pPass = Password;
    BOOL   blob_freeme = FALSE;
    int err;

    // The data we got back was Base64 encoded to remove nulls.
    // we need to decode it back to it's original format.
    if( (err = Base64DecodeA(pData,count,NULL,&blob.cbData)) != ERROR_SUCCESS ||
        (blob.pbData = (BYTE *) malloc(blob.cbData)) == NULL ||
        (err = Base64DecodeA(pData,count,blob.pbData,&blob.cbData)) != ERROR_SUCCESS ) 
    {
        SetLastError(err);
        hr = HRESULT_FROM_WIN32(err);
        return hr;
    }
    blob_freeme = TRUE;

    if (!PFXVerifyPassword(&blob, pPass, 0))
    {
        // Try empty password
        if (pPass == NULL)
        {
            if (!PFXVerifyPassword(&blob, pPass = L'\0', 0))
            {
                hr = ERROR_INVALID_PARAMETER;
            }
        }
        else
        {
            hr = ERROR_INVALID_PARAMETER;
        }
    }
    if (SUCCEEDED(hr))
    {
        HCERTSTORE hStore = PFXImportCertStore(&blob, pPass, CRYPT_MACHINE_KEYSET|CRYPT_EXPORTABLE);
        if (hStore != NULL)
        {
            //add the certificate with private key to my store; and the rest
            //to the ca store
            PCCERT_CONTEXT	pCertContext = NULL;
            PCCERT_CONTEXT	pCertPre = NULL;
            while (  SUCCEEDED(hr)
            && NULL != (pCertContext = CertEnumCertificatesInStore(hStore, pCertPre))
            )
            {
                //check if the certificate has the property on it
                //make sure the private key matches the certificate
                //search for both machine key and user keys
                DWORD dwData = 0;
                if (CertGetCertificateContextProperty(pCertContext,CERT_KEY_PROV_INFO_PROP_ID, NULL, &dwData) &&  CryptFindCertificateKeyProvInfo(pCertContext, 0, NULL))
                {
                    // This certificate should go to the My store
                    HCERTSTORE hDestStore = CertOpenStore(CERT_STORE_PROV_SYSTEM,PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,NULL,CERT_SYSTEM_STORE_LOCAL_MACHINE,L"MY");
                    if (hDestStore != NULL)
                    {
                        // Put it to store
                        if (CertAddCertificateContextToStore(hDestStore,pCertContext,CERT_STORE_ADD_REPLACE_EXISTING,NULL))
                        {
                            // Succeeded to put it to the storage
                            hr = S_OK;

                            // Install to metabase
                            CRYPT_HASH_BLOB hash;
                            hash.pbData = NULL;
                            if (  CertGetCertificateContextProperty(pCertContext,CERT_SHA1_HASH_PROP_ID, NULL, &hash.cbData))
                            {
                                hash.pbData = (BYTE *) LocalAlloc(LPTR,hash.cbData);
                                if (hash.pbData)
                                {
                                    if (CertGetCertificateContextProperty(pCertContext, CERT_SHA1_HASH_PROP_ID, hash.pbData, &hash.cbData)))
                                    {
                                        if (TRUE == bInstallToMetabase)
                                        {
                                            // returns error code in hr
                                            InstallHashToMetabase(&hash, InstanceName, &hr);
                                        }
          
                                        // check if we need to return back the hash
                                        if (NULL != pbHashBuffer)
                                        {
                                            *pbHashBuffer = (char *) ::CoTaskMemAlloc(hash.cbData);
                                            if (NULL == *pbHashBuffer)
                                            {
                                                hr = E_OUTOFMEMORY;
                                                *pbHashBuffer = NULL;
                                                *cbHashBufferSize = 0;
                                            }
                                            else
                                            {
                                                *cbHashBufferSize = hash.cbData;
                                                memcpy(*pbHashBuffer,hash.pbData,hash.cbData);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        hr = HRESULT_FROM_WIN32(GetLastError());
                                    }
                                    if (hash.pbData)
                                    {
                                        LocalFree(hash.pbData);hash.pbData=NULL;
                                    }
                                }
                                else
                                {
                                    hr = HRESULT_FROM_WIN32(GetLastError());
                                }
                            }
                            else
                            {
                                hr = HRESULT_FROM_WIN32(GetLastError());
                            }
                        }
                        else
                        {
                            hr = HRESULT_FROM_WIN32(GetLastError());
                        }
                        CertCloseStore(hDestStore, 0);
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }
                }  // my store certificate
                //see if the certificate is self-signed.
                //if it is selfsigned, goes to the root store
                else if (TrustIsCertificateSelfSigned(pCertContext,pCertContext->dwCertEncodingType, 0))
                {
                    //Put it to the root store
                    HCERTSTORE hDestStore=CertOpenStore(CERT_STORE_PROV_SYSTEM,PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,NULL,CERT_SYSTEM_STORE_LOCAL_MACHINE,L"ROOT");
                    if (hDestStore != NULL)
                    {
                        // Put it to store
                        if (!CertAddCertificateContextToStore(hDestStore,pCertContext,CERT_STORE_ADD_REPLACE_EXISTING,NULL))
                        {
                            hr = HRESULT_FROM_WIN32(GetLastError());
                        }
                        CertCloseStore(hDestStore, 0);
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }
                }
                else
                {
                    //Put it to the CA store
                    HCERTSTORE hDestStore=CertOpenStore(CERT_STORE_PROV_SYSTEM,PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,NULL,CERT_SYSTEM_STORE_LOCAL_MACHINE,L"CA");
                    if (hDestStore != NULL)
                    {
                        // Put it to store
                        if (!CertAddCertificateContextToStore(hDestStore,pCertContext,CERT_STORE_ADD_REPLACE_EXISTING,NULL))
                        {
                            hr = HRESULT_FROM_WIN32(GetLastError());
                        }
                        CertCloseStore(hDestStore, 0);
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }
                }
                pCertPre = pCertContext;
            } //while

            CertCloseStore(hStore, 0);
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

//ImportFromBlobHash_Exit:
    if (blob_freeme)
    {
        if (blob.pbData != NULL)
        {
            ZeroMemory(blob.pbData, blob.cbData);
            free(blob.pbData);blob.pbData=NULL;
        }
    }
    return hr;
}


HRESULT ImportFromBlobProxy(BSTR InstanceName,BSTR Password,BOOL bInstallToMetabase,DWORD actual,BYTE *pData,DWORD *cbHashBufferSize,char **pbHashBuffer)
{
    HRESULT hr = E_FAIL;
    char *pszB64Out = NULL;
    DWORD pcchB64Out = 0;

    // base64 encode the data for transfer to the remote machine
    DWORD  err;
    pcchB64Out = 0;

    // Encode it so that it can be passed back as a string (there are no Nulls in it)
    err = Base64EncodeA(pData,actual,NULL,&pcchB64Out);
    if (err != ERROR_SUCCESS)
    {
        hr = E_FAIL;
        goto ImportFromBlobProxy_Exit;
    }

    // allocate some space and then try it.
    pcchB64Out = pcchB64Out * sizeof(char);
    pszB64Out = (char *) ::CoTaskMemAlloc(pcchB64Out);
    if (NULL == pszB64Out)
    {
        hr = E_OUTOFMEMORY;
        goto ImportFromBlobProxy_Exit;
    }

    err = Base64EncodeA(pData,actual,pszB64Out,&pcchB64Out);
    if (err != ERROR_SUCCESS)
    {
        hr = E_FAIL;
        goto ImportFromBlobProxy_Exit;
    }

    // the data to send are now in these variables
    // pcchB64Out
    // pszB64Out
    if (NULL != pbHashBuffer)
    {
        hr = ImportFromBlobHash(InstanceName,Password,bInstallToMetabase,pcchB64Out,pszB64Out,cbHashBufferSize,pbHashBuffer);
    }
    if (SUCCEEDED(hr))
    {
        // otherwise hey, The data was imported!
        hr = S_OK;
    }

ImportFromBlobProxy_Exit:
    if (NULL != pszB64Out)
    {
        ZeroMemory(pszB64Out,pcchB64Out);
        CoTaskMemFree(pszB64Out);
    }
    return hr;
}


HRESULT ImportCertFromFile(BSTR FileName, BSTR Password, BSTR bstrInstanceName)
{
    HRESULT hr = S_OK;
    BYTE * pbData = NULL;
    DWORD actual = 0, cbData = 0;

    // Check mandatory properties
    if (  FileName == NULL || *FileName == 0
        || Password == NULL || *Password == 0
        || bstrInstanceName == NULL || *bstrInstanceName == 0)
    {
        return ERROR_INVALID_PARAMETER;
    }

    HANDLE hFile = CreateFile(FileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        hFile = NULL;
        goto Import_Exit;
    }

    if (-1 == (cbData = ::GetFileSize(hFile, NULL)))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Import_Exit;
    }

    if (NULL == (pbData = (BYTE *)::CoTaskMemAlloc(cbData)))
    {
        hr = E_OUTOFMEMORY;
        goto Import_Exit;
    }
    if (ReadFile(hFile, pbData, cbData, &actual, NULL))
    {
        hr = ImportFromBlobProxy(bstrInstanceName, Password, TRUE, actual, pbData, 0, NULL);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Import_Exit;
    }

Import_Exit:
    if (pbData != NULL)
    {
        ZeroMemory(pbData, cbData);
        ::CoTaskMemFree(pbData);
    }
    if (hFile != NULL){CloseHandle(hFile);}
    return hr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\certutil.cpp ===
//
// CertUtil.cpp
//
#include "StdAfx.h"
#include "CertUtil.h"
#include "base64.h"
#include <malloc.h>
#include "Certificat.h"
#include <wincrypt.h>
#include "Resource.h"
#include "Shlwapi.h"
#include "CertCA.h"
#include "cryptui.h"
#include <schannel.h>
#include <strsafe.h>

// for certobj object
#include "certobj.h"


#define ISNUM(cChar)				((cChar >= _T('0')) && (cChar <= _T('9'))) ? (TRUE) : (FALSE)

const CLSID CLSID_CCertConfig =
	{0x372fce38, 0x4324, 0x11d0, {0x88, 0x10, 0x00, 0xa0, 0xc9, 0x03, 0xb8, 0x3c}};

const GUID IID_ICertConfig = 
	{0x372fce34, 0x4324, 0x11d0, {0x88, 0x10, 0x00, 0xa0, 0xc9, 0x03, 0xb8, 0x3c}};

#define	CRYPTUI_MAX_STRING_SIZE		768
#define ARRAYSIZE(x) (sizeof(x)/sizeof(x[0]))


BOOL
GetOnlineCAList(CStringList& list, const CString& certType, HRESULT * phRes)
{
	BOOL bRes = TRUE;
   HRESULT hr = S_OK;
   DWORD errBefore = GetLastError();
   DWORD dwCACount = 0;

   HCAINFO hCurCAInfo = NULL;
   HCAINFO hPreCAInfo = NULL;
   
   if (certType.IsEmpty())
		return FALSE;

   *phRes = CAFindByCertType(certType, NULL, 0, &hCurCAInfo);
   if (FAILED(*phRes) || NULL == hCurCAInfo)
   {
		if (S_OK == hr)
         hr=E_FAIL;   
		return FALSE;
   }

   //get the CA count
   if (0 == (dwCACount = CACountCAs(hCurCAInfo)))
   {
      *phRes = E_FAIL;
		return FALSE;
   }
	WCHAR ** ppwstrName, ** ppwstrMachine;
   while (hCurCAInfo)
   {
		//get the CA information
      if (	SUCCEEDED(CAGetCAProperty(hCurCAInfo, CA_PROP_DISPLAY_NAME, &ppwstrName))
			&& SUCCEEDED(CAGetCAProperty(hCurCAInfo, CA_PROP_DNSNAME, &ppwstrMachine))
			)
      {
			CString config;
			config = *ppwstrMachine;
			config += L"\\";
			config += *ppwstrName;
			list.AddTail(config);
			CAFreeCAProperty(hCurCAInfo, ppwstrName);
			CAFreeCAProperty(hCurCAInfo, ppwstrMachine);
      }
		else
		{
			bRes = FALSE;
			break;
		}

      hPreCAInfo = hCurCAInfo;
		if (FAILED(*phRes = CAEnumNextCA(hPreCAInfo, &hCurCAInfo)))
		{
			bRes = FALSE;
			break;
		}
      CACloseCA(hPreCAInfo);
	  hPreCAInfo = NULL;
   }
   
   if (hPreCAInfo)
      CACloseCA(hPreCAInfo);
   if (hCurCAInfo)
      CACloseCA(hCurCAInfo);

   SetLastError(errBefore);

	return bRes;
}

PCCERT_CONTEXT
GetRequestContext(CCryptBlob& pkcs7, HRESULT * phRes)
{
	ASSERT(phRes != NULL);
	BOOL bRes = FALSE;
   HCERTSTORE hStoreMsg = NULL;
   PCCERT_CONTEXT pCertContextMsg = NULL;

   if (!CryptQueryObject(CERT_QUERY_OBJECT_BLOB,
            (PCERT_BLOB)pkcs7,
            (CERT_QUERY_CONTENT_FLAG_CERT |
            CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED |
            CERT_QUERY_CONTENT_FLAG_SERIALIZED_STORE |
            CERT_QUERY_CONTENT_FLAG_PKCS7_UNSIGNED) ,
            CERT_QUERY_FORMAT_FLAG_ALL,
            0,
            NULL,
            NULL,
            NULL,
            &hStoreMsg,
            NULL,
            NULL)
      || NULL == (pCertContextMsg = CertFindCertificateInStore(
            hStoreMsg,
            X509_ASN_ENCODING,
            0,
            CERT_FIND_ANY,
            NULL,
            NULL)) 
      )
   {
		*phRes = HRESULT_FROM_WIN32(GetLastError());
   }
   return pCertContextMsg;
}


BOOL GetRequestInfoFromPKCS10(CCryptBlob& pkcs10, 
										PCERT_REQUEST_INFO * pReqInfo,
										HRESULT * phRes)
{
	ASSERT(pReqInfo != NULL);
	ASSERT(phRes != NULL);
	BOOL bRes = FALSE;
	DWORD req_info_size;
	if (!(bRes = CryptDecodeObjectEx(
							X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 
							X509_CERT_REQUEST_TO_BE_SIGNED,
							pkcs10.GetData(), 
							pkcs10.GetSize(), 
							CRYPT_DECODE_ALLOC_FLAG,
							NULL,
							pReqInfo, 
							&req_info_size)))
	{
		TRACE(_T("Error from CryptDecodeObjectEx: %xd\n"), GetLastError());
		*phRes = HRESULT_FROM_WIN32(GetLastError());
	}
	return bRes;
}

#if 0
// This function extracts data from pkcs7 format
BOOL GetRequestInfoFromRenewalRequest(CCryptBlob& renewal_req,
                              PCCERT_CONTEXT * pSignerCert,
                              HCERTSTORE hStore,
										PCERT_REQUEST_INFO * pReqInfo,
										HRESULT * phRes)
{
   BOOL bRes;
   CRYPT_DECRYPT_MESSAGE_PARA decr_para;
   CRYPT_VERIFY_MESSAGE_PARA ver_para;

   decr_para.cbSize = sizeof(decr_para);
   decr_para.dwMsgAndCertEncodingType = X509_ASN_ENCODING | PKCS_7_ASN_ENCODING;
   decr_para.cCertStore = 1;
   decr_para.rghCertStore = &hStore;

   ver_para.cbSize = sizeof(ver_para);
   ver_para.dwMsgAndCertEncodingType = X509_ASN_ENCODING | PKCS_7_ASN_ENCODING;
   ver_para.hCryptProv = 0;
   ver_para.pfnGetSignerCertificate = NULL;
   ver_para.pvGetArg = NULL;

   DWORD dwMsgType;
   DWORD dwInnerContentType;
   DWORD cbDecoded;

   if (bRes = CryptDecodeMessage(
                  CMSG_SIGNED_FLAG,
                  &decr_para,
                  &ver_para,
                  0,
                  renewal_req.GetData(),
                  renewal_req.GetSize(),
                  0,
                  &dwMsgType,
                  &dwInnerContentType,
                  NULL,
                  &cbDecoded,
                  NULL,
                  pSignerCert))
   {
      CCryptBlobLocal decoded_req;
      decoded_req.Resize(cbDecoded);
      if (bRes = CryptDecodeMessage(
                  CMSG_SIGNED_FLAG,
                  &decr_para,
                  &ver_para,
                  0,
                  renewal_req.GetData(),
                  renewal_req.GetSize(),
                  0,
                  &dwMsgType,
                  &dwInnerContentType,
                  decoded_req.GetData(),
                  &cbDecoded,
                  NULL,
                  pSignerCert))
      {
         bRes = GetRequestInfoFromPKCS10(decoded_req,
                  pReqInfo, phRes);
      }
   }
   if (!bRes)
   {
	   *phRes = HRESULT_FROM_WIN32(GetLastError());
   }
   return bRes;
}
#endif

HCERTSTORE
OpenRequestStore(IEnroll * pEnroll, HRESULT * phResult)
{
	ASSERT(NULL != phResult);
	HCERTSTORE hStore = NULL;
	WCHAR * bstrStoreName, * bstrStoreType;
	long dwStoreFlags;
	VERIFY(SUCCEEDED(pEnroll->get_RequestStoreNameWStr(&bstrStoreName)));
	VERIFY(SUCCEEDED(pEnroll->get_RequestStoreTypeWStr(&bstrStoreType)));
	VERIFY(SUCCEEDED(pEnroll->get_RequestStoreFlags(&dwStoreFlags)));
	size_t store_type_len = _tcslen(bstrStoreType);

	char * szStoreProvider = (char *) LocalAlloc(LPTR,store_type_len + 1);

	ASSERT(szStoreProvider != NULL);
	size_t n = wcstombs(szStoreProvider, bstrStoreType, store_type_len);
	szStoreProvider[n] = '\0';
	hStore = CertOpenStore(
		szStoreProvider,
      PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
		NULL,
		dwStoreFlags,
		bstrStoreName
		);
	CoTaskMemFree(bstrStoreName);
	CoTaskMemFree(bstrStoreType);
	if (hStore == NULL)
	{
		*phResult = HRESULT_FROM_WIN32(GetLastError());
	}

	if (szStoreProvider)
	{
		LocalFree(szStoreProvider);szStoreProvider=NULL;
	}
	return hStore;
}

HCERTSTORE
OpenMyStore(IEnroll * pEnroll, HRESULT * phResult)
{
	ASSERT(NULL != phResult);
	HCERTSTORE hStore = NULL;
	BSTR bstrStoreName, bstrStoreType;
	long dwStoreFlags;
	VERIFY(SUCCEEDED(pEnroll->get_MyStoreNameWStr(&bstrStoreName)));
	VERIFY(SUCCEEDED(pEnroll->get_MyStoreTypeWStr(&bstrStoreType)));
	VERIFY(SUCCEEDED(pEnroll->get_MyStoreFlags(&dwStoreFlags)));
	size_t store_type_len = _tcslen(bstrStoreType);

	char * szStoreProvider = (char *) LocalAlloc(LPTR,store_type_len + 1);
	ASSERT(szStoreProvider != NULL);
	size_t n = wcstombs(szStoreProvider, bstrStoreType, store_type_len);
	ASSERT(n != -1);
	// this converter doesn't set zero byte!!!
	szStoreProvider[n] = '\0';
	hStore = CertOpenStore(
		szStoreProvider,
      PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
		NULL,
		dwStoreFlags,
		bstrStoreName
		);
	CoTaskMemFree(bstrStoreName);
	CoTaskMemFree(bstrStoreType);
	if (hStore == NULL)
	{
		*phResult = HRESULT_FROM_WIN32(GetLastError());
	}
	if (szStoreProvider)
	{
		LocalFree(szStoreProvider);szStoreProvider=NULL;
	}
	return hStore;
}

BOOL
GetStringProperty(PCCERT_CONTEXT pCertContext,
						DWORD propId,
						CString& str,
						HRESULT * phRes)
{
	BOOL bRes = FALSE;
	DWORD cb = 0;
	BYTE * prop = NULL;
	DWORD cbData = 0;
	void * pData = NULL;

	// compare property value
	if (!CertGetCertificateContextProperty(pCertContext, propId, NULL, &cb))
	{
		goto GetStringProperty_Exit;
	}

	prop = (BYTE *) LocalAlloc(LPTR,cb);
	if (NULL == prop)
	{
		goto GetStringProperty_Exit;
	}

	if (!CertGetCertificateContextProperty(pCertContext, propId, prop, &cb))
	{
		goto GetStringProperty_Exit;
	}

	// decode this instance name property
	if (!CryptDecodeObject(CRYPT_ASN_ENCODING, X509_UNICODE_ANY_STRING,prop, cb, 0, NULL, &cbData))
	{
		goto GetStringProperty_Exit;
	}
	pData = LocalAlloc(LPTR,cbData);
	if (NULL == pData)
	{
		goto GetStringProperty_Exit;
	}

	if (!CryptDecodeObject(CRYPT_ASN_ENCODING, X509_UNICODE_ANY_STRING,prop, cb, 0, pData, &cbData))
	{
		goto GetStringProperty_Exit;
	}
	else
	{
		CERT_NAME_VALUE * pName = (CERT_NAME_VALUE *)pData;
		DWORD cch = pName->Value.cbData/sizeof(TCHAR);
		void * p = str.GetBuffer(cch);
		memcpy(p, pName->Value.pbData, pName->Value.cbData);
		str.ReleaseBuffer(cch);
		bRes = TRUE;
	}

GetStringProperty_Exit:
	if (!bRes)
	{
		*phRes = HRESULT_FROM_WIN32(GetLastError());
	}
	if (prop)
	{
		LocalFree(prop);prop=NULL;
	}
	if (pData)
	{
		LocalFree(pData);pData=NULL;
	}
	return bRes;
}

BOOL
GetBlobProperty(PCCERT_CONTEXT pCertContext,
					 DWORD propId,
					 CCryptBlob& blob,
					 HRESULT * phRes)
{
	BOOL bRes = FALSE;
	DWORD cb;
	// compare property value
	if (	CertGetCertificateContextProperty(pCertContext, propId, NULL, &cb)
		&& blob.Resize(cb)
		&& CertGetCertificateContextProperty(pCertContext, propId, blob.GetData(), &cb)
		)
	{
		bRes = TRUE;
	}
	if (!bRes)
		*phRes = HRESULT_FROM_WIN32(GetLastError());
	return bRes;
}

PCCERT_CONTEXT
GetPendingDummyCert(const CString& inst_name, 
						  IEnroll * pEnroll, 
						  HRESULT * phRes)
{
	PCCERT_CONTEXT pRes = NULL;
	HCERTSTORE hStore = OpenRequestStore(pEnroll, phRes);
	if (hStore != NULL)
	{
		DWORD dwPropId = CERTWIZ_INSTANCE_NAME_PROP_ID;
		PCCERT_CONTEXT pDummyCert = NULL;
		while (NULL != (pDummyCert = CertFindCertificateInStore(hStore, 
													X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
													0, CERT_FIND_PROPERTY, 
													(LPVOID)&dwPropId, pDummyCert)))
		{
			CString str;
			if (GetStringProperty(pDummyCert, dwPropId, str, phRes))
			{
				if (str.CompareNoCase(inst_name) == 0)
				{
					pRes = pDummyCert;
					break;
				}
			}
		}
		CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
	}
	return pRes;
}

PCCERT_CONTEXT
GetReqCertByKey(IEnroll * pEnroll, CERT_PUBLIC_KEY_INFO * pKeyInfo, HRESULT * phResult)
{
	PCCERT_CONTEXT pRes = NULL;
	HCERTSTORE hStore = OpenRequestStore(pEnroll, phResult);
	if (hStore != NULL)
	{
		if (NULL != (pRes = CertFindCertificateInStore(hStore, 
				X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 
				0, CERT_FIND_PUBLIC_KEY, (LPVOID)pKeyInfo, NULL)))
		{
			*phResult = S_OK;
		}
		VERIFY(CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG));
	}
	return pRes;
}

#define CERT_QUERY_CONTENT_FLAGS\
								CERT_QUERY_CONTENT_FLAG_CERT\
								|CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED\
								|CERT_QUERY_CONTENT_FLAG_SERIALIZED_STORE\
								|CERT_QUERY_CONTENT_FLAG_PKCS7_UNSIGNED

PCCERT_CONTEXT
GetCertContextFromPKCS7File(const CString& resp_file_name, 
									CERT_PUBLIC_KEY_INFO * pKeyInfo,
									HRESULT * phResult)
{
	ASSERT(phResult != NULL);
	PCCERT_CONTEXT pRes = NULL;
	HANDLE hFile;

	if (INVALID_HANDLE_VALUE != (hFile = CreateFile(resp_file_name,
						GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 
						FILE_ATTRIBUTE_NORMAL, NULL)))
	{
		// find the length of the buffer
		DWORD cbData = GetFileSize(hFile, NULL);
		BYTE * pbData = NULL;
		// alloc temp buffer
		if ((pbData = (BYTE *) LocalAlloc(LPTR,cbData)) != NULL) 
		{
			DWORD cb = 0;
			if (ReadFile(hFile, pbData, cbData, &cb, NULL))
			{
				ASSERT(cb == cbData);
				pRes = GetCertContextFromPKCS7(pbData, cb, pKeyInfo, phResult);
			}
			else
				*phResult = HRESULT_FROM_WIN32(GetLastError());
		}
		CloseHandle(hFile);

		if (pbData)
		{
			LocalFree(pbData);pbData=NULL;
		}
	}
	else
		*phResult = HRESULT_FROM_WIN32(GetLastError());
	return pRes;
}

PCCERT_CONTEXT
GetCertContextFromPKCS7(const BYTE * pbData,
								DWORD cbData,
								CERT_PUBLIC_KEY_INFO * pKeyInfo,
								HRESULT * phResult)
{
	ASSERT(phResult != NULL);
	PCCERT_CONTEXT pRes = NULL;
	CRYPT_DATA_BLOB blob;
	memset(&blob, 0, sizeof(CRYPT_DATA_BLOB));
	blob.cbData = cbData;
	blob.pbData = (BYTE *)pbData;

   HCERTSTORE hStoreMsg = NULL;

	if(CryptQueryObject(CERT_QUERY_OBJECT_BLOB, 
            &blob,
            (CERT_QUERY_CONTENT_FLAG_CERT |
            CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED |
            CERT_QUERY_CONTENT_FLAG_SERIALIZED_STORE |
            CERT_QUERY_CONTENT_FLAG_PKCS7_UNSIGNED) ,
            CERT_QUERY_FORMAT_FLAG_ALL,
            0, 
            NULL, 
            NULL, 
            NULL, 
            &hStoreMsg, 
            NULL, 
            NULL))
	{
		if (pKeyInfo != NULL)
			pRes = CertFindCertificateInStore(hStoreMsg, 
                        X509_ASN_ENCODING,
								0, 
                        CERT_FIND_PUBLIC_KEY, 
                        pKeyInfo, 
                        NULL);
		else
			pRes = CertFindCertificateInStore(hStoreMsg, 
                        X509_ASN_ENCODING,
								0, 
                        CERT_FIND_ANY, 
                        NULL, 
                        NULL);
		if (pRes == NULL)
			*phResult = HRESULT_FROM_WIN32(GetLastError());
		CertCloseStore(hStoreMsg, CERT_CLOSE_STORE_CHECK_FLAG);
	}
	else
		*phResult = HRESULT_FROM_WIN32(GetLastError());
	return pRes;
}

BOOL 
FormatDateString(CString& str, FILETIME ft, BOOL fIncludeTime, BOOL fLongFormat)
{
	int cch;
   int cch2;
   LPWSTR psz;
   SYSTEMTIME st;
   FILETIME localTime;
    
   if (!FileTimeToLocalFileTime(&ft, &localTime))
   {
		return FALSE;
   }
    
   if (!FileTimeToSystemTime(&localTime, &st)) 
   {
		//
      // if the conversion to local time failed, then just use the original time
      //
      if (!FileTimeToSystemTime(&ft, &st)) 
      {
			return FALSE;
      }
   }

   cch = (GetTimeFormat(LOCALE_SYSTEM_DEFAULT, 0, &st, NULL, NULL, 0) +
          GetDateFormat(LOCALE_SYSTEM_DEFAULT, fLongFormat ? DATE_LONGDATE : 0, &st, NULL, NULL, 0) + 5);

   if (NULL == (psz = str.GetBuffer((cch+5) * sizeof(WCHAR))))
   {
		return FALSE;
   }
    
   cch2 = GetDateFormat(LOCALE_SYSTEM_DEFAULT, fLongFormat ? DATE_LONGDATE : 0, &st, NULL, psz, cch);

   if (fIncludeTime)
   {
		psz[cch2-1] = ' ';
      GetTimeFormat(LOCALE_SYSTEM_DEFAULT, TIME_NOSECONDS, &st, NULL, &psz[cch2], cch-cch2);
   }
	str.ReleaseBuffer();  
   return TRUE;
}

BOOL MyGetOIDInfo(LPWSTR string, DWORD stringSize, LPSTR pszObjId)
{   
    PCCRYPT_OID_INFO pOIDInfo;
            
    if (NULL != (pOIDInfo = CryptFindOIDInfo(CRYPT_OID_INFO_OID_KEY, pszObjId, 0)))
    {
        if ((DWORD)wcslen(pOIDInfo->pwszName)+1 <= stringSize)
        {
            if (FAILED(StringCbCopy(string,stringSize * sizeof(WCHAR),pOIDInfo->pwszName)))
			{
				return FALSE;
			}
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
        return (MultiByteToWideChar(CP_ACP, 0, pszObjId, -1, string, stringSize) != 0);
    }
    return TRUE;
}

BOOL
GetKeyUsageProperty(PCCERT_CONTEXT pCertContext, 
						  CERT_ENHKEY_USAGE ** pKeyUsage, 
						  BOOL fPropertiesOnly, 
						  HRESULT * phRes)
{
	DWORD cb = 0;
	BOOL bRes = FALSE;
   if (!CertGetEnhancedKeyUsage(pCertContext,
                                fPropertiesOnly ? CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG : 0,
                                NULL,
                                &cb))
   {
		*phRes = HRESULT_FROM_WIN32(GetLastError());
		goto ErrExit;
   }
   if (NULL == (*pKeyUsage = (CERT_ENHKEY_USAGE *)malloc(cb)))
   {
		*phRes = E_OUTOFMEMORY;
		goto ErrExit;
   }
   if (!CertGetEnhancedKeyUsage (pCertContext,
                                 fPropertiesOnly ? CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG : 0,
                                 *pKeyUsage,
                                 &cb))
   {
		free(*pKeyUsage);
		*phRes = HRESULT_FROM_WIN32(GetLastError());
		goto ErrExit;
   }
	*phRes = S_OK;
	bRes = TRUE;
ErrExit:
	return bRes;
}

BOOL
GetFriendlyName(PCCERT_CONTEXT pCertContext,
					 CString& name,
					 HRESULT * phRes)
{
	BOOL bRes = FALSE;
	DWORD cb;
	BYTE * pName = NULL;

	if (	CertGetCertificateContextProperty(pCertContext, CERT_FRIENDLY_NAME_PROP_ID, NULL, &cb)
		&&	NULL != (pName = (BYTE *)name.GetBuffer((cb + 1)/sizeof(TCHAR)))
		&&	CertGetCertificateContextProperty(pCertContext, CERT_FRIENDLY_NAME_PROP_ID, pName, &cb)
		)
	{
		pName[cb] = 0;
		bRes = TRUE;
	}
	else
	{
		*phRes = HRESULT_FROM_WIN32(GetLastError());
	}
	if (pName != NULL && name.IsEmpty())
	{
		name.ReleaseBuffer();
	}
	return bRes;
}

BOOL
GetNameString(PCCERT_CONTEXT pCertContext,
				  DWORD type,
				  DWORD flag,
				  CString& name,
				  HRESULT * phRes)
{
	BOOL bRes = FALSE;
	LPTSTR pName;
	DWORD cchName = CertGetNameString(pCertContext, type, flag, NULL, NULL, 0);
	if (cchName > 1 && (NULL != (pName = name.GetBuffer(cchName))))
	{
		bRes = (1 != CertGetNameString(pCertContext, type, flag, NULL, pName, cchName));
		name.ReleaseBuffer();
	}
	else
	{
		*phRes = HRESULT_FROM_WIN32(GetLastError());
	}
	return bRes;
}

// Return:
// 0 = The CertContext does not have a EnhancedKeyUsage (EKU) field
// 1 = The CertContext has EnhancedKeyUsage (EKU) and contains the uses we want.
//     This is also returned when The UsageIdentifier that depics "all uses" is true
// 2 = The CertContext has EnhancedKeyUsage (EKU) but does NOT contain the uses we want.
//     This is also returned when The UsageIdentifier that depics "no uses" is true
INT
ContainsKeyUsageProperty(PCCERT_CONTEXT pCertContext, 
						 CArray<LPCSTR, LPCSTR>& uses,
						 HRESULT * phRes
						 )
{
    // Default it with "No EnhancedKeyUsage (EKU) Exist"
    INT iReturn = 0;
	CERT_ENHKEY_USAGE * pKeyUsage = NULL;
	if (	uses.GetSize() > 0
		&&	GetKeyUsageProperty(pCertContext, &pKeyUsage, FALSE, phRes)
		)
	{
		if (pKeyUsage->cUsageIdentifier == 0)
		{
            /*
            But in MSDN article about SR
            (see: ms-help://MS.MSDNQTR.2002APR.1033/security/security/certgetenhancedkeyusage.htm)

            In Windows Me and Windows 2000 and later, if the cUsageIdentifier member is zero (0), 
            the certificate might be valid for ALL uses or the certificate might have no valid uses. 
            The return from a call to GetLastError can be used to determine whether the certificate 
            is good for all uses or for none. If GetLastError returns CRYPT_E_NOT_FOUND, the certificate 
            is good for all uses. If it returns zero (0), the certificate has no valid uses.
            */

            // Default it with "has EnhancedKeyUsage (EKU), but doesn't have what we want"
            iReturn = 2;
            if (GetLastError() == CRYPT_E_NOT_FOUND)
            {
                // All uses!
                iReturn = 1;
            }
		}
		else
		{
            // Default it with "has EnhancedKeyUsage (EKU), but doesn't have what we want"
            iReturn = 2;

			for (DWORD i = 0; i < pKeyUsage->cUsageIdentifier; i++)
			{
				// Our friends from CAPI made this property ASCII even for 
				// UNICODE program
				for (int n = 0; n < uses.GetSize(); n++)
				{
					if (strstr(pKeyUsage->rgpszUsageIdentifier[i], uses[n]) != NULL)
					{
                        iReturn = 1;
						break;
					}
				}
			}
		}
		free(pKeyUsage);
	}
	return iReturn;
}

BOOL 
FormatEnhancedKeyUsageString(CString& str, 
									  PCCERT_CONTEXT pCertContext, 
									  BOOL fPropertiesOnly, 
									  BOOL fMultiline,
									  HRESULT * phRes)
{
	CERT_ENHKEY_USAGE * pKeyUsage = NULL;
	WCHAR szText[CRYPTUI_MAX_STRING_SIZE];
	BOOL bRes = FALSE;

	if (GetKeyUsageProperty(pCertContext, &pKeyUsage, fPropertiesOnly, phRes))
	{
		// loop for each usage and add it to the display string
		for (DWORD i = 0; i < pKeyUsage->cUsageIdentifier; i++)
		{
			if (!(bRes = MyGetOIDInfo(szText, ARRAYSIZE(szText), pKeyUsage->rgpszUsageIdentifier[i])))
				break;
			// add delimeter if not first iteration
			if (i != 0)
			{
				str += fMultiline ? L"\n" : L", ";
			}
			// add the enhanced key usage string
			str += szText;
		}
		free (pKeyUsage);
	}
	else
	{
		str.LoadString(IDS_ANY);
		bRes = TRUE;
	}
	return bRes;
}

BOOL
GetServerComment(const CString& machine_name,
					  const CString& server_name,
					  CString& comment,
					  HRESULT * phResult)
{
	ASSERT(!machine_name.IsEmpty());
	ASSERT(!server_name.IsEmpty());
	*phResult = S_OK;
    CComAuthInfo auth(machine_name);
	CMetaKey key(&auth,
            server_name,
				METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE
				);
	if (key.Succeeded())
	{
		return SUCCEEDED(*phResult = key.QueryValue(MD_SERVER_COMMENT, comment));
	}
	else
	{
		*phResult = key.QueryResult();
		return FALSE;
	}
}

/*
		GetInstalledCert

		Function reads cert hash attribute from metabase
		using machine_name and server name as server instance
		description, then looks in MY store for a certificate
		with hash equal found in metabase.
		Return is cert context pointer or NULL, if cert wasn't
		found or certificate store wasn't opened.
		On return HRESULT * is filled by error code.
 */
PCCERT_CONTEXT
GetInstalledCert(const CString& machine_name, 
					  const CString& server_name,
					  IEnroll * pEnroll,
					  HRESULT * phResult)
{
	ASSERT(pEnroll != NULL);
	ASSERT(phResult != NULL);
	ASSERT(!machine_name.IsEmpty());
	ASSERT(!server_name.IsEmpty());
	PCCERT_CONTEXT pCert = NULL;
	*phResult = S_OK;
   CComAuthInfo auth(machine_name);
	CMetaKey key(&auth, server_name,
				METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE
				);
	if (key.Succeeded())
	{
		CString store_name;
		CBlob hash;
		if (	SUCCEEDED(*phResult = key.QueryValue(MD_SSL_CERT_STORE_NAME, store_name))
			&&	SUCCEEDED(*phResult = key.QueryValue(MD_SSL_CERT_HASH, hash))
			)
		{
			// Open MY store. We assume that store type and flags
			// cannot be changed between installation and unistallation
			// of the sertificate.
			HCERTSTORE hStore = OpenMyStore(pEnroll, phResult);
			ASSERT(hStore != NULL);
			if (hStore != NULL)
			{
				// Now we need to find cert by hash
				CRYPT_HASH_BLOB crypt_hash;
                ZeroMemory(&crypt_hash, sizeof(CRYPT_HASH_BLOB));

				crypt_hash.cbData = hash.GetSize();
				crypt_hash.pbData = hash.GetData();
				pCert = CertFindCertificateInStore(hStore, 
												X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 
												0, CERT_FIND_HASH, (LPVOID)&crypt_hash, NULL);
				if (pCert == NULL)
					*phResult = HRESULT_FROM_WIN32(GetLastError());
				VERIFY(CertCloseStore(hStore, 0));
			}
		}
	}
	else
    {
		*phResult = key.QueryResult();
    }
	return pCert;
}


/*
		GetInstalledCert

		Function reads cert hash attribute from metabase
		using machine_name and server name as server instance
		description, then looks in MY store for a certificate
		with hash equal found in metabase.
		Return is cert context pointer or NULL, if cert wasn't
		found or certificate store wasn't opened.
		On return HRESULT * is filled by error code.
 */
CRYPT_HASH_BLOB *
GetInstalledCertHash(const CString& machine_name, 
					  const CString& server_name,
					  IEnroll * pEnroll,
					  HRESULT * phResult)
{
	ASSERT(pEnroll != NULL);
	ASSERT(phResult != NULL);
	ASSERT(!machine_name.IsEmpty());
	ASSERT(!server_name.IsEmpty());
    CRYPT_HASH_BLOB * pHashBlob = NULL;
	*phResult = S_OK;
    CComAuthInfo auth(machine_name);
	CMetaKey key(&auth, server_name,
				METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE
				);
	if (key.Succeeded())
	{
		CString store_name;
		CBlob hash;
		if (	SUCCEEDED(*phResult = key.QueryValue(MD_SSL_CERT_STORE_NAME, store_name))
			&&	SUCCEEDED(*phResult = key.QueryValue(MD_SSL_CERT_HASH, hash))
			)
		{
            pHashBlob = new CRYPT_HASH_BLOB;
            if (pHashBlob)
            {
                pHashBlob->cbData = hash.GetSize();
                pHashBlob->pbData = (BYTE *) ::CoTaskMemAlloc(pHashBlob->cbData);
                if (pHashBlob->pbData)
                {
                    memcpy(pHashBlob->pbData,hash.GetData(),pHashBlob->cbData);
                }
            }
		}
	}
	else
    {
		*phResult = key.QueryResult();
    }
	return pHashBlob;
}


/*
	InstallHashToMetabase

	Function writes hash array to metabase. After that IIS 
	could use certificate with that hash from MY store.
	Function expects server_name in format lm\w3svc\<number>,
	i.e. from root node down to virtual server

 */
BOOL
InstallHashToMetabase(CRYPT_HASH_BLOB * pHash,
					  const CString& machine_name, 
					  const CString& server_name,
					  HRESULT * phResult)
{
	BOOL bRes = FALSE;
    CComAuthInfo auth(machine_name);
	CMetaKey key(&auth, server_name,
						METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE
						);
	if (key.Succeeded())
	{
		CBlob blob;
		blob.SetValue(pHash->cbData, pHash->pbData, TRUE);
		bRes = SUCCEEDED(*phResult = key.SetValue(MD_SSL_CERT_HASH, blob)) 
			&& SUCCEEDED(*phResult = key.SetValue(MD_SSL_CERT_STORE_NAME, CString(L"MY")));
	}
	else
	{
		TRACE(_T("Failed to open metabase key. Error 0x%x\n"), key.QueryResult());
		*phResult = key.QueryResult();
	}
	return bRes;
}

/*
	InstallCertByHash

	Function looks in MY store for certificate which has hash
	equal to pHash parameter. If cert is found, it is installed
	to metabase.
	This function is used after xenroll accept() method, which
	puts certificate to store

 */
BOOL 
InstallCertByHash(CRYPT_HASH_BLOB * pHash,
					  const CString& machine_name, 
					  const CString& server_name,
					  IEnroll * pEnroll,
					  HRESULT * phResult)

{
	BOOL bRes = FALSE;
	// we are looking to MY store only
	HCERTSTORE hStore = OpenMyStore(pEnroll, phResult);
	if (hStore != NULL)
	{
		PCCERT_CONTEXT pCert = CertFindCertificateInStore(hStore, 
												X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 
												0, CERT_FIND_HASH, (LPVOID)pHash, NULL);
		// now install cert info to IIS MetaBase
		if (pCert != NULL)
		{
			bRes = InstallHashToMetabase(pHash, 
							machine_name, server_name, phResult);
			CertFreeCertificateContext(pCert);
		}
		else
		{
			TRACE(_T("FAILED: certificate installation, error 0x%x\n"), GetLastError());
			// We definitely need to store the hash of the cert, so error out
			*phResult = HRESULT_FROM_WIN32(GetLastError());
		}
		VERIFY(CertCloseStore(hStore, 0));
	}
	return bRes;
}

HRESULT
CreateRequest_Base64(const BSTR bstr_dn, 
                     IEnroll * pEnroll, 
                     BSTR csp_name,
                     DWORD csp_type,
                     BSTR * pOut)
{
	ASSERT(pOut != NULL);
	ASSERT(bstr_dn != NULL);
	HRESULT hRes = S_OK;
	CString strUsage(szOID_PKIX_KP_SERVER_AUTH);
	CRYPT_DATA_BLOB request = {0, NULL};
    pEnroll->put_ProviderType(csp_type);
    pEnroll->put_ProviderNameWStr(csp_name);
    if (csp_type == PROV_DH_SCHANNEL)
    {
       pEnroll->put_KeySpec(AT_SIGNATURE);
    }
    else if (csp_type == PROV_RSA_SCHANNEL)
    {
       pEnroll->put_KeySpec(AT_KEYEXCHANGE);
    }
    
	if (SUCCEEDED(hRes = pEnroll->createPKCS10WStr(
									bstr_dn, 
									(LPTSTR)(LPCTSTR)strUsage, 
									&request)))
	{
		WCHAR * wszRequestB64 = NULL;
		DWORD cch = 0;
		DWORD err = ERROR_SUCCESS;
		// BASE64 encode pkcs 10
		if ((err = Base64EncodeW(request.pbData, request.cbData, NULL, &cch)) == ERROR_SUCCESS)
		{
			wszRequestB64 = (WCHAR *) LocalAlloc(LPTR,cch * sizeof(WCHAR));
		    if (NULL != wszRequestB64)
			{
				if ((err = Base64EncodeW(request.pbData, request.cbData, wszRequestB64, &cch)) == ERROR_SUCCESS)
				{
					if ((*pOut = SysAllocStringLen(wszRequestB64, cch)) == NULL ) 
					{
						hRes = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
					}
				}
				else
				{
					hRes = HRESULT_FROM_WIN32(err);
				}

				if (request.pbData != NULL)
				{
					CoTaskMemFree(request.pbData);
				}

				if (wszRequestB64)
				{
					LocalFree(wszRequestB64);wszRequestB64=NULL;
				}
			}
		}
	}

	return hRes;	
}

BOOL
AttachFriendlyName(PCCERT_CONTEXT pContext, 
						 const CString& name,
						 HRESULT * phRes)
{
	BOOL bRes = TRUE;
	CRYPT_DATA_BLOB blob_name;

    // Check if friendlyname is empty
    // if it is then don't try to set the friendly name
    if (!name.IsEmpty())
    {
	    blob_name.pbData = (LPBYTE)(LPCTSTR)name;
	    blob_name.cbData = (name.GetLength() + 1) * sizeof(WCHAR);
	    if (!(bRes = CertSetCertificateContextProperty(pContext,
						    CERT_FRIENDLY_NAME_PROP_ID, 0, &blob_name)))
	    {
		    ASSERT(phRes != NULL);
		    *phRes = HRESULT_FROM_WIN32(GetLastError());
	    }
    }

	return bRes;
}

BOOL GetHashProperty(PCCERT_CONTEXT pCertContext, 
							CCryptBlob& blob, 
							HRESULT * phRes)
{
	DWORD cb;
	if (CertGetCertificateContextProperty(pCertContext, CERT_SHA1_HASH_PROP_ID, NULL, &cb))
	{
		if (blob.Resize(cb))
		{
			if (CertGetCertificateContextProperty(pCertContext, 
								CERT_SHA1_HASH_PROP_ID, blob.GetData(), &cb))
				return TRUE;
		}
	}
	*phRes = HRESULT_FROM_WIN32(GetLastError());
	return FALSE;
}

BOOL 
EncodeString(CString& str, 
				 CCryptBlob& blob, 
				 HRESULT * phRes)
{
	BOOL bRes = FALSE;
	DWORD cb;
	CERT_NAME_VALUE name_value;
	name_value.dwValueType = CERT_RDN_BMP_STRING;
	name_value.Value.cbData = 0;
	name_value.Value.pbData = (LPBYTE)(LPCTSTR)str;
	if (	CryptEncodeObject(CRYPT_ASN_ENCODING, X509_UNICODE_ANY_STRING,
										&name_value, NULL, &cb) 
		&&	blob.Resize(cb)
		&&	CryptEncodeObject(CRYPT_ASN_ENCODING, X509_UNICODE_ANY_STRING,
										&name_value, blob.GetData(), &cb) 
		)
	{
		bRes = TRUE;
	}
	else
		*phRes = HRESULT_FROM_WIN32(GetLastError());
	return bRes;
}

#define CERTWIZ_RENEWAL_DATA	((LPCSTR)1000)

BOOL 
EncodeBlob(CCryptBlob& in, 
			  CCryptBlob& out, 
			  HRESULT * phRes)
{
	BOOL bRes = FALSE;
	DWORD cb;
	if (	CryptEncodeObject(CRYPT_ASN_ENCODING, CERTWIZ_RENEWAL_DATA, in, NULL, &cb) 
		&&	out.Resize(cb)
		&&	CryptEncodeObject(CRYPT_ASN_ENCODING, CERTWIZ_RENEWAL_DATA, in, out.GetData(), &cb) 
		)
	{
		bRes = TRUE;
	}
	else
		*phRes = HRESULT_FROM_WIN32(GetLastError());
	return bRes;
}

BOOL
DecodeBlob(CCryptBlob& in,
			  CCryptBlob& out,
			  HRESULT * phRes)
{
	BOOL bRes = FALSE;
	DWORD cb;
	if (	CryptDecodeObject(CRYPT_ASN_ENCODING, CERTWIZ_RENEWAL_DATA, 
						in.GetData(),
						in.GetSize(), 
						0, 
						NULL, &cb) 
		&&	out.Resize(cb)
		&&	CryptDecodeObject(CRYPT_ASN_ENCODING, CERTWIZ_RENEWAL_DATA, 
						in.GetData(),
						in.GetSize(), 
						0, 
						out.GetData(), 
						&cb) 
		)
	{
		bRes = TRUE;
	}
	else
		*phRes = HRESULT_FROM_WIN32(GetLastError());
	return bRes;
}

BOOL 
EncodeInteger(int number, 
				 CCryptBlob& blob, 
				 HRESULT * phRes)
{
	BOOL bRes = FALSE;
	DWORD cb;
	if (	CryptEncodeObject(CRYPT_ASN_ENCODING, X509_INTEGER,
										&number, NULL, &cb) 
		&&	blob.Resize(cb)
		&&	CryptEncodeObject(CRYPT_ASN_ENCODING, X509_INTEGER,
										&number, blob.GetData(), &cb) 
		)
	{
		bRes = TRUE;
	}
	else
		*phRes = HRESULT_FROM_WIN32(GetLastError());
	return bRes;
}

const WCHAR     RgwchHex[] = {'0', '1', '2', '3', '4', '5', '6', '7',
                              '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};

static BOOL 
FormatMemBufToString(CString& str, LPBYTE pbData, DWORD cbData)
{   
    DWORD   i = 0;
    LPBYTE  pb;
    DWORD   numCharsInserted = 0;
	 LPTSTR pString;
    
    //
    // calculate the size needed
    //
    pb = pbData;
    while (pb <= &(pbData[cbData-1]))
    {   
        if (numCharsInserted == 4)
        {
            i += sizeof(WCHAR);
            numCharsInserted = 0;
        }
        else
        {
            i += 2 * sizeof(WCHAR);
            pb++;
            numCharsInserted += 2;  
        }
    }

    if (NULL == (pString = str.GetBuffer(i)))
    {
        return FALSE;
    }

    //
    // copy to the buffer
    //
    i = 0;
    numCharsInserted = 0;
    pb = pbData;
    while (pb <= &(pbData[cbData-1]))
    {   
        if (numCharsInserted == 4)
        {
            pString[i++] = L' ';
            numCharsInserted = 0;
        }
        else
        {
            pString[i++] = RgwchHex[(*pb & 0xf0) >> 4];
            pString[i++] = RgwchHex[*pb & 0x0f];
            pb++;
            numCharsInserted += 2;  
        }
    }
    pString[i] = 0;
	 str.ReleaseBuffer();
    return TRUE;
}


void FormatRdnAttr(CString& str, DWORD dwValueType, CRYPT_DATA_BLOB& blob, BOOL fAppend)
{
	if (	CERT_RDN_ENCODED_BLOB == dwValueType 
		||	CERT_RDN_OCTET_STRING == dwValueType
		)
	{
		// translate the buffer to a text string
      FormatMemBufToString(str, blob.pbData, blob.cbData);
   }
	else 
   {
        // buffer is already a string so just copy/append to it
        if (fAppend)
        {
            str += (LPTSTR)blob.pbData;
        }
        else
        {
            // don't concatenate these entries...
            str = (LPTSTR)blob.pbData;
        }
   }
}

BOOL
CreateDirectoryFromPath(LPCTSTR szPath, LPSECURITY_ATTRIBUTES lpSA)
/*++

Routine Description:

    Creates the directory specified in szPath and any other "higher"
        directories in the specified path that don't exist.

Arguments:

    IN  LPCTSTR szPath
        directory path to create (assumed to be a DOS path, not a UNC)

    IN  LPSECURITY_ATTRIBUTES   lpSA
        pointer to security attributes argument used by CreateDirectory


Return Value:

    TRUE    if directory(ies) created
    FALSE   if error (GetLastError to find out why)

--*/
{
	LPTSTR pLeftHalf, pNext;
	CString RightHalf;
	// 1. We are supporting only absolute paths. Caller should decide which
	//		root to use and build the path
	if (PathIsRelative(szPath))
	{
		ASSERT(FALSE);
		return FALSE;
	}

	pLeftHalf = (LPTSTR)szPath;
	pNext = PathSkipRoot(pLeftHalf);

	do {
		// copy the chunk between pLeftHalf and pNext to the
		// local buffer
		while (pLeftHalf < pNext)
			RightHalf += *pLeftHalf++;
		// check if new path exists
		int index = RightHalf.GetLength() - 1;
		BOOL bBackslash = FALSE, bContinue = FALSE;
		if (bBackslash = (RightHalf[index] == L'\\'))
		{
			RightHalf.SetAt(index, 0);
		}
		bContinue = PathIsUNCServerShare(RightHalf);
		if (bBackslash)
			RightHalf.SetAt(index, L'\\');
		if (bContinue || PathIsDirectory(RightHalf))
			continue;
		else if (PathFileExists(RightHalf))
		{
			// we cannot create this directory 
			// because file with this name already exists
			SetLastError(ERROR_ALREADY_EXISTS);
			return FALSE;
		}
		else
		{
			// no file no directory, create
			if (!CreateDirectory(RightHalf, lpSA))
				return FALSE;
		}
	}
   while (NULL != (pNext = PathFindNextComponent(pLeftHalf)));
	return TRUE;
}

BOOL
CompactPathToWidth(CWnd * pControl, CString& strPath)
{
	BOOL bRes;
	CRect rc;
	CFont * pFont = pControl->GetFont(), * pFontTmp;
	CDC * pdc = pControl->GetDC(), dc;
	LPTSTR pPath = strPath.GetBuffer(MAX_PATH);

	dc.CreateCompatibleDC(pdc);
	pFontTmp = dc.SelectObject(pFont);
	pControl->GetClientRect(&rc);
	
	bRes = PathCompactPath(dc.GetSafeHdc(), pPath, rc.Width());
	
	dc.SelectObject(pFontTmp);
	pControl->ReleaseDC(pdc);
	strPath.ReleaseBuffer();

	return bRes;
}

BOOL
GetKeySizeLimits(IEnroll * pEnroll, 
					  DWORD * min, DWORD * max, DWORD * def, 
					  BOOL bGSC,
					  HRESULT * phRes)
{
   HCRYPTPROV hProv = NULL;
	long dwProviderType;
   DWORD dwFlags, cbData;
	BSTR bstrProviderName;
   PROV_ENUMALGS_EX paramData;
	BOOL bRes = FALSE;
	
	VERIFY(SUCCEEDED(pEnroll->get_ProviderNameWStr(&bstrProviderName)));
	VERIFY(SUCCEEDED(pEnroll->get_ProviderType(&dwProviderType)));

	if (!CryptAcquireContext(
                &hProv,
                NULL,
                bstrProviderName,
                dwProviderType,
                CRYPT_VERIFYCONTEXT))
   {
		*phRes = GetLastError();
		return FALSE;
   }

   for (int i = 0; ; i++)
   {
		dwFlags = 0 == i ? CRYPT_FIRST : 0;
      cbData = sizeof(paramData);
      if (!CryptGetProvParam(hProv, PP_ENUMALGS_EX, (BYTE*)&paramData, &cbData, dwFlags))
      {
         if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == GetLastError())
         {
				// out of for loop
				*phRes = S_OK;
				bRes = TRUE;
         }
			else
			{
				*phRes = GetLastError();
			}
         break;
      }
      if (ALG_CLASS_KEY_EXCHANGE == GET_ALG_CLASS(paramData.aiAlgid))
      {
			*min = paramData.dwMinLen;
         *max = paramData.dwMaxLen;
			*def = paramData.dwDefaultLen;
			bRes = TRUE;
			*phRes = S_OK;
         break;
      }
   }
	if (NULL != hProv)
   {
		CryptReleaseContext(hProv, 0);
   }
	return bRes;
}

HRESULT ShutdownSSL(CString& machine_name, CString& server_name)
{
    CString str = server_name;
    str += _T("/root");
    CComAuthInfo auth(machine_name);
    CMetaKey key(&auth, str,METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);

    DWORD dwSslAccess;
    if (	key.Succeeded() 
        && SUCCEEDED(key.QueryValue(MD_SSL_ACCESS_PERM, dwSslAccess))
        &&	dwSslAccess > 0
        )
    {
        // bug356587 should remove SslAccessPerm property and not set to 0 when Cert Removed
        key.SetValue(MD_SSL_ACCESS_PERM, 0);
        key.DeleteValue(MD_SSL_ACCESS_PERM);
		//bug:612595 leave binding if removing cert.
		//key.DeleteValue(MD_SECURE_BINDINGS);
    }

    // Now we need to remove SSL setting from any virtual directory below
    CError err;
    CStringListEx strlDataPaths;
    DWORD dwMDIdentifier, dwMDAttributes, dwMDUserType,dwMDDataType;

    VERIFY(CMetaKey::GetMDFieldDef(MD_SSL_ACCESS_PERM, dwMDIdentifier, dwMDAttributes, dwMDUserType,dwMDDataType));

    err = key.GetDataPaths(strlDataPaths,dwMDIdentifier,dwMDDataType);

    if (err.Succeeded() && !strlDataPaths.IsEmpty())
    {
        POSITION pos = strlDataPaths.GetHeadPosition();
        while (pos)
        {
            CString& str2 = strlDataPaths.GetNext(pos);
            if (SUCCEEDED(key.QueryValue(MD_SSL_ACCESS_PERM, dwSslAccess, NULL, str2)) &&	dwSslAccess > 0)
            {
                key.SetValue(MD_SSL_ACCESS_PERM, 0, NULL, str2);
                key.DeleteValue(MD_SSL_ACCESS_PERM, str2);
				//bug:612595 leave binding if removing cert.
                //key.DeleteValue(MD_SECURE_BINDINGS, str2);
            }
        }
    }
    return key.QueryResult();
}


BOOL 
GetServerComment(const CString& machine_name,
                      const CString& user_name,
                      const CString& user_password,
                      CString& MetabaseNode,
                      CString& comment,
                      HRESULT * phResult
                      )
{
	ASSERT(!machine_name.IsEmpty());
	*phResult = S_OK;

    if (user_name.IsEmpty())
    {
        CComAuthInfo auth(machine_name);
        CMetaKey key(&auth,MetabaseNode,METADATA_PERMISSION_READ);
	    if (key.Succeeded())
	    {
		    return SUCCEEDED(*phResult = key.QueryValue(MD_SERVER_COMMENT, comment));
	    }
	    else
	    {
		    *phResult = key.QueryResult();
		    return FALSE;
	    }

    }
    else
    {
        CComAuthInfo auth(machine_name,user_name,user_password);
        CMetaKey key(&auth,MetabaseNode,METADATA_PERMISSION_READ);
	    if (key.Succeeded())
	    {
            return SUCCEEDED(*phResult = key.QueryValue(MD_SERVER_COMMENT, comment));
	    }
	    else
	    {
		    *phResult = key.QueryResult();
		    return FALSE;
	    }
    }
   
}


BOOL IsSiteTypeMetabaseNode(CString & MetabasePath)
{
    BOOL bReturn = FALSE;
    INT iPos1 = 0;
    CString PathCopy = MetabasePath;
    CString PathCopy2;
    TCHAR MyChar;

    // check if ends with a slash...
    // if it does, then cut it off
    if (PathCopy.Right(1) == _T('/'))
    {
        iPos1 = PathCopy.ReverseFind(_T('/'));
        if (iPos1 != -1)
        {
            PathCopy.SetAt(iPos1,_T('0'));
        }
    }

    iPos1 = PathCopy.ReverseFind((TCHAR) _T('/'));
    if (iPos1 == -1)
    {
        goto IsSiteTypeMetabaseNode_Exit;
    }
    PathCopy2 = PathCopy.Right(PathCopy.GetLength() - iPos1);
    PathCopy2.TrimRight();
    for (INT i = 0; i < PathCopy2.GetLength(); i++)
    {
        MyChar = PathCopy2.GetAt(i);
        if (MyChar != _T(' ') && MyChar != _T('/'))
        {
            if (FALSE == ISNUM(MyChar))
            {
                goto IsSiteTypeMetabaseNode_Exit;
            }
        }
    }
    bReturn = TRUE;

IsSiteTypeMetabaseNode_Exit:
    return bReturn;
}

BOOL IsMachineLocal(CString& machine_name,CString& user_name,CString& user_password)
{
    CComAuthInfo auth(machine_name,user_name,user_password);
    return auth.IsLocal();
}

HRESULT EnumSites(CString& machine_name,CString& user_name,CString& user_password,CString strCurrentMetabaseSite, CString strSiteToExclude,CStringListEx * MyStringList)
{
    HRESULT hr = E_FAIL;
    CString str = ReturnGoodMetabaseServerPath(strCurrentMetabaseSite);
    CString strChildPath = _T("");
    CString strServerComment;
    BOOL IsLocalMachine = FALSE;
    CComAuthInfo auth(machine_name,user_name,user_password);
    CMetaKey key(&auth,str,METADATA_PERMISSION_READ);

    // if it's local then make sure not to diplay the current site
    IsLocalMachine = auth.IsLocal();

    hr = key.QueryResult();
    if (key.Succeeded())
    {
        // Do a Get data paths on this key.
        CError err;
        CStringListEx strlDataPaths;
        CBlob hash;
        DWORD dwMDIdentifier, dwMDAttributes, dwMDUserType,dwMDDataType;

        VERIFY(CMetaKey::GetMDFieldDef(MD_SERVER_BINDINGS, dwMDIdentifier, dwMDAttributes, dwMDUserType,dwMDDataType));
        err = key.GetDataPaths(strlDataPaths,dwMDIdentifier,dwMDDataType);
        if (err.Succeeded() && !strlDataPaths.IsEmpty())
        {
            POSITION pos = strlDataPaths.GetHeadPosition();
            while (pos)
            {
                CString& strJustTheEnd = strlDataPaths.GetNext(pos);

                strChildPath = str + strJustTheEnd;
                if (TRUE == IsSiteTypeMetabaseNode(strChildPath))
                {
                    if (TRUE == IsLocalMachine)
                    {
                        // Check if this the site that we want to exclude
                        if (strChildPath.Left(1) == _T("/"))
                        {
                            if (strSiteToExclude.Left(1) != _T("/"))
                                {strSiteToExclude = _T("/") + strSiteToExclude;}
                        }

                        if (strChildPath.Right(1) == _T("/"))
                        {
                            if (strSiteToExclude.Right(1) != _T("/"))
                                {strSiteToExclude = strSiteToExclude + _T("/");}
                        }
                        if (0 != _tcsicmp(strChildPath,strSiteToExclude))
                        {
                            MyStringList->AddTail(strChildPath);
                        }
                    }
                    else
                    {
                        MyStringList->AddTail(strChildPath);
                    }
                }
            }
        }
        hr = key.QueryResult();
    }

    return hr;
}

HRESULT EnumSitesWithCertInstalled(CString& machine_name,CString& user_name,CString& user_password,CString strCurrentMetabaseSite,CString strSiteToExclude,CStringListEx * MyStringList)
{
    HRESULT hr = E_FAIL;
    CString str = ReturnGoodMetabaseServerPath(strCurrentMetabaseSite);
    CString strChildPath = _T("");
    CString strServerComment;
    BOOL IsLocalMachine = FALSE;
    CComAuthInfo auth(machine_name,user_name,user_password);
    CMetaKey key(&auth,str,METADATA_PERMISSION_READ);

    // if it's local then make sure not to diplay the current site
    IsLocalMachine = auth.IsLocal();

    hr = key.QueryResult();
    if (key.Succeeded())
    {
        // Do a Get data paths on this key.
        CError err;
        CStringListEx strlDataPaths;
        CBlob hash;
        DWORD dwMDIdentifier, dwMDAttributes, dwMDUserType,dwMDDataType;

        //MD_SSL_CERT_STORE_NAME
        //MD_SSL_CERT_HASH, hash
        VERIFY(CMetaKey::GetMDFieldDef(MD_SSL_CERT_HASH, dwMDIdentifier, dwMDAttributes, dwMDUserType,dwMDDataType));
        err = key.GetDataPaths(strlDataPaths,dwMDIdentifier,dwMDDataType);
        if (err.Succeeded() && !strlDataPaths.IsEmpty())
        {
            POSITION pos = strlDataPaths.GetHeadPosition();
            while (pos)
            {
                CString& strJustTheEnd = strlDataPaths.GetNext(pos);

                strChildPath = str + strJustTheEnd;

                if (TRUE == IsSiteTypeMetabaseNode(strChildPath))
                {
                    // check if this is a local machine.
                    if (TRUE == IsLocalMachine)
                    {
                        if (strChildPath.Left(1) == _T("/"))
                        {
                            if (strSiteToExclude.Left(1) != _T("/"))
                                {strSiteToExclude = _T("/") + strSiteToExclude;}
                        }

                        if (strChildPath.Right(1) == _T("/"))
                        {
                            if (strSiteToExclude.Right(1) != _T("/"))
                                {strSiteToExclude = strSiteToExclude + _T("/");}
                        }
                        // Check if this the site that we want to exclude
                        if (0 != _tcsicmp(strChildPath,strSiteToExclude))
                        {
                            MyStringList->AddTail(strChildPath);
                        }
                    }
                    else
                    {
                        MyStringList->AddTail(strChildPath);
                    }
                }
            }
        }
        hr = key.QueryResult();
    }

    return hr;
}

BOOL IsWebSiteExistRemote(CString& machine_name,CString& user_name,CString& user_password,CString& site_instance_path,BOOL * bReturnIfCertificateExists)
{
    HRESULT hr = E_FAIL;
    CComAuthInfo auth(machine_name,user_name,user_password);
    CMetaKey key(&auth,site_instance_path,METADATA_PERMISSION_READ);
    *bReturnIfCertificateExists = FALSE;

    hr = key.QueryResult();
    if (key.Succeeded())
    {
        // see if there is a certificate on it!
		CString store_name;
		CBlob hash;
		if (	SUCCEEDED(hr = key.QueryValue(MD_SSL_CERT_STORE_NAME, store_name))
			&&	SUCCEEDED(hr = key.QueryValue(MD_SSL_CERT_HASH, hash))
			)
		{
            *bReturnIfCertificateExists = TRUE;
		}
        return TRUE;
    }
    else
    {
        if (hr == ERROR_ACCESS_DENIED)
        {
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
}


HRESULT IsWebServerExistRemote(CString& machine_name,CString& user_name,CString& user_password,CString strCurrentMetabaseSite)
{
    HRESULT hr = E_FAIL;
    CString str = ReturnGoodMetabaseServerPath(strCurrentMetabaseSite);
    CComAuthInfo auth(machine_name,user_name,user_password);
    CMetaKey key(&auth,str,METADATA_PERMISSION_READ);

    hr = key.QueryResult();
    if (key.Succeeded())
    {
        // i guess so.
    }
    return hr;
}

HRESULT IsCertObjExistRemote(CString& machine_name,CString& user_name,CString& user_password)
{
    BOOL bPleaseDoCoUninit = FALSE;
    HRESULT hResult = E_FAIL;
    IIISCertObj *pTheObject = NULL;

    hResult = CoInitialize(NULL);
    if(FAILED(hResult))
    {
        return hResult;
    }
    bPleaseDoCoUninit = TRUE;

    CComAuthInfo auth(machine_name,user_name,user_password);
    // RPC_C_AUTHN_LEVEL_DEFAULT       0 
    // RPC_C_AUTHN_LEVEL_NONE          1 
    // RPC_C_AUTHN_LEVEL_CONNECT       2 
    // RPC_C_AUTHN_LEVEL_CALL          3 
    // RPC_C_AUTHN_LEVEL_PKT           4 
    // RPC_C_AUTHN_LEVEL_PKT_INTEGRITY 5 
    // RPC_C_AUTHN_LEVEL_PKT_PRIVACY   6 
    COSERVERINFO * pcsiName = auth.CreateServerInfoStruct(RPC_C_AUTHN_LEVEL_PKT_PRIVACY);
    MULTI_QI res[1] = 
    {
        {&__uuidof(IIISCertObj), NULL, 0}
    };

    // this one seems to work with surrogates..
    hResult = CoCreateInstanceEx(CLSID_IISCertObj,NULL,CLSCTX_LOCAL_SERVER,pcsiName,1,res);
	pTheObject = (IIISCertObj *) res[0].pItf;
    if (FAILED(hResult))
    {
        // The object probably doesn't exist on remote system
    }
	else
	{
		// at this point we were able to instantiate the com object on the server (local or remote)
		if (auth.UsesImpersonation())
		{
			HRESULT hr = auth.ApplyProxyBlanket(pTheObject,RPC_C_AUTHN_LEVEL_PKT_PRIVACY);

			// There is a remote IUnknown Interface that lurks behind IUnknown.
			// If that is not set, then the Release call can return access denied.
			IUnknown * pUnk = NULL;
			if(FAILED(pTheObject->QueryInterface(IID_IUnknown, (void **)&pUnk)))
			{
				goto IsCertObjExistRemote_Exit;
			}
			if (FAILED(auth.ApplyProxyBlanket(pUnk,RPC_C_AUTHN_LEVEL_PKT_PRIVACY)))
			{
				goto IsCertObjExistRemote_Exit;
			}
			pUnk->Release();pUnk = NULL;
		}
		auth.FreeServerInfoStruct(pcsiName);
	}	

IsCertObjExistRemote_Exit:
    if (pTheObject)
    {
        pTheObject->Release();
        pTheObject = NULL;
    }
    if (bPleaseDoCoUninit)
    {
        CoUninitialize();
    }
    return hResult;
}


HRESULT IsCertUsedBySSLBelowMe(CString& machine_name, CString& server_name, CStringList& listFillMe)
{
    CString str = server_name;
    str += _T("/root");
    CComAuthInfo auth(machine_name);
    CMetaKey key(&auth, str,METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);

    DWORD dwSslAccess;
    if (	key.Succeeded() 
        && SUCCEEDED(key.QueryValue(MD_SSL_ACCESS_PERM, dwSslAccess))
        &&	dwSslAccess > 0
        )
    {
        // it's used on my node...
        // return back something to say it's used...
        listFillMe.AddTail(str);
    }

    // Now check if it's being used below me...
    CError err;
    CStringListEx strlDataPaths;
    DWORD dwMDIdentifier, dwMDAttributes, dwMDUserType,dwMDDataType;

    VERIFY(CMetaKey::GetMDFieldDef(MD_SSL_ACCESS_PERM, dwMDIdentifier, dwMDAttributes, dwMDUserType,dwMDDataType));

    err = key.GetDataPaths(strlDataPaths,dwMDIdentifier,dwMDDataType);

    if (err.Succeeded() && !strlDataPaths.IsEmpty())
    {
        POSITION pos = strlDataPaths.GetHeadPosition();
        while (pos)
        {
            CString& str2 = strlDataPaths.GetNext(pos);
            if (SUCCEEDED(key.QueryValue(MD_SSL_ACCESS_PERM, dwSslAccess, NULL, str2)) &&	dwSslAccess > 0)
            {
                // yes, it's being used here...
                // return back something to say it's used...
                listFillMe.AddTail(str2);
            }
        }
    }
    return key.QueryResult();
}



HRESULT
HereIsVtArrayGimmieBinary(
    VARIANT * lpVarSrcObject,
    DWORD * cbBinaryBufferSize,
    char **pbBinaryBuffer,
    BOOL bReturnBinaryAsVT_VARIANT
    )
{
    HRESULT hr = S_OK;
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    CHAR HUGEP *pArray = NULL;

    if (NULL == cbBinaryBufferSize || NULL == pbBinaryBuffer)
    {
        hr = E_INVALIDARG;
        goto HereIsVtArrayGimmieBinary_Exit;
    }

    if (bReturnBinaryAsVT_VARIANT)
    {
        hr = VariantChangeType(lpVarSrcObject,lpVarSrcObject,0,VT_ARRAY | VT_VARIANT);
    }
    else
    {
        hr = VariantChangeType(lpVarSrcObject,lpVarSrcObject,0,VT_ARRAY | VT_UI1);
    }

    if (FAILED(hr)) 
    {
        if (hr != E_OUTOFMEMORY) 
        {
            hr = OLE_E_CANTCONVERT;
        }
        goto HereIsVtArrayGimmieBinary_Exit;
    }

    if (bReturnBinaryAsVT_VARIANT)
    {
        if( lpVarSrcObject->vt != (VT_ARRAY | VT_VARIANT)) 
        {
            hr = OLE_E_CANTCONVERT;
            goto HereIsVtArrayGimmieBinary_Exit;
        }
    }
    else
    {
        if( lpVarSrcObject->vt != (VT_ARRAY | VT_UI1)) 
        {
            hr = OLE_E_CANTCONVERT;
            goto HereIsVtArrayGimmieBinary_Exit;
        }
    }

    hr = SafeArrayGetLBound(V_ARRAY(lpVarSrcObject),1,(long FAR *) &dwSLBound );
    if (FAILED(hr))
        {goto HereIsVtArrayGimmieBinary_Exit;}

    hr = SafeArrayGetUBound(V_ARRAY(lpVarSrcObject),1,(long FAR *) &dwSUBound );
    if (FAILED(hr))
        {goto HereIsVtArrayGimmieBinary_Exit;}

    //*pbBinaryBuffer = (LPBYTE) AllocADsMem(dwSUBound - dwSLBound + 1);
    *pbBinaryBuffer = (char *) ::CoTaskMemAlloc(dwSUBound - dwSLBound + 1);
    if (*pbBinaryBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto HereIsVtArrayGimmieBinary_Exit;
    }

    *cbBinaryBufferSize = dwSUBound - dwSLBound + 1;

    hr = SafeArrayAccessData( V_ARRAY(lpVarSrcObject),(void HUGEP * FAR *) &pArray );
    if (FAILED(hr))
        {goto HereIsVtArrayGimmieBinary_Exit;}

    memcpy(*pbBinaryBuffer,pArray,dwSUBound-dwSLBound+1);
    SafeArrayUnaccessData( V_ARRAY(lpVarSrcObject) );

HereIsVtArrayGimmieBinary_Exit:
    return hr;
}


CERT_CONTEXT * GetInstalledCertFromHash(HRESULT * phResult,DWORD cbHashBlob, char * pHashBlob)
{
    ATLASSERT(phResult != NULL);
    CERT_CONTEXT * pCert = NULL;
    *phResult = S_OK;
    CString store_name = _T("MY");

    HCERTSTORE hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM,PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,NULL,CERT_SYSTEM_STORE_LOCAL_MACHINE,store_name);
    ASSERT(hStore != NULL);
    if (hStore != NULL)
    {
        // Now we need to find cert by hash
        CRYPT_HASH_BLOB crypt_hash;
        ZeroMemory(&crypt_hash, sizeof(CRYPT_HASH_BLOB));

        crypt_hash.cbData = cbHashBlob;
        crypt_hash.pbData = (BYTE *) pHashBlob;
        pCert = (CERT_CONTEXT *)CertFindCertificateInStore(hStore,X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,0,CERT_FIND_HASH,(LPVOID)&crypt_hash,NULL);
        if (pCert == NULL)
        {
            *phResult = HRESULT_FROM_WIN32(GetLastError());
        }
        VERIFY(CertCloseStore(hStore, 0));
    }
    else
    {
        *phResult = HRESULT_FROM_WIN32(GetLastError());
    }

    return pCert;
}


BOOL ViewCertificateDialog(CRYPT_HASH_BLOB* pcrypt_hash, HWND hWnd)
{
    BOOL bReturn = FALSE;
    HCERTSTORE hStore = NULL;
    PCCERT_CONTEXT pCert = NULL;
	CString store_name = _T("MY");


	hStore = CertOpenStore(
            CERT_STORE_PROV_SYSTEM,
            PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
           	NULL,
            CERT_SYSTEM_STORE_LOCAL_MACHINE,
            store_name
            );
    if (hStore != NULL)
    {
		// Now we need to find cert by hash
		//CRYPT_HASH_BLOB crypt_hash;
		//crypt_hash.cbData = hash.GetSize();
		//crypt_hash.pbData = hash.GetData();
		pCert = CertFindCertificateInStore(hStore, 
			X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 
			0, CERT_FIND_HASH, (LPVOID)pcrypt_hash, NULL);
    }

	if (pCert)
	{
		BOOL fPropertiesChanged;
		CRYPTUI_VIEWCERTIFICATE_STRUCT vcs;
		HCERTSTORE hCertStore = ::CertDuplicateStore(hStore);
		::ZeroMemory (&vcs, sizeof (vcs));
		vcs.dwSize = sizeof (vcs);
        vcs.hwndParent = hWnd;
		vcs.dwFlags = 0;
		vcs.cStores = 1;
		vcs.rghStores = &hCertStore;
		vcs.pCertContext = pCert;
		::CryptUIDlgViewCertificate(&vcs, &fPropertiesChanged);
		::CertCloseStore (hCertStore, 0);
        bReturn = TRUE;
	}
    else
    {
        // it failed
    }
    if (pCert != NULL)
        ::CertFreeCertificateContext(pCert);
    if (hStore != NULL)
        ::CertCloseStore(hStore, 0);

    return bReturn;
}

/*

  -----Original Message-----
From: 	Helle Vu (SPECTOR)  
Sent:	Friday, April 27, 2001 6:02 PM
To:	Aaron Lee; Trevor Freeman
Cc:	Sergei Antonov
Subject:	RE: bug 31010

Perfect timing, I was just about to send you an update on this:

I talked to Trevor about this, and he suggested the best thing to do for IIS would be the following (Trevor, please double-check I got this right):
If there is an EKU, and it has serverauth, display it in the list to pick web server certs from
If no EKU, look at basic constraints:
    * If we do not have basic constraints, do display it in the list to pick web server certs from
    * If we do have basic constraints with Subject Type =CA, don't display it in the list to pick web server certs from (this will filter out CA certs)
    * If we do have basic constraints with SubectType !=CA, do display it in the list to pick web server certs from 
*/

/*
===== Opened by kshenoy on 11/13/2000 02:26PM =====
Add Existing certificate option in "Web Server Certificate Request wizard"  should not list CA certificates in the filter
but only End entity certificates with "Server Authentication" EKU

Since CA certificates by default have all the EKUs the filter will list CA certificates apart from 
end entity certificates with "Server Auth" EKU.

In order to check if a given certificate is a CA or end entity you can look at the Basic Constraints 
extension of the certificate if present. This will be present in CA certificates and set to SubjectType=CA.
If present in end entity certificates it will be set to "ServerAuth"
*/

int CheckCertConstraints(PCCERT_CONTEXT pCC)
{
    PCERT_EXTENSION pCExt;
    LPCSTR pszObjId;
    DWORD i;
    CERT_BASIC_CONSTRAINTS_INFO *pConstraints=NULL;
    CERT_BASIC_CONSTRAINTS2_INFO *p2Constraints=NULL;
    DWORD ConstraintSize=0;
    int ReturnValue = FAILURE;
    BOOL Using2=FALSE;
    void* ConstraintBlob=NULL;

    pszObjId = szOID_BASIC_CONSTRAINTS;

    pCExt = CertFindExtension(pszObjId,pCC->pCertInfo->cExtension,pCC->pCertInfo->rgExtension);
    if (pCExt == NULL) 
    {
        pszObjId = szOID_BASIC_CONSTRAINTS2;
        pCExt = CertFindExtension(pszObjId,pCC->pCertInfo->cExtension,pCC->pCertInfo->rgExtension);
        Using2=TRUE;
    }
    
    if (pCExt == NULL) 
    {
        ReturnValue = DID_NOT_FIND_CONSTRAINT;
        goto CheckCertConstraints_Exit;
    }

    // Decode extension
    if (!CryptDecodeObject(X509_ASN_ENCODING,pCExt->pszObjId,pCExt->Value.pbData,pCExt->Value.cbData,0,NULL,&ConstraintSize)) 
    {
        goto CheckCertConstraints_Exit;
    }

    ConstraintBlob = malloc(ConstraintSize);
    if (ConstraintBlob == NULL) 
    {
        goto CheckCertConstraints_Exit;
    }

    if (!CryptDecodeObject(X509_ASN_ENCODING,pCExt->pszObjId,pCExt->Value.pbData,pCExt->Value.cbData,0,(void*)ConstraintBlob,&ConstraintSize)) 
    {
       goto CheckCertConstraints_Exit;
        
    }

    if (Using2) 
    {
        p2Constraints=(CERT_BASIC_CONSTRAINTS2_INFO*)ConstraintBlob;
        if (!p2Constraints->fCA) 
        {
            // there is a constraint, and it's not a CA
            ReturnValue = FOUND_CONSTRAINT;
        }
        else
        {
            // This is a CA.  CA cannot be used as a 'server auth'
            ReturnValue = FOUND_CONSTRAINT_BUT_THIS_IS_A_CA_OR_ITS_NOT_AN_END_ENTITY;
        }
    }
    else 
    {
        pConstraints=(CERT_BASIC_CONSTRAINTS_INFO*)ConstraintBlob;
        if (((pConstraints->SubjectType.cbData * 8) - pConstraints->SubjectType.cUnusedBits) >= 2) 
        {
            if ((*pConstraints->SubjectType.pbData) & CERT_END_ENTITY_SUBJECT_FLAG) 
            {
                // there is a valid constraint
                ReturnValue = FOUND_CONSTRAINT;
            }
            else
            {
                // this is not an 'end entity' so hey -- we can't use it.
                ReturnValue = FOUND_CONSTRAINT_BUT_THIS_IS_A_CA_OR_ITS_NOT_AN_END_ENTITY;
            }

        }
    }
        
CheckCertConstraints_Exit:
    if (ConstraintBlob){free(ConstraintBlob);}
    return (ReturnValue);

}


BOOL IsCertExportable(PCCERT_CONTEXT pCertContext)
{
    HCRYPTPROV  hCryptProv = NULL;
    DWORD       dwKeySpec = 0;
    BOOL        fCallerFreeProv = FALSE;
    BOOL        fReturn = FALSE;
    HCRYPTKEY   hKey = NULL;
    DWORD       dwPermissions = 0;
    DWORD       dwSize = 0;

    if (!pCertContext)
    {
        fReturn = FALSE;
        goto IsCertExportable_Exit;
    }

    //
    // first get the private key context
    //
    if (!CryptAcquireCertificatePrivateKey(
            pCertContext,
            CRYPT_ACQUIRE_USE_PROV_INFO_FLAG | CRYPT_ACQUIRE_COMPARE_KEY_FLAG,
            NULL,
            &hCryptProv,
            &dwKeySpec,
            &fCallerFreeProv))
    {
        fReturn = FALSE;
        goto IsCertExportable_Exit;
    }

    //
    // get the handle to the key
    //
    if (!CryptGetUserKey(hCryptProv, dwKeySpec, &hKey))
    {
        fReturn = FALSE;
        goto IsCertExportable_Exit;
    }

    //
    // finally, get the permissions on the key and check if it is exportable
    //
    dwSize = sizeof(dwPermissions);
    if (!CryptGetKeyParam(hKey, KP_PERMISSIONS, (PBYTE)&dwPermissions, &dwSize, 0))
    {
        fReturn = FALSE;
        goto IsCertExportable_Exit;
    }

    fReturn = (dwPermissions & CRYPT_EXPORT) ? TRUE : FALSE;

IsCertExportable_Exit:
    if (hKey != NULL){CryptDestroyKey(hKey);}
    if (fCallerFreeProv){CryptReleaseContext(hCryptProv, 0);}
    return fReturn;
}

BOOL IsCertExportableOnRemoteMachine(CString ServerName,CString UserName,CString UserPassword,CString InstanceName)
{
	BOOL bRes = FALSE;
    BOOL bPleaseDoCoUninit = FALSE;
    HRESULT hResult = E_FAIL;
    IIISCertObj *pTheObject = NULL;
    VARIANT_BOOL varBool = VARIANT_FALSE;

    BSTR bstrServerName = SysAllocString(ServerName);
    BSTR bstrUserName = SysAllocString(UserName);
    BSTR bstrUserPassword = SysAllocString(UserPassword);
    BSTR bstrInstanceName = SysAllocString(InstanceName);

    hResult = CoInitialize(NULL);
    if(FAILED(hResult))
    {
        return bRes;
    }
    bPleaseDoCoUninit = TRUE;

    // this one seems to work with surrogates..
    hResult = CoCreateInstance(CLSID_IISCertObj,NULL,CLSCTX_SERVER,IID_IIISCertObj,(void **)&pTheObject);
    if (FAILED(hResult))
    {
        goto InstallCopyMoveFromRemote_Exit;
    }

    // at this point we were able to instantiate the com object on the server (local or remote)
    pTheObject->put_ServerName(bstrServerName);
    pTheObject->put_UserName(bstrUserName);
    pTheObject->put_UserPassword(bstrUserPassword);
    pTheObject->put_InstanceName(bstrInstanceName);

	hResult = pTheObject->IsInstalled(&varBool);

    hResult = pTheObject->IsExportable(&varBool);
    if (FAILED(hResult))
    {
        goto InstallCopyMoveFromRemote_Exit;
    }

    if (varBool == VARIANT_FALSE) 
    {
        bRes = FALSE;
    }
    else
    {
        bRes = TRUE;
    }

InstallCopyMoveFromRemote_Exit:
    if (pTheObject)
    {
        pTheObject->Release();
        pTheObject = NULL;
    }
    if (bPleaseDoCoUninit)
    {
        CoUninitialize();
    }

    if (bstrServerName) {SysFreeString(bstrServerName);}
    if (bstrUserName) {SysFreeString(bstrUserName);}
    if (bstrUserPassword) {SysFreeString(bstrUserPassword);}
    if (bstrInstanceName) {SysFreeString(bstrInstanceName);}
	return bRes;
}

BOOL DumpCertDesc(char * pBlobInfo)
{
	BOOL bRes = FALSE;

	IISDebugOutput(_T("blob=%s\n"),pBlobInfo);

	bRes = TRUE;
	return bRes;
}


BOOL GetCertDescInfo(CString ServerName,CString UserName,CString UserPassword,CString InstanceName,CERT_DESCRIPTION* desc)
{
    BOOL bReturn = FALSE;
    HRESULT hResult = E_FAIL;
    IIISCertObj *pTheObject = NULL;
    DWORD cbBinaryBufferSize = 0;
    char * pbBinaryBuffer = NULL;
    BOOL bPleaseDoCoUninit = FALSE;
    BSTR bstrServerName = SysAllocString(ServerName);
    BSTR bstrUserName = SysAllocString(UserName);
    BSTR bstrUserPassword = SysAllocString(UserPassword);
    BSTR bstrInstanceName = SysAllocString(InstanceName);
    VARIANT VtArray;
    CString csTemp;
    

    hResult = CoInitialize(NULL);
    if(FAILED(hResult))
    {
        return bReturn;
    }
    bPleaseDoCoUninit = TRUE;

    // this one seems to work with surrogates..
    hResult = CoCreateInstance(CLSID_IISCertObj,NULL,CLSCTX_SERVER,IID_IIISCertObj,(void **)&pTheObject);
    if (FAILED(hResult))
    {
        goto GetCertDescInfo_Exit;
    }

    pTheObject->put_ServerName(bstrServerName);
    pTheObject->put_UserName(bstrUserName);
    pTheObject->put_UserPassword(bstrUserPassword);
    pTheObject->put_InstanceName(bstrInstanceName);

    hResult = pTheObject->GetCertInfo(&VtArray);
    if (FAILED(hResult))
    {
        goto GetCertDescInfo_Exit;
    }

    // we have a VtArray now.
    // change it back to a binary blob
    hResult = HereIsVtArrayGimmieBinary(&VtArray,&cbBinaryBufferSize,&pbBinaryBuffer,FALSE);
    if (FAILED(hResult))
    {
        goto GetCertDescInfo_Exit;
    }

    // Dump it out!
    //DumpCertDesc(pbBinaryBuffer);

    // Loop thru the buffer
    // and fill up the data structure that was passed in...
    // should be delimited by carriage returns...
    TCHAR *token = NULL;
    INT iColon = 0;
    token = _tcstok((TCHAR*) pbBinaryBuffer, _T("\n"));
    while (token)
    {
        csTemp = token;
        iColon = csTemp.Find( _T('=') );
        if (iColon != 0)
        {
            char AsciiString[255];
            CString csTemp2;

            csTemp2 = csTemp.Left(iColon);
            WideCharToMultiByte( CP_ACP, 0, (LPCTSTR) csTemp2, -1, AsciiString, 255, NULL, NULL );

            if (strcmp(AsciiString,szOID_COMMON_NAME) == 0)
            {
                desc->m_CommonName = csTemp.Right(csTemp.GetLength() - iColon - 1);
            }
            if (strcmp(AsciiString,szOID_COUNTRY_NAME) == 0)
            {
                desc->m_Country = csTemp.Right(csTemp.GetLength() - iColon - 1);
            }
            if (strcmp(AsciiString,szOID_LOCALITY_NAME) == 0)
            {
                desc->m_Locality = csTemp.Right(csTemp.GetLength() - iColon - 1);
            }
            if (strcmp(AsciiString,szOID_STATE_OR_PROVINCE_NAME) == 0)
            {
                desc->m_State = csTemp.Right(csTemp.GetLength() - iColon - 1);
            }
            if (strcmp(AsciiString,szOID_ORGANIZATION_NAME) == 0)
            {
                desc->m_Organization = csTemp.Right(csTemp.GetLength() - iColon - 1);
            }
            if (strcmp(AsciiString,szOID_ORGANIZATIONAL_UNIT_NAME) == 0)
            {
                desc->m_OrganizationUnit = csTemp.Right(csTemp.GetLength() - iColon - 1);
            }
            if (strcmp(AsciiString,"4") == 0)
            {
                desc->m_CAName = csTemp.Right(csTemp.GetLength() - iColon - 1);
            }
            if (strcmp(AsciiString,"6") == 0)
            {
                desc->m_ExpirationDate = csTemp.Right(csTemp.GetLength() - iColon - 1);
            }
            if (strcmp(AsciiString,szOID_ENHANCED_KEY_USAGE) == 0)
            {
                desc->m_Usage = csTemp.Right(csTemp.GetLength() - iColon - 1);
            }
            if (strcmp(AsciiString,szOID_SUBJECT_ALT_NAME2) == 0)
            {
                desc->m_AltSubject = csTemp.Right(csTemp.GetLength() - iColon - 1);
            }
            if (strcmp(AsciiString,szOID_SUBJECT_ALT_NAME) == 0)
            {
                desc->m_AltSubject = csTemp.Right(csTemp.GetLength() - iColon - 1);
            }
        }

        token = _tcstok(NULL, _T("\n"));
    }

    /*
    IISDebugOutput(_T("desc.m_CommonName=%s\n"),(LPCTSTR) desc->m_CommonName);
    IISDebugOutput(_T("desc.m_Country=%s\n"),(LPCTSTR) desc->m_Country);
    IISDebugOutput(_T("desc.m_Locality=%s\n"),(LPCTSTR) desc->m_Locality);
    IISDebugOutput(_T("desc.m_State=%s\n"),(LPCTSTR) desc->m_State);
    IISDebugOutput(_T("desc.m_Organization=%s\n"),(LPCTSTR) desc->m_Organization);
    IISDebugOutput(_T("desc.m_OrganizationUnit=%s\n"),(LPCTSTR) desc->m_OrganizationUnit);
    IISDebugOutput(_T("desc.m_CAName=%s\n"),(LPCTSTR) desc->m_CAName);
    IISDebugOutput(_T("desc.m_ExpirationDate=%s\n"),(LPCTSTR) desc->m_ExpirationDate);
    IISDebugOutput(_T("desc.m_Usage=%s\n"),(LPCTSTR) desc->m_Usage);
    */
    
    bReturn = TRUE;

GetCertDescInfo_Exit:
    if (pTheObject)
    {
        pTheObject->Release();
        pTheObject = NULL;
    }
    if (pbBinaryBuffer)
    {
        CoTaskMemFree(pbBinaryBuffer);
    }
    if (bPleaseDoCoUninit)
    {
        CoUninitialize();
    }
	return bReturn;
}


BOOL IsWhistlerWorkstation(void)
{
    BOOL WorkstationSKU = FALSE;
    OSVERSIONINFOEX osvi;
    //
    // Determine if we are installing Personal/Professional SKU
    //
    ZeroMemory( &osvi, sizeof( OSVERSIONINFOEX ) );
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    GetVersionEx((OSVERSIONINFO *) &osvi);
    if (osvi.wProductType == VER_NT_WORKSTATION)
    {
        WorkstationSKU = TRUE;
    }
    return WorkstationSKU;
}


void MsgboxPopup(HRESULT hResult)
{
    DWORD dwFMResult;
    LPTSTR szBuffer = NULL;

    dwFMResult = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, 0, hResult, 0,(LPTSTR) &szBuffer,0, NULL);
    if (dwFMResult)
    {
        AfxMessageBox(szBuffer, MB_OK);
    }

    if (dwFMResult)
    {
        LocalFree(szBuffer);szBuffer=NULL;
    }

    return;
}

CString ReturnGoodMetabaseServerPath(CString csInstanceName)
{
    CString csTemp = _T("");
    CString csInstanceName2 = _T("");
    CString key_path = _T("");
    int iPlace = 0;
    //IISDebugOutput(_T("START=%s\n"),(LPCTSTR) csInstanceName);

    // csInstanceName will come in looking like
    // w3svc/1
    // or /lm/w3svc/1
    // or LM/W3SVC/1
    //
    // we want to it to go out as /lm/w3svc
    key_path = csInstanceName;

    if (!key_path.IsEmpty())
    {
        // Get the service name.
        // which is right after the LM.
        iPlace = csInstanceName.Find(SZ_MBN_MACHINE SZ_MBN_SEP_STR);
        if (iPlace != -1)
        {
            iPlace = iPlace + _tcslen(SZ_MBN_MACHINE) + _tcslen(SZ_MBN_SEP_STR);
            csTemp = csInstanceName.Right(csInstanceName.GetLength() - iPlace);
            // we should now have
            // "W3SVC/1"
            // find the next "/"
            iPlace = csTemp.Find(SZ_MBN_SEP_STR);
            if (iPlace != -1)
            {
                csTemp = csTemp.Left(iPlace);
                key_path = SZ_MBN_SEP_STR SZ_MBN_MACHINE SZ_MBN_SEP_STR;
                key_path += csTemp;
            }
            else
            {
                key_path = SZ_MBN_SEP_STR SZ_MBN_MACHINE SZ_MBN_SEP_STR;
                key_path += csTemp;
            }
        }
        else
        {
            // could not find a LM/
            // so it must be like w3svc/1 or /w3svc/1
            if (csInstanceName == SZ_MBN_SEP_STR SZ_MBN_MACHINE )
            {
                key_path += csInstanceName;
            }
            else
            {
                if (csInstanceName.Left(1) == SZ_MBN_SEP_STR)
                {
                    csInstanceName2 = SZ_MBN_SEP_STR SZ_MBN_MACHINE;
                }
                else
                {
                    csInstanceName2 = SZ_MBN_SEP_STR SZ_MBN_MACHINE SZ_MBN_SEP_STR;
                }
                csInstanceName2 += csInstanceName;

                key_path = csInstanceName2;
                iPlace = csInstanceName2.Find(SZ_MBN_MACHINE SZ_MBN_SEP_STR);
                if (iPlace != -1)
                {
                    iPlace = iPlace + _tcslen(SZ_MBN_MACHINE) + _tcslen(SZ_MBN_SEP_STR);
                    csTemp = csInstanceName2.Right(csInstanceName2.GetLength() - iPlace);
                    // we should now have
                    // "W3SVC/1"
                    // find the next "/"
                    iPlace = csTemp.Find(SZ_MBN_SEP_STR);
                    if (iPlace != -1)
                    {
                        csTemp = csTemp.Left(iPlace);
                        key_path = SZ_MBN_SEP_STR SZ_MBN_MACHINE SZ_MBN_SEP_STR;
                        key_path += csTemp;
                    }
                    else
                    {
                        key_path = SZ_MBN_SEP_STR SZ_MBN_MACHINE SZ_MBN_SEP_STR;
                        key_path += csTemp;
                    }
                }
            }
        }
    }

    //IISDebugOutput(_T("  END=%s\n"),(LPCTSTR) key_path);
    return key_path;
}


static const LPCSTR rgpszSubjectAltOID[] = 
{
    szOID_SUBJECT_ALT_NAME2,
    szOID_SUBJECT_ALT_NAME
};
#define NUM_SUBJECT_ALT_OID (sizeof(rgpszSubjectAltOID) / sizeof(rgpszSubjectAltOID[0]))

void *AllocAndDecodeObject(
    IN DWORD dwCertEncodingType,
    IN LPCSTR lpszStructType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN DWORD dwFlags,
    OUT OPTIONAL DWORD *pcbStructInfo = NULL
    )
{
    DWORD cbStructInfo;
    void *pvStructInfo;

    if (!CryptDecodeObjectEx(
            dwCertEncodingType,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            dwFlags | CRYPT_DECODE_ALLOC_FLAG | CRYPT_DECODE_NOCOPY_FLAG,
            NULL,
            (void *) &pvStructInfo,
            &cbStructInfo
            ))
        goto ErrorReturn;

CommonReturn:
    if (pcbStructInfo)
    {
        *pcbStructInfo = cbStructInfo;
    }
    return pvStructInfo;

ErrorReturn:
    pvStructInfo = NULL;
    cbStructInfo = 0;
    goto CommonReturn;
}


//+-------------------------------------------------------------------------
//  Returns pointer to allocated CERT_ALT_NAME_INFO by decoding either the
//  Subject or Issuer Alternative Extension. CERT_NAME_ISSUER_FLAG is
//  set to select the Issuer.
//
//  Returns NULL if extension not found or cAltEntry == 0
//--------------------------------------------------------------------------
PCERT_ALT_NAME_INFO AllocAndGetAltSubjectInfo(IN PCCERT_CONTEXT pCertContext)
{
    DWORD cAltOID;
    const LPCSTR *ppszAltOID;

    PCERT_EXTENSION pExt;
    PCERT_ALT_NAME_INFO pInfo;

    cAltOID = NUM_SUBJECT_ALT_OID;
    ppszAltOID = rgpszSubjectAltOID;
    
    // Try to find an alternative name extension
    pExt = NULL;
    for ( ; cAltOID > 0; cAltOID--, ppszAltOID++) 
    {
        if (pExt = CertFindExtension(*ppszAltOID,pCertContext->pCertInfo->cExtension,pCertContext->pCertInfo->rgExtension))
        {
            break;
        }
    }

    if (NULL == pExt)
    {
        return NULL;
    }

    if (NULL == (pInfo = (PCERT_ALT_NAME_INFO) AllocAndDecodeObject(pCertContext->dwCertEncodingType,X509_ALTERNATE_NAME,pExt->Value.pbData,pExt->Value.cbData,0)))
    {
        return NULL;
    }
    if (0 == pInfo->cAltEntry) 
    {
        LocalFree(pInfo);
        pInfo = NULL;
        return NULL;
    }
    else
    {
        return pInfo;
    }
}

//+-------------------------------------------------------------------------
//  Attempt to find the specified choice in the decoded alternative name
//  extension.
//--------------------------------------------------------------------------
BOOL GetAltNameUnicodeStringChoiceW(
    IN DWORD dwAltNameChoice,
    IN PCERT_ALT_NAME_INFO pAltNameInfo,
    OUT TCHAR **pcwszOut
    )
{
    DWORD cEntry;
    PCERT_ALT_NAME_ENTRY pEntry;

    if (NULL == pAltNameInfo)
    {
        return FALSE;
    }

    cEntry = pAltNameInfo->cAltEntry;
    pEntry = pAltNameInfo->rgAltEntry;
    for ( ; cEntry > 0; cEntry--, pEntry++) 
    {
        if (dwAltNameChoice == pEntry->dwAltNameChoice) 
        {
            // pwszRfc822Name union choice is the same as
            // pwszDNSName and pwszURL.

            // This is it, copy it out to a new allocation
            if (pEntry->pwszRfc822Name)
            {
                *pcwszOut = NULL;
                if(*pcwszOut = (TCHAR *) LocalAlloc(LPTR, sizeof(TCHAR)*(lstrlen(pEntry->pwszRfc822Name)+1)))
                {
					if (FAILED(StringCbCopy(*pcwszOut,sizeof(TCHAR)*(lstrlen(pEntry->pwszRfc822Name)+1),pEntry->pwszRfc822Name)))
					{
						return FALSE;
					}
                    return TRUE;
                }
            }
        }
    }

    return FALSE;
}

BOOL GetAlternateSubjectName(PCCERT_CONTEXT pCertContext,TCHAR ** cwszOut)
{
    BOOL bRet = FALSE;
    PCERT_ALT_NAME_INFO pAltNameInfo = NULL;
    *cwszOut = NULL;

    pAltNameInfo = AllocAndGetAltSubjectInfo(pCertContext);
    if (pAltNameInfo)
    {
        if (!GetAltNameUnicodeStringChoiceW(CERT_ALT_NAME_RFC822_NAME,pAltNameInfo,cwszOut))
        {
            if (!GetAltNameUnicodeStringChoiceW(CERT_ALT_NAME_DNS_NAME,pAltNameInfo,cwszOut))
            {
                cwszOut = NULL;
                bRet = TRUE;
            }
        }
    }

    if (pAltNameInfo){LocalFree(pAltNameInfo);pAltNameInfo=NULL;}
    return bRet;
}


BOOL IsSiteUsingThisCertHash(const CString& machine_name, const CString& server_name,CRYPT_HASH_BLOB * hash_blob,HRESULT *phResult)
{
    BOOL bReturn = FALSE;
	PCCERT_CONTEXT pCert = NULL;
	*phResult = E_FAIL;
    CComAuthInfo auth(machine_name);
	CMetaKey key(&auth,server_name,METADATA_PERMISSION_READ);

	if (key.Succeeded())
	{
        CString store_name;
		CBlob hash;
		if (	SUCCEEDED(*phResult = key.QueryValue(MD_SSL_CERT_STORE_NAME, store_name))
			&&	SUCCEEDED(*phResult = key.QueryValue(MD_SSL_CERT_HASH, hash))
			)
		{
			// Now we need to find cert by hash
			CRYPT_HASH_BLOB crypt_hash;
            ZeroMemory(&crypt_hash, sizeof(CRYPT_HASH_BLOB));

			crypt_hash.cbData = hash.GetSize();
			crypt_hash.pbData = hash.GetData();
            //IISDebugOutput(_T("\r\nOurHash[%p,%d]\r\nSiteHash[%p,%d]\r\n"),hash_blob->pbData,hash_blob->cbData,crypt_hash.pbData,crypt_hash.cbData);

            if (hash_blob->cbData == crypt_hash.cbData)
            {
                // Compare with the cert hash we are looking for.
                if (0 == memcmp(hash_blob->pbData, crypt_hash.pbData, hash_blob->cbData))
                {
                    bReturn = TRUE;
                }
            }
		}
	}
	else
    {
		*phResult = key.QueryResult();
    }
	return bReturn;
}


HRESULT EnumSitesWithThisCertHashInstalled(CRYPT_HASH_BLOB * hash_blob,CString& machine_name,CString& user_name,CString& user_password,CString strCurrentMetabaseSite,CStringListEx * MyStringList)
{
    HRESULT hr;
    CStringListEx strlDataPaths;

    hr = EnumSitesWithCertInstalled(machine_name,user_name,user_password,strCurrentMetabaseSite,_T(""),&strlDataPaths);
    if (!strlDataPaths.IsEmpty())
    {
        POSITION pos;
        CString SiteInstance;

        // loop thru the list and display all the stuff on a dialog box...
        pos = strlDataPaths.GetHeadPosition();
        while (pos) 
        {
            SiteInstance = strlDataPaths.GetAt(pos);

            // See if this site is using our certificate.
            if (TRUE == IsSiteUsingThisCertHash(machine_name,SiteInstance,hash_blob,&hr))
            {
                MyStringList->AddTail(SiteInstance);
            }

            strlDataPaths.GetNext(pos);
        }
    }
    return hr;
}

HRESULT GetHashFromCertFile(LPCTSTR PFXFileName,LPCTSTR PFXPassword,DWORD *cbHashBufferSize,BYTE **pbHashBuffer)
{
    HRESULT hr = S_OK;
    BYTE * pbData = NULL;
    DWORD actual = 0, cbData = 0;
    BOOL bAllowExport = TRUE;
    PCCERT_CONTEXT  pCertContext = NULL;
    PCCERT_CONTEXT	pCertPre = NULL;
    CRYPT_DATA_BLOB blob;
    CRYPT_HASH_BLOB hash;
    ZeroMemory(&blob, sizeof(CRYPT_DATA_BLOB));
    ZeroMemory(&hash, sizeof(CRYPT_HASH_BLOB));

    HANDLE hFile = CreateFile(PFXFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        hFile = NULL;
        goto GetHashFromCertFile_Exit;
    }

    if (-1 == (cbData = ::GetFileSize(hFile, NULL)))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto GetHashFromCertFile_Exit;
    }

    if (NULL == (pbData = (BYTE *)::CoTaskMemAlloc(cbData)))
    {
        hr = E_OUTOFMEMORY;
        goto GetHashFromCertFile_Exit;
    }
    if (FALSE == ReadFile(hFile, pbData, cbData, &actual, NULL))
    {
        goto GetHashFromCertFile_Exit;
    }

    ZeroMemory(&blob, sizeof(CRYPT_DATA_BLOB));
    blob.pbData = pbData;
    blob.cbData = cbData;

    HCERTSTORE hStore = PFXImportCertStore(&blob, PFXPassword, (bAllowExport ? CRYPT_MACHINE_KEYSET|CRYPT_EXPORTABLE : CRYPT_MACHINE_KEYSET));
    if (hStore == NULL)
    {
        goto GetHashFromCertFile_Exit;
    }

    while (SUCCEEDED(hr) && NULL != (pCertContext = CertEnumCertificatesInStore(hStore, pCertPre)))
    {
        //check if the certificate has the property on it
        //make sure the private key matches the certificate
        //search for both machine key and user keys
        DWORD dwData = 0;
        if (CertGetCertificateContextProperty(pCertContext,CERT_KEY_PROV_INFO_PROP_ID, NULL, &dwData) &&  CryptFindCertificateKeyProvInfo(pCertContext, 0, NULL))
        {
            if (CertGetCertificateContextProperty(pCertContext,CERT_SHA1_HASH_PROP_ID, NULL, &hash.cbData))
			{
				hash.pbData = NULL;
				hash.pbData = (BYTE *) LocalAlloc(LPTR,hash.cbData);
				if (NULL != hash.pbData)
				{
					if (CertGetCertificateContextProperty(pCertContext, CERT_SHA1_HASH_PROP_ID, hash.pbData, &hash.cbData))
					{
						// check if we need to return back the hash
						if (NULL != pbHashBuffer)
						{
							*pbHashBuffer = (BYTE *) ::CoTaskMemAlloc(hash.cbData);
							if (NULL == *pbHashBuffer)
							{
								hr = E_OUTOFMEMORY;
								*pbHashBuffer = NULL;
								*cbHashBufferSize = 0;
							}
							else
							{
								*cbHashBufferSize = hash.cbData;
								memcpy(*pbHashBuffer,hash.pbData,hash.cbData);
							}
						}
					}
				}
            }
            else
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }
        pCertPre = pCertContext;
    }
    CertCloseStore(hStore, 0);

GetHashFromCertFile_Exit:
	if (hash.pbData != NULL)
	{
		ZeroMemory(hash.pbData, hash.cbData);
		LocalFree(hash.pbData);hash.pbData=NULL;
	}
    if (pCertContext != NULL)
    {
        CertFreeCertificateContext(pCertContext);
    }
    if (pbData != NULL)
    {
        ZeroMemory(pbData, cbData);
        ::CoTaskMemFree(pbData);
    }
    if (hFile != NULL)
    {
        CloseHandle(hFile);
    }
    return hr;
}

HRESULT DisplayUsageBySitesOfCert(LPCTSTR PFXFileName,LPCTSTR PFXPassword,CString &machine_name,CString &user_name,CString &user_password,CString &current_site)
{
    HRESULT hr = S_OK;
    CRYPT_HASH_BLOB hash;
    ZeroMemory(&hash, sizeof(CRYPT_HASH_BLOB));

    // Try to get the certificate hash.
    hr = GetHashFromCertFile(PFXFileName,PFXPassword,&(hash.cbData),&(hash.pbData));
    if (SUCCEEDED(hr))
    {
        // Enum thru all our sites to see if this is being used right now...
        CStringListEx MyStringList;
        if (SUCCEEDED(EnumSitesWithThisCertHashInstalled(&hash,machine_name,user_name,user_password,current_site,&MyStringList)))
        {
            if (!MyStringList.IsEmpty())
            {
                POSITION pos;
                CString SiteInstance;

                // loop thru the list and display all the stuff on a dialog box...
                pos = MyStringList.GetHeadPosition();
                while (pos) 
                {
                    SiteInstance = MyStringList.GetAt(pos);

                    IISDebugOutput(_T("CertUsedBy:%s\r\n"),SiteInstance);

                    MyStringList.GetNext(pos);
                }
            }
        }
    }

    if (hash.pbData != NULL)
    {
        ZeroMemory(hash.pbData, hash.cbData);
        ::CoTaskMemFree(hash.pbData);
    }
    return hr;
}

BOOL IsWebServerType(CString strMetabaseNode)
{
    CString spath, sname;
    CMetabasePath::GetServicePath(strMetabaseNode, spath);
    CMetabasePath::GetLastNodeName(spath, sname);
    if (sname.CompareNoCase(SZ_MBN_WEB) == 0)
    {
        return TRUE;
    }
    return FALSE;
}

void
BuildBinding(
    OUT CString & strBinding,
    IN  CIPAddress & iaIpAddress,
    IN  UINT & nTCPPort,
    IN  CString & strDomainName
    )
/*++

Routine Description:

    Build up a binding string from its component parts

Arguments:

    CString & strBinding        : Output binding string
    CIPAddress & iaIpAddress    : ip address (could be 0.0.0.0)
    UINT & nTCPPort             : TCP Port
    CString & strDomainName     : Domain name (host header)

Return Value:

    None.

--*/
{
    if (!iaIpAddress.IsZeroValue())
    {
        strBinding.Format(
            _T("%s:%d:%s"),
            (LPCTSTR)iaIpAddress,
            nTCPPort,
            (LPCTSTR)strDomainName
            );
    }
    else
    {
        //
        // Leave the ip address field blank
        //
        strBinding.Format(_T(":%d:%s"), nTCPPort, (LPCTSTR)strDomainName);
    }
}


void
CrackBinding(
    IN  CString strBinding,
    OUT CIPAddress & iaIpAddress,
    OUT UINT & nTCPPort,
    OUT CString & strDomainName
    )
/*++

Routine Description:

    Helper function to crack a binding string

Arguments:

    CString strBinding          : Binding string to be parsed
    CIPAddress & iaIpAddress    : IP Address output
	UINT & nTCPPort             : TCP Port
    CString & strDomainName     : Domain (host) header name

Return Value:

    None

--*/
{
    //
    // Zero initialize
    //
    iaIpAddress.SetZeroValue();
    nTCPPort = 0;
    strDomainName.Empty();
    int iColonPos = strBinding.Find(_TCHAR(':'));

    if(iColonPos != -1)
    {
        //
        // Get the IP address
        //
        iaIpAddress = strBinding.Left(iColonPos);

        //
        // Look for the second colon
        //
        strBinding = strBinding.Mid(iColonPos + 1);
        iColonPos  = strBinding.Find(_TCHAR(':'));
    }

    if(iColonPos != -1)
    {
        //
        // Get the port number
        //
        nTCPPort = ::_ttol(strBinding.Left(iColonPos));

        //
        // Look for the NULL termination
        //
        strBinding = strBinding.Mid(iColonPos + 1);
        iColonPos = strBinding.Find(_TCHAR('\0'));
    }

    if(iColonPos != -1)
    {
        strDomainName = strBinding.Left(iColonPos);
    }
}


BOOL
WriteSSLPortToSite( const CString& machine_name, 
                    const CString& server_name,
                    const CString& strSSLPort,
                    HRESULT * phResult)
{
	BOOL bRes = FALSE;
    CComAuthInfo auth(machine_name);
	CMetaKey key(&auth,server_name,METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);
	if (key.Succeeded())
	{
		CString strBinding(strSSLPort);
		CString strDomainName = _T("");
		CIPAddress iaIpAddress((DWORD)0);
		CIPAddress iaIpAddress2((DWORD)0);
		UINT nSSLPort = StrToInt(strSSLPort);
		UINT nTCPPort = 0;
		CString strDomainName2;
		BOOL bFoundExisting = FALSE;

		// Bug:761056
		// if we have an existing securebindings for ssl, then use it.
        CStringListEx strSecureBindings;
        if SUCCEEDED(key.QueryValue(MD_SECURE_BINDINGS, strSecureBindings))
        {
			if (!strSecureBindings.IsEmpty())
			{
				CString &strBinding2 = strSecureBindings.GetHead();
				nTCPPort = 0;
				iaIpAddress2.SetZeroValue();
				CrackBinding(strBinding2, iaIpAddress2, nTCPPort, strDomainName2);

				// check if ipaddress is specified.
				if (!iaIpAddress2.IsZeroValue())
				{
					// use the IP address that is already there...
					iaIpAddress = iaIpAddress2;
					bFoundExisting = TRUE;
				}
			}
        }

		if (!bFoundExisting)
		{
			// Bug:761056
			// lookup to see if the IP address is specified in the Server Bindings metabase value.
			// If it is then add that info to the SSL site.
			CStringListEx strServerBindings;
			if SUCCEEDED(key.QueryValue(MD_SERVER_BINDINGS, strServerBindings))
			{
				if (!strServerBindings.IsEmpty())
				{
					CString &strBinding2 = strServerBindings.GetHead();
					nTCPPort = 0;
					iaIpAddress2.SetZeroValue();
					CrackBinding(strBinding2, iaIpAddress2, nTCPPort, strDomainName2);

					// check if ipaddress is specified.
					if (!iaIpAddress2.IsZeroValue())
					{
						// use the IP address that the serverbinding is using.
						iaIpAddress = iaIpAddress2;
					}
				}
			}
		}

		BuildBinding(strBinding,iaIpAddress,nSSLPort,strDomainName);

        CStringListEx strlBindings;
        strlBindings.AddTail(strBinding);
        bRes = SUCCEEDED(*phResult = key.SetValue(MD_SECURE_BINDINGS, strlBindings));
	}
	else
	{
		TRACE(_T("Failed to open metabase key. Error 0x%x\n"), key.QueryResult());
		*phResult = key.QueryResult();
	}
	return bRes;
}


BOOL
GetSSLPortFromSite(const CString& machine_name,
                   const CString& server_name,
                   CString& strSSLPort,
                   HRESULT * phResult)
{
	ASSERT(!machine_name.IsEmpty());
	ASSERT(!server_name.IsEmpty());
	*phResult = S_OK;

    CComAuthInfo auth(machine_name);
	CMetaKey key(&auth,server_name,METADATA_PERMISSION_READ);
	if (key.Succeeded())
	{
        CStringListEx strlBindings;
        *phResult = key.QueryValue(MD_SECURE_BINDINGS, strlBindings);
        if SUCCEEDED(*phResult)
        {
			if (!strlBindings.IsEmpty())
			{
				UINT nTCPPort = 0;
				CString strDomainName;
				CString &strBinding = strlBindings.GetHead();
				CIPAddress iaIpAddress((DWORD)0);
				CrackBinding(strBinding, iaIpAddress, nTCPPort, strDomainName);
				if (nTCPPort > 0)
				{
					TCHAR Buf[10];
					_itot(nTCPPort, Buf, 10);
					strSSLPort = Buf;
				}
			}
        }
		return SUCCEEDED(*phResult);
	}
	else
	{
		*phResult = key.QueryResult();
		return FALSE;
	}
}


BOOL
IsSSLPortBeingUsedOnNonSSLPort(const CString& machine_name,
                   const CString& server_name,
                   const CString& strSSLPort,
                   HRESULT * phResult)
{
	ASSERT(!machine_name.IsEmpty());
	ASSERT(!server_name.IsEmpty());
	CString strPort;
	BOOL bRet = FALSE;
	*phResult = S_OK;

    CComAuthInfo auth(machine_name);
	CMetaKey key(&auth,server_name,METADATA_PERMISSION_READ);
	if (key.Succeeded())
	{
        CStringListEx strlBindings;
        *phResult = key.QueryValue(MD_SERVER_BINDINGS, strlBindings);
        if SUCCEEDED(*phResult)
        {
			if (!strlBindings.IsEmpty())
			{
				UINT nTCPPort = 0;
				CString strDomainName;
				CString &strBinding = strlBindings.GetHead();
				CIPAddress iaIpAddress((DWORD)0);
				CrackBinding(strBinding, iaIpAddress, nTCPPort, strDomainName);
				if (nTCPPort > 0)
				{
					TCHAR Buf[10];
					_itot(nTCPPort, Buf, 10);
					strPort = Buf;
				}
				if (strPort.IsEmpty() && strSSLPort.IsEmpty())
				{
					bRet = FALSE;
				}
				else
				{
					if (0 == strSSLPort.CompareNoCase(strPort))
					{
						bRet = TRUE;
					}
				}
			}
        }
	}
	else
	{
		*phResult = key.QueryResult();
	}

	return bRet;
}

#define CB_SHA_DIGEST_LEN   20

BOOL
CheckForCertificateRenewal(
    DWORD dwProtocol,
    PCCERT_CONTEXT pCertContext,
    PCCERT_CONTEXT *ppNewCertificate)
{
    BYTE rgbThumbprint[CB_SHA_DIGEST_LEN];
    DWORD cbThumbprint = sizeof(rgbThumbprint);
    CRYPT_HASH_BLOB HashBlob;
    PCCERT_CONTEXT pNewCert;
    BOOL fMachineCert;
    PCRYPT_KEY_PROV_INFO pProvInfo = NULL;
    DWORD cbSize;
    HCERTSTORE hMyCertStore = 0;
    BOOL fRenewed = FALSE;

    HCERTSTORE g_hMyCertStore;

    if(dwProtocol & SP_PROT_SERVERS)
    {
        fMachineCert = TRUE;
    }
    else
    {
        fMachineCert = FALSE;
    }


    //
    // Loop through the linked list of renewed certificates, looking
    // for the last one.
    //
    
    while(TRUE)
    {
        //
        // Check for renewal property.
        //

        if(!CertGetCertificateContextProperty(pCertContext,
                                              CERT_RENEWAL_PROP_ID,
                                              rgbThumbprint,
                                              &cbThumbprint))
        {
            // Certificate has not been renewed.
            break;
        }
        //DebugLog((DEB_TRACE, "Certificate has renewal property\n"));


        //
        // Determine whether to look in the local machine MY store
        // or the current user MY store.
        //

        if(!hMyCertStore)
        {
            if(CertGetCertificateContextProperty(pCertContext,
                                                 CERT_KEY_PROV_INFO_PROP_ID,
                                                 NULL,
                                                 &cbSize))
            {
				
                pProvInfo = (PCRYPT_KEY_PROV_INFO) LocalAlloc(LPTR,cbSize);
                if(pProvInfo == NULL)
                {
                    break;
                }

                if(CertGetCertificateContextProperty(pCertContext,
                                                     CERT_KEY_PROV_INFO_PROP_ID,
                                                     pProvInfo,
                                                     &cbSize))
                {
                    if(pProvInfo->dwFlags & CRYPT_MACHINE_KEYSET)
                    {
                        fMachineCert = TRUE;
                    }
                    else
                    {
                        fMachineCert = FALSE;
                    }
                }

				if (pProvInfo)
				{
					LocalFree(pProvInfo);pProvInfo=NULL;
				}
            }
        }


        //
        // Open up the appropriate MY store, and attempt to find
        // the new certificate.
        //

        if(!hMyCertStore)
        {
            if(fMachineCert)
            {
                g_hMyCertStore = CertOpenStore(CERT_STORE_PROV_SYSTEM,X509_ASN_ENCODING,0,CERT_SYSTEM_STORE_LOCAL_MACHINE,L"MY");
                if(g_hMyCertStore)
                {
                    hMyCertStore = g_hMyCertStore;
                }
            }
            else
            {
                hMyCertStore = CertOpenSystemStore(0, _T("MY"));
            }

            if(!hMyCertStore)
            {
                //DebugLog((DEB_ERROR, "Error 0x%x opening %s MY certificate store!\n", GetLastError(),(fMachineCert ? "local machine" : "current user") ));
                break;
            }
        }

        HashBlob.cbData = cbThumbprint;
        HashBlob.pbData = rgbThumbprint;

        pNewCert = CertFindCertificateInStore(hMyCertStore, 
                                              X509_ASN_ENCODING, 
                                              0, 
                                              CERT_FIND_HASH, 
                                              &HashBlob, 
                                              NULL);
        if(pNewCert == NULL)
        {
            // Certificate has been renewed, but the new certificate
            // cannot be found.
            //DebugLog((DEB_ERROR, "New certificate cannot be found: 0x%x\n", GetLastError()));
            break;
        }


        //
        // Return the new certificate, but first loop back and see if it's been
        // renewed itself.
        //

        pCertContext = pNewCert;
        *ppNewCertificate = pNewCert;


        //DebugLog((DEB_TRACE, "Certificate has been renewed\n"));
        fRenewed = TRUE;
    }


    //
    // Cleanup.
    //

    if(hMyCertStore && hMyCertStore != g_hMyCertStore)
    {
        CertCloseStore(hMyCertStore, 0);
    }

    return fRenewed;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\certwiz.h ===
#if !defined(AFX_CERTWIZ_H__D4BE8638_0C85_11D2_91B1_00C04F8C8761__INCLUDED_)
#define AFX_CERTWIZ_H__D4BE8638_0C85_11D2_91B1_00C04F8C8761__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// CertWiz.h : main header file for CERTWIZ.DLL

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CCertWizApp : See CertWiz.cpp for implementation.

class CCertWizApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
	HKEY RegOpenKeyWizard();
	void GetRegistryPath(CString& str);
};

// Implemented in orginfopage.cpp
void DDV_MaxCharsCombo(CDataExchange* pDX, UINT ControlID, CString const& value, int nChars);

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CERTWIZ_H__D4BE8638_0C85_11D2_91B1_00C04F8C8761__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\certwiz.cpp ===
// CertWiz.cpp : Implementation of CCertWizApp and DLL registration.

#include "stdafx.h"
#include "CertWiz.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CCertWizApp NEAR theApp;

const GUID CDECL BASED_CODE _tlid =
		{ 0xd4be862f, 0xc85, 0x11d2, { 0x91, 0xb1, 0, 0xc0, 0x4f, 0x8c, 0x87, 0x61 } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;

const TCHAR szRegistryKey[] = _T("SOFTWARE\\Microsoft\\InetMgr");
const TCHAR szWizardKey[] = _T("CertWiz");

///////////////////////////////////////////////////////////////////////////
// CCertWizApp::InitInstance - DLL initialization

BOOL CCertWizApp::InitInstance()
{
	BOOL bInit = COleControlModule::InitInstance();
	if (bInit)
	{
		AfxEnableControlContainer();
		InitCommonDll();

        CString sz;
        // set the name of the application correctly
        sz.LoadString(IDS_CERTWIZ);
        // free the existing name, and copy in the new one
        free((void*)m_pszAppName);
        m_pszAppName = _tcsdup(sz);

		GetOutputDebugFlag();
	}
	return bInit;
}

////////////////////////////////////////////////////////////////////////////
// CCertWizApp::ExitInstance - DLL termination

int CCertWizApp::ExitInstance()
{
	// TODO: Add your own module termination code here.

	return COleControlModule::ExitInstance();
}

HKEY
CCertWizApp::RegOpenKeyWizard()
{
	HKEY hKey = NULL;
	
	CString strKey;
	GetRegistryPath(strKey);
    
	VERIFY(ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, strKey, 0, KEY_ALL_ACCESS, &hKey));
	return hKey;
}

void
CCertWizApp::GetRegistryPath(CString& str)
{
	str = szRegistryKey;
	str += _T("\\");
	str += szWizardKey;
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid))
		return ResultFromScode(SELFREG_E_TYPELIB);
	if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))
		return ResultFromScode(SELFREG_E_CLASS);
	
	HKEY hKey;
	int rc = NOERROR;
	if (ERROR_SUCCESS == (rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
							szRegistryKey, 0, KEY_CREATE_SUB_KEY, &hKey)))
	{
		HKEY hWizardKey;
		if (ERROR_SUCCESS == (rc = RegCreateKey(hKey, szWizardKey, &hWizardKey)))
		{
			RegCloseKey(hWizardKey);
		}
		RegCloseKey(hKey);
	}

	return rc;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor))
		return ResultFromScode(SELFREG_E_TYPELIB);
	if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
		return ResultFromScode(SELFREG_E_CLASS);
	// remove CertWiz data from the Registry
	HKEY hKey;
	if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
								szRegistryKey, 0, KEY_ALL_ACCESS, &hKey))
	{
		RegDeleteKey(hKey, szWizardKey);
		RegCloseKey(hKey);
	}

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\certutil.h ===
//
// CertUtil.h
//
#ifndef _CERTUTIL_H
#define _CERTUTIL_H

#include <wincrypt.h>
#include <CertCli.h>
#include <xenroll.h>
#include "Certificat.h"

BOOL GetOnlineCAList(CStringList& list, const CString& certType, HRESULT * phRes);
BOOL GetRequestInfoFromPKCS10(CCryptBlob& pkcs10, 
										PCERT_REQUEST_INFO * pReqInfo,
										HRESULT * phRes);
PCCERT_CONTEXT GetPendingDummyCert(const CString& inst_name, 
											  IEnroll * pEnroll,
											  HRESULT * phRes);
HCERTSTORE OpenRequestStore(IEnroll * pEnroll, HRESULT * phResult);
HCERTSTORE OpenMyStore(IEnroll * pEnroll, HRESULT * phResult);
PCCERT_CONTEXT GetCertContextFromPKCS7File(const CString& resp_file_name, 
														CERT_PUBLIC_KEY_INFO * pKeyInfo,
														HRESULT * phResult);
PCCERT_CONTEXT GetCertContextFromPKCS7(const BYTE * pbData, DWORD cbData,
													CERT_PUBLIC_KEY_INFO * pKeyInfo,
													HRESULT * phResult);
PCCERT_CONTEXT GetRequestContext(CCryptBlob& pkcs10, HRESULT * phRes);
BOOL GetRequestInfoFromPKCS10(CCryptBlob& pkcs10, 
										PCERT_REQUEST_INFO * pReqInfo,
										HRESULT * phRes);
//BOOL GetRequestInfoFromRenewalRequest(CCryptBlob& renewal_req,
//                              PCCERT_CONTEXT * pSignerCert,
//                              HCERTSTORE hStore,
//										PCERT_REQUEST_INFO * pReqInfo,
//										HRESULT * phRes);
PCCERT_CONTEXT GetReqCertByKey(IEnroll * pEnroll, 
										 CERT_PUBLIC_KEY_INFO * pKeyInfo, 
										 HRESULT * phResult);

BOOL FormatDateString(CString& str, 
							 FILETIME ft, 
							 BOOL fIncludeTime, 
							 BOOL fLongFormat);
BOOL
GetKeyUsageProperty(PCCERT_CONTEXT pCertContext, 
						  CERT_ENHKEY_USAGE ** pKeyUsage, 
						  BOOL fPropertiesOnly, 
						  HRESULT * phRes);
INT
ContainsKeyUsageProperty(PCCERT_CONTEXT pCertContext, 
						 CArray<LPCSTR, LPCSTR>& uses, 
						 HRESULT * phRes);
BOOL FormatEnhancedKeyUsageString(CString& str, 
											 PCCERT_CONTEXT pCertContext, 
											 BOOL fPropertiesOnly, 
											 BOOL fMultiline,
											 HRESULT * phRes);
PCCERT_CONTEXT
GetInstalledCert(const CString& machine_name, 
					  const CString& server_name,
					  IEnroll * pEnroll,
					  HRESULT * phResult);
BOOL 
InstallCertByHash(CRYPT_HASH_BLOB * pHash,
					  const CString& machine_name, 
					  const CString& server_name,
					  IEnroll * pEnroll,
					  HRESULT * phResult);
BOOL
InstallHashToMetabase(CRYPT_HASH_BLOB * pHash,
					  const CString& machine_name, 
					  const CString& server_name,
					  HRESULT * phResult);
HRESULT CreateRequest_Base64(const BSTR bstr_dn, 
                             IEnroll * pEnroll,
                             BSTR csp_name,
                             DWORD csp_type,
                             BSTR * pOut);
BOOL AttachFriendlyName(PCCERT_CONTEXT pContext, const CString& name, HRESULT * phRes);
BOOL GetFriendlyName(PCCERT_CONTEXT pCertContext,
					 CString& name,
					 HRESULT * phRes);
BOOL GetNameString(PCCERT_CONTEXT pCertContext,
				  DWORD type,
				  DWORD flag,
				  CString& name,
				  HRESULT * phRes);
BOOL GetHashProperty(PCCERT_CONTEXT pCertContext, CCryptBlob& hash_blob, HRESULT * phRes);
BOOL GetStringProperty(PCCERT_CONTEXT pCertContext, DWORD propId, CString& str, HRESULT * phRes);
BOOL GetBlobProperty(PCCERT_CONTEXT pCertContext,
					 DWORD propId,
					 CCryptBlob& blob,
					 HRESULT * phRes);

BOOL EncodeString(CString& str, CCryptBlob& blob, HRESULT * phRes);
BOOL EncodeInteger(int number, CCryptBlob& blob, HRESULT * phRes);
BOOL EncodeBlob(CCryptBlob& in, CCryptBlob& out, HRESULT * phRes);
BOOL DecodeBlob(CCryptBlob& in, CCryptBlob& out, HRESULT * phRes);
BOOL GetServerComment(const CString& machine_name, const CString& server_name,
					  CString& comment, HRESULT * phResult);
void FormatRdnAttr(CString& str, DWORD dwValueType, CRYPT_DATA_BLOB& blob, BOOL fAppend);

BOOL CreateDirectoryFromPath(LPCTSTR szPath, LPSECURITY_ATTRIBUTES lpSA);

BOOL CompactPathToWidth(CWnd * pControl, CString& strPath);

BOOL GetKeySizeLimits(IEnroll * pEnroll, 
					  DWORD * min, DWORD * max, DWORD * def, 
					  BOOL bGSC,
					  HRESULT * phRes);
HRESULT ShutdownSSL(CString& machine_name, CString& server_name);
HRESULT HereIsVtArrayGimmieBinary(VARIANT * lpVarSrcObject,DWORD * cbBinaryBufferSize,char **pbBinaryBuffer,BOOL bReturnBinaryAsVT_VARIANT);
CERT_CONTEXT * GetInstalledCertFromHash(HRESULT * phResult,DWORD cbHashBlob, char * pHashBlob);
BOOL ViewCertificateDialog(CRYPT_HASH_BLOB* pcrypt_hash, HWND hWnd);
HRESULT IsCertUsedBySSLBelowMe(CString& machine_name, CString& server_name, CStringList& listFillMe);

CRYPT_HASH_BLOB * GetInstalledCertHash(const CString& machine_name,const CString& server_name,IEnroll * pEnroll,HRESULT * phResult);
HRESULT EnumSitesWithCertInstalled(CString& machine_name,CString& user_name,CString& user_password,CString strCurrentMetabaseSite,CString strSiteToExclude,CStringListEx * MyStringList);
BOOL GetServerComment(const CString& machine_name,const CString& user_name,const CString& user_password,CString& MetabaseNode,CString& comment,HRESULT * phResult);
HRESULT EnumSites(CString& machine_name,CString& user_name,CString& user_password,CString strCurrentMetabaseSite,CString strSiteToExclude,CStringListEx * MyStringList);

#define FAILURE                                                     0
#define DID_NOT_FIND_CONSTRAINT                                     1
#define FOUND_CONSTRAINT_BUT_THIS_IS_A_CA_OR_ITS_NOT_AN_END_ENTITY  2
#define FOUND_CONSTRAINT                                            3
int CheckCertConstraints(PCCERT_CONTEXT pCC);
BOOL IsCertExportable(PCCERT_CONTEXT pCertContext);
BOOL IsCertExportableOnRemoteMachine(CString ServerName,CString UserName,CString UserPassword,CString InstanceName);
BOOL DumpCertDesc(char * pBlobInfo);
BOOL GetCertDescInfo(CString ServerName,CString UserName,CString UserPassword,CString InstanceName,CERT_DESCRIPTION* desc);
BOOL IsWhistlerWorkstation(void);
HRESULT IsWebServerExistRemote(CString& machine_name,CString& user_name,CString& user_password,CString csCurrentMetabaseInstanceName);
BOOL    IsWebSiteExistRemote(CString& machine_name,CString& user_name,CString& user_password,CString& site_instance_path,BOOL * bReturnIfCertificateExists);
HRESULT IsCertObjExistRemote(CString& machine_name,CString& user_name,CString& user_password);
void MsgboxPopup(HRESULT hResult);
BOOL    IsMachineLocal(CString& machine_name,CString& user_name,CString& user_password);
CString ReturnGoodMetabaseServerPath(CString csInstanceName);
BOOL GetAlternateSubjectName(PCCERT_CONTEXT pCertContext,TCHAR ** cwszOut);
HRESULT DisplayUsageBySitesOfCert(LPCTSTR PFXFileName,LPCTSTR PFXPassword,CString &machine_name,CString &user_name,CString &user_password,CString &current_site);
BOOL IsWebServerType(CString strMetabaseNode);
BOOL WriteSSLPortToSite( const CString& machine_name,const CString& server_name,const CString& SSLPort,HRESULT * phResult);
BOOL GetSSLPortFromSite(const CString& machine_name,const CString& server_name,CString& strSSLPort,HRESULT * phResult);
BOOL IsSSLPortBeingUsedOnNonSSLPort(const CString& machine_name,const CString& server_name,const CString& strSSLPort,HRESULT * phResult);

HRESULT CreateRequest_Base64(const BSTR bstr_dn, IEnroll * pEnroll, BSTR csp_name,DWORD csp_type,BSTR * pOut);
BOOL CheckForCertificateRenewal(DWORD dwProtocol,PCCERT_CONTEXT pCertContext,PCCERT_CONTEXT *ppNewCertificate);

#endif	//_CERTUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\certwizctl.cpp ===
// CertWizCtl.cpp : Implementation of the CCertWizCtrl ActiveX Control class.

#include "stdafx.h"
#include "CertWiz.h"
#include "CertWizCtl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CCertWizCtrl, COleControl)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CCertWizCtrl, COleControl)
	//{{AFX_MSG_MAP(CCertWizCtrl)
	// NOTE - ClassWizard will add and remove message map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
	ON_MESSAGE(OCM_COMMAND, OnOcmCommand)
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CCertWizCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CCertWizCtrl)
	DISP_FUNCTION(CCertWizCtrl, "SetMachineName", SetMachineName, VT_EMPTY, VTS_BSTR)
	DISP_FUNCTION(CCertWizCtrl, "SetServerInstance", SetServerInstance, VT_EMPTY, VTS_BSTR)
	DISP_STOCKFUNC_DOCLICK()
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CCertWizCtrl, COleControl)
	//{{AFX_EVENT_MAP(CCertWizCtrl)
	//}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

// TODO: Add more property pages as needed.  Remember to increase the count!
//BEGIN_PROPPAGEIDS(CCertWizCtrl, 1)
//	PROPPAGEID(CCertWizPropPage::guid)
//END_PROPPAGEIDS(CCertWizCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CCertWizCtrl, "CERTWIZ.CertWizCtrl.1",
	0xd4be8632, 0xc85, 0x11d2, 0x91, 0xb1, 0, 0xc0, 0x4f, 0x8c, 0x87, 0x61)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CCertWizCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DCertWiz =
		{ 0xd4be8630, 0xc85, 0x11d2, { 0x91, 0xb1, 0, 0xc0, 0x4f, 0x8c, 0x87, 0x61 } };
const IID BASED_CODE IID_DCertWizEvents =
		{ 0xd4be8631, 0xc85, 0x11d2, { 0x91, 0xb1, 0, 0xc0, 0x4f, 0x8c, 0x87, 0x61 } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwCertWizOleMisc =
	OLEMISC_INVISIBLEATRUNTIME |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CCertWizCtrl, IDS_CERTWIZ, _dwCertWizOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CCertWizCtrl::CCertWizCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CCertWizCtrl

BOOL CCertWizCtrl::CCertWizCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	// TODO: Verify that your control follows apartment-model threading rules.
	// Refer to MFC TechNote 64 for more information.
	// If your control does not conform to the apartment-model rules, then
	// you must modify the code below, changing the 6th parameter from
	// afxRegApartmentThreading to 0.

	if (bRegister)
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_CERTWIZ,
			IDB_CERTWIZ,
			afxRegApartmentThreading,
			_dwCertWizOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}


/////////////////////////////////////////////////////////////////////////////
// CCertWizCtrl::CCertWizCtrl - Constructor

CCertWizCtrl::CCertWizCtrl()
{
	InitializeIIDs(&IID_DCertWiz, &IID_DCertWizEvents);

	// TODO: Initialize your control's instance data here.
}


/////////////////////////////////////////////////////////////////////////////
// CCertWizCtrl::~CCertWizCtrl - Destructor

CCertWizCtrl::~CCertWizCtrl()
{
	// TODO: Cleanup your control's instance data here.
}


/////////////////////////////////////////////////////////////////////////////
// CCertWizCtrl::OnDraw - Drawing function

void CCertWizCtrl::OnDraw(
			CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
{
	DoSuperclassPaint(pdc, rcBounds);
}


/////////////////////////////////////////////////////////////////////////////
// CCertWizCtrl::DoPropExchange - Persistence support

void CCertWizCtrl::DoPropExchange(CPropExchange* pPX)
{
	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);

	// TODO: Call PX_ functions for each persistent custom property.

}


/////////////////////////////////////////////////////////////////////////////
// CCertWizCtrl::GetControlFlags -
// Flags to customize MFC's implementation of ActiveX controls.
//
// For information on using these flags, please see MFC technical note
// #nnn, "Optimizing an ActiveX Control".
DWORD CCertWizCtrl::GetControlFlags()
{
	DWORD dwFlags = COleControl::GetControlFlags();


	// The control can activate without creating a window.
	// TODO: when writing the control's message handlers, avoid using
	//		the m_hWnd member variable without first checking that its
	//		value is non-NULL.
	dwFlags |= windowlessActivate;
	return dwFlags;
}


/////////////////////////////////////////////////////////////////////////////
// CCertWizCtrl::OnResetState - Reset control to default state

void CCertWizCtrl::OnResetState()
{
	COleControl::OnResetState();  // Resets defaults found in DoPropExchange

	// TODO: Reset any other control state here.
}


/////////////////////////////////////////////////////////////////////////////
// CCertWizCtrl::PreCreateWindow - Modify parameters for CreateWindowEx

BOOL CCertWizCtrl::PreCreateWindow(CREATESTRUCT& cs)
{
	cs.lpszClass = _T("BUTTON");
	return COleControl::PreCreateWindow(cs);
}


/////////////////////////////////////////////////////////////////////////////
// CCertWizCtrl::IsSubclassedControl - This is a subclassed control

BOOL CCertWizCtrl::IsSubclassedControl()
{
	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CCertWizCtrl::OnOcmCommand - Handle command messages

LRESULT CCertWizCtrl::OnOcmCommand(WPARAM wParam, LPARAM lParam)
{
#ifdef _WIN32
	WORD wNotifyCode = HIWORD(wParam);
#else
	WORD wNotifyCode = HIWORD(lParam);
#endif

	// TODO: Switch on wNotifyCode here.

	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CCertWizCtrl message handlers

#include "WelcomePage.h"
#include "FinalPages.h"
#include "CertContentsPages.h"
#include "GetWhatPage.h"
#include "ChooseCAType.h"
#include "SecuritySettingsPage.h"
#include "ChooseCspPage.h"
#include "OrgInfoPage.h"
#include "SiteNamePage.h"
#include "GeoInfoPage.h"
#include "ChooseFileName.h"
#include "ChooseOnlinePage.h"
#include "WhatToDoPendingPage.h"
#include "ManageCertPage.h"
#include "ChooseCertPage.h"
#include "KeyPasswordPage.h"
#include "Certificat.h"
#include "CopyMoveCertRemotePage.h"
#include "ChooseServerPages.h"
#include "ChooseServerSitePages.h"
#include "sslportpage.h"

void CCertWizCtrl::OnClick(USHORT iButton) 
{
	CIISWizardSheet propsheet(IDB_WIZ_LEFT, IDB_WIZ_TOP);

	CCertificate * cert = new CCertificate;

	ASSERT(!m_InstanceName.IsEmpty());
	cert->m_WebSiteInstanceName = m_InstanceName;
	cert->m_MachineName = m_MachineName;
	VERIFY(cert->Init());

	CWelcomePage welcome_page(cert);
	CGetWhatPage get_what_page(cert);
	CChooseCAType choose_ca_page(cert);
	CSecuritySettingsPage security_settings_page(cert);
    CChooseCspPage csp_page(cert);
	COrgInfoPage org_info_page(cert);
	CSiteNamePage site_name_page(cert);
	CGeoInfoPage geo_info_page(cert);
	CChooseReqFile choose_reqfile_name(cert);
    CChooseReqFileRenew choose_reqfile_name_renew(cert);
	CChooseRespFile choose_respfile_name(cert);
	CChooseKeyFile choose_keyfile_name(cert);
	CRequestToFilePage check_request(cert);
    CRequestToFilePageRenew check_request_renew(cert);
	CFinalToFilePage final_tofile_page(&cert->m_hResult, cert);
	CChooseOnlinePage choose_online(cert);
	COnlineRequestSubmit online_request_dump(cert);
	CWhatToDoPendingPage what_pending(cert);
	CInstallRespPage install_resp(cert);
	CManageCertPage manage_cert(cert);
	CFinalInstalledPage final_install(&cert->m_hResult, cert);
	CRemoveCertPage remove_cert(cert);
	CFinalRemovePage final_remove(&cert->m_hResult, cert);
	CReplaceCertPage replace_cert(cert);
	CFinalReplacedPage final_replace(&cert->m_hResult, cert);
	CChooseCertPage choose_cert(cert);
	CInstallCertPage install_cert(cert);
	CRequestCancelPage cancel_request(cert);
	CFinalCancelPage final_cancel(&cert->m_hResult, cert);
	CKeyPasswordPage key_password_page(cert);
	CInstallKeyPage install_key(cert);
    // new stuff for iis6
    CCopyMoveCertFromRemotePage copy_move_from_cert_remote_page(cert);
    CCopyMoveCertToRemotePage copy_move_to_cert_remote_page(cert);
    CChooseImportPFXFile choose_import_pfx_file_name(cert);
    CChooseExportPFXFile choose_export_pfx_file_name(cert);
    CImportPFXPasswordPage import_pfx_password_name(cert);
    CExportPFXPasswordPage export_pfx_password_name(cert);
    CInstallImportPFXPage install_import_pfx_key(cert);
    CInstallExportPFXPage install_export_pfx_key(cert);
    CFinalInstalledImportPFXPage final_import_pfx(&cert->m_hResult, cert);
    CFinalInstalledExportPFXPage final_export_pfx(&cert->m_hResult, cert);
    CChooseServerPages choose_server_name(cert);
    CChooseServerSitePages choose_server_site_name(cert);
    CChooseServerPagesTo choose_server_name_to(cert);
    CChooseServerSitePagesTo choose_server_site_name_to(cert);
    CInstallCopyFromRemotePage install_copy_from_remote(cert);
    CInstallMoveFromRemotePage install_move_from_remote(cert);
    CInstallCopyToRemotePage install_copy_to_remote(cert);
    CInstallMoveToRemotePage install_move_to_remote(cert);
    CFinalInstalledCopyFromRemotePage final_copy_from_remote(&cert->m_hResult, cert);
    CFinalInstalledMoveFromRemotePage final_move_from_remote(&cert->m_hResult, cert);
    CFinalInstalledCopyToRemotePage final_copy_to_remote(&cert->m_hResult, cert);
    CFinalInstalledMoveToRemotePage final_move_to_remote(&cert->m_hResult, cert);

#ifdef ENABLE_W3SVC_SSL_PAGE
    // SSL only for iis sites
    CSSLPortPage choose_ssl_port(cert);
#endif
    
	propsheet.AddPage(&welcome_page);
	propsheet.AddPage(&get_what_page);
	propsheet.AddPage(&choose_ca_page);
	propsheet.AddPage(&security_settings_page);
    propsheet.AddPage(&csp_page);
	propsheet.AddPage(&org_info_page);
	propsheet.AddPage(&site_name_page);
	propsheet.AddPage(&geo_info_page);
	propsheet.AddPage(&choose_reqfile_name);
    propsheet.AddPage(&choose_reqfile_name_renew);
	propsheet.AddPage(&choose_respfile_name);
	propsheet.AddPage(&choose_keyfile_name);
	propsheet.AddPage(&check_request);
    propsheet.AddPage(&check_request_renew);
	propsheet.AddPage(&final_tofile_page);
	propsheet.AddPage(&choose_online);
	propsheet.AddPage(&online_request_dump);
	propsheet.AddPage(&what_pending);
	propsheet.AddPage(&install_resp);
	propsheet.AddPage(&manage_cert);
	propsheet.AddPage(&final_install);
	propsheet.AddPage(&remove_cert);
	propsheet.AddPage(&final_remove);
	propsheet.AddPage(&choose_cert);
	propsheet.AddPage(&replace_cert);
	propsheet.AddPage(&final_replace);
	propsheet.AddPage(&install_cert);
	propsheet.AddPage(&cancel_request);
	propsheet.AddPage(&final_cancel);
	propsheet.AddPage(&key_password_page);
	propsheet.AddPage(&install_key);
    // new stuff for iis6
    propsheet.AddPage(&copy_move_from_cert_remote_page);
    propsheet.AddPage(&copy_move_to_cert_remote_page);
    propsheet.AddPage(&choose_import_pfx_file_name);
    propsheet.AddPage(&choose_export_pfx_file_name);
    propsheet.AddPage(&import_pfx_password_name);
    propsheet.AddPage(&export_pfx_password_name);
    propsheet.AddPage(&install_import_pfx_key);
    propsheet.AddPage(&install_export_pfx_key);
    propsheet.AddPage(&final_import_pfx);
    propsheet.AddPage(&final_export_pfx);
    propsheet.AddPage(&choose_server_name);
    propsheet.AddPage(&choose_server_site_name);
    propsheet.AddPage(&choose_server_name_to);
    propsheet.AddPage(&choose_server_site_name_to);
    propsheet.AddPage(&install_copy_from_remote);
    propsheet.AddPage(&install_move_from_remote);
    propsheet.AddPage(&install_copy_to_remote);
    propsheet.AddPage(&install_move_to_remote);
    propsheet.AddPage(&final_copy_from_remote);
    propsheet.AddPage(&final_move_from_remote);
    propsheet.AddPage(&final_copy_to_remote);
    propsheet.AddPage(&final_move_to_remote);
#ifdef ENABLE_W3SVC_SSL_PAGE
    propsheet.AddPage(&choose_ssl_port);
#endif

	if (IDCANCEL != propsheet.DoModal())
	{
		// save our settings to the Registry
		VERIFY(cert->SaveSettings());
	}
   delete cert;
}

void CCertWizCtrl::SetMachineName(LPCTSTR MachineName) 
{
	m_MachineName = MachineName;
}

void CCertWizCtrl::SetServerInstance(LPCTSTR InstanceName) 
{
	m_InstanceName = InstanceName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\certwizctl.h ===
#if !defined(AFX_CERTWIZCTL_H__D4BE863F_0C85_11D2_91B1_00C04F8C8761__INCLUDED_)
#define AFX_CERTWIZCTL_H__D4BE863F_0C85_11D2_91B1_00C04F8C8761__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// CertWizCtl.h : Declaration of the CCertWizCtrl ActiveX Control class.

/////////////////////////////////////////////////////////////////////////////
// CCertWizCtrl : See CertWizCtl.cpp for implementation.

class CCertWizCtrl : public COleControl
{
	DECLARE_DYNCREATE(CCertWizCtrl)

// Constructor
public:
	CCertWizCtrl();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCertWizCtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	virtual DWORD GetControlFlags();
	virtual void OnClick(USHORT iButton);
	//}}AFX_VIRTUAL

// Implementation
protected:
	~CCertWizCtrl();

	DECLARE_OLECREATE_EX(CCertWizCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CCertWizCtrl)      // GetTypeInfo
//	DECLARE_PROPPAGEIDS(CCertWizCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CCertWizCtrl)		// Type name and misc status

	// Subclassed control support
	BOOL PreCreateWindow(CREATESTRUCT& cs);
	BOOL IsSubclassedControl();
	LRESULT OnOcmCommand(WPARAM wParam, LPARAM lParam);

// Message maps
	//{{AFX_MSG(CCertWizCtrl)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CCertWizCtrl)
	afx_msg void SetMachineName(LPCTSTR MachineName);
	afx_msg void SetServerInstance(LPCTSTR InstanceName);
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

// Event maps
	//{{AFX_EVENT(CCertWizCtrl)
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CCertWizCtrl)
	dispidSetMachineName = 1L,
	dispidSetServerInstance = 2L,
	//}}AFX_DISP_ID
	};
// This project will build only for Unicode
#ifdef _UNICODE
protected:
	CString m_MachineName, m_InstanceName;
#endif
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CERTWIZCTL_H__D4BE863F_0C85_11D2_91B1_00C04F8C8761__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\choosecatype.h ===
#if !defined(AFX_CHOOSECATYPE_H__1FE282A3_29AD_11D2_97AD_000000000000__INCLUDED_)
#define AFX_CHOOSECATYPE_H__1FE282A3_29AD_11D2_97AD_000000000000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ChooseCAType.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CChooseCAType dialog
class CCertificate;

class CChooseCAType : public CIISWizardPage
{
	DECLARE_DYNCREATE(CChooseCAType)

// Construction
public:
	CChooseCAType(CCertificate * pCert = NULL);
	~CChooseCAType();

	enum
	{
		IDD_PAGE_NEXT_NEW = IDD_PAGE_WIZ_SECURITY_SETTINGS,
		IDD_PAGE_PREV_NEW = IDD_PAGE_WIZ_GET_WHAT,
		IDD_PAGE_NEXT_RENEW_OFFLINE = IDD_PAGE_WIZ_CHOOSE_FILENAME_RENEW,
		IDD_PAGE_NEXT_RENEW_ONLINE = IDD_PAGE_WIZ_CHOOSE_ONLINE,
		IDD_PAGE_PREV_RENEW = IDD_PAGE_WIZ_MANAGE_CERT
	};
// Dialog Data
	//{{AFX_DATA(CChooseCAType)
	enum { IDD = IDD_PAGE_WIZ_CHOOSE_CATYPE };
	int		m_Index;
	//}}AFX_DATA
	CCertificate * m_pCert;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChooseCAType)
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChooseCAType)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CHOOSECATYPE_H__1FE282A3_29AD_11D2_97AD_000000000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\choosecatype.cpp ===
// ChooseCAType.cpp : implementation file
//

#include "stdafx.h"
#include "CertWiz.h"
#include "ChooseCAType.h"
#include "CertUtil.H"
#include "Certificat.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChooseCAType property page

IMPLEMENT_DYNCREATE(CChooseCAType, CIISWizardPage)

CChooseCAType::CChooseCAType(CCertificate * pCert) 
	: CIISWizardPage(CChooseCAType::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)

{
	//{{AFX_DATA_INIT(CChooseCAType)
	m_Index = -1;
	//}}AFX_DATA_INIT
}

CChooseCAType::~CChooseCAType()
{
}

void CChooseCAType::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChooseCAType)
	DDX_Radio(pDX, IDC_OFFLINE_RADIO, m_Index);
	//}}AFX_DATA_MAP
}

LRESULT 
CChooseCAType::OnWizardBack()
/*++
Routine Description:
    Prev button handler

Arguments:
    None

Return Value:
	0 to automatically advance to the prev page;
	1 to prevent the page from changing. 
	To jump to a page other than the prev one, 
	return the identifier of the dialog to be displayed.
--*/
{
	if (m_pCert->GetStatusCode() == CCertificate::REQUEST_RENEW_CERT)
		return IDD_PAGE_PREV_RENEW;
	else if (m_pCert->GetStatusCode() == CCertificate::REQUEST_NEW_CERT)
		return IDD_PAGE_PREV_NEW;
	ASSERT(FALSE);
	return 1;
}

LRESULT 
CChooseCAType::OnWizardNext()
/*++
Routine Description:
    Next button handler

Arguments:
    None

Return Value:
	0 to automatically advance to the next page;
	1 to prevent the page from changing. 
	To jump to a page other than the next one, 
	return the identifier of the dialog to be displayed.
--*/
{
	LRESULT id = 1;
	UpdateData();
	m_pCert->m_CAType = m_Index == 0 ? 
		CCertificate::CA_OFFLINE : CCertificate::CA_ONLINE;
	if (m_pCert->GetStatusCode() == CCertificate::REQUEST_RENEW_CERT)
	{
		if (m_pCert->m_CAType == CCertificate::CA_OFFLINE)
			id = IDD_PAGE_NEXT_RENEW_OFFLINE;
		else if (m_pCert->m_CAType == CCertificate::CA_ONLINE)
			id = IDD_PAGE_NEXT_RENEW_ONLINE;
	}
	else if (m_pCert->GetStatusCode() == CCertificate::REQUEST_NEW_CERT)
		id = IDD_PAGE_NEXT_NEW;
	return id;
}

BEGIN_MESSAGE_MAP(CChooseCAType, CIISWizardPage)
	//{{AFX_MSG_MAP(CChooseCAType)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChooseCAType message handlers

//#define _NO_DISABLE

BOOL CChooseCAType::OnInitDialog() 
{
	CIISWizardPage::OnInitDialog();
	ASSERT(m_pCert != NULL);
	m_Index = m_pCert->m_CAType == CCertificate::CA_OFFLINE ? 0 : 1;
	CString temp;
	m_pCert->GetCertificateTemplate(temp);
#ifdef _NO_DISABLE
	VERIFY(GetOnlineCAList(m_pCert->m_OnlineCAList, L"WebServer", &m_pCert->m_hResult));
#else
	if (!GetOnlineCAList(m_pCert->m_OnlineCAList, L"WebServer", &m_pCert->m_hResult))
	{
		// none online CA present: disable online CA button
		GetDlgItem(IDC_ONLINE_RADIO)->EnableWindow(FALSE);
		m_Index = 0;
	}
#endif
	UpdateData(FALSE);
	return FALSE;
}

BOOL CChooseCAType::OnSetActive() 
{
	SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);
	return CIISWizardPage::OnSetActive();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\choosecertpage.cpp ===
// ReplaceChooseCert.cpp : implementation file
//

#include "stdafx.h"
#include "CertWiz.h"
#include "ChooseCertPage.h"
#include "Certificat.h"
#include "CertUtil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define COL_COMMON_NAME				0
#define COL_CA_NAME					1
#define COL_EXPIRATION_DATE		2
#define COL_PURPOSE					3
#define COL_FRIENDLY_NAME			4
#define COL_COMMON_NAME_WID		100
#define COL_CA_NAME_WID				100
#define COL_EXPIRATION_DATE_WID	100
#define COL_PURPOSE_WID				100
#define COL_FRIENDLY_NAME_WID		100

int
CCertListCtrl::GetSelectedIndex()
{
#if _AFX_VER >= 0x0600
	POSITION pos = GetFirstSelectedItemPosition();
	return pos != NULL ? GetNextSelectedItem(pos) : -1;
#else
	// I guess we should do it in a hard way
	int count = GetItemCount();
	int index = -1;
	for (int i = 0; i < count; i++)
	{
		if (GetItemState(i, LVIS_SELECTED))
		{
			index = i;
			break;
		}
	}
	return index;
#endif
}

void
CCertListCtrl::AdjustStyle()
{
#if _AFX_VER >= 0x0600
	DWORD dwStyle = m_CertList.GetExtendedStyle();
	m_CertList.SetExtendedStyle(dwStyle | LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP);
#else
	ASSERT(m_hWnd != NULL);
	DWORD dwStyle = ListView_GetExtendedListViewStyle(m_hWnd);
	ListView_SetExtendedListViewStyle(m_hWnd,
		dwStyle | LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP);
#endif
}

/////////////////////////////////////////////////////////////////////////////
// CChooseCertPage property page

IMPLEMENT_DYNCREATE(CChooseCertPage, CIISWizardPage)

CChooseCertPage::CChooseCertPage(CCertificate * pCert)
	: CIISWizardPage(CChooseCertPage::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CChooseCertPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CChooseCertPage::~CChooseCertPage()
{
}

void CChooseCertPage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChooseCertPage)
	DDX_Control(pDX, IDC_CERT_LIST, m_CertList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CChooseCertPage, CIISWizardPage)
	//{{AFX_MSG_MAP(CChooseCertPage)
	ON_NOTIFY(NM_CLICK, IDC_CERT_LIST, OnClickCertList)
    ON_NOTIFY(NM_DBLCLK, IDC_CERT_LIST, OnDblClickCertList)
    ON_NOTIFY(LVN_KEYDOWN, IDC_CERT_LIST, OnKeydown)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChooseCertPage message handlers

LRESULT CChooseCertPage::OnWizardBack()
{
	LRESULT id = 1;
	switch (m_pCert->GetStatusCode())
	{
	case CCertificate::REQUEST_REPLACE_CERT:
		id = IDD_PAGE_PREV_REPLACE;
		break;
	case CCertificate::REQUEST_INSTALL_CERT:
		id = IDD_PAGE_PREV_INSTALL;
		break;
	default:
		ASSERT(FALSE);
	}
	return id;
}

LRESULT CChooseCertPage::OnWizardNext()
{
	// get hash pointer for selected cert
	int index = m_CertList.GetSelectedIndex();
	ASSERT(index != -1);
	// find cert in store
	CRYPT_HASH_BLOB * pHash = (CRYPT_HASH_BLOB *)m_CertList.GetItemData(index);
	ASSERT(pHash != NULL);
	
	m_pCert->m_pSelectedCertHash = pHash;

	LRESULT id = 1;
	switch (m_pCert->GetStatusCode())
	{
	case CCertificate::REQUEST_REPLACE_CERT:
		id = IDD_PAGE_NEXT_REPLACE;
		break;
	case CCertificate::REQUEST_INSTALL_CERT:
        // Check if we are on the w3svc node...
        // if we are then show the ssl page..
        id = IDD_PAGE_NEXT_INSTALL;
#ifdef ENABLE_W3SVC_SSL_PAGE
        if (IsWebServerType(m_pCert->m_WebSiteInstanceName))
        {
            id = IDD_PAGE_NEXT_INSTALL_W3SVC_ONLY;
        }
#endif
		break;
	default:
		ASSERT(FALSE);
	}
	return id;
}

BOOL CChooseCertPage::OnSetActive()
{
	// If nothing is selected -- stay here
	SetWizardButtons(-1 == m_CertList.GetSelectedIndex() ?
					PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	return CIISWizardPage::OnSetActive();
}

BOOL CChooseCertPage::OnInitDialog()
{
	ASSERT(m_pCert != NULL);

	CIISWizardPage::OnInitDialog();

	CString str;
	str.LoadString(IDS_ISSUED_TO);
	m_CertList.InsertColumn(COL_COMMON_NAME, str, LVCFMT_LEFT, COL_COMMON_NAME_WID);
	str.LoadString(IDS_ISSUED_BY);
	m_CertList.InsertColumn(COL_CA_NAME, str, LVCFMT_LEFT, COL_CA_NAME_WID);
	str.LoadString(IDS_EXPIRATION_DATE);
	m_CertList.InsertColumn(COL_EXPIRATION_DATE, str, LVCFMT_LEFT, COL_EXPIRATION_DATE_WID);
	str.LoadString(IDS_PURPOSE);
	m_CertList.InsertColumn(COL_PURPOSE, str, LVCFMT_LEFT, COL_PURPOSE_WID);
	str.LoadString(IDS_FRIENDLY_NAME);
	m_CertList.InsertColumn(COL_FRIENDLY_NAME, str, LVCFMT_LEFT, COL_FRIENDLY_NAME_WID);

	m_CertList.AdjustStyle();

	if (m_pCert->GetCertDescList(m_DescList))
	{
		int item = 0;
		POSITION pos = m_DescList.GetHeadPosition();
		LV_ITEMW lvi;
		//
		// set up the fields in the list view item struct that don't change from item to item
		//
		memset(&lvi, 0, sizeof(LV_ITEMW));
		lvi.mask = LVIF_TEXT;

		m_CertList.SetItemCount((int)m_DescList.GetCount());

		while (pos != NULL)
		{
			CERT_DESCRIPTION * pDesc = m_DescList.GetNext(pos);
			int i;

            if (!pDesc->m_CommonName.IsEmpty())
            {
			    lvi.iItem = item;
			    lvi.iSubItem = 0;
			    lvi.pszText = (LPTSTR)(LPCTSTR)pDesc->m_CommonName;
			    lvi.cchTextMax = pDesc->m_CommonName.GetLength();
			    i = m_CertList.InsertItem(&lvi);
			    ASSERT(i != -1);
            }
            else
            {
			    lvi.iItem = item;
			    lvi.iSubItem = 0;
			    lvi.pszText = (LPTSTR)(LPCTSTR)pDesc->m_AltSubject;
			    lvi.cchTextMax = pDesc->m_AltSubject.GetLength();
			    i = m_CertList.InsertItem(&lvi);
			    ASSERT(i != -1);
            }

			lvi.iItem = i;
			lvi.iSubItem = COL_CA_NAME;
			lvi.pszText = (LPTSTR)(LPCTSTR)pDesc->m_CAName;
			lvi.cchTextMax = pDesc->m_CAName.GetLength();
			VERIFY(m_CertList.SetItem(&lvi));

			lvi.iSubItem = COL_EXPIRATION_DATE;
			lvi.pszText = (LPTSTR)(LPCTSTR)pDesc->m_ExpirationDate;
			lvi.cchTextMax = pDesc->m_ExpirationDate.GetLength();
			VERIFY(m_CertList.SetItem(&lvi));

			lvi.iSubItem = COL_PURPOSE;
			lvi.pszText = (LPTSTR)(LPCTSTR)pDesc->m_Usage;
			lvi.cchTextMax = pDesc->m_Usage.GetLength();
			VERIFY(m_CertList.SetItem(&lvi));

			lvi.iSubItem = COL_FRIENDLY_NAME;
			lvi.pszText = (LPTSTR)(LPCTSTR)pDesc->m_FriendlyName;
			lvi.cchTextMax = pDesc->m_FriendlyName.GetLength();
			VERIFY(m_CertList.SetItem(&lvi));

			// create CRYPT_HASH_BLOB from desc data and put it to list item
			CRYPT_HASH_BLOB * pHashBlob = new CRYPT_HASH_BLOB;
			ASSERT(pHashBlob != NULL);
			pHashBlob->cbData = pDesc->m_hash_length;
			pHashBlob->pbData = pDesc->m_phash;
			VERIFY(m_CertList.SetItemData(item, (LONG_PTR)pHashBlob));

			item++;
		}
	}
	return TRUE;
}

void CChooseCertPage::OnClickCertList(NMHDR* pNMHDR, LRESULT* pResult)
{
	SetWizardButtons(-1 == m_CertList.GetSelectedIndex() ?
					PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	*pResult = 0;
}

void CChooseCertPage::OnDblClickCertList(NMHDR* pNMHDR, LRESULT* pResult)
{
    // Get the hash for the certificate that is clicked on...
	int index = m_CertList.GetSelectedIndex();
    if (index != -1)
    {
	    // find cert in store
	    CRYPT_HASH_BLOB * pHash = (CRYPT_HASH_BLOB *)m_CertList.GetItemData(index);
        m_pCert->m_pSelectedCertHash = pHash;
        ViewCertificateDialog(pHash,m_hWnd);
        // don't need to make modal, so the user can compare certs side-by-side
        //ViewCertificateDialog(pHash,NULL);
    }
    return;
}

void CChooseCertPage::OnKeydown(NMHDR* pNMHDR, LRESULT* pResult) 
{
	SetWizardButtons(-1 == m_CertList.GetSelectedIndex() ? PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
    *pResult = 0;
    return;
}

void CChooseCertPage::OnDestroy()
{
	// before dialog will be desroyed we need to delete all
	// the item data pointers
	int count = m_CertList.GetItemCount();
	for (int index = 0; index < count; index++)
	{
		CRYPT_HASH_BLOB * pData = (CRYPT_HASH_BLOB *)m_CertList.GetItemData(index);
		delete pData;
	}
	CIISWizardPage::OnDestroy();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\choosecsppage.cpp ===
// ChooseCspPage.cpp : implementation file
//

#include "stdafx.h"
#include "CertWiz.h"
#include "ChooseCspPage.h"
#include "Certificat.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChooseCertPage property page

IMPLEMENT_DYNCREATE(CChooseCspPage, CIISWizardPage)

CChooseCspPage::CChooseCspPage(CCertificate * pCert)
	: CIISWizardPage(CChooseCspPage::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CChooseCspPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CChooseCspPage::~CChooseCspPage()
{
}

void CChooseCspPage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChooseCspPage)
	DDX_Control(pDX, IDC_CSP_LIST, m_List);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CChooseCspPage, CIISWizardPage)
	//{{AFX_MSG_MAP(CChooseCspPage)
	ON_LBN_SELCHANGE(IDC_CSP_LIST, OnListSelChange)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChooseCspPage message handlers

LRESULT CChooseCspPage::OnWizardBack()
{
   return IDD_PREV_PAGE;
}

LRESULT CChooseCspPage::OnWizardNext()
{
	int index = m_List.GetCurSel();
	ASSERT(index != LB_ERR);
	m_List.GetText(index, m_pCert->m_CspName);
   m_pCert->m_CustomProviderType = (DWORD) m_List.GetItemData(index);
   return IDD_NEXT_PAGE;
}

BOOL CChooseCspPage::OnSetActive()
{
	// If nothing is selected -- stay here
   if (!m_pCert->m_CspName.IsEmpty())
   {
      m_List.SelectString(-1, m_pCert->m_CspName);
   }
	SetWizardButtons(LB_ERR == m_List.GetCurSel() ?
					PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	return CIISWizardPage::OnSetActive();
}

BOOL CChooseCspPage::OnInitDialog()
{
	ASSERT(m_pCert != NULL);

	CIISWizardPage::OnInitDialog();

	CString str;
   BSTR bstrProvName = NULL;
   DWORD dwType, nProv;
   int j;
   HRESULT hr;

   // array of compatible CSP provider types (see wincrypt.h)
   DWORD IISProvType[] = 
   { 
      PROV_RSA_SCHANNEL,
      PROV_DH_SCHANNEL
   };

   IEnroll * pEnroll = m_pCert->GetEnrollObject();
   ASSERT(pEnroll != NULL);

   // Loop, for each Prov Type
   for (j = 0; j < (sizeof(IISProvType)/sizeof(DWORD)); j++)
   {
      nProv = 0;
    
      // check specific prov type
      dwType = IISProvType[j];
      // pEnroll is previously instantiated ICEnroll interface pointer
      hr = pEnroll->put_ProviderType(dwType);
      if (FAILED(hr))
      {
         TRACE(_T("Failed put_ProviderType - %x\n"), hr);
         goto error;
      }
      // enumerate the CSPs of this type
      int idx;
      while (S_OK == (hr  = pEnroll->enumProvidersWStr(nProv, 0, &bstrProvName)))
      {
         TRACE(_T("Provider %ws (type %d )\n"), bstrProvName, dwType );
         // increment the index
         nProv++;
         // Free this string, so it can be re-used.
         idx = m_List.AddString(bstrProvName);
         m_List.SetItemData(idx, dwType);
         if (NULL != bstrProvName)
         {
            CoTaskMemFree(bstrProvName);
            bstrProvName = NULL;
         }
      }
      // Print message if provider type doesn't have any CSPs.
      if (0 == nProv)
      {
         TRACE(_T("There were no CSPs of type %d\n"), dwType );
      }
   }

error:
   // Clean up resources, etc.
   if (NULL != bstrProvName)
      CoTaskMemFree(bstrProvName);

	return TRUE;
}

void CChooseCspPage::OnListSelChange()
{
	SetWizardButtons(-1 == m_List.GetCurSel() ?
					PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\choosecertpage.h ===
#if !defined(AFX_REPLACECHOOSECERT_H__F126182F_4039_11D2_9318_0060088FF80E__INCLUDED_)
#define AFX_REPLACECHOOSECERT_H__F126182F_4039_11D2_9318_0060088FF80E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ChooseCertPage.h : header file
//
#include "Certificat.h"
/////////////////////////////////////////////////////////////////////////////
// CChooseCertPage dialog

class CCertListCtrl : public CListCtrl
{
public:
	int GetSelectedIndex();
	void AdjustStyle();
};

class CChooseCertPage : public CIISWizardPage
{
	DECLARE_DYNCREATE(CChooseCertPage)

// Construction
public:
	CChooseCertPage(CCertificate * pCert = NULL);
	~CChooseCertPage();

	enum
	{
		IDD_PAGE_NEXT_REPLACE = IDD_PAGE_WIZ_REPLACE_CERT,
		IDD_PAGE_NEXT_INSTALL = IDD_PAGE_WIZ_INSTALL_CERT,
#ifdef ENABLE_W3SVC_SSL_PAGE
        IDD_PAGE_NEXT_INSTALL_W3SVC_ONLY = IDD_PAGE_WIZ_GET_SSL_PORT,
#endif
		IDD_PAGE_PREV_REPLACE = IDD_PAGE_WIZ_MANAGE_CERT,
		IDD_PAGE_PREV_INSTALL = IDD_PAGE_WIZ_GET_WHAT
	};
// Dialog Data
	//{{AFX_DATA(CChooseCertPage)
	enum { IDD = IDD_PAGE_WIZ_CHOOSE_CERT };
	CCertListCtrl	m_CertList;
	//}}AFX_DATA
	CCertificate * m_pCert;
	CCertDescList m_DescList;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChooseCertPage)
	public:
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChooseCertPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnClickCertList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnDblClickCertList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnKeydown(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_REPLACECHOOSECERT_H__F126182F_4039_11D2_9318_0060088FF80E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\chooseonlinepage.h ===
#if !defined(AFX_CHOOSEONLINEPAGE_H__5760F32A_144F_11D2_8A1E_000000000000__INCLUDED_)
#define AFX_CHOOSEONLINEPAGE_H__5760F32A_144F_11D2_8A1E_000000000000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ChooseOnlinePage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CChooseCAPage dialog
class CCertificate;

class CChooseOnlinePage : public CIISWizardPage
{
	DECLARE_DYNCREATE(CChooseOnlinePage)

// Construction
public:
	CChooseOnlinePage(CCertificate * pCert = NULL);
	~CChooseOnlinePage();

	enum
	{
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_ONLINE_DUMP,
		IDD_PAGE_PREV_NEW = IDD_PAGE_WIZ_GEO_INFO,
		IDD_PAGE_PREV_RENEW = IDD_PAGE_WIZ_CHOOSE_CATYPE
#ifdef ENABLE_W3SVC_SSL_PAGE
      ,IDD_PAGE_PREV_INSTALL_W3SVC_ONLY = IDD_PAGE_WIZ_GET_SSL_PORT
#endif

	};
// Dialog Data
	//{{AFX_DATA(CChooseCAPage)
	enum { IDD = IDD_PAGE_WIZ_CHOOSE_ONLINE };
	int		m_CAIndex;
	//}}AFX_DATA
	CCertificate * m_pCert;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChooseOnlinePage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChooseOnlinePage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CHOOSEONLINEPAGE_H__5760F32A_144F_11D2_8A1E_000000000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\choosecsppage.h ===
#if !defined(_CHOOSECSPPAGE_H)
#define _CHOOSECSPPAGE_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ChooseCertPage.h : header file
//
#include "Certificat.h"
/////////////////////////////////////////////////////////////////////////////
// CChooseCertPage dialog

class CChooseCspPage : public CIISWizardPage
{
	DECLARE_DYNCREATE(CChooseCspPage)

// Construction
public:
	CChooseCspPage(CCertificate * pCert = NULL);
	~CChooseCspPage();

	enum
	{
		IDD_PREV_PAGE = IDD_PAGE_WIZ_SECURITY_SETTINGS,
		IDD_NEXT_PAGE = IDD_PAGE_WIZ_ORG_INFO,
	};
// Dialog Data
	//{{AFX_DATA(CChooseCspPage)
	enum { IDD = IDD_PAGE_WIZ_CHOOSE_CSP };
	CListBox	m_List;
	//}}AFX_DATA
	CCertificate * m_pCert;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChooseCspPage)
	public:
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChooseCspPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnListSelChange();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(_CHOOSECSPPAGE_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\choosefilename.cpp ===
// ChooseFileNamePage.cpp : implementation file
//

#include "stdafx.h"
#include "CertWiz.h"
#include "ChooseFileName.h"
#include "Certificat.h"
#include "Shlwapi.h"
#include "strutil.h"
#include "certutil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChooseFileNamePage property page

IMPLEMENT_DYNCREATE(CChooseFileNamePage, CIISWizardPage)

static BOOL
AnswerIsYes(UINT id, CString& file)
{
	CString strMessage;
	AfxFormatString1(strMessage, id, file);
	return (IDYES == AfxMessageBox(strMessage, MB_ICONEXCLAMATION | MB_YESNO));
}

CChooseFileNamePage::CChooseFileNamePage(UINT id, 
													  UINT defaultID,
													  UINT extID,
													  UINT filterID,
													  CString * pOutFileName,
                                                      CString csAdditionalInfo) 
	: CIISWizardPage(id, IDS_CERTWIZ, TRUE),
	m_id(id),
	m_defaultID(defaultID),
	m_DoReplaceFile(FALSE),
	m_pOutFileName(pOutFileName),
    m_AdditionalInfo(csAdditionalInfo)
{
	//{{AFX_DATA_INIT(CChooseFileNamePage)
	m_FileName = _T("");
	//}}AFX_DATA_INIT
	if (extID != 0)
		ext.LoadString(extID);
	if (filterID != 0)
		filter.LoadString(filterID);
	// replace '!'s in this string to null chars
	for (int i = 0; i < filter.GetLength(); i++)
	{
		if (filter[i] == L'!')
			filter.SetAt(i, L'\0');
	}
}

CChooseFileNamePage::~CChooseFileNamePage()
{
}

void CChooseFileNamePage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChooseFileNamePage)
	DDX_Text(pDX, IDC_FILE_NAME, m_FileName);
	//}}AFX_DATA_MAP
}

LRESULT 
CChooseFileNamePage::OnWizardBack()
{
	ASSERT(FALSE);
	return 1;
}

#if 0
#define SHOW_MESSAGE_BOX(id,str)\
	do {\
		CString strMessage;\
		AfxFormatString1(strMessage, (id), (str));\
		if (IDNO == AfxMessageBox(strMessage, MB_ICONEXCLAMATION | MB_YESNO))\
		{\
			CEdit * pEdit = (CEdit *)CWnd::FromHandle(GetDlgItem(IDC_FILE_NAME)->m_hWnd);\
			pEdit->SetSel(0, -1);\
			pEdit->SetFocus();\
			return 1;\
		}\
	} while(FALSE)
#endif

LRESULT CChooseFileNamePage::DoWizardNext(LRESULT id)
{
	if (id != 1)
	{
		ASSERT(m_pOutFileName != NULL);
		*m_pOutFileName = m_FileName;
	}
	else
	{
		UpdateData(FALSE);
		SetWizardButtons(PSWIZB_BACK);
		GetDlgItem(IDC_FILE_NAME)->SendMessage(EM_SETSEL, 0, -1);
		GetDlgItem(IDC_FILE_NAME)->SetFocus();
		MessageBeep(MB_ICONQUESTION);
	}
	return id;
}

BOOL CChooseFileNamePage::OnSetActive()
{
	SetWizardButtons(m_FileName.IsEmpty() ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
   return CIISWizardPage::OnSetActive();
}

BEGIN_MESSAGE_MAP(CChooseFileNamePage, CIISWizardPage)
	//{{AFX_MSG_MAP(CChooseCAPage)
	ON_BN_CLICKED(IDC_BROWSE_BTN, OnBrowseBtn)
	ON_EN_CHANGE(IDC_FILE_NAME, OnChangeFileName)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChooseCAPage message handlers

void CChooseFileNamePage::OnBrowseBtn() 
{
	ASSERT(FALSE);
}

void CChooseFileNamePage::Browse(CString& strPath, CString& strFile)
{
	if (strPath.IsEmpty())
	{
		::GetCurrentDirectory(MAX_PATH, strPath.GetBuffer(MAX_PATH + 1));
		strPath.ReleaseBuffer();
	}

	CFileDialog fileName(IsReadFileDlg());
	fileName.m_ofn.Flags |= OFN_NOCHANGEDIR | OFN_OVERWRITEPROMPT;
	if (IsReadFileDlg())
		fileName.m_ofn.Flags |= OFN_PATHMUSTEXIST;
	else
		fileName.m_ofn.Flags |= OFN_NOREADONLYRETURN;
	// We need to disable hook to show new style of File Dialog
	fileName.m_ofn.Flags &= ~(OFN_ENABLEHOOK);
	CString strExt = _T("*");
	strExt += ext;
	fileName.m_ofn.lpstrDefExt = strExt;
	fileName.m_ofn.lpstrFile = strFile.GetBuffer(MAX_PATH+1);
	fileName.m_ofn.nMaxFile = MAX_PATH;
	fileName.m_ofn.lpstrInitialDir = strPath.IsEmpty() ? NULL : (LPCTSTR)strPath;
	fileName.m_ofn.lpstrFilter = filter;
	fileName.m_ofn.nFilterIndex = 0;
	if (IDOK == fileName.DoModal())
	{
		ASSERT(NULL != GetDlgItem(IDC_FILE_NAME));
		CString strPrev;
		GetDlgItemText(IDC_FILE_NAME, strPrev);
		if (strPrev.CompareNoCase(strFile) != 0)
		{
			SetDlgItemText(IDC_FILE_NAME, strFile);
			m_DoReplaceFile = TRUE;
			FileNameChanged();
		}
	}
	strFile.ReleaseBuffer();
}

BOOL CChooseFileNamePage::OnInitDialog() 
{
	CIISWizardPage::OnInitDialog();

    if ( (this != NULL) && (this->m_hWnd != NULL) && (GetDlgItem(IDC_FILE_NAME) != NULL) )
    {
	    SHAutoComplete(GetDlgItem(IDC_FILE_NAME)->m_hWnd, SHACF_FILESYSTEM);
	    GetDlgItem(IDC_FILE_NAME)->SetFocus();
		SetWizardButtons(m_FileName.IsEmpty() ? PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
    }
	return FALSE;
}

void CChooseFileNamePage::OnChangeFileName() 
{
	UpdateData(TRUE);
	//
	// Our replacement flag is not valid now:
	// It may be set to TRUE only when name was entered through
	// FileOpen dialog box which asks user about replacing itself
	//
	m_DoReplaceFile = FALSE;
	SetWizardButtons(m_FileName.IsEmpty() ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	// call virtual handler to notify inherited classes
	FileNameChanged();
}

BOOL IsValidFilenameChar(TCHAR cChar)
{
   switch (PathGetCharType((TCHAR)cChar))
   {
        case GCT_INVALID:
        case GCT_WILD:
        case GCT_SEPARATOR:
            return FALSE;
        case GCT_LFNCHAR:
        case GCT_SHORTCHAR:
            break;
   }
   return TRUE;
}

CString GimmieValidFilenameFromString(LPCTSTR path)
{
    CString str;
    // remove all bad characters
    // remove forward slashes
    // remove commas, semicolons...
    str = _T("");
    UINT len = lstrlen(path);
    TCHAR c = _T('');

    for (UINT i = 0; i < len; i++)
    {
        c = path[i];
        if (c != _T('\"'))
        {
            if (TRUE == IsValidFilenameChar(c))
            {
                str = str + c;
            }
        }
    }
    return str;
}

void
CChooseFileNamePage::GetDefaultFileName(CString& str)
{
	if (m_defaultID != 0)
    {
        // check for special type of file
        // which includes a %s string...
        if (m_defaultID == IDS_PFX_FILE_DEFAULT)
        {
            CString str1;
            str1.LoadString(m_defaultID);
            if (str1.Find(_T("%s")) != -1)
            {
                TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
                DWORD dwSize = MAX_COMPUTERNAME_LENGTH + 1;

                if (GetComputerName(szComputerName, &dwSize))
                {
                    CString csOurFileName;
                    csOurFileName = szComputerName;

                    // m_AdditionalInfo should contain
                    // /LM/W3SVC/1 at this point
                    // let's make a filename from it.
                    if (m_AdditionalInfo.GetLength() >= 4)
                    {
                        CString key_path_lm = SZ_MBN_SEP_STR SZ_MBN_MACHINE SZ_MBN_SEP_STR;
                        if (m_AdditionalInfo.Left(4) == key_path_lm)
                        {
                            m_AdditionalInfo = m_AdditionalInfo.Right(m_AdditionalInfo.GetLength() - 4);
                        }
                        else
                        {
                            key_path_lm = SZ_MBN_MACHINE SZ_MBN_SEP_STR;
                            if (m_AdditionalInfo.Left(3) == key_path_lm)
                            {
                                m_AdditionalInfo = m_AdditionalInfo.Right(m_AdditionalInfo.GetLength() - 3);
                            }
                        }
                    }

                    csOurFileName = csOurFileName + _T("_") + GimmieValidFilenameFromString(m_AdditionalInfo);

                    // add on other things...
                    str.Format(str1, csOurFileName);
                }
                else
                {
                    str.Format(str1, _T("1"));
                }
            }
            else
            {
                str.LoadString(m_defaultID);
            }
        }
        else
        {
		    str.LoadString(m_defaultID);
        }
    }
	// set system disk letter to the string
	TCHAR sz[MAX_PATH];
	if (MAX_PATH >= GetSystemDirectory(sz, MAX_PATH))
	{
		str.SetAt(0, sz[0]);
		str.MakeLower();
	}
}

/////////////////////////////////////////////////////////////////////////////
// CChooseReadFileName property page
IMPLEMENT_DYNCREATE(CChooseReadFileName, CChooseFileNamePage)

CChooseReadFileName::CChooseReadFileName(UINT id,
											UINT defaultID,
											UINT extID,
											UINT filterID,
											CString * pOutFileName,
                                            CString csAdditionalInfo
											)
	: CChooseFileNamePage(id, defaultID, extID, filterID, pOutFileName, csAdditionalInfo)
{
}

BEGIN_MESSAGE_MAP(CChooseReadFileName, CChooseFileNamePage)
	//{{AFX_MSG_MAP(CChooseReadFileName)
	ON_BN_CLICKED(IDC_BROWSE_BTN, OnBrowseBtn)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL
CChooseReadFileName::OnInitDialog()
{
	GetDefaultFileName(m_FileName);
	// check if this default file exists
	if (!PathFileExists(m_FileName))
	{
		// try to find first file with this extension
		CString find_str = m_FileName;
		WIN32_FIND_DATA find_data;
		PathRemoveFileSpec(find_str.GetBuffer(MAX_PATH));
		find_str.ReleaseBuffer();
		find_str += _T("*");
		find_str += ext;
		HANDLE hFind = FindFirstFile(find_str, &find_data);
		if (	hFind != INVALID_HANDLE_VALUE 
			&& (find_data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0
			)
		{
			PathRemoveFileSpec(m_FileName.GetBuffer(MAX_PATH));
			m_FileName.ReleaseBuffer();
			m_FileName += find_data.cFileName;
			FindClose(hFind);
		}
		else
		{
			// if nothing found, just attach *.exe to the path
			// it will prevent user from just clicking Next
			m_FileName = find_str;
		}
	}
	return CChooseFileNamePage::OnInitDialog();
}

LRESULT
CChooseReadFileName::OnWizardNext()
{
	LRESULT id = 0;
	CString buf;

	UpdateData();
	// check if this file exists
	if (	!PathFileExists(m_FileName) 
		&&	!PathIsDirectory(m_FileName)
		)
	{
		// try with default extension if it is just filename
		CString str = m_FileName;
		LPTSTR p = PathFindExtension(str);
		if (p != NULL && *p == 0)
		{
			str += ext;
			if (PathFileExists(str))
			{
				m_FileName = str;
				goto DoNext;
			}
		}
		AfxFormatString1(buf, IDS_FILE_DOES_NOT_EXIST, m_FileName);
		AfxMessageBox(buf, MB_OK);
		id = 1;
	}
	else if (PathIsDirectory(m_FileName))
	{
		AfxFormatString1(buf, IDS_FILE_IS_DIRECTORY, m_FileName);
		AfxMessageBox(buf, MB_OK);
		if (m_FileName.Right(1) != L'\\')
			m_FileName += _T("\\");
		id = 1;
	}
DoNext:
	return DoWizardNext(id);
}

void CChooseReadFileName::OnBrowseBtn() 
{
	CString strFile, strPath;
	GetDlgItemText(IDC_FILE_NAME, m_FileName);

	if (!PathFileExists(m_FileName))
	{
		int n = m_FileName.ReverseFind(_T('\\'));
		if (n != -1)
		{
			strPath = m_FileName.Left(n);
			if (!PathFileExists(strPath))
			{
				strPath.Empty();
				strFile = m_FileName.Right(m_FileName.GetLength() - n - 1);
			}
			else if (PathIsDirectory(strPath))
			{
				strFile = m_FileName.Right(m_FileName.GetLength() - n - 1);
			}
		}
		else
			strFile = m_FileName;
	} 
	else if (PathIsDirectory(m_FileName)) 
	{
		strPath = m_FileName;
	}
	else
	{
		// split filename and path
		strPath = m_FileName;
		PathRemoveFileSpec(strPath.GetBuffer(0));
		strPath.ReleaseBuffer();
		strFile = PathFindFileName(m_FileName);
	}
	CChooseFileNamePage::Browse(strPath, strFile);
}

/////////////////////////////////////////////////////////////////////////////
// CChooseWriteFileName

IMPLEMENT_DYNCREATE(CChooseWriteFileName, CChooseFileNamePage)

CChooseWriteFileName::CChooseWriteFileName(UINT id,
											UINT defaultID,
											UINT extID,
											UINT filterID,
											CString * pOutFileName,
                                            CString csAdditionalInfo
											)
	: CChooseFileNamePage(id, defaultID, extID, filterID, pOutFileName, csAdditionalInfo)
{
}

BEGIN_MESSAGE_MAP(CChooseWriteFileName, CChooseFileNamePage)
	//{{AFX_MSG_MAP(CChooseWriteFileName)
	ON_BN_CLICKED(IDC_BROWSE_BTN, OnBrowseBtn)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL
CChooseWriteFileName::OnInitDialog()
{
	GetDefaultFileName(m_FileName);
	return CChooseFileNamePage::OnInitDialog();
}

LRESULT 
CChooseWriteFileName::OnWizardNext()
{
	LRESULT id = 0;
	UpdateData();
	CString fileName = m_FileName, strPathOnly;

    if (FALSE == IsValidPathFileName(fileName))
    {
		id = 1;
		goto ExitPoint;
    }

	if (PathIsURL(fileName))
	{
		// we cannot use URLs
		id = 1;
		goto ExitPoint;
	}
	if (PathIsUNC(fileName))
	{
		if (PathIsUNCServer(fileName))
		{
			// path is incomplete
			id = 1;
			goto ExitPoint;
		}
		if (PathIsUNCServerShare(fileName))
		{
			// path is incomplete
			id = 1;
			goto ExitPoint;
		}
	}
	// If it is not an UNC, then make sure we have absolute path
	else if (PathIsRelative(fileName))
	{
		// We will make path from default drive root, 
		// not from current directory
		CString path;
		if (0 != GetCurrentDirectory(MAX_PATH, path.GetBuffer(MAX_PATH)))
		{
			TCHAR szRoot[5];
			fileName = PathBuildRoot(szRoot, PathGetDriveNumber(path));
			PathAppend(fileName.GetBuffer(MAX_PATH), m_FileName);
			fileName.ReleaseBuffer();
		}
		else
			ASSERT(FALSE);
	}

	// Check if we already have file with this name
	if (PathFileExists(fileName))
	{
		// if it is directory, do nothing, file spec is incomplete
		if (PathIsDirectory(fileName))
			id = 1;
		else
		{
			if (!m_DoReplaceFile)
				id = AnswerIsYes(IDS_REPLACE_FILE, fileName) ? 0 : 1;
		}
		goto ExitPoint;
	}

	// File does not exists
	//
	// we should check, if target directory exists
	strPathOnly = fileName;
	if (strPathOnly.Right(1) != _T('\\'))
	{
		if (PathRemoveFileSpec(strPathOnly.GetBuffer(MAX_PATH)))
		{
			if (PathIsUNCServerShare(strPathOnly))
			{
				// check if we have write access to this
				if (GetFileAttributes(strPathOnly) & FILE_ATTRIBUTE_READONLY)
				{
					id = 1; 
					goto ExitPoint;
				}
			}
			if (!PathIsDirectory(strPathOnly))
			{
				id = AnswerIsYes(IDS_ASK_CREATE_DIR, strPathOnly) ? 0 : 1;
				goto ExitPoint;
			}
		}
		strPathOnly.ReleaseBuffer();
		// If user entered filename with dot only (qqqq.) it means
		// that no extension should be used
		if (fileName.Right(1) == _T("."))
		{
			// remove this dot and check if this file exists
			fileName.ReleaseBuffer(fileName.GetLength() - 1);
			if (PathIsDirectory(fileName))
			{
				id = 1;
			}
			else if (PathFileExists(fileName))
			{
				id = AnswerIsYes(IDS_REPLACE_FILE, fileName) ? 0 : 1;
			}
			goto ExitPoint;
		}
	}
	else
	{
		// not clear, what to do with this
		id = 1;
		goto ExitPoint;
	}
	// It could be just a file name, without extension, try
	// with default extension now
	if (PathFindExtension(fileName) == NULL)
	{
		fileName += ext;
		if (PathIsDirectory(fileName))
		{
			id = 1;
		}
		else if (PathFileExists(fileName))
		{
			id = AnswerIsYes(IDS_REPLACE_FILE, fileName) ? 0 : 1;
		}
		goto ExitPoint;
	}

ExitPoint:

	fileName.MakeLower();
	m_FileName = fileName;
	// prepare to go to the next page
	return DoWizardNext(id);
}

// I try to start FileOpen dialog in some reasonable directory
// 
void CChooseWriteFileName::OnBrowseBtn()
{
	CString strPath, strFile;
	UpdateData();
	strPath = m_FileName;
	if (!PathIsDirectory(strPath))
	{
		LPTSTR pPath = strPath.GetBuffer(strPath.GetLength());
		if (PathRemoveFileSpec(pPath))
		{
			// check if path part of filename exists
			if (PathIsDirectory(pPath))
			{
				// we will use non-path part of spec as a filename
				strFile = PathFindFileName(m_FileName);
			}
			else
			{
				// it is wrong path, use default one
				// TODO: actually I need to take from filespec all existent
				// chunks of path and filename, for example c:\aa\bb\cc\dd.txt,
				// if c:\aa\bb exists, then strPath should be set to c:\aa\bb,
				// and strFile to dd.txt
				strPath.Empty();
			}
		}
		else
		{
			// it is filename only
			strFile = m_FileName;
			strPath.Empty();
		}
		strPath.ReleaseBuffer();
	}
	CChooseFileNamePage::Browse(strPath, strFile);
}

/////////////////////////////////////////////////////////////////////////////
// CChooseRespFile property page

IMPLEMENT_DYNCREATE(CChooseRespFile, CChooseFileNamePage)

CChooseRespFile::CChooseRespFile(CCertificate * pCert) 
	: CChooseReadFileName(CChooseRespFile::IDD,
								 IDS_RESP_FILE_DEFAULT,
								 IDS_RESP_FILE_EXT,
								 IDS_RESP_FILE_FILTER,
								 &pCert->m_RespFileName,
                                 pCert->m_WebSiteInstanceName
                                 ),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CChooseRespFile)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CChooseRespFile::~CChooseRespFile()
{
}

void CChooseRespFile::FileNameChanged()
{
	// we should remove any error messages now
	SetDlgItemText(IDC_ERROR_MSG, _T(""));
	GetDlgItem(IDC_ERROR_MSG)->InvalidateRect(NULL, TRUE);
	GetDlgItem(IDC_ERROR_MSG)->UpdateWindow();
}

void CChooseRespFile::DoDataExchange(CDataExchange* pDX)
{
	CChooseReadFileName::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChooseRespFile)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CChooseRespFile, CChooseReadFileName)
	//{{AFX_MSG_MAP(CChooseRespFile)
    ON_WM_CTLCOLOR()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChooseRespFile message handlers

HBRUSH 
CChooseRespFile::OnCtlColor(
    IN CDC * pDC, 
    IN CWnd * pWnd, 
    IN UINT nCtlColor
    )
{
	if (pWnd->GetDlgCtrlID() == IDC_ERROR_MSG)
	{
		//
		// Default processing...
		//
		return CPropertyPage::OnCtlColor(pDC, pWnd, nCtlColor);
	}
	else
		return CIISWizardPage::OnCtlColor(pDC, pWnd, nCtlColor);
}

LRESULT CChooseRespFile::OnWizardNext() 
{
	LRESULT id = 1;
	// Parent class will check all about files
	if (1 != CChooseReadFileName::OnWizardNext())
	{
		m_pCert->m_RespFileName = m_FileName;
		if (m_pCert->GetResponseCert() == NULL)
		{
			CString strInstanceName;
			CString str;
			// it is possible, that this is wrong response file
			// we will try to inform user, for which site this response
			// file was created
			if (m_pCert->FindInstanceNameForResponse(strInstanceName))
			{
				AfxFormatString1(str, IDS_CERTKEY_MISMATCH_ERROR1, strInstanceName);
			}
			// it is possible that this certificate response file already have been processed
			// in this case it should be in MY store
			else if (m_pCert->IsResponseInstalled(strInstanceName))
			{
				if (!strInstanceName.IsEmpty())
					AfxFormatString1(str, 
						IDS_CERTKEY_ALREADY_INSTALLED_WHERE, strInstanceName);
				else
					str.LoadString(IDS_CERTKEY_ALREADY_INSTALLED);
			}
			else
			{
				// request probably was canceled
				str.LoadString(IDS_CERTKEY_MISMATCH_ERROR2);
			}
			SetDlgItemText(IDC_ERROR_MSG, str);
			SetWizardButtons(PSWIZB_BACK);
		}
		else
		{
			id = IDD_PAGE_NEXT;

#ifdef ENABLE_W3SVC_SSL_PAGE
			if (IsWebServerType(m_pCert->m_WebSiteInstanceName))
			{
				id = IDD_PAGE_NEXT_INSTALL_W3SVC_ONLY;
			}
#endif
		}
	}
	return id;
}

LRESULT 
CChooseRespFile::OnWizardBack()
{
	return IDD_PAGE_PREV;
}

/////////////////////////////////////////////////////////////////////////////
// CChooseReqFile property page

IMPLEMENT_DYNCREATE(CChooseReqFile, CChooseWriteFileName)

CChooseReqFile::CChooseReqFile(CCertificate * pCert) 
	: CChooseWriteFileName(CChooseReqFile::IDD,
								 IDS_REQ_FILE_DEFAULT,
								 IDS_REQ_FILE_EXT,
								 IDS_REQ_FILE_FILTER,
								 &pCert->m_ReqFileName,
                                 pCert->m_WebSiteInstanceName
                                 ),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CChooseRespFile)
	//}}AFX_DATA_INIT
}

CChooseReqFile::~CChooseReqFile()
{
}

void CChooseReqFile::DoDataExchange(CDataExchange* pDX)
{
	CChooseWriteFileName::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChooseRespFile)
	//}}AFX_DATA_MAP
}

LRESULT 
CChooseReqFile::OnWizardBack()
{
	return IDD_PAGE_PREV;
}

LRESULT 
CChooseReqFile::OnWizardNext()
{
	if (CChooseWriteFileName::OnWizardNext() != 1)
		return IDD_PAGE_NEXT;
	return 1;
}

BEGIN_MESSAGE_MAP(CChooseReqFile, CChooseWriteFileName)
	//{{AFX_MSG_MAP(CChooseReqFile)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChooseReqFile property page

IMPLEMENT_DYNCREATE(CChooseReqFileRenew, CChooseWriteFileName)

CChooseReqFileRenew::CChooseReqFileRenew(CCertificate * pCert) 
	: CChooseWriteFileName(CChooseReqFileRenew::IDD,
								 IDS_REQ_FILE_DEFAULT,
								 IDS_REQ_FILE_EXT,
								 IDS_REQ_FILE_FILTER,
								 &pCert->m_ReqFileName,
                                 pCert->m_WebSiteInstanceName
                                 ),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CChooseRespFile)
	//}}AFX_DATA_INIT
}

CChooseReqFileRenew::~CChooseReqFileRenew()
{
}

void CChooseReqFileRenew::DoDataExchange(CDataExchange* pDX)
{
	CChooseWriteFileName::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChooseRespFile)
	//}}AFX_DATA_MAP
}

LRESULT 
CChooseReqFileRenew::OnWizardBack()
{
	return IDD_PAGE_PREV;
}

LRESULT 
CChooseReqFileRenew::OnWizardNext()
{
	if (CChooseWriteFileName::OnWizardNext() != 1)
		return IDD_PAGE_NEXT;
	return 1;
}

BEGIN_MESSAGE_MAP(CChooseReqFileRenew, CChooseWriteFileName)
	//{{AFX_MSG_MAP(CChooseReqFileRenew)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChooseReqFileRenew message handlers



/////////////////////////////////////////////////////////////////////////////
// CChooseKeyFile property page

IMPLEMENT_DYNCREATE(CChooseKeyFile, CChooseReadFileName)

CChooseKeyFile::CChooseKeyFile(CCertificate * pCert) 
	: CChooseReadFileName(CChooseKeyFile::IDD,
								 IDS_KEY_FILE_DEFAULT,
								 IDS_KEY_FILE_EXT,
								 IDS_KEY_FILE_FILTER,
								 &pCert->m_KeyFileName,
                                 pCert->m_WebSiteInstanceName),
	m_pCert(pCert)
{
}

CChooseKeyFile::~CChooseKeyFile()
{
}

void CChooseKeyFile::DoDataExchange(CDataExchange* pDX)
{
	CChooseReadFileName::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChooseRespFile)
	//}}AFX_DATA_MAP
}

LRESULT 
CChooseKeyFile::OnWizardBack()
{
	return IDD_PAGE_PREV;
}

LRESULT 
CChooseKeyFile::OnWizardNext()
{
	CString strFileName = m_pCert->m_KeyFileName;
	if (CChooseReadFileName::OnWizardNext() != 1)
	{
		// if file name was changed then probably password is wrong now
		// and if cert context was imported before -- it is also invalid
		//
		if (m_pCert->m_KeyFileName.CompareNoCase(strFileName))
		{
			m_pCert->m_KeyPassword.Empty();
			m_pCert->DeleteKeyRingCert();
		}
		return IDD_PAGE_NEXT;
	}
	return 1;
}

BEGIN_MESSAGE_MAP(CChooseKeyFile, CChooseReadFileName)
	//{{AFX_MSG_MAP(CChooseKeyFile)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CChooseImportPFXFile property page

IMPLEMENT_DYNCREATE(CChooseImportPFXFile, CChooseReadFileName)

CChooseImportPFXFile::CChooseImportPFXFile(CCertificate * pCert) 
	: CChooseReadFileName(CChooseImportPFXFile::IDD,
								 IDS_PFX_FILE_DEFAULT,
								 IDS_PFX_FILE_EXT,
								 IDS_PFX_FILE_FILTER,
                                 &pCert->m_KeyFileName,
                                 pCert->m_WebSiteInstanceName),
	m_pCert(pCert)
{
    //{{AFX_DATA_INIT(CChooseImportPFXFile)
    m_MarkAsExportable =  FALSE;
    //}}AFX_DATA_INIT
}

CChooseImportPFXFile::~CChooseImportPFXFile()
{
}

void CChooseImportPFXFile::DoDataExchange(CDataExchange* pDX)
{
	CChooseReadFileName::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChooseImportPFXFile)
    DDX_Check(pDX, IDC_MARK_AS_EXPORTABLE, m_MarkAsExportable);
	//}}AFX_DATA_MAP
}

LRESULT 
CChooseImportPFXFile::OnWizardBack()
{
	return IDD_PAGE_PREV;
}

LRESULT 
CChooseImportPFXFile::OnWizardNext()
{
    m_pCert->m_MarkAsExportable = m_MarkAsExportable;

	CString strFileName = m_pCert->m_KeyFileName;
	if (CChooseReadFileName::OnWizardNext() != 1)
	{
        /*
		// if file name was changed then probably password is wrong now
		// and if cert context was imported before -- it is also invalid
		//
		if (m_pCert->m_KeyFileName.CompareNoCase(strFileName))
		{
			m_pCert->m_KeyPassword.Empty();
			m_pCert->DeleteKeyRingCert();
		}
        */
		return IDD_PAGE_NEXT;
	}
	return 1;
}

void CChooseImportPFXFile::OnExportable() 
{
   UpdateData();
}


BEGIN_MESSAGE_MAP(CChooseImportPFXFile, CChooseReadFileName)
	//{{AFX_MSG_MAP(CChooseImportPFXFile)
    ON_BN_CLICKED(IDC_MARK_AS_EXPORTABLE, OnExportable)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CChooseExportPFXFile property page

IMPLEMENT_DYNCREATE(CChooseExportPFXFile, CChooseWriteFileName)

CChooseExportPFXFile::CChooseExportPFXFile(CCertificate * pCert) 
	: CChooseWriteFileName(CChooseExportPFXFile::IDD,
								 IDS_PFX_FILE_DEFAULT,
								 IDS_PFX_FILE_EXT,
								 IDS_PFX_FILE_FILTER,
								 &pCert->m_KeyFileName,
                                 pCert->m_WebSiteInstanceName
                                 ),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CChooseExportPFXFile)
	//}}AFX_DATA_INIT
}

CChooseExportPFXFile::~CChooseExportPFXFile()
{
}

void CChooseExportPFXFile::DoDataExchange(CDataExchange* pDX)
{
	CChooseWriteFileName::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChooseExportPFXFile)
	//}}AFX_DATA_MAP
}

LRESULT 
CChooseExportPFXFile::OnWizardBack()
{
	return IDD_PAGE_PREV;
}

LRESULT 
CChooseExportPFXFile::OnWizardNext()
{
	if (CChooseWriteFileName::OnWizardNext() != 1)
	{
		// Check if the file they want to save to is on a FAT drive and thus unprotected.
		CString strComputerName;
		DWORD   cch = MAX_COMPUTERNAME_LENGTH + 1;
		BOOL    bAnswer;
		// get the actual name of the local machine
		bAnswer = GetComputerName(strComputerName.GetBuffer(cch), &cch);
		strComputerName.ReleaseBuffer();
		if (bAnswer)
		{
			CString strPath;
			CString strInQuestion = m_pCert->m_KeyFileName;
			GetFullPathLocalOrRemote(strComputerName, strInQuestion, strPath);
			if (!SupportsSecurityACLs(strPath))
			{
				::AfxMessageBox(IDS_FAT_DRIVE_WARNING);
			}
		}
		return IDD_PAGE_NEXT;
	}
	return 1;
}

BEGIN_MESSAGE_MAP(CChooseExportPFXFile, CChooseWriteFileName)
	//{{AFX_MSG_MAP(CChooseExportPFXFile)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\chooseserverpages.cpp ===
// ChooseServerPages.cpp: implementation of the CChooseServerPages class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "certwiz.h"
#include "Certificat.h"
#include "ChooseServerPages.h"
#include "certutil.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CChooseServerPages property page

IMPLEMENT_DYNCREATE(CChooseServerPages, CIISWizardPage)

CChooseServerPages::CChooseServerPages(CCertificate * pCert) 
	: CIISWizardPage(CChooseServerPages::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CChooseServerPages)
	m_ServerName = _T("");
    m_UserName = _T("");
    m_UserPassword = _T("");
	//}}AFX_DATA_INIT
}

CChooseServerPages::~CChooseServerPages()
{
}

void CChooseServerPages::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChooseServerPages)
	DDX_Text(pDX, IDC_SERVER_NAME, m_ServerName);
    DDX_Text(pDX, IDC_USER_NAME, m_UserName);
    DDX_Text_SecuredString(pDX, IDC_USER_PASSWORD, m_UserPassword);
	DDV_MaxChars(pDX, m_ServerName, 64);
	//}}AFX_DATA_MAP
}

LRESULT 
CChooseServerPages::OnWizardBack()
/*++
Routine Description:
    Prev button handler

Arguments:
    None

Return Value:
	0 to automatically advance to the prev page;
	1 to prevent the page from changing. 
	To jump to a page other than the prev one, 
	return the identifier of the dialog to be displayed.
--*/
{
	return IDD_PAGE_PREV;
}

LRESULT 
CChooseServerPages::OnWizardNext()
{
    LRESULT lResult = 1;
    HRESULT hResult = 0;
	UpdateData(TRUE);
    CString UserPassword_Remote;
	if (0 != m_ServerName.Compare(m_pCert->m_MachineName_Remote))
	{
		m_pCert->m_MachineName_Remote = m_ServerName;
	}
    m_pCert->m_UserName_Remote = m_UserName;

    m_UserPassword.CopyTo(UserPassword_Remote);
    m_UserPassword.CopyTo(m_pCert->m_UserPassword_Remote);

    // See if we can actually connect to the specified
    // server with username/password combination...
    hResult = IsWebServerExistRemote(m_pCert->m_MachineName_Remote,m_pCert->m_UserName_Remote,UserPassword_Remote,m_pCert->m_WebSiteInstanceName);
    if (SUCCEEDED(hResult))
    {
        // check if the certobj is available on remote machine...
        hResult = IsCertObjExistRemote(m_pCert->m_MachineName_Remote,m_pCert->m_UserName_Remote,UserPassword_Remote);
        if (SUCCEEDED(hResult))
        {
            lResult = IDD_PAGE_NEXT;
        }
        else
        {
            // Tell the user somehow that
            // the object doesn't exist on the remote system
            IISDebugOutput(_T("The object doesn't exist on the specified machine,code=0x%x\n"),hResult);
            if (REGDB_E_CLASSNOTREG == hResult)
            {
                CString buf;
                buf.LoadString(IDS_CERTOBJ_NOT_IMPLEMENTED);
                AfxMessageBox(buf, MB_OK);
            }
            else
            {
                MsgboxPopup(hResult);
            }
        }
    }
    else
    {
        // Tell the user that the remote server
        // does not exist, or that they don't have access
        //IISDebugOutput(_T("Machine not reachable or bad credentials,code=0x%x\n"),hResult);
        MsgboxPopup(hResult);
    }

	return lResult;
}

BOOL 
CChooseServerPages::OnSetActive() 
{
	ASSERT(m_pCert != NULL);
	m_ServerName = m_pCert->m_MachineName_Remote;
    m_UserName = m_pCert->m_UserName_Remote;
    m_pCert->m_UserPassword_Remote.CopyTo(m_UserPassword);

	UpdateData(FALSE);
	SetWizardButtons(m_ServerName.IsEmpty() ?
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	return CIISWizardPage::OnSetActive();
}

BOOL
CChooseServerPages::OnKillActive()
{
	UpdateData();
	m_pCert->m_MachineName_Remote = m_ServerName;
    m_pCert->m_UserName_Remote = m_UserName;
    m_UserPassword.CopyTo(m_pCert->m_UserPassword_Remote);
	return CIISWizardPage::OnKillActive();
}

BEGIN_MESSAGE_MAP(CChooseServerPages, CIISWizardPage)
	//{{AFX_MSG_MAP(CChooseServerPages)
	ON_EN_CHANGE(IDC_SERVER_NAME, OnEditchangeServerName)
    ON_EN_CHANGE(IDC_USER_NAME, OnEditchangeUserName)
    ON_EN_CHANGE(IDC_USER_PASSWORD, OnEditchangeUserPassword)
    ON_BN_CLICKED(IDC_BROWSE_BTN, OnBrowseForMachine)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSiteNamePage message handlers

void CChooseServerPages::OnEditchangeServerName() 
{
	UpdateData(TRUE);	
	SetWizardButtons(m_ServerName.IsEmpty() ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	CString str;
	SetDlgItemText(IDC_ERROR_TEXT, str);
}


void CChooseServerPages::OnEditchangeUserName() 
{
	UpdateData(TRUE);	
	SetWizardButtons(m_ServerName.IsEmpty() ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	CString str;
	SetDlgItemText(IDC_ERROR_TEXT, str);
}


void CChooseServerPages::OnEditchangeUserPassword() 
{
	UpdateData(TRUE);	
	SetWizardButtons(m_ServerName.IsEmpty() ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	CString str;
	SetDlgItemText(IDC_ERROR_TEXT, str);
}

void CChooseServerPages::OnBrowseForMachine()
{
    CGetComputer picker;
    if (picker.GetComputer(m_hWnd))
    {
        SetDlgItemText(IDC_SERVER_NAME, picker.m_strComputerName);
    }

    return;
}


/////////////////////////////////////////////////////////////////////////////
// CChooseServerPages property page

IMPLEMENT_DYNCREATE(CChooseServerPagesTo, CIISWizardPage)

CChooseServerPagesTo::CChooseServerPagesTo(CCertificate * pCert) 
	: CIISWizardPage(CChooseServerPagesTo::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CChooseServerPagesTo)
	m_ServerName = _T("");
    m_UserName = _T("");
    m_UserPassword = _T("");
	//}}AFX_DATA_INIT
}

CChooseServerPagesTo::~CChooseServerPagesTo()
{
}

void CChooseServerPagesTo::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChooseServerPagesTo)
	DDX_Text(pDX, IDC_SERVER_NAME, m_ServerName);
    DDX_Text(pDX, IDC_USER_NAME, m_UserName);
    DDX_Text_SecuredString(pDX, IDC_USER_PASSWORD, m_UserPassword);
	DDV_MaxChars(pDX, m_ServerName, 64);
	//}}AFX_DATA_MAP
}

LRESULT 
CChooseServerPagesTo::OnWizardBack()
/*++
Routine Description:
    Prev button handler

Arguments:
    None

Return Value:
	0 to automatically advance to the prev page;
	1 to prevent the page from changing. 
	To jump to a page other than the prev one, 
	return the identifier of the dialog to be displayed.
--*/
{
	return IDD_PAGE_PREV;
}

LRESULT 
CChooseServerPagesTo::OnWizardNext()
{
    LRESULT lResult = 1;
    HRESULT hResult = 0;
	UpdateData(TRUE);
    CString UserPassword_Remote;

	if (0 != m_ServerName.Compare(m_pCert->m_MachineName_Remote))
	{
		m_pCert->m_MachineName_Remote = m_ServerName;
	}
    m_pCert->m_UserName_Remote = m_UserName;

    m_UserPassword.CopyTo(UserPassword_Remote);
    m_UserPassword.CopyTo(m_pCert->m_UserPassword_Remote);

    // See if we can actually connect to the specified
    // server with username/password combination...
    hResult = IsWebServerExistRemote(m_pCert->m_MachineName_Remote,m_pCert->m_UserName_Remote,UserPassword_Remote,m_pCert->m_WebSiteInstanceName);
    if (SUCCEEDED(hResult))
    {
        // check if the certobj is available on remote machine...
        hResult = IsCertObjExistRemote(m_pCert->m_MachineName_Remote,m_pCert->m_UserName_Remote,UserPassword_Remote);
        if (SUCCEEDED(hResult))
        {
            lResult = IDD_PAGE_NEXT;
        }
        else
        {
            // Tell the user somehow that
            // the object doesn't exist on the remote system
            //IISDebugOutput(_T("The object doesn't exist on the specified machine,code=0x%x\n"),hResult);
            if (REGDB_E_CLASSNOTREG == hResult)
            {
                CString buf;
                buf.LoadString(IDS_CERTOBJ_NOT_IMPLEMENTED);
                AfxMessageBox(buf, MB_OK);
            }
            else
            {
                MsgboxPopup(hResult);
            }
        }
    }
    else
    {
        // Tell the user that the remote server
        // does not exist, or that they don't have access
        //IISDebugOutput(_T("Machine not reachable or bad credentials,code=0x%x\n"),hResult);
        MsgboxPopup(hResult);
    }

    return lResult;
}

BOOL 
CChooseServerPagesTo::OnSetActive() 
{
	ASSERT(m_pCert != NULL);
	m_ServerName = m_pCert->m_MachineName_Remote;
    m_UserName = m_pCert->m_UserName_Remote;

    m_pCert->m_UserPassword_Remote.CopyTo(m_UserPassword);

	UpdateData(FALSE);
	SetWizardButtons(m_ServerName.IsEmpty() ?
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	return CIISWizardPage::OnSetActive();
}

BOOL
CChooseServerPagesTo::OnKillActive()
{
	UpdateData();
	m_pCert->m_MachineName_Remote = m_ServerName;
    m_pCert->m_UserName_Remote = m_UserName;

    m_UserPassword.CopyTo(m_pCert->m_UserPassword_Remote);

	return CIISWizardPage::OnKillActive();
}

BEGIN_MESSAGE_MAP(CChooseServerPagesTo, CIISWizardPage)
	//{{AFX_MSG_MAP(CChooseServerPagesTo)
	ON_EN_CHANGE(IDC_SERVER_NAME, OnEditchangeServerName)
    ON_EN_CHANGE(IDC_USER_NAME, OnEditchangeUserName)
    ON_EN_CHANGE(IDC_USER_PASSWORD, OnEditchangeUserPassword)
    ON_BN_CLICKED(IDC_BROWSE_BTN, OnBrowseForMachine)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSiteNamePage message handlers

void CChooseServerPagesTo::OnEditchangeServerName() 
{
	UpdateData(TRUE);	
	SetWizardButtons(m_ServerName.IsEmpty() ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	CString str;
	SetDlgItemText(IDC_ERROR_TEXT, str);
}


void CChooseServerPagesTo::OnEditchangeUserName() 
{
	UpdateData(TRUE);	
	SetWizardButtons(m_ServerName.IsEmpty() ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	CString str;
	SetDlgItemText(IDC_ERROR_TEXT, str);
}


void CChooseServerPagesTo::OnEditchangeUserPassword() 
{
	UpdateData(TRUE);	
	SetWizardButtons(m_ServerName.IsEmpty() ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	CString str;
	SetDlgItemText(IDC_ERROR_TEXT, str);
}

void CChooseServerPagesTo::OnBrowseForMachine()
{
    CGetComputer picker;
    if (picker.GetComputer(m_hWnd))
    {
        SetDlgItemText(IDC_SERVER_NAME, picker.m_strComputerName);
    }
   
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\chooseonlinepage.cpp ===
// ChooseCAPage.cpp : implementation file
//

#include "stdafx.h"
#include "CertWiz.h"
#include "ChooseOnlinePage.h"
#include "Certificat.h"
#include "CertUtil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChooseOnlinePage property page

IMPLEMENT_DYNCREATE(CChooseOnlinePage, CIISWizardPage)

CChooseOnlinePage::CChooseOnlinePage(CCertificate * pCert) 
	: CIISWizardPage(CChooseOnlinePage::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CChooseOnlinePage)
	m_CAIndex = -1;
	//}}AFX_DATA_INIT
}

CChooseOnlinePage::~CChooseOnlinePage()
{
}

void CChooseOnlinePage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChooseOnlinePage)
	DDX_CBIndex(pDX, IDC_CA_ONLINE_LIST, m_CAIndex);
	//}}AFX_DATA_MAP
}

LRESULT 
CChooseOnlinePage::OnWizardBack()
/*++
Routine Description:
    Prev button handler

Arguments:
    None

Return Value:
	0 to automatically advance to the prev page;
	1 to prevent the page from changing. 
	To jump to a page other than the prev one, 
	return the identifier of the dialog to be displayed.
--*/
{
	LRESULT id = 1;

	switch (m_pCert->GetStatusCode())
	{
		case CCertificate::REQUEST_RENEW_CERT:
			id = IDD_PAGE_PREV_RENEW;
			break;
		case CCertificate::REQUEST_NEW_CERT:
			id = IDD_PAGE_PREV_NEW;
#ifdef ENABLE_W3SVC_SSL_PAGE
			if (IsWebServerType(m_pCert->m_WebSiteInstanceName))
			{
				id = IDD_PAGE_PREV_INSTALL_W3SVC_ONLY;
			}
#endif
			break;
		default:
			id = 1;
	}

	return id;
}

LRESULT 
CChooseOnlinePage::OnWizardNext()
/*++
Routine Description:
    Next button handler

Arguments:
    None

Return Value:
	0 to automatically advance to the next page;
	1 to prevent the page from changing. 
	To jump to a page other than the next one, 
	return the identifier of the dialog to be displayed.
--*/
{
	UpdateData();
	CComboBox * pCombo = (CComboBox *)CWnd::FromHandle(
		GetDlgItem(IDC_CA_ONLINE_LIST)->m_hWnd);
	pCombo->GetLBText(m_CAIndex, m_pCert->m_ConfigCA);
	return IDD_PAGE_NEXT;
}

BEGIN_MESSAGE_MAP(CChooseOnlinePage, CIISWizardPage)
	//{{AFX_MSG_MAP(CChooseCAPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChooseCAPage message handlers

BOOL CChooseOnlinePage::OnInitDialog() 
{
	m_CAIndex = 0;
	// We need to create controls first
	CIISWizardPage::OnInitDialog();
	ASSERT(m_pCert != NULL);
	GetDlgItem(IDC_CA_ONLINE_LIST)->SetFocus();
	CComboBox * pCombo = (CComboBox *)CWnd::FromHandle(
		GetDlgItem(IDC_CA_ONLINE_LIST)->m_hWnd);
	CString str;
	POSITION pos = m_pCert->m_OnlineCAList.GetHeadPosition();
	while (pos != NULL)
	{
		str = m_pCert->m_OnlineCAList.GetNext(pos);
		pCombo->AddString(str);
	}
	int idx;
	if (	!m_pCert->m_ConfigCA.IsEmpty()
		&&	CB_ERR != (idx = pCombo->FindString(-1, m_pCert->m_ConfigCA))
		)
	{
		pCombo->SetCurSel(idx);
	}
	else
		pCombo->SetCurSel(0);
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\choosefilename.h ===
#if !defined(_CHOOSEFILENAMEPAGE_H)
#define _CHOOSEFILENAMEPAGE_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ChooseFileNamePage.h : header file
//
#include "Certificat.h"

/////////////////////////////////////////////////////////////////////////////
// CChooseFileNamePage dialog
//class CCertificate;

class CChooseFileNamePage : public CIISWizardPage
{
	DECLARE_DYNCREATE(CChooseFileNamePage)

// Construction
public:
	CChooseFileNamePage(	UINT id = 0, 
							   UINT defaultID = 0,
								UINT extID = 0,
								UINT filterID = 0,
								CString * pOutFileName = NULL,
                                CString  csAdditionalInfo = _T("")
								);
	~CChooseFileNamePage();

// Dialog Data
	//{{AFX_DATA(CChooseCAPage)
	CString	m_FileName;
	//}}AFX_DATA
	BOOL m_DoReplaceFile;
	UINT m_id, m_defaultID;
	CString ext, filter;
	CString * m_pOutFileName;
    CString m_AdditionalInfo;

// Overrides
	virtual void FileNameChanged() 
	{
	}
	virtual BOOL IsReadFileDlg()
	{
		ASSERT(FALSE);
		return FALSE;
	}
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChooseCAPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	public:
	virtual LRESULT OnWizardNext()
		{
			ASSERT(FALSE);
			return 1;
		}
	virtual LRESULT OnWizardBack();
	virtual BOOL OnSetActive();
	//}}AFX_VIRTUAL

// Implementation
protected:
	void GetDefaultFileName(CString& str);
	void Browse(CString& strPath, CString& strFile);
	LRESULT DoWizardNext(LRESULT id);
	// Generated message map functions
	//{{AFX_MSG(CChooseCAPage)
	afx_msg void OnBrowseBtn();
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeFileName();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

class CChooseReadFileName : public CChooseFileNamePage
{
	DECLARE_DYNCREATE(CChooseReadFileName)
// Construction
public:
	CChooseReadFileName(	UINT id = 0, 
							   UINT defaultID = 0,
								UINT extID = 0,
								UINT filterID = 0,
								CString * pOutFileName = NULL,
                                CString  csAdditionalInfo = _T("")
								);
	~CChooseReadFileName() 
	{
	}
// Overrides
	virtual void FileNameChanged() 
	{
	}
	virtual BOOL IsReadFileDlg()
	{
		return TRUE;
	}
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChooseCAPage)
	protected:
//	virtual void DoDataExchange(CDataExchange* pDX)
//		{
//			CChooseFileNamePage::DoDataExchange(pDX);
//		}
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack() {return 1;}
	virtual BOOL OnSetActive()
		{
			return CChooseFileNamePage::OnSetActive();
		}
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChooseCAPage)
	afx_msg void OnBrowseBtn();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

class CChooseWriteFileName : public CChooseFileNamePage
{
	DECLARE_DYNCREATE(CChooseWriteFileName)
// Construction
public:
	CChooseWriteFileName(UINT id = 0, 
							   UINT defaultID = 0,
								UINT extID = 0,
								UINT filterID = 0,
								CString * pOutFileName = NULL,
                                CString  csAdditionalInfo = _T("")
								);
	~CChooseWriteFileName() {}
// Overrides
	virtual void FileNameChanged() {}
	virtual BOOL IsReadFileDlg()
	{
		return FALSE;
	}
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChooseCAPage)
	protected:
//	virtual void DoDataExchange(CDataExchange* pDX)
//		{
//			CChooseFileNamePage::DoDataExchange(pDX);
//		}
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack() {return 1;}
	virtual BOOL OnSetActive()
		{
			return CChooseFileNamePage::OnSetActive();
		}
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChooseCAPage)
	afx_msg void OnBrowseBtn();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

class CChooseRespFile : public CChooseReadFileName
{
	DECLARE_DYNCREATE(CChooseRespFile)

// Construction
public:
	CChooseRespFile(CCertificate * pCert = NULL);
	~CChooseRespFile();

	enum
	{
		IDD_PAGE_PREV	= IDD_PAGE_WIZ_PENDING_WHAT_TODO,
		IDD_PAGE_NEXT	= IDD_PAGE_WIZ_INSTALL_RESP
#ifdef ENABLE_W3SVC_SSL_PAGE
      ,IDD_PAGE_NEXT_INSTALL_W3SVC_ONLY = IDD_PAGE_WIZ_GET_SSL_PORT
#endif
	};
// Dialog Data
	//{{AFX_DATA(CChooseRespFile)
	enum { IDD = IDD_PAGE_WIZ_GETRESP_FILE };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA
	CCertificate * m_pCert;


// Overrides
	virtual void FileNameChanged();
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChooseRespFile)
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChooseRespFile)
    afx_msg HBRUSH OnCtlColor(CDC * pDC, CWnd * pWnd, UINT nCtlColor);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

class CChooseReqFile : public CChooseWriteFileName
{
	DECLARE_DYNCREATE(CChooseReqFile)

// Construction
public:
	CChooseReqFile(CCertificate * pCert = NULL);
	~CChooseReqFile();

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_GEO_INFO,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_REQUEST_DUMP
	};
// Dialog Data
	//{{AFX_DATA(CChooseReqFile)
	enum { IDD = IDD_PAGE_WIZ_CHOOSE_FILENAME };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA
	CCertificate * m_pCert;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChooseReqFile)
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChooseReqFile)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

class CChooseReqFileRenew : public CChooseWriteFileName
{
	DECLARE_DYNCREATE(CChooseReqFileRenew)

// Construction
public:
	CChooseReqFileRenew(CCertificate * pCert = NULL);
	~CChooseReqFileRenew();

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_CHOOSE_CATYPE,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_REQUEST_DUMP_RENEW
	};
// Dialog Data
	//{{AFX_DATA(CChooseReqFileRenew)
	enum { IDD = IDD_PAGE_WIZ_CHOOSE_FILENAME_RENEW };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA
	CCertificate * m_pCert;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChooseReqFileRenew)
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChooseReqFileRenew)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

class CChooseKeyFile : public CChooseReadFileName
{
	DECLARE_DYNCREATE(CChooseKeyFile)

// Construction
public:
	CChooseKeyFile(CCertificate * pCert = NULL);
	~CChooseKeyFile();

	enum
	{
		IDD_PAGE_PREV	= IDD_PAGE_WIZ_GET_WHAT,
		IDD_PAGE_NEXT	= IDD_PAGE_WIZ_GET_PASSWORD,
	};
// Dialog Data
	//{{AFX_DATA(CChooseKeyFile)
	enum { IDD = IDD_PAGE_WIZ_GETKEY_FILE };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA
	CCertificate * m_pCert;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChooseKeyFile)
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChooseKeyFile)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};


class CChooseImportPFXFile : public CChooseReadFileName
{
	DECLARE_DYNCREATE(CChooseImportPFXFile)

// Construction
public:
	CChooseImportPFXFile(CCertificate * pCert = NULL);
	~CChooseImportPFXFile();

	enum
	{
		IDD_PAGE_PREV	= IDD_PAGE_WIZ_GET_WHAT,
		IDD_PAGE_NEXT	= IDD_PAGE_WIZ_GET_IMPORT_PFX_PASSWORD,
	};
// Dialog Data
	//{{AFX_DATA(CChooseImportPFXFile)
	enum { IDD = IDD_PAGE_WIZ_GET_IMPORT_PFX_FILE };
    BOOL m_MarkAsExportable;
	//}}AFX_DATA
	CCertificate * m_pCert;
    

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChooseImportPFXFile)
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChooseImportPFXFile)
		// NOTE: the ClassWizard will add member functions here
    afx_msg void OnExportable();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


class CChooseExportPFXFile : public CChooseWriteFileName
{
	DECLARE_DYNCREATE(CChooseExportPFXFile)

// Construction
public:
	CChooseExportPFXFile(CCertificate * pCert = NULL);
	~CChooseExportPFXFile();

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_MANAGE_CERT,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_GET_EXPORT_PFX_PASSWORD,
	};
// Dialog Data
	//{{AFX_DATA(CChooseExportPFXFile)
	enum { IDD = IDD_PAGE_WIZ_GET_EXPORT_PFX_FILE };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA
	CCertificate * m_pCert;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChooseExportPFXFile)
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChooseExportPFXFile)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(_CHOOSEFILENAMEPAGE_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\chooseserverpages.h ===
// ChooseServerPages.h: interface for the CChooseServerPages class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_CHOOSESERVERPAGES_H__CB354F31_7FB7_4909_B605_F5F8B037914C__INCLUDED_)
#define AFX_CHOOSESERVERPAGES_H__CB354F31_7FB7_4909_B605_F5F8B037914C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CChooseServerPages dialog
class CCertificate;

class CChooseServerPages : public CIISWizardPage
{
	DECLARE_DYNCREATE(CChooseServerPages)

// Construction
public:
	CChooseServerPages(CCertificate * pCert = NULL);
	~CChooseServerPages();

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_CHOOSE_COPY_MOVE_FROM_REMOTE,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_CHOOSE_SERVER_SITE
	};
// Dialog Data
	//{{AFX_DATA(CChooseServerPages)
	enum { IDD = IDD_PAGE_WIZ_CHOOSE_SERVER };
	CString	m_ServerName;
    CString	m_UserName;
    CStrPassword m_UserPassword;
	//}}AFX_DATA
	CCertificate * m_pCert;

    

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChooseServerPages)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	virtual BOOL OnSetActive();
	virtual BOOL OnKillActive();
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChooseServerPages)
	afx_msg void OnEditchangeServerName();
    afx_msg void OnEditchangeUserName();
    afx_msg void OnEditchangeUserPassword();
    afx_msg void OnBrowseForMachine();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};


class CChooseServerPagesTo : public CIISWizardPage
{
	DECLARE_DYNCREATE(CChooseServerPagesTo)

// Construction
public:
	CChooseServerPagesTo(CCertificate * pCert = NULL);
	~CChooseServerPagesTo();

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_CHOOSE_COPY_MOVE_TO_REMOTE,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_CHOOSE_SERVER_SITE_TO
	};
// Dialog Data
	//{{AFX_DATA(CChooseServerPagesTo)
	enum { IDD = IDD_PAGE_WIZ_CHOOSE_SERVER_TO };
	CString	m_ServerName;
    CString	m_UserName;
    CStrPassword m_UserPassword;
	//}}AFX_DATA
	CCertificate * m_pCert;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChooseServerPagesTo)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	virtual BOOL OnSetActive();
	virtual BOOL OnKillActive();
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChooseServerPagesTo)
	afx_msg void OnEditchangeServerName();
    afx_msg void OnEditchangeUserName();
    afx_msg void OnEditchangeUserPassword();
    afx_msg void OnBrowseForMachine();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};


#endif // !defined(AFX_CHOOSESERVERPAGES_H__CB354F31_7FB7_4909_B605_F5F8B037914C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\chooseserversite.h ===
#if !defined(AFX_CHOOSESERVERSITE_H__25260090_DB36_49E2_9435_7519047DDF49__INCLUDED_)
#define AFX_CHOOSESERVERSITE_H__25260090_DB36_49E2_9435_7519047DDF49__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ChooseServerSite.h : header file
//
#include "Certificat.h"

/////////////////////////////////////////////////////////////////////////////
// CChooseServerSite window

class CCertificate;


class CCertListCtrl : public CListCtrl
{
public:
	int GetSelectedIndex();
	void AdjustStyle();
};



class CChooseServerSite : public CDialog
{

// Construction
public:
    CChooseServerSite(BOOL bShowOnlyCertSites, CString& strSiteReturned, CCertificate * pCert = NULL,IN CWnd * pParent = NULL OPTIONAL);
    ~CChooseServerSite();

// Dialog Data
    //{{AFX_DATA(CChooseServerSite)
    enum {IDD = IDD_DIALOG_CHOOSE_SITE};
    CCertListCtrl m_ServerSiteList;
    //}}AFX_DATA
    CCertificate * m_pCert;
    CString m_strSiteReturned;
    int m_Index;
    BOOL m_ShowOnlyCertSites;

// Overrides
	//{{AFX_VIRTUAL(CChooseServerSite)
	protected:
    virtual void DoDataExchange(CDataExchange * pDX);
	//}}AFX_VIRTUAL

	// Generated message map functions
protected:
	//{{AFX_MSG(CChooseServerSite)
    virtual BOOL OnInitDialog();
    virtual void OnOK();
	afx_msg void OnClickSiteList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnDblClickSiteList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnDestroy();
    afx_msg void OnKeydown(NMHDR* pNMHDR, LRESULT* pResult);
    
	//}}AFX_MSG
    BOOL FillListWithMetabaseSiteDesc();

	DECLARE_MESSAGE_MAP()
private:
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CHOOSESERVERSITE_H__25260090_DB36_49E2_9435_7519047DDF49__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\copymovecertremotepage.cpp ===
// CopyMoveCertRemotePage.cpp : implementation file
//

#include "stdafx.h"
#include "certwiz.h"
#include "CopyMoveCertRemotePage.h"
#include "Certificat.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCopyMoveCertFromRemotePage property page

IMPLEMENT_DYNCREATE(CCopyMoveCertFromRemotePage, CIISWizardPage)

CCopyMoveCertFromRemotePage::CCopyMoveCertFromRemotePage(CCertificate * pCert)
	: CIISWizardPage(CCopyMoveCertFromRemotePage::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CCopyMoveCertFromRemotePage)
    m_Index = -1;
    m_MarkAsExportable = FALSE;
	//}}AFX_DATA_INIT
}

CCopyMoveCertFromRemotePage::~CCopyMoveCertFromRemotePage()
{
}

void CCopyMoveCertFromRemotePage::DoDataExchange(CDataExchange* pDX)
{
    CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCopyMoveCertFromRemotePage)
    DDX_Check(pDX, IDC_MARK_AS_EXPORTABLE, m_MarkAsExportable);
    DDX_Radio(pDX, IDC_COPY_FROM_REMOTE, m_Index);
	//}}AFX_DATA_MAP
}

void CCopyMoveCertFromRemotePage::OnExportable() 
{
   UpdateData();
}

BEGIN_MESSAGE_MAP(CCopyMoveCertFromRemotePage, CIISWizardPage)
	//{{AFX_MSG_MAP(CCopyMoveCertFromRemotePage)
	ON_BN_CLICKED(IDC_MARK_AS_EXPORTABLE, OnExportable)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCopyMoveCertFromRemotePage message handlers

LRESULT CCopyMoveCertFromRemotePage::OnWizardBack() 
{
	return IDD_PAGE_PREV;
}

LRESULT CCopyMoveCertFromRemotePage::OnWizardNext() 
{
	LRESULT res = 1;
	UpdateData();
	switch (m_Index)
	{
	case CONTINUE_COPY_FROM_REMOTE:
        m_pCert->m_DeleteAfterCopy = FALSE;
        m_pCert->m_MarkAsExportable = m_MarkAsExportable;
		res = IDD_PAGE_NEXT_COPY_FROM_REMOTE;
		break;
	case CONTINUE_MOVE_FROM_REMOTE:
        m_pCert->m_DeleteAfterCopy = TRUE;
        m_pCert->m_MarkAsExportable = m_MarkAsExportable;
		res = IDD_PAGE_NEXT_MOVE_FROM_REMOTE;
		break;
	}
	return res;
}

BOOL CCopyMoveCertFromRemotePage::OnSetActive() 
{
	m_pCert->SetStatusCode(CCertificate::REQUEST_UNDEFINED);
	SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);
	return CIISWizardPage::OnSetActive();
}

BOOL CCopyMoveCertFromRemotePage::OnInitDialog() 
{
	m_Index = 0;
	CIISWizardPage::OnInitDialog();

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CCopyMoveCertToRemotePage property page

IMPLEMENT_DYNCREATE(CCopyMoveCertToRemotePage, CIISWizardPage)

CCopyMoveCertToRemotePage::CCopyMoveCertToRemotePage(CCertificate * pCert)
	: CIISWizardPage(CCopyMoveCertToRemotePage::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CCopyMoveCertToRemotePage)
    m_Index = -1;
    m_MarkAsExportable = FALSE;
	//}}AFX_DATA_INIT
}

CCopyMoveCertToRemotePage::~CCopyMoveCertToRemotePage()
{
}

void CCopyMoveCertToRemotePage::DoDataExchange(CDataExchange* pDX)
{
    CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCopyMoveCertToRemotePage)
    DDX_Check(pDX, IDC_MARK_AS_EXPORTABLE, m_MarkAsExportable);
    DDX_Radio(pDX, IDC_COPY_TO_REMOTE, m_Index);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCopyMoveCertToRemotePage, CIISWizardPage)
	//{{AFX_MSG_MAP(CCopyMoveCertToRemotePage)
	ON_BN_CLICKED(IDC_MARK_AS_EXPORTABLE, OnExportable)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCopyMoveCertToRemotePage message handlers

LRESULT CCopyMoveCertToRemotePage::OnWizardBack() 
{
	return IDD_PAGE_PREV;
}

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
LRESULT CCopyMoveCertToRemotePage::OnWizardNext() 
{
	LRESULT res = 1;
	UpdateData();

	switch (m_Index)
	{
	case CONTINUE_COPY_TO_REMOTE:
		//m_pCert->SetStatusCode(CCertificate::REQUEST_COPYREMOTE_CERT);
        m_pCert->m_DeleteAfterCopy = FALSE;
        m_pCert->m_MarkAsExportable = m_MarkAsExportable;
		res = IDD_PAGE_NEXT_COPY_TO_REMOTE;
		break;
	case CONTINUE_MOVE_TO_REMOTE:
        m_pCert->m_DeleteAfterCopy = TRUE;
        m_pCert->m_MarkAsExportable = m_MarkAsExportable;
		res = IDD_PAGE_NEXT_MOVE_TO_REMOTE;
		break;
	}

	return res;
}

BOOL CCopyMoveCertToRemotePage::OnSetActive() 
{
	m_pCert->SetStatusCode(CCertificate::REQUEST_UNDEFINED);
	SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);
	return CIISWizardPage::OnSetActive();
}

BOOL CCopyMoveCertToRemotePage::OnInitDialog() 
{
	m_Index = 0;
	CIISWizardPage::OnInitDialog();
    // we should make some checks and disable some buttons
    if (!m_pCert->m_CertObjInstalled)
	{
		ASSERT(NULL != GetDlgItem(IDC_COPY_TO_REMOTE));
        ASSERT(NULL != GetDlgItem(IDC_MOVE_TO_REMOTE));
		GetDlgItem(IDC_COPY_TO_REMOTE)->EnableWindow(FALSE);
        GetDlgItem(IDC_MOVE_TO_REMOTE)->EnableWindow(FALSE);
	}
	return TRUE;
}

void CCopyMoveCertToRemotePage::OnExportable() 
{
   UpdateData();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\chooseserversite.cpp ===
// ChooseServerSite.cpp : implementation file
//

#include "stdafx.h"
#include "certwiz.h"
#include "Certificat.h"
#include "CertUtil.h"
#include "ChooseServerSite.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define COL_SITE_INSTANCE     0
#define COL_SITE_DESC         1
#define COL_SITE_INSTANCE_WID 50
#define COL_SITE_DESC_WID     100

/////////////////////////////////////////////////////////////////////////////
// CChooseServerSite


CChooseServerSite::CChooseServerSite(BOOL bShowOnlyCertSites, CString& strSiteReturned,CCertificate * pCert,IN CWnd * pParent OPTIONAL) 
: CDialog(CChooseServerSite::IDD,pParent)
{
    m_ShowOnlyCertSites = bShowOnlyCertSites;
    m_strSiteReturned = strSiteReturned;
    m_pCert = pCert;
	//{{AFX_DATA_INIT(CChooseServerSite)
	//}}AFX_DATA_INIT
}

CChooseServerSite::~CChooseServerSite()
{
}

void CChooseServerSite::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChooseServerSite)
	DDX_Control(pDX, IDC_SITE_LIST, m_ServerSiteList);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CChooseServerSite, CDialog)
	//{{AFX_MSG_MAP(CChooseServerSite)
    ON_NOTIFY(NM_CLICK, IDC_SITE_LIST, OnClickSiteList)
    ON_NOTIFY(NM_DBLCLK, IDC_SITE_LIST, OnDblClickSiteList)
    ON_NOTIFY(LVN_KEYDOWN, IDC_SITE_LIST, OnKeydown)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChooseServerSite message handlers

BOOL CChooseServerSite::OnInitDialog()
{
	CDialog::OnInitDialog();
    HRESULT hr;
    CString MachineName_Remote;
    CString UserName_Remote;
    CString UserPassword_Remote;
    CString SiteToExclude;
    CMapStringToString MetabaseSiteKeyWithSiteDescValueList;
    CStringListEx strlDataPaths;

	CCertListCtrl* pControl = (CCertListCtrl *)CWnd::FromHandle(GetDlgItem(IDC_SITE_LIST)->m_hWnd);
	CRect rcControl;
	pControl->GetClientRect(&rcControl);

    // make the list have column headers
	CString str;
    str= _T("");

    str.LoadString(IDS_SITE_NUM_COLUMN);
	m_ServerSiteList.InsertColumn(COL_SITE_INSTANCE, str, LVCFMT_LEFT, COL_SITE_INSTANCE_WID);

	str.LoadString(IDS_WEB_SITE_COLUMN);
	m_ServerSiteList.InsertColumn(COL_SITE_DESC, str, LVCFMT_LEFT, rcControl.Width() - COL_SITE_INSTANCE_WID);

	m_ServerSiteList.AdjustStyle();

    // Use machine/username/userpassword
    // to connect to the machine
    // and enumerate all the sites on that machine.
    // return back a string1=string2 pair
    // string1 = /w3svc/1
    // string2 = "site description"

    // present a dialog so the user can choose which one they want...
    // m_ServerSiteInstance = /w3svc/1
    // m_ServerSiteDescription = "site description"

    MachineName_Remote = m_pCert->m_MachineName_Remote;
    UserName_Remote = m_pCert->m_UserName_Remote;

    m_pCert->m_UserPassword_Remote.CopyTo(UserPassword_Remote);

    SiteToExclude = m_pCert->m_WebSiteInstanceName;

    if (m_ShowOnlyCertSites)
    {
        hr = EnumSitesWithCertInstalled(MachineName_Remote,UserName_Remote,UserPassword_Remote,m_pCert->m_WebSiteInstanceName,SiteToExclude,&strlDataPaths);
    }
    else
    {
        hr = EnumSites(MachineName_Remote,UserName_Remote,UserPassword_Remote,m_pCert->m_WebSiteInstanceName,SiteToExclude,&strlDataPaths);
    }

    if (!strlDataPaths.IsEmpty())
    {
        POSITION pos;
        CString name;
        CString value = _T("");
        CString SiteInstance;

        int item = 0;
        LV_ITEMW lvi;

    	//
		// set up the fields in the list view item struct that don't change from item to item
		//
		memset(&lvi, 0, sizeof(LV_ITEMW));
		lvi.mask = LVIF_TEXT;

        // loop thru the list and display all the stuff on a dialog box...
        pos = strlDataPaths.GetHeadPosition();
        while (pos) 
        {
            int i = 0;
            name = strlDataPaths.GetAt(pos);

            value = _T("");
            
            SiteInstance.Format(_T("%d"), CMetabasePath::GetInstanceNumber(name));
			lvi.iItem = item;
			lvi.iSubItem = COL_SITE_INSTANCE;
			lvi.pszText = (LPTSTR)(LPCTSTR)SiteInstance;
			lvi.cchTextMax = SiteInstance.GetLength();
			i = m_ServerSiteList.InsertItem(&lvi);
			ASSERT(i != -1);

			lvi.iItem = i;
			lvi.iSubItem = COL_SITE_DESC;
			lvi.pszText = (LPTSTR)(LPCTSTR)value;
			lvi.cchTextMax = value.GetLength();
			VERIFY(m_ServerSiteList.SetItem(&lvi));

            // set item data with the pointer to the Strings
            CString * pDataItemString = new CString(name);
            VERIFY(m_ServerSiteList.SetItemData(item, (LONG_PTR)pDataItemString));

			item++;
            strlDataPaths.GetNext(pos);
        }

        FillListWithMetabaseSiteDesc();
    }

    GetDlgItem(IDOK)->EnableWindow(FALSE);
	return TRUE;
}


BOOL CChooseServerSite::FillListWithMetabaseSiteDesc()
{
	int count = m_ServerSiteList.GetItemCount();
    CString strMetabaseKey;
    CString value = _T("");
    CString strDescription;
    HRESULT hr = E_FAIL;
    CString MachineName_Remote;
    CString UserName_Remote;
    CString UserPassword_Remote;
    MachineName_Remote = m_pCert->m_MachineName_Remote;
    UserName_Remote = m_pCert->m_UserName_Remote;

    m_pCert->m_UserPassword_Remote.CopyTo(UserPassword_Remote);

    CString * pMetabaseKey;

    for (int index = 0; index < count; index++)
    {
        pMetabaseKey = (CString *) m_ServerSiteList.GetItemData(index);
        if (pMetabaseKey)
        {
            strMetabaseKey = *pMetabaseKey;
            // Go get the site's description;
            if (TRUE == GetServerComment(MachineName_Remote,UserName_Remote,UserPassword_Remote,strMetabaseKey,strDescription,&hr))
            {
                value = strDescription;
            }
            else
            {
                value = strMetabaseKey;
            }
            m_ServerSiteList.SetItemText(index, COL_SITE_DESC,value);
        }
    }

    return TRUE;
}

void CChooseServerSite::OnDblClickSiteList(NMHDR* pNMHDR, LRESULT* pResult)
{
    // Get the hash for the certificate that is clicked on...
    m_Index = m_ServerSiteList.GetSelectedIndex();
    if (m_Index != -1)
    {
        // Get the metabase key..
        CString * pMetabaseKey = NULL;
        pMetabaseKey = (CString *) m_ServerSiteList.GetItemData(m_Index);
        if (pMetabaseKey)
        {
            m_strSiteReturned = *pMetabaseKey;
            // use the metabase key to lookup the hash
	        // find cert in store
            CRYPT_HASH_BLOB * pHash = NULL;
            HRESULT hr;
            // go lookup the certhash from the metabase
            if (0 == _tcsicmp(m_pCert->m_MachineName_Remote,m_pCert->m_MachineName))
            {
		        pHash = GetInstalledCertHash(m_pCert->m_MachineName_Remote,m_strSiteReturned,m_pCert->GetEnrollObject(),&hr);
                if (pHash)
                {
                    ViewCertificateDialog(pHash,m_hWnd);
                    if (pHash){CoTaskMemFree(pHash);}
                }
            }
        }
        GetDlgItem(IDOK)->EnableWindow(TRUE);
    }
    return;
}

void CChooseServerSite::OnOK() 
{
	m_Index = m_ServerSiteList.GetSelectedIndex();
    m_strSiteReturned = _T("");
    if (m_Index != -1)
    {
        CString * pMetabaseKey = NULL;
        pMetabaseKey = (CString *) m_ServerSiteList.GetItemData(m_Index);
        if (pMetabaseKey)
        {
            m_strSiteReturned = *pMetabaseKey;

            if (m_ShowOnlyCertSites)
            {
                CString csPasswordTemp;
                m_pCert->m_UserPassword_Remote.CopyTo(csPasswordTemp);

                // check if the returned site has an exportable certificate on it...
                if (FALSE == IsCertExportableOnRemoteMachine(m_pCert->m_MachineName_Remote,m_pCert->m_UserName_Remote,csPasswordTemp,m_strSiteReturned))
                {
                    // tell the user that certificat that they chose is not exportable.
                    CString buf;
                    buf.LoadString(IDS_CERT_NOT_EXPORTABLE);
                    AfxMessageBox(buf, MB_OK);
                    return;
                }
            }
        }
    }

    CDialog::OnOK();
}

void CChooseServerSite::OnClickSiteList(NMHDR* pNMHDR, LRESULT* pResult)
{
    m_Index = m_ServerSiteList.GetSelectedIndex();
    if (m_Index != -1)
    {
        GetDlgItem(IDOK)->EnableWindow(TRUE);
    }
    else
    {
        GetDlgItem(IDOK)->EnableWindow(FALSE);
    }

	*pResult = 0;
}


void CChooseServerSite::OnDestroy()
{
	// before dialog will be desroyed we need to delete all
	// the item data pointers
	int count = m_ServerSiteList.GetItemCount();
	for (int index = 0; index < count; index++)
	{
		CString * pData = (CString *) m_ServerSiteList.GetItemData(index);
		delete pData;
	}
	CDialog::OnDestroy();
}


void CChooseServerSite::OnKeydown(NMHDR* pNMHDR, LRESULT* pResult) 
{
    m_Index = m_ServerSiteList.GetSelectedIndex();
    if (m_Index != -1)
    {
        GetDlgItem(IDOK)->EnableWindow(TRUE);
    }
    else
    {
        GetDlgItem(IDOK)->EnableWindow(FALSE);
    }
    *pResult = 0;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\chooseserversitepages.h ===
// ChooseServerSitePages.h: interface for the CChooseServerSitePages class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_CHOOSESERVERSITEPAGES_H__B545F741_C25F_410C_93F6_56F98A5911BC__INCLUDED_)
#define AFX_CHOOSESERVERSITEPAGES_H__B545F741_C25F_410C_93F6_56F98A5911BC__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CChooseServerSitePages dialog
class CCertificate;

class CChooseServerSitePages : public CIISWizardPage
{
	DECLARE_DYNCREATE(CChooseServerSitePages)

// Construction
public:
	CChooseServerSitePages(CCertificate * pCert = NULL);
	~CChooseServerSitePages();

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_CHOOSE_SERVER,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_INSTALL_COPY_FROM_REMOTE,
        IDD_PAGE_NEXT2 = IDD_PAGE_WIZ_INSTALL_MOVE_FROM_REMOTE
	};
// Dialog Data
	//{{AFX_DATA(CChooseServerSitePages)
	enum { IDD = IDD_PAGE_WIZ_CHOOSE_SERVER_SITE };
    CString	m_ServerSiteDescription;
	DWORD m_ServerSiteInstance;
    CString	m_ServerSiteInstancePath;
	//}}AFX_DATA
	CCertificate * m_pCert;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChooseServerSitePages)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	virtual BOOL OnSetActive();
	virtual BOOL OnKillActive();
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChooseServerSitePages)
	afx_msg void OnEditchangeServerSiteName();
    afx_msg void OnBrowseForMachineWebSite();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};




class CChooseServerSitePagesTo : public CIISWizardPage
{
	DECLARE_DYNCREATE(CChooseServerSitePagesTo)

// Construction
public:
	CChooseServerSitePagesTo(CCertificate * pCert = NULL);
	~CChooseServerSitePagesTo();

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_CHOOSE_SERVER_TO,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_INSTALL_COPY_TO_REMOTE,
        IDD_PAGE_NEXT2 = IDD_PAGE_WIZ_INSTALL_MOVE_TO_REMOTE
	};
// Dialog Data
	//{{AFX_DATA(CChooseServerSitePagesTo)
	enum { IDD = IDD_PAGE_WIZ_CHOOSE_SERVER_SITE_TO };
    CString	m_ServerSiteDescription;
	DWORD m_ServerSiteInstance;
    CString	m_ServerSiteInstancePath;
	//}}AFX_DATA
	CCertificate * m_pCert;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChooseServerSitePagesTo)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	virtual BOOL OnSetActive();
	virtual BOOL OnKillActive();
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChooseServerSitePagesTo)
	afx_msg void OnEditchangeServerSiteName();
    afx_msg void OnBrowseForMachineWebSite();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

#endif // !defined(AFX_CHOOSESERVERSITEPAGES_H__B545F741_C25F_410C_93F6_56F98A5911BC__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\countrycombobox.cpp ===
// CountryComboBox.cpp : implementation file
//

#include "stdafx.h"
#include "CertWiz.h"
#include "CountryComboBox.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

BEGIN_MESSAGE_MAP(CComboEdit, CEdit)
	ON_WM_CHAR()
END_MESSAGE_MAP()

void CComboEdit::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	if (m_pParent->OnEditChar(nChar))
    {
		CEdit::OnChar(nChar, nRepCnt, nFlags);
    }
}

BOOL CComboEdit::SubclassDlgItem(UINT nID, CCountryComboBox * pParent)
{
	ASSERT(pParent != NULL);
	m_pParent = pParent;
	return CEdit::SubclassDlgItem(nID, pParent);
}

BOOL CCountryComboBox::OnEditChar(UINT nChar)
{
	int index;
	int len = m_strInput.GetLength();

    if ( ((nChar == VK_ESCAPE) || (nChar == VK_RETURN) || (nChar == VK_TAB)) &&
         GetDroppedState() ) 
    {
        // hide the dropdown
        ShowDropDown(FALSE);
    }

    if (nChar == VK_RETURN)
    {
        // Check if there is something selected...
        index = GetCurSel();
        if (index != -1)
        {
			m_Index = index;
			SetCurSel(m_Index);
			SetEditSel(0, m_strInput.GetLength());
            return TRUE;
        }
    }

	if (nChar == VK_ESCAPE)
	{
		if (len == 0)
		{
			MessageBeep(MB_ICONQUESTION);
            return FALSE;
		}
		m_strInput.Empty();
		len = 0;
        return FALSE;
	}
	else if (nChar == VK_BACK)
	{
		if (len == 0)
		{
			MessageBeep(MB_ICONQUESTION);
			return FALSE;
		}
		m_strInput.ReleaseBuffer(--len);
	}
	else if (_istalpha((TCHAR) nChar) || VK_SPACE == nChar)
	{
		m_strInput += (TCHAR)nChar;
		len++;
	}
	else
	{
		MessageBeep(MB_ICONQUESTION);
		return FALSE;
	}

	if (len > 0 && len <= 2)
	{
		if (CB_ERR != (index = FindString(-1, m_strInput)))
		{
			m_Index = index;
			SetCurSel(m_Index);
			SetEditSel(0, m_strInput.GetLength());
		}
		else
		{
			// try to find it in country names list
			index = -1;
			POSITION pos = m_map_name_code.GetStartPosition();
			int i = 0;
			while (pos != NULL)
			{
				CString name, code;
				m_map_name_code.GetNextAssoc(pos, name, code);
				if (0 == _tcsnicmp(name, m_strInput, len))
				{
					index = i;
					break;
				}
				i++;
			}
			if (index != -1)
			{
				m_Index = index;
				SetCurSel(m_Index);
				SetEditSel(4, len);
			}
			else
			{
				m_strInput.ReleaseBuffer(--len);
				MessageBeep(MB_ICONQUESTION);
			}
		}
	}
	else if (len > 2)
	{
		// try to find it in country names list
		index = -1;
		POSITION pos = m_map_name_code.GetStartPosition();
		while (pos != NULL)
		{
			CString name, code;
			m_map_name_code.GetNextAssoc(pos, name, code);
			if (0 == _tcsnicmp(name, m_strInput, len))
			{
				index = FindString(-1, code);
				break;
			}
		}
		if (index != -1)
		{
			m_Index = index;
			SetCurSel(m_Index);
			SetEditSel(4, 4+len);
		}
		else
		{
			m_strInput.ReleaseBuffer(--len);
			MessageBeep(MB_ICONQUESTION);
		}
	}
	else
	{
		// just remove selection
		SetEditSel(-1, 0);
	}
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CCountryComboBox

CCountryComboBox::CCountryComboBox()
{
}

CCountryComboBox::~CCountryComboBox()
{
}

#define IDC_COMBOEDIT 1001

BOOL
CCountryComboBox::SubclassDlgItem(UINT nID, CWnd * pParent)
{
	return CComboBox::SubclassDlgItem(nID, pParent)
		&& m_edit.SubclassDlgItem(IDC_COMBOEDIT, this);
}

BOOL
CCountryComboBox::Init()
{
	BOOL rc = FALSE;
   CString strData, strCode, strName, str;
   for (int i = IDS_COUNTRIES_FIRST;; i++)
   {
      if (!strData.LoadString(i))
      {
         break;
      }
      if (strData.IsEmpty())
      {
         rc = TRUE;
         break;
      }
      strCode = strData.Left(2);
      strName = strData.Right(strData.GetLength() - 2);
      str = strCode;
      str += _T(" (");
      str += strName;
      str += _T(")");
	  if (CB_ERR == AddString(str))
	     break;
	  m_map_name_code.SetAt(strName, strCode);
   }
	return rc;
}


#define MAX_COUNTRY_NAME	64
#define MAX_COUNTRY_CODE	10
void CCountryComboBox::SetSelectedCountry(CString& country_code)
{
	int index;
    TCHAR szCountryName[MAX_COUNTRY_NAME+1];
    TCHAR sz3CharCountryCode[MAX_COUNTRY_CODE+1];
    int iRet = GetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_SISO3166CTRYNAME, sz3CharCountryCode, MAX_COUNTRY_CODE);
    iRet = GetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_SCOUNTRY, szCountryName, MAX_COUNTRY_NAME);

    if (country_code.IsEmpty())
	{
        // Try to look it up from the country name
        // i know this is kind of weird since we can look it up from
        // the countrycode, but this code has been like this for a while
        // and i don't want to break anything
		m_map_name_code.Lookup(szCountryName, country_code);
	}
	if (!country_code.IsEmpty() && CB_ERR != (index = FindString(-1, country_code) ))
	{
        SetCurSel(index);
    }
	else
    {
        int len = 0;
        POSITION pos = NULL;
        CString name, code;
        //IISDebugOutput((_T("No Match for:%s\n"),szCountryName));

        // we didn't find a match
        // try looping thru the m_map_name_code
        // to find a matching country code
        index = -1;
        len = _tcslen(sz3CharCountryCode);
		pos = m_map_name_code.GetStartPosition();
		while (pos != NULL)
		{
			m_map_name_code.GetNextAssoc(pos, name, code);
			if (0 == _tcsnicmp(code, sz3CharCountryCode, len))
			{
				index = FindString(-1, code);
				break;
			}
		}

        if (index == -1)
        {
            // if we still didn't find it
            // then search thru the list and look for a similiar
            // looking country name
            index = -1;
            len = _tcslen(szCountryName);
		    pos = m_map_name_code.GetStartPosition();
		    while (pos != NULL)
		    {
			    m_map_name_code.GetNextAssoc(pos, name, code);
			    if (0 == _tcsnicmp(name, szCountryName, len))
			    {
				    index = FindString(-1, code);
				    break;
			    }
		    }
        }
		if (index != -1)
		{
            SetCurSel(index);
		}
        else
        {
            SetCurSel(0);
        }
    }
}

void CCountryComboBox::GetSelectedCountry(CString& country_code)
{
	CString str;
	GetLBText(GetCurSel(), str);
	country_code = str.Left(2);
}

BEGIN_MESSAGE_MAP(CCountryComboBox, CComboBox)
	//{{AFX_MSG_MAP(CCountryComboBox)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCountryComboBox message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\chooseserversitepages.cpp ===
// ChooseServerSitePages.cpp: implementation of the CChooseServerSitePages class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "certwiz.h"
#include "Certificat.h"
#include "Certutil.h"
#include "ChooseServerSite.h"
#include "ChooseServerSitePages.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif


static BOOL
AnswerIsYes3(UINT id)
{
	CString strMessage;
    strMessage.LoadString(id);
	return (IDYES == AfxMessageBox(strMessage, MB_ICONEXCLAMATION | MB_YESNO | MB_DEFBUTTON2));
}

/////////////////////////////////////////////////////////////////////////////
// CChooseServerSitePages property page

IMPLEMENT_DYNCREATE(CChooseServerSitePages, CIISWizardPage)

CChooseServerSitePages::CChooseServerSitePages(CCertificate * pCert) 
	: CIISWizardPage(CChooseServerSitePages::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CChooseServerSitePages)
	m_ServerSiteInstance = 0;
    m_ServerSiteInstancePath = _T("");
    m_ServerSiteDescription = _T("");
	//}}AFX_DATA_INIT
}

CChooseServerSitePages::~CChooseServerSitePages()
{
}

void CChooseServerSitePages::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChooseServerSitePages)
	DDX_Text(pDX, IDC_SERVER_SITE_NAME, m_ServerSiteInstance);
	//}}AFX_DATA_MAP
}

LRESULT 
CChooseServerSitePages::OnWizardBack()
/*++
Routine Description:
    Prev button handler

Arguments:
    None

Return Value:
	0 to automatically advance to the prev page;
	1 to prevent the page from changing. 
	To jump to a page other than the prev one, 
	return the identifier of the dialog to be displayed.
--*/
{
	return IDD_PAGE_PREV;
}

LRESULT 
CChooseServerSitePages::OnWizardNext()
{
    LRESULT lres = 1;
    BOOL bCertificateExists = FALSE;
    CString csInstanceName;
    CString UserPassword_Remote;
    m_ServerSiteInstance = -1;
	UpdateData(TRUE);

    m_pCert->m_UserPassword_Remote.CopyTo(UserPassword_Remote);

    if (m_ServerSiteInstance != -1)
    {
        // Get the site # and create an instance path
        csInstanceName = ReturnGoodMetabaseServerPath(m_pCert->m_WebSiteInstanceName);
        csInstanceName += _T("/%d");

        m_ServerSiteInstancePath.Format(csInstanceName,m_ServerSiteInstance);
        m_pCert->m_WebSiteInstanceName_Remote = m_ServerSiteInstancePath;

        // Check if this is a local to local copy that
        // we are not copy/moving to the same local site that we're on!
        if (TRUE == IsMachineLocal(m_pCert->m_MachineName_Remote, m_pCert->m_UserName_Remote, UserPassword_Remote))
        {
            CString SiteToExclude = m_pCert->m_WebSiteInstanceName;
            CString SiteToLookAt = m_ServerSiteInstancePath;

            // We are on the local machine!!!
            // make sure it's not the same web site
            // if it is then popup a msgbox!!!!!!
            if (SiteToLookAt.Left(1) == _T("/"))
            {
                if (SiteToExclude.Left(1) != _T("/"))
                    {SiteToExclude = _T("/") + SiteToExclude;}
            }
            if (SiteToLookAt.Right(1) == _T("/"))
            {
                if (SiteToExclude.Right(1) != _T("/"))
                    {SiteToExclude = SiteToExclude + _T("/");}
            }

            if (0 == _tcsicmp(SiteToLookAt,SiteToExclude))
            {
                // Cannot do this, popup messagebox
                AfxMessageBox(IDS_NOT_TO_ITSELF);
                lres = 1;
                goto CChooseServerSitePages_OnWizardNext_Exit;
            }
        }

        // Check if the specified path actually exists!!!!!!!
        if (FALSE == IsWebSiteExistRemote(m_pCert->m_MachineName_Remote, m_pCert->m_UserName_Remote, UserPassword_Remote, m_ServerSiteInstancePath, &bCertificateExists))
        {
            AfxMessageBox(IDS_SITE_NOT_EXIST);
            lres = 1;
        }
        else
        {
            // Check if Certificate Exist...
            if (!bCertificateExists)
            {
                AfxMessageBox(IDS_CERT_NOT_EXIST_ON_SITE);
                lres = 1;
            }
            else
            {
                if (m_pCert->m_DeleteAfterCopy)
                {
                    lres = IDD_PAGE_NEXT2;
                }
                else
                {
                    lres = IDD_PAGE_NEXT;
                }

                // Get info for that cert from remote site...
                CERT_DESCRIPTION desc;
                CString MachineName_Remote = m_pCert->m_MachineName_Remote;
                CString UserName_Remote = m_pCert->m_UserName_Remote;
                GetCertDescInfo(MachineName_Remote,UserName_Remote,UserPassword_Remote,m_ServerSiteInstancePath,&desc);

	            m_pCert->m_CommonName = desc.m_CommonName;
	            m_pCert->m_FriendlyName = desc.m_FriendlyName;
	            m_pCert->m_Country = desc.m_Country;
	            m_pCert->m_State = desc.m_State;
	            m_pCert->m_Locality = desc.m_Locality;
	            m_pCert->m_Organization = desc.m_Organization;
	            m_pCert->m_OrganizationUnit = desc.m_OrganizationUnit;
                m_pCert->m_CAName = desc.m_CAName;
                m_pCert->m_ExpirationDate = desc.m_ExpirationDate;
                m_pCert->m_Usage = desc.m_Usage;
            }
        }
    }

CChooseServerSitePages_OnWizardNext_Exit:
	return lres;
}

BOOL 
CChooseServerSitePages::OnSetActive() 
{
	ASSERT(m_pCert != NULL);
    m_ServerSiteInstancePath = m_pCert->m_WebSiteInstanceName_Remote;
    m_ServerSiteInstance = CMetabasePath::GetInstanceNumber(m_ServerSiteInstancePath);

    UpdateData(FALSE);
	SetWizardButtons(m_ServerSiteInstance <=0 ? PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	return CIISWizardPage::OnSetActive();
}

BOOL
CChooseServerSitePages::OnKillActive()
{
	//UpdateData();
	m_pCert->m_WebSiteInstanceName_Remote = m_ServerSiteInstancePath;
	return CIISWizardPage::OnKillActive();
}

BEGIN_MESSAGE_MAP(CChooseServerSitePages, CIISWizardPage)
	//{{AFX_MSG_MAP(CChooseServerSitePages)
	ON_EN_CHANGE(IDC_SERVER_SITE_NAME, OnEditchangeServerSiteName)
    ON_BN_CLICKED(IDC_BROWSE_BTN, OnBrowseForMachineWebSite)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSiteNamePage message handlers

void CChooseServerSitePages::OnEditchangeServerSiteName() 
{
	UpdateData(TRUE);	
	SetWizardButtons(m_ServerSiteInstance <=0 ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	CString str;
	SetDlgItemText(IDC_ERROR_TEXT, str);
}

void CChooseServerSitePages::OnBrowseForMachineWebSite()
{
    CString strWebSite;

    CChooseServerSite dlg(TRUE,strWebSite,m_pCert);
    if (dlg.DoModal() == IDOK)
    {
        // Get the one that they selected...
        strWebSite = dlg.m_strSiteReturned; 
        m_ServerSiteInstancePath = strWebSite;
        m_ServerSiteInstance = CMetabasePath::GetInstanceNumber(m_ServerSiteInstancePath);
        CString Temp;
        Temp.Format(_T("%d"),m_ServerSiteInstance);
        SetDlgItemText(IDC_SERVER_SITE_NAME, Temp);
    }

    return;
}

/////////////////////////////////////////////////////////////////////////////
// CChooseServerSitePages property page

IMPLEMENT_DYNCREATE(CChooseServerSitePagesTo, CIISWizardPage)

CChooseServerSitePagesTo::CChooseServerSitePagesTo(CCertificate * pCert) 
	: CIISWizardPage(CChooseServerSitePagesTo::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CChooseServerSitePagesTo)
	m_ServerSiteInstance = 0;
    m_ServerSiteInstancePath = _T("");
    m_ServerSiteDescription = _T("");
	//}}AFX_DATA_INIT
}

CChooseServerSitePagesTo::~CChooseServerSitePagesTo()
{
}

void CChooseServerSitePagesTo::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChooseServerSitePagesTo)
	DDX_Text(pDX, IDC_SERVER_SITE_NAME, m_ServerSiteInstance);
	//}}AFX_DATA_MAP
}

LRESULT 
CChooseServerSitePagesTo::OnWizardBack()
/*++
Routine Description:
    Prev button handler

Arguments:
    None

Return Value:
	0 to automatically advance to the prev page;
	1 to prevent the page from changing. 
	To jump to a page other than the prev one, 
	return the identifier of the dialog to be displayed.
--*/
{
	return IDD_PAGE_PREV;
}

LRESULT 
CChooseServerSitePagesTo::OnWizardNext()
{
    LRESULT lres = 1;
    BOOL bCertificateExists = FALSE;
    CString csInstanceName;
    CString UserPassword_Remote;
    m_ServerSiteInstance = -1;
	UpdateData(TRUE);

    m_pCert->m_UserPassword_Remote.CopyTo(UserPassword_Remote);
    
    if (m_ServerSiteInstance != -1)
    {
        lres = IDD_PAGE_NEXT;
        // Get the site # and create an instance path
        csInstanceName = ReturnGoodMetabaseServerPath(m_pCert->m_WebSiteInstanceName);
        csInstanceName += _T("/%d");

        m_ServerSiteInstancePath.Format(csInstanceName,m_ServerSiteInstance);
        m_pCert->m_WebSiteInstanceName_Remote = m_ServerSiteInstancePath;

        // Check if this is a local to local copy that
        // we are not copy/moving to the same local site that we're on!
        if (TRUE == IsMachineLocal(m_pCert->m_MachineName_Remote, m_pCert->m_UserName_Remote, UserPassword_Remote))
        {
            CString SiteToExclude = m_pCert->m_WebSiteInstanceName;
            CString SiteToLookAt = m_ServerSiteInstancePath;

            // We are on the local machine!!!
            // make sure it's not the same web site
            // if it is then popup a msgbox!!!!!!
            if (SiteToLookAt.Left(1) == _T("/"))
            {
                if (SiteToExclude.Left(1) != _T("/"))
                    {SiteToExclude = _T("/") + SiteToExclude;}
            }
            if (SiteToLookAt.Right(1) == _T("/"))
            {
                if (SiteToExclude.Right(1) != _T("/"))
                    {SiteToExclude = SiteToExclude + _T("/");}
            }

            if (0 == _tcsicmp(SiteToLookAt,SiteToExclude))
            {
                // Cannot do this, popup messagebox
                AfxMessageBox(IDS_NOT_TO_ITSELF);
                lres = 1;
                goto CChooseServerSitePagesTo_OnWizardNext_Exit;
            }
        }

        // Check if the specified path actually exists!!!!!!!
        if (FALSE == IsWebSiteExistRemote(m_pCert->m_MachineName_Remote, m_pCert->m_UserName_Remote, UserPassword_Remote, m_ServerSiteInstancePath, &bCertificateExists))
        {
            AfxMessageBox(IDS_SITE_NOT_EXIST);
            lres = 1;
        }
        else
        {
            lres = 1;
            BOOL ProceedWithCopyMove = FALSE;

            // Check if Certificate Exist...
            if (bCertificateExists)
            {
                if (TRUE == AnswerIsYes3(IDS_CERT_EXISTS_OVERWRITE))
                {
                    ProceedWithCopyMove = TRUE;
                }
                else
                {
                    ProceedWithCopyMove = FALSE;
                }
            }
            else
            {
                ProceedWithCopyMove = TRUE;
            }

            if (TRUE == ProceedWithCopyMove)
            {
                if (m_pCert->m_DeleteAfterCopy)
                {
                    lres = IDD_PAGE_NEXT2;
                }
                else
                {
                    lres = IDD_PAGE_NEXT;
                }
            }
        }
    }

CChooseServerSitePagesTo_OnWizardNext_Exit:
	return lres;
}

BOOL 
CChooseServerSitePagesTo::OnSetActive() 
{
	ASSERT(m_pCert != NULL);

	m_ServerSiteInstancePath = m_pCert->m_WebSiteInstanceName_Remote;
    m_ServerSiteInstance = CMetabasePath::GetInstanceNumber(m_ServerSiteInstancePath);

	UpdateData(FALSE);
	SetWizardButtons(m_ServerSiteInstance <=0 ? PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	return CIISWizardPage::OnSetActive();
}

BOOL
CChooseServerSitePagesTo::OnKillActive()
{
	//UpdateData();
	m_pCert->m_WebSiteInstanceName_Remote = m_ServerSiteInstancePath;
	return CIISWizardPage::OnKillActive();
}

BEGIN_MESSAGE_MAP(CChooseServerSitePagesTo, CIISWizardPage)
	//{{AFX_MSG_MAP(CChooseServerSitePagesTo)
	ON_EN_CHANGE(IDC_SERVER_SITE_NAME, OnEditchangeServerSiteName)
    ON_BN_CLICKED(IDC_BROWSE_BTN, OnBrowseForMachineWebSite)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSiteNamePage message handlers

void CChooseServerSitePagesTo::OnEditchangeServerSiteName() 
{
	UpdateData(TRUE);	
	SetWizardButtons(m_ServerSiteInstance <=0 ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	CString str;
	SetDlgItemText(IDC_ERROR_TEXT, str);
}

void CChooseServerSitePagesTo::OnBrowseForMachineWebSite()
{
    CString strWebSite;

    CChooseServerSite dlg(FALSE,strWebSite,m_pCert);
    if (dlg.DoModal() == IDOK)
    {
        // Get the one that they selected...
        strWebSite = dlg.m_strSiteReturned; 
        m_ServerSiteInstancePath = strWebSite;
        m_ServerSiteInstance = CMetabasePath::GetInstanceNumber(m_ServerSiteInstancePath);
        CString Temp;
        Temp.Format(_T("%d"),m_ServerSiteInstance); 
        SetDlgItemText(IDC_SERVER_SITE_NAME, Temp);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\copymovecertremotepage.h ===
#if !defined(AFX_COPYMOVECERTREMOTEPAGE_H__2BC5260E_AB68_43ED_9E7B_35794097905F__INCLUDED_)
#define AFX_COPYMOVECERTREMOTEPAGE_H__2BC5260E_AB68_43ED_9E7B_35794097905F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// CopyMoveCertRemotePage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCopyMoveCertFromRemotePage dialog
class CCertificate;

class CCopyMoveCertFromRemotePage : public CIISWizardPage
{
	DECLARE_DYNCREATE(CCopyMoveCertFromRemotePage)

// Construction
public:
	CCopyMoveCertFromRemotePage(CCertificate * pCert = NULL);
	~CCopyMoveCertFromRemotePage();

	enum
	{
        IDD_PAGE_NEXT_COPY_FROM_REMOTE = IDD_PAGE_WIZ_CHOOSE_SERVER,
        IDD_PAGE_NEXT_MOVE_FROM_REMOTE = IDD_PAGE_WIZ_CHOOSE_SERVER,
		IDD_PAGE_PREV = IDD_PAGE_WIZ_GET_WHAT
	};
	enum
	{
        CONTINUE_COPY_FROM_REMOTE = 0,
        CONTINUE_MOVE_FROM_REMOTE
	};

// Dialog Data
	//{{AFX_DATA(CCopyMoveCertFromRemotePage)
	enum { IDD = IDD_PAGE_WIZ_CHOOSE_COPY_MOVE_FROM_REMOTE };
    int		m_Index;
	//}}AFX_DATA
    CCertificate * m_pCert;
    BOOL m_MarkAsExportable;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CCopyMoveCertFromRemotePage)
	public:
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CCopyMoveCertFromRemotePage)
    virtual BOOL OnInitDialog();
    afx_msg void OnExportable();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};


class CCopyMoveCertToRemotePage : public CIISWizardPage
{
	DECLARE_DYNCREATE(CCopyMoveCertToRemotePage)

// Construction
public:
	CCopyMoveCertToRemotePage(CCertificate * pCert = NULL);
	~CCopyMoveCertToRemotePage();

	enum
	{
		IDD_PAGE_NEXT_COPY_TO_REMOTE = IDD_PAGE_WIZ_CHOOSE_SERVER_TO,
		IDD_PAGE_NEXT_MOVE_TO_REMOTE = IDD_PAGE_WIZ_CHOOSE_SERVER_TO,
		IDD_PAGE_PREV = IDD_PAGE_WIZ_MANAGE_CERT
	};
	enum
	{
		CONTINUE_COPY_TO_REMOTE = 0,
		CONTINUE_MOVE_TO_REMOTE
	};

// Dialog Data
	//{{AFX_DATA(CCopyMoveCertToRemotePage)
	enum { IDD = IDD_PAGE_WIZ_CHOOSE_COPY_MOVE_TO_REMOTE };
    int		m_Index;
	//}}AFX_DATA
    CCertificate * m_pCert;
    BOOL m_MarkAsExportable;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CCopyMoveCertToRemotePage)
	public:
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CCopyMoveCertToRemotePage)
    virtual BOOL OnInitDialog();
    afx_msg void OnExportable();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_COPYMOVECERTREMOTEPAGE_H__2BC5260E_AB68_43ED_9E7B_35794097905F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\countrycombobox.h ===
#if !defined(AFX_COUNTRYCOMBOBOX_H__8F522A56_3E30_11D2_9313_0060088FF80E__INCLUDED_)
#define AFX_COUNTRYCOMBOBOX_H__8F522A56_3E30_11D2_9313_0060088FF80E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// CountryComboBox.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCountryComboBox window
class CCountryComboBox;

class CComboEdit : public CEdit
{
	CCountryComboBox * m_pParent;
public:
	BOOL SubclassDlgItem(UINT nID, CCountryComboBox * pParent);

	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	DECLARE_MESSAGE_MAP()
};

typedef struct _COUNTRY_DATA 
{
	TCHAR * code;
	TCHAR * name;
} COUNTRY_DATA;

class CCountryComboBox : public CComboBox
{
	CComboEdit m_edit;
	CMapStringToString m_map_name_code;
	CString m_strInput;
	int m_Index;

// Construction
public:
	CCountryComboBox();

// Attributes
public:

// Operations
public:
	BOOL SubclassDlgItem(UINT nID, CWnd * pParent);
	BOOL Init();
	BOOL OnEditChar(UINT nChar);
	void SetSelectedCountry(CString& country_code);
	void GetSelectedCountry(CString& country_code);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCountryComboBox)
	public:
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CCountryComboBox();

	// Generated message map functions
protected:
	//{{AFX_MSG(CCountryComboBox)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_COUNTRYCOMBOBOX_H__8F522A56_3E30_11D2_9313_0060088FF80E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\finalpages.cpp ===
// FinalInstalledPage.cpp : implementation file
//

#include "stdafx.h"
#include "CertWiz.h"
#include "FinalPages.h"
#include "Certificat.h"
#include "Certutil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFinalInstalledPage property page

IMPLEMENT_DYNCREATE(CFinalInstalledPage, CIISWizardBookEnd2)

CFinalInstalledPage::CFinalInstalledPage(HRESULT * phResult, CCertificate * pCert) 
	: CIISWizardBookEnd2(phResult,
		USE_DEFAULT_CAPTION,
		IDS_INSTALL_CERT_FAILURE_HEADER,
		IDS_CERTWIZ,
		&m_idBodyText,
		NULL,
		&pCert->m_idErrorText,
		&pCert->m_strErrorText,
		USE_DEFAULT_CAPTION,
		CFinalInstalledPage::IDD),
		m_pCert(pCert)
{
	m_idBodyText = IDS_CERT_INSTALLED_SUCCESS;
}

CFinalInstalledPage::~CFinalInstalledPage()
{
}

BEGIN_MESSAGE_MAP(CFinalInstalledPage, CIISWizardBookEnd2)
	//{{AFX_MSG_MAP(CFinalInstalledPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFinalInstalledPage message handlers


/////////////////////////////////////////////////////////////////////////////
// CFinalReplacedPage property page

IMPLEMENT_DYNCREATE(CFinalReplacedPage, CIISWizardBookEnd2)

CFinalReplacedPage::CFinalReplacedPage(HRESULT * phResult, CCertificate * pCert) 
	: CIISWizardBookEnd2(phResult,
		USE_DEFAULT_CAPTION,
		IDS_INSTALL_CERT_FAILURE_HEADER,
		IDS_CERTWIZ,
		&m_idBodyText,
		NULL,
		&pCert->m_idErrorText,
		&pCert->m_strErrorText,
		USE_DEFAULT_CAPTION,
		CFinalReplacedPage::IDD),
		m_pCert(pCert)
{
	m_idBodyText = IDS_CERT_REPLACE_SUCCESS;
}

CFinalReplacedPage::~CFinalReplacedPage()
{
}

BEGIN_MESSAGE_MAP(CFinalReplacedPage, CIISWizardBookEnd2)
	//{{AFX_MSG_MAP(CFinalReplacedPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFinalInstalledPage message handlers


/////////////////////////////////////////////////////////////////////////////
// CFinalRemovePage property page

IMPLEMENT_DYNCREATE(CFinalRemovePage, CIISWizardBookEnd2)

CFinalRemovePage::CFinalRemovePage(HRESULT * phResult, CCertificate * pCert) 
	: CIISWizardBookEnd2(phResult,
		USE_DEFAULT_CAPTION,
		IDS_REMOVE_CERT_FAILURE_HEADER,
		IDS_CERTWIZ,
		&m_idBodyText,
		NULL,
		&pCert->m_idErrorText,
		&pCert->m_strErrorText,
		USE_DEFAULT_CAPTION,
		CFinalRemovePage::IDD),
		m_pCert(pCert)
{
	m_idBodyText = IDS_CERT_REMOVE_SUCCESS;
}

CFinalRemovePage::~CFinalRemovePage()
{
}

void CFinalRemovePage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardBookEnd2::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFinalRemovePage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFinalRemovePage, CIISWizardBookEnd2)
	//{{AFX_MSG_MAP(CFinalRemovePage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFinalRemovePage message handlers

BOOL CFinalRemovePage::OnInitDialog() 
{
	CIISWizardBookEnd2::OnInitDialog();
	ASSERT(m_pCert != NULL);
	if (m_pCert->m_hResult != S_OK)
	{
		// we need to replace text in template to error message
		CString str;
		str.LoadString(m_pCert->m_idErrorText);
		SetDlgItemText(IDC_STATIC_WZ_BODY, str);
        GetDlgItem(IDC_STATIC_WZ_BODY)->SendMessage(EM_SETSEL, -1, -1);
	}
	GetParent()->GetDlgItem(IDCANCEL)->EnableWindow(FALSE);
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CFinalCancelPage property page

IMPLEMENT_DYNCREATE(CFinalCancelPage, CIISWizardBookEnd2)

CFinalCancelPage::CFinalCancelPage(HRESULT * phResult, CCertificate * pCert) 
	: CIISWizardBookEnd2(phResult,
		USE_DEFAULT_CAPTION,
		IDS_CANCEL_CERT_FAILURE_HEADER,
		IDS_CERTWIZ,
		&m_idBodyText,
		NULL,
		&pCert->m_idErrorText,
		&pCert->m_strErrorText,
		USE_DEFAULT_CAPTION,
		CFinalCancelPage::IDD),
		m_pCert(pCert)
{
	m_idBodyText = IDS_CERT_CANCEL_SUCCESS;
}

CFinalCancelPage::~CFinalCancelPage()
{
}

void CFinalCancelPage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardBookEnd2::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFinalRemovePage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFinalCancelPage, CIISWizardBookEnd2)
	//{{AFX_MSG_MAP(CFinalCancelPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFinalCancelPage message handlers

BOOL CFinalCancelPage::OnInitDialog() 
{
	CIISWizardBookEnd2::OnInitDialog();
	ASSERT(m_pCert != NULL);
	if (m_pCert->m_hResult != S_OK)
	{
		// we need to replace text in template to error message
		CString str;
		str.LoadString(m_pCert->m_idErrorText);
		SetDlgItemText(IDC_STATIC_WZ_BODY, str);
        GetDlgItem(IDC_STATIC_WZ_BODY)->SendMessage(EM_SETSEL, -1, -1);
	}
	GetParent()->GetDlgItem(IDCANCEL)->EnableWindow(FALSE);
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CFinalToFilePage property page

IMPLEMENT_DYNCREATE(CFinalToFilePage, CIISWizardBookEnd2)

CFinalToFilePage::CFinalToFilePage(HRESULT * phResult, CCertificate * pCert) 
	: CIISWizardBookEnd2(phResult,
			USE_DEFAULT_CAPTION,
			IDS_FINAL_TO_FILE_FAILURE_HEADER,
			IDS_CERTWIZ,
			NULL,
			NULL,
			&pCert->m_idErrorText,
			&pCert->m_strErrorText,
			USE_DEFAULT_CAPTION,
			CFinalToFilePage::IDD),
	m_pCert(pCert)
{
}

CFinalToFilePage::~CFinalToFilePage()
{
}

void CFinalToFilePage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardBookEnd2::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFinalToFilePage)
//	DDX_Control(pDX, IDC_HOTLINK_CCODES, m_hotlink_codessite);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CFinalToFilePage, CIISWizardBookEnd2)
	//{{AFX_MSG_MAP(CFinalToFilePage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFinalToFilePage message handlers

BOOL CFinalToFilePage::OnInitDialog() 
{
	ASSERT(NULL != m_pCert);
	CIISWizardBookEnd2::OnInitDialog();
	// in case of success we should prepare text and include
	// request file name into
	if (SUCCEEDED(m_pCert->m_hResult))
	{
		CString str, strPath;
      
      	strPath = m_pCert->m_ReqFileName;
		// If filename is too long, it will look ugly, we could
		// limit it to our static control width.
		VERIFY(CompactPathToWidth(GetDlgItem(IDC_STATIC_WZ_BODY), strPath));
// This MFC helper limits the format internally 
// to 256 characters: cannot use it here
//		AfxFormatString1(str, IDS_FINAL_TO_FILE_BODY_SUCCESS, m_pCert->m_ReqFileName);
		str.Format(IDS_CERT_REQUEST_SUCCESS, strPath);
		SetDlgItemText(IDC_STATIC_WZ_BODY, str);

		GetDlgItem(IDC_STATIC_WZ_BODY)->SendMessage(EM_SETSEL, -1, -1);
		//GetDlgItem(IDC_STATIC_WZ_BODY)->SetFocus();


		// setup the link to CA list
//		m_hotlink_codessite.SetLink(IDS_MICROSOFT_CA_LINK);
	}
//	else
//	{
		// hide controls that are not for error message
		GetDlgItem(IDC_HOTLINK_CCODES)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_STATIC_WZ_BODY2)->ShowWindow(SW_HIDE);
//	}
	SetWizardButtons(PSWIZB_FINISH);	
	GetParent()->GetDlgItem(IDCANCEL)->EnableWindow(FALSE);
	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CFinalInstalledPage property page

IMPLEMENT_DYNCREATE(CFinalInstalledImportPFXPage, CIISWizardBookEnd2)

CFinalInstalledImportPFXPage::CFinalInstalledImportPFXPage(HRESULT * phResult, CCertificate * pCert) 
	: CIISWizardBookEnd2(phResult,
		USE_DEFAULT_CAPTION,
		IDS_INSTALL_CERT_FAILURE_HEADER,
		IDS_CERTWIZ,
		&m_idBodyText,
		NULL,
		&pCert->m_idErrorText,
		&pCert->m_strErrorText,
		USE_DEFAULT_CAPTION,
		CFinalInstalledImportPFXPage::IDD),
		m_pCert(pCert)
{
	m_idBodyText = IDS_CERT_INSTALLED_SUCCESS;
}

CFinalInstalledImportPFXPage::~CFinalInstalledImportPFXPage()
{
}

BEGIN_MESSAGE_MAP(CFinalInstalledImportPFXPage, CIISWizardBookEnd2)
	//{{AFX_MSG_MAP(CFinalInstalledImportPFXPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()



/////////////////////////////////////////////////////////////////////////////
// CFinalInstalledPage property page

IMPLEMENT_DYNCREATE(CFinalInstalledExportPFXPage, CIISWizardBookEnd2)

CFinalInstalledExportPFXPage::CFinalInstalledExportPFXPage(HRESULT * phResult, CCertificate * pCert) 
	: CIISWizardBookEnd2(phResult,
		USE_DEFAULT_CAPTION,
		IDS_INSTALL_CERT_FAILURE_HEADER,
		IDS_CERTWIZ,
		&m_idBodyText,
		NULL,
		&pCert->m_idErrorText,
		&pCert->m_strErrorText,
		USE_DEFAULT_CAPTION,
		CFinalInstalledExportPFXPage::IDD),
		m_pCert(pCert)
{
	m_idBodyText = IDS_PFX_EXPORT_SUCCESS;
}

CFinalInstalledExportPFXPage::~CFinalInstalledExportPFXPage()
{
}

BEGIN_MESSAGE_MAP(CFinalInstalledExportPFXPage, CIISWizardBookEnd2)
	//{{AFX_MSG_MAP(CFinalInstalledExportPFXPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()



/////////////////////////////////////////////////////////////////////////////
// CFinalInstalledPage property page

IMPLEMENT_DYNCREATE(CFinalInstalledCopyFromRemotePage, CIISWizardBookEnd2)

CFinalInstalledCopyFromRemotePage::CFinalInstalledCopyFromRemotePage(HRESULT * phResult, CCertificate * pCert) 
	: CIISWizardBookEnd2(phResult,
		USE_DEFAULT_CAPTION,
		IDS_INSTALL_CERT_FAILURE_HEADER,
		IDS_CERTWIZ,
		&m_idBodyText,
		NULL,
		&pCert->m_idErrorText,
		&pCert->m_strErrorText,
		USE_DEFAULT_CAPTION,
		CFinalInstalledCopyFromRemotePage::IDD),
		m_pCert(pCert)
{
	m_idBodyText = IDS_CERT_INSTALLED_SUCCESS;
}

CFinalInstalledCopyFromRemotePage::~CFinalInstalledCopyFromRemotePage()
{
}

BEGIN_MESSAGE_MAP(CFinalInstalledCopyFromRemotePage, CIISWizardBookEnd2)
	//{{AFX_MSG_MAP(CFinalInstalledCopyFromRemotePage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CFinalInstalledPage property page

IMPLEMENT_DYNCREATE(CFinalInstalledMoveFromRemotePage, CIISWizardBookEnd2)

CFinalInstalledMoveFromRemotePage::CFinalInstalledMoveFromRemotePage(HRESULT * phResult, CCertificate * pCert) 
	: CIISWizardBookEnd2(phResult,
		USE_DEFAULT_CAPTION,
		IDS_INSTALL_CERT_FAILURE_HEADER,
		IDS_CERTWIZ,
		&m_idBodyText,
		NULL,
		&pCert->m_idErrorText,
		&pCert->m_strErrorText,
		USE_DEFAULT_CAPTION,
		CFinalInstalledMoveFromRemotePage::IDD),
		m_pCert(pCert)
{
	m_idBodyText = IDS_CERT_INSTALLED_SUCCESS;
}

CFinalInstalledMoveFromRemotePage::~CFinalInstalledMoveFromRemotePage()
{
}

BEGIN_MESSAGE_MAP(CFinalInstalledMoveFromRemotePage, CIISWizardBookEnd2)
	//{{AFX_MSG_MAP(CFinalInstalledMoveFromRemotePage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CFinalInstalledPage property page

IMPLEMENT_DYNCREATE(CFinalInstalledCopyToRemotePage, CIISWizardBookEnd2)

CFinalInstalledCopyToRemotePage::CFinalInstalledCopyToRemotePage(HRESULT * phResult, CCertificate * pCert) 
	: CIISWizardBookEnd2(phResult,
		USE_DEFAULT_CAPTION,
		IDS_INSTALL_CERT_FAILURE_HEADER,
		IDS_CERTWIZ,
		&m_idBodyText,
		NULL,
		&pCert->m_idErrorText,
		&pCert->m_strErrorText,
		USE_DEFAULT_CAPTION,
		CFinalInstalledCopyToRemotePage::IDD),
		m_pCert(pCert)
{
	m_idBodyText = IDS_CERT_INSTALLED_REMOTE_SUCCESS;
}

CFinalInstalledCopyToRemotePage::~CFinalInstalledCopyToRemotePage()
{
}

BEGIN_MESSAGE_MAP(CFinalInstalledCopyToRemotePage, CIISWizardBookEnd2)
	//{{AFX_MSG_MAP(CFinalInstalledCopyToRemotePage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CFinalInstalledPage property page

IMPLEMENT_DYNCREATE(CFinalInstalledMoveToRemotePage, CIISWizardBookEnd2)

CFinalInstalledMoveToRemotePage::CFinalInstalledMoveToRemotePage(HRESULT * phResult, CCertificate * pCert) 
	: CIISWizardBookEnd2(phResult,
		USE_DEFAULT_CAPTION,
		IDS_INSTALL_CERT_FAILURE_HEADER,
		IDS_CERTWIZ,
		&m_idBodyText,
		NULL,
		&pCert->m_idErrorText,
		&pCert->m_strErrorText,
		USE_DEFAULT_CAPTION,
		CFinalInstalledMoveToRemotePage::IDD),
		m_pCert(pCert)
{
	m_idBodyText = IDS_CERT_INSTALLED_REMOTE_SUCCESS;
}

CFinalInstalledMoveToRemotePage::~CFinalInstalledMoveToRemotePage()
{
}

BEGIN_MESSAGE_MAP(CFinalInstalledMoveToRemotePage, CIISWizardBookEnd2)
	//{{AFX_MSG_MAP(CFinalInstalledMoveToRemotePage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\iisdebug.cpp ===
#include "stdafx.h"

INT g_iDebugOutputLevel = 0;

void GetOutputDebugFlag(void)
{
    DWORD rc, err, size, type;
    HKEY  hkey;
    err = RegOpenKey(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\InetMgr"), &hkey);
    if (err != ERROR_SUCCESS) {return;}
    size = sizeof(DWORD);
    err = RegQueryValueEx(hkey,_T("OutputDebugFlag"),0,&type,(LPBYTE)&rc,&size);
    if (err != ERROR_SUCCESS || type != REG_DWORD) {rc = 0;}
    RegCloseKey(hkey);

	if (rc < 0xffffffff)
	{
		g_iDebugOutputLevel = rc;
	}
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\hotlink.cpp ===
// HotLink.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "HotLink.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define COLOR_BLUE			RGB(0, 0, 0xFF)
#define COLOR_YELLOW		RGB(0xff, 0x80, 0)

/////////////////////////////////////////////////////////////////////////////
// CHotLink

CHotLink::CHotLink():
    m_CapturedMouse(FALSE),
    m_fBrowse(FALSE),
    m_fExplore(FALSE),
    m_fOpen(TRUE),
    m_fInitializedFont(FALSE)
{
}

CHotLink::~CHotLink()
{
}

BEGIN_MESSAGE_MAP(CHotLink, CButton)
	//{{AFX_MSG_MAP(CHotLink)
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_WM_CAPTURECHANGED()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

//------------------------------------------------------------------------
// set the title string
void CHotLink::SetTitle( CString sz )
{
    // set the title
    SetWindowText( sz );
    // force the window to redraw
    Invalidate( TRUE );
}

/////////////////////////////////////////////////////////////////////////////
// CHotLink message handlers

//------------------------------------------------------------------------
void CHotLink::DrawItem( LPDRAWITEMSTRUCT lpDrawItemStruct )
{
	// prep the device context
	CDC* pdc = CDC::FromHandle(lpDrawItemStruct->hDC);

	// get the drawing rect
	CRect rect = lpDrawItemStruct->rcItem;
	CString sz;
	GetWindowText(sz);

	if (!m_fInitializedFont)
	{
		// get the window font
		LOGFONT logfont;
		HFONT hFont = (HFONT)SendMessage(WM_GETFONT, 0, 0);
		ASSERT(hFont != NULL);
		VERIFY(0 < GetObject(hFont, sizeof(LOGFONT), &logfont));

		// modify the font  - add underlining
		logfont.lfUnderline = TRUE;

        // set the font back
		HFONT hNewFont = ::CreateFontIndirect(&logfont);
		ASSERT(hNewFont != NULL);
		SendMessage(WM_SETFONT, (WPARAM)hNewFont, MAKELPARAM(TRUE, 0));
		// get the extents fo the text for later reference
		m_cpTextExtents = pdc->GetOutputTextExtent(sz);
		// get the main rect
		GetClientRect(m_rcText);

		// reduce it by the width of the text
		m_rcText.left = m_rcText.left + (m_rcText.Width() - m_cpTextExtents.cx) / 2;
		m_rcText.right = m_rcText.left + m_cpTextExtents.cx;
		m_rcText.top = m_rcText.top + (m_rcText.Height() - m_cpTextExtents.cy) / 2;
		m_rcText.bottom = m_rcText.top + m_cpTextExtents.cy;
		m_clrText = COLOR_BLUE;
		m_fInitializedFont = TRUE;
	}

	// draw the text in color that was set outside
	pdc->SetTextColor(m_clrText);
	
	// draw the text
	pdc->DrawText(sz, &rect, DT_CENTER|DT_SINGLELINE|DT_VCENTER);
}

//------------------------------------------------------------------------
// calculate the rectangle that surrounds the text
void CHotLink::GetTextRect( CRect &rect )
{
    // get the main rect
    GetClientRect( rect );

    // reduce it by margins
	// Calculations below are for centered text. To locate it inside
	// the dialog just make it tight and move control itself
	rect.left = rect.left + (rect.Width() - m_cpTextExtents.cx) / 2;
    rect.right = rect.left + m_cpTextExtents.cx;
	rect.top = rect.top + (rect.Height() - m_cpTextExtents.cy) / 2;
	rect.bottom = rect.top + m_cpTextExtents.cy;
}

//------------------------------------------------------------------------
void CHotLink::OnLButtonDown(UINT nFlags, CPoint point)
{
   	// don't do the hotlink thing if there is no text
	if (!m_strLink.IsEmpty() && !m_CapturedMouse && m_rcText.PtInRect(point))
   	{
		SetCapture();
      	m_CapturedMouse = TRUE;
   	}
}

//------------------------------------------------------------------------
void CHotLink::OnLButtonUp(UINT nFlags, CPoint point)
{
	// only bother if we have the capture
   if (m_CapturedMouse)
   {
		ReleaseCapture();
      	if ( m_fBrowse )
			Browse();
      	else if ( m_fExplore )
			Explore();
      	else if ( m_fOpen )
			Open();
	}
}

//------------------------------------------------------------------------
void CHotLink::Browse()
{
    ShellExecute(
        NULL,			// handle to parent window
        NULL,			// pointer to string that specifies operation to perform
        m_strLink,		// pointer to filename or folder name string
        NULL,			// pointer to string that specifies executable-file parameters
        NULL,			// pointer to string that specifies default directory
        SW_SHOW 		// whether file is shown when opened
       );
}

//------------------------------------------------------------------------
void CHotLink::Explore()
{
    ShellExecute(
        NULL,			// handle to parent window
        _T("explore"),	// pointer to string that specifies operation to perform
        m_strLink,		// pointer to filename or folder name string
        NULL,			// pointer to string that specifies executable-file parameters
        NULL,			// pointer to string that specifies default directory
        SW_SHOW 		// whether file is shown when opened
       );
}

//------------------------------------------------------------------------
void CHotLink::Open()
{
    ShellExecute(
        NULL,			// handle to parent window
        _T("open"),		// pointer to string that specifies operation to perform
        m_strLink,		// pointer to filename or folder name string
        NULL,			// pointer to string that specifies executable-file parameters
        NULL,			// pointer to string that specifies default directory
        SW_SHOW 		// whether file is shown when opened
       );
}

//------------------------------------------------------------------------
void CHotLink::OnMouseMove(UINT nFlags, CPoint point)
{
	CRect   rect;
	GetTextRect(rect);
	// if the mouse is over the hot area, show the right cursor
	if (rect.PtInRect(point))
	{
		::SetCursor(AfxGetApp()->LoadCursor(IDC_BROWSE_CUR));
		// also reset text color to *yellow*
		if (m_clrText != COLOR_YELLOW)
		{
			m_clrText = COLOR_YELLOW;
			InvalidateRect(m_rcText, FALSE);
			UpdateWindow();
		}
	}
	else 
	{
		if (m_clrText != COLOR_BLUE)
		// we are not pointing to text, render it in *blue*
		{
			m_clrText = COLOR_BLUE;
			InvalidateRect(m_rcText, FALSE);
			UpdateWindow();
		}
		// also remove capture and reset the cursor
		ReleaseCapture();
		::SetCursor(AfxGetApp()->LoadCursor(IDC_ARROW));
	}
}

void CHotLink::OnCaptureChanged(CWnd *pWnd) 
{
	m_clrText = COLOR_BLUE;
	InvalidateRect(m_rcText, FALSE);
	UpdateWindow();
	m_CapturedMouse = FALSE;
	CButton::OnCaptureChanged(pWnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\getwhatpage.cpp ===
// GetWhatPage.cpp : implementation file
//

#include "stdafx.h"
#include "CertWiz.h"
#include "GetWhatPage.h"
#include "Certificat.h"
#include "certutil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGetWhatPage property page

IMPLEMENT_DYNCREATE(CGetWhatPage, CIISWizardPage)

CGetWhatPage::CGetWhatPage(CCertificate * pCert) 
	: CIISWizardPage(CGetWhatPage::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CGetWhatPage)
	m_Index = -1;
	//}}AFX_DATA_INIT
}

CGetWhatPage::~CGetWhatPage()
{
}

void CGetWhatPage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGetWhatPage)
	DDX_Radio(pDX, IDC_RADIO0, m_Index);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CGetWhatPage, CIISWizardPage)
	//{{AFX_MSG_MAP(CGetWhatPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWelcomePage message handlers

BOOL 
CGetWhatPage::OnSetActive() 
{
	m_pCert->SetStatusCode(CCertificate::REQUEST_UNDEFINED);
   SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);
   return CIISWizardPage::OnSetActive();
}

enum 
{
	REQUEST_NEW_CERT = 0,
	INSTALL_EXISTING_CERT,
	IMPORT_KEYRING_CERT,
    IMPORT_CERT,
    COPY_MOVE_REMOTE_CERT,
};

LRESULT 
CGetWhatPage::OnWizardPrev()
{
	return IDD_PAGE_PREV;
}

LRESULT 
CGetWhatPage::OnWizardNext()
{
	UpdateData();
	switch (m_Index)
	{
	case REQUEST_NEW_CERT:
		m_pCert->SetStatusCode(CCertificate::REQUEST_NEW_CERT);
		return IDD_PAGE_NEXT_NEW;
	case INSTALL_EXISTING_CERT:
		m_pCert->SetStatusCode(CCertificate::REQUEST_INSTALL_CERT);
		return IDD_PAGE_NEXT_EXISTING;
	case IMPORT_KEYRING_CERT:
		m_pCert->SetStatusCode(CCertificate::REQUEST_IMPORT_KEYRING);
		return IDD_PAGE_NEXT_IMPORT;
	case IMPORT_CERT:
		m_pCert->SetStatusCode(CCertificate::REQUEST_IMPORT_CERT);
		return IDD_PAGE_NEXT_IMPORT_PFX;
	case COPY_MOVE_REMOTE_CERT:
		m_pCert->SetStatusCode(CCertificate::REQUEST_COPY_MOVE_FROM_REMOTE);
		return IDD_PAGE_NEXT_COPY_MOVE_REMOTE;
	default:
		ASSERT(FALSE);
	}
	return 1;
}

BOOL CGetWhatPage::OnInitDialog() 
{
	ASSERT(m_pCert != NULL);
	m_Index = 0;
	CIISWizardPage::OnInitDialog();
    if ( (this != NULL) && (this->m_hWnd != NULL) )
    {

       if (GetDlgItem(IDC_RADIO0) != NULL)
       {
	       GetDlgItem(IDC_RADIO0)->SetFocus();
       }

       // Enable or disable controls based on weather certobj is installed
       GetDlgItem(IDC_RADIO3)->EnableWindow(m_pCert->m_CertObjInstalled);
       GetDlgItem(IDC_RADIO4)->EnableWindow(m_pCert->m_CertObjInstalled);

       if (m_pCert->m_CertObjInstalled)
       {
           GetDlgItem(IDC_RADIO3)->ShowWindow(SW_SHOW);
           GetDlgItem(IDC_RADIO4)->ShowWindow(SW_SHOW);
       }

       // Turn off for workstation.
       if (TRUE == IsWhistlerWorkstation())
       {
           GetDlgItem(IDC_RADIO3)->ShowWindow(SW_HIDE);
           GetDlgItem(IDC_RADIO4)->ShowWindow(SW_HIDE);
       }
   }
   return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\geoinfopage.cpp ===
// GeoInfoPage.cpp : implementation file
//

#include "stdafx.h"
#include "CertWiz.h"
#include "GeoInfoPage.h"
#include "Certificat.h"
#include "mru.h"
#include "strutil.h"
#include "CertUtil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGeoInfoPage property page

IMPLEMENT_DYNCREATE(CGeoInfoPage, CIISWizardPage)

CGeoInfoPage::CGeoInfoPage(CCertificate * pCert) 
	: CIISWizardPage(CGeoInfoPage::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CGeoInfoPage)
	m_Locality = _T("");
	m_State = _T("");
	m_Country = _T("");
	//}}AFX_DATA_INIT
}

CGeoInfoPage::~CGeoInfoPage()
{
}

void CGeoInfoPage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGeoInfoPage)
	DDX_Text(pDX, IDC_NEWKEY_LOCALITY, m_Locality);
	DDV_MaxCharsCombo(pDX, IDC_NEWKEY_LOCALITY, m_Locality, 64);
	DDX_Text(pDX, IDC_NEWKEY_STATE, m_State);
	DDV_MaxCharsCombo(pDX, IDC_NEWKEY_STATE, m_State, 64);
	DDX_CBString(pDX, IDC_NEWKEY_COUNTRY, m_Country);
	//}}AFX_DATA_MAP
}

LRESULT 
CGeoInfoPage::OnWizardPrev()
{
	return IDD_PAGE_PREV;
//	return m_pCert->m_CAType == CCertificate::CA_OFFLINE ?
//		IDD_PAGE_PREV_FILE : IDD_PAGE_PREV_ONLINE;
}

LRESULT 
CGeoInfoPage::OnWizardNext()
{
    LRESULT lres = 1;

	ASSERT(m_pCert != NULL);
	UpdateData(TRUE);
	m_pCert->m_Locality = m_Locality;
	m_pCert->m_State = m_State;
	m_countryCombo.GetSelectedCountry(m_pCert->m_Country);

    CString buf;
    buf.LoadString(IDS_INVALID_X500_CHARACTERS);

    if (!IsValidX500Chars(m_pCert->m_Country))
    {
        GetDlgItem(IDC_NEWKEY_COUNTRY)->SetFocus();
        AfxMessageBox(buf, MB_OK);
    }
    else if (!IsValidX500Chars(m_State))
    {
        GetDlgItem(IDC_NEWKEY_STATE)->SetFocus();
        AfxMessageBox(buf, MB_OK);
    }
    else if (!IsValidX500Chars(m_Locality))
    {
        GetDlgItem(IDC_NEWKEY_LOCALITY)->SetFocus();
        AfxMessageBox(buf, MB_OK);
    }
    else
    {
		if (m_pCert->m_CAType == CCertificate::CA_OFFLINE)
		{
			lres = IDD_PAGE_NEXT_FILE;
		}
		else
		{
			lres = IDD_PAGE_NEXT_ONLINE;
#ifdef ENABLE_W3SVC_SSL_PAGE
			if (IsWebServerType(m_pCert->m_WebSiteInstanceName))
			{
				lres = IDD_PAGE_NEXT_INSTALL_W3SVC_ONLY;
			}
#endif
		}
    }

	return lres;
}

BOOL CGeoInfoPage::OnSetActive()
{
	SetButtons();
	return CIISWizardPage::OnSetActive();
}

void CGeoInfoPage::SetButtons()
{
	UpdateData(TRUE);	
	SetWizardButtons(m_Country.IsEmpty() || m_Locality.IsEmpty() ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
}

BEGIN_MESSAGE_MAP(CGeoInfoPage, CIISWizardPage)
	//{{AFX_MSG_MAP(CGeoInfoPage)
	ON_CBN_EDITCHANGE(IDC_NEWKEY_LOCALITY, OnChangeNewkeyLocality)
	ON_CBN_EDITCHANGE(IDC_NEWKEY_STATE, OnChangeNewkeyState)
	ON_CBN_EDITCHANGE(IDC_NEWKEY_COUNTRY, OnEditchangeNewkeyCountry)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGeoInfoPage message handlers

BOOL CGeoInfoPage::OnInitDialog() 
{
	ASSERT(m_pCert != NULL);
	m_Locality = m_pCert->m_Locality;
	m_State = m_pCert->m_State;
	m_countryCombo.SubclassDlgItem(IDC_NEWKEY_COUNTRY, this);
	CIISWizardPage::OnInitDialog();
	m_countryCombo.Init();
	m_countryCombo.SetSelectedCountry(m_pCert->m_Country);
	// Load MRU names
	LoadMRUToCombo(this, IDC_NEWKEY_STATE, szStateMRU, m_State, MAX_MRU);
	LoadMRUToCombo(this, IDC_NEWKEY_LOCALITY, szLocalityMRU, m_Locality, MAX_MRU);
	SetButtons();
	GetDlgItem(IDC_NEWKEY_COUNTRY)->SetFocus();
	return FALSE;
}

void CGeoInfoPage::OnChangeNewkeyLocality() 
{
	SetButtons();
}

void CGeoInfoPage::OnChangeNewkeyState() 
{
	SetButtons();
}

void CGeoInfoPage::OnEditchangeNewkeyCountry() 
{
	SetButtons();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\hotlink.h ===
// HotLink.h : header file
//
#ifndef _HOTLINK_H
#define _HOTLINK_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CHotLink window

class CHotLink : public CButton
{
// Construction
public:
	CHotLink();

// Attributes
public:
    BOOL    m_fBrowse;
    BOOL    m_fExplore;
    BOOL    m_fOpen;

// Operations
public:
    void Browse();
    void Explore();
    void Open();

    virtual void DrawItem( LPDRAWITEMSTRUCT lpDrawItemStruct );

    // set the title string
    void SetTitle( CString sz );
	void SetLink(const CString& sz)
	{
		m_strLink = sz;
	}
	void SetLink(UINT id)
	{
		VERIFY(m_strLink.LoadString(id));
	}

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CHotLink)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CHotLink();

	// Generated message map functions
protected:
	//{{AFX_MSG(CHotLink)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnCaptureChanged(CWnd *pWnd);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

    // height and width of the displayed text
    void GetTextRect( CRect &rect );
    CSize   m_cpTextExtents;
	CRect m_rcText;
	COLORREF m_clrText;
	// URL for link could be not the same as caption
	CString m_strLink;

    // tracking the mouse flag
    BOOL    m_CapturedMouse;

    // init the font
    BOOL    m_fInitializedFont;
};

/////////////////////////////////////////////////////////////////////////////
#endif // _HOTLINK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\geoinfopage.h ===
#if !defined(_GEOINFOPAGE_H)
#define _GEOINFOPAGE_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// GeoInfoPage.h : header file
//
#include "CountryComboBox.h"

class CCertificate;

/////////////////////////////////////////////////////////////////////////////
// CGeoInfoPage dialog

class CGeoInfoPage : public CIISWizardPage
{
	DECLARE_DYNCREATE(CGeoInfoPage)

// Construction
public:
	CGeoInfoPage(CCertificate * pCert = NULL);
	~CGeoInfoPage();

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_SITE_NAME,
		IDD_PAGE_NEXT_FILE = IDD_PAGE_WIZ_CHOOSE_FILENAME,
		IDD_PAGE_NEXT_ONLINE = IDD_PAGE_WIZ_CHOOSE_ONLINE
#ifdef ENABLE_W3SVC_SSL_PAGE
      ,IDD_PAGE_NEXT_INSTALL_W3SVC_ONLY = IDD_PAGE_WIZ_GET_SSL_PORT
#endif

	};
// Dialog Data
	//{{AFX_DATA(CGeoInfoPage)
	enum { IDD = IDD_PAGE_WIZ_GEO_INFO };
	CString	m_Locality;
	CString	m_State;
	CString	m_Country;
	//}}AFX_DATA
	CCertificate * m_pCert;
	CCountryComboBox m_countryCombo;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CGeoInfoPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardPrev();
	virtual BOOL OnSetActive();
//	virtual BOOL OnKillActive();
	//}}AFX_VIRTUAL

// Implementation
protected:
	void SetButtons();
	void GetSelectedCountry(CString& str);
	void SetSelectedCountry(CString& str);
	// Generated message map functions
	//{{AFX_MSG(CGeoInfoPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeNewkeyLocality();
	afx_msg void OnChangeNewkeyState();
	afx_msg void OnEditchangeNewkeyCountry();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(_GEOINFOPAGE_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\getwhatpage.h ===
#if !defined(AFX_GETWHATPAGE_H__E8F5A02F_1372_11D2_8A1D_000000000000__INCLUDED_)
#define AFX_GETWHATPAGE_H__E8F5A02F_1372_11D2_8A1D_000000000000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// GetWhatPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CGetWhatPage window
class CCertificate;

class CGetWhatPage : public CIISWizardPage
{
	DECLARE_DYNCREATE(CGetWhatPage)
// Construction
public:
	CGetWhatPage(CCertificate * pCert = NULL);
	~CGetWhatPage();

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WELCOME_START,
		IDD_PAGE_NEXT_NEW = IDD_PAGE_WIZ_CHOOSE_CATYPE,
		IDD_PAGE_NEXT_EXISTING = IDD_PAGE_WIZ_CHOOSE_CERT,
		IDD_PAGE_NEXT_IMPORT = IDD_PAGE_WIZ_GETKEY_FILE,
        IDD_PAGE_NEXT_IMPORT_PFX = IDD_PAGE_WIZ_GET_IMPORT_PFX_FILE,
        IDD_PAGE_NEXT_COPY_MOVE_REMOTE = IDD_PAGE_WIZ_CHOOSE_COPY_MOVE_FROM_REMOTE
	};
// Dialog Data
	//{{AFX_DATA(CGetWhatPage)
	enum { IDD = IDD_PAGE_WIZ_GET_WHAT };
	int		m_Index;
	//}}AFX_DATA
	CCertificate * m_pCert;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CGetWhatPage)
   public:
   virtual BOOL OnSetActive();
	virtual LRESULT OnWizardPrev();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CGetWhatPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_GETWHATPAGE_H__E8F5A02F_1372_11D2_8A1D_000000000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\finalpages.h ===
#if !defined(AFX_FINALPAGES_H__98544A13_3C60_11D2_8180_0000F87A921B__INCLUDED_)
#define AFX_FINALPAGES_H__98544A13_3C60_11D2_8180_0000F87A921B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// FinalPages.h : header file
//
#include "HotLink.h"
#include "BookEndPage.h"

class CCertificate;

/////////////////////////////////////////////////////////////////////////////
// CFinalInstalledPage dialog
class CFinalInstalledPage : public CIISWizardBookEnd2
{
	DECLARE_DYNCREATE(CFinalInstalledPage)

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_INSTALL_RESP
	};
// Construction
public:
	CFinalInstalledPage(HRESULT * phResult = NULL, CCertificate * pCert = NULL);
	~CFinalInstalledPage();

// Dialog Data
	//{{AFX_DATA(CFinalInstalledPage)
	enum { IDD = IDD_PAGE_WIZ_FINAL_INSTALL };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA
	CCertificate * m_pCert;
	UINT m_idBodyText;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFinalInstalledPage)
	public:
	protected:
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFinalInstalledPage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CFinalReplacedPage dialog
class CFinalReplacedPage : public CIISWizardBookEnd2
{
	DECLARE_DYNCREATE(CFinalReplacedPage)

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_REPLACE_CERT
	};
// Construction
public:
	CFinalReplacedPage(HRESULT * phResult = NULL, CCertificate * pCert = NULL);
	~CFinalReplacedPage();

// Dialog Data
	//{{AFX_DATA(CFinalReplacedPage)
	enum { IDD = IDD_PAGE_WIZ_FINAL_REPLACE };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA
	CCertificate * m_pCert;
	UINT m_idBodyText;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFinalReplacedPage)
	public:
	protected:
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFinalReplacedPage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CFinalRemovePage dialog
class CFinalRemovePage : public CIISWizardBookEnd2
{
	DECLARE_DYNCREATE(CFinalRemovePage)

// Construction
public:
	CFinalRemovePage(HRESULT * phResult = NULL, CCertificate * pCert = NULL);
	~CFinalRemovePage();

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_REMOVE_CERT,
	};
// Dialog Data
	//{{AFX_DATA(CFinalRemovePage)
	enum { IDD = IDD_PAGE_WIZ_FINAL_REMOVE };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA
	CCertificate * m_pCert;
	UINT m_idBodyText;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFinalRemovePage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFinalRemovePage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CFinalToFilePage dialog

class CFinalToFilePage : public CIISWizardBookEnd2
{
	DECLARE_DYNCREATE(CFinalToFilePage)

// Construction
public:
	CFinalToFilePage(HRESULT * phResult = NULL, CCertificate * pCert = NULL);
	~CFinalToFilePage();

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_REQUEST_DUMP
	};
// Dialog Data
	//{{AFX_DATA(CFinalToFilePage)
	enum { IDD = IDD_PAGE_WIZ_FINAL_TO_FILE };
//	CHotLink	m_hotlink_codessite;
	//}}AFX_DATA
	CCertificate * m_pCert;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFinalToFilePage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	public:
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFinalToFilePage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CFinalCancelPage dialog
class CFinalCancelPage : public CIISWizardBookEnd2
{
	DECLARE_DYNCREATE(CFinalCancelPage)

// Construction
public:
	CFinalCancelPage(HRESULT * phResult = NULL, CCertificate * pCert = NULL);
	~CFinalCancelPage();

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_CANCEL_REQUEST,
	};
// Dialog Data
	//{{AFX_DATA(CFinalCancelPage)
	enum { IDD = IDD_PAGE_WIZ_FINAL_CANCEL };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA
	CCertificate * m_pCert;
	UINT m_idBodyText;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFinalCancelPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFinalCancelPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};



/////////////////////////////////////////////////////////////////////////////
// CFinalInstalledPage dialog
class CFinalInstalledImportPFXPage : public CIISWizardBookEnd2
{
	DECLARE_DYNCREATE(CFinalInstalledImportPFXPage)

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_INSTALL_IMPORT_PFX
	};
// Construction
public:
	CFinalInstalledImportPFXPage(HRESULT * phResult = NULL, CCertificate * pCert = NULL);
	~CFinalInstalledImportPFXPage();

// Dialog Data
	//{{AFX_DATA(CFinalInstalledImportPFXPage)
	enum { IDD = IDD_PAGE_WIZ_FINAL_INSTALL_IMPORT_PFX };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA
	CCertificate * m_pCert;
	UINT m_idBodyText;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFinalInstalledImportPFXPage)
	public:
	protected:
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFinalInstalledImportPFXPage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};



/////////////////////////////////////////////////////////////////////////////
// CFinalInstalledPage dialog
class CFinalInstalledExportPFXPage : public CIISWizardBookEnd2
{
	DECLARE_DYNCREATE(CFinalInstalledExportPFXPage)

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_INSTALL_EXPORT_PFX
	};
// Construction
public:
	CFinalInstalledExportPFXPage(HRESULT * phResult = NULL, CCertificate * pCert = NULL);
	~CFinalInstalledExportPFXPage();

// Dialog Data
	//{{AFX_DATA(CFinalInstalledExportPFXPage)
	enum { IDD = IDD_PAGE_WIZ_FINAL_INSTALL_EXPORT_PFX };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA
	CCertificate * m_pCert;
	UINT m_idBodyText;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFinalInstalledExportPFXPage)
	public:
	protected:
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFinalInstalledExportPFXPage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};


/////////////////////////////////////////////////////////////////////////////
// CFinalInstalledPage dialog
class CFinalInstalledCopyFromRemotePage : public CIISWizardBookEnd2
{
	DECLARE_DYNCREATE(CFinalInstalledCopyFromRemotePage)

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_CHOOSE_SERVER_SITE
	};
// Construction
public:
	CFinalInstalledCopyFromRemotePage(HRESULT * phResult = NULL, CCertificate * pCert = NULL);
	~CFinalInstalledCopyFromRemotePage();

// Dialog Data
	//{{AFX_DATA(CFinalInstalledCopyFromRemotePage)
	enum { IDD = IDD_PAGE_WIZ_FINAL_INSTALL_COPY_FROM_REMOTE };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA
	CCertificate * m_pCert;
	UINT m_idBodyText;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFinalInstalledCopyFromRemotePage)
	public:
	protected:
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFinalInstalledCopyFromRemotePage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

class CFinalInstalledMoveFromRemotePage : public CIISWizardBookEnd2
{
	DECLARE_DYNCREATE(CFinalInstalledMoveFromRemotePage)

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_CHOOSE_SERVER_SITE
	};
// Construction
public:
	CFinalInstalledMoveFromRemotePage(HRESULT * phResult = NULL, CCertificate * pCert = NULL);
	~CFinalInstalledMoveFromRemotePage();

// Dialog Data
	//{{AFX_DATA(CFinalInstalledMoveFromRemotePage)
	enum { IDD = IDD_PAGE_WIZ_FINAL_INSTALL_MOVE_FROM_REMOTE };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA
	CCertificate * m_pCert;
	UINT m_idBodyText;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFinalInstalledMoveFromRemotePage)
	public:
	protected:
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFinalInstalledMoveFromRemotePage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

class CFinalInstalledCopyToRemotePage : public CIISWizardBookEnd2
{
	DECLARE_DYNCREATE(CFinalInstalledCopyToRemotePage)

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_CHOOSE_SERVER_SITE
	};
// Construction
public:
	CFinalInstalledCopyToRemotePage(HRESULT * phResult = NULL, CCertificate * pCert = NULL);
	~CFinalInstalledCopyToRemotePage();

// Dialog Data
	//{{AFX_DATA(CFinalInstalledCopyToRemotePage)
	enum { IDD = IDD_PAGE_WIZ_FINAL_INSTALL_COPY_TO_REMOTE };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA
	CCertificate * m_pCert;
	UINT m_idBodyText;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFinalInstalledCopyToRemotePage)
	public:
	protected:
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFinalInstalledCopyToRemotePage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};


class CFinalInstalledMoveToRemotePage : public CIISWizardBookEnd2
{
	DECLARE_DYNCREATE(CFinalInstalledMoveToRemotePage)

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_CHOOSE_SERVER_SITE
	};
// Construction
public:
	CFinalInstalledMoveToRemotePage(HRESULT * phResult = NULL, CCertificate * pCert = NULL);
	~CFinalInstalledMoveToRemotePage();

// Dialog Data
	//{{AFX_DATA(CFinalInstalledMoveToRemotePage)
	enum { IDD = IDD_PAGE_WIZ_FINAL_INSTALL_MOVE_TO_REMOTE };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA
	CCertificate * m_pCert;
	UINT m_idBodyText;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFinalInstalledMoveToRemotePage)
	public:
	protected:
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFinalInstalledMoveToRemotePage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FINALPAGES_H__98544A13_3C60_11D2_8180_0000F87A921B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\managecertpage.cpp ===
// ManageCertPage.cpp : implementation file
//

#include "stdafx.h"
#include "CertWiz.h"
#include "ManageCertPage.h"
#include "Certificat.h"
#include "certutil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CManageCertPage property page

IMPLEMENT_DYNCREATE(CManageCertPage, CIISWizardPage)

CManageCertPage::CManageCertPage(CCertificate * pCert) 
	: CIISWizardPage(CManageCertPage::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CManageCertPage)
	m_Index = -1;
	//}}AFX_DATA_INIT
}

CManageCertPage::~CManageCertPage()
{
}

void CManageCertPage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CManageCertPage)
	DDX_Radio(pDX, IDC_RENEW_CERT, m_Index);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CManageCertPage, CIISWizardPage)
	//{{AFX_MSG_MAP(CManageCertPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CManageCertPage message handlers

LRESULT CManageCertPage::OnWizardBack() 
{
	return IDD_PAGE_PREV;
}

LRESULT CManageCertPage::OnWizardNext() 
{
	LRESULT res = 1;
	UpdateData();
	switch (m_Index)
	{
	case CONTINUE_RENEW:
		m_pCert->SetStatusCode(CCertificate::REQUEST_RENEW_CERT);
		res = IDD_PAGE_NEXT_RENEW;
		break;
	case CONTINUE_REMOVE:
		res = IDD_PAGE_NEXT_REMOVE;
		break;
	case CONTINUE_REPLACE:
		m_pCert->SetStatusCode(CCertificate::REQUEST_REPLACE_CERT);
		res = IDD_PAGE_NEXT_REPLACE;
		break;
	case CONTINUE_EXPORT_PFX:
		m_pCert->SetStatusCode(CCertificate::REQUEST_EXPORT_CERT);
		res = IDD_PAGE_NEXT_EXPORT_PFX;
		break;
	case CONTINUE_COPY_MOVE_TO_REMOTE:
		m_pCert->SetStatusCode(CCertificate::REQUEST_COPY_MOVE_TO_REMOTE);
		res = IDD_PAGE_NEXT_COPY_MOVE_TO_REMOTE;
		break;
	}
	return res;
}

BOOL CManageCertPage::OnSetActive() 
{
	m_pCert->SetStatusCode(CCertificate::REQUEST_UNDEFINED);
	SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);
	return CIISWizardPage::OnSetActive();
}

BOOL CManageCertPage::OnInitDialog() 
{
	m_Index = 0;
	CIISWizardPage::OnInitDialog();
	// we should make some checks and disable some buttons
	if (m_pCert->MyStoreCertCount() == 0)
	{
		ASSERT(NULL != GetDlgItem(IDC_REPLACE_CERT));
		GetDlgItem(IDC_REPLACE_CERT)->EnableWindow(FALSE);
	}

    // Enable or disable controls based on weather certobj is installed
    GetDlgItem(IDC_EXPORT_PFX_CERT)->EnableWindow(m_pCert->m_CertObjInstalled);
    GetDlgItem(IDC_EXPORT_PFX_CERT2)->EnableWindow(m_pCert->m_CertObjInstalled);

    if (m_pCert->m_CertObjInstalled)
    {
        BOOL fExportable = FALSE;
        GetDlgItem(IDC_EXPORT_PFX_CERT)->ShowWindow(SW_SHOW);
        GetDlgItem(IDC_EXPORT_PFX_CERT2)->ShowWindow(SW_SHOW);

        fExportable = IsCertExportable(m_pCert->GetInstalledCert());
        // if it is not exportable, then grey it out
        GetDlgItem(IDC_EXPORT_PFX_CERT)->EnableWindow(fExportable);
        GetDlgItem(IDC_EXPORT_PFX_CERT2)->EnableWindow(fExportable);
    }

    // Turn off for workstation.
    if (TRUE == IsWhistlerWorkstation())
    {
        GetDlgItem(IDC_EXPORT_PFX_CERT)->ShowWindow(SW_HIDE);
        GetDlgItem(IDC_EXPORT_PFX_CERT2)->ShowWindow(SW_HIDE);
    }
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\keypasswordpage.cpp ===
// KeyPasswordPage.cpp : implementation file
//

#include "stdafx.h"
#include "CertWiz.h"
#include "KeyPasswordPage.h"
#include "YesNoUsage.h"
#include "Certificat.h"
#include "CertUtil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CKeyPasswordPage property page

IMPLEMENT_DYNCREATE(CKeyPasswordPage, CIISWizardPage)

CKeyPasswordPage::CKeyPasswordPage(CCertificate * pCert) 
	: CIISWizardPage(CKeyPasswordPage::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CKeyPasswordPage)
	m_Password = _T("");
	//}}AFX_DATA_INIT
}

CKeyPasswordPage::~CKeyPasswordPage()
{
}

void CKeyPasswordPage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CKeyPasswordPage)
	DDX_Text_SecuredString(pDX, IDC_KEYPASSWORD, m_Password);
	DDV_MaxChars_SecuredString(pDX, m_Password, 64);
	//DDX_Text(pDX, IDC_KEYPASSWORD, m_Password);
	//DDV_MaxChars(pDX, m_Password, 64);
	//}}AFX_DATA_MAP
}

LRESULT 
CKeyPasswordPage::OnWizardBack()
/*++
Routine Description:
    Prev button handler

Arguments:
    None

Return Value:
	0 to automatically advance to the prev page;
	1 to prevent the page from changing. 
	To jump to a page other than the prev one, 
	return the identifier of the dialog to be displayed.
--*/
{
	return IDD_PAGE_PREV;
}

LRESULT 
CKeyPasswordPage::OnWizardNext()
{
	UpdateData(TRUE);

	if (0 != m_Password.Compare(m_pCert->m_KeyPassword))
	{
		m_pCert->DeleteKeyRingCert();
        m_Password.CopyTo(m_pCert->m_KeyPassword);
	}
    
	if (NULL == m_pCert->GetKeyRingCert())
	{
		// probably password was wrong
		CString txt;
		txt.LoadString(IDS_FAILED_IMPORT_KEY_FILE);
		ASSERT(GetDlgItem(IDC_ERROR_TEXT) != NULL);
		SetDlgItemText(IDC_ERROR_TEXT, txt);
		GetDlgItem(IDC_KEYPASSWORD)->SetFocus();
		GetDlgItem(IDC_KEYPASSWORD)->SendMessage(EM_SETSEL, 0, -1);
		SetWizardButtons(PSWIZB_BACK);
		return 1;
	}

#ifdef ENABLE_W3SVC_SSL_PAGE
        if (IsWebServerType(m_pCert->m_WebSiteInstanceName))
        {
            return IDD_PAGE_NEXT_INSTALL_W3SVC_ONLY;
        }
#endif

	return IDD_PAGE_NEXT;
}

BOOL 
CKeyPasswordPage::OnSetActive() 
{
	ASSERT(m_pCert != NULL);
    m_pCert->m_KeyPassword.CopyTo(m_Password);
	UpdateData(FALSE);
	SetWizardButtons(m_Password.IsEmpty() ? PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	return CIISWizardPage::OnSetActive();
}

BOOL
CKeyPasswordPage::OnKillActive()
{
	UpdateData();
    m_Password.CopyTo(m_pCert->m_KeyPassword);
	return CIISWizardPage::OnKillActive();
}

BEGIN_MESSAGE_MAP(CKeyPasswordPage, CIISWizardPage)
	//{{AFX_MSG_MAP(CKeyPasswordPage)
	ON_EN_CHANGE(IDC_KEYPASSWORD, OnEditchangePassword)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSiteNamePage message handlers

void CKeyPasswordPage::OnEditchangePassword() 
{
	UpdateData(TRUE);	
	SetWizardButtons(m_Password.IsEmpty() ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	CString str;
	SetDlgItemText(IDC_ERROR_TEXT, str);
}




/////////////////////////////////////////////////////////////////////////////
// CKeyPasswordPage property page

IMPLEMENT_DYNCREATE(CImportPFXPasswordPage, CIISWizardPage)

CImportPFXPasswordPage::CImportPFXPasswordPage(CCertificate * pCert) 
	: CIISWizardPage(CImportPFXPasswordPage::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CImportPFXPasswordPage)
	m_Password = _T("");
	//}}AFX_DATA_INIT
}

CImportPFXPasswordPage::~CImportPFXPasswordPage()
{
}

void CImportPFXPasswordPage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CImportPFXPasswordPage)
	//DDX_Text(pDX, IDC_KEYPASSWORD, m_Password);
	//DDV_MaxChars(pDX, m_Password, 64);
	DDX_Text_SecuredString(pDX, IDC_KEYPASSWORD, m_Password);
	DDV_MaxChars_SecuredString(pDX, m_Password, 64);
	//}}AFX_DATA_MAP
}

LRESULT 
CImportPFXPasswordPage::OnWizardBack()
/*++
Routine Description:
    Prev button handler

Arguments:
    None

Return Value:
	0 to automatically advance to the prev page;
	1 to prevent the page from changing. 
	To jump to a page other than the prev one, 
	return the identifier of the dialog to be displayed.
--*/
{
	return IDD_PAGE_PREV;
}

LRESULT 
CImportPFXPasswordPage::OnWizardNext()
{
	UpdateData(TRUE);

    if (0 != m_Password.Compare(m_pCert->m_KeyPassword))
	{
		m_pCert->DeleteKeyRingCert();
        m_Password.CopyTo(m_pCert->m_KeyPassword);
	}

    // if existing cert exists, then just over write it.
    m_pCert->m_OverWriteExisting = TRUE;
	if (NULL == m_pCert->GetPFXFileCert())
	{
		// probably password was wrong
        goto OnWizardNext_Error;
	}

    /*
	if (NULL == m_pCert->GetPFXFileCert())
	{
        // Check if the error was -- object already exist.
        // if this is what the error is then
        // we have to ask the user if they want to replace the
        // existing cert!
        if (CRYPT_E_EXISTS == m_pCert->m_hResult)
        {
            // Try to get the certificate hash.
            //DisplayUsageBySitesOfCert((LPCTSTR) m_pCert->m_KeyFileName,(LPCTSTR) m_pCert->m_KeyPassword,m_pCert->m_MachineName_Remote,m_pCert->m_UserName_Remote,m_pCert->m_UserPassword_Remote,m_pCert->m_WebSiteInstanceName_Remote);

            CYesNoUsage YesNoUsageDialog(m_pCert);
            INT_PTR nRet = YesNoUsageDialog.DoModal();
            switch (nRet)
            {
                case IDOK:
                    // make sure to overwrite.
                    m_pCert->m_OverWriteExisting = TRUE;
                    if (NULL != m_pCert->GetPFXFileCert())
                    {
                        goto OnWizardNext_Exit;
                    }
                    break;
                case IDCANCEL:
                default:
                    return 1;
                    break;
            };

            // ask them if they want to try it again...
            //CString strFilename;
	        //CString strMessage;
            //strFilename = m_pCert->m_KeyFileName;
	        //AfxFormatString1(strMessage, IDS_REPLACE_FILE, strFilename);
	        //if (IDYES == AfxMessageBox(strMessage, MB_ICONEXCLAMATION | MB_YESNO))
            //{
            //    // make sure to overwrite.
            //    m_pCert->m_OverWriteExisting = TRUE;
            //    if (NULL != m_pCert->GetPFXFileCert())
            //    {
            //        goto OnWizardNext_Exit;
            //    }
            //}
        }

        goto OnWizardNext_Error;
	}
    */

#ifdef ENABLE_W3SVC_SSL_PAGE
        if (IsWebServerType(m_pCert->m_WebSiteInstanceName))
        {
            return IDD_PAGE_NEXT_INSTALL_W3SVC_ONLY;
        }
#endif

	return IDD_PAGE_NEXT;

OnWizardNext_Error:
    // probably password was wrong
    CString txt;
    txt.LoadString(IDS_FAILED_IMPORT_PFX_FILE);
    ASSERT(GetDlgItem(IDC_ERROR_TEXT) != NULL);
    SetDlgItemText(IDC_ERROR_TEXT, txt);
    GetDlgItem(IDC_KEYPASSWORD)->SetFocus();
    GetDlgItem(IDC_KEYPASSWORD)->SendMessage(EM_SETSEL, 0, -1);
    SetWizardButtons(PSWIZB_BACK);
    return 1;
}

BOOL 
CImportPFXPasswordPage::OnSetActive() 
{
	ASSERT(m_pCert != NULL);
    m_pCert->m_KeyPassword.CopyTo(m_Password);
	UpdateData(FALSE);
	SetWizardButtons(m_Password.IsEmpty() ? PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	return CIISWizardPage::OnSetActive();
}

BOOL
CImportPFXPasswordPage::OnKillActive()
{
	UpdateData();
    m_Password.CopyTo(m_pCert->m_KeyPassword);
	return CIISWizardPage::OnKillActive();
}

BEGIN_MESSAGE_MAP(CImportPFXPasswordPage, CIISWizardPage)
	//{{AFX_MSG_MAP(CImportPFXPasswordPage)
	ON_EN_CHANGE(IDC_KEYPASSWORD, OnEditchangePassword)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSiteNamePage message handlers

void CImportPFXPasswordPage::OnEditchangePassword() 
{
	UpdateData(TRUE);	
	SetWizardButtons(m_Password.IsEmpty() ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	CString str;
	SetDlgItemText(IDC_ERROR_TEXT, str);
}







/////////////////////////////////////////////////////////////////////////////
// CExportPFXPasswordPage property page

IMPLEMENT_DYNCREATE(CExportPFXPasswordPage, CIISWizardPage)

CExportPFXPasswordPage::CExportPFXPasswordPage(CCertificate * pCert) 
	: CIISWizardPage(CExportPFXPasswordPage::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CExportPFXPasswordPage)
	m_Password = _T("");
    m_Password2 = _T("");
    m_Export_Private_key = FALSE;
	//}}AFX_DATA_INIT

	m_Password.Empty();
	m_Password2.Empty();
}

CExportPFXPasswordPage::~CExportPFXPasswordPage()
{
}

void CExportPFXPasswordPage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CExportPFXPasswordPage)
	//DDX_Text(pDX, IDC_KEYPASSWORD, m_Password);
    //DDX_Text(pDX, IDC_KEYPASSWORD2, m_Password2);
	//DDV_MaxChars(pDX, m_Password, 64);
    //DDV_MaxChars(pDX, m_Password2, 64);
	DDX_Text_SecuredString(pDX, IDC_KEYPASSWORD, m_Password);
    DDX_Text_SecuredString(pDX, IDC_KEYPASSWORD2, m_Password2);
	DDV_MaxChars_SecuredString(pDX, m_Password, 64);
    DDV_MaxChars_SecuredString(pDX, m_Password2, 64);

    DDX_Check(pDX, IDC_CHK_EXPORT_PRIVATE, m_Export_Private_key);
	//}}AFX_DATA_MAP
}

LRESULT 
CExportPFXPasswordPage::OnWizardBack()
/*++
Routine Description:
    Prev button handler

Arguments:
    None

Return Value:
	0 to automatically advance to the prev page;
	1 to prevent the page from changing. 
	To jump to a page other than the prev one, 
	return the identifier of the dialog to be displayed.
--*/
{
	return IDD_PAGE_PREV;
}

LRESULT 
CExportPFXPasswordPage::OnWizardNext()
{
	UpdateData(TRUE);

    if (0 != m_Password.Compare(m_Password2))
    {
        AfxMessageBox(IDS_PASSWORDS_DOESNT_MATCH);
        return 1;
    }

    if (0 != m_Password.Compare(m_pCert->m_KeyPassword))
	{
		m_pCert->DeleteKeyRingCert();
        m_Password.CopyTo(m_pCert->m_KeyPassword);

        m_pCert->m_ExportPFXPrivateKey = m_Export_Private_key;
        // There is no sense exporting the key with the private key!
        // that's why this HAS to be true!
        m_pCert->m_ExportPFXPrivateKey = TRUE;
	}
    
    /*
	if (NULL == m_pCert->GetKeyRingCert())
	{
		// probably password was wrong
		CString txt;
		txt.LoadString(IDS_FAILED_IMPORT_KEY_FILE);
		ASSERT(GetDlgItem(IDC_ERROR_TEXT) != NULL);
		SetDlgItemText(IDC_ERROR_TEXT, txt);
		GetDlgItem(IDC_KEYPASSWORD)->SetFocus();
		GetDlgItem(IDC_KEYPASSWORD)->SendMessage(EM_SETSEL, 0, -1);
		SetWizardButtons(PSWIZB_BACK);
		return 1;
	}
    */
	return IDD_PAGE_NEXT;
}

BOOL 
CExportPFXPasswordPage::OnSetActive() 
{
	ASSERT(m_pCert != NULL);
    m_pCert->m_KeyPassword.CopyTo(m_Password);
	UpdateData(FALSE);
    SetWizardButtons((m_Password.IsEmpty() || m_Password2.IsEmpty()) ? PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);

	return CIISWizardPage::OnSetActive();
}

BOOL
CExportPFXPasswordPage::OnKillActive()
{
	UpdateData();
    m_Password.CopyTo(m_pCert->m_KeyPassword);
	return CIISWizardPage::OnKillActive();
}

BEGIN_MESSAGE_MAP(CExportPFXPasswordPage, CIISWizardPage)
	//{{AFX_MSG_MAP(CExportPFXPasswordPage)
	ON_EN_CHANGE(IDC_KEYPASSWORD, OnEditchangePassword)
    ON_EN_CHANGE(IDC_KEYPASSWORD2, OnEditchangePassword)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CExportPFXPasswordPage::OnEditchangePassword() 
{
	UpdateData(TRUE);	
	SetWizardButtons(( m_Password.IsEmpty() || m_Password2.IsEmpty()) ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	CString str;
	SetDlgItemText(IDC_ERROR_TEXT, str);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\mru.h ===
//
// mru.h
//
#define MAX_MRU   10
BOOL LoadMRU(LPCTSTR mru_name, CComboBox * pCombo, int nMax);
BOOL AddToMRU(LPCTSTR mru_name, CString& str);
BOOL LoadMRUToCombo(CWnd * pDlg, int id, LPCTSTR mru_name, LPCTSTR str, int mru_size);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\iisdebug.h ===
#include "stdafx.h"
#include "debugdefs.h"

extern g_iDebugOutputLevel;

#if defined(_DEBUG) || DBG
	#define DEBUG_FLAG
#endif

#ifdef DEBUG_FLAG
    inline void _cdecl DebugTrace(LPTSTR lpszFormat, ...)
    {
        // Only do this if the flag is set.
        if (0 != g_iDebugOutputLevel)
        {
			if (DEBUG_FLAG_MODULE_CERTWIZ & g_iDebugOutputLevel)
			{
				int nBuf;
				TCHAR szBuffer[_MAX_PATH];
				va_list args;
				va_start(args, lpszFormat);

				nBuf = _vsntprintf(szBuffer, sizeof(szBuffer)/sizeof(szBuffer[0]), lpszFormat, args);

				OutputDebugString(szBuffer);
				va_end(args);

				// if it does not end if '\r\n' then make one.
				int nLen = _tcslen(szBuffer);
				if (szBuffer[nLen-1] != _T('\n')){OutputDebugString(_T("\r\n"));}
			}
        }
    }
#else
    inline void _cdecl DebugTrace(LPTSTR , ...){}
#endif

void GetOutputDebugFlag(void);

#define IISDebugOutput DebugTrace
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\mru.cpp ===
//
// mru.cpp
//
#include "stdafx.h"
#include "CertWiz.h"

#include <commctrl.h>
#include <comctrlp.h>
#include <shlwapi.h>
#include "mru.h"

extern CCertWizApp NEAR theApp;

/***********************************************************************
	Thunks to internal functions in ComCtl32
 */

const TCHAR szComCtl32[] = _T("comctl32.dll");

#ifdef UNICODE
#define CREATE_LIST_ORD			400
#define ADD_MRU_STRING_ORD		401
#define ENUM_MRU_LIST_ORD		403
#define FIND_MRU_STRING_ORD	402
#else
#define CREATE_LIST_ORD			151
#define ADD_MRU_STRING_ORD		153
#define ENUM_MRU_LIST_ORD		154
#define FIND_MRU_STRING_ORD	155
#endif
#define FREE_LIST_ORD			152
#define DEL_MRU_STRING_ORD		156
#define DPA_SET_PTR_ORD			335

typedef HANDLE (CALLBACK *CREATE_MRU_LIST)(LPMRUINFO);
typedef void (CALLBACK *FREE_MRU_LIST)(HANDLE);
typedef int (CALLBACK *ADD_MRU_STRING)(HANDLE, LPCTSTR);
typedef int (CALLBACK *DEL_MRU_STRING)(HANDLE, int);
typedef int (CALLBACK *FIND_MRU_STRING)(HANDLE, LPCTSTR, LPINT);
typedef int (CALLBACK *ENUM_MRU_LIST)(HANDLE, int, LPVOID, UINT);

typedef struct _DPA * HDPA;
typedef BOOL (CALLBACK *DPA_SET_PTR)(HDPA hdpa, int i, LPVOID p);

static HINSTANCE
_GetComCtlInstance()
{
	static HANDLE g_hInst;
	if (g_hInst == NULL)
	{
		g_hInst = GetModuleHandle(szComCtl32);
		if (NULL == g_hInst)
			g_hInst = LoadLibrary(szComCtl32);
		ASSERT(NULL != g_hInst);
	}
	return (HINSTANCE)g_hInst;
}

static HANDLE 
_CreateMRUList(LPMRUINFO pmi)
{
	static CREATE_MRU_LIST pfnCreateMRUList;
	if (pfnCreateMRUList == NULL)
	{
		pfnCreateMRUList = (CREATE_MRU_LIST)GetProcAddress(
			_GetComCtlInstance(), (LPCSTR)CREATE_LIST_ORD);
	}
	ASSERT(pfnCreateMRUList != NULL);
    if (pfnCreateMRUList)
    {
        return pfnCreateMRUList(pmi);
    }
    else
    {
        return NULL;
    }
}

static void
_FreeMRUList(HANDLE hMru)
{
	static FREE_MRU_LIST pfnFreeMRUList;
	if (pfnFreeMRUList == NULL)
	{
		pfnFreeMRUList = (FREE_MRU_LIST)GetProcAddress(
			_GetComCtlInstance(), (LPCSTR)FREE_LIST_ORD);
	}
	ASSERT(pfnFreeMRUList != NULL);
    if (pfnFreeMRUList){pfnFreeMRUList(hMru);}
}

static int
_AddMRUString(HANDLE hMru, LPCTSTR szString)
{
	static ADD_MRU_STRING pfnAddMRUString;
	if (pfnAddMRUString == NULL)
	{
		pfnAddMRUString = (ADD_MRU_STRING)GetProcAddress(
			_GetComCtlInstance(), (LPCSTR)ADD_MRU_STRING_ORD);
	}
	ASSERT(pfnAddMRUString != NULL);
    if (pfnAddMRUString)
    {
        return pfnAddMRUString(hMru, szString);
    }
    else
    {
        return 0;
    }
}

static int
_DelMRUString(HANDLE hMru, int item)
{
	static DEL_MRU_STRING pfnDelMRUString;
	if (pfnDelMRUString == NULL)
	{
		pfnDelMRUString = (DEL_MRU_STRING)GetProcAddress(
			_GetComCtlInstance(), (LPCSTR)DEL_MRU_STRING_ORD);
	}
	ASSERT(pfnDelMRUString != NULL);
	return pfnDelMRUString(hMru, item);
}

static int
_EnumMRUList(HANDLE hMru, int nItem, LPVOID lpData, UINT uLen)
{
	static ENUM_MRU_LIST pfnEnumMRUList;
	if (pfnEnumMRUList == NULL)
	{
		pfnEnumMRUList = (ENUM_MRU_LIST)GetProcAddress(
			_GetComCtlInstance(), (LPCSTR)ENUM_MRU_LIST_ORD);
	}
	ASSERT(pfnEnumMRUList != NULL);
    if (pfnEnumMRUList)
    {
        return pfnEnumMRUList(hMru, nItem, lpData, uLen);
    }
    else
    {
        return 0;
    }
}

#if 0
static BOOL
_DPA_SetPtr(HDPA hdpa, int i, LPVOID p)
{
	static DPA_SET_PTR pfnDPASetPtr;
	if (pfnDPASetPtr == NULL)
	{
		pfnDPASetPtr = (DPA_SET_PTR)GetProcAddress(
			_GetComCtlInstance(), (LPCSTR)DPA_SET_PTR_ORD);
	}
	ASSERT(pfnDPASetPtr != NULL);
	return pfnDPASetPtr(hdpa, i, p);
}
#endif
/****************************************************************************/

HANDLE 
CreateMRU(const CString& mru_name, int nMax)
{
	MRUINFO mi =  
	{
		sizeof(MRUINFO),
      nMax,
      MRU_CACHEWRITE,
      theApp.RegOpenKeyWizard(),
      mru_name,
      NULL        // NOTE: use default string compare
   };

   //Call the comctl32 mru implementation to load the MRU from
   //the registry
   HANDLE hMRU = _CreateMRUList(&mi);
	RegCloseKey(mi.hKey);
	return hMRU;
}

BOOL 
GetMRUEntry(HANDLE hMRU, int iIndex, CString& str)
{
	BOOL bRes= FALSE;
   //Check for valid parameters
	ASSERT(hMRU != NULL);
     
	//Check for valid index
   if (iIndex >= 0 && iIndex <= _EnumMRUList(hMRU, -1, NULL, 0))
   {
		LPTSTR p = str.GetBuffer(MAX_PATH);
		bRes = (_EnumMRUList(hMRU, iIndex, p, MAX_PATH) > 0);
		str.ReleaseBuffer();
	}
	return bRes;
}

BOOL 
LoadMRU(LPCTSTR mru_name, CComboBox * pCombo, int nMax)
{   
	BOOL fRet = FALSE;
	HANDLE hMRU;
    
	ASSERT(mru_name != NULL && mru_name[0] != 0);
	ASSERT(nMax > 0);

   if (NULL != (hMRU = CreateMRU(mru_name, nMax)))
	{
		//First reset the hwndCombo
		pCombo->ResetContent();

		//Now load the hwndcombo with file list from MRU.
		int i = 0;
		while (nMax > 0)
		{
			CString name;
			if (GetMRUEntry(hMRU, i++, name))
			{
				pCombo->AddString(name);
				nMax--;
				fRet = TRUE;
			}
			else
				break;
		}
		_FreeMRUList(hMRU);
	}
   return fRet;
}

BOOL 
AddToMRU(LPCTSTR mru_name, CString& name)
{
   HANDLE hMRU = CreateMRU(mru_name, 10);
   if (hMRU)
   {
      _AddMRUString(hMRU, name);
		_FreeMRUList(hMRU);
		return TRUE;
	}
   return FALSE;
}

BOOL
LoadMRUToCombo(CWnd * pDlg, int id, LPCTSTR mru_name, LPCTSTR str, int mru_size)
{
	ASSERT(mru_name != NULL);
	ASSERT(str != NULL);
	CComboBox * pCombo = (CComboBox *)CComboBox::FromHandle(pDlg->GetDlgItem(id)->m_hWnd);
	if (LoadMRU(mru_name, pCombo, mru_size))
	{
		// select LRU name in combobox
		if (	CB_ERR == pCombo->SelectString(-1, str)
			&& !str[0] == 0
			)
		{
			// put our default to combobox edit
			pCombo->AddString(str);
			pCombo->SelectString(-1, str);
		}
		return TRUE;
	}
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\managecertpage.h ===
#if !defined(AFX_MANAGECERTPAGE_H__A57C38A8_3B7F_11D2_817E_0000F87A921B__INCLUDED_)
#define AFX_MANAGECERTPAGE_H__A57C38A8_3B7F_11D2_817E_0000F87A921B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ManageCertPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CManageCertPage dialog
class CCertificate;

class CManageCertPage : public CIISWizardPage
{
	DECLARE_DYNCREATE(CManageCertPage)

// Construction
public:
	CManageCertPage(CCertificate * pCert = NULL);
	~CManageCertPage();

	enum
	{
		IDD_PAGE_NEXT_RENEW = IDD_PAGE_WIZ_CHOOSE_CATYPE,
		IDD_PAGE_NEXT_REMOVE = IDD_PAGE_WIZ_REMOVE_CERT,
		IDD_PAGE_NEXT_REPLACE = IDD_PAGE_WIZ_CHOOSE_CERT,
        IDD_PAGE_NEXT_EXPORT_PFX = IDD_PAGE_WIZ_GET_EXPORT_PFX_FILE,
        IDD_PAGE_NEXT_COPY_MOVE_TO_REMOTE = IDD_PAGE_WIZ_CHOOSE_COPY_MOVE_TO_REMOTE,
		IDD_PAGE_PREV = IDD_PAGE_WELCOME_START
	};
	enum
	{
		CONTINUE_RENEW = 0,
		CONTINUE_REMOVE,
		CONTINUE_REPLACE,
        CONTINUE_EXPORT_PFX,
        CONTINUE_COPY_MOVE_TO_REMOTE,
	};
// Dialog Data
	//{{AFX_DATA(CManageCertPage)
	enum { IDD = IDD_PAGE_WIZ_MANAGE_CERT };
	int		m_Index;
	//}}AFX_DATA
	CCertificate * m_pCert;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CManageCertPage)
	public:
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CManageCertPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MANAGECERTPAGE_H__A57C38A8_3B7F_11D2_817E_0000F87A921B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\netutil.cpp ===
//
// NetUtil.cpp
//
#include "stdafx.h"
#include <lm.h>
#include "NetUtil.h"

#include <wincrypt.h>
#include <certrpc.h>
#include <certcli.h>
#include <malloc.h>

#define LEVEL_1						1
#define LEVEL_2						2

BOOL GetCurrentUserFullName(CString& name)
{
	BOOL bRes = FALSE;
	NET_API_STATUS nas;
	WKSTA_USER_INFO_1 * pWksInfo = NULL;
	if (NERR_Success == (nas = NetWkstaUserGetInfo(NULL, 
										LEVEL_1, (BYTE **)&pWksInfo)))
	{
		USER_INFO_2 * pUserInfo = NULL;
		CString strServerName = _T("\\\\");
		ASSERT(pWksInfo->wkui1_logon_server[0] != 0);
		strServerName += pWksInfo->wkui1_logon_server;
		if (NERR_Success == (nas = NetUserGetInfo(
					(LPCWSTR)strServerName,
					(LPCWSTR)pWksInfo->wkui1_username,
					LEVEL_2,
					(BYTE **)&pUserInfo)))
		{
			name = pUserInfo->usri2_full_name;
			if (pUserInfo != NULL)
				NetApiBufferFree(pUserInfo);
			bRes = TRUE;
		}
		if (pWksInfo != NULL)
			NetApiBufferFree(pWksInfo);
	}
	return bRes;
}

#if 0
/*********************************** Direct Cert Request *********************************/

typedef struct _RPC_BINDING_LIST
{
	LPTSTR pszProtSeq;
   LPTSTR pszEndpoint;
} RPC_BINDING_LIST;

RPC_BINDING_LIST g_BindingList[] =
{
	{_T("ncacn_ip_tcp"), NULL},
   {_T("ncacn_np"), _T("\\pipe\\cert")}
};
DWORD g_BindingListSize = sizeof(g_BindingList)/sizeof(g_BindingList[0]);

typedef struct _RPC_ATHN_LIST
{
   DWORD dwAuthnLevel;
   DWORD dwAuthnService;
} RPC_ATHN_LIST;

RPC_ATHN_LIST g_AthnList[] =
{
   { RPC_C_AUTHN_LEVEL_PKT_INTEGRITY, RPC_C_AUTHN_GSS_NEGOTIATE},
   { RPC_C_AUTHN_LEVEL_NONE, RPC_C_AUTHN_NONE }
};
DWORD g_AthnListSize = sizeof(g_AthnList)/sizeof(g_AthnList[0]);

//-----------------------------------------------------------------------
//
// RetrivePKCS7FromCA
//
//------------------------------------------------------------------------
HRESULT 
RetrievePKCS7FromCA(CString& strCALocation,
                    CString& strCAName,
                    LPWSTR pwszRequestString,
                    CRYPT_DATA_BLOB * pPKCS10Blob,
                    CRYPT_DATA_BLOB * pPKCS7Blob,
                    DWORD * pdwStatus,
						  BOOL bRenew)
{
   HRESULT hr = E_FAIL;
   UINT id = 0;
	DWORD dwDisposition = 0;
	DWORD dwErr = 0;
	DWORD dwStatus = 0;
   RPC_STATUS rpcStatus = 0;

	CERTTRANSBLOB tbRequest = {0, NULL};
   CERTTRANSBLOB tbCert = {0, NULL};
   CERTTRANSBLOB tbCertChain = {0, NULL};
   CERTTRANSBLOB tbAttrib = {0, NULL};
   CERTTRANSBLOB tbDispositionMessage = {0, NULL};

   LPTSTR szStringBinding = NULL;
   RPC_BINDING_HANDLE hCARPCBinding = NULL;
   LPTSTR pszCAPrinceName = NULL;

   //input checking
   if (!pPKCS10Blob || !pPKCS7Blob)
      return E_INVALIDARG;

	for (DWORD i = 0; i < g_BindingListSize; i++)
   {
		if (RPC_S_OK != RpcNetworkIsProtseqValid(g_BindingList[i].pszProtSeq))
			continue;
		rpcStatus = RpcStringBindingCompose(NULL, 
										g_BindingList[i].pszProtSeq,
                              (LPTSTR)(LPCTSTR)strCALocation,
                              g_BindingList[i].pszEndpoint,
                              NULL,
                              &szStringBinding);
      if(rpcStatus != RPC_S_OK)
			continue;
		rpcStatus = RpcBindingFromStringBinding(szStringBinding, &hCARPCBinding);
      if (szStringBinding)
			RpcStringFree(&szStringBinding);
      if (rpcStatus != RPC_S_OK)
			continue;
      rpcStatus = RpcEpResolveBinding(hCARPCBinding, ICertPassage_v0_0_c_ifspec);
      if (rpcStatus == RPC_S_OK)
			break;
	}
   if (rpcStatus != RPC_S_OK)
   {
      dwStatus = WIZ_CERT_REQUEST_STATUS_CONNECTION_FAILED;
		hr = E_FAIL;
      goto CLEANUP;
   }

	//add the attribute to the request
   if (pwszRequestString)
   {
		tbAttrib.cb = (wcslen(pwszRequestString) + 1) * sizeof(WCHAR);
      tbAttrib.pb = (BYTE *)pwszRequestString;
   }

   //submit the request
   tbRequest.cb = pPKCS10Blob->cbData;
   tbRequest.pb = pPKCS10Blob->pbData;

   //set the RPC connect as the SNEGO connect, which can authenticate
   //a machine if supported by the system
   //do not need to check the return value since not supported by NT4/Win9x

   for (i = 0; i < g_AthnListSize; i++)
   {
		pszCAPrinceName = NULL;
      if (g_AthnList[i].dwAuthnService != RPC_C_AUTHN_NONE)
      {
			dwErr = RpcMgmtInqServerPrincNameA(hCARPCBinding, 
										g_AthnList[i].dwAuthnService,
                              (PBYTE *)&pszCAPrinceName);
         if (dwErr == RPC_S_UNKNOWN_AUTHN_SERVICE)
				continue;
		}
		dwErr = RpcBindingSetAuthInfo(hCARPCBinding,
										pszCAPrinceName,
                              g_AthnList[i].dwAuthnLevel,
                              g_AthnList[i].dwAuthnService,
                              NULL,
                              RPC_C_AUTHZ_NONE);
		if (pszCAPrinceName)
			RpcStringFree(&pszCAPrinceName);
		if (dwErr == RPC_S_UNKNOWN_AUTHN_SERVICE)
			continue;
      if (dwErr != RPC_S_OK)
			break;
		//determine the format flag
		DWORD dwFlags = CR_IN_BINARY | bRenew ? CR_IN_PKCS7 : CR_IN_PKCS10;
		DWORD dwRequestId = 0;
		__try
      {
			dwErr = CertServerRequest(
			    hCARPCBinding,
             dwFlags,
			    strCAName,
			    &dwRequestId,
			    &dwDisposition,
			    &tbAttrib,
			    &tbRequest,
			    &tbCertChain,
			    &tbCert,
			    &tbDispositionMessage);
		}
      __except(dwErr = GetExceptionCode(), EXCEPTION_EXECUTE_HANDLER)
      {
      }

      if (dwErr != RPC_S_UNKNOWN_AUTHN_SERVICE)
			break;
	}

	if (	dwErr == RPC_S_UNKNOWN_AUTHN_SERVICE 
		||	dwErr == RPC_S_SERVER_UNAVAILABLE 
		||	dwErr == RPC_S_SERVER_TOO_BUSY
		)
	{
      // We tried all of our auth services, but just couldn't connect
      dwStatus = WIZ_CERT_REQUEST_STATUS_CONNECTION_FAILED;
		hr = E_FAIL;
      goto CLEANUP;
	}

   //get the return code
   hr = HRESULT_FROM_WIN32(dwErr);

   //we want to detect the case when hr is S_OK and the
   //request is denied.  In this case, dwDispotion
   //is the REAL hresult code.
   if (hr == S_OK)
   {
		if(FAILED(dwDisposition))
      {
			hr = dwDisposition;
         dwDisposition = CR_DISP_DENIED;
      }
   }
   else
   {
		dwDisposition=CR_DISP_ERROR;
   }

   //map the dwDisposition
	switch (dwDisposition)
   {
   case CR_DISP_DENIED:
		dwStatus = WIZ_CERT_REQUEST_STATUS_REQUEST_DENIED;
		if (!FAILED(hr))
         hr = E_FAIL;
		break;

	case CR_DISP_ISSUED:
		dwStatus = WIZ_CERT_REQUEST_STATUS_CERT_ISSUED;
      break;

	case CR_DISP_ISSUED_OUT_OF_BAND:
		dwStatus = WIZ_CERT_REQUEST_STATUS_ISSUED_SEPARATELY;
      break;

	case CR_DISP_UNDER_SUBMISSION:
		dwStatus = WIZ_CERT_REQUEST_STATUS_UNDER_SUBMISSION;
      break;

	//we should never get CR_DISP_INCOMPLETE or CR_DISP_REVOKED
   //case    CR_DISP_INCOMPLETE:
   //case    CR_DISP_REVOKED:
   case CR_DISP_ERROR:
   default:
		dwStatus = WIZ_CERT_REQUEST_STATUS_REQUEST_ERROR;
		if (!FAILED(hr))
         hr=E_FAIL;
      break;
	}

   if (hr != S_OK)
      goto CLEANUP;

   //copy the PKCS7 blob
   pPKCS7Blob->cbData = tbCertChain.cb;
	pPKCS7Blob->pbData = new BYTE[tbCertChain.cb];

   if (NULL == pPKCS7Blob->pbData)
   {
		hr = E_OUTOFMEMORY;
      dwStatus = WIZ_CERT_REQUEST_STATUS_INSTALL_FAILED;
      goto CLEANUP;
   }
   memcpy(pPKCS7Blob->pbData,tbCertChain.pb,tbCertChain.cb);

   hr = S_OK;

CLEANUP:

	if (pdwStatus)
		*pdwStatus = dwStatus;

	if (tbCert.pb)
		CoTaskMemFree(tbCert.pb);

	if (tbCertChain.pb)
		CoTaskMemFree(tbCertChain.pb);

	if (tbDispositionMessage.pb)
		CoTaskMemFree(tbDispositionMessage.pb);

	if (hCARPCBinding)
		RpcBindingFree(&hCARPCBinding);

	return hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\keypasswordpage.h ===
#if !defined(AFX_KEYPASSWORDPAGE_H__7209C46A_15CB_11D2_91BB_00C04F8C8761__INCLUDED_)
#define AFX_KEYPASSWORDPAGE_H__7209C46A_15CB_11D2_91BB_00C04F8C8761__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// KeyPassword.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CKeyPasswordPage dialog
class CCertificate;

class CKeyPasswordPage : public CIISWizardPage
{
	DECLARE_DYNCREATE(CKeyPasswordPage)

// Construction
public:
	CKeyPasswordPage(CCertificate * pCert = NULL);
	~CKeyPasswordPage();

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_GETKEY_FILE,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_INSTALL_KEYCERT
#ifdef ENABLE_W3SVC_SSL_PAGE
      ,IDD_PAGE_NEXT_INSTALL_W3SVC_ONLY = IDD_PAGE_WIZ_GET_SSL_PORT
#endif
	};
// Dialog Data
	//{{AFX_DATA(CKeyPasswordPage)
	enum { IDD = IDD_PAGE_WIZ_GET_PASSWORD };
	CStrPassword m_Password;
	//}}AFX_DATA
	CCertificate * m_pCert;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CKeyPasswordPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	virtual BOOL OnSetActive();
	virtual BOOL OnKillActive();
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CKeyPasswordPage)
	afx_msg void OnEditchangePassword();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};


class CImportPFXPasswordPage : public CIISWizardPage
{
	DECLARE_DYNCREATE(CImportPFXPasswordPage)

// Construction
public:
	CImportPFXPasswordPage(CCertificate * pCert = NULL);
	~CImportPFXPasswordPage();

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_GET_IMPORT_PFX_FILE,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_INSTALL_IMPORT_PFX
#ifdef ENABLE_W3SVC_SSL_PAGE
      ,IDD_PAGE_NEXT_INSTALL_W3SVC_ONLY = IDD_PAGE_WIZ_GET_SSL_PORT
#endif
	};
// Dialog Data
	//{{AFX_DATA(CImportPFXPasswordPage)
	enum { IDD = IDD_PAGE_WIZ_GET_IMPORT_PFX_PASSWORD };
	CStrPassword m_Password;
	//}}AFX_DATA
	CCertificate * m_pCert;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CImportPFXPasswordPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	virtual BOOL OnSetActive();
	virtual BOOL OnKillActive();
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CImportPFXPasswordPage)
	afx_msg void OnEditchangePassword();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};


class CExportPFXPasswordPage : public CIISWizardPage
{
	DECLARE_DYNCREATE(CExportPFXPasswordPage)

// Construction
public:
	CExportPFXPasswordPage(CCertificate * pCert = NULL);
	~CExportPFXPasswordPage();

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_GET_EXPORT_PFX_FILE,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_INSTALL_EXPORT_PFX
	};
// Dialog Data
	//{{AFX_DATA(CExportPFXPasswordPage)
	enum { IDD = IDD_PAGE_WIZ_GET_EXPORT_PFX_PASSWORD };
	CStrPassword m_Password;
    CStrPassword m_Password2;
    BOOL m_Export_Private_key;
	//}}AFX_DATA
	CCertificate * m_pCert;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CExportPFXPasswordPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	virtual BOOL OnSetActive();
	virtual BOOL OnKillActive();
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CExportPFXPasswordPage)
	afx_msg void OnEditchangePassword();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_KEYPASSWORDPAGE_H__7209C46A_15CB_11D2_91BB_00C04F8C8761__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\notdefined.h ===
//
// notdefined.h
//
// This is temporal header file. We should use it until we will switch
// to latest version of MFC

// From WinUser.h
#if(WINVER < 0x0500)
#define IDC_HAND            MAKEINTRESOURCE(32649)
#endif /* WINVER < 0x0500 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\orginfopage.cpp ===
// OrgInfoPage.cpp : implementation file
//

#include "stdafx.h"
#include "CertWiz.h"
#include "OrgInfoPage.h"
#include "Certificat.h"
#include "mru.h"
#include "strutil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

void DDV_MaxCharsCombo(CDataExchange* pDX, UINT ControlID, CString const& value, int nChars)
{
	ASSERT(nChars >= 1);        // allow them something
	if (pDX->m_bSaveAndValidate && value.GetLength() > nChars)
	{
		DDV_MaxChars(pDX, value, nChars);
	}
	else
	{
	  // limit the control max-chars automatically
	  pDX->m_pDlgWnd->SendDlgItemMessage(ControlID, CB_LIMITTEXT, nChars, 0);
	}
}

/////////////////////////////////////////////////////////////////////////////
// COrgInfoPage property page

IMPLEMENT_DYNCREATE(COrgInfoPage, CIISWizardPage)

COrgInfoPage::COrgInfoPage(CCertificate * pCert) 
	: CIISWizardPage(COrgInfoPage::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(COrgInfoPage)
	m_OrgName = _T("");
	m_OrgUnit = _T("");
	//}}AFX_DATA_INIT
}

COrgInfoPage::~COrgInfoPage()
{
}

void COrgInfoPage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(COrgInfoPage)
	DDX_Text(pDX, IDC_NEWKEY_ORG, m_OrgName);
	DDV_MaxCharsCombo(pDX, IDC_NEWKEY_ORG, m_OrgName, 64);
	DDX_Text(pDX, IDC_NEWKEY_ORGUNIT, m_OrgUnit);
	DDV_MaxCharsCombo(pDX, IDC_NEWKEY_ORGUNIT, m_OrgUnit, 64);
	//}}AFX_DATA_MAP
}

LRESULT 
COrgInfoPage::OnWizardBack()
{
   return m_pCert->m_DefaultCSP ? IDD_PAGE_PREV : IDD_PREV_CSP;
}

LRESULT 
COrgInfoPage::OnWizardNext()
{
    LRESULT lret = 1;
	UpdateData(TRUE);
	m_pCert->m_Organization = m_OrgName;
	m_pCert->m_OrganizationUnit = m_OrgUnit;

    CString buf;
    buf.LoadString(IDS_INVALID_X500_CHARACTERS);
    if (!IsValidX500Chars(m_OrgName))
    {
        GetDlgItem(IDC_NEWKEY_ORG)->SetFocus();
        AfxMessageBox(buf, MB_OK);
    }
    else if (!IsValidX500Chars(m_OrgUnit))
    {
        GetDlgItem(IDC_NEWKEY_ORGUNIT)->SetFocus();
        AfxMessageBox(buf, MB_OK);
    }
    else
    {
        lret = IDD_PAGE_NEXT;
    }

	return lret;
}

BOOL 
COrgInfoPage::OnSetActive() 
{
	SetButtons();
   return CIISWizardPage::OnSetActive();
}

void COrgInfoPage::SetButtons()
{
	UpdateData(TRUE);	
	SetWizardButtons(m_OrgName.IsEmpty() || m_OrgUnit.IsEmpty() ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
}

BEGIN_MESSAGE_MAP(COrgInfoPage, CIISWizardPage)
	//{{AFX_MSG_MAP(COrgInfoPage)
	ON_CBN_EDITCHANGE(IDC_NEWKEY_ORG, OnChangeName)
	ON_CBN_EDITCHANGE(IDC_NEWKEY_ORGUNIT, OnChangeName)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COrgInfoPage message handlers

BOOL COrgInfoPage::OnInitDialog() 
{
	ASSERT(m_pCert != NULL);
	m_OrgName = m_pCert->m_Organization;
	m_OrgUnit = m_pCert->m_OrganizationUnit;
	
	CIISWizardPage::OnInitDialog();
		
	// Load MRU names
	LoadMRUToCombo(this, IDC_NEWKEY_ORG, szOrganizationMRU, m_OrgName, MAX_MRU);
	LoadMRUToCombo(this, IDC_NEWKEY_ORGUNIT, szOrganizationUnitMRU, m_OrgUnit, MAX_MRU);

	GetDlgItem(IDC_NEWKEY_ORG)->SetFocus();
	return FALSE;
}

void COrgInfoPage::OnChangeName() 
{
	SetButtons();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\netutil.h ===
//
// NetUtil.h
//
#ifndef _NETUTIL_H
#define _NETUTIL_H

BOOL GetCurrentUserFullName(CString& name);

#define WIZ_CERT_REQUEST_STATUS_CONNECTION_FAILED		1
#define WIZ_CERT_REQUEST_STATUS_REQUEST_DENIED			2
#define WIZ_CERT_REQUEST_STATUS_CERT_ISSUED				3
#define WIZ_CERT_REQUEST_STATUS_ISSUED_SEPARATELY		4
#define WIZ_CERT_REQUEST_STATUS_UNDER_SUBMISSION		5
#define WIZ_CERT_REQUEST_STATUS_REQUEST_ERROR			6
#define WIZ_CERT_REQUEST_STATUS_INSTALL_FAILED			7



#endif	// _NETUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\orginfopage.h ===
#if !defined(AFX_ORGINFOPAGE_H__549054D7_1561_11D2_8A1F_000000000000__INCLUDED_)
#define AFX_ORGINFOPAGE_H__549054D7_1561_11D2_8A1F_000000000000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// OrgInfoPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// COrgInfoPage dialog

class CCertificate;

class COrgInfoPage : public CIISWizardPage
{
	DECLARE_DYNCREATE(COrgInfoPage)

// Construction
public:
	COrgInfoPage(CCertificate * pCert = NULL);
	~COrgInfoPage();

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_SECURITY_SETTINGS,
      IDD_PREV_CSP = IDD_PAGE_WIZ_CHOOSE_CSP,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_SITE_NAME
	};
// Dialog Data
	//{{AFX_DATA(COrgInfoPage)
	enum { IDD = IDD_PAGE_WIZ_ORG_INFO };
	CString	m_OrgName;
	CString	m_OrgUnit;
	//}}AFX_DATA
	CCertificate * m_pCert;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(COrgInfoPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	virtual BOOL OnSetActive();
	//}}AFX_VIRTUAL

// Implementation
protected:
	void SetButtons();
	// Generated message map functions
	//{{AFX_MSG(COrgInfoPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeName();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ORGINFOPAGE_H__549054D7_1561_11D2_8A1F_000000000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by certwiz.rc
//
#define IDS_CERTWIZ                     1
#define IDB_CERTWIZ                     1
#define IDS_CERTWIZ_PPG                 2
#define IDSHOWUSAGE                     3
#define IDC_USAGE_DISPLAY               3
#define IDS_NO_PORT                     3
#define IDC_LIST1                       30
#define IDD_PAGE_WELCOME_START          132
#define IDS_CERTWIZ_PPG_CAPTION         200
#define IDD_PROPPAGE_CERTWIZ            200
#define IDB_WIZ_LEFT                    201
#define IDS_WELCOME_PAGE_CAPTION        201
#define IDC_COUNTRY_CODE_FILE           201
#define IDB_WIZ_TOP                     202
#define IDS_CHOOSE_CA_PAGE_CAPTION      202
#define IDC_CERT_LIST                   202
#define IDC_BROWSE_CUR                  203
#define IDC_INFO_FILENAME               203
#define IDS_REPLACE_FILE                203
#define IDC_OFFLINE_RADIO               204
#define IDS_PENDING_REQUEST             204
#define IDC_ONLINE_RADIO                205
#define IDS_NEW_CERT                    205
#define IDC_FILE_NAME                   206
#define IDS_REQ_FILE_EXT                206
#define IDD_PAGE_WIZ_CHOOSE_COPY_MOVE_FROM_REMOTE 206
#define IDC_REQUEST_DUMP                207
#define IDS_RESP_FILE_EXT               207
#define IDD_PAGE_WIZ_IMPORT_CERT        207
#define IDC_STATUS_TEXT                 208
#define IDS_REQ_FILE_FILTER             208
#define IDD_PAGE_WIZ_EXPORT_CERT        208
#define IDC_BROWSE_BTN                  209
#define IDS_RESP_FILE_FILTER            209
#define IDD_PAGE_WIZ_GET_IMPORT_PFX_FILE 209
#define IDC_RESP_DUMP                   210
#define IDS_INSTALLED_CERT              210
#define IDD_PAGE_WIZ_GET_EXPORT_PFX_FILE 210
#define IDS_CERT_INSTALLATION_FAILURE   211
#define IDD_PAGE_WIZ_GET_IMPORT_PFX_PASSWORD 211
#define IDS_METABASE_OPEN_FAILURE       212
#define IDD_PAGE_WIZ_GET_EXPORT_PFX_PASSWORD 212
#define IDS_INSTALL_CERT_SUCCESS_HEADER 213
#define IDC_CA_NAME                     213
#define IDD_PAGE_WIZ_INSTALL_IMPORT_PFX 213
#define IDS_INSTALL_CERT_FAILURE_HEADER 214
#define IDC_TARGET_INSTANCE_NAME        214
#define IDD_PAGE_WIZ_INSTALL_EXPORT_PFX 214
#define IDC_CA_NAME2                    214
#define IDS_REMOVE_CERT_FAILED          215
#define IDC_CERT_DUMP                   215
#define IDD_PAGE_WIZ_FINAL_INSTALL_IMPORT_PFX 215
#define IDS_CR_DISP_INCOMPLETE          216
#define IDD_PAGE_WIZ_FINAL_INSTALL_EXPORT_PFX 216
#define IDS_PASSWORDS_DOESNT_MATCH      216
#define IDS_CR_DISP_ERROR               217
#define IDC_KEYPASSWORD                 217
#define IDD_PAGE_WIZ_CHOOSE_COPY_MOVE_TO_REMOTE 217
#define IDS_SITE_NOT_EXIST              217
#define IDS_CR_DISP_DENIED              218
#define IDC_ERROR_TEXT                  218
#define IDD_PAGE_WIZ_CHOOSE_SERVER      218
#define IDS_NOT_TO_ITSELF               218
#define IDS_CR_DISP_ISSUED_OUT_OF_BAND  219
#define IDD_PAGE_WIZ_CHOOSE_SERVER_SITE 219
#define IDC_KEYPASSWORD2                219
#define IDS_CERT_NOT_EXIST_ON_SITE      219
#define IDS_CR_DISP_UNDER_SUBMISSION    220
#define IDC_CERT_CONTENTS               220
#define IDD_PAGE_WIZ_FINAL_INSTALL_COPY_FROM_REMOTE 220
#define IDS_CERT_EXISTS_OVERWRITE       220
#define IDC_RADIO0                      221
#define IDC_PROCESS_PENDING             221
#define IDC_RENEW_CERT                  221
#define IDS_INTERNAL_ERROR              221
#define IDD_PAGE_WIZ_FINAL_INSTALL_MOVE_FROM_REMOTE 221
#define IDC_RADIO1                      222
#define IDC_KILL_PENDING                222
#define IDC_REMOVE_CERT                 222
#define IDS_RESPONSE_CERT_KEY_MISMATCH  222
#define IDD_PAGE_WIZ_INSTALL_COPY_FROM_REMOTE 222
#define IDS_ISSUED_TO                   223
#define IDC_ERROR_MSG                   223
#define IDD_PAGE_WIZ_INSTALL_MOVE_FROM_REMOTE 223
#define IDS_ISSUED_BY                   224
#define IDC_SGC_CERT                    224
#define IDD_PAGE_WIZ_INSTALL_COPY_TO_REMOTE 224
#define IDC_RADIO2                      225
#define IDS_EXPIRATION_DATE             225
#define IDD_PAGE_WIZ_INSTALL_MOVE_TO_REMOTE 225
#define IDS_PURPOSE                     226
#define IDC_RADIO3                      226
#define IDD_PAGE_WIZ_FINAL_INSTALL_COPY_TO_REMOTE 226
#define IDS_FRIENDLY_NAME               227
#define IDC_RADIO4                      227
#define IDD_PAGE_WIZ_FINAL_INSTALL_MOVE_TO_REMOTE 227
#define IDS_FRIENDLYNAME_NONE           228
#define IDD_PAGE_WIZ_CHOOSE_SERVER_TO   228
#define IDS_REMOVE_CERT_SUCCESS_HEADER  229
#define IDD_PAGE_WIZ_CHOOSE_SERVER_SITE_TO 229
#define IDC_REPLACE_CERT                230
#define IDS_REMOVE_CERT_FAILURE_HEADER  230
#define IDD_PAGE_WIZ_CHOOSE_FILENAME_RENEW 230
#define IDS_RESP_FILE_DEFAULT           231
#define IDS_REQ_FILE_DEFAULT            232
#define IDC_STATIC_WZ_BODY2             232
#define IDD_PAGE_WIZ_REQUEST_DUMP_RENEW 232
#define IDS_CANCEL_CERT_SUCCESS_HEADER  233
#define IDC_PHONE_EXT                   233
#define IDD_DIALOG_CHOOSE_SITE          233
#define IDS_CANCEL_CERT_FAILURE_HEADER  234
#define IDC_STATUS_LINE                 234
#define IDD_DIALOG_IMPORT_EXISTS        234
#define IDS_ASK_CREATE_DIR              235
#define IDC_PROVIDER_SELECT             235
#define IDD_DIALOG_DISPLAY_SITES        235
#define IDS_FINAL_TO_FILE_SUCCESS_HEADER 236
#define IDD_PAGE_WIZ_GET_SSL_PORT       236
#define IDS_FINAL_TO_FILE_FAILURE_HEADER 237
#define IDC_CSP_LIST                    237
#define IDS_CERTKEY_MISMATCH_ERROR1     238
#define IDC_IMPORT_PFX_CERT             238
#define IDS_CERTKEY_MISMATCH_ERROR2     239
#define IDC_EXPORT_PFX_CERT             239
#define IDS_WEB_SITE_N                  240
#define IDC_COPY_TO_REMOTE              240
#define IDC_EXPORT_PFX_CERT2            240
#define IDS_KEY_FILE_EXT                241
#define IDC_MOVE_TO_REMOTE              241
#define IDS_KEY_FILE_FILTER             242
#define IDC_COPY_FROM_REMOTE            242
#define IDC_USER_NAME                   242
#define IDS_KEY_FILE_DEFAULT            243
#define IDC_MOVE_FROM_REMOTE            243
#define IDC_USER_PASSWORD               243
#define IDC_STATIC_DESC                 244
#define IDS_FAILED_IMPORT_KEY_FILE      244
#define IDC_SERVER_NAME                 244
#define IDS_COUNTRY                     245
#define IDC_SERVER_SITE_NAME            245
#define IDC_STATIC_DESC_WHERE2MAIL_CERT 246
#define IDS_STATE                       246
#define IDC_CHK_EXPORT_PRIVATE          246
#define IDS_LOCALITY                    247
#define IDC_VIEW_CERT                   247
#define IDS_ORGANIZATION                248
#define IDS_ORGANIZATION_UNIT           249
#define IDS_ANY                         250
#define IDS_CERTKEY_ALREADY_INSTALLED   251
#define IDC_SITE_LIST                   251
#define IDS_CERTKEY_ALREADY_INSTALLED_WHERE 252
#define IDS_FINAL_TO_FILE_BODY_SUCCESS  253
#define IDC_MARK_AS_EXPORTABLE          253
#define IDS_CONTACT_NAME                254
#define IDC_STATIC_EXPORTABLE           254
#define IDS_CONTACT_ADDRESS             255
#define IDC_USAGE_YES                   255
#define IDS_CONTACT_PHONE               256
#define IDC_USAGE_NO                    256
#define IDS_FILE_DOES_NOT_EXIST         257
#define IDC_SSL_PORT                    257
#define IDS_FILE_IS_DIRECTORY           258
#define IDS_CERT_REPLACE_SUCCESS        259
#define IDS_CERT_INSTALLED_SUCCESS      260
#define IDS_CERT_CANCEL_SUCCESS         261
#define IDS_CERT_REMOVE_SUCCESS         262
#define IDS_CERT_REQUEST_SUCCESS        263
#define IDS_MICROSOFT_CA_LINK           264
#define IDS_ALL                         265
#define IDS_WRONG_PHONE_NUMBER          266
#define IDS_INVALID_X500_CHARACTERS     267
#define IDS_PFX_FILE_EXT                268
#define IDS_PFX_FILE_FILTER             269
#define IDS_PFX_FILE_DEFAULT            270
#define IDS_CERT_BEING_USED             271
#define IDS_WEB_SITE_COLUMN             272
#define IDS_FAILED_IMPORT_PFX_FILE      273
#define IDS_PFX_EXPORT_SUCCESS          274
#define IDS_SITE_NUM_COLUMN             275
#define IDS_CERT_NOT_EXPORTABLE         276
#define IDS_CERTOBJ_NOT_IMPLEMENTED     277
#define IDS_CERT_INSTALLED_REMOTE_SUCCESS 278
#define IDS_PORT_ALREADY_USED           279
#define IDS_FAT_DRIVE_WARNING           280
#define IDC_NEWKEY_COUNTRY              1017
#define IDC_NEWKEY_ORG                  1018
#define IDC_NEWKEY_STATE                1019
#define IDC_NEWKEY_ORGUNIT              1020
#define IDC_NEWKEY_LOCALITY             1022
#define IDC_NEWKEY_COMMONNAME           1023
#define IDC_HOTLINK_CCODES              1052
#define IDC_NK_CA_FILE_RADIO            1070
#define IDC_NK_CA_ONLINE_RADIO          1071
#define IDC_NK_CA_ONLINE                1072
#define IDC_CA_ONLINE_LIST              1072
#define IDC_NKUI_USER_NAME              1073
#define IDC_CONTACT_NAME                1073
#define IDC_NK_CA_BROWSE                1074
#define IDC_NK_INFO_FILENAME            1080
#define IDC_NK_CA_FILE                  1082
#define IDC_NKUI_EMAIL_ADDRESS          1083
#define IDC_EMAIL_ADDRESS               1083
#define IDC_NKUI_PHONE_NUMBER           1084
#define IDC_PHONE_NUMBER                1084
#define IDC_NKKI_NAME                   1085
#define IDC_FRIENDLY_NAME               1085
#define IDC_NKKI_BITS                   1086
#define IDC_BIT_LENGTH                  1086
#define IDD_PAGE_WIZ_CHOOSE_CERT        2776
#define IDC_STATIC_WZ_WELCOME           4000
#define IDC_STATIC_WZ_TITLE             4001
#define IDC_STATIC_WZ_SUBTITLE          4002
#define IDC_STATIC_WZ_BODY              4003
#define IDC_STATIC_WZ_CLICK             4004
#define IDC_STATIC_WZ_HEADER_DIVIDER    4005
#define IDD_PAGE_WIZ_GET_WHAT           30140
#define IDD_PAGE_WIZ_CHOOSE_CA          30141
#define IDD_PAGE_WIZ_CHOOSE_ONLINE      30141
#define IDD_PAGE_WIZ_SECURITY_SETTINGS  30142
#define IDD_PAGE_WIZ_ORG_INFO           30143
#define IDD_PAGE_WIZ_SITE_NAME          30144
#define IDD_PAGE_WIZ_GEO_INFO           30145
#define IDD_PAGE_WIZ_CONTACT_INFO       30146
#define IDD_PAGE_WIZ_FILE_INFO          30147
#define IDD_PAGE_WIZ_FINAL_TO_FILE      30148
#define IDD_PAGE_WIZ_CHOOSE_CATYPE      30149
#define IDD_PAGE_WIZ_CHOOSE_FILENAME    30150
#define IDD_PAGE_WIZ_REQUEST_DUMP       30151
#define IDD_PAGE_WIZ_PENDING_WHAT_TODO  30152
#define IDD_PAGE_WIZ_GETRESP_FILE       30153
#define IDD_PAGE_WIZ_INSTALL_RESP       30154
#define IDD_PAGE_WIZ_MANAGE_CERT        30155
#define IDD_PAGE_WIZ_FINAL_INSTALL      30156
#define IDD_PAGE_WIZ_REMOVE_CERT        30157
#define IDD_PAGE_WIZ_FINAL_REMOVE       30158
#define IDD_PAGE_WIZ_ONLINE_DUMP        30159
#define IDD_PAGE_WIZ_ERROR_KEY_MISMATCH 30160
#define IDD_PAGE_WIZ_REPLACE_CERT       30161
#define IDD_PAGE_WIZ_INSTALL_CERT       30162
#define IDD_PAGE_WIZ_CANCEL_REQUEST     30163
#define IDD_PAGE_WIZ_FINAL_CANCEL       30164
#define IDD_PAGE_WIZ_GETKEY_FILE        30165
#define IDD_PAGE_WIZ_GET_PASSWORD       30166
#define IDD_PAGE_WIZ_INSTALL_KEYCERT    30167
#define IDD_PAGE_WIZ_FINAL_REPLACE      30168
#define IDD_PAGE_WIZ_CHOOSE_CSP         30169
#define IDS_COUNTRIES_FIRST             61000
#define ID_STATIC                       65535

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        237
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         258
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\sitenamepage.cpp ===
// SiteNamePage.cpp : implementation file
//

#include "stdafx.h"
#include "CertWiz.h"
#include "SiteNamePage.h"
#include "Certificat.h"
#include "strutil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSiteNamePage property page

IMPLEMENT_DYNCREATE(CSiteNamePage, CIISWizardPage)

CSiteNamePage::CSiteNamePage(CCertificate * pCert) 
	: CIISWizardPage(CSiteNamePage::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CSiteNamePage)
	m_CommonName = _T("");
	//}}AFX_DATA_INIT
}

CSiteNamePage::~CSiteNamePage()
{
}

void CSiteNamePage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSiteNamePage)
	DDX_Text(pDX, IDC_NEWKEY_COMMONNAME, m_CommonName);
	DDV_MaxChars(pDX, m_CommonName, 64);
	//}}AFX_DATA_MAP
}

LRESULT 
CSiteNamePage::OnWizardPrev()
/*++
Routine Description:
    Prev button handler

Arguments:
    None

Return Value:
	0 to automatically advance to the prev page;
	1 to prevent the page from changing. 
	To jump to a page other than the prev one, 
	return the identifier of the dialog to be displayed.
--*/
{
	return IDD_PAGE_PREV;
}

LRESULT 
CSiteNamePage::OnWizardNext()
/*++
Routine Description:
    Next button handler

Arguments:
    None

Return Value:
	0 to automatically advance to the next page;
	1 to prevent the page from changing. 
	To jump to a page other than the next one, 
	return the identifier of the dialog to be displayed.
--*/
{
    LRESULT lres = 1;
	UpdateData(TRUE);
	m_pCert->m_CommonName = m_CommonName;

    CString buf;
    buf.LoadString(IDS_INVALID_X500_CHARACTERS);
    if (!IsValidX500Chars(m_CommonName))
    {
        GetDlgItem(IDC_NEWKEY_COMMONNAME)->SetFocus();
        AfxMessageBox(buf, MB_OK);
    }
    else
    {
        lres = IDD_PAGE_NEXT;
    }
 	return lres;
}

BOOL 
CSiteNamePage::OnSetActive() 
/*++
Routine Description:
    Activation handler
	We could have empty name field on entrance, so we should
	disable Back button

Arguments:
    None

Return Value:
    TRUE for success, FALSE for failure
--*/
{
	ASSERT(m_pCert != NULL);
	m_CommonName = m_pCert->m_CommonName;
	UpdateData(FALSE);
	SetWizardButtons(m_CommonName.IsEmpty() ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
   return CIISWizardPage::OnSetActive();
}

BOOL 
CSiteNamePage::OnKillActive() 
/*++
Routine Description:
    Activation handler
	We could leave this page only if we have good names
	entered or when Back button is clicked. In both cases
	we should enable both buttons

Arguments:
    None

Return Value:
    TRUE for success, FALSE for failure
--*/
{
	SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);
   return CIISWizardPage::OnSetActive();
}

BEGIN_MESSAGE_MAP(CSiteNamePage, CIISWizardPage)
	//{{AFX_MSG_MAP(CSiteNamePage)
	ON_EN_CHANGE(IDC_NEWKEY_COMMONNAME, OnEditchangeNewkeyCommonname)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSiteNamePage message handlers

void CSiteNamePage::OnEditchangeNewkeyCommonname() 
{
	UpdateData(TRUE);	
	SetWizardButtons(m_CommonName.IsEmpty() ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\sitenamepage.h ===
#if !defined(AFX_SITENAMEPAGE_H__7209C46A_15CB_11D2_91BB_00C04F8C8761__INCLUDED_)
#define AFX_SITENAMEPAGE_H__7209C46A_15CB_11D2_91BB_00C04F8C8761__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SiteNamePage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSiteNamePage dialog
class CCertificate;

class CSiteNamePage : public CIISWizardPage
{
	DECLARE_DYNCREATE(CSiteNamePage)

// Construction
public:
	CSiteNamePage(CCertificate * pCert = NULL);
	~CSiteNamePage();

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_ORG_INFO,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_GEO_INFO
	};
// Dialog Data
	//{{AFX_DATA(CSiteNamePage)
	enum { IDD = IDD_PAGE_WIZ_SITE_NAME };
	CString	m_CommonName;
	//}}AFX_DATA
	CCertificate * m_pCert;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSiteNamePage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardPrev();
	virtual BOOL OnSetActive();
	virtual BOOL OnKillActive();
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CSiteNamePage)
	afx_msg void OnEditchangeNewkeyCommonname();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SITENAMEPAGE_H__7209C46A_15CB_11D2_91BB_00C04F8C8761__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\securitysettingspage.cpp ===
// SecuritySettingsPage.cpp : implementation file
//

#include "stdafx.h"
#include "CertWiz.h"
#include "SecuritySettingsPage.h"
#include "Certificat.h"
#include "CertUtil.h"
#include "Shlwapi.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSecuritySettingsPage property page

IMPLEMENT_DYNCREATE(CSecuritySettingsPage, CIISWizardPage)

CSecuritySettingsPage::CSecuritySettingsPage(CCertificate * pCert) 
	: CIISWizardPage(CSecuritySettingsPage::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CSecuritySettingsPage)
	m_BitLengthIndex = -1;
	m_FriendlyName = _T("");
	m_SGC_cert = FALSE;
    m_choose_CSP = FALSE;
	//}}AFX_DATA_INIT
	m_lru_reg = m_lru_sgc = -1;
}

CSecuritySettingsPage::~CSecuritySettingsPage()
{
}

void CSecuritySettingsPage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSecuritySettingsPage)
	DDX_CBIndex(pDX, IDC_BIT_LENGTH, m_BitLengthIndex);
	DDX_Text(pDX, IDC_FRIENDLY_NAME, m_FriendlyName);
	DDV_MaxChars(pDX, m_FriendlyName, 256);
	DDX_Check(pDX, IDC_SGC_CERT, m_SGC_cert);
	DDX_Check(pDX, IDC_PROVIDER_SELECT, m_choose_CSP);
   DDX_Control(pDX, IDC_PROVIDER_SELECT, m_check_csp);
	//}}AFX_DATA_MAP
}

BOOL 
CSecuritySettingsPage::OnSetActive() 
{
	SetWizardButtons(m_FriendlyName.IsEmpty() ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	return CIISWizardPage::OnSetActive();
}

LRESULT 
CSecuritySettingsPage::OnWizardPrev()
/*++
Routine Description:
    Prev button handler

Arguments:
    None

Return Value:
	0 to automatically advance to the prev page;
	1 to prevent the page from changing. 
	To jump to a page other than the prev one, 
	return the identifier of the dialog to be displayed.
--*/
{
	return CSecuritySettingsPage::IDD_PREV_PAGE;
}

LRESULT 
CSecuritySettingsPage::OnWizardNext()
{
	TCHAR buf[6];
	UpdateData();
	
	m_pCert->m_FriendlyName = m_FriendlyName;
	GetDlgItem(IDC_BIT_LENGTH)->SendMessage(CB_GETLBTEXT, m_BitLengthIndex, (LPARAM)buf);
	m_pCert->m_KeyLength = StrToInt(buf);

	m_pCert->m_SGCcertificat = m_SGC_cert;
	if (m_SGC_cert)
	{
		// it was a smart move, but xenroll makes 512 bits default for SGC,
		// so we always creating 512 certs
//		if (m_pCert->m_KeyLength == (int)m_sgckey_limits.def)
//			m_pCert->m_KeyLength = 0;
	}
	else
	{
		if (m_pCert->m_KeyLength == (int)m_regkey_limits.def)
        {
			m_pCert->m_KeyLength = 0;
        }
	}

	VERIFY(m_pCert->SetSecuritySettings());
   m_pCert->m_DefaultCSP = !m_choose_CSP;
   return m_choose_CSP ? IDD_NEXT_CSP : IDD_NEXT_PAGE;
}

BEGIN_MESSAGE_MAP(CSecuritySettingsPage, CIISWizardPage)
	//{{AFX_MSG_MAP(CSecuritySettingsPage)
	ON_EN_CHANGE(IDC_FRIENDLY_NAME, OnChangeFriendlyName)
	ON_BN_CLICKED(IDC_SGC_CERT, OnSgcCert)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSecuritySettingsPage message handlers

DWORD dwPredefinedKeyLength[] =
{
    0,    // 0 means default
    512,
    1024,
    2048,
    4096,
    8192,
    16384
};
#define COUNT_KEYLENGTH sizeof(dwPredefinedKeyLength)/sizeof(dwPredefinedKeyLength[0])

BOOL CSecuritySettingsPage::OnInitDialog() 
{
	ASSERT(m_pCert != NULL);
	m_FriendlyName = m_pCert->m_FriendlyName;
	CIISWizardPage::OnInitDialog();
	OnChangeFriendlyName();

	HRESULT hr;
	CString str;
	if (GetKeySizeLimits(m_pCert->GetEnrollObject(),
				&m_regkey_limits.min, 
				&m_regkey_limits.max, 
				&m_regkey_limits.def, 
				FALSE, 
				&hr))
	{
		for (int i = 0, n = 0; i < COUNT_KEYLENGTH; i++)
		{
			if (	dwPredefinedKeyLength[i] >= m_regkey_limits.min 
				&& dwPredefinedKeyLength[i] <= m_regkey_limits.max
				)
			{
				m_regkey_size_list.AddTail(dwPredefinedKeyLength[i]);
            if (m_pCert->GetStatusCode() == CCertificate::REQUEST_NEW_CERT)
            {
               if  (m_regkey_limits.def == (int)dwPredefinedKeyLength[i])
					   m_BitLengthIndex = n;
            }
				else
            {
               if  (m_pCert->m_KeyLength == (int)dwPredefinedKeyLength[i])
					   m_BitLengthIndex = n;
            }
            n++;
			}
		}
	}
	else
	{
		ASSERT(FALSE);
		m_pCert->m_hResult = hr;
	}
	if (m_BitLengthIndex == -1)
		m_BitLengthIndex = 0;

	// for SGC temporarily set only one size
	m_sgckey_limits.min = 1024;
	m_sgckey_limits.max = 1024;
	m_sgckey_limits.def = 1024;
	m_sgckey_size_list.AddTail(1024);
	
	m_SGC_cert = m_pCert->m_SGCcertificat;
    m_choose_CSP = !m_pCert->m_DefaultCSP;
	UpdateData(FALSE);
	
   SetupKeySizesCombo();

	GetDlgItem(IDC_FRIENDLY_NAME)->SetFocus();
	return FALSE;
}

void CSecuritySettingsPage::OnChangeFriendlyName() 
{
	UpdateData(TRUE);
	SetWizardButtons(m_FriendlyName.IsEmpty() ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
}

void CSecuritySettingsPage::OnSgcCert() 
{
    UpdateData();
    SetupKeySizesCombo();

    // If SCG checkbox is disabled,
    // then do not allow the user to select they're own CSP
    CButton * pCheckBox = (CButton *)CWnd::FromHandle(GetDlgItem(IDC_SGC_CERT)->m_hWnd);
    CButton * pCheckBox2 = (CButton *)CWnd::FromHandle(GetDlgItem(IDC_PROVIDER_SELECT)->m_hWnd);
    int check_state = pCheckBox->GetCheck();
    if (check_state)
        {pCheckBox2->SetCheck(BST_UNCHECKED);}
    pCheckBox2->EnableWindow(!check_state);
}

void CSecuritySettingsPage::SetupKeySizesCombo()
{
	// Currently, only one key size works with SGC flag:
	// 1024, so we need to limit combobox to this length, if 
	// button is checked
	CButton * pCheckBox = (CButton *)CWnd::FromHandle(GetDlgItem(IDC_SGC_CERT)->m_hWnd);
	CComboBox * pCombo = (CComboBox *)CWnd::FromHandle(GetDlgItem(IDC_BIT_LENGTH)->m_hWnd);
	int check_state = pCheckBox->GetCheck();
	int index, count;
	CList<int, int> * pList;
	if (m_SGC_cert)
	{
		// switch combo to previously selected SGC size
		m_lru_reg = pCombo->GetCurSel();
		index = m_lru_sgc;
		pList = &m_sgckey_size_list;
	}
	else
	{
		// switch combo to previously selected regular size
		m_lru_sgc = pCombo->GetCurSel();
		index = m_lru_reg;
		pList = &m_regkey_size_list;
	}
	// now refill the combo with key length and select the relevant last one
	pCombo->ResetContent();
	CString str;
	POSITION pos = pList->GetHeadPosition();
	while (pos != NULL)
	{
		str.Format(L"%d", pList->GetNext(pos));
		pCombo->AddString(str);
	}
	count = pCombo->GetCount();
   if (m_SGC_cert)
   {
      if (index == CB_ERR)
         index = 0;
   }
   else
   {
      if (index == CB_ERR)
         index = m_BitLengthIndex;
   }
   pCombo->SetCurSel(index);
	pCombo->EnableWindow(count > 1);
}

void CSecuritySettingsPage::OnSelectCsp() 
{
   m_pCert->m_DefaultCSP = m_check_csp.GetCheck() == 0;
   m_choose_CSP = !m_pCert->m_DefaultCSP;
   if (m_pCert->m_DefaultCSP)
      m_pCert->m_CspName.Empty();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\securitysettingspage.h ===
#if !defined(AFX_SECURITYSETTINGSPAGE_H__549054D4_1561_11D2_8A1F_000000000000__INCLUDED_)
#define AFX_SECURITYSETTINGSPAGE_H__549054D4_1561_11D2_8A1F_000000000000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SecuritySettingsPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSecuritySettingsPage dialog
class CCertificate;

typedef struct _KEY_LIMITS
{
	DWORD min, max, def;
} KEY_LIMITS;

class CSecuritySettingsPage : public CIISWizardPage
{
	DECLARE_DYNCREATE(CSecuritySettingsPage)

// Construction
public:
	CSecuritySettingsPage(CCertificate * pCert = NULL);
	~CSecuritySettingsPage();

	enum
	{
		IDD_PREV_PAGE = IDD_PAGE_WIZ_CHOOSE_CA,
		IDD_NEXT_PAGE = IDD_PAGE_WIZ_ORG_INFO,
      IDD_NEXT_CSP = IDD_PAGE_WIZ_CHOOSE_CSP
	};
// Dialog Data
	//{{AFX_DATA(CSecuritySettingsPage)
	enum { IDD = IDD_PAGE_WIZ_SECURITY_SETTINGS };
	int		m_BitLengthIndex;
	CString	m_FriendlyName;
	BOOL	m_SGC_cert;
   BOOL  m_choose_CSP;
   CButton m_check_csp;
	//}}AFX_DATA
	CCertificate * m_pCert;
	CList<int, int> m_regkey_size_list;
	CList<int, int> m_sgckey_size_list;
	KEY_LIMITS	m_regkey_limits, m_sgckey_limits;
	int m_lru_reg, m_lru_sgc;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSecuritySettingsPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardPrev();
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CSecuritySettingsPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeFriendlyName();
	afx_msg void OnSgcCert();
	afx_msg void OnSelectCsp();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
   void SetupKeySizesCombo();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SECURITYSETTINGSPAGE_H__549054D4_1561_11D2_8A1F_000000000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\sslportpage.cpp ===
#include "stdafx.h"
#include "CertWiz.h"
#include "SSLPortPage.h"
#include "Certificat.h"
#include "certutil.h"
#include "strutil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define DEFAULT_SSL_PORT   _T("443")

/////////////////////////////////////////////////////////////////////////////
// CSSLPortPage property page

void AFXAPI
DDXV_UINT(
    IN CDataExchange * pDX,
    IN UINT nID,
    IN OUT UINT & uValue,
    IN UINT uMin,
    IN UINT uMax,
    IN UINT nEmptyErrorMsg  OPTIONAL
    )
/*++

Routine Description:

    DDX/DDV Function that uses a space to denote a 0 value

Arguments:

    CDataExchange * pDX     : Data exchange object
    UINT nID                : Resource ID
    OUT UINT & uValue       : Value
    UINT uMin               : Minimum value
    UINT uMax               : Maximum value
    UINT nEmptyErrorMsg     : Error message ID for empty unit, or 0 if empty OK

Return Value:

    None.

--*/
{
    ASSERT(uMin <= uMax);

    CWnd * pWnd = CWnd::FromHandle(pDX->PrepareEditCtrl(nID));
    ASSERT(pWnd != NULL);

    if (pDX->m_bSaveAndValidate)
    {
        if (pWnd->GetWindowTextLength() > 0)
        {
			// this needs to come before DDX_TextBalloon
			DDV_MinMaxBalloon(pDX, nID, uMin, uMax);
            DDX_TextBalloon(pDX, nID, uValue);
        }
        else
        {
            uValue = 0;
            if (nEmptyErrorMsg)
            {
                DDV_ShowBalloonAndFail(pDX, nEmptyErrorMsg);
            }
        }
    }
    else
    {
        if (uValue != 0)
        {
            DDX_TextBalloon(pDX, nID, uValue);
        }    
        else
        {
            pWnd->SetWindowText(_T(""));
        }
    }
}

IMPLEMENT_DYNCREATE(CSSLPortPage, CIISWizardPage)

CSSLPortPage::CSSLPortPage(CCertificate * pCert) 
	: CIISWizardPage(CSSLPortPage::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CSSLPortPage)
	m_SSLPort = _T("");
	//}}AFX_DATA_INIT
	IDD_PAGE_PREV = IDD_PAGE_WIZ_CHOOSE_CERT;
    IDD_PAGE_NEXT = IDD_PAGE_WIZ_INSTALL_CERT;
}

CSSLPortPage::~CSSLPortPage()
{
}

BOOL CSSLPortPage::OnInitDialog() 
{
	CIISWizardPage::OnInitDialog();
	// If m_SSLPort is empty, then look it up from the metabase...
	if (m_SSLPort.IsEmpty())
	{
        HRESULT hr = 0;
		if (m_pCert)
		{
			GetSSLPortFromSite(m_pCert->m_MachineName,m_pCert->m_WebSiteInstanceName,m_pCert->m_SSLPort,&hr);
		}
	}

	return FALSE;
}

void CSSLPortPage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSSLPortPage)
	DDX_Text(pDX, IDC_SSL_PORT, m_SSLPort);
	DDV_MaxChars(pDX, m_SSLPort, 32);

	UINT nSSLPort = StrToInt(m_SSLPort);
	DDXV_UINT(pDX, IDC_SSL_PORT, nSSLPort, 1, 65535, IDS_NO_PORT);
	//}}AFX_DATA_MAP
}

LRESULT 
CSSLPortPage::OnWizardBack()
/*++
Routine Description:
    Prev button handler

Arguments:
    None

Return Value:
	0 to automatically advance to the prev page;
	1 to prevent the page from changing. 
	To jump to a page other than the prev one, 
	return the identifier of the dialog to be displayed.
--*/
{
	return IDD_PAGE_PREV;
}

LRESULT 
CSSLPortPage::OnWizardNext()
/*++
Routine Description:
    Next button handler

Arguments:
    None

Return Value:
	0 to automatically advance to the next page;
	1 to prevent the page from changing. 
	To jump to a page other than the next one, 
	return the identifier of the dialog to be displayed.
--*/
{
    LRESULT lres = 1;
	UpdateData(TRUE);
	if (m_pCert)
	{
		m_pCert->m_SSLPort = m_SSLPort;
	}

    CString buf;
    buf.LoadString(IDS_NO_PORT);
    if (!IsValidPort((LPCTSTR) m_SSLPort))
    {
        GetDlgItem(IDC_SSL_PORT)->SetFocus();
        AfxMessageBox(buf, MB_OK);
    }
    else
    {
		// Check for if it's already being used on other port!
		HRESULT hr;
		if (TRUE == IsSSLPortBeingUsedOnNonSSLPort(m_pCert->m_MachineName,m_pCert->m_WebSiteInstanceName,m_SSLPort,&hr))
		{
			GetDlgItem(IDC_SSL_PORT)->SetFocus();
			buf.LoadString(IDS_PORT_ALREADY_USED);
			AfxMessageBox(buf, MB_OK);
		}
		else
		{
			lres = IDD_PAGE_NEXT;
		}
    }
 	return lres;
}

BOOL 
CSSLPortPage::OnSetActive() 
/*++
Routine Description:
    Activation handler
	We could have empty name field on entrance, so we should
	disable Back button

Arguments:
    None

Return Value:
    TRUE for success, FALSE for failure
--*/
{
	ASSERT(m_pCert != NULL);
	if (m_pCert)
	{
		m_SSLPort = m_pCert->m_SSLPort;
		switch (m_pCert->GetStatusCode())
		{
			case CCertificate::REQUEST_INSTALL_CERT:
				// this is valid...
				IDD_PAGE_PREV = IDD_PAGE_WIZ_CHOOSE_CERT;
				IDD_PAGE_NEXT = IDD_PAGE_WIZ_INSTALL_CERT;
				break;
			case CCertificate::REQUEST_NEW_CERT:
				// this is also valid....
				//if (m_pCert->m_CAType == CCertificate::CA_ONLINE)
				{
					IDD_PAGE_PREV = IDD_PAGE_WIZ_GEO_INFO;
					IDD_PAGE_NEXT = IDD_PAGE_WIZ_CHOOSE_ONLINE;
				}
				break;
			case CCertificate::REQUEST_PROCESS_PENDING:
				// this is valid too...
				IDD_PAGE_PREV = IDD_PAGE_WIZ_GETRESP_FILE;
				IDD_PAGE_NEXT = IDD_PAGE_WIZ_INSTALL_RESP;
				break;
            case CCertificate::REQUEST_IMPORT_KEYRING:
				// this is valid too...
				IDD_PAGE_PREV = IDD_PAGE_WIZ_GET_PASSWORD;
				IDD_PAGE_NEXT = IDD_PAGE_WIZ_INSTALL_KEYCERT;
				break;
			case CCertificate::REQUEST_IMPORT_CERT:
				// this is valid too...
				IDD_PAGE_PREV = IDD_PAGE_WIZ_GET_IMPORT_PFX_PASSWORD;
				IDD_PAGE_NEXT = IDD_PAGE_WIZ_INSTALL_IMPORT_PFX;
				break;

			// none of these have been implemented to show ssl port
			case CCertificate::REQUEST_RENEW_CERT:
			case CCertificate::REQUEST_REPLACE_CERT:
			case CCertificate::REQUEST_EXPORT_CERT:
			case CCertificate::REQUEST_COPY_MOVE_FROM_REMOTE:
			case CCertificate::REQUEST_COPY_MOVE_TO_REMOTE:
			default:
				IDD_PAGE_PREV = IDD_PAGE_WIZ_CHOOSE_CERT;
				IDD_PAGE_NEXT = IDD_PAGE_WIZ_INSTALL_CERT;
				break;
		}
	}

	if (m_SSLPort.IsEmpty())
	{
		m_SSLPort = DEFAULT_SSL_PORT;
	}
	UpdateData(FALSE);
	SetWizardButtons(m_SSLPort.IsEmpty() ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);

    return CIISWizardPage::OnSetActive();
}

BOOL 
CSSLPortPage::OnKillActive() 
/*++
Routine Description:
    Activation handler
	We could leave this page only if we have good names
	entered or when Back button is clicked. In both cases
	we should enable both buttons

Arguments:
    None

Return Value:
    TRUE for success, FALSE for failure
--*/
{
	SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);
   return CIISWizardPage::OnSetActive();
}

BEGIN_MESSAGE_MAP(CSSLPortPage, CIISWizardPage)
	//{{AFX_MSG_MAP(CSSLPortPage)
	ON_EN_CHANGE(IDC_SSL_PORT, OnEditChangeSSLPort)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSSLPortPage message handlers

void CSSLPortPage::OnEditChangeSSLPort() 
{
	UpdateData(TRUE);	
	SetWizardButtons(m_SSLPort.IsEmpty() ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\stdafx.h ===
#if !defined(AFX_STDAFX_H__D4BE8636_0C85_11D2_91B1_00C04F8C8761__INCLUDED_)
#define AFX_STDAFX_H__D4BE8636_0C85_11D2_91B1_00C04F8C8761__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers
#include <afxtempl.h>
#include <afxctl.h>         // MFC support for ActiveX Controls
#include <afxcmn.h>

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include <atlwin.h>

// from \NT\PUBLIC\sdk\inc
#include "basetsd.h"		
#include "accctrl.h"

// from ..\ComProp
#include "Common.h"
#include "Wizard.h"

// for debug spew
#include "iisdebug.h"

#include "strpass.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__D4BE8636_0C85_11D2_91B1_00C04F8C8761__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\sslportpage.h ===
#if !defined(AFX_SSLPORTPAGE_H__7209C46A_15CB_11D2_91BB_00C04F8C8761__INCLUDED_)
#define AFX_SSLPORTPAGE_H__7209C46A_15CB_11D2_91BB_00C04F8C8761__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CSSLPortPage dialog
class CCertificate;

class CSSLPortPage : public CIISWizardPage
{
	DECLARE_DYNCREATE(CSSLPortPage)

// Construction
public:
	CSSLPortPage(CCertificate * pCert = NULL);
	~CSSLPortPage();

// Dialog Data
	//{{AFX_DATA(CSSLPortPage)
    int IDD_PAGE_PREV;
    int IDD_PAGE_NEXT;
	enum { IDD = IDD_PAGE_WIZ_GET_SSL_PORT };
	CString	m_SSLPort;
	//}}AFX_DATA
	CCertificate * m_pCert;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSSLPortPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	virtual BOOL OnSetActive();
	virtual BOOL OnKillActive();
	virtual BOOL OnInitDialog();
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CSSLPortPage)
	afx_msg void OnEditChangeSSLPort();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SSLPORTPAGE_H__7209C46A_15CB_11D2_91BB_00C04F8C8761__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\strutil.cpp ===
#include "stdafx.h"
#include "strutil.h"


BOOL IsValidX500Chars(CString csStringToCheck)
{
    BOOL iReturn = TRUE;

    if (csStringToCheck.IsEmpty())
    {
        goto IsValidX500Chars_Exit;
    }

    // check if the string has any special chars
	if (csStringToCheck.FindOneOf(_T(",=+<>#;\r\n")) != -1)
    {
        iReturn = FALSE;
        goto IsValidX500Chars_Exit;
    }

IsValidX500Chars_Exit:
    return iReturn;
}

BOOL IsValidPath(LPCTSTR lpFileName)
{
	while ((*lpFileName != _T('?'))
			&& (*lpFileName != _T('*'))
			&& (*lpFileName != _T('"'))
			&& (*lpFileName != _T('<'))
			&& (*lpFileName != _T('>'))
			&& (*lpFileName != _T('|'))
			&& (*lpFileName != _T('/'))
            && (*lpFileName != _T(','))
			&& (*lpFileName != _T('\0')))
		lpFileName++;
	
	if (*lpFileName != '\0')
		return FALSE;

  return TRUE;
}

BOOL IsValidName(LPCTSTR lpFileName)
{
	while ((*lpFileName != _T('?'))
			&& (*lpFileName != _T('\\'))
			&& (*lpFileName != _T('*'))
			&& (*lpFileName != _T('"'))
			&& (*lpFileName != _T('<'))
			&& (*lpFileName != _T('>'))
			&& (*lpFileName != _T('|'))
			&& (*lpFileName != _T('/'))
			&& (*lpFileName != _T(':'))
			&& (*lpFileName != _T('\0')))
		lpFileName++;
	
	if (*lpFileName != '\0')
		return FALSE;

  return TRUE;
}

BOOL IsValidPathFileName(LPCTSTR lpFileName)
{
    BOOL bReturn = TRUE;
    TCHAR szDrive_only[_MAX_DRIVE];
    TCHAR szPath_only[_MAX_PATH];
    TCHAR szFilename_only[_MAX_FNAME];
    TCHAR szFilename_ext_only[_MAX_EXT];

    _tsplitpath(lpFileName, szDrive_only, szPath_only, szFilename_only, szFilename_ext_only);

    if (FALSE == IsValidName(szFilename_only))
    {
        bReturn = FALSE;
    }
    if (FALSE == IsValidPath(szFilename_only))
    {
        bReturn = FALSE;
    }
    if (FALSE == IsValidPath(szPath_only))
    {
        bReturn = FALSE;
    }
    
    return bReturn;
}

BOOL IsValidPort(LPCTSTR str)
{
    if (0 == _tcscmp(str,_T("0")))
    {
        return FALSE;
    }

    if (*str == '\0') return FALSE;
    //if (*str == '-') str++;

    while( *str >= '0' && *str <= '9' )
    {
        str++;
    }
    return !*str;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\strutil.h ===
#include "stdafx.h"

BOOL IsValidX500Chars(CString csStringToCheck);
BOOL IsValidPathFileName(LPCTSTR lpFileName);
BOOL IsValidPort(LPCTSTR str);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\yesnousage.cpp ===
#include "stdafx.h"
#include "certwiz.h"
#include "Certificat.h"
#include "CertUtil.h"
#include "CertSiteUsage.h"
#include "YesNoUsage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CYesNoUsage

CYesNoUsage::CYesNoUsage(CCertificate * pCert,IN CWnd * pParent OPTIONAL) 
: CDialog(CYesNoUsage::IDD,pParent)
{
    m_pCert = pCert;
	//{{AFX_DATA_INIT(CYesNoUsage)
	//}}AFX_DATA_INIT
}

CYesNoUsage::~CYesNoUsage()
{
}

void CYesNoUsage::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CYesNoUsage)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CYesNoUsage, CDialog)
	//{{AFX_MSG_MAP(CYesNoUsage)
    ON_BN_CLICKED(IDC_USAGE_DISPLAY, OnUsageDisplay)
    ON_BN_CLICKED(IDC_USAGE_YES, OnOK)
    ON_BN_CLICKED(IDC_USAGE_NO, OnCancel)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CYesNoUsage message handlers

BOOL CYesNoUsage::OnInitDialog()
{
	CDialog::OnInitDialog();
	return TRUE;
}

void CYesNoUsage::OnUsageDisplay()
{
    // Display the usage dialog
    CDialog UsageDialog(IDD_DIALOG_DISPLAY_SITES);
    UsageDialog.DoModal();
    return;
}

void CYesNoUsage::OnOK()
{
    CDialog::OnOK();
    return;
}

void CYesNoUsage::OnCancel()
{
    CDialog::OnCancel();
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\yesnousage.h ===
#if !defined(AFX_CYesNoUsage_H__25260090_DB36_49E2_9435_7519047DDF49__INCLUDED_)
#define AFX_CYesNoUsage_H__25260090_DB36_49E2_9435_7519047DDF49__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "Certificat.h"

class CCertificate;

class CYesNoUsage : public CDialog
{

// Construction
public:
    CYesNoUsage(CCertificate * pCert = NULL,IN CWnd * pParent = NULL OPTIONAL);
    ~CYesNoUsage();

// Dialog Data
    //{{AFX_DATA(CYesNoUsage)
    enum {IDD = IDD_DIALOG_IMPORT_EXISTS};
    //}}AFX_DATA
    CCertificate * m_pCert;

// Overrides
	//{{AFX_VIRTUAL(CYesNoUsage)
	protected:
    virtual void DoDataExchange(CDataExchange * pDX);
	//}}AFX_VIRTUAL

	// Generated message map functions
protected:
	//{{AFX_MSG(CYesNoUsage)
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    virtual void OnCancel();
	//}}AFX_MSG
    void OnUsageDisplay();

	DECLARE_MESSAGE_MAP()
private:
};

/////////////////////////////////////////////////////////////////////////////
//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CYesNoUsage_H__25260090_DB36_49E2_9435_7519047DDF49__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\welcomepage.cpp ===
// WelcomePage.cpp : implementation file
//

#include "stdafx.h"
#include "CertWiz.h"
#include "WelcomePage.h"
#include "Certificat.h"
#include "certutil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWelcomePage property page

IMPLEMENT_DYNCREATE(CWelcomePage, CIISWizardBookEnd2)

CWelcomePage::CWelcomePage(CCertificate * pCert) 
	: CIISWizardBookEnd2(CWelcomePage::IDD, IDS_WELCOME_PAGE_CAPTION, &pCert->m_idErrorText),
	m_pCert(pCert),
	m_ContinuationFlag(CONTINUE_UNDEFINED)
{
	//{{AFX_DATA_INIT(CWelcomePage)
	//}}AFX_DATA_INIT
}

CWelcomePage::~CWelcomePage()
{
}

void CWelcomePage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardBookEnd2::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWelcomePage)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CWelcomePage, CIISWizardBookEnd2)
	//{{AFX_MSG_MAP(CWelcomePage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWelcomePage message handlers

LRESULT 
CWelcomePage::OnWizardNext()
/*++
Routine Description:
    Next button handler

Arguments:
    None

Return Value:
	0 to automatically advance to the next page;
	1 to prevent the page from changing. 
	To jump to a page other than the next one, 
	return the identifier of the dialog to be displayed.
--*/
{
	ASSERT(m_pCert != NULL);
	int id;
	switch (m_ContinuationFlag)
	{
	case CONTINUE_NEW_CERT:
		id = IDD_PAGE_NEXT_NEW;
		break;
	case CONTINUE_PENDING_CERT:
		id = IDD_PAGE_NEXT_PENDING;
		break;
	case CONTINUE_INSTALLED_CERT:
		id = IDD_PAGE_NEXT_INSTALLED;
		break;
	default:
		id = 1;
	}
	return id;
}

BOOL 
CWelcomePage::OnSetActive() 
/*++
Routine Description:
    Activation handler

Arguments:
    None

Return Value:
    TRUE for success, FALSE for failure
--*/
{
   SetWizardButtons(PSWIZB_NEXT);
   return CIISWizardBookEnd2::OnSetActive();
}

BOOL CWelcomePage::OnInitDialog() 
{
	ASSERT(!m_pCert->m_MachineName.IsEmpty());
	ASSERT(!m_pCert->m_WebSiteInstanceName.IsEmpty());
	// check status of web server
	// set status flag

#ifdef ENABLE_W3SVC_SSL_PAGE
        HRESULT hr = 0;
        GetSSLPortFromSite(m_pCert->m_MachineName,m_pCert->m_WebSiteInstanceName,m_pCert->m_SSLPort,&hr);
#endif

	UINT id;
	if (m_pCert->HasPendingRequest())
	{
		m_ContinuationFlag = CONTINUE_PENDING_CERT;
		id = IDS_PENDING_REQUEST;
	}
	else if (m_pCert->HasInstalledCert())
	{
		m_ContinuationFlag = CONTINUE_INSTALLED_CERT;
		id = IDS_INSTALLED_CERT;
    }
	else
	{
		m_ContinuationFlag = CONTINUE_NEW_CERT;
		id = IDS_NEW_CERT;
	}
	m_pCert->SetBodyTextID(id);
	return CIISWizardBookEnd2::OnInitDialog();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\whattodopendingpage.cpp ===
// WhatToDoPendingPage.cpp : implementation file
//

#include "stdafx.h"
#include "CertWiz.h"
#include "WhatToDoPendingPage.h"
#include "Certificat.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWhatToDoPendingPage property page

IMPLEMENT_DYNCREATE(CWhatToDoPendingPage, CIISWizardPage)

CWhatToDoPendingPage::CWhatToDoPendingPage(CCertificate * pCert) 
	: CIISWizardPage(CWhatToDoPendingPage::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CWhatToDoPendingPage)
	m_Index = -1;
	//}}AFX_DATA_INIT
}

CWhatToDoPendingPage::~CWhatToDoPendingPage()
{
}

void CWhatToDoPendingPage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWhatToDoPendingPage)
	DDX_Radio(pDX, IDC_PROCESS_PENDING, m_Index);
	//}}AFX_DATA_MAP
}

BOOL 
CWhatToDoPendingPage::OnSetActive() 
{
	m_pCert->SetStatusCode(CCertificate::REQUEST_UNDEFINED);
   SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);
   return CIISWizardPage::OnSetActive();
}

LRESULT 
CWhatToDoPendingPage::OnWizardNext()
{
	UpdateData();
	switch (m_Index)
	{
	case 0:
		m_pCert->SetStatusCode(CCertificate::REQUEST_PROCESS_PENDING);
		return IDD_PAGE_NEXT_PROCESS;
	case 1:
		return IDD_PAGE_NEXT_CANCEL;
	default:
		ASSERT(FALSE);
	}
	return 1;
}

LRESULT 
CWhatToDoPendingPage::OnWizardBack()
{
	return IDD_PAGE_PREV;
}

BEGIN_MESSAGE_MAP(CWhatToDoPendingPage, CIISWizardPage)
	//{{AFX_MSG_MAP(CWhatToDoPendingPage)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWhatToDoPendingPage message handlers
BOOL CWhatToDoPendingPage::OnInitDialog() 
{
	m_Index = 0;
	CIISWizardPage::OnInitDialog();
    if ( (this != NULL) && (this->m_hWnd != NULL) )
    {
        if (GetDlgItem(IDC_PROCESS_PENDING))
        {
 	       GetDlgItem(IDC_PROCESS_PENDING)->SetFocus();
        }
    }
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\whattodopendingpage.h ===
#if !defined(AFX_WHATTODOPENDINGPAGE_H__6BF86387_2E29_11D2_816C_0000F87A921B__INCLUDED_)
#define AFX_WHATTODOPENDINGPAGE_H__6BF86387_2E29_11D2_816C_0000F87A921B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// WhatToDoPendingPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CWhatToDoPendingPage dialog
class CCertificate;

class CWhatToDoPendingPage : public CIISWizardPage
{
	DECLARE_DYNCREATE(CWhatToDoPendingPage)

// Construction
public:
	CWhatToDoPendingPage(CCertificate * pCert = NULL);
	~CWhatToDoPendingPage();

	enum
	{
		IDD_PAGE_NEXT_PROCESS = IDD_PAGE_WIZ_GETRESP_FILE,
		IDD_PAGE_NEXT_CANCEL = IDD_PAGE_WIZ_CANCEL_REQUEST,
		IDD_PAGE_PREV = IDD_PAGE_WELCOME_START
	};

// Dialog Data
	//{{AFX_DATA(CWhatToDoPendingPage)
	enum { IDD = IDD_PAGE_WIZ_PENDING_WHAT_TODO };
	int		m_Index;
	//}}AFX_DATA
	CCertificate * m_pCert;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CWhatToDoPendingPage)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CWhatToDoPendingPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};


#endif // !defined(AFX_WHATTODOPENDINGPAGE_H__6BF86387_2E29_11D2_816C_0000F87A921B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\welcomepage.h ===
#if !defined(AFX_WELCOMEPAGE_H__D4BE8672_0C85_11D2_91B1_00C04F8C8761__INCLUDED_)
#define AFX_WELCOMEPAGE_H__D4BE8672_0C85_11D2_91B1_00C04F8C8761__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// WelcomePage.h : header file
//
#include "BookEndPage.h"

/////////////////////////////////////////////////////////////////////////////
// CWelcomePage dialog
class CCertificate;

class CWelcomePage : public CIISWizardBookEnd2
{
	DECLARE_DYNCREATE(CWelcomePage)

// Construction
public:
	CWelcomePage(CCertificate * pCert = NULL);
	~CWelcomePage();

	enum
	{
		CONTINUE_UNDEFINED = 0,
		CONTINUE_NEW_CERT = 1,
		CONTINUE_PENDING_CERT = 2,
		CONTINUE_INSTALLED_CERT = 3
	};
	enum
	{
		IDD_PAGE_NEXT_NEW = IDD_PAGE_WIZ_GET_WHAT,
		IDD_PAGE_NEXT_PENDING = IDD_PAGE_WIZ_PENDING_WHAT_TODO,
		IDD_PAGE_NEXT_INSTALLED = IDD_PAGE_WIZ_MANAGE_CERT
	};
// Dialog Data
	//{{AFX_DATA(CWelcomePage)
	enum { IDD = IDD_PAGE_WELCOME_START };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA
	CCertificate * m_pCert;
	int m_ContinuationFlag;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CWelcomePage)
   public:
   virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CWelcomePage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WELCOMEPAGE_H__D4BE8672_0C85_11D2_91B1_00C04F8C8761__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\cnfgprts\font.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "font.h"


/////////////////////////////////////////////////////////////////////////////
// COleFont properties

CString COleFont::GetName()
{
	CString result;
	GetProperty(0x0, VT_BSTR, (void*)&result);
	return result;
}

void COleFont::SetName(LPCTSTR propVal)
{
	SetProperty(0x0, VT_BSTR, propVal);
}

CY COleFont::GetSize()
{
	CY result;
	GetProperty(0x2, VT_CY, (void*)&result);
	return result;
}

void COleFont::SetSize(const CY& propVal)
{
	SetProperty(0x2, VT_CY, &propVal);
}

BOOL COleFont::GetBold()
{
	BOOL result;
	GetProperty(0x3, VT_BOOL, (void*)&result);
	return result;
}

void COleFont::SetBold(BOOL propVal)
{
	SetProperty(0x3, VT_BOOL, propVal);
}

BOOL COleFont::GetItalic()
{
	BOOL result;
	GetProperty(0x4, VT_BOOL, (void*)&result);
	return result;
}

void COleFont::SetItalic(BOOL propVal)
{
	SetProperty(0x4, VT_BOOL, propVal);
}

BOOL COleFont::GetUnderline()
{
	BOOL result;
	GetProperty(0x5, VT_BOOL, (void*)&result);
	return result;
}

void COleFont::SetUnderline(BOOL propVal)
{
	SetProperty(0x5, VT_BOOL, propVal);
}

BOOL COleFont::GetStrikethrough()
{
	BOOL result;
	GetProperty(0x6, VT_BOOL, (void*)&result);
	return result;
}

void COleFont::SetStrikethrough(BOOL propVal)
{
	SetProperty(0x6, VT_BOOL, propVal);
}

short COleFont::GetWeight()
{
	short result;
	GetProperty(0x7, VT_I2, (void*)&result);
	return result;
}

void COleFont::SetWeight(short propVal)
{
	SetProperty(0x7, VT_I2, propVal);
}

short COleFont::GetCharset()
{
	short result;
	GetProperty(0x8, VT_I2, (void*)&result);
	return result;
}

void COleFont::SetCharset(short propVal)
{
	SetProperty(0x8, VT_I2, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// COleFont operations
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\make_countries\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__1C24BC61_D2FD_4002_A7AF_564E4AECFB4A__INCLUDED_)
#define AFX_STDAFX_H__1C24BC61_D2FD_4002_A7AF_564E4AECFB4A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__1C24BC61_D2FD_4002_A7AF_564E4AECFB4A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\make_countries\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	make_countries.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\certwiz\make_countries\make_countries.cpp ===
// make_countries.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include <iostream.h>
#include <fstream.h>
#include <stdio.h>

int __cdecl main(int argc, char* argv[])
{
   ifstream in("countries.txt");
   ofstream out("countries.rc");
   char inbuf[256], outbuf[256];
   int idx = 0;

   out << "STRINGTABLE DISCARDABLE" << endl;
   out << "BEGIN" << endl;

   while (in)
   {
      in.getline(inbuf, 256);
      if (idx == 0)
      {
         sprintf(outbuf, "\tIDS_COUNTRIES_FIRST\t\t\"%s\"", inbuf);
      }
      else
      {
         sprintf(outbuf, "\tIDS_COUNTRIES_FIRST+%d\t\t\"%s\"", idx, inbuf);
      }
      out << outbuf << endl;
      idx++;
   }

   out << "END" << endl;

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\cnfgprts\iishelp.cpp ===
#include "stdafx.h"

INT g_iDebugOutputLevel = 0;

void GetOutputDebugFlag(void)
{
    DWORD rc, err, size, type;
    HKEY  hkey;
    err = RegOpenKey(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\InetMgr"), &hkey);
    if (err != ERROR_SUCCESS) {return;}
    size = sizeof(DWORD);
    err = RegQueryValueEx(hkey,_T("OutputDebugFlag"),0,&type,(LPBYTE)&rc,&size);
    if (err != ERROR_SUCCESS || type != REG_DWORD) {rc = 0;}
    RegCloseKey(hkey);

	if (rc < 0xffffffff)
	{
		g_iDebugOutputLevel = rc;
	}
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\cnfgprts\cnfgprts.h ===
// cnfgprts.h : main header file for CNFGPRTS.DLL

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "resource.h"       // main symbols
#include "helpmap.h"       // main symbols

#define REGKEY_STP          _T("SOFTWARE\\Microsoft\\INetStp")
#define REGKEY_INSTALLKEY   _T("InstallPath")

/////////////////////////////////////////////////////////////////////////////
// CCnfgprtsApp : See cnfgprts.cpp for implementation.

class CCnfgprtsApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
};

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\cnfgprts\helpmap.h ===
// helpmaps for the logui project - handmade

#define HIDD_RATINGS_SERVICE                    0x50300
#define HIDD_RATINGS_RATING                     0x50301

#define HIDD_APPMAPS_MAPS                       0x50310
#define HIDD_APPMAPS_ASP_MAIN                   0x50311
#define HIDD_APPMAPS_ASP_DEBUG                  0x50312
#define HIDD_APPMAPS_OTHER                      0x50313
#define HIDD_APPMAPS_OUT_OF_PROC				0x50314
#define HIDD_APPMAPS_IN_PROC_GLOBAL				0x50315
#define HIDD_APPMAPS_EDIT_MAP                   0x50318
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\cnfgprts\guid.cpp ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

        guid.cpp

   Abstract:

        Initialization as required by initguid

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include <stdafx.h>

#include <objbase.h>
#include <initguid.h>
#include <iadmw.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\cnfgprts\cnfgprts.cpp ===
// cnfgprts.cpp : Implementation of CCnfgprtsApp and DLL registration.

#include "stdafx.h"
#include "cnfgprts.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CCnfgprtsApp NEAR theApp;

const GUID CDECL BASED_CODE _tlid =
		{ 0xba634600, 0xb771, 0x11d0, { 0x92, 0x96, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;


////////////////////////////////////////////////////////////////////////////
// CCnfgprtsApp::InitInstance - DLL initialization

BOOL CCnfgprtsApp::InitInstance()
{
	BOOL bInit = COleControlModule::InitInstance();
    AfxEnableControlContainer( );

	if (bInit)
	    {
        // finally, we need to redirect the winhelp file location to something more desirable
        CString sz;
        CString szHelpLocation;
        sz.LoadString( IDS_HELPLOC_HELP );

        // expand the path
        ExpandEnvironmentStrings(
            sz,	                                        // pointer to string with environment variables 
            szHelpLocation.GetBuffer(MAX_PATH + 1),   // pointer to string with expanded environment variables  
            MAX_PATH                                    // maximum characters in expanded string 
           );
        szHelpLocation.ReleaseBuffer();

        // free the existing path, and copy in the new one
        if ( m_pszHelpFilePath )
            free((void*)m_pszHelpFilePath);
        m_pszHelpFilePath = _tcsdup(szHelpLocation);

        // get debug flag
        GetOutputDebugFlag();
	    }

	return bInit;
}


////////////////////////////////////////////////////////////////////////////
// CCnfgprtsApp::ExitInstance - DLL termination

int CCnfgprtsApp::ExitInstance()
{
	return COleControlModule::ExitInstance();
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\cnfgprts\font.h ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// COleFont wrapper class

class COleFont : public COleDispatchDriver
{
public:
	COleFont() {}		// Calls COleDispatchDriver default constructor
	COleFont(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	COleFont(const COleFont& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:
	CString GetName();
	void SetName(LPCTSTR);
	CY GetSize();
	void SetSize(const CY&);
	BOOL GetBold();
	void SetBold(BOOL);
	BOOL GetItalic();
	void SetItalic(BOOL);
	BOOL GetUnderline();
	void SetUnderline(BOOL);
	BOOL GetStrikethrough();
	void SetStrikethrough(BOOL);
	short GetWeight();
	void SetWeight(short);
	short GetCharset();
	void SetCharset(short);

// Operations
public:
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\cnfgprts\iishelp.h ===
#ifndef  _IISHELP_H_
#define  _IISHELP_H_

#include "debugdefs.h"

#if defined(_DEBUG) || DBG
    #define DEBUG_WINHELP_FLAG
#else
    // set this to debug on fre build
    //#define DEBUG_WINHELP_FLAG
#endif

extern INT g_iDebugOutputLevel;

#ifdef DEBUG_WINHELP_FLAG
    inline void _cdecl DebugTraceHelp(DWORD_PTR dwWinHelpID)
    {
        // Only do this if the flag is set.
        if (0 != g_iDebugOutputLevel)
        {
			if (DEBUG_FLAG_HELP & g_iDebugOutputLevel)
			{
				TCHAR szBuffer[30];
				_stprintf(szBuffer,_T("WinHelp:0x%x,%d\r\n"),dwWinHelpID,dwWinHelpID);
				OutputDebugString(szBuffer);
			}
		}
        return;
    }

    inline void _cdecl DebugTrace(LPTSTR lpszFormat, ...)
    {
        // Only do this if the flag is set.
        if (0 != g_iDebugOutputLevel)
        {
			if (DEBUG_FLAG_MODULE_CNFGPRTS & g_iDebugOutputLevel)
			{
				int nBuf;
				TCHAR szBuffer[_MAX_PATH];
				va_list args;
				va_start(args, lpszFormat);

				nBuf = _vsntprintf(szBuffer, sizeof(szBuffer)/sizeof(szBuffer[0]), lpszFormat, args);

				OutputDebugString(szBuffer);
				va_end(args);

				// if it does not end if '\r\n' then make one.
				int nLen = _tcslen(szBuffer);
				if (szBuffer[nLen-1] != _T('\n')){OutputDebugString(_T("\r\n"));}
			}
        }
    }

#else
    inline void _cdecl DebugTraceHelp(DWORD_PTR dwWinHelpID){}
	inline void _cdecl DebugTrace(LPTSTR , ...){}
#endif

void GetOutputDebugFlag(void);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\cnfgprts\loguictl.h ===
// LogUICtl.h : Declaration of the CLogUICtrl OLE control class.

/////////////////////////////////////////////////////////////////////////////
// CLogUICtrl : See LogUICtl.cpp for implementation.

class CLogUICtrl : public COleControl
{
	DECLARE_DYNCREATE(CLogUICtrl)

// Constructor
public:
	CLogUICtrl();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CLogUICtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	virtual void OnClick(USHORT iButton);
	virtual void OnFontChanged();
	virtual void OnAmbientPropertyChange(DISPID dispid);
	virtual void OnGetControlInfo(LPCONTROLINFO pControlInfo);
	virtual void OnKeyUpEvent(USHORT nChar, USHORT nShiftState);
	virtual void OnMnemonic(LPMSG pMsg);
	virtual void OnTextChanged();
	//}}AFX_VIRTUAL

// Implementation
protected:
	~CLogUICtrl();

	DECLARE_OLECREATE_EX(CLogUICtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CLogUICtrl)      // GetTypeInfo
	DECLARE_PROPPAGEIDS(CLogUICtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CLogUICtrl)		// Type name and misc status

	// Subclassed control support
	BOOL PreCreateWindow(CREATESTRUCT& cs);
	BOOL IsSubclassedControl();
	LRESULT OnOcmCommand(WPARAM wParam, LPARAM lParam);

// Message maps
	//{{AFX_MSG(CLogUICtrl)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CLogUICtrl)
	afx_msg void SetAdminTarget(LPCTSTR szMachineName, LPCTSTR szMetaTarget);
	afx_msg void ApplyLogSelection();
	afx_msg void SetComboBox(HWND hComboBox);
	afx_msg void Terminate();
	afx_msg void SetUserData(LPCTSTR szName, LPCTSTR szPassword);
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

// Event maps
	//{{AFX_EVENT(CLogUICtrl)
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CLogUICtrl)
	dispidSetAdminTarget = 1L,
	dispidApplyLogSelection = 2L,
	dispidSetComboBox = 3L,
	dispidTerminate = 4L,
	dispidSetUserData = 5L,
	//}}AFX_DISP_ID
	};

protected:
    void ActivateLogProperties(REFIID clsidUI);
    BOOL GetSelectedStringIID( CString &szIID );
    BOOL SetAccelTable( LPCTSTR pszCaption );

    BOOL m_fUpdateFont;
    CString m_szMachine;
    CString m_szMetaObject;
	CString m_szUserName;
	CStrPassword m_szPassword;
    BOOL m_fComboInit;
    CComboBox m_comboBox;
    // the accelerator table
    HACCEL  m_hAccel;
    WORD    m_cAccel;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\cnfgprts\loguippg.cpp ===
// LogUIPpg.cpp : Implementation of the CLogUIPropPage property page class.

#include "stdafx.h"
#include "cnfgprts.h"
#include "LogUIPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CLogUIPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CLogUIPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CLogUIPropPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CLogUIPropPage, "CNFGPRTS.LogUIPropPage.1",
	0xba634604, 0xb771, 0x11d0, 0x92, 0x96, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b)


/////////////////////////////////////////////////////////////////////////////
// CLogUIPropPage::CLogUIPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CLogUIPropPage

BOOL CLogUIPropPage::CLogUIPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(
         AfxGetInstanceHandle(),
			m_clsid, 
         IDS_LOGUI_PPG,
         afxRegApartmentThreading
         );
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CLogUIPropPage::CLogUIPropPage - Constructor

CLogUIPropPage::CLogUIPropPage() :
	COlePropertyPage(IDD, IDS_LOGUI_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CLogUIPropPage)
	m_sz_caption = _T("");
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CLogUIPropPage::DoDataExchange - Moves data between page and properties

void CLogUIPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CLogUIPropPage)
	DDP_Text(pDX, IDC_CAPTIONEDIT, m_sz_caption, _T("Caption") );
	DDX_Text(pDX, IDC_CAPTIONEDIT, m_sz_caption);
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CLogUIPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\cnfgprts\mdobjs.h ===
#define SZ_W3_ROOT     _T("/lm/w3svc")
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\cnfgprts\loguictl.cpp ===
// LogUICtl.cpp : Implementation of the CLogUICtrl OLE control class.

#include "stdafx.h"
#include "cnfgprts.h"
#include "LogUICtl.h"
#include "LogUIPpg.h"
#include <iiscnfg.h>

#include "initguid.h"
#include <inetcom.h>
#include <logtype.h>
#include <ilogobj.hxx>


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CLogUICtrl, COleControl)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CLogUICtrl, COleControl)
    //{{AFX_MSG_MAP(CLogUICtrl)
    //}}AFX_MSG_MAP
    ON_MESSAGE(OCM_COMMAND, OnOcmCommand)
    ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CLogUICtrl, COleControl)
    //{{AFX_DISPATCH_MAP(CLogUICtrl)
    DISP_FUNCTION(CLogUICtrl, "SetAdminTarget", SetAdminTarget, VT_EMPTY, VTS_BSTR VTS_BSTR)
    DISP_FUNCTION(CLogUICtrl, "ApplyLogSelection", ApplyLogSelection, VT_EMPTY, VTS_NONE)
    DISP_FUNCTION(CLogUICtrl, "SetComboBox", SetComboBox, VT_EMPTY, VTS_HANDLE)
    DISP_FUNCTION(CLogUICtrl, "Terminate", Terminate, VT_EMPTY, VTS_NONE)
    DISP_FUNCTION(CLogUICtrl, "SetUserData", SetUserData, VT_EMPTY, VTS_BSTR VTS_BSTR)
    DISP_STOCKFUNC_DOCLICK()
    DISP_STOCKPROP_CAPTION()
    DISP_STOCKPROP_FONT()
    DISP_STOCKPROP_ENABLED()
    DISP_STOCKPROP_BORDERSTYLE()
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CLogUICtrl, COleControl)
    //{{AFX_EVENT_MAP(CLogUICtrl)
    EVENT_STOCK_CLICK()
    EVENT_STOCK_KEYUP()
    EVENT_STOCK_KEYDOWN()
    EVENT_STOCK_KEYPRESS()
    //}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

BEGIN_PROPPAGEIDS(CLogUICtrl, 2)
    PROPPAGEID(CLogUIPropPage::guid)
    PROPPAGEID(CLSID_CFontPropPage)
END_PROPPAGEIDS(CLogUICtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CLogUICtrl, "CNFGPRTS.LogUICtrl.1",
    0xba634603, 0xb771, 0x11d0, 0x92, 0x96, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CLogUICtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DLogUI =
        { 0xba634601, 0xb771, 0x11d0, { 0x92, 0x96, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b } };
const IID BASED_CODE IID_DLogUIEvents =
        { 0xba634602, 0xb771, 0x11d0, { 0x92, 0x96, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwLogUIOleMisc =
    OLEMISC_ACTIVATEWHENVISIBLE |
    OLEMISC_SETCLIENTSITEFIRST |
    OLEMISC_INSIDEOUT |
    OLEMISC_CANTLINKINSIDE |
    OLEMISC_ACTSLIKEBUTTON |
    OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CLogUICtrl, IDS_LOGUI, _dwLogUIOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CLogUICtrl::CLogUICtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CLogUICtrl

BOOL CLogUICtrl::CLogUICtrlFactory::UpdateRegistry(BOOL bRegister)
{
	// TODO: Verify that your control follows apartment-model threading rules.
	// Refer to MFC TechNote 64 for more information.
	// If your control does not conform to the apartment-model rules, then
	// you must modify the code below, changing the 6th parameter from
	// afxRegApartmentThreading to 0.

	if (bRegister)
		return AfxOleRegisterControlClass(
		AfxGetInstanceHandle(),
		m_clsid,
		m_lpszProgID,
		IDS_LOGUI,
		IDB_LOGUI,
		afxRegApartmentThreading,
		_dwLogUIOleMisc,
		_tlid,
		_wVerMajor,
		_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}


/////////////////////////////////////////////////////////////////////////////
// CLogUICtrl::CLogUICtrl - Constructor

CLogUICtrl::CLogUICtrl():
        m_fUpdateFont( FALSE ),
        m_fComboInit( FALSE ),
        m_hAccel( NULL ),
        m_cAccel( 0 )
{
	InitializeIIDs(&IID_DLogUI, &IID_DLogUIEvents);
}


/////////////////////////////////////////////////////////////////////////////
// CLogUICtrl::~CLogUICtrl - Destructor

CLogUICtrl::~CLogUICtrl()
{
	if ( m_hAccel )
		DestroyAcceleratorTable( m_hAccel );
	m_hAccel = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CLogUICtrl::OnDraw - Drawing function

void CLogUICtrl::OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
{
	DoSuperclassPaint(pdc, rcBounds);
}


/////////////////////////////////////////////////////////////////////////////
// CLogUICtrl::DoPropExchange - Persistence support

void CLogUICtrl::DoPropExchange(CPropExchange* pPX)
{
	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);
}


/////////////////////////////////////////////////////////////////////////////
// CLogUICtrl::OnResetState - Reset control to default state

void CLogUICtrl::OnResetState()
{
	COleControl::OnResetState();  // Resets defaults found in DoPropExchange
}


/////////////////////////////////////////////////////////////////////////////
// CLogUICtrl::PreCreateWindow - Modify parameters for CreateWindowEx

BOOL CLogUICtrl::PreCreateWindow(CREATESTRUCT& cs)
{
	if ( cs.style & WS_CLIPSIBLINGS )
		cs.style ^= WS_CLIPSIBLINGS;
	cs.lpszClass = _T("BUTTON");
	return COleControl::PreCreateWindow(cs);
}


/////////////////////////////////////////////////////////////////////////////
// CLogUICtrl::IsSubclassedControl - This is a subclassed control

BOOL CLogUICtrl::IsSubclassedControl()
{
	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CLogUICtrl::OnOcmCommand - Handle command messages

LRESULT CLogUICtrl::OnOcmCommand(WPARAM wParam, LPARAM lParam)
{
#ifdef _WIN32
    WORD wNotifyCode = HIWORD(wParam);
#else
    WORD wNotifyCode = HIWORD(lParam);
#endif

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
// CLogUICtrl message handlers

//---------------------------------------------------------------------------
// OLE Interfaced Routine
void CLogUICtrl::OnClick(USHORT iButton)
{
	CWaitCursor wait;

	CString sz;
	sz.LoadString( IDS_LOG_ERR_TITLE );
	free((void*)AfxGetApp()->m_pszAppName);
	AfxGetApp()->m_pszAppName = _tcsdup(sz);

	if (GetSelectedStringIID(sz))
	{
	IID iid;
		HRESULT h = CLSIDFromString((LPTSTR)(LPCTSTR)sz, &iid);
		ActivateLogProperties(iid);
	}
	COleControl::OnClick(iButton);
}

void CLogUICtrl::OnFontChanged()
{
	m_fUpdateFont = TRUE;
	COleControl::OnFontChanged();
}

void CLogUICtrl::SetAdminTarget(LPCTSTR szMachineName, LPCTSTR szMetaTarget)
{
	m_szMachine = szMachineName;
	m_szMetaObject = szMetaTarget;
}

void CLogUICtrl::SetUserData(LPCTSTR szName, LPCTSTR szPassword)
{
	m_szUserName = szName;
	m_szPassword = szPassword;
}

//---------------------------------------------------------------------------
void CLogUICtrl::ActivateLogProperties(REFIID clsidUI)
{
	AFX_MANAGE_STATE(::AfxGetStaticModuleState());

	IClassFactory * pcsfFactory = NULL;
	HRESULT hresError;
	ILogUIPlugin2 * pUI = NULL;

	hresError = CoGetClassObject(clsidUI, CLSCTX_INPROC, NULL, IID_IClassFactory, (void **)&pcsfFactory);
	if (SUCCEEDED(hresError))
	{
		hresError = pcsfFactory->CreateInstance(NULL, IID_LOGGINGUI2, (void **)&pUI);
		if (SUCCEEDED(hresError))
		{
            CString csTempPassword;
            m_szPassword.CopyTo(csTempPassword);
			pcsfFactory->Release();
			hresError = pUI->OnPropertiesEx(
				(LPTSTR)(LPCTSTR)m_szMachine, 
				(LPTSTR)(LPCTSTR)m_szMetaObject,
				(LPTSTR)(LPCTSTR)m_szUserName,
				(LPTSTR)(LPCTSTR)csTempPassword);
			pUI->Release();
		}
	}
}

void CLogUICtrl::ApplyLogSelection()
{
    CString szName;
    m_comboBox.GetWindowText( szName );
    // if nothing is selected, fail
    if (!szName.IsEmpty()) 
    {
        CString guid;
        CString csTempPassword;
        m_szPassword.CopyTo(csTempPassword);
        CComAuthInfo auth(m_szMachine, m_szUserName, csTempPassword);
        CMetaKey mk(&auth, NULL, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);
        if (mk.Succeeded())
        {
            CMetabasePath path(TRUE, _T("logging"), szName);
            mk.QueryValue(MD_LOG_PLUGIN_MOD_ID, guid, NULL, path);
        }
        if (!guid.IsEmpty())
        {
            mk.SetValue(MD_LOG_PLUGIN_ORDER, guid, NULL, m_szMetaObject);
        }
    }
}

//---------------------------------------------------------------------------
BOOL CLogUICtrl::GetSelectedStringIID( CString &szIID )
{
    if (!m_fComboInit) 
        return FALSE;
    BOOL bRes = FALSE;
    CString szName;
    m_comboBox.GetWindowText( szName );
    if (!szName.IsEmpty())
    {
        CString log_path = _T("/lm/logging"), guid;
        CString csTempPassword;
        m_szPassword.CopyTo(csTempPassword);
        CComAuthInfo auth(m_szMachine, m_szUserName, csTempPassword);
        CMetaKey mk(&auth, log_path, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);
        if (mk.Succeeded())
        {
            mk.QueryValue(MD_LOG_PLUGIN_UI_ID, szIID, NULL, szName);
            bRes = mk.Succeeded();
        }
    }
    return bRes;
}

//---------------------------------------------------------------------------
// OLE Interfaced Routine
void CLogUICtrl::SetComboBox(HWND hComboBox)
{
    CString szAvailableList;
    CString szCurrentModGuid;

    // in case there are any errors, prepare the error string
    // set the name of the application correctly
    szAvailableList.LoadString( IDS_LOG_ERR_TITLE );
    AfxGetApp()->m_pszAppName = _tcsdup(szAvailableList);
    szAvailableList.Empty();

    // attach the combo box
    m_comboBox.Attach(hComboBox);
    m_fComboInit = TRUE;

    CString csTempPassword;
    m_szPassword.CopyTo(csTempPassword);
    CComAuthInfo auth(m_szMachine, m_szUserName, csTempPassword);
    CMetaKey mk(&auth);
    if (mk.Succeeded())
    {
        if (FAILED(mk.QueryValue(MD_LOG_PLUGIN_ORDER, szCurrentModGuid, NULL, m_szMetaObject)))
        {
            AfxMessageBox( IDS_ERR_LOG_PLUGIN );
            return;
        }
    }
    CString info;
    CMetabasePath::GetServiceInfoPath(m_szMetaObject, info);
    if (FAILED(mk.QueryValue(MD_LOG_PLUGINS_AVAILABLE, szAvailableList, NULL, info)))
    {
        AfxMessageBox( IDS_ERR_LOG_PLUGIN );
        return;
    }

    CMetaEnumerator me(FALSE, &mk);
    CMetabasePath log_path(TRUE, _T("logging"));
    CString key, buf;
    BOOL fFoundCurrent = FALSE;
    while (SUCCEEDED(me.Next(key, log_path)))
    {
		int idx = 0;
        if ((idx = szAvailableList.Find(key)) >= 0)
        {
			// Log plugin name could include "Custom Logging". Check if this is part of string.
			// we should have comma before and after string
			BOOL bCommaAfter = 
				szAvailableList.GetLength() == idx + key.GetLength() 
				|| szAvailableList.GetAt(idx + key.GetLength()) == _T(',');
			BOOL bCommaBefore = idx == 0 || szAvailableList.GetAt(idx - 1) == _T(',');
            if (!fFoundCurrent)
            {
                CMetabasePath current_path(FALSE, log_path, key);
                mk.QueryValue(MD_LOG_PLUGIN_MOD_ID, buf, NULL, current_path);
                fFoundCurrent = (buf == szCurrentModGuid);
				if (fFoundCurrent)
				{
					buf = key;
				}
            }
			if (bCommaBefore && bCommaAfter)
			{
				m_comboBox.AddString(key);
			}
        }
    }
    // select the current item in the combo box
    m_comboBox.SelectString(-1, buf);
}

//---------------------------------------------------------------------------
// OLE Interfaced Routine
void CLogUICtrl::Terminate()
{
	if ( m_fComboInit )
		m_comboBox.Detach();
	m_fComboInit = FALSE;
}


//------------------------------------------------------------------------
void CLogUICtrl::OnAmbientPropertyChange(DISPID dispid)
{
	BOOL    flag;
	UINT    style;

	// do the right thing depending on the dispid
	switch ( dispid )
	{
	case DISPID_AMBIENT_DISPLAYASDEFAULT:
		if ( GetAmbientProperty( DISPID_AMBIENT_DISPLAYASDEFAULT, VT_BOOL, &flag ) )
		{
			style = GetWindowLong(
				GetSafeHwnd(), // handle of window
				GWL_STYLE  // offset of value to retrieve
				);
			if ( flag )
				style |= BS_DEFPUSHBUTTON;
			else
				style ^= BS_DEFPUSHBUTTON;
			SetWindowLong(
				GetSafeHwnd(), // handle of window
				GWL_STYLE,  // offset of value to retrieve
				style
				);
			Invalidate(TRUE);
		}
		break;
	};

	COleControl::OnAmbientPropertyChange(dispid);
}

//------------------------------------------------------------------------
// an important method where we tell the container how to deal with us.
// pControlInfo is passed in by the container, although we are responsible
// for maintining the hAccel structure
void CLogUICtrl::OnGetControlInfo(LPCONTROLINFO pControlInfo)
{
	if ( !pControlInfo || pControlInfo->cb < sizeof(CONTROLINFO) )
		return;

	pControlInfo->hAccel = m_hAccel;
	pControlInfo->cAccel = m_cAccel;
	pControlInfo->dwFlags = CTRLINFO_EATS_RETURN;
}

//------------------------------------------------------------------------
// the ole control container object specifically filters out the space
// key so we do not get it as a OnMnemonic call. Thus we need to look
// for it ourselves
void CLogUICtrl::OnKeyUpEvent(USHORT nChar, USHORT nShiftState)
{
	if ( nChar == _T(' ') )
	{
		OnClick((USHORT)GetDlgCtrlID());
	}
	COleControl::OnKeyUpEvent(nChar, nShiftState);
}

//------------------------------------------------------------------------
void CLogUICtrl::OnMnemonic(LPMSG pMsg)
{
	OnClick((USHORT)GetDlgCtrlID());
	COleControl::OnMnemonic(pMsg);
}

//------------------------------------------------------------------------
void CLogUICtrl::OnTextChanged()
{
	// get the new text
	CString sz = InternalGetText();

	// set the accelerator table
	SetAccelTable((LPCTSTR)sz);
	if ( SetAccelTable((LPCTSTR)sz) )
		// make sure the new accelerator table gets loaded
		ControlInfoChanged();

	// finish with the default handling.
	COleControl::OnTextChanged();
}

//------------------------------------------------------------------------
BOOL CLogUICtrl::SetAccelTable( LPCTSTR pszCaption )
{
	BOOL    fAnswer = FALSE;
	ACCEL   accel;
	int     iAccel;

	// get the new text
	CString sz = pszCaption;
	sz.MakeLower();

	// if the handle has already been allocated, free it
	if ( m_hAccel )
	{
		DestroyAcceleratorTable( m_hAccel );
		m_hAccel = NULL;
		m_cAccel = 0;
	}

	// if there is a & character, then declare the accelerator
	iAccel = sz.Find(_T('&'));
	if ( iAccel >= 0 )
	{
		// fill in the accererator record
		accel.fVirt = FALT;
		accel.key = sz.GetAt(iAccel + 1);
		accel.cmd = (USHORT)GetDlgCtrlID();

		m_hAccel = CreateAcceleratorTable( &accel, 1 );
		if ( m_hAccel )
			m_cAccel = 1;

		fAnswer = TRUE;
	}

	// return the answer
	return fAnswer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\cnfgprts\loguippg.h ===
// LogUIPpg.h : Declaration of the CLogUIPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CLogUIPropPage : See LogUIPpg.cpp.cpp for implementation.

class CLogUIPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CLogUIPropPage)
	DECLARE_OLECREATE_EX(CLogUIPropPage)

// Constructor
public:
	CLogUIPropPage();

// Dialog Data
	//{{AFX_DATA(CLogUIPropPage)
	enum { IDD = IDD_PROPPAGE_LOGUI };
	CString	m_sz_caption;
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CLogUIPropPage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\cnfgprts\ratadvpg.cpp ===
// RatAdvPg.cpp : implementation file
//

#include "stdafx.h"
#include "cnfgprts.h"
#include "parserat.h"
#include "RatData.h"
#include "RatAdvPg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRatAdvancedPage property page

IMPLEMENT_DYNCREATE(CRatAdvancedPage, CPropertyPage)

CRatAdvancedPage::CRatAdvancedPage() : CPropertyPage(CRatAdvancedPage::IDD)
{
	//{{AFX_DATA_INIT(CRatAdvancedPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CRatAdvancedPage::~CRatAdvancedPage()
{
}

void CRatAdvancedPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRatAdvancedPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRatAdvancedPage, CPropertyPage)
	//{{AFX_MSG_MAP(CRatAdvancedPage)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,  DoHelp)
    ON_COMMAND(ID_HELP,         DoHelp)
    ON_COMMAND(ID_CONTEXT_HELP, DoHelp)
    ON_COMMAND(ID_DEFAULT_HELP, DoHelp)
END_MESSAGE_MAP()

//---------------------------------------------------------------------------
void CRatAdvancedPage::DoHelp()
    {
    }

/////////////////////////////////////////////////////////////////////////////
// CRatAdvancedPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\cnfgprts\parserat.h ===
/****************************************************************************\
 *
 *   PARSERAT.H --Structures for holding pics information
 *
 *   Created:   Jason Thomas
 *   Updated:   Ann McCurdy
 *   
\****************************************************************************/

#ifndef _PARSERAT_H_
#define _PARSERAT_H_




// output defines ---------------------------------------
#define OUTPUT_PICS




/*Array template---------------------------------------------------*/

/*Interface-------------------------------------------------------------------*/
template <class T>
class array {
    private:
        int nLen, nMax;
        T   *pData;
        void Destruct();
    public:
        array();
        ~array();

        BOOL Append(T v);
        int  Length() const;
        void ClearAll();
        void DeleteAll();

        T& operator[](int index);
};

/*definitions of everything*/

#ifndef ARRAY_CXX
#define ARRAY_CXX

/*Implementation------------------------------------------------------------*/
template <class T>
array<T>::array(){
    nLen  = nMax = 0;
    pData = NULL;
}

template <class T>
inline array<T>::~array() {
    if (pData) ::MemFree(pData);
    pData = NULL;
    nMax  = nLen = 0;
}

template <class T>
inline int array<T>::Length() const{
    return nLen;
}

template <class T>
inline T& array<T>::operator[](int index){
    assert(index<Length());
    assert(index>=0);
    assert(pData);
    return pData[index];
}

template <class T>
BOOL array<T>::Append(T v) {
    if (nLen == nMax){
        nMax  = nMax + 8;           /* grow by bigger chunks */
        T* pNew = (T*)::MemReAlloc(pData, sizeof(T)*nMax);
        if (pNew == NULL)
            return FALSE;
        pData = pNew;
    }
    assert(pData);
    assert(nMax);
    pData[nLen++] = v;
    return TRUE;
}

template <class T>
void array<T>::Destruct(){
    while (nLen){
        delete pData[--nLen];
    }
}

template <class T>
inline void array<T>::ClearAll() {
    nLen = 0;
}

template <class T>
inline void array<T>::DeleteAll() {
    Destruct();
}

#endif 
/* ARRAY_CXX */


#define P_INFINITY           9999
#define N_INFINITY          -9999

/*Simple PICS types------------------------------------------------*/

#if 0
class ET{
    private:
        BOOL m_fInit;
    public:
        ET();
        void Init();
        void UnInit();
        BOOL fIsInit();
};
#endif

class ETN
{
    private:
        INT_PTR r;
        BOOL m_fInit;
    public:
        ETN() { m_fInit = FALSE; }

        void Init() { m_fInit = TRUE; }
        void UnInit() { m_fInit = FALSE; }
        BOOL fIsInit() { return m_fInit; }

#ifdef DEBUG
        void  Set(INT_PTR rIn);
        INT_PTR Get();
#else
        void  Set(INT_PTR rIn) { Init(); r = rIn; }
        INT_PTR Get() { return r; }
#endif

        ETN*  Duplicate();
};

const UINT ETB_VALUE = 0x01;
const UINT ETB_ISINIT = 0x02;
class ETB
{
    private:
        UINT m_nFlags;
    public:
        ETB() { m_nFlags = 0; }

#ifdef DEBUG
        INT_PTR Get();
        void Set(INT_PTR b);
#else
        INT_PTR Get() { return m_nFlags & ETB_VALUE; }
        void Set(INT_PTR b) { m_nFlags = ETB_ISINIT | (b ? ETB_VALUE : 0); }
#endif

        ETB   *Duplicate();
        BOOL fIsInit() { return m_nFlags & ETB_ISINIT; }
};

class ETS
{
    private:
        char *pc;
    public:
        ETS() { pc = NULL; }
        ~ETS();
#ifdef DEBUG
        char* Get();
#else
        char *Get() { return pc; }
#endif
        void  Set(const char *pIn);
        ETS*  Duplicate();
        void  SetTo(char *pIn);

        BOOL fIsInit() { return pc != NULL; }
};

/*Complex PICS types-----------------------------------------------*/


enum RatObjectID
{
    ROID_INVALID,           /* dummy entry for terminating arrays */
    ROID_PICSDOCUMENT,      /* value representing the entire document (i.e., no token) */
    ROID_PICSVERSION,
    ROID_RATINGSYSTEM,
    ROID_RATINGSERVICE,
    ROID_RATINGBUREAU,
    ROID_BUREAUREQUIRED,
    ROID_CATEGORY,
    ROID_TRANSMITAS,
    ROID_LABEL,
    ROID_VALUE,
    ROID_DEFAULT,
    ROID_DESCRIPTION,
    ROID_EXTENSION,
    ROID_MANDATORY,
    ROID_OPTIONAL,
    ROID_ICON,
    ROID_INTEGER,
    ROID_LABELONLY,
    ROID_MAX,
    ROID_MIN,
    ROID_MULTIVALUE,
    ROID_NAME,
    ROID_UNORDERED
};

/* A RatObjectHandler parses the contents of a parenthesized object and
 * spits out a binary representation of that data, suitable for passing
 * to an object's AddItem function.  It does not consume the ')' which
 * closes the object.
 */
class RatFileParser;
typedef HRESULT (*RatObjectHandler)(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser);


class PicsCategory;

class PicsObjectBase : public CObject
{
public:
    virtual HRESULT AddItem(RatObjectID roid, LPVOID pData) = 0;
    virtual HRESULT InitializeMyDefaults(PicsCategory *pCategory) = 0;
    virtual void Dump( void ) = 0;
};


const DWORD AO_SINGLE = 0x01;
const DWORD AO_SEEN = 0x02;
const DWORD AO_MANDATORY = 0x04;

struct AllowableOption
{
    RatObjectID roid;
    DWORD fdwOptions;
};


class PicsEnum : public PicsObjectBase
{
    private:
    public:
        ETS etstrName, etstrIcon, etstrDesc;
        ETN etnValue;

        PicsEnum() {}
        ~PicsEnum() {}

        HRESULT AddItem(RatObjectID roid, LPVOID pData);
        HRESULT InitializeMyDefaults(PicsCategory *pCategory);
        void Dump( void );
};

class PicsRatingSystem;

class PicsCategory : public PicsObjectBase
{
    public:
        PicsCategory():currentValue(0) {;}
        ~PicsCategory()
        {
            arrpPC.DeleteAll();
            arrpPE.DeleteAll();
        }

    private:
    public:
        array<PicsCategory*> arrpPC;
        array<PicsEnum*>     arrpPE;
        ETS   etstrTransmitAs, etstrName, etstrIcon, etstrDesc;
        ETN   etnMin,   etnMax;
        ETB   etfMulti, etfInteger, etfLabelled, etfUnordered;
        PicsRatingSystem *pPRS;

        WORD  currentValue;

        void FixupLimits();
        void SetParents(PicsRatingSystem *pOwner);

        HRESULT AddItem(RatObjectID roid, LPVOID pData);
        HRESULT InitializeMyDefaults(PicsCategory *pCategory);

        void Dump( void );

        // boydm
        void OutputLabel( CString &sz );
        BOOL FSetValuePair( CHAR chCat, WORD value );
};


class PicsDefault : public PicsObjectBase
{
public:
    ETB etfInteger, etfLabelled, etfMulti, etfUnordered;
    ETN etnMax, etnMin;

    PicsDefault() {}
    ~PicsDefault() {}

    HRESULT AddItem(RatObjectID roid, LPVOID pData);
    HRESULT InitializeMyDefaults(PicsCategory *pCategory);

    void Dump( void );
};


class PicsExtension : public PicsObjectBase
{
public:
    LPSTR m_pszRatingBureau;

    PicsExtension();
    ~PicsExtension();

    HRESULT AddItem(RatObjectID roid, LPVOID pData);
    HRESULT InitializeMyDefaults(PicsCategory *pCategory);

    void Dump( void );
};


class PicsRatingSystem : public PicsObjectBase
{
    private:
    public:
        array<PicsCategory*> arrpPC;
        ETS                  etstrFile, etstrName, etstrIcon, etstrDesc, 
                             etstrRatingService, etstrRatingSystem, etstrRatingBureau;
        ETN                  etnPicsVersion;
        ETB                  etbBureauRequired;
        PicsDefault *        m_pDefaultOptions;
        DWORD                dwFlags;
        UINT                 nErrLine;

        PicsRatingSystem() :
            m_pDefaultOptions( NULL ),
            dwFlags( 0 ),
            nErrLine( 0 ) {}
        
        ~PicsRatingSystem()
        {
            arrpPC.DeleteAll();
            if (m_pDefaultOptions != NULL)
                delete m_pDefaultOptions;
        }
            
        HRESULT Parse(LPSTR pStreamIn);

        HRESULT AddItem(RatObjectID roid, LPVOID pData);
        HRESULT InitializeMyDefaults(PicsCategory *pCategory);
        VOID Dump();
        void ReportError(HRESULT hres);

        void OutputLabels( CString &sz, CString szURL,CString szName, CString szStart, CString szEnd );
};

void SkipWhitespace(LPSTR *ppsz);
BOOL IsEqualToken(LPCSTR pszTokenStart, LPCSTR pszTokenEnd, LPCSTR pszTokenToMatch);
LPSTR FindTokenEnd(LPSTR pszStart);
HRESULT GetBool(LPSTR *ppszToken, BOOL *pfOut);
HRESULT ParseNumber(LPSTR *ppszNumber, INT *pnOut);

/*Memory utility functions-----------------------------------------------*/

inline void * WINAPI MemAlloc(long cb)
{
    return (void *)::LocalAlloc(LPTR, cb);
}
    
inline void * WINAPI MemReAlloc(void * pb, long cb)
{
    if (pb == NULL)
        return MemAlloc(cb);

    return (void *)::LocalReAlloc((HLOCAL)pb, cb, LMEM_MOVEABLE | LMEM_ZEROINIT);
}

inline BOOL WINAPI MemFree(void * pb)
{
    return (BOOL)HandleToUlong(::LocalFree((HLOCAL)pb));
}

/*String manipulation wrappers---------------------------------------------*/

#ifdef __cplusplus
extern "C" {
#endif

#define memcmpf(d,s,l)  memcmp((d),(s),(l))
#define memcpyf(d,s,l)  memcpy((d),(s),(l))
#define memmovef(d,s,l) MoveMemory((d),(s),(l))
#define memsetf(s,c,l)  memset((s),(c),(l))
#define strcatf(d,s)    strcat((d),(s))
#define strcmpf(s1,s2)  lstrcmp(s1,s2)
#define strcpyf(d,s)    strcpy((d),(s))
#define stricmpf(s1,s2) lstrcmpi(s1,s2)
#define strlenf(s)      strlen((s))
#define strchrf(s,c)    strchr((s),(c))
#define strrchrf(s,c)   strrchr((s),(c))
#define strspnf(s1,s2)  strspn((s1),(s2))
#define strnicmpf(s1,s2,i)  _strnicmp((s1),(s2),(i))
#define strncpyf(s1,s2,i)   strncpy((s1),(s2),(i))
#define strcspnf(s1,s2) strcspn((s1),(s2))
#define strtokf(s1,s2)  strtok((s1),(s2))
#define strstrf(s1,s2)  strstr((s1),(s2))


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\cnfgprts\parserat.cpp ===
/****************************************************************************\
 *
 *   PARSERAT.C -- Code to parse .RAT files
 *
 *   Created:   Greg Jones
 *
\****************************************************************************/

/*Includes------------------------------------------------------------------*/
#include "stdafx.h"
#include "cnfgprts.h"

#include "parserat.h"
#include <iis64.h>

/****************************************************************************
Some design notes on how this parser works:

A ParenThing is:

'(' identifier [stuff] ')'

where [stuff] could be:
    a quoted string
    a number
    a boolean
    a series of ParenThings
    in the case of extensions:
        a quoted string, followed by
        one or more quoted strings and/or ParenThings

The entire .RAT file is a ParenThing, except that it has no identifier, just
a list of ParenThings inside it.


**********************************************************************
We pass the parser a schema for what things it expects -- we have
a big array listing identifiers for each different possible keyword, and
each parser call receives a smaller array containing only those indices
that are valid to occur within that object.

We make PicsRatingSystem, PicsCategory, and PicsEnum derive from a common
base class which supports a virtual function AddItem(ID,data).  So at the
top level, we construct an (empty) PicsRatingSystem.  We call the parser,
giving it a pointer to that guy, and a structure describing what to parse --
the ParenObject's token is a null string (since the global structure is the
one that doesn't start with a token before its first embedded ParenThing),
and we give a list saying the allowable things in a PicsRatingSystem are
PICS-version, rating-system, rating-service, default, description, extension,
icon, name, category.  There is a global table indicating a handler function
for every type of ParenThing, which knows how to create a data structure
completely describing that ParenThing.  (That data structure could be as
simple as a number or as complex as allocating and parsing a complete
PicsCategory object.)

The parser walks along, and for each ParenThing he finds, he identifies it
by looking up its token in the list provided by the caller. Each entry in
that list should include a field which indicates whether multiple things
of that identity are allowed (e.g., 'category') or not (e.g., rating-system).
If only one is allowed, then when the parser finds one he marks it as having
been found.

When the parser identifies the ParenThing, he calls its handler function to
completely parse the data in the ParenThing and return that object into an
LPVOID provided by the parser.  If that is successful, the parser then calls
its object's AddItem(ID,data) virtual function to add the specified item to
the object, relying on the object itself to know what type "data" points to --
a number, a pointer to a heap string which can be given to ETS::SetTo, a
pointer to a PicsCategory object which can be appended to an array, etc.

The RatFileParser class exists solely to provide a line number shared by
all the parsing routines.  This line number is updated as the parser walks
through the file, and is frozen as soon as an error is found.  This line
number can later be reported to the user to help localize errors in RAT files.

*****************************************************************************/

/*Globals-------------------------------------------------------------------*/

#define EXTTEXT(n) const CHAR n[]
#define TEXTCONST(name,text) EXTTEXT(name) = (text)

/* Text strings used in parsing rating labels. */

TEXTCONST(szNULL,"");
TEXTCONST(szDoubleCRLF,"\r\n\r\n");
TEXTCONST(szPicsOpening,"(PICS-");
TEXTCONST(szWhitespace," \t\r\n");
TEXTCONST(szExtendedAlphaNum,"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+-.,;:&=?!*~@#/");
TEXTCONST(szSingleCharTokens,"()\"");
TEXTCONST(szLeftParen,"(");
TEXTCONST(szRightParen,")");
TEXTCONST(szOptional,"optional");
TEXTCONST(szMandatory,"mandatory");
TEXTCONST(szAtOption,"at");
TEXTCONST(szByOption,"by");
TEXTCONST(szCommentOption,"comment");
TEXTCONST(szCompleteLabelOption,"complete-label");
TEXTCONST(szFullOption,"full");
TEXTCONST(szExtensionOption,"extension");
TEXTCONST(szGenericOption,"generic");
TEXTCONST(szShortGenericOption,"gen");
TEXTCONST(szForOption,"for");
TEXTCONST(szMICOption,"MIC-md5");
TEXTCONST(szMD5Option,"md5");
TEXTCONST(szOnOption,"on");
TEXTCONST(szSigOption,"signature-PKCS");
TEXTCONST(szUntilOption,"until");
TEXTCONST(szExpOption,"exp");
TEXTCONST(szRatings,"ratings");
TEXTCONST(szShortRatings,"r");
TEXTCONST(szError,"error");
TEXTCONST(szNoRatings,"no-ratings");
TEXTCONST(szLabelWord,"labels");
TEXTCONST(szShortLabelWord,"l");
TEXTCONST(szShortTrue,"t");
TEXTCONST(szTrue,"true");
TEXTCONST(szShortFalse,"f");
TEXTCONST(szFalse,"false");

TEXTCONST(szNegInf,"-INF");
TEXTCONST(szPosInf,"+INF");
TEXTCONST(szLabel,"label");
TEXTCONST(szName,"name");
TEXTCONST(szValue,"value");
TEXTCONST(szIcon,"icon");
TEXTCONST(szDescription, "description");
TEXTCONST(szCategory, "category");
TEXTCONST(szTransmitAs, "transmit-as");
TEXTCONST(szMin,"min");
TEXTCONST(szMax,"max");
TEXTCONST(szMultivalue,"multivalue");
TEXTCONST(szInteger,"integer");
TEXTCONST(szLabelOnly, "label-only");
TEXTCONST(szPicsVersion,"PICS-version");
TEXTCONST(szRatingSystem,"rating-system");
TEXTCONST(szRatingService,"rating-service");
TEXTCONST(szRatingBureau,"rating-bureau");
TEXTCONST(szBureauRequired,"bureau-required");
TEXTCONST(szDefault,"default");
TEXTCONST(szMultiValue,"multivalue");
TEXTCONST(szUnordered,"unordered");
TEXTCONST(szRatingBureauExtension,"www.w3.org/PICS/service-extensions/label-bureau");

/* define some error codes */
const HRESULT RAT_E_BASE = 0x80050000;                  /* just a guess at a free area for internal use */
const HRESULT RAT_E_EXPECTEDLEFT    = RAT_E_BASE + 1;   /* expected left paren */
const HRESULT RAT_E_EXPECTEDRIGHT   = RAT_E_BASE + 2;   /* expected right paren */
const HRESULT RAT_E_EXPECTEDTOKEN   = RAT_E_BASE + 3;   /* expected unquoted token */
const HRESULT RAT_E_EXPECTEDSTRING  = RAT_E_BASE + 4;   /* expected quoted string */
const HRESULT RAT_E_EXPECTEDNUMBER  = RAT_E_BASE + 5;   /* expected number */
const HRESULT RAT_E_EXPECTEDBOOL    = RAT_E_BASE + 6;   /* expected boolean */
const HRESULT RAT_E_DUPLICATEITEM   = RAT_E_BASE + 7;   /* AO_SINGLE item appeared twice */
const HRESULT RAT_E_MISSINGITEM     = RAT_E_BASE + 8;   /* AO_MANDATORY item not found */
const HRESULT RAT_E_UNKNOWNITEM     = RAT_E_BASE + 9;   /* unrecognized token */
const HRESULT RAT_E_UNKNOWNMANDATORY= RAT_E_BASE + 10;  /* unrecognized mandatory extension */

char PicsDelimChar='/';

class RatFileParser
{
public:
    UINT m_nLine;

    RatFileParser() { m_nLine = 1; }

    LPSTR EatQuotedString(LPSTR pIn);
    HRESULT ParseToOpening(LPSTR *ppIn, AllowableOption *paoExpected,
                           AllowableOption **ppFound);
    HRESULT ParseParenthesizedObject(
        LPSTR *ppIn,                    /* where we are in the text stream */
        AllowableOption aao[],          /* allowable things inside this object */
        PicsObjectBase *pObject         /* object to set parameters into */
    );
    char* FindNonWhite(char *pc);
};



/* White returns a pointer to the first whitespace character starting at pc.
 */
char* White(char *pc){
    assert(pc);
    while (1){
        if (*pc == '\0' ||
            *pc ==' ' ||
            *pc == '\t' ||
            *pc == '\r' ||
            *pc == '\n')
        {
            return pc;
        }
        pc++;
    }
}


/* NonWhite returns a pointer to the first non-whitespace character starting
 * at pc.
 */
char* NonWhite(char *pc){
    assert(pc);
    while (1){
        if (*pc != ' ' &&
            *pc != '\t' &&
            *pc != '\r' &&
            *pc != '\n')            /* includes null terminator */
        {
            return pc;
        }
        pc++;
    }
}


/* FindNonWhite returns a pointer to the first non-whitespace character starting
 * at pc.
 */
char* RatFileParser::FindNonWhite(char *pc)
{
    assert(pc);
    while (1)
    {
        if (*pc != ' ' &&
            *pc != '\t' &&
            *pc != '\r' &&
            *pc != '\n')            /* includes null terminator */
        {
            return pc;
        }
        if (*pc == '\n')
            m_nLine++;
        pc++;
    }
}

/* AppendSlash forces pszString to end in a single slash if it doesn't
 * already.  This may produce a technically invalid URL (for example,
 * "http://gregj/default.htm/", but we're only using the result for
 * comparisons against other paths similarly mangled.
 */
void AppendSlash(LPSTR pszString)
{
    LPSTR pszSlash = ::strrchrf(pszString, '/');

    if (pszSlash == NULL || *(pszSlash + 1) != '\0')
        ::strcatf(pszString, "/");
}

/* SkipWhitespace(&pszString)
 *
 * advances pszString past whitespace characters
 */
void SkipWhitespace(LPSTR *ppsz)
{
    UINT cchWhitespace = ::strspnf(*ppsz, szWhitespace);

    *ppsz += cchWhitespace;
}


/* FindTokenEnd(pszStart)
 *
 * Returns a pointer to the end of a contiguous range of similarly-typed
 * characters (whitespace, quote mark, punctuation, or alphanumerics).
 */
LPSTR FindTokenEnd(LPSTR pszStart)
{
    LPSTR pszEnd = pszStart;

    if (*pszEnd == '\0') {
        return pszEnd;
    }
    else if (strchr(szSingleCharTokens, *pszEnd)) {
        return ++pszEnd;
    }

    UINT cch;
    cch = ::strspnf(pszEnd, szWhitespace);
    if (cch > 0)
        return pszEnd + cch;

    cch = ::strspnf(pszEnd, szExtendedAlphaNum);
    if (cch > 0)
        return pszEnd + cch;

    return pszEnd;              /* unrecognized characters */
}


/* GetBool(LPSTR *ppszToken, BOOL *pfOut)
 *
 * Parses a boolean value at the given token and returns its value in *pfOut.
 * Legal values are 't', 'f', 'true', and 'false'.  If success, *ppszToken
 * is advanced past the boolean token and any following whitespace.  If failure,
 * *ppszToken is not modified.
 *
 * pfOut may be NULL if the caller just wants to eat the token and doesn't
 * care about its value.
 */
HRESULT GetBool(LPSTR *ppszToken, BOOL *pfOut)
{
    BOOL bValue;

    LPSTR pszTokenEnd = FindTokenEnd(*ppszToken);

    if (IsEqualToken(*ppszToken, pszTokenEnd, szShortTrue) ||
        IsEqualToken(*ppszToken, pszTokenEnd, szTrue)) {
        bValue = TRUE;
    }
    else if (IsEqualToken(*ppszToken, pszTokenEnd, szShortFalse) ||
        IsEqualToken(*ppszToken, pszTokenEnd, szFalse)) {
        bValue = FALSE;
    }
    else
        return ResultFromScode(MK_E_SYNTAX);

    if (pfOut != NULL)
        *pfOut = bValue;

    *ppszToken = pszTokenEnd;
    SkipWhitespace(ppszToken);

    return NOERROR;
}


/* GetQuotedToken(&pszThisToken, &pszQuotedToken)
 *
 * Sets pszQuotedToken to point to the contents of the doublequotes.
 * pszQuotedToken may be NULL if the caller just wants to eat the token.
 * Sets pszThisToken to point to the first character after the closing
 *   doublequote.
 * Fails if pszThisToken doesn't start with a doublequote or doesn't
 *   contain a closing doublequote.
 * The closing doublequote is replaced with a null terminator, iff the
 *   function does not fail.
 */
HRESULT GetQuotedToken(LPSTR *ppszThisToken, LPSTR *ppszQuotedToken)
{
    HRESULT hres = ResultFromScode(MK_E_SYNTAX);

    LPSTR pszStart = *ppszThisToken;
    if (*pszStart != '\"')
        return hres;

    pszStart++;
    LPSTR pszEndQuote = strchrf(pszStart, '\"');
    if (pszEndQuote == NULL)
        return hres;

    *pszEndQuote = '\0';
    if (ppszQuotedToken != NULL)
        *ppszQuotedToken = pszStart;
    *ppszThisToken = pszEndQuote+1;

    return NOERROR;
}


BOOL IsEqualToken(LPCSTR pszTokenStart, LPCSTR pszTokenEnd, LPCSTR pszTokenToMatch)
{
    UINT cbToken = strlenf(pszTokenToMatch);

    if (cbToken != (UINT)(pszTokenEnd - pszTokenStart) || strnicmpf(pszTokenStart, pszTokenToMatch, cbToken))
        return FALSE;

    return TRUE;
}


/* ParseLiteralToken(ppsz, pszToken) tries to match *ppsz against pszToken.
 * If they don't match, an error is returned.  If they do match, then *ppsz
 * is advanced past the token and any following whitespace.
 *
 * If ppszInvalid is NULL, then the function is non-destructive in the error
 * path, so it's OK to call ParseLiteralToken just to see if a possible literal
 * token is what's next; if the token isn't found, whatever was there didn't
 * get eaten or anything.
 *
 * If ppszInvalid is not NULL, then if the token doesn't match, *ppszInvalid
 * will be set to *ppsz.
 */
HRESULT ParseLiteralToken(LPSTR *ppsz, LPCSTR pszToken, LPCSTR *ppszInvalid)
{
    LPSTR pszTokenEnd = FindTokenEnd(*ppsz);

    if (!IsEqualToken(*ppsz, pszTokenEnd, pszToken)) {
        if (ppszInvalid != NULL)
            *ppszInvalid = *ppsz;
        return ResultFromScode(MK_E_SYNTAX);
    }

    *ppsz = pszTokenEnd;

    SkipWhitespace(ppsz);

    return NOERROR;
}


/* ParseNumber parses a numeric token at the specified position.  If the
 * number makes sense, the pointer is advanced to the end of the number
 * and past any following whitespace, and the numeric value is returned
 * in *pnOut.  Any non-numeric characters are considered to terminate the
 * number without error;  it is assumed that higher-level parsing code
 * will eventually reject such characters if they're not supposed to be
 * there.
 *
 * pnOut may be NULL if the caller doesn't care about the number being
 * returned and just wants to eat it.
 *
 * Floating point numbers of the form nnn.nnn are rounded to the next
 * higher integer and returned as such.
 */
HRESULT ParseNumber(LPSTR *ppszNumber, INT *pnOut)
{
    HRESULT hres = ResultFromScode(MK_E_SYNTAX);
    BOOL fNegative = FALSE;
    INT nAccum = 0;
    BOOL fNonZeroDecimal = FALSE;
    BOOL fInDecimal = FALSE;
    BOOL fFoundDigits = FALSE;

    LPSTR pszCurrent = *ppszNumber;

    /* Handle one sign character. */
    if (*pszCurrent == '+') {
        pszCurrent++;
    }
    else if (*pszCurrent == '-') {
        pszCurrent++;
        fNegative = TRUE;
    }

    for (;;) {
        if (*pszCurrent == '.') {
            fInDecimal = TRUE;
        }
        else if (*pszCurrent >= '0' && *pszCurrent <= '9') {
            fFoundDigits = TRUE;
            if (fInDecimal) {
                if (*pszCurrent > '0') {
                    fNonZeroDecimal = TRUE;
                }
            }
            else {
                nAccum = nAccum * 10 + (*pszCurrent - '0');
            }
        }
        else
            break;

        pszCurrent++;
    }

    if (fFoundDigits) {
        hres = NOERROR;
        if (fNonZeroDecimal)
            nAccum++;           /* round away from zero if decimal present */
        if (fNegative)
            nAccum = -nAccum;
    }

    if (SUCCEEDED(hres)) {
        if (pnOut != NULL)
            *pnOut = nAccum;
        *ppszNumber = pszCurrent;
        SkipWhitespace(ppszNumber);
    }

    return hres;
}

HRESULT ParsePseudoFloat(LPSTR *ppszNumber, INT *pnOut)
{
    HRESULT hres = ResultFromScode(MK_E_SYNTAX);
    INT val1, val2;
    BOOL fInDecimal = FALSE;
    CHAR achBuffer[ 256 ];      // ugly

    LPSTR pszCurrent = *ppszNumber;

    *achBuffer = '\0';

    /* Handle one sign character. */
    if (*pszCurrent == '+') {
        pszCurrent++;
    }
    else if (*pszCurrent == '-') {
        strcatf( achBuffer, "-" );
        pszCurrent++;
    }

    for (;;) {
        if (*pszCurrent == '.') {
            if ( fInDecimal ) break;
            fInDecimal = TRUE;
            strcatf( achBuffer, "." );
        }
        else if (*pszCurrent >= '0' && *pszCurrent <= '9') {
            CHAR achFoo[ 2 ] = { '\0', '\0' };
            achFoo[ 0 ] = *pszCurrent;
            strcatf( achBuffer, achFoo );
        }
        else
            break;

        pszCurrent++;
    }

    if ( !fInDecimal )
    {
        strcatf( achBuffer, ".0" );
    }

    if ( sscanf( achBuffer, "%d.%d", &val1, &val2 ) == 2 )
    {
        hres = NOERROR;
    }

    if (SUCCEEDED(hres)) {
        if (pnOut != NULL)
            *pnOut = ( ( val1 << 16 ) & 0xFFFF0000 ) | ( val2 & 0x0000FFFF );
        *ppszNumber = pszCurrent;
        SkipWhitespace(ppszNumber);
    }

    return hres;
}

const char szPicsVersionLabel[] = "PICS-";
const UINT cchLabel = (sizeof(szPicsVersionLabel)-1) / sizeof(szPicsVersionLabel[0]);

/* Returns a pointer to the closing doublequote of a quoted string, counting
 * linefeeds as we go.  Returns NULL if no closing doublequote found.
 */
LPSTR RatFileParser::EatQuotedString(LPSTR pIn)
{
    LPSTR pszQuote = strchrf(pIn, '\"');
    if (pszQuote == NULL)
        return NULL;

    pIn = strchrf(pIn, '\n');
    while (pIn != NULL && pIn < pszQuote) {
        m_nLine++;
        pIn = strchrf(pIn+1, '\n');
    }

    return pszQuote;
}

/***************************************************************************
    Member functions for ET* classes
***************************************************************************/

/* ETN */
#ifdef DEBUG
void  ETN::Set(int rIn){
    Init();
    r = rIn;
}
int ETN::Get(){
    assert(fIsInit());
    return r;
}
#endif

ETN* ETN::Duplicate(){
    ETN *pETN=new ETN;
    if (fIsInit()) pETN->Set(Get());
    return pETN;
}

/* ETB */
#ifdef DEBUG
BOOL ETB::Get()
{
    assert(fIsInit());
    return m_nFlags & ETB_VALUE;
}

void ETB::Set(BOOL b)
{
    m_nFlags = ETB_ISINIT | (b ? ETB_VALUE : 0);
}
#endif

ETB* ETB::Duplicate()
{
    assert(fIsInit());

    ETB *pETB = new ETB;
    if (pETB != NULL)
        pETB->m_nFlags = m_nFlags;
    return pETB;
}

/* ETS */

ETS::~ETS()
{
    if (pc != NULL) {
        delete pc;
        pc = NULL;
    }
}

#ifdef DEBUG
char* ETS::Get()
{
    assert(fIsInit());
    return pc;
}
#endif

void ETS::Set(const char *pIn)
{
    if (pc != NULL)
        delete pc;

    if (pIn != NULL) {
        pc = new char[strlenf(pIn) + 1];
        if (pc != NULL) {
            strcpyf(pc, pIn);
        }
    }
    else {
        pc = NULL;
    }
}


void ETS::SetTo(char *pIn)
{
    if (pc != NULL)
        delete pc;

    pc = pIn;
}


ETS* ETS::Duplicate()
{
    ETS *pETS=new ETS;
    try
    {
        if (pETS != NULL)
        {
            pETS->Set(Get());
        }
    }
    catch(...)
    {
    }

    return pETS;
}

/***************************************************************************
    Worker functions for inheriting category properties and other
    miscellaneous category stuff.
***************************************************************************/

HRESULT PicsCategory::InitializeMyDefaults(PicsCategory *pCategory)
    {
    if (!pCategory->etnMin.fIsInit()      && etnMin.fIsInit())
        pCategory->etnMin.Set(etnMin.Get());

    if (!pCategory->etnMax.fIsInit()      && etnMax.fIsInit())
        pCategory->etnMax.Set(etnMax.Get());

    if (!pCategory->etfMulti.fIsInit()    && etfMulti.fIsInit())
        pCategory->etfMulti.Set(etfMulti.Get());

    if (!pCategory->etfInteger.fIsInit()  && etfInteger.fIsInit())
        pCategory->etfInteger.Set(etfInteger.Get());

    if (!pCategory->etfLabelled.fIsInit() && etfLabelled.fIsInit())
        pCategory->etfLabelled.Set(etfLabelled.Get());

    if (!pCategory->etfUnordered.fIsInit() && etfUnordered.fIsInit())
        pCategory->etfUnordered.Set(etfUnordered.Get());

    return NOERROR;
    }


HRESULT PicsRatingSystem::InitializeMyDefaults(PicsCategory *pCategory)
{
    if (m_pDefaultOptions != NULL)
        return m_pDefaultOptions->InitializeMyDefaults(pCategory);

    return NOERROR;             /* no defaults to initialize */
}


HRESULT PicsDefault::InitializeMyDefaults(PicsCategory *pCategory)
{
    if (!pCategory->etnMin.fIsInit()      && etnMin.fIsInit())
        pCategory->etnMin.Set(etnMin.Get());

    if (!pCategory->etnMax.fIsInit()      && etnMax.fIsInit())
        pCategory->etnMax.Set(etnMax.Get());

    if (!pCategory->etfMulti.fIsInit()    && etfMulti.fIsInit())
        pCategory->etfMulti.Set(etfMulti.Get());

    if (!pCategory->etfInteger.fIsInit()  && etfInteger.fIsInit())
        pCategory->etfInteger.Set(etfInteger.Get());

    if (!pCategory->etfLabelled.fIsInit() && etfLabelled.fIsInit())
        pCategory->etfLabelled.Set(etfLabelled.Get());

    if (!pCategory->etfUnordered.fIsInit() && etfUnordered.fIsInit())
        pCategory->etfUnordered.Set(etfUnordered.Get());

    return NOERROR;
}


HRESULT PicsEnum::InitializeMyDefaults(PicsCategory *pCategory)
{
    return E_NOTIMPL;       /* should never have a category inherit from an enum */
}


PicsExtension::PicsExtension()
    : m_pszRatingBureau(NULL)
{
    /* nothing else */
}


PicsExtension::~PicsExtension()
{
    delete m_pszRatingBureau;
}


HRESULT PicsExtension::InitializeMyDefaults(PicsCategory *pCategory)
{
    return E_NOTIMPL;       /* should never have a category inherit from an extension */
}


void PicsCategory::FixupLimits()
{
    BOOL fLabelled = (etfLabelled.fIsInit() && etfLabelled.Get());

    /*fix up max and min values*/
    if (fLabelled ||
        (arrpPE.Length()>0 && (!etnMax.fIsInit() || !etnMax.fIsInit())))
    {
        if (arrpPE.Length() > 0)
        {
            if (!etnMax.fIsInit())
                etnMax.Set(N_INFINITY);
            if (!etnMin.fIsInit())
                etnMin.Set(P_INFINITY);
            for (int z=0;z<arrpPE.Length();++z)
            {
                if (arrpPE[z]->etnValue.Get() > etnMax.Get()) etnMax.Set(arrpPE[z]->etnValue.Get());
                if (arrpPE[z]->etnValue.Get() < etnMin.Get()) etnMin.Set(arrpPE[z]->etnValue.Get());
            }
        }
        else {
            etfLabelled.Set(FALSE); /* no enum labels?  better not have labelled flag then */
            fLabelled = FALSE;
        }
    }

    /*sort labels by value*/
    if (fLabelled)
    {
        int x,y;
        PicsEnum *pPE;
        for (x=0;x<arrpPE.Length()-1;++x){
            for (y=x+1;y<arrpPE.Length();++y){
                if (arrpPE[y]->etnValue.Get() < arrpPE[x]->etnValue.Get()){
                    pPE = arrpPE[x];
                    arrpPE[x] = arrpPE[y];
                    arrpPE[y] = pPE;
                }
            }
        }
    }
}


void PicsCategory::SetParents(PicsRatingSystem *pOwner)
{
    pPRS = pOwner;
    UINT cSubCategories = arrpPC.Length();
    for (UINT i = 0; i < cSubCategories; i++) {
        InitializeMyDefaults(arrpPC[i]);    /* subcategory inherits our defaults */
        arrpPC[i]->SetParents(pOwner);      /* process all subcategories */
    }
    FixupLimits();      /* inheritance is done, make sure limits make sense */
}


/***************************************************************************
    Handler functions which know how to parse the various kinds of content
    which can occur within a parenthesized object.
***************************************************************************/

HRESULT RatParseString(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser)
{
    *ppOut = NULL;

    LPSTR pszCurrent = *ppszIn;

    if (*pszCurrent != '\"')
        return RAT_E_EXPECTEDSTRING;

    pszCurrent++;

    LPSTR pszEnd = pParser->EatQuotedString(pszCurrent);
    if (pszEnd == NULL)
        return RAT_E_EXPECTEDSTRING;

    UINT cbString = DIFF(pszEnd - pszCurrent);
    LPSTR pszNew = new char[cbString + 1];
    if (pszNew == NULL)
        return E_OUTOFMEMORY;

    memcpyf(pszNew, pszCurrent, cbString);
    pszNew[cbString] = '\0';

    *ppOut = (LPVOID)pszNew;
    *ppszIn = pParser->FindNonWhite(pszEnd + 1);

    return NOERROR;
}


HRESULT RatParseNumber(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser)
{
    int n;

    LPSTR pszCurrent = *ppszIn;
    HRESULT hres = ::ParseNumber(&pszCurrent, &n);

    if (FAILED(hres))
        return RAT_E_EXPECTEDNUMBER;

    *(int *)ppOut = n;

    LPSTR pszNewline = strchrf(*ppszIn, '\n');
    while (pszNewline != NULL && pszNewline < pszCurrent) {
        pParser->m_nLine++;
        pszNewline = strchrf(pszNewline+1, '\n');
    }
    *ppszIn = pszCurrent;

    return NOERROR;
}

HRESULT RatParsePseudoFloat(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser)
{
    INT n;

    LPSTR pszCurrent = *ppszIn;
    HRESULT hres = ::ParsePseudoFloat(&pszCurrent, &n);

    if (FAILED(hres))
        return RAT_E_EXPECTEDNUMBER;

    *(INT *)ppOut = n;

    LPSTR pszNewline = strchrf(*ppszIn, '\n');
    while (pszNewline != NULL && pszNewline < pszCurrent) {
        pParser->m_nLine++;
        pszNewline = strchrf(pszNewline+1, '\n');
    }
    *ppszIn = pszCurrent;

    return NOERROR;
}

HRESULT RatParseBool(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser)
{
    BOOL b;

    /* PICS spec allows a terse way of specifying a TRUE boolean -- leaving
     * out the value entirely.  In a .RAT file, the result looks like
     *
     * (unordered)
     * (multivalue)
     *
     * and so on.  Called has pointed us at non-whitespace, so if we see
     * a closing paren, we know the .RAT file author used this syntax.
     */
    if (**ppszIn == ')') {
        b = TRUE;
    }
    else {
        LPSTR pszCurrent = *ppszIn;
        HRESULT hres = ::GetBool(&pszCurrent, &b);

        if (FAILED(hres))
            return RAT_E_EXPECTEDBOOL;

        LPSTR pszNewline = strchrf(*ppszIn, '\n');
        while (pszNewline != NULL && pszNewline < pszCurrent) {
            pParser->m_nLine++;
            pszNewline = strchrf(pszNewline+1, '\n');
        }
        *ppszIn = pszCurrent;
    }

    *(LPBOOL)ppOut = b;

    return NOERROR;
}


AllowableOption aaoPicsCategory[] = {
    { ROID_TRANSMITAS, AO_SINGLE | AO_MANDATORY },
    { ROID_NAME, AO_SINGLE },
    { ROID_DESCRIPTION, AO_SINGLE },
    { ROID_ICON, AO_SINGLE },
    { ROID_EXTENSION, 0 },
    { ROID_INTEGER, AO_SINGLE },
    { ROID_LABELONLY, AO_SINGLE },
    { ROID_MIN, AO_SINGLE },
    { ROID_MAX, AO_SINGLE },
    { ROID_MULTIVALUE, AO_SINGLE },
    { ROID_UNORDERED, AO_SINGLE },
    { ROID_LABEL, 0 },
    { ROID_CATEGORY, 0 },
    { ROID_INVALID, 0 }
};
const UINT caoPicsCategory = sizeof(aaoPicsCategory) / sizeof(aaoPicsCategory[0]);

HRESULT RatParseCategory(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser)
{
    /* We must make a copy of the allowable options array because the
     * parser will fiddle with the flags in the entries -- specifically,
     * setting AO_SEEN.  It wouldn't be thread-safe to do this to a
     * static array.
     */
    AllowableOption aao[caoPicsCategory];

    ::memcpyf(aao, ::aaoPicsCategory, sizeof(aao));

    PicsCategory *pCategory = new PicsCategory;
    if (pCategory == NULL)
        return E_OUTOFMEMORY;

    HRESULT hres = pParser->ParseParenthesizedObject(
                        ppszIn,                 /* var containing current ptr */
                        aao,                    /* what's legal in this object */
                        pCategory);             /* object to add items back to */

    if (FAILED(hres)) {
        delete pCategory;
        return hres;
    }

    *ppOut = (LPVOID)pCategory;
    return NOERROR;
}


AllowableOption aaoPicsEnum[] = {
    { ROID_NAME, AO_SINGLE },
    { ROID_DESCRIPTION, AO_SINGLE },
    { ROID_VALUE, AO_SINGLE | AO_MANDATORY },
    { ROID_ICON, AO_SINGLE },
    { ROID_INVALID, 0 }
};
const UINT caoPicsEnum = sizeof(aaoPicsEnum) / sizeof(aaoPicsEnum[0]);

HRESULT RatParseLabel(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser)
{
    /* We must make a copy of the allowable options array because the
     * parser will fiddle with the flags in the entries -- specifically,
     * setting AO_SEEN.  It wouldn't be thread-safe to do this to a
     * static array.
     */
    AllowableOption aao[caoPicsEnum];

    ::memcpyf(aao, ::aaoPicsEnum, sizeof(aao));

    PicsEnum *pEnum = new PicsEnum;
    if (pEnum == NULL)
        return E_OUTOFMEMORY;

    HRESULT hres = pParser->ParseParenthesizedObject(
                        ppszIn,                 /* var containing current ptr */
                        aao,                    /* what's legal in this object */
                        pEnum);                 /* object to add items back to */

    if (FAILED(hres)) {
        delete pEnum;
        return hres;
    }

    *ppOut = (LPVOID)pEnum;
    return NOERROR;
}


AllowableOption aaoPicsDefault[] = {
    { ROID_EXTENSION, 0 },
    { ROID_INTEGER, AO_SINGLE },
    { ROID_LABELONLY, AO_SINGLE },
    { ROID_MAX, AO_SINGLE },
    { ROID_MIN, AO_SINGLE },
    { ROID_MULTIVALUE, AO_SINGLE },
    { ROID_UNORDERED, AO_SINGLE },
    { ROID_INVALID, 0 }
};
const UINT caoPicsDefault = sizeof(aaoPicsDefault) / sizeof(aaoPicsDefault[0]);

HRESULT RatParseDefault(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser)
{
    /* We must make a copy of the allowable options array because the
     * parser will fiddle with the flags in the entries -- specifically,
     * setting AO_SEEN.  It wouldn't be thread-safe to do this to a
     * static array.
     */
    AllowableOption aao[caoPicsDefault];

    ::memcpyf(aao, ::aaoPicsDefault, sizeof(aao));

    PicsDefault *pDefault = new PicsDefault;
    if (pDefault == NULL)
        return E_OUTOFMEMORY;

    HRESULT hres = pParser->ParseParenthesizedObject(
                        ppszIn,                 /* var containing current ptr */
                        aao,                    /* what's legal in this object */
                        pDefault);              /* object to add items back to */

    if (FAILED(hres)) {
        delete pDefault;
        return hres;
    }

    *ppOut = (LPVOID)pDefault;
    return NOERROR;
}


AllowableOption aaoPicsExtension[] = {
    { ROID_MANDATORY, AO_SINGLE },
    { ROID_OPTIONAL, AO_SINGLE },
    { ROID_INVALID, 0 }
};
const UINT caoPicsExtension = sizeof(aaoPicsExtension) / sizeof(aaoPicsExtension[0]);

HRESULT RatParseExtension(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser)
{
    /* We must make a copy of the allowable options array because the
     * parser will fiddle with the flags in the entries -- specifically,
     * setting AO_SEEN.  It wouldn't be thread-safe to do this to a
     * static array.
     */
    AllowableOption aao[caoPicsExtension];

    ::memcpyf(aao, ::aaoPicsExtension, sizeof(aao));

    PicsExtension *pExtension = new PicsExtension;
    if (pExtension == NULL)
        return E_OUTOFMEMORY;

    HRESULT hres = pParser->ParseParenthesizedObject(
                        ppszIn,                 /* var containing current ptr */
                        aao,                    /* what's legal in this object */
                        pExtension);            /* object to add items back to */

    if (FAILED(hres)) {
        delete pExtension;
        return hres;
    }

    *ppOut = (LPVOID)pExtension;
    return NOERROR;
}


/* Since the only extension we support right now is the one for a label
 * bureau, we just return the first quoted string we find if the caller
 * wants it.  If ppOut is NULL, then it's some other extension and the
 * caller doesn't care about the data, he just wants it eaten.
 */
HRESULT ParseRatExtensionData(LPSTR *ppszIn, RatFileParser *pParser, LPSTR *ppOut)
{
    HRESULT hres = NOERROR;

    LPSTR pszCurrent = *ppszIn;

    /* Must look for closing ')' ourselves to terminate */
    while (*pszCurrent != ')') {
        if (*pszCurrent == '(') {
            pszCurrent = pParser->FindNonWhite(pszCurrent+1);       /* skip paren and whitespace */
            hres = ParseRatExtensionData(&pszCurrent, pParser, ppOut);  /* parentheses contain data */
            if (FAILED(hres))
                return hres;
            if (*pszCurrent != ')')
                return RAT_E_EXPECTEDRIGHT;

            pszCurrent = pParser->FindNonWhite(pszCurrent+1);   /* skip close ) and whitespace */
        }
        else if (*pszCurrent == '\"') {             /* should be just a quoted string */
            if (ppOut != NULL && *ppOut == NULL) {
                hres = RatParseString(&pszCurrent, (LPVOID *)ppOut, pParser);
            }
            else {
                ++pszCurrent;
                LPSTR pszEndQuote = pParser->EatQuotedString(pszCurrent);
                if (pszEndQuote == NULL)
                    return RAT_E_EXPECTEDSTRING;
                pszCurrent = pParser->FindNonWhite(pszEndQuote+1);  /* skip close " and whitespace */
            }
        }
        else
            return RAT_E_UNKNOWNITEM;               /* general bad syntax */
    }

    /* Caller will skip over final ')' for us. */

    *ppszIn = pszCurrent;

    return NOERROR;
}


HRESULT RatParseMandatory(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser)
{
    LPSTR pszCurrent = *ppszIn;

    /* First thing better be a quoted URL identifying the extension. */
    if (*pszCurrent != '\"')
        return RAT_E_EXPECTEDSTRING;

    pszCurrent++;
    LPSTR pszEnd = pParser->EatQuotedString(pszCurrent);
    if (pszCurrent == NULL)
        return RAT_E_EXPECTEDSTRING;            /* missing closing " */

    /* See if it's the extension for a label bureau. */

    LPSTR pszBureau = NULL;
    LPSTR *ppData = NULL;
    if (IsEqualToken(pszCurrent, pszEnd, ::szRatingBureauExtension)) {
        ppData = &pszBureau;
    }

    pszCurrent = pParser->FindNonWhite(pszEnd+1);       /* skip closing " and whitespace */

    HRESULT hres = ParseRatExtensionData(&pszCurrent, pParser, ppData);
    if (FAILED(hres))
        return hres;

    *ppOut = pszBureau;     /* return label bureau string if that's what we found */
    *ppszIn = pszCurrent;

    if (ppData == NULL)
        return RAT_E_UNKNOWNMANDATORY;      /* we didn't recognize it */
    else
        return NOERROR;
}


/* RatParseOptional uses the code in RatParseMandatory to parse the extension
 * data, in case an extension that should be optional comes in as mandatory.
 * We then detect RatParseMandatory rejecting the thing as unrecognized and
 * allow it through, since here it's optional.
 */
HRESULT RatParseOptional(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser)
{
    HRESULT hres = RatParseMandatory(ppszIn, ppOut, pParser);
    if (hres == RAT_E_UNKNOWNMANDATORY)
        hres = S_OK;

    return hres;
}


/***************************************************************************
    Code to identify the opening keyword of a parenthesized object and
    associate it with content.
***************************************************************************/

/* The following array is indexed by RatObjectID values. */
struct {
    LPCSTR pszToken;            /* token by which we identify it */
    RatObjectHandler pHandler;  /* function which parses the object's contents */
} aObjectDescriptions[] = {
    { szNULL, NULL },
    { NULL, NULL },             /* placeholder for comparing against no token */
    { szPicsVersion, RatParsePseudoFloat },
    { szRatingSystem, RatParseString },
    { szRatingService, RatParseString },
    { szRatingBureau, RatParseString },
    { szBureauRequired, RatParseBool },
    { szCategory, RatParseCategory },
    { szTransmitAs, RatParseString },
    { szLabel, RatParseLabel },
    { szValue, RatParseNumber },
    { szDefault, RatParseDefault },
    { szDescription, RatParseString },
    { szExtensionOption, RatParseExtension },
    { szMandatory, RatParseMandatory },
    { szOptional, RatParseOptional },
    { szIcon, RatParseString },
    { szInteger, RatParseBool },
    { szLabelOnly, RatParseBool },
    { szMax, RatParseNumber },
    { szMin, RatParseNumber },
    { szMultiValue, RatParseBool },
    { szName, RatParseString },
    { szUnordered, RatParseBool }
};


/* ParseToOpening eats the opening '(' of a parenthesized object, and
 * verifies that the token just inside it is one of the expected ones.
 * If so, *ppIn is advanced past that token to the next non-whitespace
 * character;  otherwise, an error is returned.
 *
 * For example, if *ppIn is pointing at "(PICS-version 1.1)", and
 * ROID_PICSVERSION is in the allowable option table supplied, then
 * NOERROR is returned and *ppIn will point at "1.1)".
 *
 * If the function is successful, *ppFound is set to point to the element
 * in the allowable-options table which matches the type of thing this
 * object actually is.
 */
HRESULT RatFileParser::ParseToOpening(LPSTR *ppIn, AllowableOption *paoExpected,
                                      AllowableOption **ppFound)
{
    LPSTR pszCurrent = *ppIn;

    pszCurrent = FindNonWhite(pszCurrent);
    if (*pszCurrent != '(')
        return RAT_E_EXPECTEDLEFT;

    pszCurrent = FindNonWhite(pszCurrent+1);    /* skip '(' and whitespace */
    LPSTR pszTokenEnd = FindTokenEnd(pszCurrent);

    for (; paoExpected->roid != ROID_INVALID; paoExpected++) {
        LPCSTR pszThisToken = aObjectDescriptions[paoExpected->roid].pszToken;

        /* Special case for beginning of RAT file structure: no token at all. */
        if (pszThisToken == NULL) {
            if (*pszCurrent == '(') {
                *ppIn = pszCurrent;
                *ppFound = paoExpected;
                return NOERROR;
            }
            else {
                return RAT_E_EXPECTEDLEFT;
            }
        }
        else if (IsEqualToken(pszCurrent, pszTokenEnd, pszThisToken))
            break;

    }

    if (paoExpected->roid != ROID_INVALID) {
        *ppIn = FindNonWhite(pszTokenEnd);  /* skip token and whitespace */
        *ppFound = paoExpected;
        return NOERROR;
    }
    else
        return RAT_E_UNKNOWNITEM;
}


/***************************************************************************
    The top-level entrypoint for parsing out a whole rating system.
***************************************************************************/

AllowableOption aaoPicsRatingSystem[] = {
    { ROID_PICSVERSION, AO_SINGLE | AO_MANDATORY },
    { ROID_RATINGSYSTEM, AO_SINGLE | AO_MANDATORY },
    { ROID_RATINGSERVICE, AO_SINGLE | AO_MANDATORY },
    { ROID_RATINGBUREAU, AO_SINGLE },
    { ROID_BUREAUREQUIRED, AO_SINGLE },
    { ROID_DEFAULT, 0 },
    { ROID_DESCRIPTION, AO_SINGLE },
    { ROID_EXTENSION, 0 },
    { ROID_ICON, AO_SINGLE },
    { ROID_NAME, AO_SINGLE },
    { ROID_CATEGORY, AO_MANDATORY },
    { ROID_INVALID, 0 }
};
const UINT caoPicsRatingSystem = sizeof(aaoPicsRatingSystem) / sizeof(aaoPicsRatingSystem[0]);

HRESULT PicsRatingSystem::Parse(LPSTR pIn)
{
    /* This guy is small enough to just init directly on the stack */
    AllowableOption aaoRoot[] = { { ROID_PICSDOCUMENT, 0 }, { ROID_INVALID, 0 } };
    AllowableOption aao[caoPicsRatingSystem];

    ::memcpyf(aao, ::aaoPicsRatingSystem, sizeof(aao));

    AllowableOption *pFound;

    RatFileParser parser;

    HRESULT hres = parser.ParseToOpening(&pIn, aaoRoot, &pFound);
    if (FAILED(hres))
        return hres;                        /* some error early on */

    hres = parser.ParseParenthesizedObject(
                        &pIn,                   /* var containing current ptr */
                        aao,                    /* what's legal in this object */
                        this);                  /* object to add items back to */

    if (FAILED(hres))
        nErrLine = parser.m_nLine;

    return hres;
}


/***************************************************************************
    Callbacks into the various class objects to add parsed properties.
***************************************************************************/

HRESULT PicsRatingSystem::AddItem(RatObjectID roid, LPVOID pData)
{
    HRESULT hres = S_OK;

    switch (roid) {
    case ROID_PICSVERSION:
        etnPicsVersion.Set((INT_PTR)pData);
        break;

    case ROID_RATINGSYSTEM:
        etstrRatingSystem.SetTo((LPSTR)pData);
        break;

    case ROID_RATINGSERVICE:
        etstrRatingService.SetTo((LPSTR)pData);
        break;

    case ROID_RATINGBUREAU:
        etstrRatingBureau.SetTo((LPSTR)pData);
        break;

    case ROID_BUREAUREQUIRED:
        etbBureauRequired.Set((INT_PTR)pData);
        break;

    case ROID_DEFAULT:
        m_pDefaultOptions = (PicsDefault *)pData;
        break;

    case ROID_DESCRIPTION:
        etstrDesc.SetTo((LPSTR)pData);
        break;

    case ROID_EXTENSION:
        {
            /* just eat extensions for now */
            PicsExtension *pExtension = (PicsExtension *)pData;
            if (pExtension != NULL) {
                /* If this is a rating bureau extension, take his bureau
                 * string and store it in this PicsRatingSystem.  We now
                 * own the memory, so NULL out the extension's pointer to
                 * it so he won't delete it.
                 */
                if (pExtension->m_pszRatingBureau != NULL) {
                    etstrRatingBureau.SetTo(pExtension->m_pszRatingBureau);
                    pExtension->m_pszRatingBureau = NULL;
                }
                delete pExtension;
            }
        }
        break;

    case ROID_ICON:
        etstrIcon.SetTo((LPSTR)pData);
        break;

    case ROID_NAME:
        etstrName.SetTo((LPSTR)pData);
        break;

    case ROID_CATEGORY:
        {
            PicsCategory *pCategory = (PicsCategory *)pData;
            hres = arrpPC.Append(pCategory) ? S_OK : E_OUTOFMEMORY;
            if (FAILED(hres)) {
                delete pCategory;
            }
            else {
                InitializeMyDefaults(pCategory);    /* category inherits default settings */
                pCategory->SetParents(this);    /* set pPRS fields in whole tree */
            }
        }
        break;

    default:
        assert(FALSE);  /* shouldn't have been given a ROID that wasn't in
                         * the table we passed to the parser! */
        hres = E_UNEXPECTED;
        break;
    }

    return hres;
}

void PicsRatingSystem::Dump( void )
{
    fprintf( stdout,
             "Rating system: %s\n"
             "Version: %d.%d\n"
             "Rating Service: %s\n"
             "Rating bureau: %s\n"
             "Bureau required: %s\n"
             "Description: %s\n"
             "Icon: %s\n"
             "Name: %s\n"
             "Number of categories: %d\n",
             etstrRatingSystem.Get(),
             ( etnPicsVersion.Get() & 0xFFFF0000 ) >> 16,
             etnPicsVersion.Get() & 0x0000FFFF,
             etstrRatingService.Get(),
             etstrRatingBureau.Get(),
             etbBureauRequired.Get() ? "TRUE" : "FALSE",
             etstrDesc.Get(),
             etstrIcon.Get(),
             etstrName.Get(),
             arrpPC.Length() );

    int iCounter = 0;
    for( ; iCounter < arrpPC.Length(); iCounter++ )
    {
        arrpPC[ iCounter ]->Dump();
    }
}

//---------------------------------------------------------------
// boydm
void PicsRatingSystem::OutputLabels( CString &sz, CString szURL, CString szName, CString szStart, CString szEnd )
    {
    CString szScratch;
    CString szTemp;

    INT_PTR   dwVersion = etnPicsVersion.Get();

    // start with the name, and the version number
    szTemp = szPicsOpening;
    szScratch.Format( _T("%s%d.%d"), szTemp, HIWORD(dwVersion), LOWORD(dwVersion) );
    sz += szScratch;

    // add in the URL string - surrounded by quotes and a return
    sz += _T(" \"http://www.rsac.org/ratingsv01.html\" ");

    // start the labels
    sz += szShortLabelWord;
    sz += _T(" ");

    // if it is there, add the by name string
    if ( !szName.IsEmpty() )
        {
        sz += szByOption;
        sz += _T(" \"");
        sz += szName;
        sz += _T("\" ");
        }

    // if it is there, add the start string
    if ( !szStart.IsEmpty() )
        {
        sz += szOnOption;
        sz += _T(" \"");
        sz += szStart;
        sz += _T("\" ");
        }

    // if it is there, add the expiration string
    if ( !szEnd.IsEmpty() )
        {
        sz += szExpOption;
        sz += _T(" \"");
        sz += szEnd;
        sz += _T("\" ");
        }

    // add in the categorical ratings
    DWORD   nCat = arrpPC.Length();
    sz += szShortRatings;
    sz += _T(" (");
    for ( DWORD iCat = 0; iCat < nCat; iCat++ )
        {
        arrpPC[iCat]->OutputLabel( sz );
        }
    // trim any trailing whitespace
    sz.TrimRight();
    // close with a parenthesis
    sz += _T(')');

    // end with the closing parenthesis
    sz += _T(")");
    }



//---------------------------------------------------------------
HRESULT PicsCategory::AddItem(RatObjectID roid, LPVOID pData)
{
    HRESULT hres = S_OK;

    switch (roid) {
    case ROID_TRANSMITAS:
        etstrTransmitAs.SetTo((LPSTR)pData);
        break;

    case ROID_NAME:
        etstrName.SetTo((LPSTR)pData);
        break;

    case ROID_DESCRIPTION:
        etstrDesc.SetTo((LPSTR)pData);
        break;

    case ROID_ICON:
        etstrIcon.SetTo((LPSTR)pData);
        break;

    case ROID_EXTENSION:
        {           /* we support no extensions below the rating system level */
            PicsExtension *pExtension = (PicsExtension *)pData;
            if (pExtension != NULL)
                delete pExtension;
        }
        break;

    case ROID_INTEGER:
        etfInteger.Set((INT_PTR)pData);
        break;

    case ROID_LABELONLY:
        etfLabelled.Set((INT_PTR)pData);
        break;

    case ROID_MULTIVALUE:
        etfMulti.Set((INT_PTR)pData);
        break;

    case ROID_UNORDERED:
        etfUnordered.Set((INT_PTR)pData);
        break;

    case ROID_MIN:
        etnMin.Set((INT_PTR)pData);
        break;

    case ROID_MAX:
        etnMax.Set((INT_PTR)pData);
        break;

    case ROID_LABEL:
        {
            PicsEnum *pEnum = (PicsEnum *)pData;
            hres = arrpPE.Append(pEnum) ? S_OK : E_OUTOFMEMORY;
            if (FAILED(hres))
                delete pEnum;
        }
        break;

    case ROID_CATEGORY:
        {
            PicsCategory *pCategory = (PicsCategory *)pData;

            /* For a nested category, synthesize the transmit-name from
             * ours and the child's (e.g., parent category 'color' plus
             * child category 'hue' becomes 'color/hue'.
             *
             * Note that the memory we allocate for the new name will be
             * owned by pCategory->etstrTransmitAs.  There is no memory
             * leak there.
             */
            UINT cbCombined = strlenf(etstrTransmitAs.Get()) +
                              strlenf(pCategory->etstrTransmitAs.Get()) +
                              2;        /* for PicsDelimChar + null */
            LPSTR pszTemp = new char[cbCombined];
            if (pszTemp == NULL)
                hres = E_OUTOFMEMORY;
            else {
                sprintf(pszTemp, "%s%c%s", etstrTransmitAs.Get(),
                         PicsDelimChar, pCategory->etstrTransmitAs.Get());
                pCategory->etstrTransmitAs.SetTo(pszTemp);
                hres = arrpPC.Append(pCategory) ? S_OK : E_OUTOFMEMORY;
            }

            if (FAILED(hres)) {
                delete pCategory;
            }
        }
        break;

    default:
        assert(FALSE);  /* shouldn't have been given a ROID that wasn't in
                         * the table we passed to the parser! */
        hres = E_UNEXPECTED;
        break;
    }

    return hres;
}

void PicsCategory::Dump( void )
{
    fprintf( stdout,
             "  Transmit As: %s  Name: %s  Description: %s  Icon: %s\n",
             etstrTransmitAs.Get(),
             etstrName.Get(),
             etstrDesc.Get(),
             etstrIcon.Get() );

    int iCounter = 0;
    for( ; iCounter < arrpPE.Length(); iCounter++ )
    {
        arrpPE[ iCounter ]->Dump();
    }
}

//---------------------------------------------------------------
void PicsCategory::OutputLabel( CString &sz )
    {
    CString szCat;
    CString szTransmit = etstrTransmitAs.Get();
    // prepare the category string
    szCat.Format( _T("%s %d "), szTransmit, currentValue );
    sz += szCat;
    }

//---------------------------------------------------------------
BOOL PicsCategory::FSetValuePair( CHAR chCat, WORD value )
    {
    CString szCat = etstrTransmitAs.Get();

    // first check to see if this is the right category
    if ( szCat == chCat )
        {
        // success! set the value and return
        currentValue = value;
        return TRUE;
        }

    // try its categorical children
    DWORD nCat = arrpPC.Length();
    for ( DWORD iCat = 0; iCat < nCat; iCat++ )
        {
        // stop at the first successful setting
        if ( arrpPC[iCat]->FSetValuePair(chCat, value) )
            return TRUE;
        }

    // nope
    return FALSE;
    }

//---------------------------------------------------------------
HRESULT PicsEnum::AddItem(RatObjectID roid, LPVOID pData)
{
    HRESULT hres = S_OK;

    switch (roid) {
    case ROID_NAME:
        etstrName.SetTo((LPSTR)pData);
        break;

    case ROID_DESCRIPTION:
        etstrDesc.SetTo((LPSTR)pData);
        break;

    case ROID_ICON:
        etstrIcon.SetTo((LPSTR)pData);
        break;

    case ROID_VALUE:
        etnValue.Set((INT_PTR)pData);
        break;

    default:
        assert(FALSE);  /* shouldn't have been given a ROID that wasn't in
                         * the table we passed to the parser! */
        hres = E_UNEXPECTED;
        break;
    }

    return hres;
}

void PicsEnum::Dump( void )
{
    fprintf( stdout,
             "    %s %s %s %d\n",
             etstrName.Get(),
             etstrDesc.Get(),
             etstrIcon.Get(),
             etnValue.Get() );
}

HRESULT PicsDefault::AddItem(RatObjectID roid, LPVOID pData)
{
    HRESULT hres = S_OK;

    switch (roid) {
    case ROID_EXTENSION:
        {           /* we support no extensions below the rating system level */
            PicsExtension *pExtension = (PicsExtension *)pData;
            if (pExtension != NULL)
                delete pExtension;
        }
        break;

    case ROID_INTEGER:
        etfInteger.Set((INT_PTR)pData);
        break;

    case ROID_LABELONLY:
        etfLabelled.Set((INT_PTR)pData);
        break;

    case ROID_MULTIVALUE:
        etfMulti.Set((INT_PTR)pData);
        break;

    case ROID_UNORDERED:
        etfUnordered.Set((INT_PTR)pData);
        break;

    case ROID_MIN:
        etnMin.Set((INT_PTR)pData);
        break;

    case ROID_MAX:
        etnMax.Set((INT_PTR)pData);
        break;

    default:
        assert(FALSE);  /* shouldn't have been given a ROID that wasn't in
                         * the table we passed to the parser! */
        hres = E_UNEXPECTED;
        break;
    }

    return hres;
}

void PicsDefault::Dump( void )
{
    fprintf( stdout,
             "  Default?\n" );
}

HRESULT PicsExtension::AddItem(RatObjectID roid, LPVOID pData)
{
    HRESULT hres = S_OK;

    switch (roid) {
    case ROID_OPTIONAL:
    case ROID_MANDATORY:
        /* Only data we should get is a label bureau string. */
        if (pData != NULL)
            m_pszRatingBureau = (LPSTR)pData;
        break;

    default:
        assert(FALSE);  /* shouldn't have been given a ROID that wasn't in
                         * the table we passed to the parser! */
        hres = E_UNEXPECTED;
        break;
    }

    return hres;
}

void PicsExtension::Dump( void )
{
    fprintf( stdout,
             "  Extension?\n" );
}

/***************************************************************************
    The main loop of the parser.
***************************************************************************/

/* ParseParenthesizedObjectContents is called with a text pointer pointing at
 * the first non-whitespace thing following the token identifying the type of
 * object.  It parses the rest of the contents of the object, up to and
 * including the ')' which closes it.  The array of AllowableOption structures
 * specifies which understood options are allowed to occur within this object.
 */
HRESULT RatFileParser::ParseParenthesizedObject(
    LPSTR *ppIn,                    /* where we are in the text stream */
    AllowableOption aao[],          /* allowable things inside this object */
    PicsObjectBase *pObject         /* object to set parameters into */
)
{
    HRESULT hres = S_OK;

    LPSTR pszCurrent = *ppIn;
    AllowableOption *pFound;

    for (pFound = aao; pFound->roid != ROID_INVALID; pFound++) {
        pFound->fdwOptions &= ~AO_SEEN;
    }

    pFound = NULL;

    while (*pszCurrent != ')' && *pszCurrent != '\0' && SUCCEEDED(hres)) {
        hres = ParseToOpening(&pszCurrent, aao, &pFound);
        if (SUCCEEDED(hres)) {
            LPVOID pData;
            hres = (*(aObjectDescriptions[pFound->roid].pHandler))(&pszCurrent, &pData, this);
            if (SUCCEEDED(hres)) {
                if ((pFound->fdwOptions & (AO_SINGLE | AO_SEEN)) == (AO_SINGLE | AO_SEEN))
                    hres = RAT_E_DUPLICATEITEM;
                else {
                    pFound->fdwOptions |= AO_SEEN;
                    hres = pObject->AddItem(pFound->roid, pData);
                    if (SUCCEEDED(hres)) {
                        if (*pszCurrent != ')')
                            hres = RAT_E_EXPECTEDRIGHT;
                        else
                            pszCurrent = FindNonWhite(pszCurrent+1);
                    }
                }
            }
        }
    }

    if (FAILED(hres))
        return hres;

    for (pFound = aao; pFound->roid != ROID_INVALID; pFound++) {
        if ((pFound->fdwOptions & (AO_MANDATORY | AO_SEEN)) == AO_MANDATORY)
            return RAT_E_MISSINGITEM;       /* mandatory item not found */
    }

    *ppIn = pszCurrent;

    return hres;
}


/*
int __cdecl main(int argc, char **argv)
{
    PicsRatingSystem            Rating;
    HANDLE                      hFile;
    HANDLE                      hFileMapping;
    VOID *                      pMem;

    assert( argc > 1 );

    hFile = CreateFile( argv[ 1 ],
                        GENERIC_READ,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );

    if ( hFile == INVALID_HANDLE_VALUE )
    {
        fprintf( stderr, "Error opening file %s\n", argv[ 1 ] );
        return 1;
    }

    hFileMapping = CreateFileMapping( hFile,
                                      NULL,
                                      PAGE_READONLY,
                                      0,
                                      0,
                                      NULL );

    if ( hFileMapping == NULL )
    {
        fprintf( stderr, "Error creating mapping for %s\n", argv[ 1 ] );
        CloseHandle( hFile );
        return 2;
    }

    pMem = MapViewOfFile( hFileMapping,
                          FILE_MAP_READ,
                          0,
                          0,
                          0 );

    if ( pMem == NULL )
    {
        fprintf( stderr, "Error mapping view to file %s\n", argv [1 ] );
        CloseHandle( hFileMapping );
        CloseHandle( hFile );
        return 3;
    }

    Rating.Parse( argv[ 1 ], (LPSTR) pMem );

    fprintf( stdout,
             "Dumping contents of RAT\n" );

    Rating.Dump();

    UnmapViewOfFile( pMem );
    CloseHandle( hFileMapping );
    CloseHandle( hFile );

    return 0;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\cnfgprts\ratadvpg.h ===
// RatAdvPg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CRatAdvancedPage dialog

class CRatAdvancedPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CRatAdvancedPage)

// Construction
public:
	CRatAdvancedPage();
	~CRatAdvancedPage();

    // the data
    CRatingsData*   m_pRatData;

// Dialog Data
	//{{AFX_DATA(CRatAdvancedPage)
	enum { IDD = IDD_RAT_ADVANCED };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRatAdvancedPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CRatAdvancedPage)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
    void DoHelp();
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\cnfgprts\ratctl.cpp ===
// RatCtl.cpp : Implementation of the CRatCtrl OLE control class.

#include "stdafx.h"
#include "cnfgprts.h"
#include "RatCtl.h"
#include "RatPpg.h"
#include "parserat.h"
#include "RatData.h"
#include "RatGenPg.h"
#include "RatSrvPg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CRatCtrl, COleControl)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CRatCtrl, COleControl)
    //{{AFX_MSG_MAP(CRatCtrl)
    //}}AFX_MSG_MAP
    ON_MESSAGE(OCM_COMMAND, OnOcmCommand)
    ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CRatCtrl, COleControl)
    //{{AFX_DISPATCH_MAP(CRatCtrl)
    DISP_FUNCTION(CRatCtrl, "SetAdminTarget", SetAdminTarget, VT_EMPTY, VTS_BSTR VTS_BSTR)
    DISP_FUNCTION(CRatCtrl, "SetUserData", SetUserData, VT_EMPTY, VTS_BSTR VTS_BSTR)
    DISP_FUNCTION(CRatCtrl, "SetUrl", SetUrl, VT_EMPTY, VTS_BSTR)
    DISP_STOCKFUNC_DOCLICK()
    DISP_STOCKPROP_BORDERSTYLE()
    DISP_STOCKPROP_ENABLED()
    DISP_STOCKPROP_FONT()
    DISP_STOCKPROP_CAPTION()
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CRatCtrl, COleControl)
    //{{AFX_EVENT_MAP(CRatCtrl)
    EVENT_STOCK_CLICK()
    EVENT_STOCK_KEYUP()
    //}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

BEGIN_PROPPAGEIDS(CRatCtrl, 2)
    PROPPAGEID(CRatPropPage::guid)
    PROPPAGEID(CLSID_CFontPropPage)
END_PROPPAGEIDS(CRatCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CRatCtrl, "CNFGPRTS.RatCtrl.1",
    0xba634607, 0xb771, 0x11d0, 0x92, 0x96, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CRatCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DRat =
        { 0xba634605, 0xb771, 0x11d0, { 0x92, 0x96, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b } };
//const IID BASED_CODE IID_DRat2 =
//        { 0x9352B26C, 0x7907, 0x4c8e, { 0xa1, 0x64, 0x14, 0xe3, 0x42, 0x53, 0x2f, 0x8b } };
const IID BASED_CODE IID_DRatEvents =
        { 0xba634606, 0xb771, 0x11d0, { 0x92, 0x96, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwRatOleMisc =
    OLEMISC_ACTIVATEWHENVISIBLE |
    OLEMISC_SETCLIENTSITEFIRST |
    OLEMISC_INSIDEOUT |
    OLEMISC_CANTLINKINSIDE |
    OLEMISC_ACTSLIKEBUTTON |
    OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CRatCtrl, IDS_RAT, _dwRatOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CRatCtrl::CRatCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CRatCtrl

BOOL CRatCtrl::CRatCtrlFactory::UpdateRegistry(BOOL bRegister)
{
    // TODO: Verify that your control follows apartment-model threading rules.
    // Refer to MFC TechNote 64 for more information.
    // If your control does not conform to the apartment-model rules, then
    // you must modify the code below, changing the 6th parameter from
    // afxRegApartmentThreading to 0.

    if (bRegister)
        return AfxOleRegisterControlClass(
            AfxGetInstanceHandle(),
            m_clsid,
            m_lpszProgID,
            IDS_RAT,
            IDB_RAT,
            afxRegApartmentThreading,
            _dwRatOleMisc,
            _tlid,
            _wVerMajor,
            _wVerMinor);
    else
        return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}

/////////////////////////////////////////////////////////////////////////////
// CRatCtrl::CRatCtrl - Constructor

CRatCtrl::CRatCtrl():
    m_fUpdateFont( FALSE ),
    m_hAccel( NULL ),
    m_cAccel( 0 )
{
    InitializeIIDs(&IID_DRat, &IID_DRatEvents);
}

/////////////////////////////////////////////////////////////////////////////
// CRatCtrl::~CRatCtrl - Destructor

CRatCtrl::~CRatCtrl()
{
    if ( m_hAccel )
        DestroyAcceleratorTable( m_hAccel );
    m_hAccel = NULL;
}

/////////////////////////////////////////////////////////////////////////////
// CRatCtrl::OnDraw - Drawing function

void CRatCtrl::OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
{
    DoSuperclassPaint(pdc, rcBounds);
}

/////////////////////////////////////////////////////////////////////////////
// CRatCtrl::DoPropExchange - Persistence support

void CRatCtrl::DoPropExchange(CPropExchange* pPX)
{
    ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
    COleControl::DoPropExchange(pPX);
}

/////////////////////////////////////////////////////////////////////////////
// CRatCtrl::OnResetState - Reset control to default state

void CRatCtrl::OnResetState()
{
    COleControl::OnResetState();  // Resets defaults found in DoPropExchange
}

/////////////////////////////////////////////////////////////////////////////
// CRatCtrl::PreCreateWindow - Modify parameters for CreateWindowEx

BOOL CRatCtrl::PreCreateWindow(CREATESTRUCT& cs)
{
    if ( cs.style & WS_CLIPSIBLINGS )
        cs.style ^= WS_CLIPSIBLINGS;
    cs.lpszClass = _T("BUTTON");
    return COleControl::PreCreateWindow(cs);
}


/////////////////////////////////////////////////////////////////////////////
// CRatCtrl::IsSubclassedControl - This is a subclassed control

BOOL CRatCtrl::IsSubclassedControl()
{
    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CRatCtrl::OnOcmCommand - Handle command messages

LRESULT CRatCtrl::OnOcmCommand(WPARAM wParam, LPARAM lParam)
{
#ifdef _WIN32
    WORD wNotifyCode = HIWORD(wParam);
#else
    WORD wNotifyCode = HIWORD(lParam);
#endif

    return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CRatCtrl message handlers

//---------------------------------------------------------------------------
void CRatCtrl::OnClick(USHORT iButton)
{
	CString sz;
	sz.LoadString( IDS_RAT_ERR_TITLE );
	AfxGetApp()->m_pszAppName = _tcsdup(sz);

	CWaitCursor wait;

	// if there is no set metabase path - give it a test path
	if ( m_szMetaObject.IsEmpty() )
		m_szMetaObject = _T("/lm/w3svc/1/Root");

	// we have to be able to initialize the ratings data object
	CRatingsData dataRatings;
    dataRatings.SetServer(m_szMachine, m_szMetaObject);
    CString csTempPassword;
    m_szUserPassword.CopyTo(csTempPassword);
    dataRatings.SetUser(m_szUserName, csTempPassword);
	dataRatings.SetURL(m_szURL);
	if (!dataRatings.Init())
	{
		AfxMessageBox( IDS_RAT_READFILE_ERROR );
		return;
	}

	CRatServicePage pageService;
	CRatGenPage pageSetRatings;

	CPropertySheet propsheet( IDS_RAT_SHEETTITLE );

	pageService.m_pRatData = &dataRatings;
	pageSetRatings.m_pRatData = &dataRatings;

    // BUG:684590
	//propsheet.AddPage( &pageService );
	propsheet.AddPage( &pageSetRatings );

	propsheet.m_psh.dwFlags |= PSH_HASHELP;
	pageService.m_psp.dwFlags |= PSP_HASHELP;
	pageSetRatings.m_psp.dwFlags |= PSP_HASHELP;

	try
	{
		PreModalDialog();
		if ( propsheet.DoModal() == IDOK )
		{
			dataRatings.SaveTheLabel();
		}
		// let the host container know we are done with the modality
		PostModalDialog();
	}
	catch ( CException* pException )
	{
		pException->Delete();
	}
	COleControl::OnClick(iButton);
}

//---------------------------------------------------------------------------
void CRatCtrl::OnFontChanged()
{
    m_fUpdateFont = TRUE;
    COleControl::OnFontChanged();
}

//---------------------------------------------------------------------------
void CRatCtrl::SetAdminTarget(LPCTSTR szMachineName, LPCTSTR szMetaTarget)
{
    m_szMachine = szMachineName;
    m_szMetaObject = szMetaTarget;
}

void CRatCtrl::SetUserData(LPCTSTR szUserName, LPCTSTR szUserPassword)
{
    m_szUserName = szUserName;
    m_szUserPassword = szUserPassword;
}

void CRatCtrl::SetUrl(LPCTSTR szURL)
{
    m_szURL = szURL;
}
//---------------------------------------------------------------------------
// an important method where we tell the container how to deal with us.
// pControlInfo is passed in by the container, although we are responsible
// for maintining the hAccel structure
void CRatCtrl::OnGetControlInfo(LPCONTROLINFO pControlInfo)
{
    // do a rudimentary check to see if we understand pControlInfo
    if ( !pControlInfo || pControlInfo->cb < sizeof(CONTROLINFO) )
        return;

    // set the accelerator handle into place
    pControlInfo->hAccel = m_hAccel;
    pControlInfo->cAccel = m_cAccel;

    // when we have focus, we do want the enter key
    pControlInfo->dwFlags = CTRLINFO_EATS_RETURN;
}

//---------------------------------------------------------------------------
// when the caption text has changed, we need to rebuild the accelerator handle
void CRatCtrl::OnTextChanged()
{
	ACCEL   accel;
	int     iAccel;

	// get the new text
	CString sz = InternalGetText();
	sz.MakeLower();

	// if the handle has already been allocated, free it
	if ( m_hAccel )
	{
		DestroyAcceleratorTable( m_hAccel );
		m_hAccel = NULL;
		m_cAccel = 0;
	}

	// if there is a & character, then declare the accelerator
	iAccel = sz.Find(_T('&'));
	if ( iAccel >= 0 )
	{
		// fill in the accererator record
		accel.fVirt = FALT;
		accel.key = sz.GetAt(iAccel + 1);
		accel.cmd = (USHORT)GetDlgCtrlID();

		m_hAccel = CreateAcceleratorTable( &accel, 1 );
		if ( m_hAccel )
			m_cAccel = 1;

		// make sure the new accelerator table gets loaded
		ControlInfoChanged();
	}

	// finish with the default handling.
	COleControl::OnTextChanged();
}

//---------------------------------------------------------------------------
void CRatCtrl::OnMnemonic(LPMSG pMsg)
{
    OnClick((USHORT)GetDlgCtrlID());
	COleControl::OnMnemonic(pMsg);
}

//---------------------------------------------------------------------------
void CRatCtrl::OnAmbientPropertyChange(DISPID dispid)
{
    BOOL    flag;
	UINT    style;

	// do the right thing depending on the dispid
	switch ( dispid )
	{
	case DISPID_AMBIENT_DISPLAYASDEFAULT:
		if ( GetAmbientProperty( DISPID_AMBIENT_DISPLAYASDEFAULT, VT_BOOL, &flag ) )
		{
			style = GetWindowLong(GetSafeHwnd(), GWL_STYLE);
			if ( flag )
				style |= BS_DEFPUSHBUTTON;
			else
				style ^= BS_DEFPUSHBUTTON;
			SetWindowLong(GetSafeHwnd(), GWL_STYLE, style);
			Invalidate(TRUE);
		}
		break;
	};

	COleControl::OnAmbientPropertyChange(dispid);
}

//---------------------------------------------------------------------------
// the ole control container object specifically filters out the space
// key so we do not get it as a OnMnemonic call. Thus we need to look
// for it ourselves
void CRatCtrl::OnKeyUpEvent(USHORT nChar, USHORT nShiftState)
{
    if ( nChar == _T(' ') )
	{
		OnClick((USHORT)GetDlgCtrlID());
	}
	COleControl::OnKeyUpEvent(nChar, nShiftState);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\cnfgprts\ratexprd.h ===
// RatExprD.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CRatExpireDlg dialog
//{{AFX_INCLUDES()
#include "msacal70.h"
//}}AFX_INCLUDES

class CRatExpireDlg : public CDialog
{
// Construction
public:
	CRatExpireDlg(CWnd* pParent = NULL);   // standard constructor
virtual  BOOL OnInitDialog( );

    WORD    m_day;
    WORD    m_month;
    WORD    m_year;

// Dialog Data
	//{{AFX_DATA(CRatExpireDlg)
	enum { IDD = IDD_RAT_EXPIRE };
	CMsacal70	m_calendar;
	//}}AFX_DATA


// Overrides

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRatExpireDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

    BOOL IsSystemDBCS( void );

	// Generated message map functions
	//{{AFX_MSG(CRatExpireDlg)
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\cnfgprts\ratdata.h ===
/*++

   Copyright    (c)    1997-2001    Microsoft Corporation

   Module  Name :
        ratdata.h

   Abstract:
        Ratings data class

   Author:
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:
--*/

class CRatingsData : public CObject
{
public:
    CRatingsData();
    ~CRatingsData();

    // other data for/from the metabase
    BOOL m_fEnabled;
    CString m_szEmail;

    // start date
    WORD    m_start_minute;
    WORD    m_start_hour;
    WORD    m_start_day;
    WORD    m_start_month;
    WORD    m_start_year;

    // expire date
    WORD    m_expire_minute;
    WORD    m_expire_hour;
    WORD    m_expire_day;
    WORD    m_expire_month;
    WORD    m_expire_year;

    void SaveTheLabel();
    void SetUser(LPCTSTR name, LPCTSTR password)
    {
        m_username = name;
        m_password = password;
    }
    void SetServer(LPCTSTR name, LPCTSTR metapath)
    {
        m_szServer = name;
        m_szMeta = metapath;
    }
    void SetURL(LPCTSTR url)
    {
        m_szURL = url;
    }
    BOOL Init();

    DWORD   iRat;
    CTypedPtrArray<CObArray, PicsRatingSystem*> rgbRats;

protected:
    BOOL    LoadRatingsFile(CString szFilePath);
    void    LoadMetabaseValues();
    void    ParseMetaRating(CString szRating);
    void    ParseMetaPair( TCHAR chCat, TCHAR chVal );
    BOOL    ParseRatingsFile(LPSTR pData);
    void    CreateDateSz( CString &sz, WORD day, WORD month, WORD year, WORD hour, WORD minute );
    void    ReadDateSz( CString sz, WORD* pDay, WORD* pMonth, WORD* pYear, WORD* pHour, WORD* pMinute );

    CString m_szMeta;
    CString m_szServer;
    CString m_szMetaPartial;
    CString m_username;
    CStrPassword m_password;
	CString m_szURL;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\cnfgprts\ratexprd.cpp ===
// RatExprD.cpp : implementation file
//

#include "stdafx.h"
#include "cnfgprts.h"
#include "RatExprD.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRatExpireDlg dialog


//--------------------------------------------------------------------------
CRatExpireDlg::CRatExpireDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CRatExpireDlg::IDD, pParent),
        m_day( 0 ),
        m_month( 0 ),
        m_year( 0 )
    {
    //{{AFX_DATA_INIT(CRatExpireDlg)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    }

//--------------------------------------------------------------------------
void CRatExpireDlg::DoDataExchange(CDataExchange* pDX)
    {
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CRatExpireDlg)
    DDX_Control(pDX, IDC_MSACALCTRL, m_calendar);
    //}}AFX_DATA_MAP
    }


//--------------------------------------------------------------------------
BEGIN_MESSAGE_MAP(CRatExpireDlg, CDialog)
    //{{AFX_MSG_MAP(CRatExpireDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRatExpireDlg message handlers


//--------------------------------------------------------------------------
BOOL CRatExpireDlg::IsSystemDBCS( void )
    {
    WORD wPrimaryLangID = PRIMARYLANGID( GetSystemDefaultLangID() );

    return ( wPrimaryLangID == LANG_JAPANESE ||
        wPrimaryLangID == LANG_CHINESE ||
        wPrimaryLangID == LANG_KOREAN );
    } 

//--------------------------------------------------------------------------
BOOL CRatExpireDlg::OnInitDialog( )
    {
    SYSTEMTIME  time;

    // get the base class going
    BOOL f = CDialog::OnInitDialog();

    // set up the calendar in DBCS mode as appropriate - suggested by the japanese guys
    if ( IsSystemDBCS() )
        {
        m_calendar.SetDayLength( 0 );    // 0: localized one
        m_calendar.SetMonthLength( 0 );  // 0: localized one
        m_calendar.SetDayFont( NULL );   // use default
        m_calendar.SetGridFont( NULL );  // use default
        m_calendar.SetTitleFont( NULL ); // use default
        }

    //
    // Background colour looks weird if the dialog
    // is not gray
    //
    m_calendar.SetBackColor(GetSysColor(COLOR_BTNFACE));

    // now tell the calendar to focus on one year from today, or the supplied date
    // if there is one
    if ( m_year )
        {
 	    m_calendar.SetYear( m_year );
	    m_calendar.SetMonth( m_month );
	    m_calendar.SetDay( m_day );
       }
    else
        {
        // the default case - use one year from today
        GetLocalTime( &time );
 	    m_calendar.SetYear( time.wYear + 1 );
	    m_calendar.SetMonth( time.wMonth );
	    m_calendar.SetDay( time.wDay );
        }

    // return the answer
    return f;
    }

//--------------------------------------------------------------------------
void CRatExpireDlg::OnOK() 
    {
    // get the date
    m_day = m_calendar.GetDay();
    m_month = m_calendar.GetMonth();
    m_year = m_calendar.GetYear();

    // test if nothing is selected - check if the year is 0
    if ( m_year == 0 )
        {
        AfxMessageBox(IDS_NO_DATE_SELECTED);
        return;
        }

    // put it into a CTime so we can compare
    CTime  timeCal(m_year,m_month,m_day,12,0,0);

    // compare
    if ( timeCal < CTime::GetCurrentTime() )
        {
        if ( AfxMessageBox(IDS_EXPIRE_SET_PAST,MB_YESNO) == IDNO )
            return;
        }

    // let the dialog close
    CDialog::OnOK();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\cnfgprts\ratgenpg.cpp ===
// RatGenPg.cpp : implementation file
//

#include "stdafx.h"
#include <iadmw.h>
#include "cnfgprts.h"

#include "parserat.h"
#include "RatData.h"

#include "RatGenPg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


// enumerate the tree icon indexes
enum
    {
    IMAGE_SERVICE = 0,
    IMAGE_CATEGORY
    };

/////////////////////////////////////////////////////////////////////////////
// CRatGenPage property page

IMPLEMENT_DYNCREATE(CRatGenPage, CPropertyPage)

//--------------------------------------------------------------------------
CRatGenPage::CRatGenPage() : CPropertyPage(CRatGenPage::IDD),
        m_fInititialized( FALSE )
    {
    //{{AFX_DATA_INIT(CRatGenPage)
    m_sz_description = _T("");
    m_bool_enable = FALSE;
    m_sz_moddate = _T("");
    m_sz_person = _T("");
	//}}AFX_DATA_INIT
    }

//--------------------------------------------------------------------------
CRatGenPage::~CRatGenPage()
    {
    }

//--------------------------------------------------------------------------
void CRatGenPage::DoDataExchange(CDataExchange* pDX)
    {
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CRatGenPage)
    DDX_Control(pDX, IDC_MOD_DATE, m_cstatic_moddate);
    DDX_Control(pDX, IDC_STATIC_MOD_DATE, m_cstatic_moddate_title);
    DDX_Control(pDX, IDC_TREE, m_ctree_tree);
    DDX_Control(pDX, IDC_TITLE, m_cstatic_title);
    DDX_Control(pDX, IDC_STATIC_RATING, m_cstatic_rating);
    DDX_Control(pDX, IDC_STATIC_ICON, m_cstatic_icon);
    DDX_Control(pDX, IDC_STATIC_EXPIRES, m_cstatic_expires);
    DDX_Control(pDX, IDC_STATIC_EMAIL, m_cstatic_email);
    DDX_Control(pDX, IDC_STATIC_CATEGORY, m_cstatic_category);
    DDX_Control(pDX, IDC_SLIDER, m_cslider_slider);
    DDX_Control(pDX, IDC_NAME_PERSON, m_cedit_person);
    DDX_Control(pDX, IDC_DESCRIPTION, m_cstatic_description);
    DDX_Text(pDX, IDC_DESCRIPTION, m_sz_description);
    DDX_Check(pDX, IDC_ENABLE, m_bool_enable);
    DDX_Text(pDX, IDC_MOD_DATE, m_sz_moddate);
    DDX_Text(pDX, IDC_NAME_PERSON, m_sz_person);
    DDV_MaxChars(pDX, m_sz_person, 200);
	//}}AFX_DATA_MAP

    DDX_Control(pDX, IDC_DTP_ABS_DATE, m_dtpDate);
    }


//--------------------------------------------------------------------------
BEGIN_MESSAGE_MAP(CRatGenPage, CPropertyPage)
    //{{AFX_MSG_MAP(CRatGenPage)
    ON_BN_CLICKED(IDC_ENABLE, OnEnable)
    ON_NOTIFY(TVN_SELCHANGED, IDC_TREE, OnSelchangedTree)
    ON_WM_HSCROLL()
	ON_WM_DESTROY()
    ON_EN_CHANGE(IDC_NAME_PERSON, OnChangeNamePerson)
    ON_EN_CHANGE(IDC_MOD_DATE, OnChangeModDate)
	//}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,  DoHelp)
    ON_COMMAND(ID_HELP,         DoHelp)
    ON_COMMAND(ID_CONTEXT_HELP, DoHelp)
    ON_COMMAND(ID_DEFAULT_HELP, DoHelp)
END_MESSAGE_MAP()

//---------------------------------------------------------------------------
void CRatGenPage::DoHelp()
    {
    DebugTraceHelp(HIDD_RATINGS_RATING);
    WinHelp( HIDD_RATINGS_RATING );
    }


//--------------------------------------------------------------------------
void CRatGenPage::EnableButtons()
    {
    UpdateData( TRUE );

    // enabling is based on whether or not things are enabled
    if ( m_bool_enable )
        {
        m_ctree_tree.EnableWindow( TRUE );
        m_cstatic_title.EnableWindow( TRUE );
        m_cstatic_rating.EnableWindow( TRUE );
        m_cstatic_icon.EnableWindow( TRUE );
        m_cstatic_expires.EnableWindow( TRUE );
        m_cstatic_email.EnableWindow( TRUE );
        m_cstatic_category.EnableWindow( TRUE );
        m_cslider_slider.EnableWindow( TRUE );
        m_cedit_person.EnableWindow( TRUE );
        m_cstatic_moddate.EnableWindow( TRUE );
        m_cstatic_moddate_title.EnableWindow( TRUE );
        m_cstatic_description.EnableWindow( TRUE );
        m_dtpDate.EnableWindow(TRUE);

        // also need to take care of the slider bar
        UpdateRatingItems();
        }
    else
        {
        // not enabled
        m_ctree_tree.EnableWindow( FALSE );
        m_cstatic_title.EnableWindow( FALSE );
        m_cstatic_rating.EnableWindow( FALSE );
        m_cstatic_icon.EnableWindow( FALSE );
        m_cstatic_email.EnableWindow( FALSE );
        m_cstatic_category.EnableWindow( FALSE );
        m_cedit_person.EnableWindow( FALSE );
        m_cstatic_moddate.EnableWindow( FALSE );
        m_cstatic_moddate_title.EnableWindow( FALSE );
        m_dtpDate.EnableWindow(FALSE);

        // don't just disable the slider and description - hide them!
        m_cslider_slider.ShowWindow( SW_HIDE );
        m_cstatic_description.ShowWindow( SW_HIDE );
        }
    }

//--------------------------------------------------------------------------
void CRatGenPage::UpdateRatingItems()
    {
    // get the selected item in the tree
    HTREEITEM hItem = m_ctree_tree.GetSelectedItem();

    // get the item category
    PicsCategory* pCat = GetTreeItemCategory( hItem );

    // if there is no item, or it is the root, hide the sliders
    if ( !pCat )
        {
        // don't just disable the slider and description - hide them!
        m_cslider_slider.ShowWindow( SW_HIDE );
        m_cstatic_description.ShowWindow( SW_HIDE );
        }
    else
        {
        // make sure the windows are showing and enabled
        m_cslider_slider.ShowWindow( SW_SHOW );
        m_cstatic_description.ShowWindow( SW_SHOW );
        m_cslider_slider.EnableWindow( TRUE );
        m_cstatic_description.EnableWindow( TRUE );

        // get the item category
        PicsCategory* pCat = GetTreeItemCategory( hItem );

        // set up the slider
        m_cslider_slider.SetRangeMin( 0 );
        m_cslider_slider.SetRangeMax( pCat->arrpPE.Length() - 1, TRUE );

        // set current value of the slider
        m_cslider_slider.SetPos( pCat->currentValue );

        // set up the description
        UpdateDescription();
        }
    }

//--------------------------------------------------------------------------
PicsCategory* CRatGenPage::GetTreeItemCategory( HTREEITEM hItem )
    {
    DWORD   iRat;
    DWORD   iCat = 0;

    // get the item's parent in the tree
    HTREEITEM hParent = m_ctree_tree.GetParentItem(hItem);

    // get the cat
    // IA64 - OK to cast as this is an index
    iCat = (DWORD)m_ctree_tree.GetItemData( hItem );

    // if the parent is null, return NULL to indicate that this is a root item
    if ( !hParent )
        return NULL;

    // if the parent is a root though, we can simply return the category
    if ( !m_ctree_tree.GetParentItem(hParent) )
        {
        // get the rat and the cat
    // IA64 - OK to cast as this is an index
        iRat = (DWORD)m_ctree_tree.GetItemData( hParent );
        // return the category
        return m_pRatData->rgbRats[iRat]->arrpPC[iCat];
        }
    else
        {
        // we are deeper in the tree. Get the parent category first
        PicsCategory* pParentCat = GetTreeItemCategory( hParent );
        // return the category
        return pParentCat->arrpPC[iCat];
        }
    // shouldn't get here
    return NULL;
    }

//--------------------------------------------------------------------------
void CRatGenPage::UpdateDateStrings()
    {
    CString sz;
    TCHAR    chBuff[MAX_PATH];
    int     i;

    SYSTEMTIME  sysTime;

    UpdateData( TRUE );

    // start with the epxiration date
    ZeroMemory( chBuff, sizeof(chBuff) );
    ZeroMemory( &sysTime, sizeof(sysTime) );
    sysTime.wDay = m_pRatData->m_expire_day;
    sysTime.wMonth = m_pRatData->m_expire_month;
    sysTime.wYear = m_pRatData->m_expire_year;

    m_dtpDate.SetTime(&sysTime);


    // now the modified date and time
    ZeroMemory( chBuff, sizeof(chBuff) );
    ZeroMemory( &sysTime, sizeof(sysTime) );
    sysTime.wDay = m_pRatData->m_start_day;
    sysTime.wMonth = m_pRatData->m_start_month;
    sysTime.wYear = m_pRatData->m_start_year;
    sysTime.wMinute = m_pRatData->m_start_minute;
    sysTime.wHour = m_pRatData->m_start_hour;

    i = GetDateFormat(
        LOCALE_USER_DEFAULT,
        DATE_LONGDATE,
        &sysTime,
        NULL,
        chBuff,
        sizeof(chBuff)/sizeof(TCHAR)
       );
    m_sz_moddate = chBuff;

    ZeroMemory( chBuff, sizeof(chBuff) );
    i = GetTimeFormat(
        LOCALE_USER_DEFAULT,
        TIME_NOSECONDS,
        &sysTime,
        NULL,
        chBuff,
        sizeof(chBuff)/sizeof(TCHAR)
       );
    m_sz_moddate += ", ";
    m_sz_moddate += chBuff;

//    CTime timeModified( sysTime );
//    m_sz_moddate = timeModified.Format( "%#c" );

    // put it back
    UpdateData( FALSE );
    }

//--------------------------------------------------------------------------
// Update the text displayed in the description
void CRatGenPage::UpdateDescription()
    {
    // get the selected item in the tree
    HTREEITEM hItem = m_ctree_tree.GetSelectedItem();
    if ( !hItem ) return;

    // get the selected category object
    PicsCategory* pCat = GetTreeItemCategory( hItem );

    // shouldn't be any problem, but might as well check
    if ( !pCat )
        return;

    // get the current value
    WORD value = pCat->currentValue;

    // build the description string
    m_sz_description = pCat->arrpPE[value]->etstrName.Get();
    UpdateData( FALSE );
    }

//--------------------------------------------------------------------------
// tell it to query the metabase and get any defaults
BOOL CRatGenPage::FInit()
    {
    UpdateData( TRUE );

    HIMAGELIST hImage = ImageList_LoadImage(AfxGetResourceHandle(),
        MAKEINTRESOURCE(IDB_RATLIST), 16, 3, 0x00FF00FF, IMAGE_BITMAP, LR_DEFAULTCOLOR);
    if (hImage != NULL)
    {
        m_ctree_tree.SetImageList(CImageList::FromHandle(hImage), TVSIL_NORMAL);
    }
    // start with the parsed rat files
    if ( !FLoadRatFiles() )
        return FALSE;

    // do the right thing based on the ratings being enabled
    if ( m_pRatData->m_fEnabled )
        {
        // ratings are enabled.
        m_bool_enable = TRUE;
        m_sz_person = m_pRatData->m_szEmail;
        }
    else
        {
        // ratings are not enabled.
        m_bool_enable = FALSE;
        }

    // do the dates
    // if the mod date is not set give date today's as a default moddate
    if ( m_pRatData->m_start_year == 0 )
        {
        SetCurrentModDate();
        }



    //
    // Set the minimum of the date picker to today
    // and the maximum to Dec 31, 2035.
    // taken from Ron's code
    //
    CTime m_tmNow(CTime::GetCurrentTime());
    CTime tmThen(2035, 12, 31, 23, 59, 59);
    m_dtpDate.SetRange(&m_tmNow, &tmThen);

    // if there is no expire date, set it for one year after the mod date
    if ( m_pRatData->m_expire_year == 0 )
        {
        m_pRatData->m_expire_minute = 0;
        m_pRatData->m_expire_hour = 12;
        m_pRatData->m_expire_day = m_pRatData->m_start_day;
        m_pRatData->m_expire_month = m_pRatData->m_start_month;
        m_pRatData->m_expire_year = m_pRatData->m_start_year + 1;
        }

    // update the date strings
    UpdateDateStrings();

    // update the name string and the enabled switch as well
    m_sz_person = m_pRatData->m_szEmail;
    m_bool_enable = m_pRatData->m_fEnabled;

    // put the data back
    UpdateData( FALSE );

    EnableButtons();

    // success
    return TRUE;
    }

//--------------------------------------------------------------------------
// load the parsed rat files into the tree
BOOL CRatGenPage::FLoadRatFiles()
    {
    HTREEITEM   hRoot;
    HTREEITEM   hItem;
    CString     sz;

    // how many rat files are there?
    DWORD   nRatFiles = (DWORD)m_pRatData->rgbRats.GetSize();
    // loop them
    for ( DWORD iRat = 0; iRat < nRatFiles; iRat++ )
        {
        // get the rating system
        PicsRatingSystem*   pRating = m_pRatData->rgbRats[iRat];

        // get the root node name
        sz = pRating->etstrName.Get();

        // add the root node to the tree
        hRoot = m_ctree_tree.InsertItem( sz );
        // because the list is alphabetized, embed the iRat number in the item
        m_ctree_tree.SetItemData( hRoot, iRat );
        m_ctree_tree.SetItemImage( hRoot, IMAGE_SERVICE, IMAGE_SERVICE );

        // add the subnodes to the tree as well
        DWORD nCats = pRating->arrpPC.Length();
        // loop them
        for ( DWORD iCat = 0; iCat < nCats; iCat++ )
            {
            // get the category node name
            sz = pRating->arrpPC[iCat]->etstrName.Get();

            // add the category node to the tree
            hItem = m_ctree_tree.InsertItem( sz, hRoot );

            // because the list is alphabetized, embed the iCat number in the item
            m_ctree_tree.SetItemData( hItem, iCat );
            m_ctree_tree.SetItemImage( hItem, IMAGE_CATEGORY, IMAGE_CATEGORY );

            // even though there aren't any now, add any sub-categories
            LoadSubCategories( pRating->arrpPC[iCat], hItem );
            }

        // expand the rat node
        m_ctree_tree.Expand( hRoot, TVE_EXPAND );
        }

    return TRUE;
    }

//--------------------------------------------------------------------------
void CRatGenPage::LoadSubCategories( PicsCategory* pParentCat, HTREEITEM hParent )
    {
    CString sz;
    HTREEITEM hItem;

    // add the subnodes to the tree as well
    DWORD nCats = pParentCat->arrpPC.Length();
    // loop them
    for ( DWORD iCat = 0; iCat < nCats; iCat++ )
        {
        // get the category node name
        sz = pParentCat->arrpPC[iCat]->etstrName.Get();

        // add the category node to the tree
        hItem = m_ctree_tree.InsertItem( sz, hParent );

        // because the list is alphabetized, embed the iCat number in the item
        m_ctree_tree.SetItemData( hItem, iCat );
        m_ctree_tree.SetItemImage( hItem, IMAGE_CATEGORY, IMAGE_CATEGORY );

        // even though there aren't any now, add any sub-categories
        LoadSubCategories( pParentCat->arrpPC[iCat], hItem );
        }

    // if there were sub-categories, expand the parental node in the tree
    if ( nCats > 0 )
        m_ctree_tree.Expand( hParent, TVE_EXPAND );
    }


//--------------------------------------------------------------------------
void CRatGenPage::SetModifiedTime()
    {
    SetCurrentModDate();
    UpdateDateStrings();
    SetModified();
    }


/////////////////////////////////////////////////////////////////////////////
// CRatGenPage message handlers

//--------------------------------------------------------------------------
void CRatGenPage::OnEnable()
    {
    EnableButtons();
    SetModified();
    }

//--------------------------------------------------------------------------
BOOL CRatGenPage::OnSetActive()
    {
    // if it hasn't been initialized yet, do so
    if ( !m_fInititialized )
        {
        FInit();
        m_fInititialized = TRUE;
        }

    // enable the button appropriately
    EnableButtons();

    return CPropertyPage::OnSetActive();
    }

//--------------------------------------------------------------------------
void CRatGenPage::OnOK()
    {
    CPropertyPage::OnOK();
    }

//--------------------------------------------------------------------------
BOOL CRatGenPage::OnApply()
    {
    UpdateData( TRUE );

    // make sure there are no quote symbols in the name
    if ( m_sz_person.Find(_T('\"')) >= 0 )
        {
        AfxMessageBox( IDS_RAT_NAME_ERROR );
        return FALSE;
        }

    // put the data into place
    m_pRatData->m_fEnabled = m_bool_enable;
    m_pRatData->m_szEmail = m_sz_person;

    // set the expire date
    SYSTEMTIME  sysTime;
    ZeroMemory( &sysTime, sizeof(sysTime) );
    // get the date from the control
    m_dtpDate.GetTime(&sysTime);
    // set the date into place
    m_pRatData->m_expire_day = sysTime.wDay;
    m_pRatData->m_expire_month = sysTime.wMonth;
    m_pRatData->m_expire_year = sysTime.wYear;

    // generate the label and save it into the metabase
    m_pRatData->SaveTheLabel();

    // we can now apply
    SetModified( FALSE );
    return CPropertyPage::OnApply();
    }

//--------------------------------------------------------------------------
void CRatGenPage::SetCurrentModDate()
    {
    SYSTEMTIME time;
    GetLocalTime( &time );

    m_pRatData->m_start_day = time.wDay;
    m_pRatData->m_start_month = time.wMonth;
    m_pRatData->m_start_year = time.wYear;
    m_pRatData->m_start_minute = time.wMinute;
    m_pRatData->m_start_hour = time.wHour;
    }

//--------------------------------------------------------------------------
void CRatGenPage::OnSelchangedTree(NMHDR* pNMHDR, LRESULT* pResult)
    {
    NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
    UpdateRatingItems();
    *pResult = 0;
    }

//--------------------------------------------------------------------------
void CRatGenPage::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)
    {
    // get the value of the slider
    WORD iPos = (WORD)m_cslider_slider.GetPos();

    // get the current item
    HTREEITEM   hItem = m_ctree_tree.GetSelectedItem();

    // get the selected category object
    PicsCategory* pCat = GetTreeItemCategory( hItem );

    // shouldn't be any problem, but might as well check
    if ( !pCat )
        return;

    // set the category value
    pCat->currentValue = iPos;

    // update the description
    UpdateDescription();

    // we can now apply
    SetModifiedTime();

    // update the mod date
    SetCurrentModDate();
    CPropertyPage::OnHScroll(nSBCode, nPos, pScrollBar);
    }

//--------------------------------------------------------------------------
void CRatGenPage::OnChangeNamePerson()
    {
    // we can now apply
    SetModifiedTime();
    }

//--------------------------------------------------------------------------
void CRatGenPage::OnChangeModDate()
    {
    // we can now apply
    SetModifiedTime();
    }


//--------------------------------------------------------------------------
// Stolen from w3scfg - the httppage.cpp file
BOOL
CRatGenPage::OnNotify(
    WPARAM wParam,
    LPARAM lParam,
    LRESULT * pResult
    )
/*++

Routine Description:

    Handle notification changes

Arguments:

    WPARAM wParam           : Control ID
    LPARAM lParam           : NMHDR *
    LRESULT * pResult       : Result pointer

Return Value:

    TRUE if handled, FALSE if not

--*/
{
    //
    // Message cracker crashes - so checking this here instead
    //
    if (wParam == IDC_DTP_ABS_DATE)
    {
        NMHDR * pHdr = (NMHDR *)lParam;
        if (pHdr->code == DTN_DATETIMECHANGE)
        {
            SetModified();
        }
    }

    //
    // Default behaviour -- go to the message map
    //
    return CPropertyPage::OnNotify(wParam, lParam, pResult);
}

void CRatGenPage::OnDestroy()
{
	CPropertyPage::OnDestroy();
    CImageList * pImage = m_ctree_tree.SetImageList(CImageList::FromHandle(NULL), TVSIL_NORMAL);
    if (pImage != NULL && pImage->m_hImageList != NULL)
    {
        ImageList_Destroy(pImage->m_hImageList);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\cnfgprts\ratdata.cpp ===
/*++

   Copyright    (c)    1997-2001    Microsoft Corporation

   Module  Name :
        ratdata.h

   Abstract:
        Ratings data class

   Author:
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:
        sergeia     7/2/2001        Replaced most of previous code -- it was pretty bad
--*/
#include "stdafx.h"
#include "cnfgprts.h"
#include "parserat.h"
#include "RatData.h"

//----------------------------------------------------------------
CRatingsData::CRatingsData():
    iRat(0),
    m_fEnabled( FALSE ),
    m_start_minute(0),
    m_start_hour(0),
    m_start_day(0),
    m_start_month(0),
    m_start_year(0),
    m_expire_minute(0),
    m_expire_hour(0),
    m_expire_day(0),
    m_expire_month(0),
    m_expire_year(0)
{
}

//----------------------------------------------------------------
CRatingsData::~CRatingsData()
{
    // delete the rating systems
    DWORD nRats = (DWORD)rgbRats.GetSize();
    for (DWORD iRat = 0; iRat < nRats; iRat++)
    {
        delete rgbRats[iRat];
    }
}

//----------------------------------------------------------------
// generate the label and save it into the metabase
void CRatingsData::SaveTheLabel()
{
    BOOL fBuiltLabel = FALSE;
    CError err;

    CString csTempPassword;
    m_password.CopyTo(csTempPassword);
    CComAuthInfo auth(m_szServer, m_username, csTempPassword);
    CMetaKey mk(&auth, m_szMeta, METADATA_PERMISSION_WRITE);
    err = mk.QueryResult();
    if (err.Failed())
    {
        if (err.Win32Error() == ERROR_PATH_NOT_FOUND)
        {
            //
            // Path didn't exist yet, create it and reopen
            // it.
            //
            err = mk.CreatePathFromFailedOpen();
            if (err.Succeeded())
            {
                err = mk.ReOpen(METADATA_PERMISSION_WRITE);
            }
        }
    }

    if (err.Succeeded())
    {
        if (!m_fEnabled)
        {
            err = mk.DeleteValue(MD_HTTP_PICS);
        }
        else
        {
            CString szLabel = _T("PICS-Label: ");
            // create the modified string for this label
            CString szMod;
            CreateDateSz( szMod, m_start_day, m_start_month, m_start_year, m_start_hour, m_start_minute );
            // create the exipres string for this label
            CString szExpire;
            CreateDateSz( szExpire, m_expire_day, m_expire_month, m_expire_year, m_expire_hour, m_expire_minute );
            // tell each ratings system object to add its label to the string
            CStringListEx list;
            DWORD   nRatingSystems = (DWORD)rgbRats.GetSize();
            for ( DWORD iRat = 0; iRat < nRatingSystems; iRat++ )
            {
                // build the label string
                rgbRats[iRat]->OutputLabels( szLabel, m_szURL, m_szEmail, szMod, szExpire );
                list.AddTail(szLabel);
            }
            err = mk.SetValue(MD_HTTP_PICS, list);
        }
    }
}

BOOL CRatingsData::Init()
{
    BOOL fGotSomething = FALSE;
    TCHAR flt[MAX_PATH];
	ExpandEnvironmentStrings(_T("%windir%\\system32\\*.rat"), flt, MAX_PATH);
	WIN32_FIND_DATA ffdata;
	ZeroMemory(&ffdata, sizeof(ffdata));
	HANDLE hFind = ::FindFirstFile(flt, &ffdata);
	if (hFind != INVALID_HANDLE_VALUE)
	{
		do
		{
			if ((ffdata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
			{
				TCHAR filename[MAX_PATH];
				ExpandEnvironmentStrings(_T("%windir%\\system32"), filename, MAX_PATH);
				PathAppend(filename, ffdata.cFileName);
				fGotSomething |= LoadRatingsFile(filename);
			}
		} while (::FindNextFile(hFind, &ffdata));
		::FindClose(hFind);
	}

    if ( fGotSomething )
    {
        LoadMetabaseValues();
    }
    else
    {
        AfxMessageBox(IDS_RAT_FINDFILE_ERROR);
    }
    return fGotSomething;
}

BOOL CRatingsData::LoadRatingsFile(CString szFilePath)
{
    CFile f;
    CFileException e;
    if(!f.Open(szFilePath, CFile::modeRead | CFile::shareDenyWrite, &e))
    {
#ifdef _DEBUG
        afxDump << "File could not be opened " << e.m_cause << "\n";
#endif
        return FALSE;
    }
    ULONGLONG len = f.GetLength();
    LPSTR pBuf = (LPSTR)_alloca((int)len);
    BOOL fParsed = FALSE;
    if (NULL != pBuf)
    {
        if (len == f.Read(pBuf, (UINT)len))
        {
            fParsed = ParseRatingsFile(pBuf);
        }
    }
    return fParsed;
}

BOOL CRatingsData::ParseRatingsFile(LPSTR pData)
{
    HRESULT hres;
    BOOL fSuccess = FALSE;

    PicsRatingSystem * pRating = new PicsRatingSystem();
    if (NULL != pRating)
    {
        fSuccess = SUCCEEDED(pRating->Parse(pData));
        if ( !fSuccess )
        {
            delete pRating;
            return FALSE;
        }
        rgbRats.Add(pRating);
    }
    return fSuccess;
}


//----------------------------------------------------------------
// create a date string
void CRatingsData::CreateDateSz( CString &sz, WORD day, WORD month, WORD year, WORD hour, WORD minute )
{
    // get the local time zone
    TIME_ZONE_INFORMATION   tZone;
    INT                     hrZone, mnZone;
    DWORD                   dwDaylight = GetTimeZoneInformation( &tZone );
    // Fix for 339525: Boyd, this could be negative and must be signed type!
    LONG					tBias;

    // First, calculate the correct bias - depending whether or not
    // we are in daylight savings time.
    if ( dwDaylight == TIME_ZONE_ID_DAYLIGHT )
    {
        tBias = tZone.Bias + tZone.DaylightBias;
    }
    else
    {
        tBias = tZone.Bias + tZone.StandardBias;
    }

    // calculate the hours and minutes offset for the time-zone
    hrZone = tBias / 60;
    mnZone = tBias % 60;

    // need to handle time zones east of GMT
    if ( hrZone < 0 )
    {
        hrZone *= (-1);
        mnZone *= (-1);
        // make the string
        sz.Format( _T("%04d.%02d.%02dT%02d:%02d+%02d%02d"), year, month, day, hour, minute, hrZone, mnZone );
    }
    else
    {
        // make the string
        sz.Format( _T("%04d.%02d.%02dT%02d:%02d-%02d%02d"), year, month, day, hour, minute, hrZone, mnZone );
    }
}

//----------------------------------------------------------------
// read a date string
void CRatingsData::ReadDateSz( CString sz, WORD* pDay, WORD* pMonth, WORD* pYear, WORD* pHour, WORD* pMinute )
{
    CString szNum;
    WORD    i;
    DWORD   dw;

    // year
    szNum = sz.Left( sz.Find(_T('.')) );
    i = (WORD)swscanf( szNum, _T("%d"), &dw );
    *pYear = (WORD)dw;
    sz = sz.Right( sz.GetLength() - szNum.GetLength() - 1 );

    // month
    szNum = sz.Left( sz.Find(_T('.')) );
    i = (WORD)swscanf( szNum, _T("%d"), &dw );
    *pMonth = (WORD)dw;
    sz = sz.Right( sz.GetLength() - szNum.GetLength() - 1 );

    // day
    szNum = sz.Left( sz.Find(_T('T')) );
    i = (WORD)swscanf( szNum, _T("%d"), &dw );
    *pDay = (WORD)dw;
    sz = sz.Right( sz.GetLength() - szNum.GetLength() - 1 );

    // hour
    szNum = sz.Left( sz.Find(_T(':')) );
    i = (WORD)swscanf( szNum, _T("%d"), &dw );
    *pHour = (WORD)dw;
    sz = sz.Right( sz.GetLength() - szNum.GetLength() - 1 );

    // minute
    szNum = sz.Left( 2 );
    i = (WORD)swscanf( szNum, _T("%d"), &dw );
    *pMinute = (WORD)dw;
}

void CRatingsData::LoadMetabaseValues()
{
    CString csTempPassword;
    m_password.CopyTo(csTempPassword);
    CComAuthInfo auth(m_szServer, m_username, csTempPassword);
    CMetaKey mk(&auth);
    CString path = m_szMeta;
    CError err;

    while (FAILED(mk.DoesPathExist(path)))
    {
        CMetabasePath::ConvertToParentPath(path);
    }
    CStringListEx list;
    err = mk.QueryValue(MD_HTTP_PICS, list, NULL, path);
    if (err.Succeeded())
    {
        if (!list.IsEmpty())
        {
            ParseMetaRating(list.GetHead());
        }
    }
}

//----------------------------------------------------------------
// NOTE: this is a pretty fragile reading of the PICS file. If things are
// not in the order that this file would write them back out in, it will fail.
// however, This will work on PICS ratings that this module has written out,
// which should pretty much be all of them
// it also assumes that one-letter abbreviations are used just about everywhere
#define RAT_PERSON_DETECTOR     _T("by \"")
#define RAT_LABEL_DETECTOR      _T("l ")
#define RAT_ON_DETECTOR         _T("on \"")
#define RAT_EXPIRE_DETECTOR     _T("exp \"")
#define RAT_RAT_DETECTOR        _T("r (")
void CRatingsData::ParseMetaRating( CString szRating )
{
    CString     szScratch;

    // if we got here, then we know that the rating system is enabled
    m_fEnabled = TRUE;

    // operate on a copy of the data
    CString     szRat;

    // skip past the http headerpart
    szRat = szRating.Right( szRating.GetLength() - szRating.Find(_T("\"http://")) - 1 );
    szRat = szRat.Right( szRat.GetLength() - szRat.Find(_T('\"')) - 1 );
    szRat.TrimLeft();

    // the next bit should be the label indicator. Skip over it
    if ( szRat.Left(wcslen(RAT_LABEL_DETECTOR)) == RAT_LABEL_DETECTOR )
        szRat = szRat.Right( szRat.GetLength() - wcslen(RAT_LABEL_DETECTOR) );

    // we should now be at the author part. If it is there, load it in
    if ( szRat.Left(wcslen(RAT_PERSON_DETECTOR)) == RAT_PERSON_DETECTOR )
    {
        szRat = szRat.Right( szRat.GetLength() - wcslen(RAT_PERSON_DETECTOR) );
        m_szEmail = szRat.Left( szRat.Find(_T('\"')) );
        szRat = szRat.Right( szRat.GetLength() - m_szEmail.GetLength() - 1 );
        szRat.TrimLeft();
    }

    // next should be the modification date
    // we should now be at the author part. If we are, load it in
    if ( szRat.Left(wcslen(RAT_ON_DETECTOR)) == RAT_ON_DETECTOR )
    {
        szRat = szRat.Right( szRat.GetLength() - wcslen(RAT_ON_DETECTOR) );
        szScratch = szRat.Left( szRat.Find(_T('\"')) );
        szRat = szRat.Right( szRat.GetLength() - szScratch.GetLength() - 1 );
        szRat.TrimLeft();
        ReadDateSz( szScratch, &m_start_day, &m_start_month, &m_start_year,
            &m_start_hour, &m_start_minute );
    }

    // next should be the expiration date
    // we should now be at the author part. If we are, load it in
    if ( szRat.Left(wcslen(RAT_EXPIRE_DETECTOR)) == RAT_EXPIRE_DETECTOR )
    {
        szRat = szRat.Right( szRat.GetLength() - wcslen(RAT_EXPIRE_DETECTOR) );
        szScratch = szRat.Left( szRat.Find(_T('\"')) );
        szRat = szRat.Right( szRat.GetLength() - szScratch.GetLength() - 1 );
        szRat.TrimLeft();
        ReadDateSz( szScratch, &m_expire_day, &m_expire_month, &m_expire_year,
            &m_expire_hour, &m_expire_minute );
    }

    // we should now be at the actual ratings part. If we are, load it in as one string first
    if ( szRat.Left(wcslen(RAT_RAT_DETECTOR)) == RAT_RAT_DETECTOR )
    {
        szRat = szRat.Right( szRat.GetLength() - wcslen(RAT_RAT_DETECTOR) );
        szScratch = szRat.Left( szRat.Find(_T(')')) );
        szRat = szRat.Right( szRat.GetLength() - szScratch.GetLength() - 1 );
        szRat.TrimLeft();

        // loop through all the value pairs in the ratings string
        while ( szScratch.GetLength() )
        {
            // this part goes <ch> sp <ch> so that we know we can use chars 0 and 2
            ParseMetaPair( szScratch[0], szScratch[2] );

            // cut down the string
            szScratch = szScratch.Right( szScratch.GetLength() - 3 );
            szScratch.TrimLeft();
        }
    }
}

//----------------------------------------------------------------
void CRatingsData::ParseMetaPair( TCHAR chCat, TCHAR chVal )
{
    // check validity of the value character
    if ( (chVal < _T('0')) || (chVal > _T('9')) )
        return;

    // convert the value into a number - the quick way
    WORD    value = chVal - _T('0');

    // try all the categories
    DWORD nCat = rgbRats[0]->arrpPC.Length();
    for ( DWORD iCat = 0; iCat < nCat; iCat++ )
    {
        // stop at the first successful setting
        if ( rgbRats[0]->arrpPC[iCat]->FSetValuePair((CHAR)chCat, (CHAR)value) )
            break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\cnfgprts\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\cnfgprts\ratctl.h ===
// RatCtl.h : Declaration of the CRatCtrl OLE control class.

/////////////////////////////////////////////////////////////////////////////
// CRatCtrl : See RatCtl.cpp for implementation.

class CRatCtrl : public COleControl
{
	DECLARE_DYNCREATE(CRatCtrl)

// Constructor
public:
	CRatCtrl();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRatCtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	virtual void OnClick(USHORT iButton);
	virtual void OnFontChanged();
	virtual void OnGetControlInfo(LPCONTROLINFO pControlInfo);
	virtual void OnTextChanged();
	virtual void OnMnemonic(LPMSG pMsg);
	virtual void OnAmbientPropertyChange(DISPID dispid);
	virtual void OnKeyUpEvent(USHORT nChar, USHORT nShiftState);
	//}}AFX_VIRTUAL

// Implementation
protected:
	~CRatCtrl();

	DECLARE_OLECREATE_EX(CRatCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CRatCtrl)      // GetTypeInfo
	DECLARE_PROPPAGEIDS(CRatCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CRatCtrl)		// Type name and misc status

	// Subclassed control support
	BOOL PreCreateWindow(CREATESTRUCT& cs);
	BOOL IsSubclassedControl();
	LRESULT OnOcmCommand(WPARAM wParam, LPARAM lParam);

// Message maps
	//{{AFX_MSG(CRatCtrl)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CRatCtrl)
	afx_msg void SetAdminTarget(LPCTSTR szMachineName, LPCTSTR szMetaTarget);
	afx_msg void SetUserData(LPCTSTR szUserName, LPCTSTR szUserPassword);
	afx_msg void SetUrl(LPCTSTR szURL);
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

// Event maps
	//{{AFX_EVENT(CRatCtrl)
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CRatCtrl)
	dispidSetAdminTarget = 1L,
	//}}AFX_DISP_ID
	};

protected:
    BOOL 	m_fUpdateFont;
    CString m_szMachine;
    CString m_szMetaObject;
	CString m_szUserName;
	CStrPassword m_szUserPassword;
	CString m_szURL;

    // the accelerator table
    HACCEL  m_hAccel;
    WORD    m_cAccel;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\cnfgprts\ratgenpg.h ===
// RatGenPg.h : header file
//
/////////////////////////////////////////////////////////////////////////////
// CRatGenPage dialog

class CRatGenPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CRatGenPage)

// Construction
public:
	CRatGenPage();
	~CRatGenPage();
    
    // the data
    CRatingsData*   m_pRatData;

// Dialog Data
	//{{AFX_DATA(CRatGenPage)
	enum { IDD = IDD_RAT_SETRATING };
	CStatic	m_cstatic_moddate;
	CStatic	m_cstatic_moddate_title;
	CButton	m_cbutton_optional;
	CTreeCtrl	m_ctree_tree;
	CStatic	m_cstatic_title;
	CStatic	m_cstatic_rating;
	CStatic	m_cstatic_icon;
	CStatic	m_cstatic_expires;
	CStatic	m_cstatic_email;
	CStatic	m_cstatic_category;
	CSliderCtrl	m_cslider_slider;
	CEdit	m_cedit_person;
	CStatic	m_cstatic_description;
	CString	m_sz_description;
	BOOL	m_bool_enable;
	CString	m_sz_moddate;
	CString	m_sz_person;
	//}}AFX_DATA

   CDateTimeCtrl m_dtpDate;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRatGenPage)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL OnApply();
	virtual void OnOK();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CRatGenPage)
	afx_msg void OnEnable();
	afx_msg void OnSelchangedTree(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnChangeNamePerson();
	afx_msg void OnChangeModDate();
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    void DoHelp();

    // tell it to query the metabase and get any defaults
    BOOL    FInit();
    // load the parsed rat files into the tree
    BOOL    FLoadRatFiles();

    // utilities
    void EnableButtons();
    void UpdateRatingItems();
    void SetCurrentModDate();
    void UpdateDescription();
    void UpdateDateStrings();
    void SetModifiedTime();

    PicsCategory* GetTreeItemCategory( HTREEITEM hItem );
    void LoadSubCategories( PicsCategory* pParentCat, HTREEITEM hParent );

    // initialized flag
    BOOL        m_fInititialized;
    CImageList	m_imageList;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\cnfgprts\ratsrvpg.h ===
// RatSrvPg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CRatServicePage dialog

class CRatServicePage : public CPropertyPage
{
	DECLARE_DYNCREATE(CRatServicePage)

// Construction
public:
	CRatServicePage();
	~CRatServicePage();

    // the data
    CRatingsData*   m_pRatData;


// Dialog Data
	//{{AFX_DATA(CRatServicePage)
	enum { IDD = IDD_RAT_SERVICE };
	CString	m_sz_description;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRatServicePage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CRatServicePage)
	afx_msg void OnQuestionaire();
	afx_msg void OnMoreinfo();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    void DoHelp();

    CString m_szMoreInfoURL;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\cnfgprts\ratsrvpg.cpp ===
// RatSrvPg.cpp : implementation file
//

#include "stdafx.h"
#include <iadmw.h>
#include "cnfgprts.h"

#include "parserat.h"
#include "RatData.h"

#include "RatSrvPg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRatServicePage property page

IMPLEMENT_DYNCREATE(CRatServicePage, CPropertyPage)

CRatServicePage::CRatServicePage() : CPropertyPage(CRatServicePage::IDD)
{
	//{{AFX_DATA_INIT(CRatServicePage)
	m_sz_description = _T("");
	//}}AFX_DATA_INIT
}

CRatServicePage::~CRatServicePage()
{
}

void CRatServicePage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRatServicePage)
	DDX_Text(pDX, IDC_DESCRIPTION, m_sz_description);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRatServicePage, CPropertyPage)
	//{{AFX_MSG_MAP(CRatServicePage)
	ON_BN_CLICKED(IDC_QUESTIONAIRE, OnQuestionaire)
	ON_BN_CLICKED(IDC_MOREINFO, OnMoreinfo)
	//}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,  DoHelp)
    ON_COMMAND(ID_HELP,         DoHelp)
    ON_COMMAND(ID_CONTEXT_HELP, DoHelp)
    ON_COMMAND(ID_DEFAULT_HELP, DoHelp)
END_MESSAGE_MAP()

//---------------------------------------------------------------------------
void CRatServicePage::DoHelp()
    {
    DebugTraceHelp(HIDD_RATINGS_SERVICE);
    WinHelp( HIDD_RATINGS_SERVICE );
    }

/////////////////////////////////////////////////////////////////////////////
// CRatServicePage message handlers

//--------------------------------------------------------------------------
void CRatServicePage::OnQuestionaire() 
    {
    // sometimes it takes a few moments of IE to get going
    CWaitCursor waitcursor;

    // get the URL of the ratings service place
    CString     szURL;
    szURL.LoadString( IDS_RATING_URL );

    // launch IE with the URL of the ratings service place
    ShellExecute(
        NULL,	// handle to parent window
        NULL,	// pointer to string that specifies operation to perform
        szURL,	// pointer to filename or folder name string
        NULL,	// pointer to string that specifies executable-file parameters 
        NULL,	// pointer to string that specifies default directory
        SW_SHOW 	// whether file is shown when opened
       );
    }

//--------------------------------------------------------------------------
void CRatServicePage::OnMoreinfo() 
    {
    // sometimes it takes a few moments of IE to get going
    CWaitCursor waitcursor;

    // if the string isn't there, fail
    if ( m_szMoreInfoURL.IsEmpty() )
        return;

    // go to the URL
    ShellExecute(
        NULL,	// handle to parent window
        NULL,	// pointer to string that specifies operation to perform
        m_szMoreInfoURL,	// pointer to filename or folder name string
        NULL,	// pointer to string that specifies executable-file parameters 
        NULL,	// pointer to string that specifies default directory
        SW_SHOW 	// whether file is shown when opened
       );
   }

//--------------------------------------------------------------------------
BOOL CRatServicePage::OnSetActive() 
    {
    UpdateData( TRUE );

    // put the proper display string into place
    m_sz_description = m_pRatData->rgbRats[m_pRatData->iRat]->etstrDesc.Get();
    // get the more info URL too
    m_szMoreInfoURL = m_pRatData->rgbRats[m_pRatData->iRat]->etstrRatingService.Get();

    UpdateData( FALSE );
    
    return CPropertyPage::OnSetActive();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\cnfgprts\ratppg.cpp ===
// RatPpg.cpp : Implementation of the CRatPropPage property page class.

#include "stdafx.h"
#include "cnfgprts.h"
#include "RatPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CRatPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CRatPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CRatPropPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CRatPropPage, "CNFGPRTS.RatPropPage.1",
	0xba634608, 0xb771, 0x11d0, 0x92, 0x96, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b)


/////////////////////////////////////////////////////////////////////////////
// CRatPropPage::CRatPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CRatPropPage

BOOL CRatPropPage::CRatPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(
         AfxGetInstanceHandle(),
			m_clsid, 
         IDS_RAT_PPG,
         afxRegApartmentThreading
         );
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CRatPropPage::CRatPropPage - Constructor

CRatPropPage::CRatPropPage() :
	COlePropertyPage(IDD, IDS_RAT_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CRatPropPage)
	m_sz_caption = _T("");
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CRatPropPage::DoDataExchange - Moves data between page and properties

void CRatPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CRatPropPage)
	DDP_Text(pDX, IDC_CAPTIONEDIT, m_sz_caption, _T("Caption") );
	DDX_Text(pDX, IDC_CAPTIONEDIT, m_sz_caption);
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CRatPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\cnfgprts\ratppg.h ===
// RatPpg.h : Declaration of the CRatPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CRatPropPage : See RatPpg.cpp.cpp for implementation.

class CRatPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CRatPropPage)
	DECLARE_OLECREATE_EX(CRatPropPage)

// Constructor
public:
	CRatPropPage();

// Dialog Data
	//{{AFX_DATA(CRatPropPage)
	enum { IDD = IDD_PROPPAGE_RAT };
	CString	m_sz_caption;
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CRatPropPage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\cnfgprts\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxctl.h>         // MFC support for OLE Controls
#include <afxdtctl.h>
#include <atlbase.h>

// Delete the two includes below if you do not wish to use the MFC
//  database classes
#ifndef _UNICODE
//#include <afxdb.h>			// MFC database classes
//#include <afxdao.h>			// MFC DAO database classes
#endif //_UNICODE

#include <afxcmn.h>			// MFC support for Windows Common Controls
#include <afxtempl.h>

#include <assert.h>
#include <aclapi.h>

#define _COMIMPORT
#include "common.h"
#include "iishelp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\cnfgprts\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cnfgprts.rc
//
#define IDS_LOGUI                       1
#define IDB_LOGUI                       1
#define IDS_LOGUI_PPG                   2
#define IDB_RAT                         2
#define IDS_RAT                         3
#define IDB_APPS                        3
#define IDS_RAT_PPG                     4
#define IDS_APPS                        5
#define IDS_APPS_PPG                    6
#define IDC_DTP_ABS_DATE                3826
#define IDC_DTP_ABS_TIME                3827
#define IDS_LOGUI_PPG_CAPTION           10100
#define IDD_PROPPAGE_LOGUI              10100
#define IDS_RAT_PPG_CAPTION             10101
#define IDD_PROPPAGE_RAT                10101
#define IDS_APPS_PPG_CAPTION            10102
#define IDD_PROPPAGE_APPS               10102
#define IDS_RATING_URL                  10103
#define IDS_RAT_SHEETTITLE              10104
#define IDS_RAT_READFILE_ERROR          10105
#define IDS_RAT_FINDFILE_ERROR          10106
#define IDS_RAT_NAME_ERROR              10107
#define IDS_HTTP_HEADER                 10108
#define IDS_APP_SHEETTITLE              10109
#define IDS_LOG_INVALID_DIR             10110
#define IDS_APP_EXTENSION               10111
#define IDS_APP_EXE_PATH                10112
#define IDS_APP_MAP_REMOVE_CONFIRM      10113
#define IDS_APP_MAP_INVALID_PATH        10114
#define IDS_APP_MAP_INVALID_EXT         10115
#define IDS_ELLIPSIS                    10116
#define IDS_APP_MAP_FILTER              10117
#define IDS_HELPLOC_HELP                10118
#define IDS_APP_ONLY_ONE                10119
#define IDS_EXPIRE_SET_PAST             10120
#define IDS_LOGUI_DLL                   10121
#define IDS_APP_EXCLUSIONS              10122
#define IDS_APP_ERR_TITLE               10123
#define IDS_RAT_ERR_TITLE               10124
#define IDS_LOG_ERR_TITLE               10125
#define IDS_APP_ERR_EXT_REQUIRED        10126
#define IDS_SCRIPTS                     10127
#define IDS_NO_DATE_SELECTED            10128
#define IDS_ERR_LOG_PLUGIN              10129
#define IDS_APP_MAP_USE_VALID_DRIVE     10130
#define IDS_VERBS_ALL                   10131
#define IDS_ERR_NO_VERBS                10132
#define IDC_CAPTIONEDIT                 10201
#define IDD_LOG_GENERAL                 10201
#define IDC_LOG_AUTO_OPEN               10201
#define IDC_LOG_DAILY                   10202
#define IDD_RAT_SETRATING               10202
#define IDC_LOG_WEEKLY                  10203
#define IDD_RAT_SERVICE                 10203
#define IDI_ICON1                       10203
#define IDI_GLOBE                       10203
#define IDC_LOG_MONTHLY                 10204
#define IDC_LOG_WHENSIZE                10205
#define IDD_RAT_EXPIRE                  10205
#define IDC_SPIN                        10207
#define IDC_LOG_SIZE                    10208
#define IDC_LOG_DIRECTORY               10209
#define IDB_RATLIST                     10209
#define IDC_BROWSE                      10210
#define IDC_LOG_SIZE_UNITS              10211
#define IDC_LOG_FILE_SAMPLE             10212
#define IDC_TREE                        10213
#define IDD_APP_ASPMAIN                 10214
#define IDC_SLIDER                      10215
#define IDD_APP_ASPDEBUG                10215
#define IDC_DESCRIPTION                 10216
#define IDD_APP_APPMAP                  10216
#define IDD_APP_OTHER                   10217
#define IDC_NAME_PERSON                 10218
#define IDD_APP_EDITMAP                 10218
#define IDC_MOD_DATE                    10219
#define IDC_EXPIRES                     10220
#define IDD_APP_PROC                    10220
#define IDC_DATE_BUTTON                 10221
#define IDD_APP_RECYCLE                 10221
#define IDC_ENABLE                      10222
#define IDD_TIME_PICKER                 10222
#define IDC_QUESTIONAIRE                10223
#define IDC_MOREINFO                    10224
#define IDC_RATSYSTEM                   10225
#define IDC_TITLE                       10226
#define IDC_STATIC_ICON                 10227
#define IDC_STATIC_CATEGORY             10228
#define IDC_STATIC_RATING               10229
#define IDC_STATIC_OPTIONAL             10230
#define IDC_STATIC_EMAIL                10231
#define IDC_STATIC_MOD_DATE             10232
#define IDC_STATIC_EXPIRES              10233
#define IDC_MSACALCTRL                  10234
#define IDC_CHECK1                      10235
#define IDC_CHK_SCRIPT_ENGINE           10235
#define IDC_CHK_EXCEPTION_CATCH         10235
#define IDC_RECYCLE_TIMER               10235
#define IDC_CHECK2                      10236
#define IDC_CHK_ENABLE_BUFFERING        10236
#define IDC_CHK_FILE_EXISTS             10236
#define IDC_CHK_JAVA_DEBUG              10236
#define IDC_CHECK3                      10237
#define IDC_CHK_ENABLE_PARENTS          10237
#define IDC_CHECK4                      10238
#define IDC_CHK_WRITE_FAIL_TO_LOG       10238
#define IDC_CHECK5                      10239
#define IDC_EDIT1                       10240
#define IDC_EDT_SESSION_TIMEOUT         10240
#define IDC_EDT_EXECUTABLE              10240
#define IDC_TIMESPAN                    10240
#define IDC_EDIT2                       10241
#define IDC_EDT_NUM_ENGINES             10241
#define IDC_EDT_EXTENSION               10241
#define IDC_REQUEST_LIMIT               10241
#define IDC_COMBO1                      10242
#define IDC_CMBO_LANGUAGES              10242
#define IDC_EDIT3                       10243
#define IDC_EDT_SCRIPT_TIMEOUT          10243
#define IDC_EDT_EXCLUSIONS              10243
#define IDC_RADIO1                      10244
#define IDC_RDO_CACHE_ALL               10244
#define IDC_RADIO_ALL_VERBS             10244
#define IDC_RADIO2                      10245
#define IDC_RDO_CACHE_SIZE              10245
#define IDC_RADIO_LIMIT_VERBS           10245
#define IDC_EDIT4                       10246
#define IDC_EDT_CACHE_SIZE              10246
#define IDC_LIST1                       10247
#define IDC_LIST                        10247
#define IDC_RDO_CACHE_NONE              10247
#define IDC_BUTTON1                     10248
#define IDC_ADD                         10248
#define IDC_ADD_TIME                    10248
#define IDC_BUTTON2                     10249
#define IDC_REMOVE                      10249
#define IDC_BUTTON3                     10250
#define IDC_EDIT                        10250
#define IDC_CHK_ENABLE                  10251
#define IDC_CHK_SERVER_DEBUG            10251
#define IDC_CHK_BREAK                   10252
#define IDC_CHK_CLIENT_DEBUG            10252
#define IDC_RDO_SEND_DETAILED_ERROR     10253
#define IDC_RDO_SEND_DEF_ERROR          10254
#define IDC_DEFAULT_ERROR               10255
#define IDC_CHK_POOL_ODBC               10256
#define IDC_ODBC_TIMEOUT                10257
#define IDC_CGI_SECONDS                 10258
#define IDC_ODBC_TITLE                  10259
#define IDC_ODBC_SECONDS                10260
#define IDC_CGI_UNITS                   10261
#define IDC_ODBC_UNITS                  10262
#define IDC_CHK_ENABLE_SESSION          10263
#define IDC_SESSION_TITLE               10264
#define IDC_SESSION_UNITS               10265
#define IDC_CACHE_UNITS                 10266
#define IDC_LANG_TITLE                  10267
#define IDC_CHK_CACHE_ISAPI             10268
#define ID_HELPBTN                      10269
#define IDC_EDT_LANGUAGES               10270
#define IDC_RECYCLE_TIMESPAN            10271
#define IDC_RECYCLE_REQUESTS            10272
#define IDC_TIMES_LIST                  10273
#define IDC_TIME_PICKER                 10274

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        10223
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         10275
#define _APS_NEXT_SYMED_VALUE           10101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\accentry.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        accentry.cpp

   Abstract:

        CAccessEntry class implementation

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:
         1/9/2000       sergeia     Cleaned out from usrbrows.cpp

--*/

//
// Include Files
//
#include "stdafx.h"
#include <iiscnfgp.h>
#include "common.h"
#include "objpick.h"
#include "accentry.h"



#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


#define new DEBUG_NEW
#define SZ_USER_CLASS           _T("user")
#define SZ_GROUP_CLASS          _T("group")

BOOL
CAccessEntry::LookupAccountSid(
    OUT CString & strFullUserName,
    OUT int & nPictureID,
    IN  PSID pSid,
    IN  LPCTSTR lpstrSystemName /* OPTIONAL */
    )
/*++

Routine Description:

    Get a full user name and picture ID from the SID
    
Arguments:

    CString &strFullUserName        : Returns the user name
    int & nPictureID                : Returns offset into the imagemap that
                                      represents the account type.
    PSID pSid                       : Input SID pointer
    LPCTSTR lpstrSystemName         : System name or NULL
     
Return Value:

    TRUE for success, FALSE for failure.

--*/
{
    DWORD cbUserName = PATHLEN * sizeof(TCHAR);
    DWORD cbRefDomainName = PATHLEN * sizeof(TCHAR);

    CString strUserName;
    CString strRefDomainName;
    SID_NAME_USE SidToNameUse;

    LPTSTR lpUserName = strUserName.GetBuffer(PATHLEN);
    LPTSTR lpRefDomainName = strRefDomainName.GetBuffer(PATHLEN);
    BOOL fLookUpOK = ::LookupAccountSid(
        lpstrSystemName, 
        pSid, 
        lpUserName,
        &cbUserName, 
        lpRefDomainName, 
        &cbRefDomainName, 
        &SidToNameUse
        );

    strUserName.ReleaseBuffer();
    strRefDomainName.ReleaseBuffer();

    strFullUserName.Empty();

    if (fLookUpOK)
    {
        if (!strRefDomainName.IsEmpty()
            && strRefDomainName.CompareNoCase(_T("BUILTIN")))
        {
            strFullUserName += strRefDomainName;
            strFullUserName += "\\";
        }

        strFullUserName += strUserName;

        nPictureID = SidToNameUse;
    }
    else
    {
        strFullUserName.LoadString(IDS_UNKNOWN_USER);
        nPictureID = SidTypeUnknown;
    }

    //
    // SID_NAME_USE is 1-based
    //
    --nPictureID ;

    return fLookUpOK;
}



CAccessEntry::CAccessEntry(
    IN LPVOID pAce,
    IN BOOL fResolveSID
    )
/*++

Routine Description:

    Construct from an ACE

Arguments:

    LPVOID pAce         : Pointer to ACE object
    BOOL fResolveSID    : TRUE to resolve the SID immediately

Return Value:

    N/A

--*/
    : m_pSid(NULL),
      m_fSIDResolved(FALSE),
      m_fDeletable(TRUE),
      m_fInvisible(FALSE),
      m_nPictureID(SidTypeUnknown-1),   // SID_NAME_USE is 1-based
      m_lpstrSystemName(NULL),
      m_accMask(0L),
      m_fDeleted(FALSE),
      m_strUserName()
{
    MarkEntryAsClean();

    PACE_HEADER ph = (PACE_HEADER)pAce;
    PSID pSID = NULL;

    switch(ph->AceType)
    {
    case ACCESS_ALLOWED_ACE_TYPE:
        pSID = (PSID)&((PACCESS_ALLOWED_ACE)pAce)->SidStart;
        m_accMask = ((PACCESS_ALLOWED_ACE)pAce)->Mask;
        break;
        
    case ACCESS_DENIED_ACE_TYPE:
    case SYSTEM_AUDIT_ACE_TYPE:
    case SYSTEM_ALARM_ACE_TYPE:           
    default:
        //
        // Not supported!
        //
        ASSERT_MSG("Unsupported ACE type");
        break;
    }

    if (pSID == NULL)
    {
        return;
    }

    //
    // Allocate a new copy of the sid.
    //
    DWORD cbSize = ::RtlLengthSid(pSID);
    m_pSid = (PSID)AllocMem(cbSize); 
    if (m_pSid != NULL)
    {
       DWORD err = ::RtlCopySid(cbSize, m_pSid, pSID);
       ASSERT(err == ERROR_SUCCESS);
    }

    //
    // Only the non-deletable administrators have execute
    // privileges
    //
    m_fDeletable = (m_accMask & FILE_EXECUTE) == 0L;

    //
    // Enum_keys is a special access right that literally "everyone"
    // has, but it doesn't designate an operator, so it should not
    // show up in the operator list if this is the only right it has.
    //
    m_fInvisible = (m_accMask == MD_ACR_ENUM_KEYS);
    
    //SetAccessMask(lpAccessEntry);

    if (fResolveSID)
    {
        ResolveSID();
    }
}



CAccessEntry::CAccessEntry(
    IN ACCESS_MASK accPermissions,
    IN PSID pSid,
    IN LPCTSTR lpstrSystemName,     OPTIONAL
    IN BOOL fResolveSID
    )
/*++

Routine Description:

    Constructor from access permissions and SID.

Arguments:

    ACCESS_MASK accPermissions      : Access mask
    PSID pSid                       : Pointer to SID
    LPCTSTR lpstrSystemName         : Optional system name
    BOOL fResolveSID                : TRUE to resolve SID immediately

Return Value:

    N/A

--*/
    : m_pSid(NULL),
      m_fSIDResolved(FALSE),
      m_fDeletable(TRUE),
      m_fInvisible(FALSE),
      m_fDeleted(FALSE),
      m_nPictureID(SidTypeUnknown-1),   // SID_NAME_USE is 1-based
      m_strUserName(),
      m_lpstrSystemName(NULL),
      m_accMask(accPermissions)
{
    MarkEntryAsClean();

    //
    // Allocate a new copy of the sid.
    //
    DWORD cbSize = ::RtlLengthSid(pSid);
    m_pSid = (PSID)AllocMem(cbSize); 
    if (m_pSid != NULL)
    {
       DWORD err = ::RtlCopySid(cbSize, m_pSid, pSid);
       ASSERT(err == ERROR_SUCCESS);
    }
    if (lpstrSystemName != NULL)
    {
        m_lpstrSystemName = AllocTString(::lstrlen(lpstrSystemName) + 1);
        if (m_lpstrSystemName != NULL)
        {
           ::lstrcpy(m_lpstrSystemName, lpstrSystemName);
        }
    }

    if (fResolveSID)
    {
        TRACEEOLID("Bogus SID");
        ResolveSID();
    }
}



CAccessEntry::CAccessEntry(
    IN PSID pSid,
    IN LPCTSTR pszUserName,
    IN LPCTSTR pszClassName
    )
/*++

Routine Description:

    Constructor from access sid and user/class name.

Arguments:

    PSID pSid,              Pointer to SID
    LPCTSTR pszUserName     User name
    LPCTSTR pszClassName    User Class name

Return Value:

    N/A

--*/
    : m_pSid(NULL),
      m_fSIDResolved(pszUserName != NULL),
      m_fDeletable(TRUE),
      m_fInvisible(FALSE),
      m_fDeleted(FALSE),
      m_nPictureID(SidTypeUnknown-1),   // SID_NAME_USE is 1-based
      m_strUserName(pszUserName),
      m_lpstrSystemName(NULL),
      m_accMask(0)
{
    MarkEntryAsClean();

    //
    // Allocate a new copy of the sid.
    //
    DWORD cbSize = ::RtlLengthSid(pSid);
    m_pSid = (PSID)AllocMem(cbSize); 
    if (m_pSid != NULL)
    {
       DWORD err = ::RtlCopySid(cbSize, m_pSid, pSid);
       ASSERT(err == ERROR_SUCCESS);
    }
    if (_tcsicmp(SZ_USER_CLASS, pszClassName) == 0)
    {
        m_nPictureID = SidTypeUser - 1;
    }
    else if (_tcsicmp(SZ_GROUP_CLASS, pszClassName) == 0)
    {
        m_nPictureID = SidTypeGroup - 1;
    }
}




CAccessEntry::CAccessEntry(
    IN CAccessEntry & ae
    )
/*++

Routine Description:

    Copy constructor

Arguments:

    CAccessEntry & ae       : Source to copy from

Return Value:

    N/A

--*/
    : m_fSIDResolved(ae.m_fSIDResolved),
      m_fDeletable(ae.m_fDeletable),
      m_fInvisible(ae.m_fInvisible),
      m_fDeleted(ae.m_fDeleted),
      m_fDirty(ae.m_fDirty),
      m_nPictureID(ae.m_nPictureID),
      m_strUserName(ae.m_strUserName),
      m_lpstrSystemName(ae.m_lpstrSystemName),
      m_accMask(ae.m_accMask)
{
    DWORD cbSize = ::RtlLengthSid(ae.m_pSid);
    m_pSid = (PSID)AllocMem(cbSize); 
    if (m_pSid != NULL)
    {
       DWORD err = ::RtlCopySid(cbSize, m_pSid, ae.m_pSid);
       ASSERT(err == ERROR_SUCCESS);
    }
}




CAccessEntry::~CAccessEntry()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    TRACEEOLID(_T("Destroying local copy of the SID"));
    ASSERT_PTR(m_pSid);
    FreeMem(m_pSid);

    if (m_lpstrSystemName != NULL)
    {
        FreeMem(m_lpstrSystemName);
    }
}




BOOL
CAccessEntry::ResolveSID()
/*++

Routine Description:

    Look up the user name and type.

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure.

Notes:

    This could take some time.

--*/
{
    //
    // Even if it fails, it will be considered
    // resolved
    //
    m_fSIDResolved = TRUE;   

    return CAccessEntry::LookupAccountSid(
        m_strUserName,
        m_nPictureID,
        m_pSid,
        m_lpstrSystemName
        );
}



void 
CAccessEntry::AddPermissions(
    IN ACCESS_MASK accNewPermissions
    )
/*++

Routine Description:

   Add permissions to this entry.

Arguments:

    ACCESS_MASK accNewPermissions       : New access permissions to be added

Return Value:

    None.

--*/
{
    m_accMask |= accNewPermissions;
    m_fInvisible = (m_accMask == MD_ACR_ENUM_KEYS);
    m_fDeletable = (m_accMask & FILE_EXECUTE) == 0L;
    MarkEntryAsChanged();
}



void 
CAccessEntry::RemovePermissions(
    IN ACCESS_MASK accPermissions
    )
/*++

Routine Description:

    Remove permissions from this entry.

Arguments:

    ACCESS_MASK accPermissions          : Access permissions to be taken away

--*/
{
    m_accMask &= ~accPermissions;
    MarkEntryAsChanged();
}

//
// Helper Functions
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



PSID
GetOwnerSID()
/*++

Routine Description:

    Return a pointer to the primary owner SID we're using.

Arguments:

    None

Return Value:

    Pointer to owner SID.

--*/
{
    PSID pSID = NULL;

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    if (!::AllocateAndInitializeSid(
        &NtAuthority, 
        2,
        SECURITY_BUILTIN_DOMAIN_RID,
        DOMAIN_ALIAS_RID_ADMINS, 
        0, 0, 0, 0, 0, 0,
        &pSID
        ))
    {
        TRACEEOLID("Unable to get primary SID " << ::GetLastError());
    }

    return pSID;
}



BOOL
BuildAclBlob(
    IN  CObListPlus & oblSID,
    OUT CBlob & blob
    )
/*++

Routine Description:

    Build a security descriptor blob from the access entries in the oblist

Arguments:

    CObListPlus & oblSID    : Input list of access entries
    CBlob & blob            : Output blob
    
Return Value:

    TRUE if the list is dirty.  If the list had no entries marked
    as dirty, the blob generated will be empty, and this function will
    return FALSE.

Notes:

    Entries marked as deleted will not be added to the list.

--*/
{
    ASSERT(blob.IsEmpty());

    BOOL fAclDirty = FALSE;
    CAccessEntry * pEntry;

    DWORD dwAclSize = sizeof(ACL) - sizeof(DWORD);
    CObListIter obli(oblSID);
    int cItems = 0;

    while(NULL != (pEntry = (CAccessEntry *)obli.Next()))
    {
        if (!pEntry->IsDeleted())
        {
            dwAclSize += GetLengthSid(pEntry->GetSid());
            dwAclSize += sizeof(ACCESS_ALLOWED_ACE);
            ++cItems;
        }

        if (pEntry->IsDirty())
        {
            fAclDirty = TRUE;
        }
    }

    if (fAclDirty)
    {
        //
        // Build the acl
        //
        PACL pacl = NULL;

        if (cItems > 0 && dwAclSize > 0)
        {
            pacl = (PACL)AllocMem(dwAclSize);
            if (pacl != NULL)
            {
               if (InitializeAcl(pacl, dwAclSize, ACL_REVISION))
               {
                   obli.Reset();    
                   while(NULL != (pEntry = (CAccessEntry *)obli.Next()))
                   {
                       if (!pEntry->IsDeleted())
                       {
                           VERIFY(AddAccessAllowedAce(
                               pacl, 
                               ACL_REVISION, 
                               pEntry->QueryAccessMask(),
                               pEntry->GetSid()
                               ));
                       }
                   }
               }
            }
            else
            {
               return FALSE;
            }
        }

         //
         // Build the security descriptor
         //
         PSECURITY_DESCRIPTOR pSD = 
             (PSECURITY_DESCRIPTOR)AllocMem(SECURITY_DESCRIPTOR_MIN_LENGTH);
         if (pSD != NULL)
         {
            VERIFY(InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION));
            VERIFY(SetSecurityDescriptorDacl(pSD, TRUE, pacl, FALSE));
         }
         else
         {
            return FALSE;
         }

         //
         // Set owner and primary group
         //
         PSID pSID = GetOwnerSID();
         ASSERT(pSID);
         VERIFY(SetSecurityDescriptorOwner(pSD, pSID, TRUE));
         VERIFY(SetSecurityDescriptorGroup(pSD, pSID, TRUE));
     
         //
         // Convert to self-relative
         //
         PSECURITY_DESCRIPTOR pSDSelfRelative = NULL;
         DWORD dwSize = 0L;
         MakeSelfRelativeSD(pSD, pSDSelfRelative, &dwSize);
         pSDSelfRelative = AllocMem(dwSize);
         if (pSDSelfRelative != NULL)
         {
            MakeSelfRelativeSD(pSD, pSDSelfRelative, &dwSize);

            //
            // Blob takes ownership 
            //
            blob.SetValue(dwSize, (PBYTE)pSDSelfRelative, FALSE);
         }

         //
         // Clean up
         //
         FreeMem(pSD);
         FreeSid(pSID);
    }

    return fAclDirty;
}



DWORD
BuildAclOblistFromBlob(
    IN  CBlob & blob,
    OUT CObListPlus & oblSID
    )
/*++

Routine Description:

    Build an oblist of access entries from a security descriptor blob

Arguments:

    CBlob & blob            : Input blob
    CObListPlus & oblSID    : Output oblist of access entries
    
Return Value:

    Error return code

--*/
{
    PSECURITY_DESCRIPTOR pSD = NULL;

    if (!blob.IsEmpty())
    {
        pSD = (PSECURITY_DESCRIPTOR)blob.GetData();
    }

    if (pSD == NULL)
    {
        //
        // Empty...
        //
        return ERROR_SUCCESS;
    }

    if (!IsValidSecurityDescriptor(pSD))
    {
        return ::GetLastError();
    }

    ASSERT(GetSecurityDescriptorLength(pSD) == blob.GetSize());

    PACL pacl = NULL;
    BOOL fDaclPresent = FALSE;
    BOOL fDaclDef= FALSE;

    VERIFY(GetSecurityDescriptorDacl(pSD, &fDaclPresent, &pacl, &fDaclDef));

    if (!fDaclPresent || pacl == NULL)
    {
        return ERROR_SUCCESS;
    }

    if (!IsValidAcl(pacl))
    {
        return GetLastError();
    }

    CError err;

    for (WORD w = 0; w < pacl->AceCount; ++w)
    {
        PVOID pAce;

        if (GetAce(pacl, w, &pAce))
        {
            CAccessEntry * pEntry = new CAccessEntry(pAce, TRUE);

            if (pEntry)
            {
                oblSID.AddTail(pEntry);
            }
            else
            {
                TRACEEOLID("BuildAclOblistFromBlob: OOM");
                err = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
        }
        else
        {
            //
            // Save last error, but continue
            //
            err.GetLastWinError();
        }
    }

    //
    // Return last error
    //
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\acl.h ===
#ifndef _ACL_H_
#define _ACL_H_


BOOL COMDLL SupportsSecurityACLs(LPCTSTR path);
BOOL COMDLL IsLocalComputer(IN LPCTSTR lpszComputer);
void COMDLL GetFullPathLocalOrRemote(IN LPCTSTR lpszServer,IN LPCTSTR lpszDir,OUT CString& cstrPath);

#endif // _ACL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\acl.cpp ===
#include "stdafx.h"
#include "common.h"
#include "windns.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif
#define new DEBUG_NEW

extern HINSTANCE hDLLInstance;

// NOTE: this function only handles limited cases, e.g., no ip address
BOOL IsLocalComputer(IN LPCTSTR lpszComputer)
{
    if (!lpszComputer || !*lpszComputer)
    {
        return TRUE;
    }

    if ( _tcslen(lpszComputer) > 2 && *lpszComputer == _T('\\') && *(lpszComputer + 1) == _T('\\') )
    {
        lpszComputer += 2;
    }

    BOOL    bReturn = FALSE;
    DWORD   dwErr = 0;
    TCHAR   szBuffer[DNS_MAX_NAME_BUFFER_LENGTH];
    DWORD   dwSize = DNS_MAX_NAME_BUFFER_LENGTH;

    // 1st: compare against local Netbios computer name
    if ( !GetComputerNameEx(ComputerNameNetBIOS, szBuffer, &dwSize) )
    {
        dwErr = GetLastError();
    }
    else
    {
        bReturn = (0 == lstrcmpi(szBuffer, lpszComputer));
        if (!bReturn)
        {
            // 2nd: compare against local Dns computer name 
            dwSize = DNS_MAX_NAME_BUFFER_LENGTH;
            if (GetComputerNameEx(ComputerNameDnsFullyQualified, szBuffer, &dwSize))
            {
                bReturn = (0 == lstrcmpi(szBuffer, lpszComputer));
            }
            else
            {
                dwErr = GetLastError();
            }
        }
    }

    if (dwErr)
    {
        TRACE(_T("IsLocalComputer dwErr = %x\n"), dwErr);
    }

    return bReturn;
}

void GetFullPathLocalOrRemote(
    IN  LPCTSTR   lpszServer,
    IN  LPCTSTR   lpszDir,
    OUT CString&  cstrPath
)
{
    ASSERT(lpszDir && *lpszDir);

    if (IsLocalComputer(lpszServer))
    {
        cstrPath = lpszDir;
    }
    else
    {
        // Check if it's already pointing to a share...
        if (*lpszDir == _T('\\') || *(lpszDir + 1) == _T('\\'))
        {
            cstrPath = lpszDir;
        }
        else
        {
            if (*lpszServer != _T('\\') || *(lpszServer + 1) != _T('\\'))
            {
                cstrPath = _T("\\\\");
                cstrPath += lpszServer;
            }
            else
            {
                cstrPath = lpszServer;
            }

            cstrPath += _T("\\");
            cstrPath += lpszDir;
            int i = cstrPath.Find(_T(':'));
            ASSERT(-1 != i);
            cstrPath.SetAt(i, _T('$'));
        }
    }
}

BOOL SupportsSecurityACLs(LPCTSTR path)
{
    const UINT BUFF_LEN = 32;       // Should be large enough to hold the volume and the file system type
    // set to true by default, since most likely it will be
    // and if this function fails, then no big deal...
    BOOL  bReturn = TRUE;           
    TCHAR root[MAX_PATH];
	DWORD len = 0;
	DWORD flg	= 0;
	TCHAR fs[BUFF_LEN];

    StrCpyN(root, path, MAX_PATH);
    if (PathIsUNC(root))
    {
        LPTSTR p = NULL;
        while (!PathIsUNCServerShare(root))
        {
            p = StrRChr(root, p, _T('\\'));
            if (p != NULL)
                *p = 0;
        }
        StrCat(root, _T("\\"));
//        NET_API_STATUS rc = NetShareGetInfo(server, share, 
        if (GetVolumeInformation(root, NULL, 0, NULL, &len, &flg, fs, BUFF_LEN))
        {
            bReturn = 0 != (flg & FS_PERSISTENT_ACLS);
        }
        else
        {
            DWORD err = GetLastError();
        }
    }
    else
    {
        if (PathStripToRoot(root))
        {
	        if (GetVolumeInformation(root, NULL, 0, NULL, &len, &flg, fs, BUFF_LEN))
            {
                bReturn = 0 != (flg & FS_PERSISTENT_ACLS);
            }
        }
    }
	return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\balloon.h ===
#ifndef _BALLOON_H_
#define _BALLOON_H_


LRESULT Edit_ShowBalloonTipHandler(HWND hwndControl,LPCTSTR szText);
void Edit_HideBalloonTipHandler(void);

#endif // _BALLOON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\balloon.cpp ===
#include "stdafx.h"
#include "common.h"
#include "bidi.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif
#define new DEBUG_NEW

extern HINSTANCE hDLLInstance;

#define ID_MY_EDITTIMER           10007
#define EDIT_TIPTIMEOUT           10000
// 2.0 seconds
#define EDIT_TIPTIMEOUT_LOSTFOCUS  20000000

inline UINT64 FILETIMEToUINT64( const FILETIME & FileTime )
{
    ULARGE_INTEGER LargeInteger;
    LargeInteger.HighPart = FileTime.dwHighDateTime;
    LargeInteger.LowPart = FileTime.dwLowDateTime;
    return LargeInteger.QuadPart;
}

inline FILETIME UINT64ToFILETIME( UINT64 Int64Value )
{
    ULARGE_INTEGER LargeInteger;
    LargeInteger.QuadPart = Int64Value;

    FILETIME FileTime;
    FileTime.dwHighDateTime = LargeInteger.HighPart;
    FileTime.dwLowDateTime = LargeInteger.LowPart;

    return FileTime;
}

typedef struct tagBALLOONCONTROLINFO
{
    HWND hwndControl;
    HWND hwndBalloon;
	FILETIME ftStart;
} BALLOONCONTROLINFO, *PBALLOONCONTROLINFO;

// global
BALLOONCONTROLINFO g_MyBalloonInfo;

// forwards
LRESULT CALLBACK Edit_BalloonTipParentSubclassProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam, UINT_PTR uID, ULONG_PTR dwRefData);


BOOL IsSupportTooltips(void)
{
    BOOL bReturn = FALSE;
    HINSTANCE hComCtl = NULL;
    //
    //  Comctl32.dll must be 5.80 or greater to use balloon tips.  We check the dll version 
    //  by calling DllGetVersion in comctl32.dll.
    //
    hComCtl = LoadLibraryExA("comctl32.dll", NULL, 0);
    if (hComCtl != NULL)
    {
        typedef HRESULT (*DLLGETVERSIONPROC)(DLLVERSIONINFO* lpdvi);
        DLLGETVERSIONPROC fnDllGetVersion = (DLLGETVERSIONPROC) GetProcAddress(hComCtl,"DllGetVersion");
        if (NULL == fnDllGetVersion)
        {
            //
            //  DllGetVersion does not exist in Comctl32.dll.  This mean the version is too old so we need to fail.
            //
            goto IsSupportTooltips_Exit;
        }
        else
        {
            DLLVERSIONINFO dvi;

            ZeroMemory(&dvi, sizeof(dvi));
            dvi.cbSize = sizeof(dvi);

            HRESULT hResult = (*fnDllGetVersion)(&dvi);

            if (SUCCEEDED(hResult))
            {
                //
                //  Take the version returned and compare it to 5.80.
                //
                if (MAKELONG(dvi.dwMinorVersion,dvi.dwMajorVersion) < MAKELONG(80,5))
                {
                    //CMTRACE2(TEXT("COMCTL32.DLL version - %d.%d"),dvi.dwMajorVersion,dvi.dwMinorVersion);
                    //CMTRACE1(TEXT("COMCTL32.DLL MAKELONG - %li"),MAKELONG(dvi.dwMinorVersion,dvi.dwMajorVersion));
                    //CMTRACE1(TEXT("Required minimum MAKELONG - %li"),MAKELONG(80,5));
					
                    // Wrong DLL version
                    bReturn = FALSE;
                    goto IsSupportTooltips_Exit;
                }
                
                // version is larger than 5.80
                bReturn = TRUE;
            }
        }
    }

IsSupportTooltips_Exit:
    if (hComCtl)
    {
        FreeLibrary(hComCtl);hComCtl=NULL;
    }
    return bReturn;
}

LRESULT Edit_BalloonTipSubclassParents(PBALLOONCONTROLINFO pi)
{
    //if (pMyBalloonInfo)
    //{
    //    // Subclass all windows along the parent chain from the edit control
    //    // and in the same thread (can only subclass windows with same thread affinity)
    //    HWND  hwndParent = GetAncestor(pMyBalloonInfo->hwndControl, GA_PARENT);
    //    DWORD dwTid      = GetWindowThreadProcessId(pMyBalloonInfo->hwndControl, NULL);

    //    while (hwndParent && (dwTid == GetWindowThreadProcessId(hwndParent, NULL)))
    //    {
    //        SetWindowSubclass(hwndParent, Edit_BalloonTipParentSubclassProc, (UINT_PTR)pMyBalloonInfo->hwndControl, (DWORD_PTR) pMyBalloonInfo);
    //        hwndParent = GetAncestor(hwndParent, GA_PARENT);
    //    }
    //}
    //return TRUE;
    return SetWindowSubclass(pi->hwndControl, 
        Edit_BalloonTipParentSubclassProc, (UINT_PTR)pi->hwndControl, (DWORD_PTR)pi);
}

HWND Edit_BalloonTipRemoveSubclasses(HWND hwndControl)
{
    //HWND  hwndParent  = GetAncestor(hwndControl, GA_PARENT);
    //HWND  hwndTopMost = NULL;
    //DWORD dwTid       = GetWindowThreadProcessId(hwndControl, NULL);

    //while (hwndParent && (dwTid == GetWindowThreadProcessId(hwndParent, NULL)))
    //{
    //    RemoveWindowSubclass(hwndParent, Edit_BalloonTipParentSubclassProc, (UINT_PTR) NULL);
    //    hwndTopMost = hwndParent;
    //    hwndParent = GetAncestor(hwndParent, GA_PARENT);
    //}
    //return hwndTopMost;
    RemoveWindowSubclass(hwndControl, Edit_BalloonTipParentSubclassProc, (UINT_PTR)hwndControl); 
    return NULL;
}

LRESULT Edit_HideBalloonTipHandler(PBALLOONCONTROLINFO pi)
{
    HWND hwndParent = 0;

    if (pi)
    {
        KillTimer(pi->hwndControl, ID_MY_EDITTIMER);
        if (SendMessage(pi->hwndBalloon, TTM_ENUMTOOLS, 0, (LPARAM)0))
        {
            SendMessage(pi->hwndBalloon, TTM_DELTOOL, 0, (LPARAM)0);
        }
        SendMessage(pi->hwndBalloon, TTM_TRACKACTIVATE, FALSE, 0);
        DestroyWindow(pi->hwndBalloon);
        pi->hwndBalloon = NULL;
        RemoveWindowSubclass(pi->hwndControl, Edit_BalloonTipParentSubclassProc, (UINT_PTR)pi->hwndControl); 

        //hwndParent = Edit_BalloonTipRemoveSubclasses(pi->hwndControl);
        //if (hwndParent && IsWindow(hwndParent))
        //{
        //    InvalidateRect(hwndParent, NULL, TRUE);
        //    UpdateWindow(hwndParent);
        //}

        //if (hwndParent != pMyBalloonControl->hwndControl)
        //{
        //    RedrawWindow(pMyBalloonControl->hwndControl, NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW);
        //}
    }

    return TRUE;
}

void Edit_HideBalloonTipHandler(void)
{
    if (g_MyBalloonInfo.hwndBalloon)
    {
        Edit_HideBalloonTipHandler(&g_MyBalloonInfo);
    }
}

LRESULT CALLBACK 
Edit_BalloonTipParentSubclassProc(
    HWND hDlg, 
    UINT uMessage, 
    WPARAM wParam, 
    LPARAM lParam, 
    UINT_PTR uID, 
    ULONG_PTR dwRefData)
{
    
    PBALLOONCONTROLINFO pi = (PBALLOONCONTROLINFO) dwRefData;
    switch (uMessage)
    {
    case WM_MOVE:
    case WM_SIZING:
    case WM_LBUTTONDOWN:
    case WM_LBUTTONDBLCLK:
    case WM_MBUTTONDOWN:
    case WM_MBUTTONDBLCLK:
    case WM_RBUTTONDOWN:
    case WM_RBUTTONDBLCLK:
    case WM_KEYDOWN:
    case WM_CHAR:
        if (pi->hwndBalloon)
        {
            Edit_HideBalloonTipHandler(pi);
        }
        break;
	case WM_KILLFOCUS:
		/*
		// dont do this for common build
		// just for common2 build
		if (pi->hwndBalloon)
		{
			FILETIME ftNow;
			::GetSystemTimeAsFileTime(&ftNow);

			// Check if at least 2 seconds have gone by
			// if they have not then show for at least that long
			if ((FILETIMEToUINT64(ftNow) - FILETIMEToUINT64(g_MyBalloonInfo.ftStart)) > EDIT_TIPTIMEOUT_LOSTFOCUS)
			{
				// Displayed for longer than 2 seconds
				// that's long enough
				Edit_HideBalloonTipHandler(pi);
			}
			else
			{
				// special case here
				// set timeout to kill the tip in 2 seconds
				KillTimer(g_MyBalloonInfo.hwndControl, ID_MY_EDITTIMER);
				SetTimer(g_MyBalloonInfo.hwndControl, ID_MY_EDITTIMER, EDIT_TIPTIMEOUT_LOSTFOCUS / 10000, NULL);
				//Edit_HideBalloonTipHandler(pi);
			}
		}
		*/
        if (pi->hwndBalloon)
        {
            Edit_HideBalloonTipHandler(pi);
        }
        break;

    case WM_TIMER:
        if (ID_MY_EDITTIMER == wParam)
        {
            Edit_HideBalloonTipHandler(pi);
            return 0;
        }
        break;

    case WM_DESTROY:
        // Clean up subclass
        RemoveWindowSubclass(hDlg, Edit_BalloonTipParentSubclassProc, uID);
        break;

    default:
        break;
    }
    return DefSubclassProc(hDlg, uMessage, wParam, lParam);
}


LRESULT Edit_TrackBalloonTip(PBALLOONCONTROLINFO pMyBalloonControl)
{
    if (pMyBalloonControl)
    {
        DWORD dwPackedCoords;
        HDC   hdc = GetDC(pMyBalloonControl->hwndControl);
        RECT  rcWindowCaret;
        RECT  rcWindowControl;
        POINT ptBalloonSpear;
        ptBalloonSpear.x = 0;
        ptBalloonSpear.y = 0;
        POINT ptCaret;
        ptCaret.x = 0;
        ptCaret.y = 0;
    
        //
        // get the average size of one character
        //
        int cxCharOffset = 0;
        //cxCharOffset = TESTFLAG(GET_EXSTYLE(ped), WS_EX_RTLREADING) ? -ped->aveCharWidth : ped->aveCharWidth;
        TEXTMETRIC tm;
        GetTextMetrics(hdc, &tm);
        cxCharOffset = tm.tmAveCharWidth / 2;

        //
        // Get current caret position.
        //
        GetCaretPos( (POINT FAR*)& ptCaret);
        GetClientRect(pMyBalloonControl->hwndControl,&rcWindowCaret);
        ptBalloonSpear.x = ptCaret.x + cxCharOffset;
        ptBalloonSpear.y = rcWindowCaret.top + (rcWindowCaret.bottom - rcWindowCaret.top) / 2 ;

        //
        // Translate to window coords
        //
        GetWindowRect(pMyBalloonControl->hwndControl, &rcWindowControl);
        ptBalloonSpear.x += rcWindowControl.left;
        ptBalloonSpear.y += rcWindowControl.top;

        //
        // Position the tip stem at the caret position
        //
        dwPackedCoords = (DWORD) MAKELONG(ptBalloonSpear.x, ptBalloonSpear.y);
        SendMessage(pMyBalloonControl->hwndBalloon, TTM_TRACKPOSITION, 0, (LPARAM) dwPackedCoords);

        ReleaseDC(pMyBalloonControl->hwndBalloon,hdc);
    }
    return 1;
}

VOID CALLBACK MyBalloonTimerProc(HWND hwnd,UINT uMsg,UINT idEvent,DWORD dwTime)
{
    Edit_HideBalloonTipHandler(&g_MyBalloonInfo);
}

#define LIMITINPUTTIMERID       472
LRESULT Edit_ShowBalloonTipHandler(HWND hwndControl, LPCTSTR szText)
{
    LRESULT lResult = FALSE;

    // Close any other subclasses Balloon that could be poped up.
    // Kill any Tooltip that could have been there
    // from the SHLimitInputEditWithFlags call...
    // we don't want this here since we could
    // be poping up another Tooltip of our own...
    // And thus user will have two...
    ::SendMessage(hwndControl, WM_TIMER, LIMITINPUTTIMERID, 0);

    if (g_MyBalloonInfo.hwndBalloon)
    {
        Edit_HideBalloonTipHandler(&g_MyBalloonInfo);
    }

    g_MyBalloonInfo.hwndControl = hwndControl;
    KillTimer(g_MyBalloonInfo.hwndControl , ID_MY_EDITTIMER);

    g_MyBalloonInfo.hwndBalloon = CreateWindowEx(
                            (IsBiDiLocalizedSystem() ? WS_EX_LAYOUTRTL : 0), 
                            TOOLTIPS_CLASS, NULL,
                            WS_POPUP | TTS_NOPREFIX | TTS_BALLOON,
                            CW_USEDEFAULT, CW_USEDEFAULT,
                            CW_USEDEFAULT, CW_USEDEFAULT,
                            hwndControl, NULL, hDLLInstance,
                            NULL);
    if (NULL != g_MyBalloonInfo.hwndBalloon)
    {
        TOOLINFO ti = {0};

        ti.cbSize = TTTOOLINFOW_V2_SIZE;
        ti.uFlags = TTF_IDISHWND | TTF_TRACK | TTF_SUBCLASS; // not sure if we need TTF_SUBCLASS
        ti.hwnd   = hwndControl;
        ti.uId    = (WPARAM) g_MyBalloonInfo.hwndBalloon;
        ti.lpszText = (LPTSTR) szText;

        // set the version so we can have non buggy mouse event forwarding
        SendMessage(g_MyBalloonInfo.hwndBalloon, CCM_SETVERSION, COMCTL32_VERSION, 0);
        SendMessage(g_MyBalloonInfo.hwndBalloon, TTM_ADDTOOL, 0, (LPARAM)&ti);
        SendMessage(g_MyBalloonInfo.hwndBalloon, TTM_SETMAXTIPWIDTH, 0, 300);
        //SendMessage(g_MyBalloonInfo.hwndBalloon, TTM_SETTITLE, (WPARAM) 0, (LPARAM) "");

		// SetFocus must happen before Edit_TrackBalloonTip
		// for somereason, GetCaretPos() will return different value otherwise.
		SetFocus(g_MyBalloonInfo.hwndControl);
        Edit_TrackBalloonTip(&g_MyBalloonInfo);
        SendMessage(g_MyBalloonInfo.hwndBalloon, TTM_TRACKACTIVATE, (WPARAM) TRUE, (LPARAM)&ti);

//        Edit_BalloonTipSubclassParents(&g_MyBalloonInfo);
        if (SetWindowSubclass(g_MyBalloonInfo.hwndControl, 
                Edit_BalloonTipParentSubclassProc, (UINT_PTR)g_MyBalloonInfo.hwndControl, 
                (DWORD_PTR)&g_MyBalloonInfo)
           )
        {
            //
            // set timeout to kill the tip
            //
            KillTimer(g_MyBalloonInfo.hwndControl, ID_MY_EDITTIMER);
			::GetSystemTimeAsFileTime(&g_MyBalloonInfo.ftStart);
            SetTimer(g_MyBalloonInfo.hwndControl, ID_MY_EDITTIMER, EDIT_TIPTIMEOUT, NULL/*(TIMERPROC) MyBalloonTimerProc*/);
            lResult = TRUE;
        }
    }

    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\accentry.h ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        accentry.h

   Abstract:

        CAccessEntry class definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:
        
        1/9/2000     sergeia    Cleaned out from usrbrows.h to left only CAccessEntry

--*/

#ifndef _ACCENTRY_H
#define _ACCENTRY_H

#ifndef _SHLOBJ_H_
#include <shlobj.h>
#endif // _SHLOBJ_H_

class COMDLL CAccessEntry : public CObjectPlus
/*++

Class Description:

    An access description entry, containing a SID and ACCESS mask
    of rights specifically granted.

Public Interface:

    LookupAccountSid        : Resolve account name to SID

    CAccessEntry            : Constructors
    ~CAccessEntry           : Destructor

    ResolveSID              : Resolve account name to SID
    operator ==             : Comparison operator
    AddPermissions          : Add to access mask
    RemovePermissions       : Remove from access mask
    MarkEntryAsNew          : Flag object as new
    MarkEntryAsClean        : Remove dirty flag
    QueryUserName           : Get the account name
    QueryPictureID          : Get 0-based bitmap offset for account
    GetSid                  : Get the SID
    QueryAccessMask         : Get the raw Access granted bits
    IsDirty                 : Determine if item has changed
    IsDeleted               : Determine if item is flagged for deletion
    IsVisible               : Determine if item should be shown in listbox
    FlagForDeletion         : Flag object for deletion or reset that flag
    IsSIDResolved           : Return TRUE if the SID has already been resolved
    HasAppropriateAccess    : Compare access bits to see if the objects has
                              specific permissions
    HasSomeAccess           : Check to see if object has at least one
                              permission bit set.
    IsDeletable             : Determine if object can be deleted

--*/
{
public:
    //
    // Helper function to look up account sid
    //
    static BOOL LookupAccountSid(
        IN  CString & str,
        OUT int & nPictureID,
        OUT PSID pSid,
        IN  LPCTSTR lpstrSystemName = NULL
        );

//
// Construction/Destruction
//
public:
    CAccessEntry(
        IN LPVOID pAce,
        IN BOOL fResolveSID = FALSE
        );

    CAccessEntry(
        IN ACCESS_MASK accPermissions,
        IN PSID pSid,
        IN LPCTSTR lpstrSystemName = NULL,
        IN BOOL fResolveSID = FALSE
        );

    CAccessEntry(
        IN PSID pSid,
        IN LPCTSTR pszUserName,
        IN LPCTSTR pszClassName
        );

    CAccessEntry(
        IN CAccessEntry& ae
        );

    ~CAccessEntry();

//
// Operations
//
public:
    //void SetAccessMask(LPACCESS_ENTRY lpAccessEntry);
    BOOL ResolveSID();
    BOOL operator ==(const CAccessEntry & acc) const;
    BOOL operator ==(const PSID pSid) const;
    void AddPermissions(ACCESS_MASK accnewPermissions);
    void RemovePermissions(ACCESS_MASK accPermissions);
    void MarkEntryAsNew();
    void MarkEntryAsClean();
    void MarkEntryAsChanged();

//
// Access Functions
//
public:
    LPCTSTR QueryUserName() const;

    //
    // The "picture" id is the 0-based index of the
    // bitmap that goes with this entry, and which
    // is used for display in the listbox.
    //
    int QueryPictureID() const;

    PSID GetSid();

    ACCESS_MASK QueryAccessMask() const;

    //
    // Check to see if this entry has undergone
    // any changes since we called it up
    //
    BOOL IsDirty() const;

    BOOL IsDeleted() const;

    BOOL IsVisible() const;

    void FlagForDeletion(
        IN BOOL fDelete = TRUE
        );

    //
    // Check to see if we've already looked up the
    // name of this SID
    //
    BOOL IsSIDResolved() const;

    //
    // Check to see if the add flag has been set for this
    // entry.
    //
    /*
    BOOL IsNew() const;

    //
    // Check to see if the update flag has been set for this
    // entry.
    //
    BOOL IsDifferent() const;
    */

    //
    // See if the entry has the access mask required.
    //
    BOOL HasAppropriateAccess(ACCESS_MASK accTargetMask) const;

    //
    // Check to see if the entry has at least some
    // privileges (if it doesn't, it should be deleted)
    //
    BOOL HasSomeAccess() const;

    //
    // See if this is a deletable entry
    //
    BOOL IsDeletable() const;

private:
    ACCESS_MASK m_accMask;
    CString m_strUserName;
    LPTSTR m_lpstrSystemName;
    PSID m_pSid;
    BOOL m_fDirty;
    BOOL m_fSIDResolved;
    BOOL m_fDeletable;
    BOOL m_fInvisible;
    BOOL m_fDeleted;
    int m_nPictureID;
    int m_fUpdates;
};



//
// Helper functions
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



//
// Convert an oblist of CAccessEntry objects to a blob
//
BOOL COMDLL BuildAclBlob(
    IN  CObListPlus & oblSID,
    OUT CBlob & blob
    );

//
// Reverse the above.  Build an oblist of CAccessEntry lists from
// a blob.
//
DWORD COMDLL BuildAclOblistFromBlob(
    IN  CBlob & blob,
    OUT CObListPlus & oblSID
    );

//
// Build a blob representing an ACL with the local domain group
//
DWORD COMDLL BuildAdminAclBlob(
    OUT CBlob & blob
    );


//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline int CAccessEntry::QueryPictureID() const
{
    ASSERT(m_fSIDResolved);
    return m_nPictureID;
}

inline LPCTSTR CAccessEntry::QueryUserName() const
{
    return m_strUserName;
}

inline PSID CAccessEntry::GetSid()
{
    return m_pSid;
}

inline ACCESS_MASK CAccessEntry::QueryAccessMask() const
{
    return m_accMask;
}

inline BOOL CAccessEntry::IsDirty() const
{
    return m_fDirty;
}

inline BOOL CAccessEntry::IsDeleted() const
{
    return m_fDeleted;
}

inline BOOL CAccessEntry::IsVisible() const
{
    return !m_fInvisible;
}

inline void CAccessEntry::FlagForDeletion(
    IN BOOL fDelete
    )
{
    m_fDirty = TRUE;
    m_fDeleted = fDelete;
}

inline BOOL CAccessEntry::IsSIDResolved() const
{
    return m_fSIDResolved;
}

/*
inline BOOL CAccessEntry::IsNew() const
{
    return (m_fUpdates & UPD_ADDED) != 0;
}

inline BOOL CAccessEntry::IsDifferent() const
{
    return (m_fUpdates & UPD_CHANGED) != 0;
}

inline void CAccessEntry::SetAccessMask(
    IN LPACCESS_ENTRY lpAccessEntry
    )
{
    m_accMask = lpAccessEntry->AccessRights;
}

*/

inline BOOL CAccessEntry::HasAppropriateAccess(
    IN ACCESS_MASK accTargetMask
    ) const
{
    return (m_accMask & accTargetMask) == accTargetMask;
}

inline BOOL CAccessEntry::HasSomeAccess() const
{
    return m_accMask;
}

inline BOOL CAccessEntry::IsDeletable() const
{
    return m_fDeletable;
}

inline BOOL  CAccessEntry::operator ==(
    IN const CAccessEntry & acc
    ) const
{
    return ::EqualSid(acc.m_pSid, m_pSid);
}

inline BOOL CAccessEntry::operator ==(
    IN const PSID pSid
    ) const
{
    return ::EqualSid(pSid, m_pSid);
}

inline void  CAccessEntry::MarkEntryAsNew()
{
    m_fDirty = TRUE;
    //m_fUpdates |= UPD_ADDED;
}

inline void CAccessEntry::MarkEntryAsClean()
{
    m_fDirty = FALSE;
    //m_fUpdates = UPD_NONE;
}

inline void CAccessEntry::MarkEntryAsChanged()
{
    m_fDirty = TRUE;
    //m_fUpdates = UPD_CHANGED;
}

#endif // _ACCENTRY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\bidi.h ===
#ifndef _BIDI_H_
#define _BIDI_H_


BOOL COMDLL AFXAPI 
IsBiDiLocalizedSystem(void);

#endif // _BIDI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\coauth.h ===
BOOL EqualAuthInfo(COAUTHINFO* pAuthInfo,COAUTHINFO* pAuthInfoOther);

/*
HRESULT CopyAuthIdentity(COAUTHIDENTITY * pAuthIdentSrc,COAUTHIDENTITY ** ppAuthIdentDest);
HRESULT CopyAuthInfo(COAUTHINFO * pAuthInfoSrc,COAUTHINFO ** ppAuthInfoDest);
HRESULT CopyServerInfo(COSERVERINFO * pServerInfoSrc,COSERVERINFO ** ppServerInfoDest);
*/

HRESULT CopyAuthIdentityStruct(COAUTHIDENTITY * pAuthIdentSrc,COAUTHIDENTITY * pAuthIdentDest);
HRESULT CopyAuthInfoStruct(COAUTHINFO * pAuthInfoSrc,COAUTHINFO * pAuthInfoDest);
HRESULT CopyServerInfoStruct(COSERVERINFO * pServerInfoSrc,COSERVERINFO * pServerInfoDest);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\coauth.cpp ===
#include "stdafx.h"
#include "common.h"
#include "coauth.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif
#define new DEBUG_NEW

BOOL
EqualAuthInfo(
             COAUTHINFO*         pAuthInfo,
             COAUTHINFO*         pAuthInfoOther)
{
    if ( pAuthInfo && pAuthInfoOther )
    {
        if ( (pAuthInfo->dwAuthnSvc != pAuthInfoOther->dwAuthnSvc) ||
             (pAuthInfo->dwAuthzSvc != pAuthInfoOther->dwAuthzSvc) ||
             (pAuthInfo->dwAuthnLevel != pAuthInfoOther->dwAuthnLevel) ||
             (pAuthInfo->dwImpersonationLevel != pAuthInfoOther->dwImpersonationLevel) ||
             (pAuthInfo->dwCapabilities != pAuthInfoOther->dwCapabilities) )
        {
            return FALSE;
        }

        // only compare pwszServerPrincName's if they're both specified
        if (pAuthInfo->pwszServerPrincName && pAuthInfoOther->pwszServerPrincName)
        {
            if ( lstrcmpW(pAuthInfo->pwszServerPrincName,
                          pAuthInfoOther->pwszServerPrincName) != 0 )
            {
                return FALSE;
            }
        }
        else
        {
            // if one was NULL, both should be NULL for equality
            if (pAuthInfo->pwszServerPrincName != pAuthInfoOther->pwszServerPrincName)
            {
                return FALSE;
            }
        }
        // we never cache authid, so one of them must be NULL
        ASSERT(!(pAuthInfo->pAuthIdentityData && pAuthInfoOther->pAuthIdentityData));
        if (pAuthInfo->pAuthIdentityData || pAuthInfoOther->pAuthIdentityData) 
        {
           return FALSE;
        }
    }
    else
    {
        if ( pAuthInfo != pAuthInfoOther )
        {
            return FALSE;
        }
    }

    return TRUE;
}

/*
HRESULT
CopyAuthIdentity(
                IN  COAUTHIDENTITY *    pAuthIdentSrc,
                IN  COAUTHIDENTITY **   ppAuthIdentDest
                )
{
    HRESULT hr = E_OUTOFMEMORY;
    ULONG ulCharLen = 1;
    COAUTHIDENTITY  *pAuthIdentTemp = NULL;

    *ppAuthIdentDest = NULL;
    
    // Guard against both being set, although presumably this would have
    // caused grief before we got to this point.
    if ((pAuthIdentSrc->Flags & SEC_WINNT_AUTH_IDENTITY_UNICODE) &&
        (pAuthIdentSrc->Flags & SEC_WINNT_AUTH_IDENTITY_ANSI))
    {
        ASSERT(0 && "Both string type flags were set!");
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    if (pAuthIdentSrc->Flags & SEC_WINNT_AUTH_IDENTITY_UNICODE)
    {
        ulCharLen = sizeof(WCHAR);
    }
    else if (pAuthIdentSrc->Flags & SEC_WINNT_AUTH_IDENTITY_ANSI)
    {
        ulCharLen = sizeof(CHAR);
    }
    else
    {
       // The user didn't specify either string bit? How did we get here?
        ASSERT(0 && "String type flag was not set!");
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    pAuthIdentTemp = (COAUTHIDENTITY*) AllocMem(sizeof(COAUTHIDENTITY));
    if (!pAuthIdentTemp)
        goto Cleanup;

    CopyMemory(pAuthIdentTemp, pAuthIdentSrc, sizeof(COAUTHIDENTITY));

    // Strings need to be allocated individually and copied
    pAuthIdentTemp->User = pAuthIdentTemp->Domain = pAuthIdentTemp->Password = NULL;

    if (pAuthIdentSrc->User)
    {
        pAuthIdentTemp->User = (USHORT *)AllocMem((pAuthIdentTemp->UserLength+1) * ulCharLen);

        if (!pAuthIdentTemp->User)
            goto Cleanup;

        CopyMemory(pAuthIdentTemp->User, pAuthIdentSrc->User, (pAuthIdentTemp->UserLength+1) * ulCharLen);
    }

    if (pAuthIdentSrc->Domain)
    {
        pAuthIdentTemp->Domain = (USHORT *)AllocMem((pAuthIdentTemp->DomainLength+1) * ulCharLen);

        if (!pAuthIdentTemp->Domain)
            goto Cleanup;

        CopyMemory(pAuthIdentTemp->Domain, pAuthIdentSrc->Domain, (pAuthIdentTemp->DomainLength+1) * ulCharLen);
    }
            
    if (pAuthIdentSrc->Password)
    {
        pAuthIdentTemp->Password = (USHORT *)AllocMem((pAuthIdentTemp->PasswordLength+1) * ulCharLen);

        if (!pAuthIdentTemp->Password)
            goto Cleanup;

        CopyMemory(pAuthIdentTemp->Password, pAuthIdentSrc->Password, (pAuthIdentTemp->PasswordLength+1) * ulCharLen);
    }
    

    hr = S_OK;

Cleanup:
    if (SUCCEEDED(hr))
    {
        *ppAuthIdentDest = pAuthIdentTemp;
    }
    else
    {
        if (pAuthIdentTemp)
        {
            FreeMem(pAuthIdentTemp);
        }
    }

    return hr;
}

HRESULT
CopyAuthInfo(
            IN  COAUTHINFO *    pAuthInfoSrc,
            IN  COAUTHINFO **   ppAuthInfoDest
            )
{
    HRESULT hr = E_OUTOFMEMORY;
    COAUTHINFO   *pAuthInfoTemp = NULL;
    
    *ppAuthInfoDest = NULL;

    if (pAuthInfoSrc == NULL)
    {
       return S_OK;
    }

    pAuthInfoTemp = (COAUTHINFO*)AllocMem(sizeof(COAUTHINFO));

    if (!pAuthInfoTemp)
        goto Cleanup;

    CopyMemory(pAuthInfoTemp, pAuthInfoSrc, sizeof(COAUTHINFO));

    // We need to allocate these fields and make a copy
    pAuthInfoTemp->pwszServerPrincName = NULL;
    pAuthInfoTemp->pAuthIdentityData = NULL;

    // only alloc space for  pwszServerPrincName if its non-null
    if (pAuthInfoSrc->pwszServerPrincName)
    {
        pAuthInfoTemp->pwszServerPrincName = 
            (LPWSTR) AllocMem((lstrlenW(pAuthInfoSrc->pwszServerPrincName) + 1) * sizeof(WCHAR));

        if (!pAuthInfoTemp->pwszServerPrincName)
            goto Cleanup;
        
        lstrcpyW(pAuthInfoTemp->pwszServerPrincName, pAuthInfoSrc->pwszServerPrincName);
    }
    
    // copy the AuthIdentity if its non-null
    if (pAuthInfoSrc->pAuthIdentityData)
    {
        hr = CopyAuthIdentity(pAuthInfoSrc->pAuthIdentityData, &pAuthInfoTemp->pAuthIdentityData);
        if (FAILED(hr))
            goto Cleanup;
    }
    hr = S_OK;
    
Cleanup:

    if (SUCCEEDED(hr))
    {
        *ppAuthInfoDest = pAuthInfoTemp;
    }
    else if (pAuthInfoTemp)
    {
        FreeMem(pAuthInfoTemp);
    }

    return hr;
}

HRESULT
CopyServerInfo(
            IN  COSERVERINFO *    pServerInfoSrc,
            IN  COSERVERINFO **   ppServerInfoDest
            )
{
    HRESULT hr = E_OUTOFMEMORY;
    COSERVERINFO   *pServerInfoTemp = NULL;
    
    *ppServerInfoDest = NULL;

    if (pServerInfoSrc == NULL)
    {
       return S_OK;
    }

    pServerInfoTemp = (COSERVERINFO*)AllocMem(sizeof(COSERVERINFO));
    if (!pServerInfoTemp)
        goto Cleanup;

    CopyMemory(pServerInfoTemp, pServerInfoSrc, sizeof(COSERVERINFO));

    // We need to allocate these fields and make a copy
    pServerInfoTemp->pwszName = NULL;

    // only alloc space for  pwszServerPrincName if its non-null
    if (pServerInfoSrc->pwszName)
    {
        pServerInfoTemp->pwszName = 
            (LPWSTR) AllocMem((lstrlenW(pServerInfoSrc->pwszName) + 1) * sizeof(WCHAR));

        if (!pServerInfoTemp->pwszName)
            goto Cleanup;
        
        lstrcpyW(pServerInfoTemp->pwszName, pServerInfoSrc->pwszName);
    }

    pServerInfoTemp->pAuthInfo = NULL;
    // copy the AuthIdentity if its non-null
    if (pServerInfoSrc->pAuthInfo)
    {
        hr = CopyAuthInfo(pServerInfoSrc->pAuthInfo, &pServerInfoTemp->pAuthInfo);
        if (FAILED(hr))
            goto Cleanup;
    }
    hr = S_OK;
    
Cleanup:

    if (SUCCEEDED(hr))
    {
        *ppServerInfoDest = pServerInfoTemp;
    }
    else if (pServerInfoTemp)
    {
        FreeMem(pServerInfoTemp);
    }

    return hr;
}

*/

HRESULT
CopyServerInfoStruct(
            IN  COSERVERINFO *    pServerInfoSrc,
            IN  COSERVERINFO *    pServerInfoDest
            )
{
    HRESULT hr = E_OUTOFMEMORY;
   
    if (pServerInfoSrc == NULL)
    {
       return S_OK;
    }

    if (pServerInfoDest == NULL)
    {
       return E_POINTER;
    }

    CopyMemory(pServerInfoDest, pServerInfoSrc, sizeof(COSERVERINFO));

    // We need to allocate these fields and make a copy
    pServerInfoDest->pwszName = NULL;

    // only alloc space for pwszServerPrincName if its non-null
    if (pServerInfoSrc->pwszName)
    {
        pServerInfoDest->pwszName = 
            (LPWSTR) AllocMem((lstrlenW(pServerInfoSrc->pwszName) + 1) * sizeof(WCHAR));

        if (!pServerInfoDest->pwszName)
            goto Cleanup;
        
        lstrcpyW(pServerInfoDest->pwszName, pServerInfoSrc->pwszName);
    }

    pServerInfoDest->pAuthInfo = NULL;
    hr = S_OK;
    
Cleanup:
    return hr;
}

HRESULT
CopyAuthInfoStruct(
            IN  COAUTHINFO *    pAuthInfoSrc,
            IN  COAUTHINFO *    pAuthInfoDest
            )
{
    HRESULT hr = E_OUTOFMEMORY;

    if (pAuthInfoSrc == NULL)
    {
       return S_OK;
    }

    if (pAuthInfoDest == NULL)
    {
        return E_POINTER;
    }

    CopyMemory(pAuthInfoDest, pAuthInfoSrc, sizeof(COAUTHINFO));

    // We need to allocate these fields and make a copy
    pAuthInfoDest->pwszServerPrincName = NULL;
    pAuthInfoDest->pAuthIdentityData = NULL;

    // only alloc space for  pwszServerPrincName if its non-null
    if (pAuthInfoSrc->pwszServerPrincName)
    {
        pAuthInfoDest->pwszServerPrincName = 
            (LPWSTR) AllocMem((lstrlenW(pAuthInfoSrc->pwszServerPrincName) + 1) * sizeof(WCHAR));

        if (!pAuthInfoDest->pwszServerPrincName)
            goto Cleanup;
        
        lstrcpyW(pAuthInfoDest->pwszServerPrincName, pAuthInfoSrc->pwszServerPrincName);
    }
    
    pAuthInfoDest->pAuthIdentityData = NULL;
    hr = S_OK;
    
Cleanup:
    return hr;
}

HRESULT
CopyAuthIdentityStruct(
                IN  COAUTHIDENTITY *    pAuthIdentSrc,
                IN  COAUTHIDENTITY *    pAuthIdentDest
                )
{
    HRESULT hr = E_OUTOFMEMORY;
    ULONG ulCharLen = 1;

    if (pAuthIdentSrc == NULL)
    {
        hr =  E_POINTER;
        goto Cleanup;
    }
    if (pAuthIdentDest == NULL)
    {
        hr =  E_POINTER;
        goto Cleanup;
    }
    
    // Guard against both being set, although presumably this would have
    // caused grief before we got to this point.
    if ((pAuthIdentSrc->Flags & SEC_WINNT_AUTH_IDENTITY_UNICODE) &&
        (pAuthIdentSrc->Flags & SEC_WINNT_AUTH_IDENTITY_ANSI))
    {
        ASSERT(0 && "Both string type flags were set!");
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    if (pAuthIdentSrc->Flags & SEC_WINNT_AUTH_IDENTITY_UNICODE)
    {
        ulCharLen = sizeof(WCHAR);
    }
    else if (pAuthIdentSrc->Flags & SEC_WINNT_AUTH_IDENTITY_ANSI)
    {
        ulCharLen = sizeof(CHAR);
    }
    else
    {
       // The user didn't specify either string bit? How did we get here?
        ASSERT(0 && "String type flag was not set!");
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    CopyMemory(pAuthIdentDest, pAuthIdentSrc, sizeof(COAUTHIDENTITY));

    // Strings need to be allocated individually and copied
    pAuthIdentDest->User = pAuthIdentDest->Domain = pAuthIdentDest->Password = NULL;

    if (pAuthIdentSrc->User)
    {
        pAuthIdentDest->User = (USHORT *)AllocMem((pAuthIdentDest->UserLength+1) * ulCharLen);

        if (!pAuthIdentDest->User)
            goto Cleanup;

        CopyMemory(pAuthIdentDest->User, pAuthIdentSrc->User, (pAuthIdentDest->UserLength+1) * ulCharLen);
    }

    if (pAuthIdentSrc->Domain)
    {
        pAuthIdentDest->Domain = (USHORT *)AllocMem((pAuthIdentDest->DomainLength+1) * ulCharLen);

        if (!pAuthIdentDest->Domain)
            goto Cleanup;

        CopyMemory(pAuthIdentDest->Domain, pAuthIdentSrc->Domain, (pAuthIdentDest->DomainLength+1) * ulCharLen);
    }
            
    if (pAuthIdentSrc->Password)
    {
        pAuthIdentDest->Password = (USHORT *)AllocMem((pAuthIdentDest->PasswordLength+1) * ulCharLen);

        if (!pAuthIdentDest->Password)
            goto Cleanup;

        CopyMemory(pAuthIdentDest->Password, pAuthIdentSrc->Password, (pAuthIdentDest->PasswordLength+1) * ulCharLen);
    }
    
    hr = S_OK;

Cleanup:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\common.h ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        comprop.h

   Abstract:

        Common properties header file

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



#ifndef __COMPROP_H__
#define __COMPROP_H__

#ifdef _COMEXPORT
    #define COMDLL __declspec(dllexport)
#elif defined(_COMIMPORT)
    #define COMDLL __declspec(dllimport)
#elif defined(_COMSTATIC)
    #define COMDLL
#else
    #error "Must define either _COMEXPORT, _COMIMPORT or _COMSTATIC"
#endif // _COMEXPORT

#pragma warning(disable: 4275)
#pragma warning(disable: 4251)

#include <lmcons.h>
#include <iis64.h>
#include "inetcom.h"
#include "iisinfo.h"
#include "svcloc.h"

#include "..\common\resource.h"


//
// Memory Allocation Macros
//
#define AllocMem(cbSize)\
    ::LocalAlloc(LPTR, cbSize)

#define FreeMem(lp)\
    ::LocalFree(lp);\
    lp = NULL;


#define AllocMemByType(citems, type)\
    (type *)AllocMem(citems * sizeof(type))



//
// Program flow macros
//
#define FOREVER for(;;)

#define BREAK_ON_ERR_FAILURE(err)\
    if (err.Failed()) break;

#define BREAK_ON_NULL_PTR(lp)\
    if (lp == NULL) break;

//
// Safe allocators
//
#define SAFE_DELETE(obj)\
    if (obj != NULL) do { delete obj; obj = NULL; } while(0)

#define SAFE_DELETE_OBJECT(obj)\
    if (obj != NULL) do { DeleteObject(obj); obj = NULL; } while(0)

#define SAFE_FREEMEM(lp)\
    if (lp != NULL) do { FreeMem(lp); lp = NULL; } while(0)

#define SAFE_SYSFREESTRING(lp)\
    if (lp != NULL) do { ::SysFreeString(lp); lp = NULL; } while(0)

#define SAFE_AFXFREELIBRARY(hLib)\
    if (hLib != NULL) do { ::AfxFreeLibrary(hLib); hLib = NULL; } while(0)

#define SAFE_RELEASE(lpInterface)\
    if (lpInterface != NULL) do { lpInterface->Release(); lpInterface = NULL; } while(0)


//
// General purpose files
//
#include "debugafx.h"
#include "objplus.h"
#include "strfn.h"
#include "strvalid.h"
#include "odlbox.h"
#include "msg.h"
#include "mdkeys.h"
#include "ipa.h"
#include "wizard.h"
//#include "registry.h"
#include "ddxv.h"
#include "objpick.h"
#include "accentry.h"
#include "sitesecu.h"
#include "utcls.h"
//#include "ipctl.h"
//#include "dtp.h"
#include "dirbrows.h"
#include "acl.h"
#include "util.h"
#include "hosthead.h"

extern "C" void WINAPI InitCommonDll();

#endif // __COMPROP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\bidi.cpp ===
#include "stdafx.h"
#include "common.h"
#include "bidi.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif
#define new DEBUG_NEW

/***************************************************************************\
* ConvertHexStringToIntW
*
* Converts a hex numeric string into an integer.
*
* History:
* 14-June-1998 msadek    Created
\***************************************************************************/
BOOL ConvertHexStringToIntW( WCHAR *pszHexNum , int *piNum )
{
    int   n=0L;
    WCHAR  *psz=pszHexNum;

  
    for(n=0 ; ; psz=CharNextW(psz))
    {
        if( (*psz>='0') && (*psz<='9') )
            n = 0x10 * n + *psz - '0';
        else
        {
            WCHAR ch = *psz;
            int n2;

            if(ch >= 'a')
                ch -= 'a' - 'A';

            n2 = ch - 'A' + 0xA;
            if (n2 >= 0xA && n2 <= 0xF)
                n = 0x10 * n + n2;
            else
                break;
        }
    }

    /*
     * Update results
     */
    *piNum = n;

    return (psz != pszHexNum);
}

typedef struct tagMUIINSTALLLANG {
    LANGID LangID;
    BOOL   bInstalled;
} MUIINSTALLLANG, *LPMUIINSTALLLANG;

typedef BOOL (WINAPI *PFNENUMUILANGUAGES)(UILANGUAGE_ENUMPROC, DWORD, LONG_PTR);

BOOL CALLBACK Mirror_EnumUILanguagesProc(LPTSTR lpUILanguageString, LONG_PTR lParam)
{
    int langID = 0;

    ConvertHexStringToIntW(lpUILanguageString, &langID);

    if((LANGID)langID == ((LPMUIINSTALLLANG)lParam)->LangID)
    {
        ((LPMUIINSTALLLANG)lParam)->bInstalled = TRUE;
        return FALSE;
    }
    return TRUE;
}

/***************************************************************************\
* Mirror_IsUILanguageInstalled
*
* Verifies that the User UI language is installed on W2k
*
* History:
* 14-June-1999 msadek    Created
\***************************************************************************/
BOOL Mirror_IsUILanguageInstalled( LANGID langId )
{

    MUIINSTALLLANG MUILangInstalled = {0};
    MUILangInstalled.LangID = langId;
    
    static PFNENUMUILANGUAGES pfnEnumUILanguages=NULL;

    if( NULL == pfnEnumUILanguages )
    {
        HMODULE hmod = GetModuleHandleA("KERNEL32");

        if( hmod )
            pfnEnumUILanguages = (PFNENUMUILANGUAGES)
                                          GetProcAddress(hmod, "EnumUILanguagesW");
    }

    if( pfnEnumUILanguages )
        pfnEnumUILanguages(Mirror_EnumUILanguagesProc, 0, (LONG_PTR)&MUILangInstalled);

    return MUILangInstalled.bInstalled;
}

/***************************************************************************\
* IsBiDiLocalizedSystemEx
*
* returns TRUE if running on a lozalized BiDi (Arabic/Hebrew) NT5 or Memphis.
* Should be called whenever SetProcessDefaultLayout is to be called.
*
* History:
* 02-Feb-1998 samera    Created
\***************************************************************************/
BOOL IsBiDiLocalizedSystemEx( LANGID *pLangID )
{
    int           iLCID=0L;
    static BOOL   bRet = (BOOL)(DWORD)-1;
    static LANGID langID = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);

    if (bRet != (BOOL)(DWORD)-1)
    {
        if (bRet && pLangID)
        {
            *pLangID = langID;
        }
        return bRet;
    }

    bRet = FALSE;
    /*
     * Need to use NT5 detection method (Multiligual UI ID)
     */
    langID = GetUserDefaultUILanguage();

    if( langID )
    {
        WCHAR wchLCIDFontSignature[16];
        iLCID = MAKELCID( langID , SORT_DEFAULT );

        /*
         * Let's verify this is a RTL (BiDi) locale. Since reg value is a hex string, let's
         * convert to decimal value and call GetLocaleInfo afterwards.
         * LOCALE_FONTSIGNATURE always gives back 16 WCHARs.
         */

        if( GetLocaleInfoW( iLCID , 
                            LOCALE_FONTSIGNATURE , 
                            (WCHAR *) &wchLCIDFontSignature[0] ,
                            (sizeof(wchLCIDFontSignature)/sizeof(WCHAR))) )
        {
  
            /* Let's verify the bits we have a BiDi UI locale */
            if(( wchLCIDFontSignature[7] & (WCHAR)0x0800) && Mirror_IsUILanguageInstalled(langID) )
            {
                bRet = TRUE;
            }
        }
    }

    if (bRet && pLangID)
    {
        *pLangID = langID;
    }
    return bRet;
}

BOOL AFXAPI
IsBiDiLocalizedSystem( void )
{
    return IsBiDiLocalizedSystemEx(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\commsg.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994-1998           **/
/**********************************************************************/

/*
    wsockmsg.h

    This file is generated by the MC tool from the WSOCKMSG.MC message
    file.

    NOTE: Definitions below should match definitions in winsock.h

*/


#ifndef _WSOCKMSG_H_
#define _WSOCKMSG_H_


//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: WSABASEERR
//
// MessageText:
//
//  WSABASEERR
//
#define WSABASEERR                       0x00002710L

//
// MessageId: WSAEINTR
//
// MessageText:
//
//  Interrupted system call.
//
#define WSAEINTR                         0x00002714L

//
// MessageId: WSAEBADF
//
// MessageText:
//
//  Bad file number.
//
#define WSAEBADF                         0x00002719L

//
// MessageId: WSAEACCES
//
// MessageText:
//
//  Access denied.
//
#define WSAEACCES                        0x0000271DL

//
// MessageId: WSAEFAULT
//
// MessageText:
//
//  Bad address.
//
#define WSAEFAULT                        0x0000271EL

//
// MessageId: WSAEINVAL
//
// MessageText:
//
//  Invalid argument.
//
#define WSAEINVAL                        0x00002726L

//
// MessageId: WSAEMFILE
//
// MessageText:
//
//  Too many open files.
//
#define WSAEMFILE                        0x00002728L

//
// MessageId: WSAEWOULDBLOCK
//
// MessageText:
//
//  Operation would block.
//
#define WSAEWOULDBLOCK                   0x00002733L

//
// MessageId: WSAEINPROGRESS
//
// MessageText:
//
//  Operation now in progress.
//
#define WSAEINPROGRESS                   0x00002734L

//
// MessageId: WSAEALREADY
//
// MessageText:
//
//  Operation already in progress.
//
#define WSAEALREADY                      0x00002735L

//
// MessageId: WSAENOTSOCK
//
// MessageText:
//
//  Socket operation on non-socket.
//
#define WSAENOTSOCK                      0x00002736L

//
// MessageId: WSAEDESTADDRREQ
//
// MessageText:
//
//  Destination address required.
//
#define WSAEDESTADDRREQ                  0x00002737L

//
// MessageId: WSAEMSGSIZE
//
// MessageText:
//
//  Message too long.
//
#define WSAEMSGSIZE                      0x00002738L

//
// MessageId: WSAEPROTOTYPE
//
// MessageText:
//
//  Protocol is wrong type for socket.
//
#define WSAEPROTOTYPE                    0x00002739L

//
// MessageId: WSAENOPROTOOPT
//
// MessageText:
//
//  Bad protocol option.
//
#define WSAENOPROTOOPT                   0x0000273AL

//
// MessageId: WSAEPROTONOSUPPORT
//
// MessageText:
//
//  Protocol not supported.
//
#define WSAEPROTONOSUPPORT               0x0000273BL

//
// MessageId: WSAESOCKNOSUPPORT
//
// MessageText:
//
//  Socket type not supported.
//
#define WSAESOCKNOSUPPORT                0x0000273CL

//
// MessageId: WSAEOPNOTSUPP
//
// MessageText:
//
//  Operation not supported on socket.
//
#define WSAEOPNOTSUPP                    0x0000273DL

//
// MessageId: WSAEPFNOSUPPORT
//
// MessageText:
//
//  Protocol family not supported.
//
#define WSAEPFNOSUPPORT                  0x0000273EL

//
// MessageId: WSAEAFNOSUPPORT
//
// MessageText:
//
//  Address family not supported by protocol family.
//
#define WSAEAFNOSUPPORT                  0x0000273FL

//
// MessageId: WSAEADDRINUSE
//
// MessageText:
//
//  Address already in use.
//
#define WSAEADDRINUSE                    0x00002740L

//
// MessageId: WSAEADDRNOTAVAIL
//
// MessageText:
//
//  Can't assign requested address.
//
#define WSAEADDRNOTAVAIL                 0x00002741L

//
// MessageId: WSAENETDOWN
//
// MessageText:
//
//  Network is down.
//
#define WSAENETDOWN                      0x00002742L

//
// MessageId: WSAENETUNREACH
//
// MessageText:
//
//  ICMP network unreachable.
//
#define WSAENETUNREACH                   0x00002743L

//
// MessageId: WSAENETRESET
//
// MessageText:
//
//  Network was reset.
//
#define WSAENETRESET                     0x00002744L

//
// MessageId: WSAECONNABORTED
//
// MessageText:
//
//  Software caused connection abort.
//
#define WSAECONNABORTED                  0x00002745L

//
// MessageId: WSAECONNRESET
//
// MessageText:
//
//  Connection reset by peer.
//
#define WSAECONNRESET                    0x00002746L

//
// MessageId: WSAENOBUFS
//
// MessageText:
//
//  No buffer space is supported.
//
#define WSAENOBUFS                       0x00002747L

//
// MessageId: WSAEISCONN
//
// MessageText:
//
//  Socket is already connected.
//
#define WSAEISCONN                       0x00002748L

//
// MessageId: WSAENOTCONN
//
// MessageText:
//
//  Socket is not connected.
//
#define WSAENOTCONN                      0x00002749L

//
// MessageId: WSAESHUTDOWN
//
// MessageText:
//
//  Can't send after socket shutdown.
//
#define WSAESHUTDOWN                     0x0000274AL

//
// MessageId: WSAETOOMANYREFS
//
// MessageText:
//
//  Too many references.
//
#define WSAETOOMANYREFS                  0x0000274BL

//
// MessageId: WSAETIMEDOUT
//
// MessageText:
//
//  Connection timed out.
//
#define WSAETIMEDOUT                     0x0000274CL

//
// MessageId: WSAECONNREFUSED
//
// MessageText:
//
//  Connection refused.
//
#define WSAECONNREFUSED                  0x0000274DL

//
// MessageId: WSAELOOP
//
// MessageText:
//
//  Too many levels of symbolic links.
//
#define WSAELOOP                         0x0000274EL

//
// MessageId: WSAENAMETOOLONG
//
// MessageText:
//
//  Name too long.
//
#define WSAENAMETOOLONG                  0x0000274FL

//
// MessageId: WSAEHOSTDOWN
//
// MessageText:
//
//  Host is down.
//
#define WSAEHOSTDOWN                     0x00002750L

//
// MessageId: WSAEHOSTUNREACH
//
// MessageText:
//
//  Host is unreachable.
//
#define WSAEHOSTUNREACH                  0x00002751L

//
// MessageId: WSAENOTEMPTY
//
// MessageText:
//
//  Directory not empty.
//
#define WSAENOTEMPTY                     0x00002752L

//
// MessageId: WSAEPROCLIM
//
// MessageText:
//
//  WSAEPROCLIM
//
#define WSAEPROCLIM                      0x00002753L

//
// MessageId: WSAEUSERS
//
// MessageText:
//
//  WSAEUSERS
//
#define WSAEUSERS                        0x00002754L

//
// MessageId: WSAEDQUOT
//
// MessageText:
//
//  Disk quota exceeded.
//
#define WSAEDQUOT                        0x00002755L

//
// MessageId: WSAESTALE
//
// MessageText:
//
//  WSAESTALE
//
#define WSAESTALE                        0x00002756L

//
// MessageId: WSAEREMOTE
//
// MessageText:
//
//  The object is remote.
//
#define WSAEREMOTE                       0x00002757L

//
// MessageId: WSASYSNOTREADY
//
// MessageText:
//
//  System not ready.
//
#define WSASYSNOTREADY                   0x0000276BL

//
// MessageId: WSAVERNOTSUPPORTED
//
// MessageText:
//
//  Version is not supported.
//
#define WSAVERNOTSUPPORTED               0x0000276CL

//
// MessageId: WSANOTINITIALISED
//
// MessageText:
//
//  Not initialized.
//
#define WSANOTINITIALISED                0x0000276DL

//
// MessageId: WSAEDISCON
//
// MessageText:
//
//  Disconnected.
//
#define WSAEDISCON                       0x00002775L

//
// MessageId: WSAHOST_NOT_FOUND
//
// MessageText:
//
//  Host not found.
//
#define WSAHOST_NOT_FOUND                0x00002AF9L

//
// MessageId: WSATRY_AGAIN
//
// MessageText:
//
//  Try again.
//
#define WSATRY_AGAIN                     0x00002AFAL

//
// MessageId: WSANO_RECOVERY
//
// MessageText:
//
//  Non-recoverable error.
//
#define WSANO_RECOVERY                   0x00002AFBL

//
// MessageId: WSANO_DATA
//
// MessageText:
//
//  No data record available.
//
#define WSANO_DATA                       0x00002AFCL


#endif // _WSOCKMSG_H_

/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994-1998           **/
/**********************************************************************/

/*
    mtxmsg.h

    NOTE: Definitions below should match definitions in mtxadmin.h

*/


#ifndef _MTXMSG_H_
#define _MTXMSG_H_

//
// MessageId: E_MTS_OBJECTERRORS
//
// MessageText:
//
//  Some object-level errors occurred.
//
#define E_MTS_OBJECTERRORS               0x80110401L

//
// MessageId: E_MTS_OBJECTINVALID
//
// MessageText:
//
//  Object is inconsistent or damaged.
//
#define E_MTS_OBJECTINVALID              0x80110402L

//
// MessageId: E_MTS_KEYMISSING
//
// MessageText:
//
//  Object could not be found.
//
#define E_MTS_KEYMISSING                 0x80110403L

//
// MessageId: E_MTS_ALREADYINSTALLED
//
// MessageText:
//
//  Component is already installed.
//
#define E_MTS_ALREADYINSTALLED           0x80110404L

//
// MessageId: E_MTS_DOWNLOADFAILED
//
// MessageText:
//
//  Could not download files.
//
#define E_MTS_DOWNLOADFAILED             0x80110405L

//
// MessageId: E_MTS_PDFWRITEFAIL
//
// MessageText:
//
//  Failure to write to PDF file.
//
#define E_MTS_PDFWRITEFAIL               0x80110407L

//
// MessageId: E_MTS_PDFREADFAIL
//
// MessageText:
//
//  Failure reading from PDF file.
//
#define E_MTS_PDFREADFAIL                0x80110408L

//
// MessageId: E_MTS_PDFVERSION
//
// MessageText:
//
//  Version mismatch in PDF file.
//
#define E_MTS_PDFVERSION                 0x80110409L

///////////////////////////////////////////////////////////////////////////////

#pragma message Warning: IDs are out of sync in mtxadmin.h

///////////////////////////////////////////////////////////////////////////////
//MessageId=+1 Facility=MTX Severity=CoError SymbolicName=E_MTS_COREQCOMPINSTALLED
//Language=English
//A co-requisite Component is already installed.
//.
//
// MessageId: E_MTS_BADPATH
//
// MessageText:
//
//  Invalid or no access to source or destination path.
//
#define E_MTS_BADPATH                    0x8011040AL

//
// MessageId: E_MTS_PACKAGEEXISTS
//
// MessageText:
//
//  Installing package already exists.
//
#define E_MTS_PACKAGEEXISTS              0x8011040BL

//
// MessageId: E_MTS_ROLEEXISTS
//
// MessageText:
//
//  Installing role already exists.
//
#define E_MTS_ROLEEXISTS                 0x8011040CL

//
// MessageId: E_MTS_CANTCOPYFILE
//
// MessageText:
//
//  A file cannot be copied.
//
#define E_MTS_CANTCOPYFILE               0x8011040DL

//
// MessageId: E_MTS_NOTYPELIB
//
// MessageText:
//
//  Export without typelib fails.
//
#define E_MTS_NOTYPELIB                  0x8011040EL

//
// MessageId: E_MTS_NOUSER
//
// MessageText:
//
//  No such NT user.
//
#define E_MTS_NOUSER                     0x8011040FL

//
// MessageId: E_MTS_INVALIDUSERIDS
//
// MessageText:
//
//  One or all userids in a package (import) are invalid.
//
#define E_MTS_INVALIDUSERIDS             0x80110410L

//
// MessageId: E_MTS_USERPASSWDNOTVALID
//
// MessageText:
//
//  User/password validation failed.
//
#define E_MTS_USERPASSWDNOTVALID         0x80110414L

//
// MessageId: E_MTS_CLSIDORIIDMISMATCH
//
// MessageText:
//
//  The GUIDs in the package don't match the component's GUIDs.
//
#define E_MTS_CLSIDORIIDMISMATCH         0x80110418L

#endif // _MTXMSG_H_
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    webcluserr.h

    This file is generated by the MC tool from the WEBCLUSERR.MC message
    file.


    FILE HISTORY:
        AMallet   14-June-1999  Created

*/


#ifndef _WEBCLUSERR_H_
#define _WEBCLUSERR_H_

#define FACILITY_APPSERVER          0x400
#define SEV_SUCCESS                 0x0
#define SEV_INFORMATIONAL           0x1
#define SEV_WARNING                 0x2
#define SEV_ERROR                   0x3

#define MAKE_AS_HRESULT(sev, code) \
  ((HRESULT) (((unsigned long)(sev)<<31) | ((unsigned long)(FACILITY_APPSERVER)<<16) | ((unsigned long)(code))) )



//
// MessageId: AS_ERROR_BAD_OS
//
// MessageText:
//
//  This feature requires a different OS version [Win2k Advanced Server or higher] 
//
#define AS_ERROR_BAD_OS                  0xC0140001L

//
// MessageId: AS_ERROR_NLB_NOT_INSTALLED
//
// MessageText:
//
//  The Windows Load Balancing Service is not installed on this machine
//
#define AS_ERROR_NLB_NOT_INSTALLED       0xC0140002L

//
// MessageId: AS_ERROR_MACHINE_ALREADY_IN_CLUSTER
//
// MessageText:
//
//  This machine is already part of an Application Server cluster
//
#define AS_ERROR_MACHINE_ALREADY_IN_CLUSTER 0xC0140003L

//
// MessageId: AS_ERROR_BAD_IIS_VERSION
//
// MessageText:
//
//  This feature requires a later version of IIS than is currently installed on this machine
//
#define AS_ERROR_BAD_IIS_VERSION         0xC0140004L

//
// MessageId: AS_ERROR_MACHINE_NOT_IN_CLUSTER
//
// MessageText:
//
//  This machine is not part of an Application Server cluster
//
#define AS_ERROR_MACHINE_NOT_IN_CLUSTER  0xC0140005L

//
// MessageId: AS_ERROR_INVALID_PARTITION
//
// MessageText:
//
//  The partition ID is not valid.
//
#define AS_ERROR_INVALID_PARTITION       0xC0140006L

//
// MessageId: AS_ERROR_MACHINE_ALREADY_IN_PARTITION
//
// MessageText:
//
//  The machine is already part of the partition. 
//
#define AS_ERROR_MACHINE_ALREADY_IN_PARTITION 0xC0140007L

//
// MessageId: AS_ERROR_SVC_NOT_INSTALLED
//
// MessageText:
//
//  A necessary service is not installed. 
//
#define AS_ERROR_SVC_NOT_INSTALLED       0xC0140008L

//
// MessageId: AS_ERROR_INVALID_SITE_BINDING
//
// MessageText:
//
//  A site is bound to an illegal IP address. 
//
#define AS_ERROR_INVALID_SITE_BINDING    0xC0140009L

//
// MessageId: AS_ERROR_BAD_SUBNET
//
// MessageText:
//
//  The machine is on a different subnet.
//
#define AS_ERROR_BAD_SUBNET              0xC014000AL

//
// MessageId: AS_ERROR_MASTER_NOT_FOUND
//
// MessageText:
//
//  The cluster master could not be located.
//
#define AS_ERROR_MASTER_NOT_FOUND        0xC014000BL

//
// MessageId: AS_ERROR_NOT_CLUSTER_MASTER
//
// MessageText:
//
//  This machine is not the cluster master. 
//
#define AS_ERROR_NOT_CLUSTER_MASTER      0xC014000CL

//
// MessageId: AS_ERROR_DIFFERENT_CLUSTER
//
// MessageText:
//
//  This machine is part of a different cluster.
//
#define AS_ERROR_DIFFERENT_CLUSTER       0xC014000DL

//
// MessageId: AS_ERROR_WRONG_MEMBERSHIP
//
// MessageText:
//
//  This machine is part of a different domain/workgroup than the cluster controller.
//
#define AS_ERROR_WRONG_MEMBERSHIP        0xC014000EL

//
// MessageId: AS_ERROR_SVC_SHUTTING_DOWN
//
// MessageText:
//
//  This WebCluster service is shutting down. 
//
#define AS_ERROR_SVC_SHUTTING_DOWN       0xC014000FL

//
// MessageId: AS_ERROR_NOT_INITIALIZED
//
// MessageText:
//
//  The object was not initialized.
//
#define AS_ERROR_NOT_INITIALIZED         0xC0140010L

//
// MessageId: AS_ERROR_INVALID_CLUSTER_IP
//
// MessageText:
//
//  The cluster IP address and/or subnet mask is invalid.
//
#define AS_ERROR_INVALID_CLUSTER_IP      0xC0140011L

//
// MessageId: AS_ERROR_INVALID_DEDICATED_IP
//
// MessageText:
//
//  The dedicated IP address and/or subnet mask is invalid.
//
#define AS_ERROR_INVALID_DEDICATED_IP    0xC0140012L

//
// MessageId: AS_ERROR_NO_NIC
//
// MessageText:
//
//  No netcard was supplied.
//
#define AS_ERROR_NO_NIC                  0xC0140013L

//
// MessageId: AS_ERROR_ALREADY_INITIALIZED
//
// MessageText:
//
//  The object was already initialized.
//
#define AS_ERROR_ALREADY_INITIALIZED     0xC0140014L

//
// MessageId: AS_ERROR_NETWORK_CFG_CONFLICT
//
// MessageText:
//
//  Network properties are already being modified.
//
#define AS_ERROR_NETWORK_CFG_CONFLICT    0xC0140015L    

//
// MessageId: AS_ERROR_CONFLICTING_ACTION
//
// MessageText:
//
//  An administrative action is in progress that conflicts with the requested action.
//
#define AS_ERROR_CONFLICTING_ACTION      0xC0140016L    

//
// MessageId: AS_ERROR_STALE_DATA
//
// MessageText:
//
//  A more recent copy of the data exists.
//
#define AS_ERROR_STALE_DATA              0xC0140017L

//
// MessageId: AS_ERROR_CONTROLLER_CHANGING
//
// MessageText:
//
//  A cluster controller change is in progress.
//
#define AS_ERROR_CONTROLLER_CHANGING     0xC0140018L

//
// MessageId: AS_ERROR_CONTROLLER_NOT_CHANGING
//
// MessageText:
//
//  There is no cluster controller change currently in progress.
//
#define AS_ERROR_CONTROLLER_NOT_CHANGING 0xC0140019L

//
// MessageId: AS_ERROR_CONTROLLER_EXISTS
//
// MessageText:
//
//  There is already a cluster controller.
//
#define AS_ERROR_CONTROLLER_EXISTS       0xC014001AL

//
// MessageId: AS_ERROR_CONTROLLER_UNREACHABLE
//
// MessageText:
//
//  The cluster controller could not be reached.
//
#define AS_ERROR_CONTROLLER_UNREACHABLE  0xC014001BL

//
// MessageId: AS_ERROR_NLB_NOT_BOUND
//
// MessageText:
//
//  Network Load Balancing isn't bound to any network card.
//
#define AS_ERROR_NLB_NOT_BOUND           0xC014001CL

//
// MessageId: AS_ERROR_NLB_CONFLICTING_HOST_PRIORITY
//
// MessageText:
//
//  The server has a conflicting NLB host priority.
//
#define AS_ERROR_NLB_CONFLICTING_HOST_PRIORITY 0xC014001DL

//
// MessageId: AS_ERROR_NLB_ONLY_ONE_NIC
//
// MessageText:
//
//  The server has only one network card. 
//
#define AS_ERROR_NLB_ONLY_ONE_NIC        0xC014001EL

//
// MessageId: AS_ERROR_NLB_UNSUPP_PORTRULES
//
// MessageText:
//
//  The server has unsupported (probably failover) NLB port rules.
//
#define AS_ERROR_NLB_UNSUPP_PORTRULES    0xC014001FL

//
// MessageId: AS_ERROR_NLB_UNMANAGEABLE_CONFIG
//
// MessageText:
//
//  The server has an NLB or network configuration that prevents it from going into managed NLB mode.
//
#define AS_ERROR_NLB_UNMANAGEABLE_CONFIG 0xC0140020L


#endif  // _WEBCLUSERR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\cryptpass.h ===
#ifndef _PASSWORD_H_
#define _PASSWORD_H_


HRESULT EncryptMemoryPassword(LPWSTR pszClearTextPassword,LPWSTR *ppszEncryptedPassword,DWORD *ppdwBufferBytes);
HRESULT DecryptMemoryPassword(LPWSTR pszEncodedPassword,LPWSTR *ppszReturnedPassword,DWORD dwBufferBytes);

#endif // _PASSWORD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\cryptpass.cpp ===
#include "stdafx.h"
#include "common.h"
#include <wincrypt.h>
#include <strsafe.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif
#define new DEBUG_NEW

//  Given a clear text password.  this function will encrypt the password in memory
//  then allocate memory and passback the encrypted password into the memory
//
//  The class can then store the ppszEncryptedPassword in it's member variables safely
//  and when the class is destructed, should SecureZeroMemory() out the password and LocalFree() up the the memory.
HRESULT EncryptMemoryPassword(LPWSTR pszClearTextPassword,LPWSTR *ppszEncryptedPassword,DWORD *ppdwBufferBytes)
{
	HRESULT hRes = E_FAIL;

	LPWSTR pszTempStr = NULL;
	DWORD dwTempStrSizeOf = 0;

    *ppszEncryptedPassword = NULL;
    *ppdwBufferBytes = 0;

	if (pszClearTextPassword)
	{
        // We should check if the pszClearTextPassword is null terminated before doing wcslen

		DWORD dwBufferByteLen = (wcslen(pszClearTextPassword) + 1) * sizeof(WCHAR);
		if (CRYPTPROTECTMEMORY_BLOCK_SIZE > 0 && dwBufferByteLen > 0)
		{
			int iBlocks = dwBufferByteLen / CRYPTPROTECTMEMORY_BLOCK_SIZE;
			iBlocks++;

			dwTempStrSizeOf = iBlocks * CRYPTPROTECTMEMORY_BLOCK_SIZE;
			pszTempStr = (LPWSTR) LocalAlloc(LPTR,dwTempStrSizeOf);
			if (!pszTempStr)
			{
				hRes = E_OUTOFMEMORY;
				goto EncryptMemoryPassword_Exit;
			}

			ZeroMemory(pszTempStr,dwTempStrSizeOf);
            StringCbCopy(pszTempStr,dwTempStrSizeOf,pszClearTextPassword);

			if (FALSE != CryptProtectMemory(pszTempStr,dwTempStrSizeOf,CRYPTPROTECTMEMORY_SAME_PROCESS))
			{
				// We're all set...
				*ppszEncryptedPassword = pszTempStr;
				*ppdwBufferBytes = dwTempStrSizeOf;

				hRes = S_OK;
				goto EncryptMemoryPassword_Exit;
			}
		}
	}

EncryptMemoryPassword_Exit:
    if (FAILED(hRes)) 
	{
		if (pszTempStr)
		{
			if (dwTempStrSizeOf > 0)
			{
				SecureZeroMemory(pszTempStr,dwTempStrSizeOf);
			}
			LocalFree(pszTempStr);
			pszTempStr = NULL;
			dwTempStrSizeOf = 0;
		}
	}
	return hRes;
}

// Given a encrypted password (encrypted in the same process with EncryptMemoryPassword -- which uses CryptProtectMemory)
// this function will allocate some new memory, decrypt the password and put it in the new memory
// and return it back to the caller in ppszReturnedPassword.
//
// The caller must ensure to erase and free the memory after it is finished using the decrypted password.
//
//     LPWSTR lpwstrTempPassword = NULL;
//
//     if (FAILED(DecryptMemoryPassword((LPWSTR) pszUserPasswordEncrypted,&lpwstrTempPassword,cbUserPasswordEncrypted)))
//     {
//			// do some failure processing...
//     }
//
//     // use password for whatever you needed to use it for...
//
//     if (lpwstrTempPassword)
//     {
//         if (cbTempPassword > 0)
//         (
//             SecureZeroMemory(lpwstrTempPassword,cbTempPassword);
//         )
//         LocalFree(lpwstrTempPassword);lpwstrTempPassword = NULL;
//      }
HRESULT DecryptMemoryPassword(LPWSTR pszEncodedPassword,LPWSTR *ppszReturnedPassword,DWORD dwBufferBytes)
{
    HRESULT hRes = E_FAIL;
    LPWSTR pszTempStr = NULL;
    
    if (!dwBufferBytes || !ppszReturnedPassword) 
	{
		return E_FAIL;
    }

    *ppszReturnedPassword = NULL;
    if (dwBufferBytes) 
	{
        pszTempStr = (LPWSTR) LocalAlloc(LPTR,dwBufferBytes);
        if (!pszTempStr) 
		{
			hRes = E_OUTOFMEMORY;
			goto DecryptMemoryPassword_Exit;
        }

		ZeroMemory(pszTempStr,dwBufferBytes);
        memcpy(pszTempStr,pszEncodedPassword,dwBufferBytes);
		if (FALSE != CryptUnprotectMemory(pszTempStr,dwBufferBytes,CRYPTPROTECTMEMORY_SAME_PROCESS))
		{
			// We're all set...
			*ppszReturnedPassword = pszTempStr;
			hRes = S_OK;
		}
    }

DecryptMemoryPassword_Exit:
    if (FAILED(hRes)) 
	{
		if (pszTempStr)
		{
			if (dwBufferBytes > 0)
			{
				SecureZeroMemory(pszTempStr,dwBufferBytes);
			}
			LocalFree(pszTempStr);
			pszTempStr =  NULL;
		}
    }

	return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\ddxv.cpp ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        ddxv.cpp

   Abstract:
        DDX/DDV Routines

   Author:
        Ronald Meijer (ronaldm)
		Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
#include "stdafx.h"
#include "common.h"
#include "balloon.h"
#include "shlobjp.h"
#include "strpass.h"
#include "util.h"


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif
#define new DEBUG_NEW


//
// Prototype for external function
//
void AFXAPI AfxSetWindowText(HWND hWndCtrl, LPCTSTR lpszNew);

//
// Numeric strings cannot be longer than 32 digits
//
#define NUMERIC_BUFF_SIZE (32)

//
// Dummy password used for display purposes
//
LPCTSTR g_lpszDummyPassword = _T("**********");
static TCHAR g_InvalidCharsPath[] = _T("|<>/*?\"\t\r\n");
static TCHAR g_InvalidCharsPathAllowSpecialPath[] = _T("|<>/*\"\t\r\n");
static TCHAR g_InvalidCharsDomainName[] = _T(" ~`!@#$%^&*()_+={}[]|/\\?*:;\"\'<>,");

extern HINSTANCE hDLLInstance;


#define MACRO_MAXCHARSBALLOON()\
    if (pDX->m_bSaveAndValidate)\
    {\
        UINT nID;\
        TCHAR szT[NUMERIC_BUFF_SIZE + 1];\
        if (value.GetLength() > nChars)\
        {\
            nID = AFX_IDP_PARSE_STRING_SIZE;\
            ::wsprintf(szT, _T("%d"), nChars);\
			CString prompt;\
			::AfxFormatString1(prompt, nID, szT);\
			DDV_ShowBalloonAndFail(pDX, prompt);\
		}\
    }\
    else if (pDX->m_hWndLastControl != NULL && pDX->m_bEditLastControl)\
    {\
        ::SendMessage(pDX->m_hWndLastControl, EM_LIMITTEXT, nChars, 0);\
    }\

#define MACRO_MINMAXCHARS()\
    if (pDX->m_bSaveAndValidate)\
    {\
        UINT nID;\
        TCHAR szT[NUMERIC_BUFF_SIZE + 1];\
        if (value.GetLength() < nMinChars)\
        {\
            nID = IDS_DDX_MINIMUM;\
            ::wsprintf(szT, _T("%d"), nMinChars);\
        }\
        else if (value.GetLength() > nMaxChars)\
        {\
            nID = AFX_IDP_PARSE_STRING_SIZE;\
            ::wsprintf(szT, _T("%d"), nMaxChars);\
        }\
        else\
        {\
            return;\
        }\
        CString prompt;\
        ::AfxFormatString1(prompt, nID, szT);\
		DDV_ShowBalloonAndFail(pDX, prompt);\
    }\
    else if (pDX->m_hWndLastControl != NULL && pDX->m_bEditLastControl)\
    {\
        ::SendMessage(pDX->m_hWndLastControl, EM_LIMITTEXT, nMaxChars, 0);\
    }\

#define MACRO_MINCHARS()\
    if (pDX->m_bSaveAndValidate && value.GetLength() < nChars)\
    {\
        TCHAR szT[NUMERIC_BUFF_SIZE + 1];\
        wsprintf(szT, _T("%d"), nChars);\
        CString prompt;\
        ::AfxFormatString1(prompt, IDS_DDX_MINIMUM, szT);\
		DDV_ShowBalloonAndFail(pDX, prompt);\
    }\

#define MACRO_PASSWORD()\
    HWND hWndCtrl = pDX->PrepareEditCtrl(nIDC);\
    if (pDX->m_bSaveAndValidate)\
    {\
        if (::IsWindowEnabled(hWndCtrl))\
        {\
            if (!::SendMessage(hWndCtrl, EM_GETMODIFY, 0, 0))\
            {\
                TRACEEOLID("No changes -- skipping");\
                return;\
            }\
            CString strNew;\
            int nLen = ::GetWindowTextLength(hWndCtrl);\
            ::GetWindowText(hWndCtrl, strNew.GetBufferSetLength(nLen), nLen + 1);\
            strNew.ReleaseBuffer();\
            CConfirmDlg dlg(pDX->m_pDlgWnd);\
		    dlg.SetReference(strNew);\
            if (dlg.DoModal() == IDOK)\
            {\
                value = strNew;\
			    ::SendMessage(hWndCtrl, EM_SETMODIFY, 0, 0);\
                return;\
            }\
		    pDX->Fail();\
        }\
    }\
    else\
    {\
        if (!value.IsEmpty())\
        {\
            ::AfxSetWindowText(hWndCtrl, lpszDummy);\
        }\
    }\


BOOL
PathIsValid(LPCTSTR path, BOOL bAllowSpecialPath)
{
    if (path == NULL || *path == 0)
        return FALSE;
	if (bAllowSpecialPath)
	{
		return 0 == StrSpn(path, g_InvalidCharsPathAllowSpecialPath);
	}
	else
	{
		return 0 == StrSpn(path, g_InvalidCharsPath);
	}
}

HRESULT AFXAPI
LimitInputPath(HWND hWnd, BOOL bAllowSpecialPath)
{
    LIMITINPUT li   = {0};
    li.cbSize       = sizeof(li);
    li.dwMask       = LIM_FLAGS | LIM_FILTER | LIM_MESSAGE | LIM_HINST;
    li.dwFlags      = LIF_EXCLUDEFILTER | LIF_HIDETIPONVALID | LIF_PASTESKIP;
    li.hinst        = hDLLInstance;
	if (bAllowSpecialPath)
	{
		li.pszMessage   = MAKEINTRESOURCE(IDS_PATH_INPUT_INVALID_ALLOW_DEVICE_PATH);
		li.pszFilter    = g_InvalidCharsPathAllowSpecialPath;
	}
	else
	{
		li.pszMessage   = MAKEINTRESOURCE(IDS_PATH_INPUT_INVALID);
		li.pszFilter    = g_InvalidCharsPath;
	}

	return SHLimitInputEditWithFlags(hWnd, &li);
}

HRESULT AFXAPI
LimitInputDomainName(HWND hWnd)
{
    LIMITINPUT li   = {0};
    li.cbSize       = sizeof(li);
    li.dwMask       = LIM_FLAGS | LIM_FILTER | LIM_MESSAGE | LIM_HINST;
    li.dwFlags      = LIF_EXCLUDEFILTER | LIF_HIDETIPONVALID | LIF_PASTESKIP;
    li.hinst        = hDLLInstance;
    li.pszMessage   = MAKEINTRESOURCE(IDS_ERR_INVALID_HOSTHEADER_CHARS);
    li.pszFilter    = g_InvalidCharsDomainName;

	return SHLimitInputEditWithFlags(hWnd, &li);
}

void AFXAPI 
DDV_MinChars(CDataExchange * pDX, CString const & value, int nChars)
/*++

Routine Description:
    Validate CString using a minimum string length

Arguments:
    CDataExchange * pDX   : Data exchange structure
    CString const & value : String to be validated
    int nChars            : Minimum length of string

--*/
{
    MACRO_MINCHARS()
}

void AFXAPI 
DDV_MaxCharsBalloon(CDataExchange * pDX, CString const & value, int nChars)
{
    MACRO_MAXCHARSBALLOON()
}

void AFXAPI 
DDV_MinMaxChars(CDataExchange * pDX, CString const & value, int nMinChars, int nMaxChars)
/*++

Routine Description:
    Validate CString using a minimum and maximum string length.

Arguments:
    CDataExchange * pDX   : Data exchange structure
    CString const & value : String to be validated
    int nMinChars         : Minimum length of string
    int nMaxChars         : Maximum length of string

--*/
{
    MACRO_MINMAXCHARS()
}



void 
AFXAPI DDX_Spin(
    IN CDataExchange * pDX,
    IN int nIDC,
    IN OUT int & value
    )
/*++

Routine Description:

    Save/store data from spinbutton control

Arguments:

    CDataExchange * pDX : Data exchange structure
    int nIDC            : Control ID of the spinbutton control
    int & value         : Value to be saved or stored

Return Value:

    None

--*/
{
    HWND hWndCtrl = pDX->PrepareCtrl(nIDC);
    if (pDX->m_bSaveAndValidate)
    {
        if (::IsWindowEnabled(hWndCtrl))
        {
            value = (int)LOWORD(::SendMessage(hWndCtrl, UDM_GETPOS, 0, 0L));
        }
    }
    else
    {
        ::SendMessage(hWndCtrl, UDM_SETPOS, 0, MAKELPARAM(value, 0));
    }
}



void 
AFXAPI DDV_MinMaxSpin(
    IN CDataExchange * pDX,
    IN HWND hWndControl,
    IN int minVal,
    IN int maxVal
    )
/*++

Routine Description:

    Enforce minimum/maximum spin button range

Arguments:

    CDataExchange * pDX : Data exchange structure
    HWND hWndControl    : Control window handle
    int minVal          : Minimum value
    int maxVal          : Maximum value

Return Value:

    None

Note:

    Unlike most data validation routines, this one
    MUST be used prior to an accompanying DDX_Spin()
    function.  This is because spinbox controls have a
    native limit of 0-100.  Also, this function requires
    a window handle to the child control.  The
    CONTROL_HWND macro can be used for this.

--*/
{
    ASSERT(minVal <= maxVal);
    
    if (!pDX->m_bSaveAndValidate && hWndControl != NULL)
    {
        //
        // limit the control range automatically
        //
        ::SendMessage(hWndControl, UDM_SETRANGE, 0, MAKELPARAM(maxVal, minVal));
    }
}

void AFXAPI
OldEditShowBalloon(HWND hwnd, CString txt)
{
    EDITBALLOONTIP ebt = {0};
    ebt.cbStruct = sizeof(ebt);
    ebt.pszText = txt;
	SetFocus(hwnd);
	Edit_ShowBalloonTip(hwnd, &ebt);
}

void AFXAPI EditHideBalloon(void)
{
	Edit_HideBalloonTipHandler();
}

void AFXAPI EditShowBalloon(HWND hwnd, CString txt)
{
    Edit_ShowBalloonTipHandler(hwnd, (LPCTSTR) txt);
}

void AFXAPI
EditShowBalloon(HWND hwnd, UINT ids)
{
	if (ids != 0)
	{
		CString txt;
		if (txt.LoadString(ids))
		{
			EditShowBalloon(hwnd, txt);
		}
	}
}

void AFXAPI
DDV_ShowBalloonAndFail(CDataExchange * pDX, UINT ids)
{
	if (ids != 0)
	{
		EditShowBalloon(pDX->m_hWndLastControl, ids);
        pDX->Fail();
	}
}

void AFXAPI
DDV_ShowBalloonAndFail(CDataExchange * pDX, CString txt)
{
	if (!txt.IsEmpty())
	{
		EditShowBalloon(pDX->m_hWndLastControl, txt);
        pDX->Fail();
	}
}

void 
AFXAPI DDV_FolderPath(
    CDataExchange * pDX,
    CString& value,
    BOOL local
    )
{
	if (pDX->m_bSaveAndValidate)
	{
		CString expanded, csPathMunged;
		ExpandEnvironmentStrings(value, expanded.GetBuffer(MAX_PATH), MAX_PATH);
		expanded.ReleaseBuffer();
		expanded.TrimRight();
		expanded.TrimLeft();
        csPathMunged = expanded;
#ifdef SUPPORT_SLASH_SLASH_QUESTIONMARK_SLASH_TYPE_PATHS
        GetSpecialPathRealPath(0,expanded,csPathMunged);
#endif
		int ids = 0;
		do
		{
			if (!PathIsValid(csPathMunged,FALSE))
			{
				ids = IDS_ERR_INVALID_PATH;
				break;
			}

            DWORD dwAllowed = CHKPATH_ALLOW_DEVICE_PATH;
            dwAllowed |= CHKPATH_ALLOW_UNC_PATH; // allow UNC type dir paths
            // don't allow these type of paths commented out below:
            //dwAllowed |= CHKPATH_ALLOW_RELATIVE_PATH;
            //dwAllowed |= CHKPATH_ALLOW_UNC_SERVERNAME_ONLY;
            //dwAllowed |= CHKPATH_ALLOW_UNC_SERVERSHARE_ONLY;
            DWORD dwCharSet = CHKPATH_CHARSET_GENERAL;
            FILERESULT dwValidRet = MyValidatePath(csPathMunged,local,CHKPATH_WANT_DIR,dwAllowed,dwCharSet);
            if (FAILED(dwValidRet))
            {
                ids = IDS_ERR_BAD_PATH;

                if (dwValidRet == CHKPATH_FAIL_NOT_ALLOWED_DIR_NOT_EXIST)
                {
                    ids = IDS_ERR_PATH_NOT_FOUND;
                }
                break;
            }
		}
		while (FALSE);
		DDV_ShowBalloonAndFail(pDX, ids);
	}
}


void 
AFXAPI DDV_FilePath(
    CDataExchange * pDX,
    CString& value,
    BOOL local
    )
{
    CString expanded, csPathMunged;
    ExpandEnvironmentStrings(value, expanded.GetBuffer(MAX_PATH), MAX_PATH);
	expanded.ReleaseBuffer();
    csPathMunged = expanded;
#ifdef SUPPORT_SLASH_SLASH_QUESTIONMARK_SLASH_TYPE_PATHS
    GetSpecialPathRealPath(0,expanded,csPathMunged);
#endif
	int ids = 0;
    do
    {
        if (!PathIsValid(csPathMunged,FALSE))
        {
		    ids = IDS_ERR_INVALID_PATH;
            break;
        }
		if (!IsDevicePath(csPathMunged))
		{
			if (PathIsUNCServerShare(csPathMunged) || PathIsUNCServer(csPathMunged))
			{
				ids = IDS_ERR_BAD_PATH;
				break;
			}
			if (PathIsRelative(csPathMunged))
			{
				ids = IDS_ERR_BAD_PATH;
				break;
			}
			if (local)
			{
				if (PathIsDirectory(csPathMunged))
				{
					ids = IDS_ERR_FILE_NOT_FOUND;
					break;
				}
				if (!PathFileExists(csPathMunged))
				{
					ids = IDS_ERR_FILE_NOT_FOUND;
					break;
				}
			}
		}
    }
    while (FALSE);
    DDV_ShowBalloonAndFail(pDX, ids);
}


void 
AFXAPI DDV_UNCFolderPath(
    CDataExchange * pDX,
    CString& value,
    BOOL local
    )
{
	int ids = 0;
    CString csPathMunged;
    csPathMunged = value;
#ifdef SUPPORT_SLASH_SLASH_QUESTIONMARK_SLASH_TYPE_PATHS
    GetSpecialPathRealPath(0,value,csPathMunged);
#endif
    do
    {
        if (!PathIsValid(csPathMunged,FALSE))
        {
            ids = IDS_ERR_INVALID_PATH;
            break;
        }

        // PathIsUNCServer doesn't catch "\\". We are expecting share here.
        if (!PathIsUNC(csPathMunged) || lstrlen(csPathMunged) == 2)
        {
		    ids = IDS_BAD_UNC_PATH;
            break;
        }

        // Additional validation checks not covered above
        DWORD dwAllowed = CHKPATH_ALLOW_UNC_PATH;
        // We do accept server shares, but it has to have a fullpath
        // with a filename at the end
        dwAllowed |= CHKPATH_ALLOW_UNC_SERVERSHARE_ONLY;
        // don't allow these type of paths commented out below:
        //dwAllowed |= CHKPATH_ALLOW_DEVICE_PATH;
        //dwAllowed |= CHKPATH_ALLOW_RELATIVE_PATH;
        //dwAllowed |= CHKPATH_ALLOW_UNC_SERVERNAME_ONLY;
        DWORD dwCharSet = CHKPATH_CHARSET_GENERAL;

        FILERESULT dwValidRet = MyValidatePath(csPathMunged,local,CHKPATH_WANT_DIR,dwAllowed,dwCharSet);
        if (FAILED(dwValidRet))
        {
            ids = IDS_BAD_UNC_PATH;
            break;
        }

		if (local)
		{
            /*
            if (!DoesUNCShareExist(csPathMunged))
            {
                ids = IDS_ERR_FILE_NOT_FOUND;
                break;
            }
            */
		}
    }
    while (FALSE);
    DDV_ShowBalloonAndFail(pDX, ids);
}

void 
AFXAPI DDV_Url(
    CDataExchange * pDX,
    CString& value
    )
{
	int ids = 0;

	if (IsRelURLPath(value))
	{
		return;
	}

	if ( IsWildcardedRedirectPath(value)
		 || IsURLName(value)
		 )
	{
		TCHAR host[MAX_PATH];
		DWORD cch = MAX_PATH;
		UrlGetPart(value, host, &cch, URL_PART_HOSTNAME, 0);
		if (cch > 0)
		{
			return;
		}
	}

	// none of the above, so it must be a bad path
	ids = IDS_BAD_URL_PATH;
    DDV_ShowBalloonAndFail(pDX, ids);
}

void AFXAPI 
DDX_Text_SecuredString(CDataExchange * pDX, int nIDC, CStrPassword & value)
{
    HWND hWndCtrl = pDX->PrepareEditCtrl(nIDC);
    if (pDX->m_bSaveAndValidate)
    {
        if (::IsWindowEnabled(hWndCtrl))
        {
            // get the value from the UI if we need to
            if (!::SendMessage(hWndCtrl, EM_GETMODIFY, 0, 0))
            {
                TRACEEOLID("No changes -- skipping");
                return;
            }

            CString strNew;
            int nLen = ::GetWindowTextLength(hWndCtrl);
            ::GetWindowText(hWndCtrl, strNew.GetBufferSetLength(nLen), nLen + 1);
            strNew.ReleaseBuffer();

            value = (LPCTSTR) strNew;
        }
    }
    else
    {
        //
        // set the value in the UI if we need to
        //
        if (!value.IsEmpty())
        {
            TCHAR * pszPassword = NULL;
            pszPassword = value.GetClearTextPassword();
            if (pszPassword)
            {
                ::AfxSetWindowText(hWndCtrl, pszPassword);
                value.DestroyClearTextPassword(pszPassword);
            }
        }
    }
}

void AFXAPI 
DDV_MaxChars_SecuredString(CDataExchange* pDX, CStrPassword const& value, int nChars)
{
    MACRO_MAXCHARSBALLOON()
}

void AFXAPI 
DDV_MaxCharsBalloon_SecuredString(CDataExchange * pDX, CStrPassword const & value, int nChars)
{
    MACRO_MAXCHARSBALLOON()
}

void AFXAPI 
DDV_MinMaxChars_SecuredString(CDataExchange * pDX, CStrPassword const & value, int nMinChars, int nMaxChars)
{
    MACRO_MINMAXCHARS()
}

void AFXAPI 
DDV_MinChars_SecuredString(CDataExchange * pDX, CStrPassword const & value, int nChars)
{
    MACRO_MINCHARS()
}

void AFXAPI 
DDX_Password_SecuredString(
    IN CDataExchange * pDX,
    IN int nIDC,
    IN OUT CStrPassword & value,
    IN LPCTSTR lpszDummy
    )
{
    MACRO_PASSWORD()
}

void AFXAPI 
DDX_Password(
    IN CDataExchange * pDX,
    IN int nIDC,
    IN OUT CString & value,
    IN LPCTSTR lpszDummy
    )
/*++

Routine Description:

    DDX_Text for passwords.  Always display a dummy string
    instead of the real password, and ask for confirmation
    if the password has changed

Arguments:

    CDataExchange * pDX : Data exchange structure
    int nIDC            : Control ID
    CString & value     : value
    LPCTSTR lpszDummy   : Dummy password string to be displayed

Return Value:

    None

--*/
{
    MACRO_PASSWORD()
}


void AFXAPI 
DDV_MinMaxBalloon(CDataExchange* pDX,int nIDC, DWORD minVal, DWORD maxVal)
{
    HWND hWndCtrl = pDX->PrepareEditCtrl(nIDC);
	if (pDX->m_bSaveAndValidate && ::IsWindowEnabled(hWndCtrl))
	{
		TCHAR szT[64];
		BOOL bShowFailure = TRUE;
		ULONGLONG nBigSpace = 0;
		ASSERT(minVal <= maxVal);
		ASSERT( hWndCtrl != NULL );

		// Get the text
		::GetWindowText(hWndCtrl, szT, sizeof(szT)/sizeof(TCHAR));

		// convert the text into a big number
		if (_stscanf(szT, _T("%I64u"), &nBigSpace) == 1)
		{
			// check the range...
			if (nBigSpace < minVal || nBigSpace > maxVal)
			{
				// failed
			}
			else
			{
				bShowFailure = FALSE;
			}
		}

		if (bShowFailure)
		{
			TCHAR szMin[32];
			TCHAR szMax[32];
			wsprintf(szMin, _T("%ld"), minVal);
			wsprintf(szMax, _T("%ld"), maxVal);
			CString prompt;
			AfxFormatString2(prompt, AFX_IDP_PARSE_INT_RANGE, szMin, szMax);
			ASSERT(pDX->m_hWndLastControl != NULL && pDX->m_bEditLastControl);
			EditShowBalloon(pDX->m_hWndLastControl, prompt);
			pDX->Fail();        
		}
	}
	return;
}

static void 
DDX_TextWithFormatBalloon(CDataExchange* pDX, int nIDC, LPCTSTR lpszFormat, UINT nIDPrompt, DWORD dwSizeOf, ...)
// only supports windows output formats - no floating point
{
	va_list pData;
	va_start(pData, dwSizeOf);

	HWND hWndCtrl = pDX->PrepareEditCtrl(nIDC);
    ASSERT( hWndCtrl != NULL );

	TCHAR szT[64];
	if (pDX->m_bSaveAndValidate)
	{
        if (::IsWindowEnabled(hWndCtrl))
        {
		    void* pResult;
		    pResult = va_arg( pData, void* );

		    // the following works for %d, %u, %ld, %lu
		    ::GetWindowText(hWndCtrl, szT, sizeof(szT)/sizeof(TCHAR));

		    // remove begining and trailing spaces
		    // remove beginning 0's
		    // check if there are too many characters to even fit in the numeric space provided
		    //int iTextLen = ::GetWindowTextLength(hWndCtrl);

		    // Will this string length even fit into the space they want us to put it into?
		    ULONGLONG nBigSpace = 0;
		    if (_stscanf(szT, _T("%I64u"), &nBigSpace) == 1)
		    {
			    // the string was assigned to the ia64
			    // check if it's larger than what was passed in.
			    if (dwSizeOf == sizeof(DWORD))
			    {
				    // 4 bytes
				    if (nBigSpace > 0xffffffff)
				    {
					    DDV_ShowBalloonAndFail(pDX, IDS_ERR_NUM_TOO_LARGE);
				    }
			    }
			    else if (dwSizeOf == sizeof(short))
			    {
				    // 2 bytes
				    if (nBigSpace > 0xffff)
				    {
					    DDV_ShowBalloonAndFail(pDX, IDS_ERR_NUM_TOO_LARGE);
				    }
			    }
			    else if (dwSizeOf == sizeof(char))
			    {
				    // 1 byte
				    if (nBigSpace > 0xff)
				    {
					    DDV_ShowBalloonAndFail(pDX, IDS_ERR_NUM_TOO_LARGE);
				    }
			    }
		    }

		    if (_stscanf(szT, lpszFormat, pResult) != 1)
		    {
                DDV_ShowBalloonAndFail(pDX, nIDPrompt);
		    }
        }
	}
	else
	{
		_vstprintf(szT, lpszFormat, pData);
		// does not support floating point numbers - see dlgfloat.cpp
		AfxSetWindowText(hWndCtrl, szT);
	}

	va_end(pData);
}

void AFXAPI
DDX_TextBalloon(CDataExchange* pDX, int nIDC, BYTE& value)
{
	int n = (int)value;
    HWND hWndCtrl = pDX->PrepareEditCtrl(nIDC);
    if (pDX->m_bSaveAndValidate)
	{
        if (::IsWindowEnabled(hWndCtrl))
        {
		    DDX_TextWithFormatBalloon(pDX, nIDC, _T("%u"), AFX_IDP_PARSE_BYTE, sizeof(BYTE), &n);
		    if (n > 255)
		    {
                DDV_ShowBalloonAndFail(pDX, AFX_IDP_PARSE_BYTE);
		    }
		    value = (BYTE)n;
        }
	}
	else
		DDX_TextWithFormatBalloon(pDX, nIDC, _T("%u"), AFX_IDP_PARSE_BYTE, sizeof(BYTE), n);
}

void AFXAPI  
DDX_TextBalloon(CDataExchange* pDX, int nIDC, short& value)
{
	if (pDX->m_bSaveAndValidate)
		DDX_TextWithFormatBalloon(pDX, nIDC, _T("%hd"), AFX_IDP_PARSE_INT, sizeof(short), &value);
	else
		DDX_TextWithFormatBalloon(pDX, nIDC, _T("%hd"), AFX_IDP_PARSE_INT, sizeof(short), value);
}

void AFXAPI 
DDX_TextBalloon(CDataExchange* pDX, int nIDC, int& value)
{
	if (pDX->m_bSaveAndValidate)
		DDX_TextWithFormatBalloon(pDX, nIDC, _T("%d"), AFX_IDP_PARSE_INT, sizeof(int), &value);
	else
		DDX_TextWithFormatBalloon(pDX, nIDC, _T("%d"), AFX_IDP_PARSE_INT, sizeof(int), value);
}

void AFXAPI 
DDX_TextBalloon(CDataExchange* pDX, int nIDC, UINT& value)
{
	if (pDX->m_bSaveAndValidate)
		DDX_TextWithFormatBalloon(pDX, nIDC, _T("%u"), AFX_IDP_PARSE_UINT, sizeof(UINT), &value);
	else
		DDX_TextWithFormatBalloon(pDX, nIDC, _T("%u"), AFX_IDP_PARSE_UINT, sizeof(UINT), value);
}

void AFXAPI 
DDX_TextBalloon(CDataExchange* pDX, int nIDC, long& value)
{
	if (pDX->m_bSaveAndValidate)
		DDX_TextWithFormatBalloon(pDX, nIDC, _T("%ld"), AFX_IDP_PARSE_INT, sizeof(long), &value);
	else
		DDX_TextWithFormatBalloon(pDX, nIDC, _T("%ld"), AFX_IDP_PARSE_INT, sizeof(long), value);
}

void AFXAPI 
DDX_TextBalloon(CDataExchange* pDX, int nIDC, DWORD& value)
{
	if (pDX->m_bSaveAndValidate)
		DDX_TextWithFormatBalloon(pDX, nIDC, _T("%lu"), AFX_IDP_PARSE_UINT, sizeof(DWORD), &value);
	else
		DDX_TextWithFormatBalloon(pDX, nIDC, _T("%lu"), AFX_IDP_PARSE_UINT, sizeof(DWORD), value);
}

void AFXAPI 
DDX_TextBalloon(CDataExchange* pDX, int nIDC, LONGLONG& value)
{
	if (pDX->m_bSaveAndValidate)
		DDX_TextWithFormatBalloon(pDX, nIDC, _T("%I64d"), AFX_IDP_PARSE_INT, sizeof(LONGLONG), &value);
	else
		DDX_TextWithFormatBalloon(pDX, nIDC, _T("%I64d"), AFX_IDP_PARSE_INT, sizeof(LONGLONG), value);
}

void AFXAPI 
DDX_TextBalloon(CDataExchange* pDX, int nIDC, ULONGLONG& value)
{
	if (pDX->m_bSaveAndValidate)
		DDX_TextWithFormatBalloon(pDX, nIDC, _T("%I64u"), AFX_IDP_PARSE_UINT, sizeof(ULONGLONG), &value);
	else
		DDX_TextWithFormatBalloon(pDX, nIDC, _T("%I64u"), AFX_IDP_PARSE_UINT, sizeof(ULONGLONG), value);
}

void AFXAPI 
DDX_Text(CDataExchange * pDX, int nIDC, CILong & value)
{
    HWND hWndCtrl = pDX->PrepareEditCtrl(nIDC);
    pDX->m_bEditLastControl = TRUE;

    TCHAR szT[NUMERIC_BUFF_SIZE + 1];

    if (pDX->m_bSaveAndValidate && ::IsWindowEnabled(hWndCtrl))
    {
        LONG l;

        ::GetWindowText(hWndCtrl, szT, NUMERIC_BUFF_SIZE);
        
        if (CINumber::ConvertStringToLong(szT, l))
        {
            value = l;
        }
        else
        {
//            HINSTANCE hOld = AfxGetResourceHandle();
//            AfxSetResourceHandle(hDLLInstance);
//            ASSERT(pDX->m_hWndLastControl != NULL && pDX->m_bEditLastControl);
			DDV_ShowBalloonAndFail(pDX, IDS_INVALID_NUMBER);
//
//          AfxSetResourceHandle(hOld);
//
//            pDX->Fail();
        }
    }
    else
    {
        ::wsprintf(szT, _T("%s"), (LPCTSTR)value);
        ::AfxSetWindowText(hWndCtrl, szT);
    }
}



CConfirmDlg::CConfirmDlg(CWnd * pParent)
    : CDialog(CConfirmDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CConfirmDlg)
    m_strPassword = _T("");
    //}}AFX_DATA_INIT
}



void 
CConfirmDlg::DoDataExchange(CDataExchange * pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CConfirmDlg)
    DDX_Text(pDX, IDC_EDIT_CONFIRM_PASSWORD, m_strPassword);
    //}}AFX_DATA_MAP
	if (pDX->m_bSaveAndValidate)
	{
		if (m_ref.Compare(m_strPassword) != 0)
		{
			DDV_ShowBalloonAndFail(pDX, IDS_PASSWORD_NO_MATCH);
		}
	}
}



//
// Message Handlers
//
BEGIN_MESSAGE_MAP(CConfirmDlg, CDialog)
    //{{AFX_MSG_MAP(CConfirmDlg)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\guid.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        guid.cpp

   Abstract:

        Initialization as required by initguid

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager (cluster edition)

   Revision History:

--*/

//
// Include Files
//
#include <stdafx.h>
#include <winsvc.h>

#include <objbase.h>
#include <initguid.h>

#include <iwamreg.h>
#include <iadmw.h>
#include <iisrsta.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\debugafx.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        debugafx.cpp

   Abstract:

        Debugging routines using AFX/MFC extensions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



//
// Include Files
//
#include "stdafx.h"
#include "common.h"


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



#define new DEBUG_NEW



#if defined(_DEBUG) || DBG



int 
IISUIFireAssert(
    const char * filename,
    const char * timestamp,
    int linenum,
    const char * expr
    )
{
    char sz[4096];
    char * pch = sz;

    pch += wsprintfA(pch, 
        "-------------------------------------------------------------------------------\n"
        "ASSERT FAILURE!\n"
        "-------------------------------------------------------------------------------\n"
        "File:\t\t%s\n"
        "Line:\t\t%u\n"
        "Time Stamp:\t%s\n"
        "-------------------------------------------------------------------------------\n",
        filename, linenum, timestamp
        );
        
    if (expr)
    {
        wsprintfA(pch, "Expression:\t%s\n"
        "-------------------------------------------------------------------------------\n",
        expr
        );
    } 

    TRACEEOL(sz);

    int nReturn = MessageBoxA(
        NULL, 
        sz, 
        "ASSERT FAILURE!", 
        MB_ABORTRETRYIGNORE | MB_DEFBUTTON1 | MB_ICONHAND
        );
    
    if (nReturn == IDABORT)
    {
        exit(-1);
    }
    
    //
    // Return 1 to break, 0 to ignore
    //
    return (nReturn == IDRETRY);
}



#endif // _DEBUG || DBG



#if defined(_DEBUG) || DBG



#ifndef _DEBUG
    //
    // SDK build links with retail MFC.  Swiped code from MFC sources.  Some
    // modifications.
    //
    COMDLL CDumpContext afxDump;
    COMDLL BOOL afxTraceEnabled = TRUE;

    void 
    CDumpContext::OutputString(LPCTSTR lpsz)
    {
        if (m_pFile == NULL)
        {
            OutputDebugString(lpsz);
            return;
        }

        m_pFile->Write(lpsz, lstrlen(lpsz)*sizeof(TCHAR));
    }

    CDumpContext::CDumpContext(CFile * pFile)
    {
        if (pFile)
        {
            ASSERT_PTR(pFile);
        }

        m_pFile = pFile;
        m_nDepth = 0;
    }

    void 
    CDumpContext::Flush()
    {
        if (m_pFile)
        {
            m_pFile->Flush();
        }
    }

    CDumpContext& CDumpContext::operator<<(LPCTSTR lpsz)
    {
        if (lpsz == NULL)
        {
            OutputString(_T("(NULL)"));
            return *this;
        }

        if (m_pFile == NULL)
        {
            TCHAR szBuffer[512];
            LPTSTR lpBuf = szBuffer;

            while (*lpsz != '\0')
            {
                if (lpBuf > szBuffer + ARRAY_SIZE(szBuffer) - 3)
                {
                    *lpBuf = '\0';
                    OutputString(szBuffer);
                    lpBuf = szBuffer;
                }

                if (*lpsz == '\n')
                {
                    *lpBuf++ = '\r';
                }

                *lpBuf++ = *lpsz++;
            }

            *lpBuf = '\0';
            OutputString(szBuffer);
            return *this;
        }

        m_pFile->Write(lpsz, lstrlen(lpsz) * sizeof(TCHAR));
        return *this;
    }

    CDumpContext& CDumpContext::operator<<(BYTE by)
    {
        TCHAR szBuffer[32];

        wsprintf(szBuffer, _T("%d"), (int)by);
        OutputString(szBuffer);

        return *this;
    }

    CDumpContext& CDumpContext::operator<<(WORD w)
    {
        TCHAR szBuffer[32];

        wsprintf(szBuffer, _T("%u"), (UINT) w);
        OutputString(szBuffer);

        return *this;
    }

    CDumpContext& CDumpContext::operator<<(UINT u)
    {
        TCHAR szBuffer[32];

        wsprintf(szBuffer, _T("0x%X"), u);
        OutputString(szBuffer);

        return *this;
    }

    CDumpContext& CDumpContext::operator<<(LONG l)
    {
        TCHAR szBuffer[32];

        wsprintf(szBuffer, _T("%ld"), l);
        OutputString(szBuffer);

        return *this;
    }

    CDumpContext& CDumpContext::operator<<(DWORD dw)
    {
        TCHAR szBuffer[32];

        wsprintf(szBuffer, _T("%lu"), dw);
        OutputString(szBuffer);

        return *this;
    }

    CDumpContext& CDumpContext::operator<<(int n)
    {
        TCHAR szBuffer[32];

        wsprintf(szBuffer, _T("%d"), n);
        OutputString(szBuffer);

        return *this;
    }

    CDumpContext& CDumpContext::operator<<(const CObject * pOb)
    {
        if (pOb == NULL)
        {
            *this << _T("NULL");
        }
        else
        {
            pOb->Dump(*this);
        }

        return *this;
    }

    CDumpContext& CDumpContext::operator<<(const CObject & ob)
    {
        return *this << &ob;
    }

    CDumpContext& CDumpContext::operator<<(const void * lp)
    {
        TCHAR szBuffer[32];

        wsprintf(szBuffer, _T("$%p"), lp);
        OutputString(szBuffer);

        return *this;
    }

    void 
    CDumpContext::HexDump(
        LPCTSTR lpszLine, 
        BYTE * pby,
        int nBytes, 
        int nWidth
        )
    {
        ASSERT(nBytes > 0);
        ASSERT(nWidth > 0);
        ASSERT(AfxIsValidString(lpszLine));
        ASSERT(AfxIsValidAddress(pby, nBytes, FALSE));

        int nRow = 0;
        TCHAR szBuffer[32];

        while (nBytes--)
        {
            if (nRow == 0)
            {
                wsprintf(szBuffer, lpszLine, pby);
                *this << szBuffer;
            }

            wsprintf(szBuffer, _T(" %02X"), *pby++);
            *this << szBuffer;

            if (++nRow >= nWidth)
            {
                *this << _T("\n");
                nRow = 0;
            }
        }

        if (nRow != 0)
        {
            *this << _T("\n");
        }
    }

    /////////////////////////////////////////////////////////////////////////////

    #ifdef _UNICODE
    
    CDumpContext & CDumpContext::operator<<(LPCSTR lpsz)
    {
        if (lpsz == NULL)
        {
            OutputString(L"(NULL)");
            return *this;
        }

        TCHAR szBuffer[512];
        _mbstowcsz(szBuffer, lpsz, ARRAY_SIZE(szBuffer));
        return *this << szBuffer;
    }

    #else   //_UNICODE

    CDumpContext& CDumpContext::operator<<(LPCWSTR lpsz)
    {
        if (lpsz == NULL)
        {
            OutputString("(NULL)");
            return *this;
        }

        char szBuffer[512];
        _wcstombsz(szBuffer, lpsz, ARRAY_SIZE(szBuffer));
        return *this << szBuffer;
    }

    #endif  //!_UNICODE

//
// End of block of code copied from MFC
//
#endif // _DEBUG



LPCSTR
DbgFmtPgm(
    IN LPCSTR szFn,
    IN int line
    )
/*++

Routine Description:

    Format debugging string containing file name and line number.  Remove
    the path portion of the file name if present.

Arguments:

    LPCSTR szFn : File name (ANSI)
    int line    : Line number

Return Value:

    Pointer to the internal buffer

--*/
{
    LPCSTR pszTail = szFn + lstrlenA(szFn);
    static CHAR szBuff[MAX_PATH + 1];

    for ( /**/; pszTail > szFn; --pszTail)
    {
        if (*pszTail == '\\' || *pszTail == ':')
        {
            ++pszTail;
            break;
        }
    }

    wsprintfA(szBuff, "[%s:%d] ", pszTail, line);

    return szBuff;
}



CDumpContext & 
operator <<(
    IN OUT CDumpContext & out,
    IN ENUM_DEBUG_AFX edAfx
    )
/*++

Routine Description:

    Output debugging control character to the debug context

Arguments:

    CDumpContext & out : Output debugging context
    edAfx              : Control character

Return Value:

    Output debugging context reference

--*/
{
    static CHAR * szEol = "\r\n";

    switch (edAfx)
    {
    case EDBUG_AFX_EOL:
        out << szEol;
        break;

    default:
        break;
    }

    return out;
}



#ifndef UNICODE



CDumpContext & 
operator <<(
    IN OUT CDumpContext & out,
    IN LPCWSTR pwchStr
    )
/*++

Routine Description:

    Insert a wide-character string into the output stream. For non-UNICODE only,
    as this functions would be handled by the generic 'T' function otherwise.

Arguments:

    CDumpContext & out : Output debugging context
    pwchStr            : Wide character string

Return Value:

    Output debugging context reference

--*/
{
    size_t cwch ;

    if (pwchStr == NULL)
    {
        out << "<null>";
    }
    else if ((cwch = ::wcslen(pwchStr )) > 0)
    {
        CHAR * pszTemp = (LPSTR)AllocMem(cwch + 2);

        if (pszTemp != NULL)
        {
            for (int i = 0; pwchStr[i]; ++i)
            {
                pszTemp[i] = (CHAR)pwchStr[i];
            }

            pszTemp[i] = 0;
            out << pszTemp;
            FreeMem(pszTemp);
        }
        else
        {
            out << "<memerr>";
        }
    }
    else
    {
        out << "\"\"";
    }

    return out;
}



#endif // UNICODE



CDumpContext & 
operator <<(
    IN CDumpContext & out,
    IN const GUID & guid
    )
/*++

Routine Description:

    Dump a GUID to the debugger

Arguments:

    CDumpContext & out : Output debugging context
    GUID & guid        : GUID

Return Value:

    Output debugging context reference

--*/
{
    out << "{ "
        << guid.Data1 
        << "," 
        << guid.Data2
        << "," 
        << guid.Data3 
        << "," 
        << guid.Data4 
        << "}";

    return out;
}


#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\ddxv.h ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        ddxv.h

   Abstract:
        DDX/DDV Routine definitions

   Author:
        Ronald Meijer (ronaldm)
		Sergei Antonov (sergeia)

   Project:
        Internet Services Manager (cluster edition)

   Revision History:
--*/
#include "strpass.h"

#ifndef _DDXV_H_
#define _DDXV_H_

//
// Helper macro to convert ID of dialog child control to window handle
//
#define CONTROL_HWND(nID) (::GetDlgItem(m_hWnd, nID))

//
// Dummy password
//
extern LPCTSTR COMDLL g_lpszDummyPassword;

HRESULT COMDLL AFXAPI 
LimitInputPath(HWND hWnd,BOOL bAllowSpecialPath);
HRESULT COMDLL AFXAPI 
LimitInputDomainName(HWND hWnd);

BOOL COMDLL
PathIsValid(LPCTSTR path,BOOL bAllowSpecialPath);

void COMDLL AFXAPI
EditShowBalloon(HWND hwnd, UINT ids);
void COMDLL AFXAPI
EditShowBalloon(HWND hwnd, CString txt);
void COMDLL AFXAPI
EditHideBalloon(void);
void COMDLL AFXAPI
DDV_ShowBalloonAndFail(CDataExchange * pDX, UINT ids);
void COMDLL AFXAPI
DDV_ShowBalloonAndFail(CDataExchange * pDX, CString txt);

void COMDLL AFXAPI 
DDV_MinMaxBalloon(CDataExchange* pDX, int nIDC, DWORD minVal, DWORD maxVal);
void COMDLL AFXAPI
DDV_MaxCharsBalloon(CDataExchange* pDX, CString const& value, int count);
void COMDLL AFXAPI 
DDV_MinChars(CDataExchange * pDX, CString const & value, int nChars);
void COMDLL AFXAPI 
DDV_MinMaxChars(CDataExchange * pDX, CString const & value, int nMinChars, int nMaxChars);
void COMDLL AFXAPI 
DDV_FilePath(CDataExchange * pDX, CString& value, BOOL local);
void COMDLL AFXAPI 
DDV_FolderPath(CDataExchange * pDX, CString& value, BOOL local);
void COMDLL AFXAPI 
DDV_UNCFolderPath(CDataExchange * pDX, CString& value, BOOL local);
void COMDLL AFXAPI 
DDV_Url(CDataExchange * pDX, CString& value );
void COMDLL AFXAPI
DDX_TextBalloon(CDataExchange* pDX, int nIDC, BYTE& value);
void COMDLL AFXAPI
DDX_TextBalloon(CDataExchange* pDX, int nIDC, short& value);
void COMDLL AFXAPI
DDX_TextBalloon(CDataExchange* pDX, int nIDC, int& value);
void COMDLL AFXAPI
DDX_TextBalloon(CDataExchange* pDX, int nIDC, UINT& value);
void COMDLL AFXAPI
DDX_TextBalloon(CDataExchange* pDX, int nIDC, long& value);
void COMDLL AFXAPI
DDX_TextBalloon(CDataExchange* pDX, int nIDC, DWORD& value);
void COMDLL AFXAPI
DDX_TextBalloon(CDataExchange* pDX, int nIDC, LONGLONG& value);
void COMDLL AFXAPI
DDX_TextBalloon(CDataExchange* pDX, int nIDC, ULONGLONG& value);
void COMDLL AFXAPI
DDX_Text(CDataExchange * pDX, int nIDC, CILong & value);
//
// Spin control ddx
//
void COMDLL AFXAPI 
DDX_Spin(CDataExchange * pDX, int nIDC, int & value);

//
// Enforce min/max spin control range
//
void COMDLL AFXAPI 
DDV_MinMaxSpin(CDataExchange * pDX, HWND hWndControl, int nLowerRange, int nUpperRange);
//
// Similar to DDX_Text -- but always display a dummy string.
//
void COMDLL AFXAPI 
DDX_Password(CDataExchange * pDX, int nIDC, CString & value, LPCTSTR lpszDummy);

void COMDLL AFXAPI 
DDX_Password_SecuredString(CDataExchange * pDX, int nIDC, CStrPassword & value, LPCTSTR lpszDummy);
void COMDLL AFXAPI 
DDX_Text_SecuredString(CDataExchange * pDX, int nIDC, CStrPassword & value);
void COMDLL AFXAPI
DDV_MaxChars_SecuredString(CDataExchange* pDX, CStrPassword const& value, int count);
void COMDLL AFXAPI
DDV_MaxCharsBalloon_SecuredString(CDataExchange* pDX, CStrPassword const& value, int count);
void COMDLL AFXAPI 
DDV_MinMaxChars_SecuredString(CDataExchange * pDX, CStrPassword const & value, int nMinChars, int nMaxChars);
void COMDLL AFXAPI 
DDV_MinChars_SecuredString(CDataExchange * pDX, CStrPassword const & value, int nChars);


class COMDLL CConfirmDlg : public CDialog
{
public:
    CConfirmDlg(CWnd * pParent = NULL);

public:
    CString& GetPassword() { return m_strPassword; }
	void SetReference(CString& str)
	{
		m_ref = str;
	}

protected:
    //{{AFX_DATA(CConfirmDlg)
    enum { IDD = IDD_CONFIRM_PASSWORD };
    CString m_strPassword;
    //}}AFX_DATA
	CString m_ref;

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CConfirmDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CConfirmDlg)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};



#endif // _DDXV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\dirbrows.h ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module Name :

        dirbrows.h

   Abstract:

        Directory Browser Dialog definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



#ifndef _DIRBROWS_H
#define _DIRBROWS_H



#ifndef _SHLOBJ_H_
#include <shlobj.h>
#endif // _SHLOBJ_H_



class COMDLL CDirBrowseDlg
/*++

Class Description:

    Directory browsing dialog.  Use the shell browser functionality to
    return a folder.  Optionally allow conversion of remote paths to 
    UNC paths.

Public Interface:

    CDirBrowseDlg   : Construct the dialog
    ~CDirBrowseDlg  : Destruct the dialog
    GetFullPath     : Get the full path selected

--*/
{
//
// Construction
//
public:
    //
    // standard constructor
    //
    CDirBrowseDlg(
        IN CWnd * pParent = NULL,
        IN LPCTSTR lpszInitialDir = NULL
        );

    ~CDirBrowseDlg();

public:
    LPCTSTR GetFullPath(
        OUT CString & str,
        IN  BOOL fConvertToUNC = TRUE
        ) const;

    virtual int DoModal();

protected:
    TCHAR m_szBuffer[MAX_PATH + 1];
    CComBSTR m_bstrTitle;
    CString m_strInitialDir;
    BROWSEINFO m_bi;
};



#endif // _DIRBROWS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\debugafx.h ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        debugafx.h

   Abstract:

        Debugging routines using AFX/MFC extensions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



#ifndef _DEBUGAFX_H
#define _DEBUGAFX_H



#if defined(_DEBUG) || DBG
    //
    // Defined private ASSERT macros because they're not available
    // in SDK builds (which always uses retail MFC)
    //
    #undef ATLASSERT
    #undef ASSERT
    #undef _ASSERTE
    #undef VERIFY

    #define _ASSERTE(expr)\
            do { if (!(expr) &&\
                    (IISUIFireAssert(__FILE__, __TIMESTAMP__, __LINE__, #expr)==1))\
                 DebugBreak(); } while (0)

    #define ASSERT(expr)    _ASSERTE(expr)

    #define VERIFY(expr)    _ASSERTE(expr)
    #define ATLASSERT(expr) _ASSERTE(expr)

    #define ASSERT_PTR(ptr)                 _ASSERTE(ptr != NULL);
    #define ASSERT_READ_PTR(ptr)            _ASSERTE(ptr != NULL && !IsBadReadPtr(ptr, sizeof(*ptr)));
    #define ASSERT_READ_PTR2(ptr, cb)       _ASSERTE(ptr != NULL && !IsBadReadPtr(ptr, cb));
    #define ASSERT_WRITE_PTR(ptr)           _ASSERTE(ptr != NULL && !IsBadWritePtr(ptr, sizeof(*ptr)));
    #define ASSERT_WRITE_PTR2(ptr, cb)      _ASSERTE(ptr != NULL && !IsBadWritePtr(ptr, cb));
    #define ASSERT_READ_WRITE_PTR(ptr)      ASSERT_READ_PTR(ptr); ASSERT_WRITE_PTR(ptr);
    #define ASSERT_READ_WRITE_PTR2(ptr, cb) ASSERT_READ_PTR2(ptr, cb); && ASSERT_WRITE_PTR2(ptr, cb);
    #define ASSERT_MSG(msg)\
            do { if (IISUIFireAssert(__FILE__, __TIMESTAMP__, __LINE__, msg)==1)\
                 DebugBreak(); } while (0)

    int COMDLL IISUIFireAssert(
        const char * filename,
        const char * timestamp,
        int linenum,
        const char * expr
        );

#else
    //
    // Retail
    //
    #define ASSERT_PTR(ptr)           
    #define ASSERT_READ_PTR(ptr)
    #define ASSERT_READ_PTR2(ptr, cb)
    #define ASSERT_WRITE_PTR(ptr)
    #define ASSERT_WRITE_PTR2(ptr, cb)
    #define ASSERT_READ_WRITE_PTR(ptr)
    #define ASSERT_READ_WRITE_PTR2(ptr, cb)
    #define ASSERT_MSG(msg)                 

#endif // _DEBUG || DBG



#if defined(_DEBUG) || DBG

#ifndef _DEBUG
    //
    // SDK Build environment
    //
    extern COMDLL CDumpContext afxDump;
    extern COMDLL BOOL afxTraceEnabled;
#endif // _DEBUG

    //
    // ENUM for special debug output control tokens
    //
    enum ENUM_DEBUG_AFX 
    { 
        EDBUG_AFX_EOL = -1 
    };

    #define TRACEFMTPGM        DbgFmtPgm(THIS_FILE, __LINE__)
    #define TRACEOUT(x)        { afxDump << x; }
    #define TRACEEOL(x)        { afxDump << x << EDBUG_AFX_EOL; }
    #define TRACEEOLID(x)      { afxDump << TRACEFMTPGM << x << EDBUG_AFX_EOL; }
    #define TRACEEOLERR(err,x) { if (err) TRACEEOLID(x) }

    //
    // Append an EOL onto the debug output stream
    //
    COMDLL CDumpContext & operator <<(
        IN CDumpContext & out,
        IN ENUM_DEBUG_AFX edAfx
        );

#ifndef UNICODE

    COMDLL CDumpContext & operator <<(
        IN CDumpContext & out,
        IN LPCWSTR pwchStr
        );

#endif UNICODE

    //
    // Format a program name and line number for output (removes the path info)
    //
    COMDLL extern LPCSTR DbgFmtPgm(
        IN LPCSTR szFn,
        IN int line
        );

    COMDLL CDumpContext & operator <<(
        IN CDumpContext & out,
        IN const GUID & guid
        );

#else // !_DEBUG

    //
    // Retail definitions
    //
    #define TRACEOUT(x)              ;
    #define TRACEEOL(x)              ;
    #define TRACEEOLID(x)            ;
    #define TRACEEOLERR(err, x)      ;

#endif // _DEBUG

    #define TRACE_RETURN(msg, err) TRACEEOLID(msg); return err;
    #define TRACE_NOTIMPL(msg)     TRACE_RETURN(msg, E_NOTIMPL);
    #define TRACE_NOINTERFACE(msg) TRACE_RETURN(msg, E_NOINTERFACE);
    #define TRACE_UNEXPECTED(msg)  TRACE_RETURN(msg, E_UNEXPECTED);
    #define TRACE_POINTER(msg)     TRACE_RETURN(msg, E_POINTER);

#endif // _DEBUGAFX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\dirbrows.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module Name :

        dirbrows.cpp

   Abstract:

        Directory Browser Dialog.  Allow browsing for directories only.
        optionally allows UNC conversions for remote paths.

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "common.h"
#include "dirbrows.h"
#include <dlgs.h>



#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


extern HINSTANCE hDLLInstance;



static
int 
BrowseCallbackProc(
   IN HWND hwnd,    
   IN UINT uMsg,    
   IN LPARAM lParam,    
   IN LPARAM lpData 
   )
/*++

Routine Description:

    Callback function for the folder browser

Arguments:

    hwnd     : Handle to the browse dialog box. The callback function can 
               send the following messages to this window:

               BFFM_ENABLEOK      Enables the OK button if the wParam parameter 
                                  is nonzero or disables it if wParam is zero.
               BFFM_SETSELECTION  Selects the specified folder. The lParam 
                                  parameter is the PIDL of the folder to select 
                                  if wParam is FALSE, or it is the path of the 
                                  folder otherwise.
               BFFM_SETSTATUSTEXT Sets the status text to the null-terminated 
                                  string specified by the lParam parameter.
 
    uMsg     : Value identifying the event. This parameter can be one of the 
               following values:

               0                  Initialize dir path.  lParam is the path.

               BFFM_INITIALIZED   The browse dialog box has finished 
                                  initializing. lpData is NULL.
               BFFM_SELCHANGED    The selection has changed. lpData 
                                  is a pointer to the item identifier list for 
                                  the newly selected folder.
 
    lParam   : Message-specific value. For more information, see the 
               description of uMsg.

    lpData   : Application-defined value that was specified in the lParam 
               member of the BROWSEINFO structure.

Return Value:

    0

--*/
{
   lpData;
    static LPCTSTR lpstrDir = NULL;

    switch(uMsg)
    {
    case 0:
        lpstrDir = (LPCTSTR)lParam;
        break;

    case BFFM_INITIALIZED:
        //
        // Dialog initialized -- select desired folder
        //
        if (lpstrDir != NULL)
        {
            ::SendMessage(hwnd, BFFM_SETSELECTION, TRUE, (LPARAM)lpstrDir);
        }
        break;
    }

    return 0;
}



CDirBrowseDlg::CDirBrowseDlg(
    IN CWnd * pParent         OPTIONAL,
    IN LPCTSTR lpszInitialDir OPTIONAL
    )
/*++

Routine Description:

    Constructor for directory browser dialog

Arguments:

    CWnd * pParent         : Parent window or NULL
    LPCTSTR lpszInitialDir : Initial directory, or NULL for current directory

Return Value:

    N/A

--*/
    : m_strInitialDir(lpszInitialDir)
{
    VERIFY(m_bstrTitle.LoadString(hDLLInstance, IDS_BROWSE_DIRECTORY));

    m_bi.pidlRoot = NULL;
    m_bi.hwndOwner = pParent ? pParent->m_hWnd : NULL;
    m_bi.pszDisplayName = m_szBuffer;
    m_bi.lpszTitle = m_bstrTitle;
    m_bi.ulFlags = BIF_RETURNFSANCESTORS | BIF_RETURNONLYFSDIRS,
    m_bi.lpfn = BrowseCallbackProc;
    m_bi.lParam = 0;

    //
    // Let the callback function know the default dir is
    //
    lpszInitialDir = !m_strInitialDir.IsEmpty() 
        ? (LPCTSTR)m_strInitialDir : NULL;
    BrowseCallbackProc(m_bi.hwndOwner, 0, (LPARAM)lpszInitialDir, NULL);
}



CDirBrowseDlg::~CDirBrowseDlg()
/*++

Routine Description:

    Destructor for directory browser dialog

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    if (m_bi.pidlRoot != NULL)
    {
        LPITEMIDLIST pidl = (LPITEMIDLIST)m_bi.pidlRoot;

        //
        // Free using shell allocator
        //
        LPMALLOC pMalloc;
        if (::SHGetMalloc(&pMalloc) == NOERROR)
        {
            pMalloc->Free(pidl);
            pMalloc->Release();
        }
    }
}



/* virtual */
int 
CDirBrowseDlg::DoModal()
/*++

Routine Description:

    Display the browser dialog, and fill in the selected directory path.

Arguments:

    None

Return Value:

    IDOK if the OK button was pressed, IDCANCEL otherwise.

--*/
{
    BOOL fSelectionMade = FALSE;

    //
    // Get the Shell's default allocator
    //
    LPMALLOC pMalloc;
    if (::SHGetMalloc(&pMalloc) == NOERROR)
    {
        LPITEMIDLIST pidl;

        if ((pidl = ::SHBrowseForFolder(&m_bi)) != NULL)
        {
            if (::SHGetPathFromIDList(pidl, m_szBuffer))
            {
                fSelectionMade = TRUE;
            }
            else
            {
                //
                // OK Pressed, but no path found
                //
                ::AfxMessageBox(IDS_BAD_BROWSE);
            }

            //
            // Free the PIDL allocated by SHBrowseForFolder.
            //
            pMalloc->Free(pidl);
        }

        //
        // Release the shell's allocator.
        //
        pMalloc->Release();
    }

    return fSelectionMade ? IDOK : IDCANCEL;
}



LPCTSTR
CDirBrowseDlg::GetFullPath(
    OUT CString & strName,
    IN  BOOL fConvertToUNC
    ) const
/*++

Routine Description:

    Get the full path selected.  Optionally allow a remote path to be
    converted to a UNC path.

Arguments:

    CString & strName  : String in which to return the directory path
    BOOL fConvertToUNC : If TRUE, then if the drive selected is a network
                         drive, convert the path to a UNC path.

Return Value:

    A pointer to the directory path string or NULL in case of error.

Notes:

    This function should be called only after the dialog has been dismissed.

--*/
{
    LPCTSTR lp = NULL;

    try
    {
        strName = m_szBuffer;
        lp = strName;

        if (fConvertToUNC && lp != NULL)
        {
            //
            // If it's network drive, convert it to a UNC path
            //
            CString strDrive, strUNC;

            if (IsNetworkPath(strName, &strDrive, &strUNC))
            {
                strUNC += (lp + 2);
                strName = strUNC;
            }

            lp = strName;
        }
    }
    catch(CMemoryException * e)
    {
        TRACEEOLID("!!!exception getting path");
        strName.Empty();
        e->ReportError();
        e->Delete();
    }

    return lp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\hosthead.h ===
HRESULT COMDLL IsValidHostHeader(LPCTSTR pHostHeader);
HRESULT COMDLL IsAllNumHostHeader(LPCTSTR pHostname);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\iisdebug.cpp ===
#include "stdafx.h"
#include "common.h"
#include "iisdebug.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif
#define new DEBUG_NEW

INT g_iDebugOutputLevel = 0;

void GetOutputDebugFlag(void)
{
    DWORD rc, err, size, type;
    HKEY  hkey;
    err = RegOpenKey(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\InetMgr"), &hkey);
    if (err != ERROR_SUCCESS) {return;}
    size = sizeof(DWORD);
    err = RegQueryValueEx(hkey,_T("OutputDebugFlag"),0,&type,(LPBYTE)&rc,&size);
    if (err != ERROR_SUCCESS || type != REG_DWORD) {rc = 0;}
    RegCloseKey(hkey);

	if (rc < 0xffffffff)
	{
		g_iDebugOutputLevel = rc;
	}
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\idlg.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        idlg.cpp

   Abstract:

        Inheritance Dialog

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "common.h"
#include "iisdebug.h"
#include "idlg.h"



#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


#define new DEBUG_NEW


extern HINSTANCE hDLLInstance;


//
// Inheritance dialog
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

CInheritanceDlg::CInheritanceDlg(
    IN DWORD dwMetaID,
    IN BOOL fWrite,
    IN CComAuthInfo * pAuthInfo,            OPTIONAL
    IN LPCTSTR lpstrMetaRoot,
    IN CStringList & strlMetaChildNodes,
    IN LPCTSTR lpstrPropertyName,           OPTIONAL
    IN CWnd * pParent                       OPTIONAL
    )
/*++

Routine Description:

    Inheritance dialog constructor.  This constructor assumes GetDataPaths()
    has already been called.

Arguments:

    DWORD dwMetaID                      : Meta ID
    BOOL fWrite                         : TRUE from write, FALSE from delete
    CIISServer * pAuthInfo              : Auth info object or NULL
    LPCTSTR lpstrMetaRoot               : Meta root
    CStringList & strlMetaChildNodes    : List of child nodes from GetDataPaths
    LPCTSTR lpstrPropertyName           : Optional text string for the property
    CWnd * pParent                      : Optional parent window

Return Value:

    None

--*/
    : m_fWrite(fWrite),
      m_fEmpty(TRUE),
      m_fUseTable(TRUE),
      m_strMetaRoot(lpstrMetaRoot),
      m_strPropertyName(lpstrPropertyName ? lpstrPropertyName : _T("")),
      m_mk(pAuthInfo),
      CDialog(CInheritanceDlg::IDD, pParent)
{
    m_strlMetaChildNodes = strlMetaChildNodes;

    VERIFY(CMetaKey::GetMDFieldDef(
        dwMetaID, 
        m_dwMDIdentifier, 
        m_dwMDAttributes, 
        m_dwMDUserType,
        m_dwMDDataType
        ));

    Initialize();
}



CInheritanceDlg::CInheritanceDlg(
    IN DWORD dwMetaID,
    IN BOOL fWrite,
    IN CComAuthInfo * pAuthInfo,            OPTIONAL
    IN LPCTSTR lpstrMetaRoot,
    IN LPCTSTR lpstrPropertyName,           OPTIONAL
    IN CWnd * pParent                       OPTIONAL
    )
/*++

Routine Description:

    Inheritance dialog constructor.  This constructor will call GetDataPaths().

Arguments:

    DWORD dwMetaID                      : Meta ID
    BOOL fWrite                         : TRUE from write, FALSE from delete
    CComAuthInfo * pAuthInfo            : Auth info or NULL
    LPCTSTR lpstrMetaRoot               : Meta root
    LPCTSTR lpstrPropertyName           : Optional text string for the property
    CWnd * pParent                      : Optional parent window

Return Value:

    None

--*/
    : m_fWrite(fWrite),
      m_fEmpty(TRUE),
      m_fUseTable(TRUE),
      m_strMetaRoot(lpstrMetaRoot),
      m_strlMetaChildNodes(),
      m_strPropertyName(lpstrPropertyName ? lpstrPropertyName : _T("")),
      m_mk(pAuthInfo),
      CDialog(CInheritanceDlg::IDD, pParent)
{
    //
    // Specify the resources to use
    //
    HINSTANCE hOldRes = AfxGetResourceHandle();
    AfxSetResourceHandle(hDLLInstance);

    VERIFY(CMetaKey::GetMDFieldDef(
        dwMetaID, 
        m_dwMDIdentifier, 
        m_dwMDAttributes, 
        m_dwMDUserType,
        m_dwMDDataType
        ));

    //
    // Need to do our own GetDataPaths()
    //
    CError err(GetDataPaths());

    if (!err.MessageBoxOnFailure(m_hWnd))
    {
        Initialize();
    }

    //
    // Restore the resources
    //
    AfxSetResourceHandle(hOldRes);
}



CInheritanceDlg::CInheritanceDlg(
    IN BOOL    fTryToFindInTable,
    IN DWORD   dwMDIdentifier,
    IN DWORD   dwMDAttributes,
    IN DWORD   dwMDUserType,
    IN DWORD   dwMDDataType,
    IN LPCTSTR lpstrPropertyName,
    IN BOOL    fWrite,
    IN CComAuthInfo * pAuthInfo,        OPTIONAL
    IN LPCTSTR lpstrMetaRoot,
    IN CWnd *  pParent                  OPTIONAL
    )
/*++

Routine Description:

    Inheritance dialog constructor.  This constructor will call GetDataPaths(),
    and will use the specified parameters if the property ID does not exist
    in the property table

Arguments:

    BOOL    fTryToFindInTable           : If TRUE, first look in table
    DWORD   dwMDIdentifier              : Metadata identifier
    DWORD   dwMDAttributes              : Metadata attributes
    DWORD   dwMDUserType                : Metadata user type
    DWORD   dwMDDataType                : Metadata data type
    LPCTSTR lpstrPropertyName           : Text string for the property
    BOOL    fWrite                      : TRUE from write, FALSE from delete
    CComAuthInfo * pAuthInfo            : Authentication info or NULL.
    LPCTSTR lpstrMetaRoot               : Meta root
    CWnd *  pParent                     : Optional parent window

Return Value:

    None

--*/
    : m_fWrite(fWrite),
      m_fEmpty(TRUE),
      m_fUseTable(FALSE),
      m_strMetaRoot(lpstrMetaRoot),
      m_strlMetaChildNodes(),
      m_mk(pAuthInfo),
      CDialog(CInheritanceDlg::IDD, pParent)
{
    //
    // Specify the resources to use
    //
    HINSTANCE hOldRes = AfxGetResourceHandle();
    AfxSetResourceHandle(hDLLInstance);

    if (fTryToFindInTable && !CMetaKey::GetMDFieldDef(
        dwMDIdentifier, 
        m_dwMDIdentifier, 
        m_dwMDAttributes, 
        m_dwMDUserType,
        m_dwMDDataType
        ))
    {
        //
        // Did not exist in the table, use specified parameters
        //
        m_dwMDIdentifier  = dwMDIdentifier;
        m_dwMDAttributes  = dwMDAttributes;
        m_dwMDUserType    = dwMDUserType;
        m_dwMDDataType    = dwMDDataType;
        m_strPropertyName = lpstrPropertyName;
    }


    //
    // Need to do our own GetDataPaths()
    //
    CError err(GetDataPaths());

    if (!err.MessageBoxOnFailure(m_hWnd))
    {
        Initialize();
    }

    //
    // Restore the resources
    //
    AfxSetResourceHandle(hOldRes);
}



HRESULT
CInheritanceDlg::GetDataPaths()
/*++

Routine Description:

    GetDataPaths()

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    //ASSERT(!m_strServer.IsEmpty());

    CError err(m_mk.QueryResult());

    if (err.Succeeded())
    {
        err = m_mk.GetDataPaths( 
            m_strlMetaChildNodes,
            m_dwMDIdentifier,
            m_dwMDDataType,
            m_strMetaRoot
            );
    }

    return err;
}



void
CInheritanceDlg::Initialize()
/*++

Routine Description:

    Initialize data members.  Set the m_fEmpty flag to determine if
    it is necessary to proceed.

Arguments:

    None

Return Value:

    None

--*/
{
    //{{AFX_DATA_INIT(CInheritanceDlg)
    //}}AFX_DATA_INIT

    CMetabasePath::CleanMetaPath(m_strMetaRoot);

    if (m_fUseTable && !CMetaKey::IsPropertyInheritable(m_dwMDIdentifier))
    {
        //
        // No point in displaying non-inheritable properties
        //
        return;
    }

    switch(m_dwMDIdentifier)
    {
    //
    // Ignore these properties, even though they are inheritable
    //
    case MD_VR_PATH:
    case MD_DOWNLEVEL_ADMIN_INSTANCE:
    case MD_APP_ISOLATED:
    case MD_APP_FRIENDLY_NAME:
        return;
    }

    //
    // Check to see if the current metabase path contains an instance
    //
    CString strTmp;
    m_fHasInstanceInMaster = FriendlyInstance(m_strMetaRoot, strTmp);

    //
    // If property name was not specified in the constructor, load default
    // one from table.
    //
    if (m_strPropertyName.IsEmpty())
    {
        ASSERT(m_fUseTable);

        //
        // Specify the resources to use
        //
        HINSTANCE hOldRes = AfxGetResourceHandle();
        AfxSetResourceHandle(hDLLInstance);

        VERIFY(CMetaKey::GetPropertyDescription(
            m_dwMDIdentifier, 
            m_strPropertyName
            ));

        AfxSetResourceHandle(hOldRes);
    }

    //
    // Go through the list of metapaths, and clean them
    // up.
    //
    POSITION pos = m_strlMetaChildNodes.GetHeadPosition();

    while(pos)
    {
        CString & strMetaPath = m_strlMetaChildNodes.GetNext(pos);
        CMetabasePath::CleanMetaPath(strMetaPath);
    }

    //
    // If the special info key (lm/service/info) is in the list, remove it.
    // We only need to this if the key that is getting the
    // change (m_strMetaRoot) is the service master property (lm/service).
    // If it is anything else, then the special "info" key cannot be below
    // it so we don't need to check. Thus the first test is to see if there
    // is only one "/" character. If there is only one, then we know it is
    // the service and we can go ahead and do the test.  In some ways,
    // mfc is a pain, so we limited to the CString methods to do this
    // copy the root into the temp string.
    //
    int iSlash = m_strMetaRoot.ReverseFind(SZ_MBN_SEP_CHAR);

    if (iSlash >= 0)
    {
        strTmp = m_strMetaRoot.Left(iSlash);

        //
        // Now make sure that there aren't any more slashes
        //
        if (strTmp.Find(SZ_MBN_SEP_CHAR) == -1)
        {
            //
            // Now build the path to the special info key by adding it
            // to the meta root
            //
            strTmp = m_strMetaRoot + SZ_MBN_SEP_CHAR + IIS_MD_SVC_INFO_PATH;

            TRACEEOLID("Removing any descendants of " << strTmp);

            //
            // Search the list for the info key and remove it if we find it
            //
            pos = m_strlMetaChildNodes.GetHeadPosition();

            while(pos)
            {
                POSITION pos2 = pos;
                CString & strMetaPath = m_strlMetaChildNodes.GetNext(pos);
                TRACEEOLID("Checking " << strMetaPath);

                if (strTmp.CompareNoCase(
                    strMetaPath.Left(strTmp.GetLength())) == 0)
                {
                    TRACEEOLID("Removing service/info metapath from list");
                    m_strlMetaChildNodes.RemoveAt(pos2);
                }
            }
        }
    }

    //
    // Remove the first item if it's the current metapath
    //
    pos = m_strlMetaChildNodes.GetHeadPosition();
    if (pos)
    {
        TRACEEOLID("Stripping " << m_strMetaRoot);

        CString & strMetaPath = m_strlMetaChildNodes.GetAt(pos);

        if (strMetaPath.CompareNoCase(m_strMetaRoot) == 0)
        {
            TRACEEOLID("Removing current metapath from list");
            m_strlMetaChildNodes.RemoveHead();
        }
    }

    TRACEEOLID("ID=" << m_dwMDIdentifier << " Prop=" << m_strPropertyName);

    m_fEmpty = m_strlMetaChildNodes.GetCount() == 0;
}



/* virtual */
INT_PTR
//int
CInheritanceDlg::DoModal()
/*++

Routine Description:

    Display the dialog.

Arguments:

    None

Return Value:

    IDOK if the OK button was pressed, IDCANCEL otherwise.

--*/
{
    //
    // Specify the resources to use
    //
    HINSTANCE hOldRes = AfxGetResourceHandle();
    AfxSetResourceHandle(hDLLInstance);

    INT_PTR answer = CDialog::DoModal();

    //
    // restore the resources
    //
    AfxSetResourceHandle(hOldRes);

    return answer;
}




void
CInheritanceDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CInheritanceDlg)
    DDX_Control(pDX, IDC_LIST_CHILD_NODES, m_list_ChildNodes);
    //}}AFX_DATA_MAP
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CInheritanceDlg, CDialog)
    //{{AFX_MSG_MAP(CInheritanceDlg)
    ON_BN_CLICKED(IDC_BUTTON_SELECT_ALL, OnButtonSelectAll)
    ON_BN_CLICKED(ID_HELP, OnHelp)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



BOOL
CInheritanceDlg::FriendlyInstance(
    IN  CString & strMetaRoot,
    OUT CString & strFriendly
    )
/*++

Routine Description:

    Replace the instance number with its descriptive name.

Arguments:

    CString & strMetaRoot       : Metabase path
    CString & strFriendly       : Converted output friendly path.

Return Value:

    TRUE if the path contained an instance number.

--*/
{
    //
    // Break into fields
    //
    // CODEWORK: make static like BuildMetaPath
    //
    LPCTSTR lp = _tcschr(strMetaRoot, SZ_MBN_SEP_CHAR); // lm

    if (lp != NULL)
    {
        LPCTSTR lp2 = lp;
        CString strService(++lp2);
        lp = _tcschr(++lp, SZ_MBN_SEP_CHAR);  // service name

        if (lp == NULL)
        {
            //
            // Master Instance (can never be a descendant)
            //
            //strFriendly = m_strWebMaster;
            return FALSE;
        }
        else
        {
            strService.ReleaseBuffer(DIFF(lp - lp2));
        }
        TRACEEOLID(strService);

        CString keyType;
        HRESULT hr = m_mk.Open(METADATA_PERMISSION_READ, strMetaRoot);
        if (SUCCEEDED(hr))
        {
            hr = m_mk.QueryValue(MD_KEY_TYPE, keyType);
		    if (FAILED(hr))
            {
                return FALSE;
            }
            else
            {
                // Succeeded,
                // but check if this is a keytype that
                // we want to get the friendlyname for
                if (
                   0 == keyType.CompareNoCase(IIS_CLASS_WEB_SERVER_W)
			    && 0 == keyType.CompareNoCase(IIS_CLASS_FTP_SERVER_W)
                && 0 == keyType.CompareNoCase(IIS_CLASS_WEB_VDIR_W)
                && 0 == keyType.CompareNoCase(IIS_CLASS_WEB_DIR_W)
                && 0 == keyType.CompareNoCase(IIS_CLASS_WEB_FILE_W)
                && 0 == keyType.CompareNoCase(IIS_CLASS_FTP_VDIR_W)
                )
                {
                    return FALSE;
                }

            }
            m_mk.Close();
        }

        DWORD dwInstance = _ttol(++lp);
        TRACEEOLID(dwInstance);
        lp = _tcschr(lp, SZ_MBN_SEP_CHAR);       // Instance #

        BOOL bThisIsTheRootDir = FALSE;
        if (lp != NULL)
        {
            lp = _tcschr(++lp, SZ_MBN_SEP_CHAR); // Skip "ROOT"
            if (!lp)
            {
                bThisIsTheRootDir = TRUE;
            }
        }

        hr = m_mk.Open(
            METADATA_PERMISSION_READ, 
            CMetabasePath(strService, dwInstance)
            );

        if (SUCCEEDED(hr))
        {
            CString strComment;
            hr = m_mk.QueryValue(MD_SERVER_COMMENT, strComment);
            m_mk.Close();

            if (FAILED(hr) || strComment.IsEmpty())
            {
                strFriendly.Format(
                    SZ_MBN_MACHINE SZ_MBN_SEP_STR _T("%s") SZ_MBN_SEP_STR _T("%d"),
                    (LPCTSTR)strService,
                    dwInstance
                    );
            }
            else
            {
                strFriendly.Format(
                    SZ_MBN_MACHINE SZ_MBN_SEP_STR _T("%s") SZ_MBN_SEP_STR _T("%s"),
                    (LPCTSTR)strService,
                    (LPCTSTR)strComment
                    );
            }

            TRACEEOLID(strFriendly);

            //
            // Append the rest of the path
            //
            if (lp != NULL)
            {
                strFriendly += lp;
            }
            else
            {
                if (bThisIsTheRootDir)
                {
                    strFriendly += SZ_MBN_SEP_CHAR;
                }
            }

            return TRUE;
        }
    }
    return FALSE;
}



CString &
CInheritanceDlg::CleanDescendantPath(
    IN OUT CString & strMetaPath
    )
/*++

Routine Description:

    Clean the descendant metabase path.  The path is shown
    as a descendant of the current metabase root, and instance
    numbers are replaced with their description names.

Arguments:

    CString & strMetaPath   : Metabase path to be treated

Return Value:

    Reference to the cleaned-up path.

--*/
{
    //
    // This better be a descendant!
    //
    ASSERT(strMetaPath.GetLength() >= m_strMetaRoot.GetLength());
    ASSERT(!::_tcsnicmp(strMetaPath, m_strMetaRoot, m_strMetaRoot.GetLength()));

    // we do care only about something below LM
    CString machine_path;
    CMetabasePath::GetMachinePath(strMetaPath, machine_path);
    if (machine_path.CompareNoCase(SZ_MBN_MACHINE) == 0)
    {
       if (!m_fHasInstanceInMaster)
       {
           //
           // Need to replace the instance number with the friendly
           // name.
           //
           CString strTmp;
           if (FriendlyInstance(strMetaPath, strTmp))
           {
               strMetaPath = strTmp;
           }
       }

       strMetaPath = strMetaPath.Mid(m_strMetaRoot.GetLength() + 1);
    }
    return strMetaPath;
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL
CInheritanceDlg::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    //
    // Get friendly name for the property, and set the text.
    //
    CString strPrompt; 
    CComBSTR bstrFmt;
    VERIFY(bstrFmt.LoadString(hDLLInstance, IDS_INHERITANCE_PROMPT));
    strPrompt.Format(bstrFmt, (LPCTSTR)m_strPropertyName);
    GetDlgItem(IDC_STATIC_PROMPT)->SetWindowText(strPrompt);

    //
    // Turn inherited nodes into friendly paths, and add them
    // to the listbox.  Note the "current" node should have been
    // deleted at this stage.
    //
    POSITION pos = m_strlMetaChildNodes.GetHeadPosition();

    while(pos)
    {
        CString strNode = m_strlMetaChildNodes.GetNext(pos);
        m_list_ChildNodes.AddString(CleanDescendantPath(strNode));
    }

    return TRUE;
}



void
CInheritanceDlg::OnButtonSelectAll()
/*++

Routine Description:

    'Select All' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Select all entries
    //
    if (m_list_ChildNodes.GetCount() == 1)
    {
        //
        // SelItemRange refuses to do a single member
        //
        m_list_ChildNodes.SetSel(0, TRUE);
    }
    else
    {
        m_list_ChildNodes.SelItemRange(
            TRUE, 
            0, 
            m_list_ChildNodes.GetCount() - 1
            );
    }
}



void
CInheritanceDlg::OnOK()
{
    //
    // Now delete the property for all selected child nodes.
    // Grab from the orginal list, and not the listbox
    // as the latter have been frienly-fied, and is no longer
    // usable.
    //
    int cItems = m_list_ChildNodes.GetCount();
    ASSERT(cItems > 0);

    CString strMetaPath;
    CError err(m_mk.QueryResult());

    if (err.Succeeded())
    {
        int i = 0;
        POSITION pos = m_strlMetaChildNodes.GetHeadPosition();

        while(pos)
        {
            strMetaPath = m_strlMetaChildNodes.GetNext(pos);

            if (m_list_ChildNodes.GetSel(i++) > 0)
            {
                TRACEEOLID("Deleting property on " << strMetaPath);

                err = m_mk.Open(METADATA_PERMISSION_WRITE, strMetaPath);

                if (err.Failed())
                {
                    break;
                }

                err = m_mk.DeleteValue(m_dwMDIdentifier);

                m_mk.Close();

                if (err.Failed())
                {
                    break;
                }
            }
        }
    }

    if (!err.MessageBoxOnFailure(m_hWnd))
    {
        //
        // Dialog can be dismissed
        //
        CDialog::OnOK();
    }
}

const LPCTSTR g_cszInetMGRBasePath = _T("Software\\Microsoft\\InetMGR");
const LPCTSTR g_cszParameters      = _T("Parameters");
const LPCTSTR g_cszHelpPath        = _T("HelpLocation");

void
CInheritanceDlg::OnHelp()
{
    CString strKey, path;
    strKey.Format(_T("%s\\%s"), g_cszInetMGRBasePath, g_cszParameters);
    CRegKey rk;
    rk.Create(HKEY_LOCAL_MACHINE, strKey);
    DWORD len = MAX_PATH;
    rk.QueryValue(path.GetBuffer(len), g_cszHelpPath, &len);
    path.ReleaseBuffer(-1);
    path += _T("\\inetmgr.hlp");
	DebugTraceHelp(0x20000 + CInheritanceDlg::IDD);
	::WinHelp(m_hWnd, path, HELP_CONTEXT, 0x20000 + CInheritanceDlg::IDD);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\iisdebug.h ===
#include "debugdefs.h"

void GetOutputDebugFlag(void);

extern INT g_iDebugOutputLevel;

#if defined(_DEBUG) || DBG
	#define DEBUG_FLAG
#endif

#ifdef DEBUG_FLAG
    inline void _cdecl DebugTraceHelp(DWORD_PTR dwWinHelpID)
    {
        // Only do this if the flag is set.
        if (0 != g_iDebugOutputLevel)
        {
			if (DEBUG_FLAG_HELP & g_iDebugOutputLevel)
			{
				TCHAR szBuffer[30];
				_stprintf(szBuffer,_T("WinHelp:0x%x,%d\r\n"),dwWinHelpID,dwWinHelpID);
				OutputDebugString(szBuffer);
			}
		}
        return;
    }

    inline void _cdecl DebugTrace(LPTSTR lpszFormat, ...)
    {
        // Only do this if the flag is set.
        if (0 != g_iDebugOutputLevel)
        {
			if (DEBUG_FLAG_MODULE_IISUI & g_iDebugOutputLevel)
			{
				int nBuf;
				TCHAR szBuffer[_MAX_PATH];
				va_list args;
				va_start(args, lpszFormat);

				nBuf = _vsntprintf(szBuffer, sizeof(szBuffer)/sizeof(szBuffer[0]), lpszFormat, args);

				OutputDebugString(szBuffer);
				va_end(args);

				// if it does not end if '\r\n' then make one.
				int nLen = _tcslen(szBuffer);
				if (szBuffer[nLen-1] != _T('\n')){OutputDebugString(_T("\r\n"));}
			}
        }
    }
#else
    inline void _cdecl DebugTrace(LPTSTR , ...){}
	inline void _cdecl DebugTraceHelp(DWORD_PTR dwWinHelpID){}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\hosthead.cpp ===
#include "stdafx.h"
#include "common.h"
#include "hosthead.h"
#include "iisdebug.h"
#include <lm.h>
#include <ipexport.h>
#include <ntdef.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif
#define new DEBUG_NEW

#define DEFAULT_MAX_LABEL_LENGTH 63
#define ANSI_HIGH_MAX    0x00ff
#define IS_ANSI(c)       ((unsigned) (c) <= ANSI_HIGH_MAX)
#define ISDIGIT(x)       ( x >= '0' && x <= '9' ? (TRUE) : FALSE )
#define ISHEX(x)         ( x >= '0' && x <= '9' ? (TRUE) :     \
                           x >= 'A' && x <= 'F' ? (TRUE) :     \
                           x >= 'a' && x <= 'f' ? (TRUE) : FALSE )

#define IS_ILLEGAL_COMPUTERNAME_SET(x) (\
	x == '\"' ? (TRUE) : \
	x == '/' ? (TRUE) :  \
	x == '\\' ? (TRUE) : \
	x == '[' ? (TRUE) :  \
	x == ']' ? (TRUE) :  \
	x == ':' ? (TRUE) :  \
	x == '|' ? (TRUE) :  \
	x == ' ' ? (TRUE) :  \
	x == '%' ? (TRUE) :  \
	x == '<' ? (TRUE) :  \
	x == '>' ? (TRUE) :  \
	x == '+' ? (TRUE) :  \
	x == '=' ? (TRUE) :  \
	x == ';' ? (TRUE) :  \
	x == ',' ? (TRUE) :  \
	x == '?' ? (TRUE) :  \
	x == '*' ? (TRUE) :  \
    FALSE )


// returns:
//   S_OK if it is a valid domain or ipv4 address
//   E_FAIL if it is not a valid domain or ipv4 address
//
// comments:
//   This code was stolen from NT\net\http\common\C14n.c
//   and then modified.
HRESULT IsHostHeaderDomainNameOrIPv4(LPCTSTR pHostname)
{
	HRESULT hRes = E_FAIL;
    LPCTSTR pChar = NULL;
	LPCTSTR pLabel = NULL;
    LPCTSTR pEnd = pHostname + _tcslen(pHostname);
	BOOL AlphaLabel = FALSE;
	INT iPeriodCounts = 0;
	NTSTATUS Status;

    //
    // It must be a domain name or an IPv4 literal. We'll try to treat
    // it as a domain name first. If the labels turn out to be all-numeric,
    // we'll try decoding it as an IPv4 literal.
    //
    pLabel     = pHostname;
    for (pChar = pHostname;  pChar < pEnd;  ++pChar)
    {
		// check each character...
        if (L'.' == *pChar)
        {
            ULONG LabelLength = DIFF(pChar - pLabel);

			iPeriodCounts++;

            // There must be at least one char in the label
            if (0 == LabelLength)
            {
				// Empty label, can't have that...
				goto IsHostHeaderDomainNameOrIPv4_Exit;
            }

            // Label can't have more than 63 chars
            if (LabelLength > DEFAULT_MAX_LABEL_LENGTH)
            {
				// label is too long, can't have that...
				goto IsHostHeaderDomainNameOrIPv4_Exit;
            }

            // Reset for the next label
            pLabel = pChar + _tcslen(_T("."));

            continue;
        }

        //
        // All chars above 0xFF are considered valid
        //
        if (!IS_ANSI(*pChar)  ||  !IS_ILLEGAL_COMPUTERNAME_SET(*pChar))
        {
            if (!IS_ANSI(*pChar)  ||  !ISDIGIT(*pChar))
                AlphaLabel = TRUE;

            if (pChar > pLabel)
                continue;

            // The first char of a label cannot be a hyphen. (Underscore?)
            if (L'-' == *pChar)
            {
				// um yeah.
				goto IsHostHeaderDomainNameOrIPv4_Exit;
            }

            continue;
        }

		// We found some invalid characters in there...
		goto IsHostHeaderDomainNameOrIPv4_Exit;

    }

	// if we get here then the string is either
	// a valid domain name or a semi valid ipv4 address

	// check if the label had at least one alpha character..
	if (AlphaLabel)
	{
		// if there was a non digit character,
		// then it's a domain name.
		// this is fine.
		hRes = S_OK;
	}
	else
	{
		// this could be a ipv4 address
		// if there are periods in there... like
		// 0.0.0.0 then this is acceptable
		// but all number is not
		if (iPeriodCounts > 0 )
		{
			struct in_addr  IPv4Address;
			LPCTSTR pTerminator = NULL;

			// Let's see if it's a valid IPv4 address
			Status = RtlIpv4StringToAddressW(
						(LPCTSTR) pHostname,
						TRUE,           // strict => 4 dotted decimal octets
						&pTerminator,
						&IPv4Address
						);

			if (!NT_SUCCESS(Status))
			{
			    // Invalid IPv4 address
				//RETURN(Status);
				goto IsHostHeaderDomainNameOrIPv4_Exit;
			}

			hRes = S_OK;
		}
	}

IsHostHeaderDomainNameOrIPv4_Exit:
	return hRes;
}


// returns:
//   S_OK if it is a valid IPv6 address
//   S_FALSE if it is a IPv6 address but something is invalid about it
//   E_FAIL if it is not a IPv6 address
//
// comments:
//   This code was stolen from NT\net\http\common\C14n.c
//   and then modified.
HRESULT IsHostHeaderIPV6(LPCTSTR pHostname)
{
	HRESULT hRes = E_FAIL;
    LPCTSTR pChar = NULL;
    LPCTSTR pEnd = pHostname + _tcslen(pHostname);
	NTSTATUS Status;
	
    // Is this an IPv6 literal address, per RFC 2732?
    if ('[' == *pHostname)
    {
		// If it starts with a [
		// then it's a IPv6 type
		hRes = S_FALSE;

        // Empty brackets?
        if (_tcslen(pHostname) < _tcslen(_T("[0]"))  
			||  _T(']') == pHostname[1])
        {
			goto IsHostHeaderIPV6_Exit;
        }

        for (pChar = pHostname + _tcslen(_T("["));  pChar < pEnd;  ++pChar)
        {
            if (']' == *pChar)
                break;

            //
            // Dots are allowed because the last 32 bits may be represented
            // in IPv4 dotted-octet notation. We do not accept Scope IDs
            // (indicated by '%') in hostnames.
            //
            if (ISHEX(*pChar)  ||  ':' == *pChar  ||  '.' == *pChar)
                continue;

			// Invalid Characters between brackets...
			goto IsHostHeaderIPV6_Exit;
        }

        if (pChar == pEnd)
        {
			// No ending ']'
			goto IsHostHeaderIPV6_Exit;
        }

		{
			struct in6_addr IPv6Address;
			LPCTSTR pTerminator = NULL;

			// Let the RTL routine do the hard work of parsing IPv6 addrs
			Status = RtlIpv6StringToAddressW(
						(LPCTSTR) pHostname + _tcslen(_T("[")),
						&pTerminator,
						&IPv6Address
						);
			if (! NT_SUCCESS(Status))
			{
				// Invalid IPv6 address
				//RETURN(Status);
				goto IsHostHeaderIPV6_Exit;
			}
		}

		// if we got this far, then
		// it's probably a valid IPv6 literal
		hRes = S_OK;
    }

IsHostHeaderIPV6_Exit:
	return hRes;
}

HRESULT IsAllNumHostHeader(LPCTSTR pHostname)
{
	HRESULT hRes = S_OK;
    LPCTSTR pChar = NULL;
    LPCTSTR pEnd = pHostname + _tcslen(pHostname);
    for (pChar = pHostname;  pChar < pEnd;  ++pChar)
    {
        if (!IS_ANSI(*pChar)  ||  !ISDIGIT(*pChar))
            {
                // Found an alpha label
                // return false, that it's not all numeric
                hRes = E_FAIL;
                break;
            }
    }

    return hRes;
}

HRESULT IsValidHostHeader(LPCTSTR pHostHeader)
{
	HRESULT hr = E_FAIL;

	hr = IsHostHeaderIPV6(pHostHeader);
	if (S_OK == hr)
	{
		// It is a valid IPV6 address
		return S_OK;
	}
	if (S_FALSE == hr)
	{
		// It is a IPV6 address but there is something wrong with it
		return E_FAIL;
	}
	else
	{
		// it is not a IPV6 literal
		// Check if it's something else...
		hr = IsHostHeaderDomainNameOrIPv4(pHostHeader);
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\idlg.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        idlg.h

   Abstract:

        Inheritance Dialog Definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef __IDLG__H__
#define __IDLG__H__



class COMDLL CInheritanceDlg : public CDialog
/*++

Class Description:

    Inheritance override checker dialog.

Public Interface:

    CInheritanceDlg         : Constructor

    IsEmpty                 : Check to see if there are overrides.

Notes:

    There are two constructors.  One which assumes GetDataPaths() has
    already been called, and which takes the results from GetDataPaths()
    as a CStringList, and a second constructor which will make the GetDataPaths
    automatically.

    In either case, the calling process should check IsEmpty() right after
    constructing the dialog to see if DoModal() needs to be called.  If
    IsEmpty() returns TRUE, there's no reason to call DoModal().

--*/
{
//
// fWrite parameter helper definitions
//
#define FROM_WRITE_PROPERTY     (TRUE)
#define FROM_DELETE_PROPERTY    (FALSE)

//
// Construction
//
public:
    //
    // Standard constructor (GetDataPaths() already called)
    //
    CInheritanceDlg(
        IN DWORD dwMetaID,
        IN BOOL fWrite,
        IN CComAuthInfo * pAuthInfo,
        IN LPCTSTR lpstrMetaRoot,
        IN CStringList & strlMetaChildNodes,
        IN LPCTSTR lpstrPropertyName            = NULL,
        IN CWnd * pParent                       = NULL
        );

    //
    // Constructor which will call GetDataPaths()
    //
    CInheritanceDlg(
        IN DWORD dwMetaID,
        IN BOOL fWrite,
        IN CComAuthInfo * pAuthInfo,
        IN LPCTSTR lpstrMetaRoot,
        IN LPCTSTR lpstrPropertyName            = NULL,
        IN CWnd * pParent                       = NULL
        );

    //
    // Constructor which will call GetDataPaths(), and which
    // does not use the predefined property table unless
    // fTryToFindInTable is TRUE, in which case it will attempt
    // to use the table first, and use the specified parameters
    // only if the property ID is not found in the table.
    //
    CInheritanceDlg(
        IN BOOL    fTryToFindInTable,
        IN DWORD   dwMDIdentifier,
        IN DWORD   dwMDAttributes,
        IN DWORD   dwMDUserType,
        IN DWORD   dwMDDataType,
        IN LPCTSTR lpstrPropertyName,
        IN BOOL    fWrite,
        IN CComAuthInfo * pAuthInfo,
        IN LPCTSTR lpstrMetaRoot,
        IN CWnd *  pParent                      = NULL                     
        );

//
// Access
//
public:
    virtual INT_PTR DoModal();
//    virtual int DoModal();
    
    //
    // Check to see if there's a reason to continue displaying
    // the dialog.
    //
    BOOL IsEmpty() const { return m_fEmpty; }

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CInheritanceDlg)
    enum { IDD = IDD_INHERITANCE };
    CListBox m_list_ChildNodes;
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CInheritanceDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CInheritanceDlg)
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    afx_msg void OnButtonSelectAll();
    afx_msg void OnHelp();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void Initialize();
    HRESULT GetDataPaths();

    BOOL FriendlyInstance(CString & strMetaRoot, CString & strFriendly);
    CString & CleanDescendantPath(CString & strMetaPath);

private:
    BOOL    m_fWrite;
    BOOL    m_fEmpty;
    BOOL    m_fHasInstanceInMaster;
    BOOL    m_fUseTable;
    DWORD   m_dwMDIdentifier;
    DWORD   m_dwMDAttributes;
    DWORD   m_dwMDUserType;
    DWORD   m_dwMDDataType;
    CString m_strMetaRoot;
    //CString m_strServer;
    CString m_strPropertyName;
    CStringListEx m_strlMetaChildNodes;
    CMetaKey m_mk;
};


#endif // __IDLG__H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\iisui.cpp ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        iisui.cpp

   Abstract:
        DLL Main entry point.

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
#include "stdafx.h"
#include "common.h"
#include "iisdebug.h"
#include <winsock2.h>

#ifdef _COMEXPORT

HINSTANCE hDLLInstance;

//
// Dll Version Only
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



STDAPI
DllRegisterServer()
{
    return S_OK;
}



STDAPI
DllUnregisterServer()
{
    return S_OK;
}



static AFX_EXTENSION_MODULE commonDLL = {NULL, NULL};



extern "C" int APIENTRY
DllMain(
    IN HINSTANCE hInstance,
    IN DWORD dwReason,
    IN LPVOID lpReserved
    )
/*++

Routine Description:

    DLL Main entry point

Arguments:

    HINSTANCE hInstance : Instance handle
    DWORD dwReason      : DLL_PROCESS_ATTACH, etc
    LPVOID lpReserved   : Reserved value

Return Value:

    1 for succesful initialisation, 0 for failed initialisation

--*/
{
   lpReserved;

   int res = 1;

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        ASSERT(hInstance != NULL);
        hDLLInstance = hInstance;
        res = ::AfxInitExtensionModule(commonDLL, hInstance);
        InitErrorFunctionality();
        InitIntlSettings();
        WSADATA wsaData;
        {
            BOOL WinSockInit = (::WSAStartup(MAKEWORD(1, 1), &wsaData) == 0);
        }
#if defined(_DEBUG) || DBG
        afxTraceEnabled = TRUE;
		GetOutputDebugFlag();
#endif // _DEBUG
        break;

    case DLL_PROCESS_DETACH:
        //
        // termination
        //
        TerminateIntlSettings();
        TerminateErrorFunctionality();
        ::AfxTermExtensionModule(commonDLL);
        break;
    }
    return res;
}


extern "C" void WINAPI
InitCommonDll()
{
    new CDynLinkLibrary(commonDLL);
//    hDLLInstance = commonDLL.hResource;
}


#endif // IISUI_EXPORTS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\ipa.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        ipa.cpp

   Abstract:

        IP Address value and helper functions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



//
// Include Files
//
#include "stdafx.h"
#include "common.h"
#include "util.h"
#include <winsock2.h>


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


#define new DEBUG_NEW



//
// Calling instance
//
extern HINSTANCE hDLLInstance;



/* static */
DWORD
CIPAddress::StringToLong(
    IN LPCTSTR lpstr,
    IN int nLength
    )
/*++

Routine Description:

    Static function to convert an ip address string of the form "1.2.3.4"
    to a a single 32 bit number.

Arguments:

    LPCTSTR lpstr : String ip address
    int nLength   : Length of string

Return Value:

    32 bit ip address.

--*/
{
    DWORD dwIPValue = 0L;

    if (nLength > 0)
    {
        u_long ul = 0;

#ifdef UNICODE

        try
        {
            //
            // Convert to ANSI
            //
            LPSTR pszDest = AllocAnsiString(lpstr);
			if (NULL != pszDest)
			{
				ul = ::inet_addr(pszDest);
				FreeMem(pszDest);
			}
        }
        catch(CException * e)
        {
            TRACEEOLID("!!!Exception converting string to ip address");
            e->ReportError();
            e->Delete();
        }

#else

        ul = ::inet_addr(lpstr);

#endif // UNICODE

        //
        // Convert to host byte order.
        //
        dwIPValue = (DWORD)::ntohl(ul);
    }

    return dwIPValue;
}



/* static */
LPTSTR
CIPAddress::LongToString(
    IN  const DWORD dwIPAddress,
    OUT LPTSTR lpStr,
    IN  int cbSize
    )
/*++

Routine Description:

    Static function to convert a 32 bit number to a CString of the format
    "1.2.3.4"

Arguments:

    const DWORD dwIPAddress : 32 bit ip address to be converted to string
    LPTSTR lpStr            : Destination string
    int cbSize              : Size of destination string

Return Value:

    Pointer to string buffer

--*/
{
    struct in_addr ipaddr;

    //
    // Convert the unsigned long to network byte order
    //
    ipaddr.s_addr = ::htonl((u_long)dwIPAddress);

    //
    // Convert the IP address value to a string
    //
    LPCSTR pchAddr = ::inet_ntoa(ipaddr);

#ifdef UNICODE

    VERIFY(::MultiByteToWideChar(CP_ACP, 0L, pchAddr, -1, lpStr, cbSize));

#else

    ::lstrcpy(lpStr, pchAddr);

#endif // UNICODE

    return lpStr;
}



/* static */
LPCTSTR
CIPAddress::LongToString(
    IN  const DWORD dwIPAddress,
    OUT CString & str
    )
/*++

Routine Description:

    Static function to convert a 32 bit number to a CString of the format
    "1.2.3.4"

Arguments:

    const DWORD dwIPAddress : 32 bit ip address to be converted to string
    CString & str           : Destination string

Return Value:

    Pointer to string buffer

--*/
{
    struct in_addr ipaddr;

    //
    // Convert the unsigned long to network byte order
    //
    ipaddr.s_addr = ::htonl((u_long)dwIPAddress);

    //
    // Convert the IP address value to a string
    //
    LPCSTR pchAddr = ::inet_ntoa(ipaddr);

    try
    {
        str = pchAddr;
    }
    catch(CMemoryException * e)
    {
        TRACEEOLID("!!!Exception converting ip address to string");
        e->ReportError();
        e->Delete();
    }

    return (LPCTSTR)str;
}



/* static */
LPCTSTR
CIPAddress::LongToString(
    IN  const DWORD dwIPAddress,
    OUT CComBSTR & bstr
    )
/*++

Routine Description:

    Static function to convert a 32 bit number to a CComBSTR of the format
    "1.2.3.4"

Arguments:

    const DWORD dwIPAddress : 32 bit ip address to be converted to string
    CComBSTR & bstr         : Destination string

Return Value:

    Pointer to string buffer

--*/
{
    struct in_addr ipaddr;

    //
    // Convert the unsigned long to network byte order
    //
    ipaddr.s_addr = ::htonl((u_long)dwIPAddress);

    //
    // Convert the IP address value to a string
    //
    bstr = ::inet_ntoa(ipaddr);

    return bstr;
}




/* static */
LPBYTE
CIPAddress::DWORDtoLPBYTE(
    IN  DWORD  dw,
    OUT LPBYTE lpBytes
    )
/*++

Routine Description:

    Convert a DWORD to a byte array of 4 bytes.  No size
    checking is performed.

Arguments:

    DWORD  dw      : 32 bit ip address
    LPBYTE lpBytes : Byte stream

Return Value:

    Pointer to the input buffer.

--*/
{
    lpBytes[0] = (BYTE)GETIP_FIRST(dw);
    lpBytes[1] = (BYTE)GETIP_SECOND(dw);
    lpBytes[2] = (BYTE)GETIP_THIRD(dw);
    lpBytes[3] = (BYTE)GETIP_FOURTH(dw);

    return lpBytes;
}



CIPAddress::CIPAddress()
/*++

Routine Description:

    Constructor

Arguments:

    None

Return Value:

    N/A

--*/
    : m_dwIPAddress(0L)
{
}



CIPAddress::CIPAddress(
    IN DWORD dwIPAddress,
    IN BOOL fNetworkByteOrder
    )
/*++

Routine Description:

    Constructor.

Arguments:

    DWORD dwIPAddress      : IP address value
    BOOL fNetworkByteOrder : if TRUE, value must be converted to host byte
                             order, otherwise is assumed to already be in
                             host byte order.

Return Value:

    N/A

--*/
{
    if (fNetworkByteOrder)
    {
        //
        // Convert to host byte order
        //
        dwIPAddress = (DWORD)::ntohl((u_long)dwIPAddress);
    }

    m_dwIPAddress = dwIPAddress;
}



CIPAddress::CIPAddress(
    IN BYTE b1,
    IN BYTE b2,
    IN BYTE b3,
    IN BYTE b4
    )
/*++

Routine Description:

    Constructor.

Arguments:

    BYTE b1 : First octet
    BYTE b2 : Second octet
    BYTE b3 : Third octet
    BYTE b4 : Fourth octet

Return Value:

    N/A

Notes:

    This is already assumed to be in host order

--*/
    : m_dwIPAddress(MAKEIPADDRESS(b1, b2, b3, b4))
{
}



CIPAddress::CIPAddress(
    IN LPBYTE lpBytes,
    IN BOOL  fNetworkByteOrder OPTIONAL
    )
/*++

Routine Description:

    Construct from byte stream

Arguments:

    LPBYTE lpBytes           : Byte stream
    BOOL  fNetworkByteOrder  : TRUE if the byte stream is in network byte order

Return Value:

    N/A

--*/
{
   lpBytes;
   fNetworkByteOrder;
}



CIPAddress::CIPAddress(
    IN const CIPAddress & ia
    )
/*++

Routine Description:

    Copy Constructor.

Arguments:

    const CIPAddress & ia

Return Value:

    N/A

--*/
    : m_dwIPAddress(ia.m_dwIPAddress)
{
}



CIPAddress::CIPAddress(
    IN LPCTSTR lpstr,
    IN int nLength
    )
/*++

Routine Description:

    Constructor.

Arguments:

    LPCTSTR lpstr : string ip value
    int nLength   : length of string

Return Value:

    N/A

--*/
{
    m_dwIPAddress = CIPAddress::StringToLong(lpstr, nLength);
}



CIPAddress::CIPAddress(
    const CString & str
    )
/*++

Routine Description:

    Constructor.

Arguments:

    const CString & str : IP Address string

Return Value:

    N/A

--*/
{
    m_dwIPAddress = CIPAddress::StringToLong(str);
}



const CIPAddress &
CIPAddress::operator =(
    IN const CIPAddress & ia
    )
/*++

Routine Description:

    Assignment operator

Arguments:

    const CIPAddress & ia : Source ip address

Return Value:

    Current object

--*/
{
    m_dwIPAddress = ia.m_dwIPAddress;

    return *this;
}



const CIPAddress &
CIPAddress::operator =(
    IN const DWORD dwIPAddress
    )
/*++

Routine Description:

    Assignment operator

Arguments:

    const DWORD dwIPAddress : Source ip address

Return Value:

    Current object

--*/
{
    m_dwIPAddress = dwIPAddress;

    return *this;
}



const CIPAddress &
CIPAddress::operator =(
    IN LPCTSTR lpstr
    )
/*++

Routine Description:

    Assignment operator

Arguments:

    LPCTSTR lpstr : Source string

Return Value:

    Current object

--*/
{
    m_dwIPAddress = CIPAddress::StringToLong(lpstr, ::lstrlen(lpstr));

    return *this;
}



const CIPAddress &
CIPAddress::operator =(
    IN const CString & str
    )
/*++

Routine Description:

    Assignment operator

Arguments:

    const CString & str : Source string

Return Value:

    Current object

--*/
{
    m_dwIPAddress = CIPAddress::StringToLong(str);

    return *this;
}



int
CIPAddress::CompareItem(
    IN const CIPAddress & ia
    ) const
/*++

Routine Description:

    Compare two ip addresses

Arguments:

    const CIPAddress & ia : IP Address to compare this to

Return Value:

    +1 if the current ip address is greater,
     0 if the two ip addresses are the same
    -1 if the current ip address is less,

--*/
{
    return (DWORD)ia < m_dwIPAddress
           ? +1
           : (DWORD)ia == m_dwIPAddress
                ? 0
                : -1;
}



CIPAddress::operator LPCTSTR() const
/*++

Routine Description:

    Conversion operator

Arguments:

    N/A

Return Value:

    Pointer to converted string

--*/
{
    static TCHAR szIPAddress[] = _T("xxx.xxx.xxx.xxx");

    return CIPAddress::LongToString(
        m_dwIPAddress,
        szIPAddress,
        ARRAY_SIZE(szIPAddress)
        );
}



CIPAddress::operator CString() const
/*++

Routine Description:

    Conversion operator

Arguments:

    N/A

Return Value:

    Converted string

--*/
{
    CString str;

    CIPAddress::LongToString(m_dwIPAddress, str);

    return str;
}



DWORD
CIPAddress::QueryIPAddress(
    IN BOOL fNetworkByteOrder
    ) const
/*++

Routine Description:

    Get the ip address as a 32 bit number

Arguments:

    BOOL fNetworkByteOrder : If TRUE, convert to network byte order

Return Value:

    32 bit ip address

--*/
{
    return fNetworkByteOrder
        ? ::htonl((u_long)m_dwIPAddress)
        : m_dwIPAddress;
}



//
// IP Address helper functions
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



DWORD
PopulateComboWithKnownIpAddresses(
    IN  LPCTSTR lpszServer,
    IN  CComboBox & combo,
    IN  CIPAddress & iaIpAddress,
    OUT CObListPlus & oblIpAddresses,
    OUT int & nIpAddressSel
    )
/*++

Routine Description:

    Fill a combo box with known ip addresses

Arguments:

    LPCTSTR lpszServer           : Server whose ip addresses to obtain
                                  (can be computer name or ip address)

    CComboBox & combo            : Combo box to populate
    CIPAddress & iaIpAddress     : IP Address to select
    CObListPlus & oblIpAddresses : Returns an oblist of CIPAddress objects
    int & nIpAddressSel          : Returns selected IP address

Return Value:

    Error return code

--*/
{
    //
    // Start clean
    //
    oblIpAddresses.RemoveAll();
    combo.ResetContent();

    //
    // Don't like \\names
    //
    lpszServer = PURE_COMPUTER_NAME(lpszServer);
    struct hostent * pHostEntry = NULL;

    if (LooksLikeIPAddress(lpszServer))
    {
        //
        // Get by ip address
        //
        u_long ul = (DWORD)CIPAddress(lpszServer);
        ul = ::htonl(ul);   // convert to network order.
        pHostEntry = ::gethostbyaddr((CHAR *)&ul, sizeof(ul), PF_INET);
    }
    else
    {
        //
        // Get by domain name
        //
        const char FAR * lpszAnsiServer = NULL;

#ifdef UNICODE

        CHAR szAnsi[255];

        if (::WideCharToMultiByte(CP_ACP, 0L, lpszServer, -1,  szAnsi,
            sizeof(szAnsi), NULL, NULL) > 0)
        {
            lpszAnsiServer = szAnsi;
        }
#else
        lpszAnsiServer = lpszServer;
#endif // UNICODE

        if (lpszAnsiServer)
        {
            pHostEntry = ::gethostbyname(lpszAnsiServer);
        }
    }

    //
    // We'll always have the 'default' server id
    // selected
    //
    CComBSTR bstr, bstrDefault;
    VERIFY(bstrDefault.LoadString(hDLLInstance, IDS_ALL_UNASSIGNED));

    nIpAddressSel = -1;
    CIPAddress * pia = new CIPAddress;

    if (!pia)
    {
        TRACEEOLID("PopulateComboWithKnownIpAddresses: OOM");
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    oblIpAddresses.AddTail(pia);
    int nNewSel = combo.AddString(bstrDefault);

    if (iaIpAddress == *pia)
    {
        //
        // Remember selection
        //
        nIpAddressSel = nNewSel;
    }

    if (pHostEntry != NULL)
    {
        int n = 0;
        while (((DWORD *)pHostEntry->h_addr_list[n]) != NULL)
        {
            //
            // Convert from network byte order
            //
            pia = new CIPAddress(
               *((DWORD *)(pHostEntry->h_addr_list[n++])), TRUE);

            if (!pia)
            {
                TRACEEOLID("PopulateComboWithKnownIpAddresses: OOM");
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            nNewSel = combo.AddString(pia->QueryIPAddress(bstr));
            oblIpAddresses.AddTail(pia);

            if (iaIpAddress == *pia)
            {
                //
                // This is our current ip address, save index
                // for selection
                //
                nIpAddressSel = nNewSel;
            }
        }
    }

    if (nIpAddressSel < 0)
    {
        //
        // Ok, the IP address selected is not part of the
        // list.  Add it to the list, and select it.
        //
        pia = new CIPAddress(iaIpAddress);

        if (!pia)
        {
            TRACEEOLID("PopulateComboWithKnownIpAddresses: OOM");
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        nIpAddressSel = combo.AddString(pia->QueryIPAddress(bstr));
        oblIpAddresses.AddTail(pia);
    }

    combo.SetCurSel(nIpAddressSel);

    return ERROR_SUCCESS;
}



BOOL
FetchIpAddressFromCombo(
    IN  CComboBox & combo,
    IN  CObListPlus & oblIpAddresses,
    OUT CIPAddress & ia
    )
/*++

Routine Description:

    Helper function to fetch an ip address from the combo box.
    The combo box may not have a selection, in which case whatever
    is in the edit box is used

Arguments:

    CComboBox & combo               : Combo box
    CObListPlus & oblIpAddresses    : Oblist of ip addresses
    CIPAddress & ia                 : Returns the ip address

Return Value:

    TRUE if a valid IP address is found, FALSE otherwise.

--*/
{
    int nSel = combo.GetCurSel();
    CString str;
    combo.GetWindowText(str);
	// after touching (All unassigned) combo loses selection, 
	// but text still could be the same
	if (nSel < 0)
	{
		nSel = combo.FindStringExact(-1, str);
	}
    if (nSel >= 0)
    {
        //
        // Fetch selected item
        //
        CIPAddress * pia = (CIPAddress *)oblIpAddresses.Index(nSel);
        ASSERT_PTR(pia);
        if (pia != NULL)
        {
            ia = *pia;
            return TRUE;
        }
        else
        {
           return FALSE;
        }
    }

    //
    // Try to make an ip address out of what's in the editbox
    //
    if (!str.IsEmpty())
    {
		ia = str;
		if (!ia.IsZeroValue() && !ia.IsBadValue())
		{
			return TRUE;
		}
    }

    //
    // No good
    //
    ::AfxMessageBox(IDS_INVALID_IP_ADDRESS);

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\mbschema.h ===
//
// This is computer generated code
// please don't edit it manually.
//
#ifndef IDS_MD_BEGIN_TABLE
#define IDS_MD_BEGIN_TABLE	60000
#endif

#define IDS_MaxBandwidth                        (IDS_MD_BEGIN_TABLE+0)
#define IDS_KeyType                             (IDS_MD_BEGIN_TABLE+2)
#define IDS_MaxBandwidthBlocked                 (IDS_MD_BEGIN_TABLE+3)
#define IDS_ServerCommand                       (IDS_MD_BEGIN_TABLE+4)
#define IDS_ConnectionTimeout                   (IDS_MD_BEGIN_TABLE+5)
#define IDS_MaxConnections                      (IDS_MD_BEGIN_TABLE+6)
#define IDS_ServerComment                       (IDS_MD_BEGIN_TABLE+7)
#define IDS_ServerState                         (IDS_MD_BEGIN_TABLE+8)
#define IDS_ServerAutoStart                     (IDS_MD_BEGIN_TABLE+9)
#define IDS_ServerSize                          (IDS_MD_BEGIN_TABLE+10)
#define IDS_ServerListenBacklog                 (IDS_MD_BEGIN_TABLE+11)
#define IDS_ServerListenTimeout                 (IDS_MD_BEGIN_TABLE+12)
#define IDS_DownlevelAdminInstance              (IDS_MD_BEGIN_TABLE+13)
#define IDS_DirectoryLevelsToScan               (IDS_MD_BEGIN_TABLE+14)
#define IDS_ServerBindings                      (IDS_MD_BEGIN_TABLE+15)
#define IDS_MaxEndpointConnections              (IDS_MD_BEGIN_TABLE+16)
#define IDS_ClusterEnabled                      (IDS_MD_BEGIN_TABLE+17)
#define IDS_ServerConfigFlags                   (IDS_MD_BEGIN_TABLE+18)
#define IDS_DisableSocketPooling                (IDS_MD_BEGIN_TABLE+20)
#define IDS_Win32Error                          (IDS_MD_BEGIN_TABLE+22)
#define IDS_MajorIIsVersionNumber               (IDS_MD_BEGIN_TABLE+24)
#define IDS_MinorIIsVersionNumber               (IDS_MD_BEGIN_TABLE+25)
#define IDS_SecureBindings                      (IDS_MD_BEGIN_TABLE+27)
#define IDS_FilterLoadOrder                     (IDS_MD_BEGIN_TABLE+29)
#define IDS_FilterPath                          (IDS_MD_BEGIN_TABLE+30)
#define IDS_FilterState                         (IDS_MD_BEGIN_TABLE+31)
#define IDS_FilterEnabled                       (IDS_MD_BEGIN_TABLE+32)
#define IDS_FilterFlags                         (IDS_MD_BEGIN_TABLE+33)
#define IDS_FilterDescription                   (IDS_MD_BEGIN_TABLE+34)
#define IDS_FilterEnableCache                   (IDS_MD_BEGIN_TABLE+35)
#define IDS_AuthChangeURL                       (IDS_MD_BEGIN_TABLE+36)
#define IDS_AuthExpiredURL                      (IDS_MD_BEGIN_TABLE+37)
#define IDS_AuthNotifyPwdExpURL                 (IDS_MD_BEGIN_TABLE+38)
#define IDS_PasswordExpirePrenotifyDays         (IDS_MD_BEGIN_TABLE+39)
#define IDS_PasswordCacheTTL                    (IDS_MD_BEGIN_TABLE+40)
#define IDS_AuthExpiredUnsecureURL              (IDS_MD_BEGIN_TABLE+43)
#define IDS_PasswordChangeFlags                 (IDS_MD_BEGIN_TABLE+44)
#define IDS_AuthNotifyPwdExpUnsecureURL         (IDS_MD_BEGIN_TABLE+45)
#define IDS_ProcessNTCRIfLoggedOn               (IDS_MD_BEGIN_TABLE+46)
#define IDS_FrontPageWeb                        (IDS_MD_BEGIN_TABLE+47)
#define IDS_InProcessIsapiApps                  (IDS_MD_BEGIN_TABLE+48)
#define IDS_AllowPathInfoForScriptMappings      (IDS_MD_BEGIN_TABLE+49)
#define IDS_AppFriendlyName                     (IDS_MD_BEGIN_TABLE+50)
#define IDS_AppRoot                             (IDS_MD_BEGIN_TABLE+51)
#define IDS_AppIsolated                         (IDS_MD_BEGIN_TABLE+52)
#define IDS_AppWamClsid                         (IDS_MD_BEGIN_TABLE+53)
#define IDS_AppPackageID                        (IDS_MD_BEGIN_TABLE+54)
#define IDS_AppPackageName                      (IDS_MD_BEGIN_TABLE+55)
#define IDS_AppOopRecoverLimit                  (IDS_MD_BEGIN_TABLE+57)
#define IDS_AdminServer                         (IDS_MD_BEGIN_TABLE+58)
#define IDS_CustomErrorDescriptions             (IDS_MD_BEGIN_TABLE+60)
#define IDS_CPUResetInterval                    (IDS_MD_BEGIN_TABLE+66)
#define IDS_CertCheckMode                       (IDS_MD_BEGIN_TABLE+72)
#define IDS_RevocationFreshnessTime             (IDS_MD_BEGIN_TABLE+73)
#define IDS_RevocationURLRetrievalTimeout       (IDS_MD_BEGIN_TABLE+74)
#define IDS_ApplicationDependencies             (IDS_MD_BEGIN_TABLE+79)
#define IDS_WebSvcExtRestrictionList            (IDS_MD_BEGIN_TABLE+80)
#define IDS_HcCompressionDirectory              (IDS_MD_BEGIN_TABLE+81)
#define IDS_HcCacheControlHeader                (IDS_MD_BEGIN_TABLE+82)
#define IDS_HcExpiresHeader                     (IDS_MD_BEGIN_TABLE+83)
#define IDS_HcDoDynamicCompression              (IDS_MD_BEGIN_TABLE+84)
#define IDS_HcDoStaticCompression               (IDS_MD_BEGIN_TABLE+85)
#define IDS_HcDoOnDemandCompression             (IDS_MD_BEGIN_TABLE+86)
#define IDS_HcDoDiskSpaceLimiting               (IDS_MD_BEGIN_TABLE+87)
#define IDS_HcNoCompressionForHttp10            (IDS_MD_BEGIN_TABLE+88)
#define IDS_HcNoCompressionForProxies           (IDS_MD_BEGIN_TABLE+89)
#define IDS_HcNoCompressionForRange             (IDS_MD_BEGIN_TABLE+90)
#define IDS_HcSendCacheHeaders                  (IDS_MD_BEGIN_TABLE+91)
#define IDS_HcMaxDiskSpaceUsage                 (IDS_MD_BEGIN_TABLE+92)
#define IDS_HcIoBufferSize                      (IDS_MD_BEGIN_TABLE+93)
#define IDS_HcCompressionBufferSize             (IDS_MD_BEGIN_TABLE+94)
#define IDS_HcMaxQueueLength                    (IDS_MD_BEGIN_TABLE+95)
#define IDS_HcFilesDeletedPerDiskFree           (IDS_MD_BEGIN_TABLE+96)
#define IDS_HcMinFileSizeForComp                (IDS_MD_BEGIN_TABLE+97)
#define IDS_HcCompressionDll                    (IDS_MD_BEGIN_TABLE+98)
#define IDS_HcFileExtensions                    (IDS_MD_BEGIN_TABLE+99)
#define IDS_HcPriority                          (IDS_MD_BEGIN_TABLE+100)
#define IDS_HcDynamicCompressionLevel           (IDS_MD_BEGIN_TABLE+101)
#define IDS_HcOnDemandCompLevel                 (IDS_MD_BEGIN_TABLE+102)
#define IDS_HcCreateFlags                       (IDS_MD_BEGIN_TABLE+103)
#define IDS_HcScriptFileExtensions              (IDS_MD_BEGIN_TABLE+104)
#define IDS_DoDynamicCompression                (IDS_MD_BEGIN_TABLE+105)
#define IDS_DoStaticCompression                 (IDS_MD_BEGIN_TABLE+106)
#define IDS_Path                                (IDS_MD_BEGIN_TABLE+107)
#define IDS_UNCUserName                         (IDS_MD_BEGIN_TABLE+108)
#define IDS_UNCPassword                         (IDS_MD_BEGIN_TABLE+109)
#define IDS_LogType                             (IDS_MD_BEGIN_TABLE+110)
#define IDS_LogFileDirectory                    (IDS_MD_BEGIN_TABLE+111)
#define IDS_LogFilePeriod                       (IDS_MD_BEGIN_TABLE+112)
#define IDS_LogFileTruncateSize                 (IDS_MD_BEGIN_TABLE+113)
#define IDS_LogModuleId                         (IDS_MD_BEGIN_TABLE+114)
#define IDS_LogModuleUiId                       (IDS_MD_BEGIN_TABLE+115)
#define IDS_LogOdbcDataSource                   (IDS_MD_BEGIN_TABLE+116)
#define IDS_LogOdbcTableName                    (IDS_MD_BEGIN_TABLE+117)
#define IDS_LogOdbcUserName                     (IDS_MD_BEGIN_TABLE+118)
#define IDS_LogOdbcPassword                     (IDS_MD_BEGIN_TABLE+119)
#define IDS_LogPluginClsid                      (IDS_MD_BEGIN_TABLE+120)
#define IDS_LogModuleList                       (IDS_MD_BEGIN_TABLE+121)
#define IDS_LogExtFileFlags                     (IDS_MD_BEGIN_TABLE+122)
#define IDS_LogFileLocaltimeRollover            (IDS_MD_BEGIN_TABLE+123)
#define IDS_CentralBinaryLoggingEnabled         (IDS_MD_BEGIN_TABLE+124)
#define IDS_LogCustomPropertyName               (IDS_MD_BEGIN_TABLE+125)
#define IDS_LogCustomPropertyHeader             (IDS_MD_BEGIN_TABLE+126)
#define IDS_LogCustomPropertyID                 (IDS_MD_BEGIN_TABLE+127)
#define IDS_LogCustomPropertyMask               (IDS_MD_BEGIN_TABLE+128)
#define IDS_LogCustomPropertyDataType           (IDS_MD_BEGIN_TABLE+129)
#define IDS_LogCustomPropertyServicesString     (IDS_MD_BEGIN_TABLE+130)
#define IDS_LogCustomPropertyNodeID             (IDS_MD_BEGIN_TABLE+131)
#define IDS_ExitMessage                         (IDS_MD_BEGIN_TABLE+132)
#define IDS_GreetingMessage                     (IDS_MD_BEGIN_TABLE+133)
#define IDS_MaxClientsMessage                   (IDS_MD_BEGIN_TABLE+134)
#define IDS_MSDOSDirOutput                      (IDS_MD_BEGIN_TABLE+135)
#define IDS_AllowAnonymous                      (IDS_MD_BEGIN_TABLE+136)
#define IDS_AnonymousOnly                       (IDS_MD_BEGIN_TABLE+137)
#define IDS_LogAnonymous                        (IDS_MD_BEGIN_TABLE+138)
#define IDS_LogNonAnonymous                     (IDS_MD_BEGIN_TABLE+139)
#define IDS_FtpDirBrowseShowLongDate            (IDS_MD_BEGIN_TABLE+140)
#define IDS_BannerMessage                       (IDS_MD_BEGIN_TABLE+141)
#define IDS_UserIsolationMode                   (IDS_MD_BEGIN_TABLE+142)
#define IDS_FtpLogInUtf8                        (IDS_MD_BEGIN_TABLE+143)
#define IDS_ADConnectionsUserName               (IDS_MD_BEGIN_TABLE+144)
#define IDS_ADConnectionsPassword               (IDS_MD_BEGIN_TABLE+145)
#define IDS_PassivePortRange                    (IDS_MD_BEGIN_TABLE+146)
#define IDS_SSLCertHash                         (IDS_MD_BEGIN_TABLE+147)
#define IDS_SSLStoreName                        (IDS_MD_BEGIN_TABLE+148)
#define IDS_SslCtlIdentifier                    (IDS_MD_BEGIN_TABLE+149)
#define IDS_SslCtlStoreName                     (IDS_MD_BEGIN_TABLE+150)
#define IDS_SslUseDsMapper                      (IDS_MD_BEGIN_TABLE+151)
#define IDS_AuthFlags                           (IDS_MD_BEGIN_TABLE+152)
#define IDS_Realm                               (IDS_MD_BEGIN_TABLE+153)
#define IDS_HttpExpires                         (IDS_MD_BEGIN_TABLE+154)
#define IDS_HttpPics                            (IDS_MD_BEGIN_TABLE+155)
#define IDS_HttpCustomHeaders                   (IDS_MD_BEGIN_TABLE+156)
#define IDS_DirBrowseFlags                      (IDS_MD_BEGIN_TABLE+157)
#define IDS_DefaultDoc                          (IDS_MD_BEGIN_TABLE+158)
#define IDS_HttpErrors                          (IDS_MD_BEGIN_TABLE+159)
#define IDS_DefaultDocFooter                    (IDS_MD_BEGIN_TABLE+160)
#define IDS_EnableDocFooter                     (IDS_MD_BEGIN_TABLE+161)
#define IDS_HttpRedirect                        (IDS_MD_BEGIN_TABLE+162)
#define IDS_DefaultLogonDomain                  (IDS_MD_BEGIN_TABLE+163)
#define IDS_LogonMethod                         (IDS_MD_BEGIN_TABLE+164)
#define IDS_ScriptMaps                          (IDS_MD_BEGIN_TABLE+165)
#define IDS_MimeMap                             (IDS_MD_BEGIN_TABLE+166)
#define IDS_AccessFlags                         (IDS_MD_BEGIN_TABLE+167)
#define IDS_IPSecurity                          (IDS_MD_BEGIN_TABLE+168)
#define IDS_AnonymousUserName                   (IDS_MD_BEGIN_TABLE+169)
#define IDS_AnonymousUserPass                   (IDS_MD_BEGIN_TABLE+170)
#define IDS_AnonymousPasswordSync               (IDS_MD_BEGIN_TABLE+171)
#define IDS_DontLog                             (IDS_MD_BEGIN_TABLE+172)
#define IDS_AdminACL                            (IDS_MD_BEGIN_TABLE+173)
#define IDS_SSIExecDisable                      (IDS_MD_BEGIN_TABLE+174)
#define IDS_EnableReverseDns                    (IDS_MD_BEGIN_TABLE+175)
#define IDS_AccessSSLFlags                      (IDS_MD_BEGIN_TABLE+176)
#define IDS_AuthPersistence                     (IDS_MD_BEGIN_TABLE+177)
#define IDS_NTAuthenticationProviders           (IDS_MD_BEGIN_TABLE+178)
#define IDS_CGITimeout                          (IDS_MD_BEGIN_TABLE+179)
#define IDS_CacheISAPI                          (IDS_MD_BEGIN_TABLE+180)
#define IDS_CreateProcessAsUser                 (IDS_MD_BEGIN_TABLE+181)
#define IDS_CreateCGIWithNewConsole             (IDS_MD_BEGIN_TABLE+182)
#define IDS_PoolIdcTimeout                      (IDS_MD_BEGIN_TABLE+183)
#define IDS_AllowKeepAlive                      (IDS_MD_BEGIN_TABLE+184)
#define IDS_ContentIndexed                      (IDS_MD_BEGIN_TABLE+185)
#define IDS_CacheControlNoCache                 (IDS_MD_BEGIN_TABLE+186)
#define IDS_CacheControlMaxAge                  (IDS_MD_BEGIN_TABLE+187)
#define IDS_CacheControlCustom                  (IDS_MD_BEGIN_TABLE+188)
#define IDS_RedirectHeaders                     (IDS_MD_BEGIN_TABLE+189)
#define IDS_UploadReadAheadSize                 (IDS_MD_BEGIN_TABLE+190)
#define IDS_UseDigestSSP                        (IDS_MD_BEGIN_TABLE+191)
#define IDS_AzEnable                            (IDS_MD_BEGIN_TABLE+192)
#define IDS_AzStoreName                         (IDS_MD_BEGIN_TABLE+193)
#define IDS_AzScopeName                         (IDS_MD_BEGIN_TABLE+194)
#define IDS_MaxRequestEntityAllowed             (IDS_MD_BEGIN_TABLE+195)
#define IDS_AdminACLBin                         (IDS_MD_BEGIN_TABLE+197)
#define IDS_AspBufferingOn                      (IDS_MD_BEGIN_TABLE+198)
#define IDS_AspLogErrorRequests                 (IDS_MD_BEGIN_TABLE+199)
#define IDS_AspScriptErrorSentToBrowser         (IDS_MD_BEGIN_TABLE+200)
#define IDS_AspScriptErrorMessage               (IDS_MD_BEGIN_TABLE+201)
#define IDS_AspScriptFileCacheSize              (IDS_MD_BEGIN_TABLE+202)
#define IDS_AspScriptEngineCacheMax             (IDS_MD_BEGIN_TABLE+203)
#define IDS_AspScriptTimeout                    (IDS_MD_BEGIN_TABLE+204)
#define IDS_AspSessionTimeout                   (IDS_MD_BEGIN_TABLE+205)
#define IDS_AspEnableParentPaths                (IDS_MD_BEGIN_TABLE+206)
#define IDS_AspAllowSessionState                (IDS_MD_BEGIN_TABLE+207)
#define IDS_AspScriptLanguage                   (IDS_MD_BEGIN_TABLE+208)
#define IDS_AspQueueTimeout                     (IDS_MD_BEGIN_TABLE+209)
#define IDS_AspAllowOutOfProcComponents         (IDS_MD_BEGIN_TABLE+210)
#define IDS_AspExceptionCatchEnable             (IDS_MD_BEGIN_TABLE+211)
#define IDS_AspCodepage                         (IDS_MD_BEGIN_TABLE+212)
#define IDS_AppAllowDebugging                   (IDS_MD_BEGIN_TABLE+213)
#define IDS_AppAllowClientDebug                 (IDS_MD_BEGIN_TABLE+214)
#define IDS_AspTrackThreadingModel              (IDS_MD_BEGIN_TABLE+215)
#define IDS_AspEnableAspHtmlFallback            (IDS_MD_BEGIN_TABLE+216)
#define IDS_AspEnableChunkedEncoding            (IDS_MD_BEGIN_TABLE+217)
#define IDS_AspEnableTypelibCache               (IDS_MD_BEGIN_TABLE+218)
#define IDS_AspErrorsToNTLog                    (IDS_MD_BEGIN_TABLE+219)
#define IDS_AspProcessorThreadMax               (IDS_MD_BEGIN_TABLE+220)
#define IDS_AspRequestQueueMax                  (IDS_MD_BEGIN_TABLE+221)
#define IDS_AspEnableApplicationRestart         (IDS_MD_BEGIN_TABLE+222)
#define IDS_AspQueueConnectionTestTime          (IDS_MD_BEGIN_TABLE+223)
#define IDS_AspSessionMax                       (IDS_MD_BEGIN_TABLE+224)
#define IDS_AspDiskTemplateCacheDirectory       (IDS_MD_BEGIN_TABLE+225)
#define IDS_AspMaxDiskTemplateCacheFiles        (IDS_MD_BEGIN_TABLE+226)
#define IDS_AspExecuteInMTA                     (IDS_MD_BEGIN_TABLE+227)
#define IDS_AspLCID                             (IDS_MD_BEGIN_TABLE+228)
#define IDS_AspKeepSessionIDSecure              (IDS_MD_BEGIN_TABLE+229)
#define IDS_AspAppServiceFlags                  (IDS_MD_BEGIN_TABLE+230)
#define IDS_AspPartitionID                      (IDS_MD_BEGIN_TABLE+231)
#define IDS_AspSxsName                          (IDS_MD_BEGIN_TABLE+232)
#define IDS_AspCalcLineNumber                   (IDS_MD_BEGIN_TABLE+233)
#define IDS_AspRunOnEndAnonymously              (IDS_MD_BEGIN_TABLE+234)
#define IDS_AspBufferingLimit                   (IDS_MD_BEGIN_TABLE+235)
#define IDS_AspMaxRequestEntityAllowed          (IDS_MD_BEGIN_TABLE+236)
#define IDS_WAMUserName                         (IDS_MD_BEGIN_TABLE+237)
#define IDS_WAMUserPass                         (IDS_MD_BEGIN_TABLE+238)
#define IDS_PeriodicRestartTime                 (IDS_MD_BEGIN_TABLE+239)
#define IDS_PeriodicRestartRequests             (IDS_MD_BEGIN_TABLE+240)
#define IDS_MaxProcesses                        (IDS_MD_BEGIN_TABLE+241)
#define IDS_PingingEnabled                      (IDS_MD_BEGIN_TABLE+242)
#define IDS_IdleTimeout                         (IDS_MD_BEGIN_TABLE+243)
#define IDS_RapidFailProtection                 (IDS_MD_BEGIN_TABLE+244)
#define IDS_SMPAffinitized                      (IDS_MD_BEGIN_TABLE+245)
#define IDS_SMPProcessorAffinityMask            (IDS_MD_BEGIN_TABLE+246)
#define IDS_OrphanWorkerProcess                 (IDS_MD_BEGIN_TABLE+247)
#define IDS_StartupTimeLimit                    (IDS_MD_BEGIN_TABLE+248)
#define IDS_ShutdownTimeLimit                   (IDS_MD_BEGIN_TABLE+249)
#define IDS_PingInterval                        (IDS_MD_BEGIN_TABLE+250)
#define IDS_PingResponseTime                    (IDS_MD_BEGIN_TABLE+251)
#define IDS_DisallowOverlappingRotation         (IDS_MD_BEGIN_TABLE+252)
#define IDS_AppPoolQueueLength                  (IDS_MD_BEGIN_TABLE+253)
#define IDS_DisallowRotationOnConfigChange      (IDS_MD_BEGIN_TABLE+254)
#define IDS_PeriodicRestartSchedule             (IDS_MD_BEGIN_TABLE+255)
#define IDS_AppPoolIdentityType                 (IDS_MD_BEGIN_TABLE+256)
#define IDS_CPUAction                           (IDS_MD_BEGIN_TABLE+257)
#define IDS_CPULimit                            (IDS_MD_BEGIN_TABLE+258)
#define IDS_PeriodicRestartMemory               (IDS_MD_BEGIN_TABLE+259)
#define IDS_AppPoolCommand                      (IDS_MD_BEGIN_TABLE+260)
#define IDS_AppPoolState                        (IDS_MD_BEGIN_TABLE+261)
#define IDS_AppPoolAutoStart                    (IDS_MD_BEGIN_TABLE+262)
#define IDS_RapidFailProtectionInterval         (IDS_MD_BEGIN_TABLE+263)
#define IDS_RapidFailProtectionMaxCrashes       (IDS_MD_BEGIN_TABLE+264)
#define IDS_OrphanActionExe                     (IDS_MD_BEGIN_TABLE+265)
#define IDS_OrphanActionParams                  (IDS_MD_BEGIN_TABLE+266)
#define IDS_LoadBalancerCapabilities            (IDS_MD_BEGIN_TABLE+268)
#define IDS_AutoShutdownAppPoolExe              (IDS_MD_BEGIN_TABLE+269)
#define IDS_AutoShutdownAppPoolParams           (IDS_MD_BEGIN_TABLE+270)
#define IDS_LogEventOnRecycle                   (IDS_MD_BEGIN_TABLE+271)
#define IDS_PeriodicRestartPrivateMemory        (IDS_MD_BEGIN_TABLE+272)
#define IDS_AppPoolId                           (IDS_MD_BEGIN_TABLE+273)
#define IDS_MaxGlobalBandwidth                  (IDS_MD_BEGIN_TABLE+274)
#define IDS_IIs5IsolationModeEnabled            (IDS_MD_BEGIN_TABLE+275)
#define IDS_HeaderWaitTimeout                   (IDS_MD_BEGIN_TABLE+276)
#define IDS_MinFileBytesPerSec                  (IDS_MD_BEGIN_TABLE+277)
#define IDS_LogInUTF8                           (IDS_MD_BEGIN_TABLE+278)
#define IDS_DemandStartThreshold                (IDS_MD_BEGIN_TABLE+279)
#define IDS_MaxErrorFiles                       (IDS_MD_BEGIN_TABLE+281)
#define IDS_CollectionComment                   (IDS_MD_BEGIN_TABLE+282)
#define IDS_BINSchemaTimeStamp                  (IDS_MD_BEGIN_TABLE+284)
#define IDS_XMLSchemaTimeStamp                  (IDS_MD_BEGIN_TABLE+285)
#define IDS_HistoryMajorVersionNumber           (IDS_MD_BEGIN_TABLE+286)
#define IDS_MaxHistoryFiles                     (IDS_MD_BEGIN_TABLE+287)
#define IDS_EnableHistory                       (IDS_MD_BEGIN_TABLE+288)
#define IDS_ChangeNumber                        (IDS_MD_BEGIN_TABLE+289)
#define IDS_EnableEditWhileRunning              (IDS_MD_BEGIN_TABLE+290)
#define IDS_SessionKey                          (IDS_MD_BEGIN_TABLE+291)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\ipa.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        ipa.h

   Abstract:

        IP Address value

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef _IPA_H
#define _IPA_H

//
// IP Address Conversion Macros
//
#ifdef MAKEIPADDRESS
#undef MAKEIPADDRESS
#endif // MAKEIPADDRESS

#define MAKEIPADDRESS(b1,b2,b3,b4) (((DWORD)(b1)<<24) +\
                                    ((DWORD)(b2)<<16) +\
                                    ((DWORD)(b3)<< 8) +\
                                    ((DWORD)(b4)))

#ifndef GETIP_FIRST

  #define GETIP_FIRST(x)             ((x>>24) & 0xff)
  #define GETIP_SECOND(x)            ((x>>16) & 0xff)
  #define GETIP_THIRD(x)             ((x>> 8) & 0xff)
  #define GETIP_FOURTH(x)            ((x)     & 0xff)

#endif // GETIP_FIRST

//
// Some predefined IP values
//
#define NULL_IP_ADDRESS     (DWORD)(0x00000000)
#define NULL_IP_MASK        (DWORD)(0xFFFFFFFF)
#define BAD_IP_ADDRESS      (DWORD)(0xFFFFFFFF)

class COMDLL CIPAddress : public CObjectPlus
/*++

Class Description:

    IP Address classes.  Winsock is required to be initialized for this
    to work.

Public Interface:

    CIPAddress                 : Various constructors

    operator =                 : Assignment operator
    operator ==                : Comparison operators
    operator const DWORD       : Cast operator
    operator LPCTSTR           : Cast operator
    operator CString           : Cast operator
    CompareItem                : Comparison function
    QueryIPAddress             : Get the ip address value
    QueryNetworkOrderIPAddress : Get the ip address value (network order)
    QueryHostOrderIPAddress    : Get the ip address value (host order)

    StringToLong               : Convert ip address string to 32 bit number
    LongToString               : Convert 32 bit value to ip address string

--*/
{
//
// Helper Functions
//
public:
    static DWORD StringToLong(
        IN LPCTSTR lpstr,
        IN int nLength
        );

    static DWORD StringToLong(
        IN const CString & str
        );

    static DWORD StringToLong(
        IN const CComBSTR & bstr
        );

    static LPCTSTR LongToString(
        IN  const DWORD dwIPAddress,
        OUT CString & str
        );

    static LPCTSTR LongToString(
        IN  const DWORD dwIPAddress,
        OUT CComBSTR & bstr
        );

    static LPTSTR LongToString(
        IN  const DWORD dwIPAddress,
        OUT LPTSTR lpStr,
        IN  int cbSize
        );

    static LPBYTE DWORDtoLPBYTE(
        IN  DWORD  dw,
        OUT LPBYTE lpBytes
        );

public:
    //
    // Constructors
    //
    CIPAddress();

    //
    // Construct from DWORD
    //
    CIPAddress(
        IN DWORD dwIPValue,
        IN BOOL  fNetworkByteOrder = FALSE
        );

    //
    // Construct from byte stream
    //
    CIPAddress(
        IN LPBYTE lpBytes,
        IN BOOL  fNetworkByteOrder = FALSE
        );

    //
    // Construct from octets
    //
    CIPAddress(
        IN BYTE b1,
        IN BYTE b2,
        IN BYTE b3,
        IN BYTE b4
        );

    //
    // Copy constructor
    //
    CIPAddress(
        IN const CIPAddress & ia
        );

    //
    // Construct from string
    //
    CIPAddress(
        IN LPCTSTR lpstr,
        IN int nLength
        );

    //
    // Construct from CString
    //
    CIPAddress(
        IN const CString & str
        );

//
// Access Functions
//
public:
    int CompareItem(
        IN const CIPAddress & ia
        ) const;

    //
    // Query IP address value as a dword
    //
    DWORD QueryIPAddress(
        IN BOOL fNetworkByteOrder = FALSE
        ) const;

    //
    // Get the ip address value as a byte stream
    //
    LPBYTE QueryIPAddress(
        OUT LPBYTE lpBytes,
        IN  BOOL fNetworkByteOrder = FALSE
        ) const;

    //
    // Get the ip address as a CString
    //
    LPCTSTR QueryIPAddress(
        OUT CString & strAddress
        ) const;

    //
    // Get the ip address as a CComBSTR
    //
    LPCTSTR QueryIPAddress(
        OUT CComBSTR & bstrAddress
        ) const;

    //
    // Get ip address in network byte order DWORD
    //
    DWORD QueryNetworkOrderIPAddress() const;

    //
    // Get the ip address in host byte order DWORD
    //
    DWORD QueryHostOrderIPAddress() const;

    //
    // Assignment operators
    //
    const CIPAddress & operator =(
        IN const DWORD dwIPAddress
        );

    const CIPAddress & operator =(
        IN LPCTSTR lpstr
        );

    const CIPAddress & operator =(
        IN const CString & str
        );

    const CIPAddress & operator =(
        IN const CIPAddress & ia
        );

    //
    // Comparison operators
    //
    BOOL operator ==(
        IN const CIPAddress & ia
        ) const;

    BOOL operator ==(
        IN DWORD dwIPAddress
        ) const;

    BOOL operator !=(
        IN const CIPAddress & ia
        ) const;

    BOOL operator !=(
        IN DWORD dwIPAddress
        ) const;

    //
    // Conversion operators
    //
    operator const DWORD() const { return m_dwIPAddress; }
    operator LPCTSTR() const;
    operator CString() const;

    //
    // Value Verification Helpers
    //
    void SetZeroValue();
    BOOL IsZeroValue() const;
    BOOL IsBadValue() const;

private:
    DWORD m_dwIPAddress;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline /* static */ DWORD CIPAddress::StringToLong(
    IN const CString & str
    )
{
    return CIPAddress::StringToLong(str, str.GetLength());
}

inline /* static */ DWORD CIPAddress::StringToLong(
    IN const CComBSTR & bstr
    )
{
    return CIPAddress::StringToLong(bstr, bstr.Length());
}

inline LPCTSTR CIPAddress::QueryIPAddress(
    OUT CString & strAddress
    ) const
{
    return LongToString(m_dwIPAddress, strAddress);
}

inline LPCTSTR CIPAddress::QueryIPAddress(
    OUT CComBSTR & bstrAddress
    ) const
{
    return LongToString(m_dwIPAddress, bstrAddress);
}
        
inline DWORD CIPAddress::QueryNetworkOrderIPAddress() const
{
    return QueryIPAddress(TRUE);
}

inline DWORD CIPAddress::QueryHostOrderIPAddress() const
{
    return QueryIPAddress(FALSE);
}

inline BOOL CIPAddress::operator ==(
    IN const CIPAddress & ia
    ) const
{
    return CompareItem(ia) == 0;
}

inline BOOL CIPAddress::operator ==(
    IN DWORD dwIPAddress
    ) const
{
    return m_dwIPAddress == dwIPAddress;
}

inline BOOL CIPAddress::operator !=(
    IN const CIPAddress & ia
    ) const
{
    return CompareItem(ia) != 0;
}

inline BOOL CIPAddress::operator !=(
    IN DWORD dwIPAddress
    ) const
{
    return m_dwIPAddress != dwIPAddress;
}

inline void CIPAddress::SetZeroValue() 
{
    m_dwIPAddress = NULL_IP_ADDRESS;
}

inline BOOL CIPAddress::IsZeroValue() const
{
    return m_dwIPAddress == NULL_IP_ADDRESS;
}

inline BOOL CIPAddress::IsBadValue() const
{
    return m_dwIPAddress == BAD_IP_ADDRESS;
}



//
// Helper function to build a list of known IP addresses,
// and add them to a combo box
//
DWORD 
COMDLL
PopulateComboWithKnownIpAddresses(
    IN  LPCTSTR lpszServer,
    IN  CComboBox & combo,
    IN  CIPAddress & iaIpAddress,
    OUT CObListPlus & oblIpAddresses,
    OUT int & nIpAddressSel
    );

//
// Helper function to get an ip address from a combo/edit/list
// control
//
BOOL 
COMDLL
FetchIpAddressFromCombo(
    IN  CComboBox & combo,
    IN  CObListPlus & oblIpAddresses,
    OUT CIPAddress & ia
    );

#endif // _IPA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\makefile.inc ===
#
# Since we don't support multiple mc files or msg0001.bin
# blobs, we combine them into a single .mc file.
#
# all: mtxmsg.h wsockmsg.h webcluserr.h commsg.rc

commsg.rc msg00001.bin: commsg.mc
    mc -v commsg.mc -r .\ -h .\

commsg.mc: mtxmsg.mc wsockmsg.mc ..\..\inc\webcluserr.mc wsockmsg.h mtxmsg.h webcluserr.h
    copy /A wsockmsg.mc+mtxmsg.mc+..\..\inc\webcluserr.mc commsg.mc

wsockmsg.h: wsockmsg.mc
    mc -d -v wsockmsg.mc -r .\ -h .\

mtxmsg.h: mtxmsg.mc
    mc -o -v mtxmsg.mc -r .\ -h .\

webcluserr.h: ..\..\inc\webcluserr.mc
    mc -o -v ..\..\inc\webcluserr.mc -r .\ -h .\

clean::
    -del wsockmsg.h   wsockmsg.rc
    -del mtxmsg.h     mtxmsg.rc
    -del webcluserr.h webcluserr.rc
    -del commsg.h     commsg.rc     commsg.mc msg0001.bin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\mdkeys.h ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module Name :
        mdkeys.h

   Abstract:
        Metabase key wrapper classes
        Wam admin interface wrapper class
        App admin interface wrapper class

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/

#ifndef _MDKEYS_H_
#define _MDKEYS_H_

#include <iadmw.h>
#include <iwamreg.h>
#include <iiscnfgp.h>
#include <winsvc.h>
#include <iisrsta.h>
#include "strpass.h"

//
// Forward definitions
//
class CBlob;

//
// Use this instance number to denote the master
//
#define MASTER_INSTANCE       (0)
#define IS_MASTER_INSTANCE(i) (i == MASTER_INSTANCE)


#define ASSURE_PROPER_INTERFACE()\
    if (!HasInterface()) { ASSERT_MSG("No interface"); return MD_ERROR_NOT_INITIALIZED; }


//
// Metabase node constants, used for static initialization of const
// strings further down.  Defined here with #defines for easier 
// concatenation later.
//
#define SZ_MBN_MACHINE      _T("LM")
#define SZ_MBN_FILTERS      _T("Filters")
#define SZ_MBN_MIMEMAP      _T("MimeMap")
#define SZ_MBN_TEMPLATES    _T("Templates")
#define SZ_MBN_INFO         _T("Info")
#define SZ_MBN_ROOT         _T("Root")
#define SZ_MBN_COMPRESSION  _T("Compression")
#define SZ_MBN_PARAMETERS   _T("Parameters")
#define SZ_MBN_SEP_CHAR     _T('/')
#define SZ_MBN_SEP_STR      _T("/")
#define SZ_MBN_WEB          _T("W3SVC")
#define SZ_MBN_FTP          _T("MSFTPSVC")
#define SZ_MBN_SMTP         _T("SMTPSVC")
#define SZ_MBN_NNTP         _T("NNTPSVC")
#define SZ_MBN_APP_POOLS    _T("AppPools")

class CIISInterface;
class COMDLL CComAuthInfo
/*++

Class Description:

    Server/authentication information.  Contains optional 
    impersonation parameters. Typically used in the construction in 
    CIISInterface.

Public Interface:

    CComAuthInfo            : Constructor.  Impersonation optional
    operator=               : Assignment operators
    CreateServerInfoStruct  : Helper function for use in COM
    FreeServerInfoStruct    : As above.

Notes:

    Because there's an operator for a pointer to itself and because
    CIISInterface copies the information at construction time, a 
    CComAuthInfo can safely be constructed on the stack as a parameter
    to CIISInterface derived classes.

--*/
{
//
// Constructor/Destructor
//
public:
    //
    // Standard Constructor.  NULL for servername indicates
    // local computer.
    //
    CComAuthInfo(
        IN LPCOLESTR lpszServerName  = NULL,    
        IN LPCOLESTR lpszUserName    = NULL,
        IN LPCOLESTR lpszPassword    = NULL
        );

    //
    // Copy Constructors
    //
    CComAuthInfo(
        IN CComAuthInfo & auth
        );

    CComAuthInfo(
        IN CComAuthInfo * pAuthInfo OPTIONAL
        );

//
// Assignment operators
//
public:
    CComAuthInfo & operator =(CComAuthInfo & auth);
    CComAuthInfo & operator =(CComAuthInfo * pAuthInfo);
    CComAuthInfo & operator =(LPCTSTR lpszServerName);

//
// Access
//
public:
    COSERVERINFO * CreateServerInfoStruct() const;
    COSERVERINFO * CreateServerInfoStruct(DWORD dwAuthnLevel) const;
    void FreeServerInfoStruct(COSERVERINFO * pServerInfo) const;

    LPOLESTR QueryServerName() const { return m_bstrServerName; }
    LPOLESTR QueryUserName() const { return m_bstrUserName; }
    LPOLESTR QueryPassword() const { return m_bstrPassword; }
    BOOL     IsLocal() const { return m_fLocal; }
    BOOL     UsesImpersonation() const { return m_bstrUserName.Length() > 0; }
    void     SetImpersonation(LPCOLESTR lpszUser, LPCOLESTR lpszPassword);
    void     RemoveImpersonation();
    void     StorePassword(LPCOLESTR lpszPassword);

public:
    HRESULT  ApplyProxyBlanket(IUnknown * pInterface);
	HRESULT  ApplyProxyBlanket(IUnknown * pInterface,DWORD dwAuthnLevel);
    
//
// Conversion Operators
//
public:
    operator LPOLESTR() { return QueryServerName(); }
    operator CComAuthInfo *() { return this; }

//
// Static Helpers
//
public:
    //
    // Given domain\username, split into user name and domain
    //
    static BOOL SplitUserNameAndDomain(
        IN OUT CString & strUserName,
        IN CString & strDomainName
        );

    //
    // Verify username and password are correct
    //
    static DWORD VerifyUserPassword(
        IN LPCTSTR lpstrUserName,
        IN LPCTSTR lpstrPassword
        );

protected:
    //
    // Store the computer name (NULL for local computer)
    //
    void SetComputerName(
        IN LPCOLESTR lpszServerName   OPTIONAL
        );

private:
    CComBSTR    m_bstrServerName;
    CComBSTR    m_bstrUserName;
    CComBSTR    m_bstrPassword;
    BOOL        m_fLocal;
};



class COMDLL CMetabasePath
/*++

Class Description:

    Metabase path class.  This is a helper class to build complete
    metabase paths out of various components.

    Example: CMetaKey(CComAuthInfo("ronaldm3"), CMetabasePath(SZ_WEBSVC, dwInstance, _T("root")));

--*/
{
    //
    // Metabase components in order
    //
    enum
    {
        iBlank,                    // Sep 0
        iMachine,                  // LM
        iService,                  // e.g. lm/w3svc
        iInstance,                 // e.g. lm/w3svc/1
        iRootDirectory,            // e.g. lm/w3svc/1/root
        iSubDirectory,             // e.g. lm/w3vsc/1/root/foobar
    };

//
// Metabase helper functions.
//
public:
    //
    // Clean metabase path
    //
    static LPCTSTR CleanMetaPath(
        IN OUT CString & strMetaRoot
        );

    //
    // Find out the instance number from the given metabase path
    //
    static DWORD GetInstanceNumber(LPCTSTR lpszMDPath);

    //
    // Get the last nodename in the given metabase path
    //
    static LPCTSTR GetLastNodeName(
        IN  LPCTSTR lpszMDPath,
        OUT CString & strNodeName
        );

    //
    // Truncate the path at a given sub path
    //
    static LPCTSTR TruncatePath(
        IN  int     nLevel,          
        IN  LPCTSTR lpszMDPath,
        OUT CString & strNewPath,
        OUT CString * pstrRemainder = NULL
        );

    static LPCTSTR GetMachinePath(
        IN  LPCTSTR lpszMDPath,
        OUT CString & strNewPath,
        OUT CString * pstrRemainder = NULL
        );

    static LPCTSTR GetServicePath(
        IN  LPCTSTR lpszMDPath,
        OUT CString & strNewPath,
        OUT CString * pstrRemainder = NULL
        );

    static LPCTSTR GetInstancePath(
        IN  LPCTSTR lpszMDPath,
        OUT CString & strNewPath,
        OUT CString * pstrRemainder = NULL
        );

    static LPCTSTR GetRootPath(
        IN  LPCTSTR lpszMDPath,
        OUT CString & strNewPath,
        OUT CString * pstrRemainder = NULL
        );

    //
    // Determine the path to the info node that's relevant
    // to this metabase path.
    //
    static LPCTSTR GetServiceInfoPath(
        IN  LPCTSTR lpszMDPath,
        OUT CString & strInfoPath,   
        IN  LPCTSTR lpszDefService  = SZ_MBN_WEB
        );

    //
    // Change path to parent node
    //
    static LPCTSTR ConvertToParentPath(
        OUT IN CString & strMetaPath
        );

    //
    // Determine if the path describes a home directory path
    //
    static BOOL IsHomeDirectoryPath(
        IN LPCTSTR lpszMDPath
        );

    //
    // Determine if the path describes the 'master' instance (site)
    //
    static BOOL IsMasterInstance(
        IN LPCTSTR lpszMDPath
        );

    //
    // Split the metapath at the instance border
    //
    static void SplitMetaPathAtInstance(
        IN  LPCTSTR lpszMDPath,
        OUT CString & strParent,
        OUT CString & strAlias
        );
 

//
// Constructor/Destructor
//
public:
    CMetabasePath(
        IN BOOL    fAddBasePath,
        IN LPCTSTR lpszMDPath,
        IN LPCTSTR lpszMDPath2 = NULL,
        IN LPCTSTR lpszMDPath3 = NULL,
        IN LPCTSTR lpszMDPath4 = NULL
        );

    //
    // Construct with path components
    //
    CMetabasePath(
        IN  LPCTSTR lpszSvc        = NULL,    
        IN  DWORD   dwInstance     = MASTER_INSTANCE,
        IN  LPCTSTR lpszParentPath = NULL,        
        IN  LPCTSTR lpszAlias      = NULL    
        );

//
// Access
//
public:
    BOOL    IsHomeDirectoryPath() const { return IsHomeDirectoryPath(m_strMetaPath); }
    LPCTSTR QueryMetaPath() const { return m_strMetaPath; }

//
// Conversion Operators
//
public:
    operator LPCTSTR() const { return QueryMetaPath(); }

//
// Helpers
//
protected:
    void BuildMetaPath(  
        IN  LPCTSTR lpszSvc,
        IN  LPCTSTR szInstance,
        IN  LPCTSTR lpszParentPath,
        IN  LPCTSTR lpszAlias           
        );

    void BuildMetaPath(  
        IN  LPCTSTR lpszSvc,
        IN  DWORD   dwInstance,
        IN  LPCTSTR lpszParentPath,
        IN  LPCTSTR lpszAlias           
        );

    void AppendPath(LPCTSTR lpszPath);
    void AppendPath(DWORD dwInstance);

protected:
    //
    // Metabase path components
    //
    static const LPCTSTR _cszMachine;     
    static const LPCTSTR _cszRoot;        
    static const LPCTSTR _cszSep;         
    static const TCHAR   _chSep;          

private:
    CString m_strMetaPath;
};



class COMDLL CIISInterface
/*++

Class Description:

    Base interface class for IIS interfaces.  Most client COM-wrappers
    should derive from this class so that they can easily pick up
    share authentication and proxy blanket information methods.

Virtual Interface:

    Succeeded           : Return TRUE if item constructed successfully
    QueryResult         : Return construction error code

Public Interface:

    operator BOOL       : Cast to TRUE/FALSE depending on success
    operator HRESULT    : Cast to the HRESULT status

    QueryServerName     : Get the server name
    IsLocal             : Determine if the interface is on the local machine

--*/
{
//
// Constructor/Destructor
//
public:
    CIISInterface(
        IN CComAuthInfo * pAuthInfo,
        IN HRESULT hrInterface    = S_OK
        );

//
// Interface:
//
public:
    CComAuthInfo * QueryAuthInfo() { return &m_auth; }
    LPCOLESTR QueryServerName() const { return m_auth.QueryServerName(); }
    BOOL IsLocal() const { return m_auth.IsLocal(); }

//
// Virtual Interface:
//
public:
    virtual BOOL Succeeded() const { return SUCCEEDED(m_hrInterface); }
    virtual HRESULT QueryResult() const { return m_hrInterface; }
    virtual HRESULT ChangeProxyBlanket(
        IN LPCOLESTR lpszUserName, 
        IN LPCOLESTR lpszPassword
        );

//
// Conversion Operators
//
public:
    operator BOOL() const { return Succeeded(); }
    operator HRESULT() const { return m_hrInterface; }

protected:
    virtual HRESULT ApplyProxyBlanket() = 0;
    HRESULT Create(
        IN  int   cInterfaces,       
        IN  const IID rgIID[],      
        IN  const GUID rgCLSID[],    
        OUT int * pnInterface,          OPTIONAL
        OUT IUnknown ** ppInterface 
        );

protected:
    CComAuthInfo m_auth;
    HRESULT    m_hrInterface;
};



class COMDLL CMetaInterface : public CIISInterface
/*++

Class description:

    Metabase interface class.

Virtual Interface:

    Succeeded           : Return TRUE if item constructed successfully
    QueryResult         : Return construction error code

Public Interface:

    Regenerate          : Recreate the interface

--*/
{
public:
    //
    // Destructor destroys the interface
    //
    virtual ~CMetaInterface();

//
// Constructor/Destructor
//
protected:
    //
    // Fully defined constructor that creates the interface.
    // Use NULL to indicate the local computer name
    //
    CMetaInterface(
        IN CComAuthInfo * pServer
        );

    //
    // Construct from existing interface
    //
    CMetaInterface(
        IN CMetaInterface * pInterface
        );

public:
    //
    // Rebuild the interface
    //
    HRESULT Regenerate();

    // check if there are metabases changes
    HRESULT GetSystemChangeNumber(OUT DWORD * pdwChangeNumber);
    // 
    // Flush matabase to disk
    //
    HRESULT SaveData();
    //
    IMSAdminBase * GetInterface() { return m_pInterface; }

    HRESULT GetAdminInterface2(IMSAdminBase2 ** pp);
    HRESULT GetAdminInterface3(IMSAdminBase3 ** pp);

    HRESULT CreateSite(
        LPCTSTR service,
        LPCTSTR comment,
        LPCTSTR binding,
        LPCTSTR home_path,
        DWORD * pinst,
        DWORD * pRequestedSiteInst = NULL
        );

protected:
    virtual HRESULT ApplyProxyBlanket();

    //
    // Create a metadata object in this server. This function initializes the
    // metadata object with DCOM.
    //
    HRESULT Create();

    //
    // Make sure the interface has been created
    //
    BOOL HasInterface() const { return m_pInterface != NULL; }

//
// IADMW Interface -- all methods defines as inline at the end of this file.
//
protected:
    HRESULT OpenKey(
        IN  METADATA_HANDLE hkBase,
        IN  LPCTSTR lpszMDPath,
        IN  DWORD dwFlags,
        OUT METADATA_HANDLE * phMDNewHandle
        );

    HRESULT CloseKey(
        IN METADATA_HANDLE hKey
        );

    HRESULT SetLastChangeTime( 
        IN METADATA_HANDLE hMDHandle,
        IN LPCTSTR pszMDPath,
        IN FILETIME * pftMDLastChangeTime,
        IN BOOL bLocalTime
        );
        
    HRESULT GetLastChangeTime( 
        IN  METADATA_HANDLE hMDHandle,
        IN  LPCTSTR lpszMDPath,
        OUT FILETIME * pftMDLastChangeTime,
        IN  BOOL bLocalTime
        );

    HRESULT AddKey( 
        IN METADATA_HANDLE hKey,
        IN LPCTSTR lpszMDPath
        );

    HRESULT DeleteKey(
        IN METADATA_HANDLE hKey,
        IN LPCTSTR lpszMDPath
        );

    HRESULT DeleteChildKeys(
        IN METADATA_HANDLE hKey,
        IN LPCTSTR lpszMDPath
        );

    HRESULT EnumKeys(
        IN  METADATA_HANDLE hKey,
        IN  LPCTSTR lpszMDPath,
        OUT LPTSTR lpszMDName,
        IN  DWORD dwIndex
        );

    HRESULT CopyKey(
        IN METADATA_HANDLE hSourceKey,
        IN LPCTSTR lpszMDSourcePath,
        IN METADATA_HANDLE hDestKey,
        IN LPCTSTR lpszMDDestPath,
        IN BOOL fOverwrite,
        IN BOOL fCopy
        );

    HRESULT RenameKey(
        IN METADATA_HANDLE hKey,
        IN LPCTSTR lpszMDPath,
        IN LPCTSTR lpszNewName
        );

    HRESULT GetData(
        IN  METADATA_HANDLE hKey,
        IN  LPCTSTR lpszMDPath,
        OUT METADATA_RECORD * pmdRecord,
        OUT DWORD * pdwRequiredDataLen
        );

    HRESULT SetData(
        IN METADATA_HANDLE hKey,
        IN LPCTSTR lpszMDPath,
        IN METADATA_RECORD * pmdRecord
        );

    HRESULT DeleteData(
        IN METADATA_HANDLE hKey,
        IN LPCTSTR lpszMDPath,
        IN DWORD dwMDIdentifier,
        IN DWORD dwMDDataType
        );

    HRESULT EnumData(
        IN  METADATA_HANDLE hKey,
        IN  LPCTSTR lpszMDPath,
        OUT METADATA_RECORD * pmdRecord,
        IN  DWORD dwIndex,
        OUT DWORD * pdwRequiredDataLen
        );

    HRESULT GetAllData(
        IN  METADATA_HANDLE hKey,
        IN  LPCTSTR lpszMDPath,
        IN  DWORD dwMDAttributes,
        IN  DWORD dwMDUserType,
        IN  DWORD dwMDDataType,
        OUT DWORD * pdwMDNumDataEntries,
        OUT DWORD * pdwMDDataSetNumber,
        IN  DWORD dwMDBufferSize,
        OUT LPBYTE pbMDBuffer,
        OUT DWORD * pdwRequiredBufferSize
        );

    HRESULT DeleteAllData( 
        IN METADATA_HANDLE hKey,
        IN LPCTSTR lpszMDPath,
        IN DWORD dwMDUserType,
        IN DWORD dwMDDataType
        );

    HRESULT CopyData( 
        IN METADATA_HANDLE hMDSourceKey,
        IN LPCTSTR lpszMDSourcePath,
        IN METADATA_HANDLE hMDDestKey,
        IN LPCTSTR lpszMDDestPath,
        IN DWORD dwMDAttributes,
        IN DWORD dwMDUserType,
        IN DWORD dwMDDataType,
        IN BOOL fCopy
        );

    HRESULT GetDataPaths( 
        IN  METADATA_HANDLE hKey,
        IN  LPCTSTR lpszMDPath,
        IN  DWORD dwMDIdentifier,
        IN  DWORD dwMDDataType,
        IN  DWORD dwMDBufferSize,
        OUT LPTSTR lpszBuffer,
        OUT DWORD * pdwMDRequiredBufferSize
        );

    HRESULT CMetaInterface::GetChildPaths(    
        METADATA_HANDLE hKey,
        LPCTSTR path,
        DWORD buf_size,
        WCHAR * pbuf,
        DWORD * preq_size
        );

    HRESULT Backup( 
        IN LPCTSTR lpszBackupLocation,
        IN DWORD dwMDVersion,
        IN DWORD dwMDFlags
        );

    HRESULT BackupWithPassword(
        IN LPCTSTR lpszBackupLocation,
        IN DWORD dwMDVersion,
        IN DWORD dwMDFlags,
		IN LPCTSTR lpszPassword
		);

    HRESULT Restore(    
        IN LPCTSTR lpszBackupLocation,
        IN DWORD dwMDVersion,
        IN DWORD dwMDFlags
        );

    HRESULT RestoreWithPassword(
        IN LPCTSTR lpszBackupLocation,
        IN DWORD dwMDVersion,
        IN DWORD dwMDFlags,
		IN LPCTSTR lpszPassword
		);

    HRESULT EnumBackups(
        OUT LPTSTR lpszBackupLocation,
        OUT DWORD * pdwMDVersion,
        OUT FILETIME * pftMDBackupTime,
        IN  DWORD dwIndex
        );

    HRESULT DeleteBackup(
        IN LPCTSTR lpszBackupLocation,
        IN DWORD dwMDVersion
        );

    HRESULT EnumHistory( 
        OUT LPTSTR pszMDHistoryLocation,
        OUT DWORD * pdwMDMajorVersion,
        OUT DWORD * pdwMDMinorVersion,
        OUT FILETIME * pftMDHistoryTime,
        IN  DWORD dwIndex
        );

    HRESULT RestoreHistory(    
        IN LPCTSTR pszMDHistoryLocation,
        IN DWORD dwMDMajorVersion,
        IN DWORD dwMDMinorVersion,
        IN DWORD dwMDFlags
        );

protected:
    IMSAdminBase * m_pInterface; 

private:
    int  m_iTimeOutValue;         
};



class COMDLL CMetaKey : public CMetaInterface
/*++

Class Description:

    Metabase key wrapper class

Public Interface:

    CMetaKey                    : Constructor
    ~CMetaKey                   : Destructor

    Succeeded                   : TRUE if key opened successfully.
    QueryResult                 : Get the HRESULT status

    QueryValue                  : Various overloaded methods to get values
    SetValue                    : Various overloaded methods to set values
    DeleteValue                 : Delete a value
    Open                        : Open key
    ReOpen                      : Re key that was opened before
    Close                       : Close key
    ConvertToParentPath         : Change path to parent path

    operator METADATA_HANDLE    : Cast to a metadata handle
    operator LPCTSTR            : Cast to the metabase path
    operator BOOL               : Cast to TRUE if the key is open, FALSE if not

    GetHandle                   : Obtain metadata handle
    IsOpen                      : TRUE if a key is open
    QueryMetaPath               : Get the relative metabase path
    QueryFlags                  : Get the open permissions

--*/
{
//
// Constructor/Destructor
//
public:
    //
    // Null constructor that only creates the interface.
    // A key constructed this way may read from META_ROOT_HANDLE.
    // This is not true of other constructors.
    //
    CMetaKey(
        IN CComAuthInfo * pServer
        );

    //
    // As above, using an existing interface
    //
    CMetaKey(
        IN CMetaInterface * pInterface
        );

    //
    // Fully defined constructor that opens a key
    //
    CMetaKey(
        IN CComAuthInfo * pServer,
        IN LPCTSTR lpszMDPath,
        IN DWORD   dwFlags        = METADATA_PERMISSION_READ,
        IN METADATA_HANDLE hkBase = METADATA_MASTER_ROOT_HANDLE
        );

    //
    // As above, using an existing interface
    //
    CMetaKey(
        IN CMetaInterface * pInterface,
        IN LPCTSTR lpszMDPath,
        IN DWORD   dwFlags        = METADATA_PERMISSION_READ,
        IN METADATA_HANDLE hkBase = METADATA_MASTER_ROOT_HANDLE
        );

    //
    // Copy constructor, might or might not own the key
    //
    CMetaKey(
        IN BOOL  fOwnKey,
        IN CMetaKey * pKey
        );

    //
    // Destructor -- closes key.
    //
    virtual ~CMetaKey();

//
// Interface
//
public:
    //
    // Fetch a DWORD
    //
    HRESULT QueryValue(
        IN  DWORD dwID, 
        OUT DWORD & dwValue,
        IN  BOOL * pfInheritanceOverride = NULL,
        IN  LPCTSTR lpszMDPath           = NULL,
        OUT DWORD * pdwAttributes        = NULL
        );

    //
    // Fetch a boolean
    //
    HRESULT QueryValue(
        IN  DWORD dwID, 
        OUT BOOL & fValue,
        IN  BOOL * pfInheritanceOverride = NULL,
        IN  LPCTSTR lpszMDPath           = NULL,
        OUT DWORD * pdwAttributes        = NULL
        );

    //
    // Fetch a string
    //
    HRESULT QueryValue(
        IN  DWORD dwID, 
        OUT CString & strValue, 
        IN  BOOL * pfInheritanceOverride = NULL,
        IN  LPCTSTR lpszMDPath           = NULL,
        OUT DWORD * pdwAttributes        = NULL
        );

    //
    // Fetch a CStrPassword
    //
    HRESULT QueryValue(
        IN  DWORD dwID, 
        OUT CStrPassword & strValue, 
        IN  BOOL * pfInheritanceOverride = NULL,
        IN  LPCTSTR lpszMDPath           = NULL,
        OUT DWORD * pdwAttributes        = NULL
        );

    //
    // Fetch a BSTR
    //
    HRESULT QueryValue(
        IN  DWORD dwID, 
        OUT CComBSTR & strValue, 
        IN  BOOL * pfInheritanceOverride = NULL,
        IN  LPCTSTR lpszMDPath           = NULL,
        OUT DWORD * pdwAttributes        = NULL
        );

    //
    // Fetch a string list
    //
    HRESULT QueryValue(
        IN  DWORD dwID, 
        OUT CStringListEx & strlValue, 
        IN  BOOL * pfInheritanceOverride = NULL,
        IN  LPCTSTR lpszMDPath           = NULL,
        OUT DWORD * pdwAttributes        = NULL
        );

    //
    // Fetch binary blob
    //
    HRESULT QueryValue(
        IN  DWORD dwID, 
        OUT CBlob & blValue, 
        IN  BOOL * pfInheritanceOverride = NULL,
        IN  LPCTSTR lpszMDPath           = NULL,
        OUT DWORD * pdwAttributes        = NULL
        );

    //
    // Store a DWORD
    //
    HRESULT SetValue(
        IN DWORD dwID,
        IN DWORD dwValue,
        IN BOOL * pfInheritanceOverride = NULL,
        IN LPCTSTR lpszMDPath           = NULL
        );

    //
    // Store a BOOL
    //
    HRESULT SetValue(
        IN DWORD dwID,
        IN BOOL fValue,
        IN BOOL * pfInheritanceOverride = NULL,
        IN LPCTSTR lpszMDPath           = NULL
        );

    //
    // Store a string
    //
    HRESULT SetValue(
        IN DWORD dwID,
        IN CString & strValue,
        IN BOOL * pfInheritanceOverride = NULL,
        IN LPCTSTR lpszMDPath           = NULL
        );

    //
    // Store a StrPassword
    //
    HRESULT SetValue(
        IN DWORD dwID,
        IN CStrPassword & strValue,
        IN BOOL * pfInheritanceOverride = NULL,
        IN LPCTSTR lpszMDPath           = NULL
        );

    //
    // Store a BSTR
    //
    HRESULT SetValue(
        IN DWORD dwID,
        IN CComBSTR & strValue,
        IN BOOL * pfInheritanceOverride = NULL,
        IN LPCTSTR lpszMDPath           = NULL
        );


    //
    // Store a stringlist
    //
    HRESULT SetValue(
        IN DWORD dwID,
        IN CStringListEx & strlValue,
        IN BOOL * pfInheritanceOverride  = NULL,
        IN LPCTSTR lpszMDPath            = NULL
        );

    //
    // Store a binary blob
    //
    HRESULT SetValue(
        IN DWORD dwID,
        IN CBlob & blValue,
        IN BOOL * pfInheritanceOverride  = NULL,
        IN LPCTSTR lpszMDPath            = NULL
        );

    //
    // Delete Value:
    //
    HRESULT DeleteValue(
        IN DWORD   dwID,
        IN LPCTSTR lpszMDPath = NULL
        );

    //
    // Check for path existance
    //
    HRESULT DoesPathExist(
        IN LPCTSTR lpszMDPath
        );

    //
    // Create current path (which we attempted to open, and got
    // a path not found error on).
    //
    HRESULT CreatePathFromFailedOpen();

    //
    // Check for descendant overrides
    //
    HRESULT CheckDescendants(
        IN DWORD   dwID,
        IN CComAuthInfo * pServer,
        IN LPCTSTR lpszMDPath       = NULL
        );

    //
    // Open key
    //
    HRESULT Open(
        IN DWORD   dwFlags,
        IN LPCTSTR lpszMDPath       = NULL,
        IN METADATA_HANDLE hkBase   = METADATA_MASTER_ROOT_HANDLE 
        );

    //
    // Re-open previously opened key
    //
    HRESULT ReOpen(
        IN DWORD   dwFlags
        );

    //
    // As above using the same permissions as before
    //
    HRESULT ReOpen();

    //
    // Open the parent object
    // 
    HRESULT ConvertToParentPath(
        IN  BOOL fImmediate
        );

    //
    // Close key, set it to NULL, but doesn't destroy the interface
    //
    HRESULT Close();

    //
    // Add key
    //
    HRESULT AddKey(
        IN LPCTSTR lpszMDPath
        );

    //
    // Delete key off currently open key
    //
    HRESULT DeleteKey(
        IN LPCTSTR lpszMDPath
        );

    //
    // Rename key off currently open key
    //
    HRESULT RenameKey(
        IN LPCTSTR lpszMDPath,
        IN LPCTSTR lpszNewName
        );

    //
    // Get list of descendant nodes that override
    // a specific value
    //
    HRESULT GetDataPaths( 
        OUT CStringListEx & strlNodes,
        IN  DWORD dwMDIdentifier,
        IN  DWORD dwMDDataType,
        IN  LPCTSTR lpszMDPath = NULL
        );

    HRESULT GetChildPaths(
        CStringListEx & strlValue, 
        LPCTSTR lpszMDPath           = NULL
        );


//
// Access
//
public:
    METADATA_HANDLE GetHandle() const { return m_hKey; }
    METADATA_HANDLE GetBase() const   { return m_hBase; }
    LPCTSTR QueryMetaPath() const     { return m_strMetaPath; }
    DWORD QueryFlags() const          { return m_dwFlags; }
    BOOL IsOpen() const               { return m_hKey != NULL; }
    BOOL IsHomeDirectoryPath() const ;

//
// Conversion operators
//
public:
    operator METADATA_HANDLE() const  { return GetHandle(); }
    operator LPCTSTR() const          { return QueryMetaPath(); }
    operator BOOL() const             { return IsOpen(); }

//
// Virtual Interface:
//
public:
    virtual BOOL Succeeded() const;
    virtual HRESULT QueryResult() const;

//
// Protected members
//
protected:
    //
    // Get data
    //
    HRESULT GetPropertyValue(
        IN  DWORD dwID,
        OUT IN DWORD & dwSize,
        OUT IN void *& pvData,
        OUT IN DWORD * pdwDataType           = NULL,
        IN  BOOL * pfInheritanceOverride     = NULL,
        IN  LPCTSTR lpszMDPath               = NULL,
        OUT DWORD * pdwAttributes            = NULL
        );

    //
    // Store data
    //
    HRESULT SetPropertyValue(
        IN DWORD dwID,
        IN DWORD dwSize,
        IN void * pvData,
        IN BOOL * pfInheritanceOverride = NULL,
        IN LPCTSTR lpszMDPath           = NULL
        );

    //
    // Get All Data off the open key
    //
    HRESULT GetAllData(
        IN  DWORD dwMDAttributes,
        IN  DWORD dwMDUserType,
        IN  DWORD dwMDDataType,
        OUT DWORD * pdwMDNumEntries,
        OUT DWORD * pdwMDDataLen,
        OUT PBYTE * ppbMDData,
        IN  LPCTSTR lpszMDPath  = NULL
        );

//
// Property Table Methods
//
public:
    //
    // Metabase table entry definition
    //
    typedef struct tagMDFIELDDEF
    {
        DWORD dwMDIdentifier;
        DWORD dwMDAttributes;
        DWORD dwMDUserType;
        DWORD dwMDDataType;
        UINT  uStringID;
    } MDFIELDDEF;

protected:
    static const MDFIELDDEF s_rgMetaTable[];
	static const int s_MetaTableSize;

//
// CODEWORK: Ideally, these should be protected, but are used
//           by idlg.
//
public:
    static BOOL GetMDFieldDef(
        DWORD dwID,
        DWORD & dwMDIdentifier,
        DWORD & dwMDAttributes,
        DWORD & dwMDUserType,
        DWORD & dwMDDataType
        );

    //
    // Map metabase ID value to table index
    //
    static int MapMDIDToTableIndex(DWORD dwID);
    static const CMetaKey::MDFIELDDEF * CMetaKey::GetMetaProp(DWORD id);

//
// Allow limited access to the table
//
public:
    static BOOL IsPropertyInheritable(DWORD dwID);
    static BOOL GetPropertyDescription(DWORD dwID, CString & strName);

protected:
    BOOL    m_fAllowRootOperations;
    BOOL    m_fOwnKey;
    DWORD   m_cbInitialBufferSize;    
    DWORD   m_dwFlags;
    HRESULT m_hrKey;
    CString m_strMetaPath;
    METADATA_HANDLE m_hKey;
    METADATA_HANDLE m_hBase;
};



class COMDLL CWamInterface : public CIISInterface
/*++

Class description:

    WAM interface class

Virtual Interface:

    Succeeded           : Return TRUE if item constructed successfully
    QueryResult         : Return construction error code

Public Interface:

    SupportsPooledProc  : Check to see if pooled out of proc is supported.

--*/
{
//
// App Protection States:
//
public:
    enum
    {
        //
        // Note: order must match MD_APP_ISOLATED values
        //
        APP_INPROC,
        APP_OUTOFPROC,
        APP_POOLEDPROC,
    };

//
// Constructor/Destructor
//
public:
    //
    // Destructor destroys the interface
    //
    virtual ~CWamInterface();

protected:
    //
    // Fully defined constructor that creates the interface.
    // Use NULL to create the interface on the local computer
    //
    CWamInterface(
        IN CComAuthInfo * pServer
        );

    //
    // Construct from existing interface.  
    //
    CWamInterface(
        IN CWamInterface * pInterface
        );

//
// Access
//
public:
    BOOL SupportsPooledProc() const { return m_fSupportsPooledProc; }
	HRESULT GetAppAdminInterface(IIISApplicationAdmin ** pp);

protected:
    virtual HRESULT ApplyProxyBlanket();

    //
    // Create a wam object in this server. This function initializes the
    // object with DCOM.
    //
    HRESULT Create();

    //
    // Make sure the interface has been created
    //
    BOOL HasInterface() const { return m_pInterface != NULL; }

//
// IWAM Interface
//
protected:
    HRESULT AppCreate( 
        IN LPCTSTR szMDPath,
        IN DWORD dwAppProtection
        );
    
    HRESULT AppDelete( 
        IN LPCTSTR szMDPath,
        IN BOOL fRecursive
        );
    
    HRESULT AppUnLoad( 
        IN LPCTSTR szMDPath,
        IN BOOL fRecursive
        );
    
    HRESULT AppGetStatus( 
        IN  LPCTSTR szMDPath,
        OUT DWORD * pdwAppStatus
        );
    
    HRESULT AppDeleteRecoverable( 
        IN LPCTSTR szMDPath,
        IN BOOL fRecursive
        );
    
    HRESULT AppRecover( 
        IN LPCTSTR szMDPath,
        IN BOOL fRecursive
        );

//
// IIISApplicationAdmin interface
//
    HRESULT CreateApplication(
        LPCWSTR szMDPath,
        DWORD dwAppMode,
        LPCWSTR szAppPoolId,
        BOOL fCreatePool
        );
    
    HRESULT DeleteApplication(
        LPCWSTR szMDPath,
        BOOL fRecursive
        );
    
    HRESULT CreateApplicationPool(
        LPCWSTR szMDPath
        );
    
    HRESULT DeleteApplicationPool(
        LPCWSTR szMDPath
        );
    
    HRESULT RecycleApplicationPool(
        LPCWSTR szMDPath
        );
    
    HRESULT EnumerateApplicationsInPool(
        LPCWSTR szMDPath,
        BSTR   *pbstr
        );
    
    HRESULT GetProcessMode(
        DWORD * pdwMode
        );

protected:
    IWamAdmin * m_pInterface;

private:
    BOOL m_fSupportsPooledProc;
};

class COMDLL CMetaBack : public CMetaInterface, public CWamInterface
/*++

Class Description:

    Metabase backup/restore class

Virtual Interface:

    Succeeded           : Return TRUE if item constructed successfully
    QueryResult         : Return construction error code

Public Interface:

    Reset               : Enum first existing backup
    Next                : Enum next existing backup
    NextHistory         : Enum next existing history backup
    Backup              : Create new backup
    Delete              : Delete existing backup
    Restore             : Restore from existing backup
    RestoreHistoryBackup: Restore from existing history

--*/
{
public:
    //
    // Construct and create the interfaces.  Use NULL to create
    // on the local computer.
    //
    CMetaBack(
        IN CComAuthInfo * pServer
        );

//
// Virtual Interface
//
public:
    virtual BOOL Succeeded() const;
    virtual HRESULT QueryResult() const;

//
// Interface
//
public:
    //
    // Reset counter
    //
    void Reset() { m_dwIndex = 0L; }

    HRESULT Next(
        OUT DWORD * pdwVersion,
        OUT LPTSTR lpszLocation,
        OUT FILETIME * pftBackupTime
        );

    HRESULT NextHistory(
        OUT DWORD * pdwMDMajorVersion,
        OUT DWORD * pdwMDMinorVersion,
        OUT LPTSTR lpszLocation,
        OUT FILETIME * pftBackupTime
        );

    HRESULT Backup(
        IN LPCTSTR lpszLocation
        );

    HRESULT BackupWithPassword(
        IN LPCTSTR lpszLocation,
		IN LPCTSTR lpszPassword
		);

    HRESULT Delete(
        IN LPCTSTR lpszLocation,
        IN DWORD dwVersion
        );

    HRESULT Restore(
        IN LPCTSTR lpszLocation,
        IN DWORD dwVersion
        );

    HRESULT RestoreWithPassword(
        IN LPCTSTR lpszLocation,
        IN DWORD dwVersion,
		IN LPCTSTR lpszPassword
        );

    HRESULT RestoreHistoryBackup(    
        IN LPCTSTR pszMDHistoryLocation,
        IN DWORD dwMDMajorVersion,
        IN DWORD dwMDMinorVersion,
        IN DWORD dwMDFlags
        );

protected:
    virtual HRESULT ApplyProxyBlanket();

protected:
    static const LPCTSTR s_szMasterAppRoot;

private:
    DWORD m_dwIndex;
};



class COMDLL CMetaEnumerator : public CMetaKey
/*++

Class Description:

    Metabase key enumerator

Public Interface:

    CMetaEnumerator     : Constructor
    
    Reset               : Reset the enumerator
    Next                : Get next key

--*/
{
public:
    //
    // Constructor creates a new interface and opens a key
    //
    CMetaEnumerator(
        IN CComAuthInfo * pServer,
        IN LPCTSTR lpszMDPath     = NULL,
        IN METADATA_HANDLE hkBase = METADATA_MASTER_ROOT_HANDLE
        );

    //
    // Constructor which uses an existing interface and opens
    // a new key
    //
    CMetaEnumerator(
        IN CMetaInterface * pInterface,
        IN LPCTSTR lpszMDPath     = NULL,
        IN METADATA_HANDLE hkBase = METADATA_MASTER_ROOT_HANDLE
        );

    //
    // Constructor which uses an open key
    //
    CMetaEnumerator(
        IN BOOL fOwnKey,
        IN CMetaKey * pKey
        );

//
// Interface:
//
public:
    //
    // Reset counter
    //
    void Reset() { m_dwIndex = 0L; }

    //
    // Get next key as string.
    //
    HRESULT Next(
        OUT CString & strKey,
        IN  LPCTSTR lpszMDPath = NULL
        );

    //
    // Get next key as a DWORD (numeric keys only)
    //
    HRESULT Next(
        OUT DWORD & dwKey,
        OUT CString & strKey,
        IN  LPCTSTR lpszMDPath = NULL
        );

private:
    DWORD m_dwIndex;
};



class COMDLL CIISApplication : public CWamInterface, public CMetaKey
/*++

Class Description:

    IIS Application class

Virtual Interface:

    Succeeded           : Return TRUE if item constructed successfully
    QueryResult         : Return construction error code

Public Interface:

    RefreshState        : Refresh application state
    QueryAppState       : Return current application state
    IsEnabledApplication: Return TRUE if appplication is enabled. 
    Create              : Create app
    Delete              : Delete app
    Unload              : Unload app
    DeleteRecoverable   : Delete w. recovery allowed
    Recover             : Recover
    WriteFriendlyName   : Write friendly name to metabase

--*/
{
//
// Constructor/Destructor
//
public:
    CIISApplication(
        IN CComAuthInfo * pServer,
        IN LPCTSTR lpszMetapath
        );

//
// Virtual Interface:
//
public:
    virtual BOOL Succeeded() const;
    virtual HRESULT QueryResult() const;

//
// Interface
//
public:
    DWORD   QueryAppState() const { return m_dwAppState; }
    LPCTSTR QueryWamPath() const { return m_strWamPath; }
    BOOL    IsEnabledApplication() const;
    HRESULT RefreshAppState();
    HRESULT Create(LPCTSTR lpszName, DWORD dwAppProtection);
	HRESULT CreatePooled(LPCTSTR lpszName, DWORD dwAppMode,
		LPCTSTR pool_id, BOOL fCreatePool = FALSE);
    HRESULT Delete(BOOL fRecursive = FALSE);
    HRESULT Unload(BOOL fRecursive = FALSE);
    HRESULT DeleteRecoverable(BOOL fRecursive = FALSE);
    HRESULT Recover(BOOL fRecursive = FALSE);
    HRESULT WriteFriendlyName(LPCTSTR lpszName);
    HRESULT WritePoolId(LPCTSTR id);

public:
    BOOL IsInproc() const { return m_dwProcessProtection == APP_INPROC; }
    BOOL IsOutOfProc() const { return m_dwProcessProtection == APP_OUTOFPROC; }
    BOOL IsPooledProc() const { return m_dwProcessProtection == APP_POOLEDPROC; }

public:
    DWORD   m_dwProcessProtection;
    CString m_strAppPoolId;
    CString m_strFriendlyName;
    CString m_strAppRoot;

protected:
    void CommonConstruct();

private:
    DWORD   m_dwAppState;
    CString m_strWamPath;
    HRESULT m_hrApp;
};

class COMDLL CIISAppPool : public CWamInterface, public CMetaKey
{
public:
    CIISAppPool(
        IN CComAuthInfo * pServer,
        IN LPCTSTR lpszMetapath = NULL
        );
//
// Virtual Interface:
//
public:
    virtual BOOL Succeeded() const;
    virtual HRESULT QueryResult() const;

//
// Interface
//
public:
    HRESULT RefreshState();
    DWORD QueryPoolState() const { return m_dwPoolState; }
    LPCTSTR QueryWamPath() const { return m_strWamPath; }
    HRESULT Create(LPCTSTR lpszName = NULL);
    HRESULT Delete(LPCTSTR id);
	HRESULT Recycle(LPCTSTR id);
    HRESULT GetProcessMode(DWORD * pdwMode);
    HRESULT WriteFriendlyName(LPCTSTR lpszName);
    HRESULT EnumerateApplications(CStringListEx& list);

public:
    CString m_strAppPoolId;

private:
    DWORD m_dwPoolState;
    CString m_strWamPath;
    HRESULT m_hrPool;
};

class COMDLL CIISSvcControl : public CIISInterface
/*++

Class description:

    IIS Service control

Virtual Interface:

    Succeeded           : Return TRUE if item constructed successfully
    QueryResult         : Return construction error code

--*/
{
//
// Constructor/Destructor
//
public:
    //
    // Fully defined constructor that creates the interface.
    // Use NULL to create the interface on the local computer
    //
    CIISSvcControl(
        IN CComAuthInfo * pServer
        );

    //
    // Construct from existing interface.  
    //
    CIISSvcControl(
        IN CIISSvcControl * pInterface
        );

    //
    // Destructor destroys the interface
    //
    virtual ~CIISSvcControl();

protected:
    //
    // Create an object in this server. This function initializes the
    // object with DCOM.
    //
    HRESULT Create();

    //
    // Make sure the interface has been created
    //
    BOOL HasInterface() const { return m_pInterface != NULL; }

//
// Interface
//
public:
    //
    // Stop services
    //
    HRESULT Stop(
        IN DWORD dwTimeoutMsecs,
        IN BOOL fForce
        );

    //
    // Start services
    //
    HRESULT Start(
        IN DWORD dwTimeoutMsecs
        );

    //
    // Reboot
    //
    HRESULT Reboot(
        IN DWORD dwTimeouMsecs,
        IN BOOL fForceAppsClosed
        );

    //
    // Status
    //
    HRESULT Status(
        IN  DWORD dwBufferSize,
        OUT LPBYTE pbBuffer,
        OUT DWORD * MDRequiredBufferSize,
        OUT DWORD * pdwNumServices
        );

    //
    // Kill
    //
    HRESULT Kill();

protected:
    virtual HRESULT ApplyProxyBlanket();

protected:
    IIisServiceControl * m_pInterface; 
};


//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline void CComAuthInfo::StorePassword(LPCOLESTR lpszPassword)
{
    m_bstrPassword = lpszPassword;
}

inline /* virtual */ HRESULT CIISInterface::ChangeProxyBlanket(
    IN LPCOLESTR lpszUserName, 
    IN LPCOLESTR lpszPassword
    )
{
    m_auth.SetImpersonation(lpszUserName, lpszPassword);
    return ApplyProxyBlanket();
}

inline /*static */ LPCTSTR CMetabasePath::GetMachinePath(
    IN  LPCTSTR lpszMDPath,
    OUT CString & strNewPath,
    OUT CString * pstrRemainder
    )
{
    return TruncatePath(iMachine, lpszMDPath, strNewPath, pstrRemainder);
}

inline /* static */ LPCTSTR CMetabasePath::GetServicePath(
    IN  LPCTSTR lpszMDPath,
    OUT CString & strNewPath,
    OUT CString * pstrRemainder
    )
{
    return TruncatePath(iService, lpszMDPath, strNewPath, pstrRemainder);
}

inline /* static */ LPCTSTR CMetabasePath::GetInstancePath(
    IN  LPCTSTR lpszMDPath,
    OUT CString & strNewPath,
    OUT CString * pstrRemainder
    )
{
    return TruncatePath(iInstance, lpszMDPath, strNewPath, pstrRemainder);
}

inline /* static */ LPCTSTR CMetabasePath::GetRootPath(
    IN  LPCTSTR lpszMDPath,
    OUT CString & strNewPath,
    OUT CString * pstrRemainder
    )
{
    return TruncatePath(iRootDirectory, lpszMDPath, strNewPath, pstrRemainder);
}

inline HRESULT CMetaInterface::Create()
{
    return CIISInterface::Create(
        1,
        &IID_IMSAdminBase, 
        &CLSID_MSAdminBase, 
        NULL,
        (IUnknown **)&m_pInterface
        );
}

inline /* virtual */ HRESULT CMetaInterface::ApplyProxyBlanket()
{
    return m_auth.ApplyProxyBlanket(m_pInterface);
}

inline HRESULT CMetaInterface::OpenKey(
    IN  METADATA_HANDLE hkBase,
    IN  LPCTSTR lpszMDPath,
    IN  DWORD dwFlags,
    OUT METADATA_HANDLE * phMDNewHandle
    )
{
    ASSERT_PTR(m_pInterface);
	ASSURE_PROPER_INTERFACE();
	return m_pInterface->OpenKey(
        hkBase,
        lpszMDPath,
        dwFlags,
        m_iTimeOutValue,
        phMDNewHandle
        );
}

inline HRESULT CMetaInterface::CloseKey(
    IN METADATA_HANDLE hKey
    )
{
    ASSERT_PTR(m_pInterface);
	ASSURE_PROPER_INTERFACE();
    return m_pInterface->CloseKey(hKey);
}

inline HRESULT CMetaInterface::SetLastChangeTime( 
    IN METADATA_HANDLE hMDHandle,
    IN LPCTSTR pszMDPath,
    IN FILETIME * pftMDLastChangeTime,
    IN BOOL bLocalTime
    )
{
    ASSERT_PTR(m_pInterface);
	ASSURE_PROPER_INTERFACE();
    return m_pInterface->SetLastChangeTime(
        hMDHandle,
        pszMDPath,
        pftMDLastChangeTime,
        bLocalTime
        );
}
        
inline HRESULT CMetaInterface::GetLastChangeTime( 
    IN  METADATA_HANDLE hMDHandle,
    IN  LPCTSTR lpszMDPath,
    OUT FILETIME * pftMDLastChangeTime,
    IN  BOOL bLocalTime
    )
{
    ASSERT_PTR(m_pInterface);
	ASSURE_PROPER_INTERFACE();
    return m_pInterface->GetLastChangeTime(
        hMDHandle,
        lpszMDPath,
        pftMDLastChangeTime,
        bLocalTime
        );
}

inline HRESULT CMetaInterface::AddKey( 
    IN METADATA_HANDLE hKey,
    IN LPCTSTR lpszMDPath
    )
{
    ASSERT_PTR(m_pInterface);
	ASSURE_PROPER_INTERFACE();
    return m_pInterface->AddKey(hKey, lpszMDPath);
}

inline HRESULT CMetaInterface::DeleteKey(
    IN METADATA_HANDLE hKey,
    IN LPCTSTR lpszMDPath
    )
{
    ASSERT_PTR(m_pInterface);
	ASSURE_PROPER_INTERFACE();
    return m_pInterface->DeleteKey(hKey, lpszMDPath);
}

inline HRESULT CMetaInterface::DeleteChildKeys(
    IN METADATA_HANDLE hKey,
    IN LPCTSTR lpszMDPath
    )
{
    ASSERT_PTR(m_pInterface);
	ASSURE_PROPER_INTERFACE();
    return m_pInterface->DeleteChildKeys(hKey, lpszMDPath);
}

inline HRESULT CMetaInterface::EnumKeys(
    IN  METADATA_HANDLE hKey,
    IN  LPCTSTR lpszMDPath,
    OUT LPTSTR lpszMDName,
    IN  DWORD dwIndex
    )
{
    ASSERT_PTR(m_pInterface);
	ASSURE_PROPER_INTERFACE();
    return m_pInterface->EnumKeys(hKey, lpszMDPath, lpszMDName, dwIndex);
}        

inline HRESULT CMetaInterface::CopyKey(
    IN METADATA_HANDLE hSourceKey,
    IN LPCTSTR lpszMDSourcePath,
    IN METADATA_HANDLE hDestKey,
    IN LPCTSTR lpszMDDestPath,
    IN BOOL fOverwrite,
    IN BOOL fCopy
    )
{
    ASSERT_PTR(m_pInterface);
	ASSURE_PROPER_INTERFACE();
    return m_pInterface->CopyKey(
        hSourceKey,
        lpszMDSourcePath,
        hDestKey,
        lpszMDDestPath,
        fOverwrite,
        fCopy
        );        
}

inline HRESULT CMetaInterface::RenameKey(
    IN METADATA_HANDLE hKey,
    IN LPCTSTR lpszMDPath,
    IN LPCTSTR lpszNewName
    )
{   
    ASSERT_PTR(m_pInterface);     
	ASSURE_PROPER_INTERFACE();
    return m_pInterface->RenameKey(hKey, lpszMDPath, lpszNewName);
}

inline HRESULT CMetaInterface::GetData(
    IN  METADATA_HANDLE hKey,
    IN  LPCTSTR lpszMDPath,
    OUT METADATA_RECORD * pmdRecord,
    OUT DWORD * pdwRequiredDataLen
    )
{
    ASSERT_PTR(m_pInterface);
	ASSURE_PROPER_INTERFACE();
    return m_pInterface->GetData(
        hKey,
        lpszMDPath,
        pmdRecord,
        pdwRequiredDataLen
        );
}

inline HRESULT CMetaInterface::SetData(
    IN METADATA_HANDLE hKey,
    IN LPCTSTR lpszMDPath,
    IN METADATA_RECORD * pmdRecord
    )
{
    ASSERT_PTR(m_pInterface);
	ASSURE_PROPER_INTERFACE();
    return m_pInterface->SetData(
        hKey,
        lpszMDPath,
        pmdRecord
        );
}

inline HRESULT CMetaInterface::DeleteData(
    IN METADATA_HANDLE hKey,
    IN LPCTSTR lpszMDPath,
    IN DWORD dwMDIdentifier,
    IN DWORD dwMDDataType
    )
{
    ASSERT_PTR(m_pInterface);
	ASSURE_PROPER_INTERFACE();
    return m_pInterface->DeleteData(
        hKey,
        lpszMDPath,
        dwMDIdentifier,
        dwMDDataType
        );
}

inline HRESULT CMetaInterface::EnumData(
    IN  METADATA_HANDLE hKey,
    IN  LPCTSTR lpszMDPath,
    OUT METADATA_RECORD * pmdRecord,
    IN  DWORD dwIndex,
    OUT DWORD * pdwRequiredDataLen
    )
{
    ASSERT_PTR(m_pInterface);
	ASSURE_PROPER_INTERFACE();
    return m_pInterface->EnumData(
        hKey,
        lpszMDPath,
        pmdRecord,
        dwIndex,
        pdwRequiredDataLen
        );
}

inline HRESULT CMetaInterface::GetAllData(
    IN  METADATA_HANDLE hKey,
    IN  LPCTSTR lpszMDPath,
    IN  DWORD dwMDAttributes,
    IN  DWORD dwMDUserType,
    IN  DWORD dwMDDataType,
    OUT DWORD * pdwMDNumDataEntries,
    OUT DWORD * pdwMDDataSetNumber,
    IN  DWORD dwMDBufferSize,
    OUT LPBYTE pbMDBuffer,
    OUT DWORD * pdwRequiredBufferSize
    )
{
    ASSERT_PTR(m_pInterface);
	ASSURE_PROPER_INTERFACE();
    return m_pInterface->GetAllData(
        hKey,
        lpszMDPath,
        dwMDAttributes,
        dwMDUserType,
        dwMDDataType,
        pdwMDNumDataEntries,
        pdwMDDataSetNumber,
        dwMDBufferSize,
        pbMDBuffer,
        pdwRequiredBufferSize
        );
}    

inline HRESULT CMetaInterface::DeleteAllData( 
    IN METADATA_HANDLE hKey,
    IN LPCTSTR lpszMDPath,
    IN DWORD dwMDUserType,
    IN DWORD dwMDDataType
    )
{
    ASSERT_PTR(m_pInterface);
	ASSURE_PROPER_INTERFACE();
    return m_pInterface->DeleteAllData(
        hKey, 
        lpszMDPath, 
        dwMDUserType, 
        dwMDDataType
        );
}

inline HRESULT CMetaInterface::CopyData( 
    IN METADATA_HANDLE hMDSourceKey,
    IN LPCTSTR lpszMDSourcePath,
    IN METADATA_HANDLE hMDDestKey,
    IN LPCTSTR lpszMDDestPath,
    IN DWORD dwMDAttributes,
    IN DWORD dwMDUserType,
    IN DWORD dwMDDataType,
    IN BOOL fCopy
    )
{
    ASSERT_PTR(m_pInterface);
	ASSURE_PROPER_INTERFACE();
    return m_pInterface->CopyData(
        hMDSourceKey,
        lpszMDSourcePath,
        hMDDestKey,
        lpszMDDestPath,
        dwMDAttributes,
        dwMDUserType,
        dwMDDataType,
        fCopy
        );
}

inline HRESULT CMetaInterface::GetDataPaths( 
    IN  METADATA_HANDLE hKey,
    IN  LPCTSTR lpszMDPath,
    IN  DWORD dwMDIdentifier,
    IN  DWORD dwMDDataType,
    IN  DWORD dwMDBufferSize,
    OUT LPTSTR lpszBuffer,
    OUT DWORD * pdwMDRequiredBufferSize
    )
{
    ASSERT_PTR(m_pInterface);
	ASSURE_PROPER_INTERFACE();
    return m_pInterface->GetDataPaths(
        hKey,
        lpszMDPath,
        dwMDIdentifier,
        dwMDDataType,
        dwMDBufferSize,
        lpszBuffer,
        pdwMDRequiredBufferSize
        );
}

inline HRESULT CMetaInterface::Backup( 
    IN LPCTSTR lpszBackupLocation,
    IN DWORD dwMDVersion,
    IN DWORD dwMDFlags
    )
{
    ASSERT_PTR(m_pInterface);
	ASSURE_PROPER_INTERFACE();
    return m_pInterface->Backup(lpszBackupLocation, dwMDVersion, dwMDFlags);
}

inline HRESULT CMetaInterface::Restore(    
    IN LPCTSTR lpszBackupLocation,
    IN DWORD dwMDVersion,
    IN DWORD dwMDFlags
    )
{
    ASSERT_PTR(m_pInterface);
	ASSURE_PROPER_INTERFACE();
    return m_pInterface->Restore(lpszBackupLocation, dwMDVersion, dwMDFlags);
}

inline HRESULT CMetaInterface::EnumBackups(
    OUT LPTSTR lpszBackupLocation,
    OUT DWORD * pdwMDVersion,
    OUT FILETIME * pftMDBackupTime,
    IN  DWORD dwIndex
    )
{
    ASSERT_PTR(m_pInterface);
	ASSURE_PROPER_INTERFACE();
    return m_pInterface->EnumBackups(
        lpszBackupLocation,
        pdwMDVersion,
        pftMDBackupTime,
        dwIndex
        );    
}

inline HRESULT CMetaInterface::DeleteBackup(
    IN LPCTSTR lpszBackupLocation,
    IN DWORD dwMDVersion
    )
{
    ASSERT_PTR(m_pInterface);
	ASSURE_PROPER_INTERFACE();
    return m_pInterface->DeleteBackup(lpszBackupLocation, dwMDVersion);
}        

inline HRESULT CMetaInterface::SaveData()
{
    ASSERT_PTR(m_pInterface);
	ASSURE_PROPER_INTERFACE();
    return m_pInterface->SaveData();
}

inline HRESULT CMetaInterface::GetSystemChangeNumber(
    OUT DWORD * pdwChangeNumber
    )
{
    ASSERT_PTR(m_pInterface);
	ASSURE_PROPER_INTERFACE();
    return m_pInterface->GetSystemChangeNumber(pdwChangeNumber);
}

inline HRESULT CMetaKey::AddKey(
    IN LPCTSTR lpszMDPath
    )
{
    return CMetaInterface::AddKey(m_hKey, lpszMDPath);    
}

inline HRESULT CMetaKey::DeleteKey(
    IN LPCTSTR lpszMDPath
    )
{
    return CMetaInterface::DeleteKey(m_hKey, lpszMDPath);    
}

inline HRESULT CMetaKey::RenameKey(
    IN LPCTSTR lpszMDPath,
    IN LPCTSTR lpszNewName
    )
{
    return CMetaInterface::RenameKey(m_hKey, lpszMDPath, lpszNewName);    
}

inline HRESULT CMetaKey::ReOpen()
{
    return Open(m_dwFlags, m_strMetaPath, m_hBase);
}

inline HRESULT CMetaKey::ReOpen(DWORD dwFlags)
{
    return Open(dwFlags, m_strMetaPath, m_hBase);
}

inline BOOL CMetaKey::IsHomeDirectoryPath() const
{ 
    return CMetabasePath::IsHomeDirectoryPath(m_strMetaPath); 
}

inline HRESULT CMetaKey::QueryValue(
    IN  DWORD dwID, 
    OUT BOOL & fValue,
    IN  BOOL * pfInheritanceOverride,
    IN  LPCTSTR lpszMDPath,
    OUT DWORD * pdwAttributes        
    )
{
    ASSERT(sizeof(DWORD) == sizeof(BOOL));
    return CMetaKey::QueryValue(
        dwID, 
        (DWORD &)fValue, 
        pfInheritanceOverride, 
        lpszMDPath,
        pdwAttributes
        );
}

inline HRESULT CMetaKey::SetValue(
    IN DWORD dwID,
    IN DWORD dwValue,
    IN BOOL * pfInheritanceOverride,    OPTIONAL
    IN LPCTSTR lpszMDPath               OPTIONAL
    )
{
    return SetPropertyValue(
        dwID, 
        sizeof(dwValue), 
        &dwValue, 
        pfInheritanceOverride,
        lpszMDPath
        );
}

inline HRESULT CMetaKey::SetValue(
    IN DWORD dwID,
    IN BOOL fValue,
    IN BOOL * pfInheritanceOverride,
    IN LPCTSTR lpszMDPath
    )
{
    ASSERT(sizeof(DWORD) == sizeof(BOOL));
    return CMetaKey::SetValue(
        dwID,
        (DWORD)fValue,
        pfInheritanceOverride,
        lpszMDPath
        );
}

inline HRESULT CMetaKey::SetValue(
    IN DWORD dwID,
    IN CString & strValue,
    IN BOOL * pfInheritanceOverride,    OPTIONAL
    IN LPCTSTR lpszMDPath               OPTIONAL
    )
{
    return SetPropertyValue(
        dwID,
        (strValue.GetLength() + 1) * sizeof(TCHAR),
        (void *)(LPCTSTR)strValue,
        pfInheritanceOverride,
        lpszMDPath
        );
}

inline HRESULT CWamInterface::AppDelete( 
    IN LPCTSTR szMDPath,
    IN BOOL fRecursive
    )
{
    ASSERT_PTR(m_pInterface);
	ASSURE_PROPER_INTERFACE();
    return m_pInterface->AppDelete(szMDPath, fRecursive);
}

inline HRESULT CWamInterface::AppUnLoad( 
    IN LPCTSTR szMDPath,
    IN BOOL fRecursive
    )
{
    ASSERT_PTR(m_pInterface);
	ASSURE_PROPER_INTERFACE();
    return m_pInterface->AppUnLoad(szMDPath, fRecursive);
}

inline HRESULT CWamInterface::AppGetStatus( 
    IN  LPCTSTR szMDPath,
    OUT DWORD * pdwAppStatus
    )
{
    ASSERT_PTR(m_pInterface);
	ASSURE_PROPER_INTERFACE();
    return m_pInterface->AppGetStatus(szMDPath, pdwAppStatus);
}

inline HRESULT CWamInterface::AppDeleteRecoverable( 
    IN LPCTSTR szMDPath,
    IN BOOL fRecursive
    )
{
    ASSERT_PTR(m_pInterface);
	ASSURE_PROPER_INTERFACE();
    return m_pInterface->AppDeleteRecoverable(szMDPath, fRecursive);
}

inline HRESULT CWamInterface::AppRecover( 
    IN LPCTSTR szMDPath,
    IN BOOL fRecursive
    )
{
    ASSERT_PTR(m_pInterface);
	ASSURE_PROPER_INTERFACE();
    return m_pInterface->AppRecover(szMDPath, fRecursive);
}

inline /* virtual */ HRESULT CWamInterface::ApplyProxyBlanket()
{
    return m_auth.ApplyProxyBlanket(m_pInterface);
}

////////////////////////////

inline /* virtual */ HRESULT CMetaBack::ApplyProxyBlanket()
{
    HRESULT hr = CMetaInterface::ApplyProxyBlanket();
    return SUCCEEDED(hr) ? CWamInterface::ApplyProxyBlanket() : hr;
}

inline HRESULT CMetaBack::Next(
    OUT DWORD * pdwVersion,
    OUT LPTSTR lpszLocation,
    OUT FILETIME * pftBackupTime
    )
{
    return EnumBackups(
        lpszLocation,
        pdwVersion,
        pftBackupTime,
        m_dwIndex++
        );
}

inline HRESULT CMetaBack::NextHistory(
    OUT DWORD * pdwMDMajorVersion,
    OUT DWORD * pdwMDMinorVersion,
    OUT LPTSTR lpszLocation,
    OUT FILETIME * pftBackupTime
    )
{
    return EnumHistory(
        lpszLocation,
        pdwMDMajorVersion,
        pdwMDMinorVersion,
        pftBackupTime,
        m_dwIndex++
        );
}

inline HRESULT CMetaBack::Backup(
    IN LPCTSTR lpszLocation
    )
{
    return CMetaInterface::Backup(
        lpszLocation, 
        MD_BACKUP_NEXT_VERSION, 
        MD_BACKUP_SAVE_FIRST
        );
}

inline HRESULT CMetaBack::Delete(
    IN LPCTSTR lpszLocation,
    IN DWORD dwVersion
    )
{
    return DeleteBackup(lpszLocation, dwVersion);
}

inline HRESULT CMetaBack::RestoreHistoryBackup(
        IN LPCTSTR pszMDHistoryLocation,
        IN DWORD dwMDMajorVersion,
        IN DWORD dwMDMinorVersion,
        IN DWORD dwMDFlags
    )
{
    return RestoreHistory(
        pszMDHistoryLocation,
        dwMDMajorVersion,
        dwMDMinorVersion,
        dwMDFlags
        );
}

inline BOOL CIISApplication::IsEnabledApplication() const
{
    return m_dwAppState == APPSTATUS_STOPPED 
        || m_dwAppState == APPSTATUS_RUNNING;
}

inline HRESULT CIISApplication::Delete(
    IN BOOL fRecursive
    )
{
    ASSERT(!m_strWamPath.IsEmpty());
    return AppDelete(m_strWamPath, fRecursive);
}

inline HRESULT CIISApplication::Unload(
    IN BOOL fRecursive
    )
{
    ASSERT(!m_strWamPath.IsEmpty());
    return AppUnLoad(m_strWamPath, fRecursive);
}

inline HRESULT CIISApplication::DeleteRecoverable(
    IN BOOL fRecursive
    )
{
    ASSERT(!m_strWamPath.IsEmpty());
    return AppDeleteRecoverable(m_strWamPath, fRecursive);
}

inline HRESULT CIISApplication::Recover(
    IN BOOL fRecursive
    )
{
    ASSERT(!m_strWamPath.IsEmpty());
    return AppRecover(m_strWamPath, fRecursive);
}

inline HRESULT CIISSvcControl::Create()
{
    return CIISInterface::Create(
        1,
        &IID_IIisServiceControl, 
        &CLSID_IisServiceControl, 
        NULL, 
        (IUnknown **)&m_pInterface
        );
}

inline HRESULT CIISSvcControl::Stop(
    IN DWORD dwTimeoutMsecs,
    IN BOOL fForce
    )
{
    ASSERT_PTR(m_pInterface);
	ASSURE_PROPER_INTERFACE();
    return m_pInterface->Stop(dwTimeoutMsecs, (DWORD)fForce);
}

inline HRESULT CIISSvcControl::Start(
    IN DWORD dwTimeoutMsecs
    )
{
    ASSERT_PTR(m_pInterface);
	ASSURE_PROPER_INTERFACE();
    return m_pInterface->Start(dwTimeoutMsecs);
}

inline HRESULT CIISSvcControl::Reboot(
    IN DWORD dwTimeouMsecs,
    IN BOOL fForceAppsClosed
    )
{
    ASSERT_PTR(m_pInterface);
	ASSURE_PROPER_INTERFACE();
    return m_pInterface->Reboot(dwTimeouMsecs, (DWORD)fForceAppsClosed);
}

inline HRESULT CIISSvcControl::Status(
    IN  DWORD dwBufferSize,
    OUT LPBYTE pbBuffer,
    OUT DWORD * MDRequiredBufferSize,
    OUT DWORD * pdwNumServices
    )
{
    ASSERT_PTR(m_pInterface);
	ASSURE_PROPER_INTERFACE();
    return m_pInterface->Status(
        dwBufferSize, 
        pbBuffer,
        MDRequiredBufferSize,
        pdwNumServices
        );
}

inline HRESULT CIISSvcControl::Kill()
{
    ASSERT_PTR(m_pInterface);
	ASSURE_PROPER_INTERFACE();
    return m_pInterface->Kill();
}

inline /* virtual */ HRESULT CIISSvcControl::ApplyProxyBlanket()
{
    return m_auth.ApplyProxyBlanket(m_pInterface);
}

#endif // _MDKEYS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\common\mdkeys.cpp ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        mdkeys.cpp

   Abstract:
        Metabase key wrapper class

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
#include "stdafx.h"
#include "common.h"
#include "idlg.h"
#include "mdkeys.h"
#include "iisdebug.h"
#include "SiteCreator.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW

extern HINSTANCE hDLLInstance;

//
// Constants
//
#define MB_TIMEOUT          (15000)     // Timeout in milliseconds
#define MB_INIT_BUFF_SIZE   (  256)     // Initial buffer size



//
// CComAuthInfo implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



/* static */
BOOL
CComAuthInfo::SplitUserNameAndDomain(
    IN OUT CString & strUserName,
    IN CString & strDomainName
    )
/*++

Routine Description:

    Split the user name and domain from the given
    username, which is in the format "domain\user".

    Return TRUE if the user name contained a domain
    FALSE if it did not

Arguments:

    CString & strUserName   : User name which may contain a domain name
    CString & strDomainName : Output domain name ("." if local)

Return Value:

    TRUE if a domain is split off

--*/
{
    //
    // Assume local
    //
    strDomainName = _T(".");
    int nSlash = strUserName.Find(_T("\\"));

    if (nSlash >= 0)
    {
        strDomainName = strUserName.Left(nSlash);
        strUserName = strUserName.Mid(nSlash + 1);

        return TRUE;
    }

    return FALSE;
}



/* static */
DWORD
CComAuthInfo::VerifyUserPassword(
    IN LPCTSTR lpstrUserName,
    IN LPCTSTR lpstrPassword
    )
/*++

Routine Description:

    Verify the usernamer password combo checks out

Arguments:

    LPCTSTR lpstrUserName   : Domain/username combo
    LPCTSTR lpstrPassword   : Password

Return Value:

    ERROR_SUCCESS if the password checks out, an error code
    otherwise.

--*/
{
    CString strDomain;
    CString strUser(lpstrUserName);
    CString strPassword(lpstrPassword);

    SplitUserNameAndDomain(strUser, strDomain);

    //
    // In order to look up an account name, this process
    // must first be granted the privilege of doing so.
    //
    CError err;
#if 0
    {
        HANDLE hToken;
        LUID AccountLookupValue;
        TOKEN_PRIVILEGES tkp;

        do
        {
			// sounds like it doesn't required for Whistler
            if (!::OpenProcessToken(GetCurrentProcess(),
                TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                &hToken)
                )
            {
                err.GetLastWinError();
                break;
            }

            if (!::LookupPrivilegeValue(NULL, SE_TCB_NAME, &AccountLookupValue))
            {
                err.GetLastWinError();
                break;
            }

            tkp.PrivilegeCount = 1;
            tkp.Privileges[0].Luid = AccountLookupValue;
            tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            ::AdjustTokenPrivileges(
                hToken,
                FALSE,
                &tkp,
                sizeof(TOKEN_PRIVILEGES),
                (PTOKEN_PRIVILEGES)NULL,
                (PDWORD)NULL
                );

            err.GetLastWinError();

            if (err.Failed())
            {
                break;
            }
            HANDLE hUser = NULL;

            if (::LogonUser(
                strUser.GetBuffer(0),
                strDomain.GetBuffer(0),
                strPassword.GetBuffer(0),
                LOGON32_LOGON_NETWORK,
                LOGON32_PROVIDER_DEFAULT,
                &hUser
                ))
            {
                //
                // Success!
                //
                CloseHandle(hUser);
            }
            else
            {
                err.GetLastWinError();
            }

            //
            // Remove the privilege
            //
        }
        while(FALSE);
    }
#endif

    HANDLE hUser = NULL;

    if (::LogonUser(
        strUser.GetBuffer(0),
        strDomain.GetBuffer(0),
        strPassword.GetBuffer(0),
        LOGON32_LOGON_NETWORK,
        LOGON32_PROVIDER_DEFAULT,
        &hUser))
    {
        //
        // Success!
        //
        CloseHandle(hUser);
    }
    else
    {
        err.GetLastWinError();
    }

    return err;
}



CComAuthInfo::CComAuthInfo(
    IN LPCOLESTR lpszServerName     OPTIONAL,
    IN LPCOLESTR lpszUserName       OPTIONAL,
    IN LPCOLESTR lpszPassword       OPTIONAL
    )
/*++

Routine Description:

    Construct CIIServer object

Argument:

    LPCOLESTR lpszServerName     : Server name or NULL for local computer
    LPCOLESTR lpszUserName       : User name of blank for no impersonation
    LPCOLESTR lpszPassword       : Password (might be blank or NULL)

Return Value:

    N/A

--*/
    : m_bstrServerName(),
      m_bstrUserName(lpszUserName),
      m_bstrPassword(lpszPassword),
      m_fLocal(FALSE)
{
    SetComputerName(lpszServerName);
}



CComAuthInfo::CComAuthInfo(
    IN CComAuthInfo & auth
    )
/*++

Routine Description:

    Copy constructor

Arguments:

    CComAuthInfo & auth    : Source object to copy from

Return Value:

    N/A

--*/
    : m_bstrServerName(auth.m_bstrServerName),
      m_bstrUserName(auth.m_bstrUserName),
      m_bstrPassword(auth.m_bstrPassword),
      m_fLocal(auth.m_fLocal)
{
}



CComAuthInfo::CComAuthInfo(
    IN CComAuthInfo * pAuthInfo        OPTIONAL
    )
/*++

Routine Description:

    Copy constructor

Arguments:

    CComAuthInfo * pAuthInfo    : Source object to copy from (or NULL)

Return Value:

    N/A

--*/
    : m_bstrServerName(),
      m_bstrUserName(),
      m_bstrPassword(),
      m_fLocal(FALSE)
{
    if (pAuthInfo)
    {
        //
        // Full authentication information available
        //
        m_bstrUserName = pAuthInfo->m_bstrUserName;
        m_bstrPassword = pAuthInfo->m_bstrPassword;
        m_bstrServerName = pAuthInfo->m_bstrServerName;
        m_fLocal = pAuthInfo->m_fLocal;
    }
    else
    {
        //
        // Local computer w/o impersonation
        //
        SetComputerName(NULL);
    }
}



CComAuthInfo &
CComAuthInfo::operator =(
    IN CComAuthInfo & auth
    )
/*++

Routine Description:

    Assignment operator

Arguments:

    CComAuthInfo & auth     : Source object to copy from

Return Value:

    Reference to current object

--*/
{
    m_bstrServerName = auth.m_bstrServerName;
    m_bstrUserName   = auth.m_bstrUserName;
    m_bstrPassword   = auth.m_bstrPassword;
    m_fLocal         = auth.m_fLocal;

    return *this;
}



CComAuthInfo &
CComAuthInfo::operator =(
    IN CComAuthInfo * pAuthInfo       OPTIONAL
    )
/*++

Routine Description:

    Assignment operator

Arguments:

    CComAuthInfo * pAuthInfo : Source object to copy from (or NULL)

Return Value:

    Reference to current object

--*/
{
    if (pAuthInfo)
    {
        m_bstrUserName = pAuthInfo->m_bstrUserName;
        m_bstrPassword = pAuthInfo->m_bstrPassword;
        SetComputerName(pAuthInfo->m_bstrServerName);
    }
    else
    {
        //
        // Local computer w/o impersonation
        //
        m_bstrUserName.Empty();
        m_bstrPassword.Empty();
        SetComputerName(NULL);
    }

    return *this;
}




CComAuthInfo &
CComAuthInfo::operator =(
    IN LPCTSTR lpszServerName
    )
/*++

Routine Description:

    Assignment operator.  Assign computer name w/o impersonation

Arguments:

    LPCTSTR lpszServerName      : Source server name

Return Value:

    Reference to current object

--*/
{
    RemoveImpersonation();
    SetComputerName(lpszServerName);

    return *this;
}



void
CComAuthInfo::SetComputerName(
    IN LPCOLESTR lpszServerName   OPTIONAL
    )
/*++

Routine Description:

    Store the computer name.  Determine if its local.

Arguments:

    LPCOLESTR lpszServername  : Server name.  NULL indicates the local computer

Return Value:

    None

--*/
{
    if (lpszServerName && *lpszServerName)
    {
        //
        // Specific computer name specified
        //
        m_bstrServerName = lpszServerName;
        m_fLocal = ::IsServerLocal(lpszServerName);
    }
    else
    {
        //
        // Use local computer name
        //
        // CODEWORK: Cache static version of computername maybe?
        //
        TCHAR szLocalServer[MAX_PATH + 1];
        DWORD dwSize = MAX_PATH;

        VERIFY(::GetComputerName(szLocalServer, &dwSize));
        m_bstrServerName = szLocalServer;
        m_fLocal = TRUE;
    }
}



void
CComAuthInfo::SetImpersonation(
    IN LPCOLESTR lpszUser,
    IN LPCOLESTR lpszPassword
    )
/*++

Routine Description:

    Set impersonation parameters

Arguments:

    LPCOLESTR lpszUser          : User name
    LPCOLESTR lpszPassword      : Password

Return Value:

    None

--*/
{
    m_bstrUserName = lpszUser;
    StorePassword(lpszPassword);
}



void
CComAuthInfo::RemoveImpersonation()
/*++

Routine Description:

    Remove impersonation parameters

Arguments:

    None

Return Value:

    None

--*/
{
    m_bstrUserName.Empty();
    m_bstrPassword.Empty();
}


COSERVERINFO *
CComAuthInfo::CreateServerInfoStruct() const
{
    return (CComAuthInfo::CreateServerInfoStruct(RPC_C_AUTHN_LEVEL_DEFAULT));
}



COSERVERINFO *
CComAuthInfo::CreateServerInfoStruct(DWORD dwAuthnLevel) const
/*++

Routine Description:

    Create the server info structure.  Might return NULL for the no frills case.

Arguments:

    NULL

Return Value:

    A COSERVERINFO structure, or NULL if the computer is local, and no
    impersonation is required.

Notes:

    Caller must call FreeServerInfoStruct() to prevent memory leaks

--*/
{
    //
    // Be smart about the server name; optimize for local
    // computer name.
    //
    if (m_fLocal && !UsesImpersonation())
    {
        //
        // Special, no-frills case.
        //
        return NULL;
    }

    //
    // Create the COM server info for CoCreateInstanceEx
    //
    COSERVERINFO * pcsiName = NULL;

    do
    {
        pcsiName = (COSERVERINFO *)AllocMem(sizeof(COSERVERINFO));

        if (!pcsiName)
        {
            break;
        }

        pcsiName->pwszName = m_bstrServerName;

        //
        // Set impersonation
        //
        if (UsesImpersonation())
        {
            COAUTHINFO * pAuthInfo = (COAUTHINFO *)AllocMem(sizeof(COAUTHINFO));

            if (!pAuthInfo)
            {
                break;
            }

            COAUTHIDENTITY * pAuthIdentityData =
                (COAUTHIDENTITY *)AllocMem(sizeof(COAUTHIDENTITY));

            if (!pAuthIdentityData)
            {
                break;
            }

            CString strUserName(m_bstrUserName);
            CString strPassword(m_bstrPassword);
            CString strDomain;

            //
            // Break up domain\username combo
            //
            SplitUserNameAndDomain(strUserName, strDomain);

            pAuthIdentityData->UserLength = strUserName.GetLength();

            if (pAuthIdentityData->UserLength)
            {
                pAuthIdentityData->User = AllocString(
                    strUserName,
                    strUserName.GetLength()
                    );
            }

            pAuthIdentityData->DomainLength = strDomain.GetLength();

            if (pAuthIdentityData->DomainLength)
            {
                pAuthIdentityData->Domain = AllocString(
                    strDomain,
                    strDomain.GetLength()
                    );
            }

            pAuthIdentityData->PasswordLength = strPassword.GetLength();

            if (pAuthIdentityData->PasswordLength)
            {
                pAuthIdentityData->Password = AllocString(
                    strPassword,
                    strPassword.GetLength()
                    );
            }

            // RPC_C_AUTHN_LEVEL_DEFAULT       0
            // RPC_C_AUTHN_LEVEL_NONE          1
            // RPC_C_AUTHN_LEVEL_CONNECT       2
            // RPC_C_AUTHN_LEVEL_CALL          3
            // RPC_C_AUTHN_LEVEL_PKT           4
            // RPC_C_AUTHN_LEVEL_PKT_INTEGRITY 5
            // RPC_C_AUTHN_LEVEL_PKT_PRIVACY   6
            if (RPC_C_AUTHN_LEVEL_DEFAULT != dwAuthnLevel)
            {
                // you can only specify stuff stronger than RPC_C_AUTHN_LEVEL_CONNECT
                if (dwAuthnLevel >= RPC_C_AUTHN_LEVEL_CONNECT && dwAuthnLevel <= RPC_C_AUTHN_LEVEL_PKT_PRIVACY)
                {
                    pAuthInfo->dwAuthnLevel = dwAuthnLevel;
                }
                else
                {
                    pAuthInfo->dwAuthnLevel = RPC_C_AUTHN_LEVEL_CONNECT;
                }
            }
            else
            {
                pAuthInfo->dwAuthnLevel = RPC_C_AUTHN_LEVEL_DEFAULT;
            }
            pAuthIdentityData->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
            pAuthInfo->dwImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE;
            pAuthInfo->dwAuthnSvc = RPC_C_AUTHN_WINNT;
            pAuthInfo->dwAuthzSvc = RPC_C_AUTHZ_NONE;
            pAuthInfo->pwszServerPrincName = NULL;
            pAuthInfo->dwCapabilities = EOAC_NONE;
  