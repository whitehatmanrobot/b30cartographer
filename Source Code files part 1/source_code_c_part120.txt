 //
        // Create the entry itself
        //
        pSpecialEntry = ExAllocatePoolWithTag(
                            PagedPool,
                            sizeof(DFS_SPECIAL_ENTRY),
                            ' puM');
        if (pSpecialEntry == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            DfsDbgTrace( 0, Dbg, "Unable to allocate SpecialEntry\n", 0);
            DfsDbgTrace(-1, Dbg, "PktCreateSpecialEntryTableFromReferral: Exit -> %08lx\n", ULongToPtr(Status) );
            return (Status);
        }
        //
        // Mundate initialization
        //
        RtlZeroMemory(pSpecialEntry, sizeof(DFS_SPECIAL_ENTRY));
        pSpecialEntry->NodeTypeCode = DSFS_NTC_SPECIAL_ENTRY;
        pSpecialEntry->NodeByteSize = sizeof(DFS_SPECIAL_ENTRY);
        pSpecialEntry->USN = 1;
        pSpecialEntry->UseCount = 0;
        pSpecialEntry->ExpandedCount = 0;
        pSpecialEntry->Active = 0;
        pSpecialEntry->ExpandedNames = NULL;
        pSpecialEntry->NeedsExpansion = TRUE;
        pSpecialEntry->Stale = FALSE;
        //
        // Set gotdcreferral to false. This gets set to true only when
        // we have already been asked (via an fsctl) to get the
        // trusted domainlist for the domain represented by this special entry
        //
        pSpecialEntry->GotDCReferral = FALSE;

        //
        // Fill in the Special Name, without the leading '\'
        //
        wzSpecialName = (PWCHAR) (((PCHAR) v3) + v3->SpecialNameOffset);
        if (*wzSpecialName == UNICODE_PATH_SEP) {
            wzSpecialName++;
        }
        ustrSpecialName = &pSpecialEntry->SpecialName;
        ustrSpecialName->Length = wcslen(wzSpecialName) * sizeof(WCHAR);
        ustrSpecialName->MaximumLength = ustrSpecialName->Length + sizeof(WCHAR);
        ustrSpecialName->Buffer = ExAllocatePoolWithTag(
                                        PagedPool,
                                        ustrSpecialName->MaximumLength,
                                        ' puM');
        if (ustrSpecialName->Buffer == NULL) {
            ExFreePool(pSpecialEntry);
            Status = STATUS_INSUFFICIENT_RESOURCES;
            DfsDbgTrace( 0, Dbg, "Unable to allocate SpecialName\n", 0);
            DfsDbgTrace(-1, Dbg, "PktCreateSpecialEntryTableFromReferral: Exit -> %08lx\n", ULongToPtr(Status) );
            return (Status);
        }
        RtlCopyMemory(
                ustrSpecialName->Buffer,
                wzSpecialName,
                ustrSpecialName->MaximumLength);
	
        // If the DCName is non-null, copy it into the special entry.
        // We store null dcname for all the special entries that get to use  
        // the global pkt->dcname.

        if (DCName != NULL) {
            pSpecialEntry->DCName.Buffer = ExAllocatePoolWithTag(
                                                 PagedPool,
                                                 DCName->MaximumLength,
                                                 ' puM');
            if (pSpecialEntry->DCName.Buffer == NULL) {
	        ExFreePool(pSpecialEntry->SpecialName.Buffer);
                ExFreePool(pSpecialEntry);
                Status = STATUS_INSUFFICIENT_RESOURCES;
                DfsDbgTrace( 0, Dbg, "Unable to allocate DCName\n", 0);
                DfsDbgTrace(-1, Dbg, "PktCreateSpecialEntryTableFromReferral: Exit -> %08lx\n", ULongToPtr(Status) );
                return (Status);
            }
            pSpecialEntry->DCName.MaximumLength = DCName->MaximumLength;
            RtlCopyUnicodeString(&pSpecialEntry->DCName, DCName);
        }
	
        //
        // Clip the UNICODE_NULL off the end
        //
        if (ustrSpecialName->Buffer[(ustrSpecialName->Length/sizeof(WCHAR))-1] == UNICODE_NULL) {
            ustrSpecialName->Length -= sizeof(WCHAR);
        }

        DfsDbgTrace( 0, Dbg, "SpecialName %wZ\n", ustrSpecialName);

        TimeToLive = v3->TimeToLive;

        if (v3->NumberOfExpandedNames > 0) {
            pExpandedNames = ExAllocatePoolWithTag(
                                PagedPool,
                                sizeof(DFS_EXPANDED_NAME) * v3->NumberOfExpandedNames,
                                ' puM');
            if (pExpandedNames == NULL) {
                DfsDbgTrace( 0, Dbg, "Unable to allocate ExpandedNames\n", 0);
                DfsDbgTrace(-1, Dbg, "PktCreateSpecialEntryTableFromReferral: Exit -> %08lx\n",
                    ULongToPtr(Status) );
            }
            if (pExpandedNames != NULL) {
                RtlZeroMemory(
                    pExpandedNames,
                    sizeof(DFS_EXPANDED_NAME) * v3->NumberOfExpandedNames);
                //
                // Loop over the referral, filling in the expanded names
                // If we fail an allocate request, we simply go on.
                //
                wzExpandedName = (LPWSTR) (( (PCHAR) v3) + v3->ExpandedNameOffset);
                for (i = j = 0; i < v3->NumberOfExpandedNames; i++) {
                    //
                    // Strip leading '\'
                    //
                    if (*wzExpandedName == UNICODE_PATH_SEP)
                        wzExpandedName++;

                    DfsDbgTrace( 0, Dbg, "..expands to %ws\n", wzExpandedName);

                    ustrExpandedName = &pExpandedNames[j].ExpandedName;
                    if (wcslen(wzExpandedName) > 0) {
                        ustrExpandedName->Length = wcslen(wzExpandedName) * sizeof(WCHAR);
                        ustrExpandedName->MaximumLength = ustrExpandedName->Length + sizeof(WCHAR);
                        ustrExpandedName->Buffer = ExAllocatePoolWithTag(
                                                        PagedPool,
                                                        ustrExpandedName->MaximumLength,
                                                        ' puM');
                        if (ustrExpandedName->Buffer != NULL) {
                            RtlCopyMemory(
                                ustrExpandedName->Buffer,
                                wzExpandedName,
                                ustrExpandedName->MaximumLength);
                            j++;
                        } else {
                            ustrExpandedName->Length = ustrExpandedName->MaximumLength = 0;
                        }
                    }
                    wzExpandedName += wcslen(wzExpandedName) + 1;
                }

                if (j > 0) {
                    pSpecialEntry->ExpandedCount = j;
                    pSpecialEntry->Active = 0;
                    pSpecialEntry->ExpandedNames = pExpandedNames;
                    pSpecialEntry->NeedsExpansion = FALSE;
                    pSpecialEntry->Stale = FALSE;
                    // PktShuffleSpecialEntryList(pSpecialEntry);
                    PktSetSpecialEntryListToDc(pSpecialEntry);
                } else {
                    ExFreePool(pExpandedNames);
                }
            }
        }
        //
        // If we got a referral with a TimeToLive, use the TimeToLive we got
        //
        if (TimeToLive != 0) {
            Pkt->SpecialTable.TimeToLive = TimeToLive;
        }
        //
        // Put it in the pkt!!
        //
        PktCreateSpecialNameEntry(pSpecialEntry);

        v3 = (PDFS_REFERRAL_V3) (((PUCHAR) v3) + v3->Size);
    }

    DfsDbgTrace(-1, Dbg, "PktCreateSpecialEntryTableFromReferral: Exit -> %08lx\n", ULongToPtr(Status) );

    return Status;
}

//+----------------------------------------------------------------------------
//
//  Function:   PktpCheckReferralSyntax
//
//  Synopsis:   Does some validation of a Referral
//
//  Arguments:  [ReferralPath] -- The Path for which a referral was obtained
//              [ReferralBuffer] -- Pointer to RESP_GET_DFS_REFERRAL Buffer
//              [ReferralSize] -- Size of ReferralBuffer
//
//  Returns:    [STATUS_SUCCESS] -- Referral looks ok.
//
//              [STATUS_INVALID_USER_BUFFER] -- Buffer looks hoky.
//
//-----------------------------------------------------------------------------

NTSTATUS
PktpCheckReferralSyntax(
    IN PUNICODE_STRING ReferralPath,
    IN PRESP_GET_DFS_REFERRAL ReferralBuffer,
    IN DWORD ReferralSize)
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG Index, sizeRemaining;
    PDFS_REFERRAL_V1 ref;
    PCHAR ReferralBufferEnd = (((PCHAR) ReferralBuffer) + ReferralSize);

    DfsDbgTrace(+1, Dbg, "PktpCheckReferralSyntax: Entered\n", 0);

    if (ReferralBuffer->PathConsumed > ReferralPath->Length) {
        DfsDbgTrace( 0, Dbg, "        PathConsumed=0x%x\n", ReferralBuffer->PathConsumed);
        DfsDbgTrace( 0, Dbg, "        Length=0x%x\n", ReferralPath->Length);
        DfsDbgTrace(-1, Dbg, "PktpCheckReferralSyntax: INVALID_USER_BUFFER(1)\n", 0);
        // return( STATUS_INVALID_USER_BUFFER );
    }

    if (ReferralBuffer->NumberOfReferrals == 0) {
        status = STATUS_INVALID_USER_BUFFER;
        DfsDbgTrace(-1, Dbg, "PktpCheckReferralSyntax: INVALID_USER_BUFFER(2)\n", 0);
        MUP_TRACE_HIGH(ERROR, PktpCheckReferralSyntax_Error_InvalidBuffer2,
                       LOGSTATUS(status)
                       LOGUSTR(*ReferralPath));
        return( status );
    }

    if (ReferralBuffer->NumberOfReferrals * sizeof(DFS_REFERRAL_V1) > ReferralSize) {
        DfsDbgTrace(-1, Dbg, "PktpCheckReferralSyntax: INVALID_USER_BUFFER(3)\n", 0);
        status = STATUS_INVALID_USER_BUFFER;
        MUP_TRACE_HIGH(ERROR, PktpCheckReferralSyntax_Error_InvalidBuffer3,
                       LOGSTATUS(status)
                       LOGUSTR(*ReferralPath));
        return( status );
    }

    for (Index = 0,
            ref = &ReferralBuffer->Referrals[0].v1,
                status = STATUS_SUCCESS,
                    sizeRemaining = ReferralSize -
                        FIELD_OFFSET(RESP_GET_DFS_REFERRAL, Referrals);
                            Index < ReferralBuffer->NumberOfReferrals;
                                    Index++) {

         ULONG lenAddress;

         if ((ref->VersionNumber < 1 || ref->VersionNumber > 3) ||
                ref->Size > sizeRemaining) {
             DfsDbgTrace( 0, Dbg, "PktpCheckReferralSyntax: INVALID_USER_BUFFER(4)\n", 0);
             status = STATUS_INVALID_USER_BUFFER;
             MUP_TRACE_HIGH(ERROR, PktpCheckReferralSyntax_Error_InvalidBuffer4,
                            LOGSTATUS(status)
                            LOGUSTR(*ReferralPath));
             break;
         }

         //
         // Check the network address syntax
         //

         switch (ref->VersionNumber) {

         case 1:

             {

                 status = PktpCheckReferralString(
                            (LPWSTR) ref->ShareName,
                            (PCHAR) ReferralBuffer,
                            ReferralBufferEnd);

                 if (NT_SUCCESS(status)) {

                     lenAddress = ref->Size -
                                    FIELD_OFFSET(DFS_REFERRAL_V1, ShareName);

                     lenAddress /= sizeof(WCHAR);

                     status = PktpCheckReferralNetworkAddress(
                                (LPWSTR) ref->ShareName,
                                lenAddress);
                 }

             }

             break;

         case 2:

             {

                 PDFS_REFERRAL_V2 refV2 = (PDFS_REFERRAL_V2) ref;
                 PWCHAR dfsPath, dfsAlternatePath, networkAddress;

                 dfsPath =
                    (PWCHAR) (((PCHAR) refV2) + refV2->DfsPathOffset);

                 dfsAlternatePath =
                    (PWCHAR) (((PCHAR) refV2) + refV2->DfsAlternatePathOffset);


                 networkAddress =
                    (PWCHAR) (((PCHAR) refV2) + refV2->NetworkAddressOffset);

                 status = PktpCheckReferralString(
                            dfsPath,
                            (PCHAR) ReferralBuffer,
                            ReferralBufferEnd);

                 if (NT_SUCCESS(status)) {

                     status = PktpCheckReferralString(
                                dfsAlternatePath,
                                (PCHAR) ReferralBuffer,
                                ReferralBufferEnd);

                 }

                 if (NT_SUCCESS(status)) {

                     status = PktpCheckReferralString(
                                networkAddress,
                                (PCHAR) ReferralBuffer,
                                ReferralBufferEnd);

                 }

                 if (NT_SUCCESS(status)) {

                     lenAddress = (ULONG)(((ULONG_PTR) ReferralBufferEnd) -
                                    ((ULONG_PTR) networkAddress));

                     lenAddress /= sizeof(WCHAR);

                     status = PktpCheckReferralNetworkAddress(
                                networkAddress,
                                lenAddress);

                 }

             }

             break;

         case 3:

             {

                 PDFS_REFERRAL_V3 refV3 = (PDFS_REFERRAL_V3) ref;

                 if (refV3->NameListReferral != 0) {
                     PWCHAR dfsSpecialName, dfsExpandedNames;
                     ULONG ndx;

                     dfsSpecialName =
                        (PWCHAR) (((PCHAR) refV3) + refV3->SpecialNameOffset);

                     dfsExpandedNames =
                        (PWCHAR) (((PCHAR) refV3) + refV3->ExpandedNameOffset);

                     status = PktpCheckReferralString(
                                dfsSpecialName,
                                (PCHAR) ReferralBuffer,
                                ReferralBufferEnd);

                     if (!NT_SUCCESS(status)) {
                                DfsDbgTrace(0,
                                    Dbg,
                                    "PktpCheckReferralSyntax: INVALID_USER_BUFFER(5)\n",
                                    0);
                     }

                     if (NT_SUCCESS(status)) {

                         for (ndx = 0; ndx < refV3->NumberOfExpandedNames; ndx++) {

                             status = PktpCheckReferralString(
                                        dfsSpecialName,
                                        (PCHAR) ReferralBuffer,
                                        ReferralBufferEnd);

                             if (!NT_SUCCESS(status)) {
                                DfsDbgTrace(0,
                                    Dbg,
                                    "PktpCheckReferralSyntax: INVALID_USER_BUFFER(6)\n",
                                    0);
                                break;
                             }

                             dfsSpecialName += wcslen(dfsSpecialName) + 1;

                         }

                     }

                 } else {

                     PWCHAR dfsPath, dfsAlternatePath, networkAddress;

                     dfsPath =
                        (PWCHAR) (((PCHAR) refV3) + refV3->DfsPathOffset);

                     dfsAlternatePath =
                        (PWCHAR) (((PCHAR) refV3) + refV3->DfsAlternatePathOffset);


                     networkAddress =
                        (PWCHAR) (((PCHAR) refV3) + refV3->NetworkAddressOffset);

                     status = PktpCheckReferralString(
                                dfsPath,
                                (PCHAR) ReferralBuffer,
                                ReferralBufferEnd);

                     if (NT_SUCCESS(status)) {

                         status = PktpCheckReferralString(
                                    dfsAlternatePath,
                                    (PCHAR) ReferralBuffer,
                                    ReferralBufferEnd);

                     }

                     if (NT_SUCCESS(status)) {

                         status = PktpCheckReferralString(
                                    networkAddress,
                                    (PCHAR) ReferralBuffer,
                                    ReferralBufferEnd);

                     }

                     if (NT_SUCCESS(status)) {

                         lenAddress = (ULONG)(((ULONG_PTR) ReferralBufferEnd) -
                                        ((ULONG_PTR) networkAddress));

                         lenAddress /= sizeof(WCHAR);

                         status = PktpCheckReferralNetworkAddress(
                                    networkAddress,
                                    lenAddress);

                     }

                 }

             }

             break;

         default:

            ASSERT(FALSE && "bad ref->VersionNumber\n");

            status = STATUS_INVALID_USER_BUFFER;

            break;
         }

         //
         // This ref is ok. Go on to the next one...
         //

         sizeRemaining -= ref->Size;

         ref = (PDFS_REFERRAL_V1) (((PUCHAR) ref) + ref->Size);

    }

    DfsDbgTrace(-1, Dbg, "PktpCheckReferralSyntax: Exit -> %08lx\n", ULongToPtr(status) );

    return( status );

}

//+----------------------------------------------------------------------------
//
//  Function:   PktpCheckReferralString
//
//  Synopsis:   Validates part of a Referral as being a valid "string"
//
//  Arguments:  [String] -- Pointer to buffer thought to contain string.
//              [ReferralBuffer] -- Start of Referral Buffer
//              [ReferralBufferEnd] -- End of Referral Buffer
//
//  Returns:    [STATUS_SUCCESS] -- Valid string at String.
//
//              [STATUS_INVALID_USER_BUFFER] -- String doesn't check out.
//
//-----------------------------------------------------------------------------

NTSTATUS
PktpCheckReferralString(
    IN LPWSTR String,
    IN PCHAR ReferralBuffer,
    IN PCHAR ReferralBufferEnd)
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG i, length;

    if ( (((ULONG_PTR) String) & 0x1) != 0 ) {

        //
        // Strings should always start at word aligned addresses!
        //
        status = STATUS_INVALID_USER_BUFFER;
        MUP_TRACE_HIGH(ERROR, PktpCheckReferralString_Error_StringNotWordAlligned,
                       LOGSTATUS(status)
                       LOGWSTR(String));
        return( status );

    }

    if ( (((ULONG_PTR) String) >= ((ULONG_PTR) ReferralBuffer)) &&
            (((ULONG_PTR) String) < ((ULONG_PTR) ReferralBufferEnd)) ) {

        length = (ULONG)(( ((ULONG_PTR) ReferralBufferEnd) - ((ULONG_PTR) String) )) /
                    sizeof(WCHAR);

        for (i = 0; (i < length) && (String[i] != UNICODE_NULL); i++) {
            NOTHING;
        }

        if (i >= length)
            status = STATUS_INVALID_USER_BUFFER;

    } else {

        status = STATUS_INVALID_USER_BUFFER;

    }
    MUP_TRACE_ERROR_HIGH(status, ALL_ERROR, PktpCheckReferralString_Error,
                         LOGWSTR(String)
                         LOGSTATUS(status));
    return( status );
}

//+----------------------------------------------------------------------------
//
//  Function:   PktpCheckReferralNetworkAddress
//
//  Synopsis:   Checks to see if a NetworkAddress inside a referral
//              is of a valid form
//
//  Arguments:  [Address] -- Pointer to buffer containing network addresss
//
//              [MaxLength] -- Maximum length, in wchars, that Address can be.
//
//  Returns:    [STATUS_SUCCESS] -- Network address checks out
//
//              [STATUS_INVALID_USER_BUFFER] -- Network address looks bogus
//
//-----------------------------------------------------------------------------

NTSTATUS
PktpCheckReferralNetworkAddress(
    IN PWCHAR Address,
    IN ULONG MaxLength)
{
    ULONG j;
    BOOLEAN foundShare;
    NTSTATUS status;

    //
    // Address must be atleast \a\b followed by a NULL
    //

    if (MaxLength < 5) {
        status = STATUS_INVALID_USER_BUFFER;
        MUP_TRACE_HIGH(ERROR, PktpCheckReferralNetworkAddress_Error_TooShortToBeValid,
                       LOGWSTR(Address)
                       LOGSTATUS(status));
        return(STATUS_INVALID_USER_BUFFER);
    }
    //
    // Make sure the server name part is not NULL
    //

    if (Address[0] != UNICODE_PATH_SEP ||
            Address[1] == UNICODE_PATH_SEP) {
        status = STATUS_INVALID_USER_BUFFER;
        MUP_TRACE_HIGH(ERROR, PktpCheckReferralNetworkAddress_Error_NullServerName,
                       LOGWSTR(Address)
                       LOGSTATUS(status));
        return(STATUS_INVALID_USER_BUFFER);
    }

    //
    // Find the backslash after the server name
    //

    for (j = 2, foundShare = FALSE;
            j < MaxLength && !foundShare;
                j++) {

        if (Address[j] == UNICODE_PATH_SEP)
            foundShare = TRUE;
    }

    if (foundShare) {

        //
        // We found the second backslash. Make sure the share name
        // part is not 0 length.
        //

        if (j == MaxLength) {
            status = STATUS_INVALID_USER_BUFFER;
            MUP_TRACE_HIGH(ERROR, PktpCheckReferralNetworkAddress_Error_ZeroLengthShareName,
                           LOGWSTR(Address)
                           LOGSTATUS(status));
            return(status);
        }
        else {

            ASSERT(Address[j-1] == UNICODE_PATH_SEP);

            if (Address[j] == UNICODE_PATH_SEP ||
                    Address[j] == UNICODE_NULL) {
                status = STATUS_INVALID_USER_BUFFER;
                MUP_TRACE_HIGH(ERROR, PktpCheckReferralNetworkAddress_Error_ShareNameZeroLength,
                               LOGWSTR(Address)
                               LOGSTATUS(status));
                return(status);
            }
        }

    } else {
        status = STATUS_INVALID_USER_BUFFER;
        MUP_TRACE_HIGH(ERROR, PktpCheckReferralNetworkAddress_Error_ShareNameNotFound,
                       LOGWSTR(Address)
                       LOGSTATUS(status));
        return(status);
    }

    return( STATUS_SUCCESS );

}

//+--------------------------------------------------------------------
//
// Function:    PktpAddEntry
//
// Synopsis:    This function is called to create an entry which was obtained
//              in the form of a referral from a DC. This method should only
//              be called for adding entries which were obtained through
//              referrals. It sets an expire time on all these entries.
//
// Arguments:   [Pkt] --
//              [EntryId] --
//              [ReferralBuffer] --
//              [CreateDisposition] --
//              [ppPktEntry] --
//
// Returns:     NTSTATUS
//
//---------------------------------------------------------------------

NTSTATUS
PktpAddEntry (
    IN PDFS_PKT Pkt,
    IN PDFS_PKT_ENTRY_ID EntryId,
    IN PRESP_GET_DFS_REFERRAL ReferralBuffer,
    IN ULONG CreateDisposition,
    IN PDFS_TARGET_INFO pDfsTargetInfo,
    OUT PDFS_PKT_ENTRY  *ppPktEntry
)
{
    NTSTATUS                    status;
    DFS_PKT_ENTRY_INFO          pktEntryInfo;
    ULONG                       Type = 0;
    ULONG                       n;
    PDFS_SERVICE                service;
    PDFS_REFERRAL_V1            ref;
    LPWSTR                      shareName;
    PDS_MACHINE                 pMachine;
    ULONG                       TimeToLive = 0;
    BOOLEAN                     ShuffleList = TRUE;
    UNICODE_STRING              ServerName;
    ULONG                       i;
    BOOLEAN DomainDfsService = FALSE;

    DfsDbgTrace(+1, Dbg, "PktpAddEntry: Entered\n", 0);

    RtlZeroMemory(&pktEntryInfo, sizeof(DFS_PKT_ENTRY_INFO));

    DfsDbgTrace( 0, Dbg, "PktpAddEntry: Id.Prefix = %wZ\n", &EntryId->Prefix);

    //
    // Now we go about the business of creating the entry Info structure.
    //

    pktEntryInfo.ServiceCount = ReferralBuffer->NumberOfReferrals;

    if (pktEntryInfo.ServiceCount > 0) {

        //
        // Allocate the service list.
        //

        n = pktEntryInfo.ServiceCount;

        pktEntryInfo.ServiceList = (PDFS_SERVICE) ExAllocatePoolWithTag(
                                                        PagedPool,
                                                        sizeof(DFS_SERVICE) * n,
                                                        ' puM');

        if (pktEntryInfo.ServiceList == NULL)   {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;

        }

        RtlZeroMemory(pktEntryInfo.ServiceList, sizeof(DFS_SERVICE) * n);

        //
        // initialize temporary pointers
        //
        service = pktEntryInfo.ServiceList;
        ref = &ReferralBuffer->Referrals[0].v1;

        //
        // Cycle through the list of referrals initializing
        // service structures on the way.
        //
        while (n--) {

            if (ref->ServerType == 1) {
                service->Type = DFS_SERVICE_TYPE_MASTER;
                service->Capability = PROV_DFS_RDR;
                service->ProviderId = PROV_ID_DFS_RDR;
            } else {
                service->Type = DFS_SERVICE_TYPE_MASTER |
                                    DFS_SERVICE_TYPE_DOWN_LEVEL;
                service->Capability = PROV_STRIP_PREFIX;
                service->ProviderId = PROV_ID_MUP_RDR;
            }

            switch (ref->VersionNumber) {

            case 1:

                shareName = (LPWSTR) (ref->ShareName); break;

            case 2:

                {

                    PDFS_REFERRAL_V2 refV2 = (PDFS_REFERRAL_V2) ref;

                    service->Cost = refV2->Proximity;

                    TimeToLive = refV2->TimeToLive;

                    shareName =
                        (LPWSTR) (((PCHAR) refV2) + refV2->NetworkAddressOffset);

                }

                break;

            case 3:

                {

                    PDFS_REFERRAL_V3 refV3 = (PDFS_REFERRAL_V3) ref;

                    service->Cost = 0;

                    TimeToLive = refV3->TimeToLive;

                    shareName =
                        (LPWSTR) (((PCHAR) refV3) + refV3->NetworkAddressOffset);

                    //
                    // Don't shuffle v3 referral list - it's ordered for us
                    // using site information
                    //

                    ShuffleList = FALSE;

                }

                break;

            default:

                ASSERT(FALSE && "Bad ref->VersionNumber\n");

                break;

            }

            //
            // Now try and figure out the server name
            //

            {
                USHORT plen;
                WCHAR *pbuf;

                ASSERT( shareName[0] == UNICODE_PATH_SEP );

                pbuf = wcschr( &shareName[1], UNICODE_PATH_SEP );
                
                if(pbuf) {
                    plen = (USHORT) (((ULONG_PTR)pbuf) - ((ULONG_PTR)&shareName[1]));
                } else {
                    plen = 0;
                }
                
                service->Name.Length = plen;
                service->Name.MaximumLength = plen + sizeof(WCHAR);
                service->Name.Buffer = (PWCHAR) ExAllocatePoolWithTag(
                                                    PagedPool,
                                                    plen + sizeof(WCHAR),
                                                    ' puM');
                if (service->Name.Buffer == NULL)       {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Cleanup;
                }
                RtlMoveMemory(service->Name.Buffer, &shareName[1], plen);
                service->Name.Buffer[ service->Name.Length / sizeof(WCHAR) ] =
                    UNICODE_NULL;

                if ((DomainDfsService != TRUE) &&
                    PktLookupSpecialNameEntry(&service->Name) != NULL)
                {
                    DomainDfsService = TRUE;
                }
            }

            //
            // Next, try and copy the address...
            //

            service->Address.Length = (USHORT) wcslen(shareName) *
                                                sizeof(WCHAR);
            service->Address.MaximumLength = service->Address.Length +
                                                sizeof(WCHAR);
            service->Address.Buffer = (PWCHAR) ExAllocatePoolWithTag(
                                                    PagedPool,
                                                    service->Address.MaximumLength,
                                                    ' puM');
            if (service->Address.Buffer == NULL)        {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Cleanup;
            }
            RtlMoveMemory(service->Address.Buffer,
                          shareName,
                          service->Address.MaximumLength);

            DfsDbgTrace( 0, Dbg, "PktpAddEntry: service->Address = %wZ\n",
                &service->Address);

            //
            // Get the Machine Address structure for this server...
            //

            pMachine = PktpGetDSMachine( &service->Name );

            if (pMachine == NULL) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            service->pMachEntry = ExAllocatePoolWithTag(
                                        PagedPool, sizeof(DFS_MACHINE_ENTRY),
                                        ' puM');

            if (service->pMachEntry == NULL) {
                DfsDbgTrace( 0, Dbg, "PktpAddEntry: Unable to allocate DFS_MACHINE_ENTRY\n", 0);
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            RtlZeroMemory( (PVOID) service->pMachEntry, sizeof(DFS_MACHINE_ENTRY));
            service->pMachEntry->pMachine = pMachine;
            service->pMachEntry->UseCount = 1;


            //
            // Now we need to advance to the next referral, and to
            // the next service structure.
            //

            ref = (PDFS_REFERRAL_V1)  (((PUCHAR)ref) + ref->Size);

            service++;

        }

        //
        // Finally, if needed, we shuffle the services so that we achieve load balancing
        // while still maintaining site-cost based replica selection.
        //
        // Note: we only shuffle v1 and v2 referrals. V3 referrals are ordered by site.
        //

        if (ShuffleList == TRUE) {

            PktShuffleServiceList( &pktEntryInfo );

        }

    }

    //
    // Now we have to figure out the type for this entry.
    //

    // 
    // Ignore the storage server bit from the server.
    // Bug: 332061.
    // 
    //if (ReferralBuffer->StorageServers == 0)     {
    //
    //  ASSERT(ReferralBuffer->ReferralServers == 1);
    //
    //    Type = PKT_ENTRY_TYPE_OUTSIDE_MY_DOM;
    //
    // } else {
    //
    //    Type = PKT_ENTRY_TYPE_DFS;
    //
    //}


    Type = 0;

    //
    // Either we know it is a domain DFS or the server sent us a hint
    // that is a interlink and we dont have a special table, mark
    // it as an interlink.
    //
    if ((DomainDfsService == TRUE) ||
        ((ReferralBuffer->StorageServers == 0) &&
         (ReferralBuffer->ReferralServers == 1) &&
         (DfsData.Pkt.SpecialTable.SpecialEntryCount == 0)))
    {
        Type |= PKT_ENTRY_TYPE_OUTSIDE_MY_DOM;
    } 
    else {
        Type = PKT_ENTRY_TYPE_DFS;
        if ((ReferralBuffer->ReferralServers == 1) &&
            (ReferralBuffer->StorageServers == 1))
        {
            Type |= PKT_ENTRY_TYPE_REFERRAL_SVC;
        }
    }


    //
    //  At this point we have everything we need to create an entry, so
    //  try to add the entry.
    //

    status = PktCreateEntry(
                Pkt,
                Type,
                EntryId,
                &pktEntryInfo,
                CreateDisposition,
                pDfsTargetInfo,
                ppPktEntry);

    if (!NT_SUCCESS(status))    {

        //
        // Since we failed to add the entry, at least we need to release
        // all the memory before we return back.
        //

        goto Cleanup;
    }

    //
    // Set the active service, if possible
    //

    ServerName = (*ppPktEntry)->Id.Prefix;

    //
    // Skip any leading leading '\'
    //

    if (ServerName.Buffer != NULL) {

        if (*ServerName.Buffer == UNICODE_PATH_SEP) {

            ServerName.Buffer++;
            ServerName.Length -= sizeof(WCHAR);

        }

        //
        // Find the first '\' or end
        //

        for (i = 0;
                i < ServerName.Length/sizeof(WCHAR) &&
                    ServerName.Buffer[i] != UNICODE_PATH_SEP;
                        i++) {

            NOTHING;
        
        }

        ServerName.Length = ServerName.MaximumLength = (USHORT) (i * sizeof(WCHAR));

        //
        // Ignore the return value - for FtDfs names using \\domainname\ftdfsname,
        // there will be no services with the domain name.
        //
#if 0
        DfspSetActiveServiceByServerName(
            &ServerName,
            *ppPktEntry);
#endif

    }

    //
    // If one of the services is our DC, we try to make it the active service
    // DONT DO THIS! Screws up site selection!
#if 0
    DfspSetServiceListToDc(*ppPktEntry);
#endif
    //
    // We set the ExpireTime in this entry to
    // Pkt->EntryTimeToLive. After these many number of seconds this
    // entry will get deleted from the PKT. Do this only for non-permanent
    // entries.
    //

    if (TimeToLive != 0) {
        (*ppPktEntry)->ExpireTime = TimeToLive;
        (*ppPktEntry)->TimeToLive = TimeToLive;
    } else {
        (*ppPktEntry)->ExpireTime = Pkt->EntryTimeToLive;
        (*ppPktEntry)->TimeToLive = Pkt->EntryTimeToLive;
    }

#if DBG
    if (MupVerbose)
        DbgPrint("  Setting expiretime/timetolive = %d/%d\n",
            (*ppPktEntry)->ExpireTime,
            (*ppPktEntry)->TimeToLive);
#endif

#if DBG
    if (MupVerbose >= 2) {
        DbgPrint("  Setting expiretime and timetolive to 10\n");

        (*ppPktEntry)->ExpireTime = 10;
        (*ppPktEntry)->TimeToLive = 10;
    }
#endif

    DfsDbgTrace(-1, Dbg, "PktpAddEntry: Exit -> %08lx\n", ULongToPtr(status) );
    return status;

Cleanup:

    if (pktEntryInfo.ServiceCount > 0)    {

        n = pktEntryInfo.ServiceCount;
        if (pktEntryInfo.ServiceList != NULL)   {
            service = pktEntryInfo.ServiceList;

            while (n--) {

                if (service->Name.Buffer != NULL)
                        DfsFree(service->Name.Buffer);
                if (service->Address.Buffer != NULL)
                        DfsFree(service->Address.Buffer);
                if (service->pMachEntry != NULL) {

                    DfsDecrementMachEntryCount( service->pMachEntry, TRUE);
                }

                service++;
            }

            ExFreePool(pktEntryInfo.ServiceList);
        }
    }

    DfsDbgTrace(-1, Dbg, "PktpAddEntry: Exit -> %08lx\n", ULongToPtr(status) );
    return status;
}


//+----------------------------------------------------------------------------
//
//  Function:   PktpCreateEntryIdFromReferral
//
//  Synopsis:   Given a dfs referral, this routine constructs a PKT_ENTRY_ID
//              from the referral buffer which can then be used to create
//              the Pkt Entry.
//
//  Arguments:  [Ref] -- The referral buffer
//              [ReferralPath] -- The path for which the referral was obtained
//              [MatchingLength] -- The length in bytes of ReferralPath that
//                      matched.
//              [Peid] -- On successful return, the entry id is returned
//                      here.
//
//  Returns:    [STATUS_SUCCESS] -- Successfully create entry id.
//
//              [STATUS_INSUFFICIENT_RESOURCES] -- Out of memory condition
//
//-----------------------------------------------------------------------------

NTSTATUS
PktpCreateEntryIdFromReferral(
    IN PRESP_GET_DFS_REFERRAL Ref,
    IN PUNICODE_STRING ReferralPath,
    OUT ULONG *MatchingLength,
    OUT PDFS_PKT_ENTRY_ID Peid)
{
    NTSTATUS status = STATUS_SUCCESS;
    PDFS_REFERRAL_V2 pv2;
    PDFS_REFERRAL_V3 pv3;
    UNICODE_STRING prefix, shortPrefix;

    DfsDbgTrace(+1, Dbg, "PktpCreateIdFromReferral: Entered\n", 0);

    Peid->Prefix.Buffer = NULL;

    Peid->ShortPrefix.Buffer = NULL;

    pv2 = &Ref->Referrals[0].v2;

    switch (pv2->VersionNumber) {

    case 1:

        {

            //
            // A version 1 referral only has the number of characters that
            // matched, and it does not have short names.
            //

            prefix = *ReferralPath;

            prefix.Length = Ref->PathConsumed;

            if (prefix.Buffer[ prefix.Length/sizeof(WCHAR) - 1 ] ==
                    UNICODE_PATH_SEP) {
                prefix.Length -= sizeof(WCHAR);
            }

            prefix.MaximumLength = prefix.Length + sizeof(WCHAR);

            shortPrefix = prefix;

            *MatchingLength = prefix.Length;

        }

        break;

    case 2:

        {

            LPWSTR volPrefix;
            LPWSTR volShortPrefix;

            volPrefix = (LPWSTR) (((PCHAR) pv2) + pv2->DfsPathOffset);

            volShortPrefix = (LPWSTR) (((PCHAR) pv2) + pv2->DfsAlternatePathOffset);

            RtlInitUnicodeString(&prefix, volPrefix);

            RtlInitUnicodeString(&shortPrefix, volShortPrefix);

            *MatchingLength = Ref->PathConsumed;

        }

        break;

    case 3:

        {

            LPWSTR volPrefix;
            LPWSTR volShortPrefix;

            pv3 = &Ref->Referrals[0].v3;

            volPrefix = (LPWSTR) (((PCHAR) pv3) + pv3->DfsPathOffset);

            volShortPrefix = (LPWSTR) (((PCHAR) pv3) + pv3->DfsAlternatePathOffset);

            RtlInitUnicodeString(&prefix, volPrefix);

            RtlInitUnicodeString(&shortPrefix, volShortPrefix);

            *MatchingLength = Ref->PathConsumed;

        }

        break;

    default:

        // Fix for 440914 (prefix bug). Remove assert and return so that
        // we are not dealing with uninitialized variables.

        status = STATUS_INVALID_PARAMETER;

        return status;

    }

    Peid->Prefix.Buffer = ExAllocatePoolWithTag(
                            PagedPool,
                            prefix.MaximumLength,
                            ' puM');

    if (Peid->Prefix.Buffer == NULL)
        status = STATUS_INSUFFICIENT_RESOURCES;

    if (NT_SUCCESS(status)) {

        Peid->ShortPrefix.Buffer = ExAllocatePoolWithTag(
                                        PagedPool,
                                        shortPrefix.MaximumLength,
                                        ' puM');

        if (Peid->ShortPrefix.Buffer == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }

    }

    if (NT_SUCCESS(status)) {

        Peid->Prefix.Length =  prefix.Length;

        Peid->Prefix.MaximumLength = prefix.MaximumLength;

        RtlCopyMemory(
            Peid->Prefix.Buffer,
            prefix.Buffer,
            prefix.Length);

        Peid->Prefix.Buffer[Peid->Prefix.Length/sizeof(WCHAR)] =
            UNICODE_NULL;

        Peid->ShortPrefix.Length = shortPrefix.Length;

        Peid->ShortPrefix.MaximumLength = shortPrefix.MaximumLength;

        RtlCopyMemory(
            Peid->ShortPrefix.Buffer,
            shortPrefix.Buffer,
            shortPrefix.Length);

        Peid->ShortPrefix.Buffer[Peid->ShortPrefix.Length/sizeof(WCHAR)] =
            UNICODE_NULL;

    }

    if (!NT_SUCCESS(status)) {

        if (Peid->Prefix.Buffer != NULL) {
            ExFreePool( Peid->Prefix.Buffer );
            Peid->Prefix.Buffer = NULL;
        }

        if (Peid->ShortPrefix.Buffer != NULL) {
            ExFreePool( Peid->ShortPrefix.Buffer );
            Peid->ShortPrefix.Buffer = NULL;
        }

    }

    DfsDbgTrace(-1, Dbg, "PktpCreateIdFromReferral: Exit -> 0x%x\n", ULongToPtr(status) );

    return( status );

}


//+----------------------------------------------------------------------------
//
//  Function:   PktpGetDSMachine
//
//  Synopsis:   Builds a DS_MACHINE with a single NetBIOS address
//
//  Arguments:  [ServerName] -- Name of server.
//
//  Returns:    If successful, a pointer to a newly allocate DS_MACHINE,
//              otherwise, NULL
//
//-----------------------------------------------------------------------------

PDS_MACHINE
PktpGetDSMachine(
    IN PUNICODE_STRING ServerName)
{
    PDS_MACHINE pMachine = NULL;
    PDS_TRANSPORT pdsTransport;
    PTDI_ADDRESS_NETBIOS ptdiNB;
    ANSI_STRING astrNetBios;

    //
    // Allocate the DS_MACHINE structure
    //

    pMachine = ExAllocatePoolWithTag(PagedPool, sizeof(DS_MACHINE), ' puM');

    if (pMachine == NULL) {
        goto Cleanup;
    }

    RtlZeroMemory(pMachine, sizeof(DS_MACHINE));

    //
    // Allocate the array of principal names
    //

    pMachine->cPrincipals = 1;

    pMachine->prgpwszPrincipals = (LPWSTR *) ExAllocatePoolWithTag(
                                                PagedPool,
                                                sizeof(LPWSTR),
                                                ' puM');

    if (pMachine->prgpwszPrincipals == NULL) {
        goto Cleanup;
    }

    //
    // Allocate the principal name
    //

    pMachine->prgpwszPrincipals[0] = (PWCHAR) ExAllocatePoolWithTag(
                                        PagedPool,
                                        ServerName->MaximumLength,
                                        ' puM');
    if (pMachine->prgpwszPrincipals[0] == NULL) {
        goto Cleanup;
    }
    RtlMoveMemory(
        pMachine->prgpwszPrincipals[0],
        ServerName->Buffer,
        ServerName->MaximumLength);

    //
    // Allocate a single DS_TRANSPORT
    //

    pMachine->cTransports = 1;

    pMachine->rpTrans[0] = (PDS_TRANSPORT) ExAllocatePoolWithTag(
                                            PagedPool,
                                            sizeof(DS_TRANSPORT) + sizeof(TDI_ADDRESS_NETBIOS),
                                            ' puM');
    if (pMachine->rpTrans[0] == NULL) {
        goto Cleanup;
    }

    //
    // Initialize the DS_TRANSPORT
    //

    pdsTransport = pMachine->rpTrans[0];

    pdsTransport->usFileProtocol = FSP_SMB;

    pdsTransport->iPrincipal = 0;

    pdsTransport->grfModifiers = 0;

    //
    // Build the TA_ADDRESS_NETBIOS
    //

    pdsTransport->taddr.AddressLength = sizeof(TDI_ADDRESS_NETBIOS);

    pdsTransport->taddr.AddressType = TDI_ADDRESS_TYPE_NETBIOS;

    ptdiNB = (PTDI_ADDRESS_NETBIOS) &pdsTransport->taddr.Address[0];

    ptdiNB->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;

    RtlFillMemory( &ptdiNB->NetbiosName[0], 16, ' ' );

    astrNetBios.Length = 0;
    astrNetBios.MaximumLength = 16;
    astrNetBios.Buffer = ptdiNB->NetbiosName;

    RtlUnicodeStringToAnsiString(&astrNetBios, ServerName, FALSE);

    return( pMachine );

Cleanup:

    if (pMachine) {

        PktDSMachineDestroy( pMachine, TRUE );

        pMachine = NULL;
    }

    return( pMachine );
}


//+----------------------------------------------------------------------------
//
//  Function:  PktShuffleServiceList
//
//  Synopsis:  Randomizes a service list for proper load balancing. This
//             routine assumes that the service list is ordered based on
//             site costs. For each equivalent cost group, this routine
//             shuffles the service list.
//
//  Arguments: [pInfo] -- Pointer to PktEntryInfo whose service list needs to
//                        be shuffled.
//
//  Returns:   Nothing, unless rand() fails!
//
//-----------------------------------------------------------------------------

VOID
PktShuffleServiceList(
    PDFS_PKT_ENTRY_INFO pInfo)
{
    PktShuffleGroup(pInfo, 0, pInfo->ServiceCount);
}

//+----------------------------------------------------------------------------
//
//  Function:   PktShuffleGroup
//
//  Synopsis:   Shuffles a cost equivalent group of services around for load
//              balancing. Uses the classic card shuffling algorithm - for
//              each card in the deck, exchange it with a random card in the
//              deck.
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

VOID
PktShuffleGroup(
    PDFS_PKT_ENTRY_INFO pInfo,
    ULONG       nStart,
    ULONG       nEnd)
{
    ULONG i;
    LARGE_INTEGER seed;

    ASSERT( nStart < pInfo->ServiceCount );
    ASSERT( nEnd <= pInfo->ServiceCount );

    KeQuerySystemTime( &seed );

    for (i = nStart; i < nEnd; i++) {

        DFS_SERVICE TempService;
        ULONG j;

        ASSERT (nEnd - nStart != 0);

        j = (RtlRandom( &seed.LowPart ) % (nEnd - nStart)) + nStart;

        ASSERT( j >= nStart && j <= nEnd );

        TempService = pInfo->ServiceList[i];

        pInfo->ServiceList[i] = pInfo->ServiceList[j];

        pInfo->ServiceList[j] = TempService;

    }
}


//+----------------------------------------------------------------------------
//
//  Function:  DfspSetServiceListToDc
//
//  Synopsis:  If this is a sysvol service list, try to set the
//             DC to the one we got from DsGetDcName().
//
//  Arguments: [pInfo] -- Pointer to DFS_PKT_ENTRY whose service list is to
//                        be set.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfspSetServiceListToDc(
    PDFS_PKT_ENTRY pktEntry)
{
    PDFS_PKT Pkt;
    UNICODE_STRING DCNameShort;
    PDFS_PKT_ENTRY_INFO pInfo = &pktEntry->Info;
    ULONG i, pathSepCount;
    UNICODE_STRING ShareName;

    ShareName = (pktEntry)->Id.Prefix;
    pathSepCount = 2; // 2 \ before we reach the sharename.
    
    for (i = 0; 
	   i < ShareName.Length/sizeof(WCHAR) && pathSepCount;
               i++) {
        if (ShareName.Buffer[i] == UNICODE_PATH_SEP) {
            pathSepCount--;
	}
    }

    if (pathSepCount == 0 && ShareName.Length > i) {
        ShareName.Buffer += i;
        ShareName.Length -= (USHORT)(i * sizeof(WCHAR));

        for (i = 0;
                i < ShareName.Length/sizeof(WCHAR) &&
                   ShareName.Buffer[i] != UNICODE_PATH_SEP;
                      i++) {
             NOTHING;
        }
        ShareName.Length = (USHORT)i * sizeof(WCHAR);
        ShareName.MaximumLength = ShareName.Length;

        if (DfspIsSysVolShare(&ShareName) == FALSE) {
           return STATUS_INVALID_PARAMETER;
        }
    } else {
        return STATUS_INVALID_PARAMETER;
    }
    //
    // We simply scan the list and try to match on the DC name.  If we get
    // a hit, set the active service pointer
    //

    Pkt = _GetPkt();

    if ( Pkt->DCName.Length > 0 && pInfo != NULL) { 

        DfspDnsNameToFlatName(&Pkt->DCName, &DCNameShort);

        for (i = 0; i < pInfo->ServiceCount; i++) {
            if (
                RtlCompareUnicodeString(&pInfo->ServiceList[i].Name, &Pkt->DCName, TRUE) == 0
                    ||
                RtlCompareUnicodeString(&pInfo->ServiceList[i].Name, &DCNameShort, TRUE) == 0
             ) {
                pktEntry->ActiveService = &pInfo->ServiceList[i];
                return STATUS_SUCCESS;
             }
         }
     }
     return STATUS_INVALID_PARAMETER;
}

//+----------------------------------------------------------------------------
//
//  Function:   PktShuffleSpecialEntryList
//
//  Synopsis:   Shuffles the Special Entries
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

VOID
PktShuffleSpecialEntryList(
    PDFS_SPECIAL_ENTRY pSpecialEntry)
{
    ULONG i;
    LARGE_INTEGER seed;

    if (pSpecialEntry->ExpandedCount < 2)

        return;

    KeQuerySystemTime( &seed );

    for (i = 0; i < pSpecialEntry->ExpandedCount; i++) {

        DFS_EXPANDED_NAME TempExpandedName;
        ULONG j;

        j = RtlRandom( &seed.LowPart ) % pSpecialEntry->ExpandedCount;

        ASSERT( j < pSpecialEntry->ExpandedCount );

        TempExpandedName = pSpecialEntry->ExpandedNames[i];

        pSpecialEntry->ExpandedNames[i] = pSpecialEntry->ExpandedNames[j];

        pSpecialEntry->ExpandedNames[j] = TempExpandedName;

    }
}

//+----------------------------------------------------------------------------
//
//  Function:   PktSetSpecialEntryListToDc
//
//  Synopsis:   Sets the Special list active selection to the DC we got
//              from DsGetDcName()
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

VOID
PktSetSpecialEntryListToDc(
    PDFS_SPECIAL_ENTRY pSpecialEntry)
{
    PDFS_PKT Pkt;

    //
    // Set the 'active' entry to be the DC that DsGetDcName() gave us, if this is
    // the current domain.
    //

    Pkt = _GetPkt();

    //
    // If in our domain, start with DC last fetched by DsGetDcName()
    //

    if (
        Pkt->DCName.Length > 0
            &&
        Pkt->DomainNameFlat.Length > 0
            &&
        Pkt->DomainNameDns.Length > 0
            &&
        (RtlCompareUnicodeString(&pSpecialEntry->SpecialName, &Pkt->DomainNameFlat, TRUE) == 0
            ||
        RtlCompareUnicodeString(&pSpecialEntry->SpecialName, &Pkt->DomainNameDns, TRUE) == 0)
    ) {

        UNICODE_STRING DCNameShort;
        PUNICODE_STRING pExpandedName;
        ULONG EntryIdx;

#if DBG
        if (MupVerbose)
            DbgPrint("  PktSetSpecialEntryListToDc(SpecialName=[%wZ] Flat=[%wZ] Dns=[%wZ])\n",
                &pSpecialEntry->SpecialName,
                &Pkt->DomainNameFlat,
                &Pkt->DomainNameDns);
#endif
        DfspDnsNameToFlatName(&Pkt->DCName, &DCNameShort);
        for (EntryIdx = 0; EntryIdx < pSpecialEntry->ExpandedCount; EntryIdx++) {
            pExpandedName = &pSpecialEntry->ExpandedNames[EntryIdx].ExpandedName;
            if (
                RtlCompareUnicodeString(&Pkt->DCName, pExpandedName, TRUE) == 0
                    ||
                RtlCompareUnicodeString(&DCNameShort, pExpandedName, TRUE) == 0
            ) {
                pSpecialEntry->Active = EntryIdx;
#if DBG
                if (MupVerbose)
                    DbgPrint("    EntryIdx=%d\n", EntryIdx);
#endif
                break;
            }
        }
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   PktParsePrefix
//
//  Synopsis:   Helper routine to break a path into domain, share, remainder
//
//  Arguments:  [Path] -- PUNICODE string of path to parse
//
//  Returns:    [MachineName] -- UNICODE_STRING containing MachineName, if present
//              [ShareName] -- UNICODE_STRING containing ShareName, if present
//              [Remainder] -- UNICODE_STRING containing remainder of Path
//
//-----------------------------------------------------------------------------

VOID
PktParsePath(
    IN  PUNICODE_STRING PathName,
    OUT PUNICODE_STRING MachineName,
    OUT PUNICODE_STRING ShareName,
    OUT PUNICODE_STRING Remainder OPTIONAL)
{
    LPWSTR ustrp, ustart, uend;

    DfsDbgTrace(+1, Dbg, "PktParsePath(%wZ)\n", PathName);

    RtlInitUnicodeString(MachineName, NULL);
    RtlInitUnicodeString(ShareName, NULL);
    if (ARGUMENT_PRESENT(Remainder)) {
        RtlInitUnicodeString(Remainder, NULL);
    }

    // Be sure there's something to do

    if (PathName->Length == 0) {
        DfsDbgTrace(-1, Dbg, "PathName is empty\n",0 );
        return;
    }

    // Skip leading '\'s

    ustart = ustrp = PathName->Buffer;
    uend = &PathName->Buffer[PathName->Length / sizeof(WCHAR)] - 1;

    // strip trailing nulls
    while (uend >= ustart && *uend == UNICODE_NULL)
        uend--;

    while (ustrp <= uend && *ustrp == UNICODE_PATH_SEP)
        ustrp++;

    // MachineName

    ustart = ustrp;

    while (ustrp <= uend && *ustrp != UNICODE_PATH_SEP)
        ustrp++;

    if (ustrp != ustart) {

        MachineName->Buffer = ustart;
        MachineName->Length = (USHORT)(ustrp - ustart) * sizeof(WCHAR);
        MachineName->MaximumLength = MachineName->Length;

        // ShareName

        ustart = ++ustrp;

        while (ustrp <= uend && *ustrp != UNICODE_PATH_SEP)
            ustrp++;

        if (ustrp != ustart) {
            ShareName->Buffer = ustart;
            ShareName->Length = (USHORT)(ustrp - ustart) * sizeof(WCHAR);
            ShareName->MaximumLength = ShareName->Length;

            // Remainder is whatever's left

            ustart = ++ustrp;

            while (ustrp <= uend)
                ustrp++;

            if (ustrp != ustart && ARGUMENT_PRESENT(Remainder)) {
                Remainder->Buffer = ustart;
                Remainder->Length = (USHORT)(ustrp - ustart) * sizeof(WCHAR);
                Remainder->MaximumLength = Remainder->Length;
            }
        }
    }
    DfsDbgTrace( 0, Dbg, "PktParsePath:  MachineName -> %wZ\n", MachineName);
    if (!ARGUMENT_PRESENT(Remainder)) {
        DfsDbgTrace(-1, Dbg, "                ShareName  -> %wZ\n", ShareName);
    } else {
        DfsDbgTrace( 0, Dbg, "                ShareName  -> %wZ\n", ShareName);
        DfsDbgTrace(-1, Dbg, "                Remainder  -> %wZ\n", Remainder);
    }
}

//+--------------------------------------------------------------------
//
// Function:    PktExpandSpecialName
//
// Synopsis:    This function is called to expand a Special name into a list
//              of Names.  It returns a pointer to an array of DFS_SPECIAL_ENTRY's
//
// Arguments:   Name - Name to expand
//              ppSpecialEntry - pointer to pointer for results
//
// Returns:     STATUS_SUCCESS
//              STATUS_BAD_NETWORK_PATH
//              STATUS_INSUFFICIENT_RESOURCES
//
//---------------------------------------------------------------------

NTSTATUS
_PktExpandSpecialName(
    PUNICODE_STRING Name,
    PDFS_SPECIAL_ENTRY *ppSpecialEntry)
{
    NTSTATUS status;
    HANDLE hServer = NULL;
    DFS_SERVICE service;
    PPROVIDER_DEF provider;
    PREQ_GET_DFS_REFERRAL ref = NULL;
    ULONG refSize = 0;
    UNICODE_STRING refPath;
    IO_STATUS_BLOCK iosb;
    BOOLEAN attachedToSystemProcess = FALSE;
    PDFS_SPECIAL_ENTRY pSpecialEntry;
    PDFS_PKT Pkt;
    BOOLEAN pktLocked;
    PDFS_SPECIAL_TABLE pSpecial = &DfsData.Pkt.SpecialTable;
    LARGE_INTEGER now;
    KAPC_STATE ApcState;
    ULONG MaxReferralLength;
    SE_IMPERSONATION_STATE DisabledImpersonationState;
    BOOLEAN RestoreImpersonationState = FALSE;
    LARGE_INTEGER StartTime;
    LARGE_INTEGER EndTime;
    PUNICODE_STRING origDCName;
    UNICODE_STRING DCName;
 
    DfsDbgTrace(+1, Dbg, "PktExpandSpecialName(%wZ)\n", Name);

    DCName.Buffer = NULL;
    KeQuerySystemTime(&StartTime);
#if DBG
    if (MupVerbose) {
        KeQuerySystemTime(&EndTime);
        DbgPrint("[%d] PktExpandSpecialName: Name %wZ \n",
                    (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)),
                    Name);
    }
#endif

    *ppSpecialEntry = NULL;

    Pkt = _GetPkt();
    PktAcquireShared(TRUE, &pktLocked);

    if (Pkt->SpecialTable.SpecialEntryCount == 0) {
        PktRelease();
        pktLocked = FALSE;
        status = STATUS_BAD_NETWORK_PATH;
        MUP_TRACE_HIGH(ERROR, _PktExpandSpecialName_Error_NoSpecialReferralTable,
                       LOGSTATUS(status)
                       LOGUSTR(*Name));
        DfsDbgTrace( 0, Dbg, "No special referral table.\n", 0);
        DfsDbgTrace(-1, Dbg, "PktExpandSpecialName returning %08lx\n", ULongToPtr(status) );
        return (status);
    }

    pSpecialEntry = PktLookupSpecialNameEntry(Name);

    //
    // We don't have any expansion for this name
    //
    if (pSpecialEntry == NULL) {
        PktRelease();
        pktLocked = FALSE;
        status = STATUS_BAD_NETWORK_PATH;
        MUP_TRACE_HIGH(ERROR, _PktExpandSpecialName_Error_NotInSpecialReferralTable,
                       LOGUSTR(*Name)
                       LOGSTATUS(status));
        DfsDbgTrace( 0, Dbg, "... not in SpecialName table(cache miss)\n", 0);
        DfsDbgTrace(-1, Dbg, "PktExpandSpecialName returning %08lx\n", ULongToPtr(status) );
        return (status);
    }

    origDCName = &pSpecialEntry->DCName;
    if (origDCName->Buffer == NULL) {
      origDCName = &Pkt->DCName;
    }

    DfsDbgTrace( 0, Dbg, "Expanded Referral DCName = %wZ\n", origDCName);
    //
    // We have a (potential) expansion
    //
    if (origDCName->Buffer == NULL) {
        status = STATUS_BAD_NETWORK_PATH;
        MUP_TRACE_HIGH(ERROR, _PktExpandSpecialName_Error_DCNameNotInitialized,
                       LOGSTATUS(status)
                       LOGUSTR(*Name));
        DfsDbgTrace( 0, Dbg, "PktExpandSpecialName:DCName not initialized - \n", 0);
        DfsDbgTrace(-1, Dbg, "PktExpandSpecialName returning %08lx\n", ULongToPtr(status) );
        PktRelease();
        pktLocked = FALSE;
        return (status);
    }

    InterlockedIncrement(&pSpecialEntry->UseCount);

    if (pSpecialEntry->Stale == FALSE && pSpecialEntry->NeedsExpansion == FALSE) {
        PktRelease();
        pktLocked = FALSE;
        *ppSpecialEntry = pSpecialEntry;
        status = STATUS_SUCCESS;
        DfsDbgTrace( 0, Dbg, "... found in Special Name table (cache hit 1)\n", 0);
        DfsDbgTrace(-1, Dbg, "PktExpandSpecialName returning %08lx\n", ULongToPtr(status) );
        return (status);
    }

    //
    // It's in the special name table, but needs to be expanded or refreshed
    //

    ASSERT(pSpecialEntry->NeedsExpansion == TRUE || pSpecialEntry->Stale == TRUE);

    // Now copy the DC we are going to use before releasing the lock.

    DCName.Buffer = ExAllocatePoolWithTag(
                         PagedPool,
                         origDCName->MaximumLength,
                         ' puM');
    if (DCName.Buffer == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        MUP_TRACE_HIGH(ERROR, _PktExpandSpecialName_Error_ExAllocatePoolWithTag,
                       LOGSTATUS(status)
                       LOGUSTR(*Name));
        DfsDbgTrace(-1, Dbg, "PktExpandSpecialName returning %08lx\n", ULongToPtr(status) );
        PktRelease();
        pktLocked = FALSE;
        return (status);

    }
    DCName.Length = origDCName->Length;
    DCName.MaximumLength = origDCName->MaximumLength;
    RtlCopyMemory(
         DCName.Buffer,
         origDCName->Buffer,
         origDCName->MaximumLength);


    PktRelease();
    pktLocked = FALSE;

    DfsDbgTrace( 0, Dbg, "... in special name table (cache hit 2)\n", 0);

    //
    // get a provider and service describing the remote server.
    //

    provider = ReplLookupProvider( PROV_ID_DFS_RDR );
    if (provider == NULL) {
        DfsDbgTrace(-1, Dbg, "Unable to open LM Rdr!\n", 0);
        status =  STATUS_BAD_NETWORK_PATH;
        MUP_TRACE_HIGH(ERROR, _PktExpandSpecialName_Error_UnableToOpenRdr,
                       LOGSTATUS(status)
                       LOGUSTR(*Name));
	goto Cleanup;
    }

    RtlZeroMemory( &service, sizeof(DFS_SERVICE) );
    status = PktServiceConstruct(
                &service,
                DFS_SERVICE_TYPE_MASTER | DFS_SERVICE_TYPE_REFERRAL,
                PROV_DFS_RDR,
                STATUS_SUCCESS,
                PROV_ID_DFS_RDR,
                &DCName,
                NULL);

    DfsDbgTrace(0, Dbg, "PktServiceConstruct returned %08lx\n", ULongToPtr(status) );

    //
    // Next, we build a connection to this machine and ask it for a referral.
    //

    if (NT_SUCCESS(status)) {
        PktAcquireShared( TRUE, &pktLocked );
        if (PsGetCurrentProcess() != DfsData.OurProcess) {
            KeStackAttachProcess( DfsData.OurProcess, &ApcState );
            attachedToSystemProcess = TRUE;
        }

        RestoreImpersonationState = PsDisableImpersonation(
                                        PsGetCurrentThread(),
                                        &DisabledImpersonationState);

        status = DfsCreateConnection(
                    &service,
                    provider,
                    FALSE,
                    &hServer);
#if DBG
        if (MupVerbose) {
            KeQuerySystemTime(&EndTime);
            DbgPrint("  [%d] DfsCreateConnection to %wZ returned 0x%x\n",
                        (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)),
		        &DCName,
                        status);
        }
#endif

        if (!NT_SUCCESS(status) && DfsEventLog > 0)
            LogWriteMessage(DFS_CONNECTION_FAILURE, status, 1, &DCName);

        PktRelease();
        pktLocked = FALSE;
        DfsDbgTrace(0, Dbg, "DfsCreateConnection returned %08lx\n", ULongToPtr(status) );
    }

    MaxReferralLength = MAX_REFERRAL_LENGTH;

Retry:

    RtlZeroMemory( &refPath, sizeof(UNICODE_STRING) );

    if (NT_SUCCESS(status)) {
        ULONG ReferralSize = 0;

        refPath.Length = 0;
        refPath.MaximumLength = sizeof(UNICODE_PATH_SEP) +
                                    Name->Length +
                                        sizeof(UNICODE_NULL);

        ReferralSize = refPath.MaximumLength + sizeof(REQ_GET_DFS_REFERRAL);

        if (ReferralSize > MAX_REFERRAL_MAX) {
            status = STATUS_INVALID_PARAMETER;
        }
        else if (MaxReferralLength < ReferralSize)
        {
            MaxReferralLength = ReferralSize;
        }

        if (NT_SUCCESS(status)) {
            refPath.Buffer = ExAllocatePoolWithTag( NonPagedPool,
                                                    refPath.MaximumLength + MaxReferralLength,
                                                    ' puM');

            if (refPath.Buffer != NULL) {
                ref = (PREQ_GET_DFS_REFERRAL)
                &refPath.Buffer[refPath.MaximumLength / sizeof(WCHAR)];
                RtlAppendUnicodeToString( &refPath, UNICODE_PATH_SEP_STR);
                RtlAppendUnicodeStringToString( &refPath, Name);
                refPath.Buffer[ refPath.Length / sizeof(WCHAR) ] = UNICODE_NULL;
                ref->MaxReferralLevel = 3;

                RtlMoveMemory(&ref->RequestFileName[0],
                              refPath.Buffer,
                              refPath.Length + sizeof(WCHAR));

                DfsDbgTrace(0, Dbg, "Referral Path : %ws\n", ref->RequestFileName);

                refSize = sizeof(USHORT) + refPath.Length + sizeof(WCHAR);

                DfsDbgTrace(0, Dbg, "Referral Size is %d bytes\n", ULongToPtr(refSize) );
            } else {

                DfsDbgTrace(0, Dbg, "Unable to allocate %d bytes\n",
                            ULongToPtr(refPath.MaximumLength + MaxReferralLength));

                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }


    if (NT_SUCCESS(status)) {

        DfsDbgTrace(0, Dbg, "Ref Buffer @%08lx\n", ref);

        status = ZwFsControlFile(
                    hServer,                     // Target
                    NULL,                        // Event
                    NULL,                        // APC Routine
                    NULL,                        // APC Context,
                    &iosb,                       // Io Status block
                    FSCTL_DFS_GET_REFERRALS,     // FS Control code
                    (PVOID) ref,                 // Input Buffer
                    refSize,                     // Input Buffer Length
                    (PVOID) ref,                 // Output Buffer
                    MaxReferralLength);          // Output Buffer Length

        MUP_TRACE_ERROR_HIGH(status, ALL_ERROR, _PktExpandSpecialName_Error_ZwFsControlFile,
                             LOGUSTR(*Name)
                             LOGSTATUS(status));

        DfsDbgTrace(0, Dbg, "Fscontrol returned %08lx\n", ULongToPtr(status) );
#if DBG
        if (MupVerbose) {
            KeQuerySystemTime(&EndTime);
            DbgPrint("  [%d] ZwFsControlFile returned 0x%x\n",
                        (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)),
                        status);
        }
#endif

    }

    //
    // Use the referral to expand the entry
    //

    if (NT_SUCCESS(status)) {
        PktAcquireExclusive(TRUE, &pktLocked );
        status = PktExpandSpecialEntryFromReferral(
                    &DfsData.Pkt,
                    &refPath,
                    (ULONG)iosb.Information,
                    (PRESP_GET_DFS_REFERRAL) ref,
                    pSpecialEntry);

        DfsDbgTrace(0, Dbg, "PktExpandSpecialEntryFromReferral returned %08lx\n",
            ULongToPtr(status) );

    } else if (status == STATUS_BUFFER_OVERFLOW && (refPath.Buffer != NULL) && MaxReferralLength < MAX_REFERRAL_MAX) {

        //
        // The referral didn't fit in the buffer supplied.  Make it bigger and try
        // again.
        //

        DfsDbgTrace(0, Dbg, "PktGetSpecialReferralTable: MaxReferralLength %d too small\n",
                        ULongToPtr(MaxReferralLength) );

        ExFreePool(refPath.Buffer);
        refPath.Buffer = NULL;
        MaxReferralLength *= 2;
        if (MaxReferralLength > MAX_REFERRAL_MAX)
            MaxReferralLength = MAX_REFERRAL_MAX;
        status = STATUS_SUCCESS;
        goto Retry;

    }

    if (NT_SUCCESS(status) || 
        ((pSpecialEntry->NeedsExpansion == FALSE) &&
         (status != STATUS_NO_SUCH_DEVICE))) {
        *ppSpecialEntry = pSpecialEntry;
        status = STATUS_SUCCESS;
    } else {
        InterlockedDecrement(&pSpecialEntry->UseCount);
    }

    if (pktLocked) {
        PktRelease();
        pktLocked = FALSE;
    }

    //
    // Well, we are done. Cleanup all the things we allocated...
    //

    PktServiceDestroy( &service, FALSE );
    if (hServer != NULL) {
        ZwClose( hServer );
    }

    if (refPath.Buffer != NULL) {
        ExFreePool( refPath.Buffer );
    }

    if (attachedToSystemProcess) {
        KeUnstackDetachProcess(&ApcState);
    }

    if (RestoreImpersonationState) {
            PsRestoreImpersonation(
                PsGetCurrentThread(),
                &DisabledImpersonationState);
    }

    if (status != STATUS_SUCCESS && status != STATUS_INSUFFICIENT_RESOURCES) {
        status = STATUS_BAD_NETWORK_PATH;
    }

#if DBG
    if (MupVerbose) {
        KeQuerySystemTime(&EndTime);
        DbgPrint("[%d] PktExpandSpecialName exit 0x%x\n",
                    (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)),
                    status);
    }
#endif

Cleanup:
    if (DCName.Buffer != NULL) 
        ExFreePool( DCName.Buffer );

    DfsDbgTrace(-1, Dbg, "PktExpandSpecialName returning %08lx\n", ULongToPtr(status) );

    return( status );
}

//+--------------------------------------------------------------------
//
// Function:    PktGetSpecialReferralTable
//
// Synopsis:    This function is called to load the special name table.
//
// Arguments:   [machine] - Machine to contact
//              [systemDC] - true if the table uses the pkt->dcname.
//
// Returns:     STATUS_SUCCESS
//              STATUS_BAD_NETWORK_PATH
//              STATUS_INSUFFICIENT_RESOURCES
//
//---------------------------------------------------------------------

NTSTATUS
_PktGetSpecialReferralTable(
    PUNICODE_STRING Machine,
    BOOLEAN SystemDC)
{
    NTSTATUS status;
    HANDLE hServer = NULL;
    DFS_SERVICE service;
    PPROVIDER_DEF provider;
    PREQ_GET_DFS_REFERRAL ref = NULL;
    ULONG refSize = 0;
    UNICODE_STRING refPath;
    IO_STATUS_BLOCK iosb;
    BOOLEAN attachedToSystemProcess = FALSE;
    PDFS_SPECIAL_ENTRY pSpecialEntry;
    PDFS_PKT Pkt;
    BOOLEAN pktLocked = FALSE;
    PDFS_SPECIAL_TABLE pSpecial = &DfsData.Pkt.SpecialTable;
    LARGE_INTEGER now;
    KAPC_STATE ApcState;
    ULONG MaxReferralLength;
    SE_IMPERSONATION_STATE DisabledImpersonationState;
    BOOLEAN RestoreImpersonationState = FALSE;
    LARGE_INTEGER StartTime;
    LARGE_INTEGER EndTime;

    DfsDbgTrace(+1, Dbg, "PktGetSpecialReferralTable(%wZ)\n", Machine);
    KeQuerySystemTime(&StartTime);
#if DBG
    if (MupVerbose) {
        KeQuerySystemTime(&EndTime);
        DbgPrint("[%d] PktGetSpecialReferralTable(%wZ)\n",
                    (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)),
                    Machine);
    }
#endif
    provider = ReplLookupProvider( PROV_ID_DFS_RDR );
    if (provider == NULL) {
        DfsDbgTrace(-1, Dbg, "Unable to open LM Rdr!\n", 0);
        return( STATUS_BAD_NETWORK_PATH );
    }

    RtlZeroMemory( &service, sizeof(DFS_SERVICE) );
    status = PktServiceConstruct(
                &service,
                DFS_SERVICE_TYPE_MASTER | DFS_SERVICE_TYPE_REFERRAL,
                PROV_DFS_RDR,
                STATUS_SUCCESS,
                PROV_ID_DFS_RDR,
                Machine,
                NULL);

    DfsDbgTrace(0, Dbg, "PktServiceConstruct returned %08lx\n", ULongToPtr(status) );

    //
    // Next, we build a connection to this machine and ask it for a referral.
    //

    if (NT_SUCCESS(status)) {

        PktAcquireShared( TRUE, &pktLocked );
        if (PsGetCurrentProcess() != DfsData.OurProcess) {
            KeStackAttachProcess( DfsData.OurProcess, &ApcState );
            attachedToSystemProcess = TRUE;
        }

        RestoreImpersonationState = PsDisableImpersonation(
                                        PsGetCurrentThread(),
                                        &DisabledImpersonationState);

        status = DfsCreateConnection(
                    &service,
                    provider,
                    FALSE,
                    &hServer);

#if DBG
        if (MupVerbose) {
            KeQuerySystemTime(&EndTime);
            DbgPrint("  [%d] DfsCreateConnection returned 0x%x\n",
                        (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)),
                        status);
        }
#endif

        if (!NT_SUCCESS(status) && DfsEventLog > 0)
            LogWriteMessage(DFS_CONNECTION_FAILURE, status, 1, Machine);

        PktRelease();
        pktLocked = FALSE;
        DfsDbgTrace(0, Dbg, "DfsCreateConnection returned %08lx\n", ULongToPtr(status) );
    }

    MaxReferralLength = MAX_REFERRAL_LENGTH;

Retry:

    RtlZeroMemory( &refPath, sizeof(UNICODE_STRING) );

    if (NT_SUCCESS(status)) {
        ULONG ReferralSize = 0;

        refPath.Length = 0;
        refPath.MaximumLength = sizeof(UNICODE_NULL);

        ReferralSize = refPath.MaximumLength + sizeof(REQ_GET_DFS_REFERRAL);

        if (ReferralSize > MAX_REFERRAL_MAX) {
            status = STATUS_INVALID_PARAMETER;
        }
        else if (MaxReferralLength < ReferralSize)
        {
            MaxReferralLength = ReferralSize;
        }

        if (NT_SUCCESS(status)) {
            refPath.Buffer = ExAllocatePoolWithTag(NonPagedPool,
                                                   refPath.MaximumLength + MaxReferralLength,
                                                   ' puM');


            if (refPath.Buffer != NULL) {
                ref = (PREQ_GET_DFS_REFERRAL)
                &refPath.Buffer[refPath.MaximumLength / sizeof(WCHAR)];
                refPath.Buffer[ refPath.Length / sizeof(WCHAR) ] = UNICODE_NULL;
                ref->MaxReferralLevel = 3;

                RtlMoveMemory(&ref->RequestFileName[0],
                              refPath.Buffer,
                              refPath.Length + sizeof(WCHAR));

                DfsDbgTrace(0, Dbg, "Referral Path : (%ws)\n", ref->RequestFileName);

                refSize = sizeof(USHORT) + refPath.Length + sizeof(WCHAR);

                DfsDbgTrace(0, Dbg, "Referral Size is %d bytes\n", ULongToPtr(refSize) );
            } else {

                DfsDbgTrace(0, Dbg, "Unable to allocate %d bytes\n",
                            ULongToPtr(refPath.MaximumLength + MaxReferralLength));

                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }

    if (NT_SUCCESS(status)) {

        DfsDbgTrace(0, Dbg, "Ref Buffer @%08lx\n", ref);

        status = ZwFsControlFile(
                    hServer,                     // Target
                    NULL,                        // Event
                    NULL,                        // APC Routine
                    NULL,                        // APC Context,
                    &iosb,                       // Io Status block
                    FSCTL_DFS_GET_REFERRALS,     // FS Control code
                    (PVOID) ref,                 // Input Buffer
                    refSize,                     // Input Buffer Length
                    (PVOID) ref,                 // Output Buffer
                    MaxReferralLength);          // Output Buffer Length

        DfsDbgTrace(0, Dbg, "Fscontrol returned %08lx\n", ULongToPtr(status) );
#if DBG
        if (MupVerbose) {
            KeQuerySystemTime(&EndTime);
            DbgPrint("  [%d] ZwFsControlFile returned 0x%x\n",
                        (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)),
                        status);
        }
#endif

    }

    //
    // Use the referral to expand the entry
    //

    if (NT_SUCCESS(status)) {
        PktAcquireExclusive( TRUE, &pktLocked );
        status = PktCreateSpecialEntryTableFromReferral(
                    &DfsData.Pkt,
                    &refPath,
                    (ULONG)iosb.Information,
                    (PRESP_GET_DFS_REFERRAL) ref,
		    (SystemDC == TRUE) ? NULL : Machine);

        DfsDbgTrace(0, Dbg, "PktGetSpecialReferralTable returned %08lx\n",
            ULongToPtr(status) );

    } else if (status == STATUS_BUFFER_OVERFLOW && (refPath.Buffer!= NULL) && MaxReferralLength < MAX_REFERRAL_MAX) {

        //
        // The referral didn't fit in the buffer supplied.  Make it bigger and try
        // again.
        //

        DfsDbgTrace(0, Dbg, "PktGetSpecialReferralTable: MaxReferralLength %d too small\n",
                        ULongToPtr(MaxReferralLength) );

        ExFreePool(refPath.Buffer);
        refPath.Buffer = NULL;
        MaxReferralLength *= 2;
        if (MaxReferralLength > MAX_REFERRAL_MAX)
            MaxReferralLength = MAX_REFERRAL_MAX;
        status = STATUS_SUCCESS;
        goto Retry;

    }

    if (!NT_SUCCESS(status) && DfsEventLog > 0)
        LogWriteMessage(DFS_SPECIAL_REFERRAL_FAILURE, status, 1, Machine);

    if (pktLocked) {
        PktRelease();
        pktLocked = FALSE;
    }

    //
    // Well, we are done. Cleanup all the things we allocated...
    //
    PktServiceDestroy( &service, FALSE );
    if (hServer != NULL) {
        ZwClose( hServer );
    }

    if (refPath.Buffer != NULL) {
        ExFreePool( refPath.Buffer );
    }

    if (attachedToSystemProcess) {
        KeUnstackDetachProcess(&ApcState);
    }

    if (RestoreImpersonationState) {
            PsRestoreImpersonation(
                PsGetCurrentThread(),
                &DisabledImpersonationState);
    }

    DfsDbgTrace(-1, Dbg, "PktGetSpecialReferralTable returning %08lx\n", ULongToPtr(status) );

#if DBG
    if (MupVerbose) {
        KeQuerySystemTime(&EndTime);
        DbgPrint("[%d] PktGetSpecialReferralTable exit 0x%x\n",
                    (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)),
                    status);
    }
#endif
    return( status );
}

//+--------------------------------------------------------------------
//
// Function:    PktLookupSpecialEntry
//
// Synopsis:    Looks up a PDFS_SPECIAL_ENTRY by name in the pkt
//
// Arguments:   Name - Name to search on
//
// Returns:     [pointer] PDFS_SPECIAL_ENTRY, if found
//              [pointer] NULL, if not found
//
//---------------------------------------------------------------------

PDFS_SPECIAL_ENTRY
PktLookupSpecialNameEntry(
    PUNICODE_STRING Name)
{
    PDFS_SPECIAL_ENTRY pSpecialEntry;
    PDFS_SPECIAL_TABLE pSpecialTable;
    PDFS_PKT Pkt;
    ULONG i;

    DfsDbgTrace(+1, Dbg, "PktLookupSpecialNameEntry(%wZ)\n", Name);

    Pkt = _GetPkt();
    pSpecialTable = &Pkt->SpecialTable;

    if (pSpecialTable->SpecialEntryCount == 0) {
        return (NULL);
    }

    DfsDbgTrace( 0, Dbg, "Cache contains %d entries...\n", ULongToPtr(pSpecialTable->SpecialEntryCount) );

    pSpecialEntry = CONTAINING_RECORD(
                        pSpecialTable->SpecialEntryList.Flink,
                        DFS_SPECIAL_ENTRY,
                        Link);

    for (i = 0; i < pSpecialTable->SpecialEntryCount; i++) {

        DfsDbgTrace( 0, Dbg, "Comparing with %wZ\n", &pSpecialEntry->SpecialName);

        if (RtlCompareUnicodeString(Name, &pSpecialEntry->SpecialName, TRUE) == 0) {

            DfsDbgTrace( 0, Dbg, "Cache hit\n", 0);
            DfsDbgTrace(-1, Dbg, "returning 0x%x\n", pSpecialEntry);

            return (pSpecialEntry);
        }
        pSpecialEntry = CONTAINING_RECORD(
                            pSpecialEntry->Link.Flink,
                            DFS_SPECIAL_ENTRY,
                            Link);
    }
    //
    // Nothing found
    //

    DfsDbgTrace(-1, Dbg, "PktLookupSpecialNameEntry: returning NULL\n", 0);

    return (NULL);
}

//+--------------------------------------------------------------------
//
// Function:    PktCreateSpecialNameEntry
//
// Synopsis:    Inserts a DFS_SPECIAL_ENTRY into the pkt, on a best-effort
//              basis.
//
// Arguments:   pSpecialEntry - Entry to insert
//
// Returns:     STATUS_SUCCESS
//
//---------------------------------------------------------------------

NTSTATUS
PktCreateSpecialNameEntry(
    PDFS_SPECIAL_ENTRY pSpecialEntry)
{
    PDFS_PKT Pkt;
    PDFS_SPECIAL_TABLE pSpecialTable;
    PDFS_SPECIAL_ENTRY pExistingEntry;

    Pkt = _GetPkt();
    pSpecialTable = &Pkt->SpecialTable;

    DfsDbgTrace(+1, Dbg, "PktCreateSpecialNameEntry entered\n", 0);

    pExistingEntry = PktLookupSpecialNameEntry(&pSpecialEntry->SpecialName);

    if (pExistingEntry == NULL) {

        //
        // Put the new one in
        //

        InsertHeadList(&pSpecialTable->SpecialEntryList, &pSpecialEntry->Link);
        pSpecialTable->SpecialEntryCount++;

        DfsDbgTrace(-1, Dbg, "added entry %d\n", ULongToPtr(pSpecialTable->SpecialEntryCount) );

    } else { // entry already exists

        if (pExistingEntry->UseCount == 0) {
        
            if (pSpecialEntry->ExpandedCount > 0) {

                //
                // Unlink the entry
                //

                RemoveEntryList(&pExistingEntry->Link);
                pSpecialTable->SpecialEntryCount--;

                //
                // And free it...

                PktSpecialEntryDestroy(pExistingEntry);

                //
                // Now put the new one in
                //

                InsertHeadList(&pSpecialTable->SpecialEntryList, &pSpecialEntry->Link);
                pSpecialTable->SpecialEntryCount++;

                DfsDbgTrace(-1, Dbg, "added entry %d\n", ULongToPtr(pSpecialTable->SpecialEntryCount) );

            } else {

                pExistingEntry->Stale = TRUE;
                PktSpecialEntryDestroy(pSpecialEntry);
                DfsDbgTrace(-1, Dbg, "marked exising stale, dropping new entry on the floor\n", 0);

            }

        } else {

            //
            // Entry in use - can't replace, so free the replacement one
            //

            PktSpecialEntryDestroy(pSpecialEntry);

            DfsDbgTrace(-1, Dbg, "dropped entry\n", 0);

        }

    }

    return (STATUS_SUCCESS);
}

//+--------------------------------------------------------------------
//
// Function:    PktEntryFromSpecialEntry
//
// Synopsis:    Creates a DFS_PKT_ENTRY from a DFS_SPECIAL_ENTRY, used
//              to support sysvols
//
// Arguments:   pSpecialEntry - Entry to Convert
//              pShareName - Name of share to append to address
//              ppPktEntry - The result
//
// Returns:     STATUS_SUCCESS
//              STATUS_INSUFFICIENT_RESOURCES
//
//---------------------------------------------------------------------

NTSTATUS
PktEntryFromSpecialEntry(
    IN  PDFS_SPECIAL_ENTRY pSpecialEntry,
    IN  PUNICODE_STRING pShareName,
    OUT PDFS_PKT_ENTRY *ppPktEntry)
{
    NTSTATUS status;
    PDFS_PKT_ENTRY pktEntry = NULL;
    PDFS_SERVICE pServices = NULL;
    PDS_MACHINE pMachine = NULL;
    PDFS_EXPANDED_NAME pExpandedNames;
    ULONG svc;
    ULONG Size;
    PWCHAR pwch;

    if (pSpecialEntry->ExpandedCount == 0
            ||
        DfspIsSysVolShare(pShareName) == FALSE
    ) {

        return STATUS_BAD_NETWORK_PATH;

    }

    pktEntry = ExAllocatePoolWithTag(
                            PagedPool,
                            sizeof(DFS_PKT_ENTRY),
                            ' puM');

    if (pktEntry == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;

    }

    RtlZeroMemory( pktEntry, sizeof(DFS_PKT_ENTRY) );

    pServices = ExAllocatePoolWithTag(
                            PagedPool,
                            sizeof(DFS_SERVICE) * pSpecialEntry->ExpandedCount,
                            ' puM');

    if (pServices == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;

    }

    RtlZeroMemory( pServices, sizeof(DFS_SERVICE) * pSpecialEntry->ExpandedCount);

    pktEntry->NodeTypeCode = DSFS_NTC_PKT_ENTRY;
    pktEntry->NodeByteSize = sizeof(DFS_PKT_ENTRY);
    pktEntry->USN = 1;
    pktEntry->Type = PKT_ENTRY_TYPE_NONDFS | PKT_ENTRY_TYPE_SYSVOL;
    pktEntry->ExpireTime = 60 * 60;
    pktEntry->TimeToLive = 60 * 60;

    InitializeListHead(&pktEntry->Link);
    InitializeListHead(&pktEntry->SubordinateList);
    InitializeListHead(&pktEntry->ChildList);

    //
    // Create Prefix and ShortPrefix from SpecialName and ShareName
    //

    Size = sizeof(UNICODE_PATH_SEP) +
                   pSpecialEntry->SpecialName.Length +
                       sizeof(UNICODE_PATH_SEP) +
                           pShareName->Length;

    pwch = ExAllocatePoolWithTag(
                    PagedPool,
                    Size,
                    ' puM');

    if (pwch == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;

    }

    pktEntry->Id.Prefix.Buffer = pwch;
    pktEntry->Id.Prefix.Length = (USHORT) Size;
    pktEntry->Id.Prefix.MaximumLength = (USHORT) Size;

    *pwch++ = UNICODE_PATH_SEP;

    RtlCopyMemory(
            pwch,
            pSpecialEntry->SpecialName.Buffer,
            pSpecialEntry->SpecialName.Length);

    pwch += pSpecialEntry->SpecialName.Length/sizeof(WCHAR);

    *pwch++ = UNICODE_PATH_SEP;

    RtlCopyMemory(
            pwch,
            pShareName->Buffer,
            pShareName->Length);

    pwch = ExAllocatePoolWithTag(
                    PagedPool,
                    Size,
                    ' puM');

    if (pwch == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;

    }

    pktEntry->Id.ShortPrefix.Buffer = pwch;
    pktEntry->Id.ShortPrefix.Length = (USHORT) Size;
    pktEntry->Id.ShortPrefix.MaximumLength = (USHORT) Size;

    RtlCopyMemory(
            pwch,
            pktEntry->Id.Prefix.Buffer,
            pktEntry->Id.Prefix.Length);

    pktEntry->Info.ServiceCount = pSpecialEntry->ExpandedCount;
    pktEntry->Info.ServiceList = pServices;

    //
    // Loop over the Expanded names, creating a Service for each
    //

    pExpandedNames = pSpecialEntry->ExpandedNames;
    for (svc = 0; svc < pSpecialEntry->ExpandedCount; svc++) {

        pServices[svc].Type = DFS_SERVICE_TYPE_MASTER | DFS_SERVICE_TYPE_DOWN_LEVEL;
        pServices[svc].Capability = PROV_STRIP_PREFIX;
        pServices[svc].ProviderId = PROV_ID_MUP_RDR;

        //
        // Machine name
        //

        Size = pExpandedNames[svc].ExpandedName.Length;
        pwch = ExAllocatePoolWithTag(
                        PagedPool,
                        Size,
                        ' puM');

        if (pwch == NULL) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;

        }

        pServices[svc].Name.Buffer = pwch;
        pServices[svc].Name.Length = (USHORT) Size;
        pServices[svc].Name.MaximumLength = (USHORT) Size;

        RtlCopyMemory(
                pwch,
                pExpandedNames[svc].ExpandedName.Buffer,
                pExpandedNames[svc].ExpandedName.Length);

        //
        // Address (\machine\share)
        //

        Size = sizeof(UNICODE_PATH_SEP) +
                   pExpandedNames[svc].ExpandedName.Length +
                       sizeof(UNICODE_PATH_SEP) +
                           pShareName->Length;

        pwch = ExAllocatePoolWithTag(
                        PagedPool,
                        Size,
                        ' puM');

        if (pwch == NULL) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;

        }

        pServices[svc].Address.Buffer = pwch;
        pServices[svc].Address.Length = (USHORT) Size;
        pServices[svc].Address.MaximumLength = (USHORT) Size;

        *pwch++ = UNICODE_PATH_SEP;

        RtlCopyMemory(
                pwch,
                pExpandedNames[svc].ExpandedName.Buffer,
                pExpandedNames[svc].ExpandedName.Length);

        pwch += pExpandedNames[svc].ExpandedName.Length/sizeof(WCHAR);

        *pwch++ = UNICODE_PATH_SEP;

        RtlCopyMemory(
                pwch,
                pShareName->Buffer,
                pShareName->Length);

        //
        // Alloc and init a DSMachine struct
        //

        pMachine = PktpGetDSMachine( &pServices[svc].Name );

        if (pMachine == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        pServices[svc].pMachEntry = ExAllocatePoolWithTag(
                                    PagedPool, sizeof(DFS_MACHINE_ENTRY),
                                    ' puM');

        if (pServices[svc].pMachEntry == NULL) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;

        }

        RtlZeroMemory( (PVOID) pServices[svc].pMachEntry, sizeof(DFS_MACHINE_ENTRY));
        pServices[svc].pMachEntry->pMachine = pMachine;
        pServices[svc].pMachEntry->UseCount = 1;



    }

    //
    // Set active service to the same as the spc's active entry
    //

    pktEntry->ActiveService = &pServices[pSpecialEntry->Active];

    *ppPktEntry = pktEntry;

    return STATUS_SUCCESS;

Cleanup:

    if (pServices != NULL) {

        for (svc = 0; svc < pSpecialEntry->ExpandedCount; svc++) {

            if (pServices[svc].Name.Buffer != NULL)
                    ExFreePool(pServices[svc].Name.Buffer);
            if (pServices[svc].Address.Buffer != NULL)
                    ExFreePool(pServices[svc].Address.Buffer);
            if (pServices[svc].pMachEntry != NULL) {

                DfsDecrementMachEntryCount(pServices[svc].pMachEntry, TRUE);
            }

        }

        ExFreePool(pServices);
    }

    //
    // Cleanup on error
    //

    if (pktEntry != NULL) {

        if (pktEntry->Id.Prefix.Buffer != NULL)
            ExFreePool(pktEntry->Id.Prefix.Buffer);
        if (pktEntry->Id.ShortPrefix.Buffer != NULL)
            ExFreePool(pktEntry->Id.ShortPrefix.Buffer);

        ExFreePool(pktEntry);

    }

    return status;

}

//+----------------------------------------------------------------------------
//
//  Function:   DfspSetActiveServiceByServerName
//
//  Synopsis:   Makes a given ServerName active
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
NTSTATUS
DfspSetActiveServiceByServerName(
    PUNICODE_STRING ServerName,
    PDFS_PKT_ENTRY pktEntry)
{
    UNICODE_STRING Server;
    PDFS_SERVICE pService;
    NTSTATUS NtStatus = STATUS_OBJECT_NAME_NOT_FOUND;
    ULONG i;

    DfsDbgTrace(+1, Dbg, "DfspSetActiveServiceByServerName\n", 0);

    for (i = 0; i < pktEntry->Info.ServiceCount && NtStatus != STATUS_SUCCESS; i++) {

        LPWSTR wp;

        pService = &pktEntry->Info.ServiceList[i];

        DfsDbgTrace( 0, Dbg, "Examining %wZ\n", &pService->Address);

        //
        // Tease apart the address (of form \Server\Share) into Server and Share
        //
        RemoveLastComponent(&pService->Address, &Server);

        //
        // Remove leading & trailing '\'s
        //
        Server.Length -= 2* sizeof(WCHAR);
        Server.MaximumLength = Server.Length;
        Server.Buffer++;

        //
        // If ServerName doesn't match, then move on to the next service
        //
        if ( RtlCompareUnicodeString(ServerName, &Server, TRUE) ) {

            continue;

        }

        DfsDbgTrace( 0, Dbg, "DfspSetActiveServiceByServerName: Server=%wZ\n", &Server);

        //
        // Make this the active share
        //

        pktEntry->ActiveService = pService;

        NtStatus = STATUS_SUCCESS;

    }

    DfsDbgTrace(-1, Dbg, "DfspSetActiveServiceByServerName -> %08lx\n", ULongToPtr(NtStatus) );

    return NtStatus;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfspIsDupPktEntry
//
//  Synopsis:   Checks if a potential pkt entry is a dup of an existing one
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
BOOLEAN
DfspIsDupPktEntry(
    PDFS_PKT_ENTRY ExistingEntry,
    ULONG EntryType,
    PDFS_PKT_ENTRY_ID EntryId,
    PDFS_PKT_ENTRY_INFO EntryInfo)
{
    ULONG i;
    ULONG j;
    PDFS_SERVICE pNewSvc;
    PDFS_SERVICE pExistSvc;
    BOOLEAN FoundDup = FALSE;


    if (
        ExistingEntry == NULL
            ||
        EntryId == NULL
            ||
        EntryInfo == NULL
    )
        return FALSE;

#if DBG
    if (MupVerbose)
        DbgPrint("  DfspIsDupPktEntry([%wZ][%wZ])\n",
                &EntryId->Prefix,
                &ExistingEntry->Id.Prefix);
#endif

    if (EntryType != ExistingEntry->Type) {
#if DBG
        if (MupVerbose)
            DbgPrint("  DfspIsDupPktEntry(1) returning FALSE\n");
#endif
        return FALSE;
    }

    if (!GuidEqual(&EntryId->Uid, &ExistingEntry->Id.Uid)) {
#if DBG
        if (MupVerbose)
            DbgPrint("  DfspIsDupPktEntry(2) returning FALSE\n");
#endif
        return FALSE;
    }

    if (
        RtlCompareUnicodeString(&EntryId->Prefix, &ExistingEntry->Id.Prefix,TRUE) != 0
            ||
        RtlCompareUnicodeString(&EntryId->ShortPrefix, &ExistingEntry->Id.ShortPrefix,TRUE) != 0
    ) {
#if DBG
        if (MupVerbose)
            DbgPrint("  DfspIsDupPktEntry(3) returning FALSE\n");
#endif
        return FALSE;
    }

    //
    // Now we have to compare all the services
    //

    if (EntryInfo->ServiceCount != ExistingEntry->Info.ServiceCount) {
#if DBG
        if (MupVerbose)
            DbgPrint("  DfspIsDupPktEntry(4) returning FALSE\n");
#endif
        return FALSE;
    }

    for (i = 0; i < EntryInfo->ServiceCount; i++) {
        FoundDup = FALSE;
        pNewSvc = &EntryInfo->ServiceList[i];
        for (j = 0; j < ExistingEntry->Info.ServiceCount; j++) {
            pExistSvc = &ExistingEntry->Info.ServiceList[j];
            if (DfspIsDupSvc(pExistSvc,pNewSvc) == TRUE) {
                FoundDup = TRUE;
                break;
            }
        }
        if (FoundDup != TRUE) {
#if DBG
            if (MupVerbose)
                DbgPrint("  DfspIsDupPktEntry(5) returning FALSE\n");
#endif
            return FALSE;
        }
    }

    for (i = 0; i < ExistingEntry->Info.ServiceCount; i++) {
        FoundDup = FALSE;
        pExistSvc = &ExistingEntry->Info.ServiceList[i];
        for (j = 0; j < EntryInfo->ServiceCount; j++) {
            pNewSvc = &EntryInfo->ServiceList[j];
            if (DfspIsDupSvc(pExistSvc,pNewSvc) == TRUE) {
                FoundDup = TRUE;
                break;
            }
         }
         if (FoundDup != TRUE) {
#if DBG
            if (MupVerbose)
                DbgPrint("  DfspIsDupPktEntry(6) returning FALSE\n");
#endif
            return FALSE;
        }
    }

#if DBG
    if (MupVerbose)
        DbgPrint("  DfspIsDupPktEntry returning TRUE\n");
#endif
    return TRUE;

}

//+----------------------------------------------------------------------------
//
//  Function:   DfspIsDupSvc
//
//  Synopsis:   Checks if two services are, for all dfs purposes, identical
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

BOOLEAN
DfspIsDupSvc(
    PDFS_SERVICE pExistSvc,
    PDFS_SERVICE pNewSvc)
{
#if DBG
    if (MupVerbose & 0x80000000) {
        DbgPrint("DfspIsDupSvc([%wZ][%wZ] vs [%wZ][%wZ])\n",
            &pExistSvc->Name, &pExistSvc->Address,
            &pNewSvc->Name, &pNewSvc->Address);
        DbgPrint("Type: 0x%x vs 0x%x\n", pExistSvc->Type, pNewSvc->Type);
        DbgPrint("Capability: 0x%x vs 0x%x\n", pExistSvc->Capability, pNewSvc->Capability);
        DbgPrint("ProviderId: 0x%x vs 0x%x\n", pExistSvc->ProviderId, pNewSvc->ProviderId);
    }
#endif
    if (
        pExistSvc->Capability != pNewSvc->Capability
            ||
        RtlCompareUnicodeString(&pExistSvc->Name, &pNewSvc->Name, TRUE) != 0
            ||
        RtlCompareUnicodeString(&pExistSvc->Address, &pNewSvc->Address, TRUE) != 0
    ) {
#if DBG
        if (MupVerbose & 0x80000000)
            DbgPrint("...FALSE\n");
#endif
        return FALSE;
    }

#if DBG
    if (MupVerbose & 0x80000000)
        DbgPrint("...TRUE\n");
#endif

    return TRUE;
}

BOOLEAN
DfspDnsNameToFlatName(
    PUNICODE_STRING DnsName,
    PUNICODE_STRING FlatName)
{
    USHORT i;

    *FlatName = *DnsName;

    for (i = 1; i < (DnsName->Length/sizeof(WCHAR)); i++) {
        if (FlatName->Buffer[i] == L'.') {
            FlatName->Length = i * sizeof(WCHAR);
            break;
        }
    }
#if DBG
    if (MupVerbose)
        DbgPrint("  DfspDnsNameToFlatName:[%wZ]->[%wZ]\n",
            DnsName,
            FlatName);
#endif
    return TRUE;
}


#define MAX_SPECIAL_ENTRIES 500

//+----------------------------------------------------------------------------
//
//  Function:   PktpUpdateSpecialTable
//
//  Synopsis:   Adds entries to the special table, given a domain and a dcname.
//              We contact the dc for a list of trusted domains either if we
//              dont have the domain already in our list OR we have the domain
//              but we haven't called this code atleast once with that domain
//              name.
//  Arguments:  DomainName and DCName.
//
//  Returns:    Success or Failure status
//
//-----------------------------------------------------------------------------

NTSTATUS
PktpUpdateSpecialTable(
    PUNICODE_STRING DomainName,
    PUNICODE_STRING DCName
)
{		       
        ULONG count = 0;
        BOOLEAN needReferral = FALSE;
        NTSTATUS status = STATUS_SUCCESS;
        PDFS_SPECIAL_ENTRY pSpecialEntry;
        BOOLEAN pktLocked = FALSE;
        PDFS_PKT Pkt = _GetPkt();

        DfsDbgTrace(+1, Dbg, "PktpUpdateSpecialTable -> Domain %wZ\n", 
                    DomainName);
        DfsDbgTrace(0, Dbg, "PktpUpdateSpecialTable -> DCname %wZ\n", 
        	    DCName);

        if ((DomainName->Length ==0) || (DCName->Length == 0)) {
          return STATUS_BAD_NETWORK_PATH;
        }
	
        PktAcquireExclusive(TRUE, &pktLocked);
        pSpecialEntry = PktLookupSpecialNameEntry(DomainName);

        // If we dont have the domain in our table, or we haven't checked
        // against this domain atleast once AND the DC is not the dc that
        // is stored in our pkt table, we decide we need a referral.
        //
    
        if (pSpecialEntry == NULL) {
            needReferral = TRUE;
        }
        else {
            if (pSpecialEntry->GotDCReferral == FALSE) {
              pSpecialEntry->GotDCReferral = TRUE;
              needReferral = TRUE;
            }
        }

        if ((needReferral == TRUE) && (Pkt->DCName.Length != 0)) {
          if (RtlEqualUnicodeString(&Pkt->DCName, DCName, TRUE)) {
            needReferral = FALSE;
          }
        }
        PktRelease();
	
        if (needReferral) {
	    
            count = Pkt->SpecialTable.SpecialEntryCount;
            if (Pkt->SpecialTable.SpecialEntryCount >= MAX_SPECIAL_ENTRIES) {
                  status = STATUS_DOMAIN_LIMIT_EXCEEDED;
            }
            else {
                  status = PktGetSpecialReferralTable(DCName, FALSE);	
            }
        }

	if (NT_SUCCESS(status)) {
	  DfsDbgTrace(0, Dbg, "PktpUpdateSpecialTable: added %d entries\n",
		      ULongToPtr( Pkt->SpecialTable.SpecialEntryCount - count ));
	}

        DfsDbgTrace(-1, Dbg, "PktpUpdateSpecialTable -> Status 0x%x\n", 
        	    ULongToPtr( status ));

        return status;
}



PDFS_PKT_ENTRY
PktFindEntryByPrefix(
    IN  PDFS_PKT Pkt,
    IN  PUNICODE_STRING Prefix
)
{
    PUNICODE_PREFIX_TABLE_ENTRY pfxEntry;
    PDFS_PKT_ENTRY              pktEntry = NULL;
    UNICODE_STRING Remaining;

    Remaining.Length = 0;
    DfsDbgTrace(+1, Dbg, "PktFindEntryByPrefix: Entered\n", 0);

    //
    // If there really is a prefix to lookup, use the prefix table
    //  to initially find an entry
    //

    if ((Prefix->Length != 0) &&
       (pfxEntry = DfsFindUnicodePrefix(&Pkt->PrefixTable,Prefix,&Remaining))) {

        pktEntry = CONTAINING_RECORD(pfxEntry,
                                     DFS_PKT_ENTRY,
                                     PrefixTableEntry);
    }

    return pktEntry;
}


//
// Fix for bug: 29300.
// Do not attach the process to system thread. Instead, post the work to the
// system process.
//


typedef enum _TYPE_OF_REFERRAL {
    REFERRAL_TYPE_GET_PKT,
    REFERRAL_TYPE_EXPAND_SPECIAL_TABLE,
    REFERRAL_TYPE_GET_REFERRAL_TABLE
} TYPE_OF_REFERRAL;


typedef struct _PKT_REFERRAL_CONTEXT {
    UNICODE_STRING ContextName;
    UNICODE_STRING DomainName;
    UNICODE_STRING ShareName;
    BOOLEAN ContextBool;
    WORK_QUEUE_ITEM WorkQueueItem;
    KEVENT  Event;
    TYPE_OF_REFERRAL   Type;
    ULONG   RefCnt;
    NTSTATUS Status;
    PVOID   Data;
} PKT_REFERRAL_CONTEXT, *PPKT_REFERRAL_CONTEXT;




VOID
PktWorkInSystemContext(
    PPKT_REFERRAL_CONTEXT Context )
{

    NTSTATUS Status;

    switch (Context->Type) {

    case REFERRAL_TYPE_GET_PKT:
       Status = _PktGetReferral( &Context->ContextName,
                                 &Context->DomainName,
                                 &Context->ShareName,
                                 Context->ContextBool );
       break;

    case REFERRAL_TYPE_EXPAND_SPECIAL_TABLE:
       Status = _PktExpandSpecialName( &Context->ContextName,
                                       (PDFS_SPECIAL_ENTRY *)&Context->Data );
       break;

    case REFERRAL_TYPE_GET_REFERRAL_TABLE:
       Status = _PktGetSpecialReferralTable( &Context->ContextName,
                                             Context->ContextBool );
       break;

    default:
       Status = STATUS_INVALID_PARAMETER;
       break;
    }

    Context->Status = Status;

    KeSetEvent( &Context->Event, 0, FALSE );

    if (InterlockedDecrement(&Context->RefCnt) == 0) {
        ExFreePool(Context);
    }
}

NTSTATUS
PktPostSystemWork( 
    PPKT_REFERRAL_CONTEXT pktContext,
    PVOID *Data )
{
    NTSTATUS Status;

    KeInitializeEvent( &pktContext->Event,
                        SynchronizationEvent, 
                        FALSE );
  
    ExInitializeWorkItem( &pktContext->WorkQueueItem,
                          PktWorkInSystemContext,
                          pktContext );

    ExQueueWorkItem( &pktContext->WorkQueueItem, CriticalWorkQueue );

    Status = KeWaitForSingleObject( &pktContext->Event,
                                    UserRequest,
                                    KernelMode,
                                    FALSE,
                                    NULL);
    MUP_TRACE_ERROR_HIGH(Status, ALL_ERROR, PktPostSystemWork_Error_KeWaitForSingleObject,
                         LOGSTATUS(Status));

    if (Status == STATUS_SUCCESS) {
        Status = pktContext->Status;
    }
    if (Data != NULL) {
       *Data = pktContext->Data;
    }

    if (InterlockedDecrement(&pktContext->RefCnt) == 0) {
        ExFreePool(pktContext);
    }

    return Status;
}

NTSTATUS
PktGetReferral(
    IN PUNICODE_STRING MachineName, // Machine to direct referral to
    IN PUNICODE_STRING DomainName,  // the machine or domain name to use
    IN PUNICODE_STRING ShareName,   // the ftdfs or dfs name
    IN BOOLEAN         CSCAgentCreate) // the CSC agent create flag
{
    PPKT_REFERRAL_CONTEXT pktContext = NULL;
    NTSTATUS Status;

    ULONG NameSize = 0;

    NameSize = MachineName->Length * sizeof(WCHAR);
    NameSize += DomainName->Length * sizeof(WCHAR);
    NameSize += ShareName->Length *  sizeof(WCHAR);


    if ((MupUseNullSessionForDfs == TRUE) &&
	(PsGetCurrentProcess() != DfsData.OurProcess)) {
       pktContext = ExAllocatePoolWithTag( NonPagedPool,
                                           sizeof (PKT_REFERRAL_CONTEXT) + NameSize,
                                           ' puM');
    }
    if (pktContext != NULL) {
        pktContext->ContextName.MaximumLength = MachineName->Length;
        pktContext->ContextName.Buffer = (WCHAR *)(pktContext + 1);
        RtlCopyUnicodeString(&pktContext->ContextName, MachineName);
        
        pktContext->DomainName.MaximumLength = DomainName->Length;
        pktContext->DomainName.Buffer = pktContext->ContextName.Buffer + pktContext->ContextName.MaximumLength;
        RtlCopyUnicodeString(&pktContext->DomainName, DomainName);

        pktContext->ShareName.MaximumLength = ShareName->Length;
        pktContext->ShareName.Buffer = pktContext->DomainName.Buffer + pktContext->DomainName.MaximumLength;
        RtlCopyUnicodeString(&pktContext->ShareName, ShareName);

        pktContext->ContextBool = CSCAgentCreate;
        pktContext->Type =  REFERRAL_TYPE_GET_PKT;
        pktContext->RefCnt = 2;

        Status = PktPostSystemWork( pktContext, NULL);
    } 
    else {
        Status = _PktGetReferral( MachineName,
                                  DomainName,
                                  ShareName,
                                  CSCAgentCreate );
    }

    return Status;
}

NTSTATUS
PktExpandSpecialName(
    IN PUNICODE_STRING Name,
    PDFS_SPECIAL_ENTRY *ppSpecialEntry)
{
    PPKT_REFERRAL_CONTEXT pktContext = NULL;
    NTSTATUS Status;

    ULONG NameSize = 0;

    NameSize = Name->Length * sizeof(WCHAR);

    if ((MupUseNullSessionForDfs == TRUE) &&
	(PsGetCurrentProcess() != DfsData.OurProcess)) {
       pktContext = ExAllocatePoolWithTag( NonPagedPool,
                                           sizeof (PKT_REFERRAL_CONTEXT) + NameSize,
                                           ' puM');
    }
    if (pktContext != NULL) {
        pktContext->ContextName.MaximumLength = Name->Length;
        pktContext->ContextName.Buffer = (WCHAR *)(pktContext + 1);
        RtlCopyUnicodeString(&pktContext->ContextName, Name);

        pktContext->Type = REFERRAL_TYPE_EXPAND_SPECIAL_TABLE;
        pktContext->RefCnt = 2;
        pktContext->Data = NULL;

        Status = PktPostSystemWork( pktContext, (PVOID *)ppSpecialEntry );
    }
    else {
        Status = _PktExpandSpecialName( Name, 
                                        ppSpecialEntry );
    }

    return Status;
}

NTSTATUS
PktGetSpecialReferralTable(
    IN PUNICODE_STRING Machine,
    BOOLEAN SystemDC)
{
    PPKT_REFERRAL_CONTEXT pktContext = NULL;
    NTSTATUS Status;

    ULONG NameSize = 0;

    NameSize = Machine->Length * sizeof(WCHAR);

    if ((MupUseNullSessionForDfs == TRUE) &&
	(PsGetCurrentProcess() != DfsData.OurProcess)) {
       pktContext = ExAllocatePoolWithTag( NonPagedPool,
                                           sizeof (PKT_REFERRAL_CONTEXT) + NameSize,
                                           ' puM');
    }
    if (pktContext != NULL) {
        pktContext->ContextName.MaximumLength = Machine->Length;
        pktContext->ContextName.Buffer = (WCHAR *)(pktContext + 1);
        RtlCopyUnicodeString(&pktContext->ContextName, Machine);

        pktContext->ContextBool = SystemDC;
        pktContext->Type = REFERRAL_TYPE_GET_REFERRAL_TABLE;
        pktContext->RefCnt = 2;

        Status = PktPostSystemWork( pktContext, NULL );
    } 
    else {
        Status = _PktGetSpecialReferralTable( Machine,
                                              SystemDC );
    }

    return Status;
}






NTSTATUS
PktGetTargetInfo( 
    HANDLE IpcHandle,
    PUNICODE_STRING pDomainName,
    PUNICODE_STRING pShareName,
    PDFS_TARGET_INFO *ppDfsTargetInfo )
{
    BOOLEAN SpecialName;
    PDFS_TARGET_INFO pDfsTargetInfo = NULL;
    NTSTATUS Status;


    SpecialName = (PktLookupSpecialNameEntry(pDomainName) == NULL) ? FALSE : TRUE;
    if ((SpecialName == FALSE) &&
	DfspIsSysVolShare(pShareName)) {
	SpecialName = TRUE;
    }

    if (SpecialName)
    {
        Status = PktCreateTargetInfo( pDomainName, 
                                      pShareName, 
                                      SpecialName,
                                      &pDfsTargetInfo );
    }
    else {
        Status = DfsGetLMRTargetInfo( IpcHandle,
                                      &pDfsTargetInfo );

        if (Status != STATUS_SUCCESS)
        {
            Status = PktCreateTargetInfo( pDomainName, 
                                          pShareName, 
                                          SpecialName,
                                          &pDfsTargetInfo );
        }
    }
    if (Status == STATUS_SUCCESS)
    {
        pDfsTargetInfo->DfsHeader.Type = 'grTM';
        pDfsTargetInfo->DfsHeader.UseCount=1;

        *ppDfsTargetInfo = pDfsTargetInfo;

    }


    return Status;
}
    
#define MAX_TARGET_INFO_RETRIES 3

NTSTATUS
DfsGetLMRTargetInfo(
    HANDLE IpcHandle,
    PDFS_TARGET_INFO *ppTargetInfo )
{
    ULONG TargetInfoSize, DfsTargetInfoSize;

    PDFS_TARGET_INFO pDfsTargetInfo;
    NTSTATUS Status = STATUS_SUCCESS;
    IO_STATUS_BLOCK ioStatusBlock;
    ULONG Retry = 0;
    TargetInfoSize = sizeof(LMR_QUERY_TARGET_INFO) + MAX_PATH;

TargetInfoRetry:
    DfsTargetInfoSize = TargetInfoSize + sizeof(DFS_TARGET_INFO_HEADER) + sizeof(ULONG);

    pDfsTargetInfo = ExAllocatePoolWithTag( PagedPool,
                                            DfsTargetInfoSize,
                                            ' puM');

    if (pDfsTargetInfo == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (Status == STATUS_SUCCESS)
    {
        RtlZeroMemory( pDfsTargetInfo, DfsTargetInfoSize );

        pDfsTargetInfo->LMRTargetInfo.BufferLength = TargetInfoSize;

        Status = ZwFsControlFile(
            IpcHandle,
            NULL,
            NULL,
            NULL,
            &ioStatusBlock,
            FSCTL_LMR_QUERY_TARGET_INFO,
            NULL,
            0,
            &pDfsTargetInfo->LMRTargetInfo,
            TargetInfoSize );

        if (Status == STATUS_BUFFER_TOO_SMALL) {
            TargetInfoSize = pDfsTargetInfo->LMRTargetInfo.BufferLength;

            ExFreePool( pDfsTargetInfo );
            pDfsTargetInfo = NULL;

            if (Retry++ < MAX_TARGET_INFO_RETRIES)
            {
                Status = STATUS_SUCCESS;
                goto TargetInfoRetry;
            }
        }
    }
    if (Status == STATUS_SUCCESS)
    {
        pDfsTargetInfo->DfsHeader.Flags = TARGET_INFO_LMR;
        *ppTargetInfo = pDfsTargetInfo;
    }
    else
    {
        if (pDfsTargetInfo != NULL)
        {
            ExFreePool(pDfsTargetInfo);
        }
    }
    return Status;
}

VOID
PktAcquireTargetInfo(
    PDFS_TARGET_INFO pDfsTargetInfo)
{
    ULONG Count;

    if (pDfsTargetInfo != NULL)
    {
        Count = InterlockedIncrement( &pDfsTargetInfo->DfsHeader.UseCount);
    }

    return;
}

VOID
PktReleaseTargetInfo(
    PDFS_TARGET_INFO pDfsTargetInfo)
{
    LONG Count;

    if (pDfsTargetInfo != NULL)
    {
        Count = InterlockedDecrement( &pDfsTargetInfo->DfsHeader.UseCount);
        if (Count == 0)
        {
            ExFreePool(pDfsTargetInfo);
        }
    }
    return;
}



NTSTATUS 
PktCreateTargetInfo(
    PUNICODE_STRING pDomainName,
    PUNICODE_STRING pShareName,
    BOOLEAN SpecialName,
    PDFS_TARGET_INFO *ppDfsTargetInfo )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG TargetInfoSize;
    PDFS_TARGET_INFO pDfsTargetInfo;
    PCREDENTIAL_TARGET_INFORMATIONW pTargetInfo;
    LPWSTR StringBuf;

    TargetInfoSize = sizeof(DFS_TARGET_INFO) + 
                     sizeof(UNICODE_PATH_SEP)+
                     pDomainName->Length + 
                     sizeof(UNICODE_PATH_SEP) + 
                     pShareName->Length +
                     sizeof(WCHAR) +
                     pDomainName->Length + 
                     sizeof(WCHAR);

    pDfsTargetInfo = ExAllocatePoolWithTag( PagedPool,
                                            TargetInfoSize,
                                            ' puM' );
    if (pDfsTargetInfo == NULL)
     {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    else {
        RtlZeroMemory(pDfsTargetInfo,
                      TargetInfoSize);

        pDfsTargetInfo->DfsHeader.Flags = TARGET_INFO_DFS;

        pTargetInfo = &pDfsTargetInfo->TargetInfo;
        StringBuf = (LPWSTR)(pTargetInfo + 1);
            
        pTargetInfo->TargetName = StringBuf;

        RtlCopyMemory( StringBuf,
                       pDomainName->Buffer,
                       pDomainName->Length);
        StringBuf += (pDomainName->Length / sizeof(WCHAR));
        *StringBuf++ = UNICODE_PATH_SEP;
        RtlCopyMemory( StringBuf,
                       pShareName->Buffer,
                       pShareName->Length);
        StringBuf += (pShareName->Length / sizeof(WCHAR));
        *StringBuf++ =  0;

        pTargetInfo->DnsServerName = StringBuf;
        RtlCopyMemory( StringBuf,
                       pDomainName->Buffer,
                       pDomainName->Length);
        StringBuf += (pDomainName->Length / sizeof(WCHAR));
        *StringBuf++ =  0;

        //
        // Add this flag AFTER lab03 RI's, to prevent failure
        //

        pTargetInfo->Flags = CRED_TI_CREATE_EXPLICIT_CRED;

        pTargetInfo->Flags |= CRED_TI_SERVER_FORMAT_UNKNOWN;
        if (SpecialName == TRUE)
        {
            pTargetInfo->DnsDomainName = 
                pTargetInfo->DnsServerName;
            pTargetInfo->Flags |= CRED_TI_DOMAIN_FORMAT_UNKNOWN;
        }
        *ppDfsTargetInfo = pDfsTargetInfo;
    }
    return Status;
}





BOOLEAN
DfsIsSpecialName(
    PUNICODE_STRING pName)
{
    BOOLEAN pktLocked;
    PDFS_PKT Pkt;
    PDFS_SPECIAL_ENTRY pSpecialEntry;
    BOOLEAN ReturnValue;

    Pkt = _GetPkt();
    PktAcquireShared(TRUE, &pktLocked);

    pSpecialEntry = PktLookupSpecialNameEntry(pName);

    PktRelease();

    //
    // We don't have any expansion for this name
    //
    if (pSpecialEntry == NULL)
    {
        ReturnValue = FALSE;
    }
    else
    {
        ReturnValue = TRUE;
    }

    return ReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\pkt.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       PKT.H
//
//  Contents:   This module defines the data structures that make up the
//              major internal part of the Partition Knowledge Table (PKT).
//              The Partition Knowledge Table is used by the Dfs file
//              system to resolve a name to a specific partition (volume).
//
//  Functions:
//
//  History:    1 May 1992  PeterCo Created.
//-----------------------------------------------------------------------------



#ifndef _PKT_
#define _PKT_

//
// Pick up marshalling info for gluons
//

#include "dfsgluon.h"

//
// New Prefix Table Implementation
//
#include "prefix.h"

//
//  For determining the status of the Uid
//
#define GuidEqual(g1, g2)\
    (RtlCompareMemory((g1), (g2), sizeof(GUID)) == sizeof(GUID))

extern GUID _TheNullGuid;

#define NullGuid( guid )\
    (GuidEqual(guid, &_TheNullGuid))




//
//  Defines for Create Dispositions (we mimic the io system here).
//

#define PKT_ENTRY_CREATE            FILE_CREATE
#define PKT_ENTRY_REPLACE           FILE_OPEN
#define PKT_ENTRY_SUPERSEDE         FILE_SUPERSEDE

//
//  Different kind of referrals that a DC can give out.
//

#define DFS_STORAGE_REFERRAL                    (0x0001)
#define DFS_REFERRAL_REFERRAL                   (0x0002)

//
//  Types of service that can be supported by a provider.
//  A disjunction of any of the following values.
//

#define DFS_SERVICE_TYPE_MASTER                 (0x0001)
#define DFS_SERVICE_TYPE_READONLY               (0x0002)
#define DFS_SERVICE_TYPE_LOCAL                  (0x0004)
#define DFS_SERVICE_TYPE_REFERRAL               (0x0008)
#define DFS_SERVICE_TYPE_ACTIVE                 (0x0010)
#define DFS_SERVICE_TYPE_DOWN_LEVEL             (0x0020)
#define DFS_SERVICE_TYPE_COSTLIER               (0x0040)
#define DFS_SERVICE_TYPE_OFFLINE                (0x0080)

//
//  The status possibilities...
//

#define DFS_SERVICE_STATUS_VERIFIED     (0x0001)
#define DFS_SERVICE_STATUS_UNVERIFIED   (0x0002)

//
//  Types of Partition Knowledge Table Entries.
//  Low-order bits in these definitions correspond to volume object
//  types as defined in dfsh.idl.  High-order bits are specific
//  to PKT entries.
//

#define PKT_ENTRY_TYPE_DFS              0x0001   // Entry is to Dfs Aware srv
#define PKT_ENTRY_TYPE_MACHINE          0x0002   // Entry is a machine volume
#define PKT_ENTRY_TYPE_NONDFS           0x0004   // Entry refers to downlevel
#define PKT_ENTRY_TYPE_LEAFONLY         0x0008
#define PKT_ENTRY_TYPE_OUTSIDE_MY_DOM   0x0010   // Entry refers to volume in
                                                 // foreign domain
#define PKT_ENTRY_TYPE_SYSVOL           0x0040   // Sysvol
#define PKT_ENTRY_TYPE_REFERRAL_SVC     0x0080   // Entry refers to a DC

#define PKT_ENTRY_TYPE_PERMANENT        0x0100   // Entry cannot be scavenged
#define PKT_ENTRY_TYPE_DELETE_PENDING   0x0200   // Entry has pending delete
#define PKT_ENTRY_TYPE_LOCAL            0x0400   // Entry refers to local vol
#define PKT_ENTRY_TYPE_LOCAL_XPOINT     0x0800   // Entry refers to exit pt
#define PKT_ENTRY_TYPE_OFFLINE          0x2000   // Entry refers to a volume
                                                 // that is offline

//
// Type of messages the driver can send to DfsManager / DfsService
//

#define DFS_MSGTYPE_KNOW_INCONSISTENCY  0x0001
#define DFS_MSGTYPE_GET_DOMAIN_REFERRAL 0x0002
#define DFS_MSGTYPE_GET_DC_NAME         0x0003


//
//  There is one DFS_MACHINE_ENTRY for every unique DS_MACHINE that the
//  Dfs driver knows about. If a particular cairo server services multiple Dfs
//  volumes, then multiple DFS_SERVICE structs will point to a single, ref
//  counted DFS_MACHINE_ENTRY.
//

typedef struct DFS_MACHINE_ENTRY {

    PDS_MACHINE         pMachine;       // The addressing info is here.
    UNICODE_STRING      MachineName;    // The MachineName (principalName).
    ULONG               UseCount;       // Number of DFS_SVC structs using this
    ULONG               ConnectionCount;// The number of pkt entries that are
                                        // using this as their active machine
    PFILE_OBJECT        AuthConn;       // Handle to the tree connect with
    struct _DFS_CREDENTIALS *Credentials; // these credentials.
    UNICODE_PREFIX_TABLE_ENTRY  PrefixTableEntry;

} DFS_MACHINE_ENTRY, *PDFS_MACHINE_ENTRY;

//
// Marshalling info for DFS_MACHINE_ENTRY
//

extern MARSHAL_INFO MiMachineEntry;

#define INIT_DFS_MACHINE_ENTRY_MARSHAL_INFO()                               \
    static MARSHAL_TYPE_INFO _MCode_Machine_Entry[] = {                     \
        _MCode_pstruct(DFS_MACHINE_ENTRY, pMachine, &MiDSMachine)           \
    };                                                                      \
    MARSHAL_INFO MiMachineEntry = _mkMarshalInfo(DFS_SERVICE, _MCode_Machine_Entry);


//
//  A DFS_SERVICE structure is used to describe the provider and
//  network address to be contacted for a specific partition of
//  the distributed file system.
//

typedef struct _DFS_SERVICE {

    ULONG Type;             // type of service (see above)
    ULONG Capability;       // capability of this service
    ULONG ProviderId;       // identifies which provider
    UNICODE_STRING Name;    // service name (for authentication)
    PFILE_OBJECT ConnFile;  // FileObject for tree conn to IPC$ of server
    struct _PROVIDER_DEF* pProvider;    // pointer to provider definition
    UNICODE_STRING Address; // network address
    PDFS_MACHINE_ENTRY  pMachEntry;  // The addressing info is here.
    ULONG Cost;             // The site based cost of this service.

} DFS_SERVICE, *PDFS_SERVICE;

//
//  Marshalling information for DFS_SERVICE
//
//  NOTE:       ConnFile and pProvider have significance only to the driver and
//              are not marshalled.
//
extern MARSHAL_INFO MiService;

#define INIT_DFS_SERVICE_MARSHAL_INFO()                                     \
    static MARSHAL_TYPE_INFO _MCode_Service[] = {                           \
        _MCode_ul(DFS_SERVICE, Type),                                       \
        _MCode_ul(DFS_SERVICE, Capability),                                 \
        _MCode_ul(DFS_SERVICE, ProviderId),                                 \
        _MCode_ustr(DFS_SERVICE, Name),                                     \
        _MCode_ustr(DFS_SERVICE, Address),                                  \
        _MCode_pstruct(DFS_SERVICE, pMachEntry, &MiMachineEntry)            \
    };                                                                      \
    MARSHAL_INFO MiService = _mkMarshalInfo(DFS_SERVICE, _MCode_Service);


//
//  Structure used in FSCTL_DFS_UPDATE_MACH_ADDRESS
//

typedef struct _DFS_MACHINE_INFO        {

    UNICODE_STRING      MachineName;    // Name of Machine (prefix alone).
    PDS_MACHINE         pMachine;       // The new addressing info is here

} DFS_MACHINE_INFO, *PDFS_MACHINE_INFO;

//
// Marshalling info for DFS_MACHINE_INFO
//

extern MARSHAL_INFO MiDfsMachineInfo;

#define INIT_DFS_MACHINE_INFO()                                         \
    static MARSHAL_TYPE_INFO _MCode_MachineInfo[] = {                   \
        _MCode_ustr(DFS_MACHINE_INFO, MachineName),                     \
        _MCode_pstruct(DFS_MACHINE_INFO, pMachine, &MiDSMachine)        \
    };                                                                  \
    MARSHAL_INFO MiDfsMachineInfo =                                     \
                _mkMarshalInfo(DFS_MACHINE_INFO, _MCode_MachineInfo);



//
//  How a partition table entry is identified.
//
typedef struct _DFS_PKT_ENTRY_ID {

    GUID Uid;               // a unique identifier for this partition
    UNICODE_STRING Prefix;  //  The entry path prefix of this partition
    UNICODE_STRING ShortPrefix; // The 8.3 form of entry path prefix

} DFS_PKT_ENTRY_ID, *PDFS_PKT_ENTRY_ID;

//
// Marshalling information for DFS_PKT_ENTRY_ID
//
extern MARSHAL_INFO MiPktEntryId;

#define INIT_DFS_PKT_ENTRY_ID_MARSHAL_INFO()                                \
    static MARSHAL_TYPE_INFO _MCode_PktEntryId[] = {                        \
        _MCode_guid(DFS_PKT_ENTRY_ID, Uid),                                 \
        _MCode_ustr(DFS_PKT_ENTRY_ID, Prefix)                               \
    };                                                                      \
    MARSHAL_INFO MiPktEntryId =                                             \
        _mkMarshalInfo(DFS_PKT_ENTRY_ID, _MCode_PktEntryId);


//
//  The guts of a partition table entry
//
typedef struct _DFS_PKT_ENTRY_INFO {

    ULONG ServiceCount;         // number of services in list
    PDFS_SERVICE ServiceList;   // array of servers that support the partition

} DFS_PKT_ENTRY_INFO, *PDFS_PKT_ENTRY_INFO;

typedef struct _DFS_TARGET_INFO_HEADER {
    ULONG Type;
    LONG UseCount;
    ULONG Flags;
} DFS_TARGET_INFO_HEADER, *PDFS_TARGET_INFO_HEADER;

#define TARGET_INFO_DFS 1
#define TARGET_INFO_LMR 2

typedef struct _DFS_TARGET_INFO {
    DFS_TARGET_INFO_HEADER DfsHeader;
    union {
        CREDENTIAL_TARGET_INFORMATIONW TargetInfo;
        LMR_QUERY_TARGET_INFO  LMRTargetInfo;
    };
} DFS_TARGET_INFO, *PDFS_TARGET_INFO;

NTSTATUS
PktGetTargetInfo( 
    HANDLE IpcHandle,
    PUNICODE_STRING pDomainName,
    PUNICODE_STRING pShareName,
    PDFS_TARGET_INFO *ppTargetInfo );

VOID
PktAcquireTargetInfo(
    pTargetInfo);

VOID
PktReleaseTargetInfo(
    pTargetInfo);



//
// Marshalling information for DFS_PKT_ENTRY_INFO
//
extern MARSHAL_INFO MiPktEntryInfo;

#define INIT_DFS_PKT_ENTRY_INFO_MARSHAL_INFO()                              \
    static MARSHAL_TYPE_INFO _MCode_PktEntryInfo[] = {                      \
        _MCode_ul(DFS_PKT_ENTRY_INFO, ServiceCount),                        \
        _MCode_pcastruct(DFS_PKT_ENTRY_INFO,ServiceList,ServiceCount,&MiService)\
    };                                                                      \
    MARSHAL_INFO MiPktEntryInfo =                                           \
        _mkMarshalInfo(DFS_PKT_ENTRY_INFO, _MCode_PktEntryInfo);



//
//  A Partition Knowledge Table Entry (PktEntry) identifies each known
//  partition.
//

typedef struct _DFS_PKT_ENTRY {

    NODE_TYPE_CODE NodeTypeCode;    // node type -> DSFS_NTC_PKT_ENTRY
    NODE_BYTE_SIZE NodeByteSize;    // node size
    LIST_ENTRY Link;                // link for PKT EntryList
    ULONG Type;                     // type of partition (see above)
    ULONG USN;                      // Unique Serial Number
    DFS_PKT_ENTRY_ID Id;            // the Id of this entry
    DFS_PKT_ENTRY_INFO Info;        // info of this entry
    ULONG ExpireTime;               // time when partition should be deleted
    ULONG TimeToLive;               // time to keep this entry in the cache
    ULONG UseCount;                 // # threads (DnrContexts) are looking at it.
    ULONG FileOpenCount;            // # of files opened via this entry
    PDFS_TARGET_INFO pDfsTargetInfo;
    PDFS_SERVICE ActiveService;     // pointer into info to active service
    PDFS_SERVICE LocalService;      // pointer to local service (if any)
    struct _DFS_PKT_ENTRY *Superior;// this entrys  superior (if any)
    ULONG SubordinateCount;         // number of subordinates (if any)
    LIST_ENTRY SubordinateList;     // list of subordinates (if any)
    LIST_ENTRY SiblingLink;         // link to other siblings (if any)
    struct _DFS_PKT_ENTRY *ClosestDC; // Link to closest superiorDC in PKT.
    LIST_ENTRY ChildList;           // Link to subordinate PKT entries (if any)
    LIST_ENTRY NextLink;            // Link to link up parent's Subord list.
    UNICODE_PREFIX_TABLE_ENTRY PrefixTableEntry;// prefix table entry

} DFS_PKT_ENTRY, *PDFS_PKT_ENTRY;

//
// Marshalling information for DFS_PKT_ENTRY
//
// Note that we only marshal the id and the info...no relational info
//
//
extern MARSHAL_INFO MiPktEntry;

#define INIT_DFS_PKT_ENTRY_MARSHAL_INFO()                                   \
    static MARSHAL_TYPE_INFO _MCode_PktEntry[] = {                          \
        _MCode_ul(DFS_PKT_ENTRY, Type),                                     \
        _MCode_struct(DFS_PKT_ENTRY, Id, &MiPktEntryId),                    \
        _MCode_struct(DFS_PKT_ENTRY, Info, &MiPktEntryInfo)                 \
    };                                                                      \
    MARSHAL_INFO MiPktEntry = _mkMarshalInfo(DFS_PKT_ENTRY, _MCode_PktEntry);

//
//  A special entry table contains a special name and a list of expanded
//  names.
//

typedef struct _DFS_EXPANDED_NAME {

    UNICODE_STRING ExpandedName;    // expanded name itself
    GUID Guid;                      // GUID associated with this name;

} DFS_EXPANDED_NAME, *PDFS_EXPANDED_NAME;

typedef struct _DFS_SPECIAL_ENTRY {

    NODE_TYPE_CODE NodeTypeCode;        // node type -> DSFS_NTC_SPECIAL_ENTRY
    NODE_BYTE_SIZE NodeByteSize;        // node size
    LIST_ENTRY Link;                    // link for PKT SpecialEntryList
    ULONG USN;                          // unique serial number
    ULONG UseCount;                     // # threads (DnrContexts) are looking at it.
    UNICODE_STRING SpecialName;         // Special name itself
    ULONG ExpandedCount;                // count of expanded names
    ULONG Active;                       // active expanded name
    UNICODE_STRING DCName;              // DC to go to, to get referrals
    PDFS_EXPANDED_NAME ExpandedNames;   // the expanded names
    BOOLEAN NeedsExpansion;             // need to expand this name
    BOOLEAN Stale;                      // Entry has gone stale
    BOOLEAN GotDCReferral;              // This domain name has already 
                                        // been checked for
} DFS_SPECIAL_ENTRY, *PDFS_SPECIAL_ENTRY;

typedef struct _DFS_SPECIAL_TABLE {

    LIST_ENTRY SpecialEntryList;        // list of special entries in the PKT
    ULONG SpecialEntryCount;            // number of special entries in the PKT
    ULONG TimeToLive;                   // time when table should be deleted

} DFS_SPECIAL_TABLE, *PDFS_SPECIAL_TABLE;



//
//  A Parition Knowledge Table encapsulates all the knowledge that has
//  been obtained about partitions in the distributed file system. There
//  is only one instance of this struct in the entire system, and is
//  part of the DsData structure.
//

typedef struct _DFS_PKT {

    NODE_TYPE_CODE NodeTypeCode;        // node type -> DSFS_NTC_PKT
    NODE_BYTE_SIZE NodeByteSize;        // node size...
    ERESOURCE Resource;                 // resource to guard access to Pkt
    KSPIN_LOCK  UseCountLock;           // Use while changing UseCount
    ULONG EntryCount;                   // number of entries in the PKT
    ULONG EntryTimeToLive;              // time to live for each entry
    LIST_ENTRY EntryList;               // list of entries in the PKT
    UNICODE_STRING DCName;              // where to go for expanded referrals
    UNICODE_STRING DomainNameFlat;      // our domain name (flat)
    UNICODE_STRING DomainNameDns;       // our domain in dns format
    DFS_SPECIAL_TABLE SpecialTable;     // special entry table
    DFS_PREFIX_TABLE PrefixTable;       // prefix table
    DFS_PREFIX_TABLE ShortPrefixTable;  // prefix table for 8.3 names
    UNICODE_PREFIX_TABLE DSMachineTable;// Table for DSMachines

} DFS_PKT, *PDFS_PKT;

#ifndef _UPKT_

//
//  PARTITION KNOWLEDGE TABLE PUBLIC INLINE FUNCTIONS
//

#define _GetPkt()       (&DfsData.Pkt)

//+-------------------------------------------------------------------------
//
//  Function:   PktAcquireShared, public inline
//
//  Synopsis:   PktAcquireShared acquires the partition knowledge table
//              for shared access.
//
//  Arguments:  [WaitOk] - indicates if the call is allowed to wait for
//                      the PKT to become available or must return immediately
//              [Result] - Pointer to boolean that will receive result of
//                      lock acquisition
//
//  Returns:    Nothing
//
//  Notes:      We first check to see if there are any threads waiting to
//              update the Pkt. If so, we hold off until that thread has
//              finished before we acquire a shared lock on the Pkt.
//              Under NT, a thread waiting to acquire a resource exclusive
//              does !not! automatically prevent threads from acquiring it
//              shared. This is necessary to allow for recursive acquisition
//              of resources. So, this event mechanism is required.
//
//--------------------------------------------------------------------------
#define PktAcquireShared( WaitOk, Result )      \
{                                               \
    KeWaitForSingleObject(                      \
        &DfsData.PktWritePending,               \
        UserRequest,                            \
        KernelMode,                             \
        FALSE,                                  \
        NULL);                                  \
    *(Result) = ExAcquireResourceSharedLite(        \
                &DfsData.Pkt.Resource,          \
                WaitOk );                       \
}

//+-------------------------------------------------------------------------
//
//  Function:   PktAcquireExclusive, public inline
//
//  Synopsis:   PktAcquireExclusive acquires the partition knowledge table
//              for exclusive access.
//
//  Arguments:  [WaitOk] - indicates if the call is allowed to wait for
//                  the PKT to become available or must return immediately.
//              [Result] - Pointer to boolean that will receive result of
//                      lock acquisition
//
//  Returns:    Nothing
//
//  Notes:
//
//--------------------------------------------------------------------------
#define PktAcquireExclusive( WaitOk, Result )   \
{                                               \
    KeResetEvent(&DfsData.PktWritePending);     \
    *(Result) = ExAcquireResourceExclusiveLite(     \
                    &DfsData.Pkt.Resource,      \
                    WaitOk );                   \
}


//+-------------------------------------------------------------------------
//
//  Function:   PktRelease, public inline
//
//  Synopsis:   PktRelease releases the PKT.  It can have been acquired
//              for exclusive or shared access.
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Notes:
//
//--------------------------------------------------------------------------
#define PktRelease()                            \
{                                               \
    ExReleaseResourceLite( &DfsData.Pkt.Resource ); \
    KeSetEvent(                                 \
        &DfsData.PktWritePending,               \
        0,                                      \
        FALSE);                                 \
}

//+----------------------------------------------------------------------------
//
//  Function:   PktConvertExclusiveToShared, public inline
//
//  Synopsis:   Converts an exclusive lock on Pkt to a shared lock
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

#define PktConvertExclusiveToShared()                           \
{                                                               \
    ExConvertExclusiveToSharedLite( &DfsData.Pkt.Resource );        \
    KeSetEvent(&DfsData.PktWritePending, 0, FALSE);             \
}

//+----------------------------------------------------------------------------
//
//  Function:   PKT_LOCKED_FOR_SHARED_ACCESS, public inline
//
//  Synopsis:   Returns TRUE if Pkt is locked for shared access, FALSE if not
//
//  Arguments:  None
//
//  Returns:    TRUE if Pkt is locked for shared access, FALSE otherwise
//
//-----------------------------------------------------------------------------

#define PKT_LOCKED_FOR_SHARED_ACCESS()      \
    ( ExIsResourceAcquiredSharedLite( &DfsData.Pkt.Resource ) )

//+----------------------------------------------------------------------------
//
//  Function:   PKT_LOCKED_FOR_EXCLUSIVE_ACCESS, public inline
//
//  Synopsis:   Returns TRUE if Pkt is locked for exclusive access, FALSE if
//              not
//
//  Arguments:  None
//
//  Returns:    TRUE if Pkt is locked for exclusive access, FALSE otherwise
//
//-----------------------------------------------------------------------------

#define PKT_LOCKED_FOR_EXCLUSIVE_ACCESS()   \
    ( ExIsResourceAcquiredExclusiveLite( &DfsData.Pkt.Resource ) )

//+-------------------------------------------------------------------------
//
//  Function:   PktInvalidateEntry, public inline
//
//  Synopsis:   PktInvalidateEntry destroys a PKT Entry.  The entry cannot
//              be local, and it cannot be an exit point.
//
//  Arguments:  [Pkt] - pointer to an initialized PKT.
//              [Victim] - pointer to the entry to be invalidated.
//
//  Returns:    [STATUS_SUCCESS] - all is well.
//              [DFS_STATUS_LOCAL_ENTRY] - an attempt was made to
//                  invalidate a local entry, or an entry that is a
//                  local exit point.
//
//  Notes:
//
//--------------------------------------------------------------------------
#define PktInvalidateEntry(p, e) (                                          \
    ((e)->Type & (PKT_ENTRY_TYPE_LOCAL|PKT_ENTRY_TYPE_LOCAL_XPOINT))        \
    ? (DFS_STATUS_LOCAL_ENTRY)                                              \
    : (PktEntryDestroy(e, p, (BOOLEAN)TRUE), STATUS_SUCCESS)                \
    )


//+-------------------------------------------------------------------------
//
//  Function:   PktFirstEntry, public inline
//
//  Synopsis:   PktFirstEntry returns the first entry in the list of
//              PKT entries.
//
//  Arguments:  [Pkt] - pointer to an initialized PKT.
//
//  Returns:    A pointer to the first entry in the PKT, or NULL if the
//              PKT is empty.
//
//  Notes:
//
//--------------------------------------------------------------------------
#define PktFirstEntry(p) (                                                  \
    ((p)->EntryList.Flink != &(p)->EntryList)                               \
    ? (CONTAINING_RECORD((p)->EntryList.Flink, DFS_PKT_ENTRY, Link))        \
    : (NULL)                                                                \
    )

//+-------------------------------------------------------------------------
//
//  Function:   PktNextEntry, public inline
//
//  Synopsis:   PktNextEntry returns the next entry in the list of
//              PKT entries.
//
//  Arguments:  [Pkt] - pointer to an initialized PKT.
//              [Entry] - a pointer to the previous entry.
//
//  Returns:    A pointer to the next entry in the PKT, or NULL if we
//              are at the end of the list.
//
//  Notes:
//
//--------------------------------------------------------------------------
#define PktNextEntry(p, e) (                                                \
    ((e)->Link.Flink != &(p)->EntryList)                                    \
    ? (CONTAINING_RECORD((e)->Link.Flink, DFS_PKT_ENTRY, Link))             \
    : (NULL)                                                                \
    )

//+-------------------------------------------------------------------------
//
//  Function:   PktFirstSpecialEntry, public inline
//
//  Synopsis:   PktFirstSpecialEntry returns the first special entry in the list of
//              PKT entries.
//
//  Arguments:  [Pkt] - pointer to an initialized PKT.
//
//  Returns:    A pointer to the first special entry in the PKT, or NULL if the
//              PKT is empty.
//
//  Notes:
//
//--------------------------------------------------------------------------
#define PktFirstSpecialEntry(p) (                                           \
    ((p)->SpecialEntryList.Flink != &(p)->SpecialEntryList)                 \
    ? (CONTAINING_RECORD((p)->SpecialEntryList.Flink, DFS_SPECIAL_ENTRY, Link)) \
    : (NULL)                                                                \
    )

//+-------------------------------------------------------------------------
//
//  Function:   PktNextSpecialEntry, public inline
//
//  Synopsis:   PktNextSpecialEntry returns the next special entry in the list of
//              PKT entries.
//
//  Arguments:  [Pkt] - pointer to an initialized PKT.
//              [Entry] - a pointer to the previous special entry.
//
//  Returns:    A pointer to the next special entry in the PKT, or NULL if we
//              are at the end of the list.
//
//  Notes:
//
//--------------------------------------------------------------------------
#define PktNextSpecialEntry(p, e) (                                         \
    ((e)->Link.Flink != &(p)->SpecialEntryList)                             \
    ? (CONTAINING_RECORD((e)->Link.Flink, DFS_SPECIAL_ENTRY, Link))         \
    : (NULL)                                                                \
    )

//+-------------------------------------------------------------------------
//
//  Function:   PktLinkEntry, public inline
//
//  Synopsis:   PktLinkEntry links an entry into the list of entries
//              in the PKT.
//
//  Arguments:  [Pkt] - pointer to an initialized PKT.
//              [Entry] - a pointer to the entry to be linked in.
//
//  Returns:    VOID
//
//  Notes:      Care must be taken to insure that the entry is not already
//              linked into the PKT entry list before calling this routine.
//              No checking is done to prevent an entry from being linked
//              twice...
//
//--------------------------------------------------------------------------
#define PktLinkEntry(p, e) {                                                \
    InsertTailList(&(p)->EntryList, &(e)->Link);                            \
    (p)->EntryCount++;                                                      \
    }

//+-------------------------------------------------------------------------
//
//  Function:   PktUnlinkEntry, public inline
//
//  Synopsis:   PktUnlinkEntry unlinks an entry from the list of entries
//              in the PKT.
//
//  Arguments:  [Pkt] - pointer to an initialized PKT.
//              [Entry] - a pointer to the entry to be unlinked.
//
//  Returns:    VOID
//
//  Notes:      Care must be taken to insure that the entry is in fact
//              already linked into the PKT entry list before calling this
//              routine. No checking is done to prevent an entry from being
//              unlinked twice...
//
//--------------------------------------------------------------------------
#define PktUnlinkEntry(p, e) {                                              \
    RemoveEntryList(&(e)->Link);                                            \
    (p)->EntryCount--;                                                      \
    }

#define PktServiceListValidate(e)       TRUE


//
//  PARTITION KNOWLEDGE TABLE PUBLIC FUNCTIONS (pkt.c)
//

NTSTATUS
PktInitialize(
    IN  PDFS_PKT Pkt
    );

VOID
PktUninitialize(
    IN  PDFS_PKT Pkt
    );

NTSTATUS
PktCreateEntry(
    IN  PDFS_PKT Pkt,
    IN  ULONG EntryType,
    IN  PDFS_PKT_ENTRY_ID PktEntryId,
    IN  PDFS_PKT_ENTRY_INFO PktEntryInfo OPTIONAL,
    IN  ULONG CreateDisposition,
    IN  PDFS_TARGET_INFO pDfsTargetInfo,
    OUT PDFS_PKT_ENTRY *ppPktEntry
    );

NTSTATUS
PktCreateDomainEntry(
    IN  PUNICODE_STRING DomainName,
    IN  PUNICODE_STRING ShareName,
    IN  BOOLEAN         CSCAgentCreate);

NTSTATUS
PktCreateEntryFromReferral(
    IN  PDFS_PKT Pkt,
    IN  PUNICODE_STRING ReferralPath,
    IN  ULONG ReferralSize,
    IN  PVOID ReferralBuffer,
    IN  ULONG CreateDisposition,
    IN  PDFS_TARGET_INFO pDfsTargetInfo,
    OUT ULONG *MatchingLength,
    OUT ULONG *ReferralType,
    OUT PDFS_PKT_ENTRY *ppPktEntry
    );

NTSTATUS
PktExpandSpecialEntryFromReferral(
    IN  PDFS_PKT Pkt,
    IN  PUNICODE_STRING ReferralPath,
    IN  ULONG ReferralSize,
    IN  PVOID ReferralBuffer,
    IN  PDFS_SPECIAL_ENTRY pSpecialEntry
    );

VOID
PktSpecialEntryDestroy(
    IN  PDFS_SPECIAL_ENTRY pSpecialEntry
    );

NTSTATUS
PktCreateSubordinateEntry(
    IN      PDFS_PKT Pkt,
    IN      PDFS_PKT_ENTRY Superior,
    IN      ULONG SubordinateType,
    IN      PDFS_PKT_ENTRY_ID SubordinateId,
    IN      PDFS_PKT_ENTRY_INFO SubordinateInfo OPTIONAL,
    IN      ULONG CreateDisposition,
    IN  OUT PDFS_PKT_ENTRY *Subordinate
    );

PDFS_PKT_ENTRY
PktLookupEntryById(
    IN      PDFS_PKT Pkt,
    IN      PDFS_PKT_ENTRY_ID Id
    );

PDFS_PKT_ENTRY
PktLookupEntryByPrefix(
    IN  PDFS_PKT Pkt,
    IN  PUNICODE_STRING Prefix,
    OUT PUNICODE_STRING Remaining
    );

PDFS_PKT_ENTRY
PktLookupEntryByShortPrefix(
    IN  PDFS_PKT Pkt,
    IN  PUNICODE_STRING Prefix,
    OUT PUNICODE_STRING Remaining
    );

NTSTATUS
PktEntryModifyPrefix(
    IN  PDFS_PKT        Pkt,
    IN  PUNICODE_STRING LocalPath,
    IN  PDFS_PKT_ENTRY  Entry
    );

PDFS_PKT_ENTRY
PktLookupEntryByUid(
    IN  PDFS_PKT Pkt,
    IN  GUID *Uid
    );

PDFS_PKT_ENTRY
PktLookupReferralEntry(
    IN  PDFS_PKT        Pkt,
    IN  PDFS_PKT_ENTRY  pEntry
);

PDFS_PKT_ENTRY
PktGetReferralEntryForPath(
    PDFS_PKT            Pkt,
    UNICODE_STRING      Path,
    ULONG               *Type
);

//
//  DFS PKT PRIVATE FUNCTIONS (pkt.c)
//

NTSTATUS
PktpOpenDomainService(
    IN      PDFS_PKT Pkt,
    IN      PDFS_PKT_ENTRY PktEntry,
    IN  OUT PHANDLE DomainServiceHandle
    );

NTSTATUS
DfsGetMachPktEntry(
    UNICODE_STRING      Path
);

VOID
RemoveLastComponent(
    IN PUNICODE_STRING  Prefix,
    OUT PUNICODE_STRING newPrefix);


//
//  DFS SERVICE PUBLIC FUNCTIONS (pktsup.c)
//

NTSTATUS
PktServiceConstruct(
    OUT PDFS_SERVICE Service,
    IN  ULONG ServiceType,
    IN  ULONG ServiceCapability,
    IN  ULONG ServiceStatus,
    IN  ULONG ServiceProviderId,
    IN  PUNICODE_STRING ServiceName OPTIONAL,
    IN  PUNICODE_STRING ServiceAddress OPTIONAL
    );

VOID
PktServiceDestroy(
    IN  PDFS_SERVICE Victim OPTIONAL,
    IN  BOOLEAN DeallocateAll
    );

VOID
DfsDecrementMachEntryCount(
    PDFS_MACHINE_ENTRY  pMachEntry,
    BOOLEAN     DeallocateMachine
);

VOID
PktDSMachineDestroy(
    IN  PDS_MACHINE Victim OPTIONAL,
    IN  BOOLEAN DeallocateAll
    );

VOID
PktDSTransportDestroy(
    IN  PDS_TRANSPORT Victim OPTIONAL,
    IN  BOOLEAN DeallocateAll
    );


//
//  PKT ENTRY ID PUBLIC FUNCTIONS (pktsup.c)
//

NTSTATUS
PktEntryIdConstruct(
    OUT PDFS_PKT_ENTRY_ID PktEntryId,
    IN  GUID *Uid OPTIONAL,
    IN  UNICODE_STRING *Prefix OPTIONAL
    );

VOID
PktEntryIdDestroy(
    IN  PDFS_PKT_ENTRY_ID Victim OPTIONAL,
    IN  BOOLEAN DeallocateAll
    );

//
//  PKT ENTRY ID PUBLIC INLINE FUNCTIONS
//

//+-------------------------------------------------------------------------
//
//  Function:   PktEntryIdEqual, public inline
//
//  Synopsis:   PktpEntryIdEqual determines if two entry Ids are equal
//              or not.
//
//  Arguments:  [Id1] - a pointer to an Id to compare.
//              [Id2] - a pointer to an Id to compare.
//
//  Returns:    [TRUE] - if both Ids are equal.
//              [FALSE] - if the Ids are not equal.
//
//  Notes:      The comparison on the Prefix is done case insensitive.
//
//--------------------------------------------------------------------------
#define PktEntryIdEqual(Id1, Id2) (                                         \
    (GuidEqual(&(Id1)->Uid, &(Id2)->Uid)) &&                                \
    (RtlEqualUnicodeString(&(Id1)->Prefix, &(Id2)->Prefix, (BOOLEAN)TRUE))  \
    )

//
//  PKT ENTRY ID PRIVATE INLINE FUNCTIONS
//

//+-------------------------------------------------------------------------
//
//  Function:   PktpEntryIdMove, private inline
//
//  Synopsis:   PktpEntryIdMove removes the values from the source Id and
//              places them on the destination Id.
//
//  Arguments:  [DestId] - a pointer to an Id that is to receive the
//                  sources values.
//              [SrcId] - a pointer to an Id that is to be stripped of
//                  its values.
//
//  Returns:    VOID
//
//  Notes:      Any values that are currently on the destination Id are
//              overwritten.  No memory is freed (either on the source,
//              or the destination) by this call.
//
//--------------------------------------------------------------------------
#define PktpEntryIdMove(DestId, SrcId) {                                    \
    (*(DestId)) = (*(SrcId));                                               \
    (SrcId)->Prefix.Length = (SrcId)->Prefix.MaximumLength = 0;             \
    (SrcId)->Prefix.Buffer = NULL;                                          \
    (SrcId)->ShortPrefix.Length = (SrcId)->ShortPrefix.MaximumLength = 0;   \
    (SrcId)->ShortPrefix.Buffer = NULL;                                     \
    }


//
//  PKT ENTRY INFO PUBLIC FUNCTIONS (pktsup.c)
//

//NTSTATUS
//PktEntryInfoConstruct(
//    OUT PDFS_PKT_ENTRY_INFO PktEntryInfo,
//    IN  PULONG ExpireTime OPTIONAL,
//    IN  ULONG ServiceCount,
//    IN  PDFS_SERVICE ServiceList OPTIONAL
//    );

VOID
PktEntryInfoDestroy(
    IN  PDFS_PKT_ENTRY_INFO Victim OPTIONAL,
    IN  BOOLEAN DeallocateAll
    );

//
//  PKT ENTRY INFO PRIVATE INLINE FUNCTIONS
//

//
// The following inlines operate on Entry Infos
//

//+-------------------------------------------------------------------------
//
//  Function:   PktpEntryInfoMove, private inline
//
//  Synopsis:   PktpEntryInfoMove removes the values from the source Info and
//              places them on the destination Info.
//
//  Arguments:  [DestInfo] - a pointer to an Info that is to receive the
//                  sources values.
//              [SrcInfo] - a pointer to an Info that is to be stripped of
//                  its values.
//
//  Returns:    VOID
//
//  Notes:      Any values that are currently on the destination Info are
//              overwritten.  No memory is freed (either on the source,
//              or the destination) by this call.
//
//--------------------------------------------------------------------------
#define PktpEntryInfoMove(DestInfo, SrcInfo) {                          \
    (*(DestInfo)) = (*(SrcInfo));                                       \
    (SrcInfo)->ServiceCount = 0L;                                       \
    (SrcInfo)->ServiceList = NULL;                                      \
    }


//
// PKT ENTRY PUBLIC INLINE FUNCTIONS
//

//+-------------------------------------------------------------------------
//
//  Function:   PktEntryFirstSubordinate, public inline
//
//  Synopsis:   PktEntryFirstSubordinate returns the first entry in the
//              list of subordinates.
//
//  Arguments:  [Superior] - pointer to a PKT entry.
//
//  Returns:    A pointer to the first entry in the list of subordinates,
//              or NULL if the list is empty.
//
//  Notes:
//
//--------------------------------------------------------------------------
#define PktEntryFirstSubordinate(s) (                                   \
      ((s)->SubordinateList.Flink != &(s)->SubordinateList)             \
      ? (CONTAINING_RECORD((s)->SubordinateList.Flink, DFS_PKT_ENTRY,   \
                                SiblingLink))                           \
      : (NULL)                                                          \
    )

//+-------------------------------------------------------------------------
//
//  Function:   PktEntryNextSubordinate, public inline
//
//  Synopsis:   PktEntryNextSubordinate returns the next entry in the
//              list of subordinates.
//
//  Arguments:  [Superior] - pointer to the superior PKT entry (the one
//                  which we are getting the subordinates for).
//              [Subordinate] - pointer to the last subordinate retreived
//                  via this routine (or PktEntryFirstSubordinate).
//
//  Returns:    A pointer to the next entry in the list of subordinates,
//              or NULL if we've hit the end of the list.
//
//  Notes:
//
//--------------------------------------------------------------------------
#define PktEntryNextSubordinate(s, m) (                                     \
    ((m)->SiblingLink.Flink != &(s)->SubordinateList)                       \
    ? (CONTAINING_RECORD((m)->SiblingLink.Flink,DFS_PKT_ENTRY,SiblingLink))\
    : (NULL)                                                                \
    )

//+-------------------------------------------------------------------------
//
//  Function:   PktEntryLinkSubordinate, public inline
//
//  Synopsis:   PktEntryLinkSubordinate links a subordinate to a superior's
//              list of subordinates.
//
//  Arguments:  [Superior] - pointer to the superior PKT entry.
//              [Subordinate] - pointer to the subordinate to be linked in.
//
//  Returns:    VOID
//
//  Notes:      If the subordinate is part of another superior's list, it
//              will be removed from that list as a by-product of being
//              put on the specified Superior's list.  The Superior pointer
//              of the subordinate is adjusted appropriately.
//
//              If the superior is a local entry, the subordinate will
//              be modified to indicate that it is a local exit point.
//
//--------------------------------------------------------------------------
#define PktEntryLinkSubordinate(sup, sub) {                                 \
    while(1) {                                                              \
        if((sub)->Superior == (sup))                                        \
            break;                                                          \
        if((sub)->Superior != NULL)                                         \
            PktEntryUnlinkSubordinate((sub)->Superior, (sub));              \
        InsertTailList(&(sup)->SubordinateList, &(sub)->SiblingLink);       \
        (sup)->SubordinateCount++;                                          \
        (sub)->Superior = (sup);                                            \
        if((sup)->Type & PKT_ENTRY_TYPE_LOCAL)                              \
            (sub)->Type |= PKT_ENTRY_TYPE_LOCAL_XPOINT;                     \
        break;                                                              \
    }                                                                       \
    }

//+-------------------------------------------------------------------------
//
//  Function:   PktEntryUnlinkSubordinate, public inline
//
//  Synopsis:   PktEntryUnlinkSubordinate unlinks a subordinate from a
//              superior's list of subordinates.
//
//  Arguments:  [Superior] - pointer to the superior PKT entry.
//              [Subordinate] - pointer to the subordinate to be unlinked.
//
//  Returns:    VOID
//
//  Notes:      The Superior pointer of the subordinate is NULLed as a
//              by-product of this operation.
//
//              By default, the subordinate is modified to indicate that
//              it is not an exit point (it cannot be an exit point if it
//              has no superior).
//
//              Milans - We need to turn off the PKT_ENTRY_TYPE_PERMANENT
//              bit if the PKT_ENTRY_TYPE_LOCAL bit is not set, and we are
//              not the DC. If we decide that a machine can be a server for
//              a volume in another domain, then we need to do something
//              about the != DS_DC clause.
//
//--------------------------------------------------------------------------
#define PktEntryUnlinkSubordinate(sup, sub) {                               \
    ASSERT((sub)->Superior == (sup));                                       \
    ASSERT((sup)->SubordinateCount > 0);                                    \
    RemoveEntryList(&(sub)->SiblingLink);                                   \
    (sup)->SubordinateCount--;                                              \
    (sub)->Superior = NULL;                                                 \
    (sub)->Type &= ~PKT_ENTRY_TYPE_LOCAL_XPOINT;                            \
    if ( DfsData.MachineState != DFS_ROOT_SERVER &&                         \
         (((sub)->Type & PKT_ENTRY_TYPE_LOCAL) == 0) ) {                    \
         (sub)->Type &= ~PKT_ENTRY_TYPE_PERMANENT;                          \
    }                                                                       \
}

//
// The following set of inline functions work on the Links maintained in
// the PKT to be able to get to referral entries for interdomain stuff real
// fast. These functions are similar to the above functions.
//

//+-------------------------------------------------------------------------
//
//  Function:   PktEntryFirstChild, public inline
//
//  Synopsis:   PktEntryFirstChild returns the first entry in the
//              list of child links of a PKT entry.
//
//  Arguments:  [SuperiorDC] - pointer to a PKT entry.
//
//  Returns:    A pointer to the first entry in the list of children,
//              or NULL if the list is empty.
//
//  Notes:
//
//--------------------------------------------------------------------------
#define PktEntryFirstChild(s) (                                         \
    ((s)->ChildList.Flink != &(s)->ChildList)                           \
    ? (CONTAINING_RECORD((s)->ChildList.Flink,DFS_PKT_ENTRY,NextLink))  \
    : (NULL)                                                            \
    )

//+-------------------------------------------------------------------------
//
//  Function:   PktEntryNextChild, public inline
//
//  Synopsis:   PktEntryNextChild returns the next entry in the
//              list of children.
//
//  Arguments:  [Superior] - pointer to the superior PKT entry (the one
//                  which we are getting the subordinates for).
//              [Subordinate] - pointer to the last child retreived
//                  via this routine (or PktEntryFirstChild).
//
//  Returns:    A pointer to the next entry in the list of children,
//              or NULL if we've hit the end of the list.
//
//  Notes:
//
//--------------------------------------------------------------------------
#define PktEntryNextChild(s, m) (                                       \
    ((m)->NextLink.Flink != &(s)->ChildList)                            \
    ? (CONTAINING_RECORD((m)->NextLink.Flink,DFS_PKT_ENTRY,NextLink))   \
    : (NULL)                                                            \
    )

//+-------------------------------------------------------------------------
//
//  Function:   PktEntryLinkChild, public inline
//
//  Synopsis:   PktEntryLinkChild links a child to a closestDC's
//              list of children.
//
//  Arguments:  [Superior] - pointer to the superior PKT entry.
//              [Subordinate] - pointer to the subordinate to be linked in.
//
//  Returns:    VOID
//
//  Notes:      If the child is part of another superior's list, it
//              will be removed from that list as a by-product of being
//              put on the specified Superior's list.  The Superior pointer
//              of the child is adjusted appropriately.
//
//
//--------------------------------------------------------------------------
#define PktEntryLinkChild(sup, sub) {                                     \
    while(1) {                                                            \
        if (sub == sup) {                                                 \
            (sub)->ClosestDC = NULL;                                      \
            break;                                                        \
        }                                                                 \
        if((sub)->ClosestDC == (sup))                                     \
            break;                                                        \
        if((sub)->ClosestDC != NULL)                                      \
            PktEntryUnlinkChild((sub)->ClosestDC, (sub));                 \
        InsertTailList(&(sup)->ChildList, &(sub)->NextLink);              \
        (sub)->ClosestDC = (sup);                                         \
        break;                                                            \
    }                                                                     \
    }

//+-------------------------------------------------------------------------
//
//  Function:   PktEntryUnlinkChild, public inline
//
//  Synopsis:   PktEntryUnlinkChild unlinks a child from a
//              superior's list of children.
//
//  Arguments:  [Superior] - pointer to the superior PKT entry.
//              [Subordinate] - pointer to the subordinate to be unlinked.
//
//  Returns:    VOID
//
//  Notes:      The Superior pointer of the child is NULLed as a
//              by-product of this operation.
//
//
//--------------------------------------------------------------------------
#define PktEntryUnlinkChild(sup, sub) {                                  \
    ASSERT((sub)->ClosestDC == (sup));                                   \
    RemoveEntryList(&(sub)->NextLink);                                   \
    (sub)->ClosestDC = NULL;                                             \
    }

//+-------------------------------------------------------------------------
//
//  Function:   PktEntryUnlinkAndRelinkChild, public inline
//
//  Synopsis:   PktEntryUnlinkAndRelinkChild unlinks a child from a
//              superior's list of children and relinks it to the parent of
//              the superior.
//
//  Arguments:  [Superior] - pointer to the superior PKT entry.
//              [Subordinate] - pointer to the subordinate to be unlinked.
//
//  Returns:    VOID
//
//--------------------------------------------------------------------------
#define PktEntryUnlinkAndRelinkChild(sup, sub) {                        \
    PktEntryUnlinkChild(sup, sub);                                      \
    if ((sup)->ClosestDC != NULL) {                                     \
        PktEntryLinkChild((sup)->ClosestDC, sub);                       \
    }                                                                   \
    }

//
// PKT ENTRY PUBLIC FUNCTIONS (pktsup.c)
//

NTSTATUS
PktEntryAssemble(
    IN  OUT PDFS_PKT_ENTRY Entry,
    IN      PDFS_PKT Pkt,
    IN      ULONG EntryType,
    IN      PDFS_PKT_ENTRY_ID EntryId,
    IN      PDFS_PKT_ENTRY_INFO EntryInfo OPTIONAL,
    IN  PDFS_TARGET_INFO pDfsTargetInfo
    );

NTSTATUS
PktEntryReassemble(
    IN  OUT PDFS_PKT_ENTRY Entry,
    IN      PDFS_PKT Pkt OPTIONAL,
    IN      ULONG EntryType,
    IN      PDFS_PKT_ENTRY_ID EntryId OPTIONAL,
    IN      PDFS_PKT_ENTRY_INFO EntryInfo OPTIONAL,
    IN  PDFS_TARGET_INFO pDfsTargetInfo
    );

VOID
PktEntryDestroy(
    IN  PDFS_PKT_ENTRY Victim OPTIONAL,
    IN  PDFS_PKT Pkt,
    IN  BOOLEAN DeallocateAll
    );

VOID
PktEntryClearSubordinates(
    IN      PDFS_PKT_ENTRY PktEntry
    );

VOID
PktEntryClearChildren(
    IN      PDFS_PKT_ENTRY PktEntry
    );

NTSTATUS
PktEntryCreateReferral(
    IN  PDFS_PKT_ENTRY PktEntry,
    IN  ULONG ServiceTypes,
    IN  PVOID ReferralBuffer
    );

VOID
PktParsePath(
    IN  PUNICODE_STRING PathName,
    OUT PUNICODE_STRING MachineName,
    OUT PUNICODE_STRING ShareName,
    OUT PUNICODE_STRING Remainder OPTIONAL
    );

NTSTATUS
PktExpandSpecialName(
    IN  PUNICODE_STRING Name,
    OUT PDFS_SPECIAL_ENTRY *ppSpecialEntry
    );

PDFS_SPECIAL_ENTRY
PktLookupSpecialNameEntry(
    PUNICODE_STRING Name
    );

NTSTATUS
PktCreateSpecialNameEntry(
    PDFS_SPECIAL_ENTRY pSpecialEntry
    );

NTSTATUS
PktGetDCName(
    ULONG Flags
    );

NTSTATUS
PktGetSpecialReferralTable(
    PUNICODE_STRING Machine,
    BOOLEAN Type
    );

NTSTATUS
PktCreateSpecialEntryTableFromReferral(
    IN  PDFS_PKT Pkt,
    IN  PUNICODE_STRING ReferralPath,
    IN  ULONG ReferralSize,
    IN  PVOID ReferralBuffer,
    IN  PUNICODE_STRING DCName
    );

NTSTATUS
PktEntryFromSpecialEntry(
    IN  PDFS_SPECIAL_ENTRY pSpecialEntry,
    IN  PUNICODE_STRING pShareName,
    OUT PDFS_PKT_ENTRY *ppPktEntry
    );

PDFS_PKT_ENTRY
PktFindEntryByPrefix(
    IN  PDFS_PKT Pkt,
    IN  PUNICODE_STRING Prefix
    );


#endif // NOT _UPKT_

#endif // _PKT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\nodetype.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       NODETYPE.H
//
//  Contents:
//      This module defines all of the node type codes used in this development
//      shell.  Every major data structure in the file system is assigned a
//      node type code.  This code is the first CSHORT in the structure and is
//      followed by a CSHORT containing the size, in bytes, of the structure.
//
//  Functions:
//
//  History:    12 Nov 1991     AlanW   Created from CDFS souce.
//               8 May 1992     PeterCo Removed all EP related stuff.
//                                      Added PKT related stuff.
//
//-----------------------------------------------------------------------------


#ifndef _NODETYPE_
#define _NODETYPE_

typedef CSHORT NODE_TYPE_CODE, *PNODE_TYPE_CODE;

#define NTC_UNDEFINED                   ((NODE_TYPE_CODE)0x0000)

#define DSFS_NTC_DATA_HEADER            ((NODE_TYPE_CODE)0x0D01)
#define DSFS_NTC_IRP_CONTEXT            ((NODE_TYPE_CODE)0x0D02)
#define DSFS_NTC_REFERRAL               ((NODE_TYPE_CODE)0x0D03)
#define DSFS_NTC_VCB                    ((NODE_TYPE_CODE)0x0D04)
#define DSFS_NTC_PROVIDER               ((NODE_TYPE_CODE)0x0D05)
#define DSFS_NTC_FCB_HASH               ((NODE_TYPE_CODE)0x0D06)
#define DSFS_NTC_FCB                    ((NODE_TYPE_CODE)0x0D07)
#define DSFS_NTC_DNR_CONTEXT            ((NODE_TYPE_CODE)0x0D08)
#define DSFS_NTC_PKT                    ((NODE_TYPE_CODE)0x0D09)
#define DSFS_NTC_PKT_ENTRY              ((NODE_TYPE_CODE)0x0D0A)
#define DSFS_NTC_PKT_STUB               ((NODE_TYPE_CODE)0x0D0B)
#define DSFS_NTC_INSTRUM                ((NODE_TYPE_CODE)0x0D0C)
#define DSFS_NTC_INSTRUM_FREED          ((NODE_TYPE_CODE)0x0D0D)
#define DSFS_NTC_PWSTR                  ((NODE_TYPE_CODE)0x0D0E)
#define DSFS_NTC_SPECIAL_ENTRY          ((NODE_TYPE_CODE)0x0D0F)
#define DSFS_NTC_DRT                    ((NODE_TYPE_CODE)0x0D10)

typedef CSHORT NODE_BYTE_SIZE, *PNODE_BYTE_SIZE;

//
//  So all records start with
//
//  typedef struct _RECORD_NAME {
//      NODE_TYPE_CODE NodeTypeCode;
//      NODE_BYTE_SIZE NodeByteSize;
//          :
//  } RECORD_NAME;
//  typedef RECORD_NAME *PRECORD_NAME;
//

#define NodeType(Ptr) (*((NODE_TYPE_CODE UNALIGNED *)(Ptr)))
#define NodeSize(Ptr) (*(((PNODE_BYTE_SIZE)(Ptr))+1))

#endif // _NODETYPE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\pktfsctl.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       PKTFSCTL.C
//
//  Contents:   This module contains the implementation for FS controls
//              which manipulate the PKT.
//
//  Functions:  PktFsctrlUpdateDomainKnowledge -
//              PktFsctrlGetRelationInfo -
//              PktFsctrlSetRelationInfo -
//              PktFsctrlIsChildnameLegal -
//              PktFsctrlCreateEntry -
//              PktFsctrlCreateSubordinateEntry -
//              PktFsctrlDestroyEntry -
//              PktFsctrlUpdateSiteCosts -
//              DfsFsctrlSetDCName -
//              DfsAgePktEntries - Flush PKT entries periodically
//
//              Private Functions
//
//              DfsCreateExitPathOnRoot
//              PktpHashSiteCostList
//              PktpLookupSiteCost
//              PktpUpdateSiteCosts
//              PktpSetActiveSpcService
//
//              Debug Only Functions
//
//              PktFsctrlFlushCache - Flush PKT entries on command
//              PktFsctrlFlushSpcCache - Flush SPC entries on command
//              PktFsctrlGetFirstSvc - Test hooks for testing replica
//              PktFsctrlGetNextSvc - selection.
//
//  History:    12 Jul 1993     Alanw   Created from localvol.c.
//
//-----------------------------------------------------------------------------

#include "dfsprocs.h"
#include "dfserr.h"
#include "fsctrl.h"
#include "log.h"
#include "dnr.h"
#include "know.h"

#include <stdlib.h>

//
//  The local debug trace level
//

#define Dbg             (DEBUG_TRACE_LOCALVOL)

//
//  Local function prototypes
//

NTSTATUS
DfspProtocolToService(
    IN PDS_TRANSPORT pdsTransport,
    IN PWSTR         pwszPrincipalName,
    IN PWSTR         pwszShareName,
    IN BOOLEAN       fIsDfs,
    IN OUT PDFS_SERVICE pService);

NTSTATUS
PktFsctrlFlushCache(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
);

NTSTATUS
PktFsctrlFlushSpcCache(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
);

VOID
PktFlushChildren(
    PDFS_PKT_ENTRY pEntry
);

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, DfsAgePktEntries )
#pragma alloc_text( PAGE, DfspProtocolToService )
#pragma alloc_text( PAGE, DfsFsctrlSetDCName )
#pragma alloc_text( PAGE, PktpSetActiveSpcService )
#pragma alloc_text( PAGE, PktFlushChildren )
#pragma alloc_text( PAGE, PktFsctrlFlushCache )
#pragma alloc_text( PAGE, PktFsctrlFlushSpcCache )
#endif // ALLOC_PRAGMA


//+----------------------------------------------------------------------
//
// Function:    DfsAgePktEntries, public
//
// Synopsis:    This function gets called in the FSP to step through the PKT
//              entries and delete those entries which are old.
//
// Arguments:   [TimerContext] -- This context block contains a busy flag
//                                and a count of the number of ticks that
//                                have elapsed.
//
// Returns:     Nothing.
//
// Notes:       In case the PKT cannot be acquired exclusive, the
//              routine just returns without doing anything.  We
//              will have missed an aging interval, but aging is
//              a non-critical activity.
//
// History:     04/23/93        SudK    Created.
//
//-----------------------------------------------------------------------
VOID
DfsAgePktEntries(PDFS_TIMER_CONTEXT     DfsTimerContext)
{

    PDFS_PKT            pkt = _GetPkt();
    PDFS_PKT_ENTRY      entry, nextEntry;
    PDFS_SPECIAL_ENTRY  sentry, snextEntry;
    PLIST_ENTRY         link;
    PDFS_CREDENTIALS    creds;
    BOOLEAN             pktLocked = FALSE;
    PDFS_SPECIAL_TABLE  pSpecialTable;

    DfsDbgTrace(+1, Dbg, "DfsAgePktEntries called\n", 0);

    pSpecialTable = &pkt->SpecialTable;

    //
    // First we need to acquire a lock on the PKT and step through the PKT
    //
    //

    // If we can't get to the resource then let us return right away.
    // This is really not that critical.  We can always try again.
    //

    PktAcquireExclusive(FALSE, &pktLocked);

    if (pktLocked == FALSE) {

        DfsTimerContext->TickCount = 0;

        DfsTimerContext->InUse = FALSE;

        DfsDbgTrace(-1, Dbg, "DfsAgePktEntries Exit (no scan)\n", 0);

        return;

    }

    if (ExAcquireResourceExclusiveLite(&DfsData.Resource, FALSE) == FALSE) {

        PktRelease();

        DfsTimerContext->TickCount = 0;

        DfsTimerContext->InUse = FALSE;

        DfsDbgTrace(-1, Dbg, "DfsAgePktEntries Exit (no scan 2)\n", 0);

        return;

    }

    //
    // Age all the Pkt entries
    //

    entry = PktFirstEntry(pkt);

    while (entry != NULL)       {

        DfsDbgTrace(0, Dbg, "DfsAgePktEntries: Scanning %wZ\n", &entry->Id.Prefix);

        nextEntry = PktNextEntry(pkt, entry);

        if (entry->ExpireTime < DfsTimerContext->TickCount) {
#if DBG
            if (MupVerbose)
                DbgPrint("DfsAgePktEntries:Setting expiretime on %wZ to 0\n",
                        &entry->Id.Prefix);
#endif
            entry->ExpireTime = 0;
        } else {
            entry->ExpireTime -= DfsTimerContext->TickCount;
        }

        entry = nextEntry;

    }

    //
    // Age the special table
    //

    if (pkt->SpecialTable.SpecialEntryCount > 0) {

        if (pkt->SpecialTable.TimeToLive >= DfsTimerContext->TickCount) {

            pkt->SpecialTable.TimeToLive -= DfsTimerContext->TickCount;

        } else { // make it zero

            pkt->SpecialTable.TimeToLive = 0;

        }

    }
    
    //
    // Check the deleted credentials queue...
    //

    for (link = DfsData.DeletedCredentials.Flink;
            link != &DfsData.DeletedCredentials;
                NOTHING) {

         creds = CONTAINING_RECORD(link, DFS_CREDENTIALS, Link);

         link = link->Flink;

         if (creds->RefCount == 0) {

             RemoveEntryList( &creds->Link );

             ExFreePool( creds );

         }

    }


    ExReleaseResourceLite( &DfsData.Resource );

    PktRelease();

    //
    // Finally we need to reset the count so that the Timer Routine can
    // work fine.  We also release the context block by resetting the InUse
    // boolean.  This will make sure that the next count towards the PKT
    // aging will start again.
    //

    DfsTimerContext->TickCount = 0;

    DfsTimerContext->InUse = FALSE;

    DfsDbgTrace(-1, Dbg, "DfsAgePktEntries Exit\n", 0);
}


//+----------------------------------------------------------------------------
//
//  Function:   DfspProtocolToService
//
//  Synopsis:   Given a NetBIOS protocol definition in a DS_PROTOCOL structure
//              this function creates a corresponding DFS_SERVICE structure.
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

NTSTATUS
DfspProtocolToService(
    IN PDS_TRANSPORT pdsTransport,
    IN PWSTR         pwszPrincipalName,
    IN PWSTR         pwszShareName,
    IN BOOLEAN       fIsDfs,
    IN OUT PDFS_SERVICE pService)
{
    NTSTATUS status = STATUS_SUCCESS;
    PTA_ADDRESS pTaddr = &pdsTransport->taddr;
    PTDI_ADDRESS_NETBIOS pNBAddress;
    USHORT i;
    WCHAR    NetBiosAddress[ TDI_ADDRESS_LENGTH_NETBIOS + 1];
    ULONG cbUnused;
    PUNICODE_STRING pServiceAddr;
    ULONG AllocLen;

    DfsDbgTrace(+1, Dbg, "DfspProtocolToService - entered\n", 0);

    //
    // Initialize the service to nulls
    //

    RtlZeroMemory(pService, sizeof(DFS_SERVICE));

    ASSERT(pTaddr->AddressType == TDI_ADDRESS_TYPE_NETBIOS);

    pNBAddress = (PTDI_ADDRESS_NETBIOS) pTaddr->Address;
    ASSERT(pTaddr->AddressLength == sizeof(TDI_ADDRESS_NETBIOS));

    RtlMultiByteToUnicodeN(
        NetBiosAddress,
        sizeof(NetBiosAddress),
        &cbUnused,
        pNBAddress->NetbiosName,
        16);

    //
    // Process a NetBIOS name. Throw away char 16, then ignore the trailing
    // spaces
    //

    for (i = 14; i >= 0 && NetBiosAddress[i] == L' '; i--) {
        NOTHING;
    }
    NetBiosAddress[i+1] = UNICODE_NULL;

    DfsDbgTrace(0, Dbg, "NetBIOS address is %ws\n", NetBiosAddress);

    pService->Name.Length = wcslen(pwszPrincipalName) * sizeof(WCHAR);
    pService->Name.MaximumLength = pService->Name.Length +
                                        sizeof(UNICODE_NULL);
    pService->Name.Buffer = ExAllocatePoolWithTag(
                                PagedPool,
                                pService->Name.MaximumLength,
                                ' puM');

    if (!pService->Name.Buffer) {
        DfsDbgTrace(0, Dbg, "Unable to create principal name!\n", 0);
        status = STATUS_INSUFFICIENT_RESOURCES;
        DfsDbgTrace(-1, Dbg, "DfsProtocolToService returning %08lx\n", ULongToPtr(status) );
        return(status);
    }

    RtlCopyMemory(pService->Name.Buffer, pwszPrincipalName, pService->Name.Length);

    AllocLen = sizeof(UNICODE_PATH_SEP) +
                    pService->Name.Length +
                        sizeof(UNICODE_PATH_SEP) +
                            wcslen(pwszShareName) * sizeof(WCHAR) +
                                sizeof(UNICODE_NULL);

    if (AllocLen <= MAXUSHORT) {
        pService->Address.MaximumLength = (USHORT) AllocLen;
    } else {
        DfsDbgTrace(0, Dbg, "Address too long!\n", 0);
        ExFreePool(pService->Name.Buffer);
        status = STATUS_NAME_TOO_LONG;
        DfsDbgTrace(-1, Dbg, "DfsProtocolToService returning %08lx\n", ULongToPtr(status) );
        return(status);
    }

    pService->Address.Buffer = ExAllocatePoolWithTag(
                                    PagedPool,
                                    pService->Address.MaximumLength,
                                    ' puM');

    if (!pService->Address.Buffer) {
        DfsDbgTrace(0, Dbg, "Unable to create address!\n", 0);
        ExFreePool(pService->Name.Buffer);
        pService->Name.Buffer = NULL;
        status = STATUS_INSUFFICIENT_RESOURCES;
        DfsDbgTrace(-1, Dbg, "DfsProtocolToService returning %08lx\n", ULongToPtr(status) );
        return(status);
    }

    pService->Address.Length = sizeof(UNICODE_PATH_SEP);

    pService->Address.Buffer[0] = UNICODE_PATH_SEP;

    DnrConcatenateFilePath(
        &pService->Address,
        pService->Name.Buffer,
        pService->Name.Length);

    DnrConcatenateFilePath(
        &pService->Address,
        pwszShareName,
        (USHORT) (wcslen(pwszShareName) * sizeof(WCHAR)));

    DfsDbgTrace(0, Dbg, "Server Name is %wZ\n", &pService->Name);

    DfsDbgTrace(0, Dbg, "Address is %wZ\n", &pService->Address);

    pService->Type = DFS_SERVICE_TYPE_MASTER;

    if (fIsDfs) {
        pService->Capability = PROV_DFS_RDR;
        pService->ProviderId = PROV_ID_DFS_RDR;
    } else {
        pService->Capability = PROV_STRIP_PREFIX;
        pService->ProviderId = PROV_ID_MUP_RDR;
    }
    pService->pProvider = NULL;

    DfsDbgTrace(-1, Dbg, "DfsProtocolToService returning %08lx\n", ULongToPtr(status) );
    return(status);
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFsctrlSetDCName
//
//  Synopsis:   Sets the DC to use for special referrals,
//              also tries for more referrals if the table is emty or old,
//              and also sets the preferred DC if a new DC is passed in.
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsFsctrlSetDCName(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDFS_PKT Pkt = _GetPkt();
    BOOLEAN GotPkt = FALSE;
    BOOLEAN GotNewDc = FALSE;
    ULONG i;
    WCHAR *DCNameArg;
    UNICODE_STRING DomainNameDns;
    UNICODE_STRING DomainNameFlat;
    UNICODE_STRING DCNameFlat;
    UNICODE_STRING DCName;

    STD_FSCTRL_PROLOGUE(DfsFsctrlSetDCName, TRUE, FALSE, FALSE);

    DfsDbgTrace(+1, Dbg, "DfsFsctrlSetDCName()\n", 0);

    RtlZeroMemory(&DomainNameDns, sizeof(UNICODE_STRING));
    RtlZeroMemory(&DomainNameFlat, sizeof(UNICODE_STRING));
    RtlZeroMemory(&DCName, sizeof(UNICODE_STRING));
    RtlZeroMemory(&DCNameFlat, sizeof(UNICODE_STRING));

    DCNameArg = (WCHAR *)InputBuffer;

    //
    // We expect a the buffer to be unicode, so it had better be
    // of even length
    //

    if ((InputBufferLength & 0x1) != 0) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Verify there's a null someplace in the buffer
    //

    for (i = 0; i < InputBufferLength/sizeof(WCHAR) && DCNameArg[i]; i++)
        NOTHING;

    if (i >= InputBufferLength/sizeof(WCHAR)) { 
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Verify that the name given (with an added NULL) will fit
    // into a USHORT
    //

    if ((wcslen(DCNameArg) * sizeof(WCHAR)) > MAXUSHORT - sizeof(WCHAR)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    GotNewDc = (i > 0) ? TRUE : FALSE;

    //
    // If we have a new DC name, switch to it
    //

    if (GotNewDc == TRUE) {

        UNICODE_STRING NewDCName;

        DfsDbgTrace(0, Dbg, "DCNameArg=%ws\n", DCNameArg);

        NewDCName.Length = wcslen(DCNameArg) * sizeof(WCHAR);
        NewDCName.MaximumLength = NewDCName.Length + sizeof(UNICODE_NULL);

        NewDCName.Buffer = ExAllocatePoolWithTag(PagedPool, NewDCName.MaximumLength, ' puM');

        if (NewDCName.Buffer == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        PktAcquireExclusive(TRUE, &GotPkt);

        RtlCopyMemory(NewDCName.Buffer, DCNameArg, NewDCName.MaximumLength);

	if (Pkt->DCName.Buffer != NULL) {
           ExFreePool(Pkt->DCName.Buffer);
	}
        Pkt->DCName = NewDCName;

    }

    //
    // We need to reference the DCName in the Pkt even without the Pkt locked,
    // so we make a copy.
    //

    if (GotPkt == FALSE) {

        PktAcquireExclusive(TRUE, &GotPkt);

    }

    if (Pkt->DCName.Length > 0) {

        DFS_DUPLICATE_STRING(DCName,Pkt->DCName.Buffer, Status);

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

    }

    if (GotNewDc == TRUE) {

        if (Pkt->DomainNameDns.Length > 0) {

            DFS_DUPLICATE_STRING(DomainNameDns,Pkt->DomainNameDns.Buffer, Status);

            if (!NT_SUCCESS(Status)) {
                goto CheckSpcTable;
            }

        }

        if (Pkt->DomainNameFlat.Length > 0) {

            DFS_DUPLICATE_STRING(DomainNameFlat,Pkt->DomainNameFlat.Buffer, Status);

            if (!NT_SUCCESS(Status)) {
                goto CheckSpcTable;
            }

        }

        PktRelease();
        GotPkt = FALSE;
       
        if (DCName.Length > 0 && DomainNameDns.Length > 0) {

            PktpSetActiveSpcService(
                &DomainNameDns,
                &DCName,
                FALSE);

            DCNameFlat = DCName;

            for (i = 0;
                    i < DCNameFlat.Length / sizeof(WCHAR) && DCNameFlat.Buffer[i] != L'.';
                        i++
            ) {
                NOTHING;
            }

            DCNameFlat.Length = (USHORT) (i * sizeof(WCHAR));

            if (DCNameFlat.Length > Pkt->DCName.Length)
                DCNameFlat.Length = Pkt->DCName.Length;

        }

        if (DCNameFlat.Length > 0 && DomainNameFlat.Length > 0) {

            PktpSetActiveSpcService(
                &DomainNameFlat,
                &DCNameFlat,
                FALSE);

        }

    }

    if (GotPkt == TRUE) {

        PktRelease();
        GotPkt = FALSE;

     }

CheckSpcTable:

    if (NT_SUCCESS(Status) &&
        (Pkt->SpecialTable.SpecialEntryCount == 0 || Pkt->SpecialTable.TimeToLive == 0)) {

        if (DCName.Length > 0) {

            Status = PktGetSpecialReferralTable(&DCName, TRUE);

        } else {

            Status = STATUS_BAD_NETWORK_PATH;

        }

    }

Cleanup:

    //
    // Free the local copies
    //

    if (DomainNameDns.Buffer != NULL)
        ExFreePool(DomainNameDns.Buffer);

    if (DomainNameFlat.Buffer != NULL)
        ExFreePool(DomainNameFlat.Buffer);

    if (DCName.Buffer != NULL)
        ExFreePool(DCName.Buffer);

    if (GotPkt == TRUE) {

        PktRelease();
        GotPkt = FALSE;

     }

    DfsCompleteRequest(IrpContext, Irp, Status);
    DfsDbgTrace(+1, Dbg, "DfsFsctrlSetDCName exit 0x%x\n", ULongToPtr(Status) );

    return (Status);
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFsctrlSetDomainNameFlat
//
//  Synopsis:   Sets the DomainName (flat)
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsFsctrlSetDomainNameFlat(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDFS_PKT Pkt = _GetPkt();
    BOOLEAN GotPkt;
    ULONG i;
    WCHAR *DomainNameFlat;

    STD_FSCTRL_PROLOGUE(DfsFsctrlSetDomainNameFlat, TRUE, FALSE, FALSE);

    DfsDbgTrace(+1, Dbg, "DfsFsctrlSetDomainNameFlat()\n", 0);

    DomainNameFlat = (WCHAR *)InputBuffer;

    //
    // Verify there's a null someplace in the buffer
    //

    for (i = 0; i < InputBufferLength/sizeof(WCHAR) && DomainNameFlat[i]; i++)
        NOTHING;

    //
    // Zero-len is as bad as no terminating NULL
    //
    if (i == 0 || i >= InputBufferLength/sizeof(WCHAR)) { 
        DfsCompleteRequest(IrpContext, Irp, Status);
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Verify that the name given (with an added NULL) will fit
    // into a USHORT
    //

    if ((wcslen(DomainNameFlat) * sizeof(WCHAR)) > MAXUSHORT - sizeof(WCHAR)) {
        Status = STATUS_INVALID_PARAMETER;
        DfsCompleteRequest(IrpContext, Irp, Status);
        return STATUS_INVALID_PARAMETER;
    }

    PktAcquireExclusive(TRUE, &GotPkt);

    DfsDbgTrace(0, Dbg, "DomainNameFlat=%ws\n", DomainNameFlat);

    //
    // Replace old
    //
    if (Pkt->DomainNameFlat.Buffer) {
        ExFreePool(Pkt->DomainNameFlat.Buffer);
    }
        
    Pkt->DomainNameFlat.Length = wcslen(DomainNameFlat) * sizeof(WCHAR);
    Pkt->DomainNameFlat.MaximumLength = Pkt->DomainNameFlat.Length + sizeof(UNICODE_NULL);

    Pkt->DomainNameFlat.Buffer = ExAllocatePoolWithTag(
                                    PagedPool,
                                    Pkt->DomainNameFlat.MaximumLength,
                                    ' puM');

    if (Pkt->DomainNameFlat.Buffer != NULL) {
        RtlCopyMemory(
                Pkt->DomainNameFlat.Buffer,
                DomainNameFlat,
                Pkt->DomainNameFlat.MaximumLength);
    } else {
        Pkt->DomainNameFlat.Length = Pkt->DomainNameFlat.MaximumLength = 0;
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    PktRelease();

    DfsCompleteRequest(IrpContext, Irp, Status);
    DfsDbgTrace(+1, Dbg, "DfsFsctrlSetDomainNameFlat exit 0x%x\n", ULongToPtr(Status) );

    return (Status);
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFsctrlSetDomainNameDns
//
//  Synopsis:   Sets the DomainName (flat)
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsFsctrlSetDomainNameDns(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDFS_PKT Pkt = _GetPkt();
    BOOLEAN GotPkt;
    ULONG i;
    WCHAR *DomainNameDns;

    STD_FSCTRL_PROLOGUE(DfsFsctrlSetDomainNameDns, TRUE, FALSE, FALSE);

    DfsDbgTrace(+1, Dbg, "DfsFsctrlSetDomainNameDns()\n", 0);

    DomainNameDns = (WCHAR *)InputBuffer;

    //
    // Verify there's a null someplace in the buffer
    //

    for (i = 0; i < InputBufferLength/sizeof(WCHAR) && DomainNameDns[i]; i++)
        NOTHING;

    //
    // Zero-len is as bad as no terminating NULL
    //
    if (i == 0 || i >= InputBufferLength/sizeof(WCHAR)) { 
        DfsCompleteRequest(IrpContext, Irp, Status);
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Verify that the name given (with an added NULL) will fit
    // into a USHORT
    //

    if ((wcslen(DomainNameDns) * sizeof(WCHAR)) > MAXUSHORT - sizeof(WCHAR)) {
        Status = STATUS_INVALID_PARAMETER;
        DfsCompleteRequest(IrpContext, Irp, Status);
        return STATUS_INVALID_PARAMETER;
    }

    PktAcquireExclusive(TRUE, &GotPkt);

    DfsDbgTrace(0, Dbg, "DomainNameDns=%ws\n", DomainNameDns);

    //
    // Replace old
    //
    if (Pkt->DomainNameDns.Buffer) {
        ExFreePool(Pkt->DomainNameDns.Buffer);
    }
        
    Pkt->DomainNameDns.Length = wcslen(DomainNameDns) * sizeof(WCHAR);
    Pkt->DomainNameDns.MaximumLength = Pkt->DomainNameDns.Length + sizeof(UNICODE_NULL);

    Pkt->DomainNameDns.Buffer = ExAllocatePoolWithTag(
                                    PagedPool,
                                    Pkt->DomainNameDns.MaximumLength,
                                    ' puM');

    if (Pkt->DomainNameDns.Buffer != NULL) {
        RtlCopyMemory(
                Pkt->DomainNameDns.Buffer,
                DomainNameDns,
                Pkt->DomainNameDns.MaximumLength);
    } else {
        Pkt->DomainNameDns.Length = Pkt->DomainNameDns.MaximumLength = 0;
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    PktRelease();

    DfsCompleteRequest(IrpContext, Irp, Status);
    DfsDbgTrace(+1, Dbg, "DfsFsctrlSetDomainNameDns exit 0x%x\n", ULongToPtr(Status) );

    return (Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   PktFsctrlFlushCache, public
//
//  Synopsis:   This function will flush all entries which match the specified
//              input path.
//              However, this function will refuse to delete any Permanent
//              entries of the PKT.
//
//  Arguments:  
//
//  Returns:
//
//--------------------------------------------------------------------------
NTSTATUS
PktFsctrlFlushCache(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
)
{
    NTSTATUS status = STATUS_SUCCESS;
    PDFS_PKT Pkt;
    PDFS_PKT_ENTRY  curEntry;
    PDFS_PKT_ENTRY  nextEntry;
    PDFS_PKT_ENTRY  pEntry;
    BOOLEAN pktLocked;
    UNICODE_STRING ustrPrefix, RemainingPath;
    PWCHAR wCp = (PWCHAR) InputBuffer;
    NTSTATUS DiscardStatus;

    STD_FSCTRL_PROLOGUE(PktFsctrlFlushCache, TRUE, FALSE, FALSE);

    DfsDbgTrace(+1,Dbg, "PktFsctrlFlushCache()\n", 0);

    //
    // If InputBufferLength == 2 and InputBuffer == '*', flush all entries
    //

    if (InputBufferLength == sizeof(WCHAR) && wCp[0] == L'*') {

        Pkt = _GetPkt();
        PktAcquireExclusive(TRUE, &pktLocked);
        ExAcquireResourceExclusiveLite(&DfsData.Resource, TRUE);
        curEntry = PktFirstEntry(Pkt);

        while (curEntry!=NULL)  {

            nextEntry = PktNextEntry(Pkt, curEntry);

            if ( !(curEntry->Type & PKT_ENTRY_TYPE_PERMANENT) ) {

                if (curEntry->UseCount == 0) {

                    PktEntryDestroy(curEntry, Pkt, (BOOLEAN) TRUE);

                } else if ( !(curEntry->Type & PKT_ENTRY_TYPE_REFERRAL_SVC) ) {

                    //
                    // We can't delete this entry because it is in use, so
                    // mark it DELETE_PENDING, set its timeout to zero
                    // and remove from the prefix tables
                    // 

                    curEntry->Type |= PKT_ENTRY_TYPE_DELETE_PENDING;
                    curEntry->ExpireTime = 0;
                    curEntry->USN++;
                    DiscardStatus = DfsRemoveUnicodePrefix(&Pkt->PrefixTable, &(curEntry->Id.Prefix));
                    DiscardStatus = DfsRemoveUnicodePrefix(&Pkt->ShortPrefixTable, &(curEntry->Id.ShortPrefix));

                }

            }

            curEntry = nextEntry;
        }

        PktRelease();
        ExReleaseResourceLite( &DfsData.Resource );

        DfsCompleteRequest( IrpContext, Irp, status );
        DfsDbgTrace(-1,Dbg, "PktFsctrlFlushCache: Exit -> %08lx\n", ULongToPtr(status) );
        return(status);

    }

    //
    // Verify the buffer contains at least a '\' and is of even length
    //

    if (InputBufferLength < sizeof(WCHAR)
            ||
        (InputBufferLength & 0x1) != 0
            ||
        wCp[0] != UNICODE_PATH_SEP) {

        status = STATUS_INVALID_PARAMETER;
        DfsCompleteRequest( IrpContext, Irp, status );
        return status;

    }

    //
    // Flush one entry
    //

    ustrPrefix.Length = (USHORT) InputBufferLength;
    ustrPrefix.MaximumLength = (USHORT) InputBufferLength;
    ustrPrefix.Buffer = (PWCHAR) InputBuffer;

    if (ustrPrefix.Length >= sizeof(WCHAR) * 2 &&
        ustrPrefix.Buffer[0] == UNICODE_PATH_SEP &&
        ustrPrefix.Buffer[1] == UNICODE_PATH_SEP
    ) {
        ustrPrefix.Buffer++;
        ustrPrefix.Length -= sizeof(WCHAR);
    }

    if (ustrPrefix.Buffer[ustrPrefix.Length/sizeof(WCHAR)-1] == UNICODE_NULL) {
        ustrPrefix.Length -= sizeof(WCHAR);
    }

    Pkt = _GetPkt();

    PktAcquireExclusive(TRUE, &pktLocked);
    ExAcquireResourceExclusiveLite(&DfsData.Resource, TRUE);

    pEntry = PktLookupEntryByPrefix(Pkt,
                                    &ustrPrefix,
                                    &RemainingPath);

    if (pEntry == NULL || RemainingPath.Length != 0) {

        status = STATUS_OBJECT_NAME_NOT_FOUND;

    } else {

        if ( !(pEntry->Type & PKT_ENTRY_TYPE_PERMANENT) ) {
        
            if (pEntry->UseCount == 0) {

                PktEntryDestroy(pEntry, Pkt, (BOOLEAN) TRUE);

            } else if ( !(pEntry->Type & PKT_ENTRY_TYPE_REFERRAL_SVC) ) {

                //
                // We can't delete this entry because it is in use, so
                // mark it DELETE_PENDING, set its timeout to zero
                // and remove from the prefix tables
                //

                pEntry->Type |= PKT_ENTRY_TYPE_DELETE_PENDING;
                pEntry->ExpireTime = 0;
                DiscardStatus = DfsRemoveUnicodePrefix(&Pkt->PrefixTable, &(pEntry->Id.Prefix));
                DiscardStatus = DfsRemoveUnicodePrefix(&Pkt->ShortPrefixTable, &(pEntry->Id.ShortPrefix));

            }

        } else {

            status = STATUS_INVALID_PARAMETER;

        }

    }

    PktRelease();
    ExReleaseResourceLite( &DfsData.Resource );

    DfsCompleteRequest( IrpContext, Irp, status );
    DfsDbgTrace(-1,Dbg, "PktFsctrlFlushCache: Exit -> %08lx\n", ULongToPtr(status) );
    return status;

}

//+-------------------------------------------------------------------------
//
//  Function:   PktFsctrlFlushSpcCache, public
//
//  Synopsis:   This function will flush all entries which match the specified
//              input path.
//              However, this function will refuse to delete any Permanent
//              entries of the PKT.
//
//  Arguments:  
//
//  Returns:
//
//--------------------------------------------------------------------------
NTSTATUS
PktFsctrlFlushSpcCache(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
)
{
    NTSTATUS status = STATUS_INVALID_PARAMETER;
    PDFS_PKT Pkt;
    BOOLEAN pktLocked;
    PDFS_SPECIAL_ENTRY pSpecialEntry;
    PDFS_SPECIAL_TABLE pSpecialTable;
    PWCHAR wCp = (PWCHAR) InputBuffer;
    ULONG i;

    STD_FSCTRL_PROLOGUE(PktFsctrlFlushSpcCache, TRUE, FALSE, FALSE);

    DfsDbgTrace(+1,Dbg, "PktFsctrlFlushSpcCache()\n", 0);

    //
    // InputBufferLength == 2 and InputBuffer == '*'
    //

    if (InputBufferLength == sizeof(WCHAR) && wCp[0] == L'*') {

        Pkt = _GetPkt();
        PktAcquireExclusive(TRUE, &pktLocked);
        pSpecialTable = &Pkt->SpecialTable;

        pSpecialTable->TimeToLive = 0;

        pSpecialEntry = CONTAINING_RECORD(
                            pSpecialTable->SpecialEntryList.Flink,
                            DFS_SPECIAL_ENTRY,
                            Link);

        for (i = 0; i < pSpecialTable->SpecialEntryCount; i++) {

            pSpecialEntry->Stale = TRUE;

            pSpecialEntry = CONTAINING_RECORD(
                                pSpecialEntry->Link.Flink,
                                DFS_SPECIAL_ENTRY,
                                Link);
        }

        PktRelease();

        status = STATUS_SUCCESS;

    } else {

        status = STATUS_INVALID_PARAMETER;

    }

    DfsCompleteRequest( IrpContext, Irp, status );
    DfsDbgTrace(-1,Dbg, "PktFsctrlFlushSpcCache: Exit -> %08lx\n", ULongToPtr(status) );
    return status;

}

//+-------------------------------------------------------------------------
//
//  Function:   PktFlushChildren
//
//  Synopsis:   This function will flush all entries which are children
//              of the entry passed in.
//              However, this function will refuse to delete any Permanent
//              entries of the PKT.
//
//  Arguments:  
//
//  Returns:
//
//--------------------------------------------------------------------------
VOID
PktFlushChildren(
    PDFS_PKT_ENTRY pEntry
)
{
    NTSTATUS status = STATUS_SUCCESS;
    PDFS_PKT Pkt;
    PDFS_PKT_ENTRY curEntry;
    PDFS_PKT_ENTRY nextEntry;
    BOOLEAN pktLocked;
    NTSTATUS DiscardStatus;

    DfsDbgTrace(+1,Dbg, "PktFlushChildren(%wZ)\n", &pEntry->Id.Prefix);

#if DBG
    if (MupVerbose)
        DbgPrint("PktFlushChildren(%wZ)\n", &pEntry->Id.Prefix);
#endif

    PktAcquireExclusive(TRUE, &pktLocked);
    ExAcquireResourceExclusiveLite(&DfsData.Resource, TRUE);

    Pkt = _GetPkt();

    curEntry = PktEntryFirstChild(pEntry);

    while (curEntry != NULL)       {

        DfsDbgTrace(0, Dbg, "PktFlushChildren: examining %wZ\n",
                                        &curEntry->Id.Prefix);
        //
        // We may lose this entry due to deletion. Let us get the Next
        // entry before we go into the next stage.
        //

        nextEntry = PktEntryNextChild(pEntry,curEntry);

        //
        // Try to delete the entry.
        //

        if ( !(curEntry->Type & PKT_ENTRY_TYPE_PERMANENT) ) {
        
            if (curEntry->UseCount == 0) {

                PktEntryDestroy(curEntry, Pkt, (BOOLEAN) TRUE);

            } else if ( !(curEntry->Type & PKT_ENTRY_TYPE_REFERRAL_SVC) ) {

                //
                // We can't delete this entry because it is in use, so
                // mark it DELETE_PENDING, set its timeout to zero
                // and remove from the prefix tables
                //

                curEntry->Type |= PKT_ENTRY_TYPE_DELETE_PENDING;
                curEntry->ExpireTime = 0;
                DiscardStatus = DfsRemoveUnicodePrefix(&Pkt->PrefixTable, &(curEntry->Id.Prefix));
                DiscardStatus = DfsRemoveUnicodePrefix(&Pkt->ShortPrefixTable, &(curEntry->Id.ShortPrefix));

            }

        }

        curEntry = nextEntry;

    }

    PktRelease();
    ExReleaseResourceLite( &DfsData.Resource );

#if DBG
    if (MupVerbose)
        DbgPrint("PktFlushChildren returning VOID\n");
#endif

    DfsDbgTrace(-1,Dbg, "PktFlushChildren returning VOID\n", 0);

}

//+-------------------------------------------------------------------------
//
//  Function:   PktpSetActiveSpcService
//
//  Synopsis:   This function will attempt to set the 'active' DC in the specified
//              domain
//
//  Arguments:  
//
//  Returns: STATUS_SUCCESS or STATUS_NOT_FOUND
//
//--------------------------------------------------------------------------
NTSTATUS
PktpSetActiveSpcService(
    PUNICODE_STRING DomainName,
    PUNICODE_STRING DcName,
    BOOLEAN ResetTimeout)
{
    NTSTATUS status = STATUS_NOT_FOUND;
    ULONG EntryIdx;
    USHORT i;
    PDFS_SPECIAL_ENTRY pSpecialEntry;
    UNICODE_STRING DcNameFlat;
    BOOLEAN pktLocked;

    if (DomainName != NULL && DomainName->Length > 0) {

        status = PktExpandSpecialName(DomainName, &pSpecialEntry);

        if (NT_SUCCESS(status)) {

            for (EntryIdx = 0; EntryIdx < pSpecialEntry->ExpandedCount; EntryIdx++) {

                if (RtlCompareUnicodeString(
                        DcName,
                        &pSpecialEntry->ExpandedNames[EntryIdx].ExpandedName,
                        TRUE) == 0) {

                    pSpecialEntry->Active = EntryIdx;
                    //
                    // Keep the spc table around for a while longer
                    //
                    if (ResetTimeout == TRUE) {
                        PktAcquireExclusive(TRUE, &pktLocked);
                        if (DfsData.Pkt.SpecialTable.TimeToLive < 60 * 15) {
                            DfsData.Pkt.SpecialTable.TimeToLive += 60 * 15; // 15 min
                        }
                        PktRelease();
                    }
                    status = STATUS_SUCCESS;
                    break;

                }

                status = STATUS_NOT_FOUND;

            }

            InterlockedDecrement(&pSpecialEntry->UseCount);

        } else {

            status = STATUS_NOT_FOUND;

        }

    }

    return status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\pktsup.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       PktSup.C
//
//  Contents:   This module implements routines specific to the partition
//              knowledge table entry.
//
//  Functions:  PktDSTransportDestroy -
//              PktDSMachineDestroy -
//              PktServiceConstruct -
//              PktServiceDestroy -
//              PktEntryIdConstruct -
//              PktEntryIdDestroy -
//              PktEntryInfoConstruct -
//              PktEntryInfoDestroy -
//              PktEntryAssemble -
//              PktEntryReassemble -
//              PktEntryDestroy -
//              PktEntryClearSubordinates -
//              PktEntryClearChildren -
//              PktpServiceToReferral -
//              DfsFixDSMachineStructs -
//              DfspFixService -
//              DfsDecrementMachEntryCount -
//              PktSpecialEntryDestroy -
//
//  History:    27 May 1992 PeterCo Created.
//
//-----------------------------------------------------------------------------

#include "dfsprocs.h"
#include "dnr.h"
#include "creds.h"
#include "fsctrl.h"
#include "know.h"
#include "log.h"

#define Dbg              (DEBUG_TRACE_PKT)

ULONG MupErrorCase = 0;


NTSTATUS
DfsFixDSMachineStructs(
    PDFS_PKT_ENTRY      pEntry
);

NTSTATUS
DfspFixService(
    PDFS_SERVICE        pService
);

VOID
PktDSTransportDestroy(
    IN  PDS_TRANSPORT Victim OPTIONAL,
    IN  BOOLEAN DeallocateAll
);

VOID
PktDSMachineDestroy(
    IN  PDS_MACHINE Victim OPTIONAL,
    IN  BOOLEAN DeallocateAll
);


#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, PktServiceConstruct )
#pragma alloc_text( PAGE, PktServiceDestroy )
#pragma alloc_text( PAGE, PktEntryIdConstruct )
#pragma alloc_text( PAGE, PktEntryIdDestroy )
#pragma alloc_text( PAGE, PktEntryInfoDestroy )
#pragma alloc_text( PAGE, PktEntryAssemble )
#pragma alloc_text( PAGE, PktEntryReassemble )
#pragma alloc_text( PAGE, PktEntryDestroy)
#pragma alloc_text( PAGE, PktEntryClearSubordinates )
#pragma alloc_text( PAGE, PktEntryClearChildren )
#pragma alloc_text( PAGE, DfsFixDSMachineStructs )
#pragma alloc_text( PAGE, DfspFixService )
#pragma alloc_text( PAGE, DfsDecrementMachEntryCount )
#pragma alloc_text( PAGE, PktDSTransportDestroy )
#pragma alloc_text( PAGE, PktDSMachineDestroy )
#pragma alloc_text( PAGE, PktSpecialEntryDestroy )
#endif // ALLOC_PRAGMA
//
// NOTE - we designed for only one system-wide PKT; there is no provision
//        for multiple PKTs.
//

#define _GetPkt() (&DfsData.Pkt)


//+-------------------------------------------------------------------------
//
//  Function:   PktServiceConstruct, public
//
//  Synopsis:   PktServiceConstruct creates a new service structure.
//
//  Arguments:  [Service] - a pointer to a service structure to fill.
//              [ServiceType] - the type of the new service.
//              [ServiceCapability] - the capabilities of the new service.
//              [ServiceStatus] - the initial status of the new service.
//              [ServiceProviderId] - the provider Id of the new service.
//              [ServiceName] - the name of the principal for the service
//              [ServiceAddress] - a string which gives the address
//                                 of the service.
//
//  Returns:    [STATUS_SUCCESS] - all is well.
//              [STATUS_INSUFFICIENT_RESOURCES] - memory could not be
//                  allocated for this new service.
//
//  Notes:      All data is copied (Not MOVED).
//
//--------------------------------------------------------------------------

NTSTATUS
PktServiceConstruct(
    OUT PDFS_SERVICE Service,
    IN  ULONG ServiceType,
    IN  ULONG ServiceCapability,
    IN  ULONG ServiceStatus,
    IN  ULONG ServiceProviderId,
    IN  PUNICODE_STRING ServiceName OPTIONAL,
    IN  PUNICODE_STRING ServiceAddress OPTIONAL
) {
    DfsDbgTrace(+1, Dbg, "PktServiceConstruct: Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(Service));

    RtlZeroMemory(Service, sizeof(DFS_SERVICE));

    if (ARGUMENT_PRESENT(ServiceName) && ServiceName->Length != 0) {

        Service->Name.Buffer = DfsAllocate(ServiceName->Length);
        if (Service->Name.Buffer == NULL) {
            DfsDbgTrace(-1, Dbg, "PktServiceConstruct: Exit -> %08lx\n",
                                    ULongToPtr(STATUS_INSUFFICIENT_RESOURCES) );
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        Service->Name.Length = ServiceName->Length;
        Service->Name.MaximumLength = ServiceName->Length;
        RtlCopyUnicodeString(&Service->Name, ServiceName);
    } else {
        Service->Name.Buffer = NULL;
        Service->Name.Length = Service->Name.MaximumLength = 0;
    }

    if (ARGUMENT_PRESENT(ServiceAddress) && ServiceAddress->Length != 0) {
        Service->Address.Buffer = DfsAllocate(ServiceAddress->Length);
        if (Service->Address.Buffer == NULL) {

            if (Service->Name.Buffer != NULL)
                DfsFree(Service->Name.Buffer);

            DfsDbgTrace(-1, Dbg, "PktServiceConstruct: Exit -> %08lx\n",
                                    ULongToPtr(STATUS_INSUFFICIENT_RESOURCES) );
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlMoveMemory(Service->Address.Buffer, ServiceAddress->Buffer,
                                               ServiceAddress->Length);
        Service->Address.Length =
        Service->Address.MaximumLength = ServiceAddress->Length;
    } else {
        Service->Address.Buffer = NULL;
        Service->Address.Length = Service->Address.MaximumLength = 0;
    }

    Service->Type = ServiceType;
    Service->Capability = ServiceCapability;
    Service->ProviderId = ServiceProviderId;
    Service->pProvider = NULL;

    DfsDbgTrace(-1, Dbg, "PktServiceConstruct: Exit -> %08lx\n",
        STATUS_SUCCESS );
    return STATUS_SUCCESS;
}



//+-------------------------------------------------------------------------
//
//  Function:   PktDSTransportDestroy, public
//
//  Synopsis:   PktDSTransportDestroy destroys a DS_TRANSPORT structure, and
//              optionally deallocates the structure itself.
//
//  Arguments:  [Victim] - the DS_TRANSPORT structure to destroy
//              [DeallocateAll] - if True, indicates that the structure
//                  it self is to be deallocated, otherwise, only the
//                  strings within the structure are deallocated.
//
//  Returns:    VOID
//
//  Notes:
//
//--------------------------------------------------------------------------
VOID
PktDSTransportDestroy(
    IN  PDS_TRANSPORT Victim OPTIONAL,
    IN  BOOLEAN DeallocateAll
)
{

    DfsDbgTrace(+1, Dbg, "PktDSTransportDestroy: Entered\n", 0);

    if (ARGUMENT_PRESENT(Victim))       {

        //
        // Nothing to free in this structure??
        //

        if (DeallocateAll)
            ExFreePool(Victim);
    } else
        DfsDbgTrace(0, Dbg, "PktDSTransportDestroy: No Victim\n", 0 );

    DfsDbgTrace(-1, Dbg, "PktDSTransportDestroy: Exit -> VOID\n", 0 );
}



//+-------------------------------------------------------------------------
//
//  Function:   PktDSMachineDestroy, public
//
//  Synopsis:   PktDSMachineDestroy destroys a DS_MACHINE structure, and
//              optionally deallocates the structure itself.
//
//  Arguments:  [Victim] - the DS_MACHINE structure to destroy
//              [DeallocateAll] - if True, indicates that the structure
//                  it self is to be deallocated, otherwise, only the
//                  strings within the structure are deallocated.
//
//  Returns:    VOID
//
//  Notes:
//
//--------------------------------------------------------------------------
VOID
PktDSMachineDestroy(
    IN  PDS_MACHINE Victim OPTIONAL,
    IN  BOOLEAN DeallocateAll
)
{
    ULONG       i;
    DfsDbgTrace(+1, Dbg, "PktDSMachineDestroy: Entered\n", 0);

    if (ARGUMENT_PRESENT(Victim)) {

        if (Victim->pwszShareName != NULL) {
            DfsFree(Victim->pwszShareName);
            Victim->pwszShareName = NULL;
        }

        if (Victim->prgpwszPrincipals != NULL && Victim->cPrincipals > 0) {
            for (i = 0; i < Victim->cPrincipals; i++)   {
                if (Victim->prgpwszPrincipals[i] != NULL) {
                    DfsFree(Victim->prgpwszPrincipals[i]);
                    Victim->prgpwszPrincipals[i] = NULL;
                }
            }
        }

        if (Victim->prgpwszPrincipals) {
            ExFreePool(Victim->prgpwszPrincipals);
            Victim->prgpwszPrincipals = NULL;
        }

        for (i = 0; i < Victim->cTransports; i++)   {
            PktDSTransportDestroy(Victim->rpTrans[i], TRUE);
        }

        if (DeallocateAll)
            ExFreePool(Victim);
    } else
        DfsDbgTrace(0, Dbg, "PktDSMachineDestroy: No Victim\n", 0 );

    DfsDbgTrace(-1, Dbg, "PktDSMachineDestroy: Exit -> VOID\n", 0 );
}



//+-------------------------------------------------------------------------
//
//  Function:   DfsDecrementMachEntryCount
//
//  Synopsis:   This function decrements the count for the pMachine passed
//              in and if necessary will also free up the DS_MACHINE struct
//
//--------------------------------------------------------------------------

VOID
DfsDecrementMachEntryCount(
    PDFS_MACHINE_ENTRY  pMachEntry,
    BOOLEAN     DeallocateMachine
)
{

    NTSTATUS            status = STATUS_SUCCESS;
    UNICODE_STRING      ustrMachineName;
    PUNICODE_PREFIX_TABLE_ENTRY pfxEntry;
    PDS_MACHINE         pMachine;
    PDFS_PKT            Pkt;
    LONG Count;

    ASSERT(pMachEntry != NULL);
    if (pMachEntry == NULL)
        return;

    pMachine = pMachEntry->pMachine;
    ASSERT(pMachine != NULL);
    if (pMachine == NULL)
        return;

    //
    // We already have appropriate locks
    //
    Pkt = _GetPkt();

    //
    // For now we only expect one principal, by design?
    //
    ASSERT(pMachine->cPrincipals == 1);

    Count = InterlockedDecrement( &pMachEntry->UseCount );

    if (Count == 0) {

        if (pMachEntry->AuthConn != NULL) {

            DfsDeleteTreeConnection( pMachEntry->AuthConn, USE_LOTS_OF_FORCE );

            pMachEntry->Credentials->RefCount--;

        }

        //
        // This means we can now actually delete this DS_MACHINE structure
        //
        RtlRemoveUnicodePrefix(&Pkt->DSMachineTable,
                                   &pMachEntry->PrefixTableEntry);

        if (DeallocateMachine)
            PktDSMachineDestroy(pMachine, TRUE);

        //
        // Free the entry itself. Note that the UNICODE_STRING in the
        // entry gets freed up as part of above pMachine deletion.
        //
        DfsFree(pMachEntry);
    }

}



//+-------------------------------------------------------------------------
//
//  Function:   PktServiceDestroy, public
//
//  Synopsis:   PktServiceDestroy destroys a service structure, and
//              optionally deallocates the structure itself.
//
//  Arguments:  [Victim] - the service structure to destroy
//              [DeallocateAll] - if True, indicates that the structure
//                  it self is to be deallocated, otherwise, only the
//                  strings within the structure are deallocated.
//
//  Returns:    VOID
//
//  Notes:
//
//--------------------------------------------------------------------------

VOID
PktServiceDestroy(
    IN  PDFS_SERVICE Victim OPTIONAL,
    IN  BOOLEAN DeallocateAll
)
{
    DfsDbgTrace(+1, Dbg, "PktServiceDestroy: Entered\n", 0);

    if (ARGUMENT_PRESENT(Victim)) {

        if (Victim->ConnFile != NULL) {
            DfsCloseConnection(Victim);
            Victim->ConnFile = NULL;
        }

        if (Victim->Name.Buffer != NULL) {
            DfsFree(Victim->Name.Buffer);
            Victim->Name.Buffer = NULL;
        }

        if (Victim->Address.Buffer != NULL) {
            DfsFree(Victim->Address.Buffer);
            Victim->Address.Buffer = NULL;
        }

        //
        // Decrement the usage count. If it is to be deleted it will happen
        // automatically.
        //
        if (Victim->pMachEntry != NULL) {
            DfsDecrementMachEntryCount(Victim->pMachEntry, TRUE);
        }

        if (DeallocateAll)
            ExFreePool(Victim);
    } else
        DfsDbgTrace(0, Dbg, "PktServiceDestroy: No Victim\n", 0 );

    DfsDbgTrace(-1, Dbg, "PktServiceDestroy: Exit -> VOID\n", 0 );
}



//+-------------------------------------------------------------------------
//
//  Function:   PktEntryIdConstruct, public
//
//  Synopsis:   PktEntryIdConstruct creates a PKT Entry Id
//
//  Arguments:  [NewPktEntryId] - Where the new entry is placed
//              [NewUid] - The UID of the new Pkt Entry
//              [NewPrefix] - The new prefix of the new Pkt Entry
//
//  Returns:    [STATUS_SUCCESS] - all is well.
//              [STATUS_INSUFFICIENT_RESOURCES] - could not allocate
//                  memory for the Prefix part of the Id.
//
//  Notes:      The UNICODE_STRING used in the Prefix of the Id is COPIED,
//              not MOVED!
//
//--------------------------------------------------------------------------
NTSTATUS
PktEntryIdConstruct(
    OUT PDFS_PKT_ENTRY_ID PktEntryId,
    IN  GUID *Uid OPTIONAL,
    IN  UNICODE_STRING *Prefix OPTIONAL
)
{
    DfsDbgTrace(+1, Dbg, "PktEntryIdConstruct: Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(PktEntryId));
    ASSERT(ARGUMENT_PRESENT(Prefix));

    //
    // Zero the memory
    //
    RtlZeroMemory(PktEntryId, sizeof(DFS_PKT_ENTRY_ID));

    //
    // deal with the prefix.
    //
    if (ARGUMENT_PRESENT(Prefix)) {

        PUNICODE_STRING pus = &PktEntryId->Prefix;

        if (Prefix->Length != 0) {
            pus->Length = pus->MaximumLength = Prefix->Length;
            pus->Buffer = DfsAllocate(pus->Length);
            if (pus->Buffer != NULL) {
                RtlCopyUnicodeString(pus, Prefix);
            } else {
                DfsDbgTrace(-1,Dbg,"PktEntryIdConstruct: Exit -> %08lx\n",
                    ULongToPtr(STATUS_INSUFFICIENT_RESOURCES) );
                return STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }

    //
    // deal with the GUID.
    //
    if (ARGUMENT_PRESENT(Uid)) {
        PktEntryId->Uid = (*Uid);
    }

    DfsDbgTrace(-1,Dbg,"PktEntryIdConstruct: Exit -> %08lx\n",STATUS_SUCCESS);
    return STATUS_SUCCESS;
}


//+-------------------------------------------------------------------------
//
//  Function:   PktEntryIdDestroy, public
//
//  Synopsis:   PktEntryIdDestroy destroys a PKT Entry Id
//
//  Arguments:  [Victim] - Id to destroy
//              [DeallocateAll] - if true, indicates that the memory
//                  for the Id itself is to be release, otherwise,
//                  this memory is not released (only the memory for
//                  the UNICODE_STRING in the Prefix is released).
//
//  Returns:    VOID
//
//  Notes:      Memory for the UNICODE_STRING in the Prefix is released.
//
//--------------------------------------------------------------------------

VOID
PktEntryIdDestroy(
    IN  PDFS_PKT_ENTRY_ID Victim OPTIONAL,
    IN  BOOLEAN DeallocateAll
)
{
    DfsDbgTrace(+1, Dbg, "PktEntryIdDestroy: Entered\n", 0);
    if (ARGUMENT_PRESENT(Victim)) {
        if (Victim->Prefix.Buffer != NULL) {
            DfsFree(Victim->Prefix.Buffer);
            Victim->Prefix.Buffer = NULL;
        }
        if (Victim->ShortPrefix.Buffer != NULL) {
            DfsFree(Victim->ShortPrefix.Buffer);
            Victim->ShortPrefix.Buffer = NULL;
        }
        if (DeallocateAll)
            ExFreePool(Victim);
    } else
        DfsDbgTrace(0, Dbg, "PktEntryIdDestroy: No Victim\n", 0 );
    DfsDbgTrace(-1, Dbg, "PktEntryIdDestroy: Exit -> VOID\n", 0 );
}



//+-------------------------------------------------------------------------
//
//  Function:   PktEntryInfoDestroy, public
//
//  Synopsis:   PktEntryInfoDestroy destroys an info structure, and
//              optionally deallocates the structure itself.
//
//  Arguments:  [Victim] - the info structure to destroy
//              [DeallocateAll] - if True, indicates that the structure
//                  itself is to be deallocated, otherwise, only the
//                  service list within the structure is deallocated.
//
//  Returns:    VOID
//
//  Notes:
//
//--------------------------------------------------------------------------
VOID
PktEntryInfoDestroy(
    IN  PDFS_PKT_ENTRY_INFO Victim OPTIONAL,
    IN  BOOLEAN DeallocateAll
)
{
    DfsDbgTrace(+1, Dbg, "PktEntryInfoDestroy: Entered\n", 0);

    if (ARGUMENT_PRESENT(Victim)) {

        ULONG i;

        ExAcquireResourceExclusiveLite( &DfsData.Resource, TRUE );

        if (Victim->ServiceList != NULL) {
            for (i = 0; i < Victim->ServiceCount; i++)
                PktServiceDestroy(&Victim->ServiceList[i], FALSE);
        }

        Victim->ServiceCount = 0;

        if (Victim->ServiceList != NULL) {
            ExFreePool(Victim->ServiceList);
            Victim->ServiceList = NULL;
        }

        if (DeallocateAll)
            ExFreePool(Victim);

        ExReleaseResourceLite( &DfsData.Resource );

    } else
        DfsDbgTrace(0, Dbg, "PktEntryInfoDestroy: No Victim\n", 0 );

    DfsDbgTrace(-1, Dbg, "PktEntryInfoDestroy: Exit -> VOID\n", 0 );
}



//+-------------------------------------------------------------------------
//
//  Function:   DfspFixService
//
//  Synopsis:   This function should be called when a new service's DS_MACHINE
//              struct has to be adjusted to make sure there is a unique one
//              for each machine in the PKT.
//
//  Arguments:  [pService] -- The Service struct to fix up.
//
//  History:    23 August 1994          SudK    Created.
//
//--------------------------------------------------------------------------
NTSTATUS
DfspFixService(
    PDFS_SERVICE        pService
)
{

    NTSTATUS            status = STATUS_SUCCESS;
    UNICODE_STRING      ustrMachineName;
    PDS_MACHINE         pMachine;
    PUNICODE_PREFIX_TABLE_ENTRY pfxEntry;
    PDFS_MACHINE_ENTRY  machEntry;
    PDFS_PKT            Pkt;

    ASSERT(pService != NULL);
    ASSERT(pService->pMachEntry != NULL);
    pMachine = pService->pMachEntry->pMachine;
    if (pMachine->cPrincipals == 0)     {
        ASSERT(pService->Type && DFS_SERVICE_TYPE_DOWN_LEVEL);
        pService->pMachEntry->UseCount = 1;

        return(status);
    }
    //
    // We are called during PktCreateEntry. We already have appropriate locks
    //
    Pkt = _GetPkt();

    //
    // For now we only expect one principal. by design
    //
    ASSERT(pMachine->cPrincipals == 1);

    RtlInitUnicodeString(&ustrMachineName,
                        pMachine->prgpwszPrincipals[0]);


    ASSERT(ustrMachineName.Buffer != NULL);

    pfxEntry = RtlFindUnicodePrefix(&Pkt->DSMachineTable,&ustrMachineName,TRUE);
    if (pfxEntry != NULL) {
        //
        // In this case the DS_Machine structure already exists. Just use the
        // existing DS_Machine struct and bump the UseCount
        //
        machEntry = CONTAINING_RECORD(pfxEntry,
                                     DFS_MACHINE_ENTRY,
                                     PrefixTableEntry);

        InterlockedIncrement( &machEntry->UseCount );

        //
        // Even though we are "reusing" the Machine Entry, we might have a
        // better DS_MACHINE (ie, one with more transports) in the incoming
        // one. If so, lets use the new one.
        //

        if (pMachine->cTransports > machEntry->pMachine->cTransports) {
            PDS_MACHINE pTempMachine;

            DfsDbgTrace(0, 0, "DfspFixService: Using new DS_MACHINE for [%wZ]\n", &ustrMachineName);

            pTempMachine = machEntry->pMachine;
            machEntry->pMachine = pMachine;
            pService->pMachEntry->pMachine = pTempMachine;

            RtlRemoveUnicodePrefix(
                &Pkt->DSMachineTable,
                &machEntry->PrefixTableEntry);

            machEntry->MachineName = ustrMachineName;

            RtlInsertUnicodePrefix(
                &Pkt->DSMachineTable,
                &machEntry->MachineName,
                &machEntry->PrefixTableEntry);

        }
        pService->pMachEntry = machEntry;

    } else {
        //
        // In this case the DS_Machine is not there in the table. Need to add
        // current one to the table.
        //
        machEntry = pService->pMachEntry;
        machEntry->UseCount = 1;

        machEntry->MachineName = ustrMachineName; // Use same mem in DS_MACHINE.

        //
        // Now insert the machEntry and then we are done. This better not fail.
        //
        if (!RtlInsertUnicodePrefix(&Pkt->DSMachineTable,
                               &machEntry->MachineName,
                               &machEntry->PrefixTableEntry))   {
            BugCheck("DFS Pkt inconsistent DfspFixService");
        }

    }
    return(status);
}



//+-------------------------------------------------------------------------
//
//  Function:   DfsFixDSMachineStructs
//
//  Synopsis:   For the entry given this function makes sure that there is
//              only one DS_MACHINE structure in the PKT. If there isn't one
//              then one is registered. If there is one then the same one is
//              used and the current one in the DFS_SERVICE struct is freed up.
//
//  Arguments:  [pEntry] -- The PKT entry that has to be fixed.
//
//  Notes:      If this function fails then it will reset the pEntry to the
//              same format it was when it was called.
//
//  History:    22 Aug 1994     SudK    Created.
//
//--------------------------------------------------------------------------
NTSTATUS
DfsFixDSMachineStructs(
    PDFS_PKT_ENTRY      pEntry
)
{
    NTSTATUS            status = STATUS_SUCCESS;
    ULONG               i;
    PDFS_MACHINE_ENTRY  *apMachineEntry;
    PDFS_SERVICE        pService;

    if (pEntry->Info.ServiceCount == 0)
        return(status);

    //
    // In case of downlevel we do nothing
    //
    if (pEntry->Type & PKT_ENTRY_TYPE_NONDFS)
        return(status);

    apMachineEntry =
        ExAllocatePoolWithTag(PagedPool,
            sizeof(PDFS_MACHINE_ENTRY) * pEntry->Info.ServiceCount,
            ' puM');

    if (apMachineEntry == NULL)      {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    for (i=0; i < pEntry->Info.ServiceCount; i++) {
        //
        // First Save the current DS_Machine and then fix up
        //
        apMachineEntry[i] = pEntry->Info.ServiceList[i].pMachEntry;
        status = DfspFixService(&pEntry->Info.ServiceList[i]);
        if (!NT_SUCCESS(status))        {
            //
            // In this case we break and let the cleanup part below take care
            // of cleaning up everything.
            //
            break;
        }
    }

    if (!NT_SUCCESS(status))    {
        //
        // We need to cleanup in this case. I.E. reset all the PDS_MACHINEs
        // back to old values and decrement any usage counts on DS_MACHINE
        // structures.
        //
        ULONG j;
        for (j=0; j < i; j++)     {
            pService = &pEntry->Info.ServiceList[j];
            //
            // These have already been fixed up so decrement the count on the
            // pMachine structs. Dont want to deallocate the pMachine structs
            // if we were the last one to use it.
            //
            DfsDecrementMachEntryCount(pService->pMachEntry, FALSE);

            if (apMachineEntry[j] != pService->pMachEntry)
                pService->pMachEntry = apMachineEntry[j];
        }
    }
    else        {
        //
        // In this case everything went fine. So we need to free up the
        // DS_MACHINE structures that were superfluously allocated for now.
        //
        for (i=0; i<pEntry->Info.ServiceCount; i++)     {
            if (apMachineEntry[i] != pEntry->Info.ServiceList[i].pMachEntry) {
                //
                // This means that the pMachine in the service list got replaced
                // by a different one so let us free this one now.
                //
                PktDSMachineDestroy(apMachineEntry[i]->pMachine, TRUE);
                ExFreePool( apMachineEntry[i] );
            }
        }
    }

    ExFreePool(apMachineEntry);
    return(status);
}



//+-------------------------------------------------------------------------
//
//  Function:   PktEntryAssemble, private
//
//  Synopsis:   PktpEntryAssemble blindly constructs a new partition
//              table entry and places it in the PKT.  The caller must
//              have previously determined that no other entry with this
//              UID or Prefix existed.  The PKT must be acquired exclusively
//              for this operation.
//
//  Arguments:  [Entry] - a pointer to an entry to be filled.
//              [Pkt] - pointer to a initialized (and acquired
//                      exclusively) PKT
//              [EntryType] - the type of entry to assemble.
//              [EntryId] - pointer to the new entry's Id.
//              [EntryInfo] - pointer to the guts of the entry.
//
//  Returns:    [STATUS_SUCCESS] if no error.
//              [STATUS_INVALID_PARAMETER] - if the EntryId does not have a
//                  UID or a Prefix (no such thing as an anonymous entry).
//              [PKT_ENTRY_EXISTS] - a new prefix table entry could not
//                  be made.
//
//  Notes:      The EntryId and EntryInfo structures are MOVED (not
//              COPIED) to the new entry.  The memory used for UNICODE_STRINGS
//              and DFS_SERVICE arrays is used by the new entry.  The
//              associated fields in the EntryId and EntryInfo
//              structures passed as arguments are Zero'd to indicate that
//              the memory has been "deallocated" from these strutures and
//              reallocated to the newly create Entry.  Note that this
//              routine does not deallocate the EntryId structure or
//              the EntryInfo structure itself. On successful return from
//              this function, the EntryId structure will be modified
//              to have a NULL Prefix entry, and the EntryInfo structure
//              will be modified to have zero services and a null ServiceList
//              entry.
//
//--------------------------------------------------------------------------
NTSTATUS
PktEntryAssemble(
    IN  OUT PDFS_PKT_ENTRY Entry,
    IN      PDFS_PKT Pkt,
    IN      ULONG EntryType,
    IN      PDFS_PKT_ENTRY_ID EntryId,
    IN      PDFS_PKT_ENTRY_INFO EntryInfo,
    IN      PDFS_TARGET_INFO pDfsTargetInfo
)
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG               i;
    PDFS_SERVICE        pService;
    BOOLEAN DiscardResult;

    DfsDbgTrace(+1, Dbg, "PktEntryAssemble: Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(Entry) &&
           ARGUMENT_PRESENT(EntryId));

    //
    // We do not allow the creation of entries
    // without any Uid or Prefix.
    //

    if (NullGuid(&EntryId->Uid) && EntryId->Prefix.Length == 0) {
        DfsDbgTrace(-1, Dbg, "PktEntryAssemble: Exit -> %08lx\n",
                    ULongToPtr(STATUS_INVALID_PARAMETER) );
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Zero out the entry.
    //
    RtlZeroMemory(Entry, sizeof(DFS_PKT_ENTRY));

    //
    // Mundane initialization
    //
    Entry->NodeTypeCode =  DSFS_NTC_PKT_ENTRY;
    Entry->NodeByteSize = sizeof(DFS_PKT_ENTRY);

    //
    // Initialize the USN to 1
    //
    Entry->USN = 1;

    //
    // Move the Type, Id, and Info into this entry.
    //
    Entry->Type = EntryType;
    PktpEntryIdMove(&Entry->Id, EntryId);
    if (ARGUMENT_PRESENT(EntryInfo))  {
        PktpEntryInfoMove(&Entry->Info, EntryInfo);

        for (i = 0; i < Entry->Info.ServiceCount; i++) {
            Entry->Info.ServiceList[i].pMachEntry->UseCount = 1;
        }

        //
        // If we are setting up a PKT_ENTRY_TYPE_REFERRAL_SVC entry then we want
        // to mark ALL of its services to be REFERRAL_SERVICES as well.
        //
        if (EntryType & PKT_ENTRY_TYPE_REFERRAL_SVC)    {
            pService = Entry->Info.ServiceList;
            for (i=0; i<Entry->Info.ServiceCount; i++)  {
                pService->Type = pService->Type | DFS_SERVICE_TYPE_REFERRAL;
                pService++;
            }
        }
        //
        // Now we need to make sure that there is only one copy of the
        // DS_MACHINE structures for each of the above services that we added.
        //
        if (!(EntryType & PKT_ENTRY_TYPE_NONDFS)) {
            status = DfsFixDSMachineStructs(Entry);
            if (!NT_SUCCESS(status))    {
                //
                // We messed up. This means that something is really messed up.
                //
                DfsDbgTrace(0, 1,
                        "DFS: DfsFixDSMachineStructs failed for %wZ\n",
                        &Entry->Id.Prefix);

                PktpEntryIdMove(EntryId, &Entry->Id);

                if (ARGUMENT_PRESENT(EntryInfo))
                    PktpEntryInfoMove(EntryInfo, &Entry->Info);

                return(status);
            }
        }
    }
    //
    // Initialize the head of the subordinate list.
    //
    InitializeListHead(&Entry->SubordinateList);

    //
    // Initialize the head of the childList.
    //
    InitializeListHead(&Entry->ChildList);

    //
    // Try to get us into the prefix table.
    //

    if (DfsInsertUnicodePrefix(&Pkt->PrefixTable,
                               &Entry->Id.Prefix,
                               &Entry->PrefixTableEntry)) {

        //
        // We successfully created the prefix entry, so now we link
        // this entry into the PKT.
        //
        PktLinkEntry(Pkt, Entry);

        //
        // And insert into the short prefix table. We don't do error
        // recovery if this fails.
        //

        DiscardResult = DfsInsertUnicodePrefix(&Pkt->ShortPrefixTable,
                                               &Entry->Id.ShortPrefix,
                                               &Entry->PrefixTableEntry);

    } else {

        //
        // We failed to get the entry into the prefix table.  This
        // can only happen if a prefix already exists, and a prefix
        // can only exist if we've really gotten messed up...
        // We disassemble the entry and return an error.
        //

        DfsDbgTrace(0, 1,
                "DFS: PktEntryAssemble failed prefix table insert of %wZ\n",
                &Entry->Id.Prefix);

        PktpEntryIdMove(EntryId, &Entry->Id);
        if (ARGUMENT_PRESENT(EntryInfo))
            PktpEntryInfoMove(EntryInfo, &Entry->Info);

        MupErrorCase++;
        status = DFS_STATUS_ENTRY_EXISTS;
    }

    if (status == STATUS_SUCCESS)
    {
        Entry->pDfsTargetInfo = pDfsTargetInfo;
        PktAcquireTargetInfo(pDfsTargetInfo);
    }
    DfsDbgTrace(-1, Dbg, "PktEntryAssemble: Exit -> %08lX\n", ULongToPtr(status) );


    // Bug 435639: if insert fails dont return SUCCESS!!
    return status;
}



//+-------------------------------------------------------------------------
//
//  Function:   PktEntryReassemble, private
//
//  Synopsis:   PktpEntryReassemble blindly reconstructs a partition
//              table entry.  It provides a mechanism by which an existing
//              entry can be modified.  The caller must have previously
//              determined that no other entry with this UID or Prefix
//              existed. The PKT must be acquired exclusively for this
//              operation.
//
//  Arguments:  [Entry] - a pointer to an entry to be reassembled.
//              [Pkt] - pointer to a initialized (and acquired
//                      exclusively) PKT - must be provided if EntryId
//                      is provided.
//              [EntryType] - the type of entry to reassemble.
//              [EntryId] - pointer to the entry's new Id.
//              [EntryInfo] - pointer to the new guts of the entry.
//
//  Returns:    [STATUS_SUCCESS] if no error.
//              [STATUS_INVALID_PARAMETER] - if the EntryId does not have a
//                  UID or a Prefix (no such thing as an anonymous entry), or
//                  and EntryId was provided but a PKT argument was not.
//              [DFS_STATUS_ENTRY_EXISTS] - a new prefix table entry could not
//                  be made.
//              [DFS_STATUS_INCONSISTENT] - a new prefix table entry could
//                  not be made, and we could not back out of the operation.
//                  This status return indicates that the entry is no longer
//                  in the prefix table associated with the PKT and that
//                  it is likely that the PKT is inconsistent as a result.
//
//  Notes:      The EntryId and EntryInfo structures are MOVED (not
//              COPIED) to the entry, the old Id and Info are destroyed.
//              The memory used for UNICODE_STRINGS and DFS_SERVICE arrays
//              is used by the entry.  The associated fields in the EntryId
//              and EntryInfo structures passed as arguments are Zero'd to
//              indicate that the memory has been "deallocated" from these
//              structures and reallocated to the newly created Entry.  Note
//              that this routine does not deallocate the EntryId structure
//              or the EntryInfo structure itself.  On successful return from
//              this function, the EntryId structure will be modified
//              to have a NULL Prefix entry, and the EntryInfo structure
//              will be modified to have zero services and a null ServiceList
//              entry.
//
//--------------------------------------------------------------------------
NTSTATUS
PktEntryReassemble(
    IN  OUT PDFS_PKT_ENTRY Entry,
    IN      PDFS_PKT Pkt,
    IN      ULONG EntryType,
    IN      PDFS_PKT_ENTRY_ID EntryId,
    IN      PDFS_PKT_ENTRY_INFO EntryInfo,
    IN      PDFS_TARGET_INFO pDfsTargetInfo
)
{
    NTSTATUS            status = STATUS_SUCCESS;
    ULONG               i;
    PDFS_SERVICE        pService;
    NTSTATUS DiscardStatus;
    BOOLEAN DiscardResult;

    DfsDbgTrace(+1, Dbg, "PktEntryReassemble: Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(Entry) &&
           ARGUMENT_PRESENT(Pkt));

    if (ARGUMENT_PRESENT(EntryId)) {

        DFS_PKT_ENTRY_ID oldId;

        //
        // We do not allow the creation of entries
        // without any Prefix.
        //

        if (EntryId->Prefix.Length == 0) {
            DfsDbgTrace(-1, Dbg, "PktEntryReassemble: Exit -> %08lx\n",
                                    ULongToPtr(STATUS_INVALID_PARAMETER) );
            return STATUS_INVALID_PARAMETER;
        }

        //
        // need to get rid of our current prefix info.  We save the
        // old Id in case we fail to reassemble the new entry.
        //

        DiscardStatus = DfsRemoveUnicodePrefix(&Pkt->PrefixTable, &(Entry->Id.Prefix));
        DiscardStatus = DfsRemoveUnicodePrefix(&Pkt->ShortPrefixTable, &Entry->Id.ShortPrefix);
        PktpEntryIdMove(&oldId, &Entry->Id);

        //
        // Now we assemble the new Id and attempt to make a new entry
        // in the Pkt prefix table.
        //

        PktpEntryIdMove(&Entry->Id, EntryId);

        if (DfsInsertUnicodePrefix(&Pkt->PrefixTable,
                                   &Entry->Id.Prefix,
                                   &Entry->PrefixTableEntry)
        ) {
            //
            // Everything looks good so its safe to unload the old Id.
            //

            DiscardResult = DfsInsertUnicodePrefix(&Pkt->ShortPrefixTable,
                                   &Entry->Id.ShortPrefix,
                                   &Entry->PrefixTableEntry);

            PktEntryIdDestroy(&oldId, FALSE);
        } else {

            //
            // We were unable to make the new prefix entry, so we
            // attempt to back out and put things back the way
            // they were.
            //

            status = DFS_STATUS_ENTRY_EXISTS;

            PktpEntryIdMove(EntryId, &Entry->Id);
            PktpEntryIdMove(&Entry->Id, &oldId);

            status = DfsInsertInPrefixTable(&Pkt->PrefixTable,
                                        &Entry->Id.Prefix,
                                        &Entry->PrefixTableEntry);

            if( !NT_SUCCESS( status ) ) {

                //
                // We can't get things back to where they were. Return
                // the error that DfsInsertInPrefixTable returned to us
                // (probably STATUS_INSUFFICIENT_RESOURCES)
                //
                // Destory the entry since it can't be found.
                //
                PktEntryDestroy(Entry, Pkt, TRUE);
                DfsDbgTrace(-1, Dbg, "PktEntryReassemble: Exit -> %08lx\n", ULongToPtr(status) );
                return status;

            } else {

                DiscardResult = DfsInsertUnicodePrefix(&Pkt->ShortPrefixTable,
                                                       &Entry->Id.ShortPrefix,
                                                       &Entry->PrefixTableEntry);

            }

        }

    }

    //
    // Now we work on the entry info
    //

    if (NT_SUCCESS(status) && EntryInfo != 0) {

        //
        // Destroy the existing info structure and move the new
        // one into its place.  Note that the active service is
        // Nulled.
        //

        PktEntryInfoDestroy(&Entry->Info, FALSE);
        PktpEntryInfoMove(&Entry->Info, EntryInfo);

        for (i = 0; i < Entry->Info.ServiceCount; i++) {
            Entry->Info.ServiceList[i].pMachEntry->UseCount = 1;

        }

        if (EntryType & PKT_ENTRY_TYPE_REFERRAL_SVC)    {
            pService = Entry->Info.ServiceList;
            for (i=0; i<Entry->Info.ServiceCount; i++)  {
                pService->Type = pService->Type | DFS_SERVICE_TYPE_REFERRAL;
                pService++;
            }
        }

        Entry->ActiveService = NULL;

        //
        // Now we need to make sure that there is only one copy of the
        // DS_MACHINE structures for each of the above services that we added.
        //
        if (!(EntryType & PKT_ENTRY_TYPE_NONDFS))    {
            status = DfsFixDSMachineStructs(Entry);
            if (!NT_SUCCESS(status))    {
                //
                // We messed up. This means that something is really messed up.
                //
                DfsDbgTrace(0, 1,
                        "DFS: DfsFixDSMachineStructs failed for %wZ\n",
                        &Entry->Id.Prefix);

                PktpEntryIdMove(EntryId, &Entry->Id);

                if (ARGUMENT_PRESENT(EntryInfo))
                    PktpEntryInfoMove(EntryInfo, &Entry->Info);

                return(status);
            }
        }
    }

    if (NT_SUCCESS(status) && EntryInfo != 0) {
        Entry->Type |= EntryType;

        //
        // If the new entry type is "local" we adjust all the
        // subordinates to indicate that they are all now
        // local exit points.
        //
        if (Entry->Type & PKT_ENTRY_TYPE_LOCAL) {

            PDFS_PKT_ENTRY subEntry;

            for (subEntry = PktEntryFirstSubordinate(Entry);
                subEntry != NULL;
                subEntry = PktEntryNextSubordinate(Entry, subEntry)) {

                    subEntry->Type |= PKT_ENTRY_TYPE_LOCAL_XPOINT;
            }
        }

        //
        // Finally, we update the USN
        //

        Entry->USN++;
        DfsDbgTrace(0, Dbg, "Updated USN for %wZ", &Entry->Id.Prefix);
        DfsDbgTrace(0, Dbg, " to %d\n", ULongToPtr(Entry->USN) );
    }

    if (status == STATUS_SUCCESS)
    {
        if (Entry->pDfsTargetInfo != NULL)
        {
            PktReleaseTargetInfo( Entry->pDfsTargetInfo );
            Entry->pDfsTargetInfo = pDfsTargetInfo;
            PktAcquireTargetInfo( pDfsTargetInfo );
        }
    }

    DfsDbgTrace(-1, Dbg, "PktEntryReassemble: Exit -> %08lx\n", ULongToPtr(status) );
    return status;
}



//+-------------------------------------------------------------------------
//
//  Function:   PktEntryDestroy, public
//
//  Synopsis:   PktEntryDestroy destroys an pkt entry structure, and
//              optionally deallocates the structure itself.
//
//  Arguments:  [Victim] - the entry structure to destroy
//              [Pkt] - pointer to the PKT this entry is in.
//              [DeallocateAll] - if True, indicates that the structure
//                  itself is to be deallocated, otherwise, only the
//                  service list within the structure is deallocated.
//
//  Returns:    VOID
//
//  Notes:      This should not be called on an entry that has a
//              local service attached, or which is a local exit point.
//
//--------------------------------------------------------------------------
VOID
PktEntryDestroy(
    IN  PDFS_PKT_ENTRY Victim OPTIONAL,
    IN  PDFS_PKT Pkt,
    IN  BOOLEAN DeallocateAll
)
{
    NTSTATUS DiscardStatus;
    DfsDbgTrace(+1, Dbg, "PktEntryDestroy: Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(Pkt));

    //
    // Make sure we have a victim...
    //
    if (!ARGUMENT_PRESENT(Victim)) {
        DfsDbgTrace(-1, Dbg, "PktEntryDestroy: Exit -> No Victim\n", 0);
        return;
    }

    //
    // We really don't expect to have a LocalService but then even if we
    // do have one due to running DFSINIT again etc. let us try to handle it.
    //

    ASSERT(Victim->LocalService == NULL);

    //
    // Remove the entry from the prefix table and from the PKT.
    //

    DiscardStatus = DfsRemoveUnicodePrefix(&Pkt->PrefixTable, &(Victim->Id.Prefix));
    DiscardStatus = DfsRemoveUnicodePrefix(&Pkt->ShortPrefixTable, &(Victim->Id.ShortPrefix));
    PktUnlinkEntry(Pkt, Victim);

    //
    // We clear away all subordinates and parents.
    //
    PktEntryClearSubordinates(Victim);
    if (Victim->Superior)
        PktEntryUnlinkSubordinate(Victim->Superior, Victim);

    //
    // We clear all the children and parent pointers from here.
    //
    PktEntryClearChildren(Victim);
    if (Victim->ClosestDC) {
        PktEntryUnlinkChild(Victim->ClosestDC, Victim);
    }

    //
    // Now destroy the body of the entry (id, and info).
    //

    Victim->ActiveService = NULL;
    PktEntryIdDestroy(&Victim->Id, FALSE);
    PktEntryInfoDestroy(&Victim->Info, FALSE);

    
    if (Victim->pDfsTargetInfo != NULL)
    {
        PktReleaseTargetInfo(Victim->pDfsTargetInfo);
        Victim->pDfsTargetInfo = NULL;
    }
    //
    // Deallocate everything if they want us to.
    //
    if (DeallocateAll)
        ExFreePool(Victim);


    DfsDbgTrace(-1, Dbg, "PktEntryDestroy: Exit -> VOID\n", 0);
}


//+-------------------------------------------------------------------------
//
//  Function:   PktEntryClearSubordinates, public
//
//  Synopsis:   PktEntryClearSubordinates unlinks all subordinates from
//              this entry.
//
//  Arguments:  [PktEntry] - a pointer to an entry that is to have all its
//                  subordinates unlinked.
//
//  Returns:    VOID
//
//  Notes:
//
//--------------------------------------------------------------------------
VOID
PktEntryClearSubordinates(
    IN      PDFS_PKT_ENTRY PktEntry
)
{
    PDFS_PKT_ENTRY subEntry;

    DfsDbgTrace(+1, Dbg, "PktEntryClearSubordinates: Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(PktEntry));

    subEntry = PktEntryFirstSubordinate(PktEntry);
    while (subEntry) {
        PktEntryUnlinkSubordinate(PktEntry, subEntry);
        subEntry = PktEntryFirstSubordinate(PktEntry);
    }

    DfsDbgTrace(-1, Dbg, "PktEntryClearSubordinates: Exit -> VOID\n", 0)
}



//+-------------------------------------------------------------------------
//
//  Function:   PktEntryClearChildren, public
//
//  Synopsis:   PktEntryClearChildren unlinks all children from
//              this entry.
//
//  Arguments:  [PktEntry] - a pointer to an entry that is to have all its
//                           children unlinked.
//
//  Returns:    VOID
//
//  Notes:
//
//--------------------------------------------------------------------------

VOID
PktEntryClearChildren(
    IN      PDFS_PKT_ENTRY PktEntry
)
{
    PDFS_PKT_ENTRY subEntry;

    DfsDbgTrace(+1, Dbg, "PktEntryClearChildren: Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(PktEntry));

    subEntry = PktEntryFirstChild(PktEntry);
    while (subEntry) {
        PktEntryUnlinkAndRelinkChild(PktEntry, subEntry);
        subEntry = PktEntryFirstChild(PktEntry);
    }

    DfsDbgTrace(-1, Dbg, "PktEntryClearChildren: Exit -> VOID\n", 0)
}

//+-------------------------------------------------------------------------
//
//  Function:   PktSpecialEntryDestroy, public
//
//  Synopsis:   Returns a DFS_SPECIAL_ENTRY's expansion list to the free pool
//
//  Arguments:  [pSpecialEntry] - Pointer to DFS_SPECIAL_ENTRY
//
//  Returns:    VOID
//
//  Notes:
//
//--------------------------------------------------------------------------

VOID
PktSpecialEntryDestroy(
    IN  PDFS_SPECIAL_ENTRY pSpecialEntry)
{
    PDFS_EXPANDED_NAME pExpandedNames = pSpecialEntry->ExpandedNames;
    PUNICODE_STRING pustr;
    ULONG i;

    //
    // Free all the UNICODE_STRING ExpandedName buffers
    //
    if (pExpandedNames) {
        for (i = 0; i < pSpecialEntry->ExpandedCount; i++) {
            pustr = &pExpandedNames[i].ExpandedName;
            if (pustr->Buffer) {
                ExFreePool(pustr->Buffer);
            }
        }
        //
        // Free the array of ExpandedNames
        //
        ExFreePool(pExpandedNames);
    }

    //
    // Free the SpecialName buffer
    //

    if (pSpecialEntry->SpecialName.Buffer != NULL) {

        ExFreePool(pSpecialEntry->SpecialName.Buffer);

    }

    //
    // Free the entry itself
    //
    ExFreePool(pSpecialEntry);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\prefix.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       prefix.hxx
//
//  Contents:   PREFIX table definition
//
//  History:    SethuR -- Implemented
//
//  Notes:      The DFS prefix table data structure consists of three
//              entities and methods to manipulate them. They are the
//              DFS_PREFIX_TABLE_ENTRY,DFS_PREFIX_TABLE_BUCKET and the
//              DFS_PREFIX_TABLE.
//
//              The DFS_PREFIX_TABLE is a hash table of DFS_PREFIX_TABLE_ENTRY's
//              wherein collisions are resolved through linear chaining. The
//              hash table is organized as an array of collision lists
//              (DFS_PREFIX_TABLE_BUCKET). A brief description with each of
//              these entities is attached to the declaration.
//
//              There are certain characterstics that distinguish this
//              hash table from other hash tables. These are the extensions
//              provided to accomodate the special operations.
//
//--------------------------------------------------------------------------

#ifndef __PREFIX_HXX__
#define __PREFIX_HXX__

//+---------------------------------------------------------------------
//
// Struct:  DFS_PREFIX_TABLE_ENTRY
//
// History:
//
// Notes:   Each DFS_PREFIX_TABLE entry is in reality a member of two linked
//          lists -- a doubly linked list chaining the entries in a bucket
//          and a singly linked list establishing the path from any entry to
//          the root of the name space. In addition we have the data associated
//          with each entry, viz., the name and the data (pData). We also
//          keep track of the number of children of each entry. It can also
//          be defined as the number of paths to the root of which this entry
//          is a member.
//
//----------------------------------------------------------------------

typedef struct _DFS_PREFIX_TABLE_ENTRY_
{
   struct _DFS_PREFIX_TABLE_ENTRY_  *pParentEntry;
   struct _DFS_PREFIX_TABLE_ENTRY_  *pNextEntry;
   struct _DFS_PREFIX_TABLE_ENTRY_  *pPrevEntry;

   //
   // pFirstChildEntry and pSiblingEntry are used purely for enumeration
   //
   struct _DFS_PREFIX_TABLE_ENTRY_  *pFirstChildEntry;
   struct _DFS_PREFIX_TABLE_ENTRY_  *pSiblingEntry;

   ULONG                             NoOfChildren;

   UNICODE_STRING                    PathSegment;
   PVOID                             pData;
} DFS_PREFIX_TABLE_ENTRY, *PDFS_PREFIX_TABLE_ENTRY;

//+---------------------------------------------------------------------
//
// Struct:  DFS_PREFIX_TABLE_BUCKET
//
// History:
//
// Notes:   The DFS_PREFIX_TABLE_BUCKET is a doubly linked list of
//          DFS_PREFIX_TABLE_ENTRY's. The current implementation employs
//          the notion of a sentinel entry associated with each bucket. The
//          end pointers are never null but are always looped back to the
//          sentinel entry. The reason we employ such an organization is that
//          it considerably simplifies the list manipulation routines. The
//          reason this needs to be a doubly linked list is that we would like
//          to have the ability of deleting entries without having to traverse
//          the buckets from beginning.
//
//          The following inline methods ( macro defns. ) are provided for
//          inserting, deleting and looking up an entry in the bucket.
//
//----------------------------------------------------------------------

typedef struct _PREFIX_TABLE_BUCKET_
{
   ULONG                  NoOfEntries;   // High water mark for entries hashing to the bkt.
   DFS_PREFIX_TABLE_ENTRY SentinelEntry;
} PREFIX_TABLE_BUCKET, *PPREFIX_TABLE_BUCKET;

//+---------------------------------------------------------------------
//
// Struct:  NAME_PAGE
//
// History:
//
// Notes:   The name segments associated with the various entries are all
//          stored together in a name page. This allows us to amortize the
//          memory allocation costs over a number of entries and also allows
//          us to speed up traversal ( for details see DFS_PREFIX_TABLE
//          definition ).
//
//----------------------------------------------------------------------

#define FREESPACE_IN_NAME_PAGE ((PAGE_SIZE - sizeof(ULONG) - sizeof(PVOID)) / sizeof(WCHAR))

typedef struct _NAME_PAGE_
{
   struct _NAME_PAGE_  *pNextPage;
   LONG                cFreeSpace; // free space avilable in WCHAR's
   WCHAR               Names[FREESPACE_IN_NAME_PAGE];
} NAME_PAGE, *PNAME_PAGE;

typedef struct _NAME_PAGE_LIST_
{
   PNAME_PAGE  pFirstPage;
} NAME_PAGE_LIST, *PNAME_PAGE_LIST;

//+---------------------------------------------------------------------
//
// Struct:  DFS_PREFIX_TABLE
//
// History:
//
// Notes:   The DFS_PREFIX_TABLE is a hashed collection of DFS_PREFIX_TABLE_ENTRY
//          organized in the form of buckets. In addition one other space
//          conserving measure is adopted. There is only one copy of each
//          name segment stored in the table. As an example consider the
//          two pathnames \foo\bar and \bar\foo. We only store one copy of foo
//          and bar eventhough we accomdate both these paths. A beneficial
//          side effect of storing single copies is that our traversal of the
//          collision chain is considerably speeded up since once we have
//          located the pointer to the name, subsequent comparisons need merely
//          compare pointers as opposed to strings.
//
//----------------------------------------------------------------------

#define NO_OF_HASH_BUCKETS 57

typedef struct _DFS_PREFIX_TABLE
{
   BOOLEAN             CaseSensitive;
   NAME_PAGE_LIST      NamePageList;
   //
   // NextEntry is used purely for enumeration
   //
   PDFS_PREFIX_TABLE_ENTRY NextEntry;
   DFS_PREFIX_TABLE_ENTRY RootEntry;
   PREFIX_TABLE_BUCKET Buckets[NO_OF_HASH_BUCKETS];

#ifdef KERNEL_MODE

   // Zone for allocating DFS_PREFIX_TABLE entries .....

   ZONE_HEADER         PrefixTableEntryZone;

#else

   // A DFS_PREFIX_TABLE is part of DS_DATA. We need to make the sizes of
   // these structures identical in user and kernel mode, so that user-mode
   // utilities like dfsdump can work.

   CHAR                UnusedBuffer[sizeof(ZONE_HEADER)];

#endif
} DFS_PREFIX_TABLE, *PDFS_PREFIX_TABLE;

//+---------------------------------------------------------------------
//
// Struct:  DFS_PREFIX_TABLE API.
//
// History:
//
// Notes:   The following API's are provided for manipulating the
//          DFS_PREFIX_TABLE.
//
//----------------------------------------------------------------------

extern
NTSTATUS DfsInitializePrefixTable(PDFS_PREFIX_TABLE pTable,
                                  BOOLEAN           fCaseSensitive);

extern
NTSTATUS DfsInsertInPrefixTable(PDFS_PREFIX_TABLE pTable,
                                PUNICODE_STRING   pPath,
                                PVOID             pData);
extern
NTSTATUS DfsLookupPrefixTable(PDFS_PREFIX_TABLE   pTable,
                              PUNICODE_STRING     pPath,
                              PUNICODE_STRING     pSuffix,
                              PVOID               *ppData);

extern
NTSTATUS DfsRemoveFromPrefixTable(PDFS_PREFIX_TABLE pTable,
                                  PUNICODE_STRING pPath);

NTSTATUS
DfsFreePrefixTable(
    PDFS_PREFIX_TABLE pTable);

//
// The RTL Prefix Table function signatures are slightly different.
// For now we will define a mapping between them to ease the porting
// effort. Subsequently we will change our signatures to confirm to
// the RTL routine.
//

#define DfsInitializeUnicodePrefix(pTable) \
        (DfsInitializePrefixTable(pTable,FALSE) == STATUS_SUCCESS)

#define DfsRemoveUnicodePrefix(pTable,pPath)  \
        (DfsRemoveFromPrefixTable(pTable,pPath) == STATUS_SUCCESS)

#define DfsInsertUnicodePrefix(pTable,pPath,pData) \
        (DfsInsertInPrefixTable(pTable,pPath,pData) == STATUS_SUCCESS)

PVOID    DfsFindUnicodePrefix(PDFS_PREFIX_TABLE   pTable,
                              PUNICODE_STRING     pPath,
                              PUNICODE_STRING     pSuffix);

PVOID   DfsNextUnicodePrefix(PDFS_PREFIX_TABLE    pTable,
                             BOOLEAN              fRestart);

#endif // __PREFIX_HXX__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\prefix.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       prefix.c
//
//  Contents:   PREFIX table implementation
//
//  History:    SethuR -- Implemented
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef KERNEL_MODE
#include "dfsprocs.h"

#define Dbg     DEBUG_TRACE_RTL

#else

#define DfsDbgTrace(x,y,z,a)

#endif

#include <prefix.h>
#include <prefixp.h>

PDFS_PREFIX_TABLE_ENTRY
DfspNextUnicodeTableEntry(
    IN PDFS_PREFIX_TABLE_ENTRY pEntry);

#ifdef ALLOC_PRAGMA

#pragma alloc_text( PAGE, DfsFreePrefixTable )
#pragma alloc_text( PAGE, DfsInitializePrefixTable )
#pragma alloc_text( PAGE, DfsInsertInPrefixTable )
#pragma alloc_text( PAGE, DfsLookupPrefixTable )
#pragma alloc_text( PAGE, DfsFindUnicodePrefix )
#pragma alloc_text( PAGE, DfsRemoveFromPrefixTable )

#endif  // ALLOC_PRAGMA

//+---------------------------------------------------------------------------
//
//  Function:   DfsInitializePrefixTable
//
//  Synopsis:   API for initializing the prefix table
//
//  Arguments:  [pTable] -- the DFS prefix table instance
//
//  Returns:    one of the following NTSTATUS codes
//                  STATUS_SUCCESS -- call was successfull.
//
//  History:    04-18-94  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS DfsInitializePrefixTable(PDFS_PREFIX_TABLE pTable, BOOLEAN fCaseSensitive)
{
    NTSTATUS status = STATUS_SUCCESS;

    DfsDbgTrace(+1, Dbg,"DfsInitializePrefixTable -- Entry\n", 0);

    if (pTable != NULL)
    {
        ULONG i;

        // Initialize flags
        pTable->CaseSensitive = fCaseSensitive;

        // Initialize the root entry
        INITIALIZE_PREFIX_TABLE_ENTRY(&pTable->RootEntry);

        // Initialize the various buckets.
        for (i = 0;i < NO_OF_HASH_BUCKETS;i++)
        {
            INITIALIZE_BUCKET(pTable->Buckets[i]);
        }

        // Initialize the name page list.
        pTable->NamePageList.pFirstPage = ALLOCATE_NAME_PAGE();
        if (pTable->NamePageList.pFirstPage != NULL)
        {
            INITIALIZE_NAME_PAGE(pTable->NamePageList.pFirstPage);

            // Initialize the prefix table entry allocation mechanism.
            status = _InitializePrefixTableEntryAllocation(pTable);
        }
        else
        {
            status = STATUS_NO_MEMORY;
            DfsDbgTrace(0, Dbg,"DfsInitializePrefixTable Error -- %lx\n", ULongToPtr(status) );
        }
    }
    else
    {
        status = STATUS_INVALID_PARAMETER;
        DfsDbgTrace(0, Dbg,"DfsInitializePrefixTable Error -- %lx\n", ULongToPtr(status) );
    }

    DfsDbgTrace(-1, Dbg, "DfsInitializePrefixTable -- Exit\n", 0);
    return  status;
}

//+---------------------------------------------------------------------------
//
//  Function:   DfsInsertInPrefixTable
//
//  Synopsis:   API for inserting a path in the prefix table
//
//  Arguments:  [pTable] -- the DFS prefix table instance
//
//              [pPath]  -- the path to be looked up.
//
//              [pData] -- BLOB associated with the path
//
//  Returns:    one of the following NTSTATUS codes
//                  STATUS_SUCCESS -- call was successfull.
//
//  History:    04-18-94  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS DfsInsertInPrefixTable(PDFS_PREFIX_TABLE pTable,
                                 PUNICODE_STRING   pPath,
                                 PVOID             pData)
{
    NTSTATUS                status = STATUS_SUCCESS;
    WCHAR                   Buffer[MAX_PATH_SEGMENT_SIZE];
    PWCHAR                  NameBuffer = Buffer;
    USHORT                  cbNameBuffer = sizeof(Buffer);
    UNICODE_STRING          Path,Name;
    ULONG                   BucketNo;
    PDFS_PREFIX_TABLE_ENTRY pEntry = NULL;
    PDFS_PREFIX_TABLE_ENTRY pParentEntry = NULL;
    BOOLEAN                 fNameFound = FALSE;

    DfsDbgTrace(+1, Dbg, "DfsInsertInPrefixTable -- Entry\n", 0);

    // There is one special case, i.e., in which the prefix is '\'.
    // Since this is the PATH_DELIMITER which is treated in a special
    // way, we do the processing upfront.

    if (pPath->Length == 0)
    {
        return STATUS_SUCCESS;
    }
    else if ((pPath->Length == sizeof(WCHAR)) &&
        (pPath->Buffer[0] == PATH_DELIMITER))
    {
       pTable->RootEntry.pData = pData;
       return STATUS_SUCCESS;
    }
    else
    {
        Path.Length = pPath->Length - sizeof(WCHAR);
        Path.MaximumLength = pPath->MaximumLength;
        Path.Buffer = &pPath->Buffer[1];
        pParentEntry = &pTable->RootEntry;
    }

    if (Path.Length > MAX_PATH_SEGMENT_SIZE * sizeof(WCHAR) ) {
        NameBuffer = ExAllocatePoolWithTag( NonPagedPool, Path.Length + sizeof(WCHAR), ' puM' );
        if (NameBuffer == NULL) {
            DfsDbgTrace(0, Dbg, "Unable to allocate %d non-paged bytes\n", (Path.Length + sizeof(WCHAR)) );
            return( STATUS_INSUFFICIENT_RESOURCES );
        } else {
            cbNameBuffer = Path.Length + sizeof(WCHAR);
        }
    }

    while (Path.Length > 0)
    {
        Name.Length = 0;
        Name.Buffer = NameBuffer;
        Name.MaximumLength = cbNameBuffer;

        // Process the name segment
        if (pTable->CaseSensitive)
        {
            SPLIT_CASE_SENSITIVE_PATH(&Path,&Name,BucketNo);
        }
        else
        {
            SPLIT_CASE_INSENSITIVE_PATH(&Path,&Name,BucketNo);
        }

        if (Name.Length > 0)
        {
            // Lookup the table to see if the name segment already exists.
            DfsDbgTrace(0, Dbg, "LOOKUP_BUCKET: Bucket(%ld)\n", ULongToPtr(BucketNo) );
            DfsDbgTrace(0, Dbg, " for Name(%wZ)\n", &Name);

            LOOKUP_BUCKET(pTable->Buckets[BucketNo],Name,pParentEntry,pEntry,fNameFound);

            DfsDbgTrace(0, Dbg, "returned pEntry(%lx)", pEntry);
            DfsDbgTrace(0, Dbg, " fNameFound(%s)\n", fNameFound ? "TRUE" : "FALSE");

            if (pEntry == NULL)
            {
                // Initialize the new entry and initialize the name segment.
                pEntry = ALLOCATE_DFS_PREFIX_TABLE_ENTRY(pTable);
                if (pEntry != NULL)
                {
                    INITIALIZE_PREFIX_TABLE_ENTRY(pEntry);

                    // Allocate the name space entry if there is no entry in the
                    // name page.
                    if (!fNameFound || fNameFound)
                    {
                        PWSTR pBuffer;

                        // Allocate the entry in the name page.
                        pBuffer = ALLOCATE_NAME_PAGE_ENTRY((pTable->NamePageList),(Name.Length/sizeof(WCHAR)));

                        if (pBuffer != NULL)
                        {
                            RtlZeroMemory(pBuffer,Name.Length);
                            RtlCopyMemory(pBuffer,Name.Buffer,Name.Length);
                            pEntry->PathSegment = Name;
                            pEntry->PathSegment.Buffer = pBuffer;
                        }
                        else
                        {
                            status = STATUS_NO_MEMORY;
                            break;
                        }
                    }
                    else
                        pEntry->PathSegment = Name;

                    // thread the entry to point to the parent.
                    pEntry->pParentEntry = pParentEntry;

                    // Insert the entry in the bucket.
                    INSERT_IN_BUCKET(pTable->Buckets[BucketNo],pEntry);

                    // Insert the entry in the parent's children list.
                    INSERT_IN_CHILD_LIST(pEntry, pParentEntry);
                }
                else
                {
                    status = STATUS_NO_MEMORY;
                    DfsDbgTrace(0, Dbg, "DfsInsertInPrefixTable Error -- %lx\n", ULongToPtr(status) );
                    break;
                }
            }
            else
            {
                // Increment the no. of children associated with  this entry

                pEntry->NoOfChildren++;
            }

            pParentEntry = pEntry;
        }
        else
        {
            status = STATUS_INVALID_PARAMETER;
            DfsDbgTrace(0, Dbg, "DfsInsertInPrefixTable Error -- %lx\n", ULongToPtr(status) );
            break;
        }
    }

    // If a new entry was not successfully inserted we need to walk up the chain
    // of parent entries to undo the increment to the reference count and
    // remove the entries from their parent links.
    if (NT_SUCCESS(status))
    {
        // The entry was successfully inserted in the prefix table. Update
        // the data (BLOB) associated with it.
        // We do it outside the loop to prevent redundant comparisons within
        // the loop.

        pEntry->pData = pData;
    }
    else
    {
        while (pParentEntry != NULL)
        {
            PDFS_PREFIX_TABLE_ENTRY pMaybeTempEntry;

            pMaybeTempEntry = pParentEntry;
            pParentEntry = pParentEntry->pParentEntry;

            if (--pMaybeTempEntry->NoOfChildren == 0) {
                //
                // If pParentEntry == NULL, pMaybeTempEntry is
                // pTable->RootEntry. Do not try to remove it.
                //
                if (pParentEntry != NULL) {
                    REMOVE_FROM_CHILD_LIST(pMaybeTempEntry);
                    REMOVE_FROM_BUCKET(pMaybeTempEntry);
                    FREE_DFS_PREFIX_TABLE_ENTRY(pTable, pMaybeTempEntry);
                }
            }
        }
    }

    if (NameBuffer != Buffer) {
        ExFreePool( NameBuffer );
    }

    DfsDbgTrace(-1, Dbg, "DfsInsertInPrefixTable -- Exit\n", 0);
    return status;
}

//+---------------------------------------------------------------------------
//
//  Function:   DfsLookupPrefixTable
//
//  Synopsis:   private fn. for looking up a name segment in a prefix table
//
//  Arguments:  [pTable] -- the DFS prefix table instance
//
//              [pPath]  -- the path to be looked up.
//
//              [pSuffix] -- the suffix that could not be found.
//
//              [ppData] -- placeholder for the BLOB for the prefix.
//
//
//  Returns:    one of the following NTSTATUS codes
//                  STATUS_SUCCESS -- call was successfull.
//                  STATUS_OBJECT_PATH_NOT_FOUND -- no entry for the path
//
//  History:    04-18-94  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS DfsLookupPrefixTable(PDFS_PREFIX_TABLE   pTable,
                               PUNICODE_STRING     pPath,
                               PUNICODE_STRING     pSuffix,
                               PVOID               *ppData)
{
    NTSTATUS                status = STATUS_SUCCESS;
    PDFS_PREFIX_TABLE_ENTRY pEntry = NULL;

    DfsDbgTrace(+1, Dbg, "DfsLookupInPrefixTable -- Entry\n", 0);

    if (pPath->Length == 0)
    {
        DfsDbgTrace(-1, Dbg, "DfsLookupInPrefixTable Exited - Null Path!\n", 0);
        return STATUS_SUCCESS;
    }
    else
    {
        status = _LookupPrefixTable(pTable,pPath,pSuffix,&pEntry);

        // Update the BLOB placeholder with the results of the lookup.
        if (NT_SUCCESS(status))
        {
             *ppData = pEntry->pData;
        }

        DfsDbgTrace(-1, Dbg, "DfsLookupInPrefixTable -- Exit\n", 0);
        return status;
    }

}

//+---------------------------------------------------------------------------
//
//  Function:   DfsFindUnicodePrefix
//
//  Synopsis:   fn. for looking up a name segment in a prefix table
//
//  Arguments:  [pTable] -- the DFS prefix table instance
//
//              [pPath]  -- the path to be looked up.
//
//              [pSuffix] -- the suffix that could not be found.
//
//  Returns:    a valid ptr if successfull, NULL otherwise
//
//  History:    04-18-94  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

PVOID DfsFindUnicodePrefix(PDFS_PREFIX_TABLE   pTable,
                           PUNICODE_STRING     pPath,
                           PUNICODE_STRING     pSuffix)
{
    NTSTATUS                status = STATUS_SUCCESS;
    PDFS_PREFIX_TABLE_ENTRY pEntry = NULL;
    PVOID                   pData  = NULL;

    DfsDbgTrace(+1, Dbg, "DfsFindUnicodePrefix -- Entry\n", 0);

    if (pPath->Length == 0)
    {
        DfsDbgTrace(-1, Dbg, "DfsFindUnicodePrefix Exited - Null Path!\n", 0);
        return NULL;
    }
    else
    {
        status = _LookupPrefixTable(pTable,pPath,pSuffix,&pEntry);

        // Update the BLOB placeholder with the results of the lookup.
        if (NT_SUCCESS(status))
        {
             pData = pEntry->pData;
        }

        DfsDbgTrace(-1, Dbg, "DfsFindUnicodePrefix -- Exit\n", 0);
        return pData;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   DfsRemoveFromPrefixTable
//
//  Synopsis:   private fn. for looking up a name segment in a prefix table
//
//  Arguments:  [pTable] -- the DFS prefix table instance
//
//              [pPath]  -- the path to be looked up.
//
//  Returns:    one of the following NTSTATUS codes
//                  STATUS_SUCCESS -- call was successfull.
//                  STATUS_OBJECT_PATH_NOT_FOUND -- no entry for the path
//
//  History:    04-18-94  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS DfsRemoveFromPrefixTable(PDFS_PREFIX_TABLE pTable,
                                   PUNICODE_STRING pPath)
{
    NTSTATUS status = STATUS_SUCCESS;
    UNICODE_STRING Path,Suffix;
    ULONG    BucketNo;

    PDFS_PREFIX_TABLE_ENTRY pEntry = NULL;

    DfsDbgTrace(+1, Dbg, "DfsRemoveFromPrefixTable -- Entry\n", 0);

    Suffix.Length = 0;
    Suffix.Buffer = NULL;

    if (pPath->Length == 0)
    {
        DfsDbgTrace(-1, Dbg, "DfsRemoveFromPrefixTable Exited -- Null Path!\n", 0);
        return STATUS_SUCCESS;
    }

    else if ((pPath->Length == sizeof(WCHAR)) &&
        (pPath->Buffer[0] == PATH_DELIMITER))
    {
        if (pTable->RootEntry.pData == NULL)
        {
            status = STATUS_OBJECT_PATH_NOT_FOUND;
        }
        else
        {
            pTable->RootEntry.pData = NULL;
            DfsDbgTrace(-1, Dbg, "DfsRemoveFromPrefixTable Exited.\n", 0);
            return  STATUS_SUCCESS;
        }
    }
    else
    {
        Path.Length = pPath->Length - sizeof(WCHAR);
        Path.MaximumLength = pPath->MaximumLength;
        Path.Buffer = &pPath->Buffer[1];

        status = _LookupPrefixTable(pTable,&Path,&Suffix,&pEntry);

        if (NT_SUCCESS(status) && (Suffix.Length == 0))
        {
            // Destroy the association between the data associated with
            // this prefix.
            pEntry->pData = NULL;

            // found an exact match for the given path name in the table.
            // traverse the list of parent pointers and delete them if
            // required.

            while (pEntry != NULL)
            {
                if ((--pEntry->NoOfChildren) == 0)
                {
                    PDFS_PREFIX_TABLE_ENTRY pTempEntry = pEntry;
                    pEntry = pEntry->pParentEntry;

                    //
                    // pEntry == NULL means pTempEntry is pTable->RootEntry.
                    // Do not try to remove it.
                    //
                    if (pEntry != NULL) {
                        REMOVE_FROM_CHILD_LIST(pTempEntry);
                        REMOVE_FROM_BUCKET(pTempEntry);
                        FREE_DFS_PREFIX_TABLE_ENTRY(pTable,pTempEntry);
                    }
                }
                else
                   break;
            }
        }
    }

    DfsDbgTrace(-1, Dbg, "DfsRemoveFromPrefixTable -- Exit\n", 0);
    return status;
}

//+---------------------------------------------------------------------------
//
//  Function:   DfsFreePrefixTable
//
//  Synopsis:   API for freeing a prefix table
//
//  Arguments:  [pTable] -- the DFS prefix table instance
//
//  Returns:    one of the following NTSTATUS codes
//                  STATUS_SUCCESS -- call was successfull.
//
//  History:    08-01-99 JHarper Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS
DfsFreePrefixTable(
    PDFS_PREFIX_TABLE pTable)
{
    NTSTATUS status = STATUS_SUCCESS;
    PNAME_PAGE pNamePage = NULL;
    PNAME_PAGE pNextPage = NULL;
    PDFS_PREFIX_TABLE_ENTRY pEntry = NULL;
    PDFS_PREFIX_TABLE_ENTRY pSentinelEntry = NULL;
    ULONG i;

    if (pTable != NULL) {
       for (i = 0; i < NO_OF_HASH_BUCKETS; i++) {
            pSentinelEntry = &pTable->Buckets[i].SentinelEntry;
            while (pSentinelEntry->pNextEntry != pSentinelEntry) {
                pEntry = pSentinelEntry->pNextEntry;
                REMOVE_FROM_BUCKET(pEntry);
                if (pEntry->PathSegment.Buffer != NULL)
                    ExFreePool(pEntry->PathSegment.Buffer);
                ExFreePool(pEntry);
            }
            pTable->Buckets[i].NoOfEntries = 0;
        }
        if (pTable->RootEntry.PathSegment.Buffer != NULL)
            ExFreePool(pTable->RootEntry.PathSegment.Buffer);

        for (pNamePage = pTable->NamePageList.pFirstPage;
                pNamePage;
                    pNamePage = pNextPage
        ) {
            pNextPage = pNamePage->pNextPage;
            ExFreePool(pNamePage);
        }

    } else {
        status = STATUS_INVALID_PARAMETER;
    }

    return  status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\pool.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    heapmgr.c

Abstract:

    This module contains debugging routines for the MUP use of
    non-paged pool.

Author:

    Manny Weiser (mannyw)    27-Jan-1992

--*/

#include "mup.h"

#if MUPDBG

LIST_ENTRY PagedPoolList = { &PagedPoolList, &PagedPoolList };

typedef struct _POOL_HEADER {
    LIST_ENTRY ListEntry;
    ULONG RequestedSize;
    BLOCK_TYPE BlockType;
    PVOID Caller;
    PVOID CallersCaller;
} POOL_HEADER, *PPOOL_HEADER;

struct _MEMORY_STATISTICS {
    ULONG BytesInUse;
    ULONG TotalBytesAllocated;
    ULONG MaxBytesInUse;
    ULONG TotalBytesFreed;
    ULONG BlocksInUse;
    ULONG TotalBlocksAllocated;
    ULONG MaxBlocksInUse;
    ULONG TotalBlocksFreed;
} MupMemoryUsage = { 0, 0, 0, 0, 0, 0, 0, 0 };

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MupAllocatePoolDebug )
#pragma alloc_text( PAGE, MupFreePoolDebug )
#endif

PVOID
MupAllocatePoolDebug (
    IN POOL_TYPE PoolType,
    IN CLONG BlockSize,
    IN BLOCK_TYPE BlockType
    )
{
    PPOOL_HEADER header;
    KIRQL oldIrql;

    PAGED_CODE();

    header = FsRtlAllocatePool( PoolType, sizeof(POOL_HEADER) + BlockSize );

    header->RequestedSize = BlockSize;
    header->BlockType = BlockType;
    RtlGetCallersAddress( &header->Caller, &header->CallersCaller );

    ACQUIRE_LOCK( &MupDebugLock );
    InsertTailList( &PagedPoolList, &header->ListEntry );

    MupMemoryUsage.TotalBlocksAllocated += 1;
    MupMemoryUsage.BlocksInUse += 1;
    MupMemoryUsage.TotalBytesAllocated += BlockSize;
    MupMemoryUsage.BytesInUse += BlockSize;

    if ( MupMemoryUsage.BlocksInUse > MupMemoryUsage.MaxBlocksInUse ) {
        MupMemoryUsage.MaxBlocksInUse = MupMemoryUsage.BlocksInUse;
    }

    if ( MupMemoryUsage.BytesInUse > MupMemoryUsage.MaxBytesInUse ) {
        MupMemoryUsage.MaxBytesInUse = MupMemoryUsage.BytesInUse;
    }

    RELEASE_LOCK( &MupDebugLock );

    return (PVOID)(header + 1);

} // MupAllocatePagedPoolDebug

VOID
MupFreePoolDebug (
    IN PVOID P
    )
{
    PPOOL_HEADER header;
    KIRQL oldIrql;

    PAGED_CODE();

    header = (PPOOL_HEADER)P - 1;

    ACQUIRE_LOCK( &MupDebugLock );
    RemoveEntryList( &header->ListEntry );

    MupMemoryUsage.TotalBlocksFreed += 1;
    MupMemoryUsage.BlocksInUse -= 1;
    MupMemoryUsage.TotalBytesFreed += header->RequestedSize;
    MupMemoryUsage.BytesInUse -= header->RequestedSize;
    RELEASE_LOCK( &MupDebugLock );

    ExFreePool( header );

} // MupFreePagedPoolDebug

#endif // MUPDBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\prefixp.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       prefixp.c
//
//  Contents:   PREFIX table implementation
//
//  History:    SethuR -- Implemented
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef KERNEL_MODE

#include "dfsprocs.h"

#define Dbg DEBUG_TRACE_RTL

#else

#define DfsDbgTrace(x,y,z,a)

#endif


#include <prefix.h>
#include <prefixp.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, _InitializePrefixTableEntryAllocation )
#pragma alloc_text( PAGE, _AllocateNamePageEntry )
#pragma alloc_text( PAGE, _AllocatePrefixTableEntry )
#pragma alloc_text( PAGE, _LookupPrefixTable )
#endif // ALLOC_PRAGMA

//
//  This macro takes a pointer (or ulong) and returns its rounded up quadword
//  value
//

#define QuadAlign(Ptr) (        \
    ((((ULONG)(Ptr)) + 7) & 0xfffffff8) \
    )

//+---------------------------------------------------------------------------
//
//  Function:   _InitializePrefixTableEntryAllocation
//
//  Synopsis:   private fn. for initializing prefix table entry allocation
//
//  Arguments:  [pTable] -- table to be initialized
//
//  Returns:    one of the following NTSTATUS codes
//                  STATUS_SUCCESS -- call was successfull.
//                  STATUS_NO_MEMORY -- no resource available
//
//  History:    04-18-94  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS _InitializePrefixTableEntryAllocation(PDFS_PREFIX_TABLE pTable)
{
    NTSTATUS status = STATUS_SUCCESS;

    return  status;
}


//+---------------------------------------------------------------------------
//
//  Function:   _AllocateNamePageEntry
//
//  Synopsis:   private fn. for allocating a name page entry
//
//  Arguments:  [pNamePageList] -- name page list to allocate from
//
//              [cLength]  -- length of the buffer in WCHAR's
//
//  Returns:    NULL if unsuccessfull otherwise valid pointer
//
//  History:    04-18-94  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

PWSTR _AllocateNamePageEntry(PNAME_PAGE_LIST pNamePageList,
                             ULONG           cLength)
{
   PNAME_PAGE pTempPage = pNamePageList->pFirstPage;
   PWSTR pBuffer = NULL;

   while (pTempPage != NULL)
   {
       if (pTempPage->cFreeSpace > (LONG)cLength)
          break;
       else
          pTempPage = pTempPage->pNextPage;
   }

   if (pTempPage == NULL)
   {
       pTempPage = ALLOCATE_NAME_PAGE();

       if (pTempPage != NULL)
       {
           INITIALIZE_NAME_PAGE(pTempPage);
           pTempPage->pNextPage = pNamePageList->pFirstPage;
           pNamePageList->pFirstPage = pTempPage;
           pTempPage->cFreeSpace = FREESPACE_IN_NAME_PAGE;
       }
   }

   if ((pTempPage != NULL) && (pTempPage->cFreeSpace >= (LONG)cLength))
   {
       pTempPage->cFreeSpace -= cLength;
       pBuffer = &pTempPage->Names[pTempPage->cFreeSpace];
   }

   return pBuffer;
}

//+---------------------------------------------------------------------------
//
//  Function:   _AllocatePrefixTableEntry
//
//  Synopsis:   allocate prefic table entry
//
//  Arguments:  [pTable] -- the prefix table from which we need to allocate.
//
//  Returns:    returns a valid pointer if successfull otherwise NULL
//
//  History:    04-18-94  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

PDFS_PREFIX_TABLE_ENTRY _AllocatePrefixTableEntry(PDFS_PREFIX_TABLE pTable)
{
    PDFS_PREFIX_TABLE_ENTRY pEntry = NULL;

#ifdef KERNEL_MODE
    NTSTATUS status;
    PVOID    pSegment = NULL;

    pSegment = ExAllocatePoolWithTag(PagedPool,PREFIX_TABLE_ENTRY_SEGMENT_SIZE, ' puM');
    if (pSegment != NULL)
    {
        status = ExExtendZone(&pTable->PrefixTableEntryZone,
                              pSegment,
                              PREFIX_TABLE_ENTRY_SEGMENT_SIZE);

        if (NT_SUCCESS(status))
        {
            pEntry = ALLOCATE_DFS_PREFIX_TABLE_ENTRY(pTable);
        }
        else
        {
            DfsDbgTrace(0, Dbg, "ExExtendZone returned %lx\n", ULongToPtr(status) );
        }
    }
#endif

    return  pEntry;
}

//+---------------------------------------------------------------------------
//
//  Function:   _LookupPrefixTable
//
//  Synopsis:   private fn. for looking up a name segment in a prefix table
//
//  Arguments:  [pTable] -- the DFS prefix table instance
//
//              [pPath]  -- the path to be looked up.
//
//              [pSuffix] -- the suffix that could not be found.
//
//              [ppEntry] -- placeholder for the matching entry for the prefix.
//
//
//  Returns:    one of the following NTSTATUS codes
//                  STATUS_SUCCESS -- call was successfull.
//                  STATUS_OBJECT_PATH_NOT_FOUND -- no entry for the path
//
//  History:    04-18-94  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS _LookupPrefixTable(PDFS_PREFIX_TABLE        pTable,
                            UNICODE_STRING           *pPath,
                            UNICODE_STRING           *pSuffix,
                            PDFS_PREFIX_TABLE_ENTRY  *ppEntry)
{
    NTSTATUS                status = STATUS_SUCCESS;
    UNICODE_STRING          Path = *pPath;
    WCHAR                   Buffer[MAX_PATH_SEGMENT_SIZE];
    PWCHAR                  NameBuffer = Buffer;
    USHORT                  cbNameBuffer = sizeof(Buffer);
    UNICODE_STRING          Name;
    ULONG                   BucketNo;
    BOOLEAN                 fPrefixFound = FALSE;
    PDFS_PREFIX_TABLE_ENTRY pEntry = NULL;
    PDFS_PREFIX_TABLE_ENTRY pParentEntry = &pTable->RootEntry;
    BOOLEAN                 fNameFound = FALSE;

    DfsDbgTrace(0, Dbg, "_LookupPrefixTable -- Entry\n", 0);


    // The \ is treated as a special case. The test for all names starting with
    // a delimiter is done before we initiate the complete search process.

    if (Path.Buffer[0] == PATH_DELIMITER)
    {
        Path.Length = Path.Length - sizeof(WCHAR);
        Path.Buffer += 1; // Skip the path delimiter at the beginning.

        if (pTable->RootEntry.pData != NULL)
        {
            fPrefixFound = TRUE;
            *pSuffix     = Path;
            *ppEntry     = &pTable->RootEntry;
        }
    }

    if (Path.Length > MAX_PATH_SEGMENT_SIZE) {
        NameBuffer = ExAllocatePoolWithTag( NonPagedPool, Path.Length + sizeof(WCHAR), ' puM' );
        if (NameBuffer == NULL) {
            DfsDbgTrace(0, Dbg, "Unable to allocate %d non-paged bytes\n", (Path.Length + sizeof(WCHAR)) );
            return( STATUS_INSUFFICIENT_RESOURCES );
        } else {
            cbNameBuffer = Path.Length + sizeof(WCHAR);
        }
    }

    while (Path.Length > 0)
    {
        Name.Length = 0;
        Name.Buffer = NameBuffer;
        Name.MaximumLength = cbNameBuffer;

        if (pTable->CaseSensitive)
        {
            SPLIT_CASE_SENSITIVE_PATH(&Path,&Name,BucketNo);
        }
        else
        {
            SPLIT_CASE_INSENSITIVE_PATH(&Path,&Name,BucketNo);
        }

        if (Name.Length > 0)
        {
            // Process the name segment
            // Lookup the bucket to see if the entry exists.
            DfsDbgTrace(0, Dbg, "LOOKUP_BUCKET: Bucket(%ld)", ULongToPtr(BucketNo) );
            DfsDbgTrace(0, Dbg, "for Name(%wZ)\n", &Name);

            LOOKUP_BUCKET(pTable->Buckets[BucketNo],Name,pParentEntry,pEntry,fNameFound);

            DfsDbgTrace(0, Dbg, "Returned pEntry(%lx)", pEntry);
            DfsDbgTrace(0, Dbg, " and fNameFound(%s)\n",fNameFound ? "TRUE" : "FALSE" );

            if (pEntry != NULL)
            {
                // Cache the data available for this prefix if any.
                if (pEntry->pData != NULL)
                {
                    *pSuffix      = Path;
                    *ppEntry      = pEntry;
                    fPrefixFound  = TRUE;
                }
            }
            else
            {
                break;
            }

            // set the stage for processing the next name segment.
            pParentEntry = pEntry;
        }
    }

    if (!fPrefixFound)
    {
        status = STATUS_OBJECT_PATH_NOT_FOUND;
        DfsDbgTrace(0, Dbg, "_LookupPrefixTable Error -- %lx\n", ULongToPtr(status) );
    }

    if (NameBuffer != Buffer) {
        ExFreePool( NameBuffer );
    }

    DfsDbgTrace(-1, Dbg, "_LookupPrefixTable -- Exit\n", 0);
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\provider.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       provider.c
//
//  Contents:   Module to initialize DFS driver providers.
//
//  Classes:
//
//  Functions:  ProviderInit --
//              DfsGetProviderForDevice
//              DfsInsertProvider
//
//  History:    12 Sep 1992     Milans created.
//              05 Apr 1993     Milans moved into driver.
//
//-----------------------------------------------------------------------------

#include "dfsprocs.h"
#include "rpselect.h"
#include "provider.h"

#define MAX_ENTRY_PATH          80               // Max. length of entry path

#define Dbg                     DEBUG_TRACE_INIT
#define prov_debug_out(x, y)    DfsDbgTrace(0, Dbg, x, y)


#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, ProviderInit )
#pragma alloc_text( PAGE, DfsGetProviderForDevice )
#pragma alloc_text( PAGE, DfsInsertProvider )
#endif // ALLOC_PRAGMA


//+----------------------------------------------------------------------------
//
//  Function:  ProviderInit
//
//  Synopsis:  Initializes the provider list with
//              - Local File service provider
//              - Standard remote Cairo provider
//              - Downlevel LanMan provider.
//
//  Arguments: None
//
//  Returns:   STATUS_SUCCESS
//
//-----------------------------------------------------------------------------

NTSTATUS
ProviderInit(void)
{
    NTSTATUS Status;
    UNICODE_STRING ustrProviderName;

    //
    // Initialize the Dfs aware SMB provider
    //

    RtlInitUnicodeString(&ustrProviderName, DD_NFS_DEVICE_NAME_U);

    Status = DfsInsertProvider(
                 &ustrProviderName,
                 PROV_DFS_RDR,
                 PROV_ID_DFS_RDR);

    if (!NT_SUCCESS(Status))
        return(Status);

    RtlInitUnicodeString(&ustrProviderName, DD_MUP_DEVICE_NAME);

    Status = DfsInsertProvider(
                 &ustrProviderName,
                 PROV_STRIP_PREFIX,
                 PROV_ID_MUP_RDR);

    return( Status );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsGetProviderForDevice
//
//  Synopsis:   Retrieves a provider definition given a Device Name. If the
//              provider definition does not exist, a new one is created and
//              returned.
//
//              This routine is meant for use in handling a STATUS_REPARSE
//              returned by the MUP. Since only downlevel requests are sent
//              to the MUP, this routine will always return a provider def
//              that is marked as downlevel (ie, Capability has the
//              PROV_STRIP_PREFIX bit set).
//
//  Arguments:  [DeviceName] -- Name of Device to look for.
//
//              [Provider] -- On successful return, contains pointer to
//                      PROVIDER_DEF with given DeviceName.
//
//  Returns:    [STATUS_SUCCESS] -- Provider returned.
//
//              [STATUS_INSUFFICIENT_RESOURCES] -- Out of memory condition.
//
//              [STATUS_FS_DRIVER_REQUIRED] -- Don't have appropriate
//                      provider.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsGetProviderForDevice(
    PUNICODE_STRING DeviceName,
    PPROVIDER_DEF *Provider)
{
    NTSTATUS status;
    int i;

    ExAcquireResourceExclusiveLite( &DfsData.Resource, TRUE );

    *Provider = NULL;

    for (i = 0; i < DfsData.cProvider && *Provider == NULL; i++) {

        if ((DfsData.pProvider[i].DeviceName.Length == DeviceName->Length) &&
                (DfsData.pProvider[i].fProvCapability & PROV_STRIP_PREFIX) != 0) {

            if (RtlEqualUnicodeString(
                    &DfsData.pProvider[i].DeviceName,
                        DeviceName, TRUE)) {

                *Provider = &DfsData.pProvider[i];

                status = STATUS_SUCCESS;

                break;

            }

        }

    }

    if (*Provider == NULL) {

        //
        // Attempt to create a new provider def
        //

        UNICODE_STRING ProviderName;

        ProviderName.Length = DeviceName->Length;
        ProviderName.MaximumLength = ProviderName.Length + sizeof(WCHAR);

        ProviderName.Buffer = (PWCHAR) ExAllocatePoolWithTag(
                                PagedPool,
                                ProviderName.MaximumLength,
                                ' puM');

        if (ProviderName.Buffer != NULL) {

            RtlZeroMemory(
                ProviderName.Buffer,
                ProviderName.MaximumLength);

            RtlMoveMemory(
                ProviderName.Buffer,
                DeviceName->Buffer,
                ProviderName.Length);

            status = DfsInsertProvider(
                        &ProviderName,
                        PROV_STRIP_PREFIX,
                        i);

            if (status == STATUS_SUCCESS) {

                *Provider = &DfsData.pProvider[i];

            } else {

                ExFreePool( ProviderName.Buffer );

            }

        } else {

            status = STATUS_INSUFFICIENT_RESOURCES;

        }

    }

    ExReleaseResourceLite( &DfsData.Resource );

    if (*Provider != NULL && (*Provider)->FileObject == NULL) {

        //
        // We found (or created) a provider definition that is
        //

        *Provider = ReplLookupProvider( i );

        if (*Provider == NULL)
            status = STATUS_FS_DRIVER_REQUIRED;

    }

    return( status );

}


//+----------------------------------------------------------------------------
//
//  Function:   DfsInsertProvider
//
//  Synopsis:   Given a provider name, id, and capability, will add a new or
//              overwrite an existing provider definition.
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

NTSTATUS DfsInsertProvider(
    IN PUNICODE_STRING  ProviderName,
    IN ULONG            fProvCapability,
    IN ULONG            eProviderId)
{
    PPROVIDER_DEF pProv = DfsData.pProvider;
    int iProv;

    //
    //  Find a free provider structure, or overwrite an existing one.
    //

    for (iProv = 0; iProv < DfsData.cProvider; iProv++, pProv++) {
        if (pProv->eProviderId == eProviderId)
            break;
    }

    if (iProv >= DfsData.maxProvider) {
        ASSERT(iProv >= DfsData.maxProvider && "Out of provider structs");
        return(STATUS_INSUFFICIENT_RESOURCES);

    }

    if (iProv < DfsData.cProvider) {

        //
        // Decrement reference counts on saved objects
        //
        if (pProv->FileObject)
            ObDereferenceObject(pProv->FileObject);
        if (pProv->DeviceObject)
            ObDereferenceObject(pProv->DeviceObject);
        if (pProv->DeviceName.Buffer)
            ExFreePool(pProv->DeviceName.Buffer);
    }

    pProv->FileObject = NULL;
    pProv->DeviceObject = NULL;


    pProv->eProviderId = (USHORT) eProviderId;
    pProv->fProvCapability = (USHORT) fProvCapability;
    pProv->DeviceName = *ProviderName;

    if (iProv == DfsData.cProvider) {
        DfsData.cProvider++;
    }

    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\prefixp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       prefix.hxx
//
//  Contents:   PREFIX table definition
//
//  History:    SethuR -- Implemented
//
//  Notes:      The DFS prefix table data structure consists of three
//              entities and methods to manipulate them. They are the
//              DFS_PREFIX_TABLE_ENTRY,DFS_PREFIX_TABLE_BUCKET and the
//              DFS_PREFIX_TABLE.
//
//              The DFS_PREFIX_TABLE is a hash table of DFS_PREFIX_TABLE_ENTRY's
//              wherein collisions are resolved through linear chaining. The
//              hash table is organized as an array of collision lists
//              (DFS_PREFIX_TABLE_BUCKET). A brief description with each of
//              these entities is attached to the declaration.
//
//              There are certain characterstics that distinguish this
//              hash table from other hash tables. These are the extensions
//              provided to accomodate the special operations.
//
//--------------------------------------------------------------------------

#ifndef __PREFIXP_H__
#define __PREFIXP_H__

#include <prefix.h>


//--------------------------------------------------------------------------
//
// PREFIX TABLE UTILITIES
//
// A Path is a sequence of one or more name segments alternated with a
// distinguished concatenation character ( typically \ in FAT,NTFS,HPFS and
// / in UNIX file systems). These utilities are used to split a given path
// into the first path segment followed by the remainder of the path.
//
// SPLIT_PATH("foo\bar\bar1",Name,RemainingPath) binds Name to foo and
// RemainingPath to bar\bar1
//
// Similarly PROCESS_CASE_SENSITIVE_NAME and PROCESS_CASE_INSENSITIVE_NAME
// compute the hash signatures ( bucket no. ) for a given string.
//
//--------------------------------------------------------------------------


//
// MAX_PATH_SEGMENT_SIZE is simply used as a good size buffer to do prefix
// lookups and insertions. This should save us from having to allocate for
// most cases.
//

#define MAX_PATH_SEGMENT_SIZE  256
#define PATH_DELIMITER L'\\'

//+---------------------------------------------------------------------------
//
//  Function:   SPLIT_CASE_INSENSITIVE_PATH
//
//  Synopsis:   Split the path name around deleimiters.
//
//  Arguments:  [pPath] -- path to be split(PUNICODE_STRING)
//
//              [pName] -- the leftmost component of the path(PUNICODE_STRING)
//
//              [BucketNo] -- Hash Bucket no. corresponding to the name(ULONG)
//
//  SideEffects: the UNICODE_STRING pointed to by pName and BucketNo are
//               modified.
//
//  PreRequisite: pName be associated with a valid buffer.
//
//  History:    04-18-94  SethuR Created
//
//  Notes:      defined as a macro for inlining
//
//----------------------------------------------------------------------------

#define SPLIT_CASE_INSENSITIVE_PATH(pPath,pName,BucketNo)                    \
{                                                                            \
    WCHAR *pPathBuffer   = (pPath)->Buffer;                                  \
    WCHAR *pNameBuffer   = (pName)->Buffer;                                  \
    WCHAR *pPathBufferEnd = &pPathBuffer[(pPath)->Length / sizeof(WCHAR)];   \
                                                                             \
    BucketNo = 0;                                                            \
    while ((pPathBufferEnd != pPathBuffer) &&                                \
           ((*pNameBuffer = *pPathBuffer++) != PATH_DELIMITER))              \
    {                                                                        \
        *pNameBuffer = (*pNameBuffer < L'a')                                 \
                       ? *pNameBuffer                                        \
                       : ((*pNameBuffer < L'z')                              \
                          ? (*pNameBuffer - L'a' + L'A')                     \
                          : RtlUpcaseUnicodeChar(*pNameBuffer));             \
        BucketNo *= 131;                                                     \
        BucketNo += *pNameBuffer;                                            \
        pNameBuffer++;                                                       \
    }                                                                        \
                                                                             \
    BucketNo = BucketNo % NO_OF_HASH_BUCKETS;                                \
    *pNameBuffer = L'\0';                                                    \
    (pName)->Length = (USHORT)((CHAR *)pNameBuffer - (CHAR *)(pName)->Buffer); \
                                                                             \
    (pPath)->Length = (USHORT)((CHAR *)pPathBufferEnd - (CHAR *)pPathBuffer); \
    (pPath)->Buffer = pPathBuffer;                                           \
    DfsDbgTrace(0, Dbg, "SPLIT_PATH:Path (%wZ)",pPath);                      \
    DfsDbgTrace(0, Dbg, " Name (%wZ)\n",pName);                              \
}                                                                            \

//+---------------------------------------------------------------------------
//
//  Function:   SPLIT_CASE_SENSITIVE_PATH
//
//  Synopsis:   Split the patah name around deleimiters.
//
//  Arguments:  [pPath] -- path to be split(PUNICODE_STRING)
//
//              [pName] -- the leftmost component of the path(PUNICODE_STRING)
//
//              [BucketNo] -- Hash Bucket no. corresponding to the name(ULONG)
//
//  SideEffects: the UNICODE_STRING pointed to by pName and BucketNo are modified.
//
//  PreRequisite: pName be associated with a valid buffer.
//
//  History:    04-18-94  SethuR Created
//
//  Notes:      defined as a macro for inlining
//
//----------------------------------------------------------------------------

#define SPLIT_CASE_SENSITIVE_PATH(pPath,pName,BucketNo)                      \
{                                                                            \
    WCHAR *pPathBuffer   = (pPath)->Buffer;                                  \
    WCHAR *pNameBuffer   = (pName)->Buffer;                                  \
    WCHAR *pPathBufferEnd = &pPathBuffer[(pPath)->Length / sizeof(WCHAR)];   \
                                                                             \
    BucketNo = 0;                                                            \
    while ((pPathBufferEnd != pPathBuffer) &&                                \
           ((*pNameBuffer = *pPathBuffer++) != PATH_DELIMITER))              \
    {                                                                        \
        BucketNo *= 131;                                                     \
        BucketNo += *pNameBuffer;                                            \
        pNameBuffer++;                                                       \
    }                                                                        \
                                                                             \
    BucketNo = BucketNo % NO_OF_HASH_BUCKETS;                                \
    *pNameBuffer = L'\0';                                                    \
    (pName)->Length = (USHORT)((CHAR *)pNameBuffer - (CHAR *)(pName)->Buffer); \
                                                                             \
    (pPath)->Length = (USHORT)((CHAR *)pPathBufferEnd - (CHAR *)pPathBuffer); \
    (pPath)->Buffer = pPathBuffer;                                           \
    DfsDbgTrace(0, Dbg, "SPLIT_PATH:Path (%wZ)",pPath);                      \
    DfsDbgTrace(0, Dbg, " Name (%wZ)\n",pName);                              \
}                                                                            \


//+---------------------------------------------------------------------------
//
//  Function:   INITIALIZE_BUCKET
//
//  Synopsis:   Initializes a hash bucket.
//
//  Arguments:  [Bucket] -- the bucket to be initialized(DFS_PREFIX_TABLE_BUCKET)
//
//  SideEffects: the bucket is intialized ( the collision list and count are
//               initialized
//
//  History:    04-18-94  SethuR Created
//
//  Notes:      defined as a macro for inlining
//
//----------------------------------------------------------------------------

#define INITIALIZE_BUCKET(Bucket)                                           \
{                                                                           \
   (Bucket).SentinelEntry.pNextEntry = &(Bucket).SentinelEntry;             \
   (Bucket).SentinelEntry.pPrevEntry = &(Bucket).SentinelEntry;             \
   (Bucket).NoOfEntries = 0;                                                \
}                                                                           \

//+---------------------------------------------------------------------------
//
//  Function:   LOOKUP_BUCKET
//
//  Synopsis:   lookups the bucket for an entry.
//
//  Arguments:  [Bucket] -- the bucket to be used (DFS_PREFIX_TABLE_BUCKET)
//
//              [Name]   -- the name to be looked up (UNICODE_STRING)
//
//              [pParentEntry] -- the parent entry of the entry we are
//                                searching for.
//
//              [pEntry] -- placeholder for the desired entry.
//
//              [fNameFound] -- indicates if the name was found.
//
//  SideEffects: Name,fNameFound and pEntry are modified
//
//  History:    04-18-94  SethuR Created
//
//  Notes:      defined as a macro for inlining
//
//              We only store one copy of a string irrespective of the no. of
//              places it appears in, e.g. foo\bar and foo1\bar will result
//              in only one copy of bar being stored. This implies that the
//              lookup routine will have to return sufficient info. to prevent
//              the allocation of memory space for a string. If on exit
//              fNameFound is set to TRUE then this indicates that a similar
//              string was located in the table and the Name.Buffer field is
//              modified to point to the first instance of the string in
//              the table.
//
//----------------------------------------------------------------------------

#define LOOKUP_BUCKET(Bucket,Name,pParentEntry,pEntry,fNameFound)           \
{                                                                           \
    PDFS_PREFIX_TABLE_ENTRY pCurEntry = Bucket.SentinelEntry.pNextEntry;    \
                                                                            \
    DfsDbgTrace(0, Dbg, "LOOKUP_BUCKET: Looking for (%wZ)\n", &Name);        \
    fNameFound = FALSE;                                                     \
    pEntry = NULL;                                                          \
                                                                            \
    while (pCurEntry != &Bucket.SentinelEntry)                              \
    {                                                                       \
        if (pCurEntry->PathSegment.Length == Name.Length)                   \
        {                                                                   \
            DfsDbgTrace(0, Dbg, "LOOKUP_BUCKET: Looking at Entry with Name (%wZ)\n",&pCurEntry->PathSegment); \
            if (fNameFound &&                                               \
               (pCurEntry->PathSegment.Buffer == Name.Buffer))              \
            {                                                               \
                if (pCurEntry->pParentEntry == pParentEntry)                \
                {                                                           \
                    pEntry = pCurEntry;                                     \
                    break;                                                  \
                }                                                           \
            }                                                               \
            else if (!memcmp(pCurEntry->PathSegment.Buffer,                 \
                             Name.Buffer,                                   \
                             Name.Length))                                  \
            {                                                               \
                fNameFound = TRUE;                                          \
                Name.Buffer = pCurEntry->PathSegment.Buffer;                \
                if (pCurEntry->pParentEntry == pParentEntry)                \
                {                                                           \
                    pEntry = pCurEntry;                                     \
                    break;                                                  \
                }                                                           \
            }                                                               \
        }                                                                   \
                                                                            \
        pCurEntry = pCurEntry->pNextEntry;                                  \
    }                                                                       \
}                                                                           \

//+---------------------------------------------------------------------------
//
//  Function:   INSERT_IN_BUCKET
//
//  Synopsis:   inserts the entry in the bucket
//
//  Arguments:  [Bucket] -- the bucket to be initialized(DFS_PREFIX_TABLE_BUCKET)
//
//              [pEntry] -- the entry to be inserted
//
//  SideEffects: Bucket is modified to include the entry
//
//  History:    04-18-94  SethuR Created
//
//  Notes:      defined as a macro for inlining
//
//----------------------------------------------------------------------------

#define INSERT_IN_BUCKET(Bucket,pEntry)                                     \
{                                                                           \
    (Bucket).NoOfEntries++;                                                 \
    (pEntry)->pPrevEntry = (Bucket).SentinelEntry.pPrevEntry;               \
    (pEntry)->pNextEntry = &((Bucket).SentinelEntry);                       \
    ((Bucket).SentinelEntry.pPrevEntry)->pNextEntry = (pEntry);             \
    (Bucket).SentinelEntry.pPrevEntry = (pEntry);                           \
}                                                                           \

//+---------------------------------------------------------------------------
//
//  Function:   REMOVE_FROM_BUCKET
//
//  Synopsis:   removes the entry from the bucket
//
//  Arguments:  [pEntry] -- the entry to be inserted
//
//  SideEffects: Bucket is modified to exclude the entry
//
//  History:    04-18-94  SethuR Created
//
//  Notes:      defined as a macro for inlining
//
//----------------------------------------------------------------------------

#define REMOVE_FROM_BUCKET(pEntry)                                          \
{                                                                           \
    PDFS_PREFIX_TABLE_ENTRY pPrevEntry = (pEntry)->pPrevEntry;              \
    PDFS_PREFIX_TABLE_ENTRY pNextEntry = (pEntry)->pNextEntry;              \
                                                                            \
    pPrevEntry->pNextEntry = pNextEntry;                                    \
    pNextEntry->pPrevEntry = pPrevEntry;                                    \
}                                                                           \

//+---------------------------------------------------------------------------
//
//  Function:   INSERT_IN_CHILD_LIST
//
//  Synopsis:   Inserts this entry in the parent's list of children
//
//  Arguments:  [pEntry] -- the entry to be inserted
//
//              [pParentEntry] -- the entry into whose list of children
//                      pEntry has to be inserted.
//
//  SideEffects: Parent's list of children is modified.
//
//  History:    01-09-96  MilanS Created
//
//  Notes:      defined as a macro for inlining
//
//----------------------------------------------------------------------------

#define INSERT_IN_CHILD_LIST(pEntry, pParentEntry)                           \
{                                                                            \
    PDFS_PREFIX_TABLE_ENTRY pLastChild;                                      \
                                                                             \
    if (pParentEntry->pFirstChildEntry == NULL) {                            \
        pParentEntry->pFirstChildEntry = pEntry;                             \
    } else {                                                                 \
        for (pLastChild = pParentEntry->pFirstChildEntry;                    \
                pLastChild->pSiblingEntry != NULL;                           \
                    pLastChild = pLastChild->pSiblingEntry) {                \
             NOTHING;                                                        \
        }                                                                    \
        pLastChild->pSiblingEntry = pEntry;                                  \
    }                                                                        \
}

//+----------------------------------------------------------------------------
//
//  Function:   REMOVE_FROM_CHILD_LIST
//
//  Synopsis:   Removes an entry from its parent's list of children
//
//  Arguments:  [pEntry] -- the Entry to remove from children list.
//
//  SideEffects: The children list of pParentEntry is modified.
//
//  History:    01-09-96  MilanS Created
//
//  Notes:      Defined as a macro for inlining.
//
//              This routine will ASSERT if pEntry is not in the parent's
//              list of children.
//
//-----------------------------------------------------------------------------

#define REMOVE_FROM_CHILD_LIST(pEntry)                                       \
{                                                                            \
    PDFS_PREFIX_TABLE_ENTRY pParentEntry = pEntry->pParentEntry;             \
    PDFS_PREFIX_TABLE_ENTRY pPrevSibling;                                    \
                                                                             \
    if (pParentEntry->pFirstChildEntry == pEntry) {                          \
        pParentEntry->pFirstChildEntry = pEntry->pSiblingEntry;              \
    } else {                                                                 \
        for (pPrevSibling = pParentEntry->pFirstChildEntry;                  \
                pPrevSibling->pSiblingEntry != pEntry;                       \
                    pPrevSibling = pPrevSibling->pSiblingEntry) {            \
             ASSERT(pPrevSibling->pSiblingEntry != NULL);                    \
        }                                                                    \
        pPrevSibling->pSiblingEntry = pEntry->pSiblingEntry;                 \
    }                                                                        \
}

//+---------------------------------------------------------------------------
//
//  Function:   INITIALIZE_NAME_PAGE
//
//  Synopsis:   initializes the name page
//
//  Arguments:  [pNamePage] -- the NAME_PAGE to be initialized
//
//  SideEffects: the name page is initialized
//
//  History:    04-18-94  SethuR Created
//
//  Notes:      defined as a macro for inlining
//
//----------------------------------------------------------------------------

#define INITIALIZE_NAME_PAGE(pNamePage)                                      \
{                                                                            \
    pNamePage->pNextPage = NULL;                                             \
    pNamePage->cFreeSpace = FREESPACE_IN_NAME_PAGE - 1;                      \
    pNamePage->Names[FREESPACE_IN_NAME_PAGE - 1] = L'\0';                    \
}                                                                            \

//+---------------------------------------------------------------------------
//
//  Function:   INITIALIZE_PREFIX_TABLE_ENTRY
//
//  Synopsis:   initializes the prefix table entry
//
//  Arguments:  [pEntry] -- the entry to be initialized
//
//  SideEffects: the prefix table entry is modified
//
//  History:    04-18-94  SethuR Created
//
//  Notes:      defined as a macro for inlining
//
//----------------------------------------------------------------------------

#define INITIALIZE_PREFIX_TABLE_ENTRY(pEntry)                                \
{                                                                            \
    RtlZeroMemory( pEntry, sizeof( DFS_PREFIX_TABLE_ENTRY ) );               \
    (pEntry)->NoOfChildren = 1;                                              \
}                                                                            \

//+---------------------------------------------------------------------------
//
//  Function:   private fns. extern declarations
//
//----------------------------------------------------------------------------

extern
NTSTATUS _LookupPrefixTable(PDFS_PREFIX_TABLE        pTable,
                            UNICODE_STRING           *pPath,
                            UNICODE_STRING           *pSuffix,
                            PDFS_PREFIX_TABLE_ENTRY  *ppEntry);

//+---------------------------------------------------------------------------
//
//  Function:   ALLOCATION ROUTINES
//
//  Synopsis:   all the allocation routines are defined to be used in the KERNEL as
//              well as user mode. The KERNEL mode is turned on by defining KERNEL
//
//  History:    04-18-94  SethuR Created
//
//  Notes:      defined as a macro for inlining
//
//----------------------------------------------------------------------------

#define PREFIX_TABLE_ENTRY_SEGMENT_SIZE PAGE_SIZE

extern
NTSTATUS
_InitializePrefixTableEntryAllocation(PDFS_PREFIX_TABLE pTable);

extern
PWSTR _AllocateNamePageEntry(PNAME_PAGE_LIST pPageList,ULONG cLength);

extern
PDFS_PREFIX_TABLE_ENTRY _AllocatePrefixTableEntry(PDFS_PREFIX_TABLE pTable);

#ifdef KERNEL_MODE

#define ALLOCATE_NAME_PAGE() (PNAME_PAGE)ExAllocatePoolWithTag(PagedPool,sizeof(NAME_PAGE), ' puM')

#define FREE_NAME_PAGE(pPage) ExFreePool(pPage)

#define ALLOCATE_NAME_PAGE_ENTRY(PageList,cLength)                           \
    ExAllocatePoolWithTag(PagedPool, cLength * sizeof(WCHAR), ' puM');       \

#define FREE_NAME_PAGE_ENTRY(PageList,pName)

#define ALLOCATE_DFS_PREFIX_TABLE_ENTRY(pTable)                             \
 (PDFS_PREFIX_TABLE_ENTRY) ExAllocatePoolWithTag(PagedPool,sizeof(DFS_PREFIX_TABLE_ENTRY), ' puM')

#define FREE_DFS_PREFIX_TABLE_ENTRY(pTable,pEntry)                           \
    if ((pEntry)->PathSegment.Buffer != NULL) {                              \
        ExFreePool((pEntry)->PathSegment.Buffer);                            \
    }                                                                        \
    ExFreePool((pEntry));

#define COMPARE_MEMORY(s,d,l)   (!RtlEqualMemory(s,d,l))

#else

#define ALLOCATE_NAME_PAGE() (PNAME_PAGE)malloc(sizeof(NAME_PAGE))

#define FREE_NAME_PAGE(pPage) free(pPage)

#define ALLOCATE_NAME_PAGE_ENTRY(PageList,cLength) malloc(cLength * sizeof(WCHAR))

#define FREE_NAME_PAGE_ENTRY(PageList,pName)

#define ALLOCATE_DFS_PREFIX_TABLE_ENTRY(pTable)                              \
    (PDFS_PREFIX_TABLE_ENTRY)malloc(sizeof(DFS_PREFIX_TABLE_ENTRY))

#define FREE_DFS_PREFIX_TABLE_ENTRY(pTable,pEntry) free((pEntry))

#define COMPARE_MEMORY(s,d,l)   memcmp(s,d,l)

#endif

#endif // __PREFIXP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\provider.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       provider.h
//
//  Contents:   Interface to the provider defining module
//
//  Classes:
//
//  Functions:  ProviderInit
//
//  History:    12 Sep 1992 	Milans created.
//
//-----------------------------------------------------------------------------

#ifndef _DFS_PROVIDERS_
#define _DFS_PROVIDERS_

NTSTATUS ProviderInit(void);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\regsup.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    regsup.c

Abstract:

    This module contains routine that interact with registry.

Author:

    Manny Weiser (mannyw)    30-Mar-92

Revision History:

--*/

#include "mup.h"
//#include "stdlib.h"
//#include "zwapi.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_FSCONTROL)

//
//  local procedure prototypes
//

#if DBG
VOID
MupGetDebugFlags(void);
#endif

VOID
DfsGetEventLogValue(VOID);

VOID
DfsGetEventLogValue(VOID);

VOID
InitializeProvider(
    PWCH ProviderName,
    ULONG Priority
    );

VOID
AddUnregisteredProvider(
    PWCH providerName,
    ULONG priority
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AddUnregisteredProvider )
#pragma alloc_text( PAGE, InitializeProvider )
#pragma alloc_text( PAGE, MupCheckForUnregisteredProvider )
#pragma alloc_text( PAGE, MupGetProviderInformation )
#pragma alloc_text( PAGE, DfsGetEventLogValue )
#if DBG
#pragma alloc_text( PAGE, MupGetDebugFlags )
#endif
#endif


VOID
MupGetProviderInformation (
    VOID
    )

/*++

Routine Description:

    This routine reads MUP information from the registry and saves it for
    future use.

Arguments:

    None.

Return Value:

    None.

--*/

{
    HANDLE handle;
    NTSTATUS status;
    UNICODE_STRING valueName;
    UNICODE_STRING keyName;
    OBJECT_ATTRIBUTES objectAttributes;
    PVOID buffer = NULL;
    PWCH providerName;
    ULONG lengthRequired;
    BOOLEAN done;
    ULONG priority;
    PWCH sep;

    PAGED_CODE();
    RtlInitUnicodeString( &keyName, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Networkprovider\\Order" );
    InitializeObjectAttributes(
        &objectAttributes,
        &keyName,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        0,
        NULL
        );

    status = ZwOpenKey(
                 &handle,
                 KEY_QUERY_VALUE,
                 &objectAttributes
                 );

    if ( !NT_SUCCESS( status )) {
        return;
    }

    RtlInitUnicodeString( &valueName, L"ProviderOrder" );

    status = ZwQueryValueKey(
                 handle,
                 &valueName,
                 KeyValueFullInformation,
                 buffer,
                 0,
                 &lengthRequired
                 );

    if ( status == STATUS_BUFFER_TOO_SMALL ) {
        buffer = ExAllocatePoolWithTag( PagedPool, lengthRequired + 2, ' puM');
        if ( buffer == NULL) {
            ZwClose( handle );
            return;
        }

        status = ZwQueryValueKey(
                     handle,
                     &valueName,
                     KeyValueFullInformation,
                     buffer,
                     lengthRequired,
                     &lengthRequired
                     );
    }

    ZwClose( handle );

    if ( !NT_SUCCESS( status)  ) {
        if ( buffer != NULL ) {
            ExFreePool( buffer );
        }
        return;
    }

    //
    // Scan the ordered list of providers, and create record for each.
    //

    providerName = (PWCH)((PCHAR)buffer + ((PKEY_VALUE_FULL_INFORMATION)buffer)->DataOffset);

    done = FALSE;
    priority = 0;
    while ( !done ) {
        sep = wcschr( providerName, L',');
        if ( sep == NULL ) {
            done = TRUE;
        } else {
            *sep = L'\0';
        }

        InitializeProvider( providerName, priority );
        priority++;
        providerName = sep+1;
    }

    ExFreePool( buffer );
    return;
}

VOID
InitializeProvider(
    PWCH ProviderName,
    ULONG Priority
    )

/*++

Routine Description:

    This routine reads provider information out of the registry and
    creates an unregistered provider entry.

Arguments:

    ProviderName - The registry name for the provider.

    Priority - The priority to assign to this provider.

Return Value:

    None.

--*/

{
    UNICODE_STRING keyName;
    PVOID buffer = NULL;
    ULONG bufferLength;
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    ULONG lengthRequired;
    UNICODE_STRING valueName;
    HANDLE handle;

    PAGED_CODE();
    //
    // Allocate space for the registry string
    //

    bufferLength = sizeof( L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\" ) +
                   wcslen( ProviderName ) * sizeof( WCHAR ) +
                   sizeof( L"\\NetworkProvider" );

    buffer = ExAllocatePoolWithTag( PagedPool, bufferLength, ' puM' );
    if ( buffer == NULL ) {
        return;
    }

    //
    // Build the registry string
    //

    RtlMoveMemory(
        buffer,
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\",
        sizeof( L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\" )
        );

    keyName.Buffer = buffer;
    keyName.MaximumLength = (USHORT)bufferLength;
    keyName.Length = sizeof( L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\" ) - 2;

    status = RtlAppendUnicodeToString( &keyName, ProviderName );
    ASSERT( NT_SUCCESS( status ) );
    status = RtlAppendUnicodeToString( &keyName, L"\\NetworkProvider" );
    ASSERT( NT_SUCCESS( status ) );

    InitializeObjectAttributes(
        &objectAttributes,
        &keyName,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        0,
        NULL
        );

    status = ZwOpenKey(
                 &handle,
                 KEY_QUERY_VALUE,
                 &objectAttributes
                 );

    ExFreePool( buffer );
    if ( !NT_SUCCESS( status )) {
        return;
    }

    buffer = NULL;
    RtlInitUnicodeString( &valueName, L"DeviceName" );

    status = ZwQueryValueKey(
                 handle,
                 &valueName,
                 KeyValueFullInformation,
                 buffer,
                 0,
                 &lengthRequired
                 );

    if ( status == STATUS_BUFFER_TOO_SMALL ) {
        buffer = ExAllocatePoolWithTag( PagedPool, lengthRequired + 2, ' puM' );
        if ( buffer == NULL) {
            return;
        }

        status = ZwQueryValueKey(
                     handle,
                     &valueName,
                     KeyValueFullInformation,
                     buffer,
                     lengthRequired,
                     &lengthRequired
                     );
    }

    if ( !NT_SUCCESS( status) ) {
        if ( buffer != NULL ) {
            ExFreePool( buffer );
        }
        ZwClose( handle );
        return;
    }

    //
    // Wahoo!  We actually have the device name in hand.  Add the
    // provider to the unregistered list.
    //

    AddUnregisteredProvider(
        (PWCH)((PCHAR)buffer + ((PKEY_VALUE_FULL_INFORMATION)buffer)->DataOffset),
        Priority
        );

    ExFreePool( buffer );
    ZwClose( handle );
    return;
}

PUNC_PROVIDER
MupCheckForUnregisteredProvider(
    PUNICODE_STRING DeviceName
    )

/*++

Routine Description:

    This routine checks the list of unregistered providers for one whose
    device name matches the provider attempting to register.

    If one is found it is dequeued from the list of unregistered providers.

Arguments:

    DeviceName - The device name of the registering provider.

Return Value:

    UNC_PROVIDER - A pointer to the matching unregistered provider, or
        NULL if no match is found.

--*/

{
    PLIST_ENTRY listEntry;
    PUNC_PROVIDER uncProvider;

    PAGED_CODE();
    MupAcquireGlobalLock();

    for (listEntry = MupProviderList.Flink;
         listEntry !=  &MupProviderList;
         listEntry = listEntry->Flink ) {

        uncProvider = CONTAINING_RECORD( listEntry, UNC_PROVIDER, ListEntry );

	if(uncProvider->Registered == FALSE) {
        
	    //
	    // If we find a match take it out of the list, and
	    // return it to the caller.
	    //

	    if ( RtlEqualUnicodeString( DeviceName, &uncProvider->DeviceName, TRUE )) {
	      
		uncProvider->BlockHeader.BlockState = BlockStateActive;
		MupReleaseGlobalLock();
		return uncProvider;

	    }
	}
    }

    MupReleaseGlobalLock();
    return NULL;
}

VOID
AddUnregisteredProvider(
    PWCH ProviderName,
    ULONG Priority
    )
/*++

Routine Description:

    This routine queues an unregistered provider on a list.

Arguments:

    ProviderName - The device name of the provider. (from the registry)

    Priority - A priority for the provider.

Return Value:

    None.

--*/
{
    ULONG nameLength;
    PUNC_PROVIDER uncProvider;

    PAGED_CODE();
    nameLength = wcslen( ProviderName ) * 2;

    try {

        uncProvider = MupAllocateUncProvider( nameLength );

        if (uncProvider != NULL) {

            uncProvider->DeviceName.MaximumLength = (USHORT)nameLength;
            uncProvider->DeviceName.Length = (USHORT)nameLength;
            uncProvider->DeviceName.Buffer = (PWCH)(uncProvider + 1);
            uncProvider->Priority = Priority; 

            RtlMoveMemory(
                (PVOID)(uncProvider + 1),
                ProviderName,
                nameLength
                );

            MupAcquireGlobalLock();
            InsertTailList( &MupProviderList, &uncProvider->ListEntry );
            MupReleaseGlobalLock();

        }
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        NOTHING;
    }

}

VOID
DfsGetEventLogValue(VOID)

/*++

Routine Description:

    This routine checks registry keys to set the event logging level

Arguments:

    None

Return Value:

    None
    

--*/

{
    NTSTATUS status;
    HANDLE DfsRegHandle;
    OBJECT_ATTRIBUTES ObjAttr;
    ULONG ValueSize;

    UNICODE_STRING DfsRegKey;
    UNICODE_STRING DfsValueName;

    struct {
        KEY_VALUE_PARTIAL_INFORMATION Info;
        ULONG Buffer;
    } DfsValue;

    PAGED_CODE();

    RtlInitUnicodeString(
        &DfsRegKey,
        L"\\Registry\\Machine\\SOFTWARE\\MicroSoft\\Windows NT\\CurrentVersion\\Diagnostics");

    InitializeObjectAttributes(
        &ObjAttr,
        &DfsRegKey,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        0,
        NULL);

    status = ZwOpenKey(
                &DfsRegHandle,
                KEY_QUERY_VALUE,
                &ObjAttr);

    if (!NT_SUCCESS(status))
        return;

    RtlInitUnicodeString(&DfsValueName, L"RunDiagnosticLoggingGlobal");

    status = ZwQueryValueKey(
                DfsRegHandle,
                &DfsValueName,
                KeyValuePartialInformation,
                (PVOID) &DfsValue,
                sizeof(DfsValue),
                &ValueSize);

    if (NT_SUCCESS(status) && DfsValue.Info.Type == REG_DWORD) {

        DfsEventLog = *((PULONG) DfsValue.Info.Data);
        goto Cleanup;

    }

    RtlInitUnicodeString(&DfsValueName, L"RunDiagnosticLoggingDfs");

    status = ZwQueryValueKey(
                DfsRegHandle,
                &DfsValueName,
                KeyValuePartialInformation,
                (PVOID) &DfsValue,
                sizeof(DfsValue),
                &ValueSize);

    if (NT_SUCCESS(status) && DfsValue.Info.Type == REG_DWORD)
        DfsEventLog = *((PULONG) DfsValue.Info.Data);

Cleanup:

    ZwClose( DfsRegHandle );

}

#if DBG

VOID
MupGetDebugFlags(
    VOID
    )

/*++

Routine Description:

    This routine reads MUP debug flag settings from the registry

Arguments:

    None.

Return Value:

    None.

--*/

{
    HANDLE handle;
    NTSTATUS status;
    UNICODE_STRING valueName;
    UNICODE_STRING keyName;
    OBJECT_ATTRIBUTES objectAttributes;
    PWCH providerName;
    ULONG lengthRequired;
    ULONG Flags = 0;

     union {
        KEY_VALUE_FULL_INFORMATION;
        UCHAR   buffer[ sizeof( KEY_VALUE_FULL_INFORMATION ) + 100 ];
    } keyValueInformation;

    PAGED_CODE();

    //
    // Get MupDebugTraceLevel
    //

    RtlInitUnicodeString(
        &keyName,
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Dfs");

    InitializeObjectAttributes(
        &objectAttributes,
        &keyName,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        0,
        NULL);

    status = ZwOpenKey(
                 &handle,
                 KEY_QUERY_VALUE,
                 &objectAttributes);

    if (!NT_SUCCESS(status))
        goto GetNext;

    RtlInitUnicodeString( &valueName, L"MupDebugTraceLevel" );

    status = ZwQueryValueKey(
                 handle,
                 &valueName,
                 KeyValueFullInformation,
                 &keyValueInformation,
                 sizeof(keyValueInformation),
                 &lengthRequired
                 );

    if (
        NT_SUCCESS(status) &&
        keyValueInformation.Type == REG_DWORD &&
        keyValueInformation.DataLength != 0
    ) {

        Flags = *(PULONG)(((PUCHAR)(&keyValueInformation)) + keyValueInformation.DataOffset);
        DfsDebugTraceLevel = Flags;

    }

    ZwClose( handle );

GetNext:

    //
    // Now get MupVerbose
    //

    RtlInitUnicodeString(
        &keyName,
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Dfs");

    InitializeObjectAttributes(
        &objectAttributes,
        &keyName,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        0,
        NULL);

    status = ZwOpenKey(
                 &handle,
                 KEY_QUERY_VALUE,
                 &objectAttributes);

    if (!NT_SUCCESS(status))
        return;

    RtlInitUnicodeString( &valueName, L"MupVerbose" );

    status = ZwQueryValueKey(
                 handle,
                 &valueName,
                 KeyValueFullInformation,
                 &keyValueInformation,
                 sizeof(keyValueInformation),
                 &lengthRequired
                 );

    if (
        NT_SUCCESS(status) &&
        keyValueInformation.Type == REG_DWORD &&
        keyValueInformation.DataLength != 0
    ) {

        Flags = *(PULONG)(((PUCHAR)(&keyValueInformation)) + keyValueInformation.DataOffset);
        MupVerbose = Flags;

    }

    ZwClose( handle );

    return;
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\rpselect.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       rpselect.c
//
//  Contents:   Routines to select and walk down a PKT Entry's svc list.
//
//  Classes:
//
//  Functions:  ReplFindFirstProvider - find first appropriate provider
//              ReplFindNextProvider - walk the list of providers.
//
//              ReplFindRemoteService - Helper function to find a remote
//                      (ie, not local) service.
//
//  History:    31 Aug 92       MilanS created.
//
//-----------------------------------------------------------------------------

#include "dfsprocs.h"
#include "rpselect.h"
#include "mupwml.h"

#define Dbg     (DEBUG_TRACE_DNR)

NTSTATUS ReplFindRemoteService(
    IN PDFS_PKT_ENTRY           pPktEntry,
    IN PREPL_SELECT_CONTEXT     pSelectContext,
    OUT ULONG                   *piSvc);


#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, ReplFindFirstProvider )
#pragma alloc_text( PAGE, ReplFindNextProvider )
#pragma alloc_text( PAGE, ReplLookupProvider )
#pragma alloc_text( PAGE, ReplFindRemoteService )
#endif // ALLOC_PRAGMA


//+----------------------------------------------------------------------------
//
//  Function:  ReplFindFirstProvider
//
//  Synopsis:  Supports the abstraction that a PKT Entry's service list is an
//             ORDERED list, with a distinguished "first" element. This
//             function returns that first element.
//
//  Arguments: [pPktEntry]      - Contains the Service List.
//             [pidPrincipal]   - Look for a service with this machine id
//             [pustrPrincipal] - Look for a service with this principal name
//             [ppService]      - Will be set to point to the Service Structure
//             [pSelectContext] - An opaque structure that will get initialized
//                                properly for future calls to
//                                ReplFindNextProvider().
//             [pLastEntry]     - TRUE if last entry, FALSE otherwise
//
//  Notes:      Assumes PktEntry is locked.
//
//  Returns:    [STATUS_SUCCESS] -- If provider found.
//
//              [STATUS_NO_MORE_ENTRIES] -- If no provider found.
//
//              [STATUS_OBJECT_NAME_NOT_FOUND] if prin. name spec'd but no
//                      service has that name.
//
//              [STATUS_OBJECT_TYPE_MISMATCH] if prin. name spec'd and matched
//                      with service, but service can't be used because of
//                      type or provider incompatibility.
//
//-----------------------------------------------------------------------------

NTSTATUS
ReplFindFirstProvider(
    IN PDFS_PKT_ENTRY pPktEntry,
    IN GUID *pidPrincipal,
    IN PUNICODE_STRING pustrPrincipal,
    OUT PDFS_SERVICE *ppService,
    OUT PREPL_SELECT_CONTEXT pSelectContext,
    OUT BOOLEAN *pLastEntry
) {

    NTSTATUS Status;
    PDFS_SERVICE psvcFirst = NULL;
    ULONG iSvc;

    ASSERT(pPktEntry != NULL);

    DfsDbgTrace(+1, Dbg, "ReplFindFirstProvider Entered.\n", 0);

    *pLastEntry = FALSE;

    //
    // See if the user wants a service with a specific machine id
    //

    ASSERT( pidPrincipal == NULL );

    //
    // See if the user wants us to pick a particular server
    //

    ASSERT( pustrPrincipal == NULL );

    // Initialize the SelectContext

    if ((pSelectContext->Flags & REPL_UNINITIALIZED) == 0) {
        pSelectContext->Flags = REPL_UNINITIALIZED;
        pSelectContext->iFirstSvcIndex = 0;
    }

    //
    // Check to see if Entry has a local service that will do.
    //

    if (pPktEntry->LocalService != NULL) {

        ASSERT(pPktEntry->LocalService->pProvider != NULL);

        DfsDbgTrace(0, Dbg, "Selecting Local Svc\n", 0);

        psvcFirst = pPktEntry->LocalService;

        pSelectContext->Flags = REPL_SVC_IS_LOCAL;

        //
        // pSelectContext->iSvcIndex and iFirstSvcIndex are meaningless
        // because of REPL_SVC_IS_LOCAL flag above. Leave them at unknown
        // values.
        //

    }

    if (psvcFirst == NULL) {
        // No local service, or local service not sufficient, lets find a
        // remote service.
        Status = ReplFindRemoteService(
                    pPktEntry,
                    pSelectContext,
                    &iSvc);
        if (NT_SUCCESS(Status)) {

            pSelectContext->Flags = REPL_SVC_IS_REMOTE;
            pSelectContext->iFirstSvcIndex = pSelectContext->iSvcIndex = iSvc;
            psvcFirst = &pPktEntry->Info.ServiceList[iSvc];
        }
    }

    if (psvcFirst != NULL) {

        DfsDbgTrace(-1, Dbg, "ReplFindFirstProvider: Found service %8lx\n",
                 psvcFirst);
        ASSERT(psvcFirst->pProvider != NULL);
        *ppService = psvcFirst;

        Status = ReplFindRemoteService(
                    pPktEntry,
                    pSelectContext,
                    &iSvc);

        if (!NT_SUCCESS(Status)) {
            *pLastEntry = TRUE;
        }

        return(STATUS_SUCCESS);
    } else {

        //
        //  An appropriate provider or referral was not found.
        //

        DfsDbgTrace(-1, Dbg,
                 "ReplFindFirstProvider: no service or provider found, "
                 "pPktEntry = %x\n", pPktEntry);
        *ppService = NULL;

        RtlZeroMemory(pSelectContext, sizeof(REPL_SELECT_CONTEXT));

        pSelectContext->Flags = REPL_NO_MORE_ENTRIES;
        Status = STATUS_NO_MORE_ENTRIES;
        MUP_TRACE_HIGH(ERROR, ReplFindFirstProvider_Error_NotFound,
                       LOGSTATUS(Status));
        return(STATUS_NO_MORE_ENTRIES);
    }
}



//+----------------------------------------------------------------------------
//
//  Function:  ReplFindNextProvider
//
//  Synopsis:  Supports the abstraction that a PktEntry's service list is an
//             ORDERED list. Based on the SELECT_TOKEN (which the caller is
//             required to have initialized by a call to ReplFindFirstProvider)
//             this call returns the next provider in the ordered sequence.
//
//  Arguments: [pPktEntry]      - Contains the service list to operate on
//             [ppService]      - The next service.
//             [pSelectContext] - The context
//             [pLastEntry]     - TRUE if last entry, FALSE otherwise
//
//  Notes:     Caller is required to have called ReplFindFirstProvider() before
//             calling this.
//
//  Returns:   [STATUS_SUCCESS] -- *ppService is the lucky winner.
//
//             [STATUS_NO_MORE_ENTRIES] -- End of ordered sequence.
//
//-----------------------------------------------------------------------------

NTSTATUS
ReplFindNextProvider(
    IN PDFS_PKT_ENTRY pPktEntry,
    OUT PDFS_SERVICE *ppService,
    IN OUT PREPL_SELECT_CONTEXT pSelectContext,
    OUT BOOLEAN *pLastEntry
)  {

    NTSTATUS Status;
    PDFS_SERVICE psvcNext = NULL;                // The one we will return
    ULONG iSvc;                                  // index into ServiceList

    DfsDbgTrace( 0, Dbg, "ReplFindNextProvider Entered.\n", 0);

    *pLastEntry = FALSE;

    //
    // First, check to see if we have previously determined that the list
    // is exhausted.
    //

    if (pSelectContext->Flags & REPL_NO_MORE_ENTRIES ||
        pSelectContext->Flags & REPL_PRINCIPAL_SPECD) {

        if (pSelectContext->Flags & REPL_PRINCIPAL_SPECD) {
            DfsDbgTrace(0, Dbg,
                "ReplFindNextProvider called for open with principal", 0);
        }

        *pLastEntry = TRUE;

        return(STATUS_NO_MORE_ENTRIES);
    }

    //
    // This routine will never return the local service; if the local service
    // were an appropriate choice, it would be returned by ReplFindFirstProvider
    // So here, we simply find the next appropriate remote service, and adjust
    // pSelectContext accordingly.
    //

    Status = ReplFindRemoteService(
                pPktEntry,
                pSelectContext,
                &iSvc);
    if (!NT_SUCCESS(Status)) {
        DfsDbgTrace( 0, Dbg, "ReplFindNextProvider: No more services.\n", 0);

        pSelectContext->Flags = REPL_NO_MORE_ENTRIES;
        *ppService = NULL;
        *pLastEntry = TRUE;
        return(STATUS_NO_MORE_ENTRIES);
    }

    // Service and provider found. Update pSelectContext and return.

    ASSERT(iSvc <= pPktEntry->Info.ServiceCount);
    psvcNext = &pPktEntry->Info.ServiceList[iSvc];
    DfsDbgTrace( 0, Dbg, "ReplFindNextProvider: Found svc %8lx\n", psvcNext);

    if (pSelectContext->Flags & REPL_SVC_IS_LOCAL) {
        pSelectContext->iFirstSvcIndex = iSvc;
    }

    pSelectContext->Flags = REPL_SVC_IS_REMOTE;
    pSelectContext->iSvcIndex = iSvc;          // Record Svc for next time

    ASSERT(psvcNext->pProvider != NULL);
    *ppService = psvcNext;

    Status = ReplFindRemoteService(
                pPktEntry,
                pSelectContext,
                &iSvc);

    if (!NT_SUCCESS(Status)) {
        *pLastEntry = TRUE;
    }

    return(STATUS_SUCCESS);
}


//+-------------------------------------------------------------------
//
//  Function:   ReplLookupProvider, local
//              (formerly DnrLookupProvider)
//
//  Synopsis:   This routine looks up a provider given a provider ID.
//
//  Arguments:  [ProviderID] -- The ID of the provider to be looked up
//
//  Returns:    [PPROVIDER_DEF] -- the provider found, or NULL
//
//--------------------------------------------------------------------


PPROVIDER_DEF
ReplLookupProvider(
    ULONG ProviderId
) {
    NTSTATUS Status;
    PPROVIDER_DEF pProv;
    HANDLE   hProvider = NULL;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_HANDLE_INFORMATION handleInformation;
    PFILE_OBJECT    fileObject;
    int i;

    DfsDbgTrace(+1, Dbg, "ReplLookupProvider Entered: id = %x\n", ULongToPtr(ProviderId) );

    for (pProv = DfsData.pProvider, i=0; i<DfsData.cProvider; pProv++, i++) {

        if (ProviderId == pProv->eProviderId) {

            if (pProv->FileObject == NULL) {

                DfsDbgTrace(0, Dbg, "Provider device not been referenced yet\n", 0);

                //
                // We haven't opened a handle to the provider yet - so
                // lets try to.
                //

                if (pProv->DeviceName.Buffer) {

                    //
                    // Get a handle to the provider.
                    //

                    DfsDbgTrace(0, Dbg, "About to open %wZ\n", &pProv->DeviceName);

                    InitializeObjectAttributes(
                        &objectAttributes,
                        &pProv->DeviceName,
                        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, // Attributes
                        0,                       // Root Directory
                        NULL                     // Security
                        );

                    Status = ZwOpenFile(
                                &hProvider,
                                FILE_TRAVERSE,
                                &objectAttributes,
                                &ioStatusBlock,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                FILE_DIRECTORY_FILE
                                );

                    if ( NT_SUCCESS( Status ) ) {
                        Status = ioStatusBlock.Status;
                    }

                    DfsDbgTrace(0, Dbg, "Open returned %08lx\n", ULongToPtr(Status) );

                    if ( NT_SUCCESS( Status ) ) {

                        //
                        // Increment ref count on objects
                        //
 
                        //
                        // 426184, need to check return code for errors.
                        //
                        Status = ObReferenceObjectByHandle(
                                    hProvider,
                                    0,
                                    NULL,
                                    KernelMode,
                                    (PVOID *)&fileObject,
                                    &handleInformation );

                        ZwClose(hProvider);
                    }

                    if ( NT_SUCCESS( Status ) ) {

                        //
                        // We have to do this because the pProv structure is in paged
                        // pool, and ObReferenceObjectByHandle requires the fileObject
                        // argument in NonPaged memory. So, we pass in a stack variable
                        // to ObReferenceObjectByHandle, then copy it to pProv->FileObject
                        //

                        pProv->FileObject = fileObject;

                        ASSERT( NT_SUCCESS( Status ) );

                        pProv->DeviceObject = IoGetRelatedDeviceObject(
                                                        pProv->FileObject
                                                        );
                        Status = ObReferenceObjectByPointer(
                                    pProv->DeviceObject,
                                    0,
                                    NULL,
                                    KernelMode
                             );


                        ASSERT( pProv->DeviceObject->StackSize < 6 );   // see dsinit.c

                        DfsDbgTrace(-1, Dbg, "ReplLookupProvider Exited: "
                                    "Provider Def @ %08lx\n", pProv);
                        return pProv;

                    } else {

                        return NULL;

                    }

                }

            } else {

                DfsDbgTrace(-1, Dbg, "ReplLookupProvider Exited: "
                           "Provider Def @ %08lx\n", pProv);
                return pProv;

            } // If pProv->FileObject == NULL

        } // If ProviderId == pProv->eProviderId

    } // For all provider defs

    DfsDbgTrace(-1, Dbg, "ReplLookupProvider Exited: Failed!", 0);

    return NULL;
}


//+----------------------------------------------------------------------------
//
//  Function:   ReplFindRemoteService
//
//  Synopsis:   This routine is a worker used by both ReplFindFirstProvider
//              and ReplFindNextProvider to find a !remote! service. It
//              completely ignores the local service, if any.
//
//              For now, it will simply scan the list sequentially. Later,
//              this routine can be modified to call a separate
//              component that will compute the transport cost, given the set
//              of network addresses in the service list.
//
//  Arguments:  [pPktEntry] -- The entry for for which a remote provider is
//                      to be selected.
//
//              [pSelectContext] -- The status of replica selection so far.
//
//              [piSvc] -- On successful return, the index in the service list
//                      of the selected service.
//
//  Returns:    [STATUS_SUCCESS] -- ServiceList[*piSvc] is the lucky winner.
//
//              [STATUS_NO_MORE_ENTRIES] -- Either service list is empty, or
//                      none of the services in the service list will do.
//
//-----------------------------------------------------------------------------

NTSTATUS ReplFindRemoteService(
    IN PDFS_PKT_ENTRY           pPktEntry,
    IN PREPL_SELECT_CONTEXT     pSelectContext,
    OUT ULONG                   *piSvc)
{
    ULONG iSvc;
    BOOLEAN bFound = FALSE;

    DfsDbgTrace(+1, Dbg, "ReplFindRemoteService: Entered\n", 0);

    if ( pPktEntry->Info.ServiceCount == 0 ) {
        DfsDbgTrace(0, Dbg, "ReplFindRemoteService: No svcs in pkt entry\n", 0);
        DfsDbgTrace(-1, Dbg, "ReplFindRemoteService: returning %08lx\n",
            ULongToPtr(STATUS_NO_MORE_ENTRIES) );
        return(STATUS_NO_MORE_ENTRIES);
    }


    if (pSelectContext->Flags & REPL_SVC_IS_LOCAL ||
        pSelectContext->Flags & REPL_UNINITIALIZED) {

        //
        // We haven't looked at a remote service yet. Start from the active
        // service or the first service in the svc list.
        //

        PDFS_SERVICE pSvc;

        if (pPktEntry->ActiveService) {
            DfsDbgTrace(0, Dbg, "Starting search at active svc\n", 0);
            pSvc = pPktEntry->ActiveService;
        } else {

            DfsDbgTrace(0, Dbg, "Starting search at first svc\n", 0);
            pSvc = &pPktEntry->Info.ServiceList[ 0 ];
        }

        iSvc = (ULONG)(pSvc - &pPktEntry->Info.ServiceList[0]);

        if (pSvc->pProvider == NULL) {
            pSvc->pProvider = ReplLookupProvider(pSvc->ProviderId);
        }

        if ( pSvc->pProvider != NULL ) {
            bFound = TRUE;
        } else {
            iSvc = (iSvc + 1) % pPktEntry->Info.ServiceCount;
        }

    } else {

        //
        // We have already looked at some remote services, lets continue where
        // we left off.
        //

        ASSERT(pPktEntry->Info.ServiceCount != 0);
        iSvc = (pSelectContext->iSvcIndex + 1) % pPktEntry->Info.ServiceCount;
        DfsDbgTrace(0, Dbg, "Continuing search at svc # %d\n", ULongToPtr(iSvc) );

    }

    //
    // We know where to begin looking and where to stop.
    //

    while ( (iSvc != pSelectContext->iFirstSvcIndex) && !bFound) {

        register PDFS_SERVICE pSvc = &pPktEntry->Info.ServiceList[iSvc];

        if (pSvc->pProvider == NULL) {
            pSvc->pProvider = ReplLookupProvider(pSvc->ProviderId);
        }

        if ( pSvc->pProvider != NULL ) {
            DfsDbgTrace(0, Dbg, "Found svc # %d\n", ULongToPtr(iSvc) );
            bFound = TRUE;
        } else {
            DfsDbgTrace(0, Dbg, "No provider for svc # %d\n", ULongToPtr(iSvc) );
            iSvc = (iSvc + 1) % pPktEntry->Info.ServiceCount;
        }

    }

    if (bFound) {
        *piSvc = iSvc;
        DfsDbgTrace(-1, Dbg, "ReplFindRemoteService: returning svc %08lx\n",
                &pPktEntry->Info.ServiceList[iSvc]);
        return(STATUS_SUCCESS);
    } else {
        DfsDbgTrace(-1, Dbg, "ReplFindRemoteService: Exited-> %08lx\n",
                ULongToPtr(STATUS_NO_MORE_ENTRIES) );
        return(STATUS_NO_MORE_ENTRIES);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\kdext\dumps.c ===
#define KDEXTMODE

#include <dumpsup.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\rpselect.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       rpselect.h
//
//  Contents:   Function & Data Structure prototypes for replica selection.
//
//  Classes:
//
//  Functions:  ReplFindFirstProvider - find first appropriate provider and
//                      initialize the select context.
//              ReplFindNextProvider - get next provider from the list of
//                      providers based on an initialized select context.
//              ReplSetActiveService - a courtesy routine to tell replica
//                      selection that a particular service "worked". Will
//                      cause this service to be the first one to be tried
//                      on subsequent calls to FindFirst.
//              ReplIsRecoverableError - see if error code is something worth
//                      trying a replica for.
//
//  Data Structures:
//              REPL_SELECT_CONTEXT
//
//  History:    02 Sep 92       MilanS created.
//
//-----------------------------------------------------------------------------

#ifndef _RPSELECT_
#define _RPSELECT_

//
// This structure is supposed to be opaque to the user of this module.
// It should only be used to create select contexts to be passed to
// FindFirstProvider and FindNextProvider.
//

typedef struct _REPL_SELECT_CONTEXT {
   unsigned short       Flags;
   ULONG                iFirstSvcIndex;          // index of first svc
   ULONG                iSvcIndex;               // index of the last svc
                                                 // returned to caller.
} REPL_SELECT_CONTEXT, *PREPL_SELECT_CONTEXT;


//
// Define flags for SelectContext structures.
//

#define REPL_UNINITIALIZED      0x0001
#define REPL_SVC_IS_LOCAL       0x0002
#define REPL_SVC_IS_REMOTE      0x0004
#define REPL_PRINCIPAL_SPECD    0x0008
#define REPL_NO_MORE_ENTRIES    0x0010


NTSTATUS
ReplFindFirstProvider(
    IN  PDFS_PKT_ENTRY pPktEntry,                // for which a svc is needed
    IN  GUID *pidPrincipal,                      // look for this service
    IN  PUNICODE_STRING pustrPrincipal,          // or look for this service
    OUT PDFS_SERVICE *ppService,                 // return selected service
    OUT PREPL_SELECT_CONTEXT pSelectContext,     // Context to be initialized.
    OUT BOOLEAN *pLastEntry                      // Last entry
    );


NTSTATUS
ReplFindNextProvider(
    IN  PDFS_PKT_ENTRY pPktEntry,                // for which another svc is
    OUT PDFS_SERVICE *ppService,                 // needed.
    IN  OUT PREPL_SELECT_CONTEXT pSelectContext, // Context to use
    OUT BOOLEAN *pLastEntry                      // Last entry
    );

PPROVIDER_DEF
ReplLookupProvider(ULONG ProviderId);



//+----------------------------------------------------------------------------
//
//  Function:  ReplSetActiveService
//
//  Synopsis:  Sets the ActiveService pointer of a PKT Entry. This is an
//             Optimization. People who later look for a service for this
//             PKT Entry will be asked to look at the ActiveService first.
//
//  Arguments: [pPktEntry]      Pointer to PKT Entry.
//             [SelectContext]  Initialized Select Context returned by
//                              FindFirst or FindNext.
//
//  Returns:   Nothing
//
//  Notes:     For now, this is a #define. Later, when we support multi-
//             threaded operation, we can change it to a function that tests
//             whether the Pkt Entry has changed under it etc.
//
//-----------------------------------------------------------------------------

#define ReplSetActiveService(p,s)                                       \
    {                                                                   \
        if ((s).Flags & REPL_SVC_IS_REMOTE ) {                          \
            (p)->ActiveService = &(p)->Info.ServiceList[(s).iSvcIndex]; \
            if ((p)->ActiveService->pMachEntry != NULL) {               \
                InterlockedIncrement(                             \
                    &(p)->ActiveService->pMachEntry->ConnectionCount);  \
            }                                                           \
        }                                                               \
    }


//+----------------------------------------------------------------------------
//
//  Function:  ReplIsRecoverableError
//
//  Synopsis:  True if the argument is an NTSTATUS error code for which it
//             makes sense to try a replica if one is available.
//
//  Arguments: [x] - The NTSTATUS error code to be tested.
//
//  Returns:   True / False
//
//  Notes:     For now, this is simply #defined to be a relatively big OR
//             statement that tests for a bunch of specific error codes. If we
//             need to test for more error codes, it might be worth organizing
//             them into a hash table, which can then quickly be tested.
//
//             My initial estimates are that a hash table with either a modulo
//             or multiplication hash function will become cheaper at around
//             7-8 error codes, assuming clock cycle estimates of x86. A tree
//             type organization becomes effective after 10 error codes. The
//             problem with the latter is generating at compile time a
//             static, balanced tree.
//
//-----------------------------------------------------------------------------

#define ReplIsRecoverableError(x) ( (x) == STATUS_IO_TIMEOUT ||               \
                                    (x) == STATUS_REMOTE_NOT_LISTENING ||     \
                                    (x) == STATUS_VIRTUAL_CIRCUIT_CLOSED ||   \
                                    (x) == STATUS_BAD_NETWORK_PATH ||         \
                                    (x) == STATUS_NETWORK_BUSY ||             \
                                    (x) == STATUS_INVALID_NETWORK_RESPONSE || \
                                    (x) == STATUS_UNEXPECTED_NETWORK_ERROR || \
                                    (x) == STATUS_NETWORK_NAME_DELETED ||     \
                                    (x) == STATUS_BAD_NETWORK_NAME ||         \
                                    (x) == STATUS_REQUEST_NOT_ACCEPTED ||     \
                                    (x) == STATUS_DISK_OPERATION_FAILED ||    \
                                    (x) == STATUS_DEVICE_OFF_LINE ||          \
                                    (x) == STATUS_NETWORK_UNREACHABLE ||      \
                                    (x) == STATUS_INSUFFICIENT_RESOURCES ||   \
                                    (x) == STATUS_SHARING_PAUSED ||           \
                                    (x) == STATUS_DFS_UNAVAILABLE ||          \
                                    (x) == STATUS_NO_SUCH_DEVICE ||           \
                                    (x) == STATUS_NETLOGON_NOT_STARTED ||     \
                                    (x) == STATUS_UNMAPPABLE_CHARACTER ||     \
                                    (x) == STATUS_CONNECTION_DISCONNECTED ||  \
                                    (x) == STATUS_USER_SESSION_DELETED ||     \
                                    (x) == STATUS_NO_SUCH_LOGON_SESSION       \
                                  )
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\strucsup.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       STRUCSUP.C
//
//  Contents:   This module implements the Dsfs in-memory data structure
//              manipulation routines
//
//  Functions:
//              DfsCreateIrpContext -
//              DfsDeleteIrpContext_Real -
//              DfsInitializeVcb -
//              DfsCreateFcb -
//              DfsDeleteFcb_Real -
//              DspAllocateStringRoutine -
//
//  History:    12 Nov 1991     AlanW   Created from CDFS souce.
//               8 May 1992     PeterCo added support for new PKT stuff (M000)
//-----------------------------------------------------------------------------


#include "dfsprocs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_STRUCSUP)


#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, DfsInitializeVcb )
#pragma alloc_text( PAGE, DfsDeleteIrpContext_Real)
#pragma alloc_text( PAGE, DfsCreateFcb )
#pragma alloc_text( PAGE, DfsDeleteFcb_Real )

//
// The following routines cannot be paged because they acquire/release
// spin locks
//
// DfsCreateIrpContext
// DfsDeleteIrpContext_Real
//

#endif // ALLOC_PRAGMA


//+-------------------------------------------------------------------
//
//  Function:   DfsCreateIrpContext, public
//
//  Synopsis:   This routine creates a new IRP_CONTEXT record
//
//  Arguments:  [Irp] - Supplies the originating Irp.
//              [Wait] - Supplies the wait value to store in the context
//
//  Returns:    PIRP_CONTEXT - returns a pointer to the newly allocate
//                      IRP_CONTEXT Record
//
//--------------------------------------------------------------------

PIRP_CONTEXT
DfsCreateIrpContext (
    IN PIRP Irp,
    IN BOOLEAN Wait
) {
    KIRQL SavedIrql;
    PIRP_CONTEXT IrpContext;
    PIO_STACK_LOCATION IrpSp;

    DfsDbgTrace(+1, Dbg, "DfsCreateIrpContext\n", 0);

    IrpContext = ExAllocateFromNPagedLookasideList (&DfsData.IrpContextLookaside);

    if (IrpContext != NULL) {
        //
        //  Zero out the irp context and indicate that it is from pool and
        //  not zone allocated
        //

        RtlZeroMemory( IrpContext, sizeof(IRP_CONTEXT) );

        //
        //  Set the proper node type code and node byte size
        //

        IrpContext->NodeTypeCode = DSFS_NTC_IRP_CONTEXT;
        IrpContext->NodeByteSize = sizeof(IRP_CONTEXT);

        //
        //  Set the originating Irp field
        //

        IrpContext->OriginatingIrp = Irp;
        IrpSp = IoGetCurrentIrpStackLocation( Irp );

        //
        //  Major/Minor Function codes
        //

        IrpContext->MajorFunction = IrpSp->MajorFunction;
        IrpContext->MinorFunction = IrpSp->MinorFunction;

        //
        //  Set the Wait and InFsd flags
        //

        if (Wait) {
            IrpContext->Flags |= IRP_CONTEXT_FLAG_WAIT;
        }

        IrpContext->Flags |= IRP_CONTEXT_FLAG_IN_FSD;
    }
    //
    //  return and tell the caller
    //

    DfsDbgTrace(-1, Dbg, "DfsCreateIrpContext -> %08lx\n", IrpContext);

    return IrpContext;
}


//+-------------------------------------------------------------------
//
//  Function:   DfsDeleteIrpContext, public
//
//  Synopsis:   This routine deallocates and removes the specified
//              IRP_CONTEXT record from the Dsfs in-memory data
//              structures.  It should only be called by DfsCompleteRequest.
//
//  Arguments:  [IrpContext] -- Supplies the IRP_CONTEXT to remove
//
//  Returns:    None
//
//  Notes:
//
//--------------------------------------------------------------------

VOID
DfsDeleteIrpContext_Real (
    IN PIRP_CONTEXT IrpContext
) {

    DfsDbgTrace(+1, Dbg, "DfsDeleteIrpContext, IrpContext = %08lx\n", IrpContext);

    ASSERT( IrpContext->NodeTypeCode == DSFS_NTC_IRP_CONTEXT );

    ExFreeToNPagedLookasideList (&DfsData.IrpContextLookaside, IrpContext);

    //
    //  return and tell the caller
    //

    DfsDbgTrace(-1, Dbg, "DfsDeleteIrpContext -> VOID\n", 0);

    return;
}




//+-------------------------------------------------------------------
//
//  Function:   DfsInitializeVcb, public
//
//  Synopsis:   This routine initializes a DFS_VCB.
//
//  Arguments:  [IrpContext] --
//              [Vcb] --        Supplies the address of the Vcb record being
//                              initialized.
//              [LogRootPrefix] -- Optional Unicode String pointer that
//                              specifies the relative name of the logical
//                              root to the highest (org) root.
//              [Credentials] -- The credentials associated with this device
//              [TargetDeviceObject] -- Supplies the address of the target
//                              device object to associate with the Vcb record.
//
//  Returns:    None
//
//  Note:       If LogRootPrefix is given, its buffer will be "deallocated"
//
//--------------------------------------------------------------------


VOID
DfsInitializeVcb (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PDFS_VCB Vcb,
    IN PUNICODE_STRING LogRootPrefix,
    IN PDFS_CREDENTIALS Credentials OPTIONAL,
    IN PDEVICE_OBJECT TargetDeviceObject
) {

    DfsDbgTrace(+1, Dbg, "DfsInitializeVcb:  Entered\n", 0);

    //
    //  Zero out the memory to remove stale data.
    //

    RtlZeroMemory( Vcb, sizeof( DFS_VCB ));

    //
    //  Set the proper node type code and node byte size.
    //

    Vcb->NodeTypeCode = DSFS_NTC_VCB;
    Vcb->NodeByteSize = sizeof( DFS_VCB );

    //
    //  Set the prefix string to the input prefix, then `deallocate' the
    //  input pointer.
    //

    Vcb->LogRootPrefix = *LogRootPrefix;
    RtlZeroMemory( LogRootPrefix, sizeof( UNICODE_STRING ));

    //
    //  Save the credentials
    //

    Vcb->Credentials = Credentials;

    //
    //  Insert this Vcb record on the DfsData.VcbQueue
    //

    InsertTailList( &DfsData.VcbQueue, &Vcb->VcbLinks );


    DfsDbgTrace(-1, Dbg, "DfsInitializeVcb:  Exit\n", 0);

    return;
}


//+-------------------------------------------------------------------
//
//  Function:   DfsCreateFcb, public
//
//  Synopsis:   This routine allocates, initializes, and inserts a new
//              DFS_FCB record into the in-memory data structure.
//
//  Arguments:  [Vcb] -- Supplies the Vcb to associate the new Fcb under
//              [FullName] -- Fully qualified file name for the DFS_FCB
//
//  Returns:    PDFS_FCB - Pointer to the newly created and initialized Fcb.
//
//--------------------------------------------------------------------

PDFS_FCB
DfsCreateFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PDFS_VCB Vcb,
    IN PUNICODE_STRING FullName OPTIONAL
) {
    PDFS_FCB NewFcb;
    ULONG TotalLength;

    DfsDbgTrace(+1, Dbg, "DfsCreateFcb:  Entered\n", 0);

    //
    //  Allocate a new Fcb and zero it out.
    //

    TotalLength = sizeof(DFS_FCB);
    if (ARGUMENT_PRESENT(FullName))
        TotalLength += FullName->Length * sizeof(WCHAR);

    NewFcb = (PDFS_FCB) ExAllocatePoolWithTag( NonPagedPool, TotalLength, ' puM' );

    if (NewFcb != NULL) {

        RtlZeroMemory( NewFcb, sizeof( DFS_FCB ));

        //
        //  Set the proper node type code and node byte size
        //

        NewFcb->NodeTypeCode = DSFS_NTC_FCB;
        NewFcb->NodeByteSize = sizeof( DFS_FCB );

        if (ARGUMENT_PRESENT(FullName)) {

            NewFcb->FullFileName.Length =
                NewFcb->FullFileName.MaximumLength = FullName->Length;

            NewFcb->FullFileName.Buffer =
                (PWCHAR) ( (PCHAR)NewFcb + sizeof(DFS_FCB) );

            RtlMoveMemory( NewFcb->FullFileName.Buffer,
                           FullName->Buffer,
                           FullName->Length );

            NewFcb->AlternateFileName.Length = 0;

            NewFcb->AlternateFileName.MaximumLength = FullName->Length;

            NewFcb->AlternateFileName.Buffer =
                &NewFcb->FullFileName.Buffer[FullName->Length/sizeof(WCHAR)];

        }

        NewFcb->Vcb = Vcb;

    }

    DfsDbgTrace(-1, Dbg, "DfsCreateFcb -> %8lx\n", NewFcb);

    return NewFcb;
}

//+-------------------------------------------------------------------
//
//  Function:   DfsDeleteFcb
//
//  Synopsis:   This routine removes the Fcb record from DSFS's in-memory data
//              structures.  It also will remove all associated underlings.
//
//  Arguments:  [Fcb] -- Supplies the Fcb/Dcb to be removed
//
//  Returns:    None
//
//--------------------------------------------------------------------

VOID
DfsDeleteFcb_Real (
    IN PIRP_CONTEXT IrpContext,
    IN PDFS_FCB Fcb
) {
    DfsDbgTrace(+1, Dbg, "DfsDeleteFcb:  Fcb = %08lx\n", Fcb);

    //
    //  Zero out the structure and deallocate.
    //

    ExFreePool( Fcb );

    DfsDbgTrace(-1, Dbg, "DfsDeleteFcb:  Exit\n", 0);

    return;
}


//+-------------------------------------------------------------------
//
//  Function:   DfsGetLogonId
//
//  Synopsis:   This routine gets the current LogonID.
//              It is assumed that this will be called in the user thread
//              or from a thread that is impersonating the user thread.
//
//  Arguments:  LogonId -- Pointer to LUID where we stuff the LUID
//
//  Returns:    None
//
//--------------------------------------------------------------------

NTSTATUS
DfsGetLogonId(
    PLUID LogonId)  
{
    SECURITY_SUBJECT_CONTEXT SubjectContext;
	
    SeCaptureSubjectContext(&SubjectContext);

    if (SubjectContext.ClientToken != NULL) {

        //
        //  If its impersonating someone that is logged in locally then use
        //  the local id.
        //

        SeQueryAuthenticationIdToken(SubjectContext.ClientToken, LogonId);

    } else {

        //
        //  Use the processes LogonId
        //

        SeQueryAuthenticationIdToken(SubjectContext.PrimaryToken, LogonId);
    }

    SeReleaseSubjectContext(&SubjectContext);

    return STATUS_SUCCESS;
}



//+-------------------------------------------------------------------
//
//  Function:   DfsInitializeDrt, public
//
//  Synopsis:   This routine initializes a DFS_DEVLESS_ROOT.
//
//  Arguments:  [Drt] --        Supplies the address of the Vcb record being
//                              initialized.
//              [Name] --       Unicode String pointer that
//                              specifies the relative name of the logical
//                              root to the highest (org) root.
//              [Credentials] -- The credentials associated with this device
//
//  Returns:    None
//
//--------------------------------------------------------------------


VOID
DfsInitializeDrt (
    IN OUT PDFS_DEVLESS_ROOT Drt,
    IN PUNICODE_STRING Name,
    IN PDFS_CREDENTIALS Credentials OPTIONAL
) {

    DfsDbgTrace(+1, Dbg, "DfsInitializeDevlessRoot:  Entered %x\n", Drt);

    //
    //  Zero out the memory to remove stale data.
    //

    RtlZeroMemory( Drt, sizeof( DFS_DEVLESS_ROOT ));

    //
    //  Set the proper node type code and node byte size.
    //

    Drt->NodeTypeCode = DSFS_NTC_DRT;
    Drt->NodeByteSize = sizeof( DFS_DEVLESS_ROOT );

    Drt->DevlessPath = *Name;

    //
    //  Save the credentials
    //

    Drt->Credentials = Credentials;

    //
    //  Insert this Drt record on the DfsData.DrtQueue
    //

    InsertTailList( &DfsData.DrtQueue, &Drt->DrtLinks );

    DfsDbgTrace(-1, Dbg, "DfsInitializeDevlessRoot:  Exit\n", 0);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\kdext\kdextlib.h ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    kdextlib.h

Abstract:

    Kernel Debugger extension

Author:

    Balan Sethu Raman (SethuR) 11-May-1994

Revision History:

    11-Nov-1994 SethuR  Created
    21-Aug-1995 Milans  Copied for use in Mup Kernel Extensions

--*/

#ifndef _KDEXTLIB_H_
#define _KDEXTLIB_H_

#include <windef.h>

//
// The help strings printed out
//

extern LPSTR ExtensionNames[];

extern LPSTR Extensions[];

//
// The FIELD_DESCRIPTOR data structure is used to describe the field in a structure sufficiently
// for displaying information during debugging. The three pieces of information that are required
// are 1) the name of the field, 2) the offset in the corresponding structure and 3) a type descriptor.
// The type descriptor covers most primitive types.
//
// The task of generating these descriptors by augmenting the front end, but that will have to
// wait till we play around with these extensions and modify the data structures to meet most
// of the requirements.
//
// There are some types that can benefit from some auxillary information in the descriptors. A
// case in point is the "enum" defeinition. Merely printing out a numerical value for an enum
// type will invariably force the person using these extensions to refer to the corresponding
// include file. In order to avoid this we will accept an additional array for enum types that
// contains a textual description of the numerical value.
//
// There are certain conventions that have been adopted to ease the definition of the macros
// as well as facilitate the automation of the generation of these descriptors.
// These are as follows ....
//
// 1) All ENUM_VALUE_DESCRIPTOR definitions are named EnumValueDescrsOf_ENUMTYPENAME, where
// ENUMTYPENAME defines the corresponding enumerated type.
//

typedef struct _ENUM_VALUE_DESCRIPTOR {
    ULONG   EnumValue;
    LPSTR   EnumName;
} ENUM_VALUE_DESCRIPTOR;

typedef struct _BIT_MASK_DESCRIPTOR {
    ULONG   BitmaskValue;
    LPSTR   BitmaskName;
} BIT_MASK_DESCRIPTOR;

typedef enum _FIELD_TYPE_CLASS {
    FieldTypeByte,
    FieldTypeChar,
    FieldTypeBoolean,
    FieldTypeBool,
    FieldTypeULong,
    FieldTypeLong,
    FieldTypeUShort,
    FieldTypeShort,
    FieldTypeGuid,
    FieldTypePointer,
    FieldTypePWStr,
    FieldTypeUnicodeString,
    FieldTypeAnsiString,
    FieldTypeSymbol,
    FieldTypeEnum,
    FieldTypeByteBitMask,
    FieldTypeWordBitMask,
    FieldTypeDWordBitMask,
    FieldTypeFloat,
    FieldTypeDouble,
    FieldTypeStruct,
    FieldTypeLargeInteger,
    FieldTypeFileTime
} FIELD_TYPE_CLASS, *PFIELD_TYPE_CLASS;

typedef struct _FIELD_DESCRIPTOR_ {
    FIELD_TYPE_CLASS FieldType;   // The type of variable to be printed
    LPSTR            Name;        // The name of the field
    USHORT           Offset;      // The offset of the field in the structure
    union {
        VOID                   *pDescriptor;     // Generic Auxillary information - used by Field4 macro
        ENUM_VALUE_DESCRIPTOR  *pEnumValueDescriptor; // Auxillary information for enumerated types.
        BIT_MASK_DESCRIPTOR *pBitMaskDescriptor; // Auxillary information for bitmasks.
    } AuxillaryInfo;
} FIELD_DESCRIPTOR;

#define FIELD3(FieldType,StructureName, FieldName) \
        {FieldType, #FieldName , (USHORT) FIELD_OFFSET(StructureName,FieldName) ,NULL}

#define FIELD4(FieldType, StructureName, FieldName, AuxInfo) \
        {FieldType, #FieldName , FIELD_OFFSET(StructureName,FieldName) ,(VOID *) AuxInfo}

//
// The structs that are displayed by the debugger extensions are further
// described in another array. Each entry in the array contains the name of
// the structure and the associated Field descriptor list.
//

typedef struct _STRUCT_DESCRITOR_ {
    LPSTR             StructName;
    ULONG             StructSize;
    FIELD_DESCRIPTOR  *FieldDescriptors;
} STRUCT_DESCRIPTOR;

#define STRUCT(StructTypeName,FieldDescriptors) \
        { #StructTypeName,sizeof(StructTypeName),FieldDescriptors}

//
//  The array of structs handled by the debugger extension.
//

extern STRUCT_DESCRIPTOR Structs[];

#define    SETCALLBACKS() \
    lpOutputRoutine = lpExtensionApis->lpOutputRoutine; \
    lpGetExpressionRoutine = lpExtensionApis->lpGetExpressionRoutine; \
    lpGetSymbolRoutine = lpExtensionApis->lpGetSymbolRoutine; \
    lpReadMemoryRoutine = lpExtensionApis->lpReadVirtualMemRoutine;


VOID
PrintStructFields(
    ULONG_PTR dwAddress,
    VOID *ptr,
    FIELD_DESCRIPTOR *pFieldDescriptors
);

BOOL
PrintStringW(
    LPSTR msg,
    PUNICODE_STRING puStr,
    BOOL nl
);

BOOLEAN
GetData(
    ULONG_PTR dwAddress,
    PVOID ptr,
    ULONG size
);
BOOL
PrintGuid(
    GUID *pguid);
extern ULONG s_NoOfColumns;


#endif // _KDEXTLIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\volinfo.c ===
//+----------------------------------------------------------------------------
//
//  File:       VOLINFO.C
//
//  Contents:   This module implements the volume information routines for
//              Dfs called by the dispatch driver.
//
//  Functions:  DfsFsdQueryVolumeInformation
//              DfsFspQueryVolumeInformation
//              DfsCommonQueryVolumeInformation
//              DfsFsdSetVolumeInformation
//              DfsFspSetVolumeInformation
//              DfsCommonSetVolumeInformation
//
//  Notes:      The Query information call is a candidate for directly
//              passing through via DfsVolumePassThrough.  We'll keep
//              the entry point around for now as a convenient place
//              for breakpointing and tracing volume information calls.
//
//  History:    12 Nov 1991     AlanW   Created from CDFS souce.
//
//-----------------------------------------------------------------------------


#include "dfsprocs.h"
#include "mupwml.h"

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_VOLINFO)

//
//  Local procedure prototypes
//

NTSTATUS
DfsCommonQueryVolumeInformation (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
DfsCommonSetVolumeInformation (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

#define DfsSetFsLabelInfo(irpc,pvcb,pbuf)       (STATUS_ACCESS_DENIED)


#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, DfsFsdQueryVolumeInformation )
#pragma alloc_text( PAGE, DfsFspQueryVolumeInformation )
#pragma alloc_text( PAGE, DfsCommonQueryVolumeInformation )
#pragma alloc_text( PAGE, DfsFsdSetVolumeInformation )
#pragma alloc_text( PAGE, DfsFspSetVolumeInformation )
#pragma alloc_text( PAGE, DfsCommonSetVolumeInformation )
#endif // ALLOC_PRAGMA


//+-------------------------------------------------------------------
//
//  Function:   DfsFsdQueryVolumeInformation, public
//
//  Synopsis:   This routine implements the Fsd part of the
//              NtQueryVolumeInformation API call.
//
//  Arguments:  [DeviceObject] -- Supplies the device object where the file
//                      being queried exists.
//              [Irp] -- Supplies the Irp being processed.
//
//  Returns:    NTSTATUS - The FSD status for the Irp.
//
//--------------------------------------------------------------------

NTSTATUS
DfsFsdQueryVolumeInformation (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
) {
    NTSTATUS Status;
    PIRP_CONTEXT IrpContext;

    DfsDbgTrace(+1, Dbg, "DfsFsdQueryVolumeInformation: Entered\n", 0);

    if (DeviceObject->DeviceType == FILE_DEVICE_MULTI_UNC_PROVIDER) {
        DfsCompleteRequest( NULL, Irp, STATUS_INVALID_DEVICE_REQUEST );
        DfsDbgTrace(-1, Dbg, "DfsFsdQueryVolumeInformation - Mup file\n", 0);
        return( STATUS_INVALID_DEVICE_REQUEST );
    }

    if (DeviceObject->DeviceType == FILE_DEVICE_DFS_VOLUME) {
        Status = DfsVolumePassThrough(DeviceObject, Irp);
        DfsDbgTrace(-1, Dbg, "DfsFsdQueryVolumeInformation: Exit -> %08x\n",
                                ULongToPtr(Status) );
        return Status;
    }

    //
    //  Call the common query routine, with blocking allowed if synchronous
    //

    FsRtlEnterFileSystem();

    try {

        IrpContext = DfsCreateIrpContext( Irp, CanFsdWait( Irp ) );
        if (IrpContext == NULL)
            ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
        Status = DfsCommonQueryVolumeInformation( IrpContext, Irp );

    } except(DfsExceptionFilter( IrpContext, GetExceptionCode(), GetExceptionInformation() )) {

        //
        //  We had some trouble trying to perform the requested
        //  operation, so we'll abort the I/O request with
        //  the error status that we get back from the
        //  execption code
        //

        Status = DfsProcessException( IrpContext, Irp, GetExceptionCode() );
    }

    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DfsDbgTrace(-1, Dbg, "DfsFsdQueryVolumeInformation: Exit -> %08x\n",
                                ULongToPtr(Status) );

    return Status;

    UNREFERENCED_PARAMETER( DeviceObject );
}


//+-------------------------------------------------------------------
//
//  Function:   DfsFspQueryVolumeInformation, public
//
//  Synopsis:   This routine implements the FSP part of the
//              NtQueryVolumeInformation API call.
//
//  Arguments:  [IrpContext] -- the IRP_CONTEXT for the request
//              [Irp] -- Supplies the Irp being processed.
//
//  Returns:    Nothing
//
//--------------------------------------------------------------------

VOID
DfsFspQueryVolumeInformation (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )
{
    DfsDbgTrace(+1, Dbg, "DfsFspQueryVolumeInformation: Entered\n", 0);

    //
    //  Call the common query routine.
    //

    (VOID)DfsCommonQueryVolumeInformation( IrpContext, Irp );

    //
    //  And return to our caller
    //

    DfsDbgTrace(-1, Dbg, "DfsFspQueryVolumeInformation: Exit -> VOID\n", 0);

    return;
}


//+-------------------------------------------------------------------
//
//  Function:   DfsCommonQueryVolumeInformation, private
//
//  Synopsis:   This is the common routine for querying volume information
//              called by both the FSD and FSP threads.
//
//  Arguments:  [IrpContext] -- Supplies the context block for the IRP
//              [Irp] -- Supplies the IRP being processed
//
//  Returns:    NTSTATUS - The return status for the operation
//
//--------------------------------------------------------------------

NTSTATUS
DfsCommonQueryVolumeInformation (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
) {
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    PIO_STACK_LOCATION NextIrpSp;
    PFILE_OBJECT FileObject;

    PDFS_VCB Vcb;
    PDFS_FCB Fcb;

    ULONG Length;
    FS_INFORMATION_CLASS FsInformationClass;
    PVOID Buffer;

    TYPE_OF_OPEN TypeOfOpen;

    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    FileObject = IrpSp->FileObject;

    DfsDbgTrace(+1, Dbg, "DfsCommonQueryVolumeInformation: Entered\n", 0);
    DfsDbgTrace( 0, Dbg, "Irp                  = %08x\n", Irp );
    DfsDbgTrace( 0, Dbg, "->Length             = %08x\n", ULongToPtr(IrpSp->Parameters.QueryVolume.Length) );
    DfsDbgTrace( 0, Dbg, "->FsInformationClass = %08x\n", IrpSp->Parameters.QueryVolume.FsInformationClass);
    DfsDbgTrace( 0, Dbg, "->Buffer             = %08x\n", Irp->AssociatedIrp.SystemBuffer);

    //
    //  Reference our input parameters to make things easier
    //

    Length = IrpSp->Parameters.QueryVolume.Length;
    FsInformationClass = IrpSp->Parameters.QueryVolume.FsInformationClass;
    Buffer = Irp->AssociatedIrp.SystemBuffer;

    //
    //  Decode the file object to get the Vcb
    //

    TypeOfOpen = DfsDecodeFileObject( IrpSp->FileObject, &Vcb, &Fcb);

    try {

        Status = STATUS_INVALID_PARAMETER;

        //
        //  Case on the type of open.
        //

        switch (TypeOfOpen) {

        default:
            DfsDbgTrace(0, Dbg,
                        "DfsCommonQueryVolumeInfo: Unknown open type\n", 0);

        invalid:
            // NOTE:  FALL THROUGH
        case FilesystemDeviceOpen:
            DfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;

        case LogicalRootDeviceOpen:
            DfsDbgTrace(0, Dbg,
                        "DfsCommonQueryVolumeInfo: Logical root open\n", 0);
            goto invalid;

        case RedirectedFileOpen:

            //
            //  Nothing special is done base on the information class.
            //  We simply pass each request through to the underlying
            //  file system and let it handle the request.
            //

            //
            // Copy the stack from one to the next...
            //
            NextIrpSp = IoGetNextIrpStackLocation(Irp);
            (*NextIrpSp) = (*IrpSp);

            IoSetCompletionRoutine( Irp,
                                    NULL,
                                    NULL,
                                    FALSE,
                                    FALSE,
                                    FALSE);

            //
            //  Call the next device in the chain
            //

            Status = IoCallDriver( Fcb->TargetDevice, Irp );
            MUP_TRACE_ERROR_HIGH(Status, ALL_ERROR, DfsCommonQueryVolumeInformation_Error_IoCallDriver,
                                 LOGSTATUS(Status)
                                 LOGPTR(Irp)
                                 LOGPTR(FileObject));
            //
            //  The IRP will be completed by the called driver.  We have
            //  no need for the IrpContext in the completion routine.
            //

            DfsDeleteIrpContext(IrpContext);
            IrpContext = NULL;
            Irp = NULL;
            break;
        }

    } finally {

        DfsDbgTrace(-1, Dbg, "DfsCommonQueryVolumeInformation: Exit -> %08x\n",
                                ULongToPtr(Status) );
    }

    return Status;
}


//+-------------------------------------------------------------------
//
//  Function:   DfsFsdSetVolumeInformation, public
//
//  Synopsis:   This routine implements the Fsd part of the
//              NtSetVolumeInformation API call.
//
//  Arguments:  [DeviceObject] -- Supplies the device object where the file
//                      being queried exists.
//              [Irp] -- Supplies the Irp being processed.
//
//  Returns:    NTSTATUS - The FSD status for the Irp.
//
//--------------------------------------------------------------------

NTSTATUS
DfsFsdSetVolumeInformation (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
) {
    NTSTATUS Status;
    PIRP_CONTEXT IrpContext;

    DfsDbgTrace(+1, Dbg, "DfsFsdSetVolumeInformation: Entered\n", 0);

    if (DeviceObject->DeviceType == FILE_DEVICE_MULTI_UNC_PROVIDER) {
        DfsCompleteRequest( NULL, Irp, STATUS_INVALID_DEVICE_REQUEST );
        DfsDbgTrace(-1, Dbg, "DfsFsdSetVolumeInformation - Mup file\n", 0);
        return( STATUS_INVALID_DEVICE_REQUEST );
    }

    if (DeviceObject->DeviceType == FILE_DEVICE_DFS_VOLUME) {
        Status = DfsVolumePassThrough(DeviceObject, Irp);
        DfsDbgTrace(-1, Dbg, "DfsFsdSetVolumeInformation: Exit -> %08x\n",
                                ULongToPtr(Status) );
        return Status;
    }

    //
    //  Call the common Set routine, with blocking allowed if synchronous
    //

    FsRtlEnterFileSystem();

    try {

        IrpContext = DfsCreateIrpContext( Irp, CanFsdWait( Irp ) );
        if (IrpContext == NULL)
            ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
        Status = DfsCommonSetVolumeInformation( IrpContext, Irp );

    } except(DfsExceptionFilter( IrpContext, GetExceptionCode(), GetExceptionInformation() )) {

        //
        //  We had some trouble trying to perform the requested
        //  operation, so we'll abort the I/O request with
        //  the error status that we get back from the
        //  execption code
        //

        Status = DfsProcessException( IrpContext, Irp, GetExceptionCode() );
    }

    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DfsDbgTrace(-1, Dbg, "DfsFsdSetVolumeInformation: Exit -> %08x\n",
                                ULongToPtr(Status) );

    return Status;

    UNREFERENCED_PARAMETER( DeviceObject );
}


//+-------------------------------------------------------------------
//
//  Function:   DfsFspSetVolumeInformation, public
//
//  Synopsis:   This routine implements the FSP part of the
//              NtSetVolumeInformation API call.
//
//  Arguments:  [IrpContext] -- the IRP_CONTEXT for the request
//              [Irp] -- Supplies the Irp being processed.
//
//  Returns:    Nothing
//
//--------------------------------------------------------------------

VOID
DfsFspSetVolumeInformation (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )
{
    DfsDbgTrace(+1, Dbg, "DfsFspSetVolumeInformation: Entered\n", 0);

    //
    //  Call the common Set routine.
    //

    (VOID)DfsCommonSetVolumeInformation( IrpContext, Irp );

    //
    //  And return to our caller
    //

    DfsDbgTrace(-1, Dbg, "DfsFspSetVolumeInformation: Exit -> VOID\n", 0);

    return;
}


//+-------------------------------------------------------------------
//
//  Function:   DfsCommonSetVolumeInformation, private
//
//  Synopsis:   This is the common routine for Seting volume information
//              called by both the FSD and FSP threads.
//
//  Arguments:  [IrpContext] -- Supplies the context block for the IRP
//              [Irp] -- Supplies the IRP being processed
//
//  Returns:    NTSTATUS - The return status for the operation
//
//--------------------------------------------------------------------

NTSTATUS
DfsCommonSetVolumeInformation (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
) {
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    PDFS_VCB Vcb;
    PDFS_FCB Fcb;

    FS_INFORMATION_CLASS FsInformationClass;
    PVOID Buffer;

    TYPE_OF_OPEN TypeOfOpen;

    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );


    DfsDbgTrace(+1, Dbg, "DfsCommonSetVolumeInformation: Entered\n", 0);
    DfsDbgTrace( 0, Dbg, "Irp                  = %08x\n", Irp );
    DfsDbgTrace( 0, Dbg, "->Length             = %08x\n", ULongToPtr(IrpSp->Parameters.SetVolume.Length) );
    DfsDbgTrace( 0, Dbg, "->FsInformationClass = %08x\n", IrpSp->Parameters.SetVolume.FsInformationClass);
    DfsDbgTrace( 0, Dbg, "->Buffer             = %08x\n", Irp->AssociatedIrp.SystemBuffer);

    //
    //  Reference our input parameters to make things easier
    //

    FsInformationClass = IrpSp->Parameters.SetVolume.FsInformationClass;
    Buffer = Irp->AssociatedIrp.SystemBuffer;

    //
    //  Decode the file object to get the Vcb
    //

    TypeOfOpen = DfsDecodeFileObject( IrpSp->FileObject, &Vcb, &Fcb);

    try {

        Status = STATUS_INVALID_PARAMETER;

        //
        //  Case on the type of open.
        //

        switch (TypeOfOpen) {

        default:
            DfsDbgTrace(0, Dbg, "DfsCommonSetVolumeInfo: Unknown open type\n", 0);

            // NOTE:  FALL THROUGH
        case FilesystemDeviceOpen:
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;

        case LogicalRootDeviceOpen:
        case RedirectedFileOpen:

            //
            //  Based on the information class we'll do different actions.
            //  Each of the procedures that we're calling fills up the output
            //  buffer if possible and returns true if it successfully filled
            //  the buffer and false if it couldn't wait for any I/O to
            //  complete.
            //

            switch (FsInformationClass) {

            case FileFsLabelInformation:
                Status = DfsSetFsLabelInfo( IrpContext, Vcb, Buffer);
                break;

            default:
                DfsDbgTrace(0, Dbg, "DfsCommonSetVolumeInfo: Unknown InformationClass\n", 0);
                Status = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }
        }

    } finally {

        if (!AbnormalTermination()) {
            DfsCompleteRequest( IrpContext, Irp, Status );
        }

        DfsDbgTrace(-1, Dbg, "DfsCommonSetVolumeInformation: Exit -> %08x\n",
                                ULongToPtr(Status) );
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\kdext\kdextlib.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    kdextlib.c

Abstract:

    Library routines for dumping data structures given a meta level descrioption

Author:

    Balan Sethu Raman (SethuR) 11-May-1994

Notes:
    The implementation tends to avoid memory allocation and deallocation as much as possible.
    Therefore We have choosen an arbitrary length as the default buffer size. A mechanism will
    be provided to modify this buffer length through the debugger extension commands.

Revision History:

    11-Nov-1994 SethuR  Created

--*/

#include <ntos.h>
#include <nturtl.h>
#include "ntverp.h"

#include <windows.h>
#include <wdbgexts.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include <kdextlib.h>

BOOL
kdextAtoi(
    LPSTR lpArg,
    int *pRet
);

int
kdextStrlen(
    LPSTR lpsz
);

int
kdextStrnicmp(
    LPSTR lpsz1,
    LPSTR lpsz2,
    int cLen
);

#define    PRINTF    dprintf


PWINDBG_OUTPUT_ROUTINE                lpOutputRoutine;
PWINDBG_GET_EXPRESSION32              lpGetExpressionRoutine;
PWINDBG_GET_SYMBOL32                  lpGetSymbolRoutine;
PWINDBG_READ_PROCESS_MEMORY_ROUTINE   lpReadMemoryRoutine;

#define    NL      1
#define    NONL    0

#define DEFAULT_UNICODE_DATA_LENGTH 512
USHORT s_UnicodeStringDataLength = DEFAULT_UNICODE_DATA_LENGTH;
WCHAR  s_UnicodeStringData[DEFAULT_UNICODE_DATA_LENGTH];
WCHAR *s_pUnicodeStringData = s_UnicodeStringData;

#define DEFAULT_ANSI_DATA_LENGTH 512
USHORT s_AnsiStringDataLength = DEFAULT_ANSI_DATA_LENGTH;
CHAR  s_AnsiStringData[DEFAULT_ANSI_DATA_LENGTH];
CHAR *s_pAnsiStringData = s_AnsiStringData;

//
// No. of columns used to display struct fields;
//

ULONG s_MaxNoOfColumns = 3;
ULONG s_NoOfColumns = 1;

/*
 * Fetches the data at the given address
 */
BOOLEAN
GetData( ULONG_PTR dwAddress, PVOID ptr, ULONG size)
{
    BOOL b;
    ULONG BytesRead;

    b = (lpReadMemoryRoutine)(dwAddress, ptr, size, &BytesRead );


    if (!b || BytesRead != size ) {
        return FALSE;
    }

    return TRUE;
}

/*
 * Fetch the null terminated ASCII string at dwAddress into buf
 */
BOOL
GetStringW( DWORD dwAddress, LPWSTR buf )
{
    do {
        if( !GetData( dwAddress,buf, sizeof(WCHAR)) )
            return FALSE;

        dwAddress += sizeof(WCHAR);
        buf++;

    } while( *buf != '\0' );

    return TRUE;
}

/*
 * Displays a byte in hexadecimal
 */
VOID
PrintHexChar( UCHAR c )
{
    PRINTF( "%c%c", "0123456789abcdef"[ (c>>4)&7 ], "0123456789abcdef"[ c&7 ] );
}

/*
 * Displays a buffer of data in hexadecimal
 */
VOID
PrintHexBuf( PUCHAR buf, ULONG cbuf )
{
    while( cbuf-- ) {
        PrintHexChar( *buf++ );
        PRINTF( " " );
    }
}

/*
 * Displays a unicode string
 */
BOOL
PrintStringW(LPSTR msg, PUNICODE_STRING puStr, BOOL nl )
{
    UNICODE_STRING UnicodeString;
    BOOLEAN        b;

    if( msg )
        PRINTF( msg );

    if( puStr->Length == 0 ) {
        if( nl )
            PRINTF( "\n" );
        return TRUE;
    }

    UnicodeString.Buffer        = s_pUnicodeStringData;
    UnicodeString.MaximumLength = s_UnicodeStringDataLength;
    UnicodeString.Length = (puStr->Length > s_UnicodeStringDataLength)
                            ? s_UnicodeStringDataLength
                            : puStr->Length;

    b = GetData((ULONG_PTR)puStr->Buffer, UnicodeString.Buffer, (ULONG) UnicodeString.Length);

    if (b)    {
        PRINTF("%wZ%s", &UnicodeString, nl ? "\n" : "" );
    }

    return b;
}

/*
 * Displays a ANSI string
 */
BOOL
PrintStringA(LPSTR msg, PANSI_STRING pStr, BOOL nl )
{
    ANSI_STRING AnsiString;
    BOOL b;

    if( msg )
        PRINTF( msg );

    if( pStr->Length == 0 ) {
        if( nl )
            PRINTF( "\n" );
        return TRUE;
    }

    AnsiString.Buffer        = s_pAnsiStringData;
    AnsiString.MaximumLength = s_AnsiStringDataLength;
    AnsiString.Length = (pStr->Length > (s_AnsiStringDataLength - 1))
                        ? (s_AnsiStringDataLength - 1)
                        : pStr->Length;

    b = (lpReadMemoryRoutine)(
                (ULONG_PTR)pStr->Buffer,
                AnsiString.Buffer,
                AnsiString.Length,
                NULL);

    if (b)    {
        AnsiString.Buffer[ AnsiString.Length ] = '\0';
        PRINTF("%s%s", AnsiString.Buffer, nl ? "\n" : "" );
    }

    return b;
}

/*
 * Displays a GUID
 */

BOOL
PrintGuid(
    GUID *pguid)
{
    ULONG i;

    PRINTF( "%08x-%04x-%04x", pguid->Data1, pguid->Data2, pguid->Data3 );
    for (i = 0; i < 8; i++) {
        PRINTF("%02x",pguid->Data4[i]);
    }
    return( TRUE );
}

/*
 * Displays a LARGE_INTEGER
 */

BOOL
PrintLargeInt(
    LARGE_INTEGER *bigint)
{
    PRINTF( "%08x:%08x", bigint->HighPart, bigint->LowPart);
    return( TRUE );
}

/*
 * Displays all the fields of a given struct. This is the driver routine that is called
 * with the appropriate descriptor array to display all the fields in a given struct.
 */



LPSTR LibCommands[] = {
    "help -- This command ",
    "version -- Version of extension ",
    "dump <Struct Type Name>@<address expr> ",
    "columns <d> -- controls the number of columns in the display ",
    0
};

BOOL
help(
    DWORD                   dwCurrentPC,
    PWINDBG_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
    int i;


    PRINTF("\n");

    for( i=0; ExtensionNames[i]; i++ )
        PRINTF( "%s\n", ExtensionNames[i] );

    for( i=0; LibCommands[i]; i++ )
        PRINTF( "   %s\n", LibCommands[i] );

    for( i=0; Extensions[i]; i++) {
        PRINTF( "   %s\n", Extensions[i] );
    }

    return TRUE;
}

BOOL
columns(
    DWORD                   dwCurrentPC,
    PWINDBG_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
    ULONG NoOfColumns;
    int   i;


    if (kdextAtoi(lpArgumentString, &i) && i > 0) {

        NoOfColumns = (ULONG) i;

        if (NoOfColumns > s_MaxNoOfColumns) {
            PRINTF( "No. Of Columns exceeds maximum(%ld) -- directive Ignored\n", s_MaxNoOfColumns );
        } else {
            s_NoOfColumns = NoOfColumns;
        }

    } else {

        PRINTF( "Bad argument to command (%s)", lpArgumentString );

    }

    return TRUE;
}

BOOL
version
(
    DWORD                   dwCurrentPC,
    PWINDBG_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
#if    VER_DEBUG
    char *kind = "checked";
#else
    char *kind = "free";
#endif


    PRINTF( "Mup debugger extension dll for %s build %u\n", kind, VER_PRODUCTBUILD );

    return TRUE;
}


/*
 * KD Extensions should not link with the C-Runtime library routines. So,
 * we implement a few of the needed ones here.
 */

BOOL
kdextAtoi(
    LPSTR lpArg,
    int *pRet
)
{
    int n, cbArg, val = 0;
    BOOL fNegative = FALSE;

    cbArg = kdextStrlen( lpArg );

    if (cbArg > 0) {
        for (n = 0; lpArg[n] == ' '; n++) {
            ;
        }
        if (lpArg[n] == '-') {
            n++;
            fNegative = TRUE;
        }
        for (; lpArg[n] >= '0' && lpArg[n] <= '9'; n++) {
            val *= 10;
            val += (int) (lpArg[n] - '0');
        }
        if (lpArg[n] == 0) {
            *pRet = (fNegative ? -val : val);
            return( TRUE );
        } else {
            return( FALSE );
        }
    } else {
        return( FALSE );
    }

}

int
kdextStrlen(
    LPSTR lpsz
)
{
    int c;

    if (lpsz == NULL) {
        c = 0;
    } else {
        for (c = 0; lpsz[c] != 0; c++) {
            ;
        }
    }

    return( c );
}


#define UPCASE_CHAR(c)  \
    ( (((c) >= 'a') && ((c) <= 'z')) ? ((c) - 'a' + 'A') : (c) )

int
kdextStrnicmp(
    LPSTR lpsz1,
    LPSTR lpsz2,
    int cLen
)
{
    int nDif, i;

    for (i = nDif = 0; nDif == 0 && i < cLen; i++) {
        nDif = UPCASE_CHAR(lpsz1[i]) - UPCASE_CHAR(lpsz2[i]);
    }

    return( nDif );
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\kdext\mupkd.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    dfskd.c

Abstract:

    Dfs Kernel Debugger extension

Author:

    Milan Shah (milans) 21-Aug-1995

Revision History:

    21-Aug-1995 Milans  Created

--*/


#include <ntos.h>
#include <nturtl.h>
#include "ntverp.h"

#include <windows.h>

#include <wdbgexts.h>

#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include <windef.h>
#include <tdi.h>
#include <wincred.h>
#include <ntddnfs.h>                             // For communicating with
                                                 // the SMB Rdr
#include <ntddmup.h>                             // For UNC registration


#include <winnetwk.h>                            // For NETRESOURCE def'n

#include <dfsfsctl.h>                            // Dfs FsControl Codes.

#include <lmdfs.h>                               // DFS_INFO_X

#include "nodetype.h"
#include "dfsmrshl.h"
#include "dfsfsctl.h"
#include "pkt.h"
#include "dfsstruc.h"
#include "fcbsup.h"
#include "fsctrl.h"
#include "dnr.h"
#include "lock.h"
#include "mupstruc.h"
#include "mupdata.h"

#include <kdextlib.h>
#include <stdlib.h>
#define PRINTF dprintf

#define FIELD_NAME_LENGTH 30
#define NewLineForFields(FieldNo) \
        ((((FieldNo) % s_NoOfColumns) == 0) ? NewLine : FieldSeparator)
char *NewLine  = "\n";
char *FieldSeparator = " ";


BOOLEAN wGetData( ULONG_PTR dwAddress, PVOID ptr, ULONG size);
BOOL wGetString( ULONG_PTR dwAddress, PSZ buf );
BOOL wPrintStringW( IN LPSTR msg OPTIONAL, IN PUNICODE_STRING pStr, IN BOOL nl );
BOOL wPrintStringA( IN LPSTR msg OPTIONAL, IN PANSI_STRING pStr, IN BOOL nl );
BOOL wPrintLargeInt(LARGE_INTEGER *bigint);

/*
 * Mup global variables.
 *
 */

#define NO_SYMBOLS_MESSAGE      \
    "Unable to get address of Mup!DfsData - do you have symbols?\n"

LPSTR ExtensionNames[] = {
    "Mup debugger extensions",
    0
};

LPSTR Extensions[] = {
    "DfsData - dumps Mup!DfsData",
    "Pkt - dumps the global Pkt",
    "FcbTable - dumps all the Dfs FCBs",
    "VcbList - dumps all the Vcbs & Dfs Device Objects (net used objects)",
    "DrtList - dumps all the Devless Roots (net used objects)",
    "OfflineList - dumps all the Offline Roots",
    "CredList - dumps all the defined Credentials",
    "SpecialTable - dumps the special table",
    "PrefixList - dumps all the mup prefixes",
    "Dump - dump a data structure. Type in 'mupkd.dump' for more info",
    0
};

ENUM_VALUE_DESCRIPTOR DfsMachineStateEnum[] = {
    {DFS_UNKNOWN, "Dfs State Unknown"},
    {DFS_CLIENT, "Dfs Client"},
    {DFS_SERVER, "Dfs Server"},
    {DFS_ROOT_SERVER, "Dfs Root"},
    0
};

/*
 * DFS_DATA
 *
 */

FIELD_DESCRIPTOR DfsDataFields[] = {
    FIELD3(FieldTypeShort,DFS_DATA,NodeTypeCode),
    FIELD3(FieldTypeShort,DFS_DATA,NodeByteSize),
    FIELD3(FieldTypeStruct,DFS_DATA,VcbQueue),
    FIELD3(FieldTypeStruct,DFS_DATA,DeletedVcbQueue),
    FIELD3(FieldTypeStruct,DFS_DATA,DrtQueue),
    FIELD3(FieldTypeStruct,DFS_DATA,Credentials),
    FIELD3(FieldTypeStruct,DFS_DATA,DeletedCredentials),
    FIELD3(FieldTypeStruct,DFS_DATA,OfflineRoots),
    FIELD3(FieldTypePointer,DFS_DATA,DriverObject),
    FIELD3(FieldTypePointer,DFS_DATA,FileSysDeviceObject),
    FIELD3(FieldTypePointer,DFS_DATA,pProvider),
    FIELD3(FieldTypeULong,DFS_DATA,cProvider),
    FIELD3(FieldTypeULong,DFS_DATA,maxProvider),
    FIELD3(FieldTypeStruct,DFS_DATA,Resource),
    FIELD3(FieldTypeStruct,DFS_DATA,DfsLock),
    FIELD3(FieldTypePointer,DFS_DATA,OurProcess),
    FIELD3(FieldTypeUnicodeString,DFS_DATA,LogRootDevName),
    FIELD4(FieldTypeEnum,DFS_DATA,MachineState,DfsMachineStateEnum),
    FIELD3(FieldTypeStruct,DFS_DATA,Pkt),
    FIELD3(FieldTypeStruct,DFS_DATA,PktWritePending),
    FIELD3(FieldTypeStruct,DFS_DATA,PktReferralRequests),
    FIELD3(FieldTypePointer,DFS_DATA,FcbHashTable),
    0
};

/*
 * DFS_PKT
 *
 */

FIELD_DESCRIPTOR DfsPktFields[] = {
    FIELD3(FieldTypeUShort,DFS_PKT,NodeTypeCode),
    FIELD3(FieldTypeUShort,DFS_PKT,NodeByteSize),
    FIELD3(FieldTypeStruct,DFS_PKT,Resource),
    FIELD3(FieldTypeStruct,DFS_PKT,UseCountLock),
    FIELD3(FieldTypeULong,DFS_PKT,EntryCount),
    FIELD3(FieldTypeULong,DFS_PKT,EntryTimeToLive),
    FIELD3(FieldTypeStruct,DFS_PKT,EntryList),
    FIELD3(FieldTypeUnicodeString,DFS_PKT,DCName),
    FIELD3(FieldTypeUnicodeString,DFS_PKT,DomainNameFlat),
    FIELD3(FieldTypeUnicodeString,DFS_PKT,DomainNameDns),
    FIELD3(FieldTypeStruct,DFS_PKT,SpecialTable),
    FIELD3(FieldTypeStruct,DFS_PKT,PrefixTable),
    FIELD3(FieldTypeStruct,DFS_PKT,ShortPrefixTable),
    FIELD3(FieldTypeStruct,DFS_PKT,DSMachineTable),
    0
};


/*
 * DFS_SPECIAL_TABLE
 *
 */
FIELD_DESCRIPTOR DfsSpecialTableFields[] = {
    FIELD3(FieldTypeStruct,DFS_SPECIAL_TABLE,SpecialEntryList),
    FIELD3(FieldTypeULong,DFS_SPECIAL_TABLE,SpecialEntryCount),
    FIELD3(FieldTypeULong,DFS_SPECIAL_TABLE,TimeToLive),
    0
};

/*
 * DFS_PKT_ENTRY
 *
 */

BIT_MASK_DESCRIPTOR PktEntryType[]  = {
    {PKT_ENTRY_TYPE_DFS, "Uplevel Volume"},
    {PKT_ENTRY_TYPE_MACHINE, "Machine Volume"},
    {PKT_ENTRY_TYPE_NONDFS, "Downlevel Volume"},
    {PKT_ENTRY_TYPE_SYSVOL, "Sysvol"},
    {PKT_ENTRY_TYPE_OUTSIDE_MY_DOM, "Inter-Domain Volume"},
    {PKT_ENTRY_TYPE_REFERRAL_SVC, "Referral Service (DC)"},
    {PKT_ENTRY_TYPE_PERMANENT, "Permanent Entry"},
    {PKT_ENTRY_TYPE_LOCAL,"Local Volume"},
    {PKT_ENTRY_TYPE_LOCAL_XPOINT,"Local Exit Point"},
    {PKT_ENTRY_TYPE_OFFLINE,"Offline Volume"},
    0
};

FIELD_DESCRIPTOR DfsPktEntryFields[] = {
    FIELD3(FieldTypeUShort,DFS_PKT_ENTRY,NodeTypeCode),
    FIELD3(FieldTypeUShort,DFS_PKT_ENTRY,NodeByteSize),
    FIELD3(FieldTypeStruct,DFS_PKT_ENTRY,Link),
    FIELD4(FieldTypeDWordBitMask,DFS_PKT_ENTRY,Type,PktEntryType),
    FIELD3(FieldTypeULong,DFS_PKT_ENTRY,USN),
    FIELD3(FieldTypeUnicodeString,DFS_PKT_ENTRY,Id.Prefix),
    FIELD3(FieldTypeUnicodeString,DFS_PKT_ENTRY,Id.ShortPrefix),
    FIELD3(FieldTypeULong,DFS_PKT_ENTRY,Info.ServiceCount),
    FIELD3(FieldTypePointer,DFS_PKT_ENTRY,Info.ServiceList),
    FIELD3(FieldTypeULong,DFS_PKT_ENTRY,ExpireTime),
    FIELD3(FieldTypeULong,DFS_PKT_ENTRY,TimeToLive),
    FIELD3(FieldTypeULong,DFS_PKT_ENTRY,UseCount),
    FIELD3(FieldTypeULong,DFS_PKT_ENTRY,FileOpenCount),
    FIELD3(FieldTypePointer,DFS_PKT_ENTRY,ActiveService),
    FIELD3(FieldTypePointer,DFS_PKT_ENTRY,LocalService),
    FIELD3(FieldTypePointer,DFS_PKT_ENTRY,Superior),
    FIELD3(FieldTypeULong,DFS_PKT_ENTRY,SubordinateCount),
    FIELD3(FieldTypeStruct,DFS_PKT_ENTRY,SubordinateList),
    FIELD3(FieldTypeStruct,DFS_PKT_ENTRY,SiblingLink),
    FIELD3(FieldTypePointer,DFS_PKT_ENTRY,ClosestDC),
    FIELD3(FieldTypeStruct,DFS_PKT_ENTRY,ChildList),
    FIELD3(FieldTypeStruct,DFS_PKT_ENTRY,NextLink),
    FIELD3(FieldTypeStruct,DFS_PKT_ENTRY,PrefixTableEntry),
    0
};

/*
 * DFS_SERVICE
 *
 */

BIT_MASK_DESCRIPTOR ServiceType[] = {
    {DFS_SERVICE_TYPE_MASTER, "Master Svc"},
    {DFS_SERVICE_TYPE_READONLY, "Read-Only Svc"},
    {DFS_SERVICE_TYPE_LOCAL, "Local Svc"},
    {DFS_SERVICE_TYPE_REFERRAL, "Referral Svc"},
    {DFS_SERVICE_TYPE_ACTIVE, "Active Svc"},
    {DFS_SERVICE_TYPE_DOWN_LEVEL, "Down-level Svc"},
    {DFS_SERVICE_TYPE_COSTLIER, "Costlier than previous"},
    {DFS_SERVICE_TYPE_OFFLINE, "Svc Offline"},
    0
};

BIT_MASK_DESCRIPTOR ServiceCapability[] = {
    {PROV_DFS_RDR, "Use Dfs Rdr"},
    {PROV_STRIP_PREFIX, "Strip Prefix (downlevel or local) Svc"},
    0
};


FIELD_DESCRIPTOR DfsServiceFields[] = {
    FIELD4(FieldTypeDWordBitMask,DFS_SERVICE,Type,ServiceType),
    FIELD4(FieldTypeDWordBitMask,DFS_SERVICE,Capability,ServiceCapability),
    FIELD3(FieldTypeULong,DFS_SERVICE,ProviderId),
    FIELD3(FieldTypeUnicodeString,DFS_SERVICE,Name),
    FIELD3(FieldTypePointer,DFS_SERVICE,ConnFile),
    FIELD3(FieldTypePointer,DFS_SERVICE,pProvider),
    FIELD3(FieldTypeUnicodeString,DFS_SERVICE,Address),
    FIELD3(FieldTypePointer,DFS_SERVICE,pMachEntry),
    FIELD3(FieldTypeULong,DFS_SERVICE,Cost),
    0
};

/*
 * DFS_MACHINE_ENTRY
 *
 */

FIELD_DESCRIPTOR DfsMachineEntryFields[] = {
    FIELD3(FieldTypePointer,DFS_MACHINE_ENTRY,pMachine),
    FIELD3(FieldTypeUnicodeString,DFS_MACHINE_ENTRY,MachineName),
    FIELD3(FieldTypeULong,DFS_MACHINE_ENTRY,UseCount),
    FIELD3(FieldTypeULong,DFS_MACHINE_ENTRY,ConnectionCount),
    FIELD3(FieldTypePointer,DFS_MACHINE_ENTRY,AuthConn),
    FIELD3(FieldTypePointer,DFS_MACHINE_ENTRY,Credentials),
    0
};

/*
 * DFS_SPECIAL_ENTRY
 *
 */

FIELD_DESCRIPTOR DfsSpecialEntryFields[] = {
    FIELD3(FieldTypeShort,DFS_SPECIAL_ENTRY,NodeTypeCode),
    FIELD3(FieldTypeShort,DFS_SPECIAL_ENTRY,NodeByteSize),
    FIELD3(FieldTypeStruct,DFS_SPECIAL_ENTRY,Link),
    FIELD3(FieldTypeULong,DFS_SPECIAL_ENTRY,USN),
    FIELD3(FieldTypeULong,DFS_SPECIAL_ENTRY,UseCount),
    FIELD3(FieldTypeUnicodeString,DFS_SPECIAL_ENTRY,SpecialName),
    FIELD3(FieldTypeULong,DFS_SPECIAL_ENTRY,ExpandedCount),
    FIELD3(FieldTypeULong,DFS_SPECIAL_ENTRY,Active),
    FIELD3(FieldTypePointer,DFS_SPECIAL_ENTRY,ExpandedNames),
    FIELD3(FieldTypeBoolean,DFS_SPECIAL_ENTRY,NeedsExpansion),
    FIELD3(FieldTypeBoolean,DFS_SPECIAL_ENTRY,Stale),
    0
};

/*
 * DFS_EXPANDED_NAME
 *
 */

FIELD_DESCRIPTOR DfsExpandedNameFields[] = {
    FIELD3(FieldTypeUnicodeString,DFS_EXPANDED_NAME,ExpandedName),
    FIELD3(FieldTypeStruct,DFS_EXPANDED_NAME,Guid),
    0
};

/*
 * DS_MACHINE
 *
 */

FIELD_DESCRIPTOR DsMachineFields[] = {
    FIELD3(FieldTypeGuid,DS_MACHINE,guidSite),
    FIELD3(FieldTypeGuid,DS_MACHINE,guidMachine),
    FIELD3(FieldTypeULong,DS_MACHINE,grfFlags),
    FIELD3(FieldTypePWStr,DS_MACHINE,pwszShareName),
    FIELD3(FieldTypeULong,DS_MACHINE,cPrincipals),
    FIELD3(FieldTypePointer,DS_MACHINE,prgpwszPrincipals),
    FIELD3(FieldTypeULong,DS_MACHINE,cTransports),
    FIELD3(FieldTypeStruct,DS_MACHINE,rpTrans),
    0
};

/*
 * PROVIDER_DEF
 *
 */

FIELD_DESCRIPTOR ProviderDefFields[] = {
    FIELD3(FieldTypeUShort,PROVIDER_DEF,NodeTypeCode),
    FIELD3(FieldTypeUShort,PROVIDER_DEF,NodeByteSize),
    FIELD3(FieldTypeUShort,PROVIDER_DEF,eProviderId),
    FIELD4(FieldTypeDWordBitMask,PROVIDER_DEF,fProvCapability,ServiceCapability),
    FIELD3(FieldTypeUnicodeString,PROVIDER_DEF,DeviceName),
    FIELD3(FieldTypePointer,PROVIDER_DEF,DeviceObject),
    FIELD3(FieldTypePointer,PROVIDER_DEF,FileObject),
    0
};

/*
 * DFS_PREFIX_TABLE
 *
 */

FIELD_DESCRIPTOR DfsPrefixTableFields[] = {
    FIELD3(FieldTypeBoolean,DFS_PREFIX_TABLE,CaseSensitive),
    FIELD3(FieldTypePointer,DFS_PREFIX_TABLE,NamePageList.pFirstPage),
    FIELD3(FieldTypePointer,DFS_PREFIX_TABLE,NextEntry),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,RootEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[0].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[0].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[1].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[1].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[2].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[2].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[3].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[3].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[4].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[4].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[5].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[5].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[6].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[6].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[7].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[7].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[8].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[8].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[9].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[9].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[10].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[10].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[11].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[11].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[12].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[12].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[13].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[13].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[14].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[14].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[15].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[15].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[16].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[16].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[17].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[17].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[18].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[18].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[19].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[19].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[20].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[20].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[21].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[21].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[22].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[22].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[23].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[23].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[24].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[24].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[25].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[25].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[26].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[26].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[27].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[27].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[28].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[28].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[29].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[29].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[30].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[30].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[31].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[31].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[32].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[32].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[33].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[33].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[34].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[34].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[35].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[35].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[36].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[36].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[37].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[37].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[38].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[38].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[39].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[39].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[40].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[40].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[41].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[41].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[42].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[42].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[43].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[43].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[44].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[44].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[45].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[45].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[46].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[46].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[47].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[47].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[48].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[48].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[49].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[49].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[50].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[50].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[51].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[51].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[52].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[52].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[53].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[53].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[54].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[54].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[55].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[55].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[56].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[56].SentinelEntry),
    0
};

/*
 * DFS_PREFIX_TABLE_ENTRY
 *
 */

FIELD_DESCRIPTOR DfsPrefixTableEntryFields[] = {
    FIELD3(FieldTypePointer,DFS_PREFIX_TABLE_ENTRY,pParentEntry),
    FIELD3(FieldTypePointer,DFS_PREFIX_TABLE_ENTRY,pNextEntry),
    FIELD3(FieldTypePointer,DFS_PREFIX_TABLE_ENTRY,pPrevEntry),
    FIELD3(FieldTypePointer,DFS_PREFIX_TABLE_ENTRY,pFirstChildEntry),
    FIELD3(FieldTypePointer,DFS_PREFIX_TABLE_ENTRY,pSiblingEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE_ENTRY,NoOfChildren),
    FIELD3(FieldTypeUnicodeString,DFS_PREFIX_TABLE_ENTRY,PathSegment),
    FIELD3(FieldTypePointer,DFS_PREFIX_TABLE_ENTRY,pData),
    0
};


/*
 * DFS_FCB
 *
 */

FIELD_DESCRIPTOR FcbFields[] = {
    FIELD3(FieldTypeUShort, DFS_FCB, NodeTypeCode),
    FIELD3(FieldTypeUShort, DFS_FCB, NodeByteSize),
    FIELD3(FieldTypePointer, DFS_FCB, Vcb),
    FIELD3(FieldTypeUnicodeString, DFS_FCB, FullFileName),
    FIELD3(FieldTypePointer, DFS_FCB, FileObject),
    FIELD3(FieldTypePointer, DFS_FCB, TargetDevice),
    FIELD3(FieldTypePointer, DFS_FCB, DfsMachineEntry),
    0
};

/*
 * DFS_VCB
 *
 */

BIT_MASK_DESCRIPTOR VcbStateFlagBits[] = {
    {VCB_STATE_FLAG_LOCKED, "Vcb Locked"},
    {VCB_STATE_FLAG_ALLOC_FCB, "Allocate Fcb"},
    0
};

FIELD_DESCRIPTOR VcbFields[] = {
    FIELD3(FieldTypeUShort,DFS_VCB,NodeTypeCode),
    FIELD3(FieldTypeUShort,DFS_VCB,NodeByteSize),
    FIELD3(FieldTypeStruct,DFS_VCB,VcbLinks),
    FIELD4(FieldTypeDWordBitMask,DFS_VCB,VcbState,VcbStateFlagBits),
    FIELD3(FieldTypeUnicodeString,DFS_VCB,LogicalRoot),
    FIELD3(FieldTypeUnicodeString,DFS_VCB,LogRootPrefix),
    FIELD3(FieldTypePointer,DFS_VCB,Credentials),
    FIELD3(FieldTypeULong,DFS_VCB,DirectAccessOpenCount),
    FIELD3(FieldTypeStruct,DFS_VCB,ShareAccess),
    FIELD3(FieldTypeULong,DFS_VCB,OpenFileCount),
    FIELD3(FieldTypePointer,DFS_VCB,FileObjectWithVcbLocked),
#ifdef TERMSRV
    FIELD3(FieldTypeULong,DFS_VCB,SessionID),
#endif // TERMSRV
    FIELD3(FieldTypeULong,DFS_VCB,LogonID),
    0
};

FIELD_DESCRIPTOR DrtFields[] = {
    FIELD3(FieldTypeUShort,DFS_DEVLESS_ROOT,NodeTypeCode),
    FIELD3(FieldTypeUShort,DFS_DEVLESS_ROOT,NodeByteSize),
    FIELD3(FieldTypeStruct,DFS_DEVLESS_ROOT,DrtLinks),
    FIELD3(FieldTypeUnicodeString,DFS_DEVLESS_ROOT,DevlessPath),
    FIELD3(FieldTypePointer,DFS_DEVLESS_ROOT,Credentials),
#ifdef TERMSRV
    FIELD3(FieldTypeULong,DFS_DEVLESS_ROOT,SessionID),
#endif // TERMSRV
    FIELD3(FieldTypeULong,DFS_DEVLESS_ROOT,LogonID),
    0
};

FIELD_DESCRIPTOR OfflineRootFields[] = {
    FIELD3(FieldTypeUnicodeString,DFS_OFFLINE_SERVER,LogicalServerName),
    FIELD3(FieldTypeStruct,DFS_OFFLINE_SERVER,ListEntry),
    0
};


FIELD_DESCRIPTOR KnownPrefixFields[] = {
    FIELD3(FieldTypeULong,KNOWN_PREFIX,BlockHeader.ReferenceCount),
    FIELD3(FieldTypeStruct,KNOWN_PREFIX,TableEntry),
    FIELD3(FieldTypeUnicodeString,KNOWN_PREFIX,Prefix),
    FIELD3(FieldTypeStruct,KNOWN_PREFIX,LastUsedTime),
    FIELD3(FieldTypeLargeInteger,KNOWN_PREFIX,LastUsedTime),
    FIELD3(FieldTypePointer,KNOWN_PREFIX,UncProvider),
    FIELD3(FieldTypeBoolean,KNOWN_PREFIX,InTable),
    FIELD3(FieldTypeBoolean,KNOWN_PREFIX,Active),
    0
};


FIELD_DESCRIPTOR UncProviderFields[] = {
    FIELD3(FieldTypeULong,UNC_PROVIDER,BlockHeader.ReferenceCount),
    FIELD3(FieldTypeUnicodeString,UNC_PROVIDER,DeviceName),
    FIELD3(FieldTypeStruct,UNC_PROVIDER,Handle),
    FIELD3(FieldTypePointer,UNC_PROVIDER,DeviceObject),
    FIELD3(FieldTypePointer,UNC_PROVIDER,FileObject),
    FIELD3(FieldTypeULong,UNC_PROVIDER,Priority),
    FIELD3(FieldTypeBoolean,UNC_PROVIDER,MailslotsSupported),
    0
};

/*
 * DFS_CREDENTIALS
 *
 */

FIELD_DESCRIPTOR CredentialsFields[] = {
     FIELD3(FieldTypeStruct,DFS_CREDENTIALS,Link),
     FIELD3(FieldTypeULong,DFS_CREDENTIALS,Flags),
     FIELD3(FieldTypeULong,DFS_CREDENTIALS,RefCount),
     FIELD3(FieldTypeULong,DFS_CREDENTIALS,NetUseCount),
     FIELD3(FieldTypeUnicodeString,DFS_CREDENTIALS,ServerName),
     FIELD3(FieldTypeUnicodeString,DFS_CREDENTIALS,ShareName),
     FIELD3(FieldTypeUnicodeString,DFS_CREDENTIALS,DomainName),
     FIELD3(FieldTypeUnicodeString,DFS_CREDENTIALS,UserName),
     FIELD3(FieldTypeUnicodeString,DFS_CREDENTIALS,Password),
#ifdef TERMSRV
     FIELD3(FieldTypeULong,DFS_CREDENTIALS,SessionID),
#endif // TERMSRV
     FIELD3(FieldTypeULong,DFS_CREDENTIALS,LogonID),
     FIELD3(FieldTypeULong,DFS_CREDENTIALS, EaLength),
     FIELD3(FieldTypeStruct,DFS_CREDENTIALS,EaBuffer),
     0
};

/*
 * DNR_CONTEXT
 *
 */

ENUM_VALUE_DESCRIPTOR DnrStateEnum[] = {
    {DnrStateEnter, "DNR State Enter"},
    {DnrStateStart, "DNR State Start"},
    {DnrStateGetFirstDC, "DNR State GetFirstDC"},
    {DnrStateGetReferrals, "DNR State GetReferrals"},
    {DnrStateGetNextDC, "DNR State GetNextDC"},
    {DnrStateCompleteReferral, "DNR State CompleteReferral"},
    {DnrStateSendRequest, "DNR State SendRequest"},
    {DnrStatePostProcessOpen, "DNR State PostProcessOpen"},
    {DnrStateGetFirstReplica, "DNR State GetFirstReplica"},
    {DnrStateGetNextReplica, "DNR State GetNextReplica"},
    {DnrStateSvcListCheck, "DNR State SvcListCheck"},
    {DnrStateDone, "DNR State Done"},
    {DnrStateLocalCompletion, "DNR State LocalCompletion"},
    0
};

FIELD_DESCRIPTOR DnrContextFields[] = {
    FIELD3(FieldTypeUShort, DNR_CONTEXT, NodeTypeCode),
    FIELD3(FieldTypeUShort, DNR_CONTEXT, NodeByteSize),
    FIELD4(FieldTypeEnum, DNR_CONTEXT, State, DnrStateEnum),
    FIELD3(FieldTypeStruct,DNR_CONTEXT,SecurityContext),
    FIELD3(FieldTypePointer,DNR_CONTEXT,pPktEntry),
    FIELD3(FieldTypeULong,DNR_CONTEXT,USN),
    FIELD3(FieldTypePointer,DNR_CONTEXT,pService),
    FIELD3(FieldTypePointer,DNR_CONTEXT,pProvider),
    FIELD3(FieldTypeUShort,DNR_CONTEXT,ProviderId),
    FIELD3(FieldTypePointer,DNR_CONTEXT,TargetDevice),
    FIELD3(FieldTypePointer,DNR_CONTEXT,AuthConn),
    FIELD3(FieldTypePointer,DNR_CONTEXT,DCConnFile),
    FIELD3(FieldTypePointer,DNR_CONTEXT,Credentials),
    FIELD3(FieldTypePointer,DNR_CONTEXT,pIrpContext),
    FIELD3(FieldTypePointer,DNR_CONTEXT,OriginalIrp),
    FIELD3(FieldTypeULong,DNR_CONTEXT,FinalStatus),
    FIELD3(FieldTypePointer,DNR_CONTEXT,FcbToUse),
    FIELD3(FieldTypePointer,DNR_CONTEXT,Vcb),
    FIELD3(FieldTypeUnicodeString,DNR_CONTEXT,FileName),
    FIELD3(FieldTypeUnicodeString,DNR_CONTEXT,RemainingPart),
    FIELD3(FieldTypeUnicodeString,DNR_CONTEXT,SavedFileName),
    FIELD3(FieldTypePointer,DNR_CONTEXT,SavedRelatedFileObject),
    FIELD3(FieldTypeStruct,DNR_CONTEXT,RSelectContext),
    FIELD3(FieldTypeStruct,DNR_CONTEXT,RDCSelectContext),
    FIELD3(FieldTypeULong,DNR_CONTEXT,ReferralSize),
    FIELD3(FieldTypeULong,DNR_CONTEXT,Attempts),
    FIELD3(FieldTypeBoolean,DNR_CONTEXT,ReleasePkt),
    FIELD3(FieldTypeBoolean,DNR_CONTEXT,DnrActive),
    FIELD3(FieldTypeBoolean,DNR_CONTEXT,GotReferral),
    FIELD3(FieldTypeBoolean,DNR_CONTEXT,FoundInconsistency),
    FIELD3(FieldTypeBoolean,DNR_CONTEXT,CalledDCLocator),
    FIELD3(FieldTypeBoolean,DNR_CONTEXT,Impersonate),
    FIELD3(FieldTypeBoolean,DNR_CONTEXT,NameAllocated),
    FIELD3(FieldTypePointer,DNR_CONTEXT,DeviceObject),
    0
};

/*
 * REPL_SELECT_CONTEXT
 *
 */

BIT_MASK_DESCRIPTOR ReplSelectFlagBits[] = {
    {REPL_UNINITIALIZED, "Uninitialized Context"},
    {REPL_SVC_IS_LOCAL, "Local Svc Selected"},
    {REPL_SVC_IS_REMOTE, "Remote Svc Selected"},
    {REPL_PRINCIPAL_SPECD, "Svc Principal Specified"},
    {REPL_NO_MORE_ENTRIES, "Svc List Exhausted"},
    0
};

FIELD_DESCRIPTOR ReplSelectContextFields[] = {
    FIELD4(FieldTypeWordBitMask,REPL_SELECT_CONTEXT,Flags,ReplSelectFlagBits),
    FIELD3(FieldTypeULong,REPL_SELECT_CONTEXT,iFirstSvcIndex),
    FIELD3(FieldTypeULong,REPL_SELECT_CONTEXT,iSvcIndex),
    0
};


STRUCT_DESCRIPTOR Structs[] = {
    STRUCT(DFS_DATA,DfsDataFields),
    STRUCT(DFS_PKT,DfsPktFields),
    STRUCT(DFS_PKT_ENTRY,DfsPktEntryFields),
    STRUCT(DFS_SERVICE,DfsServiceFields),
    STRUCT(DFS_MACHINE_ENTRY,DfsMachineEntryFields),
    STRUCT(DS_MACHINE,DsMachineFields),
    STRUCT(DFS_SPECIAL_ENTRY,DfsSpecialEntryFields),
    STRUCT(DFS_SPECIAL_TABLE,DfsSpecialTableFields),
    STRUCT(DFS_EXPANDED_NAME,DfsExpandedNameFields),
    STRUCT(PROVIDER_DEF,ProviderDefFields),
    STRUCT(DFS_FCB,FcbFields),
    STRUCT(DNR_CONTEXT,DnrContextFields),
    STRUCT(DFS_VCB,VcbFields),
    STRUCT(DFS_DEVLESS_ROOT,DrtFields),
    STRUCT(DFS_OFFLINE_SERVER,OfflineRootFields),
    STRUCT(DFS_CREDENTIALS,CredentialsFields),
    STRUCT(DFS_PREFIX_TABLE,DfsPrefixTableFields),
    STRUCT(DFS_PREFIX_TABLE_ENTRY,DfsPrefixTableEntryFields),
    STRUCT(KNOWN_PREFIX,KnownPrefixFields),
    STRUCT(UNC_PROVIDER,UncProviderFields),
    0
};

/*
 * Dfs specific dump routines
 *
 */


VOID
dumplist(
    ULONG_PTR dwListEntryAddress,
    DWORD linkOffset,
    VOID (*dumpRoutine)(ULONG_PTR dwStructAddress)
);

VOID
dumpPktEntry(
    ULONG_PTR dwAddress
);

VOID
dumpFcb(
    ULONG_PTR dwAddress
);

VOID
dumpVcb(
    ULONG_PTR dwAddress
);

VOID
dumpDrt(
    ULONG_PTR dwAddress
);

VOID
dumpOfflineRoots(
    ULONG_PTR dwAddress
);

VOID
dumpPrefix(
    ULONG_PTR dwAddress
);

VOID
dumpCredentials(
     ULONG_PTR dwAddress
);

BOOL
dumpspecialtable(
     ULONG_PTR dwAddress
);

VOID
dumpspecialentry(
    ULONG_PTR dwAddress
);

/*
 * dfsdata : Routine to dump the global dfs data structure
 *
 */

BOOL
dfsdata(
    ULONG_PTR                  dwCurrentPC,
    PWINDBG_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
    ULONG_PTR dwAddress;

    // SETCALLBACKS();

    dwAddress = (GetExpression)("Mup!DfsData");

    if (dwAddress) {
        DFS_DATA DfsData;

        if (wGetData( dwAddress, &DfsData, sizeof(DfsData) )) {
            PrintStructFields( dwAddress, &DfsData, DfsDataFields);
        } else {
            PRINTF( "Unable to read DfsData @ %08lx\n", dwAddress );
        }
    } else {
        PRINTF( NO_SYMBOLS_MESSAGE );
    }

    return( TRUE );

}

/*
 * pkt : Routine to dump the Dfs PKT data structure
 *
 */

BOOL
pkt(
    ULONG_PTR                  dwCurrentPC,
    PWINDBG_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
    ULONG_PTR dwAddress;

    //    SETCALLBACKS();

    //
    // Figure out the address of the Pkt. This is an offset within
    // Mup!DfsData.
    //

    dwAddress = (GetExpression)("Mup!DfsData");

    if (dwAddress) {
        DFS_PKT pkt;

        dwAddress += FIELD_OFFSET(DFS_DATA, Pkt);

        if (wGetData(dwAddress,&pkt,sizeof(pkt))) {
            PrintStructFields( dwAddress, &pkt, DfsPktFields );
            dwAddress += FIELD_OFFSET(DFS_PKT, EntryList);
            dumplist(
                dwAddress,
                FIELD_OFFSET(DFS_PKT_ENTRY,Link),
                dumpPktEntry);
        }
    } else {
        PRINTF( NO_SYMBOLS_MESSAGE );
    }

    return( TRUE );

}

/*
 * specialtable : Routine to dump out the special table
 *
 */

BOOL
specialtable(
    ULONG_PTR                 dwCurrentPC,
    PWINDBG_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString)
{
    ULONG i;
    ULONG_PTR dwAddress;

    //   SETCALLBACKS();

    //
    // Figure out the address of the Pkt. This is an offset within
    // dfs!DfsData.
    //

    dwAddress = (GetExpression)("Mup!DfsData");

    if (dwAddress) {

        dwAddress += FIELD_OFFSET(DFS_DATA, Pkt.SpecialTable);
        PRINTF("SpecialTable@0x%x\n", dwAddress);
        return dumpspecialtable(dwAddress);
    } else {
        PRINTF( NO_SYMBOLS_MESSAGE );
    }
    return(TRUE);
}

/*
 * dumpPktEntry : Routine suitable as argument for dumplist; used to dump
 *      list of pkt entries.
 *
 */

VOID
dumpPktEntry(
    ULONG_PTR dwAddress
)
{
    DFS_PKT_ENTRY pktEntry;

    if (wGetData(dwAddress, &pktEntry, sizeof(DFS_PKT_ENTRY))) {

        PRINTF("\n--- Pkt Entry @ %08lx\n", dwAddress);

        wPrintStringW("Prefix : ", &pktEntry.Id.Prefix, TRUE);
        wPrintStringW("ShortPrefix : ", &pktEntry.Id.ShortPrefix, TRUE);

        //
        // Print the local service, if any
        //
        if (pktEntry.LocalService != NULL) {
            DFS_SERVICE Svc;

            PRINTF( "    Local Svc @%08lx : ",pktEntry.LocalService);
            if (wGetData( (ULONG_PTR)pktEntry.LocalService, &Svc, sizeof(Svc))) {
                wPrintStringW("Storage Id = ", &Svc.Address, TRUE);
            } else {
                PRINTF("Storage Id = ?\n");
            }
        }

        //
        // Now, print the service list
        //
        if (pktEntry.Info.ServiceCount != 0) {
            ULONG i;

            for (i = 0; i < pktEntry.Info.ServiceCount; i++) {
                DFS_SERVICE Svc;
                ULONG_PTR dwServiceAddress;

                if (CheckControlC())
                    return;
                dwServiceAddress = 
                    (ULONG_PTR)(pktEntry.Info.ServiceList) +
                        i * sizeof(DFS_SERVICE);
                PRINTF( "    Service %d @%08lx : ",i, dwServiceAddress);
                if (wGetData(dwServiceAddress, &Svc, sizeof(Svc))) {
                    wPrintStringW( "Address =", &Svc.Address, TRUE );
                } else {
                    PRINTF("Address = ?\n");
                }
            }
        }
    } else {
        PRINTF("Unable to get Pkt Entry @%08lx\n", dwAddress);
    }

}

BOOL
dumpspecialtable(
    ULONG_PTR dwAddress)
{
    ULONG i;
    DFS_SPECIAL_TABLE SpecialTable;
    LIST_ENTRY ListEntry;

    if (wGetData(dwAddress,&SpecialTable,sizeof(DFS_SPECIAL_TABLE))) {
        ULONG nEntries = SpecialTable.SpecialEntryCount;
        PRINTF("\n--- Special Table @ %08lx\n", dwAddress);
        PrintStructFields( dwAddress, &SpecialTable, DfsSpecialTableFields );

        dwAddress += FIELD_OFFSET(DFS_SPECIAL_TABLE, SpecialEntryList);
        dumplist(
            dwAddress,
            FIELD_OFFSET(DFS_SPECIAL_ENTRY,Link),
            dumpspecialentry);
    } else {
        PRINTF( NO_SYMBOLS_MESSAGE );
    }
    return TRUE;
}

/*
 * dumpspecialentry : Routine suitable as argument to dumplist; used to dump list of
 *      special entries
 *
 */

VOID
dumpspecialentry(
    ULONG_PTR dwAddress
)
{
    ULONG_PTR dwName;
    ULONG i;
    DFS_EXPANDED_NAME ExpName;
    DFS_SPECIAL_ENTRY specialentry;

    if (wGetData( dwAddress, &specialentry, sizeof(specialentry))) {
        PRINTF("\ndfs_special_entry @ %08lx\n", dwAddress);
        PrintStructFields( dwAddress, &specialentry, DfsSpecialEntryFields );
        dwName = (ULONG_PTR) specialentry.ExpandedNames;
        for (i = 0; i < specialentry.ExpandedCount; i++) {
            if (CheckControlC())
                return;
            wGetData(dwName, &ExpName, sizeof(DFS_EXPANDED_NAME));
            wPrintStringW("\t\tName:", &ExpName.ExpandedName, TRUE);
            dwName += sizeof(DFS_EXPANDED_NAME);
        }
    } else {
        PRINTF("\nUnable to read specialentry @ %08lx\n", dwAddress);
    }
}


/*
 * prefixhash : Routine to compute hash of path component
 *
 */

BOOL
prefixhash(
    ULONG_PTR                   dwCurrentPC,
    PWINDBG_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
    DWORD BucketNo = 0;
    LPSTR lpPath;

    //    SETCALLBACKS();

    if ((lpArgumentString == NULL) || (*lpArgumentString == 0)) {
        PRINTF("Usage: prefixhash <path-component>\n");
    } else {

        lpPath = lpArgumentString;

        while (*lpPath != 0)
        {
            WCHAR wc;

            wc = (*lpPath < 'a')
                           ? (WCHAR) *lpPath
                           : ((*lpPath < 'z')
                              ? (WCHAR) (*lpPath - 'a' + 'A')
                              : (WCHAR) *lpPath);
            BucketNo *= 131;
            BucketNo += wc;

            lpPath++;

        }

        BucketNo = BucketNo % NO_OF_HASH_BUCKETS;

        PRINTF("Hash for <%s> is %d\n", lpArgumentString, BucketNo);

    }

    return( TRUE );
}

/*
 * fcbtable : Routine to dump the dfs fcb hash table
 *
 */

BOOL
fcbtable(
    ULONG_PTR                   dwCurrentPC,
    PWINDBG_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
    ULONG_PTR dwAddress;

    //    SETCALLBACKS();

    //
    // Figure out the address of the Pkt. This is an offset withing
    // Mup!DfsData.
    //

    dwAddress = (GetExpression)("Mup!DfsData");

    if (dwAddress) {
        DFS_DATA DfsData;

        if (wGetData(dwAddress, &DfsData, sizeof(DFS_DATA))) {
            FCB_HASH_TABLE FcbTable;
            dwAddress = (ULONG_PTR) DfsData.FcbHashTable;
            if (wGetData(dwAddress, &FcbTable, sizeof(FCB_HASH_TABLE))) {
                ULONG i, cBuckets;
                ULONG_PTR dwListHeadAddress;
                cBuckets = FcbTable.HashMask + 1;
                dwListHeadAddress =
                    dwAddress + FIELD_OFFSET(FCB_HASH_TABLE, HashBuckets);
                PRINTF(
                    "+++ Fcb Hash Table @ %08lx (%d Buckets) +++\n",
                    dwAddress, cBuckets);
                for (i = 0; i < cBuckets; i++) {
                    if (CheckControlC())
                        return TRUE;
                    PRINTF( "--- Bucket(%d)\n", i );
                    dumplist(
                        dwListHeadAddress,
                        FIELD_OFFSET(DFS_FCB, HashChain),
                        dumpFcb);
                    dwListHeadAddress += sizeof(LIST_ENTRY);
                }
                PRINTF("--- Fcb Hash Table @ %08lx ---\n", dwAddress);

            } else {
                PRINTF( "Unable to read FcbTable @%08lx\n", dwAddress );
            }
        } else {
            PRINTF( "Unable to read DfsData @%08lx\n", dwAddress);
        }
    } else {
        PRINTF( NO_SYMBOLS_MESSAGE );
    }
    return( TRUE );
}

/*
 * dumpFcb : Routine suitable as argument to dumplist; used to dump list of
 *      Fcbs
 *
 */

VOID
dumpFcb(
    ULONG_PTR dwAddress
)
{
    DFS_FCB fcb;

    if (wGetData( dwAddress, &fcb, sizeof(fcb))) {
        PRINTF("\nFcb @ %08lx\n", dwAddress);
        PrintStructFields( dwAddress, &fcb, FcbFields );
    } else {
        PRINTF("\nUnable to read Fcb @ %08lx\n", dwAddress);
    }
}

/*
 * vcblist : Routine to dump out all the Dfs VCBs (ie, all the Dfs Device
 *      object descriptors).
 *
 */

BOOL
vcblist(
    ULONG_PTR                   dwCurrentPC,
    PWINDBG_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
    ULONG_PTR dwAddress;

    //    SETCALLBACKS();

    //
    // Figure out the address of the Pkt. This is an offset withing
    // Mup!DfsData.
    //

    dwAddress = (GetExpression)("Mup!DfsData");

    if (dwAddress) {
        dwAddress += FIELD_OFFSET(DFS_DATA, VcbQueue);
        dumplist(
            dwAddress,
            FIELD_OFFSET(DFS_VCB,VcbLinks),
            dumpVcb);
    } else {
        PRINTF( NO_SYMBOLS_MESSAGE );
    }
    return( TRUE );
}


/*
 * prefixlist : Routine to dump out all the mup prefixes
 *
 */

BOOL
prefixlist(
    ULONG_PTR                   dwCurrentPC,
    PWINDBG_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
    ULONG_PTR dwAddress;

    //    SETCALLBACKS();

    //
    // Figure out the address of the Pkt. This is an offset withing
    // Mup!DfsData.
    //

    dwAddress = (GetExpression)("Mup!MupPrefixList");

    if (dwAddress) {
        dumplist(
            dwAddress,
            FIELD_OFFSET(KNOWN_PREFIX,ListEntry),
            dumpPrefix);
    } else {
        PRINTF( NO_SYMBOLS_MESSAGE );
    }
    return( TRUE );
}

/*
 * dumpDeviceObject
 */

void
dumpDeviceObject(
    ULONG_PTR dwAddress)
{
    ULONG_PTR dwTempAddress;
    OBJECT_HEADER obhd;
    OBJECT_HEADER_NAME_INFO obni;

    dwTempAddress = dwAddress - FIELD_OFFSET(OBJECT_HEADER, Body);

    if (wGetData(dwTempAddress, &obhd, sizeof(obhd))) {
        if (obhd.NameInfoOffset != 0) {
            dwTempAddress -= obhd.NameInfoOffset;
            if (wGetData(dwTempAddress, &obni, sizeof(obni))) {
                wPrintStringW(
                    "    Device Name:                   ",
                    &obni.Name,
                    TRUE);
            } else {
                PRINTF("Unable to read Name Info @%08lx\n", dwTempAddress);
            }
        } else {
            PRINTF("\tDevice Name: NULL\n");
        }
    } else {
        PRINTF("Unable to read Object Header @%08lx\n", dwTempAddress);
    }
}

void
dumpVcb(
    ULONG_PTR dwAddress)
{
    ULONG_PTR dwLogicalRootAddress;
    DFS_VCB vcb;

    dwLogicalRootAddress =
        dwAddress - FIELD_OFFSET(LOGICAL_ROOT_DEVICE_OBJECT, Vcb);

    if (wGetData(dwAddress, &vcb, sizeof(vcb))) {
        PRINTF("+++ Vcb @%08lx : Logical Root Device Object @%08lx +++\n",
            dwAddress, dwLogicalRootAddress);
        PrintStructFields(dwAddress, &vcb, VcbFields);
        dumpDeviceObject( dwLogicalRootAddress );
        PRINTF("--- Vcb @%08lx : Logical Root Device Object @%08lx ---\n",
            dwAddress, dwLogicalRootAddress);
    } else {
        PRINTF("Unable to read Vcb @%08lx\n",dwAddress);
    }
}

void
dumpPrefix(
    ULONG_PTR dwAddress)
{
    KNOWN_PREFIX knownprefix;

    if (wGetData(dwAddress, &knownprefix, sizeof(knownprefix))) {
        PRINTF("+++ KnownPrefix @%08lx +++\n", dwAddress);
        PrintStructFields(dwAddress, &knownprefix, KnownPrefixFields);
        PRINTF("+++ KnownPrefix @%08lx +++\n", dwAddress);
    } else {
        PRINTF("Unable to read knownprefix @%08lx\n",dwAddress);
    }
}

/*
 * credList - dump global list of user credentials
 *
 */

BOOL
credlist(
    ULONG_PTR                   dwCurrentPC,
    PWINDBG_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
    ULONG_PTR dwAddress;

    //    SETCALLBACKS();

    //
    // Figure out the address of the Pkt. This is an offset withing
    // Mup!DfsData.
    //

    dwAddress = (GetExpression)("Mup!DfsData");

    if (dwAddress) {
        dwAddress += FIELD_OFFSET(DFS_DATA, Credentials);
        dumplist(
            dwAddress,
            FIELD_OFFSET(DFS_CREDENTIALS,Link),
            dumpCredentials);
    } else {
        PRINTF( NO_SYMBOLS_MESSAGE );
    }
    return( TRUE );
}

/*
 * dumpCredentials : Routine suitable as argument to dumplist; used to dump
 *      a list of DFS_CREDENTIALs.
 */

void
dumpCredentials(
    ULONG_PTR dwAddress)
{
    DFS_CREDENTIALS creds;

    if (wGetData(dwAddress, &creds, sizeof(creds))) {
        PRINTF("+++ Credentials @%08lx +++\n", dwAddress);
        PrintStructFields(dwAddress, &creds, CredentialsFields);
        PRINTF("--- Credentials @%08lx ---\n", dwAddress);
    } else {
        PRINTF("Unable to read Credentials @%08lx\n",dwAddress);
    }
}

/*
 * dumplist : A general-purpose routine to dump a list of structures
 *
 */

VOID
dumplist(
    ULONG_PTR dwListEntryAddress,
    DWORD linkOffset,
    VOID (*dumpRoutine)(ULONG_PTR dwStructAddress)
)
{
    LIST_ENTRY listHead, listNext;

    //
    // Get the value in the LIST_ENTRY at dwAddress
    //

    PRINTF( "Dumping list @ %08lx\n", dwListEntryAddress );

    if (wGetData(dwListEntryAddress, &listHead, sizeof(LIST_ENTRY))) {

        ULONG_PTR dwNextLink = (ULONG_PTR) listHead.Flink;

        if (dwNextLink == 0) {
            PRINTF( "Uninitialized list!\n" );
        } else if (dwNextLink == dwListEntryAddress) {
            PRINTF( "Empty list!\n" );
        } else {
            while( dwNextLink != dwListEntryAddress) {
                ULONG_PTR dwStructAddress;

                if (CheckControlC())
                    return;
                dwStructAddress = dwNextLink - linkOffset;

                dumpRoutine(dwStructAddress);

                if (wGetData( dwNextLink, &listNext, sizeof(LIST_ENTRY))) {
                    dwNextLink = (ULONG_PTR) listNext.Flink;
                } else {
                    PRINTF( "Unable to get next item @%08lx\n", dwNextLink );
                    break;
                }

            }
        }

    } else {

        PRINTF("Unable to read list head @ %08lx\n", dwListEntryAddress);

    }

}

/*
 * drtlist : Routine to dump out all the Dfs Devless Roots
 *
 */

BOOL
drtlist(
    ULONG_PTR                   dwCurrentPC,
    PWINDBG_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
    ULONG_PTR dwAddress;

    //    SETCALLBACKS();

    //
    // Figure out the address of the Pkt. This is an offset withing
    // Mup!DfsData.
    //

    dwAddress = (GetExpression)("Mup!DfsData");

    if (dwAddress) {
        dwAddress += FIELD_OFFSET(DFS_DATA, DrtQueue);
        dumplist(
            dwAddress,
            FIELD_OFFSET(DFS_DEVLESS_ROOT,DrtLinks),
            dumpDrt);
    } else {
        PRINTF( NO_SYMBOLS_MESSAGE );
    }
    return( TRUE );
}


void
dumpDrt(
    ULONG_PTR dwAddress)
{
    DFS_DEVLESS_ROOT drt;

    if (wGetData(dwAddress, &drt, sizeof(drt))) {
        PRINTF("+++ Drt @%08lx :                        +++\n",
	       dwAddress);
        PrintStructFields(dwAddress, &drt, DrtFields);
        PRINTF("--- Drt @%08lx :                        ---\n",
	       dwAddress);
    } else {
        PRINTF("Unable to read Drt @%08lx\n",dwAddress);
    }
}

BOOL
offlinelist(
    ULONG_PTR                   dwCurrentPC,
    PWINDBG_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
    ULONG_PTR dwAddress;

    //    SETCALLBACKS();

    //
    // Figure out the address of the Pkt. This is an offset withing
    // Mup!DfsData.
    //

    dwAddress = (GetExpression)("Mup!DfsData");

    if (dwAddress) {
        dwAddress += FIELD_OFFSET(DFS_DATA, OfflineRoots);
        dumplist(
            dwAddress,
            FIELD_OFFSET(DFS_OFFLINE_SERVER,ListEntry),
            dumpOfflineRoots);
    } else {
        PRINTF( NO_SYMBOLS_MESSAGE );
    }
    return( TRUE );
}

VOID
dumpOfflineRoots(
    ULONG_PTR dwAddress)
{
    DFS_OFFLINE_SERVER srv;

    if (wGetData(dwAddress, &srv, sizeof(srv))) {
        PRINTF("+++ OfflineRoot @%08lx :                        +++\n",
	       dwAddress);
        PrintStructFields(dwAddress, &srv, OfflineRootFields);
        PRINTF("--- Drt @%08lx :                        ---\n",
	       dwAddress);
    } else {
        PRINTF("Unable to read Srv @%08lx\n",dwAddress);
    }
}
     

VOID
PrintStructFields( ULONG_PTR dwAddress, VOID *ptr, FIELD_DESCRIPTOR *pFieldDescriptors )
{
    int i;
    WCHAR wszBuffer[80];

    // Display the fields in the struct.
    for( i=0; pFieldDescriptors->Name; i++, pFieldDescriptors++ ) {

        // Indentation to begin the struct display.
        PRINTF( "    " );

        if( strlen( pFieldDescriptors->Name ) > FIELD_NAME_LENGTH ) {
            PRINTF( "%-17s...%s ", pFieldDescriptors->Name, pFieldDescriptors->Name+strlen(pFieldDescriptors->Name)-10 );
        } else {
            PRINTF( "%-30s ", pFieldDescriptors->Name );
        }

        switch( pFieldDescriptors->FieldType ) {
        case FieldTypeByte:
        case FieldTypeChar:
           PRINTF( "%-16d%s",
               *(BYTE *)(((char *)ptr) + pFieldDescriptors->Offset ),
               NewLineForFields(i) );
           break;
        case FieldTypeBoolean:
           PRINTF( "%-16s%s",
               *(BOOLEAN *)(((char *)ptr) + pFieldDescriptors->Offset ) ? "TRUE" : "FALSE",
               NewLineForFields(i));
           break;
        case FieldTypeBool:
            PRINTF( "%-16s%s",
                *(BOOLEAN *)(((char *)ptr) + pFieldDescriptors->Offset ) ? "TRUE" : "FALSE",
                NewLineForFields(i));
            break;
        case FieldTypePointer:
            PRINTF( "%-16X%s",
                *(ULONG *)(((char *)ptr) + pFieldDescriptors->Offset ),
                NewLineForFields(i) );
            break;
        case FieldTypeULong:
        case FieldTypeLong:
            PRINTF( "%-16d%s",
                *(ULONG *)(((char *)ptr) + pFieldDescriptors->Offset ),
                NewLineForFields(i) );
            break;
        case FieldTypeShort:
            PRINTF( "%-16X%s",
                *(SHORT *)(((char *)ptr) + pFieldDescriptors->Offset ),
                NewLineForFields(i) );
            break;
        case FieldTypeUShort:
            PRINTF( "%-16X%s",
                *(USHORT *)(((char *)ptr) + pFieldDescriptors->Offset ),
                NewLineForFields(i) );
            break;
        case FieldTypeGuid:
            PrintGuid( (GUID *)(((char *)ptr) + pFieldDescriptors->Offset) );
            PRINTF( NewLine );
            break;
        case FieldTypePWStr:
            if (wGetString( (ULONG_PTR)(((char *)ptr) + pFieldDescriptors->Offset), (char *)wszBuffer )) {
                PRINTF( "%ws", wszBuffer );
            } else {
                PRINTF( "Unable to get string at %08lx", (ULONG_PTR)(((char *)ptr) + pFieldDescriptors->Offset));
            }
            PRINTF( NewLine );
            break;
        case FieldTypeUnicodeString:
            wPrintStringW( NULL, (UNICODE_STRING *)(((char *)ptr) + pFieldDescriptors->Offset ), 0 );
            PRINTF( NewLine );
            break;
        case FieldTypeAnsiString:
            wPrintStringA( NULL, (ANSI_STRING *)(((char *)ptr) + pFieldDescriptors->Offset ), 0 );
            PRINTF( NewLine );
            break;
        case FieldTypeSymbol:
            {
                UCHAR SymbolName[ 200 ];
                ULONG Displacement;
                PVOID sym = (PVOID)(*(ULONG *)(((char *)ptr) + pFieldDescriptors->Offset ));

                GetSymbol(sym, SymbolName, (ULONG_PTR *)&Displacement );
                PRINTF( "%-16s%s",
                        SymbolName,
                        NewLineForFields(i) );
            }
            break;
        case FieldTypeEnum:
            {
               ULONG EnumValue;
               ENUM_VALUE_DESCRIPTOR *pEnumValueDescr;
               // Get the associated numerical value.

               EnumValue = *((ULONG *)((BYTE *)ptr + pFieldDescriptors->Offset));

               if ((pEnumValueDescr = pFieldDescriptors->AuxillaryInfo.pEnumValueDescriptor)
                    != NULL) {
                   //
                   // An auxilary textual description of the value is
                   // available. Display it instead of the numerical value.
                   //

                   LPSTR pEnumName = NULL;

                   while (pEnumValueDescr->EnumName != NULL) {
                       if (EnumValue == pEnumValueDescr->EnumValue) {
                           pEnumName = pEnumValueDescr->EnumName;
                           break;
                       }
                       pEnumValueDescr++;
                   }

                   if (pEnumName != NULL) {
                       PRINTF( "%-16s ", pEnumName );
                   } else {
                       PRINTF( "%-4d (%-10s) ", EnumValue,"Unknown!");
                   }

               } else {
                   //
                   // No auxilary information is associated with the ehumerated type
                   // print the numerical value.
                   //
                   PRINTF( "%-16d",EnumValue);
               }
               PRINTF( NewLineForFields(i) );
            }
            break;

        case FieldTypeByteBitMask:
        case FieldTypeWordBitMask:
        case FieldTypeDWordBitMask:
            {
               BOOL fFirstFlag;
               ULONG BitMaskValue;
               BIT_MASK_DESCRIPTOR *pBitMaskDescr;

               BitMaskValue = *((ULONG *)((BYTE *)ptr + pFieldDescriptors->Offset));

               PRINTF("%-8x ", BitMaskValue);
               PRINTF( NewLineForFields(i) );

               pBitMaskDescr = pFieldDescriptors->AuxillaryInfo.pBitMaskDescriptor;
               fFirstFlag = TRUE;
               if (BitMaskValue != 0 && pBitMaskDescr != NULL) {
                   while (pBitMaskDescr->BitmaskName != NULL) {
                       if ((BitMaskValue & pBitMaskDescr->BitmaskValue) != 0) {
                           if (fFirstFlag) {
                               fFirstFlag = FALSE;
                               PRINTF("      ( %-s", pBitMaskDescr->BitmaskName);
                           } else {
                               PRINTF( " |\n" );
                               PRINTF("        %-s", pBitMaskDescr->BitmaskName);

                           }
                       }
                       pBitMaskDescr++;
                   }
                   PRINTF(" )");
                   PRINTF( NewLineForFields(i) );
               }
            }
            break;

        case FieldTypeStruct:
            PRINTF( "@%-15X%s",
                (dwAddress + pFieldDescriptors->Offset ),
                NewLineForFields(i) );
            break;
        case FieldTypeLargeInteger:
            wPrintLargeInt( (LARGE_INTEGER *)(((char *)ptr) + pFieldDescriptors->Offset) );
            PRINTF( NewLine );
            break;
        case FieldTypeFileTime:
        default:
            dprintf( "Unrecognized field type %c for %s\n", pFieldDescriptors->FieldType, pFieldDescriptors->Name );
            break;
        }
    }
}


#define NAME_DELIMITER '@'
#define INVALID_INDEX 0xffffffff
#define MIN(x,y)  ((x) < (y) ? (x) : (y))

ULONG SearchStructs(LPSTR lpArgument)
{
    ULONG             i = 0;
    STRUCT_DESCRIPTOR *pStructs = Structs;
    ULONG             NameIndex = INVALID_INDEX;
    ULONG               ArgumentLength = strlen(lpArgument);
    BOOLEAN           fAmbiguous = FALSE;


    while ((pStructs->StructName != 0)) {
        ULONG StructLength;
        StructLength = strlen(pStructs->StructName);
        if (StructLength >= ArgumentLength) {
            int Result = _strnicmp(
                            lpArgument,
                            pStructs->StructName,
                            ArgumentLength);

            if (Result == 0) {
                if (StructLength == ArgumentLength) {
                    // Exact match. They must mean this struct!
                    fAmbiguous = FALSE;
                    NameIndex = i;
                    break;
                } else if (NameIndex != INVALID_INDEX) {
                    // We have encountered duplicate matches. Print out the
                    // matching strings and let the user disambiguate.
                   fAmbiguous = TRUE;
                   break;
                } else {
                   NameIndex = i;
                }
            }
        }
        pStructs++;i++;
    }

    if (fAmbiguous) {
       PRINTF("Ambigous Name Specification -- The following structs match\n");
       PRINTF("%s\n",Structs[NameIndex].StructName);
       PRINTF("%s\n",Structs[i].StructName);
       while (pStructs->StructName != 0) {
           if (_strnicmp(lpArgument,
                        pStructs->StructName,
                        MIN(strlen(pStructs->StructName),ArgumentLength)) == 0) {
               PRINTF("%s\n",pStructs->StructName);
           }
           pStructs++;
       }
       PRINTF("Dumping Information for %s\n",Structs[NameIndex].StructName);
    }

    return(NameIndex);
}

VOID DisplayStructs()
{
    STRUCT_DESCRIPTOR *pStructs = Structs;

    PRINTF("The following structs are handled .... \n");
    while (pStructs->StructName != 0) {
        PRINTF("\t%s\n",pStructs->StructName);
        pStructs++;
    }
}


#define NAME_DELIMITERS "@"

DECLARE_API( dump )
{
    ULONG_PTR dwAddress;

    //SETCALLBACKS();

    if( args && *args ) {
        // Parse the argument string to determine the structure to be displayed.
        // Scan for the NAME_DELIMITER ( '@' ).

        LPSTR lpName = (PSTR)args;
        LPSTR lpArgs = strpbrk(args, NAME_DELIMITERS);
        ULONG Index;

        if (lpArgs) {
            //
            // The specified command is of the form
            // dump <name>@<address expr.>
            //
            // Locate the matching struct for the given name. In the case
            // of ambiguity we seek user intervention for disambiguation.
            //
            // We do an inplace modification of the argument string to
            // facilitate matching.
            //
            *lpArgs = '\0';

            for (;*lpName==' ';) { lpName++; } //skip leading blanks

            Index = SearchStructs(lpName);

            //
            // Let us restore the original value back.
            //

            *lpArgs = NAME_DELIMITER;

            if (INVALID_INDEX != Index) {
                BYTE DataBuffer[512];

                dwAddress = GetExpression( ++lpArgs );
                if (wGetData(dwAddress,DataBuffer,Structs[Index].StructSize)) {

                    PRINTF(
                        "++++++++++++++++ %s@%lx ++++++++++++++++\n",
                        Structs[Index].StructName,
                        dwAddress);
                    PrintStructFields(
                        dwAddress,
                        &DataBuffer,
                        Structs[Index].FieldDescriptors);
                    PRINTF(
                        "---------------- %s@%lx ----------------\n",
                        Structs[Index].StructName,
                        dwAddress);
                } else {
                    PRINTF("Error reading Memory @ %lx\n",dwAddress);
                }
            } else {
                // No matching struct was found. Display the list of
                // structs currently handled.

                DisplayStructs();
            }
        } else {
            //
            // The command is of the form
            // dump <name>
            //
            // Currently we do not handle this. In future we will map it to
            // the name of a global variable and display it if required.
            //

            DisplayStructs();
        }
    } else {
        //
        // display the list of structs currently handled.
        //

        DisplayStructs();
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\wml\inc\wmlkm.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    wmlkm.h

Abstract:

    Kernel mode definitions for an easy wmi tracing.

Author:

    gorn

Revision History:

Comments:

    Needs to be moved to wmilib\inc when DCR is approved

--*/
#ifndef WMLKM_H
#define WMLKM_H 1

#pragma warning(disable: 4201) // error C4201: nonstandard extension used : nameless struct/union
#include <wmistr.h>
#include <evntrace.h>

#include "wmlmacro.h"
#ifdef __cplusplus
extern "C" {
#endif

#define MAX_TRACE_GUIDS_PER_CONTROL  3

typedef struct _WML_CONTROL_GUID_REG {
    GUID        Guid;
    GUID        TraceGuids[MAX_TRACE_GUIDS_PER_CONTROL];
    ULONG       EnableFlags;
    ULONG       EnableLevel;
    TRACEHANDLE LoggerHandle;
} WML_CONTROL_GUID_REG, *PWML_CONTROL_GUID_REG;

typedef struct _WML_TINY_INFO {
    PWML_CONTROL_GUID_REG    ControlGuids;
    ULONG                    GuidCount;
    PDEVICE_OBJECT           LowerDeviceObject;
    PUNICODE_STRING          DriverRegPath;
} WML_TINY_INFO, *PWML_TINY_INFO;


NTSTATUS
WmlTinySystemControl(
    IN OUT PWML_TINY_INFO WmiLibInfo,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

ULONG
WmlTrace(
    IN ULONG Type,
    IN LPCGUID TraceGuid,
    IN TRACEHANDLE LoggerHandle,
    ... // Pairs: Address, Length
    );

ULONG
WmlPrintf(
    IN ULONG Type,
    IN LPCGUID TraceGuid,
    IN TRACEHANDLE LoggerHandle,
    IN PCHAR FormatString,
    ... // var args
    );



#ifdef __cplusplus
};
#endif

#endif // WMLKM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\wml\inc\wmlmacro.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    wmlmacro.h

Abstract:

    This file defines macro for an easy wmi tracing.

Author:

    gorn

Revision History:

--*/
#ifndef WMLMACRO_H
#define WMLMACRO_H 1

typedef struct {char x[418957];} WMILIBTYPE_STRING;

#undef  WMILIB_TYPEDEF
#define WMILIB_TYPEDEF(_TypeName, _EquivType, _FmtStr, _Func, _MofStr, _InitType) \
    typedef _EquivType WMILIBTYPE_ ## _TypeName ;
#include "wmltypes.inc"

typedef union _WMLLOCALSTRUCT {
    UCHAR    uchar;
    USHORT   ushort;
    ULONG    uint;
    WCHAR    wchar;
    LONGLONG longlong;
} WMLLOCALSTRUCT;

#define WMLLOCAL WMLLOCALSTRUCT _wmllocal

#define WMILIB_CHECKED_ZERO(_Value, _Type) \
    (0 * (1/(int)!(sizeof(_Type) - sizeof(_Value) )))

#define WMILIB_CHECKED_SIZEOF(_Value, _Type) \
    (sizeof(_Value) + WMILIB_CHECKED_ZERO( _Value, _Type) )

#define WMILIB_LOGPAIR(_a, _b) (_a),(_b),

#define WMILIB_LOGARGVALTYPE(_value, _type) \
            WMILIB_LOGPAIR(WMILIB_CHECKED_SIZEOF(_value, _type), &(_value) )

#define LOG(_TypeName, _Value)                         \
    WMILIB_LOGARGVALTYPE( _Value, WMILIBTYPE_ ## _TypeName)

#define ANULL "$NULL$"
#define WNULL L"$NULL$"

#define LOGASTR(_value) \
    WMILIB_LOGPAIR( strlen(_value) + WMILIB_CHECKED_ZERO((_value)[0],CHAR), _value )

#define LOGASTR_CHK(_value) \
    WMILIB_LOGPAIR( strlen(_value?_value:ANULL) + WMILIB_CHECKED_ZERO((_value?_value:ANULL)[0],CHAR), _value?_value:ANULL )

#define LOGWSTR(_value) \
    WMILIB_LOGPAIR( (wcslen(_value?_value:WNULL)+1) * sizeof(WCHAR) + WMILIB_CHECKED_ZERO((_value?_value:WNULL)[0],WCHAR), _value?_value:WNULL)

#define LOGWSTR_CHK(_value) \
    WMILIB_LOGPAIR( (wcslen(_value?_value:WNULL)+1) * sizeof(WCHAR) + WMILIB_CHECKED_ZERO((_value?_value:WNULL)[0],WCHAR), _value?_value:WNULL)

#define LOGCSTR(_x) \
    WMILIB_LOGPAIR( sizeof((_x).Length) + WMILIB_CHECKED_ZERO(_x,STRING), &(_x).Length ) \
    WMILIB_LOGPAIR( (_x).Length, (_x).Buffer )

#define LOGUSTR(_x)                                                            \
    WMILIB_LOGPAIR( sizeof((_x).Length)                                        \
                    + WMILIB_CHECKED_ZERO((_x),UNICODE_STRING), &(_x).Length)  \
    WMILIB_LOGPAIR( (_x).Length, (_x).Buffer )

#define LOGCHARARR(_count, _x)                                 \
    WMILIB_LOGARGVALTYPE( _wmllocal.ushort , USHORT )          \
    WMILIB_LOGPAIR( (_wmllocal.ushort = _count * sizeof(CHAR)) \
                    + WMILIB_CHECKED_ZERO((_x)[0], CHAR), _x ) 

#define LOGWCHARARR(_count, _x)                                 \
    WMILIB_LOGARGVALTYPE( _wmllocal.ushort , USHORT )           \
    WMILIB_LOGPAIR( (_wmllocal.ushort = _count * sizeof(WCHAR)) \
                    + WMILIB_CHECKED_ZERO((_x)[0], WCHAR), _x ) 

#define LOGTIME(_Value)    LOG(TIMENT,  _Value)
#define LOGPTR(_Value)     LOG(PTR,     _Value)
#define LOGHANDLE(_Value)  LOG(HANDLE,  _Value)
#define LOGSTATUS(_Value)  LOG(XINT,    _Value)
#define LOGBYTE(_Value)    LOG(UBYTE,   _Value)
#define LOGULONG(_Value)   LOG(UINT,    _Value)
#define LOGULONGLONG(_Value)   LOG(ULONGLONG,    _Value)
#define LOGXLONG(_Value)   LOG(XINT,    _Value)
#define LOGXSHORT(_Value)  LOG(XSHORT,  _Value)
#define LOGUCHAR(_Value)   LOG(UCHAR,   _Value)
#define LOGIRQL(_Value)    LOG(UCHAR,   _Value)
#define LOGBOOL(_Value)    LOG(BOOL,    _Value)
#define LOGBOOLEAN(_Value) LOG(BOOLEAN, _Value)
#define LOGARSTR(_Value)   LOGASTR(_Value)
#define LOGPNPMN(_Value)   LOG(UCHAR,   _Value)
#define LOGIOCTL(_Value)   LOG(ULONG,   _Value)
#define LOGGUID(_Val)      LOG(GUID, _Val)

#define LOGVAL(_val)        (sizeof(_val)), (&(_val)),

#define WML_FLAGS(_Val)  ( (ULONG)(_Val) )
#define WML_STREAM(_Val) ( (ULONG)(_Val) )

#define WML_CONTROL(_prefix, _stream) \
            ( _prefix ## _ControlGuids[ WML_STREAM(_stream) ] )
            
#define WML_ENABLED(_prefix, _stream, _level, _flags) \
            (( WML_CONTROL(_prefix, _stream).EnableLevel >= (_level) ) &&   \
             ( WML_CONTROL(_prefix, _stream).EnableFlags & WML_FLAGS(_flags) ))
            
#define WML_TRACEGUID(_prefix, _stream, _id) \
            ( WML_CONTROL(_prefix, _stream).TraceGuids[ WML_GUID(_id) ] )
            
#define WML_LOG(_prefix, _stream, _level, _flags, _id, _arg) \
    do { \
        if ( WML_ENABLED(_prefix, _stream, _level, _flags) ) { \
            WmlTrace( WML_ID(_id), \
                     &WML_TRACEGUID(_prefix, _stream, _id) , \
                      WML_CONTROL(_prefix, _stream).LoggerHandle, _arg); \
        } \
    } while (0)            

#define WML_PRINTF(_prefix, _stream, _level, _flags, _id, _fmtstr, _arg) \
    do { \
        if ( WML_ENABLED(_prefix, _stream, _level, _flags) ) { \
            WmlPrintf( WML_ID(_id), \
                      &WML_TRACEGUID(_prefix, _stream, _id) , \
                      WML_CONTROL(_prefix, _stream).LoggerHandle, \
                      _fmtstr, _arg); \
        } \
    } while (0)            


#endif // WMLMACRO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\kdext\wdbgxlib.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    wdbgxlib.c

Abstract:

    This module realizes most of the routines needed for the rdbss/smbmini debugger extension.

Author:

    Balan Sethu Raman (SethuR) 11-May-1994

Notes:

Revision History:

    11-Nov-1994 SethuR  Created
    11-Nov-1995         Changed to newer windbg apis

--*/


#include <ntos.h>
#include <nturtl.h>
#include "ntverp.h"

#include <windows.h>
#include <wdbgexts.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include <kdextlib.h>




WINDBG_EXTENSION_APIS ExtensionApis;
EXT_API_VERSION ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };

#define    ERRPRT     dprintf

#define    NL      1
#define    NONL    0

USHORT SavedMajorVersion;
USHORT SavedMinorVersion;
BOOL   ChkTarget;            // is debuggee a CHK build?


/*
 * Print out an optional message, an ANSI_STRING, and maybe a new-line
 */
BOOL
wPrintStringA( IN LPSTR msg OPTIONAL, IN PANSI_STRING pStr, IN BOOL nl )
{
    PCHAR    StringData;
    ULONG    BytesRead;

    if( msg )
        dprintf( msg );

    if( pStr->Length == 0 ) {
        if( nl )
            dprintf( "\n" );
        return TRUE;
    }

    StringData = (PCHAR)LocalAlloc( LPTR, pStr->Length + 1 );

    if( StringData == NULL ) {
        ERRPRT( "Out of memory!\n" );
        return FALSE;
    }

    ReadMemory( (ULONG_PTR)pStr->Buffer,
               StringData,
               pStr->Length,
               &BytesRead );

    if ( BytesRead ) {
        StringData[ pStr->Length ] = '\0';
        dprintf("%s%s", StringData, nl ? "\n" : "" );
    }

    LocalFree((HLOCAL)StringData);

    return BytesRead;
}

BOOL
wPrintStringW( IN LPSTR msg OPTIONAL, IN PUNICODE_STRING pStr, IN BOOL nl )
{
    UNICODE_STRING NewStr;

    ULONG    BytesRead;

    if( msg )
        dprintf( msg );

    if( pStr->Length == 0 ) {
        if( nl )
            dprintf( "\n" );
        return TRUE;
    }

    NewStr.Buffer = (WCHAR *)LocalAlloc( LPTR, pStr->Length + 1 );
    NewStr.Length = pStr->Length;
    NewStr.MaximumLength = pStr->Length+1;
    if( NewStr.Buffer == NULL ) {
        ERRPRT( "Out of memory!\n" );
        return FALSE;
    }

    ReadMemory( (ULONG_PTR)pStr->Buffer,
               NewStr.Buffer,
               pStr->Length,
               &BytesRead );

    if ( BytesRead ) {
        dprintf("%wZ%s", &NewStr, nl ? "\n" : "" );
    }

    LocalFree((HLOCAL)NewStr.Buffer);

    return BytesRead;
}



/*
 * Fetches the data at the given address
 */
BOOLEAN
wGetData( ULONG_PTR dwAddress, PVOID ptr, ULONG size)
{
    BOOL b;
    ULONG BytesRead;

    b = ReadMemory( dwAddress, ptr, size, &BytesRead );


    if (!b || BytesRead != size ) {
        dprintf( "Unable to read %u bytes at %X, for %s\n", size, dwAddress);
        return FALSE;
    }

    return TRUE;
}

/*
 * Fetch the null terminated ASCII string at dwAddress into buf
 */
BOOL
wGetString( ULONG_PTR dwAddress, PSZ buf )
{
    for(;;) {
        if( !wGetData( dwAddress,buf, 1) ){
            //dprintf("readfailure at %08lx\n",dwAddress);
            return FALSE;
        }

        //dprintf ("stringing %08lx %08lx %c\n", dwAddress, buf,
        //                                     ((*buf==0)?'.':*buf) );

        if ( *buf == '\0' ) { break; }

        dwAddress++;
        buf++;

    };

    return TRUE;
}

#if 0
/*
 * Get 'size' bytes from the debuggee program at 'dwAddress' and place it
 * in our address space at 'ptr'.  Use 'type' in an error printout if necessary
 */
BOOL
wGetData_srv( IN LPVOID ptr, IN ULONG_PTR dwAddress, IN ULONG size, IN PCSTR type )
{
    BOOL b;
    ULONG BytesRead;
    ULONG count;

    while( size > 0 ) {

        count = min( size, 3000 );

        b = ReadMemory((ULONG) dwAddress, ptr, count, &BytesRead );

        if (!b || BytesRead != count ) {
            ERRPRT( "Unable to read %u bytes at %X, for %s\n", size, dwAddress, type );
            return FALSE;
        }

        dwAddress += count;
        size -= count;
        ptr = (LPVOID)((ULONG)ptr + count);
    }

    return TRUE;
}

/*
 * Follow a LIST_ENTRY list beginning with a head at dwListHeadAddr in the debugee's
 * address space.  For each element in the list, print out the pointer value at 'offset'
 */
BOOL
PrintListEntryList( IN ULONG_PTR dwListHeadAddr, IN LONG offset )
{
    LIST_ENTRY    ListEntry;
    ULONG i=0;
    BOOL retval = TRUE;
    ULONG count = 20;

    if( !wGetData_srv( &ListEntry, dwListHeadAddr, sizeof( ListEntry ), "LIST_ENTRY" ) )
        return FALSE;

    while( count-- ) {

        if( (ULONG_PTR)ListEntry.Flink == dwListHeadAddr || (ULONG_PTR)ListEntry.Flink == 0 )
            break;

        if( !wGetData_srv( &ListEntry, (ULONG_PTR)ListEntry.Flink, sizeof( ListEntry ), "ListEntry" ) ) {
            retval = FALSE;
            break;
        }

        dprintf( "%16X%s", (LONG)ListEntry.Flink + offset, (i && !(i&3)) ? "\n" : "" );
        i++;
    }


    if( count == 0 && (ULONG_PTR)ListEntry.Flink != dwListHeadAddr && ListEntry.Flink ) {
        dprintf( "\nTruncated list dump\n" );

    } else if( ! ( i && !(i&3) ) ) {
        dprintf( "\n" );
    }

    return retval;
}
#endif

/*
 * Print out a single HEX character
 */
VOID
wPrintHexChar( IN UCHAR c )
{
    dprintf( "%c%c", "0123456789abcdef"[ (c>>4)&0xf ], "0123456789abcdef"[ c&0xf ] );
}

/*
 * Print out 'buf' of 'cbuf' bytes as HEX characters
 */
VOID
wPrintHexBuf( IN PUCHAR buf, IN ULONG cbuf )
{
    while( cbuf-- ) {
        wPrintHexChar( *buf++ );
        dprintf( " " );
    }
}

#if 0
/*
 * Fetch the null terminated UNICODE string at dwAddress into buf
 */
BOOL
GetString( IN ULONG_PTR dwAddress, IN LPWSTR buf, IN ULONG MaxChars )
{
    do {
        if( !wGetData_srv( buf, dwAddress, sizeof( *buf ), "UNICODE Character" ) )
            return FALSE;

        dwAddress += sizeof( *buf );

    } while( --MaxChars && *buf++ != '\0' );

    return TRUE;
}
#endif

VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
    ChkTarget = SavedMajorVersion == 0x0c ? TRUE : FALSE;
}


VOID
CheckVersion(
    VOID
    )
{
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}


ULONG FieldOffsetOfContextListEntryInRxC();
VOID  ReadRxContextFields(ULONG_PTR RxContext,PULONG_PTR pFcb,PULONG_PTR pThread, PULONG_PTR pMiniCtx2);
DECLARE_API( dump );



HANDLE DumpFile;
CHAR wwDumpFormat[] = "-%06d:  %s\n";
VOID DumpRoutine(
    ULONG EntryNumber,
    PSZ   OriginalStringToPrint
    )
{
    UCHAR Buffer[200];
    UCHAR StringToPrint[160];
    PUCHAR p,q,r; LONG i;
    ULONG n,l3,l2,l1,l0; UCHAR Numbuf[32];
    ULONG ReturnedSize;

    //dprintf("before %d\n",EntryNumber);
    for (p=OriginalStringToPrint,q=StringToPrint,i=160;;) {
        PSZ format=NULL;

        if (*p==0) break;

        if (*p==0x4) {
            format = "%lx";
        } else if (*p==0x5) {
            format = "%ld";
        } else if (*p < ' ') {
            p++;i--;continue;
        }

        if (format!=NULL) {
            LONG Length;
            //translate the number
            p++;
            l0=*p++;
            l1=(*p++)<<8;
            l2=(*p++)<<16;
            l3=(*p++)<<24;
            n = l0 + l1 + l2 + l3;
            //dprintf("yaya %d %08lx %08lx %08lx %08lx %08lx\n",n,n,l0,l1,l2,l3);
            Length = sprintf(Numbuf,format,n);
            if (Length <= i) {
                for (r=Numbuf;*r;) { *q++ = *r++; }
                i -= Length;
            } else {
                i = 0;
            }
            if (i>0) continue;
        }
        if (i<=0) break;
        *q++ = *p++; i--;
    }
    *q = 0;

    //dprintf("after %d\n",EntryNumber);
    if (DumpFile == INVALID_HANDLE_VALUE) {
        dprintf(wwDumpFormat,EntryNumber,StringToPrint);
        return;
    }
    sprintf(Buffer,wwDumpFormat,EntryNumber,StringToPrint);
    WriteFile(DumpFile,Buffer,strlen(Buffer),&ReturnedSize,NULL);
    //should i check??
    return;
}




PCWSTR   ExtensionLib   = NULL;
HANDLE   hExtensionMod  = NULL;
ULONG    DebugeeArchitecture = 0;

PCWSTR   GetExtensionLibPerDebugeeArchitecture(ULONG DebugeeArchitecture);


DECLARE_API( dump );

DECLARE_API( flags )
{
    ULONG i,mask,newline,value;

    if( args && *args ) {
        sscanf(args,"%lx",&value);
        dprintf("Flags for %08lx\n",value);
    } else {
        dprintf("error in flags: no value presented\n");
        return;
    }

    for (i=newline=0,mask=1;i<32;i++,mask<<=1) {
        if (value&mask) {
            dprintf("    %02d 0x%08lx%c",i,mask,(newline==0)?' ':'\n');
            newline ^= 1;
        }
    }
    if (newline) {
        dprintf("\n");
    }
}

VOID dprintfsprintfbuffer(BYTE *Buffer)
{
    dprintf("%s\n",Buffer);
}

BOOL
wPrintLargeInt(
    LARGE_INTEGER *bigint)
{
    dprintf( "%08x:%08x", bigint->HighPart, bigint->LowPart);
    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\wml\um\wmlum.cpp ===
#define _UNICODE
#define UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>

#pragma warning(disable: 4201) // error C4201: nonstandard extension used : nameless struct/union
#include <wmistr.h>
#include <evntrace.h>
#include <guiddef.h>

#define REG_TRACE_REGKEY            TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Tracing")

#define REG_TRACE_ENABLED           TEXT("EnableTracing")

#define REG_TRACE_LOG_FILE_NAME     TEXT("LogFileName")
#define REG_TRACE_LOG_SESSION_NAME  TEXT("LogSessionName")
#define REG_TRACE_LOG_BUFFER_SIZE   TEXT("BufferSize")
#define REG_TRACE_LOG_MIN_BUFFERS   TEXT("MinBuffers")
#define REG_TRACE_LOG_MAX_BUFFERS   TEXT("MaxBuffers")
#define REG_TRACE_LOG_MAX_FILESIZE  TEXT("MaxFileSize")
#define REG_TRACE_LOG_MAX_HISTORY   TEXT("MaxHistorySize")
#define REG_TRACE_LOG_MAX_BACKUPS   TEXT("MaxBackups")

#define REG_TRACE_ACTIVE            TEXT("Active")
#define REG_TRACE_CONTROL           TEXT("ControlFlags")
#define REG_TRACE_LEVEL             TEXT("Level")
#define REG_TRACE_GUID              TEXT("Guid")

#include "wmlum.h"

#ifndef ARRAYSIZE
#define ARRAYSIZE(x) (sizeof(x)/sizeof(*(x)))
#endif

VOID RegisterIfNecessary(LPWSTR KeyName, LPCGUID Guid);

WMILIBPRINTFUNC WmiLibPrint = 0;

#define NT_LOGGER L"NT Kernel Logger"

VOID
MyDbgPrint(
    UINT Level,
    PCHAR FormatString,
    ...
    )
/*++

 Routine Description:

     Prints a message to the debugger or console, as appropriate.

 Arguments:

     String - The initial message string to print.

     Any FormatMessage-compatible arguments to be inserted in the
     ErrorMessage before it is logged.

 Return Value:
     None.

--*/
{
    CHAR Buffer[256];
    DWORD Bytes;
    va_list ArgList;

    if (WmiLibPrint == NULL) {
        return;
    }

    va_start(ArgList, FormatString);

    Bytes = FormatMessageA(FORMAT_MESSAGE_FROM_STRING,
                           FormatString,
                           0,
                           0,
                           Buffer,
                           sizeof(Buffer) / sizeof(CHAR),
                           &ArgList);


    va_end(ArgList);
    if (Bytes != 0) {
        (*WmiLibPrint)(Level, Buffer);
    }
}

UINT HexVal(int ch) { return isdigit(ch) ? ch - '0' : ch - 'a' + 10; }
UINT Hex(LPWSTR s, int n)
{
    UINT res = 0;
    while(n--) {
         res = res * 16 + HexVal(*s++); 
    }
    return res;
}

VOID
GuidFromStr(
    IN LPWSTR str, 
    OUT LPGUID guid)
{    
    int i = wcslen(str);
    if(i == 36) {
        guid->Data1 =            Hex(str +  0, 8);
        guid->Data2 =    (USHORT)Hex(str +  9, 4);
        guid->Data3 =    (USHORT)Hex(str + 14, 4);
        guid->Data4[0] = (UCHAR) Hex(str + 19, 2);
        guid->Data4[1] = (UCHAR) Hex(str + 21, 2);
        guid->Data4[2] = (UCHAR) Hex(str + 24, 2);
        guid->Data4[3] = (UCHAR) Hex(str + 26, 2);
        guid->Data4[4] = (UCHAR) Hex(str + 28, 2);
        guid->Data4[5] = (UCHAR) Hex(str + 30, 2);
        guid->Data4[6] = (UCHAR) Hex(str + 32, 2);
        guid->Data4[7] = (UCHAR) Hex(str + 34, 2);
    } else {
        DbgPrint("[WMLUM} GuidFromStr - Bad guid string: %S, length %d\n", str, i);
    }
}

typedef struct _INHERITED_DATA {
    BOOL Active;
    ULONG ControlFlags;
    ULONG LogLevel;
    ULONG Reserved;
    TRACEHANDLE Logger;
    GUID  Guid;
    BOOL  GuidDefined;
} INHERITED_DATA, *PINHERITED_DATA;

VOID
ReadCommonData(
    IN HKEY hk, 
    IN OUT PINHERITED_DATA data
    )
{
    ULONG ulTemp;
    ULONG dwSize;
    WCHAR szGuid[16 * 3 + 1];
    ULONG Temp;

    dwSize = sizeof(ulTemp);
    if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_ACTIVE, 
                             NULL, NULL,(BYTE *) &ulTemp, &dwSize))
    {
        data->Active = ulTemp;
    }
    else {
        dwSize = sizeof(Temp);
        data->Active = Temp = 0;
        RegSetValueEx(hk, REG_TRACE_ACTIVE, 0, REG_DWORD, (BYTE *) &Temp, dwSize);
    }

    dwSize = sizeof(ulTemp);
    if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_CONTROL, 
                                         NULL, NULL, 
                                         (BYTE *) &ulTemp, &dwSize)) 
    {
        data->ControlFlags = ulTemp;
    }
    else {
        dwSize = sizeof(Temp);
        data->ControlFlags = Temp = 0;
        RegSetValueEx(hk, REG_TRACE_CONTROL, 0, REG_DWORD, (BYTE *)&Temp, dwSize);
    }


    dwSize = sizeof(ulTemp);
    if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_LEVEL, 
                                         NULL, NULL,
                                         (BYTE *) &ulTemp, 
                                         &dwSize)) 
    {
        data->LogLevel = ulTemp;
    }
    else {
        dwSize = sizeof(Temp);
        data->LogLevel = Temp = 0;
        RegSetValueEx(hk, REG_TRACE_LEVEL, 0, REG_DWORD, (BYTE *)&Temp, dwSize);
    }

    dwSize = sizeof(szGuid);
    if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_GUID, 
                                         NULL, NULL,
                                         (BYTE *) szGuid, 
                                         &dwSize)) 
    {
        GuidFromStr(szGuid, &data->Guid);
        data->GuidDefined = TRUE;
    }
    else {
        wcscpy(szGuid, L"d3ecd8e1-d3fb-4f26-8091-978eecb468b1");
        GuidFromStr(szGuid, &data->Guid);
        dwSize = wcslen(szGuid) * sizeof(wchar_t);
        RegSetValueEx(hk, REG_TRACE_GUID, 0, REG_SZ, (BYTE*)szGuid, dwSize);
    }

    return;
}

typedef struct _FULL_LOGGER_INFO {
    EVENT_TRACE_PROPERTIES LoggerInfo;
    WCHAR logFileName[MAX_PATH + 512];
    WCHAR logSessionName[MAX_PATH + 512];
    ULONG MaxHistorySize;
    ULONG MaxBackups;
} FULL_LOGGER_INFO, *PFULL_LOGGER_INFO;

GUID MySystemTraceControlGuid = { /* 9e814aad-3204-11d2-9a82-006008a86939 */
    0x9e814aad,
    0x3204,
    0x11d2,
    {0x9a, 0x82, 0x00, 0x60, 0x08, 0xa8, 0x69, 0x39}
  };


VOID 
ReadLoggerInfo(
    IN HKEY hk, 
    OUT PTRACEHANDLE Logger) 
{
    FULL_LOGGER_INFO x;
    WCHAR tmpName[MAX_PATH + 512];
    WCHAR tmpName2[MAX_PATH + 512];
    ULONG ulTemp;
    ULONG Temp;
    ULONG dwReadSize = sizeof(ulTemp);    
    ULONG status;
    SYSTEMTIME localTime;
    BOOL success;
    
    RtlZeroMemory(&x, sizeof(x));
    x.LoggerInfo.Wnode.BufferSize = sizeof(x);
    x.LoggerInfo.Wnode.Flags = WNODE_FLAG_TRACED_GUID; 
    x.LoggerInfo.LogFileNameOffset = (ULONG)((ULONG_PTR)x.logFileName - (ULONG_PTR)&x);
    x.LoggerInfo.LoggerNameOffset  = (ULONG)((ULONG_PTR)x.logSessionName - (ULONG_PTR)&x);
    x.LoggerInfo.LogFileMode = EVENT_TRACE_FILE_MODE_CIRCULAR;

    //
    // If the key describes a logger,
    // it should have at least LOG_SESSION_NAME value
    //
    dwReadSize = sizeof(x.logSessionName);
    status = RegQueryValueEx(hk, REG_TRACE_LOG_SESSION_NAME, 
                             NULL, NULL, 
                             (BYTE *) &x.logSessionName, &dwReadSize);
    if (status != ERROR_SUCCESS) {
        wcscpy(x.logSessionName, L"DfsSvcLog");
       // dwReadSize = wcslen(x.logSessionName) * sizeof(wchar_t);
       // RegSetValueEx(hk, REG_TRACE_LOG_SESSION_NAME, 0, REG_SZ,(BYTE*) &x.logSessionName, dwReadSize);
    }

    if ( wcscmp(x.logSessionName, NT_LOGGER) == 0) {
        MyDbgPrint(3,"[WMILIB] Enabling system tracing\n", 
                   x.logSessionName,
                   x.LoggerInfo.Wnode.HistoricalContext);

        x.LoggerInfo.Wnode.Guid = MySystemTraceControlGuid;
        x.LoggerInfo.EnableFlags |= 
            EVENT_TRACE_FLAG_PROCESS |
            EVENT_TRACE_FLAG_THREAD |
            EVENT_TRACE_FLAG_DISK_IO |
            EVENT_TRACE_FLAG_NETWORK_TCPIP |
            EVENT_TRACE_FLAG_REGISTRY;
    }

    // Let's query, whether there is a logger with this name
    status = QueryTrace(0, x.logSessionName, &x.LoggerInfo);
    if (ERROR_SUCCESS == status) {
        MyDbgPrint(1,"[WMILIB] Query successful Logger %1!ws! %2!08X!:%3!08X!\n", 
                   x.logSessionName,
                   x.LoggerInfo.Wnode.HistoricalContext);
        *Logger = x.LoggerInfo.Wnode.HistoricalContext;
        return;
    }

    if (ERROR_WMI_INSTANCE_NOT_FOUND != status) {
        MyDbgPrint(1,"[WMILIB] Query of %1!ws! failed %2!d!\n", 
                   x.logSessionName, status);
    }

    // There is no logger runing

    // First, We will query logFileName value into tmpName variable
    // and then expand it into logFileName
    dwReadSize = sizeof(tmpName);
    status = RegQueryValueEx(hk, REG_TRACE_LOG_FILE_NAME, 
                             NULL, NULL, 
                             (BYTE *) tmpName, &dwReadSize);
    if (status != ERROR_SUCCESS) {
        // If there is no logFileName, then this node doesn't describe
        // a logger. Bail out.
//        MyDbgPrint(1,"[WMILIB] Cannot read log file name, status %1!d!\n", status);
        wcscpy(tmpName, L"%SystemRoot%\\DfsSvcLogFile");
        //dwReadSize = wcslen(tmpName) * sizeof(wchar_t);;
        //RegSetValueEx(hk, REG_TRACE_LOG_FILE_NAME, 0, REG_SZ,(BYTE*) &tmpName, dwReadSize);
    }
    dwReadSize = ExpandEnvironmentStrings(tmpName, x.logFileName, ARRAYSIZE(x.logFileName) );
    if (dwReadSize == 0 || dwReadSize > ARRAYSIZE(x.logFileName)) {
        MyDbgPrint(1,"[WMILIB] Expansion of %1!ws! failed, return value %2!d!\n", tmpName, dwReadSize);
        CopyMemory(x.logFileName, tmpName, sizeof(x.logFileName));
    }
    
    MyDbgPrint(3,"[WMILIB] FileName %1!S!\n", x.logFileName);
    MyDbgPrint(3,"[WMILIB] Session %1!S!\n", x.logSessionName);

    dwReadSize = sizeof(ulTemp);
    if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_LOG_BUFFER_SIZE, 
                                         NULL, NULL, 
                                         (BYTE *) &ulTemp, &dwReadSize)) {
        x.LoggerInfo.BufferSize = ulTemp;
    }
    else {
        x.LoggerInfo.BufferSize = Temp = 0;
      //  RegSetValueEx(hk, REG_TRACE_LOG_BUFFER_SIZE, 0, REG_DWORD,(BYTE*) &Temp, dwReadSize);
    }
    dwReadSize = sizeof(ulTemp);
    if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_LOG_MIN_BUFFERS, 
                                         NULL, NULL, 
                                         (BYTE *) &ulTemp, &dwReadSize)){
        x.LoggerInfo.MinimumBuffers = ulTemp;
    }
    else {
        x.LoggerInfo.MinimumBuffers = Temp = 0;
    //    RegSetValueEx(hk, REG_TRACE_LOG_MIN_BUFFERS, 0, REG_DWORD, (BYTE*)&Temp, dwReadSize);
    }
    dwReadSize = sizeof(ulTemp);
    if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_LOG_MAX_BUFFERS, 
                                         NULL, NULL, 
                                         (BYTE *) &ulTemp, &dwReadSize)){
        x.LoggerInfo.MaximumBuffers = ulTemp;
    }
    else {
        x.LoggerInfo.MaximumBuffers = Temp = 0;
    //    RegSetValueEx(hk, REG_TRACE_LOG_MAX_BUFFERS, 0, REG_DWORD, (BYTE*)&Temp, dwReadSize);
    }

    dwReadSize = sizeof(ulTemp);
    if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_LOG_MAX_FILESIZE, 
                                         NULL, NULL, 
                                         (BYTE *) &ulTemp, &dwReadSize)){
        x.LoggerInfo.MaximumFileSize = ulTemp;
    }
    else{
        x.LoggerInfo.MaximumFileSize = Temp = 2;
     //   RegSetValueEx(hk, REG_TRACE_LOG_MAX_FILESIZE, 0, REG_DWORD, (BYTE*)&Temp, dwReadSize);
    }

	x.MaxHistorySize = 4 * x.LoggerInfo.MaximumFileSize;
    dwReadSize = sizeof(ulTemp);
    if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_LOG_MAX_HISTORY, 
                                         NULL, NULL, 
                                         (BYTE *) &ulTemp, &dwReadSize)){
        x.MaxHistorySize = ulTemp;
    }
    else {
        x.MaxHistorySize = Temp = 0;
    //    RegSetValueEx(hk, REG_TRACE_LOG_MAX_HISTORY, 0, REG_DWORD, (BYTE*)&Temp, dwReadSize);
    }

    dwReadSize = sizeof(ulTemp);
    if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_LOG_MAX_BACKUPS, 
                                         NULL, NULL, 
                                         (BYTE *) &ulTemp, &dwReadSize)) {
        x.MaxBackups = ulTemp;
    }
    else {
        x.MaxBackups = Temp = 1;
     //   RegSetValueEx(hk, REG_TRACE_LOG_MAX_BACKUPS, 0, REG_DWORD, (BYTE*)&Temp, dwReadSize);
    }


	if (x.MaxBackups == 0) {
	 	// We need to check whether the file already exist and rename it //

	 	GetLocalTime(&localTime);
		_snwprintf(tmpName, ARRAYSIZE(tmpName), 
				   L"%1ws.%04d%02d%02d%02d%02d%02d",
				   x.logFileName,
				   localTime.wYear,localTime.wMonth,localTime.wDay,
				   localTime.wHour,localTime.wMinute,localTime.wSecond);

		success = MoveFile(x.logFileName, tmpName);
		if (!success) {
	    	status = GetLastError();
		} else {
			status = ERROR_SUCCESS;
		}
	    MyDbgPrint(3,"[WMILIB] Rename %1!ws! => %2!ws!, status %3!d!\n", 
	    			x.logFileName, tmpName, status);
	} else {
		int i;
		for (i = x.MaxBackups; i >= 1; --i) {
			_snwprintf(tmpName2, ARRAYSIZE(tmpName), 
					   L"%1ws.%03d",
					   x.logFileName, i);
			if (i == 1) {
				wcscpy(tmpName, x.logFileName);
			} else {
				_snwprintf(tmpName, ARRAYSIZE(tmpName), 
						   L"%1ws.%03d",
						   x.logFileName, i-1);
			}
			success = MoveFile(tmpName, tmpName2);
			if (!success) {
		    	status = GetLastError();
			} else {
				status = ERROR_SUCCESS;
			}
		    MyDbgPrint(3,"[WMILIB] Rename %1!ws! => %2!ws!, status %3!d!\n", 
		    			tmpName, tmpName2, status);
		}
	}

    status = StartTrace(Logger, x.logSessionName, &x.LoggerInfo);
    *Logger = x.LoggerInfo.Wnode.HistoricalContext;
    MyDbgPrint(1,"[WMILIB] Logger %1!ws! started %3!08X!:%4!08X! %2!d!\n", 
               x.logSessionName, status, *Logger);
}

WCHAR szModuleName[MAX_PATH+500];

ULONG
InitWmiInternal(
    IN HKEY Dir OPTIONAL, // if 0, then current ...
    IN LPWSTR ProductName, 
    IN PINHERITED_DATA InheritedData OPTIONAL
    )
{
    ULONG status;
    INHERITED_DATA data;
    HKEY CloseMe = 0;
    HKEY hk      = 0;
    //ULONG ulTemp;
    //ULONG dwReadSize = sizeof(ulTemp);
    DWORD dwSizeOfModuleName;
    DWORD dwIndex;

    MyDbgPrint(2, "[WMILIB] Init %1!ws!\n", ProductName);

    if (InheritedData) {
        data = *InheritedData;
    } else {
        ZeroMemory(&data, sizeof(data));
    }
    data.GuidDefined = FALSE;

    if (!Dir) {
        status = RegCreateKeyEx(HKEY_LOCAL_MACHINE, 
                                REG_TRACE_REGKEY, 
                                0, 
                                NULL,
                                REG_OPTION_NON_VOLATILE, 
                                KEY_READ | KEY_WRITE,
                                NULL,
                                &CloseMe,
                                NULL);
        if (status != ERROR_SUCCESS) {
            MyDbgPrint(1,"[WMILIB] Failed to open Trace Key, %1!d!\n", status);
            goto exit_gracefully;
        }
        Dir = CloseMe;
    }

    status = RegCreateKeyEx(Dir, 
                            ProductName, 
                            0, 
                            NULL,
                            REG_OPTION_NON_VOLATILE, 
                            KEY_READ | KEY_WRITE,
                            NULL,
                            &hk,
                            NULL);
    if (status != ERROR_SUCCESS) {
        MyDbgPrint(1,"[WMILIB] Failed to open %1!ws! subkey, %2!d!\n", ProductName, status);
        goto exit_gracefully;
    }


    ReadLoggerInfo(hk, &data.Logger);
    ReadCommonData(hk, &data);

    if (!data.Active) {
        MyDbgPrint(1,"[WMILIB] Tracing is not active for %1!ws!\n", ProductName);
    	goto exit_gracefully;
    }

    if (data.GuidDefined) {
        // First, try to find its in the map.            //
        // If it is there, we need to register this Guid //
        RegisterIfNecessary(ProductName, &data.Guid);

        // We can try to start tracing //
        if (data.Logger) {
            status = EnableTrace(data.Active, 
                                 data.ControlFlags, 
                                 data.LogLevel,
                                 &data.Guid,
                                 data.Logger);
            MyDbgPrint(1,"[WMILIB] Enable=%1!d! %2!ws!, status %3!d!\n", data.
                       Active, ProductName, status);
        }
    }

    dwSizeOfModuleName = sizeof(szModuleName);
    dwIndex = 0;
    while (ERROR_SUCCESS == (status = RegEnumKeyEx(hk, dwIndex, 
                                                   szModuleName, 
                                                   &dwSizeOfModuleName,
                                                   NULL, NULL, NULL, NULL)))
    {
        InitWmiInternal(hk, szModuleName, &data);

        dwSizeOfModuleName = sizeof(szModuleName);
        ++dwIndex;
    }

    if (ERROR_NO_MORE_ITEMS == status) {
        status = ERROR_SUCCESS;
    }

exit_gracefully:
    if (CloseMe) {
        RegCloseKey(CloseMe);
    }
    if (hk) {
        RegCloseKey(hk);
    }
    return status;
}

ULONG
InitWmi(
    IN LPWSTR ProductName
    )
{
    MyDbgPrint(1, "[WMILIB] Initialize %1!ws!\n", ProductName);
    return InitWmiInternal(0, ProductName, 0);
}

#pragma warning(disable: 4512) // error C4512: 'blah-blah-blah' : assignment operator could not be generated
#pragma warning(disable: 4100) // '_P' : unreferenced formal parameter
#include <xmemory>
#pragma warning(default: 4100)
#include <map>
//#include <xstring>

struct wless {
    bool operator() (LPCWSTR a, LPCWSTR b) const { return lstrcmpW(a,b) < 0; }
};

typedef std::map<LPCWSTR, PWMILIB_REG_STRUCT, wless > WIDE_STRING_MAP;

WIDE_STRING_MAP* map;
PWMILIB_REG_STRUCT head;

ULONG
WmilibControlCallback(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID Context,
    IN OUT ULONG *InOutBufferSize,
    IN OUT PVOID Buffer
    )
{
    PWMILIB_REG_STRUCT Ctx = (PWMILIB_REG_STRUCT)Context;
    ULONG Status = ERROR_SUCCESS;

   	switch (RequestCode)
   	{
   	case WMI_ENABLE_EVENTS:
   	    {
   	    Ctx->LoggerHandle = GetTraceLoggerHandle( Buffer );
   	    Ctx->EnableLevel = GetTraceEnableLevel(Ctx->LoggerHandle);
   	    Ctx->EnableFlags = GetTraceEnableFlags(Ctx->LoggerHandle);
        MyDbgPrint(3, "[WMILIB] WMI_ENABLE_EVENTS Ctx 0x%1!08X! Flags %2!X! Lev %3!d! Logger %4!08X!:%5!08X!\n", 
                   Ctx, Ctx->EnableFlags, Ctx->EnableLevel, Ctx->LoggerHandle);
    
        break;
   	    }

   	case WMI_DISABLE_EVENTS:
   	    {
        Ctx->LoggerHandle = 0;
        Ctx->EnableFlags = 0;
        Ctx->EnableLevel = 0;
        MyDbgPrint(3, "[WMILIB] WMI_DISABLE_EVENTS Ctx 0x%1!08X!\n", Ctx);
   	    break;
    	}

   	default:
   	   {
   	       Status = ERROR_INVALID_PARAMETER;
   	       break;
   	   }
   	}
   	*InOutBufferSize = 0;
   	return(Status);
}



VOID RegisterIfNecessary(
    LPWSTR KeyName, 
    LPCGUID Guid)
{
    WIDE_STRING_MAP::iterator i = map->find(KeyName);
    if ( i == map->end() ) {
        MyDbgPrint(2, "[WMILIB] map: %1!ws!, not found\n", KeyName);
        return; // Not found //
    }
    MyDbgPrint(3, "[WMILIB] map[%1!ws!]=0x%2!08X!\n", i->first, i->second);

    TRACE_GUID_REGISTRATION Reg;

    Reg.Guid = Guid;
    Reg.RegHandle = 0;

    ULONG status = RegisterTraceGuids(
        WmilibControlCallback,
        i->second, // Context for the callback
        Guid,      // Control Guid
        1,         // # of dummies
        &Reg,      // dummy trace guid
        0, //ImagePath,
        0, //ResourceName,
        &i->second->RegistrationHandle
        );

    if (status == ERROR_SUCCESS) {
        i->second->Next = head;
        head = i->second;
    } else {
        MyDbgPrint(1, "[WMILIB] Failed to register %1!ws!, status %2!d!\n", KeyName, status);
    }
}

ULONG
WmlInitialize(
    IN LPWSTR              ProductName, 
    IN WMILIBPRINTFUNC     PrintFunc,
    OUT WMILIB_REG_HANDLE* Head, 
    ... // Pairs: LPWSTR CtrlGuidName, Corresponding WMILIB_REG_STRUCT 
    )
{
    WIDE_STRING_MAP map;
    LPWSTR str;
    va_list ap;

    WmiLibPrint = PrintFunc;

    *Head = 0;

    ::head = 0;
    ::map = &map;

    va_start(ap, Head);
    while(0 != (str = va_arg(ap, LPWSTR)) ) {
         map[ str ] = va_arg(ap, PWMILIB_REG_STRUCT);
    }
    va_end(ap);
    ULONG status = InitWmiInternal(0, ProductName, 0);
    *Head = ::head;
    return status;
}

VOID
WmlUninitialize(
    IN PWMILIB_REG_STRUCT head
    )
{
    while (head) {
        MyDbgPrint(3,"[WMILIB] Unregister 0x%1!08X!\n", head);
        UnregisterTraceGuids(head->RegistrationHandle);
        head = head->Next;
    }
}

#define WMILIB_USER_MODE

typedef struct _TRACE_BUFFER {
    union {
        EVENT_TRACE_HEADER Trace;
        WNODE_HEADER       Wnode;
    };
    MOF_FIELD MofFields[MAX_MOF_FIELDS + 1];
} TRACE_BUFFER, *PTRACE_BUFFER;


//////////////////////////////////////////////////////////////////////
//  0  | Size      | ProviderId  |   0  |Size.HT.Mk | Typ.Lev.Version|
//  2  | L o g g e r H a n d l e |   2  |    T h r e a d   I d       |
//  4  | T i m e  S t a m p      |   4  |    T i m e  S t a m p      |
//  6  |    G U I D    L o w     |   6  |    GUID Ptr / Guid L o w   |
//  8  |    G U I D    H I g h   |   8  |    G U I D    H i g h      |
// 10  | ClientCtx | Flags       |  10  |KernelTime | UserTime       |
//////////////////////////////////////////////////////////////////////

ULONG
WmlTrace(
    IN UINT Type,
    IN LPCGUID TraceGuid,
    IN TRACEHANDLE LoggerHandle,
    ... // Pairs: Address, Length
    )
{
    TRACE_BUFFER TraceBuffer;

    ((PULONG)&TraceBuffer)[1] = Type;
    
#ifndef WMILIB_USER_MODE
    TraceBuffer.Wnode.HistoricalContext = LoggerHandle;
#endif

    TraceBuffer.Trace.Guid = *TraceGuid;

    TraceBuffer.Wnode.Flags = 
        WNODE_FLAG_USE_MOF_PTR  | // MOF data are dereferenced
        WNODE_FLAG_TRACED_GUID;   // Trace Event, not a WMI event

    {
        PMOF_FIELD   ptr = TraceBuffer.MofFields;
        va_list      ap;

        va_start(ap, LoggerHandle);
        do {
            if ( 0 == (ptr->Length = (ULONG)va_arg (ap, size_t)) )  {
                break;
            }
            ptr->DataPtr = (ULONGLONG)va_arg(ap, PVOID);
        } while ( ++ptr < &TraceBuffer.MofFields[MAX_MOF_FIELDS] );
        va_end(ap);

        TraceBuffer.Wnode.BufferSize = (ULONG) ((ULONG_PTR)ptr - (ULONG_PTR)&TraceBuffer);
    }
    
#ifdef WMILIB_USER_MODE
    ULONG status = TraceEvent( LoggerHandle, &TraceBuffer.Trace);
    if (status != ERROR_SUCCESS) {
    	// Need to count failures and report them during unintialize or ...//
    }
#else
    IoWMIWriteEvent(&TraceBuffer);
#endif
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\wml\inc\wmltypes.inc ===
//#define WMILIB_TYPEDEF(_TypeName, _EquivType, _FmtStr, _Func, _MofStr, _InitType)

#define WMILIB_SIMPLE_TYPE(_TypeName, _EquivType, _FmtStr, _MofStr) \
   WMILIB_TYPEDEF(_TypeName, _EquivType, _FmtStr, FormatSimple, _MofStr, WMILIB_ALIGNEDCOPY)
   
#define WMILIB_COMPLX_TYPE(_TypeName, _EquivType, _Func, _MofStr) \
   WMILIB_TYPEDEF(_TypeName, _EquivType, 0, _Func, _MofStr, WMILIB_ALIGNEDCOPY)

#define WMILIB_STRING_TYPE(_TypeName, _EquivType, _Func, _MofStr) \
   WMILIB_TYPEDEF(_TypeName, _EquivType, 0, _Func, _MofStr, WMILIB_ASIS)

WMILIB_SIMPLE_TYPE(UBYTE, char, "u",          ItemByte)
WMILIB_SIMPLE_TYPE(SBYTE, char, "d",          ItemSByte)
WMILIB_SIMPLE_TYPE(XBYTE, char, "X",          ItemXByte)
WMILIB_SIMPLE_TYPE(OBYTE, char, "02o",        ItemOByte)
WMILIB_COMPLX_TYPE(BBYTE, char, FormatBinary, ItemXByte)

WMILIB_SIMPLE_TYPE(USHORT, short, "u",          ItemUShort)
WMILIB_SIMPLE_TYPE(SSHORT, short, "d",          ItemShort)
WMILIB_SIMPLE_TYPE(XSHORT, short, "X",          ItemXShort)
WMILIB_SIMPLE_TYPE(OSHORT, short, "o",          ItemOShort)
WMILIB_COMPLX_TYPE(BSHORT, short, FormatBinary, ItemXShort)

WMILIB_SIMPLE_TYPE(UINT, int, "u",          ItemULong)
WMILIB_SIMPLE_TYPE(SINT, int, "s",          ItemLong)
WMILIB_SIMPLE_TYPE(XINT, int, "X",          ItemULongX)
WMILIB_SIMPLE_TYPE(OINT, int, "o",          ItemULong)
WMILIB_COMPLX_TYPE(BINT, int, FormatBinary, ItemULong)

WMILIB_SIMPLE_TYPE(HANDLE, HANDLE, "x",     ItemULong)

WMILIB_SIMPLE_TYPE(ULONGLONG, _int64, "u", ItemULongLong)
WMILIB_SIMPLE_TYPE(SLONGLONG, _int64, "s", ItemLongLong)
WMILIB_SIMPLE_TYPE(XLONGLONG, _int64, "X", ItemULongLongX)
WMILIB_SIMPLE_TYPE(OLONGLONG, _int64, "o", ItemULongLong)

WMILIB_SIMPLE_TYPE(PTR,        void*, "x", ItemXPointer)

WMILIB_SIMPLE_TYPE(BOOLEAN, char, "u", ItemListByte (FALSE,TRUE) )

WMILIB_SIMPLE_TYPE(UCHAR, CHAR,  "c", ItemUChar)
WMILIB_SIMPLE_TYPE(ACHAR, CHAR,  "c", ItemChar)
WMILIB_SIMPLE_TYPE(WCHAR, WCHAR, "c", ItemShortSign)

WMILIB_STRING_TYPE(ASTR, WMILIBTYPE_STRING, FormatMisc, ItemString)
WMILIB_STRING_TYPE(WSTR, WMILIBTYPE_STRING, FormatMisc, ItemWString)
WMILIB_STRING_TYPE(USTR, WMILIBTYPE_STRING, FormatMisc, ItemPString)

WMILIB_COMPLX_TYPE(DATE,     LARGE_INTEGER, FormatMisc, ItemDate)
WMILIB_COMPLX_TYPE(TIMENT,   LARGE_INTEGER, FormatMisc, ItemTime)
WMILIB_COMPLX_TYPE(DATETIME, LARGE_INTEGER, FormatMisc, ItemDateTime)
WMILIB_COMPLX_TYPE(MILLISEC, LARGE_INTEGER, FormatMisc, ItemMillisec)
WMILIB_COMPLX_TYPE(ALETTER,  CHAR,          FormatMisc, ItemLetter)
WMILIB_COMPLX_TYPE(WLETTER,  WCHAR,         FormatMisc, ItemWLetter)
WMILIB_COMPLX_TYPE(GUID,     GUID,          FormatMisc, ItemGuid)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\wml\inc\wmlum.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    wmlum.h

Abstract:

    User mode definitions for an easy wmi tracing.

Author:

    gorn

Revision History:

Comments:

    Needs to be moved to wmilib\inc when DCR is approved


--*/
#ifndef WMLUM_H
#define WMLUM_H 1

#pragma warning(disable: 4201) // error C4201: nonstandard extension used : nameless struct/union
#include <wmistr.h>
#include <evntrace.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _WMILIB_REG_STRUCT
{
    TRACEHANDLE LoggerHandle;
    ULONG EnableFlags; 
    ULONG EnableLevel;

    struct _WMILIB_REG_STRUCT* Next;
    TRACEHANDLE RegistrationHandle;
} WMILIB_REG_STRUCT, *PWMILIB_REG_STRUCT;

typedef PWMILIB_REG_STRUCT WMILIB_REG_HANDLE;

typedef void (*WMILIBPRINTFUNC)(UINT Level, PCHAR String);

ULONG
WmlInitialize(
    IN LPWSTR ProductName, 
    IN WMILIBPRINTFUNC PrintFunc,
    OUT WMILIB_REG_HANDLE*, 
    ... // Pairs: LPWSTR CtrlGuidName, Corresponding WMILIB_REG_STRUCT 
    );
    
VOID
WmlUninitialize(
    IN WMILIB_REG_HANDLE
    );

ULONG
WmlTrace(
    IN UINT Type,
    IN LPCGUID TraceGuid,
    IN TRACEHANDLE LoggerHandle,
    ... // Pairs: Address, Length
    );

typedef 
ULONG
(*PWML_INITIALIZE)(
    IN LPWSTR ProductName, 
    IN WMILIBPRINTFUNC PrintFunc,
    OUT WMILIB_REG_HANDLE*, 
    ...
    );

typedef 
VOID 
(*PWML_UNINITIALIZE)(
    IN WMILIB_REG_HANDLE);

typedef 
ULONG
(*PWML_TRACE)(
    IN UINT Type,
    IN LPCGUID TraceGuid,
    IN TRACEHANDLE LoggerHandle,
    ... 
    );

typedef 
struct _WML_DATA {

    PWML_TRACE        Trace;
    PWML_INITIALIZE   Initialize;
    PWML_UNINITIALIZE Uninitialize;
    
    WMILIB_REG_HANDLE WmiRegHandle;
    HINSTANCE         WmlDllInstance;
    
} WML_DATA;

#define LOADWML(status, wml) \
    do \
    { \
            (wml).Trace        =        (PWML_TRACE) WmlTrace; \
            (wml).Initialize   =   (PWML_INITIALIZE) WmlInitialize; \
            (wml).Uninitialize = (PWML_UNINITIALIZE) WmlUninitialize; \
    \
            if (!(wml).Trace || !(wml).Initialize || !(wml).Uninitialize) { \
                status = GetLastError(); \
            } else { \
                status = ERROR_SUCCESS; \
            } \
    } \
    while(0)

/*
#define LOADWML(status, wml) \
    do \
    { \
        HINSTANCE hInst = LoadLibraryW(L"wmlum.dll"); \
        (wml).WmlDllInstance = hInst; \
        if (!hInst) { \
            status = GetLastError(); \
        } else { \
            (wml).Trace        =        (PWML_TRACE) GetProcAddress(hInst, "WmlTrace"); \
            (wml).Initialize   =   (PWML_INITIALIZE) GetProcAddress(hInst, "WmlInitialize"); \
            (wml).Uninitialize = (PWML_UNINITIALIZE) GetProcAddress(hInst, "WmlUninitialize"); \
    \
            if (!(wml).Trace || !(wml).Initialize || !(wml).Uninitialize) { \
                status = GetLastError(); \
            } else { \
                status = ERROR_SUCCESS; \
            } \
        } \
    } \
    while(0)
*/
#define UNLOADWML(wml) \
    do \
    { \
        if ( (wml).Uninitialize ) { \
            (wml).Uninitialize( (wml).WmiRegHandle ); \
        } \
        if ( (wml).WmlDllInstance ) { \
            FreeLibrary( (wml).WmlDllInstance ); \
        } \
        RtlZeroMemory( &(wml) , sizeof(WML_DATA) ); \
    } \
    while(0)  

#ifdef __cplusplus
};
#endif

#endif // WMLUM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\npfs\cleanup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Cleanup.c

Abstract:

    This module implements the File Cleanup routine for NPFS called by the
    dispatch driver.

Author:

    Gary Kimura     [GaryKi]    21-Aug-1990

Revision History:

--*/

#include "NpProcs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CLEANUP)

//
//  local procedure prototypes
//

NTSTATUS
NpCommonCleanup (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NpCommonCleanup)
#pragma alloc_text(PAGE, NpFsdCleanup)
#endif


NTSTATUS
NpFsdCleanup (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtCleanupFile API calls.

Arguments:

    NpfsDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpFsdCleanup\n", 0);

    //
    //  Call the common Cleanup routine.
    //

    FsRtlEnterFileSystem();

    Status = NpCommonCleanup( NpfsDeviceObject, Irp );

    FsRtlExitFileSystem();

    if (Status != STATUS_PENDING) {
        NpCompleteRequest (Irp, Status);
    }

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "NpFsdCleanup -> %08lx\n", Status );

    return Status;
}


//
//  Internal support routine
//

NTSTATUS
NpCommonCleanup (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for cleanup

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    NODE_TYPE_CODE NodeTypeCode;
    PCCB Ccb;
    PROOT_DCB RootDcb;
    NAMED_PIPE_END NamedPipeEnd;
    LIST_ENTRY DeferredList;

    PAGED_CODE();

    InitializeListHead (&DeferredList);
    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NpCommonCleanup...\n", 0);
    DebugTrace( 0, Dbg, "Irp  = %08lx\n", Irp);

    //
    //  Now acquire exclusive access to the Vcb
    //

    NpAcquireExclusiveVcb();

    //
    //  Decode the file object to figure out who we are.  If the result
    //  is null then the pipe has been disconnected.
    //

    if ((NodeTypeCode = NpDecodeFileObject( IrpSp->FileObject,
                                            &RootDcb,
                                            &Ccb,
                                            &NamedPipeEnd )) == NTC_UNDEFINED) {

        DebugTrace(0, Dbg, "Pipe is disconnected from us\n", 0);

    } else {
        //
        //  Now case on the type of file object we're closing
        //

        switch (NodeTypeCode) {

        case NPFS_NTC_VCB:

            break;

        case NPFS_NTC_ROOT_DCB:

            break;

        case NPFS_NTC_CCB:

            //
            //  If this is the server end of a pipe, decrement the count
            //  of the number of instances the server end has open.
            //  When this count is 0, attempts to connect to the pipe
            //  return OBJECT_NAME_NOT_FOUND instead of
            //  PIPE_NOT_AVAILABLE.
            //

            if ( NamedPipeEnd == FILE_PIPE_SERVER_END ) {
                ASSERT( Ccb->Fcb->ServerOpenCount != 0 );
                Ccb->Fcb->ServerOpenCount -= 1;
            }

            //
            //  The set closing state routines does everything to transition
            //  the named pipe to a closing state.
            //

            Status = NpSetClosingPipeState (Ccb, Irp, NamedPipeEnd, &DeferredList);

            break;
        }
    }
    NpReleaseVcb ();

    //
    // Complete any deferred IRPs now we have released our locks
    //
    NpCompleteDeferredIrps (&DeferredList);

    Status = STATUS_SUCCESS;

    DebugTrace(-1, Dbg, "NpCommonCleanup -> %08lx\n", Status);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\npfs\close.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Close.c

Abstract:

    This module implements the File Close routine for NPFS called by the
    dispatch driver.

Author:

    Gary Kimura     [GaryKi]    21-Aug-1990

Revision History:

--*/

#include "NpProcs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CLOSE)

//
//  local procedure prototypes
//

NTSTATUS
NpCommonClose (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NpCommonClose)
#pragma alloc_text(PAGE, NpFsdClose)
#endif


NTSTATUS
NpFsdClose (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtCloseFile API calls.

Arguments:

    NpfsDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpFsdClose\n", 0);

    //
    //  Call the common Close routine.
    //

    FsRtlEnterFileSystem();

    Status = NpCommonClose( NpfsDeviceObject, Irp );

    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "NpFsdClose -> %08lx\n", Status );

    return Status;
}

//
//  Internal support routine
//

NTSTATUS
NpCommonClose (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for creating/opening a file.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    NTSTATUS Status;

    PIO_STACK_LOCATION IrpSp;

    NODE_TYPE_CODE NodeTypeCode;
    PFCB Fcb;
    PCCB Ccb;
    LIST_ENTRY DeferredList;

    PAGED_CODE();

    InitializeListHead (&DeferredList);
    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NpCommonClose...\n", 0);
    DebugTrace( 0, Dbg, " Irp                    = %08lx\n", Irp);

    //
    //  Now acquire exclusive access to the vcb
    //

    NpAcquireExclusiveVcb();

    //
    //  Decode the file object to figure out who we are.  If the result
    //  is null then the pipe has been disconnected.
    //

    if ((NodeTypeCode = NpDecodeFileObject( IrpSp->FileObject,
                                            &Fcb,
                                            &Ccb,
                                            NULL )) == NTC_UNDEFINED) {

        DebugTrace(0, Dbg, "Pipe is disconnected from us\n", 0);

    } else {

        //
        //  Now case on the type of file object we're closing
        //

        switch (NodeTypeCode) {

        case NPFS_NTC_VCB:

            //
            //  Decrement the Open count
            //

            NpVcb->OpenCount -= 1;

            break;

        case NPFS_NTC_ROOT_DCB:

            //
            //  Decrement the Open count and clear our fields in the file object
            //

            Fcb->OpenCount -= 1;

            //
            //  Remove the root dcb ccb.
            //

            NpDeleteCcb (Ccb, &DeferredList);

            break;

        case NPFS_NTC_CCB:

            break;
        }
    }

    //
    //  Complete the close irp
    //

    NpReleaseVcb( );

    //
    // Complete any deferred IRPs now we have droped the locks
    //
    NpCompleteDeferredIrps (&DeferredList);

    Status = STATUS_SUCCESS;
    NpCompleteRequest (Irp, Status);

    DebugTrace(-1, Dbg, "NpCommonClose -> %08lx\n", Status);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\npfs\create.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Create.c

Abstract:

    This module implements the File Create routine for NPFS called by the
    dispatch driver.

Author:

    Gary Kimura     [GaryKi]    21-Aug-1990

Revision History:

--*/

#include "NpProcs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CREATE)


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NpFsdCreate)
#pragma alloc_text(PAGE, NpOpenNamedPipeFileSystem)
#pragma alloc_text(PAGE, NpOpenNamedPipeRootDirectory)
#pragma alloc_text(PAGE, NpCreateClientEnd)
#endif


NTSTATUS
NpFsdCreate (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtCreateFile and NtOpenFile
    API calls.

Arguments:

    NpfsDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    PFILE_OBJECT FileObject;
    PFILE_OBJECT RelatedFileObject;
    UNICODE_STRING FileName;
    ACCESS_MASK DesiredAccess;
    BOOLEAN CaseInsensitive = TRUE; //**** Make all searches case insensitive
    PFCB Fcb;
    PCCB Ccb;
    UNICODE_STRING RemainingPart;
    LIST_ENTRY DeferredList;
    NODE_TYPE_CODE RelatedType;

    PAGED_CODE();

    InitializeListHead (&DeferredList);

    //
    //  Reference our input parameters to make things easier
    //

    IrpSp             = IoGetCurrentIrpStackLocation (Irp);
    FileObject        = IrpSp->FileObject;
    RelatedFileObject = IrpSp->FileObject->RelatedFileObject;
    FileName          = *(PUNICODE_STRING)&IrpSp->FileObject->FileName;
    DesiredAccess     = IrpSp->Parameters.Create.SecurityContext->DesiredAccess;

    RelatedType = NTC_UNDEFINED;

    //
    //  Acquire exclusive access to the Vcb
    //

    FsRtlEnterFileSystem();

    NpAcquireExclusiveVcb();

    if (RelatedFileObject != NULL) {
        RelatedType = NpDecodeFileObject (RelatedFileObject,
                                          &Fcb,
                                          &Ccb,
                                          NULL);
    }

    //
    //  Check if we are trying to open the named pipe file system
    //  (i.e., the Vcb).
    //

    if ((FileName.Length == 0) &&
        ((RelatedFileObject == NULL) || (RelatedType == NPFS_NTC_VCB))) {

        DebugTrace(0, Dbg, "Open name pipe file system\n", 0);

        Irp->IoStatus = NpOpenNamedPipeFileSystem (FileObject,
                                                   DesiredAccess);

        Status = Irp->IoStatus.Status;
        goto exit_and_cleanup;
    }

    //
    //  Check if we are trying to open the root directory
    //

    if (((FileName.Length == 2) && (FileName.Buffer[0] == L'\\') && (RelatedFileObject == NULL))

            ||

        ((FileName.Length == 0) && (RelatedType == NPFS_NTC_ROOT_DCB))) {

        DebugTrace(0, Dbg, "Open root directory system\n", 0);

        Irp->IoStatus = NpOpenNamedPipeRootDirectory (NpVcb->RootDcb,
                                                      FileObject,
                                                      DesiredAccess,
                                                      &DeferredList);

        Status = Irp->IoStatus.Status;
        goto exit_and_cleanup;
    }

    //
    //  If the name is an alias, translate it.
    //

    Status = NpTranslateAlias (&FileName);
    if (!NT_SUCCESS (Status)) {
        goto exit_and_cleanup;
    }

    //
    //  If there is a related file object then this is a relative open
    //  and it better be the root dcb.  Both the then and the else clause
    //  return an Fcb.
    //

    if (RelatedFileObject != NULL) {

        if (RelatedType == NPFS_NTC_ROOT_DCB) {
            PDCB Dcb;

            Dcb = (PDCB) Fcb;
            Status = NpFindRelativePrefix (Dcb, &FileName, CaseInsensitive, &RemainingPart, &Fcb);
            if (!NT_SUCCESS (Status)) {
                goto exit_and_cleanup;
            }
        } else if (RelatedType == NPFS_NTC_CCB && FileName.Length == 0) {

            RemainingPart.Length = 0;
        } else {

            DebugTrace(0, Dbg, "Bad file name\n", 0);

            Status = STATUS_OBJECT_NAME_INVALID;
            goto exit_and_cleanup;
        }


    } else {

        //
        //  The only nonrelative name we allow are of the form "\pipe-name"
        //

        if ((FileName.Length <= 2) || (FileName.Buffer[0] != L'\\')) {

            DebugTrace(0, Dbg, "Bad file name\n", 0);

            Status = STATUS_OBJECT_NAME_INVALID;
            goto exit_and_cleanup;
        }

        Fcb = NpFindPrefix (&FileName, CaseInsensitive, &RemainingPart);
    }

    //
    //  If the remaining name is not empty then we have an error, either
    //  we have an illegal name or a non-existent name.
    //

    if (RemainingPart.Length != 0) {

        if (Fcb->NodeTypeCode == NPFS_NTC_FCB) {

            //
            //  We were given a name such as "\pipe-name\another-name"
            //

            DebugTrace(0, Dbg, "Illegal object name\n", 0);

            Status = STATUS_OBJECT_NAME_INVALID;

        } else {

            //
            //  We were given a non-existent name
            //

            DebugTrace(0, Dbg, "non-existent name\n", 0);

            Status = STATUS_OBJECT_NAME_NOT_FOUND;
        }

    } else {

        //
        //  The remaining name is empty so we better have an Fcb otherwise
        //  we have an invalid object name.
        //

        if (Fcb->NodeTypeCode == NPFS_NTC_FCB) {

            DebugTrace(0, Dbg, "Create client end named pipe, Fcb = %08lx\n", Fcb );

            //
            //  If the server has no handles open, then pretend that
            //  the pipe name doesn't exist.
            //

            if (Fcb->ServerOpenCount == 0) {

                Status = STATUS_OBJECT_NAME_NOT_FOUND;

            } else {

                Irp->IoStatus = NpCreateClientEnd (Fcb,
                                                   FileObject,
                                                   DesiredAccess,
                                                   IrpSp->Parameters.Create.SecurityContext->SecurityQos,
                                                   IrpSp->Parameters.Create.SecurityContext->AccessState,
                                                   (KPROCESSOR_MODE)(FlagOn(IrpSp->Flags, SL_FORCE_ACCESS_CHECK) ?
                                                                 UserMode : Irp->RequestorMode),
                                                   Irp->Tail.Overlay.Thread,
                                                   &DeferredList);
                Status = Irp->IoStatus.Status;
            }

         } else {

            DebugTrace(0, Dbg, "Illegal object name\n", 0);

            Status = STATUS_OBJECT_NAME_INVALID;
        }
    }



exit_and_cleanup:

    NpReleaseVcb ();

    //
    // Complete any deferred IRPs
    //

    NpCompleteDeferredIrps (&DeferredList);

    FsRtlExitFileSystem();

    NpCompleteRequest (Irp, Status);

    return Status;
}


//
//  Internal support routine
//

IO_STATUS_BLOCK
NpCreateClientEnd (
    IN PFCB Fcb,
    IN PFILE_OBJECT FileObject,
    IN ACCESS_MASK DesiredAccess,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    IN PACCESS_STATE AccessState,
    IN KPROCESSOR_MODE RequestorMode,
    IN PETHREAD UserThread,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This routine performs the operation for opening the client end of a named
    pipe.  This routine does not complete the IRP, it performs the function
    and then returns a status

Arguments:

    Fcb - Supplies the Fcb for the named pipe being accessed

    FileObject - Supplies the file object associated with the client end

    DesiredAccess - Supplies the callers desired access

    SecurityQos - Supplies the security qos parameter from the create irp

    AccessState - Supplies the access state parameter from the create irp

    RequestorMode - Supplies the mode of the originating irp

    UserTherad - Supplies the client end user thread

    DeferredList - List of IRP's to complete later

Return Value:

    IO_STATUS_BLOCK - Returns the appropriate status for the operation

--*/

{
    IO_STATUS_BLOCK Iosb={0};

    NAMED_PIPE_CONFIGURATION NamedPipeConfiguration;

    BOOLEAN AccessGranted;
    ACCESS_MASK GrantedAccess;
    UNICODE_STRING Name;

    PCCB Ccb;
    PLIST_ENTRY Links;
    PPRIVILEGE_SET Privileges = NULL;

    DebugTrace(+1, Dbg, "NpCreateClientEnd\n", 0 );

    NamedPipeConfiguration = Fcb->Specific.Fcb.NamedPipeConfiguration;


    //
    //  "Create Pipe Instance" access is part of generic write and so
    //  we need to mask out the bit.  Even if the client has explicitly
    //  asked for "create pipe instance" access we will mask it out.
    //  This will allow the default ACL to be strengthened to protect
    //  against spurious threads from creating new pipe instances.
    //

    DesiredAccess &= ~FILE_CREATE_PIPE_INSTANCE;

    //
    //  First do an access check for the user against the Fcb
    //

    SeLockSubjectContext (&AccessState->SubjectSecurityContext);

    AccessGranted = SeAccessCheck (Fcb->SecurityDescriptor,
                                   &AccessState->SubjectSecurityContext,
                                   TRUE,                  // Tokens are locked
                                   DesiredAccess,
                                   0,
                                   &Privileges,
                                   IoGetFileObjectGenericMapping(),
                                   RequestorMode,
                                   &GrantedAccess,
                                   &Iosb.Status);

    if (Privileges != NULL) {
        SeAppendPrivileges (AccessState,
                            Privileges);
        SeFreePrivileges (Privileges);
    }

    //
    //  Transfer over the access masks from what is desired to
    //  what we just granted.  Also patch up the maximum allowed
    //  case because we just did the mapping for it.  Note that if
    //  the user didn't ask for maximum allowed then the following
    //  code is still okay because we'll just zero a zero bit.
    //

    if (AccessGranted) {

        AccessState->PreviouslyGrantedAccess |= GrantedAccess;

        AccessState->RemainingDesiredAccess &= ~(GrantedAccess | MAXIMUM_ALLOWED);
    }

    
    Name.Buffer = L"NamedPipe";
    Name.Length = sizeof (L"NamedPipe") - sizeof (WCHAR);

    SeOpenObjectAuditAlarm (&Name,
                            NULL,
                            &FileObject->FileName,
                            Fcb->SecurityDescriptor,
                            AccessState,
                            FALSE,
                            AccessGranted,
                            RequestorMode,
                            &AccessState->GenerateOnClose);

    SeUnlockSubjectContext (&AccessState->SubjectSecurityContext);

    if (!AccessGranted) {

        DebugTrace(0, Dbg, "Access Denied\n", 0 );

        return Iosb;
    }

    //
    //  Check if the user wants to write to an outbound pipe or read from
    //  and inbound pipe.  And if so then tell the user the error
    //

    if ((FlagOn (GrantedAccess, FILE_READ_DATA) && (NamedPipeConfiguration == FILE_PIPE_INBOUND)) ||
        (FlagOn (GrantedAccess, FILE_WRITE_DATA) && (NamedPipeConfiguration == FILE_PIPE_OUTBOUND))) {

        Iosb.Status = STATUS_ACCESS_DENIED;

        return Iosb;
    }

    //
    // If the caller specifies neither read nor write access then don't capture the security context.
    //

    if ((GrantedAccess&(FILE_READ_DATA|FILE_WRITE_DATA)) == 0) {
        SecurityQos = NULL;
    }

    //
    //  First try and find a ccb that is in the listening state.  If we
    //  exit the loop with Ccb not equal to null then we've found one.
    //

    Links = Fcb->Specific.Fcb.CcbQueue.Flink;

    while (1) {

        if (Links == &Fcb->Specific.Fcb.CcbQueue) {
            Iosb.Status = STATUS_PIPE_NOT_AVAILABLE;
            return Iosb;
        }

        Ccb = CONTAINING_RECORD (Links, CCB, CcbLinks);

        if (Ccb->NamedPipeState == FILE_PIPE_LISTENING_STATE) {
            break;
        }
        Links = Links->Flink;
    }


    if (!NT_SUCCESS(Iosb.Status = NpInitializeSecurity (Ccb,
                                                        SecurityQos,
                                                        UserThread))) {

        DebugTrace(0, Dbg, "Security QOS error\n", 0);

        return Iosb;
    }

    //
    //  Set the pipe into the connect state, the read mode to byte stream,
    //  and the completion mode to queued operation.  This also
    //  sets the client file object's back pointer to the ccb
    //

    if (!NT_SUCCESS(Iosb.Status = NpSetConnectedPipeState (Ccb,
                                                           FileObject,
                                                           DeferredList))) {

        NpUninitializeSecurity (Ccb);

        return Iosb;
    }

    //
    //  Set up the client session and info.  NULL for the
    //  client info indicates a local session.
    //

    Ccb->ClientInfo = NULL;
    Ccb->ClientProcess = IoThreadToProcess (UserThread);

    //
    //  And set our return status
    //

    Iosb.Status = STATUS_SUCCESS;
    Iosb.Information = FILE_OPENED;

    DebugTrace(-1, Dbg, "NpCreateClientEnd -> %08lx\n", Iosb.Status);

    return Iosb;
}


//
//  Internal support routine
//

IO_STATUS_BLOCK
NpOpenNamedPipeFileSystem (
    IN PFILE_OBJECT FileObject,
    IN ACCESS_MASK DesiredAccess
    )

{
    IO_STATUS_BLOCK Iosb = {0};

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpOpenNamedPipeFileSystem, Vcb = %08lx\n", NpVcb);


    //
    //  Have the file object point back to the Vcb, and increment the
    //  open count.  The pipe end on the call to set file object really
    //  doesn't matter.
    //

    NpSetFileObject( FileObject, NpVcb, NULL, FILE_PIPE_CLIENT_END );

    NpVcb->OpenCount += 1;

    //
    //  Set our return status
    //
    Iosb.Status = STATUS_SUCCESS;
    Iosb.Information = FILE_OPENED;

    //
    //  And return to our caller
    //

    return Iosb;
}


//
//  Internal support routine
//

IO_STATUS_BLOCK
NpOpenNamedPipeRootDirectory(
    IN PROOT_DCB RootDcb,
    IN PFILE_OBJECT FileObject,
    IN ACCESS_MASK DesiredAccess,
    IN PLIST_ENTRY DeferredList
    )

{
    IO_STATUS_BLOCK Iosb={0};
    PROOT_DCB_CCB Ccb;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpOpenNamedPipeRootDirectory, RootDcb = %08lx\n", RootDcb);

    Iosb.Status = NpCreateRootDcbCcb (&Ccb);
    if (!NT_SUCCESS(Iosb.Status)) {
        return Iosb;
    }

    //
    //  Have the file object point back to the Dcb, and reference the root
    //  dcb, ccb, and increment our open count.  The pipe end on the
    //  call to set file object really doesn't matter.
    //

    NpSetFileObject (FileObject,
                     RootDcb,
                     Ccb,
                     FILE_PIPE_CLIENT_END);

    RootDcb->OpenCount += 1;

    //
    //  Set our return status
    //

    Iosb.Status = STATUS_SUCCESS;
    Iosb.Information = FILE_OPENED;

    DebugTrace(-1, Dbg, "NpOpenNamedPipeRootDirectory -> Iosb.Status = %08lx\n", Iosb.Status);

    //
    //  And return to our caller
    //

    return Iosb;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\mup\wml\km\wmlkm.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    cldskwmi.c

Abstract:

    km wmi tracing code. 
    
    Will be shared between our drivers.

Authors:

    GorN     10-Aug-1999

Environment:

    kernel mode only

Notes:

Revision History:

Comments:

	This code is a quick hack to enable WMI tracing in cluster drivers.
	It should eventually go away.

	WmlTinySystemControl will be replaced with WmilibSystemControl from wmilib.sys .

	WmlTrace or equivalent will be added to the kernel in addition to IoWMIWriteEvent(&TraceBuffer);

--*/
#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "stdio.h"

#include <wmistr.h>
#include <evntrace.h>

#include "wmlkm.h"

BOOLEAN
WmlpFindGuid(
    IN PWML_CONTROL_GUID_REG GuidList,
    IN ULONG GuidCount,
    IN LPGUID Guid,
    OUT PULONG GuidIndex
    )
/*++

Routine Description:

    This routine will search the list of guids registered and return
    the index for the one that was registered.

Arguments:

    GuidList is the list of guids to search

    GuidCount is the count of guids in the list

    Guid is the guid being searched for

    *GuidIndex returns the index to the guid
        
Return Value:

    TRUE if guid is found else FALSE

--*/
{
    ULONG i;

    for (i = 0; i < GuidCount; i++)
    {
        if (IsEqualGUID(Guid, &GuidList[i].Guid))
        {
            *GuidIndex = i;
            return(TRUE);
        }
    }

    return(FALSE);
}


NTSTATUS
WmlTinySystemControl(
    IN OUT PWML_TINY_INFO WmiLibInfo,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Dispatch routine for IRP_MJ_SYSTEM_CONTROL. This routine will process
    all wmi requests received, forwarding them if they are not for this
    driver or determining if the guid is valid and if so passing it to
    the driver specific function for handing wmi requests.

Arguments:

    WmiLibInfo has the WMI information control block

    DeviceObject - Supplies a pointer to the device object for this request.

    Irp - Supplies the Irp making the request.

Return Value:

    status

--*/

{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    ULONG bufferSize;
    PUCHAR buffer;
    NTSTATUS status;
    ULONG retSize;
    UCHAR minorFunction;
    ULONG guidIndex;
    ULONG instanceCount;
    ULONG instanceIndex;

    //
    // If the irp is not a WMI irp or it is not targetted at this device
    // or this device has not regstered with WMI then just forward it on.
    minorFunction = irpStack->MinorFunction;
    if ((minorFunction > IRP_MN_EXECUTE_METHOD) ||
        (irpStack->Parameters.WMI.ProviderId != (ULONG_PTR)DeviceObject) ||
        ((minorFunction != IRP_MN_REGINFO) &&
         (WmiLibInfo->GuidCount == 0) || (WmiLibInfo->ControlGuids == NULL) ))
    {
        //
        // IRP is not for us so forward if there is a lower device object
        if (WmiLibInfo->LowerDeviceObject != NULL)
        {
            IoSkipCurrentIrpStackLocation(Irp);
            return(IoCallDriver(WmiLibInfo->LowerDeviceObject, Irp));
        } else {
            status = STATUS_INVALID_DEVICE_REQUEST;
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return(status);
        }
    }

    buffer = (PUCHAR)irpStack->Parameters.WMI.Buffer;
    bufferSize = irpStack->Parameters.WMI.BufferSize;

    if (minorFunction != IRP_MN_REGINFO)
    {
        //
        // For all requests other than query registration info we are passed
        // a guid. Determine if the guid is one that is supported by the
        // device.
        if (WmlpFindGuid(WmiLibInfo->ControlGuids,
                            WmiLibInfo->GuidCount,
                            (LPGUID)irpStack->Parameters.WMI.DataPath,
                            &guidIndex) )
        {
            status = STATUS_SUCCESS;
        } else {
            status = STATUS_WMI_GUID_NOT_FOUND;
        }

        if (!NT_SUCCESS(status))
        {
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return(status);
        }
    }

    switch(minorFunction)
    {
        case IRP_MN_REGINFO:
        {
            ULONG guidCount;
            PWML_CONTROL_GUID_REG guidList;
            PWMIREGINFOW wmiRegInfo;
            PWMIREGGUIDW wmiRegGuid;
            PDEVICE_OBJECT pdo;
            PUNICODE_STRING regPath;
            PWCHAR stringPtr;
            ULONG registryPathOffset;
            ULONG bufferNeeded;
            ULONG i;
            UNICODE_STRING nullRegistryPath;

            regPath = WmiLibInfo->DriverRegPath;
            guidList = WmiLibInfo->ControlGuids;
            guidCount = WmiLibInfo->GuidCount;

            if (regPath == NULL)
            {
                // No registry path specified. This is a bad thing for 
                // the device to do, but is not fatal
                nullRegistryPath.Buffer = NULL;
                nullRegistryPath.Length = 0;
                nullRegistryPath.MaximumLength = 0;
                regPath = &nullRegistryPath;
            }                
            
            registryPathOffset = FIELD_OFFSET(WMIREGINFOW, WmiRegGuid) +
                                  guidCount * sizeof(WMIREGGUIDW);

            bufferNeeded = registryPathOffset +
                regPath->Length + sizeof(USHORT);

            if (bufferNeeded <= bufferSize)
            {
                retSize = bufferNeeded;
                RtlZeroMemory(buffer, bufferNeeded);

                wmiRegInfo = (PWMIREGINFO)buffer;
                wmiRegInfo->BufferSize = bufferNeeded;
                // wmiRegInfo->NextWmiRegInfo = 0;
                // wmiRegInfo->MofResourceName = 0;
                wmiRegInfo->RegistryPath = registryPathOffset;
                wmiRegInfo->GuidCount = guidCount;

                for (i = 0; i < guidCount; i++)
                {
                    wmiRegGuid = &wmiRegInfo->WmiRegGuid[i];
                    wmiRegGuid->Guid = guidList[i].Guid;
                    wmiRegGuid->Flags = WMIREG_FLAG_TRACED_GUID | WMIREG_FLAG_TRACE_CONTROL_GUID;
                    // wmiRegGuid->InstanceInfo = 0;
                    // wmiRegGuid->InstanceCount = 0;
                }

                stringPtr = (PWCHAR)((PUCHAR)buffer + registryPathOffset);
                *stringPtr++ = regPath->Length;
                RtlCopyMemory(stringPtr,
                          regPath->Buffer,
                          regPath->Length);
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_BUFFER_TOO_SMALL;
                *((PULONG)buffer) = bufferNeeded;
                retSize = sizeof(ULONG);
            }

            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = retSize;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return(status);
        }

        case IRP_MN_ENABLE_EVENTS:
        case IRP_MN_DISABLE_EVENTS:
        {
            PWNODE_HEADER   Wnode = irpStack->Parameters.WMI.Buffer;
            PWML_CONTROL_GUID_REG Ctx = WmiLibInfo->ControlGuids + guidIndex;
            if (irpStack->Parameters.WMI.BufferSize >= sizeof(WNODE_HEADER)) {
                status = STATUS_SUCCESS;

                if (minorFunction == IRP_MN_DISABLE_EVENTS) {
                    Ctx->EnableLevel = 0;
                    Ctx->EnableFlags = 0;
                } else {
                    Ctx->LoggerHandle = (TRACEHANDLE)( Wnode->HistoricalContext );
                    
                    Ctx->EnableLevel = WmiGetLoggerEnableLevel(Ctx->LoggerHandle);
                    Ctx->EnableFlags = WmiGetLoggerEnableFlags(Ctx->LoggerHandle);
                }
            } else {
                status = STATUS_INVALID_PARAMETER;
            }

            break;
        }

        case IRP_MN_ENABLE_COLLECTION:
        case IRP_MN_DISABLE_COLLECTION:
        {
            status = STATUS_SUCCESS;
            break;
        }

        case IRP_MN_QUERY_ALL_DATA:
        case IRP_MN_QUERY_SINGLE_INSTANCE:
        case IRP_MN_CHANGE_SINGLE_INSTANCE:
        case IRP_MN_CHANGE_SINGLE_ITEM:
        case IRP_MN_EXECUTE_METHOD:
        {
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

        default:
        {
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

    }
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    
    return(status);
}

#define MAX_SCRATCH_LOG 256

typedef struct _TRACE_BUFFER {
    union {
        EVENT_TRACE_HEADER Trace;
        WNODE_HEADER       Wnode;
    };
    union {
        MOF_FIELD MofFields[MAX_MOF_FIELDS + 1];
        UCHAR     ScratchPad[MAX_SCRATCH_LOG];
    };

} TRACE_BUFFER, *PTRACE_BUFFER;


//////////////////////////////////////////////////////////////////////
//  0  | Size      | ProviderId  |   0  |Size.HT.Mk | Typ.Lev.Version|
//  2  | L o g g e r H a n d l e |   2  |    T h r e a d   I d       |
//  4  | T i m e  S t a m p      |   4  |    T i m e  S t a m p      |
//  6  |    G U I D    L o w     |   6  |    GUID Ptr / Guid L o w   |
//  8  |    G U I D    H I g h   |   8  |    G U I D    H i g h      |
// 10  | ClientCtx | Flags       |  10  |KernelTime | UserTime       |
//////////////////////////////////////////////////////////////////////

ULONG
WmlTrace(
    IN ULONG Type,
    IN LPCGUID TraceGuid,
    IN TRACEHANDLE LoggerHandle,
    ... // Pairs: Address, Length
    )
{
    TRACE_BUFFER TraceBuffer;

    TraceBuffer.Trace.Version = Type;
    
    TraceBuffer.Wnode.HistoricalContext = LoggerHandle; // [KM]

    TraceBuffer.Trace.Guid = *TraceGuid;

    TraceBuffer.Wnode.Flags = 
        WNODE_FLAG_USE_MOF_PTR  | // MOF data are dereferenced
        WNODE_FLAG_TRACED_GUID;   // Trace Event, not a WMI event

    {
        PMOF_FIELD   ptr = TraceBuffer.MofFields;
        va_list      ap;

        va_start(ap, LoggerHandle);
        do {
            if ( 0 == (ptr->Length = (ULONG)va_arg (ap, size_t)) )  {
                break;
            }
            ptr->DataPtr = (ULONGLONG)va_arg(ap, PVOID);
        } while ( ++ptr < &TraceBuffer.MofFields[MAX_MOF_FIELDS] );
        va_end(ap);

        TraceBuffer.Wnode.BufferSize = (ULONG) ((ULONG_PTR)ptr - (ULONG_PTR)&TraceBuffer);
    }
    
    IoWMIWriteEvent(&TraceBuffer); // [KM]
    return STATUS_SUCCESS;
}


ULONG
WmlPrintf(
    IN ULONG Type,
    IN LPCGUID TraceGuid,
    IN TRACEHANDLE LoggerHandle,
    IN PCHAR FormatString,
    ... // printf var args
    )
{
    TRACE_BUFFER TraceBuffer;
    va_list ArgList;
    ULONG Length;

    TraceBuffer.Trace.Version = Type;
    
    TraceBuffer.Wnode.HistoricalContext = LoggerHandle; // [KM]

    TraceBuffer.Trace.Guid = *TraceGuid;

    TraceBuffer.Wnode.Flags = 
        WNODE_FLAG_TRACED_GUID;   // Trace Event, not a WMI event

    va_start(ArgList, FormatString);
    Length = _vsnprintf(TraceBuffer.ScratchPad, MAX_SCRATCH_LOG, FormatString, ArgList);
    TraceBuffer.ScratchPad[Length] = 0;
    va_end(ArgList);


    TraceBuffer.Wnode.BufferSize = 
        (ULONG) ((ULONG_PTR)(TraceBuffer.ScratchPad + Length) - (ULONG_PTR)&TraceBuffer);
    
    IoWMIWriteEvent(&TraceBuffer); // [KM]
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\npfs\aliassup.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    AliasSup.c

Abstract:

    This module implements alias support for the Named Pipe file system.

Author:

    Chuck Lenzmeier [chuckl]    16-Nov-1993

Revision History:

--*/

#include "NpProcs.h"

//
// Registry path (relative to Services key) to alias list
//

#define ALIAS_PATH L"Npfs\\Aliases"

//
//  The Alias record defines an aliased pipe name -- what the original
//  name is, and what it should be translated to.  Alias records are
//  linked together in singly linked lists.
//

typedef struct _ALIAS {
    SINGLE_LIST_ENTRY ListEntry;
    PUNICODE_STRING TranslationString;
    UNICODE_STRING AliasString;
} ALIAS, *PALIAS;

//
//  ALIAS_CONTEXT is used during initialization to pass context to the
//  ReadAlias routine, which is called by RtlQueryRegistryValues.
//

typedef struct _ALIAS_CONTEXT {
    BOOLEAN Phase1;
    ULONG RequiredSize;
    ULONG AliasCount;
    ULONG TranslationCount;
    PALIAS NextAlias;
    PUNICODE_STRING NextTranslation;
    PWCH NextStringData;
} ALIAS_CONTEXT, *PALIAS_CONTEXT;

//
//  Forward declarations.
//

NTSTATUS
NpReadAlias (
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, NpInitializeAliases)
#pragma alloc_text(INIT, NpReadAlias)
#pragma alloc_text(PAGE, NpTranslateAlias)
#pragma alloc_text(PAGE, NpUninitializeAliases)
#endif


NTSTATUS
NpInitializeAliases (
    VOID
    )

/*++

Routine Description:

    This routine initializes the alias package.  It reads the registry,
    builds the alias list, and sorts it.

Arguments:

    None.

Return Value:

    NTSTATUS - Returns an error if the contents of the registry contents
        are invalid or if an allocation fails.

--*/

{
    RTL_QUERY_REGISTRY_TABLE QueryTable[2];
    ALIAS_CONTEXT Context;
    NTSTATUS Status;
    PALIAS Alias;
    ULONG i;
    ULONG Length;
    PSINGLE_LIST_ENTRY PreviousEntry;
    PSINGLE_LIST_ENTRY Entry;
    PALIAS TestAlias;

    //
    //  Phase 1:  Calculate number of aliases and size of alias buffer.
    //

    QueryTable[0].QueryRoutine = NpReadAlias;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_NOEXPAND;
    QueryTable[0].Name = NULL;
    QueryTable[0].EntryContext = NULL;
    QueryTable[0].DefaultType = REG_NONE;
    QueryTable[0].DefaultData = NULL;
    QueryTable[0].DefaultLength = 0;

    QueryTable[1].QueryRoutine = NULL;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = NULL;

    Context.Phase1 = TRUE;
    Context.RequiredSize = 0;
    Context.AliasCount = 0;
    Context.TranslationCount = 0;

    Status = RtlQueryRegistryValues(
                RTL_REGISTRY_SERVICES | RTL_REGISTRY_OPTIONAL,
                ALIAS_PATH,
                QueryTable,
                &Context,
                NULL
                );

    //
    //  If an error occurred, return that error, unless the alias
    //  key wasn't present, which is not an error.  Also, if the key
    //  was there, but was empty, this is not an error.
    //

    if (!NT_SUCCESS(Status)) {
        if ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {
            Status = STATUS_SUCCESS;
        }
        return Status;
    }

    if (Context.RequiredSize == 0) {
        return STATUS_SUCCESS;
    }

    //
    //  Allocate a buffer to hold the alias information.
    //

    NpAliases = NpAllocateNonPagedPool( Context.RequiredSize, 'sfpN');
    if (NpAliases == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  Phase 2:  Read alias information into the alias buffer.
    //

    Context.Phase1 = FALSE;
    Context.NextTranslation = (PUNICODE_STRING)NpAliases;
    Alias = Context.NextAlias =
                (PALIAS)(Context.NextTranslation + Context.TranslationCount);
    Context.NextStringData = (PWCH)(Context.NextAlias + Context.AliasCount);

    Status = RtlQueryRegistryValues(
                RTL_REGISTRY_SERVICES | RTL_REGISTRY_OPTIONAL,
                ALIAS_PATH,
                QueryTable,
                &Context,
                NULL
                );
    if (!NT_SUCCESS(Status)) {
        NpFreePool( NpAliases );
        NpAliases = NULL;
        return Status;
    }

    //
    //  Phase 3:  Link aliases into alias lists.
    //

    for ( i = 0;
          i < Context.AliasCount;
          i++, Alias++ ) {

        //
        //  Point to the appropriate list head.
        //

        Length = Alias->AliasString.Length;
        if ( (Length >= MIN_LENGTH_ALIAS_ARRAY) &&
             (Length <= MAX_LENGTH_ALIAS_ARRAY) ) {
            PreviousEntry = &NpAliasListByLength[(Length - MIN_LENGTH_ALIAS_ARRAY) / sizeof(WCHAR)];
        } else {
            PreviousEntry = &NpAliasList;
        }

        //
        //  Walk the list to determine the proper place for this alias.
        //

        for ( Entry = PreviousEntry->Next;
              Entry != NULL;
              PreviousEntry = Entry, Entry = Entry->Next ) {

            TestAlias = CONTAINING_RECORD( Entry, ALIAS, ListEntry );

            //
            //  If the test alias is longer than the new alias, we want to
            //  insert the new alias in front of the test alias.  If the
            //  test alias is shorter, we need to continue walking the list.
            //

            if ( TestAlias->AliasString.Length > Length ) break;
            if ( TestAlias->AliasString.Length < Length ) continue;

            //
            //  The aliases are the same length.  Compare them.  If the new
            //  alias is lexically before the test alias, we want to insert
            //  it in front of the test alias.  If it's after, we need to
            //  keep walking.
            //
            //  Alias and TestAlias should never have the same string, but
            //  if they do, we'll insert the second occurrence of the string
            //  immediately after the first one, and all will be well.
            //

            if ( _wcsicmp( Alias->AliasString.Buffer,
                          TestAlias->AliasString.Buffer ) < 0 ) {
                break;
            }

        }

        //
        //  We have found the place where this alias belongs.  PreviousEntry
        //  points to the alias that the new alias should follow.
        //  (PreviousEntry may point to the list head.)
        //

        Alias->ListEntry.Next = PreviousEntry->Next;
        PreviousEntry->Next = &Alias->ListEntry;

    }

#if 0
    for ( Length = MIN_LENGTH_ALIAS_ARRAY;
          Length <= MAX_LENGTH_ALIAS_ARRAY + 2;
          Length += 2 ) {
        if ( (Length >= MIN_LENGTH_ALIAS_ARRAY) &&
             (Length <= MAX_LENGTH_ALIAS_ARRAY) ) {
            PreviousEntry = &NpAliasListByLength[(Length - MIN_LENGTH_ALIAS_ARRAY) / sizeof(WCHAR)];
            DbgPrint( "Length %d list:\n", Length );
        } else {
            PreviousEntry = &NpAliasList;
            DbgPrint( "Odd length list:\n" );
        }
        for ( Entry = PreviousEntry->Next;
              Entry != NULL;
              Entry = Entry->Next ) {
            Alias = CONTAINING_RECORD( Entry, ALIAS, ListEntry );
            DbgPrint( "  %wZ -> %wZ\n", &Alias->AliasString, Alias->TranslationString );
        }
    }
#endif

    return STATUS_SUCCESS;

}


NTSTATUS
NpReadAlias (
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
{
    PALIAS_CONTEXT Ctx = Context;
    USHORT Length;
    PWCH p;
    PUNICODE_STRING TranslationString;
    PALIAS Alias;

    //
    //  The value must be a REG_MULTI_SZ value.
    //

    if (ValueType != REG_MULTI_SZ) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  In phase 1, we calculate the required size of the alias buffer.
    //  In phase 2, we build the alias descriptors.
    //

    if ( Ctx->Phase1 ) {

        //
        //  The value name is the translation.  The value data is one or
        //  more strings that are aliases for the translation.
        //
        //  The "1+" and "sizeof(WCHAR)+" are for the '\' that will be
        //  placed in front of the translation string and the alias string.
        //

        Ctx->TranslationCount++;
        Length = (USHORT)((1 + wcslen(ValueName) + 1) * sizeof(WCHAR));
        Ctx->RequiredSize += Length + sizeof(UNICODE_STRING);

        p = ValueData;
        while ( *p != 0 ) {
            Ctx->AliasCount++;
            Length = (USHORT)((wcslen(p) + 1) * sizeof(WCHAR));
            Ctx->RequiredSize += sizeof(WCHAR) + Length + sizeof(ALIAS);
            p = (PWCH)((PCHAR)p + Length);
        }

    } else {

        //
        //  Build a string descriptor for the translation string.
        //

        TranslationString = Ctx->NextTranslation++;
        Length = (USHORT)((1 + wcslen(ValueName) + 1) * sizeof(WCHAR));
        TranslationString->Length = Length - sizeof(WCHAR);
        TranslationString->MaximumLength = Length;
        TranslationString->Buffer = Ctx->NextStringData;
        Ctx->NextStringData = (PWCH)((PCHAR)Ctx->NextStringData + Length);

        //
        //  Copy the string data.  Place a '\' at the beginning.
        //

        TranslationString->Buffer[0] = L'\\';
        RtlCopyMemory( &TranslationString->Buffer[1],
                       ValueName,
                       Length - sizeof(WCHAR) );

        //
        //  Upcase the string.
        //

        RtlUpcaseUnicodeString( TranslationString,
                                TranslationString,
                                FALSE );
        //
        //  Build aliases descriptors.
        //

        p = ValueData;

        while ( *p != 0 ) {

            Alias = Ctx->NextAlias++;

            //
            //  Point the alias descriptor to the translation string.
            //

            Alias->TranslationString = TranslationString;

            //
            //  Build the alias string descriptor.
            //

            Length = (USHORT)((1 + wcslen(p) + 1) * sizeof(WCHAR));
            Alias->AliasString.Length = Length - sizeof(WCHAR);
            Alias->AliasString.MaximumLength = Length;
            Alias->AliasString.Buffer = Ctx->NextStringData;
            Ctx->NextStringData = (PWCH)((PCHAR)Ctx->NextStringData + Length);

            //
            //  Copy the string data.  Place a '\' at the beginning.
            //

            Alias->AliasString.Buffer[0] = L'\\';
            RtlCopyMemory( &Alias->AliasString.Buffer[1],
                           p,
                           Length - sizeof(WCHAR) );

            //
            //  Upcase the string.
            //

            RtlUpcaseUnicodeString( &Alias->AliasString,
                                    &Alias->AliasString,
                                    FALSE );

            p = (PWCH)((PCHAR)p + Length - sizeof(WCHAR));

        }

    }

    return STATUS_SUCCESS;

}


NTSTATUS
NpTranslateAlias (
    IN OUT PUNICODE_STRING String
    )

/*++

Routine Description:

    This routine translates a pipe name string based on information
    obtained from the registry at boot time.  This translation is used
    to allow RPC services that had different names in NT 1.0 to have
    common names in 1.0a and beyond.

Arguments:

    String - Supplies the input string to search for; returns the output
        string, if the name was translated.  If so, the string points to
        a buffer allocated from paged pool.  The caller should NOT free
        this buffer.

Return Value:

    NTSTATUS - Returns STATUS_SUCCESS unless an allocation failure occurs.
        The status does NOT indicate whether the name was translated.

--*/

{
    NTSTATUS Status;
    UNICODE_STRING UpcaseString;
    ULONG Length;
    PSINGLE_LIST_ENTRY Entry;
    PALIAS Alias;
    PWCH sp, ap;
    WCHAR a, s;
    BOOLEAN NoSlash;

    WCHAR UpcaseBuffer[MAX_LENGTH_ALIAS_ARRAY];
    BOOLEAN FreeUpcaseBuffer;

    PAGED_CODE();

    //
    //  Before upcasing the string (a relatively expensive operation),
    //  make sure that the string length matches at least one alias.
    //

    Length = String->Length;
    if ( Length == 0 ) {
        return STATUS_SUCCESS;
    }

    if ( *String->Buffer != L'\\' ) {
        Length += sizeof(WCHAR);
        NoSlash = TRUE;
    } else {
        NoSlash = FALSE;
    }

    if ( (Length >= MIN_LENGTH_ALIAS_ARRAY) &&
         (Length <= MAX_LENGTH_ALIAS_ARRAY) ) {
        Entry = NpAliasListByLength[(Length - MIN_LENGTH_ALIAS_ARRAY) / sizeof(WCHAR)].Next;
        Alias = CONTAINING_RECORD( Entry, ALIAS, ListEntry );
    } else {
        Entry = NpAliasList.Next;
        while ( Entry != NULL ) {
            Alias = CONTAINING_RECORD( Entry, ALIAS, ListEntry );
            if ( Alias->AliasString.Length == Length ) {
                break;
            }
            if ( Alias->AliasString.Length > Length ) {
                return STATUS_SUCCESS;
            }
            Entry = Entry->Next;
        }
    }

    if ( Entry == NULL ) {
        return STATUS_SUCCESS;
    }

    //
    //  The string's length matches at least one alias.  Upcase the string.
    //

    if ( Length <= MAX_LENGTH_ALIAS_ARRAY ) {
        UpcaseString.MaximumLength = MAX_LENGTH_ALIAS_ARRAY;
        UpcaseString.Buffer = UpcaseBuffer;
        Status = RtlUpcaseUnicodeString( &UpcaseString, String, FALSE );
        ASSERT( NT_SUCCESS(Status) );
        FreeUpcaseBuffer = FALSE;
    } else {
        Status = RtlUpcaseUnicodeString( &UpcaseString, String, TRUE );
        if ( !NT_SUCCESS(Status) ) {
            return Status;
        }
        FreeUpcaseBuffer = TRUE;
    }

    ASSERT( UpcaseString.Length == (Length - (NoSlash ? sizeof(WCHAR) : 0)) );

    //
    //  At this point, Entry points to an alias list entry whose length
    //  matches that of the input string.  This list entry may be the
    //  first element of a length-specific list (in which all entries
    //  have the same length), or it may be an element of a length-ordered
    //  list (in which case we'll need to check each next entry to see if
    //  it's the same length.  In both cases, strings of the same length
    //  are in lexical order.
    //
    //  Try to match the upcased string up to an alias.
    //

    do {

        sp = UpcaseString.Buffer;
        ap = Alias->AliasString.Buffer;
        if ( NoSlash ) {
            ap++;
        }

        while ( TRUE ) {
            a = *ap;
            if ( a == 0 ) {
                *String = *Alias->TranslationString;
                if ( NoSlash ) {
                    String->Length -= sizeof(WCHAR);
                    String->Buffer++;
                }
                goto exit;
            }
            s = *sp;
            if ( s < a ) goto exit;
            if ( s > a ) break;
            sp++;
            ap++;
        }

        //
        //  The input string doesn't match the current alias.  Move to
        //  the next one.
        //

        Entry = Entry->Next;
        if ( Entry == NULL ) {
            goto exit;
        }

        Alias = CONTAINING_RECORD( Entry, ALIAS, ListEntry );

    } while ( Alias->AliasString.Length == Length );

exit:

    if (FreeUpcaseBuffer) {
        ASSERT( UpcaseString.Buffer != UpcaseBuffer );
        NpFreePool( UpcaseString.Buffer );
    }

    return STATUS_SUCCESS;

}

VOID
NpUninitializeAliases (
    VOID
    )

/*++

Routine Description:

    This routine uninitializes the alias package.

Arguments:

    None.

Return Value:

    None

--*/
{
    NpFreePool( NpAliases );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\npfs\datasup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    DataSup.c

Abstract:

    This module implements the Named Pipe data queue support routines.

Author:

    Gary Kimura     [GaryKi]    30-Aug-1990

Revision History:

--*/

#include "NpProcs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_DATASUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NpGetNextRealDataQueueEntry)
#pragma alloc_text(PAGE, NpInitializeDataQueue)
#pragma alloc_text(PAGE, NpUninitializeDataQueue)
#pragma alloc_text(PAGE, NpAddDataQueueEntry)
#pragma alloc_text(PAGE, NpCompleteStalledWrites)
#pragma alloc_text(PAGE, NpRemoveDataQueueEntry)
#endif

//
//  The following macro is used to dump a data queue
//

#define DumpDataQueue(S,P) {                   \
    ULONG NpDumpDataQueue(IN PDATA_QUEUE Ptr); \
    DebugTrace(0,Dbg,S,0);                     \
    DebugTrace(0,Dbg,"", NpDumpDataQueue(P));  \
}

//
//  This is a debugging aid
//

_inline BOOLEAN
NpfsVerifyDataQueue( IN ULONG Line, IN PDATA_QUEUE DataQueue ) {
    PDATA_ENTRY Entry;
    ULONG BytesInQueue = 0;
    ULONG EntriesInQueue = 0;
    for (Entry = (PDATA_ENTRY)DataQueue->Queue.Flink;
         Entry != (PDATA_ENTRY)&DataQueue->Queue;
         Entry = (PDATA_ENTRY)Entry->Queue.Flink) {
        BytesInQueue += Entry->DataSize;
        EntriesInQueue += 1;
    }
    if ((DataQueue->EntriesInQueue != EntriesInQueue) ||
        (DataQueue->BytesInQueue != BytesInQueue)) {
        DbgPrint("%d DataQueue is illformed %08lx %x %x\n", Line, DataQueue, BytesInQueue, EntriesInQueue);
        DbgBreakPoint();
        return FALSE;
    }
    return TRUE;
}


VOID
NpCancelDataQueueIrp (
    IN PDEVICE_OBJECT DevictObject,
    IN PIRP Irp
    );



NTSTATUS
NpInitializeDataQueue (
    IN PDATA_QUEUE DataQueue,
    IN ULONG Quota
    )

/*++

Routine Description:

    This routine initializes a new data queue.  The indicated quota is taken
    from the process and not returned until the data queue is uninitialized.

Arguments:

    DataQueue - Supplies the data queue being initialized

    Process - Supplies a pointer to the process creating the named pipe

    Quota - Supplies the quota to assign to the data queue

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpInitializeDataQueue, DataQueue = %08lx\n", DataQueue);

    //
    //  Now we can initialize the data queue structure
    //

    DataQueue->QueueState     = Empty;
    DataQueue->BytesInQueue   = 0;
    DataQueue->EntriesInQueue = 0;
    DataQueue->Quota          = Quota;
    DataQueue->QuotaUsed      = 0;
    InitializeListHead (&DataQueue->Queue);
    DataQueue->NextByteOffset = 0;

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "NpInitializeDataQueue -> VOID\n", 0);

    return STATUS_SUCCESS;
}


VOID
NpUninitializeDataQueue (
    IN PDATA_QUEUE DataQueue
    )

/*++

Routine Description:

    This routine uninitializes a data queue.  The previously debited quota
    is returned to the process.

Arguments:

    DataQueue - Supplies the data queue being uninitialized

    Process - Supplies a pointer to the process who created the named pipe

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpUninitializeDataQueue, DataQueue = %08lx\n", DataQueue);

    //
    //  Assert that the queue is empty
    //

    ASSERT( DataQueue->QueueState == Empty );


    //
    //  Then for safety sake we'll zero out the data queue structure
    //

    RtlZeroMemory( DataQueue, sizeof(DATA_QUEUE ) );

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "NpUnininializeDataQueue -> VOID\n", 0);

    return;
}


NTSTATUS
NpAddDataQueueEntry (
    IN NAMED_PIPE_END NamedPipeEnd,
    IN PCCB Ccb,
    IN PDATA_QUEUE DataQueue,
    IN QUEUE_STATE Who,
    IN DATA_ENTRY_TYPE Type,
    IN ULONG DataSize,
    IN PIRP Irp OPTIONAL,
    IN PVOID DataPointer OPTIONAL,
    IN ULONG ByteOffset
    )

/*++

Routine Description:

    This routine adds a new data entry to the end of the data queue.
    If necessary it will allocate a data entry buffer, or use space in
    the IRP, and possibly complete the indicated IRP.

    The different actions we are perform are based on the type and who
    parameters and quota requirements.

    Type == Internal (i.e, Unbuffered)

        +------+                          - Allocate Data Entry from Irp
        |Irp   |    +----------+
        |      |<---|Unbuffered|          - Reference Irp
        +------+    |InIrp     |
          |         +----------+          - Use system buffer from Irp
          v           |
        +------+      |
        |System|<-----+
        |Buffer|
        +------+

    Type == Buffered && Who == ReadEntries

        +----------+                      - Allocate Data Entry from Irp
        |Irp       |     +-----------+
        |BufferedIo|<----|Buffered   |    - Allocate New System buffer
        |DeallBu...|     |EitherQuota|
        +----------+     +-----------+    - Reference and modify Irp to
          |      |         |                do Buffered I/O, Deallocate
          v      |         v                buffer, and have io completion
        +------+ +------>+------+           copy the buffer (Input operation)
        |User  |         |System|
        |Buffer|         |Buffer|
        +------+         +------+

    Type == Buffered && Who == WriteEntries && PipeQuota Available

        +----------+                      - Allocate Data Entry from Quota
        |Irp       |     +-----------+
        |          |     |Buffered   |    - Allocate New System buffer
        |          |     |PipeQuota  |
        +----------+     +-----------+    - Copy data from User buffer to
          |                |                system buffer
          v                v
        +------+         +------+         - Complete Irp
        |User  |..copy..>|System|
        |Buffer|         |Buffer|
        +------+         +------+

    Type == Buffered && Who == WriteEntries && PipeQuota Not Available

        +----------+                     - Allocate Data Entry from Irp
        |Irp       |     +-----------+
        |BufferedIo|<----|Buffered   |   - Allocate New System buffer
        |DeallBuff |     |UserQuota  |
        +----------+     +-----------+   - Reference and modify Irp to use
          |      |         |               the new system buffer, do Buffered
          v      |         v               I/O, and Deallocate buffer
        +------+ +------>+------+
        |User  |         |System|        - Copy data from User buffer to
        |Buffer|..copy..>|Buffer|          system buffer
        +------+         +------+

    Type == Flush or Close

        +----------+                     - Allocate Data Entry from Irp
        |Irp       |     +-----------+
        |          |<----|Buffered   |   - Reference the Irp
        |          |     |UserQuota  |
        +----------+     +-----------+

Arguments:

    DataQueue - Supplies the Data queue being modified

    Who - Indicates if this is the reader or writer that is adding to the pipe

    Type - Indicates the type of entry to add to the data queue

    DataSize - Indicates the size of the data buffer needed to represent
        this entry

    Irp - Supplies a pointer to the Irp responsible for this entry
        The irp is only optional for buffered write with available pipe quota

    DataPointer - If the Irp is not supplied then this field points to the
        user's write buffer.

    ByteOffset - Part of this buffer satisfied a read. Use this as the initial offset

Return Value:

    PDATA_ENTRY - Returns a pointer to the newly added data entry

--*/

{
    PDATA_ENTRY DataEntry;
    PVOID DataBuffer;
    ULONG TotalSize;
    ULONG QuotaCharged;
    NTSTATUS status;
    PSECURITY_CLIENT_CONTEXT SecurityContext = NULL;
    PETHREAD Thread;
    BOOLEAN PendIRP;
    

    ASSERT((DataQueue->QueueState == Empty) || (DataQueue->QueueState == Who));

    DebugTrace(+1, Dbg, "NpAddDataQueueEntry, DataQueue = %08lx\n", DataQueue);

    status = STATUS_SUCCESS;


    //
    // Capture security context if we have to.
    //
    if (Type != Flush && Who == WriteEntries) {
        if (Irp != NULL) {
            Thread = Irp->Tail.Overlay.Thread;
        } else {
            Thread = PsGetCurrentThread ();
        }
        status = NpGetClientSecurityContext (NamedPipeEnd,
                                             Ccb,
                                             Thread,
                                             &SecurityContext);
        if (!NT_SUCCESS (status)) {
            return status;
        }
    }
    //
    //  Case on the type of operation we are doing
    //

    switch (Type) {

    case Unbuffered:
    case Flush:
    case Close:

        ASSERT(ARGUMENT_PRESENT(Irp));

        //
        //  Allocate a data entry for the Irp
        //

        DataEntry  = NpAllocateNonPagedPoolWithQuotaCold (sizeof (DATA_ENTRY), 'rFpN');
        if (DataEntry == NULL) {
            NpFreeClientSecurityContext (SecurityContext);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        DataEntry->DataEntryType = Type;
        DataEntry->QuotaCharged  = 0;
        DataEntry->Irp           = Irp;
        DataEntry->DataSize      = DataSize;

        DataEntry->SecurityClientContext = SecurityContext;

        ASSERT((DataQueue->QueueState == Empty) || (DataQueue->QueueState == Who));
        status = STATUS_PENDING;
        break;

    case Buffered:

        //
        // Allocate a buffer but put the DATA_ENTRY on the end.  We do this
        // so we can free and copy back the data in one chunk in I/O post
        // processing.
        //

        TotalSize = sizeof(DATA_ENTRY);

        if (Who != ReadEntries) {
            TotalSize += DataSize;

            if (TotalSize < DataSize) {

                //
                // DataSize is so large that adding this extra structure and
                // alignment padding causes it to wrap.
                //

                NpFreeClientSecurityContext (SecurityContext);
                return STATUS_INVALID_PARAMETER;
            }
        }

        //
        // Charge the data portion against the named pipe quota if possible and
        // charge the rest against the process.
        //

        if ((DataQueue->Quota - DataQueue->QuotaUsed) >= DataSize - ByteOffset) {
            QuotaCharged = DataSize - ByteOffset;
            PendIRP = FALSE;
        } else {
            QuotaCharged = DataQueue->Quota - DataQueue->QuotaUsed;
            PendIRP = TRUE;
        }

        DataBuffer = NpAllocateNonPagedPoolWithQuotaCold (TotalSize, 'rFpN');
        if (DataBuffer == NULL) {
            NpFreeClientSecurityContext (SecurityContext);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        DataEntry = (PDATA_ENTRY) DataBuffer;
        DataEntry->QuotaCharged          = QuotaCharged;
        DataEntry->Irp                   = Irp;
        DataEntry->DataEntryType         = Buffered;
        DataEntry->SecurityClientContext = SecurityContext;
        DataEntry->DataSize              = DataSize;
        //
        //  Check if this is the reader or writer
        //

        if (Who == ReadEntries) {

            ASSERT(ARGUMENT_PRESENT(Irp));

            status = STATUS_PENDING;

            ASSERT((DataQueue->QueueState == Empty) || (DataQueue->QueueState == Who));

        } else {

            //
            //  This is a writer entry
            //

            //
            //  Safely copy the user buffer to the new system buffer using either
            //  the irp user buffer is supplied of the data pointer we were given
            //

            if (ARGUMENT_PRESENT(Irp)) {
                DataPointer = Irp->UserBuffer;
            }

            try {
                RtlCopyMemory( DataEntry->DataBuffer, (PUCHAR) DataPointer, DataSize );
            } except(EXCEPTION_EXECUTE_HANDLER) {
                NpFreePool (DataBuffer);
                NpFreeClientSecurityContext (SecurityContext);
                return GetExceptionCode ();
            }
            if (PendIRP == FALSE || Irp == NULL) {
                DataEntry->Irp = NULL;
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_PENDING;
            }
            ASSERT((DataQueue->QueueState == Empty) || (DataQueue->QueueState == Who));
        }

        break;

    }

    ASSERT((DataQueue->QueueState == Empty) || (DataQueue->QueueState == Who));

#if DBG
    if (DataQueue->QueueState == Empty) {
        ASSERT (DataQueue->BytesInQueue == 0);
        ASSERT (DataQueue->EntriesInQueue == 0);
        ASSERT (IsListEmpty (&DataQueue->Queue));
    } else {
        ASSERT( DataQueue->QueueState == Who );
        ASSERT( DataQueue->QueueState != Empty );
        ASSERT( DataQueue->EntriesInQueue != 0 );
    }
#endif

    DataQueue->QuotaUsed      += DataEntry->QuotaCharged;
    DataQueue->QueueState      = Who;
    DataQueue->BytesInQueue   += DataEntry->DataSize;
    DataQueue->EntriesInQueue += 1;

    //
    // This handles the case where this write was used to complete some reads already and so we have to start
    // part way into the buffer. Obviously to have been completing reads we must be at the head of the queue.
    // The two cases that did this where on the outside but we call cancel here and that will need to remove
    // this offset.
    //
    if (ByteOffset) {
        DataQueue->NextByteOffset = ByteOffset;
        ASSERT (Who == WriteEntries);
        ASSERT (ByteOffset < DataEntry->DataSize);
        ASSERT (DataQueue->EntriesInQueue == 1);
    }

    InsertTailList (&DataQueue->Queue, &DataEntry->Queue);

    if (status == STATUS_PENDING) {
        IoMarkIrpPending (Irp);
        //
        // Tie the IRP to the DataQueue and DataEntry. We can divorse this link on cancel etc.
        //
        NpIrpDataQueue(Irp) = DataQueue;
        NpIrpDataEntry(Irp) = DataEntry;
        IoSetCancelRoutine( Irp, NpCancelDataQueueIrp );
        if (Irp->Cancel && IoSetCancelRoutine( Irp, NULL ) != NULL) {
            //
            //  Indicate in the first parameter that we're calling the
            //  cancel routine and not the I/O system.  Therefore
            //  the routine won't take out the VCB exclusive.
            //
            NpCancelDataQueueIrp( NULL, Irp );
        }
    }

    //
    //  And return to our caller
    //

    return status;
}

VOID
NpCompleteStalledWrites (
    IN PDATA_QUEUE DataQueue,
    IN PLIST_ENTRY DeferredList
    )
/*++

Routine Description:

    This routine is used to return any quota added back to the pipe to any stalled writes.
    We stall writes becuase there was no room in the pipe for them. If there is now room we can complete them.

Arguments:

    DataQueue - Supplies a pointer to the data queue being modifed

Return Value:

    None

--*/

{
    PLIST_ENTRY Link;
    PDATA_ENTRY DataEntry;
    ULONG ExtraQuota, Needed, ByteOffset;
    PIRP  Irp;

    ExtraQuota = DataQueue->Quota - DataQueue->QuotaUsed;
    ByteOffset = DataQueue->NextByteOffset;
    for (Link = DataQueue->Queue.Flink;
         (Link != &DataQueue->Queue) && (ExtraQuota != 0);
         Link = Link->Flink, ByteOffset = 0) {
        DataEntry = CONTAINING_RECORD (Link, DATA_ENTRY, Queue);
        Irp = DataEntry->Irp;
        if ((DataEntry->DataEntryType != Buffered) || (Irp == NULL)) {
            continue;
        }
        if (DataEntry->QuotaCharged < DataEntry->DataSize - ByteOffset) {
            Needed = DataEntry->DataSize - ByteOffset - DataEntry->QuotaCharged;
            if (Needed > ExtraQuota) {
                Needed = ExtraQuota;
            }
            ExtraQuota -= Needed;
            DataEntry->QuotaCharged += Needed;
            if (DataEntry->QuotaCharged == DataEntry->DataSize - ByteOffset) {
                //
                // Attempt to complete this IRP. If cancel is already running then leave it in
                // place for cancel to sort out.
                //
                if (IoSetCancelRoutine (Irp, NULL) != NULL) {
                    DataEntry->Irp = NULL;
                    Irp->IoStatus.Information = DataEntry->DataSize;
                    NpDeferredCompleteRequest (Irp, STATUS_SUCCESS, DeferredList);
                }
            }
        }
    }
    DataQueue->QuotaUsed = DataQueue->Quota - ExtraQuota;
}


PIRP
NpRemoveDataQueueEntry (
    IN PDATA_QUEUE DataQueue,
    IN BOOLEAN CompletedFlushes,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This routines remove the first entry from the front of the indicated
    data queue, and possibly returns the Irp associated with the entry if
    it wasn't already completed when we did the insert.

    If the data entry we are removing indicates buffered I/O then we also
    need to deallocate the data buffer besides the data entry but only
    if the Irp is null.  Note that the data entry might be stored in an IRP.
    If it is then we are going to return the IRP it is stored in.

Arguments:

    DataQueue - Supplies a pointer to the data queue being modifed

    CompleteFlushes - Specifies if this routine should look to complete pended flushes

    DeferredList - List of IRPs to complete later after we drop the locks

Return Value:

    PIRP - Possibly returns a pointer to an IRP.

--*/

{
    PDATA_ENTRY DataEntry;

    DATA_ENTRY_TYPE DataEntryType;
    PIRP Irp;
    ULONG DataSize;
    PVOID DataPointer;
    PLIST_ENTRY Links;
    PSECURITY_CLIENT_CONTEXT ClientContext;
    QUEUE_STATE Who;
    BOOLEAN DoScan;

    DebugTrace(+1, Dbg, "NpRemoveDataQueueEntry, DataQueue = %08lx\n", DataQueue);

    //
    //  Check if the queue is empty, and if so then we simply return null
    //

    if (DataQueue->QueueState == Empty) {
        ASSERT (IsListEmpty (&DataQueue->Queue));
        ASSERT (DataQueue->EntriesInQueue == 0);
        ASSERT (DataQueue->BytesInQueue == 0);
        ASSERT (DataQueue->QuotaUsed == 0);

        Irp = NULL;

    } else {

        //
        //  Reference the front of the data queue, and remove the entry
        //  from the queue itself.
        //

        Links = (PLIST_ENTRY) RemoveHeadList (&DataQueue->Queue);
        DataEntry = CONTAINING_RECORD (Links, DATA_ENTRY, Queue);

        DataQueue->BytesInQueue   -= DataEntry->DataSize;
        DataQueue->EntriesInQueue -= 1;

        Who = DataQueue->QueueState;
        //
        // If quota was completely used until now and we are adding some back in then we need to look for write
        // IRPs that were blocked becuase of pipe quota.
        //
        if (Who != WriteEntries || DataQueue->QuotaUsed < DataQueue->Quota || DataEntry->QuotaCharged == 0) {
            DoScan = FALSE;
        } else {
            DoScan = TRUE;
        }
        DataQueue->QuotaUsed      -= DataEntry->QuotaCharged;

        //
        //  Now if the queue is empty we need to reset the end of queue and
        //  queue state
        //

        if (IsListEmpty (&DataQueue->Queue)) {
            DataQueue->QueueState = Empty;
            DoScan = FALSE;
        }

        //
        //  Capture some of the fields from the data entry to make our
        //  other references a little easier
        //

        DataEntryType = DataEntry->DataEntryType;
        Irp           = DataEntry->Irp;
        DataSize      = DataEntry->DataSize;
        ClientContext = DataEntry->SecurityClientContext;

        NpFreeClientSecurityContext (ClientContext);


        if (Irp != NULL) {

            //
            // Cancel is alreayd active. Let it complete this IRP.
            //
            if (IoSetCancelRoutine( Irp, NULL ) == NULL) {
                //
                // Divorce this IRP from the data entry so it doesn't clean up
                //
                NpIrpDataEntry(Irp) = NULL;
                Irp = NULL;
            }
        }

        NpFreePool( DataEntry );

        //
        //
        //
        if (CompletedFlushes) {
            NpGetNextRealDataQueueEntry (DataQueue, DeferredList);
        }
        if (DoScan) {
            NpCompleteStalledWrites (DataQueue, DeferredList);
        }
    }

    //
    //  In all cases we'll also zero out the next byte offset.
    //

    DataQueue->NextByteOffset = 0;

    //
    //  And return to our caller
    //

    DumpDataQueue( "After RemoveDataQueueEntry\n", DataQueue );
    DebugTrace(-1, Dbg, "NpRemoveDataQueueEntry -> %08lx\n", Irp);

    return Irp;
}


PDATA_ENTRY
NpGetNextRealDataQueueEntry (
    IN PDATA_QUEUE DataQueue,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This routine will returns a pointer to the next real data queue entry
    in the indicated data queue.  A real entry is either a read or write
    entry (i.e., buffered or unbuffered).  It will complete (as necessary)
    any flush and close Irps that are in the queue until either the queue
    is empty or a real data queue entry is at the front of the queue.

Arguments:

    DataQueue - Supplies a pointer to the data queue being modified

Return Value:

    PDATA_ENTRY - Returns a pointer to the next data queue entry or NULL
        if there isn't any.

--*/

{
    PDATA_ENTRY DataEntry;
    PIRP Irp;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpGetNextRealDataQueueEntry, DataQueue = %08lx\n", DataQueue);

    //
    //  While the next data queue entry at the head of the data queue is not
    //  a real data queue entry we'll dequeue that entry and complete
    //  its corresponding IRP.
    //

    for (DataEntry = NpGetNextDataQueueEntry( DataQueue, NULL);

         (DataEntry != (PDATA_ENTRY) &DataQueue->Queue) &&
         ((DataEntry->DataEntryType != Buffered) &&
          (DataEntry->DataEntryType != Unbuffered));

         DataEntry = NpGetNextDataQueueEntry( DataQueue, NULL)) {

        //
        //  We have a non real data queue entry that needs to be removed
        //  and completed.
        //

        Irp = NpRemoveDataQueueEntry( DataQueue, FALSE, DeferredList );

        if (Irp != NULL) {
            NpDeferredCompleteRequest( Irp, STATUS_SUCCESS, DeferredList );
        }
    }

    //
    //  At this point we either have an empty data queue and data entry is
    //  null, or we have a real data queue entry.  In either case it
    //  is time to return to our caller
    //

    DebugTrace(-1, Dbg, "NpGetNextRealDataQueueEntry -> %08lx\n", DataEntry);

    return DataEntry;
}


//
//  Local support routine
//

VOID
NpCancelDataQueueIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the cancel function for an IRP saved in a
    data queue

Arguments:

    DeviceObject - Generally ignored but the low order bit is a flag indicating
        if we are being called locally (i.e., not from the I/O system) and
        therefore don't need to take out the VCB.

    Irp - Supplies the Irp being cancelled.  A pointer to the data queue
        structure is stored in the information field of the Irp Iosb
        field.

Return Value:

    None.

--*/

{
    PDATA_QUEUE DataQueue;
    PDATA_ENTRY DataEntry;
    PCCB Ccb;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;
    ULONG DataSize;
    PSECURITY_CLIENT_CONTEXT ClientContext;
    QUEUE_STATE Who;
    BOOLEAN AtHead;
    BOOLEAN DoScan;
    LIST_ENTRY DeferredList;


    if (DeviceObject != NULL) {
        IoReleaseCancelSpinLock (Irp->CancelIrql);
    }

    //
    //  The status field is used to store a pointer to the data queue
    //  containing this irp
    //

    InitializeListHead (&DeferredList);

    IrpSp = IoGetCurrentIrpStackLocation (Irp);

    FileObject = IrpSp->FileObject;

    DataQueue = NpIrpDataQueue (Irp);

    ClientContext = NULL;


    if (DeviceObject != NULL) {
        FsRtlEnterFileSystem ();
        NpAcquireExclusiveVcb ();
    }


    DataEntry = NpIrpDataEntry (Irp);
    if (DataEntry != NULL) {
        //
        //  If what we are about to removed is in the front of the queue then we must
        //  reset the next byte offset
        //

        if (DataEntry->Queue.Blink == &DataQueue->Queue) {
            DataQueue->NextByteOffset = 0;
            AtHead = TRUE;
        } else {
            AtHead = FALSE;
        }
        RemoveEntryList (&DataEntry->Queue);
        Who = DataQueue->QueueState;
        //
        //  Capture some of the fields from the data entry to make our
        //  other references a little easier
        //

        DataSize      = DataEntry->DataSize;
        ClientContext = DataEntry->SecurityClientContext;

        //
        // If quota was completely used until now and we are adding some back in then we need to look for write
        // IRPs that were blocked because of pipe quota.
        //
        if (Who != WriteEntries || DataQueue->QuotaUsed < DataQueue->Quota || DataEntry->QuotaCharged == 0) {
            DoScan = FALSE;
        } else {
            DoScan = TRUE;
        }

        //
        //  Return pipe quota for the entry.
        //
        DataQueue->QuotaUsed -= DataEntry->QuotaCharged;

        //
        //  Update the data queue header information
        //
        DataQueue->BytesInQueue   -= DataSize;
        DataQueue->EntriesInQueue -= 1;

        //
        // If the list is now empty then mark it as such. Complete any flushes at queue head as all the
        // requests a head of them have been completed.
        //
        if (IsListEmpty (&DataQueue->Queue)) {
            DataQueue->QueueState = Empty;
            ASSERT (DataQueue->BytesInQueue == 0);
            ASSERT (DataQueue->EntriesInQueue == 0);
            ASSERT (DataQueue->QuotaUsed == 0);
        } else {
            if (AtHead) {
                NpGetNextRealDataQueueEntry (DataQueue, &DeferredList);
            }
            if (DoScan) {
                NpCompleteStalledWrites (DataQueue, &DeferredList);
            }
        }
    }

    if (DeviceObject != NULL) {
        NpReleaseVcb ();
        FsRtlExitFileSystem ();
    }
    //
    //  Finally complete the request saying that it has been cancelled.
    //
    if (DataEntry != NULL) {

        NpFreePool (DataEntry);
    }

    NpFreeClientSecurityContext (ClientContext);

    NpCompleteRequest (Irp, STATUS_CANCELLED);

    NpCompleteDeferredIrps (&DeferredList);

    //
    //  And return to our caller
    //

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\npfs\createnp.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    CreateNp.c

Abstract:

    This module implements the File Create Named Pipe routine for NPFS called
    by the dispatch driver.

Author:

    Gary Kimura     [GaryKi]    04-Sep-1990

Revision History:

--*/

#include "NpProcs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CREATE_NAMED_PIPE)


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NpCreateExistingNamedPipe)
#pragma alloc_text(PAGE, NpCreateNewNamedPipe)
#pragma alloc_text(PAGE, NpFsdCreateNamedPipe)
#endif


NTSTATUS
NpFsdCreateNamedPipe (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for creating/opening a file.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    PFILE_OBJECT FileObject;
    PFILE_OBJECT RelatedFileObject;
    UNICODE_STRING FileName;
    ULONG Options;
    PNAMED_PIPE_CREATE_PARAMETERS Parameters;
    PEPROCESS CreatorProcess;
    BOOLEAN CaseInsensitive = TRUE; //**** Make all searches case insensitive
    PFCB Fcb;
    ULONG CreateDisposition;
    UNICODE_STRING RemainingPart;
    LIST_ENTRY DeferredList;

    PAGED_CODE();

    InitializeListHead (&DeferredList);

    //
    //  Reference our input parameters to make things easier
    //

    IrpSp                = IoGetCurrentIrpStackLocation( Irp );
    FileObject           = IrpSp->FileObject;
    RelatedFileObject    = IrpSp->FileObject->RelatedFileObject;
    FileName             = *(PUNICODE_STRING)&IrpSp->FileObject->FileName;
    Options              = IrpSp->Parameters.CreatePipe.Options;
    Parameters           = IrpSp->Parameters.CreatePipe.Parameters;

    CreatorProcess       = IoGetRequestorProcess( Irp );

    //
    //  Extract the create disposition
    //

    CreateDisposition = (Options >> 24) & 0x000000ff;

    //
    //  Acquire exclusive access to the Vcb.
    //

    FsRtlEnterFileSystem();

    NpAcquireExclusiveVcb();

    //
    //  If there is a related file object then this is a relative open
    //  and it better be the root dcb.  Both the then and the else clause
    //  return an Fcb.
    //

    if (RelatedFileObject != NULL) {

        PDCB Dcb;

        Dcb = RelatedFileObject->FsContext;

        if (NodeType (Dcb) != NPFS_NTC_ROOT_DCB ||
            FileName.Length < 2 || FileName.Buffer[0] == L'\\') {

            DebugTrace(0, Dbg, "Bad file name\n", 0);

            Status = STATUS_OBJECT_NAME_INVALID;
            goto exit_and_cleanup;
        }

        Status = NpFindRelativePrefix (Dcb, &FileName, CaseInsensitive, &RemainingPart, &Fcb);
        if (!NT_SUCCESS (Status)) {
            goto exit_and_cleanup;
        }

    } else {

        //
        //  The only nonrelative name we allow are of the form "\pipe-name"
        //

        if ((FileName.Length <= 2) || (FileName.Buffer[0] != L'\\')) {

            DebugTrace(0, Dbg, "Bad file name\n", 0);

            Status = STATUS_OBJECT_NAME_INVALID;
            goto exit_and_cleanup;
        }

        Fcb = NpFindPrefix (&FileName, CaseInsensitive, &RemainingPart);
    }

    //
    //  If the remaining name is empty then we better have an fcb
    //  otherwise we were given a illegal object name.
    //

    if (RemainingPart.Length == 0) {

        if (Fcb->NodeTypeCode == NPFS_NTC_FCB) {

            DebugTrace(0, Dbg, "Create existing named pipe, Fcb = %08lx\n", Fcb );

            Irp->IoStatus = NpCreateExistingNamedPipe (Fcb,
                                                       FileObject,
                                                       IrpSp->Parameters.CreatePipe.SecurityContext->DesiredAccess,
                                                       IrpSp->Parameters.CreatePipe.SecurityContext->AccessState,
                                                       (KPROCESSOR_MODE)(FlagOn(IrpSp->Flags, SL_FORCE_ACCESS_CHECK) ?
                                                                         UserMode : Irp->RequestorMode),
                                                       CreateDisposition,
                                                       IrpSp->Parameters.CreatePipe.ShareAccess,
                                                       Parameters,
                                                       CreatorProcess,
                                                       &DeferredList);
            Status = Irp->IoStatus.Status;

        } else {

            DebugTrace(0, Dbg, "Illegal object name\n", 0);

            Status = STATUS_OBJECT_NAME_INVALID;
        }

    } else {

        //
        //  The remaining name is not empty so we better have the root Dcb
        //

        if (Fcb->NodeTypeCode == NPFS_NTC_ROOT_DCB) {

            DebugTrace(0, Dbg, "Create new named pipe, Fcb = %08lx\n", Fcb );

            Status = NpCreateNewNamedPipe (Fcb,
                                           FileObject,
                                           FileName,
                                           IrpSp->Parameters.CreatePipe.SecurityContext->DesiredAccess,
                                           IrpSp->Parameters.CreatePipe.SecurityContext->AccessState,
                                           CreateDisposition,
                                           IrpSp->Parameters.CreatePipe.ShareAccess,
                                           Parameters,
                                           CreatorProcess,
                                           &DeferredList,
                                           &Irp->IoStatus);
        } else {

            DebugTrace(0, Dbg, "Illegal object name\n", 0);

            Status = STATUS_OBJECT_NAME_INVALID;
        }
    }

exit_and_cleanup:

    NpReleaseVcb ();

    //
    // complete any deferred IRPs now we have dropped the locks
    //

    NpCompleteDeferredIrps (&DeferredList);

    FsRtlExitFileSystem();

    NpCompleteRequest( Irp, Status );

    return Status;
}


//
//  Internal support routine
//

NTSTATUS
NpCreateNewNamedPipe (
    IN PROOT_DCB RootDcb,
    IN PFILE_OBJECT FileObject,
    IN UNICODE_STRING FileName,
    IN ACCESS_MASK DesiredAccess,
    IN PACCESS_STATE AccessState,
    IN ULONG CreateDisposition,
    IN USHORT ShareAccess,
    IN PNAMED_PIPE_CREATE_PARAMETERS Parameters,
    IN PEPROCESS CreatorProcess,
    IN PLIST_ENTRY DeferredList,
    OUT PIO_STATUS_BLOCK Iosb
    )

/*++

Routine Description:

    This routine performs the operation for creating a new named pipe
    Fcb and its first instance.  This routine does not complete any
    IRP, it preforms its function and then returns an iosb.

Arguments:

    RootDcb - Supplies the root dcb where this is going to be added

    FileObject - Supplies the file object associated with the first
        instance of the named pipe

    FileName - Supplies the name of the named pipe (not qualified i.e.,
        simply "pipe-name" and not "\pipe-name"

    DesiredAccess - Supplies the callers desired access

    AccessState - Supplies the access state from the irp

    CreateDisposition - Supplies the callers create disposition flags

    ShareAccess - Supplies the caller specified share access

    Parameters - Named pipe creation parameters

    CreatorProcess - Supplies the process creating the named pipe

    DeferredList - List of IRP's to complete after we release the locks

Return Value:

    IO_STATUS_BLOCK - Returns the appropriate status for the operation

--*/

{
    NAMED_PIPE_CONFIGURATION NamedPipeConfiguration;
    PSECURITY_DESCRIPTOR NewSecurityDescriptor, CachedSecurityDescriptor;
    NTSTATUS Status;

    PFCB Fcb;
    PCCB Ccb;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpCreateNewNamedPipe\n", 0 );

    //
    //  Check the parameters that must be supplied for a new named pipe
    //  (i.e., the create disposition, timeout, and max instances better
    //  be greater than zero)
    //

    if (!Parameters->TimeoutSpecified || Parameters->MaximumInstances <= 0) {
        Status = STATUS_INVALID_PARAMETER;
        goto exit_and_fill_iosb;
    }

    //
    //  The default timeout needs to be less than zero otherwise it
    //  is an absolute time out which doesn't make sense.
    //
    if (Parameters->DefaultTimeout.QuadPart >= 0) {
        Status = STATUS_INVALID_PARAMETER;
        goto exit_and_fill_iosb;
    }

    if (CreateDisposition == FILE_OPEN) {
        Status = STATUS_OBJECT_NAME_NOT_FOUND;
        goto exit_and_fill_iosb;
    }

    //
    //  Determine the pipe configuration
    //
    if (ShareAccess == (FILE_SHARE_READ | FILE_SHARE_WRITE)) {
        NamedPipeConfiguration = FILE_PIPE_FULL_DUPLEX;
    } else if (ShareAccess == FILE_SHARE_READ) {
        NamedPipeConfiguration = FILE_PIPE_OUTBOUND;
    } else if (ShareAccess == FILE_SHARE_WRITE) {
        NamedPipeConfiguration = FILE_PIPE_INBOUND;
    } else {
        Status = STATUS_INVALID_PARAMETER;
        goto exit_and_fill_iosb;
    }
    //
    //  Check that if named pipe type is byte stream then the read mode is
    //  not message mode
    //
    if ((Parameters->NamedPipeType == FILE_PIPE_BYTE_STREAM_TYPE) &&
        (Parameters->ReadMode == FILE_PIPE_MESSAGE_MODE)) {
        Status = STATUS_INVALID_PARAMETER;
        goto exit_and_fill_iosb;
    }
    //
    //  Create a new fcb and ccb for the named pipe
    //

    Status = NpCreateFcb (RootDcb,
                          &FileName,
                          Parameters->MaximumInstances,
                          Parameters->DefaultTimeout,
                          NamedPipeConfiguration,
                          Parameters->NamedPipeType,
                          &Fcb);
    if (!NT_SUCCESS (Status)) {
        goto exit_and_fill_iosb;
    }

    Status = NpCreateCcb (Fcb,
                          FileObject,
                          FILE_PIPE_LISTENING_STATE,
                          Parameters->ReadMode,
                          Parameters->CompletionMode,
                          Parameters->InboundQuota,
                          Parameters->OutboundQuota,
                          &Ccb);

    if (!NT_SUCCESS (Status)) {
        NpDeleteFcb (Fcb, DeferredList);
        goto exit_and_fill_iosb;
    }

    //
    //  Set the security descriptor in the Fcb
    //

    SeLockSubjectContext (&AccessState->SubjectSecurityContext);

    Status = SeAssignSecurity (NULL,
                               AccessState->SecurityDescriptor,
                               &NewSecurityDescriptor,
                               FALSE,
                               &AccessState->SubjectSecurityContext,
                               IoGetFileObjectGenericMapping(),
                               PagedPool);

    SeUnlockSubjectContext (&AccessState->SubjectSecurityContext);

    if (!NT_SUCCESS (Status)) {

        DebugTrace(0, Dbg, "Error calling SeAssignSecurity\n", 0 );

        NpDeleteCcb (Ccb, DeferredList);
        NpDeleteFcb (Fcb, DeferredList);
        goto exit_and_fill_iosb;
    }

    Status = ObLogSecurityDescriptor (NewSecurityDescriptor,
                                      &CachedSecurityDescriptor,
                                      1);
    NpFreePool (NewSecurityDescriptor);

    if (!NT_SUCCESS (Status)) {

        DebugTrace(0, Dbg, "Error calling ObLogSecurityDescriptor\n", 0 );

        NpDeleteCcb (Ccb, DeferredList);
        NpDeleteFcb (Fcb, DeferredList);
        goto exit_and_fill_iosb;
    }

    Fcb->SecurityDescriptor = CachedSecurityDescriptor;
    //
    //  Set the file object back pointers and our pointer to the
    //  server file object.
    //

    NpSetFileObject (FileObject, Ccb, Ccb->NonpagedCcb, FILE_PIPE_SERVER_END);
    Ccb->FileObject [FILE_PIPE_SERVER_END] = FileObject;

    //
    //  Check to see if we need to notify outstanding Irps for any
    //  changes (i.e., we just added a named pipe).
    //

    NpCheckForNotify (RootDcb, TRUE, DeferredList);

    //
    //  Set our return status
    //

    Iosb->Status = STATUS_SUCCESS;
    Iosb->Information = FILE_CREATED;

    DebugTrace(-1, Dbg, "NpCreateNewNamedPipe -> %08lx\n", Iosb.Status);

    return STATUS_SUCCESS;

exit_and_fill_iosb:

    Iosb->Information = 0;
    Iosb->Status = Status;

    return Status;

}


//
//  Internal support routine
//

IO_STATUS_BLOCK
NpCreateExistingNamedPipe (
    IN PFCB Fcb,
    IN PFILE_OBJECT FileObject,
    IN ACCESS_MASK DesiredAccess,
    IN PACCESS_STATE AccessState,
    IN KPROCESSOR_MODE RequestorMode,
    IN ULONG CreateDisposition,
    IN USHORT ShareAccess,
    IN PNAMED_PIPE_CREATE_PARAMETERS Parameters,
    IN PEPROCESS CreatorProcess,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This routine performs the operation for creating a new instance of
    an existing named pipe.  This routine does not complete any
    IRP, it preforms its function and then returns an iosb.

Arguments:

    Fcb - Supplies the Fcb for the named pipe being created

    FileObject - Supplies the file object associated with this
        instance of the named pipe

    DesiredAccess - Supplies the callers desired access

    CreateDisposition - Supplies the callers create disposition flags

    ShareAccess - Supplies the caller specified share access

    Parameters - Pipe creation parameters

    CreatorProcess - Supplies the process creating the named pipe

    DeferredList - List of IRP's to complete after we release the locks

Return Value:

    IO_STATUS_BLOCK - Returns the appropriate status for the operation

--*/

{
    IO_STATUS_BLOCK Iosb;

    BOOLEAN AccessGranted;
    ACCESS_MASK GrantedAccess;
    UNICODE_STRING Name;

    PCCB Ccb;

    NAMED_PIPE_CONFIGURATION NamedPipeConfiguration;

    USHORT OriginalShareAccess;

    PPRIVILEGE_SET  Privileges = NULL;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpCreateExistingNamedPipe\n", 0 );


    //
    //  To create a new instance of a named pipe the caller
    //  must have "create pipe instance" access.  Even if the
    //  caller didn't explicitly request this access, the call
    //  to us implicitly requests the bit.  So now jam the bit
    //  into the desired access field
    //

    DesiredAccess |= FILE_CREATE_PIPE_INSTANCE;

    //
    //  First do an access check for the user against the Fcb
    //

    SeLockSubjectContext( &AccessState->SubjectSecurityContext );

    AccessGranted = SeAccessCheck( Fcb->SecurityDescriptor,
                                   &AccessState->SubjectSecurityContext,
                                   TRUE,                      // Tokens are locked
                                   DesiredAccess,
                                   0,
                                   &Privileges,
                                   IoGetFileObjectGenericMapping(),
                                   RequestorMode,
                                   &GrantedAccess,
                                   &Iosb.Status );

    if (Privileges != NULL) {

        (VOID) SeAppendPrivileges(
                     AccessState,
                     Privileges
                     );

        SeFreePrivileges( Privileges );
    }

    //
    //  Transfer over the access masks from what is desired to
    //  what we just granted.  Also patch up the maximum allowed
    //  case because we just did the mapping for it.  Note that if
    //  the user didn't ask for maximum allowed then the following
    //  code is still okay because we'll just zero a zero bit.
    //

    if (AccessGranted) {

        AccessState->PreviouslyGrantedAccess |= GrantedAccess;
        AccessState->RemainingDesiredAccess &= ~(GrantedAccess | MAXIMUM_ALLOWED);
    }

    Name.Buffer = L"NamedPipe";
    Name.Length = sizeof (L"NamedPipe") - sizeof (WCHAR);

    SeOpenObjectAuditAlarm( &Name,
                            NULL,
                            &FileObject->FileName,
                            Fcb->SecurityDescriptor,
                            AccessState,
                            FALSE,
                            AccessGranted,
                            RequestorMode,
                            &AccessState->GenerateOnClose );

    SeUnlockSubjectContext( &AccessState->SubjectSecurityContext );

    if (!AccessGranted) {
        DebugTrace(0, Dbg, "Access Denied\n", 0 );
        return Iosb;
    }

    //
    //  Check that we're still under the maximum instances count
    //

    if (Fcb->OpenCount >= Fcb->Specific.Fcb.MaximumInstances) {
        Iosb.Status = STATUS_INSTANCE_NOT_AVAILABLE;
        return Iosb;
    }

    if (CreateDisposition == FILE_CREATE) {
        Iosb.Status = STATUS_ACCESS_DENIED;
        return Iosb;
    }

    //
    //  From the pipe configuration determine the share access specified
    //  on the first instance of this pipe. All subsequent instances must
    //  specify the same share access.
    //

    NamedPipeConfiguration = Fcb->Specific.Fcb.NamedPipeConfiguration;

    if (NamedPipeConfiguration == FILE_PIPE_OUTBOUND) {
        OriginalShareAccess = FILE_SHARE_READ;
    } else if (NamedPipeConfiguration == FILE_PIPE_INBOUND) {
        OriginalShareAccess = FILE_SHARE_WRITE;
    } else {
        OriginalShareAccess = (FILE_SHARE_READ | FILE_SHARE_WRITE);
    }

    if (OriginalShareAccess != ShareAccess) {
        Iosb.Status = STATUS_ACCESS_DENIED;
        return Iosb;
    }

    //
    //  Create a new ccb for the named pipe
    //

    Iosb.Status = NpCreateCcb (Fcb,
                               FileObject,
                               FILE_PIPE_LISTENING_STATE,
                               Parameters->ReadMode,
                               Parameters->CompletionMode,
                               Parameters->InboundQuota,
                               Parameters->OutboundQuota,
                               &Ccb);
    if (!NT_SUCCESS (Iosb.Status)) {
        return Iosb;
    }

    //
    //  Wake up anyone waiting for an instance to go into the listening state
    //

    Iosb.Status = NpCancelWaiter (&NpVcb->WaitQueue,
                                  &Fcb->FullFileName,
                                  STATUS_SUCCESS,
                                  DeferredList);
    if (!NT_SUCCESS (Iosb.Status)) {
        Ccb->Fcb->ServerOpenCount -= 1;
        NpDeleteCcb (Ccb, DeferredList);
        return Iosb;
    }

    //
    //  Set the file object back pointers and our pointer to the
    //  server file object.
    //

    NpSetFileObject( FileObject, Ccb, Ccb->NonpagedCcb, FILE_PIPE_SERVER_END );
    Ccb->FileObject[ FILE_PIPE_SERVER_END ] = FileObject;

    //
    //  Check to see if we need to notify outstanding Irps for
    //  changes (i.e., we just added a new instance of a named pipe).
    //

    NpCheckForNotify( Fcb->ParentDcb, FALSE, DeferredList );

    //
    //  Set our return status
    //

    Iosb.Status = STATUS_SUCCESS;
    Iosb.Information = FILE_OPENED;

    return Iosb;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\npfs\dir.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Dir.c

Abstract:

    This module implements the File Directory routines for the Named Pipe
    file system by the dispatch driver.

Author:

    Gary Kimura     [GaryKi]    28-Dec-1989

Revision History:

--*/

#include "NpProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (NPFS_BUG_CHECK_DIR)

//
//  Local debug trace level
//

#define Dbg                              (DEBUG_TRACE_DIR)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NpCheckForNotify)
#pragma alloc_text(PAGE, NpCommonDirectoryControl)
#pragma alloc_text(PAGE, NpFsdDirectoryControl)
#pragma alloc_text(PAGE, NpQueryDirectory)
#pragma alloc_text(PAGE, NpNotifyChangeDirectory)
#endif


NTSTATUS
NpFsdDirectoryControl (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the FSD routine that handles directory control
    functions (i.e., query and notify).

Arguments:

    NpfsDeviceObject - Supplies the device object for the directory function.

    Irp - Supplies the IRP to process

Return Value:

    NTSTATUS - The appropriate result status

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpFsdDirectoryControl\n", 0);

    //
    //  Call the common Direcotry Control routine.
    //

    FsRtlEnterFileSystem();
    NpAcquireExclusiveVcb( );

    Status = NpCommonDirectoryControl( NpfsDeviceObject, Irp );

    NpReleaseVcb();
    FsRtlExitFileSystem();

    if (Status != STATUS_PENDING) {
        NpCompleteRequest (Irp, Status);
    }

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "NpFsdDirectoryControl -> %08lx\n", Status );

    return Status;
}

VOID
NpCheckForNotify (
    IN PDCB Dcb,
    IN BOOLEAN CheckAllOutstandingIrps,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This routine checks the notify queues of a dcb and completes any
    outstanding IRPS.

    Note that the caller of this procedure must guarantee that the DCB
    is acquired for exclusive access.

Arguments:

    Dcb - Supplies the Dcb to check if is has any notify Irps outstanding

    CheckAllOutstandingIrps - Indicates if only the NotifyFullQueue should be
        checked.  If TRUE then all notify queues are checked, and if FALSE
        then only the NotifyFullQueue is checked.

Return Value:

    None.

--*/

{
    PLIST_ENTRY Links;
    PIRP Irp;

    PAGED_CODE();

    //
    //  We'll always signal the notify full queue entries.  They want
    //  to be notified if every any change is made to a directory
    //

    while (!IsListEmpty( &Dcb->Specific.Dcb.NotifyFullQueue )) {

        //
        //  Remove the Irp from the head of the queue, and complete it
        //  with success.
        //

        Links = RemoveHeadList( &Dcb->Specific.Dcb.NotifyFullQueue );

        Irp = CONTAINING_RECORD( Links, IRP, Tail.Overlay.ListEntry );

        if (IoSetCancelRoutine (Irp, NULL) != NULL) {
            NpDeferredCompleteRequest( Irp, STATUS_SUCCESS, DeferredList );
        } else {
            InitializeListHead (&Irp->Tail.Overlay.ListEntry);
        }
    }

    //
    //  Now check if we should also do the partial notify queue.
    //

    if (CheckAllOutstandingIrps) {

        while (!IsListEmpty( &Dcb->Specific.Dcb.NotifyPartialQueue )) {

            //
            //  Remove the Irp from the head of the queue, and complete it
            //  with success.
            //

            Links = RemoveHeadList( &Dcb->Specific.Dcb.NotifyPartialQueue );

            Irp = CONTAINING_RECORD( Links, IRP, Tail.Overlay.ListEntry );

            if (IoSetCancelRoutine (Irp, NULL) != NULL) {
                NpDeferredCompleteRequest( Irp, STATUS_SUCCESS, DeferredList );
            } else {
                InitializeListHead (&Irp->Tail.Overlay.ListEntry);
            }
        }
    }

    return;
}


//
//  Local Support Routine
//

NTSTATUS
NpCommonDirectoryControl (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine does the common code for directory control functions.

Arguments:

    NpfsDeviceObject - Supplies the named pipe device object

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;

    PIO_STACK_LOCATION IrpSp;

    PFCB Fcb;
    PROOT_DCB_CCB Ccb;

    PAGED_CODE();

    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NpCommonDirectoryControl...\n", 0);
    DebugTrace( 0, Dbg, "Irp  = %08lx\n", Irp);

    //
    //  Decode the file object to figure out who we are.  If the result
    //  is not the root dcb then its an illegal parameter.
    //

    if (NpDecodeFileObject( IrpSp->FileObject,
                            &Fcb,
                            (PCCB *)&Ccb,
                            NULL ) != NPFS_NTC_ROOT_DCB) {

        DebugTrace(0, Dbg, "Not a directory\n", 0);

        Status = STATUS_INVALID_PARAMETER;

        DebugTrace(-1, Dbg, "NpCommonDirectoryControl -> %08lx\n", Status );
        return Status;
    }

    //
    //  We know this is a directory control so we'll case on the
    //  minor function, and call the appropriate work routines.
    //

    switch (IrpSp->MinorFunction) {

    case IRP_MN_QUERY_DIRECTORY:

        Status = NpQueryDirectory( Fcb, Ccb, Irp );
        break;

    case IRP_MN_NOTIFY_CHANGE_DIRECTORY:

        Status = NpNotifyChangeDirectory( Fcb, Ccb, Irp );
        break;

    default:

        //
        //  For all other minor function codes we say they're invalid
        //  and complete the request.
        //

        DebugTrace(0, DEBUG_TRACE_ERROR, "Invalid FS Control Minor Function Code %08lx\n", IrpSp->MinorFunction);

        Status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    DebugTrace(-1, Dbg, "NpCommonDirectoryControl -> %08lx\n", Status);
    return Status;
}


//
//  Internal support routine
//

NTSTATUS
NpQueryDirectory (
    IN PROOT_DCB RootDcb,
    IN PROOT_DCB_CCB Ccb,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the work routine for querying a directory.

Arugments:

    RootDcb - Supplies the dcb being queried

    Ccb - Supplies the context of the caller

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The return status for the operation.

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    PUCHAR Buffer;
    CLONG SystemBufferLength;

    UNICODE_STRING FileName;
    ULONG FileIndex;
    FILE_INFORMATION_CLASS FileInformationClass;
    BOOLEAN RestartScan;
    BOOLEAN ReturnSingleEntry;
    BOOLEAN IndexSpecified;

    static WCHAR Star = L'*';

    BOOLEAN CaseInsensitive = TRUE; //*** Make searches case insensitive

    ULONG CurrentIndex;

    ULONG LastEntry;
    ULONG NextEntry;

    PLIST_ENTRY Links;
    PFCB Fcb;

    PFILE_DIRECTORY_INFORMATION DirInfo;
    PFILE_NAMES_INFORMATION NamesInfo;

    PAGED_CODE();

    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NpQueryDirectory\n", 0 );
    DebugTrace( 0, Dbg, "RootDcb              = %08lx\n", RootDcb);
    DebugTrace( 0, Dbg, "Ccb                  = %08lx\n", Ccb);
    DebugTrace( 0, Dbg, "SystemBuffer         = %08lx\n", Irp->AssociatedIrp.SystemBuffer);
    DebugTrace( 0, Dbg, "Length               = %08lx\n", IrpSp->Parameters.QueryDirectory.Length);
    DebugTrace( 0, Dbg, "FileName             = %Z\n",    IrpSp->Parameters.QueryDirectory.FileName);
    DebugTrace( 0, Dbg, "FileIndex            = %08lx\n", IrpSp->Parameters.QueryDirectory.FileIndex);
    DebugTrace( 0, Dbg, "FileInformationClass = %08lx\n", IrpSp->Parameters.QueryDirectory.FileInformationClass);
    DebugTrace( 0, Dbg, "RestartScan          = %08lx\n", FlagOn(IrpSp->Flags, SL_RESTART_SCAN));
    DebugTrace( 0, Dbg, "ReturnSingleEntry    = %08lx\n", FlagOn(IrpSp->Flags, SL_RETURN_SINGLE_ENTRY));
    DebugTrace( 0, Dbg, "IndexSpecified       = %08lx\n", FlagOn(IrpSp->Flags, SL_INDEX_SPECIFIED));

    //
    //  Save references to the input parameters within the Irp
    //

    SystemBufferLength   = IrpSp->Parameters.QueryDirectory.Length;

    FileIndex            = IrpSp->Parameters.QueryDirectory.FileIndex;

    FileInformationClass = IrpSp->Parameters.QueryDirectory.FileInformationClass;

    RestartScan          = BooleanFlagOn(IrpSp->Flags, SL_RESTART_SCAN);
    ReturnSingleEntry    = BooleanFlagOn(IrpSp->Flags, SL_RETURN_SINGLE_ENTRY);
    IndexSpecified       = BooleanFlagOn(IrpSp->Flags, SL_INDEX_SPECIFIED);

    if (IrpSp->Parameters.QueryDirectory.FileName != NULL) {

        FileName = *(IrpSp->Parameters.QueryDirectory.FileName);

        //
        //  Make sure that the user called us with a proper unicode string.
        //  We will reject odd length file names (i.e., lengths with the low
        //  bit set)
        //

        if (FileName.Length & 0x1) {

            return STATUS_INVALID_PARAMETER;
        }

    } else {

        FileName.Length = 0;
        FileName.Buffer = NULL;
    }

    //
    //  Check if the ccb already has a query template attached.  If it
    //  does not already have one then we either use the string we are
    //  given or we attach our own containing "*"
    //

    if (Ccb->QueryTemplate == NULL) {

        //
        //  This is our first time calling query directory so we need
        //  to either set the query template to the user specified string
        //  or to "*"
        //

        if (FileName.Buffer == NULL) {

            DebugTrace(0, Dbg, "Set template to *\n", 0);

            FileName.Length = 2;
            FileName.Buffer = &Star;
        }

        DebugTrace(0, Dbg, "Set query template -> %Z\n", &FileName);

        //
        //  Allocate space for the query template
        //

        Ccb->QueryTemplate = NpAllocatePagedPoolWithQuota(sizeof(UNICODE_STRING) + FileName.Length, 'qFpN' );
        if (Ccb->QueryTemplate == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        //  Initialize the query template and copy over the string
        //

        Ccb->QueryTemplate->Length = FileName.Length;
        Ccb->QueryTemplate->Buffer = (PWCH)Ccb->QueryTemplate +
                                     sizeof(UNICODE_STRING) / sizeof(WCHAR);

        RtlCopyMemory( Ccb->QueryTemplate->Buffer,
                       FileName.Buffer,
                       FileName.Length );

        //
        //  Now zero out the FileName so we won't think we're to use it
        //  as a subsearch string.
        //

        FileName.Length = 0;
        FileName.Buffer = NULL;
    }

    //
    //  Check if we were given an index to start with or if we need to
    //  restart the scan or if we should use the index that was saved in
    //  the ccb
    //

    if (RestartScan) {

        FileIndex = 0;

    } else if (!IndexSpecified) {

        FileIndex = Ccb->IndexOfLastCcbReturned + 1;
    }

    //
    //  Now we are committed to completing the Irp, we do that in
    //  the finally clause of the following try.
    //

    try {

        ULONG BaseLength;
        ULONG LengthAdded;
        BOOLEAN Match;

        //
        //  Map the user buffer
        //

        Buffer = NpMapUserBuffer( Irp );

        //
        //  At this point we are about to enter our query loop.  We have
        //  already decided which Fcb index we need to return.  The variables
        //  LastEntry and NextEntry are used to index into the user buffer.
        //  LastEntry is the last entry we added to the user buffer, and
        //  NextEntry is the current one we're working on.  CurrentIndex
        //  is the Fcb index that we are looking at next.  Logically the
        //  way the loop works is as follows.
        //
        //  Scan all of the Fcb in the directory
        //
        //      if the Fcb matches the query template then
        //
        //          if the CurrentIndex is >= the FileIndex then
        //
        //              process this fcb, and decide if we should
        //              continue the main loop
        //
        //          end if
        //
        //          Increment the current index
        //
        //      end if
        //
        //  end scan
        //

        CurrentIndex = 0;

        LastEntry = 0;
        NextEntry =0;

        switch (FileInformationClass) {

        case FileDirectoryInformation:

            BaseLength = FIELD_OFFSET( FILE_DIRECTORY_INFORMATION,
                                       FileName[0] );
            break;

        case FileFullDirectoryInformation:

            BaseLength = FIELD_OFFSET( FILE_FULL_DIR_INFORMATION,
                                       FileName[0] );
            break;

        case FileNamesInformation:

            BaseLength = FIELD_OFFSET( FILE_NAMES_INFORMATION,
                                       FileName[0] );
            break;

        case FileBothDirectoryInformation:

            BaseLength = FIELD_OFFSET( FILE_BOTH_DIR_INFORMATION,
                                       FileName[0] );
            break;

        default:

            try_return( Status = STATUS_INVALID_INFO_CLASS );
        }

        for (Links = RootDcb->Specific.Dcb.ParentDcbQueue.Flink;
             Links != &RootDcb->Specific.Dcb.ParentDcbQueue;
             Links = Links->Flink) {

            Fcb = CONTAINING_RECORD(Links, FCB, ParentDcbLinks);

            ASSERT(Fcb->NodeTypeCode == NPFS_NTC_FCB);

            DebugTrace(0, Dbg, "Top of Loop\n", 0);
            DebugTrace(0, Dbg, "Fcb          = %08lx\n", Fcb);
            DebugTrace(0, Dbg, "CurrentIndex = %08lx\n", CurrentIndex);
            DebugTrace(0, Dbg, "FileIndex    = %08lx\n", FileIndex);
            DebugTrace(0, Dbg, "LastEntry    = %08lx\n", LastEntry);
            DebugTrace(0, Dbg, "NextEntry    = %08lx\n", NextEntry);

            //
            //  Check if the Fcb represents a named pipe that is part of
            //  our query template
            //

            try {
                Match = FsRtlIsNameInExpression( Ccb->QueryTemplate,
                                                 &Fcb->LastFileName,
                                                 CaseInsensitive,
                                                 NULL );
            } except (EXCEPTION_EXECUTE_HANDLER) {
                try_return( Status = GetExceptionCode ());
            }

            if (Match) {

                //
                //  The fcb is in the query template so now check if
                //  this is the index we should start returning
                //

                if (CurrentIndex >= FileIndex) {

                    ULONG BytesToCopy;
                    ULONG BytesRemainingInBuffer;

                    //
                    //  Here are the rules concerning filling up the buffer:
                    //
                    //  1.  The Io system garentees that there will always be
                    //      enough room for at least one base record.
                    //
                    //  2.  If the full first record (including file name) cannot
                    //      fit, as much of the name as possible is copied and
                    //      STATUS_BUFFER_OVERFLOW is returned.
                    //
                    //  3.  If a subsequent record cannot completely fit into the
                    //      buffer, none of it (as in 0 bytes) is copied, and
                    //      STATUS_SUCCESS is returned.  A subsequent query will
                    //      pick up with this record.
                    //

                    BytesRemainingInBuffer = SystemBufferLength - NextEntry;

                    if ( (NextEntry != 0) &&
                         ( (BaseLength + Fcb->LastFileName.Length > BytesRemainingInBuffer) ||
                           (SystemBufferLength < NextEntry) ) ) {

                        DebugTrace(0, Dbg, "Next entry won't fit\n", 0);

                        try_return( Status = STATUS_SUCCESS );
                    }

                    ASSERT( BytesRemainingInBuffer >= BaseLength );

                    //
                    //  See how much of the name we will be able to copy into
                    //  the system buffer.  This also dictates out return
                    //  value.
                    //

                    if ( BaseLength + Fcb->LastFileName.Length <=
                         BytesRemainingInBuffer ) {

                        BytesToCopy = Fcb->LastFileName.Length;
                        Status = STATUS_SUCCESS;

                    } else {

                        BytesToCopy = BytesRemainingInBuffer - BaseLength;
                        Status = STATUS_BUFFER_OVERFLOW;
                    }

                    //
                    //  Note how much of buffer we are consuming and zero
                    //  the base part of the structure.  Protect our access
                    //  because it is the user's buffer.
                    //

                    LengthAdded = BaseLength + BytesToCopy;

                    try {

                        RtlZeroMemory( &Buffer[NextEntry], BaseLength );

                    } except (EXCEPTION_EXECUTE_HANDLER) {

                        try_return (Status = GetExceptionCode ());
                    }

                    //
                    //  Now fill the base parts of the strucure that are
                    //  applicable.
                    //

                    switch (FileInformationClass) {

                    case FileBothDirectoryInformation:

                        //
                        //  We don't need short name
                        //

                        DebugTrace(0, Dbg, "Getting directory full information\n", 0);

                    case FileFullDirectoryInformation:

                        //
                        //  We don't use EaLength, so fill in nothing here.
                        //

                        DebugTrace(0, Dbg, "Getting directory full information\n", 0);

                    case FileDirectoryInformation:

                        DebugTrace(0, Dbg, "Getting directory information\n", 0);

                        //
                        //  The eof indicates the number of instances and
                        //  allocation size is the maximum allowed.  Protect
                        //  our access because it is the user's buffer.
                        //

                        DirInfo = (PFILE_DIRECTORY_INFORMATION)&Buffer[NextEntry];

                        try {

                            DirInfo->EndOfFile.QuadPart = Fcb->OpenCount;
                            DirInfo->AllocationSize.QuadPart = Fcb->Specific.Fcb.MaximumInstances;

                            DirInfo->FileAttributes = FILE_ATTRIBUTE_NORMAL;

                            DirInfo->FileNameLength = Fcb->LastFileName.Length;

                        } except (EXCEPTION_EXECUTE_HANDLER) {

                            try_return (Status = GetExceptionCode ());
                        }

                        break;

                    case FileNamesInformation:

                        DebugTrace(0, Dbg, "Getting names information\n", 0);

                        //
                        //  Proctect our access because it is the user's buffer
                        //

                        NamesInfo = (PFILE_NAMES_INFORMATION)&Buffer[NextEntry];

                        try {

                            NamesInfo->FileNameLength = Fcb->LastFileName.Length;

                        } except (EXCEPTION_EXECUTE_HANDLER) {

                            try_return (Status = GetExceptionCode ());
                        }

                        break;

                    default:

                        NpBugCheck( FileInformationClass, 0, 0 );
                    }

                    //
                    //  Protect our access because it is the user's buffer
                    //

                    try {

                        RtlCopyMemory( &Buffer[NextEntry + BaseLength],
                                       Fcb->LastFileName.Buffer,
                                       BytesToCopy );

                    } except (EXCEPTION_EXECUTE_HANDLER) {

                        try_return (Status = GetExceptionCode ());
                    }

                    //
                    //  Update the ccb to the index we've just used
                    //

                    Ccb->IndexOfLastCcbReturned = CurrentIndex;

                    //
                    //  And indicate how much of the system buffer we have
                    //  currently used up.  We must compute this value before
                    //  we long align outselves for the next entry
                    //

                    Irp->IoStatus.Information = NextEntry + LengthAdded;

                    //
                    //  Setup the previous next entry offset.  Protect our
                    //  access because it is the user's buffer.
                    //

                    try {

                        *((PULONG)(&Buffer[LastEntry])) = NextEntry - LastEntry;

                    } except (EXCEPTION_EXECUTE_HANDLER) {

                        try_return (Status = GetExceptionCode ());
                    }

                    //
                    //  Check if the last entry didn't completely fit
                    //

                    if ( Status == STATUS_BUFFER_OVERFLOW ) {

                        try_return( NOTHING );
                    }

                    //
                    //  Check if we are only to return a single entry
                    //

                    if (ReturnSingleEntry) {

                        try_return( Status = STATUS_SUCCESS );
                    }

                    //
                    //  Set ourselves up for the next iteration
                    //

                    LastEntry = NextEntry;
                    NextEntry += (ULONG)QuadAlign( LengthAdded );
                }

                //
                //  Increment the current index by one
                //

                CurrentIndex += 1;
            }
        }

        //
        //  At this point we've scanned the entire list of Fcb so if
        //  the NextEntry is zero then we haven't found anything so we
        //  will return no more files, otherwise we return success.
        //

        if (NextEntry == 0) {

            Status = STATUS_NO_MORE_FILES;

        } else {

            Status = STATUS_SUCCESS;
        }

    try_exit: NOTHING;
    } finally {

        DebugTrace(-1, Dbg, "NpQueryDirectory -> %08lx\n", Status);
    }

    return Status;
}


//
//  Internal support routine
//

NTSTATUS
NpNotifyChangeDirectory (
    IN PROOT_DCB RootDcb,
    IN PROOT_DCB_CCB Ccb,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for doing the notify change directory.

Arugments:

    RootDcb - Supplies the dcb being queried

    Ccb - Supplies the context of the caller

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - STATUS_PENDING

--*/

{
    PIO_STACK_LOCATION IrpSp;
    PLIST_ENTRY Head;

    UNREFERENCED_PARAMETER( Ccb );

    PAGED_CODE();

    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NpNotifyChangeDirectory\n", 0 );
    DebugTrace( 0, Dbg, "RootDcb = %08lx", RootDcb);
    DebugTrace( 0, Dbg, "Ccb     = %08lx", Ccb);


    if (IrpSp->Parameters.NotifyDirectory.CompletionFilter &
        ~FILE_NOTIFY_CHANGE_NAME) {
        Head = &RootDcb->Specific.Dcb.NotifyFullQueue;
    } else {
        Head = &RootDcb->Specific.Dcb.NotifyPartialQueue;
    }

    IoSetCancelRoutine( Irp, NpCancelChangeNotifyIrp );

    if (Irp->Cancel && IoSetCancelRoutine( Irp, NULL ) != NULL) {
        return STATUS_CANCELLED;
    } else {
        //
        //  Mark the Irp pending and insert into list.
        //
        IoMarkIrpPending( Irp );
        InsertTailList( Head,
                        &Irp->Tail.Overlay.ListEntry );
        return STATUS_PENDING;
    }
}


//
//  Local support routine
//

VOID
NpCancelChangeNotifyIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the cancel function for an IRP saved in a change notify
    queue

Arguments:

    DeviceObject - ignored

    Irp - Supplies the Irp being cancelled.  A pointer to the proper dcb queue
        is stored in the information field of the Irp Iosb field.

Return Value:

    None.

--*/

{
    PLIST_ENTRY ListHead;

    UNREFERENCED_PARAMETER( DeviceObject );


    IoReleaseCancelSpinLock( Irp->CancelIrql );

    //
    //  Get exclusive access to the named pipe vcb so we can now do our work
    //
    FsRtlEnterFileSystem();
    NpAcquireExclusiveVcb();

    RemoveEntryList( &Irp->Tail.Overlay.ListEntry );

    NpReleaseVcb();
    FsRtlExitFileSystem();

    NpCompleteRequest( Irp, STATUS_CANCELLED );
    //
    //  And return to our caller
    //

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\npfs\fileinfo.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    FileInfo.c

Abstract:

    This module implements the File Info routines for NPFS called by the
    dispatch driver.  There are two entry points NpFsdQueryInformation
    and NpFsdSetInformation.

Author:

    Gary Kimura     [GaryKi]    21-Aug-1990

Revision History:

--*/

#include "NpProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (NPFS_BUG_CHECK_FILEINFO)

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_FILEINFO)


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NpCommonQueryInformation)
#pragma alloc_text(PAGE, NpCommonSetInformation)
#pragma alloc_text(PAGE, NpFsdQueryInformation)
#pragma alloc_text(PAGE, NpFsdSetInformation)
#pragma alloc_text(PAGE, NpQueryBasicInfo)
#pragma alloc_text(PAGE, NpQueryEaInfo)
#pragma alloc_text(PAGE, NpQueryInternalInfo)
#pragma alloc_text(PAGE, NpQueryNameInfo)
#pragma alloc_text(PAGE, NpQueryPipeInfo)
#pragma alloc_text(PAGE, NpQueryPipeLocalInfo)
#pragma alloc_text(PAGE, NpQueryPositionInfo)
#pragma alloc_text(PAGE, NpQueryStandardInfo)
#pragma alloc_text(PAGE, NpSetBasicInfo)
#pragma alloc_text(PAGE, NpSetPipeInfo)
#endif


NTSTATUS
NpFsdQueryInformation (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtQueryInformationFile API
    calls.

Arguments:

    NpfsDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpFsdQueryInformation\n", 0);

    //
    //  Call the common Query Information routine.
    //

    FsRtlEnterFileSystem();

    NpAcquireSharedVcb();

    Status = NpCommonQueryInformation( NpfsDeviceObject, Irp );

    NpReleaseVcb();

    FsRtlExitFileSystem();

    if (Status != STATUS_PENDING) {
        NpCompleteRequest (Irp, Status);
    }
    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "NpFsdQueryInformation -> %08lx\n", Status );

    return Status;
}


NTSTATUS
NpFsdSetInformation (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtSetInformationFile API
    calls.

Arguments:

    NpfsDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS Status;
    LIST_ENTRY DeferredList;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpFsdSetInformation\n", 0);

    //
    //  Call the common Set Information routine.
    //

    InitializeListHead (&DeferredList);

    FsRtlEnterFileSystem ();

    NpAcquireExclusiveVcb ();

    Status = NpCommonSetInformation (NpfsDeviceObject, Irp, &DeferredList);

    NpReleaseVcb ();

    //
    // Complete the deferred IRPs now we have released the locks
    //
    NpCompleteDeferredIrps (&DeferredList);

    FsRtlExitFileSystem ();

    if (Status != STATUS_PENDING) {
        NpCompleteRequest (Irp, Status);
    }
    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "NpFsdSetInformation -> %08lx\n", Status );
    return Status;
}

//
//  Internal support routine
//

NTSTATUS
NpCommonQueryInformation (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for creating/opening a file.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp;
    NTSTATUS Status;

    ULONG Length;
    FILE_INFORMATION_CLASS FileInformationClass;
    PVOID Buffer;

    NODE_TYPE_CODE NodeTypeCode;
    PFCB Fcb;
    PCCB Ccb;
    NAMED_PIPE_END NamedPipeEnd;

    PFILE_ALL_INFORMATION AllInfo;

    PAGED_CODE();

    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NpCommonQueryInformation...\n", 0);
    DebugTrace( 0, Dbg, " Irp                    = %08lx\n", Irp);
    DebugTrace( 0, Dbg, " ->Length               = %08lx\n", IrpSp->Parameters.QueryFile.Length);
    DebugTrace( 0, Dbg, " ->FileInformationClass = %08lx\n", IrpSp->Parameters.QueryFile.FileInformationClass);
    DebugTrace( 0, Dbg, " ->Buffer               = %08lx\n", Irp->AssociatedIrp.SystemBuffer);

    //
    //  Get the ccb and figure out who we are, and make sure we're not
    //  disconnected.
    //

    if ((NodeTypeCode = NpDecodeFileObject( IrpSp->FileObject,
                                            &Fcb,
                                            &Ccb,
                                            &NamedPipeEnd )) == NTC_UNDEFINED) {

        DebugTrace(0, Dbg, "Pipe is disconnected from us\n", 0);

        Status = STATUS_PIPE_DISCONNECTED;

        DebugTrace(-1, Dbg, "NpCommonQueryInformation -> %08lx\n", Status );
        return Status;
    }

    //
    //  Reference our input parameter to make things easier
    //

    Length = IrpSp->Parameters.QueryFile.Length;
    FileInformationClass = IrpSp->Parameters.QueryFile.FileInformationClass;
    Buffer = Irp->AssociatedIrp.SystemBuffer;

    //
    //  Case on the type of the context, We can only query information
    //  on an Fcb, Dcb, or Root Dcb.  If we are not passed on of these
    //  we immediately tell the caller that there is an invalid parameter.
    //

    if (NodeTypeCode != NPFS_NTC_CCB &&
        (NodeTypeCode != NPFS_NTC_ROOT_DCB || FileInformationClass != FileNameInformation)) {

        DebugTrace(0, Dbg, "Node type code is not ccb\n", 0);

        DebugTrace(-1, Dbg, "NpCommonQueryInformation -> STATUS_INVALID_PARAMETER\n", 0);
        return STATUS_INVALID_PARAMETER;
    }


    //
    //  Based on the information class we'll do different actions.  Each
    //  of the procedure that we're calling fill up as much of the
    //  buffer as possible and return the remaining length, and status
    //  This is done so that we can use them to build up the
    //  FileAllInformation request.  These procedures do not complete the
    //  Irp, instead this procedure must complete the Irp.
    //

    switch (FileInformationClass) {

    case FileAllInformation:

        //
        //  For the all information class we'll typecast a local
        //  pointer to the output buffer and then call the
        //  individual routines to fill in the buffer.
        //

        AllInfo = Buffer;

        Length -= (sizeof(FILE_ACCESS_INFORMATION)
                   + sizeof(FILE_MODE_INFORMATION)
                   + sizeof(FILE_ALIGNMENT_INFORMATION));

        //
        //  Only the QueryName call can return non-success
        //

        (VOID)NpQueryBasicInfo( Ccb, &AllInfo->BasicInformation, &Length );
        (VOID)NpQueryStandardInfo( Ccb, &AllInfo->StandardInformation, &Length, NamedPipeEnd );
        (VOID)NpQueryInternalInfo( Ccb, &AllInfo->InternalInformation, &Length );
        (VOID)NpQueryEaInfo( Ccb, &AllInfo->EaInformation, &Length );
        (VOID)NpQueryPositionInfo( Ccb, &AllInfo->PositionInformation, &Length, NamedPipeEnd );

        Status = NpQueryNameInfo( Ccb, &AllInfo->NameInformation, &Length );

        break;

    case FileBasicInformation:

        Status = NpQueryBasicInfo( Ccb, Buffer, &Length );
        break;

    case FileStandardInformation:

        Status = NpQueryStandardInfo( Ccb, Buffer, &Length, NamedPipeEnd );
        break;

    case FileInternalInformation:

        Status = NpQueryInternalInfo( Ccb, Buffer, &Length );
        break;

    case FileEaInformation:

        Status = NpQueryEaInfo( Ccb, Buffer, &Length );
        break;

    case FilePositionInformation:

        Status = NpQueryPositionInfo( Ccb, Buffer, &Length, NamedPipeEnd );
        break;

    case FileNameInformation:

        Status = NpQueryNameInfo( Ccb, Buffer, &Length );
        break;

    case FilePipeInformation:

        Status = NpQueryPipeInfo( Fcb, Ccb, Buffer, &Length, NamedPipeEnd );
        break;

    case FilePipeLocalInformation:

        Status = NpQueryPipeLocalInfo( Fcb, Ccb, Buffer, &Length, NamedPipeEnd );
        break;

    default:

        Status = STATUS_INVALID_PARAMETER;
        break;
    }

    //
    //  Set the information field to the number of bytes actually filled in
    //  and then complete the request
    //

    Irp->IoStatus.Information = IrpSp->Parameters.QueryFile.Length - Length;

    DebugTrace(-1, Dbg, "NpCommonQueryInformation -> %08lx\n", Status );
    return Status;
}


//
//  Internal support routine
//

NTSTATUS
NpCommonSetInformation (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This is the common routine for creating/opening a file.

Arguments:

    NpfsDeviceObject - Device object for npfs

    Irp - Supplies the Irp to process

    DeferredList - List or IRPs to complete after we drop locks

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp;
    NTSTATUS Status;

    ULONG Length;
    FILE_INFORMATION_CLASS FileInformationClass;
    PVOID Buffer;

    NODE_TYPE_CODE NodeTypeCode;
    PFCB Fcb;
    PCCB Ccb;
    NAMED_PIPE_END NamedPipeEnd;

    PAGED_CODE();

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NpCommonSetInformation...\n", 0);
    DebugTrace( 0, Dbg, " Irp                    = %08lx\n", Irp);
    DebugTrace( 0, Dbg, " ->Length               = %08lx\n", IrpSp->Parameters.SetFile.Length);
    DebugTrace( 0, Dbg, " ->FileInformationClass = %08lx\n", IrpSp->Parameters.SetFile.FileInformationClass);
    DebugTrace( 0, Dbg, " ->Buffer               = %08lx\n", Irp->AssociatedIrp.SystemBuffer);

    //
    //  Get the ccb and figure out who we are, and make sure we're not
    //  disconnected.
    //

    if ((NodeTypeCode = NpDecodeFileObject( IrpSp->FileObject,
                                            &Fcb,
                                            &Ccb,
                                            &NamedPipeEnd )) == NTC_UNDEFINED) {

        DebugTrace(0, Dbg, "Pipe is disconnected from us\n", 0);

        Status = STATUS_PIPE_DISCONNECTED;

        DebugTrace(-1, Dbg, "NpCommonSetInformation -> %08lx\n", Status );
        return Status;
    }

    //
    //  Case on the type of the context, We can only query information
    //  on an Fcb, Dcb, or Root Dcb.  If we are not passed on of these
    //  we immediately tell the caller that there is an invalid parameter.
    //

    if (NodeTypeCode != NPFS_NTC_CCB) {

        DebugTrace(-1, Dbg, "NpCommonQueryInformation -> STATUS_INVALID_PARAMETER\n", 0);
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Reference our input parameter to make things easier
    //

    Length = IrpSp->Parameters.SetFile.Length;
    FileInformationClass = IrpSp->Parameters.SetFile.FileInformationClass;
    Buffer = Irp->AssociatedIrp.SystemBuffer;

    //
    //  Based on the information class we'll do differnt actions. Each
    //  procedure that we're calling will complete the request.
    //

    switch (FileInformationClass) {

    case FileBasicInformation:

        Status = NpSetBasicInfo( Ccb, Buffer );
        break;

    case FilePipeInformation:

        Status = NpSetPipeInfo( Fcb, Ccb, Buffer, NamedPipeEnd, DeferredList );
        break;

    default:

        Status = STATUS_INVALID_PARAMETER;
        break;
    }


    DebugTrace(-1, Dbg, "NpCommonSetInformation -> %08lx\n", Status);
    return Status;
}


//
//  Internal support routine
//

NTSTATUS
NpQueryBasicInfo (
    IN PCCB Ccb,
    IN PFILE_BASIC_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine performs the query basic information operation.

Arguments:

    Ccb - Supplies the Ccb of the named pipe being queried

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned

    Length - Supplies the length of the buffer in bytes.  This variable
        upon return will receive the remaining bytes free in the buffer.

Return Value:

    NTSTATUS - The result of this query

--*/

{
    UNREFERENCED_PARAMETER( Ccb );

    PAGED_CODE();

    DebugTrace(0, Dbg, "NpQueryBasicInfo...\n", 0);

    //
    //  Update the length field, and zero out the buffer
    //

    *Length -= sizeof( FILE_BASIC_INFORMATION );
    RtlZeroMemory( Buffer, sizeof(FILE_BASIC_INFORMATION) );

    //
    //  Set the various fields in the record
    //
    //**** need to add the time fields to the fcb/ccb
    //

    Buffer->CreationTime.LowPart   = 0; Buffer->CreationTime.HighPart   = 0;
    Buffer->LastAccessTime.LowPart = 0; Buffer->LastAccessTime.HighPart = 0;
    Buffer->LastWriteTime.LowPart  = 0; Buffer->LastWriteTime.HighPart  = 0;
    Buffer->ChangeTime.LowPart     = 0; Buffer->ChangeTime.HighPart     = 0;

    Buffer->FileAttributes = FILE_ATTRIBUTE_NORMAL;

    //
    //  and return to our caller
    //

    return STATUS_SUCCESS;
}


//
//  Internal support routine
//

NTSTATUS
NpQueryStandardInfo (
    IN PCCB Ccb,
    IN PFILE_STANDARD_INFORMATION Buffer,
    IN OUT PULONG Length,
    IN NAMED_PIPE_END NamedPipeEnd
    )

/*++

Routine Description:

    This routine performs the query standard information operation.

Arguments:

    Ccb - Supplies the Ccb of the named pipe being queried

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned

    Length - Supplies the length of the buffer in bytes.  This variable
        upon return will receive the remaining bytes free in the buffer.

Return Value:

    NTSTATUS - The result of this query

--*/

{
    PDATA_QUEUE Inbound;
    PDATA_QUEUE Outbound;
    PDATA_QUEUE Queue;

    PAGED_CODE();

    DebugTrace(0, Dbg, "NpQueryStandardInfo...\n", 0);

    //
    //  Update the length field, and zero out the buffer
    //

    *Length -= sizeof( FILE_STANDARD_INFORMATION );
    RtlZeroMemory( Buffer, sizeof(FILE_STANDARD_INFORMATION) );

    //
    //  Set the various fields in the record
    //

    Inbound = &Ccb->DataQueue[ FILE_PIPE_INBOUND ];
    Outbound = &Ccb->DataQueue[ FILE_PIPE_OUTBOUND ];

    if (NamedPipeEnd == FILE_PIPE_CLIENT_END) {
        Queue = Outbound;
    } else {
        Queue = Inbound;
    }
    //
    //  The allocation size is the amount of quota we've charged this pipe
    //  instance
    //

    Buffer->AllocationSize.QuadPart = Inbound->Quota + Outbound->Quota;

    //
    //  The Eof is the number of writen bytes ready to be read from the queue
    //
    if (NpIsDataQueueWriters( Queue )) {
        Buffer->EndOfFile.QuadPart = Queue->BytesInQueue - Queue->NextByteOffset;
    }

    Buffer->NumberOfLinks = 1;
    Buffer->DeletePending = TRUE;
    Buffer->Directory = FALSE;

    //
    //  And return to our caller
    //

    return STATUS_SUCCESS;
}


//
//  Internal support routine
//

NTSTATUS
NpQueryInternalInfo (
    IN PCCB Ccb,
    IN PFILE_INTERNAL_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine performs the query internal information operation.

Arguments:

    Ccb - Supplies the Ccb of the named pipe being queried

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned

    Length - Supplies the length of the buffer in bytes.  This variable
        upon return will receive the remaining bytes free in the buffer.

Return Value:

    NTSTATUS - The result of this query

--*/

{
    PAGED_CODE();

    DebugTrace(0, Dbg, "NpQueryInternalInfo...\n", 0);

    //
    //  Update the length field, and zero out the buffer
    //

    *Length -= sizeof(FILE_INTERNAL_INFORMATION);
    RtlZeroMemory(Buffer, sizeof(FILE_INTERNAL_INFORMATION));

    //
    //  Set the internal index number to be the fnode lbn;
    //

    Buffer->IndexNumber.QuadPart = (ULONG_PTR)Ccb;

    //
    //  And return to our caller
    //

    return STATUS_SUCCESS;
}


//
//  Internal support routine
//

NTSTATUS
NpQueryEaInfo (
    IN PCCB Ccb,
    IN PFILE_EA_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine performs the query Ea information operation.

Arguments:

    Ccb - Supplies the Ccb of the named pipe being queried

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned

    Length - Supplies the length of the buffer in bytes.  This variable
        upon return will receive the remaining bytes free in the buffer.

Return Value:

    NTSTATUS - The result of this query

--*/

{
    UNREFERENCED_PARAMETER( Ccb );

    PAGED_CODE();

    DebugTrace(0, Dbg, "NpQueryEaInfo...\n", 0);

    //
    //  Update the length field, and zero out the buffer
    //

    *Length -= sizeof(FILE_EA_INFORMATION);
    RtlZeroMemory(Buffer, sizeof(FILE_EA_INFORMATION));

    //
    //  And return to our caller
    //

    return STATUS_SUCCESS;
}


//
//  Internal support routine
//

NTSTATUS
NpQueryNameInfo (
    IN PCCB Ccb,
    IN PFILE_NAME_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine performs the query name information operation.

Arguments:

    Ccb - Supplies the Ccb of the named pipe being queried

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned

    Length - Supplies the length of the buffer in bytes.  This variable
        upon return will receive the remaining bytes free in the buffer.

Return Value:

    NTSTATUS - The result of this query

--*/

{
    ULONG bytesToCopy;
    ULONG fileNameSize;
    PFCB Fcb;

    NTSTATUS status;

    PAGED_CODE();

    DebugTrace(0, Dbg, "NpQueryNameInfo...\n", 0);

    //
    // See if the buffer is large enough, and decide how many bytes to copy.
    //

    *Length -= FIELD_OFFSET( FILE_NAME_INFORMATION, FileName[0] );

    if (Ccb->NodeTypeCode == NPFS_NTC_ROOT_DCB_CCB) {
        Fcb = NpVcb->RootDcb;
    } else {
        Fcb = Ccb->Fcb;
    }
    fileNameSize = Fcb->FullFileName.Length;

    if ( *Length >= fileNameSize ) {

        status = STATUS_SUCCESS;

        bytesToCopy = fileNameSize;

    } else {

        status = STATUS_BUFFER_OVERFLOW;

        bytesToCopy = *Length;
    }

    //
    // Copy over the file name and its length.
    //

    RtlCopyMemory(
        Buffer->FileName,
        Fcb->FullFileName.Buffer,
        bytesToCopy);

    Buffer->FileNameLength = bytesToCopy;

    *Length -= bytesToCopy;

    return status;
}


//
//  Internal support routine
//

NTSTATUS
NpQueryPositionInfo (
    IN PCCB Ccb,
    IN PFILE_POSITION_INFORMATION Buffer,
    IN OUT PULONG Length,
    IN NAMED_PIPE_END NamedPipeEnd
    )

/*++

Routine Description:

    This routine performs the query position information operation.

Arguments:

    Ccb - Supplies the Ccb of the named pipe being queried

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned

    Length - Supplies the length of the buffer in bytes.  This variable
        upon return will receive the remaining bytes free in the buffer.

    NamedPipeEnd - Indicates if the server or client is calling

Return Value:

    NTSTATUS - The result of this query

--*/

{
    PDATA_QUEUE Queue;

    PAGED_CODE();

    DebugTrace(0, Dbg, "PbQueryPositionInfo...\n", 0);

    //
    //  Update the length field, and zero out the buffer
    //

    *Length -= sizeof(FILE_POSITION_INFORMATION);
    RtlZeroMemory(Buffer, sizeof(FILE_POSITION_INFORMATION));

    //
    //  The current byte offset is the number of bytes available in the
    //  read end of the caller's buffer.  The client read from the outbound
    //  end and the server reads from the inbound end.
    //

    if (NamedPipeEnd == FILE_PIPE_CLIENT_END) {
        Queue = &Ccb->DataQueue[ FILE_PIPE_OUTBOUND ];
    } else {
        Queue = &Ccb->DataQueue[ FILE_PIPE_INBOUND ];

    }
    if (NpIsDataQueueWriters( Queue )) {
        Buffer->CurrentByteOffset.QuadPart = Queue->BytesInQueue - Queue->NextByteOffset;
    }

    //
    //  And return to our caller
    //

    return STATUS_SUCCESS;
}


//
//  Internal support routine
//

NTSTATUS
NpQueryPipeInfo (
    IN PFCB Fcb,
    IN PCCB Ccb,
    IN PFILE_PIPE_INFORMATION Buffer,
    IN OUT PULONG Length,
    IN NAMED_PIPE_END NamedPipeEnd
    )

/*++

Routine Description:

    This routine performs the query pipe information operation.

Arguments:

    Fcb - Supplies the Fcb of the named pipe being queried

    Ccb - Supplies the Ccb of the named pipe being queried

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned

    Length - Supplies the length of the buffer in bytes.  This variable
        upon return will receive the remaining bytes free in the buffer.

    NamedPipeEnd - Indicates if the server or client is calling

Return Value:

    NTSTATUS - The result of this query

--*/

{
    UNREFERENCED_PARAMETER( Fcb );
    UNREFERENCED_PARAMETER( Ccb );

    PAGED_CODE();

    DebugTrace(0, Dbg, "PbQueryPipeInfo...\n", 0);

    //
    //  Update the length field, and zero out the buffer
    //

    *Length -= sizeof(FILE_PIPE_INFORMATION);
    RtlZeroMemory(Buffer, sizeof(FILE_PIPE_INFORMATION));

    //
    //  Set the fields in the record
    //

    Buffer->ReadMode       = Ccb->ReadCompletionMode[ NamedPipeEnd ].ReadMode;
    Buffer->CompletionMode = Ccb->ReadCompletionMode[ NamedPipeEnd ].CompletionMode;

    //
    //  And return to our caller
    //

    return STATUS_SUCCESS;
}


//
//  Internal support routine
//

NTSTATUS
NpQueryPipeLocalInfo (
    IN PFCB Fcb,
    IN PCCB Ccb,
    IN PFILE_PIPE_LOCAL_INFORMATION Buffer,
    IN OUT PULONG Length,
    IN NAMED_PIPE_END NamedPipeEnd
    )

/*++

Routine Description:

    This routine performs the query pipe information operation.

Arguments:

    Fcb - Supplies the Fcb of the named pipe being queried

    Ccb - Supplies the Ccb of the named pipe being queried

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned

    Length - Supplies the length of the buffer in bytes.  This variable
        upon return will receive the remaining bytes free in the buffer.

    NamedPipeEnd - Indicates if the server or client is calling

Return Value:

    NTSTATUS - The result of this query

--*/

{
    PDATA_QUEUE Inbound;
    PDATA_QUEUE Outbound;

    UNREFERENCED_PARAMETER( Ccb );

    PAGED_CODE();

    DebugTrace(0, Dbg, "PbQueryPipeLocalInfo...\n", 0);

    //
    //  Update the length field, and zero out the buffer
    //

    *Length -= sizeof(FILE_PIPE_LOCAL_INFORMATION);
    RtlZeroMemory(Buffer, sizeof(FILE_PIPE_LOCAL_INFORMATION));

    Inbound = &Ccb->DataQueue[ FILE_PIPE_INBOUND ];
    Outbound = &Ccb->DataQueue[ FILE_PIPE_OUTBOUND ];

    //
    //  Set the fields in the record
    //

    Buffer->NamedPipeType          = Fcb->Specific.Fcb.NamedPipeType;
    Buffer->NamedPipeConfiguration = Fcb->Specific.Fcb.NamedPipeConfiguration;
    Buffer->MaximumInstances       = Fcb->Specific.Fcb.MaximumInstances;
    Buffer->CurrentInstances       = Fcb->OpenCount;
    Buffer->InboundQuota           = Inbound->Quota;
    Buffer->OutboundQuota          = Outbound->Quota;
    Buffer->NamedPipeState         = Ccb->NamedPipeState;
    Buffer->NamedPipeEnd           = NamedPipeEnd;

    //
    //  The read data available and write quota available depend on which
    //  end of the pipe is doing the query.  The client reads from the outbound
    //  queue, and writes to the inbound queue.
    //

    if (NamedPipeEnd == FILE_PIPE_CLIENT_END) {

        if (NpIsDataQueueWriters( Outbound )) {

            Buffer->ReadDataAvailable = Outbound->BytesInQueue - Outbound->NextByteOffset;
        }

        Buffer->WriteQuotaAvailable = Inbound->Quota - Inbound->QuotaUsed;

    } else {

        if (NpIsDataQueueWriters( Inbound  )) {

            Buffer->ReadDataAvailable = Inbound->BytesInQueue - Inbound->NextByteOffset;
        }

        Buffer->WriteQuotaAvailable = Outbound->Quota - Outbound->QuotaUsed;
    }

    //
    //  And return to our caller
    //

    return STATUS_SUCCESS;
}


//
//  Internal support routine
//

NTSTATUS
NpSetBasicInfo (
    IN PCCB Ccb,
    IN PFILE_BASIC_INFORMATION Buffer
    )

/*++

Routine Description:

    This routine sets the basic information for a named pipe.

Arguments:

    Ccb - Supplies the ccb for the named pipe being modified

    Buffer - Supplies the buffer containing the data being set

Return Value:

    NTSTATUS - Returns our completion status

--*/

{
    UNREFERENCED_PARAMETER( Ccb );

    PAGED_CODE();

    DebugTrace(0, Dbg, "NpSetBasicInfo...\n", 0);

    if (((PLARGE_INTEGER)&Buffer->CreationTime)->QuadPart != 0) {

        //
        //  Modify the creation time
        //

        //**** need to add time fields
    }

    if (((PLARGE_INTEGER)&Buffer->LastAccessTime)->QuadPart != 0) {

        //
        //  Modify the last access time
        //

        //**** need to add time fields
    }

    if (((PLARGE_INTEGER)&Buffer->LastWriteTime)->QuadPart != 0) {

        //
        //  Modify the last write time
        //

        //**** need to add time fields
    }

    if (((PLARGE_INTEGER)&Buffer->ChangeTime)->QuadPart != 0) {

        //
        //  Modify the change time
        //

        //**** need to add time fields
    }

    //
    //  And return to our caller
    //

    return STATUS_SUCCESS;
}


//
//  Internal support routine
//

NTSTATUS
NpSetPipeInfo (
    IN PFCB Fcb,
    IN PCCB Ccb,
    IN PFILE_PIPE_INFORMATION Buffer,
    IN NAMED_PIPE_END NamedPipeEnd,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This routine sets the pipe information for a named pipe.

Arguments:

    Fcb - Supplies the Fcb for the named pipe being modified

    Ccb - Supplies the ccb for the named pipe being modified

    Buffer - Supplies the buffer containing the data being set

    NamedPipeEnd - Supplies the server/client end doing the operation

    DeferredList - List of IRPs to complete once we release locks

Return Value:

    NTSTATUS - Returns our completion status

--*/

{
    PDATA_QUEUE ReadQueue;
    PDATA_QUEUE WriteQueue;

    UNREFERENCED_PARAMETER( Ccb );

    PAGED_CODE();

    DebugTrace(0, Dbg, "NpSetPipeInfo...\n", 0);

    //
    //  If the caller requests message mode reads but the pipe is
    //  byte stream then its an invalid parameter
    //

    if ((Buffer->ReadMode == FILE_PIPE_MESSAGE_MODE) &&
        (Fcb->Specific.Fcb.NamedPipeType == FILE_PIPE_BYTE_STREAM_MODE)) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Get a reference to our read queue
    //

    switch (NamedPipeEnd) {

    case FILE_PIPE_SERVER_END:

        ReadQueue = &Ccb->DataQueue[ FILE_PIPE_INBOUND ];
        WriteQueue = &Ccb->DataQueue[ FILE_PIPE_OUTBOUND ];

        break;

    case FILE_PIPE_CLIENT_END:

        ReadQueue = &Ccb->DataQueue[ FILE_PIPE_OUTBOUND ];
        WriteQueue = &Ccb->DataQueue[ FILE_PIPE_INBOUND ];

        break;

    default:

        NpBugCheck( NamedPipeEnd, 0, 0 );
    }

    //
    //  If the completion mode is complete operations and the current mode
    //  is queue operations and there and the data queues are not empty
    //  then its pipe busy
    //

    if ((Buffer->CompletionMode == FILE_PIPE_COMPLETE_OPERATION)

            &&

        (Ccb->ReadCompletionMode[ NamedPipeEnd ].CompletionMode == FILE_PIPE_QUEUE_OPERATION)

            &&

        ((NpIsDataQueueReaders(ReadQueue)) ||
         (NpIsDataQueueWriters(WriteQueue)))) {

        return STATUS_PIPE_BUSY;
    }

    //
    //  Everything is fine so update the pipe
    //

    Ccb->ReadCompletionMode[ NamedPipeEnd ].ReadMode = (UCHAR) Buffer->ReadMode;
    Ccb->ReadCompletionMode[ NamedPipeEnd ].CompletionMode = (UCHAR) Buffer->CompletionMode;

    //
    //  Check for notify
    //

    NpCheckForNotify( Fcb->ParentDcb, FALSE, DeferredList );

    //
    //  And return to our caller
    //

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\npfs\dumpsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    DumpSup.c

Abstract:

    This module implements a collection of data structure dump routines
    for debugging the Named Pipe file system

Author:

    Gary Kimura     [GaryKi]    21-Aug-1990

Revision History:

--*/

#include "NpProcs.h"

#ifdef NPDBG

VOID NpDumpEventTableEntry(IN PEVENT_TABLE_ENTRY Ptr);
VOID NpDumpDataQueue(IN PDATA_QUEUE Ptr);
VOID NpDumpDataEntry(IN PDATA_ENTRY Ptr);

VOID NpDump(IN PVOID Ptr);
VOID NpDumpVcb(IN PVCB Ptr);
VOID NpDumpRootDcb(IN PROOT_DCB Ptr);
VOID NpDumpFcb(IN PFCB Ptr);
VOID NpDumpCcb(IN PCCB Ptr);
VOID NpDumpNonpagedCcb(IN PNONPAGED_CCB Ptr);
VOID NpDumpRootDcbCcb(IN PROOT_DCB_CCB Ptr);

ULONG NpDumpCurrentColumn;

#define DumpNewLine() { \
    DbgPrint("\n"); \
    NpDumpCurrentColumn = 1; \
}

#define DumpLabel(Label,Width) { \
    ULONG i; \
    CHAR _Str[20]; \
    for(i=0;i<2;i++) { _Str[i] = UCHAR_SP;} \
    strncpy(&_Str[2],#Label,Width); \
    for(i=strlen(_Str);i<Width;i++) {_Str[i] = UCHAR_SP;} \
    _Str[Width] = '\0'; \
    DbgPrint("%s", _Str); \
}

#define DumpField(Field) { \
    if ((NpDumpCurrentColumn + 18 + 9 + 9) > 80) {DumpNewLine();} \
    NpDumpCurrentColumn += 18 + 9 + 9; \
    DumpLabel(Field,18); \
    DbgPrint(":%8lx", Ptr->Field); \
    DbgPrint("         "); \
}

#define DumpListEntry(Links) { \
    if ((NpDumpCurrentColumn + 18 + 9 + 9) > 80) {DumpNewLine();} \
    NpDumpCurrentColumn += 18 + 9 + 9; \
    DumpLabel(Links,18); \
    DbgPrint(":%8lx", Ptr->Links.Flink); \
    DbgPrint(":%8lx", Ptr->Links.Blink); \
}

#define DumpName(Field,Width) { \
    ULONG i; \
    WCHAR _String[64]; \
    if ((NpDumpCurrentColumn + 18 + Width) > 80) {DumpNewLine();} \
    NpDumpCurrentColumn += 18 + Width; \
    DumpLabel(Field,18); \
    for(i=0;i<Width/2;i++) {_String[i] = Ptr->Field[i];} \
    _String[Width] = '\0'; \
    DbgPrint("%s", _String); \
}

#define TestForNull(Name) { \
    if (Ptr == NULL) { \
        DbgPrint("%s - Cannot dump a NULL pointer\n", Name); \
        return; \
    } \
}


VOID NpDumpEventTableEntry (
    IN PEVENT_TABLE_ENTRY Ptr
    )

{
    TestForNull   ("NpDumpEventTableEntry");

    DumpNewLine   ();
    DbgPrint       ("EventTableEntry@ %08lx", (Ptr));
    DumpNewLine   ();

    DumpField     (Ccb);
    DumpField     (NamedPipeEnd);
    DumpField     (EventHandle);
    DumpField     (Event);
    DumpField     (KeyValue);
    DumpField     (Process);
    DumpNewLine   ();

    return;
}


VOID NpDumpDataQueue (
    IN PDATA_QUEUE Ptr
    )

{
    PDATA_ENTRY Entry;

    TestForNull   ("NpDumpDataQueue");

    DumpNewLine   ();
    DbgPrint       ("DataQueue@ %08lx", (Ptr));
    DumpNewLine   ();

    DumpField     (QueueState);
    DumpField     (BytesInQueue);
    DumpField     (EntriesInQueue);
    DumpField     (Quota);
    DumpField     (QuotaUsed);
    DumpField     (FrontOfQueue);
    DumpField     (EndOfQueue);
    DumpField     (NextByteOffset);
    DumpNewLine   ();

    for (Entry = Ptr->FrontOfQueue;
         Entry != NULL;
         Entry = Entry->Next) {

        NpDumpDataEntry( Entry );
    }

    return;
}


VOID NpDumpDataEntry (
    IN PDATA_ENTRY Ptr
    )

{
    TestForNull   ("NpDumpDataEntry");

    DumpNewLine   ();
    DbgPrint       ("DataEntry@ %08lx", (Ptr));
    DumpNewLine   ();

    DumpField     (DataEntryType);
    DumpField     (From);
    DumpField     (Next);
    DumpField     (Irp);
    DumpField     (DataSize);
    DumpField     (DataPointer);
    DumpField     (SecurityClientContext);
    DumpNewLine   ();

    return;
}


VOID NpDump (
    IN PVOID Ptr
    )

/*++

Routine Description:

    This routine determines the type of internal record reference by ptr and
    calls the appropriate dump routine.

Arguments:

    Ptr - Supplies the pointer to the record to be dumped

Return Value:

    None

--*/

{
    TestForNull("NpDump");

    //
    //  We'll switch on the node type code
    //

    switch (NodeType(Ptr)) {

    case NPFS_NTC_VCB:               NpDumpVcb(Ptr);             break;
    case NPFS_NTC_ROOT_DCB:          NpDumpRootDcb(Ptr);         break;
    case NPFS_NTC_FCB:               NpDumpFcb(Ptr);             break;
    case NPFS_NTC_CCB:               NpDumpCcb(Ptr);             break;
    case NPFS_NTC_NONPAGED_CCB:      NpDumpNonpagedCcb(Ptr);     break;
    case NPFS_NTC_ROOT_DCB_CCB:      NpDumpRootDcbCcb(Ptr);      break;

    default :
        DbgPrint("NpDump - Unknown Node type code %8lx\n", *((PNODE_TYPE_CODE)(Ptr)));
        break;
    }

    return;
}


VOID NpDumpVcb (
    IN PVCB Ptr
    )

/*++

Routine Description:

    Dump an Vcb structure

Arguments:

    Ptr - Supplies the Device record to be dumped

Return Value:

    None

--*/

{
    TestForNull   ("NpDumpVcb");

    DumpNewLine   ();
    DbgPrint       ("Vcb@ %lx", (Ptr));
    DumpNewLine   ();

    DumpField     (NodeTypeCode);
    DumpField     (NodeByteSize);
    DumpField     (RootDcb);
    DumpField     (OpenCount);
    DumpNewLine   ();

    NpDump        (Ptr->RootDcb);

    return;
}


VOID NpDumpRootDcb (
    IN PROOT_DCB Ptr
    )

/*++

Routine Description:

    Dump a root dcb structure

Arguments:

    Ptr - Supplies the Root Dcb record to be dumped

Return Value:

    None

--*/

{
    PLIST_ENTRY Links;

    TestForNull   ("NpDumpRootDcb");

    DumpNewLine   ();
    DbgPrint       ("RootDcb@ %lx", (Ptr));
    DumpNewLine   ();

    DumpField     (NodeTypeCode);
    DumpField     (NodeByteSize);
    DumpListEntry (ParentDcbLinks);
    DumpField     (ParentDcb);
    DumpField     (OpenCount);
    DumpField     (FullFileName.Length);
    DumpField     (FullFileName.Buffer);
    DumpName      (FullFileName.Buffer, 32);
    DumpField     (LastFileName.Length);
    DumpField     (LastFileName.Buffer);
    DumpListEntry (Specific.Dcb.NotifyFullQueue);
    DumpListEntry (Specific.Dcb.NotifyPartialQueue);
    DumpListEntry (Specific.Dcb.ParentDcbQueue);
    DumpNewLine   ();

    for (Links = Ptr->Specific.Dcb.ParentDcbQueue.Flink;
         Links != &Ptr->Specific.Dcb.ParentDcbQueue;
         Links = Links->Flink) {
        NpDump(CONTAINING_RECORD(Links, FCB, ParentDcbLinks));
    }

    return;
}


VOID NpDumpFcb (
    IN PFCB Ptr
    )

/*++

Routine Description:

    Dump an Fcb structure

Arguments:

    Ptr - Supplies the Fcb record to be dumped

Return Value:

    None

--*/

{
    PLIST_ENTRY Links;

    TestForNull   ("NpDumpFcb");

    DumpNewLine   ();
    DbgPrint       ("Fcb@ %lx", (Ptr));
    DumpNewLine   ();

    DumpField     (NodeTypeCode);
    DumpField     (NodeByteSize);
    DumpListEntry (ParentDcbLinks);
    DumpField     (ParentDcb);
    DumpField     (OpenCount);
    DumpField     (FullFileName.Length);
    DumpField     (FullFileName.Buffer);
    DumpName      (FullFileName.Buffer, 32);
    DumpField     (LastFileName.Length);
    DumpField     (LastFileName.Buffer);
    DumpField     (Specific.Fcb.NamedPipeConfiguration);
    DumpField     (Specific.Fcb.NamedPipeType);
    DumpField     (Specific.Fcb.MaximumInstances);
    DumpField     (Specific.Fcb.DefaultTimeOut.LowPart);
    DumpField     (Specific.Fcb.DefaultTimeOut.HighPart);
    DumpListEntry (Specific.Fcb.CcbQueue);
    DumpNewLine   ();

    for (Links = Ptr->Specific.Fcb.CcbQueue.Flink;
         Links != &Ptr->Specific.Fcb.CcbQueue;
         Links = Links->Flink) {
        NpDump(CONTAINING_RECORD(Links, CCB, CcbLinks));
    }

    return;
}


VOID NpDumpCcb (
    IN PCCB Ptr
    )

/*++

Routine Description:

    Dump a Ccb structure

Arguments:

    Ptr - Supplies the Ccb record to be dumped

Return Value:

    None

--*/

{
    TestForNull   ("NpDumpCcb");

    DumpNewLine   ();
    DbgPrint       ("Ccb@ %lx", (Ptr));
    DumpNewLine   ();

    DumpField     (NodeTypeCode);
    DumpField     (NodeByteSize);
    DumpField     (Fcb);
    DumpField     (FileObject[0]);
    DumpField     (FileObject[1]);
    DumpField     (NamedPipeState);
    DumpField     (ReadMode[0]);
    DumpField     (ReadMode[1]);
    DumpField     (CompletionMode[0]);
    DumpField     (CompletionMode[1]);
    DumpField     (CreatorProcess);
    DumpField     (SecurityClientContext);
    DumpNewLine   ();

    NpDumpDataQueue(&Ptr->DataQueue[0]);
    NpDumpDataQueue(&Ptr->DataQueue[1]);

    NpDump        (Ptr->NonpagedCcb);

    return;
}


VOID NpDumpNonpagedCcb (
    IN PNONPAGED_CCB Ptr
    )

/*++

Routine Description:

    Dump a Nonpaged Ccb structure

Arguments:

    Ptr - Supplies the Nonpaged Ccb record to be dumped

Return Value:

    None

--*/

{
    TestForNull   ("NpDumpNonpagedCcb");

    DumpNewLine   ();
    DbgPrint       ("NonpagedCcb@ %lx", (Ptr));
    DumpNewLine   ();

    DumpField     (NodeTypeCode);
    DumpField     (NodeByteSize);
    DumpField     (EventTableEntry[0]);
    DumpField     (EventTableEntry[1]);
    DumpListEntry (ListeningQueue);
    DumpNewLine   ();

    return;
}


VOID NpDumpRootDcbCcb (
    IN PROOT_DCB_CCB Ptr
    )

/*++

Routine Description:

    Dump a Root Dcb Ccb structure

Arguments:

    Ptr - Supplies the Root Dcb Ccb record to be dumped

Return Value:

    None

--*/

{
    TestForNull   ("NpDumpRootDcbCcb");

    DumpNewLine   ();
    DbgPrint       ("RootDcbCcb@ %lx", (Ptr));
    DumpNewLine   ();

    DumpField     (NodeTypeCode);
    DumpField     (NodeByteSize);
    DumpField     (IndexOfLastCcbReturned);
    DumpNewLine   ();

    return;
}

#endif // NPDBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\npfs\deviosup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    DevIoSup.c

Abstract:

    This module implements the memory locking routines for Npfs.

Author:

    Brian Andrew    [BrianAn]   03-Apr-1991

Revision History:

--*/

#include "NpProcs.h"

//
//  Local debug trace level
//

#define Dbg                              (DEBUG_TRACE_DEVIOSUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NpLockUserBuffer)
#pragma alloc_text(PAGE, NpMapUserBuffer)
#endif


PVOID
NpMapUserBuffer (
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine conditionally maps the user buffer for the current I/O
    request in the specified mode.  If the buffer is already mapped, it
    just returns its address.

Arguments:

    Irp - Pointer to the Irp for the request.

Return Value:

    Mapped address

--*/

{
    PAGED_CODE();

    //
    // If there is no Mdl, then we must be in the Fsd, and we can simply
    // return the UserBuffer field from the Irp.
    //

    if (Irp->MdlAddress == NULL) {

        return Irp->UserBuffer;

    } else {

        return MmGetSystemAddressForMdl( Irp->MdlAddress );
    }
}


VOID
NpLockUserBuffer (
    IN OUT PIRP Irp,
    IN LOCK_OPERATION Operation,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This routine locks the specified buffer for the specified type of
    access.  The file system requires this routine since it does not
    ask the I/O system to lock its buffers for direct I/O.  This routine
    may only be called from the Fsd while still in the user context.

Arguments:

    Irp - Pointer to the Irp for which the buffer is to be locked.

    Operation - IoWriteAccess for read operations, or IoReadAccess for
                write operations.

    BufferLength - Length of user buffer.

Return Value:

    None

--*/

{
    PMDL Mdl;

    PAGED_CODE();

    if (Irp->MdlAddress == NULL) {

        //
        // This read is bound for the current process.  Perform the
        // same functions as above, only do not switch processes.
        //

        Mdl = IoAllocateMdl( Irp->UserBuffer, BufferLength, FALSE, TRUE, Irp );

        if (Mdl == NULL) {

            ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
        }

        try {

            MmProbeAndLockPages( Mdl,
                                 Irp->RequestorMode,
                                 Operation );

        } except(EXCEPTION_EXECUTE_HANDLER) {

            IoFreeMdl( Mdl );
            Irp->MdlAddress = NULL;
            ExRaiseStatus( FsRtlNormalizeNtstatus( GetExceptionCode(),
                                                   STATUS_INVALID_USER_BUFFER ));
        }
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\npfs\eventsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    EventSup.c

Abstract:

    This module implements the Named Pipe Event support routines.

Author:

    Gary Kimura     [GaryKi]    30-Aug-1990

Revision History:

--*/

#include "NpProcs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_EVENTSUP)

//
//  The following variable is exported from the kernel and is needed by npfs to
//  determine if an event was handed down.
//

extern POBJECT_TYPE *ExEventObjectType;

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, NpAddEventTableEntry)
#pragma alloc_text (PAGE, NpDeleteEventTableEntry)
#pragma alloc_text (PAGE, NpGetNextEventTableEntry)
#pragma alloc_text (PAGE, NpEventTableCompareRoutine)
#pragma alloc_text (PAGE, NpEventTableAllocate)
#pragma alloc_text (PAGE, NpEventTableDeallocate)
#endif

NTSTATUS
NpAddEventTableEntry (
    IN  PEVENT_TABLE EventTable,
    IN  PCCB Ccb,
    IN  NAMED_PIPE_END NamedPipeEnd,
    IN  HANDLE EventHandle,
    IN  ULONG KeyValue,
    IN  PEPROCESS Process,
    IN  KPROCESSOR_MODE PreviousMode,
    OUT PEVENT_TABLE_ENTRY *ppEventTableEntry
    )

/*++

Routine Description:

    This routine adds a new entry into the event table.  If an entry already
    exists it overwrites the existing entry.

Arguments:

    EventTable - Supplies the event table being modified

    Ccb - Supplies a pointer to the ccb to store in event table entry

    NamedPipeEnd - Indicates the server or client end for the event

    EventHandle - Supplies the handle to the event being added.  The object
        is referenced by this procedure

    KeyValue - Supplies a key value to associate with the event

    Process - Supplies a pointer to the process adding the event

    PreviousMode - Supplies the mode of the user initiating the action

Return Value:

    PEVENT_TABLE_ENTRY - Returns a pointer to the newly added event.
        This is an actual pointer to the table entry.

    This procedure also will raise status if the event handle cannot be
    accessed by the caller

--*/

{
    NTSTATUS Status;
    KIRQL OldIrql;

    EVENT_TABLE_ENTRY Template;
    PEVENT_TABLE_ENTRY EventTableEntry;
    PVOID Event;

    DebugTrace(+1, Dbg, "NpAddEventTableEntry, EventTable = %08lx\n", EventTable);

    //
    //  Reference the event object by handle.
    //

    if (!NT_SUCCESS(Status = ObReferenceObjectByHandle( EventHandle,
                                                        EVENT_MODIFY_STATE,
                                                        *ExEventObjectType,
                                                        PreviousMode,
                                                        &Event,
                                                        NULL ))) {

        return Status;
    }

    //
    //  Set up the template event entry to lookup
    //

    Template.Ccb = Ccb;
    Template.NamedPipeEnd = NamedPipeEnd;
    Template.EventHandle = EventHandle;
    Template.Event = Event;
    Template.KeyValue = KeyValue;
    Template.Process = Process;

    //
    //  Now insert this new entry into the event table
    //

    EventTableEntry = RtlInsertElementGenericTable( &EventTable->Table,
                                                    &Template,
                                                    sizeof(EVENT_TABLE_ENTRY),
                                                    NULL );
    if (EventTableEntry == NULL) {
        ObDereferenceObject (Event);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  Copy over the template again just in case we were given an
    //  old entry
    //

    *EventTableEntry = Template;

    DebugTrace(-1, Dbg, "NpAddEventTableEntry -> %08lx\n", EventTableEntry);

    //
    //  And now return to our caller
    //
    *ppEventTableEntry = EventTableEntry;
    return STATUS_SUCCESS;
}


VOID
NpDeleteEventTableEntry (
    IN PEVENT_TABLE EventTable,
    IN PEVENT_TABLE_ENTRY Template
    )

/*++

Routine Description:

    This routine removes an entry from the event table, it also dereferences
    the event object that was referenced when the object was inserted

Arguments:

    EventTable - Supplies a pointer to the event table being modified

    Template - Supplies a copy of the event table entry we are lookin up.
        Note that this can also be a pointer to the actual event table entry.

Return Value:

    None.

--*/

{
    KIRQL OldIrql;

    DebugTrace(+1, Dbg, "NpDeleteEventTableEntry, EventTable = %08lx\n", EventTable);

    //
    //  Only do the work if we are given a non null template
    //

    if (!ARGUMENT_PRESENT(Template)) {

        DebugTrace(-1, Dbg, "NpDeleteEventTableEntry -> VOID\n", 0);

        return;
    }

    //
    //  Dereference the event object
    //

    ObDereferenceObject(Template->Event);

    //
    //  Now remove this element from the generic table
    //

    (VOID)RtlDeleteElementGenericTable( &EventTable->Table,
                                        Template );

    DebugTrace(-1, Dbg, "NpDeleteEventTableEntry -> VOID\n", 0);

    //
    //  And now return to our caller
    //

    return;
}


PEVENT_TABLE_ENTRY
NpGetNextEventTableEntry (
    IN PEVENT_TABLE EventTable,
    IN PVOID *RestartKey
    )

/*++

Routine Description:

    This routine enumerates the events stored within an event table.

Arguments:

    EventTable - Supplies a pointer to the event being enumerated

    Restart - Indicates if the enumeration should restart or continue

Return Value:

    PEVENT_TABLE_ENTRY - Returns a pointer to the next event table entry
        in the table, or NULL if the enumeration is complete.

--*/

{
    KIRQL OldIrql;
    PEVENT_TABLE_ENTRY EventTableEntry;

    DebugTrace(+1, Dbg, "NpGetNextEventTableEntry, EventTable = %08lx\n", EventTable);

    //
    //  Lookup the next element in the table
    //

    EventTableEntry = RtlEnumerateGenericTableWithoutSplaying( &EventTable->Table, RestartKey );

    DebugTrace(-1, Dbg, "NpGetNextEventTableEntry -> %08lx\n", EventTableEntry);

    //
    //  And now return to our caller
    //

    return EventTableEntry;
}


//
//  Local support routines
//

RTL_GENERIC_COMPARE_RESULTS
NpEventTableCompareRoutine (
    IN PRTL_GENERIC_TABLE EventTable,
    IN PVOID FirstStruct,
    IN PVOID SecondStruct
    )

/*++

Routine Description:

    This routine is the comparsion routine for the Event Table which is
    implemented as a generic table.

Arguments:

    EventTable - Supplies a pointer to the event table which is involved
        in this action

    FirstStruct - Supplies a pointer to the first event table entry to examine

    SecondStruct - Supplies a pointer to the second event table entry to
        examine

Return Value:

    RTL_GENERIC_COMPARE_RESULTS - GenericLessThan if FirstEntry is less than
        SecondEntry, GenericGreaterThan if FirstEntry is greater than
        SecondEntry, and GenericEqual otherwise.

--*/

{
    PEVENT_TABLE_ENTRY FirstEntry = FirstStruct;
    PEVENT_TABLE_ENTRY SecondEntry = SecondStruct;

    UNREFERENCED_PARAMETER( EventTable );

    //
    //  We'll compare first the pointer to the ccb and then compare the
    //  pipe end types.  This will guarantee a unique ordering based on
    //  the pipe instance and pipe end (i.e., server and client end).
    //

    if (FirstEntry->Ccb < SecondEntry->Ccb) {

        return GenericLessThan;

    } else if (FirstEntry->Ccb > SecondEntry->Ccb) {

        return GenericGreaterThan;

    } else if (FirstEntry->NamedPipeEnd < SecondEntry->NamedPipeEnd) {

        return GenericLessThan;

    } else if (FirstEntry->NamedPipeEnd > SecondEntry->NamedPipeEnd) {

        return GenericGreaterThan;

    } else {

        return GenericEqual;
    }
}


//
//  Local support routines
//

PVOID
NpEventTableAllocate (
    IN PRTL_GENERIC_TABLE EventTable,
    IN CLONG ByteSize
    )

/*++

Routine Description:

    This routine is the generic allocation routine for the event table.

Arguments:

    EventTable - Supplies a pointer to the event table being used

    ByteSize - Supplies the size, in bytes, to allocate.

Return Value:

    PVOID - Returns a pointer to the newly allocated buffer.

--*/

{
    return NpAllocateNonPagedPoolWithQuota( ByteSize, 'gFpN' );
}


//
//  Local support routines
//

VOID
NpEventTableDeallocate (
    IN PRTL_GENERIC_TABLE EventTable,
    IN PVOID Buffer
    )

/*++

Routine Description:

    This routine is the generic deallocation routine for the event table.

Arguments:

    EventTable - Supplies a pointer to the event table being used

    Buffer - Supplies the buffer being deallocated

Return Value:

    None.

--*/

{
    UNREFERENCED_PARAMETER( EventTable );

    NpFreePool( Buffer );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\npfs\flushbuf.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    FlushBuf.c

Abstract:

    This module implements the File Flush Buffers routine for NPFS called by
    the dispatch driver.

Author:

    Gary Kimura     [GaryKi]    21-Aug-1990

Revision History:

--*/

#include "NpProcs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_FLUSH_BUFFERS)

//
//  local procedure prototypes
//

NTSTATUS
NpCommonFlushBuffers (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NpCommonFlushBuffers)
#pragma alloc_text(PAGE, NpFsdFlushBuffers)
#endif


NTSTATUS
NpFsdFlushBuffers (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtFlushBuffersFile API calls.

Arguments:

    NpfsDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpFsdFlushBuffers\n", 0);

    //
    //  Call the common Flush routine.
    //

    FsRtlEnterFileSystem();

    NpAcquireSharedVcb();

    Status = NpCommonFlushBuffers( NpfsDeviceObject, Irp );

    NpReleaseVcb();

    FsRtlExitFileSystem();

    if (Status != STATUS_PENDING) {
        NpCompleteRequest( Irp, Status );
    }
    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "NpFsdFlushBuffers -> %08lx\n", Status );

    return Status;
}


//
//  Internal support routine
//

NTSTATUS
NpCommonFlushBuffers (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for Flushing buffers for a file.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    PCCB Ccb;
    NAMED_PIPE_END NamedPipeEnd;

    PDATA_QUEUE WriteQueue;

    //
    //  Get the current stack location
    //

    PAGED_CODE();

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NpCommonFlushBuffers\n", 0);
    DebugTrace( 0, Dbg, "Irp        = %08lx\n", Irp);
    DebugTrace( 0, Dbg, "FileObject = %08lx\n", IrpSp->FileObject);

    //
    //  Decode the file object to figure out who we are.  If the result
    //  is not a ccb then the pipe has been disconnected.  We don't need the
    //  Fcb back from the call
    //

    if (NpDecodeFileObject( IrpSp->FileObject,
                            NULL,
                            &Ccb,
                            &NamedPipeEnd ) != NPFS_NTC_CCB) {

        DebugTrace(0, Dbg, "Pipe is disconnected from us\n", 0);

        Status = STATUS_PIPE_DISCONNECTED;

        DebugTrace(-1, Dbg, "NpCommonFlushBuffers -> %08lx\n", Status );
        return Status;
    }

    NpAcquireExclusiveCcb(Ccb);

    try {

        //
        //  Figure out the data queue that the flush buffer is
        //  targetted at.  It is the queue that we do writes into
        //

        if (NamedPipeEnd == FILE_PIPE_SERVER_END) {

            WriteQueue = &Ccb->DataQueue[ FILE_PIPE_OUTBOUND ];

        } else {

            WriteQueue = &Ccb->DataQueue[ FILE_PIPE_INBOUND ];
        }

        //
        //  Now from the write queue check if contains write entries.  If
        //  it does not contain write entries then we immediately complete
        //  this irp with success because there isn't anything to flush
        //

        if (!NpIsDataQueueWriters( WriteQueue )) {

            DebugTrace(0, Dbg, "Pipe does not contain write entries\n", 0);

            try_return(Status = STATUS_SUCCESS);
        }

        //
        //  Otherwise the queue is full of writes so we simply
        //  enqueue this irp to the back to the queue and set our
        //  return status to pending, also mark the irp pending
        //

        Status = NpAddDataQueueEntry( NamedPipeEnd,
                                      Ccb,
                                      WriteQueue,
                                      WriteEntries,
                                      Flush,
                                      0,
                                      Irp,
                                      NULL,
                                      0 );

    try_exit: NOTHING;
    } finally {
        NpReleaseCcb(Ccb);
    }


    DebugTrace(-1, Dbg, "NpCommonFlushBuffers -> %08lx\n", Status);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\npfs\nodetype.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    NodeType.h

Abstract:

    This module defines all of the node type codes used in this development
    shell.  Every major data structure in the file system is assigned a node
    type code that is.

Author:

    Gary Kimura     [GaryKi]    20-Aug-1990

Revision History:

--*/

#ifndef _NODETYPE_
#define _NODETYPE_

typedef UCHAR NODE_TYPE_CODE;
typedef NODE_TYPE_CODE *PNODE_TYPE_CODE;

#define NTC_UNDEFINED                    ((NODE_TYPE_CODE)0x00)

#define NPFS_NTC_VCB                     ((NODE_TYPE_CODE)0x01)

#define NPFS_NTC_ROOT_DCB                ((NODE_TYPE_CODE)0x02)

#define NPFS_NTC_FCB                     ((NODE_TYPE_CODE)0x04)

#define NPFS_NTC_CCB                     ((NODE_TYPE_CODE)0x06)
#define NPFS_NTC_NONPAGED_CCB            ((NODE_TYPE_CODE)0x07)

#define NPFS_NTC_ROOT_DCB_CCB            ((NODE_TYPE_CODE)0x08)

NODE_TYPE_CODE
FORCEINLINE
NodeType (
    IN PVOID FsContext
    )
{
    ULONG_PTR Ptr;
    Ptr = (ULONG_PTR) FsContext;
    Ptr &= ~(ULONG_PTR) 1;
    if (Ptr == 0) {
        return NTC_UNDEFINED;
    } else {
        return *(PNODE_TYPE_CODE) Ptr;
    }
}


//
//  The following definitions are used to generate meaningful blue bugcheck
//  screens.  On a bugcheck the file system can output 4 ulongs of useful
//  information.  The first ulong will have encoded in it a source file id
//  (in the high word) and the line number of the bugcheck (in the low word).
//  The other values can be whatever the caller of the bugcheck routine deems
//  necessary.
//
//  Each individual file that calls bugcheck needs to have defined at the
//  start of the file a constant called BugCheckFileId with one of the
//  NPFS_BUG_CHECK_ values defined below and then use NpBugCheck to bugcheck
//  the system.
//

#define NPFS_BUG_CHECK_CLEANUP           (0x00010000)
#define NPFS_BUG_CHECK_CLOSE             (0x00020000)
#define NPFS_BUG_CHECK_CREATE            (0x00030000)
#define NPFS_BUG_CHECK_CREATENP          (0x00040000)
#define NPFS_BUG_CHECK_DIR               (0x00050000)
#define NPFS_BUG_CHECK_DATASUP           (0x00060000)
#define NPFS_BUG_CHECK_DEVIOSUP          (0x00070000)
#define NPFS_BUG_CHECK_DUMPSUP           (0x00080000)
#define NPFS_BUG_CHECK_EVENTSUP          (0x00090000)
#define NPFS_BUG_CHECK_FILEINFO          (0x000a0000)
#define NPFS_BUG_CHECK_FILOBSUP          (0x000b0000)
#define NPFS_BUG_CHECK_FLUSHBUF          (0x000c0000)
#define NPFS_BUG_CHECK_FSCTRL            (0x000d0000)
#define NPFS_BUG_CHECK_NPINIT            (0x000e0000)
#define NPFS_BUG_CHECK_NPDATA            (0x000f0000)
#define NPFS_BUG_CHECK_PREFXSUP          (0x00100000)
#define NPFS_BUG_CHECK_READ              (0x00110000)
#define NPFS_BUG_CHECK_READSUP           (0x00120000)
#define NPFS_BUG_CHECK_RESRCSUP          (0x00130000)
#define NPFS_BUG_CHECK_SEINFO            (0x00140000)
#define NPFS_BUG_CHECK_SECURSUP          (0x00150000)
#define NPFS_BUG_CHECK_STATESUP          (0x00160000)
#define NPFS_BUG_CHECK_STRUCSUP          (0x00170000)
#define NPFS_BUG_CHECK_VOLINFO           (0x00180000)
#define NPFS_BUG_CHECK_WAITSUP           (0x00190000)
#define NPFS_BUG_CHECK_WRITE             (0x001a0000)
#define NPFS_BUG_CHECK_WRITESUP          (0x001b0000)

#define NpBugCheck(A,B,C) { KeBugCheckEx(NPFS_FILE_SYSTEM, BugCheckFileId | __LINE__, A, B, C ); }


//
//  In this module we'll also define some globally known constants
//

#define UCHAR_NUL                        0x00
#define UCHAR_SOH                        0x01
#define UCHAR_STX                        0x02
#define UCHAR_ETX                        0x03
#define UCHAR_EOT                        0x04
#define UCHAR_ENQ                        0x05
#define UCHAR_ACK                        0x06
#define UCHAR_BEL                        0x07
#define UCHAR_BS                         0x08
#define UCHAR_HT                         0x09
#define UCHAR_LF                         0x0a
#define UCHAR_VT                         0x0b
#define UCHAR_FF                         0x0c
#define UCHAR_CR                         0x0d
#define UCHAR_SO                         0x0e
#define UCHAR_SI                         0x0f
#define UCHAR_DLE                        0x10
#define UCHAR_DC1                        0x11
#define UCHAR_DC2                        0x12
#define UCHAR_DC3                        0x13
#define UCHAR_DC4                        0x14
#define UCHAR_NAK                        0x15
#define UCHAR_SYN                        0x16
#define UCHAR_ETB                        0x17
#define UCHAR_CAN                        0x18
#define UCHAR_EM                         0x19
#define UCHAR_SUB                        0x1a
#define UCHAR_ESC                        0x1b
#define UCHAR_FS                         0x1c
#define UCHAR_GS                         0x1d
#define UCHAR_RS                         0x1e
#define UCHAR_US                         0x1f
#define UCHAR_SP                         0x20

#endif // _NODETYPE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\npfs\npdata.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    NpData.c

Abstract:

    This module declares the global data used by the Named Pipe file system.

Author:

    Gary Kimura     [GaryKi]    28-Dec-1989

Revision History:

--*/

#include "NpProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (NPFS_BUG_CHECK_NPDATA)

//
//  Local debug trace level
//

#define Dbg                              (DEBUG_TRACE_CATCH_EXCEPTIONS)


PVCB NpVcb = NULL;

FAST_IO_DISPATCH NpFastIoDispatch = { sizeof(FAST_IO_DISPATCH),
                                      NULL,         //  FastIoCheck
                                      NpFastRead,   //  Read
                                      NpFastWrite,  //  Write
                                      NULL,         //  QueryBasicInfo
                                      NULL,         //  QueryStandardInfo
                                      NULL,         //  Lock
                                      NULL,         //  UnlockSingle
                                      NULL,         //  UnlockAll
                                      NULL };       //  UnlockAllByKey

//
//  Lists of pipe name aliases.
//

SINGLE_LIST_ENTRY NpAliasListByLength[(MAX_LENGTH_ALIAS_ARRAY-MIN_LENGTH_ALIAS_ARRAY)/sizeof(WCHAR)+1] = {NULL};
SINGLE_LIST_ENTRY NpAliasList = {NULL};

PVOID NpAliases = NULL; // single allocation containing all aliases


#ifdef NPDBG
LONG NpDebugTraceLevel = 0x00000000;
LONG NpDebugTraceIndent = 0;
#endif // NPDBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\npfs\filobsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    FilObSup.c

Abstract:

    This module implements the Named Pipe File object support routines.

Author:

    Gary Kimura     [GaryKi]    30-Aug-1990

Revision History:

--*/

#include "NpProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (NPFS_BUG_CHECK_FILOBSUP)

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_FILOBSUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NpDecodeFileObject)
#pragma alloc_text(PAGE, NpSetFileObject)
#endif


VOID
NpSetFileObject (
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PVOID FsContext,
    IN PVOID FsContext2,
    IN NAMED_PIPE_END NamedPipeEnd
    )

/*++

Routine Description:

    This routine sets the file system pointers within the file object
    and handles the indicator for storing the named pipe end.

Arguments:

    FileObject - Supplies a pointer to the file object being modified, and
        can optionally be null.

    FsContext - Supplies a pointer to either a ccb, vcb, or root_dcb
        structure.

    FsContext2 - Supplies a pointer to either a nonpaged ccb, root_dcb_ccb,
        or is null

    NamedPipeEnd - Supplies the indication if this is either the server end
        or client end file object.  This is only applicable if the
        fscontext points to a ccb.

Return Value:

    None.

--*/

{
    BOOLEAN GotCcb;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpSetFileObject, FileObject = %08lx\n", FileObject );

    //
    //  If no file object was given, do nothing.
    //

    if (ARGUMENT_PRESENT( FileObject )) {

        //
        //  Check if we need to add in the named pipe end to the
        //  fscontext pointer.  We only need to 'OR' in a 1 if this is
        //  the server end and fscontext points to a ccb.  Also remember
        //  now if this is a pointer is a ccb, so that we can later set
        //  the fo_named_pipe flag
        //

        if ((FsContext != NULL) &&
            (*(PNODE_TYPE_CODE)FsContext == NPFS_NTC_CCB)) {

            GotCcb = TRUE;

            if (NamedPipeEnd == FILE_PIPE_SERVER_END) {

                FsContext = (PVOID)((ULONG_PTR)FsContext | 0x00000001);
            }

        } else {

            GotCcb = FALSE;
        }

        //
        //  Now set the fscontext fields of the file object, and conditionally
        //  set the named pipe flag in the file object if necessary.
        //

        FileObject->FsContext  = FsContext;
        FileObject->FsContext2 = FsContext2;

        //
        //  Set the private cache map to 1 and that what we will get our
        //  fast I/O routines called
        //

        FileObject->PrivateCacheMap = (PVOID)1;

        if (GotCcb) {

            FileObject->Flags |= FO_NAMED_PIPE;
        }
    }

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "NpSetFileObject -> VOID\n", 0);

    return;
}


NODE_TYPE_CODE
NpDecodeFileObject (
    IN PFILE_OBJECT FileObject,
    OUT PFCB *Fcb OPTIONAL,
    OUT PCCB *Ccb,
    OUT PNAMED_PIPE_END NamedPipeEnd OPTIONAL
    )

/*++

Routine Description:

    This procedure takes a pointer to a file object, that has already been
    opened by the named pipe file system and figures out what it really
    is opened.

Arguments:

    FileObject - Supplies the file object pointer being interrogated

    Fcb - Receives a pointer to the Fcb for the file object, if we can
        find it.

    Ccb - Receives a pointer to the Ccb for the file object, if we can
        find it

    NamedPipeEnd - Receives a value indicating if this is a server
        or client end file object.

Return Value:

    NODE_TYPE_CODE - Returns the node type code for a Vcb, RootDcb, Ccb,
        or zero.

        Vcb - indicates that file object opens the named pipe driver.
            Fcb and Ccb are NOT returned.

        RootDcb - indicates that the file object is for the root directory.
            Fcb (RootDcb), and Ccb (RootDcbCcb) are set.

        Ccb - indicates that the file object is for a named pipe instance.
            Ccb is set, while Fcb is optionally set.

        Zero - indicates that the file object was for a named pipe instance
            but became disconnected.  Fcb, Ccb, and NamedPipeEnd are NOT
            returned.

--*/

{
    NODE_TYPE_CODE NodeTypeCode;
    PVOID FsContext;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpDecodeFileObject, FileObject = %08lx\n", FileObject);

    //
    //  Reference the fs context fields of the file object.
    //

    FsContext = FileObject->FsContext;

    //
    //  If the fscontext field is null then we been disconnected.
    //

    if ((FsContext == NULL) || ((ULONG_PTR)FsContext == 1)) {

        NodeTypeCode = NTC_UNDEFINED;

    } else {

        //
        //  We're actually pointing to something so first extract the
        //  named pipe end information and then we can reference through
        //  the fscontext pointer after we clean it up.
        //

        if (ARGUMENT_PRESENT(NamedPipeEnd)) {
            if (FlagOn((ULONG_PTR)FsContext, 0x00000001)) {
                *NamedPipeEnd = FILE_PIPE_SERVER_END;
            } else {
                *NamedPipeEnd = FILE_PIPE_CLIENT_END;
            }
        }

        FsContext = (PVOID)((ULONG_PTR)FsContext & ~0x00000001);

        //
        //  Now we can case on the node type code of the fscontext pointer
        //  and set the appropriate out pointers
        //

        NodeTypeCode = *(PNODE_TYPE_CODE)FsContext;

        switch (NodeTypeCode) {

        case NPFS_NTC_VCB:

            break;

        case NPFS_NTC_ROOT_DCB:

            *Ccb = FileObject->FsContext2;
            if (ARGUMENT_PRESENT(Fcb)) {
                *Fcb = FsContext;
            }
            break;

        case NPFS_NTC_CCB:

            *Ccb = FsContext;
            if (ARGUMENT_PRESENT(Fcb)) {
                *Fcb = ((PCCB)FsContext)->Fcb;
            }
            break;

        default:

            NpBugCheck( NodeTypeCode, 0, 0 );
        }
    }

    //
    //  and return to our caller
    //

    DebugTrace(-1, Dbg, "NpDecodeFileObject -> %08lx\n", NodeTypeCode);

    return NodeTypeCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\npfs\npdata.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    NpData.c

Abstract:

    This module declares the global data used by the Named Pipe file system.

Author:

    Gary Kimura     [GaryKi]    20-Aug-1990

Revision History:

--*/

#ifndef _NPDATA_
#define _NPDATA_

extern PVCB NpVcb;

//
//  The global structure used to contain our fast I/O callbacks
//

extern FAST_IO_DISPATCH NpFastIoDispatch;

//
//  Lists of pipe name aliases.
//

#define MIN_LENGTH_ALIAS_ARRAY (5 * sizeof(WCHAR)) // includes '\'
#define MAX_LENGTH_ALIAS_ARRAY (9 * sizeof(WCHAR))

extern SINGLE_LIST_ENTRY NpAliasListByLength[(MAX_LENGTH_ALIAS_ARRAY-MIN_LENGTH_ALIAS_ARRAY)/sizeof(WCHAR)+1];
extern SINGLE_LIST_ENTRY NpAliasList;

extern PVOID NpAliases; // single allocation containing all aliases

//
//  The global Named Pipe debug level variable, its values are:
//
//      0x00000000      Always gets printed (used when about to bug check)
//
//      0x00000001
//      0x00000002
//      0x00000004
//      0x00000008
//
//      0x00000010
//      0x00000020
//      0x00000040
//      0x00000080
//
//      0x00000100
//      0x00000200
//      0x00000400
//      0x00000800
//
//      0x00001000
//      0x00002000
//      0x00004000
//      0x00008000
//
//      0x00010000
//      0x00020000
//      0x00040000
//      0x00080000
//
//      0x00100000
//      0x00200000
//      0x00400000
//      0x00800000
//
//      0x01000000
//      0x02000000
//      0x04000000
//      0x08000000
//
//      0x10000000
//      0x20000000
//      0x40000000
//      0x80000000
//

#ifdef NPDBG

#define DEBUG_TRACE_ERROR                (0x00000001)
#define DEBUG_TRACE_DEBUG_HOOKS          (0x00000002)
#define DEBUG_TRACE_CATCH_EXCEPTIONS     (0x00000004)
#define DEBUG_TRACE_CREATE               (0x00000008)
#define DEBUG_TRACE_CLOSE                (0x00000010)
#define DEBUG_TRACE_READ                 (0x00000020)
#define DEBUG_TRACE_WRITE                (0x00000040)
#define DEBUG_TRACE_FILEINFO             (0x00000080)
#define DEBUG_TRACE_CLEANUP              (0x00000100)
#define DEBUG_TRACE_DIR                  (0x00000200)
#define DEBUG_TRACE_FSCONTRL             (0x00000400)
#define DEBUG_TRACE_CREATE_NAMED_PIPE    (0x00000800)
#define DEBUG_TRACE_FLUSH_BUFFERS        (0x00001000)
#define DEBUG_TRACE_VOLINFO              (0x00002000)
#define DEBUG_TRACE_SEINFO               (0x00004000)
#define DEBUG_TRACE_0x00008000           (0x00008000)
#define DEBUG_TRACE_0x00010000           (0x00010000)
#define DEBUG_TRACE_SECURSUP             (0x00020000)
#define DEBUG_TRACE_DEVIOSUP             (0x00040000)
#define DEBUG_TRACE_RESRCSUP             (0x00080000)
#define DEBUG_TRACE_READSUP              (0x00100000)
#define DEBUG_TRACE_WRITESUP             (0x00200000)
#define DEBUG_TRACE_STATESUP             (0x00400000)
#define DEBUG_TRACE_FILOBSUP             (0x00800000)
#define DEBUG_TRACE_PREFXSUP             (0x01000000)
#define DEBUG_TRACE_CNTXTSUP             (0x02000000)
#define DEBUG_TRACE_DATASUP              (0x04000000)
#define DEBUG_TRACE_WAITSUP              (0x08000000)
#define DEBUG_TRACE_EVENTSUP             (0x10000000)
#define DEBUG_TRACE_STRUCSUP             (0x20000000)

extern LONG NpDebugTraceLevel;
extern LONG NpDebugTraceIndent;

#define DebugTrace(INDENT,LEVEL,X,Y) {                     \
    LONG _i;                                               \
    if (((LEVEL) == 0) || (NpDebugTraceLevel & (LEVEL))) { \
        DbgPrint("%p:",PsGetCurrentThread());              \
        if ((INDENT) < 0) {                                \
            NpDebugTraceIndent += (INDENT);                \
        }                                                  \
        if (NpDebugTraceIndent < 0) {                      \
            NpDebugTraceIndent = 0;                        \
        }                                                  \
        for (_i=0; _i<NpDebugTraceIndent; _i+=1) {         \
            DbgPrint(" ");                                 \
        }                                                  \
        DbgPrint(X,Y);                                     \
        if ((INDENT) > 0) {                                \
            NpDebugTraceIndent += (INDENT);                \
        }                                                  \
    }                                                      \
}

#define DebugDump(STR,LEVEL,PTR) {                         \
    VOID NpDump(PVOID Ptr);                                \
    if (((LEVEL) == 0) || (NpDebugTraceLevel & (LEVEL))) { \
        DbgPrint("%p:",PsGetCurrentThread());              \
        DbgPrint(STR);                                     \
        if (PTR != NULL) {NpDump(PTR);}                    \
        DbgBreakPoint();                                   \
    }                                                      \
}

#else

#define DebugTrace(INDENT,LEVEL,X,Y)     {NOTHING;}
#define DebugDump(STR,LEVEL,PTR)         {NOTHING;}

#endif // NPDBG

//
//  The following macro is for all people who compile with the DBG switch
//  set, not just fastfat dbg users
//

#if DBG

#define DbgDoit(X)                       {X;}

#else

#define DbgDoit(X)                       {NOTHING;}

#endif // DBG



#endif // _NPDATA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\npfs\npprocs.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    NpProcs.h

Abstract:

    This module defines all of the globally used procedures in the Named
    Pipe file system.

Author:

    Gary Kimura     [GaryKi]    20-Aug-1990

Revision History:

--*/

#ifndef _NPPROCS_
#define _NPPROCS_

#define _NTSRV_
#define _NTDDK_


#include <Ntos.h>
#include <FsRtl.h>
#include <String.h>

//
//  This macro returns TRUE if a flag in a set of flags is on and FALSE
//  otherwise
//

#define FlagOn(Flags,SingleFlag)        ((Flags) & (SingleFlag))

#include "NodeType.h"
#include "NpStruc.h"
#include "NpData.h"

//
//  Tag all of our allocations if tagging is turned on
//

#undef FsRtlAllocatePool
#undef FsRtlAllocatePoolWithQuota

#define FsRtlAllocatePool(a,b) FsRtlAllocatePoolWithTag(a,b,'sfpN')
#define FsRtlAllocatePoolWithQuota(a,b) FsRtlAllocatePoolWithQuotaTag(a,b,'sfpN')


//
//  Data queue support routines, implemented in DataSup.c
//

NTSTATUS
NpInitializeDataQueue (
    IN PDATA_QUEUE DataQueue,
    IN ULONG Quota
    );

VOID
NpUninitializeDataQueue (
    IN PDATA_QUEUE DataQueue
    );

NTSTATUS
NpAddDataQueueEntry (
    IN NAMED_PIPE_END NamedPipeEnd,
    IN PCCB Ccb,
    IN PDATA_QUEUE DataQueue,
    IN QUEUE_STATE Who,
    IN DATA_ENTRY_TYPE Type,
    IN ULONG DataSize,
    IN PIRP Irp OPTIONAL,
    IN PVOID DataPointer OPTIONAL,
    IN ULONG ByteOffset
    );

PIRP
NpRemoveDataQueueEntry (
    IN PDATA_QUEUE DataQueue,
    IN BOOLEAN CompletedFlushes,
    IN PLIST_ENTRY DeferredList
    );

VOID
NpCompleteStalledWrites (
    IN PDATA_QUEUE DataQueue,
    IN PLIST_ENTRY DeferredList
    );

//PDATA_ENTRY
//NpGetNextDataQueueEntry (
//    IN PDATA_QUEUE DataQueue,
//    IN PDATA_ENTRY PreviousDataEntry OPTIONAL
//    );
#define NpGetNextDataQueueEntry(_dq,_pde) \
    ((_pde) != NULL ? (PDATA_ENTRY)(((PDATA_ENTRY)(_pde))->Queue.Flink) : \
                      (PDATA_ENTRY)(((PDATA_QUEUE)(_dq))->Queue.Flink))

PDATA_ENTRY
NpGetNextRealDataQueueEntry (
    IN PDATA_QUEUE DataQueue,
    IN PLIST_ENTRY DeferredList
    );

//BOOLEAN
//NpIsDataQueueEmpty (
//    IN PDATA_QUEUE DataQueue
//    );
#define NpIsDataQueueEmpty(_dq) ((_dq)->QueueState == Empty)

//BOOLEAN
//NpIsDataQueueReaders (
//    IN PDATA_QUEUE DataQueue
//    );
#define NpIsDataQueueReaders(_dq) ((_dq)->QueueState == ReadEntries)

//BOOLEAN
//NpIsDataQueueWriters (
//    IN PDATA_QUEUE DataQueue
//    );
#define NpIsDataQueueWriters(_dq) ((_dq)->QueueState == WriteEntries)


//
//  The following routines are used to manipulate the input buffers and are
//  implemented in DevioSup.c
//

//PVOID
//NpMapUserBuffer (
//    IN OUT PIRP Irp
//    );
#define NpMapUserBuffer(_irp)                                               \
    (Irp->MdlAddress == NULL ? Irp->UserBuffer :                            \
                               MmGetSystemAddressForMdl( Irp->MdlAddress ))


VOID
NpLockUserBuffer (
    IN OUT PIRP Irp,
    IN LOCK_OPERATION Operation,
    IN ULONG BufferLength
    );


//
//  The event support routines, implemented in EventSup.c
//

RTL_GENERIC_COMPARE_RESULTS
NpEventTableCompareRoutine (
    IN PRTL_GENERIC_TABLE EventTable,
    IN PVOID FirstStruct,
    IN PVOID SecondStruct
    );

PVOID
NpEventTableAllocate (
    IN PRTL_GENERIC_TABLE EventTable,
    IN CLONG ByteSize
    );

VOID
NpEventTableDeallocate (
    IN PRTL_GENERIC_TABLE EventTable,
    IN PVOID Buffer
    );

//
//  VOID
//  NpInitializeEventTable (
//      IN PEVENT_TABLE EventTable
//      );
//

#define NpInitializeEventTable(_et) {                       \
    RtlInitializeGenericTable( &(_et)->Table,               \
                               NpEventTableCompareRoutine,  \
                               NpEventTableAllocate,        \
                               NpEventTableDeallocate,      \
                               NULL );       \
}


//VOID
//NpUninitializeEventTable (
//    IN PEVENT_TABLE EventTable
//    );
#define NpUninitializeEventTable(_et) NOTHING

NTSTATUS
NpAddEventTableEntry (
    IN  PEVENT_TABLE EventTable,
    IN  PCCB Ccb,
    IN  NAMED_PIPE_END NamedPipeEnd,
    IN  HANDLE EventHandle,
    IN  ULONG KeyValue,
    IN  PEPROCESS Process,
    IN  KPROCESSOR_MODE PreviousMode,
    OUT PEVENT_TABLE_ENTRY *ppEventTableEntry
    );

VOID
NpDeleteEventTableEntry (
    IN PEVENT_TABLE EventTable,
    IN PEVENT_TABLE_ENTRY Template
    );

// VOID
// NpSignalEventTableEntry (
//    IN PEVENT_TABLE_ENTRY EventTableEntry OPTIONAL
//    );
#define NpSignalEventTableEntry(_ete)                   \
    if (ARGUMENT_PRESENT(_ete)) {                       \
        KeSetEvent((PKEVENT)(_ete)->Event, 0, FALSE);   \
    }

PEVENT_TABLE_ENTRY
NpGetNextEventTableEntry (
    IN PEVENT_TABLE EventTable,
    IN PVOID *RestartKey
    );


//
//  The following routines are used to manipulate the fscontext fields of
//  a file object, implemented in FilObSup.c
//

VOID
NpSetFileObject (
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PVOID FsContext,
    IN PVOID FsContext2,
    IN NAMED_PIPE_END NamedPipeEnd
    );

NODE_TYPE_CODE
NpDecodeFileObject (
    IN PFILE_OBJECT FileObject,
    OUT PFCB *Fcb OPTIONAL,
    OUT PCCB *Ccb,
    OUT PNAMED_PIPE_END NamedPipeEnd OPTIONAL
    );


//
//  Largest matching prefix searching routines, implemented in PrefxSup.c
//

PFCB
NpFindPrefix (
    IN PUNICODE_STRING String,
    IN BOOLEAN CaseInsensitive,
    OUT PUNICODE_STRING RemainingPart
    );

NTSTATUS
NpFindRelativePrefix (
    IN PDCB Dcb,
    IN PUNICODE_STRING String,
    IN BOOLEAN CaseInsensitive,
    OUT PUNICODE_STRING RemainingPart,
    OUT PFCB *ppFcb
    );


//
//  Pipe name aliases, implemented in AliasSup.c
//

NTSTATUS
NpInitializeAliases (
    VOID
    );

VOID
NpUninitializeAliases (
    VOID
    );

NTSTATUS
NpTranslateAlias (
    IN OUT PUNICODE_STRING String
    );


//
//  The follow routine provides common read data queue support
//  for buffered read, unbuffered read, peek, and transceive
//

IO_STATUS_BLOCK
NpReadDataQueue (
    IN PDATA_QUEUE ReadQueue,
    IN BOOLEAN PeekOperation,
    IN BOOLEAN ReadOverflowOperation,
    IN PUCHAR ReadBuffer,
    IN ULONG ReadLength,
    IN READ_MODE ReadMode,
    IN PCCB Ccb,
    IN PLIST_ENTRY DeferredList
    );


//
//  The following routines are used for setting and manipulating the
//  security fields in the data entry, and nonpaged ccb, implemented in
//  SecurSup.c
//

NTSTATUS
NpInitializeSecurity (
    IN PCCB Ccb,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    IN PETHREAD UserThread
    );

VOID
NpUninitializeSecurity (
    IN PCCB Ccb
    );

NTSTATUS
NpGetClientSecurityContext (
    IN  NAMED_PIPE_END NamedPipeEnd,
    IN  PCCB Ccb,
    IN  PETHREAD UserThread,
    OUT PSECURITY_CLIENT_CONTEXT *ppSecurityContext
    );

VOID
NpFreeClientSecurityContext (
    IN PSECURITY_CLIENT_CONTEXT SecurityContext
    );

VOID
NpCopyClientContext (
    IN PCCB Ccb,
    IN PDATA_ENTRY DataEntry
    );

NTSTATUS
NpImpersonateClientContext (
    IN PCCB Ccb
    );


//
//  The following routines are used to manipulate the named pipe state
//  implemented in StateSup.c
//

VOID
NpInitializePipeState (
    IN PCCB Ccb,
    IN PFILE_OBJECT ServerFileObject
    );

VOID
NpUninitializePipeState (
    IN PCCB Ccb
    );

NTSTATUS
NpSetListeningPipeState (
    IN PCCB Ccb,
    IN PIRP Irp,
    IN PLIST_ENTRY DeferredList
    );

NTSTATUS
NpSetConnectedPipeState (
    IN PCCB Ccb,
    IN PFILE_OBJECT ClientFileObject,
    IN PLIST_ENTRY DeferredList
    );

NTSTATUS
NpSetClosingPipeState (
    IN PCCB Ccb,
    IN PIRP Irp,
    IN NAMED_PIPE_END NamedPipeEnd,
    IN PLIST_ENTRY DeferredList
    );

NTSTATUS
NpSetDisconnectedPipeState (
    IN PCCB Ccb,
    IN PLIST_ENTRY DeferredList
    );


//
//  Internal Named Pipe data Structure Routines, implemented in StrucSup.c.
//
//  These routines maniuplate the in memory data structures.
//

VOID
NpInitializeVcb (
    VOID
    );

VOID
NpDeleteVcb (
    IN PLIST_ENTRY DeferredList
    );

NTSTATUS
NpCreateRootDcb (
    VOID
    );

VOID
NpDeleteRootDcb (
    IN PROOT_DCB Dcb,
    IN PLIST_ENTRY DeferredList
    );

NTSTATUS
NpCreateFcb (
    IN  PDCB ParentDcb,
    IN  PUNICODE_STRING FileName,
    IN  ULONG MaximumInstances,
    IN  LARGE_INTEGER DefaultTimeOut,
    IN  NAMED_PIPE_CONFIGURATION NamedPipeConfiguration,
    IN  NAMED_PIPE_TYPE NamedPipeType,
    OUT PFCB *ppFcb
    );

VOID
NpDeleteFcb (
    IN PFCB Fcb,
    IN PLIST_ENTRY DeferredList
    );

NTSTATUS
NpCreateCcb (
    IN  PFCB Fcb,
    IN  PFILE_OBJECT ServerFileObject,
    IN  NAMED_PIPE_STATE NamedPipeState,
    IN  READ_MODE ServerReadMode,
    IN  COMPLETION_MODE ServerCompletionMode,
    IN  ULONG InBoundQuota,
    IN  ULONG OutBoundQuota,
    OUT PCCB *ppCcb
    );

NTSTATUS
NpCreateRootDcbCcb (
    OUT PROOT_DCB_CCB *ppCcb
    );

VOID
NpDeleteCcb (
    IN PCCB Ccb,
    IN PLIST_ENTRY DeferredList
    );


//
//  Waiting for a named pipe support routines, implemented in WaitSup.c
//

VOID
NpInitializeWaitQueue (
    IN PWAIT_QUEUE WaitQueue
    );

VOID
NpUninitializeWaitQueue (
    IN PWAIT_QUEUE WaitQueue
    );

NTSTATUS
NpAddWaiter (
    IN PWAIT_QUEUE WaitQueue,
    IN LARGE_INTEGER DefaultTimeOut,
    IN PIRP Irp,
    IN PUNICODE_STRING TranslatedString
    );

NTSTATUS
NpCancelWaiter (
    IN PWAIT_QUEUE WaitQueue,
    IN PUNICODE_STRING NameOfPipe,
    IN NTSTATUS CompletionStatus,
    IN PLIST_ENTRY DeferredList
    );


//
//  The follow routine provides common write data queue support
//  for buffered write, unbuffered write, peek, and transceive
//

NTSTATUS
NpWriteDataQueue (                      // implemented in WriteSup.c
    IN PDATA_QUEUE WriteQueue,
    IN READ_MODE ReadMode,
    IN PUCHAR WriteBuffer,
    IN ULONG WriteLength,
    IN NAMED_PIPE_TYPE PipeType,
    OUT PULONG WriteRemaining,
    IN PCCB Ccb,
    IN NAMED_PIPE_END NamedPipeEnd,
    IN PETHREAD UserThread,
    IN PLIST_ENTRY DeferredList
    );


//
//  Miscellaneous support routines
//

#define BooleanFlagOn(F,SF) (    \
    (BOOLEAN)(((F) & (SF)) != 0) \
)

//
//  This macro takes a pointer (or ulong) and returns its rounded up word
//  value
//

#define WordAlign(Ptr) (                \
    ((((ULONG)(Ptr)) + 1) & 0xfffffffe) \
    )

//
//  This macro takes a pointer (or ulong) and returns its rounded up longword
//  value
//

#define LongAlign(Ptr) (                \
    ((((ULONG)(Ptr)) + 3) & 0xfffffffc) \
    )

//
//  This macro takes a pointer (or ulong) and returns its rounded up quadword
//  value
//

#define QuadAlign(Ptr) (                \
    ((((ULONG)(Ptr)) + 7) & 0xfffffff8) \
    )

//
//  The following types and macros are used to help unpack the packed and
//  misaligned fields found in the Bios parameter block
//

typedef union _UCHAR1 {
    UCHAR  Uchar[1];
    UCHAR  ForceAlignment;
} UCHAR1, *PUCHAR1;

typedef union _UCHAR2 {
    UCHAR  Uchar[2];
    USHORT ForceAlignment;
} UCHAR2, *PUCHAR2;

typedef union _UCHAR4 {
    UCHAR  Uchar[4];
    ULONG  ForceAlignment;
} UCHAR4, *PUCHAR4;

//
//  This macro copies an unaligned src byte to an aligned dst byte
//

#define CopyUchar1(Dst,Src) {                                \
    *((UCHAR1 *)(Dst)) = *((UNALIGNED UCHAR1 *)(Src)); \
    }

//
//  This macro copies an unaligned src word to an aligned dst word
//

#define CopyUchar2(Dst,Src) {                                \
    *((UCHAR2 *)(Dst)) = *((UNALIGNED UCHAR2 *)(Src)); \
    }

//
//  This macro copies an unaligned src longword to an aligned dsr longword
//

#define CopyUchar4(Dst,Src) {                                \
    *((UCHAR4 *)(Dst)) = *((UNALIGNED UCHAR4 *)(Src)); \
    }


//
//  VOID
//  NpAcquireExclusiveVcb (
//      );
//
//  VOID
//  NpAcquireSharedVcb (
//      );
//
//  VOID
//  NpReleaseVcb (
//      );
//

#define NpAcquireExclusiveVcb() (VOID)ExAcquireResourceExclusiveLite( &NpVcb->Resource, TRUE )

#define NpAcquireSharedVcb()    (VOID)ExAcquireResourceSharedLite( &NpVcb->Resource, TRUE )

#define NpReleaseVcb()          ExReleaseResourceLite( &NpVcb->Resource )

#define NpAcquireExclusiveCcb(Ccb) ExAcquireResourceExclusiveLite(&Ccb->NonpagedCcb->Resource,TRUE);
#define NpReleaseCcb(Ccb) ExReleaseResourceLite(&Ccb->NonpagedCcb->Resource);

#define NpIsAcquiredExclusiveVcb(VCB) ExIsResourceAcquiredExclusiveLite( &(VCB)->Resource )


//
//  The FSD Level dispatch routines.   These routines are called by the
//  I/O system via the dispatch table in the Driver Object.
//
//  They each accept as input a pointer to a device object (actually most
//  expect an npfs device object), and a pointer to the IRP.
//

NTSTATUS
NpFsdCreate (                           //  implemented in Create.c
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NpFsdCreateNamedPipe (                  //  implemented in CreateNp.c
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NpFsdClose (                            //  implemented in Close.c
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NpFsdRead (                             //  implemented in Read.c
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NpFsdWrite (                            //  implemented in Write.c
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NpFsdQueryInformation (                 //  implemented in FileInfo.c
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NpFsdSetInformation (                   //  implemented in FileInfo.c
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NpFsdCleanup (                          //  implemented in Cleanup.c
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NpFsdFlushBuffers (                     //  implemented in Flush.c
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NpFsdDirectoryControl (                 //  implemented in Dir.c
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NpFsdFileSystemControl (                //  implemented in FsContrl.c
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NpFsdSetSecurityInfo (                  //  implemented in SeInfo.c
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NpFsdQuerySecurityInfo (                //  implemented in SeInfo.c
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NpFsdQueryVolumeInformation (           //  implemented in VolInfo.c
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );


NTSTATUS
NpCommonFileSystemControl (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NpAssignEvent (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NpDisconnect (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp,
    IN PLIST_ENTRY DeferredList
    );

NTSTATUS
NpListen (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp,
    IN PLIST_ENTRY DeferredList
    );

NTSTATUS
NpPeek (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp,
    IN PLIST_ENTRY DeferredList
    );

NTSTATUS
NpQueryEvent (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NpTransceive (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp,
    IN PLIST_ENTRY DeferredList
    );

NTSTATUS
NpWaitForNamedPipe (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NpImpersonate (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NpInternalRead (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp,
    IN BOOLEAN ReadOverflowOperation,
    IN PLIST_ENTRY DeferredList
    );

NTSTATUS
NpInternalWrite (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp,
    IN PLIST_ENTRY DeferredList
    );

NTSTATUS
NpInternalTransceive (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp,
    IN PLIST_ENTRY DeferredList
    );

NTSTATUS
NpQueryClientProcess (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NpSetClientProcess (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NpCompleteTransceiveIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );


//
//  The following procedures are callbacks used to do fast I/O
//

BOOLEAN
NpFastRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
NpFastWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
NpCommonWrite (
    IN PFILE_OBJECT FileObject,
    IN PVOID WriteBuffer,
    IN ULONG WriteLength,
    IN PETHREAD UserThread,
    OUT PIO_STATUS_BLOCK Iosb,
    IN PIRP Irp OPTIONAL,
    IN PLIST_ENTRY DeferredList
    );


//
// Miscellaneous routines.
//

VOID
NpCheckForNotify (                      //  implemented in Dir.c
    IN PDCB Dcb,
    IN BOOLEAN CheckAllOutstandingIrps,
    IN PLIST_ENTRY DeferredList
    );

NTSTATUS
NpCommonQueryInformation (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );


NTSTATUS
NpCommonSetInformation (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp,
    IN PLIST_ENTRY DeferredList
    );

NTSTATUS
NpQueryBasicInfo (
    IN PCCB Ccb,
    IN PFILE_BASIC_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
NpQueryStandardInfo (
    IN PCCB Ccb,
    IN PFILE_STANDARD_INFORMATION Buffer,
    IN OUT PULONG Length,
    IN NAMED_PIPE_END NamedPipeEnd
    );

NTSTATUS
NpQueryInternalInfo (
    IN PCCB Ccb,
    IN PFILE_INTERNAL_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
NpQueryEaInfo (
    IN PCCB Ccb,
    IN PFILE_EA_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
NpQueryNameInfo (
    IN PCCB Ccb,
    IN PFILE_NAME_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
NpQueryPositionInfo (
    IN PCCB Ccb,
    IN PFILE_POSITION_INFORMATION Buffer,
    IN OUT PULONG Length,
    IN NAMED_PIPE_END NamedPipeEnd
    );

NTSTATUS
NpQueryPipeInfo (
    IN PFCB Fcb,
    IN PCCB Ccb,
    IN PFILE_PIPE_INFORMATION Buffer,
    IN OUT PULONG Length,
    IN NAMED_PIPE_END NamedPipeEnd
    );

NTSTATUS
NpQueryPipeLocalInfo (
    IN PFCB Fcb,
    IN PCCB Ccb,
    IN PFILE_PIPE_LOCAL_INFORMATION Buffer,
    IN OUT PULONG Length,
    IN NAMED_PIPE_END NamedPipeEnd
    );

NTSTATUS
NpSetBasicInfo (
    IN PCCB Ccb,
    IN PFILE_BASIC_INFORMATION Buffer
    );

NTSTATUS
NpSetPipeInfo (
    IN PFCB Fcb,
    IN PCCB Ccb,
    IN PFILE_PIPE_INFORMATION Buffer,
    IN NAMED_PIPE_END NamedPipeEnd,
    IN PLIST_ENTRY DeferredList
    );

IO_STATUS_BLOCK
NpCreateClientEnd(
    IN PFCB Fcb,
    IN PFILE_OBJECT FileObject,
    IN ACCESS_MASK DesiredAccess,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    IN PACCESS_STATE AccessState,
    IN KPROCESSOR_MODE RequestorMode,
    IN PETHREAD UserThread,
    IN PLIST_ENTRY DeferredList
    );

IO_STATUS_BLOCK
NpOpenNamedPipeFileSystem (
    IN PFILE_OBJECT FileObject,
    IN ACCESS_MASK DesiredAccess
    );

IO_STATUS_BLOCK
NpOpenNamedPipeRootDirectory (
    IN PROOT_DCB RootDcb,
    IN PFILE_OBJECT FileObject,
    IN ACCESS_MASK DesiredAccess,
    IN PLIST_ENTRY DeferredList
    );

NTSTATUS
NpCreateNewNamedPipe (
    IN PROOT_DCB RootDcb,
    IN PFILE_OBJECT FileObject,
    IN UNICODE_STRING FileName,
    IN ACCESS_MASK DesiredAccess,
    IN PACCESS_STATE AccessState,
    IN ULONG CreateDisposition,
    IN USHORT ShareAccess,
    IN PNAMED_PIPE_CREATE_PARAMETERS Parameters,
    IN PEPROCESS CreatorProcess,
    IN PLIST_ENTRY DeferredList,
    OUT PIO_STATUS_BLOCK Iosb
    );

IO_STATUS_BLOCK
NpCreateExistingNamedPipe (
    IN PFCB Fcb,
    IN PFILE_OBJECT FileObject,
    IN ACCESS_MASK DesiredAccess,
    IN PACCESS_STATE AccessState,
    IN KPROCESSOR_MODE RequestorMode,
    IN ULONG CreateDisposition,
    IN USHORT ShareAccess,
    IN PNAMED_PIPE_CREATE_PARAMETERS Parameters,
    IN PEPROCESS CreatorProcess,
    IN PLIST_ENTRY DeferredList
    );

NTSTATUS
NpCommonDirectoryControl (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NpQueryDirectory (
    IN PROOT_DCB RootDcb,
    IN PROOT_DCB_CCB Ccb,
    IN PIRP Irp
    );

NTSTATUS
NpNotifyChangeDirectory (
    IN PROOT_DCB RootDcb,
    IN PROOT_DCB_CCB Ccb,
    IN PIRP Irp
    );

VOID
NpCancelChangeNotifyIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
NpTimerDispatch(
    IN PKDPC Dpc,
    IN PVOID Contxt,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
NpCancelWaitQueueIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );



//
//  The following macro is used by the FSD routines to complete
//  an IRP.
//

#define NpCompleteRequest(IRP,STATUS) FsRtlCompleteRequest( (IRP), (STATUS) );

#define NpDeferredCompleteRequest(IRP,STATUS,LIST) {           \
    (IRP)->IoStatus.Status = STATUS;                           \
    InsertTailList ((LIST), &(IRP)->Tail.Overlay.ListEntry);   \
}
    
VOID
FORCEINLINE
NpCompleteDeferredIrps (
    IN PLIST_ENTRY DeferredList
    )
{
    PIRP Irp;
    PLIST_ENTRY Entry, NextEntry;

    Entry = DeferredList->Flink;
    while (Entry != DeferredList) {
        Irp = CONTAINING_RECORD (Entry, IRP, Tail.Overlay.ListEntry);
        NextEntry = Entry->Flink;
        NpCompleteRequest (Irp, Irp->IoStatus.Status);
        Entry = NextEntry;
    }
}


//
//  The following macros are used to establish the semantics needed
//  to do a return from within a try-finally clause.  As a rule every
//  try clause must end with a label call try_exit.  For example,
//
//      try {
//              :
//              :
//
//      try_exit: NOTHING;
//      } finally {
//
//              :
//              :
//      }
//
//  Every return statement executed inside of a try clause should use the
//  try_return macro.  If the compiler fully supports the try-finally construct
//  then the macro should be
//
//      #define try_return(S)  { return(S); }
//
//  If the compiler does not support the try-finally construct then the macro
//  should be
//
//      #define try_return(S)  { S; goto try_exit; }
//

#define try_return(S) { S; goto try_exit; }

//
// PVOID
// NpAllocatePagedPool (
//     IN ULONG Size,
//     IN ULONG Tag)
// Routine Description:
//
//     This routine will return a pointer to paged pool or NULL if no memory exists.
//
// Arguments:
//
//     Size - Size of memory to allocate
//     Tag  - Tag to use for the pool allocation
//
// Return Value:
//
//    PVOID - pointer to allocated memory or null
//
#define NpAllocatePagedPool( Size, Tag) \
    ExAllocatePoolWithTag( PagedPool, Size, Tag )

//
// PVOID
// NpAllocateNonPagedPool (
//     IN ULONG Size,
//     IN ULONG Tag)
// Routine Description:
//
//     This routine will return a pointer to paged pool or NULL if no memory exists.
//
// Arguments:
//
//     Size - Size of memory to allocate
//     Tag  - Tag to use for the pool allocation
//
// Return Value:
//
//    PVOID - pointer to allocated memory or null
//
#define NpAllocateNonPagedPool( Size, Tag) \
    ExAllocatePoolWithTag( NonPagedPool, Size, Tag )

//
// PVOID
// NpAllocatePagedPoolWithQuota (
//     IN ULONG Size,
//     IN ULONG Tag)
// Routine Description:
//
//     This routine will return a pointer to charged paged pool or NULL if no memory exists.
//
// Arguments:
//
//     Size - Size of memory to allocate
//     Tag  - Tag to use for the pool allocation
//
// Return Value:
//
//    PVOID - pointer to allocated memory or null
//
#define NpAllocatePagedPoolWithQuota( Size, Tag) \
    ExAllocatePoolWithQuotaTag( PagedPool|POOL_QUOTA_FAIL_INSTEAD_OF_RAISE, Size, Tag )

#define NpAllocatePagedPoolWithQuotaCold( Size, Tag) \
    ExAllocatePoolWithQuotaTag( PagedPool|POOL_QUOTA_FAIL_INSTEAD_OF_RAISE|POOL_COLD_ALLOCATION, Size, Tag )

//
// PVOID
// NpAllocateNonPagedPoolWithQuota (
//     IN ULONG Size,
//     IN ULONG Tag)
// Routine Description:
//
//     This routine will return a charged pointer to non-paged pool or NULL if no memory exists.
//
// Arguments:
//
//     Size - Size of memory to allocate
//     Tag  - Tag to use for the pool allocation
//
// Return Value:
//
//    PVOID - pointer to allocated memory or null
//
#define NpAllocateNonPagedPoolWithQuota( Size, Tag) \
    ExAllocatePoolWithQuotaTag( NonPagedPool|POOL_QUOTA_FAIL_INSTEAD_OF_RAISE, Size, Tag )

#define NpAllocateNonPagedPoolWithQuotaCold( Size, Tag) \
    ExAllocatePoolWithQuotaTag( NonPagedPool|POOL_QUOTA_FAIL_INSTEAD_OF_RAISE|POOL_COLD_ALLOCATION, Size, Tag )

//
// VOID
// NpFreePool (
//    IN PVOID Mem)
//
// Routine Description:
//
//
//
// Arguments:
//
//     Mem - Memory to be freed
//
// Return Value:
//
//    None
//
#define NpFreePool(Mem) ExFreePool (Mem)

#define NpIrpWaitQueue(Irp) (Irp->Tail.Overlay.DriverContext[0])

#define NpIrpWaitContext(Irp) (Irp->Tail.Overlay.DriverContext[1])

#define NpIrpDataQueue(Irp) (Irp->Tail.Overlay.DriverContext[2])

#define NpIrpDataEntry(Irp) (Irp->Tail.Overlay.DriverContext[3])

#define NpConvertFsctlToWrite(Irp) (Irp->Flags &= ~IRP_INPUT_OPERATION)

#endif // _NPPROCS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\npfs\fsctrl.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    FsContrl.c

Abstract:

    This module implements the File System Control routine for NPFS called by
    the dispatch driver.

Author:

    Gary Kimura     [GaryKi]    21-Aug-1990

Revision History:

--*/

#include "NpProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (NPFS_BUG_CHECK_FSCTRL)

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_FSCONTRL)



#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NpAssignEvent)
#pragma alloc_text(PAGE, NpCommonFileSystemControl)
#pragma alloc_text(PAGE, NpCompleteTransceiveIrp)
#pragma alloc_text(PAGE, NpDisconnect)
#pragma alloc_text(PAGE, NpFsdFileSystemControl)
#pragma alloc_text(PAGE, NpImpersonate)
#pragma alloc_text(PAGE, NpInternalRead)
#pragma alloc_text(PAGE, NpInternalTransceive)
#pragma alloc_text(PAGE, NpInternalWrite)
#pragma alloc_text(PAGE, NpListen)
#pragma alloc_text(PAGE, NpPeek)
#pragma alloc_text(PAGE, NpQueryClientProcess)
#pragma alloc_text(PAGE, NpQueryEvent)
#pragma alloc_text(PAGE, NpSetClientProcess)
#pragma alloc_text(PAGE, NpTransceive)
#pragma alloc_text(PAGE, NpWaitForNamedPipe)
#endif



NTSTATUS
NpFsdFileSystemControl (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtFsControlFile API calls.

Arguments

    NpfsDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpFsdFileSystemControl\n", 0);

    //
    //  Call the common FsControl routine.
    //

    FsRtlEnterFileSystem();

    Status = NpCommonFileSystemControl( NpfsDeviceObject,
                                        Irp );
    FsRtlExitFileSystem();

    if (Status != STATUS_PENDING) {
        NpCompleteRequest (Irp, Status);
    }

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "NpFsdFileSystemControl -> %08lx\n", Status );

    return Status;
}


//
//  Internal Support Routine
//

NTSTATUS
NpCommonFileSystemControl (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine does the common code for handling/dispatching an fsctl
    function.

Arguments:

    NpfsDeviceObject - Supplies the named pipe device object

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    BOOLEAN ReadOverflowOperation;
    LIST_ENTRY DeferredList;

    PAGED_CODE();

    //
    //  Reference our input parameters to make things easier
    //

    IrpSp = IoGetCurrentIrpStackLocation (Irp);

    InitializeListHead (&DeferredList);

    DebugTrace(+1, Dbg, "NpCommonFileSystemControl\n", 0);
    DebugTrace( 0, Dbg, "Irp                = %08lx\n", Irp);
    DebugTrace( 0, Dbg, "OutputBufferLength = %08lx\n", IrpSp->Parameters.FileSystemControl.OutputBufferLength);
    DebugTrace( 0, Dbg, "InputBufferLength  = %08lx\n", IrpSp->Parameters.FileSystemControl.InputBufferLength);
    DebugTrace( 0, Dbg, "FsControlCode      = %08lx\n", IrpSp->Parameters.FileSystemControl.FsControlCode);

    //
    //  Case on the type of function we're trying to do.  In each case
    //  we'll call a local work routine to do the actual work.
    //

    ReadOverflowOperation = FALSE;

    switch (IrpSp->Parameters.FileSystemControl.FsControlCode) {

    case FSCTL_PIPE_ASSIGN_EVENT:

        NpAcquireExclusiveVcb ();
        Status = NpAssignEvent (NpfsDeviceObject, Irp);
        break;

    case FSCTL_PIPE_DISCONNECT:

        NpAcquireExclusiveVcb ();
        Status = NpDisconnect (NpfsDeviceObject, Irp, &DeferredList);
        break;

    case FSCTL_PIPE_LISTEN:

        NpAcquireSharedVcb ();
        Status = NpListen (NpfsDeviceObject, Irp, &DeferredList);
        break;

    case FSCTL_PIPE_PEEK:

        NpAcquireExclusiveVcb ();
        Status = NpPeek (NpfsDeviceObject, Irp, &DeferredList);
        break;

    case FSCTL_PIPE_QUERY_EVENT:

        NpAcquireExclusiveVcb ();
        Status = NpQueryEvent (NpfsDeviceObject, Irp);
        break;

    case FSCTL_PIPE_TRANSCEIVE:

        NpAcquireSharedVcb ();
        Status = NpTransceive (NpfsDeviceObject, Irp, &DeferredList);
        break;

    case FSCTL_PIPE_WAIT:

        NpAcquireExclusiveVcb ();
        Status = NpWaitForNamedPipe (NpfsDeviceObject, Irp);
        break;

    case FSCTL_PIPE_IMPERSONATE:

        NpAcquireExclusiveVcb ();
        Status = NpImpersonate (NpfsDeviceObject, Irp);
        break;

    case FSCTL_PIPE_INTERNAL_READ_OVFLOW:

        ReadOverflowOperation = TRUE;

    case FSCTL_PIPE_INTERNAL_READ:

        NpAcquireSharedVcb ();
        Status = NpInternalRead (NpfsDeviceObject, Irp, ReadOverflowOperation, &DeferredList);
        break;

    case FSCTL_PIPE_INTERNAL_WRITE:

        NpAcquireSharedVcb ();
        Status = NpInternalWrite (NpfsDeviceObject, Irp, &DeferredList);
        break;

    case FSCTL_PIPE_INTERNAL_TRANSCEIVE:

        NpAcquireSharedVcb ();
        Status = NpInternalTransceive (NpfsDeviceObject, Irp, &DeferredList);
        break;

    case FSCTL_PIPE_QUERY_CLIENT_PROCESS:

        NpAcquireSharedVcb ();
        Status = NpQueryClientProcess (NpfsDeviceObject, Irp);
        break;

    case FSCTL_PIPE_SET_CLIENT_PROCESS:

        NpAcquireExclusiveVcb ();
        Status = NpSetClientProcess (NpfsDeviceObject, Irp);
        break;

    default:

        return STATUS_NOT_SUPPORTED; // No lock acquired
    }

    NpReleaseVcb ();

    //
    // Complete any deferred IRPs now we have dropped the last lock
    //
    NpCompleteDeferredIrps (&DeferredList);


    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "NpCommonFileSystemControl -> %08lx\n", Status);

    return Status;
}


//
//  Local support routine
//

NTSTATUS
NpAssignEvent (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine does the assign event control function

Arguments:

    NpfsDeviceObject - Supplies our device object

    Irp - Supplies the Irp specifying the function

Return Value:

    NTSTATUS - An appropriate return status

--*/

{
    PIO_STACK_LOCATION IrpSp;

    ULONG InputBufferLength;
    ULONG FsControlCode;

    PCCB Ccb;
    PNONPAGED_CCB NonpagedCcb;
    NAMED_PIPE_END NamedPipeEnd;

    PFILE_PIPE_ASSIGN_EVENT_BUFFER EventBuffer;
    NTSTATUS status;

    PAGED_CODE();

    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NpAssignEvent...\n", 0);

    InputBufferLength  = IrpSp->Parameters.FileSystemControl.InputBufferLength;
    FsControlCode      = IrpSp->Parameters.FileSystemControl.FsControlCode;

    //
    //  Decode the file object to figure out who we are.  If the result
    //  is not a ccb then the pipe has been disconnected.
    //

    if (NpDecodeFileObject( IrpSp->FileObject,
                            NULL,
                            &Ccb,
                            &NamedPipeEnd ) != NPFS_NTC_CCB) {

        DebugTrace(0, Dbg, "Pipe is disconnected from us\n", 0);

        return STATUS_PIPE_DISCONNECTED;
    }

    NonpagedCcb = Ccb->NonpagedCcb;

    //
    //  Reference the system buffer as an assign event buffer and make
    //  sure it's large enough
    //

    EventBuffer = Irp->AssociatedIrp.SystemBuffer;


    if (InputBufferLength < sizeof(FILE_PIPE_ASSIGN_EVENT_BUFFER)) {

        DebugTrace(0, Dbg, "System buffer size is too small\n", 0);

        return STATUS_INVALID_PARAMETER;
    }


    //
    //  First thing we do is delete the old event if there is one
    //  for this end of the pipe
    //

    NpDeleteEventTableEntry( &NpVcb->EventTable,
                             NonpagedCcb->EventTableEntry[ NamedPipeEnd ] );

    NonpagedCcb->EventTableEntry[ NamedPipeEnd ] = NULL;

    //
    //  Now if the new event handle is not null then we'll add the new
    //  event to the event table
    //

    status = STATUS_SUCCESS;
    if (EventBuffer->EventHandle != NULL) {

        status = NpAddEventTableEntry( &NpVcb->EventTable,
                                       Ccb,
                                       NamedPipeEnd,
                                       EventBuffer->EventHandle,
                                       EventBuffer->KeyValue,
                                       PsGetCurrentProcess(),
                                       Irp->RequestorMode,
                                       &NonpagedCcb->EventTableEntry[ NamedPipeEnd ] );
    }


    DebugTrace(-1, Dbg, "NpAssignEvent -> STATUS_SUCCESS\n", 0);
    return status;
}


//
//  Local Support Routine
//

NTSTATUS
NpDisconnect (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This routine does the disconnect control function

Arguments:

    NpfsDeviceObject - Supplies our device object

    Irp - Supplies the being processed

    DeferredList - List of IRPs to complete after we drop the locks

Return Value:

    NTSTATUS - An apprropriate return status

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    ULONG FsControlCode;

    PCCB Ccb;
    NAMED_PIPE_END NamedPipeEnd;

    PAGED_CODE();

    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NpDisconnect...\n", 0);

    FsControlCode = IrpSp->Parameters.FileSystemControl.FsControlCode;

    //
    //  Decode the file object to figure out who we are.  If the result
    //  is not a ccb then the pipe has been disconnected.
    //

    if (NpDecodeFileObject( IrpSp->FileObject,
                            NULL,
                            &Ccb,
                            &NamedPipeEnd ) != NPFS_NTC_CCB) {

        DebugTrace(0, Dbg, "Pipe is disconnected from us\n", 0);

        return STATUS_PIPE_DISCONNECTED;
    }

    //
    //  Make sure that this is only the server that is doing this
    //  action.
    //

    if (NamedPipeEnd != FILE_PIPE_SERVER_END) {

        DebugTrace(0, Dbg, "Not the server end\n", 0);

        return STATUS_ILLEGAL_FUNCTION;
    }

    NpAcquireExclusiveCcb(Ccb);

    //
    //  Now call the state support routine to set the ccb to
    //  a disconnected state and remove the client's cached security
    //  context.
    //

    Status = NpSetDisconnectedPipeState( Ccb, DeferredList );

    NpUninitializeSecurity( Ccb );

    NpReleaseCcb(Ccb);

    DebugTrace(-1, Dbg, "NpDisconnect -> %08lx\n", Status);
    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NpListen (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This routine does the listen control function

Arguments:

    NpfsDeviceObject - Supplies our device object

    Irp - Supplies the being processed

    DeferredList - List of IRPs to complete once we drop the locks

Return Value:

    NTSTATUS - An apprropriate return status

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    ULONG FsControlCode;

    PCCB Ccb;
    NAMED_PIPE_END NamedPipeEnd;

    PAGED_CODE();

    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NpListen...\n", 0);

    FsControlCode = IrpSp->Parameters.FileSystemControl.FsControlCode;

    //
    //  Decode the file object to figure out who we are.  If the result
    //  is not a ccb then the pipe has been disconnected.
    //

    if (NpDecodeFileObject( IrpSp->FileObject,
                            NULL,
                            &Ccb,
                            &NamedPipeEnd ) != NPFS_NTC_CCB) {

        DebugTrace(0, Dbg, "Pipe is disconnected from us\n", 0);

        DebugTrace(-1, Dbg, "NpListen -> STATUS_ILLEGAL_FUNCTION\n", 0 );
        return STATUS_ILLEGAL_FUNCTION;
    }

    //
    //  Make sure that this is only the server that is doing this
    //  action.
    //

    if (NamedPipeEnd != FILE_PIPE_SERVER_END) {

        DebugTrace(0, Dbg, "Not the server end\n", 0);

        DebugTrace(-1, Dbg, "NpListen -> STATUS_ILLEGAL_FUNCTION\n", 0 );
        return STATUS_ILLEGAL_FUNCTION;
    }

    NpAcquireExclusiveCcb(Ccb);

    //
    //  Now call the state support routine to set the ccb to
    //  a listening state.  This routine will complete the Irp
    //  for us.
    //

    Status = NpSetListeningPipeState( Ccb, Irp, DeferredList );

    NpReleaseCcb(Ccb);

    DebugTrace(-1, Dbg, "NpListen -> %08lx\n", Status);
    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NpPeek (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This routine does the peek control function

Arguments:

    NpfsDeviceObject - Supplies our device object

    Irp - Supplies the being processed

    DeferredList - List of IRPS to be completed after we drop the locks

Return Value:

    NTSTATUS - An apprropriate return status

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    ULONG OutputBufferLength;
    ULONG FsControlCode;

    NODE_TYPE_CODE NodeTypeCode;
    PCCB Ccb;
    PNONPAGED_CCB NonpagedCcb;
    NAMED_PIPE_END NamedPipeEnd;

    PFILE_PIPE_PEEK_BUFFER PeekBuffer;

    PDATA_QUEUE ReadQueue;
    READ_MODE ReadMode;

    ULONG LengthWritten;

    PUCHAR ReadBuffer;
    ULONG ReadLength;
    ULONG ReadRemaining;
    PDATA_ENTRY DataEntry;

    PAGED_CODE();

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NpPeek...\n", 0);

    //
    //  Extract the important fields from the IrpSp
    //

    OutputBufferLength = IrpSp->Parameters.FileSystemControl.OutputBufferLength;
    FsControlCode      = IrpSp->Parameters.FileSystemControl.FsControlCode;

    DebugTrace( 0, Dbg, "OutputBufferLength = %08lx\n", OutputBufferLength);
    DebugTrace( 0, Dbg, "FsControlCode      = %08lx\n", FsControlCode);

    //
    //  Decode the file object to figure out who we are.  The results
    //  have a disconnected pipe if we get back an undefined ntc
    //

    if ((NodeTypeCode = NpDecodeFileObject( IrpSp->FileObject,
                                            NULL,
                                            &Ccb,
                                            &NamedPipeEnd )) == NTC_UNDEFINED) {

        DebugTrace(0, Dbg, "FileObject has been disconnected\n", 0);

        DebugTrace(-1, Dbg, "NpPeek -> STATUS_PIPE_DISCONNECTED\n", 0 );
        return STATUS_PIPE_DISCONNECTED;
    }

    //
    //  Now make sure the node type code is for a ccb otherwise it is an
    //  invalid parameter
    //

    if (NodeTypeCode != NPFS_NTC_CCB) {

        DebugTrace(0, Dbg, "FileObject is not for a ccb\n", 0);

        DebugTrace(-1, Dbg, "NpPeek -> STATUS_INVALID_PARAMETER\n", 0 );
        return STATUS_INVALID_PARAMETER;
    }

    NonpagedCcb = Ccb->NonpagedCcb;

    //
    //  Reference the system buffer as a peek buffer and make sure it's
    //  large enough
    //

    if (OutputBufferLength < (ULONG)FIELD_OFFSET(FILE_PIPE_PEEK_BUFFER, Data[0])) {

        DebugTrace(0, Dbg, "Output buffer is too small\n", 0);

        DebugTrace(-1, Dbg, "NpPeek -> STATUS_INVALID_PARAMETER\n", 0 );
        return STATUS_INVALID_PARAMETER;
    }

    PeekBuffer = Irp->AssociatedIrp.SystemBuffer;

    //
    //  Now the data queue that we read from is based on the named pipe
    //  end.  The server reads from the inbound queue and the client reads
    //  from the outbound queue
    //

    switch (NamedPipeEnd) {

    case FILE_PIPE_SERVER_END:

        ReadQueue = &Ccb->DataQueue[ FILE_PIPE_INBOUND ];
        //ReadMode  = Ccb->ReadMode[ FILE_PIPE_SERVER_END ];

        break;

    case FILE_PIPE_CLIENT_END:

        ReadQueue = &Ccb->DataQueue[ FILE_PIPE_OUTBOUND ];
        //ReadMode  = Ccb->ReadMode[ FILE_PIPE_CLIENT_END ];

        break;

    default:

        NpBugCheck( NamedPipeEnd, 0, 0 );
    }

    //
    //  Our read mode is really based upon the pipe type and not the set
    //  read mode for the pipe end.
    //

    if (Ccb->Fcb->Specific.Fcb.NamedPipeType == FILE_PIPE_MESSAGE_TYPE) {

        ReadMode = FILE_PIPE_MESSAGE_MODE;

    } else {

        ReadMode = FILE_PIPE_BYTE_STREAM_MODE;
    }

    DebugTrace(0, Dbg, "ReadQueue = %08lx\n", ReadQueue);
    DebugTrace(0, Dbg, "ReadMode  = %08lx\n", ReadMode);

    //
    //  If the state of the pipe is not in the connected or closing
    //  state then it is an invalid pipe state
    //

    if ((Ccb->NamedPipeState != FILE_PIPE_CONNECTED_STATE) &&
        (Ccb->NamedPipeState != FILE_PIPE_CLOSING_STATE)) {

        DebugTrace(0, Dbg, "pipe not connected or closing\n", 0);

        return STATUS_INVALID_PIPE_STATE;
    }

    //
    //  If the state of the pipe is closing and the queue does
    //  not contain any writers then we return eof
    //

    if ((Ccb->NamedPipeState == FILE_PIPE_CLOSING_STATE) &&
        (!NpIsDataQueueWriters( ReadQueue ))) {

        DebugTrace(0, Dbg, "pipe closing and is empty\n", 0);

        return STATUS_PIPE_BROKEN;
    }

    //
    //  Zero out the standard header part of the peek buffer and
    //  set the length written to the amount we've just zeroed out
    //

    RtlZeroMemory( PeekBuffer, FIELD_OFFSET(FILE_PIPE_PEEK_BUFFER, Data[0]) );
    LengthWritten = FIELD_OFFSET(FILE_PIPE_PEEK_BUFFER, Data[0]);

    //
    //  Set the named pipe state
    //

    PeekBuffer->NamedPipeState = Ccb->NamedPipeState;

    //
    //  There is only data available if the read queue contains
    //  write entries otherwise the rest of record is all zero.
    //

    if (NpIsDataQueueWriters( ReadQueue )) {

        //
        //  Now find the first real entry in the read queue.  The
        //  first entry actually better be a real one.
        //

        DataEntry = NpGetNextDataQueueEntry( ReadQueue, NULL );

        ASSERT( (DataEntry->DataEntryType == Buffered) ||
                (DataEntry->DataEntryType == Unbuffered) );

        //
        //  Indicate how many bytes are available to read
        //

        PeekBuffer->ReadDataAvailable = ReadQueue->BytesInQueue - ReadQueue->NextByteOffset;

        //
        //  The number of messages and message length is only filled
        //  in for a message mode pipe
        //

        if (ReadMode == FILE_PIPE_MESSAGE_MODE) {

            PeekBuffer->NumberOfMessages  = ReadQueue->EntriesInQueue;
            PeekBuffer->MessageLength = DataEntry->DataSize - ReadQueue->NextByteOffset;
        }

        //
        //  Now we are ready to copy over the data from the read queue
        //  into the peek buffer.  First establish how much room we
        //  have in the peek buffer and who much is remaining.
        //

        ReadBuffer = &PeekBuffer->Data[0];
        ReadLength = OutputBufferLength - FIELD_OFFSET(FILE_PIPE_PEEK_BUFFER, Data[0]);
        ReadRemaining = ReadLength;

        DebugTrace(0, Dbg, "ReadBuffer = %08lx\n", ReadBuffer);
        DebugTrace(0, Dbg, "ReadLength = %08lx\n", ReadLength);

        //
        //  Now read the data queue.
        //

        if ( ReadLength != 0 ) {
            IO_STATUS_BLOCK Iosb;

            Iosb = NpReadDataQueue( ReadQueue,
                                    TRUE,
                                    FALSE,
                                    ReadBuffer,
                                    ReadLength,
                                    ReadMode,
                                    Ccb,
                                    DeferredList );

            Status = Iosb.Status;
            LengthWritten += (ULONG)Iosb.Information;

        } else {

            if ( PeekBuffer->ReadDataAvailable == 0) {

                Status = STATUS_SUCCESS;

            } else {

                Status = STATUS_BUFFER_OVERFLOW;
            }
        }

    } else {

        Status = STATUS_SUCCESS;
    }

    //
    //  Complete the request.  The amount of information copied
    //  is stored in length written
    //

    Irp->IoStatus.Information = LengthWritten;


    DebugTrace(-1, Dbg, "NpPeek -> %08lx\n", Status);
    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NpQueryEvent (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine does the query event control function

Arguments:

    NpfsDeviceObject - Supplies our device object

    Irp - Supplies the Irp specifying the function

Return Value:

    NTSTATUS - An appropriate return status

--*/

{
    PIO_STACK_LOCATION IrpSp;

    ULONG InputBufferLength;
    ULONG OutputBufferLength;
    ULONG FsControlCode;

    PCCB Ccb;
    NAMED_PIPE_END NamedPipeEnd;

    HANDLE EventHandle;
    PFILE_PIPE_EVENT_BUFFER EventArray;
    PFILE_PIPE_EVENT_BUFFER EventBuffer;
    ULONG EventArrayMaximumCount;
    ULONG EventCount;

    PEPROCESS Process;

    PEVENT_TABLE_ENTRY Ete;
    PDATA_QUEUE ReadQueue;
    PDATA_QUEUE WriteQueue;

    PVOID RestartKey;

    PAGED_CODE();

    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NpQueryEvent...\n", 0);

    InputBufferLength  = IrpSp->Parameters.FileSystemControl.InputBufferLength;
    OutputBufferLength = IrpSp->Parameters.FileSystemControl.OutputBufferLength;
    FsControlCode      = IrpSp->Parameters.FileSystemControl.FsControlCode;

    //
    //  Decode the file object to figure out who we are.  If the result
    //  is not a Vcb then its an invalid parameter
    //

    if (NpDecodeFileObject( IrpSp->FileObject,
                            NULL,
                            &Ccb,
                            &NamedPipeEnd ) != NPFS_NTC_VCB) {

        DebugTrace(0, Dbg, "FileObject is not the named pipe driver\n", 0);

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Reference the system buffer as a handle and make sure it's large
    //  enough
    //

    if (InputBufferLength < sizeof(HANDLE)) {

        DebugTrace(0, Dbg, "Input System buffer size is too small\n", 0);

        return STATUS_INVALID_PARAMETER;
    }
    EventHandle = *(PHANDLE)Irp->AssociatedIrp.SystemBuffer;


    //
    //  Reference the system buffer as an output event buffer, and compute
    //  how many event buffer records we can put in the buffer.
    //

    EventArray = Irp->AssociatedIrp.SystemBuffer;
    EventArrayMaximumCount = OutputBufferLength / sizeof(FILE_PIPE_EVENT_BUFFER);
    EventCount = 0;

    //
    //  Get our current process pointer that we'll need for our search
    //

    Process = PsGetCurrentProcess();

    //
    //  Now enumerate the event table entries in the event table
    //

    RestartKey = NULL;
    for (Ete = NpGetNextEventTableEntry( &NpVcb->EventTable, &RestartKey);
         Ete != NULL;
         Ete = NpGetNextEventTableEntry( &NpVcb->EventTable, &RestartKey)) {

        //
        //  Check if the event table entry matches the event handle
        //  and the process
        //

        if ((Ete->EventHandle == EventHandle) &&
            (Ete->Process == Process)) {

            //
            //  Now based on the named pipe end we treat the inbound/
            //  outbound as a read/write queue.
            //

            NpAcquireExclusiveCcb(Ete->Ccb);

            switch (Ete->NamedPipeEnd) {

            case FILE_PIPE_CLIENT_END:

                ReadQueue = &Ete->Ccb->DataQueue[ FILE_PIPE_OUTBOUND ];
                WriteQueue = &Ete->Ccb->DataQueue[ FILE_PIPE_INBOUND ];

                break;

            case FILE_PIPE_SERVER_END:

                ReadQueue = &Ete->Ccb->DataQueue[ FILE_PIPE_INBOUND ];
                WriteQueue = &Ete->Ccb->DataQueue[ FILE_PIPE_OUTBOUND ];

                break;

            default:

                NpBugCheck( Ete->NamedPipeEnd, 0, 0 );
            }

            //
            //  Now if there is any data in the read queue to be read
            //  we fill in the buffer
            //

            if (NpIsDataQueueWriters(ReadQueue)) {

                //
                //  First make sure there is enough room in the
                //  EventBuffer to hold another entry
                //

                if (EventCount >= EventArrayMaximumCount) {

                    DebugTrace(0, Dbg, "The event buffer is full\n", 0);

                    NpReleaseCcb(Ete->Ccb);
                    break;
                }

                //
                //  Reference the event buffer and increment the
                //  counter
                //

                EventBuffer = &EventArray[EventCount];
                EventCount += 1;

                //
                //  Fill in the event buffer entry
                //

                EventBuffer->NamedPipeState = Ete->Ccb->NamedPipeState;
                EventBuffer->EntryType = FILE_PIPE_READ_DATA;
                EventBuffer->ByteCount = ReadQueue->BytesInQueue - ReadQueue->NextByteOffset;
                EventBuffer->KeyValue = Ete->KeyValue;
                EventBuffer->NumberRequests = ReadQueue->EntriesInQueue;
            }

            //
            //  We'll always fill in a write space buffer.  The amount
            //  will either be bytes of write space available or
            //  the quota of write space that we can use.
            //

            //
            //  First make sure there is enough room in the
            //  EventBuffer to hold another entry
            //

            if (EventCount >= EventArrayMaximumCount) {

                DebugTrace(0, Dbg, "The event buffer is full\n", 0);

                NpReleaseCcb(Ete->Ccb);
                break;
            }

            //
            //  Reference the event buffer and increment the
            //  counter
            //

            EventBuffer = &EventArray[EventCount];
            EventCount += 1;

            //
            //  Fill in the event buffer entry
            //

            EventBuffer->NamedPipeState = Ete->Ccb->NamedPipeState;
            EventBuffer->EntryType = FILE_PIPE_WRITE_SPACE;
            EventBuffer->KeyValue = Ete->KeyValue;

            //
            //  Now either we put in the write space available or
            //  we put in the quota available
            //

            if (NpIsDataQueueReaders(WriteQueue)) {

                EventBuffer->ByteCount = WriteQueue->BytesInQueue - WriteQueue->NextByteOffset;
                EventBuffer->NumberRequests = WriteQueue->EntriesInQueue;

            } else {

                EventBuffer->ByteCount = WriteQueue->Quota - WriteQueue->QuotaUsed;
                EventBuffer->NumberRequests = 0;
            }

            NpReleaseCcb(Ete->Ccb);
        }
    }

    //
    //  Set the information field to be the number of bytes of output
    //  data we've fill into the system buffer
    //

    Irp->IoStatus.Information = EventCount * sizeof(FILE_PIPE_EVENT_BUFFER);


    DebugTrace(-1, Dbg, "NpQueryEvent -> STATUS_SUCCESS\n", 0);
    return STATUS_SUCCESS;
}


//
//  Local Support Routine
//

NTSTATUS
NpTransceive (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This routine does the transceive named pipe control function

Arguments:

    NpfsDeviceObject - Supplies our device object

    Irp - Supplies the being processed

    DeferredList - List of IRPs to complete after we drop locks

Return Value:

    NTSTATUS - An apprropriate return status

--*/

{
    static IO_STATUS_BLOCK Iosb;
    NTSTATUS Status;

    PIO_STACK_LOCATION IrpSp;
    PETHREAD UserThread;

    PUCHAR WriteBuffer;
    ULONG WriteLength;

    PUCHAR ReadBuffer;
    ULONG ReadLength;

    NODE_TYPE_CODE NodeTypeCode;
    PCCB Ccb;
    PNONPAGED_CCB NonpagedCcb;
    NAMED_PIPE_END NamedPipeEnd;

    PDATA_QUEUE ReadQueue;
    PDATA_QUEUE WriteQueue;
    PEVENT_TABLE_ENTRY Event;
    READ_MODE ReadMode;

    NAMED_PIPE_CONFIGURATION NamedPipeConfiguration;

    ULONG WriteRemaining;
    PIRP WriteIrp;

    //
    //  The following variable is used during abnormal unwind
    //

    PVOID UnwindStorage = NULL;

    PAGED_CODE();

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NpTransceive\n", 0);
    DebugTrace( 0, Dbg, "NpfsDeviceObject = %08lx\n", NpfsDeviceObject);
    DebugTrace( 0, Dbg, "Irp              = %08lx\n", Irp);
    DebugTrace( 0, Dbg, "FileObject       = %08lx\n", IrpSp->FileObject);

    WriteLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;
    WriteBuffer = IrpSp->Parameters.FileSystemControl.Type3InputBuffer;

    ReadLength = IrpSp->Parameters.FileSystemControl.OutputBufferLength;
    ReadBuffer = Irp->UserBuffer;

    //
    //  Now if the requestor mode is user mode we need to probe the buffers
    //  We do now need to have an exception handler here because our top
    //  level caller already has one that will complete the Irp with
    //  the appropriate status if we access violate.
    //

    if (Irp->RequestorMode != KernelMode) {

        try {

            ProbeForRead( WriteBuffer, WriteLength, sizeof(UCHAR) );
            ProbeForWrite( ReadBuffer, ReadLength, sizeof(UCHAR) );

        } except(EXCEPTION_EXECUTE_HANDLER) {

            return GetExceptionCode ();
        }
    }

    //
    //  Get the Ccb and figure out who we are, and make sure we're not
    //  disconnected
    //

    if ((NodeTypeCode = NpDecodeFileObject( IrpSp->FileObject,
                                            NULL,
                                            &Ccb,
                                            &NamedPipeEnd )) == NTC_UNDEFINED) {

        DebugTrace(0, Dbg, "Pipe is disconnected from us\n", 0);


        DebugTrace(-1, Dbg, "NpTransceive -> STATUS_PIPE_DISCONNECTED\n", 0 );
        return STATUS_PIPE_DISCONNECTED;
    }

    //
    //  Now we only will allow transceive operations on the pipe and not a
    //  directory or the device
    //

    if (NodeTypeCode != NPFS_NTC_CCB) {

        DebugTrace(0, Dbg, "FileObject is not for a named pipe\n", 0);

        DebugTrace(-1, Dbg, "NpTransceive -> STATUS_PIPE_DISCONNECTED\n", 0 );
        return STATUS_PIPE_DISCONNECTED;
    }

    NonpagedCcb = Ccb->NonpagedCcb;

    NpAcquireExclusiveCcb(Ccb);
    WriteIrp = NULL;

    try {

        //
        //  Check that the pipe is in the connected state
        //

        if (Ccb->NamedPipeState != FILE_PIPE_CONNECTED_STATE) {

            DebugTrace(0, Dbg, "Pipe not connected\n", 0);

            try_return( Status = STATUS_INVALID_PIPE_STATE );
        }

        //
        //  Figure out the read/write queue, read mode, and event based
        //  on the end of the named pipe doing the transceive.
        //

        switch (NamedPipeEnd) {

        case FILE_PIPE_SERVER_END:

            ReadQueue = &Ccb->DataQueue[ FILE_PIPE_INBOUND ];
            WriteQueue = &Ccb->DataQueue[ FILE_PIPE_OUTBOUND ];

            Event = NonpagedCcb->EventTableEntry[ FILE_PIPE_CLIENT_END ];
            ReadMode = Ccb->ReadCompletionMode[ FILE_PIPE_SERVER_END ].ReadMode;

            break;

        case FILE_PIPE_CLIENT_END:

            ReadQueue = &Ccb->DataQueue[ FILE_PIPE_OUTBOUND ];
            WriteQueue = &Ccb->DataQueue[ FILE_PIPE_INBOUND ];

            Event = NonpagedCcb->EventTableEntry[ FILE_PIPE_SERVER_END ];
            ReadMode = Ccb->ReadCompletionMode[ FILE_PIPE_CLIENT_END ].ReadMode;

            break;

        default:

            NpBugCheck( NamedPipeEnd, 0, 0 );
        }

        //
        //  We only allow a transceive on a message mode, full duplex pipe.
        //

        NamedPipeConfiguration = Ccb->Fcb->Specific.Fcb.NamedPipeConfiguration;

        if ((NamedPipeConfiguration != FILE_PIPE_FULL_DUPLEX) ||
            (ReadMode != FILE_PIPE_MESSAGE_MODE)) {

            DebugTrace(0, Dbg, "Bad pipe configuration or read mode\n", 0);

            try_return( Status = STATUS_INVALID_PIPE_STATE );
        }

        //
        //  Check that the read queue is empty.
        //

        if (!NpIsDataQueueEmpty( ReadQueue )) {

            DebugTrace(0, Dbg, "Read queue is not empty\n", 0);

            try_return( Status = STATUS_PIPE_BUSY );
        }

        //
        //  Do the transceive write operation.  We first try and push the data
        //  from the write buffer into any waiting readers in the write queue
        //  and if that succeeds then we can go on and do the read operation
        //  otherwise we need to make a copy of irp and to enqueue as
        //  a data entry into the write queue.
        //
        //  Now we'll call our common write data queue routine to
        //  transfer data out of our write buffer into the data queue.
        //  If the result of the call is FALSE then we still have some
        //  write data to put into the write queue.
        //

        UserThread = Irp->Tail.Overlay.Thread;
        Status = NpWriteDataQueue( WriteQueue,
                                   ReadMode,
                                   WriteBuffer,
                                   WriteLength,
                                   Ccb->Fcb->Specific.Fcb.NamedPipeType,
                                   &WriteRemaining,
                                   Ccb,
                                   NamedPipeEnd,
                                   UserThread,
                                   DeferredList );

        if (Status == STATUS_MORE_PROCESSING_REQUIRED)  {

            PIO_STACK_LOCATION WriteIrpSp;

            ASSERT( !NpIsDataQueueReaders( WriteQueue ));

            DebugTrace(0, Dbg, "Add write to data queue\n", 0);

            //
            //  We need to do some more write processing.  So to handle
            //  this case we'll allocate a new irp and set its system
            //  buffer to be the remaining part of the write buffer
            //

            if ((WriteIrp = IoAllocateIrp( NpfsDeviceObject->DeviceObject.StackSize, TRUE )) == NULL) {

                try_return (Status = STATUS_INSUFFICIENT_RESOURCES);
            }

            IoSetCompletionRoutine( WriteIrp, NpCompleteTransceiveIrp, NULL, TRUE, TRUE, TRUE );

            WriteIrpSp = IoGetNextIrpStackLocation( WriteIrp );

            if (WriteRemaining > 0) {

                WriteIrp->AssociatedIrp.SystemBuffer = NpAllocatePagedPoolWithQuota( WriteRemaining, 'wFpN' );
                if (WriteIrp->AssociatedIrp.SystemBuffer == NULL) {
                    IoFreeIrp (WriteIrp);
                    try_return (Status = STATUS_INSUFFICIENT_RESOURCES);
                }

                //
                //  Safely do the copy
                //

                try {

                    RtlCopyMemory( WriteIrp->AssociatedIrp.SystemBuffer,
                                   &WriteBuffer[ WriteLength - WriteRemaining ],
                                   WriteRemaining );

                } except(EXCEPTION_EXECUTE_HANDLER) {
                    NpFreePool (WriteIrp->AssociatedIrp.SystemBuffer);
                    IoFreeIrp (WriteIrp);
                    try_return (Status = GetExceptionCode ());
                }

            } else {

                WriteIrp->AssociatedIrp.SystemBuffer = NULL;
            }

            //
            //  Set the current stack location, and set in the amount we are
            //  try to write.
            //

            WriteIrp->CurrentLocation -= 1;
            WriteIrp->Tail.Overlay.CurrentStackLocation = WriteIrpSp;
            WriteIrp->Tail.Overlay.Thread = UserThread;
            WriteIrp->IoStatus.Information = WriteRemaining;

            WriteIrpSp->Parameters.Write.Length = WriteRemaining;
            WriteIrpSp->MajorFunction = IRP_MJ_WRITE;

            //
            //  Set it up to do buffered I/O and deallocate the buffer
            //  on completion.

            if (WriteRemaining > 0) {

                WriteIrp->Flags = IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER;
            }

            WriteIrp->UserIosb = &Iosb;

            //
            //  Add this write request to the write queue
            //

            Status = NpAddDataQueueEntry( NamedPipeEnd,
                                          Ccb,
                                          WriteQueue,
                                          WriteEntries,
                                          Unbuffered,
                                          WriteRemaining,
                                          WriteIrp,
                                          NULL,
                                          0);

            if (Status != STATUS_PENDING) {
                NpDeferredCompleteRequest (WriteIrp, Status, DeferredList);
            }

        }

        if (!NT_SUCCESS (Status)) {
            try_return (NOTHING);
        }

        //
        //  And because we've done something we need to signal the
        //  other ends event
        //

        NpSignalEventTableEntry( Event );

        //
        //  Do the transceive read operation.  This is just like a
        //  buffered read.
        //
        //  Now we know that the read queue is empty so we'll enqueue this
        //  Irp to the read queue and return status pending, also mark the
        //  irp pending
        //

        ASSERT( NpIsDataQueueEmpty( ReadQueue ));

        Status = NpAddDataQueueEntry( NamedPipeEnd,
                                      Ccb,
                                      ReadQueue,
                                      ReadEntries,
                                      Buffered,
                                      ReadLength,
                                      Irp,
                                      NULL,
                                      0 );
        if (!NT_SUCCESS (Status)) {
            try_return (NOTHING);
        }

        //
        //  And because we've done something we need to signal the
        //  other ends event
        //

        NpSignalEventTableEntry( Event );

    try_exit: NOTHING;
    } finally {
        NpReleaseCcb(Ccb);
    }

    DebugTrace(-1, Dbg, "NpTransceive -> %08lx\n", Status);
    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NpWaitForNamedPipe (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine does the wait for named pipe control function

Arguments:

    NpfsDeviceObject - Supplies our device object

    Irp - Supplies the being processed

Return Value:

    NTSTATUS - An apprropriate return status

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    ULONG InputBufferLength;
    ULONG FsControlCode;

    PFCB Fcb;
    PCCB Ccb;

    PFILE_PIPE_WAIT_FOR_BUFFER WaitBuffer;
    UNICODE_STRING Name;
    PVOID LocalBuffer;
    NAMED_PIPE_END NamedPipeEnd;

    PLIST_ENTRY Links;

    BOOLEAN CaseInsensitive = TRUE; //**** Make all searches case insensitive
    UNICODE_STRING RemainingPart;
    BOOLEAN Translated;

    PAGED_CODE();

    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NpWaitForNamedPipe...\n", 0);

    //
    //  Extract the important fields from the IrpSp
    //

    InputBufferLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;
    FsControlCode     = IrpSp->Parameters.FileSystemControl.FsControlCode;

    Name.Buffer = NULL;
    LocalBuffer = NULL;

    try {

        //
        //  Decode the file object to figure out who we are.  If the result
        //  is an error if the we weren't given a Vcb.
        //


        if (NpDecodeFileObject( IrpSp->FileObject,
                                NULL,
                                &Ccb,
                                &NamedPipeEnd ) != NPFS_NTC_ROOT_DCB) {

            DebugTrace(0, Dbg, "File Object is not for the named pipe root directory\n", 0);

            try_return( Status = STATUS_ILLEGAL_FUNCTION );
        }

        //
        //  Reference the system buffer as a wait for buffer and make
        //  sure it's large enough
        //

        if (InputBufferLength < sizeof(FILE_PIPE_WAIT_FOR_BUFFER)) {

            DebugTrace(0, Dbg, "System buffer size is too small\n", 0);

            try_return( Status = STATUS_INVALID_PARAMETER );
        }

        WaitBuffer = Irp->AssociatedIrp.SystemBuffer;

        //
        //  Check for an invalid buffer.  The Name Length cannot be greater than
        //  MAXUSHORT minus the backslash otherwise it will overflow the buffer.
        //  We don't need to check for less than 0 because it is unsigned.
        //

        if ((WaitBuffer->NameLength > (MAXUSHORT - 2)) ||
            (FIELD_OFFSET(FILE_PIPE_WAIT_FOR_BUFFER, Name[0]) + WaitBuffer->NameLength > InputBufferLength)) {

            DebugTrace(0, Dbg, "System buffer size or name length is too small\n", 0);

            try_return( Status = STATUS_INVALID_PARAMETER );
        }

        //
        //  Set up the local variable Name to be the name we're looking
        //  for
        //

        Name.Length = (USHORT)(WaitBuffer->NameLength + 2);
        Name.Buffer = LocalBuffer = NpAllocatePagedPool( Name.Length, 'WFpN' );
        if (LocalBuffer == NULL) {
            try_return( Status = STATUS_INSUFFICIENT_RESOURCES );
        }

        Name.Buffer[0] = L'\\';

        RtlCopyMemory( &Name.Buffer[1],
                       &WaitBuffer->Name[0],
                       WaitBuffer->NameLength );

        //
        //  If the name is an alias, translate it
        //

        Status = NpTranslateAlias( &Name );

        if ( !NT_SUCCESS(Status) ) {

            try_return( NOTHING );
        }

        //
        //  Now check to see if we can find a named pipe with the right
        //  name
        //

        Fcb = NpFindPrefix( &Name, CaseInsensitive, &RemainingPart );

        //
        //  If the Fcb is null then we can't wait for it,  Also if the
        //  Fcb is not an Fcb then we also have nothing to wait for
        //

        if (NodeType(Fcb) != NPFS_NTC_FCB) {

            DebugTrace(0, Dbg, "Bad nonexistent named pipe name", 0);

            try_return( Status = STATUS_OBJECT_NAME_NOT_FOUND );
        }

        //
        //  If translated then Name.Buffer would point to the translated buffer
        //

        Translated = (Name.Buffer != LocalBuffer);

        //
        //  Now we need to search to see if we find a ccb already in the
        //  listening state
        //  First try and find a ccb that is in the listening state
        //  If we exit the loop with ccb null then we haven't found
        //  one
        //

        Ccb = NULL;
        for (Links = Fcb->Specific.Fcb.CcbQueue.Flink;
             Links != &Fcb->Specific.Fcb.CcbQueue;
             Links = Links->Flink) {

            Ccb = CONTAINING_RECORD( Links, CCB, CcbLinks );

            if (Ccb->NamedPipeState == FILE_PIPE_LISTENING_STATE) {

                break;
            }

            Ccb = NULL;
        }

        //
        //  Check if we found one
        //

        if (Ccb != NULL) {

            DebugTrace(0, Dbg, "Found a ccb in listening state\n", 0);

            try_return( Status = STATUS_SUCCESS );
        }

        //
        //  We weren't able to find one so we need to add a new waiter
        //

        Status = NpAddWaiter( &NpVcb->WaitQueue,
                              Fcb->Specific.Fcb.DefaultTimeOut,
                              Irp,
                              Translated ? &Name : NULL);



    try_exit: NOTHING;
    } finally {

        if (LocalBuffer != NULL) {
            NpFreePool( LocalBuffer );
        }
    }

    DebugTrace(-1, Dbg, "NpWaitForNamedPipe -> %08lx\n", Status);
    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NpImpersonate (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine does the impersonate of the named pipe

Arguments:

    NpfsDeviceObject - Supplies our device object

    Irp - Supplies the being processed

Return Value:

    NTSTATUS - An apprropriate return status

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    PCCB Ccb;
    NAMED_PIPE_END NamedPipeEnd;

    UNREFERENCED_PARAMETER( NpfsDeviceObject );

    PAGED_CODE();

    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NpImpersonate...\n", 0);

    //
    //  Decode the file object to figure out who we are.  If the result
    //  is an error if the we weren't given a Vcb.
    //

    if (NpDecodeFileObject( IrpSp->FileObject,
                            NULL,
                            &Ccb,
                            &NamedPipeEnd ) != NPFS_NTC_CCB) {

        DebugTrace(0, Dbg, "File Object is not a named pipe\n", 0);

        DebugTrace(-1, Dbg, "NpImpersonate -> STATUS_ILLEGAL_FUNCTION\n", 0 );
        return STATUS_ILLEGAL_FUNCTION;
    }

    //
    //  Make sure that we are the server end and not the client end
    //

    if (NamedPipeEnd != FILE_PIPE_SERVER_END) {

        DebugTrace(0, Dbg, "Not the server end\n", 0);

        DebugTrace(-1, Dbg, "NpImpersonate -> STATUS_ILLEGAL_FUNCTION\n", 0 );
        return STATUS_ILLEGAL_FUNCTION;
    }

    //
    //  set up the impersonation
    //

    Status = NpImpersonateClientContext( Ccb );

    DebugTrace(-1, Dbg, "NpImpersonate -> %08lx\n", Status);
    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NpInternalRead (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp,
    IN BOOLEAN ReadOverflowOperation,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This routine does the unbuffered read named pipe control function

Arguments:

    NpfsDeviceObject - Supplies our device object

    Irp - Supplies the being processed

    ReadOverflowOperation - Used to indicate if the read being processed is a read overflow
        operation.

    DeferredList - List of IRP's to be completed later after we drop the locks

Return Value:

    NTSTATUS - An apprropriate return status

--*/

{
    NTSTATUS Status;

    PIO_STACK_LOCATION IrpSp;

    NODE_TYPE_CODE NodeTypeCode;
    PCCB Ccb;
    PNONPAGED_CCB NonpagedCcb;
    NAMED_PIPE_END NamedPipeEnd;

    NAMED_PIPE_CONFIGURATION NamedPipeConfiguration;

    PIRP ReadIrp;
    PUCHAR ReadBuffer;
    ULONG ReadLength;
    ULONG ReadRemaining;
    READ_MODE ReadMode;
    COMPLETION_MODE CompletionMode;
    PDATA_QUEUE ReadQueue;
    PEVENT_TABLE_ENTRY Event;

    PAGED_CODE();

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NpInternalRead\n", 0);
    DebugTrace( 0, Dbg, "NpfsDeviceObject = %08lx\n", NpfsDeviceObject);
    DebugTrace( 0, Dbg, "Irp              = %08lx\n", Irp);
    DebugTrace( 0, Dbg, "FileObject       = %08lx\n", IrpSp->FileObject);

    //
    //  Get the Ccb and figure out who we are, and make sure we're not
    //  disconnected
    //

    if ((NodeTypeCode = NpDecodeFileObject( IrpSp->FileObject,
                                            NULL,
                                            &Ccb,
                                            &NamedPipeEnd )) == NTC_UNDEFINED) {

        DebugTrace(0, Dbg, "Pipe is disconnected from us\n", 0);

        DebugTrace(-1, Dbg, "NpInternalRead -> STATUS_PIPE_DISCONNECTED\n", 0 );
        return STATUS_PIPE_DISCONNECTED;
    }

    //
    //  Now we only will allow Read operations on the pipe and not a directory
    //  or the device
    //

    if (NodeTypeCode != NPFS_NTC_CCB) {

        DebugTrace(0, Dbg, "FileObject is not for a named pipe\n", 0);

        DebugTrace(-1, Dbg, "NpInternalRead -> STATUS_INVALID_PARAMETER\n", 0 );
        return STATUS_INVALID_PARAMETER;
    }

    NonpagedCcb = Ccb->NonpagedCcb;

    NpAcquireExclusiveCcb(Ccb);


    //
    //  Check if the pipe is not in the connected state.
    //

    switch (Ccb->NamedPipeState) {

    case FILE_PIPE_DISCONNECTED_STATE:

        DebugTrace(0, Dbg, "Pipe in disconnected state\n", 0);

        NpReleaseCcb(Ccb);

        DebugTrace(-1, Dbg, "NpInternalRead -> STATUS_PIPE_DISCONNECTED\n", 0 );
        return STATUS_PIPE_DISCONNECTED;

    case FILE_PIPE_LISTENING_STATE:

        DebugTrace(0, Dbg, "Pipe in listening state\n", 0);

        NpReleaseCcb(Ccb);

        DebugTrace(-1, Dbg, "NpInternalRead -> STATUS_PIPE_LISTENING\n", 0 );
        return STATUS_PIPE_LISTENING;

    case FILE_PIPE_CONNECTED_STATE:
    case FILE_PIPE_CLOSING_STATE:

        break;

    default:

        DebugTrace(0, Dbg, "Illegal pipe state = %08lx\n", Ccb->NamedPipeState);
        NpBugCheck( Ccb->NamedPipeState, 0, 0 );
    }

    //
    //  We only allow a read by the server on a non outbound only pipe
    //  and by the client on a non inbound only pipe
    //

    NamedPipeConfiguration = Ccb->Fcb->Specific.Fcb.NamedPipeConfiguration;

    if (((NamedPipeEnd == FILE_PIPE_SERVER_END) &&
         (NamedPipeConfiguration == FILE_PIPE_OUTBOUND))

            ||

        ((NamedPipeEnd == FILE_PIPE_CLIENT_END) &&
         (NamedPipeConfiguration == FILE_PIPE_INBOUND))) {

        DebugTrace(0, Dbg, "Trying to read to the wrong pipe configuration\n", 0);

        NpReleaseCcb(Ccb);

        DebugTrace(-1, Dbg, "NpInternalRead -> STATUS_INVALID_PARAMETER\n", 0 );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Reference our input parameters to make things easier, and
    //  initialize our main variables that describe the Read command
    //

    ReadIrp        = Irp;
    ReadBuffer     = Irp->AssociatedIrp.SystemBuffer;
    ReadLength     = IrpSp->Parameters.FileSystemControl.OutputBufferLength;
    ReadRemaining  = ReadLength;
    ReadMode       = Ccb->ReadCompletionMode[ NamedPipeEnd ].ReadMode;
    CompletionMode = Ccb->ReadCompletionMode[ NamedPipeEnd ].CompletionMode;

    if (ReadOverflowOperation == TRUE && ReadMode != FILE_PIPE_MESSAGE_MODE) {
        NpReleaseCcb(Ccb);
        return STATUS_INVALID_READ_MODE;
    }


    //
    //  Now the data queue that we read from into and the event that we signal
    //  are based on the named pipe end.  The server read from the inbound
    //  queue and signals the client event.  The client does just the
    //  opposite.
    //

    switch (NamedPipeEnd) {

    case FILE_PIPE_SERVER_END:

        ReadQueue = &Ccb->DataQueue[ FILE_PIPE_INBOUND ];

        Event = NonpagedCcb->EventTableEntry[ FILE_PIPE_CLIENT_END ];

        break;

    case FILE_PIPE_CLIENT_END:

        ReadQueue = &Ccb->DataQueue[ FILE_PIPE_OUTBOUND ];

        Event = NonpagedCcb->EventTableEntry[ FILE_PIPE_SERVER_END ];

        break;

    default:

        NpBugCheck( NamedPipeEnd, 0, 0 );
    }

    DebugTrace(0, Dbg, "ReadBuffer     = %08lx\n", ReadBuffer);
    DebugTrace(0, Dbg, "ReadLength     = %08lx\n", ReadLength);
    DebugTrace(0, Dbg, "ReadMode       = %08lx\n", ReadMode);
    DebugTrace(0, Dbg, "CompletionMode = %08lx\n", CompletionMode);
    DebugTrace(0, Dbg, "ReadQueue      = %08lx\n", ReadQueue);
    DebugTrace(0, Dbg, "Event          = %08lx\n", Event);

    //
    //  if the read queue does not contain any write entries
    //  then we either need to enqueue this operation or
    //  fail immediately
    //

    if (!NpIsDataQueueWriters( ReadQueue )) {

        //
        //  Check if the other end of the pipe is closing, and if
        //  so then we complete it with end of file.
        //  Otherwise check to see if we should enqueue the irp
        //  or complete the operation and tell the user the pipe is empty.
        //

        if (Ccb->NamedPipeState == FILE_PIPE_CLOSING_STATE) {

            DebugTrace(0, Dbg, "Complete the irp with eof\n", 0);

            Status = STATUS_PIPE_BROKEN;

        } else if (CompletionMode == FILE_PIPE_QUEUE_OPERATION) {

            DebugTrace(0, Dbg, "Put the irp into the read queue\n", 0);

            Status = NpAddDataQueueEntry( NamedPipeEnd,
                                          Ccb,
                                          ReadQueue,
                                          ReadEntries,
                                          Unbuffered,
                                          ReadLength,
                                          ReadIrp,
                                          NULL,
                                          0 );

        } else {

            DebugTrace(0, Dbg, "Complete the irp with pipe empty\n", 0);

            Status = STATUS_PIPE_EMPTY;
        }

    } else {

        //
        //  otherwise there we have a read irp against a read queue
        //  that contains one or more write entries.
        //

        ReadIrp->IoStatus = NpReadDataQueue( ReadQueue,
                                             FALSE,
                                             ReadOverflowOperation,
                                             ReadBuffer,
                                             ReadLength,
                                             ReadMode,
                                             Ccb,
                                             DeferredList );

        Status = ReadIrp->IoStatus.Status;

        //
        //  Now set the remaining byte count in the allocation size of
        //  the Irp.
        //

        ReadIrp->Overlay.AllocationSize.QuadPart = ReadQueue->BytesInQueue - ReadQueue->NextByteOffset;

        //
        //  Finish up the read irp.
        //
    }

    //
    //  And because we've done something we need to signal the
    //  other ends event
    //

    NpSignalEventTableEntry( Event );

    NpReleaseCcb(Ccb);

    DebugTrace(-1, Dbg, "NpInternalRead -> %08lx\n", Status);
    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NpInternalWrite (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This routine does the unbuffered write named pipe control function

Arguments:

    NpfsDeviceObject - Supplies our device object

    Irp - Supplies the being processed

Return Value:

    NTSTATUS - An apprropriate return status

--*/

{
    NTSTATUS Status;

    PIO_STACK_LOCATION IrpSp;
    PETHREAD UserThread;

    NODE_TYPE_CODE NodeTypeCode;
    PCCB Ccb;
    PNONPAGED_CCB NonpagedCcb;
    NAMED_PIPE_END NamedPipeEnd;

    NAMED_PIPE_CONFIGURATION NamedPipeConfiguration;

    PIRP WriteIrp;
    PUCHAR WriteBuffer;
    ULONG WriteLength;
    ULONG WriteRemaining;
    PDATA_QUEUE WriteQueue;

    PEVENT_TABLE_ENTRY Event;
    READ_MODE ReadMode;

    PAGED_CODE();

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NpInternalWrite\n", 0);
    DebugTrace( 0, Dbg, "NpfsDeviceObject = %08lx\n", NpfsDeviceObject);
    DebugTrace( 0, Dbg, "Irp              = %08lx\n", Irp);
    DebugTrace( 0, Dbg, "FileObject       = %08lx\n", IrpSp->FileObject);

    //
    // This is a FSCTL path being used as a write. Make sure we can set the .Information field to the number
    // of bytes written.
    //
    NpConvertFsctlToWrite (Irp);

    //
    //  Get the Ccb and figure out who we are, and make sure we're not
    //  disconnected
    //

    if ((NodeTypeCode = NpDecodeFileObject( IrpSp->FileObject,
                                            NULL,
                                            &Ccb,
                                            &NamedPipeEnd )) == NTC_UNDEFINED) {

        DebugTrace(0, Dbg, "Pipe is disconnected from us\n", 0);

        DebugTrace(-1, Dbg, "NpInternalWrite -> STATUS_PIPE_DISCONNECTED\n", 0 );
        return STATUS_PIPE_DISCONNECTED;
    }

    //
    //  Now we only will allow write operations on the pipe and not a directory
    //  or the device
    //

    if (NodeTypeCode != NPFS_NTC_CCB) {

        DebugTrace(0, Dbg, "FileObject is not for a named pipe\n", 0);

        DebugTrace(-1, Dbg, "NpInternalWrite -> STATUS_PIPE_DISCONNECTED\n", 0);
        return STATUS_PIPE_DISCONNECTED;
    }

    NonpagedCcb = Ccb->NonpagedCcb;

    NpAcquireExclusiveCcb(Ccb);

    //
    //  We only allow a write by the server on a non inbound only pipe
    //  and by the client on a non outbound only pipe
    //

    NamedPipeConfiguration = Ccb->Fcb->Specific.Fcb.NamedPipeConfiguration;

    if (((NamedPipeEnd == FILE_PIPE_SERVER_END) &&
         (NamedPipeConfiguration == FILE_PIPE_INBOUND))

            ||

        ((NamedPipeEnd == FILE_PIPE_CLIENT_END) &&
         (NamedPipeConfiguration == FILE_PIPE_OUTBOUND))) {

        DebugTrace(0, Dbg, "Trying to write to the wrong pipe configuration\n", 0);

        NpReleaseCcb(Ccb);

        DebugTrace(-1, Dbg, "NpInternalWrite -> STATUS_PIPE_DISCONNECTED\n", 0);
        return STATUS_PIPE_DISCONNECTED;
    }

    //
    //  Reference our input parameters to make things easier, and
    //  initialize our main variables that describe the write command
    //

    WriteIrp = Irp;
    WriteBuffer = Irp->AssociatedIrp.SystemBuffer;
    WriteLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;

    //
    //  Set up the amount of data we will have written by the time this
    //  irp gets completed
    //

    WriteIrp->IoStatus.Information = WriteLength;

    //
    //  Now the data queue that we write into and the event that we signal
    //  are based on the named pipe end.  The server writes to the outbound
    //  queue and signals the client event.  The client does just the
    //  opposite.  We also need to figure out the read mode for the opposite
    //  end of the pipe.
    //

    switch (NamedPipeEnd) {

    case FILE_PIPE_SERVER_END:

        WriteQueue = &Ccb->DataQueue[ FILE_PIPE_OUTBOUND ];

        Event = NonpagedCcb->EventTableEntry[ FILE_PIPE_CLIENT_END ];
        ReadMode = Ccb->ReadCompletionMode[ FILE_PIPE_CLIENT_END ].ReadMode;

        break;

    case FILE_PIPE_CLIENT_END:

        WriteQueue = &Ccb->DataQueue[ FILE_PIPE_INBOUND ];

        Event = NonpagedCcb->EventTableEntry[ FILE_PIPE_SERVER_END ];
        ReadMode = Ccb->ReadCompletionMode[ FILE_PIPE_SERVER_END ].ReadMode;

        break;

    default:

        NpBugCheck( NamedPipeEnd, 0, 0 );
    }

    //
    //  Check if the pipe is not in the connected state.
    //

    switch (Ccb->NamedPipeState) {

    case FILE_PIPE_DISCONNECTED_STATE:

        DebugTrace(0, Dbg, "Pipe in disconnected state\n", 0);

        NpReleaseCcb(Ccb);
        return STATUS_PIPE_DISCONNECTED;

    case FILE_PIPE_LISTENING_STATE:

        DebugTrace(0, Dbg, "Pipe in listening state\n", 0);

        NpReleaseCcb(Ccb);
        return STATUS_PIPE_LISTENING;

    case FILE_PIPE_CONNECTED_STATE:

        break;

    case FILE_PIPE_CLOSING_STATE:

        DebugTrace(0, Dbg, "Pipe in closing state\n", 0);

        NpReleaseCcb(Ccb);
        return STATUS_PIPE_CLOSING;

    default:

        DebugTrace(0, Dbg, "Illegal pipe state = %08lx\n", Ccb->NamedPipeState);
        NpBugCheck( Ccb->NamedPipeState, 0, 0 );
    }

    //
    //  Check if this is a message type pipe and the operation type is complete
    //  operation,  If so then we also check that the queued reads is enough to
    //  complete the message otherwise we need to abort the write irp immediately.
    //

    if ((Ccb->Fcb->Specific.Fcb.NamedPipeType == FILE_PIPE_MESSAGE_TYPE) &&
        (Ccb->ReadCompletionMode[NamedPipeEnd].CompletionMode == FILE_PIPE_COMPLETE_OPERATION)) {

        //
        //  If the pipe contains readers and amount to read is less than the write
        //  length then we cannot do it the write.
        //  Or if pipe does not contain reads then we also cannot do the write.
        //

        if ((NpIsDataQueueReaders( WriteQueue ) &&
            (WriteQueue->BytesInQueue < WriteLength))

                ||

            (!NpIsDataQueueReaders( WriteQueue ))) {

            DebugTrace(0, Dbg, "Cannot complete the message without blocking\n", 0);

            NpReleaseCcb(Ccb);
            Irp->IoStatus.Information = 0;
            return STATUS_SUCCESS;
        }
    }

    //
    //  Now we'll call our common write data queue routine to
    //  transfer data out of our write buffer into the data queue.
    //  If the result of the call is FALSE then we still have some
    //  write data to put into the write queue.
    //

    UserThread = Irp->Tail.Overlay.Thread;
    Status = NpWriteDataQueue( WriteQueue,
                               ReadMode,
                               WriteBuffer,
                               WriteLength,
                               Ccb->Fcb->Specific.Fcb.NamedPipeType,
                               &WriteRemaining,
                               Ccb,
                               NamedPipeEnd,
                               UserThread,
                               DeferredList );

    if (Status == STATUS_MORE_PROCESSING_REQUIRED)  {

        ASSERT( !NpIsDataQueueReaders( WriteQueue ));

        //
        //  Check if the operation is not to block and if so then we
        //  will complete the operation now with what we're written, if what is
        //  left will not fit in the quota for the file
        //

        if (Ccb->ReadCompletionMode[NamedPipeEnd].CompletionMode == FILE_PIPE_COMPLETE_OPERATION) {

            DebugTrace(0, Dbg, "Complete the byte stream write immediately\n", 0);

            Irp->IoStatus.Information = WriteLength - WriteRemaining;

            Status = STATUS_SUCCESS;

        } else {

            DebugTrace(0, Dbg, "Add write to data queue\n", 0);

            //
            //  Add this write request to the write queue
            //

            Status = NpAddDataQueueEntry( NamedPipeEnd,
                                          Ccb,
                                          WriteQueue,
                                          WriteEntries,
                                          Unbuffered,
                                          WriteLength,
                                          Irp,
                                          NULL,
                                          WriteLength - WriteRemaining);

        }

    } else {

        DebugTrace(0, Dbg, "Complete the Write Irp\n", 0);


        //
        //  The write irp is finished so we can complete it now
        //

    }

    //
    //  And because we've done something we need to signal the
    //  other ends event
    //

    NpSignalEventTableEntry( Event );

    NpReleaseCcb(Ccb);

    DebugTrace(-1, Dbg, "NpInternalWrite -> %08lx\n", Status);
    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NpInternalTransceive (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This routine does the internal (i.e., unbuffered) transceive named pipe
    control function

Arguments:

    NpfsDeviceObject - Supplies our device object

    Irp - Supplies the being processed

    DeferredList - List of IRP's to be completed once we drop our locks.

Return Value:

    NTSTATUS - An apprropriate return status

--*/

{
    static IO_STATUS_BLOCK Iosb;
    NTSTATUS Status;

    PIO_STACK_LOCATION IrpSp;
    PETHREAD UserThread;

    PUCHAR WriteBuffer;
    ULONG WriteLength;

    PUCHAR ReadBuffer;
    ULONG ReadLength;

    NODE_TYPE_CODE NodeTypeCode;
    PCCB Ccb;
    PNONPAGED_CCB NonpagedCcb;
    NAMED_PIPE_END NamedPipeEnd;

    PDATA_QUEUE ReadQueue;
    PDATA_QUEUE WriteQueue;
    PEVENT_TABLE_ENTRY Event;
    READ_MODE ReadMode;

    NAMED_PIPE_CONFIGURATION NamedPipeConfiguration;

    ULONG WriteRemaining;

    PIRP WriteIrp;

    //
    //  The following variable is used for abnormal unwind
    //

    PVOID UnwindStorage = NULL;

    PAGED_CODE();

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NpInternalTransceive\n", 0);
    DebugTrace( 0, Dbg, "NpfsDeviceObject = %08lx\n", NpfsDeviceObject);
    DebugTrace( 0, Dbg, "Irp              = %08lx\n", Irp);
    DebugTrace( 0, Dbg, "FileObject       = %08lx\n", IrpSp->FileObject);

    WriteLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;
    WriteBuffer = IrpSp->Parameters.FileSystemControl.Type3InputBuffer;

    ReadLength = IrpSp->Parameters.FileSystemControl.OutputBufferLength;
    ReadBuffer = Irp->AssociatedIrp.SystemBuffer;

    //
    //  Get the Ccb and figure out who we are, and make sure we're not
    //  disconnected
    //

    if ((NodeTypeCode = NpDecodeFileObject( IrpSp->FileObject,
                                            NULL,
                                            &Ccb,
                                            &NamedPipeEnd )) == NTC_UNDEFINED) {

        DebugTrace(0, Dbg, "Pipe is disconnected from us\n", 0);

        DebugTrace(-1, Dbg, "NpInternalTransceive -> STATUS_PIPE_DISCONNECTED\n", 0 );
        return STATUS_PIPE_DISCONNECTED;
    }

    //
    //  Now we only will allow transceive operations on the pipe and not a
    //  directory or the device
    //

    if (NodeTypeCode != NPFS_NTC_CCB) {

        DebugTrace(0, Dbg, "FileObject is not for a named pipe\n", 0);

        DebugTrace(-1, Dbg, "NpInternalTransceive -> STATUS_INVALID_PARAMETER\n", 0 );
        return STATUS_INVALID_PARAMETER;
    }

    NonpagedCcb = Ccb->NonpagedCcb;

    WriteIrp = NULL;
    NpAcquireExclusiveCcb(Ccb);

    try {

        //
        //  Check that the pipe is in the connected state
        //

        if (Ccb->NamedPipeState != FILE_PIPE_CONNECTED_STATE) {

            DebugTrace(0, Dbg, "Pipe not connected\n", 0);

            try_return( Status = STATUS_INVALID_PIPE_STATE );
        }

        //
        //  Figure out the read/write queue, read mode, and event based
        //  on the end of the named pipe doing the transceive.
        //

        switch (NamedPipeEnd) {

        case FILE_PIPE_SERVER_END:

            ReadQueue = &Ccb->DataQueue[ FILE_PIPE_INBOUND ];
            WriteQueue = &Ccb->DataQueue[ FILE_PIPE_OUTBOUND ];

            Event = NonpagedCcb->EventTableEntry[ FILE_PIPE_CLIENT_END ];
            ReadMode = Ccb->ReadCompletionMode[ FILE_PIPE_SERVER_END ].ReadMode;

            break;

        case FILE_PIPE_CLIENT_END:

            ReadQueue = &Ccb->DataQueue[ FILE_PIPE_OUTBOUND ];
            WriteQueue = &Ccb->DataQueue[ FILE_PIPE_INBOUND ];

            Event = NonpagedCcb->EventTableEntry[ FILE_PIPE_SERVER_END ];
            ReadMode = Ccb->ReadCompletionMode[ FILE_PIPE_CLIENT_END ].ReadMode;

            break;

        default:

            NpBugCheck( NamedPipeEnd, 0, 0 );
        }

        //
        //  We only allow a transceive on a message mode, full duplex pipe.
        //

        NamedPipeConfiguration = Ccb->Fcb->Specific.Fcb.NamedPipeConfiguration;

        if ((NamedPipeConfiguration != FILE_PIPE_FULL_DUPLEX) ||
            (ReadMode != FILE_PIPE_MESSAGE_MODE)) {

            DebugTrace(0, Dbg, "Bad pipe configuration or read mode\n", 0);

            try_return( Status = STATUS_INVALID_READ_MODE );
        }

        //
        //  Check that the read queue is empty.
        //

        if (!NpIsDataQueueEmpty( ReadQueue )) {

            DebugTrace(0, Dbg, "Read queue is not empty\n", 0);

            try_return( Status = STATUS_PIPE_BUSY );
        }

        //
        //  Do the transceive write operation.  We first try and push the data
        //  from the write buffer into any waiting readers in the write queue
        //  and if that succeeds then we can go on and do the read operation
        //  otherwise we need to make a copy of irp and to enqueue as
        //  a data entry into the write queue.
        //
        //  Now we'll call our common write data queue routine to
        //  transfer data out of our write buffer into the data queue.
        //  If the result of the call is FALSE then we still have some
        //  write data to put into the write queue.
        //

        UserThread = Irp->Tail.Overlay.Thread;
        Status = NpWriteDataQueue( WriteQueue,
                                   ReadMode,
                                   WriteBuffer,
                                   WriteLength,
                                   Ccb->Fcb->Specific.Fcb.NamedPipeType,
                                   &WriteRemaining,
                                   Ccb,
                                   NamedPipeEnd,
                                   UserThread,
                                   DeferredList );
        if (Status == STATUS_MORE_PROCESSING_REQUIRED)  {

            PIO_STACK_LOCATION WriteIrpSp;

            ASSERT( !NpIsDataQueueReaders( WriteQueue ));

            DebugTrace(0, Dbg, "Add write to data queue\n", 0);

            //
            //  We need to do some more write processing.  So to handle
            //  this case we'll allocate a new irp and set its system
            //  buffer to be the remaining part of the write buffer
            //

            if ((WriteIrp = IoAllocateIrp( NpfsDeviceObject->DeviceObject.StackSize, TRUE )) == NULL) {

                try_return( Status = STATUS_INSUFFICIENT_RESOURCES );
            }

            IoSetCompletionRoutine( WriteIrp, NpCompleteTransceiveIrp, NULL, TRUE, TRUE, TRUE );

            WriteIrpSp = IoGetNextIrpStackLocation( WriteIrp );

            if (WriteRemaining > 0) {

                WriteIrp->AssociatedIrp.SystemBuffer = NpAllocatePagedPoolWithQuota( WriteRemaining, 'wFpN' );
                if (WriteIrp->AssociatedIrp.SystemBuffer == NULL) {
                    IoFreeIrp (WriteIrp);
                    try_return (Status = STATUS_INSUFFICIENT_RESOURCES);
                }
                //
                //  Safely do the copy
                //

                try {

                    RtlCopyMemory( WriteIrp->AssociatedIrp.SystemBuffer,
                                   &WriteBuffer[ WriteLength - WriteRemaining ],
                                   WriteRemaining );

                    WriteIrp->Flags = IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER;

                } except(EXCEPTION_EXECUTE_HANDLER) {
                    NpFreePool (WriteIrp->AssociatedIrp.SystemBuffer);
                    IoFreeIrp (WriteIrp);
                    try_return (Status = GetExceptionCode ());
                }

            } else {

                WriteIrp->AssociatedIrp.SystemBuffer = NULL;
            }

            //
            //  Set the current stack location
            //

            WriteIrp->CurrentLocation -= 1;
            WriteIrp->Tail.Overlay.CurrentStackLocation = WriteIrpSp;
            WriteIrp->Tail.Overlay.Thread = UserThread;
            WriteIrpSp->MajorFunction = IRP_MJ_WRITE;
            WriteIrp->UserIosb = &Iosb;

            //
            //  Add this write request to the write queue
            //

            Status = NpAddDataQueueEntry( NamedPipeEnd,
                                          Ccb,
                                          WriteQueue,
                                          WriteEntries,
                                          Unbuffered,
                                          WriteRemaining,
                                          WriteIrp,
                                          NULL,
                                          0 );
            if (Status != STATUS_PENDING) {
                NpDeferredCompleteRequest (WriteIrp, Status, DeferredList);
            }
        }
        if (!NT_SUCCESS (Status)) {
            try_return (NOTHING)
        }
        //
        //  And because we've done something we need to signal the
        //  other ends event
        //

        NpSignalEventTableEntry( Event );

        //
        //  Do the transceive read operation.  This is just like an
        //  unbuffered read.
        //
        //  Now we know that the read queue is empty so we'll enqueue this
        //  Irp to the read queue and return status pending, also mark the
        //  irp pending
        //

        ASSERT( NpIsDataQueueEmpty( ReadQueue ));

        Status = NpAddDataQueueEntry( NamedPipeEnd,
                                      Ccb,
                                      ReadQueue,
                                      ReadEntries,
                                      Unbuffered,
                                      ReadLength,
                                      Irp,
                                      NULL,
                                      0 );
        if (!NT_SUCCESS (Status)) {
            try_return (Status);
        }


        //
        //  And because we've done something we need to signal the
        //  other ends event
        //

        NpSignalEventTableEntry( Event );

    try_exit: NOTHING;
    } finally {

        NpReleaseCcb(Ccb);
    }

    DebugTrace(-1, Dbg, "NpInternalTransceive -> %08lx\n", Status);
    return Status;
}


//
//  Internal support routine
//

NTSTATUS
NpQueryClientProcess (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine does the query client process named pipe control function

    The output buffer may be either a FILE_PIPE_CLIENT_PROCESS_BUFFER or a
    FILE_PIPE_CLIENT_PROCESS_BUFFER_EX.

Arguments:

    NpfsDeviceObject - Supplies our device object

    Irp - Supplies the being processed

Return Value:

    NTSTATUS - An apprropriate return status

--*/

{
    PIO_STACK_LOCATION IrpSp;

    ULONG OutputBufferLength;

    PCCB Ccb;

    PFILE_PIPE_CLIENT_PROCESS_BUFFER_EX ClientProcessBuffer;
    PCLIENT_INFO ClientInfo;
    CLIENT_INFO NullInfo = {0};

    PAGED_CODE();

    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NpQueryClientProcess\n", 0);

    OutputBufferLength = IrpSp->Parameters.FileSystemControl.OutputBufferLength;

    //
    //  Decode the file object to figure out who we are.
    //

    if (NpDecodeFileObject( IrpSp->FileObject, NULL, &Ccb, NULL ) != NPFS_NTC_CCB) {

        DebugTrace(0, Dbg, "Pipe is disconnected\n", 0);

        return STATUS_PIPE_DISCONNECTED;
    }

    //
    //  Make sure the output buffer is large enough
    //

    if (OutputBufferLength < sizeof(FILE_PIPE_CLIENT_PROCESS_BUFFER)) {

        DebugTrace(0, Dbg, "Output System buffer size is too small\n", 0);

        return STATUS_INVALID_PARAMETER;
    }

    NpAcquireExclusiveCcb(Ccb);

    //
    //  Copy over the client process ID
    //

    ClientProcessBuffer = Irp->AssociatedIrp.SystemBuffer;
    ClientProcessBuffer->ClientProcess = Ccb->ClientProcess;

    ClientInfo = Ccb->ClientInfo;
    if (ClientInfo == NULL) {
        ClientInfo = &NullInfo;
    }
    ClientProcessBuffer->ClientSession = ClientInfo->ClientSession;

    //
    // Return extended client information if so requested
    // Set the information field to the size of the client process
    // buffer
    //

    if (OutputBufferLength >= sizeof(FILE_PIPE_CLIENT_PROCESS_BUFFER_EX)) {


        ClientProcessBuffer->ClientComputerNameLength =
            ClientInfo->ClientComputerNameLength;

        RtlCopyMemory( ClientProcessBuffer->ClientComputerBuffer,
                       ClientInfo->ClientComputerBuffer,
                       ClientInfo->ClientComputerNameLength );
        ClientProcessBuffer->ClientComputerBuffer[
            ClientProcessBuffer->ClientComputerNameLength / sizeof(WCHAR)] = L'\0';

        Irp->IoStatus.Information = sizeof(FILE_PIPE_CLIENT_PROCESS_BUFFER_EX);

    } else {

        Irp->IoStatus.Information = sizeof(FILE_PIPE_CLIENT_PROCESS_BUFFER);

    }
    NpReleaseCcb(Ccb);

    DebugTrace(-1, Dbg, "NpQueryClientProcess -> STATUS_SUCCESS\n", 0);
    return STATUS_SUCCESS;
}


//
//  Internal support routine
//

NTSTATUS
NpSetClientProcess (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine does the set client process named pipe control function

    Note that we expect a FILE_PIPE_CLIENT_PROCESS_BUFFER_EX structure to be
    passed in to us.

Arguments:

    NpfsDeviceObject - Supplies our device object

    Irp - Supplies the being processed

Return Value:

    NTSTATUS - An apprropriate return status

--*/

{
    PIO_STACK_LOCATION IrpSp;
    PCLIENT_INFO ClientInfo;
    ULONG InputBufferLength;

    PCCB Ccb;

    PFILE_PIPE_CLIENT_PROCESS_BUFFER_EX ClientProcessBuffer;

    PAGED_CODE();

    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NpSetClientProcess\n", 0);

    //
    // Only allow kernel callers for this API as RPC relies on this info being solid.
    //
    if (IrpSp->MinorFunction != IRP_MN_KERNEL_CALL) {
        return STATUS_ACCESS_DENIED;
    }


    InputBufferLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;

    //
    //  Decode the file object to figure out who we are.
    //

    if (NpDecodeFileObject( IrpSp->FileObject, NULL, &Ccb, NULL ) != NPFS_NTC_CCB) {

        DebugTrace(0, Dbg, "Pipe is disconnected\n", 0);

        return STATUS_PIPE_DISCONNECTED;
    }

    //
    //  Make sure the input buffer is large enough
    //

    if (InputBufferLength != sizeof(FILE_PIPE_CLIENT_PROCESS_BUFFER_EX)) {

        DebugTrace(0, Dbg, "Input System buffer size is too small\n", 0);

        return STATUS_INVALID_PARAMETER;
    }

    ClientProcessBuffer = Irp->AssociatedIrp.SystemBuffer;

    //
    //  Make verify input length is valid
    //

    if (ClientProcessBuffer->ClientComputerNameLength >
        FILE_PIPE_COMPUTER_NAME_LENGTH * sizeof (WCHAR)) {

        DebugTrace(0, Dbg, "Computer Name length is too large\n", 0);

        return STATUS_INVALID_PARAMETER;
    }

    ClientInfo = NpAllocatePagedPoolWithQuota (FIELD_OFFSET (CLIENT_INFO, ClientComputerBuffer) +
                                                   ClientProcessBuffer->ClientComputerNameLength,
                                               'iFpN');

    if (ClientInfo == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    if (Ccb->ClientInfo != NULL) {
        NpFreePool (Ccb->ClientInfo);
    }

    Ccb->ClientInfo = ClientInfo;
    //
    //  Copy over the client process ID
    //

    ClientInfo->ClientSession = ClientProcessBuffer->ClientSession;
    Ccb->ClientProcess = ClientProcessBuffer->ClientProcess;

    ClientInfo->ClientComputerNameLength = ClientProcessBuffer->ClientComputerNameLength;
    RtlCopyMemory( ClientInfo->ClientComputerBuffer,
                   ClientProcessBuffer->ClientComputerBuffer,
                   ClientProcessBuffer->ClientComputerNameLength );


    DebugTrace(-1, Dbg, "NpSetClientProcess -> STATUS_SUCCESS\n", 0);
    return STATUS_SUCCESS;
}


//
//  Internal support routine
//

NTSTATUS
NpCompleteTransceiveIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This is a local i/o completion routine used to complete the special
    Irps allocated for transcieve.  This routine simply deallocate the
    irp and return status more processing

Arguments:

    DeviceObject - Supplies the device object

    Irp - Supplies the Irp to complete

    Context - Supplies the context for the Irp

Return Value:

    NTSTATUS - STATUS_MORE_PROCESSING_REQUIRED

--*/

{
    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Context );

    PAGED_CODE();

    if (Irp->AssociatedIrp.SystemBuffer != NULL) {

        NpFreePool( Irp->AssociatedIrp.SystemBuffer );
    }

    IoFreeIrp( Irp );

    return STATUS_MORE_PROCESSING_REQUIRED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\npfs\npinit.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    NpInit.c

Abstract:

    This module implements the DRIVER_INITIALIZATION routine for the Named
    Pipe file system.

Author:

    Gary Kimura     [GaryKi]    21-Aug-1990


Revision History:

    Neill Clift     [NeillC]	22-Jan-2000
    Major rework, Don't raise exceptions, fix lots of error handling, Sort out cancel logic etc, fix validation.

--*/


#include "NpProcs.h"
//#include <zwapi.h>

VOID
NpfsUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

PNPFS_DEVICE_OBJECT NpfsDeviceObject = NULL;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(PAGE,NpfsUnload)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the initialization routine for the Named Pipe file system
    device driver.  This routine creates the device object for the named pipe
    device and performs all other driver initialization.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    NTSTATUS - The function value is the final status from the initialization
        operation.

--*/

{
    NTSTATUS Status;
    UNICODE_STRING NameString;
    PDEVICE_OBJECT DeviceObject;

    PAGED_CODE();

    //
    //  Create the alias lists.
    //

    Status = NpInitializeAliases( );
    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    //
    //  Create the device object.
    //

    RtlInitUnicodeString( &NameString, L"\\Device\\NamedPipe" );

    Status = IoCreateDevice( DriverObject,
                             sizeof(NPFS_DEVICE_OBJECT)-sizeof(DEVICE_OBJECT),
                             &NameString,
                             FILE_DEVICE_NAMED_PIPE,
                             0,
                             FALSE,
                             &DeviceObject );

    if (!NT_SUCCESS( Status )) {
        NpUninitializeAliases( );
        return Status;
    }
    //
    // Set up the unload routine
    //
    DriverObject->DriverUnload = NpfsUnload;

    //
    //  Note that because of the way data copying is done, we set neither
    //  the Direct I/O or Buffered I/O bit in DeviceObject->Flags.  If
    //  data is not buffered we may set up for Direct I/O by hand.  We do,
    //  however, set the long term request flag so that IRPs that get
    //  allocated for functions such as Listen requests come out of non-paged
    //  pool always.
    //

    DeviceObject->Flags |= DO_LONG_TERM_REQUESTS;

    //
    //  Initialize the driver object with this driver's entry points.
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE]                   = (PDRIVER_DISPATCH)NpFsdCreate;
    DriverObject->MajorFunction[IRP_MJ_CREATE_NAMED_PIPE]        = (PDRIVER_DISPATCH)NpFsdCreateNamedPipe;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]                    = (PDRIVER_DISPATCH)NpFsdClose;
    DriverObject->MajorFunction[IRP_MJ_READ]                     = (PDRIVER_DISPATCH)NpFsdRead;
    DriverObject->MajorFunction[IRP_MJ_WRITE]                    = (PDRIVER_DISPATCH)NpFsdWrite;
    DriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION]        = (PDRIVER_DISPATCH)NpFsdQueryInformation;
    DriverObject->MajorFunction[IRP_MJ_SET_INFORMATION]          = (PDRIVER_DISPATCH)NpFsdSetInformation;
    DriverObject->MajorFunction[IRP_MJ_QUERY_VOLUME_INFORMATION] = (PDRIVER_DISPATCH)NpFsdQueryVolumeInformation;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP]                  = (PDRIVER_DISPATCH)NpFsdCleanup;
    DriverObject->MajorFunction[IRP_MJ_FLUSH_BUFFERS]            = (PDRIVER_DISPATCH)NpFsdFlushBuffers;
    DriverObject->MajorFunction[IRP_MJ_DIRECTORY_CONTROL]        = (PDRIVER_DISPATCH)NpFsdDirectoryControl;
    DriverObject->MajorFunction[IRP_MJ_FILE_SYSTEM_CONTROL]      = (PDRIVER_DISPATCH)NpFsdFileSystemControl;
    DriverObject->MajorFunction[IRP_MJ_QUERY_SECURITY]           = (PDRIVER_DISPATCH)NpFsdQuerySecurityInfo;
    DriverObject->MajorFunction[IRP_MJ_SET_SECURITY]             = (PDRIVER_DISPATCH)NpFsdSetSecurityInfo;

#ifdef _PNP_POWER_
    //
    // Npfs doesn't need to handle SetPower requests.   Local named pipes
    // won't lose any state.  Remote pipes will be lost, by a network driver
    // will fail PowerQuery if there are open network connections.
    //

    DeviceObject->DeviceObjectExtension->PowerControlNeeded = FALSE;
#endif


    DriverObject->FastIoDispatch = &NpFastIoDispatch;


    //
    //  Now initialize the Vcb, and create the root dcb
    //

    NpfsDeviceObject = (PNPFS_DEVICE_OBJECT)DeviceObject;

    NpVcb = &NpfsDeviceObject->Vcb;
    NpInitializeVcb ();

    Status = NpCreateRootDcb ();

    if (!NT_SUCCESS (Status)) {
        LIST_ENTRY DeferredList;

        InitializeListHead (&DeferredList);
        NpDeleteVcb (&DeferredList);
        IoDeleteDevice (DeviceObject);
        NpUninitializeAliases ();
        NpCompleteDeferredIrps (&DeferredList);
    }

    //
    //  And return to our caller
    //

    return Status;
}

VOID
NpfsUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++
      
Routine Description:
      
    This routine cleans up all of the memory associated with
    the driver.
      
Arguments:
      
    DriverObject    - Supplies the driver object controlling the device.
      
Return Value:
      
    None.
      
--*/
{
    UNICODE_STRING us;
    LIST_ENTRY DeferredList;

    InitializeListHead (&DeferredList);
    NpDeleteVcb (&DeferredList);
    NpCompleteDeferredIrps (&DeferredList);

    RtlInitUnicodeString (&us, L"\\??\\PIPE"); // Created by SMSS
    IoDeleteSymbolicLink (&us);

    IoDeleteDevice (&NpfsDeviceObject->DeviceObject);
    NpUninitializeAliases ();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\npfs\prefxsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    PrefxSup.c

Abstract:

    This module implements the Named Pipe Prefix support routines

Author:

    Gary Kimura     [GaryKi]    13-Feb-1990

Revision History:

--*/

#include "NpProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (NPFS_BUG_CHECK_PREFXSUP)

//
//  The debug trace level for this module
//

#define Dbg                              (DEBUG_TRACE_PREFXSUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NpFindPrefix)
#pragma alloc_text(PAGE, NpFindRelativePrefix)
#endif


PFCB
NpFindPrefix (
    IN PUNICODE_STRING String,
    IN BOOLEAN CaseInsensitive,
    OUT PUNICODE_STRING RemainingPart
    )

/*++

Routine Description:

    This routine searches the FCBs/DCBs of a volume and locates the
    FCB/DCB with longest matching prefix for the given input string.  The
    search is relative to the root of the volume.  So all names must start
    with a "\".

Arguments:

    String - Supplies the input string to search for

    CaseInsensitive - Specifies if the search is to be done case sensitive
        (FALSE) or insensitive (TRUE)

    RemainingPart - Returns the string when the prefix no longer matches.
        For example, if the input string is "\alpha\beta" only matches the
        root directory then the remaining string is "alpha\beta".  If the
        same string matches a DCB for "\alpha" then the remaining string is
        "beta".

Return Value:

    PFCB - Returns a pointer to either an FCB or a DCB whichever is the
        longest matching prefix.

--*/

{
    PUNICODE_PREFIX_TABLE_ENTRY PrefixTableEntry;
    PFCB Fcb;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpFindPrefix, NpVcb = %08lx\n", NpVcb);
    DebugTrace( 0, Dbg, "  String = %Z\n", String);

    //
    //  Find the longest matching prefix
    //

    PrefixTableEntry = RtlFindUnicodePrefix( &NpVcb->PrefixTable,
                                             String,
                                             CaseInsensitive );

    //
    //  If we didn't find one then it's an error
    //

    if (PrefixTableEntry == NULL) {

        DebugDump("Error looking up a prefix", 0, NpVcb);
        NpBugCheck( 0, 0, 0 );
    }

    //
    //  Get a pointer to the Fcb containing the prefix table entry
    //

    Fcb = CONTAINING_RECORD( PrefixTableEntry, FCB, PrefixTableEntry );

    //
    //  Tell the caller how many characters we were able to match.  We first
    //  set the remaining part to the original string minus the matched
    //  prefix, then we check if the remaining part starts with a backslash
    //  and if it does then we remove the backslash from the remaining string.
    //

    RemainingPart->Length = String->Length - Fcb->FullFileName.Length;
    RemainingPart->MaximumLength = RemainingPart->Length;
    RemainingPart->Buffer = &String->Buffer[ Fcb->FullFileName.Length/sizeof(WCHAR) ];

    if ((RemainingPart->Length > 0) &&
        (RemainingPart->Buffer[0] == L'\\')) {

        RemainingPart->Length -= sizeof(WCHAR);
        RemainingPart->MaximumLength -= sizeof(WCHAR);
        RemainingPart->Buffer += 1;
    }

    DebugTrace(0, Dbg, "RemainingPart set to %Z\n", RemainingPart);

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "NpFindPrefix -> %08lx\n", Fcb);

    return Fcb;
}


NTSTATUS
NpFindRelativePrefix (
    IN PDCB Dcb,
    IN PUNICODE_STRING String,
    IN BOOLEAN CaseInsensitive,
    OUT PUNICODE_STRING RemainingPart,
    OUT PFCB *ppFcb
    )

/*++

Routine Description:

    This routine searches the FCBs/DCBs of a volume and locates the
    FCB/DCB with longest matching prefix for the given input string.  The
    search is relative to a input DCB, and must not start with a leading "\"
    All searching is done case insensitive.

Arguments:

    Dcb - Supplies the Dcb to start searching from

    String - Supplies the input string to search for

    CaseInsensitive - Specifies if the search is to be done case sensitive
        (FALSE) or insensitive (TRUE)

    RemainingPart - Returns the index into the string when the prefix no
        longer matches.  For example, if the input string is "beta\gamma"
        and the input Dcb is for "\alpha" and we only match beta then
        the remaining string is "gamma".

Return Value:

    PFCB - Returns a pointer to either an FCB or a DCB whichever is the
        longest matching prefix.

--*/

{
    USHORT NameLength, MaxLength;
    PWCH Name;

    UNICODE_STRING FullString;
    PWCH Temp;

    PFCB Fcb;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpFindRelativePrefix, Dcb = %08lx\n", Dcb);
    DebugTrace( 0, Dbg, "String = %08lx\n", String);


    //
    //  We first need to build the complete name and then do a relative
    //  search from the root
    //

    NameLength = String->Length;
    MaxLength  = NameLength + 2*sizeof(WCHAR);

    if (MaxLength < NameLength) {
        return STATUS_INVALID_PARAMETER;
    }

    Name       = String->Buffer;

    ASSERT(NodeType(Dcb) == NPFS_NTC_ROOT_DCB);

    Temp = NpAllocatePagedPool (MaxLength, 'nFpN');
    if (Temp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Temp[0] = L'\\';
    RtlCopyMemory (&Temp[1], Name, NameLength);
    Temp[NameLength/sizeof(WCHAR) + 1] = L'\0';

    FullString.Buffer = Temp;
    FullString.Length = NameLength + sizeof(WCHAR);
    FullString.MaximumLength = MaxLength;

    //
    //  Find the prefix relative to the volume
    //

    Fcb = NpFindPrefix (&FullString,
                        CaseInsensitive,
                        RemainingPart);

    NpFreePool (Temp);
    //
    //  Now adjust the remaining part to take care of the relative
    //  volume prefix.
    //

    RemainingPart->Buffer = &String->Buffer[(String->Length -
                                             RemainingPart->Length) / sizeof(WCHAR)];

    DebugTrace(0, Dbg, "RemainingPart set to %Z\n", RemainingPart);

    *ppFcb = Fcb;
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\npfs\read.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Read.c

Abstract:

    This module implements the File Read routine for NPFS called by the
    dispatch driver.

Author:

    Gary Kimura     [GaryKi]    21-Aug-1990

Revision History:

--*/

#include "NpProcs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_READ)

#if DBG
ULONG NpFastReadTrue = 0;
ULONG NpFastReadFalse = 0;
ULONG NpSlowReadCalls = 0;
#endif

//
//  local procedure prototypes
//

BOOLEAN
NpCommonRead (
    IN PFILE_OBJECT FileObject,
    OUT PVOID ReadBuffer,
    IN ULONG ReadLength,
    OUT PIO_STATUS_BLOCK Iosb,
    IN PIRP Irp OPTIONAL,
    IN PLIST_ENTRY DeferredList
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NpCommonRead)
#pragma alloc_text(PAGE, NpFastRead)
#pragma alloc_text(PAGE, NpFsdRead)
#endif


NTSTATUS
NpFsdRead (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtReadFile API calls.

Arguments:

    NpfsDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    IO_STATUS_BLOCK Iosb;
    PIO_STACK_LOCATION IrpSp;
    LIST_ENTRY DeferredList;

    DebugTrace(+1, Dbg, "NpFsdRead\n", 0);
    DbgDoit( NpSlowReadCalls += 1 );

    PAGED_CODE();

    InitializeListHead (&DeferredList);

    IrpSp = IoGetCurrentIrpStackLocation (Irp);

    FsRtlEnterFileSystem ();

    NpAcquireSharedVcb ();

    (VOID) NpCommonRead (IrpSp->FileObject,
                         Irp->UserBuffer,
                         IrpSp->Parameters.Read.Length,
                         &Iosb,
                         Irp,
                         &DeferredList);

    NpReleaseVcb ();

    NpCompleteDeferredIrps (&DeferredList);

    FsRtlExitFileSystem ();

    if (Iosb.Status != STATUS_PENDING) {
        Irp->IoStatus.Information = Iosb.Information;
        NpCompleteRequest (Irp, Iosb.Status);
    }
    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "NpFsdRead -> %08lx\n", Iosb.Status );

    return Iosb.Status;
}


BOOLEAN
NpFastRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine does a fast read bypassing the usual file system
    entry routine (i.e., without the Irp).

Arguments:

    FileObject - Pointer to the file object being read.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    Wait - FALSE if caller may not block, TRUE otherwise

    LockKey - Supplies the Key used to use if the byte range being read is locked.

    Buffer - Pointer to output buffer to which data should be copied.

    IoStatus - Pointer to standard I/O status block to receive the status
               for the transfer.

Return Value:

    BOOLEAN - TRUE if the operation completed successfully and FALSE if the
        caller needs to take the long IRP based route.

--*/

{
    BOOLEAN Results = FALSE;
    LIST_ENTRY DeferredList;

    UNREFERENCED_PARAMETER (FileOffset);
    UNREFERENCED_PARAMETER (Wait);
    UNREFERENCED_PARAMETER (LockKey);
    UNREFERENCED_PARAMETER (DeviceObject);

    PAGED_CODE();

    InitializeListHead (&DeferredList);

    FsRtlEnterFileSystem ();

    NpAcquireSharedVcb ();

    Results =  NpCommonRead (FileObject,
                             Buffer,
                             Length,
                             IoStatus,
                             NULL,
                             &DeferredList);
#if DBG
    if (Results) {
        NpFastReadTrue += 1;
    } else {
        NpFastReadFalse += 1;
    }
#endif

    NpReleaseVcb ();

    NpCompleteDeferredIrps (&DeferredList);

    FsRtlExitFileSystem ();
    return Results;
}


//
//  Internal support routine
//

BOOLEAN
NpCommonRead (
    IN PFILE_OBJECT FileObject,
    OUT PVOID ReadBuffer,
    IN ULONG ReadLength,
    OUT PIO_STATUS_BLOCK Iosb,
    IN PIRP Irp OPTIONAL,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This is the common routine for reading a named pipe both via the fast
    path and with an Irp

Arguments:

    FileObject - Supplies the file object used in this operation

    ReadBuffer - Supplies the buffer where data is to be written

    ReadLength - Supplies the length of read buffer in bytes

    Iosb - Receives the final completion status of this operation

    Irp - Optionally supplies an Irp to be used in this operation

    DeferredList - List of IRP's to be completed after we drop the locks

Return Value:

    BOOLEAN - TRUE if the operation was successful and FALSE if the caller
        needs to take the longer Irp based route.

--*/

{
    NODE_TYPE_CODE NodeTypeCode;
    PCCB Ccb;
    PNONPAGED_CCB NonpagedCcb;
    NAMED_PIPE_END NamedPipeEnd;

    NAMED_PIPE_CONFIGURATION NamedPipeConfiguration;

    ULONG ReadRemaining;
    READ_MODE ReadMode;
    COMPLETION_MODE CompletionMode;
    PDATA_QUEUE ReadQueue;
    PEVENT_TABLE_ENTRY Event;
    BOOLEAN Status;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpCommonRead\n", 0);
    DebugTrace( 0, Dbg, "FileObject = %08lx\n", FileObject);
    DebugTrace( 0, Dbg, "ReadBuffer = %08lx\n", ReadBuffer);
    DebugTrace( 0, Dbg, "ReadLength = %08lx\n", ReadLength);
    DebugTrace( 0, Dbg, "Iosb       = %08lx\n", Iosb);
    DebugTrace( 0, Dbg, "Irp        = %08lx\n", Irp);

    Iosb->Information = 0;

    //
    //  Get the Ccb and figure out who we are, and make sure we're not
    //  disconnected
    //

    if ((NodeTypeCode = NpDecodeFileObject( FileObject,
                                            NULL,
                                            &Ccb,
                                            &NamedPipeEnd )) == NTC_UNDEFINED) {

        DebugTrace(0, Dbg, "Pipe is disconnected from us\n", 0);

        Iosb->Status = STATUS_PIPE_DISCONNECTED;

        return TRUE;
    }

    //
    //  Now we only will allow Read operations on the pipe and not a directory
    //  or the device
    //

    if (NodeTypeCode != NPFS_NTC_CCB) {

        DebugTrace(0, Dbg, "FileObject is not for a named pipe\n", 0);

        Iosb->Status = STATUS_INVALID_PARAMETER;

        return TRUE;
    }

    NpAcquireExclusiveCcb(Ccb);

    NonpagedCcb = Ccb->NonpagedCcb;

    try {
        //
        //  Check if the pipe is not in the connected state.
        //

        if ((Ccb->NamedPipeState == FILE_PIPE_DISCONNECTED_STATE) ||
            (Ccb->NamedPipeState == FILE_PIPE_LISTENING_STATE)) {

            DebugTrace(0, Dbg, "Pipe in disconnected or listening state\n", 0);

            if (Ccb->NamedPipeState == FILE_PIPE_DISCONNECTED_STATE) {

                Iosb->Status = STATUS_PIPE_DISCONNECTED;

            } else {

                Iosb->Status = STATUS_PIPE_LISTENING;
            }

            try_return(Status = TRUE);
        }

        ASSERT((Ccb->NamedPipeState == FILE_PIPE_CONNECTED_STATE) ||
               (Ccb->NamedPipeState == FILE_PIPE_CLOSING_STATE));

        //
        //  We only allow a read by the server on a non outbound only pipe
        //  and by the client on a non inbound only pipe
        //

        NamedPipeConfiguration = Ccb->Fcb->Specific.Fcb.NamedPipeConfiguration;

        if (((NamedPipeEnd == FILE_PIPE_SERVER_END) &&
             (NamedPipeConfiguration == FILE_PIPE_OUTBOUND))

                ||

            ((NamedPipeEnd == FILE_PIPE_CLIENT_END) &&
             (NamedPipeConfiguration == FILE_PIPE_INBOUND))) {

            DebugTrace(0, Dbg, "Trying to read to the wrong pipe configuration\n", 0);

            Iosb->Status = STATUS_INVALID_PARAMETER;

            try_return (Status = TRUE);
        }

        //
        //  Reference our input parameters to make things easier, and
        //  initialize our main variables that describe the Read command
        //

        ReadRemaining  = ReadLength;
        ReadMode       = Ccb->ReadCompletionMode[ NamedPipeEnd ].ReadMode;
        CompletionMode = Ccb->ReadCompletionMode[ NamedPipeEnd ].CompletionMode;

        //
        //  Now the data queue that we read from into and the event that we signal
        //  are based on the named pipe end.  The server read from the inbound
        //  queue and signals the client event.  The client does just the
        //  opposite.
        //

        if (NamedPipeEnd == FILE_PIPE_SERVER_END) {

            ReadQueue = &Ccb->DataQueue[ FILE_PIPE_INBOUND ];

            Event = NonpagedCcb->EventTableEntry[ FILE_PIPE_CLIENT_END ];

        } else {

            ReadQueue = &Ccb->DataQueue[ FILE_PIPE_OUTBOUND ];

            Event = NonpagedCcb->EventTableEntry[ FILE_PIPE_SERVER_END ];
        }

        DebugTrace(0, Dbg, "ReadBuffer     = %08lx\n", ReadBuffer);
        DebugTrace(0, Dbg, "ReadLength     = %08lx\n", ReadLength);
        DebugTrace(0, Dbg, "ReadMode       = %08lx\n", ReadMode);
        DebugTrace(0, Dbg, "CompletionMode = %08lx\n", CompletionMode);
        DebugTrace(0, Dbg, "ReadQueue      = %08lx\n", ReadQueue);
        DebugTrace(0, Dbg, "Event          = %08lx\n", Event);

        //
        //  if the read queue does not contain any write entries
        //  then we either need to enqueue this operation or
        //  fail immediately
        //

        if (!NpIsDataQueueWriters( ReadQueue )) {

            //
            //  Check if the other end of the pipe is closing, and if
            //  so then we complete it with end of file.
            //  Otherwise check to see if we should enqueue the irp
            //  or complete the operation and tell the user the pipe is empty.
            //

            if (Ccb->NamedPipeState == FILE_PIPE_CLOSING_STATE) {

                DebugTrace(0, Dbg, "Complete the irp with eof\n", 0);

                Iosb->Status = STATUS_PIPE_BROKEN;

            } else if (CompletionMode == FILE_PIPE_QUEUE_OPERATION) {

                if (!ARGUMENT_PRESENT(Irp)) {

                    DebugTrace(0, Dbg, "Need to supply Irp\n", 0);

                    try_return(Status = FALSE);
                }

                DebugTrace(0, Dbg, "Put the irp into the read queue\n", 0);

                Iosb->Status = NpAddDataQueueEntry( NamedPipeEnd,
                                                    Ccb,
                                                    ReadQueue,
                                                    ReadEntries,
                                                    Buffered,
                                                    ReadLength,
                                                    Irp,
                                                    NULL,
                                                    0 );

                if (!NT_SUCCESS (Iosb->Status)) {
                    try_return(Status = FALSE);
                }


            } else {

                DebugTrace(0, Dbg, "Complete the irp with pipe empty\n", 0);

                Iosb->Status = STATUS_PIPE_EMPTY;
            }

        } else {

            //
            //  otherwise there we have a read irp against a read queue
            //  that contains one or more write entries.
            //

            *Iosb = NpReadDataQueue( ReadQueue,
                                     FALSE,
                                     FALSE,
                                     ReadBuffer,
                                     ReadLength,
                                     ReadMode,
                                     Ccb,
                                     DeferredList );

            if (!NT_SUCCESS (Iosb->Status)) {
                try_return(Status = TRUE);
            }
        }

        Status = TRUE;

        //
        //  And because we've done something we need to signal the
        //  other ends event
        //

        NpSignalEventTableEntry( Event );


        try_exit: NOTHING;
    } finally {
        NpReleaseCcb(Ccb);
    }


    DebugTrace(-1, Dbg, "NpCommonRead -> TRUE\n", 0);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\npfs\npstruc.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    NpStruc.h

Abstract:

    This module defines the data structures that make up the major internal
    part of the Named Pipe file system.

Author:

    Gary Kimura     [GaryKi]    20-Aug-1990

Revision History:

--*/

#ifndef _NPSTRUC_
#define _NPSTRUC_


//
//  The VCB record is the top record in the Named Pipe file system in-memory
//  data structure.  This structure must be allocated from non-paged pool
//  and immediately follows (in memory) the Device object for the named
//  pipe.  Structurally the layout of the data structure is as follows
//
//    +------------+
//    |NPDO        |
//    |            |
//    +------------+
//    |Vcb         |
//    |            |
//    | EventTable |
//    | WaitQueue  |
//    |            |
//    +------------+
//        | ^
//        | |
//        | |
//        v |
//      +-------------+
//      |RootDcb      |
//      |             |<-+
//      +-------------+  |
//       |               |
//       v               |
//      +-------------+  |
//      |NonPaged     |  |
//      |             |  |
//      +-------------+  |
//          :            |
//          :            |
//          :            |
//          v            |
//        +----------------+    +-------------------+        +---------+
//        |Fcb             |    |Ccb                |        |ServerFO |
//        |                |<---|                   |        |         |
//        | MaxInstances   |    | ServerFO          |<-------|-       1|
//        | CurrentInst    |    | ClientFO          |        |         |
//        | DefaultTimeOut |...>|                   |<-+  +--|-        |
//        |                |    |                   |  |  |  |         |
//        +----------------+    +-------------------+  |  |  +---------+
//         |                     |                     |  |
//         v                     v                     |  |
//        +----------------+    +-------------------+  |  |  +---------+
//        |NonPagedFcb     |    |NonPagedCcb        |<-|--+  |ClientFO |
//        |                |<---|                   |  |     |         |
//        | PipeConfig     |    | PipeState         |  +-----|-       0|
//        | PipeType       |    | ReadMode[2]       |        |         |
//        |                |    | CompletionMode[2] |<-------|-        |
//        |                |    | CreatorProcess    |        |         |
//        |                |    | EventTabEnt[2]    |        +---------+
//        |                |    | DataQueue[2]      |
//        |                |    |                   |     (low bit determines
//        +----------------+    +-------------------+      server/client)
//
//
//  Where there is only one Vcb for the entire Named Pipe file system, and
//  it contains a single pointer to the root dcb for the file system.  Off
//  of the Dcb is a queue of Fcb's.  There is one Fcb for every named pipe.
//  There is one Ccb for every instance of a named pipe.  There are also
//  two additional ccb types for the vcb and the root dcb, and notify records
//  for the notify change operations.
//
//  A newly initialized named pipe file system only contains the Vcb and
//  the root dcb.  A new Fcb is created when a new named pipe is created
//  and then a ccb must also be created.  The file object for the creater
//  (i.e., server end) points to the ccb and indicates that it is the server
//  end.  When a user does an open on the named pipe its file object is
//  set to point to the same ccb and is also set to indicate that it is the
//  client end.  This is denoted by using the last bit of the FsContext pointer
//  if the bit is 1 it is a server end file object, if the bit is 0 it is
//  the client end.
//
//  A file object with a null pointer to the FsContext field is a closed or
//  disconnected pipe.
//
//  The Ccb also contains back pointer to the file objects that have it opened
//


//
//  The following types are used to help during development by keeping the
//  data types distinct.  The manifest contants that go in each is declared
//  in the ntioapi.h file
//

typedef ULONG NAMED_PIPE_TYPE;
typedef NAMED_PIPE_TYPE *PNAMED_PIPE_TYPE;

typedef ULONG READ_MODE;
typedef READ_MODE *PREAD_MODE;

typedef ULONG COMPLETION_MODE;
typedef COMPLETION_MODE *PCOMPLETION_MODE;

typedef ULONG NAMED_PIPE_CONFIGURATION;
typedef NAMED_PIPE_CONFIGURATION *PNAMED_PIPE_CONFIGURATION;

typedef ULONG NAMED_PIPE_STATE;
typedef NAMED_PIPE_STATE *PNAMED_PIPE_STATE;

typedef ULONG NAMED_PIPE_END;
typedef NAMED_PIPE_END *PNAMED_PIPE_END;


//
//  The following two types are used by the event table package.  The first
//  is the event table itself which is just a generic table.  It is protected
//  by the vcb resource, and the second structure is an event table entry.
//

typedef struct _EVENT_TABLE {

    RTL_GENERIC_TABLE Table;

} EVENT_TABLE;
typedef EVENT_TABLE *PEVENT_TABLE;

//
//  The event table is a generic table of event table entries.  Each Ccb
//  optionally contains a pointer to an event table entry for each direction.
//  The entries are part of the global event table defined off of the Vcb
//

typedef struct _EVENT_TABLE_ENTRY {

    //
    //  The first two fields are used as keys in the generic table's
    //  comparison routines.  The pipe end will either be FILE_PIPE_CLIENT_END
    //  or FILE_PIPE_SERVER_END.
    //

    struct _CCB *Ccb;
    NAMED_PIPE_END NamedPipeEnd;

    //
    //  The following three fields are used to identify the event entry
    //  to the named pipe user
    //

    HANDLE EventHandle;
    PVOID Event;
    ULONG KeyValue;
    PEPROCESS Process;

} EVENT_TABLE_ENTRY;
typedef EVENT_TABLE_ENTRY *PEVENT_TABLE_ENTRY;


//
//  Each Ccb has two data queues for holding the outstanding in-bound and
//  out-bound read/write requests.  The following type is used to determine
//  if the data queue contains read requests, write requests, or is empty.
//

typedef enum _QUEUE_STATE {

    ReadEntries,
    WriteEntries,
    Empty

} QUEUE_STATE;

//
//  The data queue is a structure that contains the queue state, quota
//  information, and the list head.  The quota information is used to
//  maintain pipe quota.
//

typedef struct _DATA_QUEUE {

    //
    //  This is the head of a queue of data entries (singly linked)
    //
    LIST_ENTRY Queue;

    //
    //  The current state of what is contained in this data queue,
    //  how many bytes of read/write data there are, and how many individual
    //  requests there are in the queue that contain data (includes
    //  close or flush requests).
    //

    QUEUE_STATE QueueState;
    ULONG BytesInQueue;
    ULONG EntriesInQueue;

    //
    //  The following two fields denote who much quota was reserved for
    //  this pipe direction and how much we've used up.  This is only
    //  the creator quota and not the user quota.
    //

    ULONG Quota;
    ULONG QuotaUsed;


    //
    //  The following field indicates how far we've already processed
    //  into the first entry in the data queue
    //

    ULONG NextByteOffset;

} DATA_QUEUE;
typedef DATA_QUEUE *PDATA_QUEUE;

//
//  Each data entry has a type field that tells us if the operation
//  for the entry is buffered, unbuffered, flush, or a close entry.
//

typedef enum _DATA_ENTRY_TYPE {

    Buffered,
    Unbuffered,
    Flush,
    Close

} DATA_ENTRY_TYPE;

//
//  The following type is used to denote where we got the memory for the
//  data entry and possibly the data buffer.  We either got the memory
//  from the pipe quota, the user quota, or it is part of the next IRP stack
//  location.
//

typedef enum _FROM {

    PipeQuota,
    UserQuota,
    InIrp

} FROM;

//
//  Each entry in the data queue is a data entry.  Processing an IRP
//  has the potential of creating and inserting a new data entry.  If the
//  memory for the entry is taken from the IRP we use the next stack
//  location.
//

typedef struct _DATA_ENTRY {

    //
    //  The following field is how we connect into the queue of data entries
    //

    LIST_ENTRY Queue;


    //
    //  The following field indicates if we still have an IRP associated
    //  with this data entry that need to be completed when the remove
    //  the data entry.  Note that if From is InIrp that this IRP field
    //  must not be null.
    //
    PIRP Irp;

    //
    //  The following field is used to point to the client context if dynamic
    //  impersonation is being used
    //

    PSECURITY_CLIENT_CONTEXT SecurityClientContext;

    //
    //  The following field describe the type of data entry
    //
    ULONG DataEntryType;

    //
    // Record the amount of quota charged for this request.
    //
    ULONG QuotaCharged;

    //
    //  The following field describes the size of the data
    //  buffer described by this entry.
    //
    ULONG DataSize;

    //
    // Start of the data buffer if it exists
    //
    UCHAR DataBuffer[];

} DATA_ENTRY;
typedef DATA_ENTRY *PDATA_ENTRY;


//
//  The following type is used by the wait queue package
//

typedef struct _WAIT_QUEUE {

    LIST_ENTRY Queue;

    KSPIN_LOCK SpinLock;

} WAIT_QUEUE;
typedef WAIT_QUEUE *PWAIT_QUEUE;


typedef struct _VCB {

    //
    //  The type of this record (must be NPFS_NTC_VCB)
    //

    NODE_TYPE_CODE NodeTypeCode;

    //
    //  A pointer to the root DCB for this volume
    //

    struct _FCB *RootDcb;

    //
    //  A count of the number of file objects that have opened the \NamedPipe
    //  object directly, and also a count of the number of file objects
    //  that have opened a name pipe or the root directory.
    //

    CLONG OpenCount;

    //
    //  A prefix table that is used for quick, prefix directed, lookup of
    //  FCBs/DCBs that are part of this volume
    //

    UNICODE_PREFIX_TABLE PrefixTable;

    //
    //  A resource variable to control access to the volume specific data
    //  structures
    //

    ERESOURCE Resource;

    //
    //  The following table is used to hold the named pipe events
    //

    EVENT_TABLE EventTable;

    //
    //  The following field is a queue of waiting IRPS of type WaitForNamedPipe
    //

    WAIT_QUEUE WaitQueue;


} VCB;
typedef VCB *PVCB;


//
//  The Named Pipe Device Object is an I/O system device object with
//  additional workqueue parameters appended to the end.  There is only
//  one of these records created for the entire system during system
//  initialization.
//

typedef struct _NPFS_DEVICE_OBJECT {

    DEVICE_OBJECT DeviceObject;

    //
    //  This is the file system specific volume control block.
    //

    VCB Vcb;

} NPFS_DEVICE_OBJECT;
typedef NPFS_DEVICE_OBJECT *PNPFS_DEVICE_OBJECT;


//
//  The Fcb/Dcb record corresponds to every opened named pipe and directory,
//  and to every directory on an opened path.
//
//  The structure is really divided into two parts.  FCB can be allocated
//  from paged pool which the NONPAGED_FCB must be allocated from non-paged
//  pool.
//

typedef struct _FCB {

    //
    //  Type of this record (must be NPFS_NTC_FCB, or
    //  NPFS_NTC_ROOT_DCB)
    //

    NODE_TYPE_CODE NodeTypeCode;

    //
    //  The links for the queue of all fcbs for a specific dcb off of
    //  Dcb.ParentDcbQueue.  For the root directory this queue is empty
    //

    LIST_ENTRY ParentDcbLinks;

    //
    //  A pointer to the Dcb that is the parent directory containing
    //  this fcb.  If this record itself is the root dcb then this field
    //  is null.
    //

    struct _FCB *ParentDcb;

    //
    //  A pointer to the Vcb containing this fcb
    //

    PVCB Vcb;

    //
    //  A count of the number of file objects that have opened
    //  this file/directory.  For a pipe this is also the number of instances
    //  created for the pipe.
    //

    CLONG OpenCount;

    //
    //  A count of the number of server end file objects that have opened
    //  this pipe.  ServerOpenCount is incremented when OpenCount is
    //  incremented (when the server end creates an instance), but is
    //  decremented when the server end handle is closed, where OpenCount
    //  isn't decremented until both side's handles are closed.  When
    //  ServerOpenCount is 0, a client's attempt to open a named pipe is
    //  met with STATUS_OBJECT_NAME_NOT_FOUND, not STATUS_PIPE_NOT_AVAILABLE,
    //  based on an assumption that since the server doesn't think it has
    //  any instances open, the pipe really doesn't exist anymore.  An
    //  example of when this distinction is useful is when the server
    //  process exits, but the client processes haven't closed their
    //  handles yet.
    //

    CLONG ServerOpenCount;

    //
    //  The following field points to the security descriptor for this named pipe
    //

    PSECURITY_DESCRIPTOR SecurityDescriptor;

    //
    //  The following union is cased off of the node type code for the fcb.
    //  There is a seperate case for the directory versus file fcbs.
    //

    union {

        //
        //  A Directory Control Block (Dcb)
        //

        struct {

            //
            //  A queue of the notify IRPs that will be completed when any
            //  change is made to a file in the directory.  Enqueued using
            //  the Tail.Overlay.ListEntry of the Irp.
            //

            LIST_ENTRY NotifyFullQueue;

            //
            //  A queue of the notify IRPs that will be completed only if a
            //  file is added, deleted, or renamed in the directory.  Enqueued
            //  using the Tail.Overlay.ListEntry of the Irp.
            //

            LIST_ENTRY NotifyPartialQueue;

            //
            //  A queue of all the fcbs/dcbs that are opened under this
            //  Dcb.
            //

            LIST_ENTRY ParentDcbQueue;

        } Dcb;

        //
        //  An File Control Block (Fcb)
        //

        struct {

            //
            //  This is the maximum number of instances we can have for the
            //  named pipe and the current number of instances is the open
            //  count for the fcb (note that the current number also
            //  correspondsto the number of Ccbs)
            //

            ULONG MaximumInstances;

            //
            //  The assigned pipe configuration (FILE_PIPE_INBOUND,
            //  FILE_PIPE_OUTBOUND, or FILE_PIPE_FULL_DUPLEX) and pipe
            //  type (FILE_PIPE_MESSAGE_TYPE or
            //  FILE_PIPE_BYTE_STREAM_TYPE).
            //

            NAMED_PIPE_CONFIGURATION NamedPipeConfiguration : 16;
            NAMED_PIPE_TYPE NamedPipeType : 16;

            //
            //  The following field is the default timeout assigned to the
            //  named pipe
            //

            LARGE_INTEGER DefaultTimeOut;

            //
            //  The Following field is a queue head for a list of ccbs
            //  that are opened under us
            //

            LIST_ENTRY CcbQueue;

        } Fcb;

    } Specific;

    //
    //  The following field is the fully qualified file name for this FCB/DCB
    //  starting from the root of the volume, and last file name in the
    //  fully qualified name.
    //

    UNICODE_STRING FullFileName;
    UNICODE_STRING LastFileName;

    //
    //  The following field contains a prefix table entry that is used when
    //  searching a volume for a name (or longest matching prefix)
    //

    UNICODE_PREFIX_TABLE_ENTRY PrefixTableEntry;


} FCB, DCB, ROOT_DCB;

typedef FCB *PFCB;
typedef DCB *PDCB;
typedef ROOT_DCB *PROOT_DCB;

typedef struct _CLIENT_INFO {
    PVOID ClientSession;
    USHORT ClientComputerNameLength;
    WCHAR ClientComputerBuffer[];
} CLIENT_INFO, *PCLIENT_INFO;


//
//  The Ccb record is allocated for every opened instance of a named pipe.
//  There are two parts to a ccb a paged part and a Nonpaged part.  Both
//  parts are pointed at by the FsContext and FsContext2 field of a file
//  object.
//

typedef struct _CCB {

    //
    //  Type of this record (must be NPFS_NTC_CCB).
    //

    NODE_TYPE_CODE NodeTypeCode;
    //
    //  Pipe state indicates the current state of the pipe
    //  (FILE_PIPE_DISCONNECTED_STATE, FILE_PIPE_LISTENING_STATE,
    //  FILE_PIPE_CONNECTED_STATE, or FILE_PIPE_CLOSING_STATE).
    //

    UCHAR NamedPipeState;

    //
    //  read mode (FILE_PIPE_MESSAGE_MODE or FILE_PIPE_BYTE_STREAM_MODE),
    //  and completion mode (FILE_PIPE_QUEUE_OPERATION or
    //  FILE_PIPE_COMPLETE_OPERATION) describe how to handle requests to the
    //  pipe.  Both of these fields are indexed by either FILE_PIPE_SERVER_END
    //  or FILE_PIPE_CLIENT_END.
    //
    struct {
        UCHAR ReadMode : 1;
        UCHAR CompletionMode : 1;
    } ReadCompletionMode[2];

    //
    // Stored client impersonation level
    //

    SECURITY_QUALITY_OF_SERVICE SecurityQos;

    //
    //  The following field is a list entry for the list of ccb that we
    //  are a member of
    //

    LIST_ENTRY CcbLinks;

    //
    //  A pointer to the paged Fcb, or Vcb that we are tied to
    //

    PFCB Fcb;

    //
    //  Back pointers to the server and client file objects that have us
    //  opened.  This is indexed by either FILE_PIPE_CLIENT_END or
    //  FILE_PIPE_SERVER_END.
    //

    PFILE_OBJECT FileObject[2];
    //
    //  The following fields contain the session and process IDs of the
    //  client side of the named pipe instance.  They are originally set
    //  to NULL (indicating local session) and the real client process
    //  ID but can be changed via FsCtl calls.
    //
    PVOID ClientProcess;
    PCLIENT_INFO ClientInfo;

    //
    //  A pointer to the Nonpaged part of the ccb
    //

    struct _NONPAGED_CCB *NonpagedCcb;


    //
    //  The following data queues are used to contain the buffered information
    //  for each direction in the pipe.  They array is indexed by
    //  PIPE_DIRECTION.
    //

    DATA_QUEUE DataQueue[2];

    //
    // Stored client security for impersonation
    //

    PSECURITY_CLIENT_CONTEXT SecurityClientContext;

    //
    //  A queue of waiting listening IRPs.  They are linked into the
    //  Tail.Overlay.ListEntry field in the Irp.
    //

    LIST_ENTRY ListeningQueue;

} CCB;
typedef CCB *PCCB;

typedef struct _NONPAGED_CCB {

    //
    //  Type of this record (must be NPFS_NTC_NONPAGED_CCB)
    //

    NODE_TYPE_CODE NodeTypeCode;

    //
    //  The following pointers denote the events we are to signal for the
    //  server and client ends of the named pipe.  The actual entry
    //  is stored in the event table, and referenced here for easy access.
    //  The client end is signaled if ever a read/write occurs to the client
    //  of the pipe, and likewise for the server end.  The array is
    //  indexed by either FILE_PIPE_SERVER_END or FILE_PIPE_CLIENT_END.
    //

    PEVENT_TABLE_ENTRY EventTableEntry[2];


    //
    // Resource for synchronizing access
    //
    ERESOURCE Resource;

} NONPAGED_CCB;
typedef NONPAGED_CCB *PNONPAGED_CCB;


//
//  The Root Dcb Ccb record is allocated for every opened instance of the
//  root dcb.  This record is pointed at by FsContext2.
//

typedef struct _ROOT_DCB_CCB {

    //
    //  Type of this record (must be NPFS_NTC_ROOT_DCB_CCB).
    //

    NODE_TYPE_CODE NodeTypeCode;
    //
    //  The following field is a count of the last index returned
    //  by query directory.
    //

    ULONG IndexOfLastCcbReturned;

    //
    //  The following string is used as a query template for directory
    //  query operations
    //

    PUNICODE_STRING QueryTemplate;

} ROOT_DCB_CCB;
typedef ROOT_DCB_CCB *PROOT_DCB_CCB;

#endif // _NPSTRUC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\npfs\readsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ReadSup.c

Abstract:

    This module implements the Read support routine.  This is a common
    read function that is called to do read, unbuffered read, peek, and
    transceive.

Author:

    Gary Kimura     [GaryKi]    20-Sep-1990

Revision History:

--*/

#include "NpProcs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_READSUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NpReadDataQueue)
#endif


IO_STATUS_BLOCK
NpReadDataQueue (
    IN PDATA_QUEUE ReadQueue,
    IN BOOLEAN PeekOperation,
    IN BOOLEAN ReadOverflowOperation,
    IN PUCHAR ReadBuffer,
    IN ULONG ReadLength,
    IN READ_MODE ReadMode,
    IN PCCB Ccb,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This procedure reads data from the read queue and fills up the
    read buffer.  It will also dequeue the queue or leave it alone based
    on an input parameter.

Arguments:

    ReadQueue - Provides the read queue to examine.  Its state must
        already be set to WriteEntries.

    PeekOperation - Indicates if the operation is to dequeue information
        off of the queue as it is being read or leave the queue alone.
        TRUE means to leave the queue alone.

    ReadOverflowOperation - Indicates if this is a read overflow operation.
        With read overflow we will not alter the named pipe if the data
        will overflow the read buffer.

    ReadBuffer - Supplies a buffer to receive the data

    ReadLength - Supplies the length, in bytes, of ReadBuffer.

    ReadMode - Indicates if the read operation is message mode or
        byte stream mode.

    NamedPipeEnd - Supplies the end of the named pipe doing the read

    Ccb - Supplies the ccb for the pipe

    DeferredList - List of IRP's to complete later after we drop locks

Return Value:

    IO_STATUS_BLOCK - Indicates the result of the operation.

--*/

{
    IO_STATUS_BLOCK Iosb= {0};

    PDATA_ENTRY DataEntry;

    ULONG ReadRemaining;
    ULONG AmountRead;

    PUCHAR WriteBuffer;
    ULONG WriteLength;
    ULONG WriteRemaining;
    BOOLEAN StartStalled = FALSE;

    ULONG AmountToCopy;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpReadDataQueue\n", 0);
    DebugTrace( 0, Dbg, "ReadQueue             = %08lx\n", ReadQueue);
    DebugTrace( 0, Dbg, "PeekOperation         = %08lx\n", PeekOperation);
    DebugTrace( 0, Dbg, "ReadOverflowOperation = %08lx\n", ReadOverflowOperation);
    DebugTrace( 0, Dbg, "ReadBuffer            = %08lx\n", ReadBuffer);
    DebugTrace( 0, Dbg, "ReadLength            = %08lx\n", ReadLength);
    DebugTrace( 0, Dbg, "ReadMode              = %08lx\n", ReadMode);
    DebugTrace( 0, Dbg, "Ccb                   = %08lx\n", Ccb);

    //
    //  If this is an overflow operation then we will force us to do peeks.
    //  Later when are determine that the opreation succeeded we will complete
    //  the write irp.
    //

    if (ReadOverflowOperation) {

        PeekOperation = TRUE;
    }

    //
    //  Now for every real data entry we loop until either we run out
    //  of data entries or until the read buffer is full
    //

    ReadRemaining = ReadLength;
    Iosb.Status = STATUS_SUCCESS;
    Iosb.Information = 0;
    AmountRead = 0;

    for (DataEntry = (PeekOperation ? NpGetNextDataQueueEntry( ReadQueue, NULL )
                                    : NpGetNextRealDataQueueEntry( ReadQueue, DeferredList ));

         (DataEntry != (PDATA_ENTRY) &ReadQueue->Queue) && (ReadRemaining > 0);

         DataEntry = (PeekOperation ? NpGetNextDataQueueEntry( ReadQueue, DataEntry )
                                    : NpGetNextRealDataQueueEntry( ReadQueue, DeferredList ))) {

        DebugTrace(0, Dbg, "Top of Loop\n", 0);
        DebugTrace(0, Dbg, "ReadRemaining  = %08lx\n", ReadRemaining);

        //
        //  If this is a peek operation then make sure we got a real
        //  data entry and not a close or flush
        //

        if (!PeekOperation ||
            (DataEntry->DataEntryType == Buffered) ||
            (DataEntry->DataEntryType == Unbuffered)) {

            //
            //  Calculate how much data is in this entry.  The write
            //  remaining is based on whether this is the first entry
            //  in the queue or a later data entry
            //

            if (DataEntry->DataEntryType == Unbuffered) {
                WriteBuffer = DataEntry->Irp->AssociatedIrp.SystemBuffer;
            } else {
                WriteBuffer = DataEntry->DataBuffer;
            }

            WriteLength = DataEntry->DataSize;
            WriteRemaining = WriteLength;

            if (DataEntry == NpGetNextDataQueueEntry( ReadQueue, NULL )) {

                WriteRemaining -= ReadQueue->NextByteOffset;
            }

            DebugTrace(0, Dbg, "WriteBuffer    = %08lx\n", WriteBuffer);
            DebugTrace(0, Dbg, "WriteLength    = %08lx\n", WriteLength);
            DebugTrace(0, Dbg, "WriteRemaining = %08lx\n", WriteRemaining);

            //
            //  copy data from the write buffer at write offset to the
            //  read buffer at read offset by the mininum of write
            //  remaining or read remaining
            //

            AmountToCopy = (WriteRemaining < ReadRemaining ? WriteRemaining
                                                           : ReadRemaining);

            try {

                RtlCopyMemory( &ReadBuffer[ ReadLength - ReadRemaining ],
                               &WriteBuffer[ WriteLength - WriteRemaining ],
                               AmountToCopy );

            } except(EXCEPTION_EXECUTE_HANDLER) {

                Iosb.Status = GetExceptionCode ();
                goto exit_1;
            }

            //
            //  Update the Read and Write remaining counts, the total
            //  amount we've read and the next byte offset field in the
            //  read queue
            //

            ReadRemaining  -= AmountToCopy;
            WriteRemaining -= AmountToCopy;
            AmountRead += AmountToCopy;

            if (!PeekOperation) {
                DataEntry->QuotaCharged -= AmountToCopy;
                ReadQueue->QuotaUsed -= AmountToCopy;
                ReadQueue->NextByteOffset += AmountToCopy;
                StartStalled = TRUE;
            }

            //
            //  Now update the security fields in the ccb
            //

            NpCopyClientContext( Ccb, DataEntry );

            //
            //  If the remaining write length is greater than zero
            //  then we've filled up the read buffer so we need to
            //  figure out if its an overflow error
            //

            if (WriteRemaining > 0 ||
                (ReadOverflowOperation && (AmountRead == 0))) {

                DebugTrace(0, Dbg, "Write remaining is > 0\n", 0);

                if (ReadMode == FILE_PIPE_MESSAGE_MODE) {

                    DebugTrace(0, Dbg, "Overflow message mode read\n", 0);

                    //
                    //  Set the status field and break out of the for-loop.
                    //

                    Iosb.Status = STATUS_BUFFER_OVERFLOW;
                    break;
                }

            } else {

                DebugTrace(0, Dbg, "Remaining Write is zero\n", 0);

                //
                //  The write entry is done so remove it from the read
                //  queue, if this is not a peek operation.  This might
                //  also have an Irp that needs to be completed
                //

                if (!PeekOperation || ReadOverflowOperation) {

                    PIRP WriteIrp;

                    //
                    //  For a read overflow operation we need to get the read data
                    //  queue entry and remove it.
                    //

                    if (ReadOverflowOperation) {
                        PDATA_ENTRY TempDataEntry;
                        TempDataEntry = NpGetNextRealDataQueueEntry( ReadQueue, DeferredList );
                        ASSERT(TempDataEntry == DataEntry);
                    }

                    if ((WriteIrp = NpRemoveDataQueueEntry( ReadQueue, TRUE,  DeferredList)) != NULL) {
                        WriteIrp->IoStatus.Information = WriteLength;
                        NpDeferredCompleteRequest( WriteIrp, STATUS_SUCCESS, DeferredList );
                    }
                }

                //
                //  And if we are doing message mode reads then we'll
                //  work on completing this irp without going back
                //  to the top of the loop
                //

                if (ReadMode == FILE_PIPE_MESSAGE_MODE) {

                    DebugTrace(0, Dbg, "Successful message mode read\n", 0);

                    //
                    //  Set the status field and break out of the for-loop.
                    //

                    Iosb.Status = STATUS_SUCCESS;
                    break;
                }

                ASSERTMSG("Srv cannot use read overflow on a byte stream pipe ", !ReadOverflowOperation);
            }
        }
    }

    DebugTrace(0, Dbg, "End of loop, AmountRead = %08lx\n", AmountRead);

    Iosb.Information = AmountRead;

exit_1:
    if (StartStalled) {
        NpCompleteStalledWrites (ReadQueue, DeferredList);
    }

    DebugTrace(-1, Dbg, "NpReadDataQueue -> Iosb.Status = %08lx\n", Iosb.Status);
    return Iosb;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\npfs\secursup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    SecurSup.c

Abstract:

    This module implements the Named Pipe Security support routines

Author:

    Gary Kimura     [GaryKi]    06-May-1991

Revision History:

--*/

#include "NpProcs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_SECURSUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NpCopyClientContext)
#pragma alloc_text(PAGE, NpImpersonateClientContext)
#pragma alloc_text(PAGE, NpInitializeSecurity)
#pragma alloc_text(PAGE, NpGetClientSecurityContext)
#pragma alloc_text(PAGE, NpUninitializeSecurity)
#pragma alloc_text(PAGE, NpFreeClientSecurityContext)
#endif


NTSTATUS
NpInitializeSecurity (
    IN PCCB Ccb,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    IN PETHREAD UserThread
    )

/*++

Routine Description:

    This routine initializes the security (impersonation) fields
    in the ccb.  It is called when the client end gets opened.

Arguments:

    Ccb - Supplies the ccb being initialized

    SecurityQos - Supplies the clients quality of service parameter

    UserThread - Supplise the client's user thread

Return Value:

    NTSTATUS - Returns the result of the operation

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpInitializeSecurity, Ccb = %08lx\n", Ccb);

    //
    //  Either copy the security qos parameter, if it is not null or
    //  create a dummy qos
    //

    if (SecurityQos != NULL) {

        RtlCopyMemory( &Ccb->SecurityQos,
                       SecurityQos,
                       sizeof(SECURITY_QUALITY_OF_SERVICE) );

    } else {

        Ccb->SecurityQos.Length              = sizeof(SECURITY_QUALITY_OF_SERVICE);
        Ccb->SecurityQos.ImpersonationLevel  = SecurityImpersonation;
        Ccb->SecurityQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
        Ccb->SecurityQos.EffectiveOnly       = TRUE;
    }

    //
    //  Because we might be asked to reinitialize the ccb we need
    //  to first check if the security client context is not null and if so then
    //  free its pool and zero out the context pointer so that if we raise out
    //  this time then a second time through the code we won't try and free the
    //  pool twice.
    //

    if (Ccb->SecurityClientContext != NULL) {

        SeDeleteClientSecurity( Ccb->SecurityClientContext );
        NpFreePool( Ccb->SecurityClientContext );
        Ccb->SecurityClientContext = NULL;
    }

    //
    //  If the tracking mode is static then we need to capture the
    //  client context now otherwise we set the client context field
    //  to null
    //

    if (Ccb->SecurityQos.ContextTrackingMode == SECURITY_STATIC_TRACKING) {

        //
        //  Allocate a client context record, and then initialize it
        //

        Ccb->SecurityClientContext = NpAllocatePagedPoolWithQuota (sizeof (SECURITY_CLIENT_CONTEXT), 'sFpN');
        if (Ccb->SecurityClientContext == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        } else {
            DebugTrace(0, Dbg, "Static tracking, ClientContext = %08lx\n", Ccb->SecurityClientContext);

            if (!NT_SUCCESS (Status = SeCreateClientSecurity (UserThread,
                                                              &Ccb->SecurityQos,
                                                              FALSE,
                                                              Ccb->SecurityClientContext))) {

                DebugTrace(0, Dbg, "Not successful at creating client security, %08lx\n", Status);

                NpFreePool (Ccb->SecurityClientContext);
                Ccb->SecurityClientContext = NULL;
            }
        }

    } else {

        DebugTrace(0, Dbg, "Dynamic tracking\n", 0);

        Ccb->SecurityClientContext = NULL;
        Status = STATUS_SUCCESS;
    }

    DebugTrace(-1, Dbg, "NpInitializeSecurity -> %08lx\n", Status);

    return Status;
}


VOID
NpUninitializeSecurity (
    IN PCCB Ccb
    )

/*++

Routine Description:

    This routine deletes the client context referenced by the ccb

Arguments:

    Ccb - Supplies the ccb being uninitialized

Return Value:

    None

--*/

{
    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpUninitializeSecurity, Ccb = %08lx\n", Ccb);

    //
    //  We only have work to do if the client context field is not null
    //  and then we need to delete the client context, and free the memory.
    //

    if (Ccb->SecurityClientContext != NULL) {

        DebugTrace(0, Dbg, "Delete client context, %08lx\n", Ccb->SecurityClientContext);

        SeDeleteClientSecurity( Ccb->SecurityClientContext );

        NpFreePool( Ccb->SecurityClientContext );
        Ccb->SecurityClientContext = NULL;
    }

    DebugTrace(-1, Dbg, "NpUninitializeSecurity -> VOID\n", 0);

    return;
}

VOID
NpFreeClientSecurityContext (
    IN PSECURITY_CLIENT_CONTEXT SecurityContext
    )
/*++

Routine Description:

    This routine frees previously captured security context.

Arguments:

    SecurityContext - Previously captured security context.

Return Value:

    None.

--*/
{
    if (SecurityContext != NULL) {
        SeDeleteClientSecurity (SecurityContext);
        NpFreePool (SecurityContext );
    }
}


NTSTATUS
NpGetClientSecurityContext (
    IN  NAMED_PIPE_END NamedPipeEnd,
    IN  PCCB Ccb,
    IN  PETHREAD UserThread,
    OUT PSECURITY_CLIENT_CONTEXT *ppSecurityContext
    )

/*++

Routine Description:

    This routine captures a new client context and stores it in the indicated
    data entry, but only if the tracking mode is dynamic and only for the
    client end of the named pipe.

Arguments:

    NamedPipeEnd - Indicates the client or server end of the named pipe.
        Only the client end does anything.

    Ccb - Supplies the ccb for this instance of the named pipe.

    DataEntry - Supplies the data entry to use to store the client context

    UserThread - Supplies the thread of the client

Return Value:

    NTSTATUS - Returns our success code.

--*/

{
    NTSTATUS Status;
    PSECURITY_CLIENT_CONTEXT SecurityContext;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpSetDataEntryClientContext, Ccb = %08lx\n", Ccb);

    //
    //  Only do the work if this is the client end and tracking is dynamic
    //

    if ((NamedPipeEnd == FILE_PIPE_CLIENT_END) &&
        (Ccb->SecurityQos.ContextTrackingMode == SECURITY_DYNAMIC_TRACKING)) {

        //
        //  Allocate a client context record, and then initialize it
        //

        SecurityContext = NpAllocatePagedPoolWithQuota (sizeof(SECURITY_CLIENT_CONTEXT), 'sFpN');
        if (SecurityContext == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        DebugTrace(0, Dbg, "Client End, Dynamic Tracking, ClientContext = %08lx\n", DataEntry->SecurityClientContext);

        if (!NT_SUCCESS (Status = SeCreateClientSecurity (UserThread,
                                                          &Ccb->SecurityQos,
                                                          FALSE,
                                                          SecurityContext))) {

            DebugTrace(0, Dbg, "Not successful at creating client security, %08lx\n", Status);

            NpFreePool (SecurityContext);
            SecurityContext = NULL;
        }

    } else {

        DebugTrace(0, Dbg, "Static Tracking or Not Client End\n", 0);

        SecurityContext = NULL;
        Status = STATUS_SUCCESS;
    }

    DebugTrace(-1, Dbg, "NpSetDataEntryClientContext -> %08lx\n", Status);

    *ppSecurityContext = SecurityContext;
    return Status;
}


VOID
NpCopyClientContext (
    IN PCCB Ccb,
    IN PDATA_ENTRY DataEntry
    )

/*++

Routine Description:

    This routine copies the client context stored in the data entry into
    the ccb, but only for dynamic tracking.

Arguments:

    Ccb - Supplies the ccb to update.

    DataEntry - Supplies the DataEntry to copy from.

Return Value:

--*/

{
    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpCopyClientContext, Ccb = %08lx\n", Ccb);

    //
    //  Only do the copy if the data entries client context field is not null
    //  which means that we are doing dynamic tracking.  Note we will
    //  not be called with a server write data entry that has a non null
    //  client context.
    //

    if (DataEntry->SecurityClientContext != NULL) {

        DebugTrace(0, Dbg, "have something to copy %08lx\n", DataEntry->SecurityClientContext);

        //
        //  First check if we need to delete and deallocate the client
        //  context in the nonpaged ccb
        //

        if (Ccb->SecurityClientContext != NULL) {

            DebugTrace(0, Dbg, "Remove current client context %08lx\n", Ccb->SecurityClientContext);

            SeDeleteClientSecurity (Ccb->SecurityClientContext);

            NpFreePool (Ccb->SecurityClientContext);
        }

        //
        //  Now copy over the reference to the client context, and zero
        //  out the reference in the data entry.
        //

        Ccb->SecurityClientContext = DataEntry->SecurityClientContext;
        DataEntry->SecurityClientContext = NULL;
    }

    DebugTrace(-1, Dbg, "NpCopyClientContext -> VOID\n", 0 );

    return;
}


NTSTATUS
NpImpersonateClientContext (
    IN PCCB Ccb
    )

/*++

Routine Description:

    This routine impersonates the current client context stored in the
    ccb

Arguments:

    Ccb - Supplies the ccb for the named pipe

Return Value:

    NTSTATUS - returns our status code.

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpImpersonateClientContext, Ccb = %08lx\n", Ccb);

    if (Ccb->SecurityClientContext == NULL) {

        DebugTrace(0, Dbg, "Cannot impersonate\n", 0);

        Status = STATUS_CANNOT_IMPERSONATE;

    } else {

        Status = SeImpersonateClientEx( Ccb->SecurityClientContext, NULL );

    }

    DebugTrace(-1, Dbg, "NpImpersonateClientContext -> %08lx\n", Status);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\npfs\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=ntos
MINORCOMP=npfs

TARGETNAME=npfs
TARGETTYPE=DRIVER

INCLUDES=..;..\..\inc;$(PROJECT_ROOT)\ntos\inc


MSC_WARNING_LEVEL=/W3 /WX

C_DEFINES=$(C_DEFINES) -D_NTDRIVER_

SOURCES=           \
        ..\AliasSup.c \
        ..\Cleanup.c  \
        ..\Close.c    \
        ..\Create.c   \
        ..\CreateNp.c \
        ..\DataSup.c  \
        ..\Dir.c      \
        ..\DumpSup.c  \
        ..\EventSup.c \
        ..\FileInfo.c \
        ..\FilObSup.c \
        ..\FlushBuf.c \
        ..\FsCtrl.c   \
        ..\NpData.c   \
        ..\Npfs.rc    \
        ..\NpInit.c   \
        ..\PrefxSup.c \
        ..\Read.c     \
        ..\ReadSup.c  \
        ..\SecurSup.c \
        ..\SeInfo.c   \
        ..\StateSup.c \
        ..\StrucSup.c \
        ..\VolInfo.c  \
        ..\WaitSup.c  \
        ..\Write.c    \
        ..\WriteSup.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\npfs\seinfo.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    SeInfo.c

Abstract:

    This module implements the Security Info routines for NPFS called by the
    dispatch driver.  There are two entry points NpFsdQueryInformation
    and NpFsdSetInformation.

Author:

    Gary Kimura     [GaryKi]    21-Aug-1990

Revision History:

--*/

#include "NpProcs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_SEINFO)

//
//  local procedure prototypes
//

NTSTATUS
NpCommonQuerySecurityInfo (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );


NTSTATUS
NpCommonSetSecurityInfo (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NpCommonQuerySecurityInfo)
#pragma alloc_text(PAGE, NpCommonSetSecurityInfo)
#pragma alloc_text(PAGE, NpFsdQuerySecurityInfo)
#pragma alloc_text(PAGE, NpFsdSetSecurityInfo)
#endif


NTSTATUS
NpFsdQuerySecurityInfo (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the Query Security Information API
    calls.

Arguments:

    NpfsDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpFsdQuerySecurityInfo\n", 0);

    //
    //  Call the common Query Information routine.
    //

    FsRtlEnterFileSystem();

    NpAcquireExclusiveVcb();

    Status = NpCommonQuerySecurityInfo( NpfsDeviceObject, Irp );

    NpReleaseVcb();

    FsRtlExitFileSystem();

    if (Status != STATUS_PENDING) {
        NpCompleteRequest (Irp, Status);
    }

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "NpFsdQuerySecurityInfo -> %08lx\n", Status );

    return Status;
}


NTSTATUS
NpFsdSetSecurityInfo (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the Set Security Information API
    calls.

Arguments:

    NpfsDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpFsdSetSecurityInfo\n", 0);

    //
    //  Call the common Set Information routine.
    //

    FsRtlEnterFileSystem();

    NpAcquireExclusiveVcb();

    Status = NpCommonSetSecurityInfo( NpfsDeviceObject, Irp );

    NpReleaseVcb();

    FsRtlExitFileSystem();

    if (Status != STATUS_PENDING) {
        NpCompleteRequest (Irp, Status);
    }
    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "NpFsdSetSecurityInfo -> %08lx\n", Status );

    return Status;
}


//
//  Internal support routine
//

NTSTATUS
NpCommonQuerySecurityInfo (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for querying security information.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp;
    NTSTATUS Status;

    NODE_TYPE_CODE NodeTypeCode;
    PFCB Fcb;
    PCCB Ccb;
    NAMED_PIPE_END NamedPipeEnd;

    PAGED_CODE();

    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NpCommonQuerySecurityInfo...\n", 0);
    DebugTrace( 0, Dbg, " Irp                   = %08lx\n", Irp);
    DebugTrace( 0, Dbg, " ->SecurityInformation = %08lx\n", IrpSp->Parameters.QuerySecurity.SecurityInformation);
    DebugTrace( 0, Dbg, " ->Length              = %08lx\n", IrpSp->Parameters.QuerySecurity.Length);
    DebugTrace( 0, Dbg, " ->UserBuffer          = %08lx\n", Irp->UserBuffer);

    //
    //  Get the ccb and figure out who we are, and make sure we're not
    //  disconnected.
    //

    if ((NodeTypeCode = NpDecodeFileObject( IrpSp->FileObject,
                                            &Fcb,
                                            &Ccb,
                                            &NamedPipeEnd )) == NTC_UNDEFINED) {

        DebugTrace(0, Dbg, "Pipe is disconnected from us\n", 0);

        Status = STATUS_PIPE_DISCONNECTED;

        DebugTrace(-1, Dbg, "NpCommonQueryInformation -> %08lx\n", Status );
        return Status;
    }

    //
    //  Now we only will allow write operations on the pipe and not a directory
    //  or the device
    //

    if (NodeTypeCode != NPFS_NTC_CCB) {

        DebugTrace(0, Dbg, "FileObject is not for a named pipe\n", 0);

        Status = STATUS_INVALID_PARAMETER;

        DebugTrace(-1, Dbg, "NpCommonQueryInformation -> %08lx\n", Status );
        return Status;
    }

    //
    //  Call the security routine to do the actual query
    //

    Status = SeQuerySecurityDescriptorInfo( &IrpSp->Parameters.QuerySecurity.SecurityInformation,
                                            Irp->UserBuffer,
                                            &IrpSp->Parameters.QuerySecurity.Length,
                                            &Fcb->SecurityDescriptor );

    if (  Status == STATUS_BUFFER_TOO_SMALL ) {

        Irp->IoStatus.Information = IrpSp->Parameters.QuerySecurity.Length;

        Status = STATUS_BUFFER_OVERFLOW;
    }



    DebugTrace(-1, Dbg, "NpCommonQuerySecurityInfo -> %08lx\n", Status );
    return Status;
}


//
//  Internal support routine
//

NTSTATUS
NpCommonSetSecurityInfo (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for Setting security information.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp;
    NTSTATUS Status;

    NODE_TYPE_CODE NodeTypeCode;
    PFCB Fcb;
    PCCB Ccb;
    NAMED_PIPE_END NamedPipeEnd;

    PSECURITY_DESCRIPTOR OldSecurityDescriptor, NewSecurityDescriptor, CachedSecurityDescriptor;

    PAGED_CODE();

    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NpCommonSetSecurityInfo...\n", 0);
    DebugTrace( 0, Dbg, " Irp                   = %08lx\n", Irp);
    DebugTrace( 0, Dbg, " ->SecurityInformation = %08lx\n", IrpSp->Parameters.SetSecurity.SecurityInformation);
    DebugTrace( 0, Dbg, " ->SecurityDescriptor  = %08lx\n", IrpSp->Parameters.SetSecurity.SecurityDescriptor);

    //
    //  Get the ccb and figure out who we are, and make sure we're not
    //  disconnected.
    //

    if ((NodeTypeCode = NpDecodeFileObject( IrpSp->FileObject,
                                            &Fcb,
                                            &Ccb,
                                            &NamedPipeEnd )) == NTC_UNDEFINED) {

        DebugTrace(0, Dbg, "Pipe is disconnected from us\n", 0);

        Status = STATUS_PIPE_DISCONNECTED;

        DebugTrace(-1, Dbg, "NpCommonQueryInformation -> %08lx\n", Status );
        return Status;
    }

    //
    //  Now we only will allow write operations on the pipe and not a directory
    //  or the device
    //

    if (NodeTypeCode != NPFS_NTC_CCB) {

        DebugTrace(0, Dbg, "FileObject is not for a named pipe\n", 0);

        Status = STATUS_INVALID_PARAMETER;

        DebugTrace(-1, Dbg, "NpCommonQueryInformation -> %08lx\n", Status );
        return Status;
    }

    //
    //  Call the security routine to do the actual set
    //

    NewSecurityDescriptor = OldSecurityDescriptor = Fcb->SecurityDescriptor;

    Status = SeSetSecurityDescriptorInfo( NULL,
                                          &IrpSp->Parameters.SetSecurity.SecurityInformation,
                                          IrpSp->Parameters.SetSecurity.SecurityDescriptor,
                                          &NewSecurityDescriptor,
                                          PagedPool,
                                          IoGetFileObjectGenericMapping() );

    if (NT_SUCCESS(Status)) {
        Status = ObLogSecurityDescriptor (NewSecurityDescriptor,
                                          &CachedSecurityDescriptor,
                                          1);
        NpFreePool (NewSecurityDescriptor);
        if (NT_SUCCESS(Status)) {
            Fcb->SecurityDescriptor = CachedSecurityDescriptor;
            ObDereferenceSecurityDescriptor( OldSecurityDescriptor, 1 );
        }
        
    }

    DebugTrace(-1, Dbg, "NpCommonSetSecurityInfo -> %08lx\n", Status );
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\npfs\resrcsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ResrcSup.c

Abstract:

    This module implements the NamedPipe Resource acquisition routines

Author:

    Gary Kimura     [GaryKi]    22-Mar-1990

Revision History:

--*/

#include "NpProcs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_RESRCSUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NpAcquireExclusiveCcb)
#pragma alloc_text(PAGE, NpAcquireExclusiveVcb)
#pragma alloc_text(PAGE, NpAcquireSharedCcb)
#pragma alloc_text(PAGE, NpAcquireSharedVcb)
#pragma alloc_text(PAGE, NpReleaseCcb)
#pragma alloc_text(PAGE, NpReleaseVcb)
#endif


VOID
NpAcquireExclusiveVcb (
    )

/*++

Routine Description:

    This routine acquires exclusive access to the Vcb

Arguments:

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpAcquireExclusiveVcb\n", 0);

    ExAcquireResourceExclusive( &(NpVcb->Resource), TRUE );

    DebugTrace(-1, Dbg, "NpAcquireExclusiveVcb -> (VOID)\n", 0);

    return;
}


VOID
NpAcquireSharedVcb (
    )

/*++

Routine Description:

    This routine acquires shared access to the Vcb

Arguments:

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpAcquireSharedVcb\n", 0);

    ExAcquireResourceShared( &(NpVcb->Resource), TRUE );

    DebugTrace(-1, Dbg, "NpAcquireSharedVcb -> (VOID)\n", 0);

    return;
}


VOID
NpAcquireExclusiveCcb (
    IN PNONPAGED_CCB NonpagedCcb
    )

/*++

Routine Description:

    This routine acquires exclusive access to the Ccb by first getting
    shared access to the Fcb.

Arguments:

    NonpagedCcb - Supplies the Ccb to acquire

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpAcquireExclusiveCcb, NonpagedCcb = %08lx\n", NonpagedCcb);

    (VOID)ExAcquireResourceShared( &(NpVcb->Resource), TRUE );

    (VOID)ExAcquireResourceExclusive( &(NonpagedCcb->Resource), TRUE );

    DebugTrace(-1, Dbg, "NpAcquireExclusiveCcb -> (VOID)\n", 0);

    return;
}


VOID
NpAcquireSharedCcb (
    IN PNONPAGED_CCB NonpagedCcb
    )

/*++

Routine Description:

    This routine acquires shared access to the Ccb by first getting
    shared access to the Fcb.

Arguments:

    NonpagedCcb - Supplies the Ccb to acquire

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpAcquireSharedCcb, NonpagedCcb = %08lx\n", NonpagedCcb);

    (VOID)ExAcquireResourceShared( &(NpVcb->Resource), TRUE );

    (VOID)ExAcquireResourceShared( &(NonpagedCcb->Resource), TRUE );

    DebugTrace(-1, Dbg, "NpAcquireSharedCcb -> (VOID)\n", 0);

    return;
}


VOID
NpReleaseVcb (
    )

/*++

Routine Description:

    This routine releases access to the Vcb

Arguments:

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace(0, Dbg, "NpReleaseVcb\n", 0);

    ExReleaseResource( &(NpVcb->Resource) );

    return;
}


VOID
NpReleaseCcb (
    IN PNONPAGED_CCB NonpagedCcb
    )

/*++

Routine Description:

    This routine releases access to the Ccb

Arguments:

    Ccb - Supplies the Ccb being released

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace(0, Dbg, "NpReleaseCcb, NonpagedCcb = %08lx\n", NonpagedCcb);

    ExReleaseResource( &(NonpagedCcb->Resource) );
    ExReleaseResource( &(NpVcb->Resource) );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\npfs\strucsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    StrucSup.c

Abstract:

    This module implements the Named Pipe in-memory data structure manipulation
    routines

Author:

    Gary Kimura     [GaryKi]    22-Jan-1990

Revision History:

--*/

#include "NpProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (NPFS_BUG_CHECK_STRUCSUP)

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_STRUCSUP)


WCHAR NpRootDCBName[] = L"\\";

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, NpInitializeVcb)
#pragma alloc_text(INIT, NpCreateRootDcb)
#pragma alloc_text(PAGE, NpCreateCcb)
#pragma alloc_text(PAGE, NpCreateFcb)
#pragma alloc_text(PAGE, NpCreateRootDcbCcb)
#pragma alloc_text(PAGE, NpDeleteCcb)
#pragma alloc_text(PAGE, NpDeleteFcb)
#pragma alloc_text(PAGE, NpDeleteRootDcb)
#pragma alloc_text(PAGE, NpDeleteVcb)
#endif


VOID
NpInitializeVcb (
    VOID
    )

/*++

Routine Description:

    This routine initializes new Vcb record. The Vcb record "hangs" off the
    end of the Npfs device object and must be allocated by our caller.

Arguments:

    None.

Return Value:

    None.

--*/

{

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpInitializeVcb, Vcb = %08lx\n", NpVcb);

    //
    //  We start by first zeroing out all of the VCB, this will guarantee
    //  that any stale data is wiped clean
    //

    RtlZeroMemory( NpVcb, sizeof(VCB) );

    //
    //  Set the proper node type code and node byte size
    //

    NpVcb->NodeTypeCode = NPFS_NTC_VCB;

    //
    //  Initialize the Prefix table
    //

    RtlInitializeUnicodePrefix( &NpVcb->PrefixTable );

    //
    //  Initialize the resource variable for the Vcb
    //

    ExInitializeResourceLite( &NpVcb->Resource );

    //
    //  Initialize the event table
    //

    NpInitializeEventTable( &NpVcb->EventTable );

    //
    //  Initialize the wait queue
    //

    NpInitializeWaitQueue( &NpVcb->WaitQueue );


    //
    //  return and tell the caller
    //

    return;
}


VOID
NpDeleteVcb (
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This routine removes the Vcb record from our in-memory data
    structures.  It also will remove all associated underlings
    (i.e., FCB records).

Arguments:

    DeferredList - List of deferred IRPs to complete once we release locks

Return Value:

    None

--*/

{
    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpDeleteVcb, Vcb = %08lx\n", NpVcb);

    //
    //  Make sure the open count is zero, and the open underling count
    //  is also zero.
    //

    if (NpVcb->OpenCount != 0) {

        DebugDump("Error deleting Vcb\n", 0, NpVcb);
        NpBugCheck( 0, 0, 0 );
    }

    //
    //  Remove the Root Dcb
    //

    if (NpVcb->RootDcb != NULL) {

        NpDeleteRootDcb( NpVcb->RootDcb, DeferredList );
    }

    //
    //  Uninitialize the resource variable for the Vcb
    //

    ExDeleteResourceLite( &NpVcb->Resource );

    //
    //  Uninitialize the event table
    //

    NpUninitializeEventTable( &NpVcb->EventTable );

    //
    //  Uninitialize the wait queue
    //

    NpUninitializeWaitQueue( &NpVcb->WaitQueue );

    //
    //  And zero out the Vcb, this will help ensure that any stale data is
    //  wiped clean
    //

    RtlZeroMemory( NpVcb, sizeof(VCB) );

    //
    //  return and tell the caller
    //

    DebugTrace(-1, Dbg, "NpDeleteVcb -> VOID\n", 0);

    return;
}


NTSTATUS
NpCreateRootDcb (
    VOID
    )

/*++

Routine Description:

    This routine allocates, initializes, and inserts a new root DCB record
    into the in memory data structure.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpCreateRootDcb, Vcb = %08lx\n", NpVcb);

    //
    //  Make sure we don't already have a root dcb for this vcb
    //

    if (NpVcb->RootDcb != NULL) {

        DebugDump("Error trying to create multiple root dcbs\n", 0, NpVcb);
        NpBugCheck( 0, 0, 0 );
    }

    //
    //  Allocate a new DCB and zero it out
    //

    NpVcb->RootDcb = NpAllocatePagedPool ( sizeof(DCB), 'DFpN' );

    if (NpVcb->RootDcb == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory( NpVcb->RootDcb, sizeof(DCB));

    //
    //  Set the proper node type code and node byte size
    //

    NpVcb->RootDcb->NodeTypeCode = NPFS_NTC_ROOT_DCB;

    //
    //  The root Dcb has an empty parent dcb links field
    //

    InitializeListHead( &NpVcb->RootDcb->ParentDcbLinks );

    //
    //  initialize the notify queues, and the parent dcb queue.
    //

    InitializeListHead( &NpVcb->RootDcb->Specific.Dcb.NotifyFullQueue );
    InitializeListHead( &NpVcb->RootDcb->Specific.Dcb.NotifyPartialQueue );
    InitializeListHead( &NpVcb->RootDcb->Specific.Dcb.ParentDcbQueue );

    NpVcb->RootDcb->FullFileName.Buffer = NpRootDCBName;
    NpVcb->RootDcb->FullFileName.Length = sizeof (NpRootDCBName) - sizeof (UNICODE_NULL);
    NpVcb->RootDcb->FullFileName.MaximumLength = sizeof (NpRootDCBName);

    //
    // Last file name is the same as file name.
    //
    NpVcb->RootDcb->LastFileName = NpVcb->RootDcb->FullFileName;

    //
    //  Insert this dcb into the prefix table
    //

    if (!RtlInsertUnicodePrefix( &NpVcb->PrefixTable,
                                 &NpVcb->RootDcb->FullFileName,
                                 &NpVcb->RootDcb->PrefixTableEntry )) {

        DebugDump("Error trying to insert root dcb into prefix table\n", 0, NpVcb);
        NpBugCheck( 0, 0, 0 );
    }

    DebugTrace(-1, Dbg, "NpCreateRootDcb -> %8lx\n", NpVcb->RootDcb);

    return STATUS_SUCCESS;
}


VOID
NpDeleteRootDcb (
    IN PROOT_DCB RootDcb,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This routine deallocates and removes the ROOT DCB record
    from our in-memory data structures.  It also will remove all
    associated underlings (i.e., Notify queues and child FCB records).

Arguments:

    RootDcb - Supplies the ROOT DCB to be removed

    DeferredList - List of IRPs to complete after we release locks

Return Value:

    None

--*/

{
    PLIST_ENTRY Links;
    PIRP Irp;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpDeleteRootDcb, RootDcb = %08lx\n", RootDcb);

    //
    //  We can only delete this record if the open count is zero.
    //

    if (RootDcb->OpenCount != 0) {

        DebugDump("Error deleting RootDcb, Still Open\n", 0, RootDcb);
        NpBugCheck( 0, 0, 0 );
    }

    //
    //  Remove every Notify Irp from the two notify queues
    //

    while (!IsListEmpty(&RootDcb->Specific.Dcb.NotifyFullQueue)) {

        Links = RemoveHeadList( &RootDcb->Specific.Dcb.NotifyFullQueue );

        Irp = CONTAINING_RECORD( Links, IRP, Tail.Overlay.ListEntry );

        NpDeferredCompleteRequest( Irp, STATUS_FILE_FORCED_CLOSED, DeferredList );
    }

    while (!IsListEmpty(&RootDcb->Specific.Dcb.NotifyPartialQueue)) {

        Links = RemoveHeadList( &RootDcb->Specific.Dcb.NotifyPartialQueue );

        Irp = CONTAINING_RECORD( Links, IRP, Tail.Overlay.ListEntry );

        NpDeferredCompleteRequest( Irp, STATUS_FILE_FORCED_CLOSED, DeferredList );
    }

    //
    //  We can only be removed if the no other FCB have us referenced
    //  as a their parent DCB.
    //

    if (!IsListEmpty(&RootDcb->Specific.Dcb.ParentDcbQueue)) {

        DebugDump("Error deleting RootDcb\n", 0, RootDcb);
        NpBugCheck( 0, 0, 0 );
    }

    //
    //  Remove the entry from the prefix table, and then remove the full
    //  file name
    //

    RtlRemoveUnicodePrefix( &NpVcb->PrefixTable, &RootDcb->PrefixTableEntry );

    //
    //  Finally deallocate the Dcb record
    //

    NpFreePool( RootDcb );

    //
    //  and return to our caller
    //

    DebugTrace(-1, Dbg, "NpDeleteRootDcb -> VOID\n", 0);

    return;
}


NTSTATUS
NpCreateFcb (
    IN PDCB ParentDcb,
    IN PUNICODE_STRING FileName,
    IN ULONG MaximumInstances,
    IN LARGE_INTEGER DefaultTimeOut,
    IN NAMED_PIPE_CONFIGURATION NamedPipeConfiguration,
    IN NAMED_PIPE_TYPE NamedPipeType,
    OUT PFCB *ppFcb
    )

/*++

Routine Description:

    This routine allocates, initializes, and inserts a new Fcb record into
    the in memory data structures.

Arguments:

    ParentDcb - Supplies the parent dcb that the new FCB is under.

    FileName - Supplies the file name of the file relative to the directory
        it's in (e.g., the file \config.sys is called "CONFIG.SYS" without
        the preceding backslash).

    MaximumInstances - Supplies the maximum number of pipe instances

    DefaultTimeOut - Supplies the default wait time out value

    NamedPipeConfiguration - Supplies our initial pipe configuration

    NamedPipeType - Supplies our initial pipe type

Return Value:

    PFCB - Returns a pointer to the newly allocated FCB

--*/

{
    PFCB Fcb;
    PWCH Name;
    USHORT Length;
    USHORT MaximumLength;
    BOOLEAN AddBackSlash = FALSE;
    ULONG i;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpCreateFcb\n", 0);

    Length = FileName->Length;
    MaximumLength = Length + sizeof (WCHAR);
    if (Length < sizeof (WCHAR) || MaximumLength < Length) {
        return STATUS_INVALID_PARAMETER;
    }
    if (FileName->Buffer[0] != '\\') {
        AddBackSlash = TRUE;
        MaximumLength += sizeof (WCHAR);
        if (MaximumLength < sizeof (WCHAR)) {
            return STATUS_INVALID_PARAMETER;
        }
    }

    //
    //  Allocate a new FCB record and zero it out
    //

    Fcb = NpAllocatePagedPoolWithQuota( sizeof(FCB), 'FfpN' );
    if (Fcb == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory( Fcb, sizeof(FCB) );

    //
    //  Set the proper node type code and node byte size
    //

    Fcb->NodeTypeCode = NPFS_NTC_FCB;

    //
    //  Point back to our parent dcb
    //

    Fcb->ParentDcb = ParentDcb;

    //
    //  Set our maximum instances, default timeout, and initialize our
    //  ccb queue
    //

    Fcb->Specific.Fcb.MaximumInstances = MaximumInstances;
    Fcb->Specific.Fcb.DefaultTimeOut = DefaultTimeOut;
    InitializeListHead( &Fcb->Specific.Fcb.CcbQueue );

    //
    //  set the file name.  We need to do this from nonpaged pool because
    //  cancel waiters works while holding a spinlock and uses the fcb name
    //


    Name = NpAllocateNonPagedPoolWithQuota( MaximumLength, 'nFpN' );
    if (Name == NULL) {
        NpFreePool (Fcb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  Insert this fcb into our parent dcb's queue
    //

    InsertTailList( &ParentDcb->Specific.Dcb.ParentDcbQueue,
                    &Fcb->ParentDcbLinks );

    i = 0;
    if (AddBackSlash == TRUE) {
        i++;
        Name[0] = '\\';
    }
    RtlCopyMemory( &Name[i], FileName->Buffer, Length );
    Name[ i + Length / sizeof(WCHAR) ] = L'\0';

    Fcb->FullFileName.Length = MaximumLength - sizeof (WCHAR);
    Fcb->FullFileName.MaximumLength = MaximumLength ;
    Fcb->FullFileName.Buffer = Name;

    Fcb->LastFileName.Length = MaximumLength - 2*sizeof (WCHAR);
    Fcb->LastFileName.MaximumLength = MaximumLength - sizeof (WCHAR);
    Fcb->LastFileName.Buffer = &Name[1];

    //
    //  Insert this Fcb into the prefix table
    //

    if (!RtlInsertUnicodePrefix( &NpVcb->PrefixTable,
                                 &Fcb->FullFileName,
                                 &Fcb->PrefixTableEntry )) {

        DebugDump("Error trying to name into prefix table\n", 0, Fcb);
        NpBugCheck( 0, 0, 0 );
    }
    //
    //  Set the configuration and pipe type
    //

    Fcb->Specific.Fcb.NamedPipeConfiguration = NamedPipeConfiguration;
    Fcb->Specific.Fcb.NamedPipeType = NamedPipeType;

    DebugTrace(-1, Dbg, "NpCreateFcb -> %08lx\n", Fcb);

    //
    //  return and tell the caller
    //
    *ppFcb = Fcb;
    return STATUS_SUCCESS;
}


VOID
NpDeleteFcb (
    IN PFCB Fcb,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This routine deallocates and removes an FCB
    from our in-memory data structures.  It also will remove all
    associated underlings.

Arguments:

    Fcb - Supplies the FCB to be removed

    DeferredList - List of IRPs to complete later

Return Value:

    None

--*/

{
    PDCB ParentDcb;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpDeleteFcb, Fcb = %08lx\n", Fcb);

    ParentDcb = Fcb->ParentDcb;

    //
    //  We can only delete this record if the open count is zero.
    //

    if (Fcb->OpenCount != 0) {

        DebugDump("Error deleting Fcb, Still Open\n", 0, Fcb);
        NpBugCheck( 0, 0, 0 );
    }

    //
    // Complete any waiters waiting on this server. All instances have now gone.
    //
    NpCancelWaiter (&NpVcb->WaitQueue,
                    &Fcb->FullFileName,
                    STATUS_OBJECT_NAME_NOT_FOUND,
                    DeferredList);

    //
    //  Remove ourselves from our parents Dcb queue
    //

    RemoveEntryList( &(Fcb->ParentDcbLinks) );

    //
    //  If there is a security descriptor on the named pipe then deassign it
    //

    if (Fcb->SecurityDescriptor != NULL) {

        ObDereferenceSecurityDescriptor( Fcb->SecurityDescriptor, 1 );
    }

    //
    //  Remove the entry from the prefix table, and then remove the full
    //  file name
    //

    RtlRemoveUnicodePrefix( &NpVcb->PrefixTable, &Fcb->PrefixTableEntry );
    NpFreePool( Fcb->FullFileName.Buffer );

    //
    //  Finally deallocate the Fcb record
    //

    NpFreePool( Fcb );

    //
    //  Check for any outstanding notify irps
    //

    NpCheckForNotify( ParentDcb, TRUE, DeferredList );

    //
    //  and return to our caller
    //

    DebugTrace(-1, Dbg, "NpDeleteFcb -> VOID\n", 0);

    return;
}


NTSTATUS
NpCreateCcb (
    IN  PFCB Fcb,
    IN  PFILE_OBJECT ServerFileObject,
    IN  NAMED_PIPE_STATE NamedPipeState,
    IN  READ_MODE ServerReadMode,
    IN  COMPLETION_MODE ServerCompletionMode,
    IN  ULONG InBoundQuota,
    IN  ULONG OutBoundQuota,
    OUT PCCB *ppCcb
    )

/*++

Routine Description:

    This routine creates a new CCB record

Arguments:

    Fcb - Supplies a pointer to the fcb we are attached to

    ServerFileObject - Supplies a pointer to the file object for the server
        end

    NamedPipeState - Supplies the initial pipe state

    ServerReadMode - Supplies our initial read mode

    ServerCompletionMode - Supplies our initial completion mode

    CreatorProcess - Supplies a pointer to our creator process

    InBoundQuota - Supplies the initial inbound quota

    OutBoundQuota - Supplies the initial outbound quota

Return Value:

    PCCB - returns a pointer to the newly allocate CCB

--*/

{
    PCCB Ccb;
    NTSTATUS status;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpCreateCcb\n", 0);

    //
    //  Allocate a new CCB record (paged and nonpaged), and zero them out
    //

    Ccb = NpAllocatePagedPoolWithQuotaCold( sizeof(CCB), 'cFpN' );
    if (Ccb == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory( Ccb, sizeof(CCB) );

    Ccb->NonpagedCcb = NpAllocateNonPagedPoolWithQuota( sizeof(NONPAGED_CCB), 'cFpN');
    if (Ccb->NonpagedCcb == NULL) {
        NpFreePool (Ccb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory( Ccb->NonpagedCcb, sizeof(NONPAGED_CCB) );

    //
    //  Set the proper node type code and node byte size
    //

    Ccb->NodeTypeCode = NPFS_NTC_CCB;

    Ccb->Fcb = Fcb;

    //
    //  Set the server file object
    //

    Ccb->FileObject[ FILE_PIPE_SERVER_END ] = ServerFileObject;

    //
    //  Initialize the nonpaged ccb
    //
    //  Set the proper node type code and node byte size
    //

    Ccb->NonpagedCcb->NodeTypeCode = NPFS_NTC_NONPAGED_CCB;

    //
    //  Set the pipe state, read mode, completion mode, and creator process
    //

    Ccb->NamedPipeState = (UCHAR) NamedPipeState;
    Ccb->ReadCompletionMode[ FILE_PIPE_SERVER_END ].ReadMode       = (UCHAR) ServerReadMode;
    Ccb->ReadCompletionMode[ FILE_PIPE_SERVER_END ].CompletionMode = (UCHAR) ServerCompletionMode;

    //
    //  Initialize the data queues
    //

    status = NpInitializeDataQueue( &Ccb->DataQueue[ FILE_PIPE_INBOUND ],
                                    InBoundQuota );
    if (!NT_SUCCESS (status)) {
        NpFreePool (Ccb->NonpagedCcb);
        NpFreePool (Ccb);
        return status;
    }

    status = NpInitializeDataQueue( &Ccb->DataQueue[ FILE_PIPE_OUTBOUND ],
                                    OutBoundQuota );
    if (!NT_SUCCESS (status)) {
        NpUninitializeDataQueue (&Ccb->DataQueue[ FILE_PIPE_INBOUND ]);
        NpFreePool (Ccb->NonpagedCcb);
        NpFreePool (Ccb);
    }

    //
    //  Insert ourselves in the list of ccb for the fcb, and increment
    //  the reference count in the fcb.
    //
    InsertTailList( &Fcb->Specific.Fcb.CcbQueue, &Ccb->CcbLinks );
    Fcb->OpenCount += 1;
    Fcb->ServerOpenCount += 1;

    //
    //  Initialize the listening queue
    //

    InitializeListHead( &Ccb->ListeningQueue );

    ExInitializeResourceLite(&Ccb->NonpagedCcb->Resource);

    //
    //  return and tell the caller
    //

    *ppCcb = Ccb;
    return STATUS_SUCCESS;
}


NTSTATUS
NpCreateRootDcbCcb (
    OUT PROOT_DCB_CCB *ppCcb
    )

/*++

Routine Description:

    This routine creates a new ROOT DCB CCB record

Arguments:

Return Value:

    PROOT_DCB_CCB - returns a pointer to the newly allocate ROOT_DCB_CCB

--*/

{
    PROOT_DCB_CCB Ccb;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpCreateRootDcbCcb\n", 0);

    //
    //  Allocate a new ROOT DCB CCB record, and zero it out
    //

    Ccb = NpAllocatePagedPoolWithQuotaCold ( sizeof(ROOT_DCB_CCB), 'CFpN' );

    if (Ccb == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory( Ccb, sizeof(ROOT_DCB_CCB) );

    //
    //  Set the proper node type code and node byte size
    //

    Ccb->NodeTypeCode = NPFS_NTC_ROOT_DCB_CCB;

    //
    //  return and tell the caller
    //

    *ppCcb = Ccb;

    DebugTrace(-1, Dbg, "NpCreateRootDcbCcb -> %08lx\n", Ccb);

    return STATUS_SUCCESS;
}


VOID
NpDeleteCcb (
    IN PCCB Ccb,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This routine deallocates and removes the specified CCB record
    from the our in memory data structures

Arguments:

    Ccb - Supplies the CCB to remove

    DeferredList - List of IRPs to complete once we drop locks

Return Value:

    None

--*/

{
    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpDeleteCcb, Ccb = %08lx\n", Ccb);

    //
    //  Case on the type of ccb we are deleting
    //

    switch (Ccb->NodeTypeCode) {

    case NPFS_NTC_CCB:

        RemoveEntryList (&Ccb->CcbLinks);
        Ccb->Fcb->OpenCount -= 1;

        NpDeleteEventTableEntry (&NpVcb->EventTable,
                                 Ccb->NonpagedCcb->EventTableEntry[FILE_PIPE_CLIENT_END]);

        NpDeleteEventTableEntry (&NpVcb->EventTable,
                                 Ccb->NonpagedCcb->EventTableEntry[FILE_PIPE_SERVER_END]);

        NpUninitializeDataQueue (&Ccb->DataQueue[FILE_PIPE_INBOUND]);

        NpUninitializeDataQueue (&Ccb->DataQueue[FILE_PIPE_OUTBOUND]);

        //
        //  Check for any outstanding notify irps
        //

        NpCheckForNotify (Ccb->Fcb->ParentDcb, FALSE, DeferredList);

        //
        // Delete the resource
        //
        ExDeleteResourceLite (&Ccb->NonpagedCcb->Resource);

        //
        //  Free up the security fields in the ccb and then free the nonpaged
        //  ccb
        //

        NpUninitializeSecurity (Ccb);

        //
        // Free up client info if it was allocated.
        //
        if (Ccb->ClientInfo != NULL) {
            NpFreePool (Ccb->ClientInfo);
            Ccb->ClientInfo = NULL;
        }

        NpFreePool (Ccb->NonpagedCcb);

        break;

    case NPFS_NTC_ROOT_DCB_CCB:

        if (((PROOT_DCB_CCB)Ccb)->QueryTemplate != NULL) {

            NpFreePool (((PROOT_DCB_CCB)Ccb)->QueryTemplate);
        }
        break;
    }

    //  Deallocate the Ccb record
    //

    NpFreePool (Ccb);

    //
    //  return and tell the caller
    //

    DebugTrace(-1, Dbg, "NpDeleteCcb -> VOID\n", 0);

    return;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\npfs\write.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Write.c

Abstract:

    This module implements the File Write routine for NPFS called by the
    dispatch driver.

Author:

    Gary Kimura     [GaryKi]    21-Aug-1990

Revision History:

--*/

#include "NpProcs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_WRITE)

#if DBG
ULONG NpFastWriteTrue = 0;
ULONG NpFastWriteFalse = 0;
ULONG NpSlowWriteCalls = 0;
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NpCommonWrite)
#pragma alloc_text(PAGE, NpFastWrite)
#pragma alloc_text(PAGE, NpFsdWrite)
#endif


NTSTATUS
NpFsdWrite (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtWriteFile API calls.

Arguments:

    NpfsDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    IO_STATUS_BLOCK Iosb;
    PIO_STACK_LOCATION IrpSp;
    LIST_ENTRY DeferredList;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpFsdWrite\n", 0);
    DbgDoit( NpSlowWriteCalls += 1 );

    InitializeListHead (&DeferredList);

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    FsRtlEnterFileSystem();

    NpAcquireSharedVcb();

    (VOID) NpCommonWrite( IrpSp->FileObject,
                          Irp->UserBuffer,
                          IrpSp->Parameters.Write.Length,
                          Irp->Tail.Overlay.Thread,
                          &Iosb,
                          Irp,
                          &DeferredList );

    NpReleaseVcb();

    //
    // Complete any deferred IRPs now we have dropped the locks
    //
    NpCompleteDeferredIrps (&DeferredList);

    FsRtlExitFileSystem();

    if (Iosb.Status != STATUS_PENDING) {
        Irp->IoStatus.Information = Iosb.Information;
        NpCompleteRequest (Irp, Iosb.Status);
    }

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "NpFsdWrite -> %08lx\n", Iosb.Status );

    return Iosb.Status;
}


BOOLEAN
NpFastWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine does a fast write bypassing the usual file system
    entry routine (i.e., without the Irp).

Arguments:

    FileObject - Pointer to the file object being read.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    Wait - FALSE if caller may not block, TRUE otherwise

    LockKey - Supplies the Key used to use if the byte range being read is locked.

    Buffer - Pointer to output buffer to which data should be copied.

    IoStatus - Pointer to standard I/O status block to receive the status
               for the transfer.

Return Value:

    BOOLEAN - TRUE if the operation completed successfully and FALSE if the
        caller needs to take the long IRP based route.

--*/

{
    BOOLEAN Results = FALSE;
    LIST_ENTRY DeferredList;

    UNREFERENCED_PARAMETER( FileOffset );
    UNREFERENCED_PARAMETER( Wait );
    UNREFERENCED_PARAMETER( LockKey );
    UNREFERENCED_PARAMETER( DeviceObject );

    PAGED_CODE();

    InitializeListHead (&DeferredList);

    FsRtlEnterFileSystem();

    NpAcquireSharedVcb();

    if (NpCommonWrite( FileObject,
                       Buffer,
                       Length,
                       PsGetCurrentThread(),
                       IoStatus,
                       NULL,
                       &DeferredList )) {

        DbgDoit( NpFastWriteTrue += 1 );

        Results = TRUE;
    } else {

        DbgDoit( NpFastWriteFalse += 1 );
    }

    NpReleaseVcb();

    //
    // Complete any deferred IRPs now we have dropped the locks
    //
    NpCompleteDeferredIrps (&DeferredList);

    FsRtlExitFileSystem();
    return Results;
}


//
//  Internal support routine
//

BOOLEAN
NpCommonWrite (
    IN PFILE_OBJECT FileObject,
    IN PVOID WriteBuffer,
    IN ULONG WriteLength,
    IN PETHREAD UserThread,
    OUT PIO_STATUS_BLOCK Iosb,
    IN PIRP Irp OPTIONAL,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This is the common routine for writing data to a named pipe both via the
    fast path and with an Irp.

Arguments:

    FileObject - Supplies the file object used in this operation

    WriteBuffer - Supplies the buffer where data from which data is to be read

    WriteLength - Supplies the length of the write buffer in bytes

    UserThread - Supplies the thread id of the caller

    Iosb - Receives the final completion status of this operation

    Irp - Optionally supplies an Irp to be used in this operation

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    NODE_TYPE_CODE NodeTypeCode;
    PCCB Ccb;
    PNONPAGED_CCB NonpagedCcb;
    NAMED_PIPE_END NamedPipeEnd;

    NAMED_PIPE_CONFIGURATION NamedPipeConfiguration;

    ULONG WriteRemaining;
    PDATA_QUEUE WriteQueue;

    PEVENT_TABLE_ENTRY Event;
    READ_MODE ReadMode;
    BOOLEAN Status;

    PDATA_ENTRY DataEntry;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpCommonWrite\n", 0);
    DebugTrace( 0, Dbg, "FileObject  = %08lx\n", FileObject);
    DebugTrace( 0, Dbg, "WriteBuffer = %08lx\n", WriteBuffer);
    DebugTrace( 0, Dbg, "WriteLength = %08lx\n", WriteLength);
    DebugTrace( 0, Dbg, "UserThread  = %08lx\n", UserThread);
    DebugTrace( 0, Dbg, "Iosb        = %08lx\n", Iosb);
    DebugTrace( 0, Dbg, "Irp         = %08lx\n", Irp);

    Iosb->Information = 0;

    //
    //  Get the Ccb and figure out who we are, and make sure we're not
    //  disconnected
    //

    if ((NodeTypeCode = NpDecodeFileObject( FileObject,
                                            NULL,
                                            &Ccb,
                                            &NamedPipeEnd )) == NTC_UNDEFINED) {

        DebugTrace(0, Dbg, "Pipe is disconnected from us\n", 0);

        Iosb->Status = STATUS_PIPE_DISCONNECTED;
        return TRUE;
    }

    //
    //  Now we only will allow write operations on the pipe and not a directory
    //  or the device
    //

    if (NodeTypeCode != NPFS_NTC_CCB) {

        DebugTrace(0, Dbg, "FileObject is not for a named pipe\n", 0);

        Iosb->Status = STATUS_INVALID_PARAMETER;
        return TRUE;
    }

    NpAcquireExclusiveCcb(Ccb);

    NonpagedCcb = Ccb->NonpagedCcb;

    try {
        //
        //  Check if the pipe is not in the connected state.
        //

        if ((Ccb->NamedPipeState == FILE_PIPE_DISCONNECTED_STATE) ||
            (Ccb->NamedPipeState == FILE_PIPE_LISTENING_STATE) ||
            (Ccb->NamedPipeState == FILE_PIPE_CLOSING_STATE)) {

            DebugTrace(0, Dbg, "Pipe in disconnected or listening or closing state\n", 0);

            if (Ccb->NamedPipeState == FILE_PIPE_DISCONNECTED_STATE) {

                Iosb->Status = STATUS_PIPE_DISCONNECTED;

            } else if (Ccb->NamedPipeState == FILE_PIPE_LISTENING_STATE) {

                Iosb->Status = STATUS_PIPE_LISTENING;

            } else {

                Iosb->Status = STATUS_PIPE_CLOSING;
            }

            try_return(Status = TRUE);
        }

        ASSERT(Ccb->NamedPipeState == FILE_PIPE_CONNECTED_STATE);

        //
        //  We only allow a write by the server on a non inbound only pipe
        //  and by the client on a non outbound only pipe
        //

        NamedPipeConfiguration = Ccb->Fcb->Specific.Fcb.NamedPipeConfiguration;

        if (((NamedPipeEnd == FILE_PIPE_SERVER_END) &&
             (NamedPipeConfiguration == FILE_PIPE_INBOUND))

                ||

            ((NamedPipeEnd == FILE_PIPE_CLIENT_END) &&
             (NamedPipeConfiguration == FILE_PIPE_OUTBOUND))) {

            DebugTrace(0, Dbg, "Trying to write to the wrong pipe configuration\n", 0);

            Iosb->Status = STATUS_INVALID_PARAMETER;

            try_return(Status = TRUE);
        }

        //
        //  Set up the amount of data we will have written by the time this
        //  operation gets completed and indicate success until we set it otherwise.
        //

        Iosb->Status = STATUS_SUCCESS;
        Iosb->Information = WriteLength;

        //
        //  Now the data queue that we write into and the event that we signal
        //  are based on the named pipe end.  The server writes to the outbound
        //  queue and signals the client event.  The client does just the
        //  opposite.  We also need to figure out the read mode for the opposite
        //  end of the pipe.
        //

        if (NamedPipeEnd == FILE_PIPE_SERVER_END) {

            WriteQueue = &Ccb->DataQueue[ FILE_PIPE_OUTBOUND ];

            Event = NonpagedCcb->EventTableEntry[ FILE_PIPE_CLIENT_END ];
            ReadMode = Ccb->ReadCompletionMode[ FILE_PIPE_CLIENT_END ].ReadMode;

        } else {

            WriteQueue = &Ccb->DataQueue[ FILE_PIPE_INBOUND ];

            Event = NonpagedCcb->EventTableEntry[ FILE_PIPE_SERVER_END ];
            ReadMode = Ccb->ReadCompletionMode[ FILE_PIPE_SERVER_END ].ReadMode;
        }

        //
        //  The next section checks if we should continue with the write operation.
        //  The reasons why we will not continue are if we recongnize that the
        //  pipe quota will not support this write and it is a message mode type
        //  with complete operations.  We will also bail out now if the quota will
        //  not support the write and this is a fast I/O write request.
        //
        //  If the pipe contains readers and amount to read plus pipe quota is less
        //  than the write length then we need to do some additional checks.
        //  Or if pipe does not contain reads and the amount of quota left is less
        //  than the write length then we need to do some additional checks.
        //

        if ((NpIsDataQueueReaders( WriteQueue ) &&
            (WriteQueue->BytesInQueue < WriteLength) &&
            (WriteQueue->Quota < WriteLength - WriteQueue->BytesInQueue))

                ||

            (!NpIsDataQueueReaders( WriteQueue ) &&
            ((WriteQueue->Quota - WriteQueue->QuotaUsed) < WriteLength))) {

            DebugTrace(0, Dbg, "Quota is not sufficient for the request\n", 0);

            //
            //  If this is a message mode pipe with complete operations then we
            //  complete without writing the message
            //

            if ((Ccb->Fcb->Specific.Fcb.NamedPipeType == FILE_PIPE_MESSAGE_TYPE) &&
                (Ccb->ReadCompletionMode[NamedPipeEnd].CompletionMode == FILE_PIPE_COMPLETE_OPERATION)) {

                Iosb->Information = 0;
                Iosb->Status = STATUS_SUCCESS;

                try_return(Status = TRUE);
            }

            //
            //  If this is a fast I/O pipe then we tell the call to take the long
            //  Irp based route
            //

            if (!ARGUMENT_PRESENT(Irp)) {

                DebugTrace(0, Dbg, "Need to supply Irp\n", 0);

                try_return(Status = FALSE);
            }
        }

        //
        //  Now we'll call our common write data queue routine to
        //  transfer data out of our write buffer into the data queue.
        //  If the result of the call is FALSE then we still have some
        //  write data to put into the write queue.
        //
        Iosb->Status = NpWriteDataQueue( WriteQueue,
                                         ReadMode,
                                         WriteBuffer,
                                         WriteLength,
                                         Ccb->Fcb->Specific.Fcb.NamedPipeType,
                                         &WriteRemaining,
                                         Ccb,
                                         NamedPipeEnd,
                                         UserThread,
                                         DeferredList );

        if (Iosb->Status == STATUS_MORE_PROCESSING_REQUIRED)  {

            ASSERT( !NpIsDataQueueReaders( WriteQueue ));

            //
            //  Check if the operation is not to block and if so then we
            //  will complete the operation now with what we're written, if what is
            //  left will not fit in the quota for the file
            //

            if (((Ccb->ReadCompletionMode[NamedPipeEnd].CompletionMode == FILE_PIPE_COMPLETE_OPERATION) ||
                 Irp == NULL) &&
                ((WriteQueue->Quota - WriteQueue->QuotaUsed) < WriteRemaining)) {

                DebugTrace(0, Dbg, "Complete the byte stream write immediately\n", 0);

                Iosb->Information = WriteLength - WriteRemaining;
                Iosb->Status = STATUS_SUCCESS;

            } else {

                DebugTrace(0, Dbg, "Add write to data queue\n", 0);

                //
                //  Add this write request to the write queue
                //

                ASSERT( !NpIsDataQueueReaders( WriteQueue ));

                Iosb->Status = NpAddDataQueueEntry( NamedPipeEnd,
                                                    Ccb,
                                                    WriteQueue,
                                                    WriteEntries,
                                                    Buffered,
                                                    WriteLength,
                                                    Irp,
                                                    WriteBuffer,
                                                    WriteLength - WriteRemaining );

            }

        } else {

            DebugTrace(0, Dbg, "Complete the Write Irp\n", 0);

        }


        //
        //  And because we've done something we need to signal the
        //  other ends event
        //

        NpSignalEventTableEntry( Event );

        Status = TRUE;

    try_exit: NOTHING;
    } finally {
        NpReleaseCcb(Ccb);
    }


    DebugTrace(-1, Dbg, "NpCommonWrite -> TRUE\n", 0);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\npfs\npfskd\kdext.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    kdexts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Author:

    Nar Ganapathy - 9/21/99

Environment:

    User Mode

--*/

#include <stdio.h>
#include <windows.h>
#include "wdbgexts.h"

#include <ntverp.h>
#include <imagehlp.h>

//
// globals
//
EXT_API_VERSION        ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };
WINDBG_EXTENSION_APIS  ExtensionApis;
ULONG                  STeip;
ULONG                  STebp;
ULONG                  STesp;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;
ULONG                  NpDumpFlags = 0;

extern VOID NpDump(IN PVOID Ptr);


DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    UNREFERENCED_PARAMETER( hModule );
    UNREFERENCED_PARAMETER( dwReserved );
    
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}


VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}

DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    UNREFERENCED_PARAMETER( args );
    UNREFERENCED_PARAMETER( dwProcessor );
    UNREFERENCED_PARAMETER( dwCurrentPc );
    UNREFERENCED_PARAMETER( hCurrentThread );
    UNREFERENCED_PARAMETER( hCurrentProcess );

    dprintf( "%s Extension dll for Build %d debugging %s kernel for Build %d\n",
             DebuggerType,
             VER_PRODUCTBUILD,
             SavedMajorVersion == 0x0c ? "Checked" : "Free",
             SavedMinorVersion
           );
}

VOID
CheckVersion(
    VOID
    )
{
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

BOOLEAN
IsHexNumber(
   const char *szExpression
   )
{
   if (!szExpression[0]) {
      return FALSE ;
   }

   for(;*szExpression; szExpression++) {
      
      if      ((*szExpression)< '0') { return FALSE ; } 
      else if ((*szExpression)> 'f') { return FALSE ; }
      else if ((*szExpression)>='a') { continue ;     }
      else if ((*szExpression)> 'F') { return FALSE ; }
      else if ((*szExpression)<='9') { continue ;     }
      else if ((*szExpression)>='A') { continue ;     }
      else                           { return FALSE ; }
   }
   return TRUE ;
}

DECLARE_API(npcb)
{

   ULONG_PTR ptrToDump;
   char ExprBuf[256] ;
   char FlagBuf[256] ;
   int ret;

   if (!*args) {
       dprintf("Usage: !npcb <pointer> <Flag>");
       return;
   }

   ExprBuf[0] = '\0' ;
   FlagBuf[0] = '\0' ;

   NpDumpFlags = 0;
   ret = sscanf(args,"%s %lx", ExprBuf, &NpDumpFlags);

   if (ret != EOF) {

       if (IsHexNumber(ExprBuf)) {
          ret = sscanf(ExprBuf, "%lx", &ptrToDump) ;
          if (ret == EOF) {
              ptrToDump = 0;
          }
       } else {
          ptrToDump = GetExpression( ExprBuf ) ;
          if (ptrToDump == 0) {

             dprintf("An error occured trying to evaluate the expression\n");
             return ;
          }
       }
       NpDump((PVOID)ptrToDump);
   } else {
       dprintf("An error occured trying to evaluate the expression\n");
   }
}

VOID
NpfskdPrint(
    PCHAR   String,
    ULONG_PTR Val
    )
{
    dprintf("%-50s 0x%x\n",String, Val);
}

VOID
NpfskdPrintString(
    PCHAR   String1,
    PCHAR   String2
    )
{
    dprintf("%-50s %s\n",String1, String2);
}

VOID
NpfskdPrintWideString(
    PWCHAR   String1,
    PWCHAR   String2
    )
{
    dprintf("%-50S %S\n",String1, String2);
}

BOOLEAN
NpfskdReadMemory(
    PVOID   TargetPtr,
    PVOID   LocalPtr,
    ULONG   Length
    )
{
    ULONG   Result;

    if (!ReadMemory((ULONG_PTR)TargetPtr, LocalPtr, Length, &Result)) {
        dprintf("Cannot read memory at 0x%x\n", TargetPtr);
        return FALSE;
    }

    if (Result != Length) {
        dprintf("Expected length 0x%x != Actual length 0x%x\n", Length, Result);
        return FALSE;
    }

    return TRUE;
}

ULONG
NpfskdCheckControlC()
{
    return (CheckControlC());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\npfs\npfskd\npfskd.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Npfskd.c

Abstract:

    KD Extension Api for examining Npfs specific data structures

Author:

    Narayanan   Ganapathy   - 9/21/99
    
Environment:

    User Mode.

Revision History:

--*/


#include "NpProcs.h"


//
// This file should not include wdbgexts.h as it includes windows.h
// windows.h defines a structure called _DCB that clashes with the DCB for NPFS.
// So the debugger functions are called from kdexts.c and indirectly called from this function
// 




BOOLEAN NpDumpEventTableEntry(IN PEVENT_TABLE_ENTRY Ptr);
BOOLEAN NpDumpDataQueue(IN PDATA_QUEUE Ptr);
BOOLEAN NpDumpDataEntry(IN PDATA_ENTRY Ptr);

BOOLEAN NpDump(IN PVOID Ptr);
BOOLEAN NpDumpVcb(IN PVCB Ptr);
BOOLEAN NpDumpRootDcb(IN PROOT_DCB Ptr);
BOOLEAN NpDumpFcb(IN PFCB Ptr);
BOOLEAN NpDumpCcb(IN PCCB Ptr);
BOOLEAN NpDumpNonpagedCcb(IN PNONPAGED_CCB Ptr);
BOOLEAN NpDumpRootDcbCcb(IN PROOT_DCB_CCB Ptr);

extern  VOID    NpfskdPrint(PCHAR, ULONG_PTR);
extern  VOID    NpfskdPrintString(PCHAR, PCHAR);
extern  VOID    NpfskdPrintWideString(PWCHAR, PWCHAR);
extern  BOOLEAN NpfskdReadMemory(PVOID, PVOID, ULONG);
extern  ULONG   NpfskdCheckControlC(VOID);

extern  ULONG   NpDumpFlags;

ULONG NpDumpCurrentColumn;


#define DumpField(Field) NpfskdPrint( #Field , (ULONG_PTR)Ptr->Field)


#define DumpListEntry(Links)  \
    NpfskdPrint( #Links "->Flink", (ULONG_PTR)Ptr->Links.Flink);  \
    NpfskdPrint( #Links "->Blink", (ULONG_PTR)Ptr->Links.Blink)

#define DumpName(Field) { \
    ULONG i; \
    WCHAR _String[64]; \
    if (!NpfskdReadMemory(Ptr->Field, _String, sizeof(_String))) \
        return FALSE; \
    NpfskdPrintWideString(L#Field, _String); \
}

#define DumpTitle(Title, Value)    { \
    NpfskdPrint("\n                      "#Title"@                ", (Value)); \
    }
    
#define TestForNull(Name) { \
    if (targetPtr == NULL) { \
        NpfskdPrintString("Cannot dump a NULL pointer\n", Name); \
        return FALSE; \
    } \
}

#define NP_READ_MEMORY(targetPtr, localStore, localPtr)  \
    {   \
        if (!NpfskdReadMemory((targetPtr),   \
                        &(localStore),  \
                        sizeof(localStore))) { \
            return FALSE; \
        }   \
        localPtr = &(localStore);   \
    }


#define NPFS_FULL_INFORMATION   1
#define NPFS_WALK_LISTS         2


BOOLEAN 
NpDumpEventTableEntry (
    IN PEVENT_TABLE_ENTRY targetPtr
    )

{
    PEVENT_TABLE_ENTRY  Ptr;
    EVENT_TABLE_ENTRY   Event;
    TestForNull   ("NpDumpEventTableEntry");

    DumpTitle       (EventTableEntry, (ULONG_PTR)(targetPtr));

    NP_READ_MEMORY(targetPtr, Event, Ptr);

    DumpField     (Ccb);
    DumpField     (NamedPipeEnd);
    DumpField     (EventHandle);
    DumpField     (Event);
    DumpField     (KeyValue);
    DumpField     (Process);

    return TRUE;
}



BOOLEAN NpDumpDataQueue (
    IN PDATA_QUEUE targetPtr
    )

{
    PDATA_ENTRY Entry;
    DATA_ENTRY DataEntry;
    PDATA_QUEUE Ptr;
    DATA_QUEUE  Dqueue;


    TestForNull   ("NpDumpDataQueue");

    DumpTitle       (DataQueue, (ULONG_PTR)(targetPtr));

    NP_READ_MEMORY(targetPtr, Dqueue, Ptr);


    DumpField     (QueueState);
    DumpField     (BytesInQueue);
    DumpField     (EntriesInQueue);
    DumpField     (Quota);
    DumpField     (QuotaUsed);
    DumpField     (Queue.Flink);
    DumpField     (Queue.Blink);
    DumpField     (NextByteOffset);

    Entry = (PDATA_ENTRY) Ptr->Queue.Flink;

    if (!(NpDumpFlags & NPFS_WALK_LISTS)) {
        return TRUE;
    }

    while (Entry != (PDATA_ENTRY) &Ptr->Queue){

        if (!NpfskdReadMemory(Entry, &DataEntry, sizeof(DataEntry))) {
            return FALSE;
        }
        NpDumpDataEntry( Entry );
        if (NpfskdCheckControlC()) {
            NpfskdPrintString("^C Typed. Bailing out","");
            return FALSE;
        }
        Entry = (PDATA_ENTRY) DataEntry.Queue.Flink;
    }

    return TRUE;
}


BOOLEAN NpDumpDataEntry (
    IN PDATA_ENTRY targetPtr
    )

{
    DATA_ENTRY  Dentry;
    PDATA_ENTRY Ptr;

    TestForNull   ("NpDumpDataEntry");

    DumpTitle       (DataEntry, (ULONG_PTR)(targetPtr));

    NP_READ_MEMORY(targetPtr, Dentry, Ptr);

    DumpField     (DataEntryType);
    DumpField     (Queue.Flink);
    DumpField     (Irp);
    DumpField     (DataSize);
    DumpField     (SecurityClientContext);

    return TRUE;
}


BOOLEAN NpDump (
    IN PVOID Ptr
    )

/*++

Routine Description:

    This routine determines the type of internal record reference by ptr and
    calls the appropriate dump routine.

Arguments:

    Ptr - Supplies the pointer to the record to be dumped

Return Value:

    None

--*/

{
    NODE_TYPE_CODE  NodeType;
    PNODE_TYPE_CODE pNodeType;
    BOOLEAN         Ret;

    //
    //  We'll switch on the node type code
    //

    NP_READ_MEMORY(Ptr, NodeType, pNodeType);

    switch (NodeType) {

    case NPFS_NTC_VCB:               Ret = NpDumpVcb((PVCB)Ptr);             break;
    case NPFS_NTC_ROOT_DCB:          Ret = NpDumpRootDcb((PDCB)Ptr);         break;
    case NPFS_NTC_FCB:               Ret = NpDumpFcb((PFCB)Ptr);             break;
    case NPFS_NTC_CCB:               Ret = NpDumpCcb((PCCB)Ptr);             break;
    case NPFS_NTC_NONPAGED_CCB:      Ret = NpDumpNonpagedCcb((PNONPAGED_CCB)Ptr);     break;
    case NPFS_NTC_ROOT_DCB_CCB:      Ret = NpDumpRootDcbCcb((PROOT_DCB_CCB)Ptr);      break;

    default :
        Ret = TRUE;
        NpfskdPrint("NpDump - Unknown Node type code ", NodeType);
        break;
    }

    return Ret;
}


BOOLEAN NpDumpVcb (
    IN PVCB targetPtr
    )

/*++

Routine Description:

    Dump an Vcb structure

Arguments:

    Ptr - Supplies the Device record to be dumped

Return Value:

    None

--*/

{
    VCB Vcb;
    PVCB Ptr;

    TestForNull   ("NpDumpVcb");

    DumpTitle     (Vcb, (ULONG_PTR)(targetPtr));

    NP_READ_MEMORY(targetPtr, Vcb, Ptr);
    DumpField     (NodeTypeCode);
    DumpField     (RootDcb);
    DumpField     (OpenCount);

    NpDump        (Ptr->RootDcb);

    return TRUE;
}


BOOLEAN NpDumpRootDcb (
    IN PROOT_DCB targetPtr
    )

/*++

Routine Description:

    Dump a root dcb structure

Arguments:

    Ptr - Supplies the Root Dcb record to be dumped

Return Value:

    None

--*/

{
    PLIST_ENTRY Links;
    LIST_ENTRY  NextEntry;
    ROOT_DCB   RootDcb;
    PROOT_DCB   Ptr;

    TestForNull   ("NpDumpRootDcb");

    DumpTitle     (RootDcb, (ULONG_PTR)(targetPtr));
    NP_READ_MEMORY(targetPtr, RootDcb, Ptr);

    DumpField     (NodeTypeCode);
    DumpListEntry (ParentDcbLinks);
    DumpField     (ParentDcb);
    DumpField     (OpenCount);
    DumpField     (FullFileName.Length);
    DumpField     (FullFileName.Buffer);
    DumpName      (FullFileName.Buffer);
    DumpField     (LastFileName.Length);
    DumpName      (LastFileName.Buffer);
    DumpListEntry (Specific.Dcb.NotifyFullQueue);
    DumpListEntry (Specific.Dcb.NotifyPartialQueue);
    DumpListEntry (Specific.Dcb.ParentDcbQueue);


    Links = Ptr->Specific.Dcb.ParentDcbQueue.Flink;

    if (!(NpDumpFlags & NPFS_WALK_LISTS)) {
        return TRUE;
    }

    while (Links != &Ptr->Specific.Dcb.ParentDcbQueue) {
        if (!NpfskdReadMemory(Links, &NextEntry, sizeof(NextEntry))) {
            return FALSE;
        }
        if (!NpDump(CONTAINING_RECORD(Links, FCB, ParentDcbLinks))) {
            return FALSE;
        }
        if (NpfskdCheckControlC()) {
            NpfskdPrintString("^C Typed. Bailing out","");
            return FALSE;
        }
        Links = NextEntry.Flink;
    }

    return TRUE;
}


BOOLEAN NpDumpFcb (
    IN PFCB targetPtr
    )

/*++

Routine Description:

    Dump an Fcb structure

Arguments:

    Ptr - Supplies the Fcb record to be dumped

Return Value:

    None

--*/

{
    PLIST_ENTRY Links;
    LIST_ENTRY  NextEntry;
    FCB Fcb;
    PFCB  Ptr;


    TestForNull   ("NpDumpFcb");

    DumpTitle     (Fcb, (ULONG_PTR)(targetPtr));

    NP_READ_MEMORY(targetPtr, Fcb , Ptr);

    DumpField     (NodeTypeCode);
    DumpField     (FullFileName.Length);
    DumpField     (FullFileName.Buffer);
    DumpName      (FullFileName.Buffer);

    if (NpDumpFlags & NPFS_FULL_INFORMATION) {
        DumpListEntry (ParentDcbLinks);
        DumpField     (ParentDcb);
        DumpField     (OpenCount);
        DumpField     (LastFileName.Length);
        DumpName      (LastFileName.Buffer);
        DumpField     (Specific.Fcb.NamedPipeConfiguration);
        DumpField     (Specific.Fcb.NamedPipeType);
        DumpField     (Specific.Fcb.MaximumInstances);
        DumpField     (Specific.Fcb.DefaultTimeOut.LowPart);
        DumpField     (Specific.Fcb.DefaultTimeOut.HighPart);
        DumpListEntry (Specific.Fcb.CcbQueue);
    }

    if (!(NpDumpFlags & NPFS_WALK_LISTS)) {
        return TRUE;
    }

    Links = Ptr->Specific.Fcb.CcbQueue.Flink;
    while (Links != &Ptr->Specific.Fcb.CcbQueue) {
        if (!NpfskdReadMemory(Links, &NextEntry, sizeof(NextEntry))) {
            return FALSE;
        }
        if (!NpDump(CONTAINING_RECORD(Links, CCB, CcbLinks))) {
            return FALSE;
        }
        if (NpfskdCheckControlC()) {
            NpfskdPrintString("^C Typed. Bailing out","");
            return FALSE;
        }
        Links = NextEntry.Flink;
    }

    return TRUE;
}


BOOLEAN NpDumpCcb (
    IN PCCB targetPtr
    )

/*++

Routine Description:

    Dump a Ccb structure

Arguments:

    Ptr - Supplies the Ccb record to be dumped

Return Value:

    None

--*/

{
    PCCB    Ptr;
    CCB     Ccb;  

    TestForNull   ("NpDumpCcb");

    DumpTitle     (Ccb, (ULONG_PTR)(targetPtr));

    NP_READ_MEMORY(targetPtr, Ccb, Ptr);

    DumpField     (NodeTypeCode);
    DumpField     (Fcb);
    DumpField     (FileObject[FILE_PIPE_CLIENT_END]);
    DumpField     (FileObject[FILE_PIPE_SERVER_END]);

    if (NpDumpFlags & NPFS_FULL_INFORMATION) {

        DumpField     (NamedPipeState);
        DumpField     (SecurityClientContext);
        DumpListEntry (ListeningQueue);
    }

    if (!NpDumpDataQueue(&targetPtr->DataQueue[FILE_PIPE_CLIENT_END])) {
        return FALSE;
    }
    if (!NpDumpDataQueue(&targetPtr->DataQueue[FILE_PIPE_SERVER_END])) {
        return FALSE;
    }

    return NpDump        (Ptr->NonpagedCcb);

}


BOOLEAN NpDumpNonpagedCcb (
    IN PNONPAGED_CCB targetPtr
    )

/*++

Routine Description:

    Dump a Nonpaged Ccb structure

Arguments:

    Ptr - Supplies the Nonpaged Ccb record to be dumped

Return Value:

    None

--*/

{
    NONPAGED_CCB    Ccb;
    PNONPAGED_CCB   Ptr;

    TestForNull   ("NpDumpNonpagedCcb");

    DumpTitle       (NonpagedCcb, (ULONG_PTR)(targetPtr));

    NP_READ_MEMORY(targetPtr, Ccb, Ptr);

    DumpField     (NodeTypeCode);
    DumpField     (EventTableEntry[FILE_PIPE_CLIENT_END]);
    DumpField     (EventTableEntry[FILE_PIPE_SERVER_END]);

    return TRUE;
}


BOOLEAN NpDumpRootDcbCcb (
    IN PROOT_DCB_CCB targetPtr
    )

/*++

Routine Description:

    Dump a Root Dcb Ccb structure

Arguments:

    Ptr - Supplies the Root Dcb Ccb record to be dumped

Return Value:

    None

--*/

{
    ROOT_DCB_CCB    RootDcbCcb;
    PROOT_DCB_CCB   Ptr;

    TestForNull   ("NpDumpRootDcbCcb");

    DumpTitle     (RootDcbCcb, (ULONG_PTR)(targetPtr));

    NP_READ_MEMORY(targetPtr, RootDcbCcb, Ptr);

    DumpField     (NodeTypeCode);
    DumpField     (IndexOfLastCcbReturned);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\npfs\volinfo.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    VolInfo.c

Abstract:

    This module implements the volume information routines for NPFS called by
    the dispatch driver.

Author:

    Gary Kimura     [GaryKi]    12-Apr-1990

Revision History:

--*/

#include "NpProcs.h"

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_VOLINFO)

//
//  Local procedure prototypes
//

NTSTATUS
NpCommonQueryVolumeInformation (
    IN PIRP Irp
    );

NTSTATUS
NpQueryFsDeviceInfo (
    IN PFILE_FS_DEVICE_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
NpQueryFsAttributeInfo (
    IN PFILE_FS_ATTRIBUTE_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
NpQueryFsVolumeInfo (
    IN PFILE_FS_VOLUME_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
NpQueryFsSizeInfo (
    IN PFILE_FS_SIZE_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
NpQueryFsFullSizeInfo (
    IN PFILE_FS_FULL_SIZE_INFORMATION Buffer,
    IN OUT PULONG Length
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NpCommonQueryVolumeInformation)
#pragma alloc_text(PAGE, NpFsdQueryVolumeInformation)
#pragma alloc_text(PAGE, NpQueryFsAttributeInfo)
#pragma alloc_text(PAGE, NpQueryFsDeviceInfo)
#pragma alloc_text(PAGE, NpQueryFsVolumeInfo)
#pragma alloc_text(PAGE, NpQueryFsSizeInfo)
#pragma alloc_text(PAGE, NpQueryFsFullSizeInfo)
#endif


NTSTATUS
NpFsdQueryVolumeInformation (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the Fsd part of the NtQueryVolumeInformation API
    call.

Arguments:

    VolumeDeviceObject - Supplies the volume device object where the file
        being queried exists.

    Irp - Supplies the Irp being processed.

Return Value:

    NTSTATUS - The FSD status for the Irp.

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpFsdQueryVolumeInformation\n", 0);

    //
    //  Call the common query routine, with blocking allowed if synchronous
    //

    FsRtlEnterFileSystem();

    Status = NpCommonQueryVolumeInformation( Irp );

    FsRtlExitFileSystem();

    if (Status != STATUS_PENDING) {
        NpCompleteRequest (Irp, Status);
    }

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "NpFsdQueryVolumeInformation -> %08lx\n", Status);

    return Status;
}

//
//  Internal support routine
//

NTSTATUS
NpCommonQueryVolumeInformation (
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for querying volume information.

Arguments:

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    ULONG Length;
    FS_INFORMATION_CLASS FsInformationClass;
    PVOID Buffer;

    PAGED_CODE();

    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NptCommonQueryVolumeInfo...\n", 0);
    DebugTrace( 0, Dbg, "Irp                = %08lx\n", Irp );
    DebugTrace( 0, Dbg, "Length             = %08lx\n", IrpSp->Parameters.QueryVolume.Length);
    DebugTrace( 0, Dbg, "FsInformationClass = %08lx\n", IrpSp->Parameters.QueryVolume.FsInformationClass);
    DebugTrace( 0, Dbg, "Buffer             = %08lx\n", Irp->AssociatedIrp.SystemBuffer);

    //
    //  Reference our input parameters to make things easier
    //

    Length = IrpSp->Parameters.QueryVolume.Length;
    FsInformationClass = IrpSp->Parameters.QueryVolume.FsInformationClass;
    Buffer = Irp->AssociatedIrp.SystemBuffer;

    switch (FsInformationClass) {

    case FileFsDeviceInformation:

        Status = NpQueryFsDeviceInfo( Buffer, &Length );
        break;

    case FileFsAttributeInformation:

        Status = NpQueryFsAttributeInfo( Buffer, &Length );
        break;

    case FileFsVolumeInformation:

        Status = NpQueryFsVolumeInfo( Buffer, &Length );
        break;

    case FileFsSizeInformation:

        Status = NpQueryFsSizeInfo( Buffer, &Length );
        break;

    case FileFsFullSizeInformation:

        Status = NpQueryFsFullSizeInfo( Buffer, &Length );
        break;

    default:

        Status = STATUS_NOT_SUPPORTED;
        break;
    }

    //
    //  Set the information field to the number of bytes actually filled in
    //

    Irp->IoStatus.Information = IrpSp->Parameters.QueryVolume.Length - Length;

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "NpCommonQueryVolumeInformation -> %08lx\n", Status);

    return Status;
}


//
//  Internal support routine
//

NTSTATUS
NpQueryFsDeviceInfo (
    IN PFILE_FS_DEVICE_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query volume device call

Arguments:

    Buffer - Supplies a pointer to the output buffer where the information
        is to be returned

    Length - Supplies the length of the buffer in byte.  This variable
        upon return recieves the remaining bytes free in the buffer

Return Value:

    Status - Returns the status for the query

--*/

{
    PAGED_CODE();

    DebugTrace(0, Dbg, "NpQueryFsDeviceInfo...\n", 0);

    //
    //  Make sure the buffer is large enough
    //

    if (*Length < sizeof(FILE_FS_DEVICE_INFORMATION)) {

        return STATUS_BUFFER_OVERFLOW;
    }

    RtlZeroMemory( Buffer, sizeof(FILE_FS_DEVICE_INFORMATION) );

    //
    //  Set the output buffer
    //

    Buffer->DeviceType = FILE_DEVICE_NAMED_PIPE;

    //
    //  Adjust the length variable
    //

    *Length -= sizeof(FILE_FS_DEVICE_INFORMATION);

    //
    //  And return success to our caller
    //

    return STATUS_SUCCESS;
}


//
//  Internal support routine
//

NTSTATUS
NpQueryFsAttributeInfo (
    IN PFILE_FS_ATTRIBUTE_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query volume attribute call

Arguments:

    Buffer - Supplies a pointer to the output buffer where the information
        is to be returned

    Length - Supplies the length of the buffer in byte.  This variable
        upon return recieves the remaining bytes free in the buffer

Return Value:

    Status - Returns the status for the query

--*/

{
    ULONG BytesToCopy;

    NTSTATUS Status;

    PAGED_CODE();

    DebugTrace(0, Dbg, "NpQueryFsAttributeInfo...\n", 0);

    //
    //  Determine how much of the file system name will fit.
    //

    if ( (*Length - FIELD_OFFSET( FILE_FS_ATTRIBUTE_INFORMATION,
                                  FileSystemName[0] )) >= 8 ) {

        BytesToCopy = 8;
        *Length -= FIELD_OFFSET( FILE_FS_ATTRIBUTE_INFORMATION,
                                 FileSystemName[0] ) + 8;
        Status = STATUS_SUCCESS;

    } else {

        BytesToCopy = *Length - FIELD_OFFSET( FILE_FS_ATTRIBUTE_INFORMATION,
                                              FileSystemName[0]);
        *Length = 0;

        Status = STATUS_BUFFER_OVERFLOW;
    }

    //
    //  Set the output buffer
    //

    Buffer->FileSystemAttributes       = FILE_CASE_PRESERVED_NAMES;
    Buffer->MaximumComponentNameLength = MAXULONG;
    Buffer->FileSystemNameLength       = BytesToCopy;

    RtlCopyMemory( &Buffer->FileSystemName[0], L"NPFS", BytesToCopy );

    //
    //  And return success to our caller
    //

    return Status;
}

NTSTATUS
NpQueryFsVolumeInfo (
    IN PFILE_FS_VOLUME_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query volume info call

Arguments:

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned.

    Length - Supplies the length of the buffer in bytes.

Return Value:

    NTSTATUS - The result of this query.

--*/

{

#define NPFS_VOLUME_LABEL                L"NamedPipe"

    ULONG BytesToCopy;
    NTSTATUS Status;

    Status = STATUS_SUCCESS;

    Buffer->VolumeCreationTime.QuadPart = 0;
    Buffer->VolumeSerialNumber = 0;

    Buffer->SupportsObjects = FALSE;

    *Length -= FIELD_OFFSET( FILE_FS_VOLUME_INFORMATION, VolumeLabel[0] );
    //
    //  Check if the buffer we're given is long enough
    //

    BytesToCopy = sizeof (NPFS_VOLUME_LABEL) - sizeof (WCHAR);

    if (*Length < BytesToCopy) {

        BytesToCopy = *Length;

        Status = STATUS_BUFFER_OVERFLOW;
    }

    //
    //  Copy over what we can of the volume label, and adjust *Length
    //

    Buffer->VolumeLabelLength = BytesToCopy;

    if (BytesToCopy) {

        RtlCopyMemory( &Buffer->VolumeLabel[0],
                       NPFS_VOLUME_LABEL,
                       BytesToCopy );
    }

    *Length -= BytesToCopy;

    //
    //  Set our status and return to our caller
    //

    return Status;
}

NTSTATUS
NpQueryFsSizeInfo (
    IN PFILE_FS_SIZE_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query size info call

Arguments:

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned.

    Length - Supplies the length of the buffer in bytes.

Return Value:

    NTSTATUS - The result of this query.

--*/

{

    Buffer->TotalAllocationUnits.QuadPart = 0;
    Buffer->AvailableAllocationUnits.QuadPart = 0;
    Buffer->SectorsPerAllocationUnit = 1;
    Buffer->BytesPerSector = 1;

    *Length -= sizeof( FILE_FS_SIZE_INFORMATION );

    //
    //  Set our status and return to our caller
    //

    return STATUS_SUCCESS;
}

NTSTATUS
NpQueryFsFullSizeInfo (
    IN PFILE_FS_FULL_SIZE_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query full size info call

Arguments:

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned.

    Length - Supplies the length of the buffer in bytes.

Return Value:

    NTSTATUS - The result of this query.

--*/

{

    RtlZeroMemory( Buffer, sizeof(FILE_FS_FULL_SIZE_INFORMATION) );


    *Length -= sizeof(FILE_FS_FULL_SIZE_INFORMATION);

    //
    //  Set our status and return to our caller
    //

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\npfs\statesup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    StateSup.c

Abstract:

    This module implements the Named Pipe State Support routines

Author:

    Gary Kimura     [GaryKi]    30-Aug-1990

Revision History:

--*/

#include "NpProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (NPFS_BUG_CHECK_STATESUP)

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_STATESUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NpInitializePipeState)
#pragma alloc_text(PAGE, NpUninitializePipeState)
#pragma alloc_text(PAGE, NpSetListeningPipeState)
#pragma alloc_text(PAGE, NpSetConnectedPipeState)
#pragma alloc_text(PAGE, NpSetClosingPipeState)
#pragma alloc_text(PAGE, NpSetDisconnectedPipeState)
#endif

VOID
NpCancelListeningQueueIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


VOID
NpInitializePipeState (
    IN PCCB Ccb,
    IN PFILE_OBJECT ServerFileObject
    )

/*++

Routine Description:

    This routine initialize a named pipe instance to the disconnected state.

Arguments:

    Ccb - Supplies a pointer to the Ccb representing the pipe state

    ServerFileObject - Supplies a pointer to the server file object

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpInitializePipeState, Ccb = %08lx\n", Ccb);

    //
    //  Set the ccb and nonpaged ccb fields
    //

    Ccb->FileObject[ FILE_PIPE_SERVER_END ] = ServerFileObject;
    Ccb->NamedPipeState = FILE_PIPE_DISCONNECTED_STATE;

    //
    //  The file object contexts pointers.
    //

    NpSetFileObject (ServerFileObject,
                     Ccb,
                     Ccb->NonpagedCcb,
                     FILE_PIPE_SERVER_END);

    //
    //  and return to our caller
    //

    DebugTrace(-1, Dbg, "NpInitializePipeState -> VOID\n", 0);

    return;
}


VOID
NpUninitializePipeState (
    IN PCCB Ccb
    )

/*++

Routine Description:

    This routine initialize a named pipe instance to the disconnected state.

Arguments:

    Ccb - Supplies a pointer to the Ccb representing the pipe state

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpUninitializePipeState, Ccb = %08lx\n", Ccb);

    //
    //  The file object contexts pointers for our server to null
    //

    NpSetFileObject (Ccb->FileObject[ FILE_PIPE_SERVER_END ],
                     NULL,
                     NULL,
                     FILE_PIPE_SERVER_END);
    Ccb->FileObject[FILE_PIPE_SERVER_END] = NULL;


    //
    //  The file object contexts pointers for our client to null
    //

    NpSetFileObject (Ccb->FileObject[ FILE_PIPE_CLIENT_END ],
                     NULL,
                     NULL,
                     FILE_PIPE_CLIENT_END);

    Ccb->FileObject[FILE_PIPE_CLIENT_END] = NULL;

    //
    //  Set to null both pointers to file object.
    //

    Ccb->FileObject[FILE_PIPE_SERVER_END] = NULL;
    Ccb->FileObject[FILE_PIPE_CLIENT_END] = NULL;

    //
    //  and return to our caller
    //

    DebugTrace(-1, Dbg, "NpUninitializePipeState -> VOID\n", 0);

    return;
}


NTSTATUS
NpSetListeningPipeState (
    IN PCCB Ccb,
    IN PIRP Irp,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This routine sets a named pipe to the listening state.  This routine
    will either complete the IRP right away or put in the listening queue
    to be completed later.

Arguments:

    Ccb - Supplies a pointer to the Ccb representing the pipe state

    Irp - Supplies the Irp doing the listening operation

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS Status;

    DebugTrace(+1, Dbg, "NpSetListeningPipeState, Ccb = %08lx\n", Ccb);

    //
    //  Case on the current state of the named pipe
    //

    switch (Ccb->NamedPipeState) {

    case FILE_PIPE_DISCONNECTED_STATE:

        DebugTrace(0, Dbg, "Pipe was disconnected\n", 0);

        //
        //  Set the state to listening and check for any wait for named
        //  pipe requests.
        //

        Status = NpCancelWaiter (&NpVcb->WaitQueue,
                                 &Ccb->Fcb->FullFileName,
                                 STATUS_SUCCESS,
                                 DeferredList);
        if (!NT_SUCCESS (Status)) {
            break;
        }

        //
        //  If the completion mode is complete operation then we can
        //  complete this irp otherwise we need to enqueue the irp
        //  into the listening queue, and mark it pending.
        //

        if (Ccb->ReadCompletionMode[FILE_PIPE_SERVER_END].CompletionMode == FILE_PIPE_COMPLETE_OPERATION) {

            Ccb->NamedPipeState = FILE_PIPE_LISTENING_STATE;
            Status = STATUS_PIPE_LISTENING;

        } else {

            //
            //  Set the cancel routine and also check if the irp is already cancelled
            //
            IoSetCancelRoutine (Irp, NpCancelListeningQueueIrp);

            if (Irp->Cancel && IoSetCancelRoutine (Irp, NULL) != NULL) {
                Status = STATUS_CANCELLED;
            } else {
                Ccb->NamedPipeState = FILE_PIPE_LISTENING_STATE;
                IoMarkIrpPending (Irp);
                InsertTailList (&Ccb->ListeningQueue, &Irp->Tail.Overlay.ListEntry);
                Status = STATUS_PENDING;
            }
        }

        break;

    case FILE_PIPE_LISTENING_STATE:

        DebugTrace(0, Dbg, "Pipe was listening\n", 0);

        //
        //  If the completion mode is complete operation then we can
        //  complete this irp otherwise we need to enqueue the irp
        //  into the listening queue, and mark it pending.
        //

        if (Ccb->ReadCompletionMode[FILE_PIPE_SERVER_END].CompletionMode == FILE_PIPE_COMPLETE_OPERATION) {

            Status = STATUS_PIPE_LISTENING;

        } else {

            //
            //  Set the cancel routine and also check if the irp is already cancelled
            //

            IoSetCancelRoutine (Irp, NpCancelListeningQueueIrp);

            if (Irp->Cancel && IoSetCancelRoutine (Irp, NULL) != NULL) {
                Status = STATUS_CANCELLED;
            } else {
                IoMarkIrpPending (Irp);
                InsertTailList (&Ccb->ListeningQueue, &Irp->Tail.Overlay.ListEntry);
                Status = STATUS_PENDING;
            }
        }

        break;

    case FILE_PIPE_CONNECTED_STATE:

        DebugTrace(0, Dbg, "Pipe was connected\n", 0);

        Status = STATUS_PIPE_CONNECTED;

        break;

    case FILE_PIPE_CLOSING_STATE:

        DebugTrace(0, Dbg, "Pipe was closing\n", 0);

        Status = STATUS_PIPE_CLOSING;

        break;

    default:

        NpBugCheck( Ccb->NamedPipeState, 0, 0 );
    }

    //
    //  and return to our caller
    //

    DebugTrace(-1, Dbg, "NpSetListeningPipeState -> %08lx\n", Status);

    return Status;
}


NTSTATUS
NpSetConnectedPipeState (
    IN PCCB Ccb,
    IN PFILE_OBJECT ClientFileObject,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This routine sets the state of a named pipe to connected.

Arguments:

    Ccb - Supplies a pointer to the Ccb representing the pipe state

    ClientFileObject - Supplies the file object for the client that is
        doing the connect.

    DeferredList - List of IRP's to complete after we drop locks

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS Status;
    PNONPAGED_CCB NonpagedCcb;
    PIRP LocalIrp;

    DebugTrace(+1, Dbg, "NpSetConnectedPipeState, Ccb = %08lx\n", Ccb);

    //
    //  Save a pointer to the nonpaged ccb, we really need to do this now so when we
    //  complete our listening waiters we won't touch paged pool
    //

    NonpagedCcb = Ccb->NonpagedCcb;

    ASSERT (Ccb->NamedPipeState == FILE_PIPE_LISTENING_STATE);

    //
    //  Set the state of the pipe to connected and adjust the
    //  appropriate read mode and completion mode values
    //

    Ccb->NamedPipeState                                          = FILE_PIPE_CONNECTED_STATE;
    Ccb->ReadCompletionMode[FILE_PIPE_CLIENT_END].ReadMode       = FILE_PIPE_BYTE_STREAM_MODE;
    Ccb->ReadCompletionMode[FILE_PIPE_CLIENT_END].CompletionMode = FILE_PIPE_QUEUE_OPERATION;

    //
    //  Set our back pointer to the client file object and set the
    //  client file object context pointers
    //

    Ccb->FileObject[FILE_PIPE_CLIENT_END] = ClientFileObject;

    NpSetFileObject (ClientFileObject,
                     Ccb,
                     NonpagedCcb,
                     FILE_PIPE_CLIENT_END);

    //
    //  And complete any listening waiters
    //

    while (!IsListEmpty (&Ccb->ListeningQueue)) {
        PLIST_ENTRY Links;

        Links = RemoveHeadList (&Ccb->ListeningQueue);

        LocalIrp = CONTAINING_RECORD (Links, IRP, Tail.Overlay.ListEntry);

        //
        // Remove the cancel routine and detect if cancel is active. If it is leave the IRP to the
        // cancel routine.

        if (IoSetCancelRoutine (LocalIrp, NULL) != NULL) {
            NpDeferredCompleteRequest (LocalIrp, STATUS_SUCCESS, DeferredList);
        } else {
            InitializeListHead (&LocalIrp->Tail.Overlay.ListEntry);
        }
    }

    Status = STATUS_SUCCESS;

    return Status;
}


NTSTATUS
NpSetClosingPipeState (
    IN PCCB Ccb,
    IN PIRP Irp,
    IN NAMED_PIPE_END NamedPipeEnd,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This routine sets a pipe state to closing.  This routine will
    either complete the irp right away or put in on the data queue
    to be completed later.

Arguments:

    Ccb - Supplies a pointer to the Ccb representing the pipe state

    Irp - Supplies the Irp trying to do the close operation

    NamedPipeEnd - Indicates if the server or client is doing the transition

Return Value:

    NTSTATUS -

--*/

{
    NTSTATUS Status;

    PNONPAGED_CCB NonpagedCcb;

    PFCB Fcb;
    PIRP LocalIrp;
    KIRQL CancelIrql;

    PDATA_QUEUE ReadQueue;
    PDATA_QUEUE WriteQueue;

    PEVENT_TABLE_ENTRY Event;

    DebugTrace(+1, Dbg, "NpSetClosingPipeState, Ccb = %08lx\n", Ccb);

    Fcb = Ccb->Fcb;

    //
    //  Save a pointer to the nonpaged ccb, we really need to do this now so when we
    //  complete our listening waiters we won't touch paged pool
    //

    NonpagedCcb = Ccb->NonpagedCcb;

    //
    //  Case on the current state of the named pipe
    //

    switch (Ccb->NamedPipeState) {

    case FILE_PIPE_DISCONNECTED_STATE:

        DebugTrace(0, Dbg, "Pipe was disconnected\n", 0);

        ASSERT( NamedPipeEnd == FILE_PIPE_SERVER_END );

        //
        //  Pipe is disconnected, for safety sake we'll zero out the
        //  file objects context pointers to use
        //

        NpSetFileObject (Ccb->FileObject[ FILE_PIPE_SERVER_END ],
                         NULL,
                         NULL,
                         FILE_PIPE_SERVER_END);
        Ccb->FileObject[FILE_PIPE_SERVER_END] = NULL;

        NpSetFileObject (Ccb->FileObject[FILE_PIPE_CLIENT_END],
                         NULL,
                         NULL,
                         FILE_PIPE_CLIENT_END);
        Ccb->FileObject[FILE_PIPE_CLIENT_END] = NULL;

        //
        //  Close it we delete the instance, and possibly the Fcb if its
        //  open count is now zero.
        //

        NpDeleteCcb (Ccb, DeferredList);
        if (Fcb->OpenCount == 0) {

            NpDeleteFcb (Fcb, DeferredList);
        }

        Status = STATUS_SUCCESS;

        break;

    case FILE_PIPE_LISTENING_STATE:

        DebugTrace(0, Dbg, "Pipe was listening\n", 0);

        ASSERT( NamedPipeEnd == FILE_PIPE_SERVER_END );

        //
        //  Pipe in listening state, so complete all IRPs that are in the
        //  listening queue with a closing status, and then delete the
        //  instance and possibly the Fcb if its open count is now zero
        //

        //
        //  And complete any listening waiters
        //

        while (!IsListEmpty (&Ccb->ListeningQueue)) {
            PLIST_ENTRY Links;

            Links = RemoveHeadList (&Ccb->ListeningQueue);

            LocalIrp = CONTAINING_RECORD (Links, IRP, Tail.Overlay.ListEntry);

            //
            // Remove the cancel routine and detect if cancel is active. If it is leave the IRP to the
            // cancel routine.

            if (IoSetCancelRoutine (LocalIrp, NULL) != NULL) {
                NpDeferredCompleteRequest (LocalIrp, STATUS_PIPE_BROKEN, DeferredList);
            } else {
                InitializeListHead (&LocalIrp->Tail.Overlay.ListEntry);
            }
        }

        //
        //  For safety sake we'll zero out the file objects context
        //  pointers to use
        //

        NpSetFileObject (Ccb->FileObject[ FILE_PIPE_SERVER_END ],
                         NULL,
                         NULL,
                         FILE_PIPE_SERVER_END);
        Ccb->FileObject[FILE_PIPE_SERVER_END] = NULL;

        NpSetFileObject (Ccb->FileObject[FILE_PIPE_CLIENT_END],
                         NULL,
                         NULL,
                         FILE_PIPE_CLIENT_END);
        Ccb->FileObject[FILE_PIPE_CLIENT_END] = NULL;

        //
        //  Remove the ccb and possibly the Fcb
        //

        NpDeleteCcb (Ccb, DeferredList);
        if (Fcb->OpenCount == 0) {

            NpDeleteFcb (Fcb, DeferredList);
        }

        //
        //  And now complete the irp
        //

        Status = STATUS_SUCCESS;

        break;

    case FILE_PIPE_CONNECTED_STATE:

        //
        //  The pipe is connected so decide who is trying to do the close
        //  and then fall into common code
        //

        if (NamedPipeEnd == FILE_PIPE_SERVER_END) {

            DebugTrace(0, Dbg, "Pipe was connected, server doing close\n", 0);

            ReadQueue = &Ccb->DataQueue[FILE_PIPE_INBOUND];
            WriteQueue = &Ccb->DataQueue[FILE_PIPE_OUTBOUND];

            Event = NonpagedCcb->EventTableEntry[FILE_PIPE_CLIENT_END];

            //
            //  For safety sake we'll zero out the file objects context
            //  pointers to use
            //

            NpSetFileObject (Ccb->FileObject[ FILE_PIPE_SERVER_END],
                             NULL,
                             NULL,
                             FILE_PIPE_SERVER_END);
            Ccb->FileObject[FILE_PIPE_SERVER_END] = NULL;

        } else {

            DebugTrace(0, Dbg, "Pipe was connected, client doing close\n", 0);

            ReadQueue = &Ccb->DataQueue[FILE_PIPE_OUTBOUND];
            WriteQueue = &Ccb->DataQueue[FILE_PIPE_INBOUND];

            Event = NonpagedCcb->EventTableEntry[FILE_PIPE_SERVER_END];

            //
            //  For safety sake we'll zero out the file objects context
            //  pointers to use
            //

            NpSetFileObject (Ccb->FileObject[ FILE_PIPE_CLIENT_END],
                             NULL,
                             NULL,
                             FILE_PIPE_CLIENT_END);
            Ccb->FileObject[FILE_PIPE_CLIENT_END] = NULL;
        }

        //
        //  To do a close on a connected pipe we set its state to closing
        //  drain the read queue and drain reads on the write queue.
        //
        //
        //      Closing <---ReadQueue----  [ Remove all entries ]
        //      End
        //               ---WriteQueue---> [ Remove only read entries ]
        //

        Ccb->NamedPipeState = FILE_PIPE_CLOSING_STATE;

        while (!NpIsDataQueueEmpty (ReadQueue)) {

            if ((LocalIrp = NpRemoveDataQueueEntry (ReadQueue, FALSE, DeferredList)) != NULL) {

                NpDeferredCompleteRequest (LocalIrp, STATUS_PIPE_BROKEN, DeferredList);
            }
        }

        while (!NpIsDataQueueEmpty (WriteQueue) &&
               (WriteQueue->QueueState == ReadEntries)) {

            if ((LocalIrp = NpRemoveDataQueueEntry (WriteQueue, FALSE, DeferredList)) != NULL) {

                NpDeferredCompleteRequest (LocalIrp, STATUS_PIPE_BROKEN, DeferredList);
            }
        }

        Status = STATUS_SUCCESS;

        //
        //  Now signal the other sides event to show that something has
        //  happened
        //

        NpSignalEventTableEntry( Event );

        break;

    case FILE_PIPE_CLOSING_STATE:

        //
        //  The pipe is closing so decide who is trying to complete the close
        //  and then fall into common code
        //

        if (NamedPipeEnd == FILE_PIPE_SERVER_END) {

            DebugTrace(0, Dbg, "Pipe was closing, server doing close\n", 0);

            ReadQueue = &Ccb->DataQueue[ FILE_PIPE_INBOUND ];

            //
            //  For safety sake we'll zero out the file objects context
            //  pointers to use
            //

            NpSetFileObject (Ccb->FileObject[FILE_PIPE_SERVER_END],
                             NULL,
                             NULL,
                             FILE_PIPE_SERVER_END);
            Ccb->FileObject[FILE_PIPE_SERVER_END] = NULL;

            NpSetFileObject (Ccb->FileObject[FILE_PIPE_CLIENT_END],
                             NULL,
                             NULL,
                             FILE_PIPE_CLIENT_END);
            Ccb->FileObject[FILE_PIPE_CLIENT_END] = NULL;

        } else {

            DebugTrace(0, Dbg, "Pipe was closing, client doing close\n", 0);

            ReadQueue = &Ccb->DataQueue[ FILE_PIPE_OUTBOUND ];

            //
            //  For safety sake we'll zero out the file objects context
            //  pointers to use
            //

            NpSetFileObject( Ccb->FileObject[ FILE_PIPE_SERVER_END ],
                             NULL,
                             NULL,
                             FILE_PIPE_SERVER_END );
            Ccb->FileObject[ FILE_PIPE_SERVER_END ] = NULL;

            NpSetFileObject( Ccb->FileObject[ FILE_PIPE_CLIENT_END ],
                             NULL,
                             NULL,
                             FILE_PIPE_CLIENT_END );
            Ccb->FileObject[ FILE_PIPE_CLIENT_END ] = NULL;
        }

        //
        //  To do a close on a closing pipe we drain the read queue of
        //  all its entries, delete the instance, and possibly delete the
        //  Fcb if its open count is now zero.
        //
        //
        //      Previously  <-----Closed-----   Closing
        //      Closed                          End
        //      End          ----ReadQueue--->
        //

        while (!NpIsDataQueueEmpty( ReadQueue )) {

            if ((LocalIrp = NpRemoveDataQueueEntry( ReadQueue, FALSE, DeferredList )) != NULL) {

                NpDeferredCompleteRequest( LocalIrp, STATUS_PIPE_BROKEN, DeferredList );
            }
        }

        NpUninitializeSecurity (Ccb);

        if (Ccb->ClientInfo != NULL) {
            NpFreePool (Ccb->ClientInfo);
            Ccb->ClientInfo = NULL;
        }

        NpDeleteCcb( Ccb, DeferredList );
        if (Fcb->OpenCount == 0) {

            NpDeleteFcb( Fcb, DeferredList );
        }

        Status = STATUS_SUCCESS;

        break;

    default:

        NpBugCheck( Ccb->NamedPipeState, 0, 0 );
    }

    //
    //  and return to our caller
    //

    DebugTrace(-1, Dbg, "NpSetClosingPipeState -> %08lx\n", Status);

    return Status;
}


NTSTATUS
NpSetDisconnectedPipeState (
    IN PCCB Ccb,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This routine sets a pipe state to disconnected, only the server is
    allowed to do this transition

Arguments:

    Ccb - Supplies a pointer to the Ccb representing the pipe instance

    DeferredList - List of IRPs to complete later after we drop the locks

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS Status;

    PNONPAGED_CCB NonpagedCcb;

    PIRP Irp;

    PDATA_QUEUE Inbound;
    PDATA_QUEUE Outbound;
    PEVENT_TABLE_ENTRY ClientEvent;


    DebugTrace(+1, Dbg, "NpSetDisconnectedPipeState, Ccb = %08lx\n", Ccb);


    //
    //  Save a pointer to the nonpaged ccb, we really need to do this now so when we
    //  complete our listening waiters we won't touch paged pool
    //

    NonpagedCcb = Ccb->NonpagedCcb;

    //
    //  Case on the current state of the named pipe
    //

    switch (Ccb->NamedPipeState) {

    case FILE_PIPE_DISCONNECTED_STATE:

        DebugTrace(0, Dbg, "Pipe already disconnected\n", 0);

        //
        //  pipe already disconnected so there is no work for us to do
        //

        Status = STATUS_PIPE_DISCONNECTED;

        break;

    case FILE_PIPE_LISTENING_STATE:

        DebugTrace(0, Dbg, "Pipe was listening\n", 0);

        //
        //  Pipe in listening state, so complete all IRPs that are in the
        //  listening queue with a disconnected status
        //

        while (!IsListEmpty( &Ccb->ListeningQueue )) {
            PLIST_ENTRY Links;

            Links = RemoveHeadList( &Ccb->ListeningQueue );

            Irp = CONTAINING_RECORD( Links, IRP, Tail.Overlay.ListEntry );

            //
            // Remove the cancel routine and detect if cancel is active. If it is leave the IRP to the
            // cancel routine.

            if (IoSetCancelRoutine( Irp, NULL ) != NULL) {
                NpDeferredCompleteRequest( Irp, STATUS_PIPE_DISCONNECTED, DeferredList );
            } else {
                InitializeListHead (&Irp->Tail.Overlay.ListEntry);
            }
        }

        Status = STATUS_SUCCESS;

        break;

    case FILE_PIPE_CONNECTED_STATE:

        DebugTrace(0, Dbg, "Pipe was connected\n", 0);

        Inbound = &Ccb->DataQueue[ FILE_PIPE_INBOUND ];
        Outbound = &Ccb->DataQueue[ FILE_PIPE_OUTBOUND ];
        ClientEvent = NonpagedCcb->EventTableEntry[ FILE_PIPE_CLIENT_END ];

        //
        //  Pipe is connected so we need to discard all of the data queues
        //  and complete any of their IRPs with status disconnected.
        //

        while (!NpIsDataQueueEmpty( Inbound )) {

            if ((Irp = NpRemoveDataQueueEntry( Inbound, FALSE, DeferredList )) != NULL) {

                NpDeferredCompleteRequest( Irp, STATUS_PIPE_DISCONNECTED, DeferredList );
            }
        }

        while (!NpIsDataQueueEmpty( Outbound )) {

            if ((Irp = NpRemoveDataQueueEntry( Outbound, FALSE, DeferredList )) != NULL) {

                NpDeferredCompleteRequest( Irp, STATUS_PIPE_DISCONNECTED, DeferredList );
            }
        }

        //
        //  Signal the client event and then remove it from the pipe
        //

        NpSignalEventTableEntry( ClientEvent );

        NpDeleteEventTableEntry( &NpVcb->EventTable, ClientEvent );
        NonpagedCcb->EventTableEntry[ FILE_PIPE_CLIENT_END ] = NULL;

        //
        //  Disable the client's file object
        //

        NpSetFileObject( Ccb->FileObject[ FILE_PIPE_CLIENT_END ],
                         NULL,
                         NULL,
                         FILE_PIPE_CLIENT_END );
        Ccb->FileObject[ FILE_PIPE_CLIENT_END ] = NULL;

        NpUninitializeSecurity (Ccb);

        if (Ccb->ClientInfo != NULL) {
            NpFreePool (Ccb->ClientInfo);
            Ccb->ClientInfo = NULL;
        }

        Status = STATUS_SUCCESS;

        break;

    case FILE_PIPE_CLOSING_STATE:

        DebugTrace(0, Dbg, "Pipe was closing\n", 0);

        Inbound = &Ccb->DataQueue[ FILE_PIPE_INBOUND ];
        Outbound = &Ccb->DataQueue[ FILE_PIPE_OUTBOUND ];
        ClientEvent = NonpagedCcb->EventTableEntry[ FILE_PIPE_CLIENT_END ];

        //
        //  Pipe is closing (this had to have been done by the client) we
        //  need to discard all of the data queues (only the inbound can have
        //  entries) and complete any of their IRPs with status disconnected.
        //
        //
        //      Server  <----Inbound----    Client
        //      End                         End
        //               ----Closed----->
        //

        while (!NpIsDataQueueEmpty( Inbound )) {

            if ((Irp = NpRemoveDataQueueEntry( Inbound, FALSE, DeferredList )) != NULL) {

                NpDeferredCompleteRequest( Irp, STATUS_PIPE_DISCONNECTED, DeferredList );
            }
        }

        ASSERT( NpIsDataQueueEmpty( Outbound ) );

        //
        //  The client event should already be gone but for safety sake
        //  we'll make sure its gone.
        //

        NpDeleteEventTableEntry( &NpVcb->EventTable, ClientEvent );
        NonpagedCcb->EventTableEntry[ FILE_PIPE_CLIENT_END ] = NULL;

        //
        //  Also if it's still connected, disable the client's file object
        //

        NpSetFileObject( Ccb->FileObject[ FILE_PIPE_CLIENT_END ],
                         NULL,
                         NULL,
                         FILE_PIPE_CLIENT_END );
        Ccb->FileObject[ FILE_PIPE_CLIENT_END ] = NULL;

        NpUninitializeSecurity (Ccb);

        if (Ccb->ClientInfo != NULL) {
            NpFreePool (Ccb->ClientInfo);
            Ccb->ClientInfo = NULL;
        }

        Status = STATUS_SUCCESS;

        break;

    default:

        NpBugCheck( Ccb->NamedPipeState, 0, 0 );
    }

    //
    //  Set the state to disconnected
    //

    Ccb->NamedPipeState = FILE_PIPE_DISCONNECTED_STATE;

    //
    //  and return to our caller
    //

    DebugTrace(-1, Dbg, "NpSetDisconnectedPipeState -> %08lx\n", Status);

    return Status;
}


//
//  Local support routine
//

VOID
NpCancelListeningQueueIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the cancel function for an IRP saved in a listening
    queue

Arguments:

    DeviceObject - ignored

    Irp - Supplies the Irp being cancelled.  A pointer to the ccb
        structure is stored in the information field of the Irp Iosb
        field.

Return Value:

    None.

--*/

{
    UNREFERENCED_PARAMETER( DeviceObject );


    IoReleaseCancelSpinLock( Irp->CancelIrql );

    //
    //  Get exclusive access to the named pipe vcb so we can now do our work
    //

    FsRtlEnterFileSystem();
    NpAcquireExclusiveVcb();

    RemoveEntryList (&Irp->Tail.Overlay.ListEntry);

    NpReleaseVcb();
    FsRtlExitFileSystem();

    NpCompleteRequest (Irp, STATUS_CANCELLED);
    //
    //  And return to our caller
    //

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\npfs\waitsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    WaitSup.c

Abstract:

    This module implements the Wait for Named Pipe support routines.

Author:

    Gary Kimura     [GaryKi]    30-Aug-1990

Revision History:

--*/

#include "NpProcs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_WAITSUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NpInitializeWaitQueue)
#pragma alloc_text(PAGE, NpUninitializeWaitQueue)
#endif


//
//  Local procedures and structures
//

typedef struct _WAIT_CONTEXT {
    PIRP Irp;
    KDPC Dpc;
    KTIMER Timer;
    PWAIT_QUEUE WaitQueue;
    UNICODE_STRING TranslatedString;
    PFILE_OBJECT FileObject;
} WAIT_CONTEXT;
typedef WAIT_CONTEXT *PWAIT_CONTEXT;



VOID
NpInitializeWaitQueue (
    IN PWAIT_QUEUE WaitQueue
    )

/*++

Routine Description:

    This routine initializes the wait for named pipe queue.

Arguments:

    WaitQueue - Supplies a pointer to the list head being initialized

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpInitializeWaitQueue, WaitQueue = %08lx\n", WaitQueue);

    //
    //  Initialize the List head
    //

    InitializeListHead( &WaitQueue->Queue );

    //
    //  Initialize the Wait Queue's spinlock
    //

    KeInitializeSpinLock( &WaitQueue->SpinLock );

    //
    //  and return to our caller
    //

    DebugTrace(-1, Dbg, "NpInitializeWaitQueue -> VOID\n", 0);

    return;
}


VOID
NpUninitializeWaitQueue (
    IN PWAIT_QUEUE WaitQueue
    )

/*++

Routine Description:

    This routine uninitializes the wait for named pipe queue.

Arguments:

    WaitQueue - Supplies a pointer to the list head being uninitialized

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpInitializeWaitQueue, WaitQueue = %08lx\n", WaitQueue);

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "NpInitializeWaitQueue -> VOID\n", 0);

    return;
}


NTSTATUS
NpAddWaiter (
    IN PWAIT_QUEUE WaitQueue,
    IN LARGE_INTEGER DefaultTimeOut,
    IN PIRP Irp,
    IN PUNICODE_STRING TranslatedString
    )

/*++

Routine Description:

    This routine adds a new "wait for named pipe" IRP to the wait queue.
    After calling this function the caller nolonger can access the IRP

Arguments:

    WaitQueue - Supplies the wait queue being used

    DefaultTimeOut - Supplies the default time out to use if one is
        not supplied in the Irp

    Irp - Supplies a pointer to the wait Irp

    TranslatedString - If not NULL points to the translated string

Return Value:

    None.

--*/

{
    KIRQL OldIrql;
    PWAIT_CONTEXT Context;
    PFILE_PIPE_WAIT_FOR_BUFFER WaitForBuffer;
    LARGE_INTEGER Timeout;
    ULONG i;
    NTSTATUS status;
    PIO_STACK_LOCATION IrpSp;

    DebugTrace(+1, Dbg, "NpAddWaiter, WaitQueue = %08lx\n", WaitQueue);

    IrpSp = IoGetCurrentIrpStackLocation (Irp);
    //
    //  Allocate a dpc and timer structure and initialize them
    //

    Context = NpAllocateNonPagedPoolWithQuota( sizeof(WAIT_CONTEXT), 'wFpN' );
    if (Context == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    KeInitializeDpc( &Context->Dpc, NpTimerDispatch, Context );

    KeInitializeTimer( &Context->Timer );

    if (TranslatedString) {

        Context->TranslatedString = (*TranslatedString);

    } else {

        Context->TranslatedString.Length = 0;
        Context->TranslatedString.Buffer = NULL;
    }

    Context->WaitQueue = WaitQueue;
    Context->Irp = Irp;


    //
    //  Figure out our timeout value
    //

    WaitForBuffer = (PFILE_PIPE_WAIT_FOR_BUFFER)Irp->AssociatedIrp.SystemBuffer;

    if (WaitForBuffer->TimeoutSpecified) {

        Timeout = WaitForBuffer->Timeout;

    } else {

        Timeout = DefaultTimeOut;
    }

    //
    //  Upcase the name of the pipe we are waiting for
    //

    for (i = 0; i < WaitForBuffer->NameLength/sizeof(WCHAR); i += 1) {

        WaitForBuffer->Name[i] = RtlUpcaseUnicodeChar(WaitForBuffer->Name[i]);
    }

    NpIrpWaitQueue(Irp) = WaitQueue;
    NpIrpWaitContext(Irp) = Context;

    //
    //  Acquire the spinlock
    //
    KeAcquireSpinLock( &WaitQueue->SpinLock, &OldIrql );

    //
    //  Now set the cancel routine for the irp and check if it has been cancelled.
    //

    IoSetCancelRoutine( Irp, NpCancelWaitQueueIrp );
    if (Irp->Cancel && IoSetCancelRoutine( Irp, NULL ) != NULL) {
        status = STATUS_CANCELLED;
    } else {
        //
        //  Now insert this new entry into the Wait Queue
        //
        InsertTailList( &WaitQueue->Queue, &Irp->Tail.Overlay.ListEntry );
        IoMarkIrpPending (Irp);
        //
        // The DPC routine may run without an IRP if it gets completed before it runs. To keep the WaitQueue
        // valid we need a file object reference. This is an unload issue becuase the wait queue is in the VCB.
        //
        Context->FileObject = IrpSp->FileObject;
        ObReferenceObject (IrpSp->FileObject);
        //
        //  And set the timer to go off
        //
        (VOID)KeSetTimer( &Context->Timer, Timeout, &Context->Dpc );
        Context = NULL;
        status = STATUS_PENDING;
    }

    //
    //  Release the spinlock
    //

    KeReleaseSpinLock( &WaitQueue->SpinLock, OldIrql );

    if (Context != NULL) {
        NpFreePool (Context);
    }

    //
    //  And now return to our caller
    //

    DebugTrace(-1, Dbg, "NpAddWaiter -> VOID\n", 0);

    return status;
}


NTSTATUS
NpCancelWaiter (
    IN PWAIT_QUEUE WaitQueue,
    IN PUNICODE_STRING NameOfPipe,
    IN NTSTATUS Completionstatus,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This procedure cancels all waiters that are waiting for the named
    pipe to reach the listening state.  The corresponding IRPs are completed
    with Completionstatus.

Arguments:

    WaitQueue - Supplies the wait queue being modified

    NameOfPipe - Supplies the name of the named pipe (device relative)
        that has just reached the listening state.

    CompletionStatus - Status to complete IRPs with

    DeferredList - List or IRPs to complete once we drop locks

Return Value:

    None.

--*/

{
    KIRQL OldIrql;
    PLIST_ENTRY Links;
    PIRP Irp;
    PFILE_PIPE_WAIT_FOR_BUFFER WaitForBuffer;
    PWAIT_CONTEXT Context, ContextList= NULL;
    ULONG i;
    BOOLEAN SuccessfullMatch = FALSE;
    UNICODE_STRING NonPagedNameOfPipe;

    DebugTrace(+1, Dbg, "NpCancelWaiter, WaitQueue = %08lx\n", WaitQueue);

    //
    //  Capture the name of pipe before we grab the spinlock, and upcase it
    //

    NonPagedNameOfPipe.Buffer = NpAllocateNonPagedPool( NameOfPipe->Length, 'tFpN' );
    if (NonPagedNameOfPipe.Buffer == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    NonPagedNameOfPipe.Length = 0;
    NonPagedNameOfPipe.MaximumLength = NameOfPipe->Length;

    (VOID) RtlUpcaseUnicodeString( &NonPagedNameOfPipe, NameOfPipe, FALSE );

    //
    //  Acquire the spinlock
    //
    KeAcquireSpinLock( &WaitQueue->SpinLock, &OldIrql );

    //
    //  For each waiting irp check if the name matches
    //

    for (Links = WaitQueue->Queue.Flink;
         Links != &WaitQueue->Queue;
         Links = Links->Flink) {

        Irp = CONTAINING_RECORD( Links, IRP, Tail.Overlay.ListEntry );
        WaitForBuffer = (PFILE_PIPE_WAIT_FOR_BUFFER)Irp->AssociatedIrp.SystemBuffer;
        Context = NpIrpWaitContext(Irp);

        //
        //  Check if this Irp matches the one we've been waiting for
        //  First check the lengths for equality, and then compare
        //  the strings.  They match if we exit the inner loop with
        //  i >= name length.
        //

        SuccessfullMatch = FALSE;

        if (Context->TranslatedString.Length ) {
            if (NonPagedNameOfPipe.Length == Context->TranslatedString.Length) {

                if (RtlEqualMemory(Context->TranslatedString.Buffer, NonPagedNameOfPipe.Buffer, NonPagedNameOfPipe.Length)) {

                    SuccessfullMatch = TRUE;

                }
            }

        } else  {

            if (((USHORT)(WaitForBuffer->NameLength + sizeof(WCHAR))) == NonPagedNameOfPipe.Length) {

                for (i = 0; i < WaitForBuffer->NameLength/sizeof(WCHAR); i += 1) {

                    if (WaitForBuffer->Name[i] != NonPagedNameOfPipe.Buffer[i+1]) {

                        break;
                    }
                }

                if (i >= WaitForBuffer->NameLength/sizeof(WCHAR)) {

                    SuccessfullMatch = TRUE;
                }
            }
        }

        if (SuccessfullMatch) {

            Links = Links->Blink;
            RemoveEntryList( &Irp->Tail.Overlay.ListEntry );
            //
            // Attempt to stop the timer. If its already running then it must be stalled before obtaining
            // this spinlock or it would have removed this item from the list. Break the link between the timer
            // context and the IRP in this case and let it run on.
            //

            if (KeCancelTimer( &Context->Timer )) {
                 //
                 // Time got stopped. The context gets freed below after we drop the lock.
                 //
                 Context->WaitQueue = (PWAIT_QUEUE) ContextList;
                 ContextList = Context;
            } else {
                //
                // Break the link between the timer and the IRP
                //
                Context->Irp = NULL;
                NpIrpWaitContext(Irp) = NULL;
            }

            //
            // Remove cancelation. If its already running then let it complete the IRP.
            //
            if (IoSetCancelRoutine( Irp, NULL ) != NULL) {
                Irp->IoStatus.Information = 0;
                NpDeferredCompleteRequest (Irp, Completionstatus, DeferredList);
            } else {
                //
                // Cancel is already running. Let it complete this IRP but let it know its orphaned.
                //
                NpIrpWaitContext(Irp) = NULL;
            }
        }
    }

    //
    //  Release the spinlock
    //
    KeReleaseSpinLock( &WaitQueue->SpinLock, OldIrql );

    NpFreePool (NonPagedNameOfPipe.Buffer);

    while (ContextList != NULL) {
        Context = ContextList;
        ContextList = (PWAIT_CONTEXT) Context->WaitQueue;
        ObDereferenceObject (Context->FileObject);
        NpFreePool( Context );
    }

    DebugTrace(-1, Dbg, "NpCancelWaiter -> VOID\n", 0);
    //
    //  And now return to our caller
    //

    return STATUS_SUCCESS;
}


//
//  Local support routine
//

VOID
NpTimerDispatch(
    IN PKDPC Dpc,
    IN PVOID Contxt,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This routine is called whenever a timer on a wait queue Irp goes off

Arguments:

    Dpc - Ignored

    Contxt - Supplies a pointer to the context whose timer went off

    SystemArgument1 - Ignored

    SystemArgument2 - Ignored

Return Value:

    none.

--*/

{
    PIRP Irp;
    KIRQL OldIrql;
    PLIST_ENTRY Links;
    PWAIT_CONTEXT Context;
    PWAIT_QUEUE WaitQueue;

    UNREFERENCED_PARAMETER( Dpc );
    UNREFERENCED_PARAMETER( SystemArgument1 );
    UNREFERENCED_PARAMETER( SystemArgument2 );

    Context = (PWAIT_CONTEXT)Contxt;
    WaitQueue = Context->WaitQueue;

    KeAcquireSpinLock( &WaitQueue->SpinLock, &OldIrql );

    Irp = Context->Irp;
    if (Irp != NULL) {
        RemoveEntryList( &Irp->Tail.Overlay.ListEntry );
        if (IoSetCancelRoutine (Irp, NULL) == NULL) {
           //
           // Cancel started running. Let it complete the IRP but show its orphaned
           //
           NpIrpWaitContext(Irp) = NULL;
           Irp = NULL;
        }
    }

    KeReleaseSpinLock( &WaitQueue->SpinLock, OldIrql );

    if (Irp != NULL) {
        NpCompleteRequest( Irp, STATUS_IO_TIMEOUT );
    }

    //
    // Remove the file reference now we have finished with the wait queue.
    //
    ObDereferenceObject (Context->FileObject);

    //
    //  Deallocate the context
    //
    NpFreePool (Context);

    //
    //  And now return to our caller
    //

    return;
}


//
//  Local Support routine
//

VOID
NpCancelWaitQueueIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called to cancel a wait queue irp

Arguments:

    DeviceObject - Ignored

    Irp - Supplies the Irp being cancelled.  The Iosb.Status field in the irp
        points to the wait queue

Return Value:

    none.

--*/

{
    PWAIT_QUEUE WaitQueue;
    KIRQL OldIrql;
    PLIST_ENTRY Links;
    PWAIT_CONTEXT Context;

    UNREFERENCED_PARAMETER( DeviceObject );

    IoReleaseCancelSpinLock( Irp->CancelIrql );

    //
    //  The status field is used to store a pointer to the wait queue
    //  containing this irp
    //
    WaitQueue = NpIrpWaitQueue(Irp);
    //
    //  Get the spinlock proctecting the wait queue
    //

    KeAcquireSpinLock( &WaitQueue->SpinLock, &OldIrql );

    Context = NpIrpWaitContext(Irp);
    if (Context != NULL) {
        RemoveEntryList (&Irp->Tail.Overlay.ListEntry);
        if (!KeCancelTimer( &Context->Timer )) {
            //
            // Timer is already running. Break the link between the timer and the IRP as this thread is going to complete it.
            //
            Context->Irp = NULL;
            Context = NULL;
        }
    }

    KeReleaseSpinLock( &WaitQueue->SpinLock, OldIrql );

    if (Context) {
        ObDereferenceObject (Context->FileObject);
        NpFreePool (Context);
    }
    Irp->IoStatus.Information = 0;
    NpCompleteRequest( Irp, STATUS_CANCELLED );
    //
    //  And return to our caller
    //

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\npfs\writesup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    WriteSup.c

Abstract:

    This module implements the Write support routine.  This is a common
    write function that is called by write, unbuffered write, and transceive.

Author:

    Gary Kimura     [GaryKi]    21-Sep-1990

Revision History:

--*/

#include "NpProcs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_WRITESUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NpWriteDataQueue)
#endif


NTSTATUS
NpWriteDataQueue (
    IN PDATA_QUEUE WriteQueue,
    IN READ_MODE ReadMode,
    IN PUCHAR WriteBuffer,
    IN ULONG WriteLength,
    IN NAMED_PIPE_TYPE PipeType,
    OUT PULONG WriteRemaining,
    IN PCCB Ccb,
    IN NAMED_PIPE_END NamedPipeEnd,
    IN PETHREAD UserThread,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This procedure writes data from the write buffer into read entries in
    the write queue.  It will also dequeue entries in the queue as necessary.

Arguments:

    WriteQueue - Provides the write queue to process.

    ReadMode - Supplies the read mode of read entries in the write queue.

    WriteBuffer - Provides the buffer from which to read the data.

    WriteLength  - Provides the length, in bytes, of WriteBuffer.

    PipeType - Indicates if type of pipe (i.e., message or byte stream).

    WriteRemaining - Receives the number of bytes remaining to be transfered
        that were not completed by this call.  If the operation wrote
        everything then is value is set to zero.

    Ccb - Supplies the ccb for the operation

    NamedPipeEnd - Supplies the end of the pipe doing the write

    UserThread - Supplies the user thread

    DeferredList - List of IRPs to be completed after we drop the locks

Return Value:

    BOOLEAN - TRUE if the operation wrote everything and FALSE otherwise.
        Note that a zero byte message that hasn't been written will return
        a function result of FALSE and WriteRemaining of zero.

--*/

{
    NTSTATUS Result;

    BOOLEAN WriteZeroMessage;

    PDATA_ENTRY DataEntry;

    PUCHAR ReadBuffer;
    ULONG ReadLength;

    ULONG AmountToCopy;
    NTSTATUS Status;
    PSECURITY_CLIENT_CONTEXT SecurityContext;
    BOOLEAN DoneSecurity=FALSE;
    PIO_STACK_LOCATION IrpSp;
    BOOLEAN FreeBuffer;

    PIRP ReadIrp;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpWriteDataQueue\n", 0);
    DebugTrace( 0, Dbg, "WriteQueue   = %08lx\n", WriteQueue);
    DebugTrace( 0, Dbg, "WriteBuffer  = %08lx\n", WriteBuffer);
    DebugTrace( 0, Dbg, "WriteLength  = %08lx\n", WriteLength);
    DebugTrace( 0, Dbg, "PipeType     = %08lx\n", PipeType);
    DebugTrace( 0, Dbg, "Ccb          = %08lx\n", Ccb);
    DebugTrace( 0, Dbg, "NamedPipeEnd = %08lx\n", NamedPipeEnd);
    DebugTrace( 0, Dbg, "UserThread   = %08lx\n", UserThread);

    //
    //  Determine if we are to write a zero byte message, and initialize
    //  WriteRemaining
    //

    *WriteRemaining = WriteLength;

    if ((PipeType == FILE_PIPE_MESSAGE_TYPE) && (WriteLength == 0)) {

        WriteZeroMessage = TRUE;

    } else {

        WriteZeroMessage = FALSE;
    }

    //
    //  Now while the write queue has some read entries in it and
    //  there is some remaining write data or this is a write zero message
    //  then we'll do the following main loop
    //

    for (DataEntry = NpGetNextRealDataQueueEntry( WriteQueue, DeferredList );

         (NpIsDataQueueReaders(WriteQueue) &&
          ((*WriteRemaining > 0) || WriteZeroMessage));

         DataEntry = NpGetNextRealDataQueueEntry( WriteQueue, DeferredList )) {

        ReadLength = DataEntry->DataSize;

        DebugTrace(0, Dbg, "Top of main loop...\n", 0);
        DebugTrace(0, Dbg, "ReadBuffer      = %08lx\n", ReadBuffer);
        DebugTrace(0, Dbg, "ReadLength      = %08lx\n", ReadLength);
        DebugTrace(0, Dbg, "*WriteRemaining = %08lx\n", *WriteRemaining);

        //
        //  Check if this is a ReadOverflow Operation and if so then also check
        //  that the read will succeed otherwise complete this read with
        //  buffer overflow and continue on.
        //

        IrpSp = IoGetCurrentIrpStackLocation( DataEntry->Irp );

        if (IrpSp->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL &&
            IrpSp->Parameters.FileSystemControl.FsControlCode == FSCTL_PIPE_INTERNAL_READ_OVFLOW) {

            if ((ReadLength < WriteLength) || WriteZeroMessage) {

                ReadIrp = NpRemoveDataQueueEntry( WriteQueue, TRUE, DeferredList );
                if (ReadIrp != NULL) {
                    NpDeferredCompleteRequest( ReadIrp, STATUS_BUFFER_OVERFLOW, DeferredList );
                }
                continue;
            }
        }


        if (DataEntry->DataEntryType == Unbuffered) {
            DataEntry->Irp->Overlay.AllocationSize.QuadPart = WriteQueue->BytesInQueue - WriteQueue->BytesInQueue;
        }


        //
        //  copy data from the write buffer at write offset to the
        //  read buffer at read offset by the mininum of write remaining
        //  or read remaining
        //

        AmountToCopy = (*WriteRemaining < ReadLength ? *WriteRemaining
                                                        : ReadLength);

        if (DataEntry->DataEntryType != Unbuffered && AmountToCopy > 0) {
            ReadBuffer = NpAllocateNonPagedPool (AmountToCopy, 'RFpN');
            if (ReadBuffer == NULL) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }
            FreeBuffer = TRUE;
        } else {
            ReadBuffer = DataEntry->Irp->AssociatedIrp.SystemBuffer;
            FreeBuffer = FALSE;
        }

        try {

            RtlCopyMemory( ReadBuffer,
                           &WriteBuffer[ WriteLength - *WriteRemaining ],
                           AmountToCopy );

        } except (EXCEPTION_EXECUTE_HANDLER) {
            if (FreeBuffer) {
                NpFreePool (ReadBuffer);
            }
            return GetExceptionCode ();
        }

        //
        // Done update the security in the CCB multiple times. It won't change.
        //
        if (DoneSecurity == FALSE) {
            DoneSecurity = TRUE;
            //
            //  Now update the security fields in the nonpaged ccb
            //
            Status = NpGetClientSecurityContext (NamedPipeEnd,
                                                 Ccb,
                                                 UserThread,
                                                 &SecurityContext);
            if (!NT_SUCCESS(Status)) {
                if (FreeBuffer) {
                    NpFreePool (ReadBuffer);
                }
                return Status;
            }

            if (SecurityContext != NULL) {
                NpFreeClientSecurityContext (Ccb->SecurityClientContext);
                Ccb->SecurityClientContext = SecurityContext;
            }
        }

        //
        //  Now we've done with the read entry so remove it from the
        //  write queue, get its irp, and fill in the information field
        //  to be the bytes that we've transferred into the read buffer.
        //

        ReadIrp = NpRemoveDataQueueEntry( WriteQueue, TRUE, DeferredList );
        if (ReadIrp == NULL) {
            if (FreeBuffer) {
                NpFreePool (ReadBuffer);
            }
            continue;
        }

        //
        //  Update the Write remaining counts
        //

        *WriteRemaining -= AmountToCopy;

        ReadIrp->IoStatus.Information = AmountToCopy;
        if (FreeBuffer) {
            ReadIrp->AssociatedIrp.SystemBuffer = ReadBuffer;
            ReadIrp->Flags |= IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER | IRP_INPUT_OPERATION;
        }


        if (*WriteRemaining == 0) {

            DebugTrace(0, Dbg, "Finished up the write remaining\n", 0);

            //**** ASSERT( ReadIrp->IoStatus.Information != 0 );

            NpDeferredCompleteRequest( ReadIrp, STATUS_SUCCESS, DeferredList );

            WriteZeroMessage = FALSE;

        } else {

            //
            //  There is still some space in the write buffer to be
            //  written out, but before we can handle that (in the
            //  following if statement) we need to finish the read.
            //  If the read is message mode then we've overflowed the
            //  buffer otherwise we completed successfully
            //

            if (ReadMode == FILE_PIPE_MESSAGE_MODE) {

                DebugTrace(0, Dbg, "Read buffer Overflow\n", 0);

                NpDeferredCompleteRequest( ReadIrp, STATUS_BUFFER_OVERFLOW, DeferredList );

            } else {

                DebugTrace(0, Dbg, "Read buffer byte stream done\n", 0);

                //**** ASSERT( ReadIrp->IoStatus.Information != 0 );

                NpDeferredCompleteRequest( ReadIrp, STATUS_SUCCESS, DeferredList );
            }
        }
    }

    DebugTrace(0, Dbg, "Finished loop...\n", 0);
    DebugTrace(0, Dbg, "*WriteRemaining  = %08lx\n", *WriteRemaining);
    DebugTrace(0, Dbg, "WriteZeroMessage = %08lx\n", WriteZeroMessage);

    //
    //  At this point we've finished off all of the read entries in the
    //  queue and we might still have something left to write.  If that
    //  is the case then we'll set our result to FALSE otherwise we're
    //  done so we'll return TRUE.
    //

    if ((*WriteRemaining > 0) || (WriteZeroMessage)) {

        ASSERT( !NpIsDataQueueReaders( WriteQueue ));

        Result = STATUS_MORE_PROCESSING_REQUIRED;

    } else {


        Result = STATUS_SUCCESS;
    }

    DebugTrace(-1, Dbg, "NpWriteDataQueue -> %08lx\n", Result);
    return Result;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\allocsup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    AllocSup.c

Abstract:

    This module implements the general file stream allocation & truncation
    routines for Ntfs

Author:

    Tom Miller      [TomM]          15-Jul-1991

Revision History:

--*/

#include "NtfsProc.h"

//
//  Local debug trace level
//

#define Dbg                              (DEBUG_TRACE_ALLOCSUP)

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('aFtN')

ULONG NtfsExtendFactor = 4;

//
//  Internal support routines
//

VOID
NtfsDeleteAllocationInternal (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PSCB Scb,
    IN VCN StartingVcn,
    IN VCN EndingVcn,
    IN BOOLEAN LogIt
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsPreloadAllocation)
#pragma alloc_text(PAGE, NtfsAddAllocation)
#pragma alloc_text(PAGE, NtfsAddSparseAllocation)
#pragma alloc_text(PAGE, NtfsAllocateAttribute)
#pragma alloc_text(PAGE, NtfsBuildMappingPairs)
#pragma alloc_text(PAGE, NtfsCheckForReservedClusters)
#pragma alloc_text(PAGE, NtfsDeleteAllocation)
#pragma alloc_text(PAGE, NtfsDeleteAllocationInternal)
#pragma alloc_text(PAGE, NtfsDeleteReservedBitmap)
#pragma alloc_text(PAGE, NtfsGetHighestVcn)
#pragma alloc_text(PAGE, NtfsGetSizeForMappingPairs)
#pragma alloc_text(PAGE, NtfsIsRangeAllocated)
#pragma alloc_text(PAGE, NtfsReallocateRange)
#endif


ULONG
NtfsPreloadAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PSCB Scb,
    IN VCN StartingVcn,
    IN VCN EndingVcn
    )

/*++

Routine Description:

    This routine assures that all ranges of the Mcb are loaded in the specified
    Vcn range

Arguments:

    Scb - Specifies which Scb is to be preloaded

    StartingVcn - Specifies the first Vcn to be loaded

    EndingVcn - Specifies the last Vcn to be loaded

Return Value:

    Number of ranges spanned by the load request.

--*/

{
    VCN CurrentVcn, LastCurrentVcn;
    LCN Lcn;
    LONGLONG Count;
    PVOID RangePtr;
    ULONG RunIndex;
    ULONG RangesLoaded = 0;

    PAGED_CODE();

    //
    //  Start with starting Vcn
    //

    CurrentVcn = StartingVcn;

    //
    //  Always load the nonpaged guys from the front, so we don't
    //  produce an Mcb with a "known hole".
    //

    if (FlagOn(Scb->Fcb->FcbState, FCB_STATE_NONPAGED)) {
        CurrentVcn = 0;
    }

    //
    //  Loop until it's all loaded.
    //

    while (CurrentVcn <= EndingVcn) {

        //
        //  Remember this CurrentVcn as a way to know when we have hit the end
        //  (stopped making progress).
        //

        LastCurrentVcn = CurrentVcn;

        //
        //  Load range with CurrentVcn, and if it is not there, get out.
        //

        (VOID)NtfsLookupAllocation( IrpContext, Scb, CurrentVcn, &Lcn, &Count, &RangePtr, &RunIndex );

        //
        //  If preloading the mft flush and purge it afterwards. This is to
        //  remove any partial pages we generated above if any mft record for
        //  the mft described others records in the same page after it
        //

        if (FlagOn( IrpContext->Vcb->VcbState, VCB_STATE_PRELOAD_MFT )) {

            IO_STATUS_BLOCK IoStatus;

            CcFlushCache( &Scb->NonpagedScb->SegmentObject,
                          NULL,
                          0,
                          &IoStatus );

            if (!NT_SUCCESS( IoStatus.Status )) {

                NtfsNormalizeAndRaiseStatus( IrpContext,
                                             IoStatus.Status,
                                             STATUS_UNEXPECTED_IO_ERROR );
            }

            CcPurgeCacheSection( &Scb->NonpagedScb->SegmentObject,
                                 (PLARGE_INTEGER)NULL,
                                 0,
                                 FALSE );
        }

        //
        //  Find out how many runs there are in this range
        //

        if (!NtfsNumberOfRunsInRange(&Scb->Mcb, RangePtr, &RunIndex) || (RunIndex == 0)) {
            break;
        }

        //
        //  Get the highest run in this range and calculate the next Vcn beyond this range.
        //

        NtfsGetNextNtfsMcbEntry( &Scb->Mcb, &RangePtr, RunIndex - 1, &CurrentVcn, &Lcn, &Count );

        CurrentVcn += Count;

        //
        //  If we are making no progress, we must have hit the end of the allocation,
        //  and we are done.
        //

        if (CurrentVcn == LastCurrentVcn) {
            break;
        }

        RangesLoaded += 1;
    }

    return RangesLoaded;
}


BOOLEAN
NtfsLookupAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PSCB Scb,
    IN VCN Vcn,
    OUT PLCN Lcn,
    OUT PLONGLONG ClusterCount,
    OUT PVOID *RangePtr OPTIONAL,
    OUT PULONG RunIndex OPTIONAL
    )

/*++

Routine Description:

    This routine looks up the given Vcn for an Scb, and returns whether it
    is allocated and how many contiguously allocated (or deallocated) Lcns
    exist at that point.

Arguments:

    Scb - Specifies which attribute the lookup is to occur on.

    Vcn - Specifies the Vcn to be looked up.

    Lcn - If returning TRUE, returns the Lcn that the specified Vcn is mapped
          to.  If returning FALSE, the return value is undefined.

    ClusterCount - If returning TRUE, returns the number of contiguously allocated
                   Lcns exist beginning at the Lcn returned.  If returning FALSE,
                   specifies the number of unallocated Vcns exist beginning with
                   the specified Vcn.

    RangePtr - If specified, we return the range index for the start of the mapping.

    RunIndex - If specified, we return the run index within the range for the start of the mapping.

Return Value:

    BOOLEAN - TRUE if the input Vcn has a corresponding Lcn and
        FALSE otherwise.

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT Context;
    PATTRIBUTE_RECORD_HEADER Attribute;

    VCN HighestCandidate;

    BOOLEAN Found;
    BOOLEAN EntryAdded;

    VCN CapturedLowestVcn;
    VCN CapturedHighestVcn;

    PVCB Vcb = Scb->Fcb->Vcb;
    BOOLEAN McbMutexAcquired = FALSE;
    LONGLONG AllocationClusters;
    BOOLEAN MountInProgress;


    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( Scb );

    DebugTrace( +1, Dbg, ("NtfsLookupAllocation\n") );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("Vcn = %I64x\n", Vcn) );

    MountInProgress = ((IrpContext->TopLevelIrpContext->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL) &&
                       (IrpContext->TopLevelIrpContext->MinorFunction == IRP_MN_MOUNT_VOLUME));

    //
    //  First try to look up the allocation in the mcb, and return the run
    //  from there if we can.  Also, if we are doing restart, just return
    //  the answer straight from the Mcb, because we cannot read the disk.
    //  We also do this for the Mft if the volume has been mounted as the
    //  Mcb for the Mft should always represent the entire file.
    //

    HighestCandidate = MAXLONGLONG;
    if ((Found = NtfsLookupNtfsMcbEntry( &Scb->Mcb, Vcn, Lcn, ClusterCount, NULL, NULL, RangePtr, RunIndex ))

          ||

        (Scb == Vcb->MftScb

            &&

         ((!MountInProgress) ||

         //
         //  we will not try to load the mft hole during mount while preloading in any
         //  recursive faults
         //

          (FlagOn( Vcb->VcbState, VCB_STATE_PRELOAD_MFT) &&
           (!NtfsIsTopLevelNtfs( IrpContext )))))

          ||

        FlagOn( Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS )) {

        //
        //  If not found (beyond the end of the Mcb), we will return the
        //  count to the largest representable Lcn.
        //

        if ( !Found ) {

            *ClusterCount = MAXLONGLONG - Vcn;

        //
        //  Test if we found a hole in the allocation.  In this case
        //  Found will be TRUE and the Lcn will be the UNUSED_LCN.
        //  We only expect this case at restart.
        //

        } else if (*Lcn == UNUSED_LCN) {

            //
            //  If the Mcb package returned UNUSED_LCN, because of a hole, then
            //  we turn this into FALSE.
            //

            Found = FALSE;
        }

        ASSERT( !Found ||
                (*Lcn != 0) ||
                (NtfsEqualMftRef( &Scb->Fcb->FileReference, &BootFileReference )) ||
                (NtfsEqualMftRef( &Scb->Fcb->FileReference, &VolumeFileReference )));

        DebugTrace( -1, Dbg, ("NtfsLookupAllocation -> %02lx\n", Found) );

        return Found;
    }

    PAGED_CODE();

    //
    //  Prepare for looking up attribute records to get the retrieval
    //  information.
    //

    CapturedLowestVcn = MAXLONGLONG;
    NtfsInitializeAttributeContext( &Context );

    //
    //  Make sure we have the main resource acquired shared so that the
    //  attributes in the file record are not moving around.  We blindly
    //  use Wait = TRUE.  Most of the time when we go to the disk for I/O
    //  (and thus need mapping) we are synchronous, and otherwise, the Mcb
    //  is virtually always loaded anyway and we do not get here.
    //

    NtfsAcquireResourceShared( IrpContext, Scb, TRUE );

    try {

        //
        //  Lookup the attribute record for this Scb.
        //

        NtfsLookupAttributeForScb( IrpContext, Scb, &Vcn, &Context );
        Attribute = NtfsFoundAttribute( &Context );

        ASSERT( !NtfsIsAttributeResident(Attribute) );

        if (FlagOn( Scb->ScbState, SCB_STATE_FILE_SIZE_LOADED )) {
            AllocationClusters = LlClustersFromBytesTruncate( Vcb, Scb->Header.AllocationSize.QuadPart );
        } else {
            ASSERT( Attribute->Form.Nonresident.LowestVcn == 0);
            AllocationClusters = LlClustersFromBytesTruncate( Vcb, Attribute->Form.Nonresident.AllocatedLength );
        }

        //
        //  The desired Vcn is not currently in the Mcb.  We will loop to lookup all
        //  the allocation, and we need to make sure we cleanup on the way out.
        //
        //  It is important to note that if we ever optimize this lookup to do random
        //  access to the mapping pairs, rather than sequentially loading up the Mcb
        //  until we get the Vcn he asked for, then NtfsDeleteAllocation will have to
        //  be changed.
        //

        //
        //  Acquire exclusive access to the mcb to keep others from looking at
        //  it while it is not fully loaded.  Otherwise they might see a hole
        //  while we're still filling up the mcb
        //

        if (!FlagOn(Scb->Fcb->FcbState, FCB_STATE_NONPAGED)) {
            NtfsAcquireNtfsMcbMutex( &Scb->Mcb );
            McbMutexAcquired = TRUE;
        }

        //
        //  Store run information in the Mcb until we hit the last Vcn we are
        //  interested in, or until we cannot find any more attribute records.
        //

        while(TRUE) {

            VCN CurrentVcn;
            LCN CurrentLcn;
            LONGLONG Change;
            PCHAR ch;
            ULONG VcnBytes;
            ULONG LcnBytes;

            //
            //  If we raise here either there is some discrepancy between memory
            //  structures and on disk values or the on-disk value is completely corrupted
            //
            //  We Check:
            //  1) Verify the highest and lowest Vcn values on disk are valid.
            //  2) our starting Vcn sits within this range.
            //  3) the on-disk allocation matches the in memory value in the Scb
            //

            if ((Attribute->Form.Nonresident.LowestVcn < 0) ||
                (Attribute->Form.Nonresident.LowestVcn - 1 > Attribute->Form.Nonresident.HighestVcn) ||
                (Vcn < Attribute->Form.Nonresident.LowestVcn) ||
                (Attribute->Form.Nonresident.HighestVcn >= AllocationClusters)) {

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
            }

            //
            //  Define the new range.
            //

            NtfsDefineNtfsMcbRange( &Scb->Mcb,
                                    CapturedLowestVcn = Attribute->Form.Nonresident.LowestVcn,
                                    CapturedHighestVcn = Attribute->Form.Nonresident.HighestVcn,
                                    McbMutexAcquired );

            //
            //  Implement the decompression algorithm, as defined in ntfs.h.
            //

            HighestCandidate = Attribute->Form.Nonresident.LowestVcn;
            CurrentLcn = 0;
            ch = (PCHAR)Attribute + Attribute->Form.Nonresident.MappingPairsOffset;

            //
            //  Loop to process mapping pairs.
            //

            EntryAdded = FALSE;
            while (!IsCharZero(*ch)) {

                //
                //  Set Current Vcn from initial value or last pass through loop.
                //

                CurrentVcn = HighestCandidate;

                //
                //  VCNs should never be negative.
                //

                if (CurrentVcn < 0) {

                    ASSERT( FALSE );
                    NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
                }

                //
                //  Extract the counts from the two nibbles of this byte.
                //

                VcnBytes = *ch & 0xF;
                LcnBytes = *ch++ >> 4;

                //
                //  Extract the Vcn change (use of RtlCopyMemory works for little-Endian)
                //  and update HighestCandidate.
                //

                Change = 0;

                //
                //  The file is corrupt if there are 0 or more than 8 Vcn change bytes,
                //  more than 8 Lcn change bytes, or if we would walk off the end of
                //  the record, or a Vcn change is negative.
                //

                if (((ULONG)(VcnBytes - 1) > 7) || (LcnBytes > 8) ||
                    ((ch + VcnBytes + LcnBytes + 1) > (PCHAR)Add2Ptr(Attribute, Attribute->RecordLength)) ||
                    IsCharLtrZero(*(ch + VcnBytes - 1))) {

                    ASSERT( FALSE );
                    NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
                }
                RtlCopyMemory( &Change, ch, VcnBytes );
                ch += VcnBytes;
                HighestCandidate = HighestCandidate + Change;

                //
                //  Extract the Lcn change and update CurrentLcn.
                //

                if (LcnBytes != 0) {

                    Change = 0;
                    if (IsCharLtrZero(*(ch + LcnBytes - 1))) {
                        Change = Change - 1;
                    }
                    RtlCopyMemory( &Change, ch, LcnBytes );
                    ch += LcnBytes;
                    CurrentLcn = CurrentLcn + Change;

                    //
                    // Now add it in to the mcb.
                    //

                    if ((CurrentLcn >= 0) && (LcnBytes != 0)) {

                        LONGLONG ClustersToAdd;
                        ClustersToAdd = HighestCandidate - CurrentVcn;

                        //
                        //  Now try to add the current run.  We never expect this
                        //  call to return false.
                        //

                        ASSERT( ((ULONG)CurrentLcn) != 0xffffffff );

#ifdef NTFS_CHECK_BITMAP
                        //
                        //  Make sure these bits are allocated in our copy of the bitmap.
                        //

                        if ((Vcb->BitmapCopy != NULL) &&
                            !NtfsCheckBitmap( Vcb,
                                              (ULONG) CurrentLcn,
                                              (ULONG) ClustersToAdd,
                                              TRUE )) {

                            NtfsBadBitmapCopy( IrpContext, (ULONG) CurrentLcn, (ULONG) ClustersToAdd );
                        }
#endif
                        if (!NtfsAddNtfsMcbEntry( &Scb->Mcb,
                                                  CurrentVcn,
                                                  CurrentLcn,
                                                  ClustersToAdd,
                                                  McbMutexAcquired )) {

                            ASSERTMSG( "Unable to add entry to Mcb\n", FALSE );

                            NtfsRaiseStatus( IrpContext,
                                             STATUS_FILE_CORRUPT_ERROR,
                                             NULL,
                                             Scb->Fcb );
                        }

                        EntryAdded = TRUE;
                    }
                }
            }

            //
            //  Make sure that at least the Mcb gets loaded.
            //

            if (!EntryAdded) {
                NtfsAddNtfsMcbEntry( &Scb->Mcb,
                                     CapturedLowestVcn,
                                     UNUSED_LCN,
                                     1,
                                     McbMutexAcquired );
            }

            if ((Vcn < HighestCandidate) ||
                (!NtfsLookupNextAttributeForScb( IrpContext, Scb, &Context ))) {
                break;
            } else {
                Attribute = NtfsFoundAttribute( &Context );
                ASSERT( !NtfsIsAttributeResident(Attribute) );
            }
        }

        //
        //  Now free the mutex and lookup in the Mcb while we still own
        //  the resource.
        //

        if (McbMutexAcquired) {
            NtfsReleaseNtfsMcbMutex( &Scb->Mcb );
            McbMutexAcquired = FALSE;
        }

        if (NtfsLookupNtfsMcbEntry( &Scb->Mcb, Vcn, Lcn, ClusterCount, NULL, NULL, RangePtr, RunIndex )) {

            Found = (BOOLEAN)(*Lcn != UNUSED_LCN);

            if (Found) { ASSERT_LCN_RANGE_CHECKING( Vcb, (*Lcn + *ClusterCount) ); }

        } else {

            Found = FALSE;

            //
            //  At the end of file, we pretend there is one large hole!
            //

            if (HighestCandidate >=
                LlClustersFromBytes(Vcb, Scb->Header.AllocationSize.QuadPart)) {
                HighestCandidate = MAXLONGLONG;
            }

            //
            //  If we're asked to lookup a vcn but the highest vcn we found on disk
            //  is less than it - than the file record is corrupt - even if there is
            //  a hole at the end it must be written in the mapping pairs on disk
            //

            if (HighestCandidate <= Vcn) {
                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, &Scb->Fcb->FileReference, Scb->Fcb );
            }

            *ClusterCount = HighestCandidate - Vcn;
        }

    } finally {

        DebugUnwind( NtfsLookupAllocation );

        //
        //  If this is an error case then we better unload what we've just
        //  loaded
        //

        if (AbnormalTermination() &&
            (CapturedLowestVcn != MAXLONGLONG) ) {

            NtfsUnloadNtfsMcbRange( &Scb->Mcb,
                                    CapturedLowestVcn,
                                    CapturedHighestVcn,
                                    FALSE,
                                    McbMutexAcquired );
        }

        //
        //  In all cases we free up the mcb that we locked before entering
        //  the try statement
        //

        if (McbMutexAcquired) {
            NtfsReleaseNtfsMcbMutex( &Scb->Mcb );
        }

        NtfsReleaseResource( IrpContext, Scb );

        //
        // Cleanup the attribute context on the way out.
        //

        NtfsCleanupAttributeContext( IrpContext, &Context );
    }

    ASSERT( !Found ||
            (*Lcn != 0) ||
            (NtfsEqualMftRef( &Scb->Fcb->FileReference, &BootFileReference )) ||
            (NtfsEqualMftRef( &Scb->Fcb->FileReference, &VolumeFileReference )));

    DebugTrace( 0, Dbg, ("Lcn < %0I64x\n", *Lcn) );
    DebugTrace( 0, Dbg, ("ClusterCount < %0I64x\n", *ClusterCount) );
    DebugTrace( -1, Dbg, ("NtfsLookupAllocation -> %02lx\n", Found) );

    return Found;
}


BOOLEAN
NtfsIsRangeAllocated (
    IN PSCB Scb,
    IN VCN StartVcn,
    IN VCN FinalCluster,
    IN BOOLEAN RoundToSparseUnit,
    OUT PLONGLONG ClusterCount
    )

/*++

Routine Description:

    This routine is called on a sparse file to test the status of a range of the
    file.  Ntfs will return whether the range is allocated and also a known value
    for the length of the allocation.  It is possible that the range extends
    beyond this point but another call needs to be made to check it.

    Our caller needs to verify that the Mcb is loaded in this range i.e precall NtfsPreLoadAllocation

Arguments:

    Scb - Scb for the file to check.  This should be a sparse file.

    StartVcn - Vcn within the range to check first.

    FinalCluster - Trim the clusters found so we don't go beyond this point.

    RoundToSparseUnit - If TRUE the range is rounded up to VCB->SparseFileUnit == 0x10000
                        so you may get a range returned as allocated which contain
                        a partial sparse area depending on the compression unit.

    ClusterCount - Address to store the count of clusters of a known state.

Return Value:

    BOOLEAN - TRUE if the range is allocated, FALSE otherwise.

--*/

{
    BOOLEAN AllocatedRange;
    VCN ThisVcn;
    VCN ThisLcn;
    VCN ThisClusterCount;
    PVOID RangePtr;
    ULONG RunIndex;

    ULONG VcnClusterOffset = 0;
    VCN FoundClusterCount = 0;


    PAGED_CODE();

    //
    //  Assert that the file is sparse, non-resident and we are within file size.
    //

    ASSERT( FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE ));
    ASSERT( !FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT ));

    //
    //  Move the starting point back to a sparse file boundary.
    //

    ThisVcn = StartVcn;

    if (RoundToSparseUnit) {
        VcnClusterOffset = ((PLARGE_INTEGER) &ThisVcn)->LowPart & (Scb->Vcb->SparseFileClusters - 1);
        ((PLARGE_INTEGER) &ThisVcn)->LowPart &= ~(Scb->Vcb->SparseFileClusters - 1);
    }

    //
    //  Lookup the allocation at that position.
    //

    AllocatedRange = NtfsLookupNtfsMcbEntry( &Scb->Mcb,
                                             ThisVcn,
                                             &ThisLcn,
                                             &ThisClusterCount,
                                             NULL,
                                             NULL,
                                             &RangePtr,
                                             &RunIndex );

    //
    //  If the range has no mapping then it is entirely sparse.
    //

    if (!AllocatedRange) {

        ThisClusterCount = MAXLONGLONG;

    //
    //  If the block is not allocated and the length of the run is not enough
    //  clusters for a sparse file unit then look to make sure the block
    //  is fully deallocated.
    //

    } else if (ThisLcn == UNUSED_LCN) {

        AllocatedRange = FALSE;

        while (TRUE) {

            FoundClusterCount += ThisClusterCount;
            ThisVcn += ThisClusterCount;
            ThisClusterCount = 0;

            //
            //  Check successive runs to extend the hole.
            //

            if (ThisVcn >= FinalCluster) {

                break;
            }

            RunIndex += 1;
            if (!NtfsGetSequentialMcbEntry( &Scb->Mcb,
                                            &RangePtr,
                                            RunIndex,
                                            &ThisVcn,
                                            &ThisLcn,
                                            &ThisClusterCount )) {

                //
                //  The file is deallocated from here to the end of the Mcb.
                //  Treat this as a large hole.
                //

                ThisClusterCount = MAXLONGLONG - FoundClusterCount;
                break;
            }

            //
            //  If the range is allocated and we haven't found a full sparse unit
            //  then mark the block as allocated.  If we have at lease one sparse
            //  file unit then trim the hole back to the nearest sparse file
            //  unit boundary.
            //

            if (ThisLcn != UNUSED_LCN) {

                if (RoundToSparseUnit) {
                    if (FoundClusterCount < Scb->Fcb->Vcb->SparseFileClusters) {

                        //
                        //  Set our variables to indicate we are at the start of a fully
                        //  allocated sparse block.
                        //

                        ThisVcn -= FoundClusterCount;
                        ThisClusterCount += FoundClusterCount;
                        FoundClusterCount = 0;

                        AllocatedRange = TRUE;

                    } else {

                        ThisClusterCount = 0;
                        ((PLARGE_INTEGER) &FoundClusterCount)->LowPart &= ~(Scb->Vcb->SparseFileClusters - 1);
                    }
                }

                break;
            }
        }
    }

    //
    //  If we have an allocated block then find all of the contiguous allocated
    //  blocks we can.
    //

    if (AllocatedRange) {

        while (TRUE) {

            if (RoundToSparseUnit) {

                //
                //  Round the clusters found to a sparse file unit and update
                //  the next vcn and count of clusters found.
                //

                ThisClusterCount = BlockAlign( ThisClusterCount, (LONG)Scb->Fcb->Vcb->SparseFileClusters );
            }

            ThisVcn += ThisClusterCount;
            FoundClusterCount += ThisClusterCount;

            //
            //  Break out if we are past our final target or the beginning of the
            //  next range is not allocated.
            //

            if ((ThisVcn >= FinalCluster) ||
                !NtfsLookupNtfsMcbEntry( &Scb->Mcb,
                                         ThisVcn,
                                         &ThisLcn,
                                         &ThisClusterCount,
                                         NULL,
                                         NULL,
                                         &RangePtr,
                                         &RunIndex ) ||
                (ThisLcn == UNUSED_LCN)) {

                ThisClusterCount = 0;
                break;
            }
        }
    }

    //
    //  Trim the clusters found to either a sparse file unit or the input final
    //  cluster value.
    //

    *ClusterCount = ThisClusterCount + FoundClusterCount - (LONGLONG) VcnClusterOffset;

    if ((FinalCluster - StartVcn) < *ClusterCount) {

        *ClusterCount = FinalCluster - StartVcn;
    }

    return AllocatedRange;
}


BOOLEAN
NtfsAllocateAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN ATTRIBUTE_TYPE_CODE AttributeTypeCode,
    IN PUNICODE_STRING AttributeName OPTIONAL,
    IN USHORT AttributeFlags,
    IN BOOLEAN AllocateAll,
    IN BOOLEAN LogIt,
    IN LONGLONG Size,
    IN PATTRIBUTE_ENUMERATION_CONTEXT NewLocation OPTIONAL
    )

/*++

Routine Description:

    This routine creates a new attribute and allocates space for it, either in a
    file record, or as a nonresident attribute.

Arguments:

    Scb - Scb for the attribute.

    AttributeTypeCode - Attribute type code to be created.

    AttributeName - Optional name for the attribute.

    AttributeFlags - Flags to be stored in the attribute record for this attribute.

    AllocateAll - Specified as TRUE if all allocation should be allocated,
                  even if we have to break up the transaction.

    LogIt - Most callers should specify TRUE, to have the change logged.  However,
            we can specify FALSE if we are creating a new file record, and
            will be logging the entire new file record.

    Size - Size in bytes to allocate for the attribute.

    NewLocation - If specified, this is the location to store the attribute.

Return Value:

    FALSE - if the attribute was created, but not all of the space was allocated
            (this can only happen if Scb was not specified)
    TRUE - if the space was allocated.

--*/

{
    BOOLEAN UninitializeOnClose = FALSE;
    BOOLEAN NewLocationSpecified;
    ATTRIBUTE_ENUMERATION_CONTEXT Context;
    LONGLONG ClusterCount, SavedClusterCount;
    BOOLEAN FullAllocation;
    PFCB Fcb = Scb->Fcb;
    LONGLONG Delta = NtfsResidentStreamQuota( Fcb->Vcb );

    PAGED_CODE();

    //
    //  Either there is no compression taking place or the attribute
    //  type code allows compression to be specified in the header.
    //  $INDEX_ROOT is a special hack to store the inherited-compression
    //  flag.
    //

    ASSERT( (AttributeFlags == 0) ||
            (AttributeTypeCode == $INDEX_ROOT) ||
            NtfsIsTypeCodeCompressible( AttributeTypeCode ));

    //
    //  If the file is being created compressed, then we need to round its
    //  size to a compression unit boundary.
    //

    if ((Scb->CompressionUnit != 0) &&
        (Scb->Header.NodeTypeCode == NTFS_NTC_SCB_DATA)) {

        Size = BlockAlign( Size, (LONG)Scb->CompressionUnit );
    }

    //
    //  Prepare for looking up attribute records to get the retrieval
    //  information.
    //

    if (ARGUMENT_PRESENT( NewLocation )) {

        NewLocationSpecified = TRUE;

    } else {

        NtfsInitializeAttributeContext( &Context );
        NewLocationSpecified = FALSE;
        NewLocation = &Context;
    }

    try {

        //
        //  If the FILE_SIZE_LOADED flag is not set, then this Scb is for
        //  an attribute that does not yet exist on disk.  We will put zero
        //  into all of the sizes fields and set the flags indicating that
        //  Scb is valid.  NOTE - This routine expects both FILE_SIZE_LOADED
        //  and HEADER_INITIALIZED to be both set or both clear.
        //

        ASSERT( BooleanFlagOn( Scb->ScbState, SCB_STATE_FILE_SIZE_LOADED )
                ==  BooleanFlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED ));

        if (!FlagOn( Scb->ScbState, SCB_STATE_FILE_SIZE_LOADED )) {

            Scb->ValidDataToDisk =
            Scb->Header.AllocationSize.QuadPart =
            Scb->Header.FileSize.QuadPart =
            Scb->Header.ValidDataLength.QuadPart = 0;

            SetFlag( Scb->ScbState, SCB_STATE_FILE_SIZE_LOADED |
                                    SCB_STATE_HEADER_INITIALIZED |
                                    SCB_STATE_UNINITIALIZE_ON_RESTORE );

            UninitializeOnClose = TRUE;
        }

        //
        //  Now snapshot this Scb.  We use a try-finally so we can uninitialize
        //  the scb if neccessary.
        //

        NtfsSnapshotScb( IrpContext, Scb );

        UninitializeOnClose = FALSE;

        //
        //  First allocate the space he wants.
        //

        SavedClusterCount =
        ClusterCount = LlClustersFromBytes(Fcb->Vcb, Size);

        Scb->TotalAllocated = 0;

        if (Size != 0) {

            ASSERT( NtfsIsExclusiveScb( Scb ));

            Scb->ScbSnapshot->LowestModifiedVcn = 0;
            Scb->ScbSnapshot->HighestModifiedVcn = MAXLONGLONG;

            NtfsAllocateClusters( IrpContext,
                                  Fcb->Vcb,
                                  Scb,
                                  (LONGLONG)0,
                                  (BOOLEAN)!NtfsIsTypeCodeUserData( AttributeTypeCode ),
                                  ClusterCount,
                                  NULL,
                                  &ClusterCount );

            //
            //  Account for any new clusters in the allocation.
            //

            Delta += LlBytesFromClusters( Fcb->Vcb, ClusterCount );
        }

        //
        //  Make sure the owner is allowed to have this space.
        //

        if (FlagOn( Scb->ScbState, SCB_STATE_SUBJECT_TO_QUOTA )) {

            ASSERT( NtfsIsTypeCodeSubjectToQuota( Scb->AttributeTypeCode ));

            NtfsConditionallyUpdateQuota( IrpContext,
                                          Fcb,
                                          &Delta,
                                          LogIt,
                                          TRUE );
        }

        //
        //  Now create the attribute.  Remember if this routine
        //  cut the allocation because of logging problems.
        //

        FullAllocation = NtfsCreateAttributeWithAllocation( IrpContext,
                                                            Scb,
                                                            AttributeTypeCode,
                                                            AttributeName,
                                                            AttributeFlags,
                                                            LogIt,
                                                            NewLocationSpecified,
                                                            NewLocation );

        if (AllocateAll &&
            (!FullAllocation ||
             (ClusterCount < SavedClusterCount))) {

            //
            //  If we are creating the attribute, then we only need to pass a
            //  file object below if we already cached it ourselves, such as
            //  in the case of ConvertToNonresident.
            //

            NtfsAddAllocation( IrpContext,
                               Scb->FileObject,
                               Scb,
                               ClusterCount,
                               (SavedClusterCount - ClusterCount),
                               FALSE,
                               NULL );

            //
            //  Show that we allocated all of the space.
            //

            ClusterCount = SavedClusterCount;
            FullAllocation = TRUE;
        }

    } finally {

        DebugUnwind( NtfsAllocateAttribute );

        //
        //  Cleanup the attribute context on the way out.
        //

        if (!NewLocationSpecified) {

            NtfsCleanupAttributeContext( IrpContext, &Context );
        }

        //
        //  Clear out the Scb if it was uninitialized to begin with.
        //

        if (UninitializeOnClose) {

            ClearFlag( Scb->ScbState, SCB_STATE_FILE_SIZE_LOADED |
                                      SCB_STATE_HEADER_INITIALIZED |
                                      SCB_STATE_UNINITIALIZE_ON_RESTORE );
        }
    }

    return (FullAllocation && (SavedClusterCount <= ClusterCount));
}


VOID
NtfsAddAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN OUT PSCB Scb,
    IN VCN StartingVcn,
    IN LONGLONG ClusterCount,
    IN LOGICAL AskForMore,
    IN OUT PCCB CcbForWriteExtend OPTIONAL
    )

/*++

Routine Description:

    This routine adds allocation to an existing nonresident attribute.  None of
    the allocation is allowed to already exist, as this would make error recovery
    too difficult.  The caller must insure that he only asks for space not already
    allocated.

Arguments:

    FileObject - FileObject for the Scb

    Scb - Scb for the attribute needing allocation

    StartingVcn - First Vcn to be allocated.

    ClusterCount - Number of clusters to allocate.

    AskForMore - Indicates if we want to ask for extra allocation.

    CcbForWriteExtend - Use the WriteExtendCount in this Ccb to determine the number of times
        this file has been write extended.  Use this in combination with AskForMore to
        determine how much more to ask for.

Return Value:

    None.

--*/

{
    LONGLONG DesiredClusterCount;

    ATTRIBUTE_ENUMERATION_CONTEXT Context;
    BOOLEAN Extending;
    BOOLEAN AllocateAll;


    PVCB Vcb = IrpContext->Vcb;

    LONGLONG LlTemp1;
    LONGLONG LlTemp2;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( Scb );
    ASSERT_EXCLUSIVE_SCB( Scb );

    DebugTrace( +1, Dbg, ("NtfsAddAllocation\n") );

    //
    //  Determine if we must allocate in one shot or if partial results are allowed.
    //

    if (NtfsIsTypeCodeUserData( Scb->AttributeTypeCode ) &&
        NtfsSegmentNumber( &Scb->Fcb->FileReference ) >= FIRST_USER_FILE_NUMBER) {

        AllocateAll = FALSE;

    } else {

        AllocateAll = TRUE;

    }


    //
    //  We cannot add space in this high level routine during restart.
    //  Everything we can use is in the Mcb.
    //

    if (FlagOn(Scb->Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS)) {

        DebugTrace( -1, Dbg, ("NtfsAddAllocation (Nooped for Restart) -> VOID\n") );

        return;
    }

    //
    //  We limit the user to 32 bits for the clusters unless the file is
    //  sparse.  For sparse files we limit ourselves to 63 bits for the file size.
    //

    LlTemp1 = ClusterCount + StartingVcn;

    if (!FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

        if ((((PLARGE_INTEGER)&ClusterCount)->HighPart != 0)
            || (((PLARGE_INTEGER)&StartingVcn)->HighPart != 0)
            || (((PLARGE_INTEGER)&LlTemp1)->HighPart != 0)) {

            NtfsRaiseStatus( IrpContext, STATUS_DISK_FULL, NULL, NULL );
        }
    }

    //
    //  First make sure the Mcb is loaded.
    //

    NtfsPreloadAllocation( IrpContext, Scb, StartingVcn,  StartingVcn + ClusterCount - 1 );

    //
    //  Now make the call to add the new allocation, and get out if we do
    //  not actually have to allocate anything.  Before we do the allocation
    //  call check if we need to compute a new desired cluster count for
    //  extending a data attribute.  We never allocate more than the requested
    //  clusters for the Mft.
    //

    Extending = (BOOLEAN)((LONGLONG)LlBytesFromClusters(Vcb, (StartingVcn + ClusterCount)) >
                          Scb->Header.AllocationSize.QuadPart);

    //
    //  Check if we need to modified the base Vcn value stored in the snapshot for
    //  the abort case.
    //

    ASSERT( NtfsIsExclusiveScb( Scb ));

    NtfsSnapshotScb( IrpContext, Scb );

    if (Scb->ScbSnapshot != NULL) {

        if (StartingVcn < Scb->ScbSnapshot->LowestModifiedVcn) {

            Scb->ScbSnapshot->LowestModifiedVcn = StartingVcn;
        }

        LlTemp1 -= 1;
        if (LlTemp1 > Scb->ScbSnapshot->HighestModifiedVcn) {

            if (Extending) {
                Scb->ScbSnapshot->HighestModifiedVcn = MAXLONGLONG;
            } else {
                Scb->ScbSnapshot->HighestModifiedVcn = LlTemp1;
            }
        }
    }

    ASSERT( (Scb->ScbSnapshot != NULL) ||
            !NtfsIsTypeCodeUserData( Scb->AttributeTypeCode ) ||
            (Scb == Vcb->BitmapScb) );

    if (AskForMore) {

        LONGLONG MaxFreeClusters;

        //
        //  Assume these are the same.
        //

        DesiredClusterCount = ClusterCount;

        //
        //  If there is a Ccb with a WriteExtend count less than 4 then use it.
        //

        if (ARGUMENT_PRESENT( CcbForWriteExtend )) {

            //
            //  We want to be slightly smart about the rounding factor.  The key thing is to keep
            //  the user's data contiguous within likely IO boundaries (MM flush regions, etc).
            //  We will progressively round to higher even cluster values based on the number of times the
            //  user has extended the file.
            //

            if (CcbForWriteExtend->WriteExtendCount != 0) {

                //
                //  Initialize the rounding mask to 2 clusters and higher multiples of 2.
                //

                ULONG RoundingMask = (1 << CcbForWriteExtend->WriteExtendCount);

                //
                //  Next perform the basic shift based on the size of this allocation.
                //

                DesiredClusterCount = Int64ShllMod32( ClusterCount, CcbForWriteExtend->WriteExtendCount );

                //
                //  Now bias this by the StartingVcn and round this to the selected boundary.
                //

                DesiredClusterCount = BlockAlign( DesiredClusterCount + StartingVcn, (LONG)RoundingMask );

                //
                //  Remove the StartingVcn bias and see if there is anything left.
                //  Note: the 2nd test is for a longlong rollover
                //

                if ((DesiredClusterCount - StartingVcn < ClusterCount)  ||
                    (DesiredClusterCount < StartingVcn)) {

                    DesiredClusterCount = ClusterCount;

                } else {
                    DesiredClusterCount -= StartingVcn;
                }

                //
                //  Don't use more than 2^32 clusters.
                //

                if (StartingVcn + DesiredClusterCount > MAX_CLUSTERS_PER_RANGE) {

                    DesiredClusterCount = ClusterCount;
                }
            }

            //
            //  Increment the extend count.
            //

            if (CcbForWriteExtend->WriteExtendCount < NtfsExtendFactor) {

                CcbForWriteExtend->WriteExtendCount += 1;
            }
        }

        //
        //  Make sure we don't exceed our maximum file size.
        //  Also don't swallow up too much of the remaining disk space.
        //

        MaxFreeClusters = Int64ShraMod32( Vcb->FreeClusters, 10 ) + ClusterCount;

        if (Vcb->MaxClusterCount - StartingVcn < MaxFreeClusters) {

            MaxFreeClusters = Vcb->MaxClusterCount - StartingVcn;

            ASSERT( MaxFreeClusters >= ClusterCount );
        }

        if (DesiredClusterCount > MaxFreeClusters) {

            DesiredClusterCount = MaxFreeClusters;
        }

        if (NtfsPerformQuotaOperation(Scb->Fcb)) {

            NtfsGetRemainingQuota( IrpContext,
                                   Scb->Fcb->OwnerId,
                                   &LlTemp1,
                                   &LlTemp2,
                                   &Scb->Fcb->QuotaControl->QuickIndexHint );

            //
            //  Do not use LlClustersFromBytesTruncate it is signed and this must be
            //  an unsigned operation.
            //

            LlTemp1 = Int64ShrlMod32( LlTemp1, Vcb->ClusterShift );

            if (DesiredClusterCount > LlTemp1) {

                //
                //  The owner is near their quota limit.  Do not grow the
                //  file past the requested amount.  Note we do not bother
                //  calculating a desired amount based on the remaining quota.
                //  This keeps us from using up a bunch of quota that we may
                //  not need when the user is near the limit.
                //

                DesiredClusterCount = ClusterCount;
            }
        }

    } else {

        DesiredClusterCount = ClusterCount;
    }

    //
    //  All allocation adds for compressed / sparse files should start on a compression unit boundary
    //

    ASSERT( (Scb->CompressionUnit == 0) ||
            !FlagOn( StartingVcn, ClustersFromBytes( Scb->Vcb, Scb->CompressionUnit ) - 1) );

    //
    //  Prepare for looking up attribute records to get the retrieval
    //  information.
    //

    NtfsInitializeAttributeContext( &Context );

    if (Extending &&
        FlagOn( Scb->ScbState, SCB_STATE_SUBJECT_TO_QUOTA ) &&
        NtfsPerformQuotaOperation( Scb->Fcb )) {

        ASSERT( NtfsIsTypeCodeSubjectToQuota( Scb->AttributeTypeCode ));

        //
        //  The quota index must be acquired before the mft scb is acquired.
        //

        ASSERT( !NtfsIsExclusiveScb( Vcb->MftScb ) || NtfsIsSharedFcb( Vcb->QuotaTableScb->Fcb ) );

        NtfsAcquireQuotaControl( IrpContext, Scb->Fcb->QuotaControl );

    }

    try {

        while (TRUE) {

            //  Toplevel action is currently incompatible with our error recovery.
            //  It also costs in performance.
            //
            //  //
            //  //  Start the top-level action by remembering the current UndoNextLsn.
            //  //
            //
            //  if (IrpContext->TransactionId != 0) {
            //
            //      PTRANSACTION_ENTRY TransactionEntry;
            //
            //      NtfsAcquireSharedRestartTable( &Vcb->TransactionTable, TRUE );
            //
            //      TransactionEntry = (PTRANSACTION_ENTRY)GetRestartEntryFromIndex(
            //                          &Vcb->TransactionTable, IrpContext->TransactionId );
            //
            //      StartLsn = TransactionEntry->UndoNextLsn;
            //      SavedUndoRecords = TransactionEntry->UndoRecords;
            //      SavedUndoBytes = TransactionEntry->UndoBytes;
            //      NtfsReleaseRestartTable( &Vcb->TransactionTable );
            //
            //  } else {
            //
            //      StartLsn = *(PLSN)&Li0;
            //      SavedUndoRecords = 0;
            //      SavedUndoBytes = 0;
            //  }
            //

            //
            //  Remember that the clusters are only in the Scb now.
            //

            if (NtfsAllocateClusters( IrpContext,
                                      Scb->Vcb,
                                      Scb,
                                      StartingVcn,
                                      AllocateAll,
                                      ClusterCount,
                                      NULL,
                                      &DesiredClusterCount )) {


                //
                //  We defer looking up the attribute to make the "already-allocated"
                //  case faster.
                //

                NtfsLookupAttributeForScb( IrpContext, Scb, NULL, &Context );

                //
                //  Now add the space to the file record, if any was allocated.
                //

                if (Extending) {

                    LlTemp1 = Scb->Header.AllocationSize.QuadPart;

                    NtfsAddAttributeAllocation( IrpContext,
                                                Scb,
                                                &Context,
                                                NULL,
                                                NULL );

                    //
                    //  Make sure the owner is allowed to have these
                    //  clusters.
                    //

                    if (FlagOn( Scb->ScbState, SCB_STATE_SUBJECT_TO_QUOTA )) {

                        //
                        //  Note the allocated clusters cannot be used
                        //  here because StartingVcn may be greater
                        //  then allocation size.
                        //

                        LlTemp1 = Scb->Header.AllocationSize.QuadPart - LlTemp1;

                        NtfsConditionallyUpdateQuota( IrpContext,
                                                      Scb->Fcb,
                                                      &LlTemp1,
                                                      TRUE,
                                                      TRUE );
                    }
                } else {

                    NtfsAddAttributeAllocation( IrpContext,
                                                Scb,
                                                &Context,
                                                &StartingVcn,
                                                &ClusterCount );
                }

            //
            //  If he did not allocate anything, make sure we get out below.
            //

            } else {
                DesiredClusterCount = ClusterCount;
            }

            //
            //  Call the Cache Manager to extend the section, now that we have
            //  succeeded.
            //

            if (ARGUMENT_PRESENT( FileObject) && Extending) {

                NtfsSetBothCacheSizes( FileObject,
                                       (PCC_FILE_SIZES)&Scb->Header.AllocationSize,
                                       Scb );
            }

            //
            //  Set up to truncate on close.
            //

            SetFlag( Scb->ScbState, SCB_STATE_TRUNCATE_ON_CLOSE );

            //
            //  See if we need to loop back.
            //

            if (DesiredClusterCount < ClusterCount) {

                NtfsCleanupAttributeContext( IrpContext, &Context );

                //
                //  Commit the current transaction if we have one.
                //

                NtfsCheckpointCurrentTransaction( IrpContext );

                //
                //  Adjust our parameters and reinitialize the context
                //  for the loop back.
                //

                StartingVcn = StartingVcn + DesiredClusterCount;
                ClusterCount = ClusterCount - DesiredClusterCount;
                DesiredClusterCount = ClusterCount;
                NtfsInitializeAttributeContext( &Context );

            //
            //  Else we are done.
            //

            } else {

                break;
            }
        }

    } finally {

        DebugUnwind( NtfsAddAllocation );

        //
        //  Cleanup the attribute context on the way out.
        //

        NtfsCleanupAttributeContext( IrpContext, &Context );
    }

    DebugTrace( -1, Dbg, ("NtfsAddAllocation -> VOID\n") );

    return;
}


VOID
NtfsAddSparseAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN OUT PSCB Scb,
    IN LONGLONG StartingOffset,
    IN LONGLONG ByteCount
    )

/*++

Routine Description:

    This routine is called to add a hole to the end of a sparse file.  We need to
    force NtfsAddAttributeAllocation to extend a file via a hole.  We do this be
    adding a new range to the end of the Mcb and force it to have a LargeMcb.
    NtfsAddAttributeAllocation recognizes this and will write the file record.
    Otherwise that routine will truncate the hole at the end of a file.

Arguments:

    FileObject - FileObject for the Scb

    Scb - Scb for the attribute needing allocation

    StartingOffset - File offset which contains the first compression unit to add.

    ByteCount - Number of bytes to allocate from the StartingOffset.

Return Value:

    None.

--*/

{
    LONGLONG Range;
    VCN StartingVcn = LlClustersFromBytesTruncate( Scb->Vcb,
                                                   Scb->Header.AllocationSize.LowPart );
    BOOLEAN UnloadMcb = TRUE;

    ATTRIBUTE_ENUMERATION_CONTEXT Context;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( Scb );
    ASSERT_EXCLUSIVE_SCB( Scb );

    DebugTrace( +1, Dbg, ("NtfsAddSparseAllocation\n") );

    //
    //  Do a sanity check on the following.
    //
    //      - This is not restart.
    //      - This is a sparse file.
    //      - The StartingOffset is beyond the end of the file.
    //

    ASSERT( !FlagOn( Scb->Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS ) &&
            FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE ) &&
            (StartingOffset >= Scb->Header.AllocationSize.QuadPart) );

    //
    //  Check if we need to modified the base Vcn value stored in the snapshot for
    //  the abort case.
    //

    NtfsSnapshotScb( IrpContext, Scb );

    if (Scb->ScbSnapshot != NULL) {

        if (StartingVcn < Scb->ScbSnapshot->LowestModifiedVcn) {

            Scb->ScbSnapshot->LowestModifiedVcn = StartingVcn;
        }

        Scb->ScbSnapshot->HighestModifiedVcn = MAXLONGLONG;
    }

    ASSERT( Scb->ScbSnapshot != NULL );

    //
    //  Round the end of the allocation upto a compression unit boundary.
    //

    Range = BlockAlign( StartingOffset + ByteCount, (LONG)Scb->CompressionUnit );

    ASSERT( Range <= MAXFILESIZE );

    //
    //  Convert from bytes to clusters.
    //

    StartingVcn = LlClustersFromBytesTruncate( Scb->Vcb, Scb->Header.AllocationSize.QuadPart );
    Range = LlClustersFromBytesTruncate( Scb->Vcb, Range );

    //
    //  Initialize the lookup context.
    //

    NtfsInitializeAttributeContext( &Context );

    try {

        //
        //  Load the allocation for the range ahead of us.
        //

        if (StartingOffset != 0) {

            NtfsPreloadAllocation( IrpContext,
                                   Scb,
                                   StartingVcn - 1,
                                   StartingVcn - 1 );
        }

        //
        //  Define a range past the current end of the file.
        //

        NtfsDefineNtfsMcbRange( &Scb->Mcb,
                                StartingVcn,
                                Range - 1,
                                FALSE );

        //
        //  Now add a single hole so that there is an Mcb entry.
        //

        NtfsAddNtfsMcbEntry( &Scb->Mcb,
                             StartingVcn,
                             UNUSED_LCN,
                             Range - StartingVcn,
                             FALSE );

        //
        //  Lookup the first file record for this Scb.
        //

        NtfsLookupAttributeForScb( IrpContext, Scb, NULL, &Context );

        if (FlagOn( Scb->ScbState, SCB_STATE_SUBJECT_TO_QUOTA ) &&
            NtfsPerformQuotaOperation( Scb->Fcb )) {

            ASSERT( NtfsIsTypeCodeSubjectToQuota( Scb->AttributeTypeCode ));

            //
            //  The quota index must be acquired before the mft scb is acquired.
            //

            ASSERT( !NtfsIsExclusiveScb( Scb->Vcb->MftScb ) ||
                    NtfsIsSharedScb( Scb->Fcb->Vcb->QuotaTableScb ) );

            NtfsAcquireQuotaControl( IrpContext, Scb->Fcb->QuotaControl );
        }

        //
        //  Now add the space to the file record, if any was allocated.
        //

        Range = Scb->Header.AllocationSize.QuadPart;

        NtfsAddAttributeAllocation( IrpContext,
                                    Scb,
                                    &Context,
                                    NULL,
                                    NULL );

        //
        //  Make sure the owner is allowed to have these
        //  clusters.
        //

        if (FlagOn( Scb->ScbState, SCB_STATE_SUBJECT_TO_QUOTA )) {

            //
            //  Note the allocated clusters cannot be used
            //  here because StartingVcn may be greater
            //  then allocation size.
            //

            Range = Scb->Header.AllocationSize.QuadPart - Range;

            NtfsConditionallyUpdateQuota( IrpContext,
                                          Scb->Fcb,
                                          &Range,
                                          TRUE,
                                          TRUE );
        }

        //
        //  Call the Cache Manager to extend the section, now that we have
        //  succeeded.
        //

        if (ARGUMENT_PRESENT( FileObject)) {

            NtfsSetBothCacheSizes( FileObject,
                                   (PCC_FILE_SIZES)&Scb->Header.AllocationSize,
                                   Scb );
        }

        //
        //  Set up to truncate on close.
        //

        SetFlag( Scb->ScbState, SCB_STATE_TRUNCATE_ON_CLOSE );
        UnloadMcb = FALSE;

    } finally {

        DebugUnwind( NtfsAddSparseAllocation );

        //
        //  Manually unload the Mcb in the event of an error.  There may not be a
        //  transaction underway.
        //

        if (UnloadMcb) {

            NtfsUnloadNtfsMcbRange( &Scb->Mcb,
                                    StartingVcn,
                                    MAXLONGLONG,
                                    FALSE,
                                    FALSE );
        }

        //
        //  Cleanup the attribute context on the way out.
        //

        NtfsCleanupAttributeContext( IrpContext, &Context );
    }

    DebugTrace( -1, Dbg, ("NtfsAddSparseAllocation -> VOID\n") );

    return;
}


VOID
NtfsDeleteAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN OUT PSCB Scb,
    IN VCN StartingVcn,
    IN VCN EndingVcn,
    IN BOOLEAN LogIt,
    IN BOOLEAN BreakupAllowed
    )

/*++

Routine Description:

    This routine deletes allocation from an existing nonresident attribute.  If all
    or part of the allocation does not exist, the effect is benign, and only the
    remaining allocation is deleted.

Arguments:

    FileObject - FileObject for the Scb.  This should always be specified if
                 possible, and must be specified if it is possible that MM has a
                 section created.

    Scb - Scb for the attribute needing allocation

    StartingVcn - First Vcn to be deallocated.

    EndingVcn - Last Vcn to be deallocated, or xxMax to truncate at StartingVcn.
                If EndingVcn is *not* xxMax, a sparse deallocation is performed,
                and none of the stream sizes are changed.

    LogIt - Most callers should specify TRUE, to have the change logged.  However,
            we can specify FALSE if we are deleting the file record, and
            will be logging this delete.

    BreakupAllowed - TRUE if the caller can tolerate breaking up the deletion of
                     allocation into multiple transactions, if there are a large
                     number of runs.

Return Value:

    None.

--*/

{
    VCN MyStartingVcn, MyEndingVcn;
    VCN BlockStartingVcn = 0;
    PVOID FirstRangePtr;
    ULONG FirstRunIndex;
    PVOID LastRangePtr;
    ULONG LastRunIndex;
    BOOLEAN BreakingUp = FALSE;
    PVCB Vcb = Scb->Vcb;

    LCN TempLcn;
    LONGLONG TempCount;
    ULONG CompressionUnitInClusters = 1;

    PAGED_CODE();

    if (Scb->CompressionUnit != 0) {
        CompressionUnitInClusters = ClustersFromBytes( Vcb, Scb->CompressionUnit );
    }

    //
    //  If the file is compressed, make sure we round the allocation
    //  size to a compression unit boundary, so we correctly interpret
    //  the compression state of the data at the point we are
    //  truncating to.  I.e., the danger is that we throw away one
    //  or more clusters at the end of compressed data!  Note that this
    //  adjustment could cause us to noop the call.
    //

    if (Scb->CompressionUnit != 0) {

        //
        //  Now check if we are truncating at the end of the file.
        //

        if (EndingVcn == MAXLONGLONG) {
            StartingVcn = BlockAlign( StartingVcn, (LONG)CompressionUnitInClusters );
        }
    }

    //
    //  Make sure we have a snapshot and update it with the range of this deallocation.
    //

    ASSERT( NtfsIsExclusiveScb( Scb ));

    NtfsSnapshotScb( IrpContext, Scb );

    //
    //  Make sure update the VCN range in the snapshot.  We need to
    //  do it each pass through the loop
    //

    if (Scb->ScbSnapshot != NULL) {

        if (StartingVcn < Scb->ScbSnapshot->LowestModifiedVcn) {

            Scb->ScbSnapshot->LowestModifiedVcn = StartingVcn;
        }

        if (EndingVcn > Scb->ScbSnapshot->HighestModifiedVcn) {

            Scb->ScbSnapshot->HighestModifiedVcn = EndingVcn;
        }
    }

    ASSERT( (Scb->ScbSnapshot != NULL) ||
            !NtfsIsTypeCodeUserData( Scb->AttributeTypeCode ));

    //
    //  We may not be able to preload the entire allocation for an
    //  extremely large fragmented file.  The number of Mcb's may exhaust
    //  available pool.  We will break the range to deallocate into smaller
    //  ranges when preloading the allocation.
    //

    do {

        //
        //  If this is a large file and breakup is allowed then see if we
        //  want to break up the range of the deallocation.
        //

        if ((Scb->Header.AllocationSize.HighPart != 0) && BreakupAllowed) {

            //
            //  If this is the first pass through then determine the starting point
            //  for this range.
            //

            if (BlockStartingVcn == 0) {

                MyEndingVcn = EndingVcn;

                if (EndingVcn == MAXLONGLONG) {

                    MyEndingVcn = LlClustersFromBytesTruncate( Vcb,
                                                               Scb->Header.AllocationSize.QuadPart ) - 1;
                }

                BlockStartingVcn = MyEndingVcn - Vcb->ClustersPer4Gig;

                //
                //  Remember we are breaking up now, and that as a result
                //  we have to log everything.
                //

                BreakingUp = TRUE;
                LogIt = TRUE;

            } else {

                //
                //  If we are truncating from the end of the file then raise CANT_WAIT.  This will
                //  cause us to release our resources periodically when deleting a large file.
                //

                if (BreakingUp && (EndingVcn == MAXLONGLONG)) {

                    NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
                }

                BlockStartingVcn -= Vcb->ClustersPer4Gig;
            }

            if (BlockStartingVcn < StartingVcn) {

                BlockStartingVcn = StartingVcn;

            } else if (Scb->CompressionUnit != 0) {

                //
                //  Now check if we are truncating at the end of the file.
                //  Always truncate to a compression unit boundary.
                //

                if (EndingVcn == MAXLONGLONG) {
                    BlockStartingVcn = BlockAlign( BlockStartingVcn, (LONG)CompressionUnitInClusters );
                }
            }

        } else {

            BlockStartingVcn = StartingVcn;
        }

        //
        //  First make sure the Mcb is loaded.  Note it is possible that
        //  we could need the previous range loaded if the delete starts
        //  at the beginning of a file record boundary, thus the -1.
        //

        NtfsPreloadAllocation( IrpContext, Scb, ((BlockStartingVcn != 0) ? (BlockStartingVcn - 1) : 0), EndingVcn );

        //
        //  Loop to do one or more deallocate calls.
        //

        MyEndingVcn = EndingVcn;
        do {

            //
            //  Now lookup and get the indices for the first Vcn being deleted.
            //  If we are off the end, get out.  We do this in the loop, because
            //  conceivably deleting space could change the range pointer and
            //  index of the first entry.
            //

            if (!NtfsLookupNtfsMcbEntry( &Scb->Mcb,
                                         BlockStartingVcn,
                                         NULL,
                                         NULL,
                                         NULL,
                                         NULL,
                                         &FirstRangePtr,
                                         &FirstRunIndex )) {

                break;
            }

            //
            //  Now see if we can deallocate everything at once.
            //

            MyStartingVcn = BlockStartingVcn;
            LastRunIndex = MAXULONG;

            if (BreakupAllowed) {

                //
                //  Now lookup and get the indices for the last Vcn being deleted.
                //  If we are off the end, get the last index.
                //

                if (!NtfsLookupNtfsMcbEntry( &Scb->Mcb,
                                             MyEndingVcn,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             &LastRangePtr,
                                             &LastRunIndex )) {

                    NtfsNumberOfRunsInRange(&Scb->Mcb, LastRangePtr, &LastRunIndex);
                }

                //
                //  If the Vcns to delete span multiple ranges, or there
                //  are too many in the last range to delete, then we
                //  will calculate the index of a run to start with for
                //  this pass through the loop.
                //

                if ((FirstRangePtr != LastRangePtr) ||
                    ((LastRunIndex - FirstRunIndex) > MAXIMUM_RUNS_AT_ONCE)) {

                    //
                    //  Figure out where we can afford to truncate to.
                    //

                    if (LastRunIndex >= MAXIMUM_RUNS_AT_ONCE) {
                        LastRunIndex -= MAXIMUM_RUNS_AT_ONCE;
                    } else {
                        LastRunIndex = 0;
                    }

                    //
                    //  Now lookup the first Vcn in this run.
                    //

                    NtfsGetNextNtfsMcbEntry( &Scb->Mcb,
                                             &LastRangePtr,
                                             LastRunIndex,
                                             &MyStartingVcn,
                                             &TempLcn,
                                             &TempCount );

                    ASSERT(MyStartingVcn > BlockStartingVcn);

                    //
                    //  If compressed, round down to a compression unit boundary.
                    //

                    MyStartingVcn = BlockAlignTruncate( MyStartingVcn, (LONG)CompressionUnitInClusters );

                    //
                    //  Remember we are breaking up now, and that as a result
                    //  we have to log everything.
                    //

                    BreakingUp = TRUE;
                    LogIt = TRUE;
                }
            }

            //
            // CAIROBUG Consider optimizing this code when the cairo ifdef's
            // are removed.
            //

            //
            // If this is a user data stream and we are truncating to end the
            // return the quota to the owner.
            //

            if (FlagOn( Scb->ScbState, SCB_STATE_SUBJECT_TO_QUOTA ) &&
                (EndingVcn == MAXLONGLONG)) {

                //
                //  Calculate the amount that allocation size is being reduced.
                //

                TempCount = LlBytesFromClusters( Vcb, MyStartingVcn ) -
                            Scb->Header.AllocationSize.QuadPart;

                NtfsConditionallyUpdateQuota( IrpContext,
                                              Scb->Fcb,
                                              &TempCount,
                                              TRUE,
                                              FALSE );
            }

            //
            //  Now deallocate a range of clusters
            //

            NtfsDeleteAllocationInternal( IrpContext,
                                          Scb,
                                          MyStartingVcn,
                                          EndingVcn,
                                          LogIt );

            //
            //  Now, if we are breaking up this deallocation, then do some
            //  transaction cleanup.
            //

            if (BreakingUp) {

                //
                //  Free the Mft Scb if we currently own it provided we are not
                //  truncating a stream in the Mft.
                //

                if ((NtfsSegmentNumber( &Scb->Fcb->FileReference ) != MASTER_FILE_TABLE_NUMBER) &&
                    (EndingVcn == MAXLONGLONG) &&
                    (Vcb->MftScb != NULL) &&
                    (Vcb->MftScb->Fcb->ExclusiveFcbLinks.Flink != NULL) &&
                    NtfsIsExclusiveScb( Vcb->MftScb )) {

                    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_RELEASE_MFT );
                }

                NtfsCheckpointCurrentTransaction( IrpContext );

                //
                //  Move the ending Vcn backwards in the file.  This will
                //  let us move down to the next earlier file record if
                //  this case spans multiple file records.
                //

                MyEndingVcn = MyStartingVcn - 1;
            }

            //
            //  Call the Cache Manager to change allocation size for either
            //  truncate or SplitMcb case (where EndingVcn was set to xxMax!).
            //

            if ((EndingVcn == MAXLONGLONG) && ARGUMENT_PRESENT( FileObject )) {

                NtfsSetBothCacheSizes( FileObject,
                                       (PCC_FILE_SIZES)&Scb->Header.AllocationSize,
                                       Scb );
            }

        } while (MyStartingVcn != BlockStartingVcn);

    } while (BlockStartingVcn != StartingVcn);
}


VOID
NtfsReallocateRange (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PSCB Scb,
    IN VCN DeleteVcn,
    IN LONGLONG DeleteCount,
    IN VCN AllocateVcn,
    IN LONGLONG AllocateCount,
    IN PLCN TargetLcn OPTIONAL
    )

/*++

Routine Description:

    This routine is called to reallocate a individual range within the existing
    allocation of the file.  Typically this might be used to reallocate a
    compression unit or perform MoveFile.  We can modify the Mcb and then
    write a single log record to write the mapping information.  This routine
    doesn't make any attempt to split the Mcb.  Also our caller must know
    that the change of allocation occurs entirely within the existing virtual
    allocation of the file.

    We might expand this routine in the future to optimize the case where we
    are reallocating a compression unit only because we believe it is fragmented
    and there is a good chance to reduce fragmentation.  We could check to see
    if a single run is available and only reallocate if such a run exists.

Arguments:

    Scb - Scb for the attribute needing a change of allocation.

    DeleteVcn - Starting Vcn for the range to delete.

    DeleteClusters - Count of clusters to delete.  May be zero.

    AllocateVcn - Starting Vcn for the range to allocate.

    AllocateClusters - Count of clusters to allocate.  May be zero.

    TargetLcn - If specified reallocate to this particular LCN

Return Value:

    None

--*/

{
    VCN StartingVcn;
    VCN EndingVcn;

    ATTRIBUTE_ENUMERATION_CONTEXT Context;
    ULONG CleanupContext = FALSE;

    BOOLEAN ChangedAllocation = FALSE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsReallocateRange:  Entered\n") );

    //
    //  Let's make sure we are within the full allocation of the stream.
    //

    ASSERT( (DeleteCount == 0) ||
            ((DeleteVcn <= LlClustersFromBytesTruncate( IrpContext->Vcb, Scb->Header.AllocationSize.QuadPart )) &&
             ((DeleteVcn + DeleteCount) <= LlClustersFromBytesTruncate( IrpContext->Vcb, Scb->Header.AllocationSize.QuadPart ))));


    ASSERT( (AllocateCount == 0) ||
            ((AllocateVcn <= LlClustersFromBytesTruncate( IrpContext->Vcb, Scb->Header.AllocationSize.QuadPart )) &&
             ((AllocateVcn + AllocateCount) <= LlClustersFromBytesTruncate( IrpContext->Vcb, Scb->Header.AllocationSize.QuadPart ))));

    //
    //  Either one or both or our input counts may be zero.  Make sure the zero-length
    //  ranges don't make us do extra work.
    //

    if (DeleteCount == 0) {

        if (AllocateCount == 0) {

            DebugTrace( -1, Dbg, ("NtfsReallocateRange:  Exit\n") );
            return;
        }

        DeleteVcn = AllocateVcn;

        //
        //  The range is set by the allocation clusters.
        //

        StartingVcn = AllocateVcn;
        EndingVcn = AllocateVcn + AllocateCount;

    } else if (AllocateCount == 0) {

        AllocateVcn = DeleteVcn;

        //
        //  The range is set by the deallocation clusters.
        //

        StartingVcn = DeleteVcn;
        EndingVcn = DeleteVcn + DeleteCount;

    } else {

        //
        //  Find the lowest starting point.
        //

        StartingVcn = DeleteVcn;

        if (DeleteVcn > AllocateVcn) {

            StartingVcn = AllocateVcn;
        }

        //
        //  Find the highest ending point.
        //

        EndingVcn = DeleteVcn + DeleteCount;

        if (AllocateVcn + AllocateCount > EndingVcn) {

            EndingVcn = AllocateVcn + AllocateCount;
        }
    }

    //
    //  Make sure we have a snapshot and update it with the range of this deallocation.
    //

    ASSERT( NtfsIsExclusiveScb( Scb ));

    NtfsSnapshotScb( IrpContext, Scb );

    //
    //  Make sure update the VCN range in the snapshot.  We need to do this for both ranges.
    //

    if (Scb->ScbSnapshot != NULL) {

        if (StartingVcn < Scb->ScbSnapshot->LowestModifiedVcn) {

            Scb->ScbSnapshot->LowestModifiedVcn = StartingVcn;
        }

        if (EndingVcn > Scb->ScbSnapshot->HighestModifiedVcn) {

            Scb->ScbSnapshot->HighestModifiedVcn = EndingVcn;
        }
    }

    ASSERT( (Scb->ScbSnapshot != NULL) ||
            !NtfsIsTypeCodeUserData( Scb->AttributeTypeCode ));

    //
    //  First make sure the Mcb is loaded.  Note it is possible that
    //  we could need the previous range loaded if the delete starts
    //  at the beginning of a file record boundary, thus the -1.
    //

    NtfsPreloadAllocation( IrpContext,
                           Scb,
                           ((StartingVcn != 0) ? (StartingVcn - 1) : 0),
                           EndingVcn - 1 );

    //
    //  Use a try-finally in case we need to unload the Mcb.
    //

    try {

        //
        //  Do the deallocate first.
        //

        if (DeleteCount != 0) {

            ChangedAllocation = NtfsDeallocateClusters( IrpContext,
                                                        Scb->Vcb,
                                                        Scb,
                                                        DeleteVcn,
                                                        DeleteVcn + DeleteCount - 1,
                                                        &Scb->TotalAllocated );
        }

        //
        //  Now do the allocation.
        //

        if (AllocateCount != 0) {

            //
            //  The allocate path is simpler.  We don't worry about ranges.
            //  Remember if any bits are allocated though.
            //

            if (NtfsAllocateClusters( IrpContext,
                                      Scb->Vcb,
                                      Scb,
                                      AllocateVcn,
                                      TRUE,
                                      AllocateCount,
                                      TargetLcn,
                                      &AllocateCount )) {

                ChangedAllocation = TRUE;
            }
        }

        if (ChangedAllocation) {

            //
            //  Now rewrite the mapping for this range.
            //

            AllocateCount = EndingVcn - StartingVcn;

            NtfsInitializeAttributeContext( &Context );
            CleanupContext = TRUE;

            NtfsLookupAttributeForScb( IrpContext, Scb, NULL, &Context );

            NtfsAddAttributeAllocation( IrpContext,
                                        Scb,
                                        &Context,
                                        &StartingVcn,
                                        &AllocateCount );
        }

    } finally {

        if (AbnormalTermination()) {

            //
            //  Unload the Mcb if we don't have a transaction.  We need to do this
            //  in case we have already removed part of a range.
            //

            if (IrpContext->TransactionId == 0) {

                NtfsUnloadNtfsMcbRange( &Scb->Mcb,
                                        StartingVcn,
                                        MAXLONGLONG,
                                        FALSE,
                                        FALSE );
            }
        }

        //
        //  Cleanup the context if needed.
        //

        if (CleanupContext) {

            NtfsCleanupAttributeContext( IrpContext, &Context );
        }

        DebugTrace( -1, Dbg, ("NtfsReallocateRange:  Exit\n") );
    }

    return;
}


//
//  Internal support routine
//

VOID
NtfsDeleteAllocationInternal (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PSCB Scb,
    IN VCN StartingVcn,
    IN VCN EndingVcn,
    IN BOOLEAN LogIt
    )

/*++

Routine Description:

    This routine deletes allocation from an existing nonresident attribute.  If all
    or part of the allocation does not exist, the effect is benign, and only the
    remaining allocation is deleted.

Arguments:

    Scb - Scb for the attribute needing allocation

    StartingVcn - First Vcn to be deallocated.

    EndingVcn - Last Vcn to be deallocated, or xxMax to truncate at StartingVcn.
                If EndingVcn is *not* xxMax, a sparse deallocation is performed,
                and none of the stream sizes are changed.

    LogIt - Most callers should specify TRUE, to have the change logged.  However,
            we can specify FALSE if we are deleting the file record, and
            will be logging this delete.

Return Value:

    None.

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT Context, TempContext;
    PATTRIBUTE_RECORD_HEADER Attribute;
    LONGLONG SizeInBytes, SizeInClusters;
    VCN Vcn1;
    PVCB Vcb = Scb->Vcb;
    BOOLEAN AddSpaceBack = FALSE;
    BOOLEAN SplitMcb = FALSE;
    BOOLEAN UpdatedAllocationSize = FALSE;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( Scb );
    ASSERT_EXCLUSIVE_SCB( Scb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsDeleteAllocation\n") );

    //
    //  Calculate new allocation size, assuming truncate.
    //

    SizeInBytes = LlBytesFromClusters( Vcb, StartingVcn );

    ASSERT( (Scb->ScbSnapshot == NULL) ||
            (Scb->ScbSnapshot->LowestModifiedVcn <= StartingVcn) );

    //
    //  If this is a sparse deallocation, then we will have to call
    //  NtfsAddAttributeAllocation at the end to complete the fixup.
    //

    if (EndingVcn != MAXLONGLONG) {

        AddSpaceBack = TRUE;

        //
        //  If we have not written anything beyond the last Vcn to be
        //  deleted, then we can actually call FsRtlSplitLargeMcb to
        //  slide the allocated space up and keep the file contiguous!
        //
        //  Ignore this if this is the Mft and we are creating a hole or
        //  if we are in the process of changing the compression state.
        //
        //  If we were called from either SetEOF or SetAllocation for a
        //  compressed file then we can be doing a flush for the last
        //  page of the file as a result of a call to CcSetFileSizes.
        //  In this case we don't want to split the Mcb because we could
        //  reenter CcSetFileSizes and throw away the last page.
        //

        if (FlagOn( Scb->ScbState, SCB_STATE_WRITE_COMPRESSED ) &&
            (EndingVcn >= LlClustersFromBytesTruncate( Vcb,
                                                       ((Scb->ValidDataToDisk + Scb->CompressionUnit - 1) &
                                                        ~((LONGLONG) (Scb->CompressionUnit - 1))))) &&
            (Scb != Vcb->MftScb) &&
            !FlagOn( Scb->ScbState, SCB_STATE_REALLOCATE_ON_WRITE ) &&
            ((IrpContext == IrpContext->TopLevelIrpContext) ||
             (IrpContext->TopLevelIrpContext->MajorFunction != IRP_MJ_SET_INFORMATION))) {

            ASSERT( Scb->CompressionUnit != 0 );

            //
            //  If we are going to split the Mcb, then make sure it is fully loaded.
            //  Do not bother to split if there are multiple ranges involved, so we
            //  do not end up rewriting lots of file records.
            //

            if (NtfsPreloadAllocation(IrpContext, Scb, StartingVcn, MAXLONGLONG) <= 1) {

                SizeInClusters = (EndingVcn - StartingVcn) + 1;

                ASSERT( NtfsIsTypeCodeUserData( Scb->AttributeTypeCode ));

                SplitMcb = NtfsSplitNtfsMcb( &Scb->Mcb, StartingVcn, SizeInClusters );

                //
                //  If the delete is off the end, we can get out.
                //

                if (!SplitMcb) {
                    return;
                }

                //
                //  We must already have a snapshot to make sure the mcb is unloaded if
                //  something goes wrong
                //

                ASSERT( Scb->ScbSnapshot != NULL );

                //
                //  We must protect the call below with a try-finally in
                //  order to unload the Split Mcb.  If there is no transaction
                //  underway then a release of the Scb would cause the
                //  snapshot to go away.
                //

                try {

                    //
                    //  We are not properly synchronized to change AllocationSize,
                    //  so we will delete any clusters that may have slid off the
                    //  end.  Since we are going to smash EndingVcn soon anyway,
                    //  use it as a scratch to hold AllocationSize in Vcns...
                    //

                    EndingVcn = LlClustersFromBytes(Vcb, Scb->Header.AllocationSize.QuadPart);

                    NtfsDeallocateClusters( IrpContext,
                                            Vcb,
                                            Scb,
                                            EndingVcn,
                                            MAXLONGLONG,
                                            &Scb->TotalAllocated );

                } finally {

                    if (AbnormalTermination() && (IrpContext->TransactionId == 0)) {

                        NtfsUnloadNtfsMcbRange( &Scb->Mcb,
                                                StartingVcn,
                                                MAXLONGLONG,
                                                FALSE,
                                                FALSE );
                    }
                }

                NtfsUnloadNtfsMcbRange( &Scb->Mcb,
                                        EndingVcn,
                                        MAXLONGLONG,
                                        TRUE,
                                        FALSE );

                //
                //  Since we did a split, jam highest modified all the way up.
                //

                Scb->ScbSnapshot->HighestModifiedVcn = MAXLONGLONG;

                //
                //  We will have to redo all of the allocation to the end now.
                //

                EndingVcn = MAXLONGLONG;
            }
        }
    }

    //
    //  Now make the call to delete the allocation (if we did not just split
    //  the Mcb), and get out if we didn't have to do anything, because a
    //  hole is being created where there is already a hole.
    //

    if (!SplitMcb &&
        !NtfsDeallocateClusters( IrpContext,
                                 Vcb,
                                 Scb,
                                 StartingVcn,
                                 EndingVcn,
                                 &Scb->TotalAllocated ) &&
         EndingVcn != MAXLONGLONG) {

        return;
    }

    //
    //  On successful truncates, we nuke the entire range here.
    //

    if (!SplitMcb && (EndingVcn == MAXLONGLONG)) {

        NtfsUnloadNtfsMcbRange( &Scb->Mcb, StartingVcn, MAXLONGLONG, TRUE, FALSE );
    }

    //
    //  Prepare for looking up attribute records to get the retrieval
    //  information.
    //

    NtfsInitializeAttributeContext( &Context );
    NtfsInitializeAttributeContext( &TempContext );

    try {

        //
        //  Lookup the attribute record so we can ultimately delete space to it.
        //

        NtfsLookupAttributeForScb( IrpContext, Scb, &StartingVcn, &Context );

        //
        //  Now loop to delete the space to the file record.  Do not do this if LogIt
        //  is FALSE, as this is someone trying to delete the entire file
        //  record, so we do not have to clean up the attribute record.
        //

        if (LogIt) {

            do {

                Attribute = NtfsFoundAttribute(&Context);

                //
                //  If there is no overlap, then continue.
                //

                if ((Attribute->Form.Nonresident.HighestVcn < StartingVcn) ||
                    (Attribute->Form.Nonresident.LowestVcn > EndingVcn)) {

                    continue;

                //
                //  If all of the allocation is going away, then delete the entire
                //  record.  We have to show that the allocation is already deleted
                //  to avoid being called back via NtfsDeleteAttributeRecord!  We
                //  avoid this for the first instance of this attribute.
                //

                } else if ((Attribute->Form.Nonresident.LowestVcn >= StartingVcn) &&
                           (EndingVcn == MAXLONGLONG) &&
                           (Attribute->Form.Nonresident.LowestVcn != 0)) {

                    NtfsDeleteAttributeRecord( IrpContext,
                                               Scb->Fcb,
                                               (LogIt ? DELETE_LOG_OPERATION : 0) |
                                                DELETE_RELEASE_FILE_RECORD,
                                               &Context );

                //
                //  If just part of the allocation is going away, then make the
                //  call here to reconstruct the mapping pairs array.
                //

                } else {

                    //
                    //  If this is the end of a sparse deallocation, then break out
                    //  because we will rewrite this file record below anyway.
                    //

                    if (EndingVcn <= Attribute->Form.Nonresident.HighestVcn) {
                        break;

                    //
                    //  If we split the Mcb, then make sure we only regenerate the
                    //  mapping pairs once at the split point (but continue to
                    //  scan for any entire records to delete).
                    //

                    } else if (SplitMcb) {
                        continue;
                    }

                    //
                    //  If this is a sparse deallocation, then we have to call to
                    //  add the allocation, since it is possible that the file record
                    //  must split.
                    //

                    if (EndingVcn != MAXLONGLONG) {

                        //
                        //  Compute the last Vcn in the file,  Then remember if it is smaller,
                        //  because that is the last one we will delete to, in that case.
                        //

                        Vcn1 = Attribute->Form.Nonresident.HighestVcn;

                        SizeInClusters = (Vcn1 - Attribute->Form.Nonresident.LowestVcn) + 1;
                        Vcn1 = Attribute->Form.Nonresident.LowestVcn;

                        NtfsCleanupAttributeContext( IrpContext, &TempContext );
                        NtfsInitializeAttributeContext( &TempContext );

                        NtfsLookupAttributeForScb( IrpContext, Scb, NULL, &TempContext );

                        NtfsAddAttributeAllocation( IrpContext,
                                                    Scb,
                                                    &TempContext,
                                                    &Vcn1,
                                                    &SizeInClusters );

                        //
                        //  Since we used a temporary context we will need to
                        //  restart the scan from the first file record.  We update
                        //  the range to deallocate by the last operation.  In most
                        //  cases we will only need to modify one file record and
                        //  we can exit this loop.
                        //

                        StartingVcn = Vcn1 + SizeInClusters;

                        if (StartingVcn > EndingVcn) {

                            break;
                        }

                        NtfsCleanupAttributeContext( IrpContext, &Context );
                        NtfsInitializeAttributeContext( &Context );

                        NtfsLookupAttributeForScb( IrpContext, Scb, NULL, &Context );
                        continue;

                    //
                    //  Otherwise, we can simply delete the allocation, because
                    //  we know the file record cannot grow.
                    //

                    } else {

                        Vcn1 = StartingVcn - 1;

                        NtfsDeleteAttributeAllocation( IrpContext,
                                                       Scb,
                                                       LogIt,
                                                       &Vcn1,
                                                       &Context,
                                                       TRUE );

                        //
                        //  The call above will update the allocation size and
                        //  set the new file sizes on disk.
                        //

                        UpdatedAllocationSize = TRUE;
                    }
                }

            } while (NtfsLookupNextAttributeForScb(IrpContext, Scb, &Context));

            //
            //  If this deletion makes the file sparse, then we have to call
            //  NtfsAddAttributeAllocation to regenerate the mapping pairs.
            //  Note that potentially they may no longer fit, and we could actually
            //  have to add a file record.
            //

            if (AddSpaceBack) {

                //
                //  If we did not just split the Mcb, we have to calculate the
                //  SizeInClusters parameter for NtfsAddAttributeAllocation.
                //

                if (!SplitMcb) {

                    //
                    //  Compute the last Vcn in the file,  Then remember if it is smaller,
                    //  because that is the last one we will delete to, in that case.
                    //

                    Vcn1 = Attribute->Form.Nonresident.HighestVcn;

                    //
                    //  Get out if there is nothing to delete.
                    //

                    if (Vcn1 < StartingVcn) {
                        try_return(NOTHING);
                    }

                    SizeInClusters = (Vcn1 - Attribute->Form.Nonresident.LowestVcn) + 1;
                    Vcn1 = Attribute->Form.Nonresident.LowestVcn;

                    NtfsCleanupAttributeContext( IrpContext, &Context );
                    NtfsInitializeAttributeContext( &Context );

                    NtfsLookupAttributeForScb( IrpContext, Scb, NULL, &Context );

                    NtfsAddAttributeAllocation( IrpContext,
                                                Scb,
                                                &Context,
                                                &Vcn1,
                                                &SizeInClusters );

                } else {

                    NtfsCleanupAttributeContext( IrpContext, &Context );
                    NtfsInitializeAttributeContext( &Context );

                    NtfsLookupAttributeForScb( IrpContext, Scb, NULL, &Context );

                    NtfsAddAttributeAllocation( IrpContext,
                                                Scb,
                                                &Context,
                                                NULL,
                                                NULL );

                }

            //
            //  If we truncated the file by removing a file record but didn't update
            //  the new allocation size then do so now.  We don't have to worry about
            //  this for the sparse deallocation path.
            //

            } else if (!UpdatedAllocationSize) {

                Scb->Header.AllocationSize.QuadPart = SizeInBytes;

                if (Scb->Header.ValidDataLength.QuadPart > SizeInBytes) {
                    Scb->Header.ValidDataLength.QuadPart = SizeInBytes;
                }

                if (Scb->Header.FileSize.QuadPart > SizeInBytes) {
                    Scb->Header.FileSize.QuadPart = SizeInBytes;
                }

                //
                //  Possibly update ValidDataToDisk
                //

                if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK ) &&
                    (SizeInBytes < Scb->ValidDataToDisk)) {

                    Scb->ValidDataToDisk = SizeInBytes;
                }
            }
        }

        //
        //  If this was a sparse deallocation, it is time to get out once we
        //  have fixed up the allocation information.
        //

        if (SplitMcb || (EndingVcn != MAXLONGLONG)) {
            try_return(NOTHING);
        }

        //
        //  We update the allocation size in the attribute, only for normal
        //  truncates (AddAttributeAllocation does this for SplitMcb case).
        //

        if (LogIt) {

#ifdef BENL_DBG
            BOOLEAN WroteIt;

            WroteIt =
#endif

            NtfsWriteFileSizes( IrpContext,
                                Scb,
                                &Scb->Header.ValidDataLength.QuadPart,
                                FALSE,
                                TRUE,
                                TRUE );
#ifdef BENL_DBG
            ASSERT( WroteIt );
#endif
        }

        //
        //  Free any reserved clusters in the space freed.
        //

        if ((EndingVcn == MAXLONGLONG) && (Scb->CompressionUnit != 0)) {

            NtfsFreeReservedClusters( Scb,
                                      LlBytesFromClusters(Vcb, StartingVcn),
                                      0 );
        }

    try_exit: NOTHING;
    } finally {

        //
        //  If we raised and have split the mcb and have not started a transaction
        //  throw out the modified range of the mcb. We do this because in this case the
        //  snapshot can then be discarded by a caller releasing the fcb involved see NtfsZeroData
        //  so that the normal truncation that occurs in ProcessException will be skipped
        //

        if (AbnormalTermination() && SplitMcb && (IrpContext->TransactionId == 0)) {

            ASSERT( Scb->ScbSnapshot );

            //
            //  Unload any modified ranges in the Mcb.
            //

            NtfsUnloadNtfsMcbRange( &Scb->Mcb, Scb->ScbSnapshot->LowestModifiedVcn, MAXLONGLONG, FALSE, FALSE );
        }

        DebugUnwind( NtfsDeleteAllocationInternal );

        //
        //  Cleanup the attribute context on the way out.
        //

        NtfsCleanupAttributeContext( IrpContext, &Context );
        NtfsCleanupAttributeContext( IrpContext, &TempContext );
    }

    DebugTrace( -1, Dbg, ("NtfsDeleteAllocationInternal -> VOID\n") );

    return;
}


ULONG
NtfsGetSizeForMappingPairs (
    IN PNTFS_MCB Mcb,
    IN ULONG BytesAvailable,
    IN VCN LowestVcn,
    IN PVCN StopOnVcn OPTIONAL,
    OUT PVCN StoppedOnVcn
    )

/*++

Routine Description:

    This routine calculates the size required to describe the given Mcb in
    a mapping pairs array.  The caller may specify how many bytes are available
    for mapping pairs storage, for the event that the entire Mcb cannot be
    be represented.  In any case, StoppedOnVcn returns the Vcn to supply to
    NtfsBuildMappingPairs in order to generate the specified number of bytes.
    In the event that the entire Mcb could not be described in the bytes available,
    StoppedOnVcn is also the correct value to specify to resume the building
    of mapping pairs in a subsequent record.

Arguments:

    Mcb - The Mcb describing new allocation.

    BytesAvailable - Bytes available for storing mapping pairs.  This routine
                     is guaranteed to stop before returning a count greater
                     than this.

    LowestVcn - Lowest Vcn field applying to the mapping pairs array

    StopOnVcn - If specified, calculating size at the first run starting with a Vcn
                beyond the specified Vcn

    StoppedOnVcn - Returns the Vcn on which a stop was necessary, or xxMax if
                   the entire Mcb could be stored.  This Vcn should be
                   subsequently supplied to NtfsBuildMappingPairs to generate
                   the calculated number of bytes.

Return Value:

    Size required required for entire new array in bytes.

--*/

{
    VCN NextVcn, CurrentVcn, LimitVcn;
    LCN CurrentLcn;
    VCN RunVcn;
    LCN RunLcn;
    BOOLEAN Found;
    LONGLONG RunCount;
    VCN HighestVcn;
    PVOID RangePtr;
    ULONG RunIndex;
    ULONG MSize = 0;
    ULONG LastSize = 0;
    BOOLEAN FoundRun = FALSE;

    PAGED_CODE();

    HighestVcn = MAXLONGLONG;

    //
    //  Initialize CurrentLcn as it will be initialized for decode.
    //

    CurrentLcn = 0;
    NextVcn = RunVcn = LowestVcn;

    //
    //  Limit ourselves to less than 32 bits for each mapping pair range.
    //  We use -2 here because we point to the Vcn to stop on, the length
    //  is one greater.
    //

    LimitVcn = MAXLONGLONG - 1;

    //
    //  Use the input stop point if smaller.
    //

    if (ARGUMENT_PRESENT( StopOnVcn )) {

        LimitVcn = *StopOnVcn;
    }

    Found = NtfsLookupNtfsMcbEntry( Mcb, RunVcn, &RunLcn, &RunCount, NULL, NULL, &RangePtr, &RunIndex );

    //
    //  Loop through the Mcb to calculate the size of the mapping array.
    //

    while (TRUE) {

        LONGLONG Change;
        PCHAR cp;

        //
        //  See if there is another entry in the Mcb.
        //

        if (!Found) {

            //
            //  If the caller did not specify StopOnVcn, then break out.
            //

            if (!ARGUMENT_PRESENT(StopOnVcn)) {
                break;
            }

            //
            //  Otherwise, describe the "hole" up to and including the
            //  Vcn we are stopping on.
            //

            RunVcn = NextVcn;
            RunLcn = UNUSED_LCN;

            RunCount = (LimitVcn - RunVcn) + 1;
            RunIndex = MAXULONG - 1;

        //
        //  If this is the first non-hole then we need to enforce a cluster
        //  per range limit.
        //

        } else if (!FoundRun &&
                   (RunLcn != UNUSED_LCN)) {

            if ((LowestVcn + MAX_CLUSTERS_PER_RANGE) <= LimitVcn) {

                //
                //  If we are already beyond the limit then set
                //  the limit back to just before the current run.
                //  We allow a hole which is larger than our limit.
                //

                if (RunVcn >= MAX_CLUSTERS_PER_RANGE) {

                    LimitVcn = RunVcn - 1;

                } else {

                    LimitVcn = LowestVcn + MAX_CLUSTERS_PER_RANGE - 1;
                }
            }

            //
            //  Other checks in the system should prevent rollover.
            //

            ASSERT( (LimitVcn + 1) >= LowestVcn );
            FoundRun = TRUE;
        }

        //
        //  If we were asked to stop after a certain Vcn, or we have
        //  exceeded our limit then stop now.
        //

        if (RunVcn > LimitVcn) {

            if (HighestVcn == MAXLONGLONG) {
                HighestVcn = LimitVcn + 1;
            }
            break;

        //
        //  If this run extends beyond the current end of this attribute
        //  record, then we still need to stop where we are supposed to
        //  after outputting this run.
        //

        } else if ((RunVcn + RunCount) > LimitVcn) {
            HighestVcn = LimitVcn + 1;
        }

        //
        //  Advance the RunIndex for the next call.
        //

        RunIndex += 1;

        //
        //  Add in one for the count byte.
        //

        MSize += 1;

        //
        //  NextVcn becomes current Vcn and we calculate the new NextVcn.
        //

        CurrentVcn = RunVcn;
        NextVcn = RunVcn + RunCount;

        //
        //  Calculate the Vcn change to store.
        //

        Change = NextVcn - CurrentVcn;

        //
        //  Now calculate the first byte to actually output
        //

        if (Change < 0) {

            GetNegativeByte( (PLARGE_INTEGER)&Change, &cp );

        } else {

            GetPositiveByte( (PLARGE_INTEGER)&Change, &cp );
        }

        //
        //  Now add in the number of Vcn change bytes.
        //

        MSize += (ULONG)(cp - (PCHAR)&Change + 1);

        //
        //  Do not output any Lcn bytes if it is the unused Lcn.
        //

        if (RunLcn != UNUSED_LCN) {

            //
            //  Calculate the Lcn change to store.
            //

            Change = RunLcn - CurrentLcn;

            //
            //  Now calculate the first byte to actually output
            //

            if (Change < 0) {

                GetNegativeByte( (PLARGE_INTEGER)&Change, &cp );

            } else {

                GetPositiveByte( (PLARGE_INTEGER)&Change, &cp );
            }

            //
            //  Now add in the number of Lcn change bytes.
            //

            MSize += (ULONG)(cp - (PCHAR)&Change + 1);

            CurrentLcn = RunLcn;

            //
            //  If this is the first run then enforce the 32 bit limit.
            //

            if (!FoundRun) {

                if ((LowestVcn + MAX_CLUSTERS_PER_RANGE - 1) < LimitVcn) {

                    LimitVcn = LowestVcn + MAX_CLUSTERS_PER_RANGE - 1;
                }
                FoundRun = TRUE;
            }
        }

        //
        //  Now see if we can still store the required number of bytes,
        //  and get out if not.
        //

        if ((MSize + 1) > BytesAvailable) {

            HighestVcn = RunVcn;
            MSize = LastSize;
            break;
        }

        //
        //  Now advance some locals before looping back.
        //

        LastSize = MSize;

        Found = NtfsGetSequentialMcbEntry( Mcb, &RangePtr, RunIndex, &RunVcn, &RunLcn, &RunCount );
    }

    //
    //  The caller had sufficient bytes available to store at least one
    //  run, or that we were able to process the entire (empty) Mcb.
    //

    ASSERT( (MSize != 0) || (HighestVcn == LimitVcn + 1) );

    //
    //  Return the Vcn we stopped on (or xxMax) and the size caculated,
    //  adding one for the terminating 0.
    //

    *StoppedOnVcn = HighestVcn;

    return MSize + 1;
}


BOOLEAN
NtfsBuildMappingPairs (
    IN PNTFS_MCB Mcb,
    IN VCN LowestVcn,
    IN OUT PVCN HighestVcn,
    OUT PCHAR MappingPairs
    )

/*++

Routine Description:

    This routine builds a new mapping pairs array or adds to an old one.

    At this time, this routine only supports adding to the end of the
    Mapping Pairs Array.

Arguments:

    Mcb - The Mcb describing new allocation.

    LowestVcn - Lowest Vcn field applying to the mapping pairs array

    HighestVcn - On input supplies the highest Vcn, after which we are to stop.
                 On output, returns the actual Highest Vcn represented in the
                 MappingPairs array, or LlNeg1 if the array is empty.

    MappingPairs - Points to the current mapping pairs array to be extended.
                   To build a new array, the byte pointed to must contain 0.

Return Value:

    BOOLEAN - TRUE if this mapping pair only describes a hole, FALSE otherwise.

--*/

{
    VCN NextVcn, CurrentVcn;
    LCN CurrentLcn;
    VCN RunVcn;
    LCN RunLcn;
    BOOLEAN Found;
    LONGLONG RunCount;
    PVOID RangePtr;
    ULONG RunIndex;
    BOOLEAN SingleHole = TRUE;

    PAGED_CODE();

    //
    //  Initialize NextVcn and CurrentLcn as they will be initialized for decode.
    //

    CurrentLcn = 0;
    NextVcn = RunVcn = LowestVcn;

    Found = NtfsLookupNtfsMcbEntry( Mcb, RunVcn, &RunLcn, &RunCount, NULL, NULL, &RangePtr, &RunIndex );

    //
    //  Loop through the Mcb to calculate the size of the mapping array.
    //

    while (TRUE) {

        LONGLONG ChangeV, ChangeL;
        PCHAR cp;
        ULONG SizeV;
        ULONG SizeL;

        //
        //  See if there is another entry in the Mcb.
        //

        if (!Found) {

            //
            //  Break out in the normal case
            //

            if (*HighestVcn == MAXLONGLONG) {
                break;
            }

            //
            //  Otherwise, describe the "hole" up to and including the
            //  Vcn we are stopping on.
            //

            RunVcn = NextVcn;
            RunLcn = UNUSED_LCN;
            RunCount = *HighestVcn - NextVcn;
            RunIndex = MAXULONG - 1;
        }

        //
        //  Advance the RunIndex for the next call.
        //

        RunIndex += 1;

        //
        //  Exit loop if we hit the HighestVcn we are looking for.
        //

        if (RunVcn >= *HighestVcn) {
            break;
        }

        //
        //  This run may go beyond the highest we are looking for, if so
        //  we need to shrink the count.
        //

        if ((RunVcn + RunCount) > *HighestVcn) {
            RunCount = *HighestVcn - RunVcn;
        }

        //
        //  NextVcn becomes current Vcn and we calculate the new NextVcn.
        //

        CurrentVcn = RunVcn;
        NextVcn = RunVcn + RunCount;

        //
        //  Calculate the Vcn change to store.
        //

        ChangeV = NextVcn - CurrentVcn;

        //
        //  Now calculate the first byte to actually output
        //

        if (ChangeV < 0) {

            GetNegativeByte( (PLARGE_INTEGER)&ChangeV, &cp );

        } else {

            GetPositiveByte( (PLARGE_INTEGER)&ChangeV, &cp );
        }

        //
        //  Now add in the number of Vcn change bytes.
        //

        SizeV = (ULONG)(cp - (PCHAR)&ChangeV + 1);

        //
        //  Do not output any Lcn bytes if it is the unused Lcn.
        //

        SizeL = 0;
        if (RunLcn != UNUSED_LCN) {

            //
            //  Calculate the Lcn change to store.
            //

            ChangeL = RunLcn - CurrentLcn;

            //
            //  Now calculate the first byte to actually output
            //

            if (ChangeL < 0) {

                GetNegativeByte( (PLARGE_INTEGER)&ChangeL, &cp );

            } else {

                GetPositiveByte( (PLARGE_INTEGER)&ChangeL, &cp );
            }

            //
            //  Now add in the number of Lcn change bytes.
            //

            SizeL = (ULONG)(cp - (PCHAR)&ChangeL) + 1;

            //
            //  Now advance CurrentLcn before looping back.
            //

            CurrentLcn = RunLcn;
            SingleHole = FALSE;
        }

        //
        //  Now we can produce our outputs to the MappingPairs array.
        //

        *MappingPairs++ = (CHAR)(SizeV + (SizeL * 16));

        while (SizeV != 0) {
            *MappingPairs++ = (CHAR)(((ULONG)ChangeV) & 0xFF);
            ChangeV = ChangeV >> 8;
            SizeV -= 1;
        }

        while (SizeL != 0) {
            *MappingPairs++ = (CHAR)(((ULONG)ChangeL) & 0xFF);
            ChangeL = ChangeL >> 8;
            SizeL -= 1;
        }

        Found = NtfsGetSequentialMcbEntry( Mcb, &RangePtr, RunIndex, &RunVcn, &RunLcn, &RunCount );
    }

    //
    //  Terminate the size with a 0 byte.
    //

    *MappingPairs = 0;

    //
    //  Also return the actual highest Vcn.
    //

    *HighestVcn = NextVcn - 1;

    return SingleHole;
}

VCN
NtfsGetHighestVcn (
    IN PIRP_CONTEXT IrpContext,
    IN VCN LowestVcn,
    IN PCHAR EndOfMappingPairs,
    IN PCHAR MappingPairs
    )

/*++

Routine Description:

    This routine returns the highest Vcn from a mapping pairs array.  This
    routine is intended for restart, in order to update the HighestVcn field
    and possibly AllocatedLength in an attribute record after updating the
    MappingPairs array.

Arguments:

    LowestVcn - Lowest Vcn field applying to the mapping pairs array

    EndOfMappingPairs - Points to the byte RIGHT AFTER the mapping pairs array

    MappingPairs - Points to the mapping pairs array from which the highest
                   Vcn is to be extracted.

Return Value:

    The Highest Vcn represented by the MappingPairs array.

--*/

{
    VCN CurrentVcn, NextVcn;
    ULONG VcnBytes, LcnBytes;
    LONGLONG Change;
    PCHAR ch = MappingPairs;
    PCHAR VcnStart;

    PAGED_CODE();

    //
    //  Implement the decompression algorithm, as defined in ntfs.h.
    //

    NextVcn = LowestVcn;
    ch = MappingPairs;

    //
    //  Loop to process mapping pairs.
    //

    while ((ch < EndOfMappingPairs) && !IsCharZero(*ch)) {

        //
        // Set Current Vcn from initial value or last pass through loop.
        //

        CurrentVcn = NextVcn;

        //
        //  Extract the counts from the two nibbles of this byte.
        //

        VcnBytes = *ch & 0xF;
        LcnBytes = (*ch++ >> 4) & 0xF;  // avoid sign extended case

        VcnStart = ch;

        //
        //  Calculate next mapping pair location first and check for buffer overrun
        //

        ch += VcnBytes + LcnBytes;

        //
        //  Extract the Vcn change (use of RtlCopyMemory works for little-Endian)
        //  and update NextVcn.
        //

        Change = 0;

        if ((ch > EndOfMappingPairs) ||
            VcnBytes > 8 ||
            LcnBytes > 8 ||
            IsCharLtrZero(*(VcnStart + VcnBytes - 1))) {

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, NULL );
        }

        RtlCopyMemory( &Change, VcnStart, VcnBytes );
        NextVcn = NextVcn + Change;
    }

    Change = NextVcn - 1;
    return *(PVCN)&Change;
}


BOOLEAN
NtfsReserveClusters (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PSCB Scb,
    IN LONGLONG FileOffset,
    IN ULONG ByteCount
    )

/*++

Routine Description:

    This routine reserves all clusters that would be required to write
    the full range of compression units covered by the described range
    of Vcns.  All clusters in the range are reserved, without regard to
    how many clusters are already reserved in that range.  Not paying
    attention to how many clusters are already allocated in that range
    is not only a simplification, but it is also necessary, since we
    sometimes deallocate all existing clusters anyway, and make them
    ineligible for reallocation in the same transaction.  Thus in the
    worst case you do always need an additional 16 clusters when a
    compression unit is first modified. Note that although we could
    specifically reserve (double-reserve, in fact) the entire allocation
    size of the stream, when reserving from the volume, we never reserve
    more than AllocationSize + MM_MAXIMUM_DISK_IO_SIZE - size actually
    allocated, since the worst we could ever need to doubly allocate is
    limited by the maximum flush size.

    For user-mapped streams, we have no way of keeping track of dirty
    pages, so we effectivel always reserve AllocationSize +
    MM_MAXIMUM_DISK_IO_SIZE.

    This routine is called from FastIo, and therefore has no IrpContext.

Arguments:

    IrpContext - If IrpContext is not specified, then not all data is
                 available to determine if the clusters can be reserved,
                 and FALSE may be returned unnecessarily.  This case
                 is intended for the fast I/O path, which will just
                 force us to take the long path to write.

    Scb - Address of a compressed stream for which we are reserving space

    FileOffset - Starting byte being modified by caller

    ByteCount - Number of bytes being modified by caller

Return Value:

    FALSE if not all clusters could be reserved
    TRUE if all clusters were reserved

--*/

{
    ULONG FirstBit, LastBit, CurrentLastBit;
    ULONG FirstRange, LastRange;
    PRESERVED_BITMAP_RANGE FreeBitmap, NextBitmap, CurrentBitmap;
    ULONG CompressionShift;
    PVCB Vcb = Scb->Vcb;
    ULONG SizeTemp;
    LONGLONG TempL;
    PVOID NewBitmapBuffer;
    BOOLEAN ReturnValue = FALSE;
    ULONG MappedFile;
    BOOLEAN FlippedBit = FALSE;

    ASSERT( Scb->Header.NodeTypeCode == NTFS_NTC_SCB_DATA );

    //
    //  Nothing to do if byte count is zero.
    //

    if (ByteCount == 0) { return TRUE; }

    //
    //  Calculate first and last bits to reserve.
    //

    CompressionShift = Vcb->ClusterShift + (ULONG)Scb->CompressionUnitShift;

    FirstBit = ((ULONG) Int64ShraMod32( FileOffset, (CompressionShift) )) & NTFS_BITMAP_RANGE_MASK;
    FirstRange = (ULONG) Int64ShraMod32( FileOffset, CompressionShift + NTFS_BITMAP_RANGE_SHIFT );

    LastBit = ((ULONG) Int64ShraMod32( FileOffset + ByteCount - 1, CompressionShift )) & NTFS_BITMAP_RANGE_MASK;
    LastRange = (ULONG) Int64ShraMod32( FileOffset + ByteCount - 1,
                                        CompressionShift + NTFS_BITMAP_RANGE_SHIFT );
    MappedFile = FlagOn( Scb->Header.Flags, FSRTL_FLAG_USER_MAPPED_FILE );

    //
    //  Make sure we started with numbers in range.
    //

    ASSERT( (((LONGLONG) FirstRange << (CompressionShift + NTFS_BITMAP_RANGE_SHIFT)) +
             ((LONGLONG)(FirstBit + 1) << CompressionShift)) > FileOffset );

    ASSERT( (FirstRange < LastRange) || (LastBit >= FirstBit) );
    ASSERT( FileOffset + ByteCount <= Scb->Header.AllocationSize.QuadPart );

    //
    //  Purge the cache since getting the bitmap may be blocked behind the mft
    //  which needs to wait for the cache to purge
    //

    if (IrpContext) {
        NtfsPurgeFileRecordCache( IrpContext );
    }

    NtfsAcquireResourceExclusive( IrpContext, Vcb->BitmapScb, TRUE );
    NtfsAcquireReservedClusters( Vcb );

    //
    //  Loop through all of the bitmap ranges for this request.
    //

    while (TRUE) {

        CurrentBitmap = NULL;

        //
        //  If we are at the last range then set the current last bit to
        //  our final last bit.
        //

        CurrentLastBit = LastBit;
        if (FirstRange != LastRange) {

            CurrentLastBit = NTFS_BITMAP_RANGE_MASK;
        }

        //
        //  If there is no bitmap then create the first entry in the list.
        //

        if (Scb->ScbType.Data.ReservedBitMap == NULL) {

            //
            //  If we are at range zero and the bitcount is not
            //  too high then use the basic model.
            //

            if ((LastRange == 0) && (CurrentLastBit < NTFS_BITMAP_MAX_BASIC_SIZE)) {

                SizeTemp = NtfsBasicBitmapSize( CurrentLastBit + 1 );

                //
                //  Allocate a buffer for the basic bitmap.
                //

                CurrentBitmap = NtfsAllocatePoolNoRaise( PagedPool, SizeTemp );

                //
                //  Initialize the data if there is no error.
                //

                if (CurrentBitmap == NULL) { goto AllocationFailure; }

                //
                //  Initialize the new structure.
                //

                RtlZeroMemory( CurrentBitmap, SizeTemp );
                RtlInitializeBitMap( &CurrentBitmap->Bitmap,
                                     &CurrentBitmap->RangeOffset,
                                     (SizeTemp - FIELD_OFFSET( RESERVED_BITMAP_RANGE, RangeOffset )) * 8);

            //
            //  Allocate a link entry and create the bitmap.  We will defer
            //  allocating the buffer for the bitmap until later.
            //

            } else {

                CurrentBitmap = NtfsAllocatePoolNoRaise( PagedPool, sizeof( RESERVED_BITMAP_RANGE ));

                if (CurrentBitmap == NULL) { goto AllocationFailure; }

                RtlZeroMemory( CurrentBitmap, sizeof( RESERVED_BITMAP_RANGE ));

                InitializeListHead( &CurrentBitmap->Links );
                CurrentBitmap->RangeOffset = FirstRange;
            }

            //
            //  Update our pointer to the reserved bitmap.
            //

            Scb->ScbType.Data.ReservedBitMap = CurrentBitmap;

        //
        //  Look through the existing ranges to find the range we are interested in.
        //  If we currently have the basic single bitmap structure
        //  then we can either use it or must convert it.
        //

        } else if (Scb->ScbType.Data.ReservedBitMap->Links.Flink == NULL) {

            //
            //  If we are accessing range zero then grow the bitmap if necessary.
            //

            if ((FirstRange == 0) && (CurrentLastBit < NTFS_BITMAP_MAX_BASIC_SIZE)) {

                //
                //  Remember this bitmap.
                //

                NextBitmap = Scb->ScbType.Data.ReservedBitMap;
                if (CurrentLastBit >= NextBitmap->Bitmap.SizeOfBitMap) {

                    SizeTemp = NtfsBasicBitmapSize( CurrentLastBit + 1 );
                    CurrentBitmap = NtfsAllocatePoolNoRaise( PagedPool, SizeTemp );

                    if (CurrentBitmap == NULL) { goto AllocationFailure; }

                    RtlZeroMemory( CurrentBitmap, SizeTemp );
                    RtlInitializeBitMap( &CurrentBitmap->Bitmap,
                                         &CurrentBitmap->RangeOffset,
                                         (SizeTemp - FIELD_OFFSET( RESERVED_BITMAP_RANGE, RangeOffset )) * 8);

                    CurrentBitmap->BasicDirtyBits = NextBitmap->BasicDirtyBits;

                    RtlCopyMemory( CurrentBitmap->Bitmap.Buffer,
                                   NextBitmap->Bitmap.Buffer,
                                   NextBitmap->Bitmap.SizeOfBitMap / 8 );

                    //
                    //  Now store this into the Scb.
                    //

                    Scb->ScbType.Data.ReservedBitMap = CurrentBitmap;
                    NtfsFreePool( NextBitmap );

                } else {

                    CurrentBitmap = NextBitmap;
                }

            //
            //  Otherwise we want to convert to the linked list of bitmap ranges.
            //

            } else {

                NextBitmap = NtfsAllocatePoolNoRaise( PagedPool, sizeof( RESERVED_BITMAP_RANGE ));

                if (NextBitmap == NULL) { goto AllocationFailure; }

                //
                //  Update the new structure.
                //

                RtlZeroMemory( NextBitmap, sizeof( RESERVED_BITMAP_RANGE ));

                InitializeListHead( &NextBitmap->Links );
                NextBitmap->DirtyBits = Scb->ScbType.Data.ReservedBitMap->BasicDirtyBits;

                SizeTemp = Scb->ScbType.Data.ReservedBitMap->Bitmap.SizeOfBitMap / 8;

                //
                //  We will use the existing bitmap as the buffer for the new bitmap.
                //  Move the bits to the start of the buffer and then zero
                //  the remaining bytes.
                //

                RtlMoveMemory( Scb->ScbType.Data.ReservedBitMap,
                               Scb->ScbType.Data.ReservedBitMap->Bitmap.Buffer,
                               SizeTemp );

                RtlZeroMemory( Add2Ptr( Scb->ScbType.Data.ReservedBitMap, SizeTemp ),
                               sizeof( LIST_ENTRY ) + sizeof( RTL_BITMAP ));

                //
                //  Limit ourselves to the maximum range size.
                //

                SizeTemp = (SizeTemp + sizeof( LIST_ENTRY ) + sizeof( RTL_BITMAP )) * 8;
                if (SizeTemp > NTFS_BITMAP_RANGE_SIZE) {

                    SizeTemp = NTFS_BITMAP_RANGE_SIZE;
                }

                RtlInitializeBitMap( &NextBitmap->Bitmap,
                                     (PULONG) Scb->ScbType.Data.ReservedBitMap,
                                     SizeTemp );

                //
                //  Now point to this new bitmap.
                //

                Scb->ScbType.Data.ReservedBitMap = NextBitmap;
            }
        }

        //
        //  If we didn't find the correct bitmap above then scan the list looking
        //  for the entry.
        //

        if (CurrentBitmap == NULL) {

            //
            //  Walk the list looking for a matching entry.
            //

            NextBitmap = Scb->ScbType.Data.ReservedBitMap;
            FreeBitmap = NULL;

            while (TRUE) {

                //
                //  Exit if we found the correct range.
                //

                if (NextBitmap->RangeOffset == FirstRange) {

                    CurrentBitmap = NextBitmap;
                    break;
                }

                //
                //  Remember if this is a free range.
                //

                if (NextBitmap->DirtyBits == 0) {

                    FreeBitmap = NextBitmap;
                }

                //
                //  Exit if we are past our target and have a empty range then break out.
                //

                if ((NextBitmap->RangeOffset > FirstRange) &&
                    (FreeBitmap != NULL)) {

                    break;
                }

                //
                //  Move to the next entry.
                //

                NextBitmap = CONTAINING_RECORD( NextBitmap->Links.Flink,
                                                RESERVED_BITMAP_RANGE,
                                                Links );

                //
                //  Break out if we are back at the beginning of the list.
                //

                if (NextBitmap == Scb->ScbType.Data.ReservedBitMap) {

                    break;
                }
            }

            //
            //  If we still don't have the bitmap then we can look to see if
            //  we found any available free bitmaps.
            //

            if (CurrentBitmap == NULL) {

                //
                //  We lucked out and found a free bitmap.  Let's use it for
                //  this new range.
                //

                if (FreeBitmap != NULL) {

                    CurrentBitmap = FreeBitmap;

                    //
                    //  Go ahead and remove it from the list.  Deal with the cases where
                    //  we are the first entry and possibly the only entry.
                    //

                    if (Scb->ScbType.Data.ReservedBitMap == FreeBitmap) {

                        if (IsListEmpty( &FreeBitmap->Links )) {

                            Scb->ScbType.Data.ReservedBitMap = NULL;

                        } else {

                            Scb->ScbType.Data.ReservedBitMap = CONTAINING_RECORD( FreeBitmap->Links.Flink,
                                                                                     RESERVED_BITMAP_RANGE,
                                                                                     Links );
                        }
                    }

                    //
                    //  Remove this entry from the list.
                    //

                    RemoveEntryList( &FreeBitmap->Links );

                //
                //  We need to allocate a new range and insert it
                //  in the correct location.
                //

                } else {

                    //
                    //  Allocate a new bitmap and remember we need to insert it into the list.
                    //

                    CurrentBitmap = NtfsAllocatePoolNoRaise( PagedPool, sizeof( RESERVED_BITMAP_RANGE ));

                    if (CurrentBitmap == NULL) { goto AllocationFailure; }

                    RtlZeroMemory( CurrentBitmap, sizeof( RESERVED_BITMAP_RANGE ));
                }

                //
                //  Set the correct range value in the new bitmap.
                //

                CurrentBitmap->RangeOffset = FirstRange;

                //
                //  Now walk through and insert the new range into the list.  Start by checking if
                //  we are the only entry in the list.
                //

                if (Scb->ScbType.Data.ReservedBitMap == NULL) {

                    InitializeListHead( &CurrentBitmap->Links );
                    Scb->ScbType.Data.ReservedBitMap = CurrentBitmap;

                } else {

                    NextBitmap = Scb->ScbType.Data.ReservedBitMap;

                    //
                    //  Walk through the list if we are not the new first element.
                    //

                    if (CurrentBitmap->RangeOffset > NextBitmap->RangeOffset) {

                        do {

                            //
                            //  Move to the next entry.
                            //

                            NextBitmap = CONTAINING_RECORD( NextBitmap->Links.Flink,
                                                            RESERVED_BITMAP_RANGE,
                                                            Links );

                            ASSERT( NextBitmap->RangeOffset != CurrentBitmap->RangeOffset );

                            //
                            //  Exit if we are at the last entry.
                            //

                            if (NextBitmap == Scb->ScbType.Data.ReservedBitMap ) {

                                break;
                            }

                        //
                        //  Continue until we find an entry larger than us.
                        //

                        } while (CurrentBitmap->RangeOffset > NextBitmap->RangeOffset);

                    //
                    //  We are the new first element.
                    //

                    } else {

                        Scb->ScbType.Data.ReservedBitMap = CurrentBitmap;
                    }

                    //
                    //  Insert the new entry ahead of the next entry we found.
                    //

                    InsertTailList( &NextBitmap->Links, &CurrentBitmap->Links );
                }
            }
        }

        //
        //  We have a current bitmap.  Make sure it is large enough for the current
        //  bit.
        //

        if (CurrentBitmap->Bitmap.SizeOfBitMap <= CurrentLastBit) {

            //
            //  We should already have adjusted the sizes for the basic bitmap.
            //

            ASSERT( CurrentBitmap->Links.Flink != NULL );

            SizeTemp = NtfsBitmapSize( CurrentLastBit + 1 );

            //
            //  Allocate the new buffer and copy the previous bits over.
            //

            NewBitmapBuffer = NtfsAllocatePoolNoRaise( PagedPool, SizeTemp );

            if (NewBitmapBuffer == NULL) { goto AllocationFailure; }

            if (CurrentBitmap->Bitmap.SizeOfBitMap != 0) {

                RtlCopyMemory( NewBitmapBuffer,
                               CurrentBitmap->Bitmap.Buffer,
                               CurrentBitmap->Bitmap.SizeOfBitMap / 8 );

                NtfsFreePool( CurrentBitmap->Bitmap.Buffer );
            }

            RtlZeroMemory( Add2Ptr( NewBitmapBuffer, CurrentBitmap->Bitmap.SizeOfBitMap / 8 ),
                           SizeTemp - (CurrentBitmap->Bitmap.SizeOfBitMap / 8) );

            //
            //  Limit the bitmap size by the max range size.
            //

            SizeTemp *= 8;

            if (SizeTemp > NTFS_BITMAP_RANGE_SIZE) {

                SizeTemp = NTFS_BITMAP_RANGE_SIZE;
            }

            RtlInitializeBitMap( &CurrentBitmap->Bitmap,
                                 NewBitmapBuffer,
                                 SizeTemp );
        }

        //
        //  Figure out the worst case reservation required for this Scb, in bytes.
        //

        TempL = NtfsCalculateNeededReservedSpace( Scb );

        //
        //  Now loop to reserve the space, a compression unit at a time.
        //  We use the security fast mutex as a convenient end resource.
        //

        do {

            //
            //  If this compression unit is not already reserved do it now.
            //

            FlippedBit = FALSE;
            if (!RtlCheckBit( &CurrentBitmap->Bitmap, FirstBit )) {

                //
                //  If there is not sufficient space on the volume, then
                //  we must see if this Scb is totally reserved anyway.
                //

                if (((Vcb->TotalReserved + (Int64ShraMod32( Vcb->TotalReserved, 8 )) +
                     (1 << Scb->CompressionUnitShift)) >= Vcb->FreeClusters) &&
                    (Scb->ScbType.Data.TotalReserved < TempL) &&
#ifdef BRIANDBG
                    !NtfsIgnoreReserved &&
#endif
                    (FlagOn(Scb->ScbState, SCB_STATE_WRITE_ACCESS_SEEN))) {

                    NtfsReleaseReservedClusters( Vcb );
                    NtfsReleaseResource( IrpContext, Vcb->BitmapScb );
                    return FALSE;
                }

                //
                //  Reserve this compression unit and increase the number of dirty
                //  bits for this range.
                //

                SetFlag( CurrentBitmap->Bitmap.Buffer[FirstBit / 32], 1 << (FirstBit % 32) );
                if (CurrentBitmap->Links.Flink != NULL) {

                    CurrentBitmap->DirtyBits += 1;

                } else {

                    CurrentBitmap->BasicDirtyBits += 1;
                }

                FlippedBit = TRUE;
            }

            if (FlippedBit || (MappedFile && (Scb->ScbType.Data.TotalReserved <= TempL))) {

                //
                //  Increased TotalReserved bytes in the Scb.
                //

                Scb->ScbType.Data.TotalReserved += Scb->CompressionUnit;
                ASSERT( Scb->CompressionUnit != 0 );
                ASSERT( (Scb->CompressionUnitShift != 0) ||
                        (Vcb->BytesPerCluster == 0x10000) );

                //
                //  Increase total reserved clusters in the Vcb, if the user has
                //  write access.  (Otherwise this must be a call from a read
                //  to a usermapped section.)
                //

                if (FlagOn(Scb->ScbState, SCB_STATE_WRITE_ACCESS_SEEN)) {
                    Vcb->TotalReserved += 1 << Scb->CompressionUnitShift;
                }

                TempL -= Scb->CompressionUnit;
                TempL += Int64ShraMod32( Scb->CompressionUnit, 8 );
            }

            FirstBit += 1;
        } while (FirstBit <= CurrentLastBit);

        //
        //  Exit if we have reached the last range.
        //

        if (FirstRange == LastRange) { break; }

        FirstRange += 1;
        FirstBit = 0;
    }

    ReturnValue = TRUE;

AllocationFailure:

    NtfsReleaseReservedClusters( Vcb );
    NtfsReleaseResource( IrpContext, Vcb->BitmapScb );

    //
    //  If we have an Irp Context then we can raise insufficient resources.  Otherwise
    //  return FALSE.
    //

    if (!ReturnValue && ARGUMENT_PRESENT( IrpContext )) {
        NtfsRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES, NULL, NULL );
    }

    return ReturnValue;
}



VOID
NtfsFreeReservedClusters (
    IN PSCB Scb,
    IN LONGLONG FileOffset,
    IN ULONG ByteCount
    )

/*++

Routine Description:

    This routine frees any previously reserved clusters in the specified range.

Arguments:

    Scb - Address of a compressed stream for which we are freeing reserved space

    FileOffset - Starting byte being freed

    ByteCount - Number of bytes being freed by caller, or 0 if to end of file

Return Value:

    None (all errors simply raise)

--*/

{
    ULONG FirstBit, LastBit, CurrentLastBit;
    ULONG FirstRange, LastRange;
    ULONG CompressionShift;
    PRESERVED_BITMAP_RANGE CurrentBitmap = NULL;
    PUSHORT DirtyBits;
    PRESERVED_BITMAP_RANGE NextBitmap;
    PVCB Vcb = Scb->Vcb;
    LONGLONG TempL;
    ULONG MappedFile;

    NtfsAcquireReservedClusters( Vcb );

    MappedFile = FlagOn( Scb->Header.Flags, FSRTL_FLAG_USER_MAPPED_FILE );

    //
    //  If there is no bitmap for non mapped files or the reserved count is zero we
    //  can get out immediately.
    //

    if ((Scb->Header.NodeTypeCode != NTFS_NTC_SCB_DATA) ||
        (NULL == Scb->ScbType.Data.ReservedBitMap) ||
        (Scb->ScbType.Data.TotalReserved == 0)) {
        NtfsReleaseReservedClusters( Vcb );
        return;
    }

    TempL = NtfsCalculateNeededReservedSpace( Scb );

    if (MappedFile) {

        //
        //  Mapped files can only shrink reserved down to upper limit
        //

        if (Scb->ScbType.Data.TotalReserved <= TempL + Scb->CompressionUnit) {
            NtfsReleaseReservedClusters( Vcb );
            return;
        }
    }

    //
    //  Calculate first bit to free, and initialize LastBit
    //

    CompressionShift = Vcb->ClusterShift + (ULONG)Scb->CompressionUnitShift;
    FirstBit = ((ULONG) Int64ShraMod32( FileOffset, CompressionShift )) & NTFS_BITMAP_RANGE_MASK;
    FirstRange = (ULONG) Int64ShraMod32( FileOffset, CompressionShift + NTFS_BITMAP_RANGE_SHIFT );
    LastRange = MAXULONG;
    LastBit = MAXULONG;

    //
    //  If ByteCount was specified, then calculate LastBit.
    //

    if (ByteCount != 0) {
        LastBit = ((ULONG) Int64ShraMod32( FileOffset + ByteCount - 1, CompressionShift )) & NTFS_BITMAP_RANGE_MASK;
        LastRange = (ULONG) Int64ShraMod32( FileOffset + ByteCount - 1,
                                            CompressionShift + NTFS_BITMAP_RANGE_SHIFT );
    }

    //
    //  Make sure we started with numbers in range.
    //

    ASSERT( (((LONGLONG) FirstRange << (CompressionShift + NTFS_BITMAP_RANGE_SHIFT)) +
             ((LONGLONG)(FirstBit + 1) << CompressionShift)) > FileOffset );

    ASSERT( (FirstRange < LastRange) || (LastBit >= FirstBit) );

    //
    //  Look for the first range which lies within our input range.
    //

    NextBitmap = Scb->ScbType.Data.ReservedBitMap;

    //
    //  If this is a basic bitmap range then our input should be range zero.
    //

    if (NextBitmap->Links.Flink == NULL) {

        if (FirstRange == 0) {

            CurrentBitmap = NextBitmap;
            DirtyBits = &CurrentBitmap->BasicDirtyBits;
        }

    //
    //  Otherwise loop through the links.
    //

    } else {

        do {

            //
            //  Check if this bitmap is within the range being checked.
            //

            if (NextBitmap->RangeOffset >= FirstRange) {

                if (NextBitmap->RangeOffset <= LastRange) {

                    CurrentBitmap = NextBitmap;
                    DirtyBits = &CurrentBitmap->DirtyBits;

                    if (NextBitmap->RangeOffset != FirstRange) {

                        FirstBit = 0;
                        FirstRange = NextBitmap->RangeOffset;
                    }
                }

                break;
            }

            NextBitmap = CONTAINING_RECORD( NextBitmap->Links.Flink,
                                            RESERVED_BITMAP_RANGE,
                                            Links );

        } while (NextBitmap != Scb->ScbType.Data.ReservedBitMap);
    }

    //
    //  If we didn't find a match we can exit.
    //

    if (CurrentBitmap == NULL) {

        NtfsReleaseReservedClusters( Vcb );
        return;
    }

    //
    //  Loop for each bitmap in the input range.
    //

    while (TRUE) {

        //
        //  If we are at the last range then use the input last bit.
        //

        CurrentLastBit = LastBit;
        if (FirstRange != LastRange) {

            CurrentLastBit = NTFS_BITMAP_RANGE_MASK;
        }

        //
        //  Under no circumstances should we go off the end!
        //

        if (CurrentLastBit >= CurrentBitmap->Bitmap.SizeOfBitMap) {
            CurrentLastBit = CurrentBitmap->Bitmap.SizeOfBitMap - 1;
        }

        //
        //  Now loop to free the space, a compression unit at a time.
        //  We use the security fast mutex as a convenient end resource.
        //

        if (MappedFile || (*DirtyBits != 0)) {

            while (FirstBit <= CurrentLastBit) {

                //
                //  If this compression unit is reserved, then free it.
                //

                if (MappedFile || RtlCheckBit( &CurrentBitmap->Bitmap, FirstBit )) {

                    //
                    //  Free this compression unit and decrement the dirty bits
                    //  for this bitmap if required.
                    //

                    if (!MappedFile) {
                        ClearFlag( CurrentBitmap->Bitmap.Buffer[FirstBit / 32], 1 << (FirstBit % 32) );
                    }

                    //
                    //  Decrease TotalReserved bytes in the Scb.
                    //

                    ASSERT( Scb->ScbType.Data.TotalReserved >= Scb->CompressionUnit );
                    Scb->ScbType.Data.TotalReserved -= Scb->CompressionUnit;
                    ASSERT( Scb->CompressionUnit != 0 );

                    //
                    //  Decrease total reserved clusters in the Vcb, if we are counting
                    //  against the Vcb.
                    //

                    if (FlagOn(Scb->ScbState, SCB_STATE_WRITE_ACCESS_SEEN)) {
                        ASSERT(Vcb->TotalReserved >= (1  << Scb->CompressionUnitShift));
                        Vcb->TotalReserved -= 1 << Scb->CompressionUnitShift;
                    }

                    if (MappedFile) {

                        TempL += Scb->CompressionUnit;
                        TempL -= Int64ShraMod32( Scb->CompressionUnit, 8 );

                        if (Scb->ScbType.Data.TotalReserved <= TempL) {
                            break;
                        }
                    }

                    //
                    //  Go ahead and break out if the count of dirty bits goes to zero.
                    //

                    ASSERT( MappedFile || *DirtyBits != 0 );

                    if (!MappedFile) {
                        *DirtyBits -= 1;

                        if (*DirtyBits == 0) { break; }
                    }
                }
                FirstBit += 1;
            }
        }

        //
        //  Break out if we are last the last range or there is no next range
        //  or we're mapped and not at the limit
        //

        if ((NULL == CurrentBitmap->Links.Flink) ||
            (FirstRange == LastRange) ||
            (MappedFile &&
             (Scb->ScbType.Data.TotalReserved <= TempL))) {

            break;
        }

        //
        //  Move to the next range.
        //

        CurrentBitmap = CONTAINING_RECORD( CurrentBitmap->Links.Flink,
                                           RESERVED_BITMAP_RANGE,
                                           Links );

        //
        //  Exit if we did not find a new range within the user specified range.
        //

        if ((CurrentBitmap->RangeOffset > LastRange) ||
            (CurrentBitmap->RangeOffset <= FirstRange)) {

            break;
        }

        FirstRange = CurrentBitmap->RangeOffset;
        DirtyBits = &CurrentBitmap->DirtyBits;

        FirstBit = 0;
    }

    NtfsReleaseReservedClusters( Vcb );
}


BOOLEAN
NtfsCheckForReservedClusters (
    IN PSCB Scb,
    IN LONGLONG StartingVcn,
    IN OUT PLONGLONG ClusterCount
    )

/*++

Routine Description:

    This routine is called to determine if a range of a stream has reserved
    clusters.  It is used when the user queries for the allocated ranges.  We
    want to tell the user that a range which has reserved clusters is allocated.
    Otherwise he may skip over this range when reading from the file for a
    backup or copy operation.

Arguments:

    Scb - Address of the Scb for a sparsestream for which we are checking for
        reservation.  Our caller should only call us for this type of stream.

    StartingVcn - Starting offset of a potential zeroed range.  This is guaranteed
        to begin on a sparse range boundary.

    ClusterCount - On input this is the length of the range to check.  On output it
        is the length of the deallocated range beginning at this offset.  The length
        will be zero if the first compression unit is reserved.

Return Value:

    BOOLEAN - TRUE if a reserved unit is found in the range, FALSE otherwise.

--*/

{
    ULONG CompressionShift;
    ULONG FirstBit, LastBit, CurrentLastBit, CurrentBits;
    ULONG FirstRange, LastRange;
    ULONG RemainingBits;
    ULONG FoundBit;
    PRESERVED_BITMAP_RANGE CurrentBitmap = NULL;
    PRESERVED_BITMAP_RANGE NextBitmap;
    PUSHORT DirtyBits;
    PVCB Vcb = Scb->Vcb;
    LONGLONG FoundBits = 0;

    BOOLEAN FoundReserved = FALSE;

    RTL_BITMAP LocalBitmap;

    PAGED_CODE();

    //
    //  Check that the stream is really sparse and that the file offset is on a sparse
    //  boundary.
    //

    ASSERT( FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE ));
    ASSERT( (((ULONG) LlBytesFromClusters( Vcb, StartingVcn )) & (Scb->CompressionUnit - 1)) == 0 );

    //
    //  If there is no bitmap, we can get out.
    //

    if ((Scb->ScbType.Data.ReservedBitMap == NULL) ||
        (Scb->ScbType.Data.TotalReserved == 0)) {
        return FoundReserved;
    }

    //
    //  Compute the range of bits that need to be checked.  Trim this by the range of
    //  the bitmap.
    //

    CompressionShift = (ULONG) Scb->CompressionUnitShift;
    FirstBit = ((ULONG) Int64ShraMod32( StartingVcn, CompressionShift )) & NTFS_BITMAP_RANGE_MASK;
    FirstRange = (ULONG) Int64ShraMod32( StartingVcn, CompressionShift + NTFS_BITMAP_RANGE_SHIFT );

    LastBit = ((ULONG) Int64ShraMod32( StartingVcn + *ClusterCount - 1, CompressionShift )) & NTFS_BITMAP_RANGE_MASK;
    LastRange = (ULONG) Int64ShraMod32( StartingVcn + *ClusterCount - 1,
                                        CompressionShift + NTFS_BITMAP_RANGE_SHIFT );

    NtfsAcquireReservedClusters( Vcb );

    //
    //  Look for the first range which lies within our input range.
    //

    NextBitmap = Scb->ScbType.Data.ReservedBitMap;

    //
    //  If this is a basic bitmap range then our input should be range zero.
    //

    if (NextBitmap->Links.Flink == NULL) {

        if (FirstRange == 0) {

            CurrentBitmap = NextBitmap;
            DirtyBits = &CurrentBitmap->BasicDirtyBits;
        }

    //
    //  Otherwise loop through the links.
    //

    } else {

        do {

            //
            //  Check if this bitmap is within the range being checked.
            //

            if (NextBitmap->RangeOffset >= FirstRange) {

                if (NextBitmap->RangeOffset <= LastRange) {

                    CurrentBitmap = NextBitmap;
                    DirtyBits = &CurrentBitmap->DirtyBits;

                    //
                    //  If we are skipping any ranges then remember how
                    //  many bits are implicitly clear.
                    //

                    if (NextBitmap->RangeOffset != FirstRange) {

                        FoundBits = (NextBitmap->RangeOffset - FirstRange) * NTFS_BITMAP_RANGE_SIZE;
                        FoundBits -= FirstBit;
                        FirstBit = 0;
                        FirstRange = NextBitmap->RangeOffset;
                    }
                }

                break;
            }

            NextBitmap = CONTAINING_RECORD( NextBitmap->Links.Flink,
                                            RESERVED_BITMAP_RANGE,
                                            Links );

        } while (NextBitmap != Scb->ScbType.Data.ReservedBitMap);
    }

    //
    //  If we didn't find a match we can exit.
    //

    if (CurrentBitmap == NULL) {

        NtfsReleaseReservedClusters( Vcb );
        return FoundReserved;
    }

    //
    //  Loop for each bitmap in the input range.
    //

    while (TRUE) {

        //
        //  If we are at the last range then use the input last bit.
        //

        CurrentLastBit = LastBit;
        if (FirstRange != LastRange) {

            CurrentLastBit = NTFS_BITMAP_RANGE_MASK;
        }

        CurrentBits = CurrentLastBit - FirstBit + 1;

        //
        //  Skip this range if there are no dirty bits.
        //

        if (*DirtyBits != 0) {

            //
            //  Under no circumstances should we go off the end!
            //

            if (CurrentLastBit >= CurrentBitmap->Bitmap.SizeOfBitMap) {
                CurrentLastBit = CurrentBitmap->Bitmap.SizeOfBitMap - 1;
            }

            //
            //  Check on the number of bits remaining in this bitmap.
            //

            if (FirstBit <= CurrentLastBit) {

                RemainingBits = CurrentLastBit - FirstBit + 1;
                ASSERT( RemainingBits != 0 );

                //
                //  If the starting bit is set then there is nothing else to do.
                //  Otherwise find the length of the clear run.
                //

                if (RtlCheckBit( &CurrentBitmap->Bitmap, FirstBit )) {

                    FoundBit = FirstBit;

                } else {

                    RtlInitializeBitMap( &LocalBitmap,
                                         CurrentBitmap->Bitmap.Buffer,
                                         CurrentLastBit + 1 );

                    FoundBit = RtlFindNextForwardRunClear( &LocalBitmap,
                                                           FirstBit,
                                                           &FirstBit );

                    if (FoundBit == RemainingBits) {

                        FoundBit = 0xffffffff;

                    } else {

                        FoundBit += FirstBit;
                    }
                }

                //
                //  If a bit was found then we need to compute where it lies in the
                //  requested range.
                //

                if (FoundBit != 0xffffffff) {

                    //
                    //  Include any clear bits from this range in our total.
                    //

                    FoundBits += (FoundBit - FirstBit);

                    //
                    //  Convert from compression units to clusters and trim to a compression
                    //  unit boundary.
                    //

                    *ClusterCount = BlockAlignTruncate( Int64ShllMod32( FoundBits, CompressionShift ), (LONG)Vcb->SparseFileClusters );

                    //
                    //  Now adjust the output cluster range value.
                    //

                    ASSERT( LlBytesFromClusters( Vcb, StartingVcn + *ClusterCount ) <= (ULONGLONG) Scb->Header.FileSize.QuadPart );
                    FoundReserved = TRUE;
                    break;
                }
            }
        }

        //
        //  Break out if we are last the last range or there is no next range.
        //

        if ((CurrentBitmap->Links.Flink == NULL) ||
            (FirstRange == LastRange)) {

            break;
        }

        //
        //  Move to the next range.
        //

        CurrentBitmap = CONTAINING_RECORD( CurrentBitmap->Links.Flink,
                                           RESERVED_BITMAP_RANGE,
                                           Links );

        //
        //  Exit if we did not find a new range within the user specified range.
        //

        if ((CurrentBitmap->RangeOffset <= FirstRange) ||
            (CurrentBitmap->RangeOffset > LastRange)) {

            break;
        }

        //
        //  Add in the bits for any ranges we skipped.
        //

        FoundBits += (CurrentBitmap->RangeOffset - FirstRange - 1) * NTFS_BITMAP_RANGE_SIZE;
        FirstRange = CurrentBitmap->RangeOffset;
        FirstBit = 0;

        //
        //  Include the bits from the most recent range in our count of found bits.
        //

        FoundBits += CurrentBits;

        //
        //  Remember where the dirty bits field is.
        //

        DirtyBits = &CurrentBitmap->DirtyBits;
    }

    NtfsReleaseReservedClusters( Vcb );
    return FoundReserved;
}


VOID
NtfsDeleteReservedBitmap (
    IN PSCB Scb
    )

/*++

Routine Description:

    This routine is called to free all of the components of the reserved bitmap.  We
    free any remaining reserved clusters and deallocate all of the pool associated with
    the bitmap.

Arguments:

    Scb - Scb for the stream.

Return Value:

    None.

--*/

{
    PRESERVED_BITMAP_RANGE FirstRange;
    PRESERVED_BITMAP_RANGE CurrentRange;

    PAGED_CODE();

    FirstRange = Scb->ScbType.Data.ReservedBitMap;

    ASSERT( FirstRange != NULL );

    //
    //  Free any reserved clusters still present.
    //

    if ((Scb->ScbType.Data.TotalReserved != 0) && FlagOn( Scb->ScbState, SCB_STATE_WRITE_ACCESS_SEEN )) {

        LONGLONG ClusterCount;

        ClusterCount = LlClustersFromBytesTruncate( Scb->Vcb, Scb->ScbType.Data.TotalReserved );

        //
        //  Use the security fast mutex as a convenient end resource.
        //

        NtfsAcquireReservedClusters( Scb->Vcb );

        ASSERT(Scb->Vcb->TotalReserved >= ClusterCount);
        Scb->Vcb->TotalReserved -= ClusterCount;

        NtfsReleaseReservedClusters( Scb->Vcb );
    }

    Scb->ScbType.Data.TotalReserved = 0;

    //
    //  The typical case is where the first range is the only range
    //  for a small file.
    //

    if (FirstRange->Links.Flink == NULL) {

        NtfsFreePool( FirstRange );

    //
    //  Otherwise we need to walk through the list of ranges.
    //

    } else {

        //
        //  Loop through the reserved bitmaps until we hit the first.
        //

        do {

            CurrentRange = CONTAINING_RECORD( FirstRange->Links.Flink,
                                              RESERVED_BITMAP_RANGE,
                                              Links );

            RemoveEntryList( &CurrentRange->Links );

            if (CurrentRange->Bitmap.Buffer != NULL) {

                NtfsFreePool( CurrentRange->Bitmap.Buffer );
            }

            NtfsFreePool( CurrentRange );

        } while (CurrentRange != FirstRange);
    }

    //
    //  Show that the bitmap is gone.
    //

    Scb->ScbType.Data.ReservedBitMap = NULL;

    return;
}


#if (defined(NTFS_RWCMP_TRACE) || defined(SYSCACHE) || defined(NTFS_RWC_DEBUG) || defined(SYSCACHE_DEBUG))

BOOLEAN
FsRtlIsSyscacheFile (
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine returns to the caller whether or not the specified
    file object is a file to be logged. Originally this was only used for
    the syscache stress test (thus the name).  The function understands minimal
    wildcard patterns.  To change which filename is logged against change the
    variable MakName.

Arguments:

    FileObject - supplies the FileObject to be tested (it must not be
                 cleaned up yet).

Return Value:

    FALSE - if the file is not a Syscache file.
    TRUE - if the file is a Syscache file.

--*/
{
    ULONG iM = 0;
    ULONG iF;
    PWSTR MakName = L"cac*.tmp";
    ULONG LenMakName = wcslen(MakName);

    if (FileObject && NtfsSyscacheTrackingActive) {
        iF = FileObject->FileName.Length / 2;
        while ((iF != 0) && (FileObject->FileName.Buffer[iF - 1] != '\\')) {
            iF--;
        }


        while (TRUE) {

            //
            //  If we are past the end of the file object then we are done in any case.
            //

            if ((LONG)iF == FileObject->FileName.Length / 2) {

                //
                //  Both strings exausted then we are done.
                //

                if (iM == LenMakName) {

                    return TRUE;
                }

                break;

            //
            //  Break if more input but the match string is exhausted.
            //

            } else if (iM == LenMakName) {

                break;

            //
            //  If we are at the '*' then match everything but skip to next character
            //  on a '.'
            //

            } else if (MakName[iM] == '*') {

                //
                // if we're at the last character move past wildchar in template
                //


                if ((FileObject->FileName.Buffer[iF] == L'.') && (LenMakName != iM + 1)) {

                    //
                    //  Move past * and . in NakName
                    //

                    ASSERT(MakName[iM + 1] == L'.');

                    iM++; iM++;

                } else if (((LONG)iF + 1 == FileObject->FileName.Length / 2)) {
                    iM++;
                }
                iF++;

            } else if (MakName[iM] == (WCHAR)(FileObject->FileName.Buffer[iF] )) {
                iM++; iF++;
            } else {
                break;
            }
        }
    }

    return FALSE;
}


VOID
FsRtlVerifySyscacheData (
    IN PFILE_OBJECT FileObject,
    IN PVOID Buffer,
    IN ULONG Length,
    IN ULONG Offset
    )

/*

Routine Description:

    This routine scans a buffer to see if it is valid data for a syscache
    file, and stops if it sees bad data.

    HINT TO CALLERS: Make sure (Offset + Length) <= FileSize!

Arguments:

    Buffer - Pointer to the buffer to be checked

    Length - Length of the buffer to be checked in bytes

    Offset - File offset at which this data starts (syscache files are currently
             limited to 24 bits of file offset).

Return Value:

    None (stops on error)

--*/

{
    PULONG BufferEnd;

    BufferEnd = (PULONG)((PCHAR)Buffer + (Length & ~3));

    while ((PULONG)Buffer < BufferEnd) {

        if ((*(PULONG)Buffer != 0) && (((*(PULONG)Buffer & 0xFFFFFF) ^ Offset) != 0xFFFFFF) &&
            ((Offset & 0x1FF) != 0)) {

            DbgPrint("Bad Data, FileObject = %08lx, Offset = %08lx, Buffer = %08lx\n",
                     FileObject, Offset, (PULONG)Buffer );
            DbgBreakPoint();
        }
        Offset += 4;
        Buffer = (PVOID)((PULONG)Buffer + 1);
    }
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\attrdata.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    AttrData.c

Abstract:

    This module contains an initial image of the Attribute Definition File.

Author:

    Tom Miller      [TomM]          7-Jun-1991

Revision History:

--*/

#include "NtfsProc.h"

//
// Define an array to hold the initial attribute definitions.  This is
// essentially the initial contents of the Attribute Definition File.
// NTFS may find it convenient to use this module for attribute
// definitions prior to getting an NTFS volume mounted, however it is valid
// for NTFS to assume knowledge of the system-defined attributes without
// consulting this table.
//

ATTRIBUTE_DEFINITION_COLUMNS NtfsAttributeDefinitions[ ] =

{
    {{'$','S','T','A','N','D','A','R','D','_','I','N','F','O','R','M','A','T','I','O','N'},
    $STANDARD_INFORMATION,                              // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_MUST_BE_RESIDENT,                     // Flags
    SIZEOF_OLD_STANDARD_INFORMATION,                    // Minimum length
    sizeof(STANDARD_INFORMATION)},                      // Maximum length

    {{'$','A','T','T','R','I','B','U','T','E','_','L','I','S','T'},
    $ATTRIBUTE_LIST,                                    // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_LOG_NONRESIDENT,                      // Flags
    0,                                                  // Minimum length
    -1},                                                // Maximum length

    {{'$','F','I','L','E','_','N','A','M','E'},
    $FILE_NAME,                                         // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_MUST_BE_RESIDENT | ATTRIBUTE_DEF_INDEXABLE,   // Flags
    sizeof(FILE_NAME),                                  // Minimum length
    sizeof(FILE_NAME) + (255 * sizeof(WCHAR))},         // Maximum length

    {{'$','O','B','J','E','C','T','_','I','D'},
    $OBJECT_ID,                                         // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_MUST_BE_RESIDENT,                     // Flags
    0,                                                  // Minimum length
    256},                                               // Maximum length

    {{'$','S','E','C','U','R','I','T','Y','_','D','E','S','C','R','I','P','T','O','R'},
    $SECURITY_DESCRIPTOR,                               // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_LOG_NONRESIDENT,                      // Flags
    0,                                                  // Minimum length
    -1},                                                // Maximum length

    {{'$','V','O','L','U','M','E','_','N','A','M','E'},
    $VOLUME_NAME,                                       // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_MUST_BE_RESIDENT,                     // Flags
    2,                                                  // Minimum length
    256},                                               // Maximum length

    {{'$','V','O','L','U','M','E','_','I','N','F','O','R','M','A','T','I','O','N'},
    $VOLUME_INFORMATION,                                // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_MUST_BE_RESIDENT,                     // Flags
    FIELD_OFFSET( VOLUME_INFORMATION, LastMountedMajorVersion), // Minimum length
    FIELD_OFFSET( VOLUME_INFORMATION, LastMountedMajorVersion)}, // Maximum length

    {{'$','D','A','T','A'},
    $DATA,                                              // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    0,                                                  // Flags
    0,                                                  // Minimum length
    -1},                                                // Maximum length

    {{'$','I','N','D','E','X','_','R','O','O','T'},
    $INDEX_ROOT,                                        // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_MUST_BE_RESIDENT,                     // Flags
    0,                                                  // Minimum length
    -1},                                                // Maximum length

    {{'$','I','N','D','E','X','_','A','L','L','O','C','A','T','I','O','N'},
    $INDEX_ALLOCATION,                                  // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_LOG_NONRESIDENT,                      // Flags
    0,                                                  // Minimum length
    -1},                                                // Maximum length

    {{'$','B','I','T','M','A','P'},
    $BITMAP,                                            // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_LOG_NONRESIDENT,                      // Flags
    0,                                                  // Minimum length
    -1},                                                // Maximum length

    {{'$','R','E','P','A','R','S','E','_','P','O','I','N','T'},
    $REPARSE_POINT,                                     // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_LOG_NONRESIDENT,                      // Flags
    0,                                                  // Minimum length
    16*1024},                                           // Maximum length

    {{'$','E','A','_','I','N','F','O','R','M','A','T','I','O','N'},
    $EA_INFORMATION,                                    // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_MUST_BE_RESIDENT,                     // Flags
    sizeof(EA_INFORMATION),                             // Minimum length
    sizeof(EA_INFORMATION)},                            // Maximum length

    {{'$','E','A',},
    $EA,                                                // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    0,                                                  // Flags
    0,                                                  // Minimum length
    0x10000},                                           // Maximum length

    {{0,0,0,0},
    0xF0, 
    0,
    0,
    0,
    0},

    {{'$','L','O','G','G','E','D','_','U','T','I','L','I','T','Y','_','S','T','R','E','A','M'},
    $LOGGED_UTILITY_STREAM,                             // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_LOG_NONRESIDENT,                      // Flags
    0,                                                  // Minimum length
    0x10000},                                           // Maximum length

    {{0, 0, 0, 0},
    $UNUSED,                                            // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    0,                                                  // Flags
    0,                                                  // Minimum length
    0},                                                 // Maximum length
};

//
//  The number of attributes in the above table, including the end record.
//

ULONG NtfsAttributeDefinitionsCount = sizeof( NtfsAttributeDefinitions ) / sizeof( ATTRIBUTE_DEFINITION_COLUMNS );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\checksup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    CheckSup.c

Abstract:

    This module implements check routines for Ntfs structures.

Author:

    Tom Miller      [TomM]          14-4-92

Revision History:

--*/

#include "NtfsProc.h"

//
//  Array for log records which require a target attribute.
//  A TRUE indicates that the corresponding restart operation
//  requires a target attribute.
//

BOOLEAN TargetAttributeRequired[] = {FALSE, FALSE, TRUE, TRUE,
                                     TRUE, TRUE, TRUE, TRUE,
                                     TRUE, TRUE, FALSE, TRUE,
                                     TRUE, TRUE, TRUE, TRUE,
                                     TRUE, TRUE, TRUE, TRUE,
                                     TRUE, TRUE, TRUE, TRUE,
                                     FALSE, FALSE, FALSE, FALSE,
                                     TRUE, FALSE, FALSE, FALSE,
                                     FALSE, TRUE, TRUE };

//
//  Local procedure prototypes
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsCheckAttributeRecord)
#pragma alloc_text(PAGE, NtfsCheckFileRecord)
#pragma alloc_text(PAGE, NtfsCheckIndexBuffer)
#pragma alloc_text(PAGE, NtfsCheckIndexHeader)
#pragma alloc_text(PAGE, NtfsCheckIndexRoot)
#pragma alloc_text(PAGE, NtfsCheckLogRecord)
#pragma alloc_text(PAGE, NtfsCheckRestartTable)
#endif


BOOLEAN
NtfsCheckFileRecord (
    IN PVCB Vcb,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN PFILE_REFERENCE FileReference OPTIONAL,
    OUT PULONG CorruptionHint
    )

/*++

Routine Description:

    Consistency check for file records.

Arguments:

    Vcb - the vcb it belongs to

    FileRecord - the filerecord to check

    FileReference - if specified double check the sequence number and self ref.
        fileref against it

    CorruptionHint - hint for debugging on where corruption occured;

Return Value:

    FALSE - if the file record is not valid
    TRUE - if it is

--*/
{
    PATTRIBUTE_RECORD_HEADER Attribute;
    PFILE_RECORD_SEGMENT_HEADER EndOfFileRecord;
    ULONG BytesPerFileRecordSegment = Vcb->BytesPerFileRecordSegment;
    BOOLEAN StandardInformationSeen = FALSE;
    ULONG BytesInOldHeader;

    PAGED_CODE();

    *CorruptionHint = 0;

    EndOfFileRecord = Add2Ptr( FileRecord, BytesPerFileRecordSegment );

    //
    //  Check the file record header for consistency.
    //

    if ((*(PULONG)FileRecord->MultiSectorHeader.Signature != *(PULONG)FileSignature)

            ||

        ((ULONG)FileRecord->MultiSectorHeader.UpdateSequenceArrayOffset >
         (SEQUENCE_NUMBER_STRIDE -
          (PAGE_SIZE / SEQUENCE_NUMBER_STRIDE + 1) * sizeof(USHORT)))

            ||

        ((ULONG)((FileRecord->MultiSectorHeader.UpdateSequenceArraySize - 1) * SEQUENCE_NUMBER_STRIDE) !=
         BytesPerFileRecordSegment)

            ||

        !FlagOn(FileRecord->Flags, FILE_RECORD_SEGMENT_IN_USE)) {

        DebugTrace( 0, 0, ("Invalid file record: %08lx\n", FileRecord) );

        *CorruptionHint = 1;
        ASSERTMSG( "Invalid resident file record\n", FALSE );
        return FALSE;
    }

    BytesInOldHeader = QuadAlign( sizeof( FILE_RECORD_SEGMENT_HEADER_V0 ) + (UpdateSequenceArraySize( BytesPerFileRecordSegment ) - 1) * sizeof( USHORT ));

    //
    //  Offset bounds checks
    //

    if ((FileRecord->FirstFreeByte > BytesPerFileRecordSegment) ||
        (FileRecord->FirstFreeByte < BytesInOldHeader) ||

        (FileRecord->BytesAvailable != BytesPerFileRecordSegment) ||

        (((ULONG)FileRecord->FirstAttributeOffset < BytesInOldHeader)   ||
         ((ULONG)FileRecord->FirstAttributeOffset >
                 BytesPerFileRecordSegment - SIZEOF_RESIDENT_ATTRIBUTE_HEADER)) ||

        (!IsQuadAligned( FileRecord->FirstAttributeOffset ))) {

        *CorruptionHint = 2;
        ASSERTMSG( "Out of bound offset in frs\n", FALSE );
        return FALSE;
    }

    //
    //  Optional fileref number check
    //

    if (ARGUMENT_PRESENT( FileReference )) {

        if ((FileReference->SequenceNumber != FileRecord->SequenceNumber) ||
            ((FileRecord->FirstAttributeOffset > BytesInOldHeader) &&
             ((FileRecord->SegmentNumberHighPart != FileReference->SegmentNumberHighPart) ||
              (FileRecord->SegmentNumberLowPart != FileReference->SegmentNumberLowPart)))) {

            *CorruptionHint = 3;
            ASSERTMSG( "Filerecord fileref doesn't match expected value\n", FALSE );
            return FALSE;
        }
    }

    //
    //  Loop to check all of the attributes.
    //

    for (Attribute = NtfsFirstAttribute(FileRecord);
         Attribute->TypeCode != $END;
         Attribute = NtfsGetNextRecord(Attribute)) {

//      if (!StandardInformationSeen &&
//          (Attribute->TypeCode != $STANDARD_INFORMATION) &&
//          XxEqlZero(FileRecord->BaseFileRecordSegment)) {
//
//          DebugTrace( 0, 0, ("Standard Information missing: %08lx\n", Attribute) );
//
//          ASSERTMSG( "Standard Information missing\n", FALSE );
//          return FALSE;
//      }

        StandardInformationSeen = TRUE;

        if (!NtfsCheckAttributeRecord( Vcb,
                                       FileRecord,
                                       Attribute,
                                       FALSE,
                                       CorruptionHint )) {

            return FALSE;
        }
    }
    return TRUE;
}


BOOLEAN
NtfsCheckAttributeRecord (
    IN PVCB Vcb,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN PATTRIBUTE_RECORD_HEADER Attribute,
    IN ULONG CheckHeaderOnly,
    IN PULONG CorruptionHint
    )

{
    PVOID NextAttribute;
    PVOID EndOfFileRecord;
    PVOID FirstFreeByte;
    PVOID Data;
    ULONG Length;
    ULONG BytesPerFileRecordSegment = Vcb->BytesPerFileRecordSegment;

    PAGED_CODE();

    EndOfFileRecord = Add2Ptr( FileRecord, BytesPerFileRecordSegment );
    FirstFreeByte = Add2Ptr( FileRecord, FileRecord->FirstFreeByte );

    //
    //  Do an alignment check before creating a ptr based on this value
    //

    if (!IsQuadAligned( Attribute->RecordLength )) {

        *CorruptionHint = Attribute->TypeCode + 0xc;
        ASSERTMSG( "Misaligned attribute length\n", FALSE );
        return FALSE;
    }

    NextAttribute = NtfsGetNextRecord(Attribute);

    //
    //  Check the fixed part of the attribute record header.
    //

    if ((Attribute->RecordLength >= BytesPerFileRecordSegment)

            ||

        (NextAttribute >= EndOfFileRecord)

            ||

        (FlagOn(Attribute->NameOffset, 1) != 0)

            ||

        ((Attribute->NameLength != 0) &&
         (((ULONG)Attribute->NameOffset + (ULONG)Attribute->NameLength) >
           Attribute->RecordLength))) {

        DebugTrace( 0, 0, ("Invalid attribute record header: %08lx\n", Attribute) );

        *CorruptionHint = Attribute->TypeCode + 1;
        ASSERTMSG( "Invalid attribute record header\n", FALSE );
        return FALSE;
    }

    if (NextAttribute > FirstFreeByte) {
        *CorruptionHint = Attribute->TypeCode + 2;
        ASSERTMSG( "Attributes beyond first free byte\n", FALSE );
        return FALSE;
    }

    //
    //  Check the resident attribute fields.
    //

    if (Attribute->FormCode == RESIDENT_FORM) {

        if ((Attribute->Form.Resident.ValueLength >= Attribute->RecordLength) ||

            (((ULONG)Attribute->Form.Resident.ValueOffset +
              Attribute->Form.Resident.ValueLength) > Attribute->RecordLength) ||

            (!IsQuadAligned( Attribute->Form.Resident.ValueOffset ))) {

            DebugTrace( 0, 0, ("Invalid resident attribute record header: %08lx\n", Attribute) );

            *CorruptionHint = Attribute->TypeCode + 3;
            ASSERTMSG( "Invalid resident attribute record header\n", FALSE );
            return FALSE;
        }

    //
    //  Check the nonresident attribute fields
    //

    } else if (Attribute->FormCode == NONRESIDENT_FORM) {

        VCN CurrentVcn, NextVcn;
        LCN CurrentLcn;
        LONGLONG Change;
        PCHAR ch;
        ULONG VcnBytes;
        ULONG LcnBytes;

        if ((Attribute->Form.Nonresident.LowestVcn >
                (Attribute->Form.Nonresident.HighestVcn + 1))

                ||

            ((ULONG)Attribute->Form.Nonresident.MappingPairsOffset >=
                Attribute->RecordLength)

                ||

            (Attribute->Form.Nonresident.ValidDataLength < 0) ||
            (Attribute->Form.Nonresident.FileSize < 0) ||
            (Attribute->Form.Nonresident.AllocatedLength < 0)

                ||

            (Attribute->Form.Nonresident.ValidDataLength >
                Attribute->Form.Nonresident.FileSize)

                ||

            (Attribute->Form.Nonresident.FileSize >
                Attribute->Form.Nonresident.AllocatedLength)) {

            DebugTrace( 0, 0, ("Invalid nonresident attribute record header: %08lx\n", Attribute) );

            *CorruptionHint = Attribute->TypeCode + 4;
            ASSERTMSG( "Invalid nonresident attribute record header\n", FALSE );
            return FALSE;
        }

        if (CheckHeaderOnly) { return TRUE; }

        //
        //  Implement the decompression algorithm, as defined in ntfs.h.
        //  (This code should look remarkably similar to what goes on in
        //  NtfsLookupAllocation!)
        //

        NextVcn = Attribute->Form.Nonresident.LowestVcn;
        CurrentLcn = 0;
        ch = (PCHAR)Attribute + Attribute->Form.Nonresident.MappingPairsOffset;

        //
        //  Loop to process mapping pairs, insuring we do not run off the end
        //  of the attribute, and that we do not map to nonexistant Lcns.
        //

        while (!IsCharZero(*ch)) {

            //
            // Set Current Vcn from initial value or last pass through loop.
            //

            CurrentVcn = NextVcn;

            //
            //  Extract the counts from the two nibbles of this byte.
            //

            VcnBytes = *ch & 0xF;
            LcnBytes = *ch++ >> 4;

            //
            //  Neither of these should be larger than a VCN.
            //

            if ((VcnBytes > sizeof( VCN )) ||
                (LcnBytes > sizeof( VCN ))) {

                DebugTrace( 0, 0, ("Invalid maping pair byte count: %08lx\n", Attribute) );

                *CorruptionHint = Attribute->TypeCode + 5;
                ASSERTMSG( "Invalid maping pair byte count\n", FALSE );
                return FALSE;
            }

            //
            //  Extract the Vcn change (use of RtlCopyMemory works for little-Endian)
            //  and update NextVcn.
            //

            Change = 0;

            //
            //  Make sure we are not going beyond the end of the attribute
            //  record, and that the Vcn change is not negative or zero.
            //

            if (((ULONG_PTR)(ch + VcnBytes + LcnBytes + 1) > (ULONG_PTR)NextAttribute)

                    ||

                IsCharLtrZero(*(ch + VcnBytes - 1))) {

                DebugTrace( 0, 0, ("Invalid maping pairs array: %08lx\n", Attribute) );

                *CorruptionHint = Attribute->TypeCode + 6;
                ASSERTMSG( "Invalid maping pairs array\n", FALSE );
                return FALSE;
            }

            RtlCopyMemory( &Change, ch, VcnBytes );
            ch += VcnBytes;
            NextVcn = NextVcn + Change;

            //
            //  Extract the Lcn change and update CurrentLcn.
            //

            Change = 0;
            if (IsCharLtrZero(*(ch + LcnBytes - 1))) {
                Change = Change - 1;
            }
            RtlCopyMemory( &Change, ch, LcnBytes );
            ch += LcnBytes;
            CurrentLcn = CurrentLcn + Change;

            if ((LcnBytes != 0) &&
                ((CurrentLcn + (NextVcn - CurrentVcn) - 1) > Vcb->TotalClusters)) {

                DebugTrace( 0, 0, ("Invalid Lcn: %08lx\n", Attribute) );

                *CorruptionHint = Attribute->TypeCode + 7;
                ASSERTMSG( "Invalid Lcn\n", FALSE );
                return FALSE;
            }
        }

        //
        //  Finally, check HighestVcn.
        //

        if (NextVcn != (Attribute->Form.Nonresident.HighestVcn + 1)) {

            DebugTrace( 0, 0, ("Disagreement with mapping pairs: %08lx\n", Attribute) );

            *CorruptionHint = Attribute->TypeCode + 8;
            ASSERTMSG( "Disagreement with mapping pairs\n", FALSE );
            return FALSE;
        }

    } else {

        DebugTrace( 0, 0, ("Invalid attribute form code: %08lx\n", Attribute) );

        ASSERTMSG( "Invalid attribute form code\n", FALSE );
        return FALSE;
    }

    //
    //  Now check the attributes by type code, if they are resident.  Not all
    //  attributes require specific checks (such as $STANDARD_INFORMATION and $DATA).
    //

    if (CheckHeaderOnly || !NtfsIsAttributeResident( Attribute )) {

        return TRUE;
    }

    Data = NtfsAttributeValue(Attribute);
    Length = Attribute->Form.Resident.ValueLength;

    switch (Attribute->TypeCode) {

    case $FILE_NAME:

        {
            if ((ULONG)((PFILE_NAME)Data)->FileNameLength * sizeof( WCHAR ) >
                (Length - (ULONG)sizeof(FILE_NAME) + sizeof( WCHAR ))) {

                DebugTrace( 0, 0, ("Invalid File Name attribute: %08lx\n", Attribute) );

                *CorruptionHint = Attribute->TypeCode + 9;
                ASSERTMSG( "Invalid File Name attribute\n", FALSE );
                return FALSE;
            }
            break;
        }

    case $INDEX_ROOT:

        {
            return NtfsCheckIndexRoot( Vcb, (PINDEX_ROOT)Data, Length );
        }

    case $STANDARD_INFORMATION:

        {
            if (Length < sizeof( STANDARD_INFORMATION ) &&
                Length != SIZEOF_OLD_STANDARD_INFORMATION)
            {
                DebugTrace( 0, 0, ("Invalid Standard Information attribute: %08lx\n", Attribute) );

                *CorruptionHint = Attribute->TypeCode + 0xa;
                ASSERTMSG( "Invalid Standard Information attribute size\n", FALSE );
                return FALSE;
            }

            break;
        }

    case $ATTRIBUTE_LIST:
    case $OBJECT_ID:
    case $SECURITY_DESCRIPTOR:
    case $VOLUME_NAME:
    case $VOLUME_INFORMATION:
    case $DATA:
    case $INDEX_ALLOCATION:
    case $BITMAP:
    case $REPARSE_POINT:
    case $EA_INFORMATION:
    case $EA:
    case $LOGGED_UTILITY_STREAM:

        break;

    default:

        {
            DebugTrace( 0, 0, ("Bad Attribute type code: %08lx\n", Attribute) );

            *CorruptionHint = Attribute->TypeCode + 0xb;
            ASSERTMSG( "Bad Attribute type code\n", FALSE );
            return FALSE;
        }
    }
    return TRUE;
}


BOOLEAN
NtfsCheckIndexRoot (
    IN PVCB Vcb,
    IN PINDEX_ROOT IndexRoot,
    IN ULONG AttributeSize
    )

{
    UCHAR ShiftValue;
    PAGED_CODE();

    //
    //  Check whether this index root uses clusters or if the cluster size is larger than
    //  the index block.
    //

    if (IndexRoot->BytesPerIndexBuffer >= Vcb->BytesPerCluster) {

        ShiftValue = (UCHAR) Vcb->ClusterShift;

    } else {

        ShiftValue = DEFAULT_INDEX_BLOCK_BYTE_SHIFT;
    }

    if ((AttributeSize < sizeof(INDEX_ROOT))

            ||

        ((IndexRoot->IndexedAttributeType != $FILE_NAME) && (IndexRoot->IndexedAttributeType != $UNUSED))

            ||

        ((IndexRoot->IndexedAttributeType == $FILE_NAME) && (IndexRoot->CollationRule != COLLATION_FILE_NAME))

            ||


        (IndexRoot->BytesPerIndexBuffer !=
         BytesFromIndexBlocks( IndexRoot->BlocksPerIndexBuffer, ShiftValue ))

            ||

        ((IndexRoot->BlocksPerIndexBuffer != 1) &&
         (IndexRoot->BlocksPerIndexBuffer != 2) &&
         (IndexRoot->BlocksPerIndexBuffer != 4) &&
         (IndexRoot->BlocksPerIndexBuffer != 8) &&
         (IndexRoot->BlocksPerIndexBuffer != 16) &&
         (IndexRoot->BlocksPerIndexBuffer != 32) &&
         (IndexRoot->BlocksPerIndexBuffer != 64) &&
         (IndexRoot->BlocksPerIndexBuffer != 128))) {

        DebugTrace( 0, 0, ("Bad Index Root: %08lx\n", IndexRoot) );

        ASSERTMSG( "Bad Index Root\n", FALSE );
        return FALSE;
    }

    return NtfsCheckIndexHeader( &IndexRoot->IndexHeader,
                                 AttributeSize - sizeof(INDEX_ROOT) + sizeof(INDEX_HEADER) );
}


BOOLEAN
NtfsCheckIndexBuffer (
    IN PSCB Scb,
    IN PINDEX_ALLOCATION_BUFFER IndexBuffer
    )

{
    ULONG BytesPerIndexBuffer = Scb->ScbType.Index.BytesPerIndexBuffer;

    PAGED_CODE();

    //
    //  Check the index buffer for consistency.
    //

    if ((*(PULONG)IndexBuffer->MultiSectorHeader.Signature != *(PULONG)IndexSignature)

            ||

        ((ULONG)IndexBuffer->MultiSectorHeader.UpdateSequenceArrayOffset >
         (SEQUENCE_NUMBER_STRIDE - (PAGE_SIZE / SEQUENCE_NUMBER_STRIDE + 1) * sizeof(USHORT)))

            ||

        ((ULONG)((IndexBuffer->MultiSectorHeader.UpdateSequenceArraySize - 1) * SEQUENCE_NUMBER_STRIDE) !=
         BytesPerIndexBuffer)) {

        DebugTrace( 0, 0, ("Invalid Index Buffer: %08lx\n", IndexBuffer) );

        ASSERTMSG( "Invalid resident Index Buffer\n", FALSE );
        return FALSE;
    }

    return NtfsCheckIndexHeader( &IndexBuffer->IndexHeader,
                                 BytesPerIndexBuffer -
                                  FIELD_OFFSET(INDEX_ALLOCATION_BUFFER, IndexHeader) );
}


BOOLEAN
NtfsCheckIndexHeader (
    IN PINDEX_HEADER IndexHeader,
    IN ULONG BytesAvailable
    )

{
    PINDEX_ENTRY IndexEntry, NextIndexEntry;
    PINDEX_ENTRY EndOfIndex;
    ULONG MinIndexEntry = sizeof(INDEX_ENTRY);

    PAGED_CODE();

    if (FlagOn(IndexHeader->Flags, INDEX_NODE)) {

        MinIndexEntry += sizeof(VCN);
    }

    if ((IndexHeader->FirstIndexEntry > (BytesAvailable - MinIndexEntry))

            ||

        (IndexHeader->FirstFreeByte > BytesAvailable)

            ||

        (IndexHeader->BytesAvailable > BytesAvailable)

            ||

        ((IndexHeader->FirstIndexEntry + MinIndexEntry) > IndexHeader->FirstFreeByte)

            ||

        (IndexHeader->FirstFreeByte > IndexHeader->BytesAvailable)) {

        DebugTrace( 0, 0, ("Bad Index Header: %08lx\n", IndexHeader) );

        ASSERTMSG( "Bad Index Header\n", FALSE );
        return FALSE;
    }

    IndexEntry = NtfsFirstIndexEntry(IndexHeader);

    EndOfIndex = Add2Ptr(IndexHeader, IndexHeader->FirstFreeByte);

    while (TRUE) {

        NextIndexEntry = NtfsNextIndexEntry(IndexEntry);

        if (((ULONG)IndexEntry->Length < MinIndexEntry)

                ||

            (NextIndexEntry > EndOfIndex)

                ||

//          ((ULONG)IndexEntry->AttributeLength >
//           ((ULONG)IndexEntry->Length - MinIndexEntry))
//
//              ||

            (BooleanFlagOn(IndexEntry->Flags, INDEX_ENTRY_NODE) !=
             BooleanFlagOn(IndexHeader->Flags, INDEX_NODE))) {

            DebugTrace( 0, 0, ("Bad Index Entry: %08lx\n", IndexEntry) );

            ASSERTMSG( "Bad Index Entry\n", FALSE );
            return FALSE;
        }

        if (FlagOn(IndexEntry->Flags, INDEX_ENTRY_END)) {
            break;
        }
        IndexEntry = NextIndexEntry;
    }
    return TRUE;
}


BOOLEAN
NtfsCheckLogRecord (
    IN PNTFS_LOG_RECORD_HEADER LogRecord,
    IN ULONG LogRecordLength,
    IN TRANSACTION_ID TransactionId,
    IN ULONG AttributeEntrySize
    )

{
    BOOLEAN ValidLogRecord = FALSE;
    PAGED_CODE();

    //
    //  We make the following checks on the log record.
    //
    //      - Minimum length must contain an NTFS_LOG_RECORD_HEADER
    //      - Transaction Id must be a valid value (a valid index offset)
    //
    //  The following are values in the log record.
    //
    //      - Redo/Undo offset must be quadaligned
    //      - Redo/Undo offset + length must be contained in the log record
    //      - Target attribute must be a valid value (either 0 or valid index offset)
    //      - Record offset must be quad-aligned and less than the file record size.
    //      - Log record size must be sufficient for Lcn's to follow.
    //
    //  Use the separate assert messages in order to identify the error (used the same text so
    //  the compiler can still optimize).
    //

    if (LogRecordLength < sizeof( NTFS_LOG_RECORD_HEADER )) {

        ASSERTMSG( "Invalid log record\n", FALSE );

    } else if (TransactionId == 0) {

        ASSERTMSG( "Invalid log record\n", FALSE );

    } else if ((TransactionId - sizeof( RESTART_TABLE )) % sizeof( TRANSACTION_ENTRY )) {

        ASSERTMSG( "Invalid log record\n", FALSE );

    } else if (FlagOn( LogRecord->RedoOffset, 7 )) {

        ASSERTMSG( "Invalid log record\n", FALSE );

    } else if (FlagOn( LogRecord->UndoOffset, 7 )) {

        ASSERTMSG( "Invalid log record\n", FALSE );

    } else if ((ULONG) LogRecord->RedoOffset + LogRecord->RedoLength > LogRecordLength) {

        ASSERTMSG( "Invalid log record\n", FALSE );

    } else if ((LogRecord->UndoOperation != CompensationLogRecord) &&
               ((ULONG) LogRecord->UndoOffset + LogRecord->UndoLength > LogRecordLength)) {

        ASSERTMSG( "Invalid log record\n", FALSE );

    } else if (LogRecordLength < (sizeof( NTFS_LOG_RECORD_HEADER ) +
                                  ((LogRecord->LcnsToFollow != 0) ?
                                   (sizeof( LCN ) * (LogRecord->LcnsToFollow - 1)) :
                                   0))) {

        ASSERTMSG( "Invalid log record\n", FALSE );

    //
    //  NOTE: The next two clauses test different cases for the TargetAttribute in
    //  the log record.  Don't add any tests after this point as the ValidLogRecord
    //  value is set to TRUE internally and no other checks take place.
    //

    } else if (LogRecord->TargetAttribute == 0) {

        if (((LogRecord->RedoOperation <= UpdateRecordDataAllocation) &&
                 TargetAttributeRequired[LogRecord->RedoOperation]) ||
                ((LogRecord->UndoOperation <= UpdateRecordDataAllocation) &&
                 TargetAttributeRequired[LogRecord->UndoOperation])) {

            ASSERTMSG( "Invalid log record\n", FALSE );

        } else {

            ValidLogRecord = TRUE;
        }

    //
    //  Read the note above if changing this.
    //

    } else if ((LogRecord->RedoOperation != ForgetTransaction) &&
               ((LogRecord->TargetAttribute - sizeof( RESTART_TABLE )) % AttributeEntrySize)) {

        ASSERTMSG( "Invalid log record\n", FALSE );

    //
    //  Read the note above if changing this.
    //

    } else {

        ValidLogRecord = TRUE;
    }

    return ValidLogRecord;
}


BOOLEAN
NtfsCheckRestartTable (
    IN PRESTART_TABLE RestartTable,
    IN ULONG TableSize
    )
{
    ULONG ActualTableSize;
    ULONG Index;
    PDIRTY_PAGE_ENTRY_V0 NextEntry;

    PAGED_CODE();

    //
    //  We want to make the following checks.
    //
    //      EntrySize - Must be less than table size and non-zero.
    //
    //      NumberEntries - The table size must contain at least this many entries
    //                      plus the table header.
    //
    //      NumberAllocated - Must be less than/equal to NumberEntries
    //
    //      FreeGoal - Must lie in the table.
    //
    //      FirstFree
    //      LastFree - Must either be 0 or be on a restart entry boundary.
    //

    if ((RestartTable->EntrySize == 0) ||
        (RestartTable->EntrySize > TableSize) ||
        ((RestartTable->EntrySize + sizeof( RESTART_TABLE )) > TableSize) ||
        (((TableSize - sizeof( RESTART_TABLE )) / RestartTable->EntrySize) < RestartTable->NumberEntries) ||
        (RestartTable->NumberAllocated > RestartTable->NumberEntries)) {

        ASSERTMSG( "Invalid Restart Table sizes\n", FALSE );
        return FALSE;
    }

    ActualTableSize = (RestartTable->EntrySize * RestartTable->NumberEntries) +
                      sizeof( RESTART_TABLE );

    if ((RestartTable->FirstFree > ActualTableSize) ||
        (RestartTable->LastFree > ActualTableSize) ||
        ((RestartTable->FirstFree != 0) && (RestartTable->FirstFree < sizeof( RESTART_TABLE ))) ||
        ((RestartTable->LastFree != 0) && (RestartTable->LastFree < sizeof( RESTART_TABLE )))) {

        ASSERTMSG( "Invalid Restart Table List Head\n", FALSE );
        return FALSE;
    }

    //
    //  Make a pass through the table verifying that each entry
    //  is either allocated or points to a valid offset in the
    //  table.
    //

    for (Index = 0;Index < RestartTable->NumberEntries; Index++) {

        NextEntry = Add2Ptr( RestartTable,
                             ((Index * RestartTable->EntrySize) +
                              sizeof( RESTART_TABLE )));

        if ((NextEntry->AllocatedOrNextFree != RESTART_ENTRY_ALLOCATED) &&
            (NextEntry->AllocatedOrNextFree != 0) &&
            ((NextEntry->AllocatedOrNextFree < sizeof( RESTART_TABLE )) ||
             (((NextEntry->AllocatedOrNextFree - sizeof( RESTART_TABLE )) % RestartTable->EntrySize) != 0))) {

            ASSERTMSG( "Invalid Restart Table Entry\n", FALSE );
            return FALSE;
        }
    }

    //
    //  Walk through the list headed by the first entry to make sure none
    //  of the entries are currently being used.
    //

    for (Index = RestartTable->FirstFree; Index != 0; Index = NextEntry->AllocatedOrNextFree) {

        if (Index == RESTART_ENTRY_ALLOCATED) {

            ASSERTMSG( "Invalid Restart Table Free List\n", FALSE );
            return FALSE;
        }

        NextEntry = Add2Ptr( RestartTable, Index );
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\attrsup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    AttrSup.c

Abstract:

    This module implements the attribute management routines for Ntfs

Author:

    David Goebel        [DavidGoe]          25-June-1991
    Tom Miller          [TomM]              9-November-1991

Revision History:

--*/

#include "NtfsProc.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (NTFS_BUG_CHECK_ATTRSUP)

//
//  Local debug trace level
//

#define Dbg                              (DEBUG_TRACE_ATTRSUP)

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('AFtN')

#define NTFS_MAX_ZERO_RANGE              (0x40000000)

#define NTFS_CHECK_INSTANCE_ROLLOVER     (0xf000)

//
//
//  Internal support routines
//

BOOLEAN
NtfsFindInFileRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PATTRIBUTE_RECORD_HEADER Attribute,
    OUT PATTRIBUTE_RECORD_HEADER *ReturnAttribute,
    IN ATTRIBUTE_TYPE_CODE QueriedTypeCode,
    IN PCUNICODE_STRING QueriedName OPTIONAL,
    IN BOOLEAN IgnoreCase,
    IN PVOID QueriedValue OPTIONAL,
    IN ULONG QueriedValueLength
    );

//
//  Internal support routines for managing file record space
//

VOID
NtfsCreateNonresidentWithValue (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ATTRIBUTE_TYPE_CODE AttributeTypeCode,
    IN PUNICODE_STRING AttributeName OPTIONAL,
    IN PVOID Value OPTIONAL,
    IN ULONG ValueLength,
    IN USHORT AttributeFlags,
    IN BOOLEAN WriteClusters,
    IN PSCB ThisScb OPTIONAL,
    IN BOOLEAN LogIt,
    IN PATTRIBUTE_ENUMERATION_CONTEXT Context
    );

BOOLEAN
NtfsGetSpaceForAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG Length,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    );

VOID
MakeRoomForAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG SizeNeeded,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    );

VOID
FindLargestAttributes (
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN ULONG Number,
    OUT PATTRIBUTE_RECORD_HEADER *AttributeArray
    );

LONGLONG
MoveAttributeToOwnRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PATTRIBUTE_RECORD_HEADER Attribute,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context,
    OUT PBCB *NewBcb OPTIONAL,
    OUT PFILE_RECORD_SEGMENT_HEADER *NewFileRecord OPTIONAL
    );

VOID
SplitFileRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG SizeNeeded,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    );

PFILE_RECORD_SEGMENT_HEADER
NtfsCloneFileRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN BOOLEAN MftData,
    OUT PBCB *Bcb,
    OUT PMFT_SEGMENT_REFERENCE FileReference
    );

ULONG
GetSizeForAttributeList (
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord
    );

VOID
CreateAttributeList (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord1,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord2 OPTIONAL,
    IN MFT_SEGMENT_REFERENCE SegmentReference2,
    IN PATTRIBUTE_RECORD_HEADER OldPosition OPTIONAL,
    IN ULONG SizeOfList,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT ListContext
    );

VOID
UpdateAttributeListEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PMFT_SEGMENT_REFERENCE OldFileReference,
    IN USHORT OldInstance,
    IN PMFT_SEGMENT_REFERENCE NewFileReference,
    IN USHORT NewInstance,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT ListContext
    );

VOID
NtfsAddNameToParent (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ParentScb,
    IN PFCB ThisFcb,
    IN BOOLEAN IgnoreCase,
    IN PBOOLEAN LogIt,
    IN PFILE_NAME FileNameAttr,
    OUT PUCHAR FileNameFlags,
    OUT PQUICK_INDEX QuickIndex OPTIONAL,
    IN PNAME_PAIR NamePair OPTIONAL,
    IN PINDEX_CONTEXT IndexContext OPTIONAL
    );

VOID
NtfsAddDosOnlyName (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ParentScb,
    IN PFCB ThisFcb,
    IN UNICODE_STRING FileName,
    IN BOOLEAN LogIt,
    IN PUNICODE_STRING SuggestedDosName OPTIONAL
    );

BOOLEAN
NtfsAddTunneledNtfsOnlyName (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ParentScb,
    IN PFCB ThisFcb,
    IN PUNICODE_STRING FileName,
    IN PBOOLEAN LogIt
    );

USHORT
NtfsScanForFreeInstance (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord
    );

VOID
NtfsMergeFileRecords (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN BOOLEAN RestoreContext,
    IN PATTRIBUTE_ENUMERATION_CONTEXT Context
    );

NTSTATUS
NtfsCheckLocksInZeroRange (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PSCB Scb,
    IN PFILE_OBJECT FileObject,
    IN PLONGLONG StartingOffset,
    IN ULONG ByteCount
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CreateAttributeList)
#pragma alloc_text(PAGE, FindLargestAttributes)
#pragma alloc_text(PAGE, GetSizeForAttributeList)
#pragma alloc_text(PAGE, MakeRoomForAttribute)
#pragma alloc_text(PAGE, MoveAttributeToOwnRecord)
#pragma alloc_text(PAGE, NtfsAddAttributeAllocation)
#pragma alloc_text(PAGE, NtfsAddDosOnlyName)
#pragma alloc_text(PAGE, NtfsAddLink)
#pragma alloc_text(PAGE, NtfsAddNameToParent)
#pragma alloc_text(PAGE, NtfsAddToAttributeList)
#pragma alloc_text(PAGE, NtfsAddTunneledNtfsOnlyName)
#pragma alloc_text(PAGE, NtfsChangeAttributeSize)
#pragma alloc_text(PAGE, NtfsChangeAttributeValue)
#pragma alloc_text(PAGE, NtfsCheckLocksInZeroRange)
#pragma alloc_text(PAGE, NtfsCleanupAttributeContext)
#pragma alloc_text(PAGE, NtfsCloneFileRecord)
#pragma alloc_text(PAGE, NtfsConvertToNonresident)
#pragma alloc_text(PAGE, NtfsCreateAttributeWithAllocation)
#pragma alloc_text(PAGE, NtfsCreateAttributeWithValue)
#pragma alloc_text(PAGE, NtfsCreateNonresidentWithValue)
#pragma alloc_text(PAGE, NtfsDeleteAllocationFromRecord)
#pragma alloc_text(PAGE, NtfsDeleteAttributeAllocation)
#pragma alloc_text(PAGE, NtfsDeleteAttributeRecord)
#pragma alloc_text(PAGE, NtfsDeleteFile)
#pragma alloc_text(PAGE, NtfsDeleteFromAttributeList)
#pragma alloc_text(PAGE, NtfsFindInFileRecord)
#pragma alloc_text(PAGE, NtfsGetAttributeTypeCode)
#pragma alloc_text(PAGE, NtfsGetSpaceForAttribute)
#pragma alloc_text(PAGE, NtfsGrowStandardInformation)
#pragma alloc_text(PAGE, NtfsInitializeFileInExtendDirectory)
#pragma alloc_text(PAGE, NtfsIsFileDeleteable)
#pragma alloc_text(PAGE, NtfsLookupEntry)
#pragma alloc_text(PAGE, NtfsLookupExternalAttribute)
#pragma alloc_text(PAGE, NtfsLookupInFileRecord)
#pragma alloc_text(PAGE, NtfsMapAttributeValue)
#pragma alloc_text(PAGE, NtfsMergeFileRecords)
#pragma alloc_text(PAGE, NtfsModifyAttributeFlags)
#pragma alloc_text(PAGE, NtfsPrepareForUpdateDuplicate)
#pragma alloc_text(PAGE, NtfsRemoveLink)
#pragma alloc_text(PAGE, NtfsRemoveLinkViaFlags)
#pragma alloc_text(PAGE, NtfsRestartChangeAttributeSize)
#pragma alloc_text(PAGE, NtfsRestartChangeMapping)
#pragma alloc_text(PAGE, NtfsRestartChangeValue)
#pragma alloc_text(PAGE, NtfsRestartInsertAttribute)
#pragma alloc_text(PAGE, NtfsRestartRemoveAttribute)
#pragma alloc_text(PAGE, NtfsRestartWriteEndOfFileRecord)
#pragma alloc_text(PAGE, NtfsRewriteMftMapping)
#pragma alloc_text(PAGE, NtfsScanForFreeInstance)
#pragma alloc_text(PAGE, NtfsSetSparseStream)
#pragma alloc_text(PAGE, NtfsSetTotalAllocatedField)
#pragma alloc_text(PAGE, NtfsUpdateDuplicateInfo)
#pragma alloc_text(PAGE, NtfsUpdateFcb)
#pragma alloc_text(PAGE, NtfsUpdateFcbInfoFromDisk)
#pragma alloc_text(PAGE, NtfsUpdateFileNameFlags)
#pragma alloc_text(PAGE, NtfsUpdateLcbDuplicateInfo)
#pragma alloc_text(PAGE, NtfsUpdateScbFromAttribute)
#pragma alloc_text(PAGE, NtfsUpdateStandardInformation)
#pragma alloc_text(PAGE, NtfsWriteFileSizes)
#pragma alloc_text(PAGE, NtfsZeroRangeInStream)
#pragma alloc_text(PAGE, SplitFileRecord)
#pragma alloc_text(PAGE, UpdateAttributeListEntry)
#endif


ATTRIBUTE_TYPE_CODE
NtfsGetAttributeTypeCode (
    IN PVCB Vcb,
    IN PUNICODE_STRING AttributeTypeName
    )

/*++

Routine Description:

    This routine returns the attribute type code for a given attribute name.

Arguments:

    Vcb - Pointer to the Vcb from which to consult the attribute definitions.

    AttributeTypeName - A string containing the attribute type name to be
                        looked up.

Return Value:

    The attribute type code corresponding to the specified name, or 0 if the
    attribute type name does not exist.

--*/

{
    PATTRIBUTE_DEFINITION_COLUMNS AttributeDef = Vcb->AttributeDefinitions;
    ATTRIBUTE_TYPE_CODE AttributeTypeCode = $UNUSED;

    UNICODE_STRING AttributeCodeName;

    PAGED_CODE();

    //
    //  Loop through all of the definitions looking for a name match.
    //

    while (AttributeDef->AttributeName[0] != 0) {

        RtlInitUnicodeString( &AttributeCodeName, AttributeDef->AttributeName );

        //
        //  The name lengths must match and the characters match exactly.
        //

        if ((AttributeCodeName.Length == AttributeTypeName->Length)
            && (RtlEqualMemory( AttributeTypeName->Buffer,
                                AttributeDef->AttributeName,
                                AttributeTypeName->Length ))) {

            AttributeTypeCode = AttributeDef->AttributeTypeCode;
            break;
        }

        //
        //  Lets go to the next attribute column.
        //

        AttributeDef += 1;
    }

    return AttributeTypeCode;
}


VOID
NtfsUpdateScbFromAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PSCB Scb,
    IN PATTRIBUTE_RECORD_HEADER AttrHeader OPTIONAL
    )

/*++

Routine Description:

    This routine fills in the header of an Scb with the
    information from the attribute for this Scb.

Arguments:

    Scb - Supplies the SCB to update

    AttrHeader - Optionally provides the attribute to update from

Return Value:

    None

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;

    BOOLEAN CleanupAttrContext = FALSE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsUpdateScbFromAttribute:  Entered\n") );

    //
    //  If the attribute has been deleted, we can return immediately
    //  claiming that the Scb has been initialized.
    //

    if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED )) {

        SetFlag( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED );
        DebugTrace( -1, Dbg, ("NtfsUpdateScbFromAttribute:  Exit\n") );

        return;
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  If we weren't given the attribute header, we look it up now.
        //

        if (!ARGUMENT_PRESENT( AttrHeader )) {

            NtfsInitializeAttributeContext( &AttrContext );

            CleanupAttrContext = TRUE;

            NtfsLookupAttributeForScb( IrpContext, Scb, NULL, &AttrContext );

            AttrHeader = NtfsFoundAttribute( &AttrContext );
        }

        //
        //  Check whether this is resident or nonresident
        //

        if (NtfsIsAttributeResident( AttrHeader )) {

            //
            //  Verify the resident value length.
            //

            if (AttrHeader->Form.Resident.ValueLength > AttrHeader->RecordLength - AttrHeader->Form.Resident.ValueOffset) {

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
            }

            Scb->Header.AllocationSize.QuadPart = AttrHeader->Form.Resident.ValueLength;

            if (!FlagOn( Scb->ScbState, SCB_STATE_FILE_SIZE_LOADED )) {

                Scb->Header.ValidDataLength =
                Scb->Header.FileSize = Scb->Header.AllocationSize;
                SetFlag(Scb->ScbState, SCB_STATE_FILE_SIZE_LOADED);
            }

#ifdef SYSCACHE_DEBUG
            if (ScbIsBeingLogged( Scb )) {
                FsRtlLogSyscacheEvent( Scb, SCE_VDL_CHANGE, SCE_FLAG_UPDATE_FROM_DISK, Scb->Header.ValidDataLength.QuadPart, 0, 0 );
            }
#endif

            Scb->Header.AllocationSize.LowPart =
              QuadAlign( Scb->Header.AllocationSize.LowPart );

            Scb->TotalAllocated = Scb->Header.AllocationSize.QuadPart;

            //
            //  Set the resident flag in the Scb.
            //

            SetFlag( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT );

        } else {

            VCN FileClusters;
            VCN AllocationClusters;

            if (!FlagOn(Scb->ScbState, SCB_STATE_FILE_SIZE_LOADED)) {

                Scb->Header.ValidDataLength.QuadPart = AttrHeader->Form.Nonresident.ValidDataLength;
                Scb->Header.FileSize.QuadPart = AttrHeader->Form.Nonresident.FileSize;
                SetFlag(Scb->ScbState, SCB_STATE_FILE_SIZE_LOADED);

                if (FlagOn( AttrHeader->Flags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {
                    Scb->ValidDataToDisk = AttrHeader->Form.Nonresident.ValidDataLength;
                } else {
                    Scb->ValidDataToDisk = 0;
                }
            }

#ifdef SYSCACHE_DEBUG
            if (ScbIsBeingLogged( Scb )) {
                FsRtlLogSyscacheEvent( Scb, SCE_VDL_CHANGE, SCE_FLAG_UPDATE_FROM_DISK, Scb->Header.ValidDataLength.QuadPart, 1, 0 );
            }
#endif

            Scb->Header.AllocationSize.QuadPart = AttrHeader->Form.Nonresident.AllocatedLength;
            Scb->TotalAllocated = Scb->Header.AllocationSize.QuadPart;

            //
            //  Sanity Checks filesize lengths
            //

            if ((Scb->Header.FileSize.QuadPart < 0) ||
                (Scb->Header.ValidDataLength.QuadPart < 0 ) ||
                (Scb->Header.AllocationSize.QuadPart < 0) ||
                (Scb->Header.FileSize.QuadPart > Scb->Header.AllocationSize.QuadPart)) {

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
            }


            if (FlagOn( AttrHeader->Flags,
                        ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE )) {

                Scb->TotalAllocated = AttrHeader->Form.Nonresident.TotalAllocated;

                if (Scb->TotalAllocated < 0) {

                    Scb->TotalAllocated = 0;

                } else if (Scb->TotalAllocated > Scb->Header.AllocationSize.QuadPart) {

                    Scb->TotalAllocated = Scb->Header.AllocationSize.QuadPart;
                }
            }

            ClearFlag( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT );

            //
            //  Get the size of the compression unit.
            //

            ASSERT((AttrHeader->Form.Nonresident.CompressionUnit == 0) ||
                   (AttrHeader->Form.Nonresident.CompressionUnit == NTFS_CLUSTERS_PER_COMPRESSION) ||
                   FlagOn( AttrHeader->Flags, ATTRIBUTE_FLAG_SPARSE ));

            Scb->CompressionUnit = 0;
            Scb->CompressionUnitShift = 0;

            if ((AttrHeader->Form.Nonresident.CompressionUnit != 0) &&
                (AttrHeader->Form.Nonresident.CompressionUnit < 31)) {

                Scb->CompressionUnit = BytesFromClusters( Scb->Vcb,
                                                          1 << AttrHeader->Form.Nonresident.CompressionUnit );
                Scb->CompressionUnitShift = AttrHeader->Form.Nonresident.CompressionUnit;

                ASSERT( NtfsIsTypeCodeCompressible( Scb->AttributeTypeCode ));
            }

            //
            //  Compute the clusters for the file and its allocation.
            //

            AllocationClusters = LlClustersFromBytes( Scb->Vcb, Scb->Header.AllocationSize.QuadPart );

            if (Scb->CompressionUnit == 0) {

                FileClusters = LlClustersFromBytes(Scb->Vcb, Scb->Header.FileSize.QuadPart);

            } else {

                FileClusters = BlockAlign( Scb->Header.FileSize.QuadPart, (LONG)Scb->CompressionUnit );
            }

            //
            //  If allocated clusters are greater than file clusters, mark
            //  the Scb to truncate on close.
            //

            if (AllocationClusters > FileClusters) {

                SetFlag( Scb->ScbState, SCB_STATE_TRUNCATE_ON_CLOSE );
            }
        }

        //
        //  Update compression information if this is not an index
        //

        if (Scb->AttributeTypeCode != $INDEX_ALLOCATION) {

            Scb->AttributeFlags = AttrHeader->Flags;

            if (FlagOn( AttrHeader->Flags,
                        ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE )) {

                //
                //  For sparse files indicate CC should flush when they're mapped
                //  to keep reservations accurate
                //

                if (FlagOn( AttrHeader->Flags, ATTRIBUTE_FLAG_SPARSE )) {

                    SetFlag( Scb->Header.Flags2, FSRTL_FLAG2_PURGE_WHEN_MAPPED );
                }

                //
                //  Only support compression on data streams.
                //

                if ((Scb->AttributeTypeCode != $DATA) &&
                    FlagOn( AttrHeader->Flags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

                    ClearFlag( Scb->ScbState, SCB_STATE_WRITE_COMPRESSED );
                    Scb->CompressionUnit = 0;
                    Scb->CompressionUnitShift = 0;
                    ClearFlag( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK );

                } else {

                    ASSERT( NtfsIsTypeCodeCompressible( Scb->AttributeTypeCode ));

                    //
                    //  Do not try to infer whether we are writing compressed or not
                    //  if we are actively changing the compression state.
                    //

                    if (!FlagOn( Scb->ScbState, SCB_STATE_REALLOCATE_ON_WRITE )) {

                        SetFlag( Scb->ScbState, SCB_STATE_WRITE_COMPRESSED );

                        if (!FlagOn( AttrHeader->Flags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

                            ClearFlag( Scb->ScbState, SCB_STATE_WRITE_COMPRESSED );
                        }
                    }

                    //
                    //  If the attribute is resident, then we will use our current
                    //  default.
                    //

                    if (Scb->CompressionUnit == 0) {

                        Scb->CompressionUnit = BytesFromClusters( Scb->Vcb, 1 << NTFS_CLUSTERS_PER_COMPRESSION );
                        Scb->CompressionUnitShift = NTFS_CLUSTERS_PER_COMPRESSION;

                        while (Scb->CompressionUnit > Scb->Vcb->SparseFileUnit) {

                            Scb->CompressionUnit >>= 1;
                            Scb->CompressionUnitShift -= 1;
                        }
                    }
                }

            } else {

                //
                //  If this file is NOT compressed or sparse, the WRITE_COMPRESSED flag
                //  has no reason to be ON, irrespective of the REALLOCATE_ON_WRITE flag.
                //  If we don't clear the flag here unconditionally, we can end up with Scbs with
                //  WRITE_COMPRESSED flags switched on, but CompressionUnits of 0.
                //

                ClearFlag( Scb->ScbState, SCB_STATE_WRITE_COMPRESSED );

                //
                //  Make sure compression unit is 0
                //

                Scb->CompressionUnit = 0;
                Scb->CompressionUnitShift = 0;
            }
        }

        //
        //  If the compression unit is non-zero or this is a resident file
        //  then set the flag in the common header for the Modified page writer.
        //

        NtfsAcquireFsrtlHeader( Scb );
        if (NodeType( Scb ) == NTFS_NTC_SCB_DATA) {

            Scb->Header.IsFastIoPossible = NtfsIsFastIoPossible( Scb );

        } else {

            Scb->Header.IsFastIoPossible = FastIoIsNotPossible;
        }

        NtfsReleaseFsrtlHeader( Scb );

        //
        //  Set the flag indicating this is the data attribute.
        //

        if (Scb->AttributeTypeCode == $DATA
            && Scb->AttributeName.Length == 0) {

            SetFlag( Scb->ScbState, SCB_STATE_UNNAMED_DATA );

        } else {

            ClearFlag( Scb->ScbState, SCB_STATE_UNNAMED_DATA );
        }

        SetFlag( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED );

        if (NtfsIsExclusiveScb(Scb)) {

            NtfsSnapshotScb( IrpContext, Scb );
        }

    } finally {

        DebugUnwind( NtfsUpdateScbFromAttribute );

        //
        //  Cleanup the attribute context.
        //

        if (CleanupAttrContext) {

            NtfsCleanupAttributeContext( IrpContext, &AttrContext );
        }

        DebugTrace( -1, Dbg, ("NtfsUpdateScbFromAttribute:  Exit\n") );
    }

    return;
}


BOOLEAN
NtfsUpdateFcbInfoFromDisk (
    IN PIRP_CONTEXT IrpContext,
    IN BOOLEAN LoadSecurity,
    IN OUT PFCB Fcb,
    OUT POLD_SCB_SNAPSHOT UnnamedDataSizes OPTIONAL
    )

/*++

Routine Description:

    This routine is called to update an Fcb from the on-disk attributes
    for a file.  We read the standard information and ea information.
    The first one must be present, we raise if not.  The other does not
    have to exist.  If this is not a directory, then we also need the
    size of the unnamed data attribute.

Arguments:

    LoadSecurity - Indicates if we should load the security for this file
        if not already present.

    Fcb - This is the Fcb to update.

    UnnamedDataSizes - If specified, then we store the details of the unnamed
        data attribute as we encounter it.

Return Value:

    TRUE - if we updated the unnamedatasizes

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    PATTRIBUTE_RECORD_HEADER AttributeHeader;
    BOOLEAN FoundEntry;
    BOOLEAN CorruptDisk = FALSE;
    BOOLEAN UpdatedNamedDataSizes = FALSE;

    PBCB Bcb = NULL;

    PDUPLICATED_INFORMATION Info;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsUpdateFcbInfoFromDisk:  Entered\n") );

    NtfsInitializeAttributeContext( &AttrContext );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Look for standard information.  This routine assumes it must be
        //  the first attribute.
        //

        if (FoundEntry = NtfsLookupAttribute( IrpContext,
                                              Fcb,
                                              &Fcb->FileReference,
                                              &AttrContext )) {

            //
            //  Verify that we found the standard information attribute.
            //

            AttributeHeader = NtfsFoundAttribute( &AttrContext );

            if (AttributeHeader->TypeCode != $STANDARD_INFORMATION) {

                try_return( CorruptDisk = TRUE );
            }

        } else {

            try_return( CorruptDisk = TRUE );
        }

        Info = &Fcb->Info;

        //
        //  Copy out the standard information values.
        //

        {
            PSTANDARD_INFORMATION StandardInformation;
            StandardInformation = (PSTANDARD_INFORMATION) NtfsAttributeValue( AttributeHeader );

            Info->CreationTime = StandardInformation->CreationTime;
            Info->LastModificationTime = StandardInformation->LastModificationTime;
            Info->LastChangeTime = StandardInformation->LastChangeTime;
            Info->LastAccessTime = StandardInformation->LastAccessTime;
            Info->FileAttributes = StandardInformation->FileAttributes;

            if (AttributeHeader->Form.Resident.ValueLength >=
                sizeof(STANDARD_INFORMATION)) {

                Fcb->OwnerId = StandardInformation->OwnerId;
                Fcb->SecurityId = StandardInformation->SecurityId;

                Fcb->Usn = StandardInformation->Usn;
                if (FlagOn( Fcb->Vcb->VcbState, VCB_STATE_USN_DELETE )) {

                    Fcb->Usn = 0;
                }

                SetFlag(Fcb->FcbState, FCB_STATE_LARGE_STD_INFO);
            }

        }

        Fcb->CurrentLastAccess = Info->LastAccessTime;

        //
        //  We initialize the fields that describe the EaSize or the tag of a reparse point.
        //  ReparsePointTag is a ULONG that is the union of  PackedEaSize  and  Reserved.
        //

        Info->ReparsePointTag = 0;

        //
        //  We get the FILE_NAME_INDEX_PRESENT bit by reading the
        //  file record.
        //

        if (FlagOn( NtfsContainingFileRecord( &AttrContext )->Flags,
                    FILE_FILE_NAME_INDEX_PRESENT )) {

            SetFlag( Info->FileAttributes, DUP_FILE_NAME_INDEX_PRESENT );

        } else {

            ClearFlag( Info->FileAttributes, DUP_FILE_NAME_INDEX_PRESENT );
        }

        //
        //  Ditto for the VIEW_INDEX_PRESENT bit.
        //

        if (FlagOn( NtfsContainingFileRecord( &AttrContext )->Flags,
                    FILE_VIEW_INDEX_PRESENT )) {

            SetFlag( Info->FileAttributes, DUP_VIEW_INDEX_PRESENT );

        } else {

            ClearFlag( Info->FileAttributes, DUP_VIEW_INDEX_PRESENT );
        }

        //
        //  We now walk through all of the filename attributes, counting the
        //  number of non-8dot3-only links.
        //

        Fcb->TotalLinks =
        Fcb->LinkCount = 0;

        FoundEntry = NtfsLookupNextAttributeByCode( IrpContext,
                                                    Fcb,
                                                    $FILE_NAME,
                                                    &AttrContext );

        while (FoundEntry) {

            PFILE_NAME FileName;

            AttributeHeader = NtfsFoundAttribute( &AttrContext );

            if (AttributeHeader->TypeCode != $FILE_NAME) {

                break;
            }

            FileName = (PFILE_NAME) NtfsAttributeValue( AttributeHeader );

            //
            //  We increment the count as long as this is not a 8.3 link
            //  only.
            //

            if (FileName->Flags != FILE_NAME_DOS) {

                Fcb->LinkCount += 1;
                Fcb->TotalLinks += 1;
            }

            //
            //  Now look for the next link.
            //

            FoundEntry = NtfsLookupNextAttribute( IrpContext,
                                                  Fcb,
                                                  &AttrContext );
        }

        //
        //  There better be at least one unless this is a system file.
        //

        if ((Fcb->LinkCount == 0) &&
            (NtfsSegmentNumber( &Fcb->FileReference ) >= FIRST_USER_FILE_NUMBER)) {

            try_return( CorruptDisk = TRUE );
        }

        //
        //  If we are to load the security and it is not already present we
        //  find the security attribute.
        //

        if (LoadSecurity && Fcb->SharedSecurity == NULL) {

            //
            //  We have two sources of security descriptors.  First, we have
            //  the SecurityId that is present in a large $STANDARD_INFORMATION.
            //  The other case is where we don't have such a security Id and must
            //  retrieve it from the $SECURITY_DESCRIPTOR attribute
            //
            //  In the case where we have the Id, we load it from the volume
            //  cache or index.
            //

            if (FlagOn( Fcb->FcbState, FCB_STATE_LARGE_STD_INFO ) &&
                (Fcb->SecurityId != SECURITY_ID_INVALID) &&
                (Fcb->Vcb->SecurityDescriptorStream != NULL)) {

                ASSERT( Fcb->SharedSecurity == NULL );
                Fcb->SharedSecurity = NtfsCacheSharedSecurityBySecurityId( IrpContext,
                                                                           Fcb->Vcb,
                                                                           Fcb->SecurityId );

                ASSERT( Fcb->SharedSecurity != NULL );

            } else {

                PSECURITY_DESCRIPTOR SecurityDescriptor;
                ULONG SecurityDescriptorLength;

                //
                //  We may have to walk forward to the security descriptor.
                //

                while (FoundEntry) {

                    AttributeHeader = NtfsFoundAttribute( &AttrContext );

                    if (AttributeHeader->TypeCode == $SECURITY_DESCRIPTOR) {

                        NtfsMapAttributeValue( IrpContext,
                                               Fcb,
                                               (PVOID *)&SecurityDescriptor,
                                               &SecurityDescriptorLength,
                                               &Bcb,
                                               &AttrContext );

                        NtfsSetFcbSecurityFromDescriptor(
                                               IrpContext,
                                               Fcb,
                                               SecurityDescriptor,
                                               SecurityDescriptorLength,
                                               FALSE );

                        //
                        //  If the security descriptor was resident then the Bcb field
                        //  in the attribute context was stored in the returned Bcb and
                        //  the Bcb in the attribute context was cleared.  In that case
                        //  the resumption of the attribute search will fail because
                        //  this module using the Bcb field to determine if this
                        //  is the initial enumeration.
                        //

                        if (NtfsIsAttributeResident( AttributeHeader )) {

                            NtfsFoundBcb( &AttrContext ) = Bcb;
                            Bcb = NULL;
                        }

                    } else if (AttributeHeader->TypeCode > $SECURITY_DESCRIPTOR) {

                        break;
                    }

                    FoundEntry = NtfsLookupNextAttribute( IrpContext,
                                                          Fcb,
                                                          &AttrContext );
                }
            }
        }

        //
        //  If this is not a directory, we need the file size.
        //

        if (!IsDirectory( Info ) && !IsViewIndex( Info )) {

            BOOLEAN FoundData = FALSE;

            //
            //  Look for the unnamed data attribute.
            //

            while (FoundEntry) {

                AttributeHeader = NtfsFoundAttribute( &AttrContext );

                if (AttributeHeader->TypeCode > $DATA) {

                    break;
                }

                if ((AttributeHeader->TypeCode == $DATA) &&
                    (AttributeHeader->NameLength == 0)) {

                    //
                    //  This can vary depending whether the attribute is resident
                    //  or nonresident.
                    //

                    if (NtfsIsAttributeResident( AttributeHeader )) {

                        //
                        //  Verify the resident value length.
                        //

                        if (AttributeHeader->Form.Resident.ValueLength > AttributeHeader->RecordLength - AttributeHeader->Form.Resident.ValueOffset) {

                            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
                        }

                        Info->AllocatedLength = AttributeHeader->Form.Resident.ValueLength;
                        Info->FileSize = Info->AllocatedLength;

                        ((ULONG)Info->AllocatedLength) = QuadAlign( (ULONG)(Info->AllocatedLength) );

                        //
                        //  If the user passed in a ScbSnapshot, then copy the attribute
                        //  sizes to that.  We use the trick of setting the low bit of the
                        //  attribute size to indicate a resident attribute.
                        //

                        if (ARGUMENT_PRESENT( UnnamedDataSizes )) {

                            UnnamedDataSizes->TotalAllocated =
                            UnnamedDataSizes->AllocationSize = Info->AllocatedLength;
                            UnnamedDataSizes->FileSize = Info->FileSize;
                            UnnamedDataSizes->ValidDataLength = Info->FileSize;

                            UnnamedDataSizes->Resident = TRUE;
                            UnnamedDataSizes->CompressionUnit = 0;

                            UnnamedDataSizes->AttributeFlags = AttributeHeader->Flags;
                            NtfsVerifySizesLongLong( UnnamedDataSizes );
                            UpdatedNamedDataSizes = TRUE;
                        }

                        FoundData = TRUE;

                    } else if (AttributeHeader->Form.Nonresident.LowestVcn == 0) {

                        Info->AllocatedLength = AttributeHeader->Form.Nonresident.AllocatedLength;
                        Info->FileSize = AttributeHeader->Form.Nonresident.FileSize;

                        if (ARGUMENT_PRESENT( UnnamedDataSizes )) {

                            UnnamedDataSizes->TotalAllocated =
                            UnnamedDataSizes->AllocationSize = Info->AllocatedLength;
                            UnnamedDataSizes->FileSize = Info->FileSize;
                            UnnamedDataSizes->ValidDataLength = AttributeHeader->Form.Nonresident.ValidDataLength;

                            UnnamedDataSizes->Resident = FALSE;
                            UnnamedDataSizes->CompressionUnit = AttributeHeader->Form.Nonresident.CompressionUnit;

                            NtfsVerifySizesLongLong( UnnamedDataSizes );

                            //
                            //  Remember if it is compressed.
                            //

                            UnnamedDataSizes->AttributeFlags = AttributeHeader->Flags;
                            UpdatedNamedDataSizes = TRUE;
                        }

                        if (FlagOn( AttributeHeader->Flags,
                                    ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE )) {

                            Info->AllocatedLength = AttributeHeader->Form.Nonresident.TotalAllocated;

                            if (ARGUMENT_PRESENT( UnnamedDataSizes )) {

                                UnnamedDataSizes->TotalAllocated = Info->AllocatedLength;

                                if (UnnamedDataSizes->TotalAllocated < 0) {

                                    UnnamedDataSizes->TotalAllocated = 0;

                                } else if (UnnamedDataSizes->TotalAllocated > Info->AllocatedLength) {

                                    UnnamedDataSizes->TotalAllocated = Info->AllocatedLength;
                                }
                            }
                        }

                        FoundData = TRUE;
                    }

                    break;
                }

                FoundEntry = NtfsLookupNextAttribute( IrpContext,
                                                      Fcb,
                                                      &AttrContext );
            }

            //
            //  The following test is bad for the 5.0 support.  Assume if someone is actually
            //  trying to open the unnamed data attribute, that the right thing will happen.
            //
            //
            //  if (!FoundData) {
            //
            //      try_return( CorruptDisk = TRUE );
            //  }

        } else {

            //
            //  Since it is a directory, try to find the $INDEX_ROOT.
            //

            while (FoundEntry) {

                AttributeHeader = NtfsFoundAttribute( &AttrContext );

                if (AttributeHeader->TypeCode > $INDEX_ROOT) {

                    //
                    //  We thought this was a directory, yet it has now index
                    //  root.  That's not a legal state to be in, so let's
                    //  take the corrupt disk path out of here.
                    //

                    ASSERT( FALSE );
                    try_return( CorruptDisk = TRUE );

                    break;
                }

                //
                //  Look for encryption bit and store in Fcb.
                //

                if (AttributeHeader->TypeCode == $INDEX_ROOT) {

                    if (FlagOn( AttributeHeader->Flags, ATTRIBUTE_FLAG_ENCRYPTED )) {

                        SetFlag( Fcb->FcbState, FCB_STATE_DIRECTORY_ENCRYPTED );
                    }

                    break;
                }

                FoundEntry = NtfsLookupNextAttribute( IrpContext,
                                                      Fcb,
                                                      &AttrContext );
            }

            Info->AllocatedLength = 0;
            Info->FileSize = 0;
        }

        //
        //  Now we look for a reparse point attribute.  This one doesn't have to
        //  be there. It may also not be resident.
        //

        while (FoundEntry) {

            PREPARSE_DATA_BUFFER ReparseInformation;

            AttributeHeader = NtfsFoundAttribute( &AttrContext );

            if (AttributeHeader->TypeCode > $REPARSE_POINT) {

                break;

            } else if (AttributeHeader->TypeCode == $REPARSE_POINT) {

                if (NtfsIsAttributeResident( AttributeHeader )) {

                    ReparseInformation = (PREPARSE_DATA_BUFFER) NtfsAttributeValue( NtfsFoundAttribute( &AttrContext ));

                } else {

                    ULONG Length;

                    if (AttributeHeader->Form.Nonresident.FileSize > MAXIMUM_REPARSE_DATA_BUFFER_SIZE) {
                        NtfsRaiseStatus( IrpContext,STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
                    }

                    NtfsMapAttributeValue( IrpContext,
                                           Fcb,
                                           (PVOID *)&ReparseInformation,   //  point to the value
                                           &Length,
                                           &Bcb,
                                           &AttrContext );
                }

                Info->ReparsePointTag = ReparseInformation->ReparseTag;

                break;
            }

            FoundEntry = NtfsLookupNextAttribute( IrpContext,
                                                  Fcb,
                                                  &AttrContext );
        }

        //
        //  Now we look for an Ea information attribute.  This one doesn't have to
        //  be there.
        //

        while (FoundEntry) {

            PEA_INFORMATION EaInformation;

            AttributeHeader = NtfsFoundAttribute( &AttrContext );

            if (AttributeHeader->TypeCode > $EA_INFORMATION) {

                break;

            } else if (AttributeHeader->TypeCode == $EA_INFORMATION) {

                EaInformation = (PEA_INFORMATION) NtfsAttributeValue( NtfsFoundAttribute( &AttrContext ));

                Info->PackedEaSize = EaInformation->PackedEaSize;

                break;
            }

            FoundEntry = NtfsLookupNextAttributeByCode( IrpContext,
                                                        Fcb,
                                                        $EA_INFORMATION,
                                                        &AttrContext );
        }

        //
        //  Set the flag in the Fcb to indicate that we set these fields.
        //

        SetFlag( Fcb->FcbState, FCB_STATE_DUP_INITIALIZED );

    try_exit: NOTHING;
    } finally {

        DebugUnwind( NtfsUpdateFcbInfoFromDisk );

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );
        NtfsUnpinBcb( IrpContext, &Bcb );

        DebugTrace( -1, Dbg, ("NtfsUpdateFcbInfoFromDisk:  Exit\n") );
    }

    //
    //  If we encountered a corrupt disk, we generate a popup and raise the file
    //  corrupt error.
    //

    if (CorruptDisk) {

        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
    }

    return UpdatedNamedDataSizes;
}


VOID
NtfsCleanupAttributeContext (
    IN OUT PIRP_CONTEXT IrpContext,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT AttributeContext
    )

/*++

Routine Description:

    This routine is called to free any resources claimed within an enumeration
    context and to unpin mapped or pinned data.

Arguments:

    IrpContext - context of the call

    AttributeContext - Pointer to the enumeration context to perform cleanup
                       on.

Return Value:

    None.

--*/

{

    UNREFERENCED_PARAMETER( IrpContext );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsCleanupAttributeContext\n") );

    //
    //  TEMPCODE   We need a call to cleanup any Scb's created.
    //

    //
    //  Unpin any Bcb's pinned here.
    //

    NtfsUnpinBcb( IrpContext, &AttributeContext->FoundAttribute.Bcb );
    NtfsUnpinBcb( IrpContext, &AttributeContext->AttributeList.Bcb );
    NtfsUnpinBcb( IrpContext, &AttributeContext->AttributeList.NonresidentListBcb );

    //
    //  Originally, we zeroed the entire context at this point.  This is
    //  wildly inefficient since the context is either deallocated soon thereafter
    //  or is initialized again.
    //
    //  RtlZeroMemory( AttributeContext, sizeof(ATTRIBUTE_ENUMERATION_CONTEXT) );
    //

    //  Set entire contents to -1 (and reset Bcb's to NULL) to verify
    //  that no one reuses this data structure

#if DBG
    RtlFillMemory( AttributeContext, sizeof( *AttributeContext ), -1 );
    AttributeContext->FoundAttribute.Bcb = NULL;
    AttributeContext->AttributeList.Bcb = NULL;
    AttributeContext->AttributeList.NonresidentListBcb = NULL;
#endif

    DebugTrace( -1, Dbg, ("NtfsCleanupAttributeContext -> VOID\n") );

    return;
}


BOOLEAN
NtfsWriteFileSizes (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PLONGLONG ValidDataLength,
    IN BOOLEAN AdvanceOnly,
    IN BOOLEAN LogIt,
    IN BOOLEAN RollbackMemStructures
    )

/*++

Routine Description:

    This routine is called to modify the filesize and valid data size
    on the disk from the Scb.

Arguments:

    Scb - Scb whose attribute is being modified.

    ValidDataLength - Supplies pointer to the new desired ValidDataLength

    AdvanceOnly - TRUE if the valid data length should be set only if
                  greater than the current value on disk.  FALSE if
                  the valid data length should be set only if
                  less than the current value on disk.

    LogIt - Indicates whether we should log this change.

    RollbackMemStructures - If true then there had better be snapshots to support doing this
                            if not this indicates we're transferring persisted in memory
                            changes to disk.  I.e a the final writefilesizes at close time
                            or the check_attribute_sizes related calls

Return Value:

    TRUE if a log record was written out

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    PATTRIBUTE_RECORD_HEADER AttributeHeader;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;

    NEW_ATTRIBUTE_SIZES OldAttributeSizes;
    NEW_ATTRIBUTE_SIZES NewAttributeSizes;

    ULONG LogRecordSize = SIZEOF_PARTIAL_ATTRIBUTE_SIZES;
    BOOLEAN SparseAllocation = FALSE;

    BOOLEAN UpdateMft = FALSE;
    BOOLEAN Logged = FALSE;

    PAGED_CODE();

    UNREFERENCED_PARAMETER( RollbackMemStructures );

    //
    //  Return immediately if the volume is locked unless we have grown the Mft or the Bitmap.
    //  In some cases the user can grow the Mft with the volume locked (i.e. add
    //  a Usn journal).
    //

    if (FlagOn( Scb->Vcb->VcbState, VCB_STATE_LOCKED ) &&
        (Scb != Scb->Vcb->MftScb) && (Scb != Scb->Vcb->BitmapScb)) {

        return Logged;
    }

    DebugTrace( +1, Dbg, ("NtfsWriteFileSizes:  Entered\n") );

    ASSERT( (Scb->ScbSnapshot != NULL) || !RollbackMemStructures );

    //
    //  Use a try_finally to facilitate cleanup.
    //

    try {

        //
        //  Find the attribute on the disk.
        //

        NtfsInitializeAttributeContext( &AttrContext );

        NtfsLookupAttributeForScb( IrpContext, Scb, NULL, &AttrContext );

        //
        //  Pull the pointers out of the attribute context.
        //

        FileRecord = NtfsContainingFileRecord( &AttrContext );
        AttributeHeader = NtfsFoundAttribute( &AttrContext );

        //
        //  Check if this is a resident attribute, and if it is then we only
        //  want to assert that the file sizes match and then return to
        //  our caller
        //

        if (NtfsIsAttributeResident( AttributeHeader )) {

            try_return( NOTHING );
        }

        //
        //  Remember the existing values.
        //

        OldAttributeSizes.TotalAllocated =
        OldAttributeSizes.AllocationSize = AttributeHeader->Form.Nonresident.AllocatedLength;
        OldAttributeSizes.ValidDataLength = AttributeHeader->Form.Nonresident.ValidDataLength;
        OldAttributeSizes.FileSize = AttributeHeader->Form.Nonresident.FileSize;
        NtfsVerifySizesLongLong( &OldAttributeSizes );

        if (FlagOn( AttributeHeader->Flags,
                    ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE )) {

            SparseAllocation = TRUE;
            OldAttributeSizes.TotalAllocated = AttributeHeader->Form.Nonresident.TotalAllocated;
        }

        //
        //  Copy these values.
        //

        NewAttributeSizes = OldAttributeSizes;

        //
        //  We only want to modify the sizes if the current thread owns the
        //  EOF.  The exception is the TotalAllocated field for a compressed file.
        //  Otherwise this transaction might update the file size on disk at the
        //  same time an operation on EOF might roll back the Scb value.  The
        //  two resulting numbers would conflict.
        //
        //  Use the same test that NtfsRestoreScbSnapshots uses.
        //

        ASSERT( !RollbackMemStructures ||
                !NtfsSnapshotFileSizesTest( IrpContext, Scb ) ||
                (Scb->ScbSnapshot->OwnerIrpContext == IrpContext) ||
                (Scb->ScbSnapshot->OwnerIrpContext == IrpContext->TopLevelIrpContext));


        if (((Scb->ScbSnapshot != NULL) &&
             ((Scb->ScbSnapshot->OwnerIrpContext == IrpContext) ||
              (Scb->ScbSnapshot->OwnerIrpContext == IrpContext->TopLevelIrpContext))) ||
            (!RollbackMemStructures && NtfsSnapshotFileSizesTest( IrpContext, Scb ))) {

            //
            //  Check if we will be modifying the valid data length on
            //  disk.  Don't acquire this for the paging file in case the
            //  current code block needs to be paged in.
            //

            if (!FlagOn( Scb->Fcb->FcbState, FCB_STATE_PAGING_FILE )) {

                NtfsAcquireFsrtlHeader( Scb );
            }

            if ((AdvanceOnly
                 && (*ValidDataLength > OldAttributeSizes.ValidDataLength))

                || (!AdvanceOnly
                    && (*ValidDataLength < OldAttributeSizes.ValidDataLength))) {

                //
                //  Copy the valid data length into the new size structure.
                //

                NewAttributeSizes.ValidDataLength = *ValidDataLength;
                UpdateMft = TRUE;
            }

            //
            //  Now check if we're modifying the filesize.
            //

            if (Scb->Header.FileSize.QuadPart != OldAttributeSizes.FileSize) {

                NewAttributeSizes.FileSize = Scb->Header.FileSize.QuadPart;
                UpdateMft = TRUE;
            }

            if (!FlagOn( Scb->Fcb->FcbState, FCB_STATE_PAGING_FILE )) {

                NtfsReleaseFsrtlHeader(Scb);
            }

            //
            //  Finally, update the allocated length from the Scb if it is different.
            //

            if (Scb->Header.AllocationSize.QuadPart != AttributeHeader->Form.Nonresident.AllocatedLength) {

                NewAttributeSizes.AllocationSize = Scb->Header.AllocationSize.QuadPart;
                UpdateMft = TRUE;
            }
        }

        //
        //  If this is compressed then check if totally allocated has changed.
        //

        if (SparseAllocation) {

            LogRecordSize = SIZEOF_FULL_ATTRIBUTE_SIZES;

            if (Scb->TotalAllocated != OldAttributeSizes.TotalAllocated) {

                ASSERT( !RollbackMemStructures || (Scb->ScbSnapshot != NULL) );

                NewAttributeSizes.TotalAllocated = Scb->TotalAllocated;
                UpdateMft = TRUE;
            }
        }

        //
        //  Continue on if we need to update the Mft.
        //

        if (UpdateMft) {

            //
            //  Pin the attribute.
            //

            NtfsPinMappedAttribute( IrpContext,
                                    Scb->Vcb,
                                    &AttrContext );

            AttributeHeader = NtfsFoundAttribute( &AttrContext );

            if (NewAttributeSizes.ValidDataLength > NewAttributeSizes.FileSize) {

                NewAttributeSizes.ValidDataLength = NewAttributeSizes.FileSize;
            }

            ASSERT(NewAttributeSizes.FileSize <= NewAttributeSizes.AllocationSize);
            ASSERT(NewAttributeSizes.ValidDataLength <= NewAttributeSizes.AllocationSize);

            NtfsVerifySizesLongLong( &NewAttributeSizes );

            //
            //  Log this change to the attribute header.
            //

            if (LogIt) {

                FileRecord->Lsn = NtfsWriteLog( IrpContext,
                                                Scb->Vcb->MftScb,
                                                NtfsFoundBcb( &AttrContext ),
                                                SetNewAttributeSizes,
                                                &NewAttributeSizes,
                                                LogRecordSize,
                                                SetNewAttributeSizes,
                                                &OldAttributeSizes,
                                                LogRecordSize,
                                                NtfsMftOffset( &AttrContext ),
                                                PtrOffset( FileRecord, AttributeHeader ),
                                                0,
                                                Scb->Vcb->BytesPerFileRecordSegment );

                Logged = TRUE;

            } else {

                CcSetDirtyPinnedData( NtfsFoundBcb( &AttrContext ), NULL );
            }

            AttributeHeader->Form.Nonresident.AllocatedLength = NewAttributeSizes.AllocationSize;
            AttributeHeader->Form.Nonresident.FileSize = NewAttributeSizes.FileSize;
            AttributeHeader->Form.Nonresident.ValidDataLength = NewAttributeSizes.ValidDataLength;

            //
            //  Don't modify the total allocated field unless there is an actual field for it.
            //

            if (SparseAllocation &&
                ((AttributeHeader->NameOffset >= SIZEOF_FULL_NONRES_ATTR_HEADER) ||
                 ((AttributeHeader->NameOffset == 0) &&
                  (AttributeHeader->Form.Nonresident.MappingPairsOffset >= SIZEOF_FULL_NONRES_ATTR_HEADER)))) {

                AttributeHeader->Form.Nonresident.TotalAllocated = NewAttributeSizes.TotalAllocated;
            }
        }

    try_exit: NOTHING;
    } finally {

        DebugUnwind( NtfsWriteFileSizes );

        //
        //  Cleanup the attribute context.
        //

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );

        DebugTrace( -1, Dbg, ("NtfsWriteFileSizes:  Exit\n") );
    }

    return Logged;
}


VOID
NtfsUpdateStandardInformation (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine is called to update the standard information attribute
    for a file from the information in the Fcb.  The fields being modified
    are the time fields and the file attributes.

Arguments:

    Fcb - Fcb for the file to modify.

Return Value:

    None

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    STANDARD_INFORMATION StandardInformation;
    ULONG Length;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsUpdateStandardInformation:  Entered\n") );

    //
    //  Return immediately if the volume is mounted readonly.
    //

    if (NtfsIsVolumeReadOnly( Fcb->Vcb )) {

        return;
    }

    //
    //  Use a try-finally to cleanup the attribute context.
    //

    try {

        //
        //  Initialize the context structure.
        //

        NtfsInitializeAttributeContext( &AttrContext );

        //
        //  Locate the standard information, it must be there.
        //

        if (!NtfsLookupAttributeByCode( IrpContext,
                                        Fcb,
                                        &Fcb->FileReference,
                                        $STANDARD_INFORMATION,
                                        &AttrContext )) {

            DebugTrace( 0, Dbg, ("Can't find standard information\n") );

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
        }

        Length = NtfsFoundAttribute( &AttrContext )->Form.Resident.ValueLength;

        //
        //  Copy the existing standard information to our buffer.
        //

        RtlCopyMemory( &StandardInformation,
                       NtfsAttributeValue( NtfsFoundAttribute( &AttrContext )),
                       Length);


        //
        //  Since we are updating standard information, make sure the last
        //  access time is up-to-date.
        //

        if (Fcb->Info.LastAccessTime != Fcb->CurrentLastAccess) {

            Fcb->Info.LastAccessTime = Fcb->CurrentLastAccess;
            SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_LAST_ACCESS );
        }

        //
        //  No need to update last access standard information later.
        //

        ClearFlag( Fcb->InfoFlags, FCB_INFO_UPDATE_LAST_ACCESS );

        //
        //  Change the relevant time fields.
        //

        StandardInformation.CreationTime = Fcb->Info.CreationTime;
        StandardInformation.LastModificationTime = Fcb->Info.LastModificationTime;
        StandardInformation.LastChangeTime = Fcb->Info.LastChangeTime;
        StandardInformation.LastAccessTime = Fcb->Info.LastAccessTime;
        StandardInformation.FileAttributes = Fcb->Info.FileAttributes;

        //
        //  We clear the directory bit.
        //

        ClearFlag( StandardInformation.FileAttributes, DUP_FILE_NAME_INDEX_PRESENT );

        //
        //  Fill in the new fields if necessary.
        //

        if (FlagOn(Fcb->FcbState, FCB_STATE_LARGE_STD_INFO)) {

            StandardInformation.ClassId = 0;
            StandardInformation.OwnerId = Fcb->OwnerId;
            StandardInformation.SecurityId = Fcb->SecurityId;
            StandardInformation.Usn = Fcb->Usn;
        }

        //
        //  Call to change the attribute value.
        //

        NtfsChangeAttributeValue( IrpContext,
                                  Fcb,
                                  0,
                                  &StandardInformation,
                                  Length,
                                  FALSE,
                                  FALSE,
                                  FALSE,
                                  FALSE,
                                  &AttrContext );


    } finally {

        DebugUnwind( NtfsUpdateStandadInformation );

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );

        DebugTrace( -1, Dbg, ("NtfsUpdateStandardInformation:  Exit\n") );
    }

    return;
}


VOID
NtfsGrowStandardInformation (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine is called to grow and update the standard information
    attribute for a file from the information in the Fcb.

Arguments:

    Fcb - Fcb for the file to modify.

Return Value:

    None

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    STANDARD_INFORMATION StandardInformation;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsGrowStandardInformation:  Entered\n") );

    //
    //  Use a try-finally to cleanup the attribute context.
    //

    try {

        //
        //  Initialize the context structure.
        //

        NtfsInitializeAttributeContext( &AttrContext );

        //
        //  Locate the standard information, it must be there.
        //

        if (!NtfsLookupAttributeByCode( IrpContext,
                                        Fcb,
                                        &Fcb->FileReference,
                                        $STANDARD_INFORMATION,
                                        &AttrContext )) {

            DebugTrace( 0, Dbg, ("Can't find standard information\n") );

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
        }

        if (NtfsFoundAttribute( &AttrContext )->Form.Resident.ValueLength ==
            SIZEOF_OLD_STANDARD_INFORMATION) {

            //
            //  Copy the existing standard information to our buffer.
            //

            RtlCopyMemory( &StandardInformation,
                           NtfsAttributeValue( NtfsFoundAttribute( &AttrContext )),
                           SIZEOF_OLD_STANDARD_INFORMATION);

            RtlZeroMemory((PCHAR) &StandardInformation +
                            SIZEOF_OLD_STANDARD_INFORMATION,
                            sizeof( STANDARD_INFORMATION) -
                            SIZEOF_OLD_STANDARD_INFORMATION);
        }

        //
        //  Since we are updating standard information, make sure the last
        //  access time is up-to-date.
        //

        if (Fcb->Info.LastAccessTime != Fcb->CurrentLastAccess) {

            Fcb->Info.LastAccessTime = Fcb->CurrentLastAccess;
            SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_LAST_ACCESS );
        }

        //
        //  Change the relevant time fields.
        //

        StandardInformation.CreationTime = Fcb->Info.CreationTime;
        StandardInformation.LastModificationTime = Fcb->Info.LastModificationTime;
        StandardInformation.LastChangeTime = Fcb->Info.LastChangeTime;
        StandardInformation.LastAccessTime = Fcb->Info.LastAccessTime;
        StandardInformation.FileAttributes = Fcb->Info.FileAttributes;

        //
        //  We clear the directory bit.
        //

        ClearFlag( StandardInformation.FileAttributes, DUP_FILE_NAME_INDEX_PRESENT );


        //
        //  Fill in the new fields.
        //

        StandardInformation.ClassId = 0;
        StandardInformation.OwnerId = Fcb->OwnerId;
        StandardInformation.SecurityId = Fcb->SecurityId;
        StandardInformation.Usn = Fcb->Usn;

        //
        //  Call to change the attribute value.
        //

        NtfsChangeAttributeValue( IrpContext,
                                  Fcb,
                                  0,
                                  &StandardInformation,
                                  sizeof( STANDARD_INFORMATION),
                                  TRUE,
                                  FALSE,
                                  FALSE,
                                  FALSE,
                                  &AttrContext );


        ClearFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );
        SetFlag( Fcb->FcbState, FCB_STATE_LARGE_STD_INFO );

    } finally {

        DebugUnwind( NtfsGrowStandadInformation );

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );

        DebugTrace( -1, Dbg, ("NtfsGrowStandardInformation:  Exit\n") );
    }

    return;
}

BOOLEAN
NtfsLookupEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ParentScb,
    IN BOOLEAN IgnoreCase,
    IN OUT PUNICODE_STRING Name,
    IN OUT PFILE_NAME *FileNameAttr,
    IN OUT PUSHORT FileNameAttrLength,
    OUT PQUICK_INDEX QuickIndex OPTIONAL,
    OUT PINDEX_ENTRY *IndexEntry,
    OUT PBCB *IndexEntryBcb,
    OUT PINDEX_CONTEXT IndexContext OPTIONAL
    )

/*++

Routine Description:

    This routine is called to look up a particular file name in a directory.
    It takes a single component name and a parent Scb to search in.
    To do the search, we need to construct a FILE_NAME attribute.
    We use a reusable buffer to do this, to avoid constantly allocating
    and deallocating pool.  We try to keep this larger than we will ever need.

    When we find a match on disk, we copy over the name we were called with so
    we have a record of the actual case on the disk.  In this way we can
    be case perserving.

Arguments:

    ParentScb - This is the Scb for the parent directory.

    IgnoreCase - Indicates if we should ignore case while searching through
        the index.

    Name - This is the path component to search for.  We will overwrite this
        in place if a match is found.

    FileNameAttr - Address of the buffer we will use to create the file name
        attribute.  We will free this buffer and allocate a new buffer
        if needed.

    FileNameAttrLength - This is the length of the FileNameAttr buffer above.

    QuickIndex - If specified, supplies a pointer to a quik lookup structure
        to be updated by this routine.

    IndexEntry - Address to store the cache address of the matching entry.

    IndexEntryBcb - Address to store the Bcb for the IndexEntry above.

    IndexContext - Initialized IndexContext used for the lookup.  Can be used
        later when inserting an entry on a miss.

Return Value:

    BOOLEAN - TRUE if a match was found, FALSE otherwise.

--*/

{
    BOOLEAN FoundEntry;
    USHORT Size;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsLookupEntry:  Entered\n") );

    //
    //  We compute the size of the buffer needed to build the filename
    //  attribute.  If the current buffer is too small we deallocate it
    //  and allocate a new one.  We always allocate twice the size we
    //  need in order to minimize the number of allocations.
    //

    Size = (USHORT)(sizeof( FILE_NAME ) + Name->Length - sizeof(WCHAR));

    if (Size > *FileNameAttrLength) {

        if (*FileNameAttr != NULL) {

            DebugTrace( 0, Dbg, ("Deallocating previous file name attribute buffer\n") );
            NtfsFreePool( *FileNameAttr );

            *FileNameAttr = NULL;
        }

        *FileNameAttr = NtfsAllocatePool(PagedPool, Size << 1 );
        *FileNameAttrLength = Size << 1;
    }

    //
    //  We build the filename attribute.  If this operation is ignore case,
    //  we upcase the expression in the filename attribute.
    //

    NtfsBuildFileNameAttribute( IrpContext,
                                &ParentScb->Fcb->FileReference,
                                *Name,
                                0,
                                *FileNameAttr );

    //
    //  Now we call the index routine to perform the search.
    //

    FoundEntry = NtfsFindIndexEntry( IrpContext,
                                     ParentScb,
                                     *FileNameAttr,
                                     IgnoreCase,
                                     QuickIndex,
                                     IndexEntryBcb,
                                     IndexEntry,
                                     IndexContext );

    //
    //  We always restore the name in the filename attribute to the original
    //  name in case we upcased it in the lookup.
    //

    if (IgnoreCase) {

        RtlCopyMemory( (*FileNameAttr)->FileName,
                       Name->Buffer,
                       Name->Length );
    }

    DebugTrace( -1, Dbg, ("NtfsLookupEntry:  Exit -> %04x\n", FoundEntry) );

    return FoundEntry;
}



VOID
NtfsCreateAttributeWithValue (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ATTRIBUTE_TYPE_CODE AttributeTypeCode,
    IN PUNICODE_STRING AttributeName OPTIONAL,
    IN PVOID Value OPTIONAL,
    IN ULONG ValueLength,
    IN USHORT AttributeFlags,
    IN PFILE_REFERENCE WhereIndexed OPTIONAL,
    IN BOOLEAN LogIt,
    OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    )

/*++

Routine Description:

    This routine creates the specified attribute with the specified value,
    and returns a description of it via the attribute context.  If no
    value is specified, then the attribute is created with the specified
    number of zero bytes.

    On successful return, it is up to the caller to clean up the attribute
    context.

Arguments:

    Fcb - Current file.

    AttributeTypeCode - Type code of the attribute to create.

    AttributeName - Optional name for attribute.

    Value - Pointer to the buffer containing the desired attribute value,
            or a NULL if zeros are desired.

    ValueLength - Length of value in bytes.

    AttributeFlags - Desired flags for the created attribute.

    WhereIndexed - Optionally supplies the file reference to the file where
                   this attribute is indexed.

    LogIt - Most callers should specify TRUE, to have the change logged.  However,
            we can specify FALSE if we are creating a new file record, and
            will be logging the entire new file record.

    Context - A handle to the created attribute.  This must be cleaned up upon
              return.  Callers who may have made an attribute nonresident may
              not count on accessing the created attribute via this context upon
              return.

Return Value:

    None.

--*/

{
    UCHAR AttributeBuffer[SIZEOF_FULL_NONRES_ATTR_HEADER];
    ULONG RecordOffset;
    PATTRIBUTE_RECORD_HEADER Attribute;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    ULONG SizeNeeded;
    ULONG AttrSizeNeeded;
    PVCB Vcb;
    ULONG Passes = 0;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );

    PAGED_CODE();

    ASSERT( (AttributeFlags == 0) ||
            (AttributeTypeCode == $INDEX_ROOT) ||
            NtfsIsTypeCodeCompressible( AttributeTypeCode ));

    Vcb = Fcb->Vcb;

    DebugTrace( +1, Dbg, ("NtfsCreateAttributeWithValue\n") );
    DebugTrace( 0, Dbg, ("Value = %08lx\n", Value) );
    DebugTrace( 0, Dbg, ("ValueLength = %08lx\n", ValueLength) );

    //
    //  Clear out the invalid attribute flags for this volume.
    //

    ClearFlag( AttributeFlags, ~Vcb->AttributeFlagsMask );

    //
    //  Calculate the size needed for this attribute
    //

    SizeNeeded = SIZEOF_RESIDENT_ATTRIBUTE_HEADER + QuadAlign( ValueLength ) +
                 (ARGUMENT_PRESENT( AttributeName ) ?
                   QuadAlign( AttributeName->Length ) : 0);

    //
    //  Loop until we find all the space we need.
    //

    do {

        //
        //  Reinitialize context if this is not the first pass.
        //

        if (Passes != 0) {

            NtfsCleanupAttributeContext( IrpContext, Context );
            NtfsInitializeAttributeContext( Context );
        }

        Passes += 1;

        //
        //  Hope we will never have to loop thru this that many times.
        //  If so, we will have to bump up the threshold again or change
        //  the algorithm.
        //

        ASSERT( Passes < 6 );

        //
        //  If the attribute is not indexed, then we will position to the
        //  insertion point by type code and name.
        //

        if (!ARGUMENT_PRESENT( WhereIndexed )) {

            if (NtfsLookupAttributeByName( IrpContext,
                                           Fcb,
                                           &Fcb->FileReference,
                                           AttributeTypeCode,
                                           AttributeName,
                                           NULL,
                                           FALSE,
                                           Context )) {

                DebugTrace( 0, 0,
                            ("Nonindexed attribute already exists, TypeCode = %08lx\n",
                             AttributeTypeCode ));

                ASSERTMSG("Nonindexed attribute already exists, About to raise corrupt ", FALSE);

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
            }

            //
            //  Check here if the attribute needs to be nonresident and if so just
            //  pass this off.
            //

            FileRecord = NtfsContainingFileRecord(Context);

            if ((SizeNeeded > (FileRecord->BytesAvailable - FileRecord->FirstFreeByte)) &&
                (SizeNeeded >= Vcb->BigEnoughToMove) &&
                !FlagOn( NtfsGetAttributeDefinition( Vcb,
                                                     AttributeTypeCode)->Flags,
                         ATTRIBUTE_DEF_MUST_BE_RESIDENT)) {

                NtfsCreateNonresidentWithValue( IrpContext,
                                                Fcb,
                                                AttributeTypeCode,
                                                AttributeName,
                                                Value,
                                                ValueLength,
                                                AttributeFlags,
                                                FALSE,
                                                NULL,
                                                LogIt,
                                                Context );

                return;
            }

        //
        //  Otherwise, if the attribute is indexed, then we position by the
        //  attribute value.
        //

        } else {

            ASSERT(ARGUMENT_PRESENT(Value));

            if (NtfsLookupAttributeByValue( IrpContext,
                                            Fcb,
                                            &Fcb->FileReference,
                                            AttributeTypeCode,
                                            Value,
                                            ValueLength,
                                            Context )) {

                DebugTrace( 0, 0,
                            ("Indexed attribute already exists, TypeCode = %08lx\n",
                            AttributeTypeCode ));

                ASSERTMSG("Indexed attribute already exists, About to raise corrupt ", FALSE);
                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
            }
        }

        //
        //  If this attribute is being positioned in the base file record and
        //  there is an attribute list then we need to ask for enough space
        //  for the attribute list entry now.
        //

        FileRecord = NtfsContainingFileRecord( Context );
        Attribute = NtfsFoundAttribute( Context );

        AttrSizeNeeded = SizeNeeded;
        if (Context->AttributeList.Bcb != NULL
            && (ULONG_PTR) FileRecord <= (ULONG_PTR) Context->AttributeList.AttributeList
            && (ULONG_PTR) Attribute >= (ULONG_PTR) Context->AttributeList.AttributeList) {

            //
            //  If the attribute list is non-resident then add a fudge factor of
            //  16 bytes for any new retrieval information.
            //

            if (NtfsIsAttributeResident( Context->AttributeList.AttributeList )) {

                AttrSizeNeeded += QuadAlign( FIELD_OFFSET( ATTRIBUTE_LIST_ENTRY, AttributeName )
                                             + (ARGUMENT_PRESENT( AttributeName ) ?
                                                (ULONG) AttributeName->Length :
                                                sizeof( WCHAR )));

            } else {

                AttrSizeNeeded += 0x10;
            }
        }

        //
        //  Ask for the space we need.
        //

    } while (!NtfsGetSpaceForAttribute( IrpContext, Fcb, AttrSizeNeeded, Context ));

    //
    //  Now point to the file record and calculate the record offset where
    //  our attribute will go.  And point to our local buffer.
    //

    RecordOffset = (ULONG)((PCHAR)NtfsFoundAttribute(Context) - (PCHAR)FileRecord);
    Attribute = (PATTRIBUTE_RECORD_HEADER)AttributeBuffer;

    if (RecordOffset >= Fcb->Vcb->BytesPerFileRecordSegment) {

        ASSERTMSG("RecordOffset beyond FRS size, About to raise corrupt ", FALSE);
        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
    }

    RtlZeroMemory( Attribute, SIZEOF_RESIDENT_ATTRIBUTE_HEADER );

    Attribute->TypeCode = AttributeTypeCode;
    Attribute->RecordLength = SizeNeeded;
    Attribute->FormCode = RESIDENT_FORM;

    if (ARGUMENT_PRESENT(AttributeName)) {

        ASSERT( AttributeName->Length <= 0x1FF );

        Attribute->NameLength = (UCHAR)(AttributeName->Length / sizeof(WCHAR));
        Attribute->NameOffset = (USHORT)SIZEOF_RESIDENT_ATTRIBUTE_HEADER;
    }

    Attribute->Flags = AttributeFlags;
    Attribute->Instance = FileRecord->NextAttributeInstance;

    //
    //  If someone repeatedly adds and removes attributes from a file record we could
    //  hit a case where the sequence number will overflow.  In this case we
    //  want to scan the file record and find an earlier free instance number.
    //

    if (Attribute->Instance > NTFS_CHECK_INSTANCE_ROLLOVER) {

        Attribute->Instance = NtfsScanForFreeInstance( IrpContext, Vcb, FileRecord );
    }

    Attribute->Form.Resident.ValueLength = ValueLength;
    Attribute->Form.Resident.ValueOffset =
      (USHORT)(SIZEOF_RESIDENT_ATTRIBUTE_HEADER +
      QuadAlign( Attribute->NameLength << 1) );

    //
    //  If this attribute is indexed, then we have to set the right flag
    //  and update the file record reference count.
    //

    if (ARGUMENT_PRESENT(WhereIndexed)) {
        Attribute->Form.Resident.ResidentFlags = RESIDENT_FORM_INDEXED;
    }

    //
    //  Now we will actually create the attribute in place, so that we
    //  save copying everything twice, and can point to the final image
    //  for the log write below.
    //

    NtfsRestartInsertAttribute( IrpContext,
                                FileRecord,
                                RecordOffset,
                                Attribute,
                                AttributeName,
                                Value,
                                ValueLength );

    //
    //  Finally, log the creation of this attribute
    //

    if (LogIt) {

        //
        //  We have actually created the attribute above, but the write
        //  log below could fail.  The reason we did the create already
        //  was to avoid having to allocate pool and copy everything
        //  twice (header, name and value).  Our normal error recovery
        //  just recovers from the log file.  But if we fail to write
        //  the log, we have to remove this attribute by hand, and
        //  raise the condition again.
        //

        try {

            FileRecord->Lsn =
            NtfsWriteLog( IrpContext,
                          Vcb->MftScb,
                          NtfsFoundBcb(Context),
                          CreateAttribute,
                          Add2Ptr(FileRecord, RecordOffset),
                          Attribute->RecordLength,
                          DeleteAttribute,
                          NULL,
                          0,
                          NtfsMftOffset( Context ),
                          RecordOffset,
                          0,
                          Vcb->BytesPerFileRecordSegment );

        } except(NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {

            NtfsRestartRemoveAttribute( IrpContext, FileRecord, RecordOffset );

            NtfsRaiseStatus( IrpContext, GetExceptionCode(), NULL, NULL );
        }
    }

    //
    //  Now add it to the attribute list if necessary
    //

    if (Context->AttributeList.Bcb != NULL) {

        MFT_SEGMENT_REFERENCE SegmentReference;

        *(PLONGLONG)&SegmentReference = LlFileRecordsFromBytes( Vcb, NtfsMftOffset( Context ));
        SegmentReference.SequenceNumber = FileRecord->SequenceNumber;

        NtfsAddToAttributeList( IrpContext, Fcb, SegmentReference, Context );
    }

    DebugTrace( -1, Dbg, ("NtfsCreateAttributeWithValue -> VOID\n") );

    return;
}


VOID
NtfsCreateNonresidentWithValue (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ATTRIBUTE_TYPE_CODE AttributeTypeCode,
    IN PUNICODE_STRING AttributeName OPTIONAL,
    IN PVOID Value OPTIONAL,
    IN ULONG ValueLength,
    IN USHORT AttributeFlags,
    IN BOOLEAN WriteClusters,
    IN PSCB ThisScb OPTIONAL,
    IN BOOLEAN LogIt,
    IN PATTRIBUTE_ENUMERATION_CONTEXT Context
    )

/*++

Routine Description:

    This routine creates the specified nonresident attribute with the specified
    value, and returns a description of it via the attribute context. If no
    value is specified, then the attribute is created with the specified
    number of zero bytes.

    On successful return, it is up to the caller to clean up the attribute
    context.

Arguments:

    Fcb - Current file.

    AttributeTypeCode - Type code of the attribute to create.

    AttributeName - Optional name for attribute.

    Value - Pointer to the buffer containing the desired attribute value,
            or a NULL if zeros are desired.

    ValueLength - Length of value in bytes.

    AttributeFlags - Desired flags for the created attribute.

    WriteClusters - if supplied as TRUE, then we cannot write the data into the
        cache but must write the clusters directly to the disk.  The value buffer
        in this case must be quad-aligned and a multiple of cluster size in size.
        If TRUE it also means we are being called during the NtfsConvertToNonresident
        path.  We need to set a flag in the Scb in that case.

    ThisScb - If present, this is the Scb to use for the create.  It also indicates
              that this call is from convert to non-resident.

    LogIt - Most callers should specify TRUE, to have the change logged.  However,
            we can specify FALSE if we are creating a new file record, and
            will be logging the entire new file record.

    Context - This is the location to create the new attribute.

Return Value:

    None.

--*/

{
    PSCB Scb;
    BOOLEAN ReturnedExistingScb;
    UNICODE_STRING LocalName;
    PVCB Vcb = Fcb->Vcb;
    BOOLEAN LogNonresidentToo;
    BOOLEAN AdvanceOnly;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsCreateNonresidentWithValue\n") );

    //
    //  When we're updating the attribute definition table, we want that operation
    //  to be logged, even though it's a $DATA attribute.
    //

    //
    //  TODO: post nt5.1 change chkdsk so it can recognize an attrdef table with $EA
    //  log non-resident
    //


    AdvanceOnly =
    LogNonresidentToo = (BooleanFlagOn( NtfsGetAttributeDefinition( Vcb, AttributeTypeCode )->Flags,
                                        ATTRIBUTE_DEF_LOG_NONRESIDENT) ||
                         NtfsEqualMftRef( &Fcb->FileReference, &AttrDefFileReference ) ||
                         ($EA == AttributeTypeCode) );

    ASSERT( (AttributeFlags == 0) || NtfsIsTypeCodeCompressible( AttributeTypeCode ));

    //
    //  Clear out the invalid attribute flags for this volume.
    //

    AttributeFlags &= Vcb->AttributeFlagsMask;

    if (ARGUMENT_PRESENT(AttributeName)) {

        LocalName = *AttributeName;

    } else {

        LocalName.Length = LocalName.MaximumLength = 0;
        LocalName.Buffer = NULL;
    }

    if (ARGUMENT_PRESENT( ThisScb )) {

        Scb = ThisScb;
        ReturnedExistingScb = TRUE;

    } else {

        Scb = NtfsCreateScb( IrpContext,
                             Fcb,
                             AttributeTypeCode,
                             &LocalName,
                             FALSE,
                             &ReturnedExistingScb );

        //
        //  An attribute has gone away but the Scb hasn't left yet.
        //  Also mark the header as unitialized.
        //

        ClearFlag( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED |
                                  SCB_STATE_ATTRIBUTE_RESIDENT |
                                  SCB_STATE_FILE_SIZE_LOADED );

        //
        //  Set a flag in the Scb to indicate that we are converting to non-resident.
        //

        if (WriteClusters) { SetFlag( Scb->ScbState, SCB_STATE_CONVERT_UNDERWAY ); }
    }

    //
    //  Allocate the record for the size we need.
    //

    NtfsAllocateAttribute( IrpContext,
                           Scb,
                           AttributeTypeCode,
                           AttributeName,
                           AttributeFlags,
                           TRUE,
                           LogIt,
                           (LONGLONG) ValueLength,
                           Context );

    NtfsUpdateScbFromAttribute( IrpContext, Scb, NULL );

    SetFlag( Scb->ScbState, SCB_STATE_TRUNCATE_ON_CLOSE );

    //
    //  We need to be careful here, if this call is due to MM creating a
    //  section, we don't want to call into the cache manager or we
    //  will deadlock on the create section call.
    //

    if (!WriteClusters && !ARGUMENT_PRESENT( ThisScb )) {

        //
        //  This call will initialize a stream for use below.
        //

        NtfsCreateInternalAttributeStream( IrpContext,
                                           Scb,
                                           TRUE,
                                           &NtfsInternalUseFile[CREATENONRESIDENTWITHVALUE_FILE_NUMBER] );
    }

    //
    // Now, write in the data.
    //

    Scb->Header.FileSize.QuadPart = ValueLength;
    if ((ARGUMENT_PRESENT( Value )) && (ValueLength != 0)) {

        if (LogNonresidentToo || !WriteClusters) {

            ULONG BytesThisPage;
            PVOID Buffer;
            PBCB Bcb = NULL;

            LONGLONG CurrentFileOffset = 0;
            ULONG RemainingBytes = ValueLength;

            PVOID CurrentValue = Value;

            //
            //  While there is more to write, pin the next page and
            //  write a log record.
            //

            try {

                CC_FILE_SIZES FileSizes;

                //
                //  Call the Cache Manager to truncate and reestablish the FileSize,
                //  so that we are guaranteed to get a valid data length call when
                //  the data goes out.  Otherwise he will likely think he does not
                //  have to call us.
                //

                RtlCopyMemory( &FileSizes, &Scb->Header.AllocationSize, sizeof( CC_FILE_SIZES ));

                FileSizes.FileSize.QuadPart = 0;

                CcSetFileSizes( Scb->FileObject, &FileSizes );
                CcSetFileSizes( Scb->FileObject,
                                (PCC_FILE_SIZES)&Scb->Header.AllocationSize );

                while (RemainingBytes) {

                    BytesThisPage = (RemainingBytes < PAGE_SIZE ? RemainingBytes : PAGE_SIZE);

                    NtfsUnpinBcb( IrpContext, &Bcb );
                    NtfsPinStream( IrpContext,
                                   Scb,
                                   CurrentFileOffset,
                                   BytesThisPage,
                                   &Bcb,
                                   &Buffer );

                    if (ARGUMENT_PRESENT(ThisScb)) {

                        //
                        //  Set the address range modified so that the data will get
                        //  written to its new "home".
                        //

                        MmSetAddressRangeModified( Buffer, BytesThisPage );

                    } else {

                        RtlCopyMemory( Buffer, CurrentValue, BytesThisPage );
                    }

                    if (LogNonresidentToo) {

                        (VOID)
                        NtfsWriteLog( IrpContext,
                                      Scb,
                                      Bcb,
                                      UpdateNonresidentValue,
                                      Buffer,
                                      BytesThisPage,
                                      Noop,
                                      NULL,
                                      0,
                                      CurrentFileOffset,
                                      0,
                                      0,
                                      BytesThisPage );


                    } else {

                        CcSetDirtyPinnedData( Bcb, NULL );
                    }

                    RemainingBytes -= BytesThisPage;
                    CurrentValue = (PVOID) Add2Ptr( CurrentValue, BytesThisPage );

                    (ULONG)CurrentFileOffset += BytesThisPage;
                }

            } finally {

                NtfsUnpinBcb( IrpContext, &Bcb );
            }

        } else {

            //
            //  We are going to write the old data directly to disk.
            //

            NtfsWriteClusters( IrpContext,
                               Vcb,
                               Scb,
                               (LONGLONG)0,
                               Value,
                               ClustersFromBytes( Vcb, ValueLength ));

            //
            //  Be sure to note that the data is actually on disk.
            //

            AdvanceOnly = TRUE;
        }
    }

    //
    //  We need to maintain the file size and valid data length in the
    //  Scb and attribute record.  For this attribute, the valid data
    //  size and the file size are now the value length.
    //

    Scb->Header.ValidDataLength = Scb->Header.FileSize;
    NtfsVerifySizes( &Scb->Header );

    NtfsWriteFileSizes( IrpContext,
                        Scb,
                        &Scb->Header.ValidDataLength.QuadPart,
                        AdvanceOnly,
                        LogIt,
                        FALSE );

    if (!WriteClusters) {

        //
        //  Let the cache manager know the new size for this attribute.
        //

        CcSetFileSizes( Scb->FileObject, (PCC_FILE_SIZES)&Scb->Header.AllocationSize );
    }

    //
    //  If this is the unnamed data attribute, we need to mark this
    //  change in the Fcb.
    //

    if (FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA )) {

        Fcb->Info.AllocatedLength = Scb->TotalAllocated;
        Fcb->Info.FileSize = Scb->Header.FileSize.QuadPart;

        SetFlag( Fcb->InfoFlags,
                 (FCB_INFO_CHANGED_ALLOC_SIZE | FCB_INFO_CHANGED_FILE_SIZE) );
    }

    DebugTrace( -1, Dbg, ("NtfsCreateNonresidentWithValue -> VOID\n") );
}


VOID
NtfsMapAttributeValue (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    OUT PVOID *Buffer,
    OUT PULONG Length,
    OUT PBCB *Bcb,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    )

/*++

Routine Description:

    This routine may be called to map an entire attribute value.  It works
    whether the attribute is resident or nonresident.  It is intended for
    general handling of system-defined attributes which are small to medium
    in size, i.e. 0-64KB.  This routine will not work for attributes larger
    than the Cache Manager's virtual address granularity (currently 256KB),
    and this will be detected by the Cache Manager who will raise an error.

    Note that this routine only maps the data for read-only access.  To modify
    the data, the caller must call NtfsChangeAttributeValue AFTER UNPINNING
    THE BCB (IF THE SIZE IS CHANGING) returned from this routine.

Arguments:

    Fcb - Current file.

    Buffer - returns a pointer to the mapped attribute value.

    Length - returns the attribute value length in bytes.

    Bcb - Returns a Bcb which must be unpinned when done with the data, and
          before modifying the attribute value with a size change.

    Context - Attribute Context positioned at the attribute to change.

Return Value:

    None.

--*/

{
    PATTRIBUTE_RECORD_HEADER Attribute;
    PSCB Scb;
    UNICODE_STRING AttributeName;
    BOOLEAN ReturnedExistingScb;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsMapAttributeValue\n") );
    DebugTrace( 0, Dbg, ("Fcb = %08lx\n", Fcb) );
    DebugTrace( 0, Dbg, ("Context = %08lx\n", Context) );

    Attribute = NtfsFoundAttribute(Context);

    //
    //  For the resident case, everything we need is in the
    //  attribute enumeration context.
    //

    if (NtfsIsAttributeResident(Attribute)) {

        *Buffer = NtfsAttributeValue( Attribute );
        *Length = Attribute->Form.Resident.ValueLength;
        *Bcb = NtfsFoundBcb(Context);
        NtfsFoundBcb(Context) = NULL;

        DebugTrace( 0, Dbg, ("Buffer < %08lx\n", *Buffer) );
        DebugTrace( 0, Dbg, ("Length < %08lx\n", *Length) );
        DebugTrace( 0, Dbg, ("Bcb < %08lx\n", *Bcb) );
        DebugTrace( -1, Dbg, ("NtfsMapAttributeValue -> VOID\n") );

        return;
    }

    //
    //  Otherwise, this is a nonresident attribute.  First create
    //  the Scb and stream.  Note we do not use any try-finally
    //  around this because we currently expect cleanup to get
    //  rid of these streams.
    //

    NtfsInitializeStringFromAttribute( &AttributeName, Attribute );

    Scb = NtfsCreateScb( IrpContext,
                         Fcb,
                         Attribute->TypeCode,
                         &AttributeName,
                         FALSE,
                         &ReturnedExistingScb );

    if (!FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED )) {
        NtfsUpdateScbFromAttribute( IrpContext, Scb, Attribute );
    }

    NtfsCreateInternalAttributeStream( IrpContext,
                                       Scb,
                                       FALSE,
                                       &NtfsInternalUseFile[MAPATTRIBUTEVALUE_FILE_NUMBER] );

    //
    //  Now just try to map the whole thing.  Count on the Cache Manager
    //  to complain if the attribute is too big to map all at once.
    //

    NtfsMapStream( IrpContext,
                   Scb,
                   (LONGLONG)0,
                   ((ULONG)Attribute->Form.Nonresident.FileSize),
                   Bcb,
                   Buffer );

    *Length = ((ULONG)Attribute->Form.Nonresident.FileSize);

    DebugTrace( 0, Dbg, ("Buffer < %08lx\n", *Buffer) );
    DebugTrace( 0, Dbg, ("Length < %08lx\n", *Length) );
    DebugTrace( 0, Dbg, ("Bcb < %08lx\n", *Bcb) );
    DebugTrace( -1, Dbg, ("NtfsMapAttributeValue -> VOID\n") );
}


VOID
NtfsChangeAttributeValue (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG ValueOffset,
    IN PVOID Value OPTIONAL,
    IN ULONG ValueLength,
    IN BOOLEAN SetNewLength,
    IN BOOLEAN LogNonresidentToo,
    IN BOOLEAN CreateSectionUnderway,
    IN BOOLEAN PreserveContext,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    )

/*++

Routine Description:

    This routine changes the value of the specified attribute, optionally
    changing its size.

    The caller specifies the attribute to be changed via the attribute context,
    and must be prepared to clean up this context no matter how this routine
    returns.

    There are three byte ranges of interest for this routine.  The first is
    existing bytes to be perserved at the beginning of the attribute.  It
    begins a byte 0 and extends to the point where the attribute is being
    changed or the current end of the attribute, which ever is smaller.
    The second is the range of bytes which needs to be zeroed if the modified
    bytes begin past the current end of the file.  This range will be
    of length 0 if the modified range begins within the current range
    of bytes for the attribute.  The final range is the modified byte range.
    This is zeroed if no value pointer was specified.

    Ranges of zero bytes at the end of the attribute can be represented in
    non-resident attributes by a valid data length set to the beginning
    of what would be zero bytes.

    The following pictures illustrates these ranges when we writing data
    beyond the current end of the file.

        Current attribute
        ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ

        Value
                                            VVVVVVVVVVVVVVVVVVVVVVVV

        Byte range to save
        ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ

        Byte range to zero
                                        0000

        Resulting attribute
        ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ0000VVVVVVVVVVVVVVVVVVVVVVVV

    The following picture illustrates these ranges when we writing data
    which begins at or before the current end of the file.

        Current attribute
        ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ

        Value
                                    VVVVVVVVVVVVVVVVVVVVVVVV

        Byte range to save
        ZZZZZZZZZZZZZZZZZZZZZZZZZZZZ

        Byte range to zero (None)


        Resulting attribute
        ZZZZZZZZZZZZZZZZZZZZZZZZZZZZVVVVVVVVVVVVVVVVVVVVVVVV

    The following picture illustrates these ranges when we writing data
    totally within the current range of the file without setting
    a new size.

        Current attribute
        ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ

        Value
            VVVVVVVVVVVVVVVVVVVVVVVV

        Byte range to save (Save the whole range and then write over it)
        ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ

        Byte range to zero (None)

        Resulting attribute
        ZZZZVVVVVVVVVVVVVVVVVVVVVVVVZZZZ

    The following picture illustrates these ranges when we writing data
    totally within the current range of the file while setting
    a new size.

        Current attribute
        ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ

        Value
            VVVVVVVVVVVVVVVVVVVVVVVV

        Byte range to save (Only save the beginning)
        ZZZZ

        Byte range to zero (None)

        Resulting attribute
        ZZZZVVVVVVVVVVVVVVVVVVVVVVVV

    Any of the 'V' values above will be replaced by zeroes if the 'Value'
    parameter is not passed in.

Arguments:

    Fcb - Current file.

    ValueOffset - Byte offset within the attribute at which the value change is
                  to begin.

    Value - Pointer to the buffer containing the new value, if present.  Otherwise
        zeroes are desired.

    ValueLength - Length of the value in the above buffer.

    SetNewLength - FALSE if the size of the value is not changing, or TRUE if
                   the value length should be changed to ValueOffset + ValueLength.

    LogNonresidentToo - supplies TRUE if the update should be logged even if
                        the attribute is nonresident (such as for the
                        SECURITY_DESCRIPTOR).

    CreateSectionUnderway - if supplied as TRUE, then to the best of the caller's
                            knowledge, an MM Create Section could be underway,
                            which means that we cannot initiate caching on
                            this attribute, as that could cause deadlock.  The
                            value buffer in this case must be quad-aligned and
                            a multiple of cluster size in size.

    PreserveContext - Indicates if we need to lookup the attribute in case it
                      might move.

    Context - Attribute Context positioned at the attribute to change.

Return Value:

    None.

--*/

{
    PATTRIBUTE_RECORD_HEADER Attribute;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    ATTRIBUTE_TYPE_CODE AttributeTypeCode;
    UNICODE_STRING AttributeName;
    ULONG NewSize;
    PVCB Vcb;
    BOOLEAN ReturnedExistingScb;
    BOOLEAN GoToNonResident = FALSE;
    PVOID Buffer;
    ULONG CurrentLength;
    LONG SizeChange, QuadSizeChange;
    ULONG RecordOffset;
    ULONG ZeroLength = 0;
    ULONG UnchangedSize = 0;
    PBCB Bcb = NULL;
    PSCB Scb = NULL;
    PVOID SaveBuffer = NULL;
    PVOID CopyInputBuffer = NULL;

    WCHAR NameBuffer[8];
    UNICODE_STRING SavedName;
    ATTRIBUTE_TYPE_CODE TypeCode;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );

    Vcb = Fcb->Vcb;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsChangeAttributeValue\n") );
    DebugTrace( 0, Dbg, ("Fcb = %08lx\n", Fcb) );
    DebugTrace( 0, Dbg, ("ValueOffset = %08lx\n", ValueOffset) );
    DebugTrace( 0, Dbg, ("Value = %08lx\n", Value) );
    DebugTrace( 0, Dbg, ("ValueLength = %08lx\n", ValueLength) );
    DebugTrace( 0, Dbg, ("SetNewLength = %02lx\n", SetNewLength) );
    DebugTrace( 0, Dbg, ("LogNonresidentToo = %02lx\n", LogNonresidentToo) );
    DebugTrace( 0, Dbg, ("Context = %08lx\n", Context) );

    //
    //  Get the file record and attribute pointers.
    //

    FileRecord = NtfsContainingFileRecord(Context);
    Attribute = NtfsFoundAttribute(Context);
    TypeCode = Attribute->TypeCode;

    //
    //  Set up a pointer to the name buffer in case we have to use it.
    //

    SavedName.Buffer = NameBuffer;

    //
    //  Get the current attribute value length.
    //

    if (NtfsIsAttributeResident(Attribute)) {

        CurrentLength = Attribute->Form.Resident.ValueLength;

    } else {

        if (((PLARGE_INTEGER)&Attribute->Form.Nonresident.AllocatedLength)->HighPart != 0) {

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
        }

        CurrentLength = ((ULONG)Attribute->Form.Nonresident.AllocatedLength);
    }

    ASSERT( SetNewLength || ((ValueOffset + ValueLength) <= CurrentLength) );

    //
    // Calculate how much the file record is changing by, and its new
    // size.  We also compute the size of the range of zero bytes.
    //

    if (SetNewLength) {

        NewSize = ValueOffset + ValueLength;
        SizeChange = NewSize - CurrentLength;
        QuadSizeChange = QuadAlign( NewSize ) - QuadAlign( CurrentLength );

        //
        //  If the new size is large enough, the size change may appear to be negative.
        //  In this case we go directly to the non-resident path.
        //

        if (NewSize > Vcb->BytesPerFileRecordSegment) {

            GoToNonResident = TRUE;
        }

    } else {

        NewSize = CurrentLength;
        SizeChange = 0;
        QuadSizeChange = 0;
    }

    //
    //  If we are zeroing a range in the file and it extends to the
    //  end of the file or beyond then make this a single zeroed run.
    //

    if (!ARGUMENT_PRESENT( Value )
        && ValueOffset >= CurrentLength) {

        ZeroLength = ValueOffset + ValueLength - CurrentLength;

        ValueOffset = ValueOffset + ValueLength;
        ValueLength = 0;

    //
    //  If we are writing data starting beyond the end of the
    //  file then we have a range of bytes to zero.
    //

    } else if (ValueOffset > CurrentLength) {

        ZeroLength = ValueOffset - CurrentLength;
    }

    //
    //  At this point we know the following ranges:
    //
    //      Range to save:  Not needed unless going resident to non-resident
    //
    //      Zero range: From Zero offset for length ZeroLength
    //
    //      Modified range:  From ValueOffset to NewSize, this length may
    //          be zero.
    //

    //
    //  If the attribute is resident, and it will stay resident, then we will
    //  handle that case first, and return.
    //

    if (NtfsIsAttributeResident( Attribute )

            &&

        !GoToNonResident

            &&

        ((QuadSizeChange <= (LONG)(FileRecord->BytesAvailable - FileRecord->FirstFreeByte))
         || ((Attribute->RecordLength + SizeChange) < Vcb->BigEnoughToMove))) {

        PVOID UndoBuffer;
        ULONG UndoLength;
        ULONG AttributeOffset;

        //
        //  If the attribute record is growing, then we have to get the new space
        //  now.
        //

        if (QuadSizeChange > 0) {

            BOOLEAN FirstPass = TRUE;

            ASSERT( !FlagOn(Attribute->Form.Resident.ResidentFlags, RESIDENT_FORM_INDEXED) );

            //
            //  Save a description of the attribute in case we have to look it up
            //  again.
            //

            SavedName.Length =
            SavedName.MaximumLength = (USHORT)(Attribute->NameLength * sizeof(WCHAR));

            if (SavedName.Length > sizeof(NameBuffer)) {

                SavedName.Buffer = NtfsAllocatePool( NonPagedPool, SavedName.Length );
            }

            //
            //  Copy the name into the buffer.
            //

            if (SavedName.Length != 0) {

                RtlCopyMemory( SavedName.Buffer,
                               Add2Ptr( Attribute, Attribute->NameOffset ),
                               SavedName.Length );
            }

            //
            //  Make sure we deallocate the name buffer.
            //

            try {

                do {

                    //
                    //  If not the first pass, we have to lookup the attribute
                    //  again.
                    //

                    if (!FirstPass) {

                        NtfsCleanupAttributeContext( IrpContext, Context );
                        NtfsInitializeAttributeContext( Context );

                        if (!NtfsLookupAttributeByName( IrpContext,
                                                        Fcb,
                                                        &Fcb->FileReference,
                                                        TypeCode,
                                                        &SavedName,
                                                        NULL,
                                                        FALSE,
                                                        Context )) {

                            ASSERT(FALSE);
                            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
                        }

                        //
                        //  Now we have to reload our attribute pointer
                        //

                        Attribute = NtfsFoundAttribute( Context );
                    }

                    FirstPass = FALSE;

                //
                //  If FALSE is returned, then the space was not allocated and
                //  we have too loop back and try again.  Second time must work.
                //

                } while (!NtfsChangeAttributeSize( IrpContext,
                                                   Fcb,
                                                   QuadAlign( Attribute->Form.Resident.ValueOffset + NewSize),
                                                   Context ));
            } finally {

                if (SavedName.Buffer != NameBuffer) {

                    NtfsFreePool(SavedName.Buffer);
                }
            }

            //
            //  Now we have to reload our attribute pointer
            //

            FileRecord = NtfsContainingFileRecord(Context);
            Attribute = NtfsFoundAttribute(Context);

        } else {

            //
            //  Make sure the buffer is pinned if we are not changing size, because
            //  we begin to modify it below.
            //

            NtfsPinMappedAttribute( IrpContext, Vcb, Context );

            //
            //  We can eliminate some/all of the value if it has not changed.
            //

            if (ARGUMENT_PRESENT(Value)) {

                UnchangedSize = (ULONG)RtlCompareMemory( Add2Ptr(Attribute,
                                                          Attribute->Form.Resident.ValueOffset +
                                                            ValueOffset),
                                                  Value,
                                                  ValueLength );

                Value = Add2Ptr(Value, UnchangedSize);
                ValueOffset += UnchangedSize;
                ValueLength -= UnchangedSize;
            }
        }

        RecordOffset = PtrOffset(FileRecord, Attribute);

        //
        //  If there is a zero range of bytes, deal with it now.
        //  If we are zeroing data then we must be growing the
        //  file.
        //

        if (ZeroLength != 0) {

            //
            //  We always start zeroing at the zeroing offset.
            //

            AttributeOffset = Attribute->Form.Resident.ValueOffset +
                              CurrentLength;

            //
            //  If we are starting at the end of the file the undo
            //  buffer is NULL and the length is zero.
            //

            FileRecord->Lsn =
            NtfsWriteLog( IrpContext,
                          Vcb->MftScb,
                          NtfsFoundBcb(Context),
                          UpdateResidentValue,
                          NULL,
                          ZeroLength,
                          UpdateResidentValue,
                          NULL,
                          0,
                          NtfsMftOffset( Context ),
                          RecordOffset,
                          AttributeOffset,
                          Vcb->BytesPerFileRecordSegment );

            //
            //  Now zero this data by calling the same routine as restart.
            //

            NtfsRestartChangeValue( IrpContext,
                                    FileRecord,
                                    RecordOffset,
                                    AttributeOffset,
                                    NULL,
                                    ZeroLength,
                                    TRUE );

#ifdef SYSCACHE_DEBUG
            {
                PSCB TempScb;

                TempScb = CONTAINING_RECORD( Fcb->ScbQueue.Flink, SCB, FcbLinks );
                while (&TempScb->FcbLinks != &Fcb->ScbQueue) {

                    if (ScbIsBeingLogged( TempScb )) {
                        FsRtlLogSyscacheEvent( TempScb, SCE_ZERO_MF, 0, AttributeOffset, ZeroLength, 0 );
                    }
                    TempScb = CONTAINING_RECORD( TempScb->FcbLinks.Flink, SCB, FcbLinks );
                }
            }
#endif
        }

        //
        //  Now log the new data for the file.  This range will always begin
        //  within the current range of bytes for the file.  Because of this
        //  there is an undo action.
        //
        //  Even if there is not a nonzero ValueLength, we still have to
        //  execute this code if the attribute is being truncated.
        //  The only exception is if we logged some zero data and have
        //  nothing left to log.
        //

        if ((ValueLength != 0)
            || (ZeroLength == 0
                && SizeChange != 0)) {

            //
            //  The attribute offset is always at the value offset.
            //

            AttributeOffset = Attribute->Form.Resident.ValueOffset + ValueOffset;

            //
            //  There are 3 possible cases for the undo action to
            //  log.
            //

            //
            //  If we are growing the file starting beyond the end of
            //  the file then undo buffer is NULL and the length is
            //  zero.  This will still allow us to shrink the file
            //  on abort.
            //

            if (ValueOffset >= CurrentLength) {

                UndoBuffer = NULL;
                UndoLength = 0;

            //
            //  For the other cases the undo buffer begins at the
            //  point of the change.
            //

            } else {

                UndoBuffer = Add2Ptr( Attribute,
                                      Attribute->Form.Resident.ValueOffset + ValueOffset );

                //
                //  If the size isn't changing then the undo length is the same as
                //  the redo length.
                //

                if (SizeChange == 0) {

                    UndoLength = ValueLength;

                //
                //  Otherwise the length is the range between the end of the
                //  file and the start of the new data.
                //

                } else {

                    UndoLength = CurrentLength - ValueOffset;
                }
            }

            FileRecord->Lsn =
            NtfsWriteLog( IrpContext,
                          Vcb->MftScb,
                          NtfsFoundBcb(Context),
                          UpdateResidentValue,
                          Value,
                          ValueLength,
                          UpdateResidentValue,
                          UndoBuffer,
                          UndoLength,
                          NtfsMftOffset( Context ),
                          RecordOffset,
                          AttributeOffset,
                          Vcb->BytesPerFileRecordSegment );

            //
            //  Now update this data by calling the same routine as restart.
            //

            NtfsRestartChangeValue( IrpContext,
                                    FileRecord,
                                    RecordOffset,
                                    AttributeOffset,
                                    Value,
                                    ValueLength,
                                    (BOOLEAN)(SizeChange != 0) );
        }

        DebugTrace( -1, Dbg, ("NtfsChangeAttributeValue -> VOID\n") );

        return;
    }

    //
    //  Nonresident case.  Create the Scb and attributestream.
    //

    NtfsInitializeStringFromAttribute( &AttributeName, Attribute );
    AttributeTypeCode = Attribute->TypeCode;

    Scb = NtfsCreateScb( IrpContext,
                         Fcb,
                         AttributeTypeCode,
                         &AttributeName,
                         FALSE,
                         &ReturnedExistingScb );

    //
    //  Use try-finally for cleanup.
    //

    try {

        BOOLEAN AllocateBufferCopy = FALSE;
        BOOLEAN DeleteAllocation = FALSE;
        BOOLEAN LookupAttribute = FALSE;

        BOOLEAN AdvanceValidData = FALSE;
        LONGLONG NewValidDataLength;
        LONGLONG LargeValueOffset;

        LONGLONG LargeNewSize;

        if (SetNewLength
            && NewSize > Scb->Header.FileSize.LowPart
            && TypeCode == $ATTRIBUTE_LIST) {

            AllocateBufferCopy = TRUE;
        }

        LargeNewSize = NewSize;

        LargeValueOffset = ValueOffset;

        //
        //  Well, the attribute is either changing to nonresident, or it is already
        //  nonresident.  First we will handle the conversion to nonresident case.
        //  We can detect this case by whether or not the attribute is currently
        //  resident.
        //

        if (NtfsIsAttributeResident(Attribute)) {

            NtfsConvertToNonresident( IrpContext,
                                      Fcb,
                                      Attribute,
                                      CreateSectionUnderway,
                                      Context );

            //
            //  Reload the attribute pointer from the context.
            //

            Attribute = NtfsFoundAttribute( Context );

        //
        //  The process of creating a non resident attribute will also create
        //  and initialize a stream file for the Scb.  If the file is already
        //  non-resident we also need a stream file.
        //

        } else {

            NtfsCreateInternalAttributeStream( IrpContext,
                                               Scb,
                                               TRUE,
                                               &NtfsInternalUseFile[CHANGEATTRIBUTEVALUE_FILE_NUMBER] );
        }

        //
        //  If the attribute is already nonresident, make sure the allocation
        //  is the right size.  We grow it before we log the data to be sure
        //  we have the space for the new data.  We shrink it after we log the
        //  new data so we have the old data available for the undo.
        //

        if (((PLARGE_INTEGER)&Attribute->Form.Nonresident.AllocatedLength)->HighPart != 0) {

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
        }

        if (NewSize > ((ULONG)Attribute->Form.Nonresident.AllocatedLength)) {

            LONGLONG NewAllocation;

            if (PreserveContext) {

                //
                //  Save a description of the attribute in case we have to look it up
                //  again.
                //

                SavedName.Length =
                SavedName.MaximumLength = (USHORT)(Attribute->NameLength * sizeof(WCHAR));

                if (SavedName.Length > sizeof(NameBuffer)) {

                    SavedName.Buffer = NtfsAllocatePool( NonPagedPool, SavedName.Length );
                }

                //
                //  Copy the name into the buffer.
                //

                if (SavedName.Length != 0) {

                    RtlCopyMemory( SavedName.Buffer,
                                   Add2Ptr( Attribute, Attribute->NameOffset ),
                                   SavedName.Length );
                }

                LookupAttribute = TRUE;
            }

            //
            //  If this is the attribute list then check if we want to allocate a larger block.
            //  This way the attribute list doesn't get too fragmented.
            //

            NewAllocation = NewSize - ((ULONG)Attribute->Form.Nonresident.AllocatedLength);

            if (Scb->AttributeTypeCode == $ATTRIBUTE_LIST) {

                if ((ULONG) Attribute->Form.Nonresident.AllocatedLength > (4 * PAGE_SIZE)) {

                    NewAllocation += (2 * PAGE_SIZE);

                } else if ((ULONG) Attribute->Form.Nonresident.AllocatedLength > PAGE_SIZE) {

                    NewAllocation += PAGE_SIZE;
                }
            }

            NtfsAddAllocation( IrpContext,
                               Scb->FileObject,
                               Scb,
                               LlClustersFromBytes( Vcb, Attribute->Form.Nonresident.AllocatedLength ),
                               LlClustersFromBytes( Vcb, NewAllocation ),
                               FALSE,
                               NULL );

            //
            //  AddAllocation will adjust the sizes in the Scb and report
            //  the new size to the cache manager.  We need to remember if
            //  we changed the sizes for the unnamed data attribute.
            //

            if (FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA )) {

                Fcb->Info.AllocatedLength = Scb->TotalAllocated;

                SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_ALLOC_SIZE );
            }

        } else if (Vcb->BytesPerCluster <=
                   ((ULONG)Attribute->Form.Nonresident.AllocatedLength) - NewSize) {

            if ((Scb->AttributeTypeCode != $ATTRIBUTE_LIST) ||
                ((NewSize + Vcb->BytesPerCluster) * 2 < ((ULONG) Attribute->Form.Nonresident.AllocatedLength))) {

                DeleteAllocation = TRUE;
            }
        }

        //
        // Now, write in the data.
        //

        if ((ValueLength != 0
             && ARGUMENT_PRESENT( Value ))

            || (LogNonresidentToo
                && SetNewLength)) {

            BOOLEAN BytesToUndo;

            //
            //  We have to compute the amount of data to zero in a different
            //  way than we did for the resident case.  For the non-resident
            //  case we need to zero the data between the old valid data
            //  length and the offset in the file for the new data.
            //

            if (LargeValueOffset >= Scb->Header.ValidDataLength.QuadPart) {

                ZeroLength = (ULONG)(LargeValueOffset - Scb->Header.ValidDataLength.QuadPart);
                BytesToUndo = FALSE;

            } else {

                ZeroLength = 0;
                BytesToUndo = TRUE;
            }

            //
            //  Update existing nonresident attribute.  (We may have just created it
            //  above.)
            //
            //  If we are supposed to log it, then pin, log and do the update here.
            //

            if (LogNonresidentToo) {

                //
                //  At this point the attribute is non-resident and contains
                //  its previous value.  If the new data lies beyond the
                //  previous valid data, we need to zero this data.  This
                //  action won't require any undo.  Otherwise the new data
                //  lies within the existing data.  In this case we need to
                //  log the previous data for possible undo.  Finally, the
                //  tail of the new data may extend beyond the end of the
                //  previous data.  There is no undo requirement for these
                //  bytes.
                //
                //  We do the logging operation in three steps:
                //
                //      1 - We find the all the pages in the attribute that
                //          we need to zero any bytes for.  There is no
                //          undo for these bytes.
                //
                //      2 - Find all pages where we have to perform undo and
                //          log the changes to those pages.  Note only
                //          step 1 or step 2 will be performed as they
                //          are mutually exclusive.
                //
                //      3 - Finally, we may have pages where the new data
                //          extends beyond the current final page in the
                //          attribute.  We log the new data but there is
                //          no undo.
                //
                //      4 - We may have pages where the old data extends
                //          beyond the new data.  We will log this old
                //          data in the event that we grow and shrink
                //          this attribute several times in the same
                //          transaction (changes to the attribute list).
                //          In this case there is redo but no undo.
                //

                LONGLONG CurrentPage;
                ULONG PageOffset;

                ULONG ByteCountToUndo;
                ULONG NewBytesRemaining;

                //
                //  Find the starting page for this operation.  It is the
                //  ValidDataLength rounded down to a page boundary.
                //

                CurrentPage = Scb->Header.ValidDataLength.QuadPart;
                PageOffset = (ULONG)CurrentPage & (PAGE_SIZE - 1);

                (ULONG)CurrentPage = ((ULONG)CurrentPage & ~(PAGE_SIZE - 1));

                //
                //  Loop until there are no more bytes to zero.
                //

                while (ZeroLength != 0) {

                    ULONG ZeroBytesThisPage;

                    ZeroBytesThisPage = PAGE_SIZE - PageOffset;

                    if (ZeroBytesThisPage > ZeroLength) {

                        ZeroBytesThisPage = ZeroLength;
                    }

                    //
                    //  Pin the desired page and compute a buffer into the
                    //  page.  Also compute how many bytes we we zero on
                    //  this page.
                    //

                    NtfsUnpinBcb( IrpContext, &Bcb );

                    NtfsPinStream( IrpContext,
                                   Scb,
                                   CurrentPage,
                                   ZeroBytesThisPage + PageOffset,
                                   &Bcb,
                                   &Buffer );

                    Buffer = Add2Ptr( Buffer, PageOffset );

                    //
                    //  Now write the zeros into the log.
                    //

                    (VOID)
                    NtfsWriteLog( IrpContext,
                                  Scb,
                                  Bcb,
                                  UpdateNonresidentValue,
                                  NULL,
                                  ZeroBytesThisPage,
                                  Noop,
                                  NULL,
                                  0,
                                  CurrentPage,
                                  PageOffset,
                                  0,
                                  ZeroBytesThisPage + PageOffset );

                    //
                    //  Zero any data necessary.
                    //

                    RtlZeroMemory( Buffer, ZeroBytesThisPage );


#ifdef SYSCACHE_DEBUG
                    if (ScbIsBeingLogged( Scb )) {
                        FsRtlLogSyscacheEvent( Scb, SCE_ZERO_MF, 0, CurrentPage, ZeroBytesThisPage, 1 );
                    }
#endif

                    //
                    //  Now move through the file.
                    //

                    ZeroLength -= ZeroBytesThisPage;

                    CurrentPage = CurrentPage + PAGE_SIZE;
                    PageOffset = 0;
                }

                //
                //  Find the starting page for this operation.  It is the
                //  ValueOffset rounded down to a page boundary.
                //

                CurrentPage = LargeValueOffset;
                (ULONG)CurrentPage = ((ULONG)CurrentPage & ~(PAGE_SIZE - 1));

                PageOffset = (ULONG)LargeValueOffset & (PAGE_SIZE - 1);

                //
                //  Now loop until there are no more pages with undo
                //  bytes to log.
                //

                NewBytesRemaining = ValueLength;

                if (BytesToUndo) {

                    ByteCountToUndo = (ULONG)(Scb->Header.ValidDataLength.QuadPart - LargeValueOffset);

                    //
                    //  If we are spanning pages, growing the file and the
                    //  input buffer points into the cache, we could lose
                    //  data as we cross a page boundary.  In that case
                    //  we need to allocate a separate buffer.
                    //

                    if (AllocateBufferCopy
                        && NewBytesRemaining + PageOffset > PAGE_SIZE) {

                        CopyInputBuffer = NtfsAllocatePool(PagedPool, NewBytesRemaining );
                        RtlCopyMemory( CopyInputBuffer,
                                       Value,
                                       NewBytesRemaining );

                        Value = CopyInputBuffer;

                        AllocateBufferCopy = FALSE;
                    }

                    //
                    //  If we aren't setting a new length then limit the
                    //  undo bytes to those being overwritten.
                    //

                    if (!SetNewLength
                        && ByteCountToUndo > NewBytesRemaining) {

                        ByteCountToUndo = NewBytesRemaining;
                    }

                    while (ByteCountToUndo != 0) {

                        ULONG UndoBytesThisPage;
                        ULONG RedoBytesThisPage;
                        ULONG BytesThisPage;

                        NTFS_LOG_OPERATION RedoOperation;
                        PVOID RedoBuffer;

                        //
                        //  Also compute the number of bytes of undo and
                        //  redo on this page.
                        //

                        RedoBytesThisPage = UndoBytesThisPage = PAGE_SIZE - PageOffset;

                        if (RedoBytesThisPage > NewBytesRemaining) {

                            RedoBytesThisPage = NewBytesRemaining;
                        }

                        if (UndoBytesThisPage >= ByteCountToUndo) {

                            UndoBytesThisPage = ByteCountToUndo;
                        }

                        //
                        //  We pin enough bytes on this page to cover both the
                        //  redo and undo bytes.
                        //

                        if (UndoBytesThisPage > RedoBytesThisPage) {

                            BytesThisPage = PageOffset + UndoBytesThisPage;

                        } else {

                            BytesThisPage = PageOffset + RedoBytesThisPage;
                        }

                        //
                        //  If there is no redo (we are shrinking the data),
                        //  then make the redo a noop.
                        //

                        if (RedoBytesThisPage == 0) {

                            RedoOperation = Noop;
                            RedoBuffer = NULL;

                        } else {

                            RedoOperation = UpdateNonresidentValue;
                            RedoBuffer = Value;
                        }

                        //
                        //  Now we pin the page and calculate the beginning
                        //  buffer in the page.
                        //

                        NtfsUnpinBcb( IrpContext, &Bcb );

                        NtfsPinStream( IrpContext,
                                       Scb,
                                       CurrentPage,
                                       BytesThisPage,
                                       &Bcb,
                                       &Buffer );

                        Buffer = Add2Ptr( Buffer, PageOffset );

                        //
                        //  Now log the changes to this page.
                        //

                        (VOID)
                        NtfsWriteLog( IrpContext,
                                      Scb,
                                      Bcb,
                                      RedoOperation,
                                      RedoBuffer,
                                      RedoBytesThisPage,
                                      UpdateNonresidentValue,
                                      Buffer,
                                      UndoBytesThisPage,
                                      CurrentPage,
                                      PageOffset,
                                      0,
                                      BytesThisPage );

                        //
                        //  Move the data into place if we have new data.
                        //

                        if (RedoBytesThisPage != 0) {

                            RtlMoveMemory( Buffer, Value, RedoBytesThisPage );
                        }

                        //
                        //  Now decrement the counts and move through the
                        //  caller's buffer.
                        //

                        ByteCountToUndo -= UndoBytesThisPage;
                        NewBytesRemaining -= RedoBytesThisPage;

                        CurrentPage = PAGE_SIZE + CurrentPage;
                        PageOffset = 0;

                        Value = Add2Ptr( Value, RedoBytesThisPage );
                    }
                }

                //
                //  Now loop until there are no more pages with new data
                //  to log.
                //

                while (NewBytesRemaining != 0) {

                    ULONG RedoBytesThisPage;

                    //
                    //  Also compute the number of bytes of redo on this page.
                    //

                    RedoBytesThisPage = PAGE_SIZE - PageOffset;

                    if (RedoBytesThisPage > NewBytesRemaining) {

                        RedoBytesThisPage = NewBytesRemaining;
                    }

                    //
                    //  Now we pin the page and calculate the beginning
                    //  buffer in the page.
                    //

                    NtfsUnpinBcb( IrpContext, &Bcb );

                    NtfsPinStream( IrpContext,
                                   Scb,
                                   CurrentPage,
                                   RedoBytesThisPage,
                                   &Bcb,
                                   &Buffer );

                    Buffer = Add2Ptr( Buffer, PageOffset );

                    //
                    //  Now log the changes to this page.
                    //

                    (VOID)
                    NtfsWriteLog( IrpContext,
                                  Scb,
                                  Bcb,
                                  UpdateNonresidentValue,
                                  Value,
                                  RedoBytesThisPage,
                                  Noop,
                                  NULL,
                                  0,
                                  CurrentPage,
                                  PageOffset,
                                  0,
                                  PageOffset + RedoBytesThisPage );

                    //
                    //  Move the data into place.
                    //

                    RtlMoveMemory( Buffer, Value, RedoBytesThisPage );

                    //
                    //  Now decrement the counts and move through the
                    //  caller's buffer.
                    //

                    NewBytesRemaining -= RedoBytesThisPage;

                    CurrentPage = PAGE_SIZE + CurrentPage;
                    PageOffset = 0;

                    Value = Add2Ptr( Value, RedoBytesThisPage );
                }

            //
            //  If we have values to write, we write them to the cache now.
            //

            } else {

                //
                //  If we have data to zero, we do no now.
                //

#ifdef SYSCACHE_DEBUG
                if (ScbIsBeingLogged( Scb )) {
                    FsRtlLogSyscacheEvent( Scb, SCE_ZERO_MF, 0, Scb->Header.ValidDataLength.QuadPart, ZeroLength, 2 );
                }
#endif

                if (ZeroLength != 0) {

                    if (!NtfsZeroData( IrpContext,
                                       Scb,
                                       Scb->FileObject,
                                       Scb->Header.ValidDataLength.QuadPart,
                                       (LONGLONG)ZeroLength,
                                       NULL )) {

                        NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );

                    }
                }

                if (!CcCopyWrite( Scb->FileObject,
                                  (PLARGE_INTEGER)&LargeValueOffset,
                                  ValueLength,
                                  (BOOLEAN) FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT ),
                                  Value )) {

                    NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
                }
            }

            //
            //  We need to remember the new valid data length in the
            //  Scb if it is greater than the existing.
            //

            NewValidDataLength = LargeValueOffset + ValueLength;

            if (NewValidDataLength > Scb->Header.ValidDataLength.QuadPart) {

#ifdef SYSCACHE_DEBUG
                if (ScbIsBeingLogged( Scb )) {
                    FsRtlLogSyscacheEvent( Scb, SCE_ZERO_MF, SCE_FLAG_SET_VDL, Scb->Header.ValidDataLength.QuadPart, NewValidDataLength, 0 );
                }
#endif
                Scb->Header.ValidDataLength.QuadPart = NewValidDataLength;

                //
                //  If we took the log non-resident path, then we
                //  want to advance this on the disk as well.
                //

                if (LogNonresidentToo) {

                    AdvanceValidData = TRUE;
                }

                SetFlag( Scb->ScbState, SCB_STATE_CHECK_ATTRIBUTE_SIZE );
            }

            //
            //  We need to maintain the file size in the Scb.  If we grow the
            //  file, we extend the cache file size.  We always set the
            //  valid data length in the Scb to the new file size.  The
            //  'AdvanceValidData' boolean and the current size on the
            //  disk will determine if it changes on disk.
            //

            if (SetNewLength) {

                Scb->Header.ValidDataLength.QuadPart = NewValidDataLength;
            }
        }

        if (SetNewLength) {

            Scb->Header.FileSize.QuadPart = LargeNewSize;

            if (LogNonresidentToo) {
                Scb->Header.ValidDataLength.QuadPart = LargeNewSize;
            }
        }

        //
        //  Note VDD is nonzero only for compressed files
        //

        if (Scb->Header.ValidDataLength.QuadPart < Scb->ValidDataToDisk) {

            Scb->ValidDataToDisk = Scb->Header.ValidDataLength.QuadPart;
        }

        //
        //  If there is allocation to delete, we do so now.
        //

        if (DeleteAllocation) {

            //
            //  If this is an attribute list then leave at least one full cluster at the
            //  end.  We don't want to trim off a cluster and then try to regrow the attribute
            //  list within the same transaction.
            //

            if (Scb->AttributeTypeCode == $ATTRIBUTE_LIST) {

                LargeNewSize += Vcb->BytesPerCluster;

                ASSERT( LargeNewSize <= Scb->Header.AllocationSize.QuadPart );
            }

            NtfsDeleteAllocation( IrpContext,
                                  Scb->FileObject,
                                  Scb,
                                  LlClustersFromBytes( Vcb, LargeNewSize ),
                                  MAXLONGLONG,
                                  TRUE,
                                  FALSE );

            //
            //  DeleteAllocation will adjust the sizes in the Scb and report
            //  the new size to the cache manager.  We need to remember if
            //  we changed the sizes for the unnamed data attribute.
            //

            if (FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA )) {

                Fcb->Info.AllocatedLength = Scb->TotalAllocated;
                Fcb->Info.FileSize = Scb->Header.FileSize.QuadPart;

                SetFlag( Fcb->InfoFlags,
                         (FCB_INFO_CHANGED_ALLOC_SIZE | FCB_INFO_CHANGED_FILE_SIZE) );
            }

            if (AdvanceValidData) {

                NtfsWriteFileSizes( IrpContext,
                                    Scb,
                                    &Scb->Header.ValidDataLength.QuadPart,
                                    TRUE,
                                    TRUE,
                                    TRUE );
            }

        } else if (SetNewLength) {

            PFILE_OBJECT CacheFileObject = NULL;

            //
            //  If there is no file object, we will create a stream file
            //  now,
            //

            if (Scb->FileObject != NULL) {

                CacheFileObject = Scb->FileObject;

            } else if (!CreateSectionUnderway) {

                NtfsCreateInternalAttributeStream( IrpContext,
                                                   Scb,
                                                   FALSE,
                                                   &NtfsInternalUseFile[CHANGEATTRIBUTEVALUE2_FILE_NUMBER] );

                CacheFileObject = Scb->FileObject;

            } else {

                PIO_STACK_LOCATION IrpSp;

                IrpSp = IoGetCurrentIrpStackLocation( IrpContext->OriginatingIrp );

                if (IrpSp->FileObject->SectionObjectPointer == &Scb->NonpagedScb->SegmentObject) {

                    CacheFileObject = IrpSp->FileObject;
                }
            }

            ASSERT( CacheFileObject != NULL );

            NtfsSetBothCacheSizes( CacheFileObject,
                                   (PCC_FILE_SIZES)&Scb->Header.AllocationSize,
                                   Scb );

            //
            //  If this is the unnamed data attribute, we need to mark this
            //  change in the Fcb.
            //

            if (FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA )) {

                Fcb->Info.FileSize = Scb->Header.FileSize.QuadPart;
                SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_FILE_SIZE );
            }

            //
            //  Now update the sizes on the disk.
            //  The new sizes will already be in the Scb.
            //

            NtfsWriteFileSizes( IrpContext,
                                Scb,
                                &Scb->Header.ValidDataLength.QuadPart,
                                AdvanceValidData,
                                TRUE,
                                TRUE );

        } else if (AdvanceValidData) {

            NtfsWriteFileSizes( IrpContext,
                                Scb,
                                &Scb->Header.ValidDataLength.QuadPart,
                                TRUE,
                                TRUE,
                                TRUE );
        }

        //
        //  Look up the attribute again in case it moved.
        //

        if (LookupAttribute) {

            NtfsCleanupAttributeContext( IrpContext, Context );
            NtfsInitializeAttributeContext( Context );

            if (!NtfsLookupAttributeByName( IrpContext,
                                            Fcb,
                                            &Fcb->FileReference,
                                            TypeCode,
                                            &SavedName,
                                            NULL,
                                            FALSE,
                                            Context )) {

                ASSERT( FALSE );
                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
            }
        }

    } finally {

        DebugUnwind( NtfsChangeAttributeValue );

        if (CopyInputBuffer != NULL) {

            NtfsFreePool( CopyInputBuffer );
        }

        if (SaveBuffer != NULL) {

            NtfsFreePool( SaveBuffer );
        }

        NtfsUnpinBcb( IrpContext, &Bcb );

        DebugTrace( -1, Dbg, ("NtfsChangeAttributeValue -> VOID\n") );
    }
}


VOID
NtfsConvertToNonresident (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PATTRIBUTE_RECORD_HEADER Attribute,
    IN BOOLEAN CreateSectionUnderway,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context OPTIONAL
    )

/*++

Routine Description:

    This routine converts a resident attribute to nonresident.  It does so
    by allocating a buffer and copying the data and attribute name away,
    deleting the attribute, allocating a new attribute of the right size,
    and then copying the data back out again.

Arguments:

    Fcb - Requested file.

    Attribute - Supplies a pointer to the attribute to convert.

    CreateSectionUnderway - if supplied as TRUE, then to the best of the caller's
                            knowledge, an MM Create Section could be underway,
                            which means that we cannot initiate caching on
                            this attribute, as that could cause deadlock.  The
                            value buffer in this case must be quad-aligned and
                            a multiple of cluster size in size.

    Context - An attribute context to look up another attribute in the same
              file record.  If supplied, we insure that the context is valid
              for converted attribute.

Return Value:

    None

--*/

{
    PVOID Buffer;
    PVOID AllocatedBuffer = NULL;
    ULONG AllocatedLength;
    ULONG AttributeNameOffset;

    ATTRIBUTE_ENUMERATION_CONTEXT LocalContext;
    BOOLEAN CleanupLocalContext = FALSE;
    BOOLEAN ReturnedExistingScb;

    ATTRIBUTE_TYPE_CODE AttributeTypeCode = Attribute->TypeCode;
    USHORT AttributeFlags = Attribute->Flags;
    PVOID AttributeValue = NULL;
    ULONG ValueLength;

    UNICODE_STRING AttributeName;
    WCHAR AttributeNameBuffer[16];

    BOOLEAN WriteClusters = CreateSectionUnderway;

    PBCB ResidentBcb = NULL;
    PSCB Scb = NULL;

    PAGED_CODE();

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Build a temporary copy of the name out of the attribute.
        //

        AttributeName.MaximumLength =
        AttributeName.Length = Attribute->NameLength * sizeof( WCHAR );
        AttributeName.Buffer = Add2Ptr( Attribute, Attribute->NameOffset );

        //
        //  If we don't have an attribute context for this attribute then look it
        //  up now.
        //

        if (!ARGUMENT_PRESENT( Context )) {

            Context = &LocalContext;
            NtfsInitializeAttributeContext( Context );
            CleanupLocalContext = TRUE;

            //
            //  Lookup the first occurence of this attribute.
            //

            if (!NtfsLookupAttributeByName( IrpContext,
                                            Fcb,
                                            &Fcb->FileReference,
                                            AttributeTypeCode,
                                            &AttributeName,
                                            NULL,
                                            FALSE,
                                            Context )) {

                DebugTrace( 0, 0, ("Could not find attribute being converted\n") );

                ASSERTMSG("Could not find attribute being converted, About to raise corrupt ", FALSE);
                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
            }
        }

        //
        //  We need to figure out how much pool to allocate.  If there is a mapped
        //  view of this section or a section is being created we will allocate a buffer
        //  and copy the data into the buffer.  Otherwise we will pin the data in
        //  the cache, mark it dirty and use that buffer to perform the conversion.
        //

        AllocatedLength = AttributeName.Length;

        Scb = NtfsCreateScb( IrpContext,
                             Fcb,
                             AttributeTypeCode,
                             &AttributeName,
                             FALSE,
                             &ReturnedExistingScb );

        //
        //  Clear the file size loaded flag for resident attributes non-user data because these
        //  values are not kept current in the scb and must be loaded off the attribute
        //  This situation only occurs when the user has opened the attribute explicitly
        //

        if (ReturnedExistingScb &&
            FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT ) &&
            !NtfsIsTypeCodeUserData( Scb->AttributeTypeCode )) {

            ClearFlag( Scb->ScbState, SCB_STATE_FILE_SIZE_LOADED | SCB_STATE_HEADER_INITIALIZED );
        }

        //
        //  Make sure the Scb is up-to-date.
        //

        NtfsUpdateScbFromAttribute( IrpContext,
                                    Scb,
                                    Attribute );

        //
        //  Set the flag in the Scb to indicate that we are converting this to
        //  non resident.
        //

        SetFlag( Scb->ScbState, SCB_STATE_CONVERT_UNDERWAY );
        if (Scb->ScbSnapshot) {
            ASSERT( (NULL == Scb->ScbSnapshot->OwnerIrpContext) || (IrpContext == Scb->ScbSnapshot->OwnerIrpContext) );
            Scb->ScbSnapshot->OwnerIrpContext = IrpContext;
        }

        //
        //  Now check if the file is mapped by a user.
        //

        if (NtfsIsTypeCodeUserData( Scb->AttributeTypeCode ) &&
            (CreateSectionUnderway ||
             !MmCanFileBeTruncated( &Scb->NonpagedScb->SegmentObject, NULL ))) {

            AttributeNameOffset = ClusterAlign( Fcb->Vcb,
                                                Attribute->Form.Resident.ValueLength );
            AllocatedLength += AttributeNameOffset;
            ValueLength = Attribute->Form.Resident.ValueLength;
            WriteClusters = TRUE;

            if ((ValueLength != 0) &&
                (IrpContext->MajorFunction == IRP_MJ_WRITE) &&
                !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX ) &&
                (IrpContext->OriginatingIrp != NULL) &&
                !FlagOn( IrpContext->OriginatingIrp->Flags, IRP_PAGING_IO ) &&
                (Scb->Header.PagingIoResource != NULL)) {

                SetFlag( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX );

                //
                //  If we fault the data into the section then we better have
                //  the paging io resource exclusive.  Otherwise we could hit
                //  a collided page fault.
                //

                NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
            }

            Scb = NULL;

        } else {

            volatile UCHAR VolatileUchar;

            AttributeNameOffset = 0;
            NtfsCreateInternalAttributeStream( IrpContext,
                                               Scb,
                                               TRUE,
                                               &NtfsInternalUseFile[CONVERTTONONRESIDENT_FILE_NUMBER] );

            //
            //  Make sure the cache is up-to-date.
            //

            NtfsSetBothCacheSizes( Scb->FileObject,
                                   (PCC_FILE_SIZES)&Scb->Header.AllocationSize,
                                   Scb );

            ValueLength = Scb->Header.ValidDataLength.LowPart;

            if (ValueLength != 0) {

                ULONG WaitState;

                //
                //  There is a deadlock possibility if there is already a Bcb for
                //  this page.  If the lazy writer has acquire the Bcb to flush the
                //  page then he can be blocked behind the current request which is
                //  trying to perform the convert.  This thread will complete the
                //  deadlock by trying to acquire the Bcb to pin the page.
                //
                //  If there is a possible deadlock then we will pin in two stages:
                //  First map the page (while waiting) to bring the page into memory,
                //  then pin it without waiting.  If we are unable to acquire the
                //  Bcb then mark the Irp Context to acquire the paging io resource
                //  exclusively on the retry.
                //
                //  We only do this for ConvertToNonResident which come from a user
                //  write.  Otherwise the correct synchronization should already be done.
                //
                //  Either the top level already has the paging io resource or there
                //  is no paging io resource.
                //
                //  We might hit this point in the Hotfix path if we need to convert
                //  the bad cluster attribute list to non-resident.  It that case
                //  we won't have an originating Irp.
                //

                if ((IrpContext->MajorFunction == IRP_MJ_WRITE) &&
                    !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX ) &&
                    (IrpContext->OriginatingIrp != NULL) &&
                    !FlagOn( IrpContext->OriginatingIrp->Flags, IRP_PAGING_IO ) &&
                    (Scb->Header.PagingIoResource != NULL)) {

                    LONGLONG FileOffset = 0;

                    //
                    //  Now capture the wait state and set the IrpContext flag
                    //  to handle a failure when mapping or pinning.
                    //

                    WaitState = FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT );
                    ClearFlag( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

                    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_ACQUIRE_EX );

                    //
                    //  If we fault the data into the section then we better have
                    //  the paging io resource exclusive.  Otherwise we could hit
                    //  a collided page fault.
                    //

                    NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );

                } else {

                    NtfsPinStream( IrpContext,
                                   Scb,
                                   (LONGLONG)0,
                                   ValueLength,
                                   &ResidentBcb,
                                   &AttributeValue );
                }

                //
                //  Close the window where this page can leave memory before we
                //  have the new attribute initialized.  The result will be that
                //  we may fault in this page again and read uninitialized data
                //  out of the newly allocated sectors.
                //
                //  Make the page dirty so that the cache manager will write it out
                //  and update the valid data length.
                //

                VolatileUchar = *((PUCHAR) AttributeValue);

                *((PUCHAR) AttributeValue) = VolatileUchar;
            }
        }

        if (AllocatedLength > 8) {

            Buffer = AllocatedBuffer = NtfsAllocatePool(PagedPool, AllocatedLength );

        } else {

            Buffer = AttributeNameBuffer;
        }

        //
        //  Now update the attribute name in the buffer.
        //

        AttributeName.Buffer = Add2Ptr( Buffer, AttributeNameOffset );

        RtlCopyMemory( AttributeName.Buffer,
                       Add2Ptr( Attribute, Attribute->NameOffset ),
                       AttributeName.Length );

        //
        //  If we are going to write the clusters directly to the disk then copy
        //  the bytes into the buffer.
        //

        if (WriteClusters) {

            AttributeValue = Buffer;

            RtlCopyMemory( AttributeValue, NtfsAttributeValue( Attribute ), ValueLength );
        }

        //
        //  Now just delete the current record and create it nonresident.
        //  Create nonresident with attribute does the right thing if we
        //  are being called by MM.  Preserve the file record but release
        //  any and all allocation.
        //

        NtfsDeleteAttributeRecord( IrpContext,
                                   Fcb,
                                   DELETE_LOG_OPERATION | DELETE_RELEASE_ALLOCATION,
                                   Context );

        NtfsCreateNonresidentWithValue( IrpContext,
                                        Fcb,
                                        AttributeTypeCode,
                                        &AttributeName,
                                        AttributeValue,
                                        ValueLength,
                                        AttributeFlags,
                                        WriteClusters,
                                        Scb,
                                        TRUE,
                                        Context );

        //
        //  If we were passed an attribute context, then we want to
        //  reload the context with the new location of the file.
        //

        if (!CleanupLocalContext) {

            NtfsCleanupAttributeContext( IrpContext, Context );
            NtfsInitializeAttributeContext( Context );

            if (!NtfsLookupAttributeByName( IrpContext,
                                            Fcb,
                                            &Fcb->FileReference,
                                            AttributeTypeCode,
                                            &AttributeName,
                                            NULL,
                                            FALSE,
                                            Context )) {

                DebugTrace( 0, 0, ("Could not find attribute being converted\n") );

                ASSERTMSG("Could not find attribute being converted, About to raise corrupt ", FALSE);
                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
            }
        }

    } finally {

        DebugUnwind( NtfsConvertToNonresident );

        if (AllocatedBuffer != NULL) {

            NtfsFreePool( AllocatedBuffer );
        }

        if (CleanupLocalContext) {

            NtfsCleanupAttributeContext( IrpContext, Context );
        }

        NtfsUnpinBcb( IrpContext, &ResidentBcb );
    }
}


VOID
NtfsDeleteAttributeRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG Flags,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    )

/*++

Routine Description:

    This routine deletes an existing attribute removing it from the file record.

    The caller specifies the attribute to be deleted via the attribute context,
    and must be prepared to clean up this context no matter how this routine
    returns.

    Note that currently this routine does not deallocate any clusters allocated
    to a nonresident attribute; it expects the caller to already have done so.

Arguments:

    Fcb - Current file.

    Flags - Bitmask that modifies behaviour:
        DELETE_LOG_OPERATION        Most callers should specify this, to have the
            change logged.  However, we can omit it if we are deleting an entire
            file record, and will be logging that.
        DELETE_RELEASE_FILE_RECORD  Indicates that we should release the file record.
            Most callers will not specify this.  (Convert to non-resident will omit).
        DELETE_RELEASE_ALLOCATION   Indicates that we should free up any allocation.
            Most callers will specify this.

    Context - Attribute Context positioned at the attribute to delete.

Return Value:

    None.

--*/

{
    PATTRIBUTE_RECORD_HEADER Attribute;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    PVCB Vcb;
    ATTRIBUTE_TYPE_CODE AttributeTypeCode;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );

    Vcb = Fcb->Vcb;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsDeleteAttribute\n") );
    DebugTrace( 0, Dbg, ("Fcb = %08lx\n", Fcb) );
    DebugTrace( 0, Dbg, ("Context =%08lx\n", Context) );

    //
    //  Get the pointers we need.
    //

    Attribute = NtfsFoundAttribute(Context);
    AttributeTypeCode = Attribute->TypeCode;
    FileRecord = NtfsContainingFileRecord(Context);
    ASSERT( IsQuadAligned( Attribute->RecordLength ) );

    if (!NtfsIsAttributeResident( Attribute ) &&
        FlagOn( Flags, DELETE_RELEASE_ALLOCATION)) {

        ASSERT( (NULL == IrpContext->CleanupStructure) || (Fcb == IrpContext->CleanupStructure) );
        NtfsDeleteAllocationFromRecord( IrpContext, Fcb, Context, TRUE, FALSE );

        //
        //  Reload our local pointers.
        //

        Attribute = NtfsFoundAttribute(Context);
        FileRecord = NtfsContainingFileRecord(Context);
    }

    //
    //  If this is a resident stream then release the quota.  Quota for
    //  non-resident streams is handled by NtfsDeleteAllocaiton.
    //

    if (NtfsIsTypeCodeSubjectToQuota( Attribute->TypeCode) &&
        (NtfsIsAttributeResident( Attribute ) ||
         (Attribute->Form.Nonresident.LowestVcn == 0))) {

        LONGLONG Delta = -NtfsResidentStreamQuota( Vcb );

        NtfsConditionallyUpdateQuota( IrpContext,
                                      Fcb,
                                      &Delta,
                                      FlagOn( Flags, DELETE_LOG_OPERATION ),
                                      FALSE );
    }

    //
    //  Be sure the attribute is pinned.
    //

    NtfsPinMappedAttribute( IrpContext, Vcb, Context );

    //
    //  Log the change.
    //

    if (FlagOn( Flags, DELETE_LOG_OPERATION )) {

        FileRecord->Lsn =
        NtfsWriteLog( IrpContext,
                      Vcb->MftScb,
                      NtfsFoundBcb(Context),
                      DeleteAttribute,
                      NULL,
                      0,
                      CreateAttribute,
                      Attribute,
                      Attribute->RecordLength,
                      NtfsMftOffset( Context ),
                      (ULONG)((PCHAR)Attribute - (PCHAR)FileRecord),
                      0,
                      Vcb->BytesPerFileRecordSegment );
    }

    NtfsRestartRemoveAttribute( IrpContext,
                                FileRecord,
                                (ULONG)((PCHAR)Attribute - (PCHAR)FileRecord) );

    Context->FoundAttribute.AttributeDeleted = TRUE;

    if (FlagOn( Flags, DELETE_LOG_OPERATION ) &&
        (Context->AttributeList.Bcb != NULL)) {

        //
        //  Now delete the attribute list entry, if there is one.  Do it
        //  after freeing space above, because we assume the list has not moved.
        //  Note we only do this if DELETE_LOG_OPERATION was specified, assuming
        //  that otherwise the entire file is going away anyway, so there is no
        //  need to fix up the list.
        //

        NtfsDeleteFromAttributeList( IrpContext, Fcb, Context );
    }

    //
    //  Delete the file record if it happened to go empty.  (Note that
    //  delete file does not call this routine and deletes its own file
    //  records.)
    //

    if (FlagOn( Flags, DELETE_RELEASE_FILE_RECORD ) &&
        FileRecord->FirstFreeByte == ((ULONG)FileRecord->FirstAttributeOffset +
                                      QuadAlign( sizeof( ATTRIBUTE_TYPE_CODE )))) {

        ASSERT( NtfsFullSegmentNumber( &Fcb->FileReference ) ==
                NtfsUnsafeSegmentNumber( &Fcb->FileReference ) );

        NtfsDeallocateMftRecord( IrpContext,
                                 Vcb,
                                 (ULONG) LlFileRecordsFromBytes( Vcb, Context->FoundAttribute.MftFileOffset ));
    }

    DebugTrace( -1, Dbg, ("NtfsDeleteAttributeRecord -> VOID\n") );

    return;
}


VOID
NtfsDeleteAllocationFromRecord (
    PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PATTRIBUTE_ENUMERATION_CONTEXT Context,
    IN BOOLEAN BreakupAllowed,
    IN BOOLEAN LogIt
    )

/*++

Routine Description:

    This routine may be called to delete the allocation of an attribute
    from its attribute record.  It does nothing to the attribute record
    itself - the caller must deal with that.

Arguments:

    Fcb - Current file.

    Context - Attribute enumeration context positioned to the attribute
              whose allocation is to be deleted.

    BreakupAllowed - TRUE if the caller can tolerate breaking up the deletion of
                     allocation into multiple transactions, if there are a large
                     number of runs.

    LogIt - Indicates if we need to log the change to the mapping pairs.

Return Value:

    None

--*/

{
    PATTRIBUTE_RECORD_HEADER Attribute;
    PSCB Scb;
    UNICODE_STRING AttributeName;
    PFILE_OBJECT TempFileObject;
    BOOLEAN ScbExisted;
    BOOLEAN ScbAcquired = FALSE;
    BOOLEAN ReinitializeContext = FALSE;
    BOOLEAN FcbHadPaging;

    PAGED_CODE();

    //
    //  Point to the current attribute.
    //

    Attribute = NtfsFoundAttribute( Context );

    //
    //  If the attribute is nonresident, then delete its allocation.
    //

    ASSERT(Attribute->FormCode == NONRESIDENT_FORM);


    NtfsInitializeStringFromAttribute( &AttributeName, Attribute );

    if (Fcb->PagingIoResource != NULL) {
        FcbHadPaging = TRUE;
    } else {
        FcbHadPaging = FALSE;
    }

    //
    //  Decode the file object
    //

    Scb = NtfsCreateScb( IrpContext,
                         Fcb,
                         Attribute->TypeCode,
                         &AttributeName,
                         FALSE,
                         &ScbExisted );

    try {

        //
        //  If the scb is new and that caused a paging resource to be created
        //  E.g. a named data stream in a directory raise because our state is now
        //  incosistent. We need to acquire that paging resource first
        //

        if (!FcbHadPaging && (Fcb->PagingIoResource != NULL)) {
            NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
        }

        //
        //  Acquire the Scb Exclusive
        //

        NtfsAcquireExclusiveScb( IrpContext, Scb );
        ScbAcquired = TRUE;

        if (!FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED )) {

            NtfsUpdateScbFromAttribute( IrpContext, Scb, Attribute );
        }

        //
        //  If we created the Scb, then this is the only case where
        //  it is legal for us to omit the File Object in the delete
        //  allocation call, because there cannot possibly be a section.
        //
        //  Also if there is not a section and this thread owns everything
        //  for this file then we can neglect the file object.
        //

        if (!ScbExisted ||
            ((Scb->NonpagedScb->SegmentObject.DataSectionObject == NULL) &&
             ((Scb->Header.PagingIoResource == NULL) ||
              (NtfsIsExclusiveScbPagingIo( Scb ))))) {

            TempFileObject = NULL;

        //
        //  Else, if there is already a stream file object, we can just
        //  use it.
        //

        } else if (Scb->FileObject != NULL) {

            TempFileObject = Scb->FileObject;

        //
        //  Else the Scb existed and we did not already have a stream,
        //  so we have to create one and delete it on the way out.
        //

        } else {

            NtfsCreateInternalAttributeStream( IrpContext,
                                               Scb,
                                               TRUE,
                                               &NtfsInternalUseFile[DELETEALLOCATIONFROMRECORD_FILE_NUMBER] );
            TempFileObject = Scb->FileObject;
        }

        //
        //  Before we make this call, we need to check if we will have to
        //  reread the current attribute.  This could be necessary if
        //  we remove any records for this attribute in the delete case.
        //
        //  We only do this under the following conditions.
        //
        //      1 - There is an attribute list present.
        //      2 - There is an entry following the current entry in
        //          the attribute list.
        //      3 - The lowest Vcn for that following entry is non-zero.
        //

        if (Context->AttributeList.Bcb != NULL) {

            PATTRIBUTE_LIST_ENTRY NextEntry;

            NextEntry = (PATTRIBUTE_LIST_ENTRY) NtfsGetNextRecord( Context->AttributeList.Entry );

            if (NextEntry < Context->AttributeList.BeyondFinalEntry) {

                if ( NextEntry->LowestVcn != 0) {

                    ReinitializeContext = TRUE;
                }
            }
        }

        //
        //  Before we delete the allocation and purge the cache - flush any metadata in case
        //  we fail at some point later so we don't lose anything due to the purge. This
        //  is extra i/o when the delete works as expected but the amount of dirty metadata
        //  is limited by both metadata size and the fact its aggressively flushed by cc anyway
        //  the only case when this results in a real flush would be when an attribute like
        //  a reparse point is very quickly created and deleted
        //

        if (TempFileObject && (!NtfsIsTypeCodeUserData( Scb->AttributeTypeCode ) || FlagOn( Scb->Fcb->FcbState, FCB_STATE_SYSTEM_FILE ))) {

            IO_STATUS_BLOCK Iosb;

            CcFlushCache( TempFileObject->SectionObjectPointer, NULL, 0, &Iosb );
            if (Iosb.Status != STATUS_SUCCESS) {
                NtfsRaiseStatus( IrpContext, Iosb.Status, &Scb->Fcb->FileReference, Scb->Fcb );
            }
        }

        NtfsDeleteAllocation( IrpContext,
                              TempFileObject,
                              Scb,
                              *(PVCN)&Li0,
                              MAXLONGLONG,
                              LogIt,
                              BreakupAllowed );

        //
        //  Purge all the data - if any is left in case the cache manager didn't
        //  due to the attribute being accessed with the pin interface
        //

        if (TempFileObject) {
            CcPurgeCacheSection( TempFileObject->SectionObjectPointer, NULL, 0, FALSE );
        }

        //
        //  Reread the attribute if we need to.
        //

        if (ReinitializeContext) {

            NtfsCleanupAttributeContext( IrpContext, Context );
            NtfsInitializeAttributeContext( Context );

            NtfsLookupAttributeForScb( IrpContext, Scb, NULL, Context );
        }

    } finally {

        DebugUnwind( NtfsDeleteAllocationFromRecord );

        if (ScbAcquired) {
            NtfsReleaseScb( IrpContext, Scb );
        }
    }

    return;
}


//
//  This routine is intended for use by allocsup.c.  Other callers should use
//  the routines in allocsup.
//

BOOLEAN
NtfsCreateAttributeWithAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN ATTRIBUTE_TYPE_CODE AttributeTypeCode,
    IN PUNICODE_STRING AttributeName OPTIONAL,
    IN USHORT AttributeFlags,
    IN BOOLEAN LogIt,
    IN BOOLEAN UseContext,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    )

/*++

Routine Description:

    This routine creates the specified attribute with allocation, and returns a
    description of it via the attribute context.  If the amount of space being
    created is small enough, we do all of the work here.  Otherwise we create the
    initial attribute and call NtfsAddAttributeAllocation to add the rest (in order
    to keep the more complex logic in one place).

    On successful return, it is up to the caller to clean up the attribute
    context.

Arguments:

    Scb - Current stream.

    AttributeTypeCode - Type code of the attribute to create.

    AttributeName - Optional name for attribute.

    AttributeFlags - Desired flags for the created attribute.

    WhereIndexed - Optionally supplies the file reference to the file where
        this attribute is indexed.

    LogIt - Most callers should specify TRUE, to have the change logged.  However,
        we can specify FALSE if we are creating a new file record, and
        will be logging the entire new file record.

    UseContext - Indicates if the context is pointing at the location for the attribute.

    Context - A handle to the created attribute.  This context is in a indeterminate
        state on return.

Return Value:

    BOOLEAN - TRUE if we created the attribute with all the allocation.  FALSE
        otherwise.  We should only return FALSE if we are creating a file
        and don't want to log any of the changes to the file record.

--*/

{
    UCHAR AttributeBuffer[SIZEOF_FULL_NONRES_ATTR_HEADER];
    UCHAR MappingPairsBuffer[64];
    ULONG RecordOffset;
    PATTRIBUTE_RECORD_HEADER Attribute;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    ULONG SizeNeeded;
    ULONG AttrSizeNeeded;
    PCHAR MappingPairs;
    ULONG MappingPairsLength;
    LCN Lcn;
    VCN LastVcn;
    VCN HighestVcn;
    PVCB Vcb;
    ULONG Passes = 0;
    PFCB Fcb = Scb->Fcb;
    PNTFS_MCB Mcb = &Scb->Mcb;
    ULONG AttributeHeaderSize = SIZEOF_PARTIAL_NONRES_ATTR_HEADER;
    BOOLEAN AllocateAll = TRUE;
    UCHAR CompressionShift = 0;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );

    PAGED_CODE();

    ASSERT( (AttributeFlags == 0) ||
            NtfsIsTypeCodeCompressible( AttributeTypeCode ));

    Vcb = Fcb->Vcb;

    //
    //  Clear out the invalid attribute flags for this volume.
    //

    AttributeFlags &= Vcb->AttributeFlagsMask;

    DebugTrace( +1, Dbg, ("NtfsCreateAttributeWithAllocation\n") );
    DebugTrace( 0, Dbg, ("Mcb = %08lx\n", Mcb) );

    //
    //  Calculate the size needed for this attribute.  (We say we have
    //  Vcb->BigEnoughToMove bytes available as a short cut, since we
    //  will extend later as required anyway.  It should be extremely
    //  unusual that we would really have to extend.)
    //

    MappingPairsLength = QuadAlign( NtfsGetSizeForMappingPairs( Mcb,
                                                                Vcb->BigEnoughToMove,
                                                                (LONGLONG)0,
                                                                NULL,
                                                                &LastVcn ));

    //
    //  Extra work for compressed / sparse files
    //

    if (FlagOn( AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE )) {

        LONGLONG ClustersInCompressionUnit;

        //
        //  Calculate the compression unit size.
        //

        CompressionShift = NTFS_CLUSTERS_PER_COMPRESSION;

        //
        //  If this generates a compression unit past 64K then we need to shrink
        //  the shift value.  This can only happen for sparse files.
        //

        if (!FlagOn( AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

            while (Vcb->SparseFileClusters < (ULONG) (1 << CompressionShift)) {

                CompressionShift -= 1;
            }
        }

        ClustersInCompressionUnit = 1 << CompressionShift;

        //
        //  Round the LastVcn down to a compression unit and recalc the size
        //  needed for the mapping pairs if it was truncated. Note LastVcn = 1 + actual stop pt
        //  if we didn't allocate everything in which case it == maxlonglong
        //

        if (LastVcn != MAXLONGLONG) {

            VCN RoundedLastVcn;

            //
            //  LastVcn is the cluster beyond allocation or the allocation size i.e stop at 0 we have 1 cluster
            //  we want the new allocation to be a compression unit mult so the stop point should be
            //  a compression unit rounded allocation - 1
            //  Note LastVcn will == RoundedLastVcn + 1 on exit from GetSizeForMappingPairs
            //

            RoundedLastVcn = (LastVcn & ~(ClustersInCompressionUnit - 1)) - 1;
            MappingPairsLength = QuadAlign( NtfsGetSizeForMappingPairs( Mcb,
                                                                        Vcb->BigEnoughToMove,
                                                                        (LONGLONG)0,
                                                                        &RoundedLastVcn,
                                                                        &LastVcn ));

            ASSERT( (LastVcn & (ClustersInCompressionUnit - 1)) == 0 );
        }

        //
        //  Remember the size of the attribute header needed for this file.
        //

        AttributeHeaderSize = SIZEOF_FULL_NONRES_ATTR_HEADER;
    }

    SizeNeeded = AttributeHeaderSize +
                 MappingPairsLength +
                 (ARGUMENT_PRESENT(AttributeName) ?
                   QuadAlign( AttributeName->Length ) : 0);

    AttrSizeNeeded = SizeNeeded;

    //
    //  Loop until we find all the space we need.
    //

    do {

        //
        //  Reinitialize context if this is not the first pass.
        //

        if (Passes != 0) {

            NtfsCleanupAttributeContext( IrpContext, Context );
            NtfsInitializeAttributeContext( Context );
        }

        Passes += 1;

        //
        //  Hope we will never have to loop thru this that many times.
        //  If so, we will have to bump up the threshold again or change
        //  the algorithm.
        //

        ASSERT( Passes < 6 );

        //
        //  If the attribute is not indexed, then we will position to the
        //  insertion point by type code and name.
        //

        if (!UseContext &&
            NtfsLookupAttributeByName( IrpContext,
                                       Fcb,
                                       &Fcb->FileReference,
                                       AttributeTypeCode,
                                       AttributeName,
                                       NULL,
                                       FALSE,
                                       Context )) {

            DebugTrace( 0, 0,
                        ("Nonresident attribute already exists, TypeCode = %08lx\n",
                        AttributeTypeCode) );

            ASSERTMSG("Nonresident attribute already exists, About to raise corrupt ", FALSE);
            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
        }

        //
        //  If this attribute is being positioned in the base file record and
        //  there is an attribute list then we need to ask for enough space
        //  for the attribute list entry now.
        //

        FileRecord = NtfsContainingFileRecord( Context );
        Attribute = NtfsFoundAttribute( Context );

        AttrSizeNeeded = SizeNeeded;

        if (Context->AttributeList.Bcb != NULL
            && (ULONG_PTR) FileRecord <= (ULONG_PTR) Context->AttributeList.AttributeList
            && (ULONG_PTR) Attribute >= (ULONG_PTR) Context->AttributeList.AttributeList) {

            //
            //  If the attribute list is non-resident then add a fudge factor of
            //  16 bytes for any new retrieval information.
            //

            if (NtfsIsAttributeResident( Context->AttributeList.AttributeList )) {

                AttrSizeNeeded += QuadAlign( FIELD_OFFSET( ATTRIBUTE_LIST_ENTRY, AttributeName )
                                             + (ARGUMENT_PRESENT( AttributeName ) ?
                                                (ULONG) AttributeName->Length :
                                                sizeof( WCHAR )));

            } else {

                AttrSizeNeeded += 0x10;
            }
        }

        UseContext = FALSE;

    //
    //  Ask for the space we need.
    //

    } while (!NtfsGetSpaceForAttribute( IrpContext, Fcb, AttrSizeNeeded, Context ));

    //
    //  Now get the attribute pointer and fill it in.
    //

    FileRecord = NtfsContainingFileRecord(Context);
    RecordOffset = (ULONG)((PCHAR)NtfsFoundAttribute(Context) - (PCHAR)FileRecord);
    Attribute = (PATTRIBUTE_RECORD_HEADER)AttributeBuffer;

    RtlZeroMemory( Attribute, SIZEOF_FULL_NONRES_ATTR_HEADER );

    Attribute->TypeCode = AttributeTypeCode;
    Attribute->RecordLength = SizeNeeded;
    Attribute->FormCode = NONRESIDENT_FORM;

    //
    //  Assume no attribute name, and calculate where the Mapping Pairs
    //  will go.  (Update below if we are wrong.)
    //

    MappingPairs = Add2Ptr( Attribute, AttributeHeaderSize );

    //
    //  If the attribute has a name, take care of that now.
    //

    if (ARGUMENT_PRESENT(AttributeName)
        && AttributeName->Length != 0) {

        ASSERT( AttributeName->Length <= 0x1FF );

        Attribute->NameLength = (UCHAR)(AttributeName->Length / sizeof(WCHAR));
        Attribute->NameOffset = (USHORT)AttributeHeaderSize;
        MappingPairs += QuadAlign( AttributeName->Length );
    }

    Attribute->Flags = AttributeFlags;
    Attribute->Instance = FileRecord->NextAttributeInstance;

    //
    //  If someone repeatedly adds and removes attributes from a file record we could
    //  hit a case where the sequence number will overflow.  In this case we
    //  want to scan the file record and find an earlier free instance number.
    //

    if (Attribute->Instance > NTFS_CHECK_INSTANCE_ROLLOVER) {

        Attribute->Instance = NtfsScanForFreeInstance( IrpContext, Vcb, FileRecord );
    }

    //
    //  We always need the mapping pairs offset.
    //

    Attribute->Form.Nonresident.MappingPairsOffset = (USHORT)(MappingPairs -
                                                     (PCHAR)Attribute);

    //
    //  Set up the compression unit size.
    //

    Attribute->Form.Nonresident.CompressionUnit = CompressionShift;

    //
    //  Now we need to point to the real place to build the mapping pairs buffer.
    //  If they will not be too big we can use our internal buffer.
    //

    MappingPairs = MappingPairsBuffer;

    if (MappingPairsLength > 64) {

        MappingPairs = NtfsAllocatePool( NonPagedPool, MappingPairsLength );
    }
    *MappingPairs = 0;

    //
    //  Find how much space is allocated by finding the last Mcb entry and
    //  looking it up.  If there are no entries, all of the subsequent
    //  fields are already zeroed.
    //

    Attribute->Form.Nonresident.HighestVcn =
    HighestVcn = -1;
    if (NtfsLookupLastNtfsMcbEntry( Mcb, &HighestVcn, &Lcn )) {

        ASSERT_LCN_RANGE_CHECKING( Vcb, Lcn );

        //
        //  Now build the mapping pairs in place.
        //

        NtfsBuildMappingPairs( Mcb,
                               0,
                               &LastVcn,
                               MappingPairs );
        Attribute->Form.Nonresident.HighestVcn = LastVcn;

        //
        //  Fill in the nonresident-specific fields.  We set the allocation
        //  size to only include the Vcn's we included in the mapping pairs.
        //

        Attribute->Form.Nonresident.AllocatedLength =
            Int64ShllMod32((LastVcn + 1 ), Vcb->ClusterShift);

        //
        //  The totally allocated field in the Scb will contain the current allocated
        //  value for this stream.
        //

        if (FlagOn( AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE )) {

            ASSERT( Scb->Header.NodeTypeCode == NTFS_NTC_SCB_DATA );
            Attribute->Form.Nonresident.TotalAllocated = Scb->TotalAllocated;

            ASSERT( ((LastVcn + 1) & ((1 << CompressionShift) - 1)) == 0 );
        }

    //
    //  We are creating a attribute with zero allocation.  Make the Vcn sizes match
    //  so we don't make the call below to AddAttributeAllocation.
    //

    } else {

        LastVcn = HighestVcn;
    }

    //
    //  Now we will actually create the attribute in place, so that we
    //  save copying everything twice, and can point to the final image
    //  for the log write below.
    //

    NtfsRestartInsertAttribute( IrpContext,
                                FileRecord,
                                RecordOffset,
                                Attribute,
                                AttributeName,
                                MappingPairs,
                                MappingPairsLength );

    //
    //  Finally, log the creation of this attribute
    //

    if (LogIt) {

        //
        //  We have actually created the attribute above, but the write
        //  log below could fail.  The reason we did the create already
        //  was to avoid having to allocate pool and copy everything
        //  twice (header, name and value).  Our normal error recovery
        //  just recovers from the log file.  But if we fail to write
        //  the log, we have to remove this attribute by hand, and
        //  raise the condition again.
        //

        try {

            FileRecord->Lsn =
            NtfsWriteLog( IrpContext,
                          Vcb->MftScb,
                          NtfsFoundBcb(Context),
                          CreateAttribute,
                          Add2Ptr(FileRecord, RecordOffset),
                          Attribute->RecordLength,
                          DeleteAttribute,
                          NULL,
                          0,
                          NtfsMftOffset( Context ),
                          RecordOffset,
                          0,
                          Vcb->BytesPerFileRecordSegment );

        } except(NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {

            NtfsRestartRemoveAttribute( IrpContext, FileRecord, RecordOffset );

            if (MappingPairs != MappingPairsBuffer) {

                NtfsFreePool( MappingPairs );
            }

            NtfsRaiseStatus( IrpContext, GetExceptionCode(), NULL, NULL );
        }
    }

    //
    //  Free the mapping pairs buffer if we allocated one.
    //

    if (MappingPairs != MappingPairsBuffer) {

        NtfsFreePool( MappingPairs );
    }

    //
    //  Now add it to the attribute list if necessary
    //

    if (Context->AttributeList.Bcb != NULL) {

        MFT_SEGMENT_REFERENCE SegmentReference;

        *(PLONGLONG)&SegmentReference = LlFileRecordsFromBytes( Vcb, NtfsMftOffset( Context ));
        SegmentReference.SequenceNumber = FileRecord->SequenceNumber;

        NtfsAddToAttributeList( IrpContext, Fcb, SegmentReference, Context );
    }

    //
    //  Reflect the current allocation in the scb - in case we take the path below
    //

    Scb->Header.AllocationSize.QuadPart = Attribute->Form.Nonresident.AllocatedLength;

    //
    //  We couldn't create all of the mapping for the allocation above.  If
    //  this is a create then we want to truncate the allocation to what we
    //  have already allocated.  Otherwise we want to call
    //  NtfsAddAttributeAllocation to map the remaining allocation.
    //

    if (LastVcn != HighestVcn) {

        if (LogIt ||
            !NtfsIsTypeCodeUserData( AttributeTypeCode ) ||
            IrpContext->MajorFunction != IRP_MJ_CREATE) {

            NtfsAddAttributeAllocation( IrpContext, Scb, Context, NULL, NULL );

        } else {

            //
            //  Truncate away the clusters beyond the last Vcn and set the
            //  flag in the IrpContext indicating there is more allocation
            //  to do.
            //

            NtfsDeallocateClusters( IrpContext,
                                    Fcb->Vcb,
                                    Scb,
                                    LastVcn + 1,
                                    MAXLONGLONG,
                                    NULL );

            NtfsUnloadNtfsMcbRange( &Scb->Mcb,
                                    LastVcn + 1,
                                    MAXLONGLONG,
                                    TRUE,
                                    FALSE );

            if (FlagOn( Scb->ScbState, SCB_STATE_SUBJECT_TO_QUOTA )) {

                LONGLONG Delta = LlBytesFromClusters( Fcb->Vcb, LastVcn - HighestVcn );
                ASSERT( NtfsIsTypeCodeSubjectToQuota( AttributeTypeCode ));
                ASSERT( NtfsIsTypeCodeSubjectToQuota( Scb->AttributeTypeCode ));

                //
                //  Return any quota charged.
                //

                NtfsConditionallyUpdateQuota( IrpContext,
                                              Fcb,
                                              &Delta,
                                              LogIt,
                                              TRUE );
            }

            AllocateAll = FALSE;
        }
    }

    DebugTrace( -1, Dbg, ("NtfsCreateAttributeWithAllocation -> VOID\n") );

    return AllocateAll;
}


//
//  This routine is intended for use by allocsup.c.  Other callers should use
//  the routines in allocsup.
//

VOID
NtfsAddAttributeAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context,
    IN PVCN StartingVcn OPTIONAL,
    IN PVCN ClusterCount OPTIONAL
    )

/*++

Routine Description:

    This routine adds space to an existing nonresident attribute.

    The caller specifies the attribute to be changed via the attribute context,
    and must be prepared to clean up this context no matter how this routine
    returns.

    This routine procedes in the following steps, whose numbers correspond
    to the numbers in comments below:

        1.  Save a description of the current attribute.

        2.  Figure out how big the attribute would have to be to store all
            of the new run information.

        3.  Find the last occurrence of the attribute, to which the new
            allocation is to be appended.

        4.  If the attribute is getting very large and will not fit, then
            move it to its own file record.  In any case grow the attribute
            enough to fit either all of the new allocation, or as much as
            possible.

        5.  Construct the new mapping pairs in place, and log the change.

        6.  If there is still more allocation to describe, then loop to
            create new file records and initialize them to describe additional
            allocation until all of the allocation is described.

Arguments:

    Scb - Current stream.

    Context - Attribute Context positioned at the attribute to change.  Note
              that unlike other routines, this parameter is left in an
              indeterminate state upon return.  The caller should plan on
              doing nothing other than cleaning it up.

    StartingVcn - Supplies Vcn to start on, if not the new highest vcn

    ClusterCount - Supplies count of clusters being added, if not the new highest vcn

Return Value:

    None.

--*/

{
    PATTRIBUTE_RECORD_HEADER Attribute;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    ULONG NewSize, MappingPairsSize;
    LONG SizeChange;
    PCHAR MappingPairs;
    ULONG SizeAvailable;
    PVCB Vcb;
    VCN LowestVcnRemapped;
    LONGLONG LocalClusterCount;
    VCN OldHighestVcn;
    VCN NewHighestVcn;
    VCN LastVcn;
    BOOLEAN IsHotFixScb;
    PBCB NewBcb = NULL;
    LONGLONG MftReferenceNumber;
    PFCB Fcb = Scb->Fcb;
    PNTFS_MCB Mcb = &Scb->Mcb;
    ULONG AttributeHeaderSize;
    BOOLEAN SingleHole;

    ASSERT_IRP_CONTEXT( IrpContext );

    PAGED_CODE();

    Vcb = Fcb->Vcb;

    DebugTrace( +1, Dbg, ("NtfsAddAttributeAllocation\n") );
    DebugTrace( 0, Dbg, ("Fcb = %08lx\n", Fcb) );
    DebugTrace( 0, Dbg, ("Mcb = %08lx\n", Mcb) );
    DebugTrace( 0, Dbg, ("Context = %08lx\n", Context) );

    //
    //  Make a local copy of cluster count, if given.  We will use this local
    //  copy to determine the shrinking range if we move to a previous file
    //  record on a second pass through this loop.
    //

    if (ARGUMENT_PRESENT( ClusterCount )) {

        LocalClusterCount = *ClusterCount;
    }

    while (TRUE) {

        //
        //  Make sure the buffer is pinned.
        //

        NtfsPinMappedAttribute( IrpContext, Vcb, Context );

        //
        //  Make sure we cleanup on the way out
        //

        try {

            //
            //  Step 1.
            //
            //  Save a description of the attribute to help us look it up
            //  again, and to make clones if necessary.
            //

            Attribute = NtfsFoundAttribute(Context);

            //
            //  Do some basic verification of the on disk and in memory filesizes
            //  If they're disjoint - usually due to a failed abort raise corrupt again
            //

            if ((Attribute->FormCode != NONRESIDENT_FORM) ||
                (Attribute->Form.Nonresident.AllocatedLength != Scb->Header.AllocationSize.QuadPart)) {

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
            }


            ASSERT(Attribute->Form.Nonresident.LowestVcn == 0);
            OldHighestVcn = LlClustersFromBytes(Vcb, Attribute->Form.Nonresident.AllocatedLength) - 1;

            //
            //  Get the file record pointer.
            //

            FileRecord = NtfsContainingFileRecord( Context );

            //
            //  Step 2.
            //
            //  Come up with the Vcn we will stop on.  If a StartingVcn and ClusterCount
            //  were specified, then use them to calculate where we will stop.  Otherwise
            //  lookup the largest Vcn in this Mcb, so that we will know when we are done.
            //  We will also write the new allocation size here.
            //

            {
                LCN TempLcn;
                BOOLEAN UpdateFileSizes = FALSE;

                NewHighestVcn = -1;

                //
                //  If a StartingVcn and ClusterCount were specified, then use them.
                //

                if (ARGUMENT_PRESENT(StartingVcn)) {

                    ASSERT(ARGUMENT_PRESENT(ClusterCount));

                    NewHighestVcn = (*StartingVcn + LocalClusterCount) - 1;

                //
                //  If there are no entries in the file record then we have no new
                //  sizes to report.
                //

                } else if (NtfsLookupLastNtfsMcbEntry(Mcb, &NewHighestVcn, &TempLcn)) {

                    //
                    //  For compressed files, make sure we are not shrinking allocation
                    //  size (OldHighestVcn) due to a compression unit that was all zeros
                    //  and has no allocation.  Note, truncates are done in
                    //  NtfsDeleteAttributeAllocation, so we should not be shrinking the
                    //  file here.
                    //
                    //  If this is an attribute being written compressed, then always
                    //  insure that we keep the allocation size on a compression unit
                    //  boundary, by pushing NewHighestVcn to a boundary - 1.
                    //

                    if (Scb->CompressionUnit != 0) {

                        //
                        //  Don't shrink the file on this path.
                        //

                        if (OldHighestVcn > NewHighestVcn) {
                            NewHighestVcn = OldHighestVcn;
                        }

                        ((PLARGE_INTEGER) &NewHighestVcn)->LowPart |= ClustersFromBytes(Vcb, Scb->CompressionUnit) - 1;

                        //
                        //  Make sure we didn't push a hole into the next compression
                        //  unit.  If so then truncate to the current NewHighestVcn.  We
                        //  know this will be on a compression unit boundary.
                        //

                        if (NewHighestVcn < Scb->Mcb.NtfsMcbArray[Scb->Mcb.NtfsMcbArraySizeInUse - 1].EndingVcn) {

                            NtfsUnloadNtfsMcbRange( &Scb->Mcb,
                                                    NewHighestVcn + 1,
                                                    MAXLONGLONG,
                                                    TRUE,
                                                    FALSE );
                        }
                    }
                }

                //
                //  Copy the new allocation size into our size structure and
                //  update the attribute.
                //

                ASSERT( Scb->Header.AllocationSize.QuadPart != 0 || NewHighestVcn > OldHighestVcn );

                if (NewHighestVcn > OldHighestVcn) {

                    Scb->Header.AllocationSize.QuadPart = LlBytesFromClusters(Fcb->Vcb, NewHighestVcn + 1);
                    UpdateFileSizes = TRUE;
                }

                //
                //  If we moved the allocation size up or the totally allocated does
                //  not match the value on the disk (only for compressed files,
                //  then update the file sizes.
                //

                if (UpdateFileSizes ||
                    (FlagOn( Attribute->Flags, ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE ) &&
                     (Attribute->Form.Nonresident.TotalAllocated != Scb->TotalAllocated))) {

                    NtfsWriteFileSizes( IrpContext,
                                        Scb,
                                        &Scb->Header.ValidDataLength.QuadPart,
                                        FALSE,
                                        TRUE,
                                        TRUE );
                }
            }

            //
            //  Step 3.
            //
            //  Lookup the attribute record at which the change begins, if it is not
            //  the first file record that we are looking at.
            //

            if ((Attribute->Form.Nonresident.HighestVcn != OldHighestVcn) &&
                (NewHighestVcn > Attribute->Form.Nonresident.HighestVcn)) {

                NtfsCleanupAttributeContext( IrpContext, Context );
                NtfsInitializeAttributeContext( Context );

                NtfsLookupAttributeForScb( IrpContext, Scb, &NewHighestVcn, Context );

                Attribute = NtfsFoundAttribute(Context);
                ASSERT( IsQuadAligned( Attribute->RecordLength ) );
                FileRecord = NtfsContainingFileRecord(Context);
            }

            //
            //  Make sure we nuke this range if we get an error, by expanding
            //  the error recovery range.
            //

            if (Scb->Mcb.PoolType == PagedPool) {

                if (Scb->ScbSnapshot != NULL) {

                    if (Attribute->Form.Nonresident.LowestVcn < Scb->ScbSnapshot->LowestModifiedVcn) {
                        Scb->ScbSnapshot->LowestModifiedVcn = Attribute->Form.Nonresident.LowestVcn;
                    }

                    if (NewHighestVcn > Scb->ScbSnapshot->HighestModifiedVcn) {
                        Scb->ScbSnapshot->HighestModifiedVcn = NewHighestVcn;
                    }

                    if (Attribute->Form.Nonresident.HighestVcn > Scb->ScbSnapshot->HighestModifiedVcn) {
                        Scb->ScbSnapshot->HighestModifiedVcn = Attribute->Form.Nonresident.HighestVcn;
                    }
                }
            }

            //
            //  Remember the last Vcn we will need to create mapping pairs
            //  for.  We use either NewHighestVcn or the highest Vcn in this
            //  file record in the case that we are just inserting a run into
            //  an existing record.
            //

            if (ARGUMENT_PRESENT(StartingVcn)) {

                if (Attribute->Form.Nonresident.HighestVcn > NewHighestVcn) {

                    NewHighestVcn = Attribute->Form.Nonresident.HighestVcn;
                }
            }

            //
            //  Remember the lowest Vcn for this attribute.  We will use this to
            //  decide whether to loop back and look for an earlier file record.
            //

            LowestVcnRemapped = Attribute->Form.Nonresident.LowestVcn;

            //
            //  Remember the header size for this attribute.  This will be the
            //  mapping pairs offset except for attributes with names.
            //

            AttributeHeaderSize = Attribute->Form.Nonresident.MappingPairsOffset;

            if (Attribute->NameOffset != 0) {

                AttributeHeaderSize = Attribute->NameOffset;
            }

            //
            //  If we are making space for a totally allocated field then we
            //  want to add space to the non-resident header for these entries.
            //  To detect this we know that a starting Vcn was specified and
            //  we specified exactly the entire file record.  Also the major
            //  and minor Irp codes are exactly that for a compression operation.
            //

            if ((IrpContext->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL) &&
                (IrpContext->MinorFunction == IRP_MN_USER_FS_REQUEST) &&
                (IoGetCurrentIrpStackLocation( IrpContext->OriginatingIrp)->Parameters.FileSystemControl.FsControlCode == FSCTL_SET_COMPRESSION) &&
                ARGUMENT_PRESENT( StartingVcn ) &&
                (*StartingVcn == 0) &&
                (LocalClusterCount == Attribute->Form.Nonresident.HighestVcn + 1)) {

                AttributeHeaderSize += sizeof( LONGLONG );
            }

            //
            //  Now we must make sure that we never ask for more than can fit in
            //  one file record with our attribute and a $END record.
            //

            SizeAvailable = NtfsMaximumAttributeSize(Vcb->BytesPerFileRecordSegment) -
                            AttributeHeaderSize -
                            QuadAlign( Scb->AttributeName.Length );

            //
            //  For the Mft, we will leave a "fudge factor" of 1/8th a file record
            //  free to make sure that possible hot fixes do not cause us to
            //  break the bootstrap process to finding the mapping for the Mft.
            //  Only take this action if we already have an attribute list for
            //  the Mft, otherwise we may not detect when we need to move to own
            //  record.
            //

            IsHotFixScb = NtfsIsTopLevelHotFixScb( Scb );

            if ((Scb == Vcb->MftScb) &&
                (Context->AttributeList.Bcb != NULL) &&
                !IsHotFixScb &&
                !ARGUMENT_PRESENT( StartingVcn )) {

                SizeAvailable -= Vcb->MftCushion;
            }

            //
            //  Calculate how much space is actually needed, independent of whether it will
            //  fit.
            //

            MappingPairsSize = QuadAlign( NtfsGetSizeForMappingPairs( Mcb,
                                                                      SizeAvailable,
                                                                      Attribute->Form.Nonresident.LowestVcn,
                                                                      &NewHighestVcn,
                                                                      &LastVcn ));

            NewSize = AttributeHeaderSize + QuadAlign( Scb->AttributeName.Length ) + MappingPairsSize;

            SizeChange = (LONG)NewSize - (LONG)Attribute->RecordLength;

            //
            //  Step 4.
            //
            //  Here we decide if we need to move the attribute to its own record,
            //  or whether there is enough room to grow it in place.
            //

            {
                VCN LowestVcn;
                ULONG Pass = 0;

                //
                //  It is important to note that at this point, if we will need an
                //  attribute list attribute, then we will already have it.  This is
                //  because we calculated the size needed for the attribute, and moved
                //  to a our own record if we were not going to fit and we were not
                //  already in a separate record.  Later on we assume that the attribute
                //  list exists, and just add to it as required.  If we didn't move to
                //  own record because this is the Mft and this is not file record 0,
                //  then we already have an attribute list from a previous split.
                //

                do {

                    //
                    //  If not the first pass, we have to lookup the attribute
                    //  again.  (It looks terrible to have to refind an attribute
                    //  record other than the first one, but this should never
                    //  happen, since subsequent attributes should always be in
                    //  their own record.)
                    //

                    if (Pass != 0) {

                        NtfsCleanupAttributeContext( IrpContext, Context );
                        NtfsInitializeAttributeContext( Context );

                        if (!NtfsLookupAttributeByName( IrpContext,
                                                        Fcb,
                                                        &Fcb->FileReference,
                                                        Scb->AttributeTypeCode,
                                                        &Scb->AttributeName,
                                                        &LowestVcn,
                                                        FALSE,
                                                        Context )) {

                            ASSERT( FALSE );
                            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
                        }
                    }

                    Pass += 1;

                    //
                    //  Now we have to reload our pointers
                    //

                    Attribute = NtfsFoundAttribute(Context);
                    FileRecord = NtfsContainingFileRecord(Context);

                    //
                    //  If the attribute doesn't fit, and it is not alone in this file
                    //  record, and the attribute is big enough to move, then we will
                    //  have to take some special action.  Note that if we do not already
                    //  have an attribute list, then we will only do the move if we are
                    //  currently big enough to move, otherwise there may not be enough
                    //  space in MoveAttributeToOwnRecord to create the attribute list,
                    //  and that could cause us to recursively try to create the attribute
                    //  list in Create Attribute With Value.
                    //
                    //  We won't make this move if we are dealing with the Mft and it
                    //  is not file record 0.
                    //
                    //  Also we never move an attribute list to its own record.
                    //

                    if ((Attribute->TypeCode != $ATTRIBUTE_LIST)

                                &&

                        (SizeChange > (LONG)(FileRecord->BytesAvailable - FileRecord->FirstFreeByte))

                                &&

                        ((NtfsFirstAttribute(FileRecord) != Attribute) ||
                        (((PATTRIBUTE_RECORD_HEADER)NtfsGetNextRecord(Attribute))->TypeCode != $END))

                                &&

                        (((NewSize >= Vcb->BigEnoughToMove) && (Context->AttributeList.Bcb != NULL)) ||
                         (Attribute->RecordLength >= Vcb->BigEnoughToMove))

                                &&

                        ((Scb != Vcb->MftScb)

                                ||

                         (*(PLONGLONG)&FileRecord->BaseFileRecordSegment == 0))) {

                        //
                        //  If we are moving the Mft $DATA out of the base file record, the
                        //  attribute context will point to the split portion on return.
                        //  The attribute will only contain previously existing mapping, none
                        //  of the additional clusters which exist in the Mcb.
                        //

                        ASSERT( NewBcb == NULL );   // in case we were looping without unpinning

                        MftReferenceNumber = MoveAttributeToOwnRecord( IrpContext,
                                                                       Fcb,
                                                                       Attribute,
                                                                       Context,
                                                                       &NewBcb,
                                                                       &FileRecord );

                        Attribute = NtfsFirstAttribute(FileRecord);
                        ASSERT( IsQuadAligned( Attribute->RecordLength ) );
                        FileRecord = NtfsContainingFileRecord(Context);

                        //
                        //  If this is the MftScb then we need to recheck the size needed for the
                        //  mapping pairs.  The test for the Mft above guarantees that we
                        //  were dealing with the base file record.
                        //

                        if (Scb == Vcb->MftScb) {

                            LastVcn = LastVcn - 1;

                            //
                            //  Calculate how much space is now needed given our new LastVcn.
                            //

                            MappingPairsSize = QuadAlign( NtfsGetSizeForMappingPairs( Mcb,
                                                                                      SizeAvailable,
                                                                                      Attribute->Form.Nonresident.LowestVcn,
                                                                                      &LastVcn,
                                                                                      &LastVcn ));
                        }
                    }

                    //
                    //  Remember the lowest Vcn so that we can find this record again
                    //  if we have to.  We capture the value now, after the move attribute
                    //  in case this is the Mft doing a split and the entire attribute
                    //  didn't move.  We depend on MoveAttributeToOwnRecord to return
                    //  the new file record for the Mft split.
                    //

                    LowestVcn = Attribute->Form.Nonresident.LowestVcn;

                //
                //  If FALSE is returned, then the space was not allocated and
                //  we have to loop back and try again.  Second time must work.
                //

                } while (!NtfsChangeAttributeSize( IrpContext,
                                                   Fcb,
                                                   NewSize,
                                                   Context ));

                //
                //  Now we have to reload our pointers
                //

                Attribute = NtfsFoundAttribute(Context);
                FileRecord = NtfsContainingFileRecord(Context);
            }

            //
            //  Step 5.
            //
            //  Get pointer to mapping pairs
            //

            {
                ULONG AttributeOffset;
                ULONG MappingPairsOffset;
                CHAR MappingPairsBuffer[64];
                ULONG RecordOffset = PtrOffset(FileRecord, Attribute);

                //
                //  See if it is the case that all mapping pairs will not fit into
                //  the current file record, as we may wish to split in the middle
                //  rather than at the end as we are currently set up to do.
                //  We don't want to take this path if we are splitting the file record
                //  because of our limit on the range size due to maximum clusters per
                //  range.
                //

                if (LastVcn < NewHighestVcn) {

                    if (ARGUMENT_PRESENT( StartingVcn ) &&
                        (Scb != Vcb->MftScb)) {

                        LONGLONG TempCount;

                        //
                        //  There are two cases to deal with.  If the existing file record
                        //  was a large hole then we may need to limit the size if we
                        //  are adding allocation.  In this case we don't want to simply
                        //  split at the run being inserted.  Otherwise we might end up
                        //  creating a large number of file records containing only one
                        //  run (the case where a user fills a large hole by working
                        //  backwards).  Pad the new file record with a portion of the hole.
                        //

                        if (LastVcn - Attribute->Form.Nonresident.LowestVcn > MAX_CLUSTERS_PER_RANGE) {

                            //
                            //  We don't start within our maximum range from the beginning of the
                            //  range.  If we are within our limit from the end of the range
                            //  then extend the new range backwards to reach our limit.
                            //

                            if ((NewHighestVcn - LastVcn + 1) < MAX_CLUSTERS_PER_RANGE) {

                                LastVcn = NewHighestVcn - MAX_CLUSTERS_PER_RANGE;

                                //
                                //  Calculate how much space is now needed given our new LastVcn.
                                //

                                MappingPairsSize = QuadAlign( NtfsGetSizeForMappingPairs( Mcb,
                                                                                          SizeAvailable,
                                                                                          Attribute->Form.Nonresident.LowestVcn,
                                                                                          &LastVcn,
                                                                                          &LastVcn ));
                            }

                        //
                        //
                        //  In this case we have run out of room for mapping pairs via
                        //  an overwrite somewhere in the middle of the file.  To avoid
                        //  shoving a couple mapping pairs off the end over and over, we
                        //  will arbitrarily split this attribute in the middle.  We do
                        //  so by looking up the lowest and highest Vcns that we are working
                        //  with and get their indices, then split in the middle.
                        //

                        } else if (MappingPairsSize > (SizeAvailable >> 1)) {

                            LCN TempLcn;
                            PVOID RangeLow, RangeHigh;
                            ULONG IndexLow, IndexHigh;

                            //
                            //  Get the low and high Mcb indices for these runs.
                            //

                            if (!NtfsLookupNtfsMcbEntry( Mcb,
                                                         Attribute->Form.Nonresident.LowestVcn,
                                                         NULL,
                                                         NULL,
                                                         NULL,
                                                         NULL,
                                                         &RangeLow,
                                                         &IndexLow )) {

                                ASSERT( FALSE );
                                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
                            }

                            //
                            //  Point to the last Vcn we know is actually in the Mcb...
                            //

                            LastVcn = LastVcn - 1;

                            if (!NtfsLookupNtfsMcbEntry( Mcb,
                                                         LastVcn,
                                                         NULL,
                                                         NULL,
                                                         NULL,
                                                         NULL,
                                                         &RangeHigh,
                                                         &IndexHigh )) {

                                ASSERT( FALSE );
                                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
                            }
                            ASSERT(RangeLow == RangeHigh);

                            //
                            //  Calculate the index in the middle.
                            //

                            IndexLow += (IndexHigh - IndexLow) /2;

                            //
                            //  If we are inserting past the ValidDataToDisk (SplitMcb case),
                            //  then the allocation behind us may be relatively static, so
                            //  let's just move with our preallocated space to the new buffer.
                            //

                            if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK ) &&
                                (*StartingVcn >= LlClustersFromBytes(Vcb, Scb->ValidDataToDisk))) {

                                //
                                //  Calculate the index at about 7/8 the way.  Hopefully this will
                                //  move over all of the unallocated piece, while still leaving
                                //  some small amount of expansion space behind for overwrites.
                                //

                                IndexLow += (IndexHigh - IndexLow) /2;
                                IndexLow += (IndexHigh - IndexLow) /2;
                            }

                            //
                            //  Lookup the middle run and use the Last Vcn in that run.
                            //

                            if (!NtfsGetNextNtfsMcbEntry( Mcb,
                                                          &RangeLow,
                                                          IndexLow,
                                                          &LastVcn,
                                                          &TempLcn,
                                                          &TempCount )) {

                                ASSERT( FALSE );
                                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
                            }

                            LastVcn = (LastVcn + TempCount) - 1;

                            //
                            //  Calculate how much space is now needed given our new LastVcn.
                            //

                            MappingPairsSize = QuadAlign( NtfsGetSizeForMappingPairs( Mcb,
                                                                                      SizeAvailable,
                                                                                      Attribute->Form.Nonresident.LowestVcn,
                                                                                      &LastVcn,
                                                                                      &LastVcn ));
                        }

                    }
                }

                //
                //  If we are growing this range, then we need to make sure we fix
                //  its definition.
                //

                if ((LastVcn - 1) != Attribute->Form.Nonresident.HighestVcn) {

                    NtfsDefineNtfsMcbRange( &Scb->Mcb,
                                            Attribute->Form.Nonresident.LowestVcn,
                                            LastVcn - 1,
                                            FALSE );
                }

                //
                //  Point to our local mapping pairs buffer, or allocate one if it is not
                //  big enough.
                //

                MappingPairs = MappingPairsBuffer;

                if (MappingPairsSize > 64) {

                    MappingPairs = NtfsAllocatePool( NonPagedPool, MappingPairsSize + 8 );
                }

                //
                //  Use try-finally to insure we free any pool on the way out.
                //

                try {

                    DebugDoit(

                        VCN TempVcn;

                        TempVcn = LastVcn - 1;

                        ASSERT(MappingPairsSize >=
                                QuadAlign( NtfsGetSizeForMappingPairs( Mcb, SizeAvailable,
                                                                      Attribute->Form.Nonresident.LowestVcn,
                                                                      &TempVcn, &LastVcn )));
                    );

                    //
                    //  Now add the space in the file record.
                    //

                    *MappingPairs = 0;
                    SingleHole = NtfsBuildMappingPairs( Mcb,
                                                        Attribute->Form.Nonresident.LowestVcn,
                                                        &LastVcn,
                                                        MappingPairs );

                    //
                    //  Now find the first different byte.  (Most of the time the
                    //  cost to do this is probably more than paid for by less
                    //  logging.)
                    //

                    AttributeOffset = Attribute->Form.Nonresident.MappingPairsOffset;
                    MappingPairsOffset = (ULONG)
                      RtlCompareMemory( MappingPairs,
                                        Add2Ptr(Attribute, AttributeOffset),
                                        ((Attribute->RecordLength - AttributeOffset) > MappingPairsSize ?
                                         MappingPairsSize :
                                         (Attribute->RecordLength - AttributeOffset)));

                    AttributeOffset += MappingPairsOffset;

                    //
                    //  Log the change.
                    //

                    {
                        LONGLONG LogOffset;

                        if (NewBcb != NULL) {

                            //
                            //  We know the file record number of the new file
                            //  record.  Convert it to a file offset.
                            //

                            LogOffset = LlBytesFromFileRecords( Vcb, MftReferenceNumber );

                        } else {

                            LogOffset = NtfsMftOffset( Context );
                        }

                        FileRecord->Lsn =
                        NtfsWriteLog( IrpContext,
                                      Vcb->MftScb,
                                      NewBcb != NULL ? NewBcb : NtfsFoundBcb(Context),
                                      UpdateMappingPairs,
                                      Add2Ptr(MappingPairs, MappingPairsOffset),
                                      MappingPairsSize - MappingPairsOffset,
                                      UpdateMappingPairs,
                                      Add2Ptr(Attribute, AttributeOffset),
                                      Attribute->RecordLength - AttributeOffset,
                                      LogOffset,
                                      RecordOffset,
                                      AttributeOffset,
                                      Vcb->BytesPerFileRecordSegment );
                    }

                    //
                    //  Now do the mapping pairs update by calling the same
                    //  routine called at restart.
                    //

                    NtfsRestartChangeMapping( IrpContext,
                                              Vcb,
                                              FileRecord,
                                              RecordOffset,
                                              AttributeOffset,
                                              Add2Ptr(MappingPairs, MappingPairsOffset),
                                              MappingPairsSize - MappingPairsOffset );


                } finally {

                    if (MappingPairs != MappingPairsBuffer) {

                        NtfsFreePool(MappingPairs);
                    }
                }
            }

            ASSERT( Attribute->Form.Nonresident.HighestVcn == LastVcn );

            //
            //  Check if have spilled into the reserved area of an Mft file record.
            //

            if ((Scb == Vcb->MftScb) &&
                (Context->AttributeList.Bcb != NULL)) {

                if (FileRecord->BytesAvailable - FileRecord->FirstFreeByte < Vcb->MftReserved
                    && (*(PLONGLONG)&FileRecord->BaseFileRecordSegment != 0)) {

                    NtfsAcquireCheckpoint( IrpContext, Vcb );

                    SetFlag( Vcb->MftDefragState,
                             VCB_MFT_DEFRAG_EXCESS_MAP | VCB_MFT_DEFRAG_ENABLED );

                    NtfsReleaseCheckpoint( IrpContext, Vcb );
                }
            }

            //
            //  It is possible that we have a file record which contains nothing but a
            //  hole, if that is the case see if we can merge this with either the
            //  preceding or following attribute (merge the holes).  We will then
            //  need to rewrite the mapping for the merged record.
            //

            if (SingleHole &&
                ARGUMENT_PRESENT( StartingVcn ) &&
                (Context->AttributeList.Bcb != NULL) &&
                (Scb != Vcb->MftScb) &&
                ((Attribute->Form.Nonresident.LowestVcn != 0) ||
                 (LlClustersFromBytesTruncate( Vcb, Scb->Header.AllocationSize.QuadPart ) !=
                  (Attribute->Form.Nonresident.HighestVcn + 1)))) {

                //
                //  Call our worker routine to perform the actual work if necessary.
                //

                NtfsMergeFileRecords( IrpContext,
                                      Scb,
                                      (BOOLEAN) (LastVcn < NewHighestVcn),
                                      Context );
            }

            //
            //  Step 6.
            //
            //  Now loop to create new file records if we have more allocation to
            //  describe.  We use the highest Vcn of the file record we began with
            //  as our stopping point or the last Vcn we are adding.
            //
            //  NOTE - The record merge code above uses the same test to see if there is more
            //  work to do.  If this test changes then the body of the IF statement above also
            //  needs to be updated.
            //

            while (LastVcn < NewHighestVcn) {

                MFT_SEGMENT_REFERENCE Reference;
                LONGLONG FileRecordNumber;
                PATTRIBUTE_TYPE_CODE NewEnd;

                //
                //  If we get here as the result of a hot fix in the Mft, bail
                //  out.  We could cause a disconnect in the Mft.
                //

                if (IsHotFixScb && (Scb == Vcb->MftScb)) {
                    ExRaiseStatus( STATUS_INTERNAL_ERROR );
                }

                //
                //  If we have a large sparse range then we may find that the limit
                //  in the base file record is range of clusters in the
                //  attribute not the number of runs.  In that case the base
                //  file record may not have been moved to its own file record
                //  and there is no attribute list.  We need to create the attribute
                //  list before cloning the file record.
                //

                if (Context->AttributeList.Bcb == NULL) {

                    NtfsCleanupAttributeContext( IrpContext, Context );
                    NtfsInitializeAttributeContext( Context );

                    //
                    //  We don't use the second file reference in this case so
                    //  it is safe to pass the value in the Fcb.
                    //

                    CreateAttributeList( IrpContext,
                                         Fcb,
                                         FileRecord,
                                         NULL,
                                         Fcb->FileReference,
                                         NULL,
                                         GetSizeForAttributeList( FileRecord ),
                                         Context );

                    //
                    //  Now look up the previous attribute again.
                    //

                    NtfsCleanupAttributeContext( IrpContext, Context );
                    NtfsInitializeAttributeContext( Context );
                    NtfsLookupAttributeForScb( IrpContext, Scb, &LastVcn, Context );
                }

                //
                //  Clone our current file record, and point to our new attribute.
                //

                NtfsUnpinBcb( IrpContext, &NewBcb );

                FileRecord = NtfsCloneFileRecord( IrpContext,
                                                  Fcb,
                                                  (BOOLEAN)(Scb == Vcb->MftScb),
                                                  &NewBcb,
                                                  &Reference );

                Attribute = Add2Ptr( FileRecord, FileRecord->FirstAttributeOffset );

                //
                //  Next LowestVcn is the LastVcn + 1
                //

                LastVcn = LastVcn + 1;
                Attribute->Form.Nonresident.LowestVcn = LastVcn;

                //
                //  Consistency check for MFT defragging. An mft segment can never
                //  describe itself or any piece of the mft before it
                //

                if (Scb == Vcb->MftScb) {
                    VCN NewFileVcn;

                    if (Vcb->FileRecordsPerCluster == 0) {

                        //
                        //  For small cluster systems the file record will take 2 clusters
                        //  use the 2nd cluster in our check for self describing segments
                        //

                        NewFileVcn = (NtfsFullSegmentNumber( &Reference ) << Vcb->MftToClusterShift) + (Vcb->ClustersPerFileRecordSegment - 1);

                    } else {

                        NewFileVcn = NtfsFullSegmentNumber( &Reference ) >> Vcb->MftToClusterShift;
                    }

                    if (LastVcn <= NewFileVcn) {
#ifdef BENL_DBG
                        KdPrint(( "NTFS: selfdescribing mft segment vcn: 0x%I64x, Ref: 0x%I64x\n", LastVcn, NtfsFullSegmentNumber( &Reference )  ));
#endif
                        NtfsRaiseStatus( IrpContext, STATUS_MFT_TOO_FRAGMENTED, NULL, NULL );
                    }
                }

                //
                //  Calculate the size of the attribute record we will need.
                //

                NewSize = SIZEOF_PARTIAL_NONRES_ATTR_HEADER
                          + QuadAlign( Scb->AttributeName.Length )
                          + QuadAlign( NtfsGetSizeForMappingPairs( Mcb,
                                                                   SizeAvailable,
                                                                   LastVcn,
                                                                   &NewHighestVcn,
                                                                   &LastVcn ));

                //
                //  Define the new range.
                //

                NtfsDefineNtfsMcbRange( &Scb->Mcb,
                                        Attribute->Form.Nonresident.LowestVcn,
                                        LastVcn - 1,
                                        FALSE );

                //
                //  Initialize the new attribute from the old one.
                //

                Attribute->TypeCode = Scb->AttributeTypeCode;
                Attribute->RecordLength = NewSize;
                Attribute->FormCode = NONRESIDENT_FORM;

                //
                //  Assume no attribute name, and calculate where the Mapping Pairs
                //  will go.  (Update below if we are wrong.)
                //

                MappingPairs = (PCHAR)Attribute + SIZEOF_PARTIAL_NONRES_ATTR_HEADER;

                //
                //  If the attribute has a name, take care of that now.
                //

                if (Scb->AttributeName.Length != 0) {

                    Attribute->NameLength = (UCHAR)(Scb->AttributeName.Length / sizeof(WCHAR));
                    Attribute->NameOffset = (USHORT)PtrOffset(Attribute, MappingPairs);
                    RtlCopyMemory( MappingPairs,
                                   Scb->AttributeName.Buffer,
                                   Scb->AttributeName.Length );
                    MappingPairs += QuadAlign( Scb->AttributeName.Length );
                }

                Attribute->Flags = Scb->AttributeFlags;
                Attribute->Instance = FileRecord->NextAttributeInstance++;

                //
                //  We always need the mapping pairs offset.
                //

                Attribute->Form.Nonresident.MappingPairsOffset = (USHORT)(MappingPairs -
                                                                 (PCHAR)Attribute);
                NewEnd = Add2Ptr( Attribute, Attribute->RecordLength );
                *NewEnd = $END;
                FileRecord->FirstFreeByte = PtrOffset( FileRecord, NewEnd )
                                            + QuadAlign( sizeof(ATTRIBUTE_TYPE_CODE ));

                //
                //  Now add the space in the file record.
                //

                *MappingPairs = 0;

                NtfsBuildMappingPairs( Mcb,
                                       Attribute->Form.Nonresident.LowestVcn,
                                       &LastVcn,
                                       MappingPairs );

                Attribute->Form.Nonresident.HighestVcn = LastVcn;

                //
                //  Now log these changes and fix up the first file record.
                //

                FileRecordNumber = NtfsFullSegmentNumber(&Reference);

                //
                //  Now log these changes and fix up the first file record.
                //

                FileRecord->Lsn =
                NtfsWriteLog( IrpContext,
                              Vcb->MftScb,
                              NewBcb,
                              InitializeFileRecordSegment,
                              FileRecord,
                              FileRecord->FirstFreeByte,
                              Noop,
                              NULL,
                              0,
                              LlBytesFromFileRecords( Vcb, FileRecordNumber ),
                              0,
                              0,
                              Vcb->BytesPerFileRecordSegment );

                //
                //  Finally, we have to add the entry to the attribute list.
                //  The routine we have to do this gets most of its inputs
                //  out of an attribute context.  Our context at this point
                //  does not have quite the right information, so we have to
                //  update it here before calling AddToAttributeList.
                //

                Context->FoundAttribute.FileRecord = FileRecord;
                Context->FoundAttribute.Attribute = Attribute;
                Context->AttributeList.Entry =
                  NtfsGetNextRecord(Context->AttributeList.Entry);

                NtfsAddToAttributeList( IrpContext, Fcb, Reference, Context );
            }

        } finally {

            NtfsUnpinBcb( IrpContext, &NewBcb );
        }

        if (!ARGUMENT_PRESENT( StartingVcn) ||
            (LowestVcnRemapped <= *StartingVcn)) {

            break;
        }

        //
        //  Move the range to be remapped down.
        //

        LocalClusterCount = LowestVcnRemapped - *StartingVcn;

        NtfsCleanupAttributeContext( IrpContext, Context );
        NtfsInitializeAttributeContext( Context );

        NtfsLookupAttributeForScb( IrpContext, Scb, NULL, Context );
    }

    DebugTrace( -1, Dbg, ("NtfsAddAttributeAllocation -> VOID\n") );
}


//
//  This routine is intended for use by allocsup.c.  Other callers should use
//  the routines in allocsup.
//

VOID
NtfsDeleteAttributeAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN BOOLEAN LogIt,
    IN PVCN StopOnVcn,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context,
    IN BOOLEAN TruncateToVcn
    )

/*++

Routine Description:

    This routine deletes an existing nonresident attribute, removing the
    deleted clusters only from the allocation description in the file
    record.

    The caller specifies the attribute to be changed via the attribute context,
    and must be prepared to clean up this context no matter how this routine
    returns.  The Scb must already have deleted the clusters in question.

Arguments:

    Scb - Current attribute, with the clusters in question already deleted from
          the Mcb.

    LogIt - Most callers should specify TRUE, to have the change logged.  However,
            we can specify FALSE if we are deleting an entire file record, and
            will be logging that.

    StopOnVcn - Vcn to stop on for regerating mapping

    Context - Attribute Context positioned at the attribute to change.

    TruncateToVcn - Truncate file sizes as appropriate to the Vcn

Return Value:

    None.

--*/

{
    ULONG AttributeOffset;
    ULONG MappingPairsOffset, MappingPairsSize;
    CHAR MappingPairsBuffer[64];
    ULONG RecordOffset;
    PATTRIBUTE_RECORD_HEADER Attribute;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    PCHAR MappingPairs;
    VCN LastVcn;
    ULONG NewSize;
    PVCB Vcb;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( Scb );

    PAGED_CODE();

    Vcb = Scb->Vcb;

    //
    //  For now we only support truncation.
    //

    DebugTrace( +1, Dbg, ("NtfsDeleteAttributeAllocation\n") );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("Context = %08lx\n", Context) );

    //
    //  Make sure the buffer is pinned.
    //

    NtfsPinMappedAttribute( IrpContext, Vcb, Context );

    Attribute = NtfsFoundAttribute(Context);
    ASSERT( IsQuadAligned( Attribute->RecordLength ) );

    //
    //  Get the file record pointer.
    //

    FileRecord = NtfsContainingFileRecord(Context);
    RecordOffset = PtrOffset(FileRecord, Attribute);

    //
    //  Calculate how much space is actually needed.
    //

    MappingPairsSize = QuadAlign(NtfsGetSizeForMappingPairs( &Scb->Mcb,
                                                             MAXULONG,
                                                             Attribute->Form.Nonresident.LowestVcn,
                                                             StopOnVcn,
                                                             &LastVcn ));

    //
    //  Don't assume we understand everything about the size of the current header.
    //  Find the offset of the name or the mapping pairs to use as the size
    //  of the header.
    //


    NewSize = Attribute->Form.Nonresident.MappingPairsOffset;

    if (Attribute->NameLength != 0) {

        NewSize = Attribute->NameOffset + QuadAlign( Attribute->NameLength << 1 );
    }

    NewSize += MappingPairsSize;

    //
    //  If the record could somehow grow by deleting allocation, then
    //  NtfsChangeAttributeSize could fail and we would have to copy the
    //  loop from NtfsAddAttributeAllocation.
    //

    ASSERT( NewSize <= Attribute->RecordLength );

    MappingPairs = MappingPairsBuffer;

    if (MappingPairsSize > 64) {

        MappingPairs = NtfsAllocatePool( NonPagedPool, MappingPairsSize + 8 );
    }

    //
    //  Use try-finally to insure we free any pool on the way out.
    //

    try {

        //
        //  Now build up the mapping pairs in the buffer.
        //

        *MappingPairs = 0;
        NtfsBuildMappingPairs( &Scb->Mcb,
                               Attribute->Form.Nonresident.LowestVcn,
                               &LastVcn,
                               MappingPairs );

        //
        //  Now find the first different byte.  (Most of the time the
        //  cost to do this is probably more than paid for by less
        //  logging.)
        //

        AttributeOffset = Attribute->Form.Nonresident.MappingPairsOffset;
        MappingPairsOffset = (ULONG)
          RtlCompareMemory( MappingPairs,
                            Add2Ptr(Attribute, AttributeOffset),
                            MappingPairsSize );

        AttributeOffset += MappingPairsOffset;

        //
        //  Log the change.
        //

        if (LogIt) {

            FileRecord->Lsn =
            NtfsWriteLog( IrpContext,
                          Vcb->MftScb,
                          NtfsFoundBcb(Context),
                          UpdateMappingPairs,
                          Add2Ptr(MappingPairs, MappingPairsOffset),
                          MappingPairsSize - MappingPairsOffset,
                          UpdateMappingPairs,
                          Add2Ptr(Attribute, AttributeOffset),
                          Attribute->RecordLength - AttributeOffset,
                          NtfsMftOffset( Context ),
                          RecordOffset,
                          AttributeOffset,
                          Vcb->BytesPerFileRecordSegment );
        }

        //
        //  Now do the mapping pairs update by calling the same
        //  routine called at restart.
        //

        NtfsRestartChangeMapping( IrpContext,
                                  Vcb,
                                  FileRecord,
                                  RecordOffset,
                                  AttributeOffset,
                                  Add2Ptr(MappingPairs, MappingPairsOffset),
                                  MappingPairsSize - MappingPairsOffset );

        //
        //  If we were asked to stop on a Vcn, then the caller does not wish
        //  us to modify the Scb.  (Currently this is only done one time when
        //  the Mft Data attribute no longer fits in the first file record.)
        //

        if (TruncateToVcn) {

            LONGLONG Size;

            //
            //  We add one cluster to calculate the allocation size.
            //

            LastVcn = LastVcn + 1;
            Size = LlBytesFromClusters( Vcb, LastVcn );
            Scb->Header.AllocationSize.QuadPart = Size;

            if (Scb->Header.ValidDataLength.QuadPart > Size) {
                Scb->Header.ValidDataLength.QuadPart = Size;
            }

            if (Scb->Header.FileSize.QuadPart > Size) {
                Scb->Header.FileSize.QuadPart = Size;
            }

            //
            //  Possibly update ValidDataToDisk which is only nonzero for compressed file
            //

            if (Size < Scb->ValidDataToDisk) {
                Scb->ValidDataToDisk = Size;
            }
        }

    } finally {

        if (MappingPairs != MappingPairsBuffer) {

            NtfsFreePool(MappingPairs);
        }
    }

    DebugTrace( -1, Dbg, ("NtfsDeleteAttributeAllocation -> VOID\n") );
}


BOOLEAN
NtfsIsFileDeleteable (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    OUT PBOOLEAN NonEmptyIndex
    )

/*++

Routine Description:

    This look checks if a file may be deleted by examing all of the index
    attributes to check that they have no children.

    Note that once a file is marked for delete, we must insure
    that none of the conditions checked by this routine are allowed to
    change.  For example, once the file is marked for delete, no links
    may be added, and no files may be created in any indices of this
    file.

Arguments:

    Fcb - Fcb for the file.

    NonEmptyIndex - Address to store TRUE if the file is not deleteable because
        it contains an non-empty indexed attribute.

Return Value:

    FALSE - If it is not ok to delete the specified file.
    TRUE - If it is ok to delete the specified file.

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT Context;
    PATTRIBUTE_RECORD_HEADER Attribute;
    BOOLEAN MoreToGo;

    PAGED_CODE();

    NtfsInitializeAttributeContext( &Context );

    try {

        //
        //  Enumerate all of the attributes to check whether they may be deleted.
        //

        MoreToGo = NtfsLookupAttributeByCode( IrpContext,
                                              Fcb,
                                              &Fcb->FileReference,
                                              $INDEX_ROOT,
                                              &Context );

        while (MoreToGo) {

            //
            //  Point to the current attribute.
            //

            Attribute = NtfsFoundAttribute( &Context );

            //
            //  If the attribute is an index, then it must be empty.
            //

            if (!NtfsIsIndexEmpty( IrpContext, Attribute )) {

                *NonEmptyIndex = TRUE;
                break;
            }

            //
            //  Go to the next attribute.
            //

            MoreToGo = NtfsLookupNextAttributeByCode( IrpContext,
                                                      Fcb,
                                                      $INDEX_ROOT,
                                                      &Context );
        }

    } finally {

        DebugUnwind( NtfsIsFileDeleteable );

        NtfsCleanupAttributeContext( IrpContext, &Context );
    }

    //
    //  The File is deleteable if scanned the entire file record
    //  and found no reasons we could not delete the file.
    //

    return (BOOLEAN)(!MoreToGo);
}


VOID
NtfsDeleteFile (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB ParentScb,
    IN OUT PBOOLEAN AcquiredParentScb,
    IN OUT PNAME_PAIR NamePair OPTIONAL,
    IN OUT PNTFS_TUNNELED_DATA TunneledData OPTIONAL
    )

/*++

Routine Description:

    This routine may be called to see if it is the specified file may
    be deleted from the specified parent (i.e., if the specified parent
    were to be acquired exclusive).  This routine should be called from
    fileinfo, to see whether it is ok to mark an open file for delete.

    NamePair will capture the names of the file being deleted if supplied.

    Note that once a file is marked for delete, none of we must insure
    that none of the conditions checked by this routine are allowed to
    change.  For example, once the file is marked for delete, no links
    may be added, and no files may be created in any indices of this
    file.

    This routine does NOT do the following other delete related actions

    1) remove the fcb from the fcbtable

    2) tunneling

    3) Link count adjustments in the fcb

    4) Directory notification

    NOTE:   The caller must have the Fcb and ParentScb exclusive to call
            this routine,

Arguments:

    Fcb - Fcb for the file.

    ParentScb - Parent Scb via which the file was opened, and which would
        be acquired exclusive to perform the delete.

    AcquiredParentScb - On input indicates whether the ParentScb has
        already been acquired.  Set to TRUE here if this routine
        acquires the parent.

    TunneledData - Optionally provided to capture the name pair and
        object id of a file so they can be tunneled.

Return Value:

    None

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT Context;
    LONGLONG Delta;
    PATTRIBUTE_RECORD_HEADER Attribute;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    PVCB Vcb;
    PLIST_ENTRY Links;

    ULONG RecordNumber;
    NUKEM LocalNuke;
    ULONG Pass;
    ULONG i;
    PNUKEM TempNukem;
    PNUKEM Nukem = &LocalNuke;
    ULONG NukemIndex = 0;
    UCHAR *ObjectId;
    MAP_HANDLE MapHandle;

    ULONG ForceCheckpointCount;
    ULONG IncomingFileAttributes = 0;                             //  invalid value
    ULONG IncomingReparsePointTag = IO_REPARSE_TAG_RESERVED_ZERO;  //  invalid value

    BOOLEAN MoreToGo;
    BOOLEAN NonresidentAttributeList = FALSE;
    BOOLEAN InitializedMapHandle = FALSE;
    BOOLEAN ReparsePointIsPresent = FALSE;
    BOOLEAN ObjectIdIsPresent = FALSE;
    BOOLEAN LogIt;
    BOOLEAN AcquiredReparseIndex = FALSE;
    BOOLEAN AcquiredObjectIdIndex = FALSE;

    PAGED_CODE();

    ASSERT_EXCLUSIVE_FCB( Fcb );

    RtlZeroMemory( &LocalNuke, sizeof(NUKEM) );

    Vcb = Fcb->Vcb;

    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_QUOTA_DISABLE );

    //
    //  Remember the values of the file attribute flags and of the reparse tag
    //  for abnormal termination recovery.
    //

    IncomingFileAttributes = Fcb->Info.FileAttributes;
    IncomingReparsePointTag = Fcb->Info.ReparsePointTag;

    try {

        //
        //  We perform the delete in multiple passes.  We need to break this up carefully so that
        //  if the delete aborts for any reason that the file is left in a consistent state.  The
        //  operations are broken up into the following stages.
        //
        //
        //  First stage - free any allocation possible
        //
        //      - Truncate all user streams to length zero
        //
        //  Middle stage - this is required for files with a large number of attributes.  Otherwise
        //      we can't delete the file records and stay within the log file.  Skip this pass
        //      for smaller files.
        //
        //      - Remove data attributes except unnamed
        //
        //  Final stage - no checkpoints allowed until the end of this stage.
        //
        //      -  Acquire the quota resource if needed.
        //      -  Remove filenames from Index (for any filename attributes still present)
        //      -  Remove entry from ObjectId Index
        //      -  Delete allocation for reparse point and 4.0 style security descriptor
        //      -  Remove entry from Reparse Index
        //      -  Delete AttributeList
        //      -  Log deallocate of file records
        //

        for (Pass = 1; Pass <= 3; Pass += 1) {

            ForceCheckpointCount = 0;
            NtfsInitializeAttributeContext( &Context );

            //
            //  Enumerate all of the attributes to check whether they may be deleted.
            //

            MoreToGo = NtfsLookupAttribute( IrpContext,
                                            Fcb,
                                            &Fcb->FileReference,
                                            &Context );

            //
            //  Log the change to the mapping pairs if there is an attribute list.
            //

            LogIt = FALSE;


            if (Context.AttributeList.Bcb != NULL) {
                LogIt = TRUE;
            }

            //
            //  Remember if we want to log the changes to non-resident attributes.
            //

            while (MoreToGo) {

                //
                //  Point to the current attribute.
                //

                Attribute = NtfsFoundAttribute( &Context );

                //
                //  All indices must be empty.
                //

                ASSERT( (Attribute->TypeCode != $INDEX_ROOT) ||
                        NtfsIsIndexEmpty( IrpContext, Attribute ));

                //
                //  Remember when the $REPARSE_POINT attribute is present.
                //  When it is non-resident we delete it in pass 3.
                //  The entry in the $Reparse index always gets deleted in pass 3.
                //  We have to delete the index entry before deleting the allocation.
                //

                if (Attribute->TypeCode == $REPARSE_POINT) {

                    ReparsePointIsPresent = TRUE;

                    if (Pass == 3) {

                        //
                        //  If this is the $REPARSE_POINT attribute, delete now the appropriate
                        //  entry from the $Reparse index.
                        //

                        NTSTATUS Status = STATUS_SUCCESS;
                        INDEX_KEY IndexKey;
                        INDEX_ROW IndexRow;
                        REPARSE_INDEX_KEY KeyValue;
                        PREPARSE_DATA_BUFFER ReparseBuffer = NULL;
                        PVOID AttributeData = NULL;
                        PBCB Bcb = NULL;
                        ULONG Length = 0;

                        //
                        //  Point to the attribute data.
                        //

                        if (NtfsIsAttributeResident( Attribute )) {

                            //
                            //  Point to the value of the arribute.
                            //

                            AttributeData = NtfsAttributeValue( Attribute );
                            DebugTrace( 0, Dbg, ("Existing attribute is resident.\n") );

                        } else {

                            //
                            //  Map the attribute list if the attribute is non-resident.
                            //  Otherwise the attribute is already mapped and we have a Bcb
                            //  in the attribute context.
                            //

                            DebugTrace( 0, Dbg, ("Existing attribute is non-resident.\n") );

                            if (Attribute->Form.Nonresident.FileSize > MAXIMUM_REPARSE_DATA_BUFFER_SIZE) {
                                NtfsRaiseStatus( IrpContext,STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
                            }

                            NtfsMapAttributeValue( IrpContext,
                                                   Fcb,
                                                   &AttributeData,      //  point to the value
                                                   &Length,
                                                   &Bcb,
                                                   &Context );

                            //
                            //  Unpin the Bcb. The unpin routine checks for NULL.
                            //

                            NtfsUnpinBcb( IrpContext, &Bcb );
                        }

                        //
                        //  Set the pointer to extract the reparse point tag.
                        //

                        ReparseBuffer = (PREPARSE_DATA_BUFFER)AttributeData;

                        //
                        //  Verify that this file is in the reparse point index and delete it.
                        //

                        KeyValue.FileReparseTag = ReparseBuffer->ReparseTag;
                        KeyValue.FileId = *(PLARGE_INTEGER)&Fcb->FileReference;

                        IndexKey.Key = (PVOID)&KeyValue;
                        IndexKey.KeyLength = sizeof(KeyValue);

                        NtOfsInitializeMapHandle( &MapHandle );
                        InitializedMapHandle = TRUE;

                        //
                        //  All of the resources should have been acquired.
                        //

                        ASSERT( *AcquiredParentScb );
                        ASSERT( AcquiredReparseIndex );

                        //
                        //  NtOfsFindRecord will return an error status if the key is not found.
                        //

                        Status = NtOfsFindRecord( IrpContext,
                                                  Vcb->ReparsePointTableScb,
                                                  &IndexKey,
                                                  &IndexRow,
                                                  &MapHandle,
                                                  NULL );

                        if (!NT_SUCCESS(Status)) {

                            //
                            //  Should not happen. The reparse point should be in the index.
                            //

                            DebugTrace( 0, Dbg, ("Record not found in the reparse point index.\n") );
                            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
                        }

                        //
                        //  Remove the entry from the reparse point index.
                        //

                        NtOfsDeleteRecords( IrpContext,
                                            Vcb->ReparsePointTableScb,
                                            1,            // deleting one record from the index
                                            &IndexKey );
                    }
                }

                //
                //  If the attribute is nonresident, then delete its allocation.
                //  We only need to make the NtfsDeleteAllocation from record for
                //  the attribute with lowest Vcn of zero.  This will deallocate
                //  all of the clusters for the file.
                //

                if (Attribute->FormCode == NONRESIDENT_FORM) {

                    if ((Attribute->Form.Nonresident.LowestVcn == 0) &&
                        (Attribute->Form.Nonresident.AllocatedLength != 0)) {

                        if (Pass == 1) {

                            //
                            //  Postpone till pass 3 the deletion of the non-resident attribute in
                            //  the case of a security descriptor and a reparse point.
                            //

                            if ((Attribute->TypeCode != $SECURITY_DESCRIPTOR) &&
                                (Attribute->TypeCode != $REPARSE_POINT)) {

                                NtfsDeleteAllocationFromRecord( IrpContext, Fcb, &Context, TRUE, LogIt );

                                //
                                //  Make sure we count the number of these calls we make.  Force a
                                //  periodic checkpoint on a file with a lot of streams.  We might have
                                //  thousands of streams whose allocations won't force a checkpoint.  we
                                //  could spin indefinitely trying to delete this file.  Lets force
                                //  a checkpoint on a regular basis.
                                //

                                ForceCheckpointCount += 1;

                                if (ForceCheckpointCount > 10) {

                                    NtfsCheckpointCurrentTransaction( IrpContext );
                                    ForceCheckpointCount = 0;
                                }

                                //
                                //  Reload the attribute pointer in the event it
                                //  was remapped.
                                //

                                Attribute = NtfsFoundAttribute( &Context );
                            }

                        } else if (Pass == 3) {

                            //
                            //  Now, in pass 3, delete the security descriptor and the reparse
                            //  point attributes when they are non-residents.
                            //

                            if ((Attribute->TypeCode == $SECURITY_DESCRIPTOR) ||
                                (Attribute->TypeCode == $REPARSE_POINT)) {

                                NtfsDeleteAllocationFromRecord( IrpContext, Fcb, &Context, FALSE, LogIt );

                                //
                                //  Reload the attribute pointer in the event it
                                //  was remapped.
                                //

                                Attribute = NtfsFoundAttribute( &Context );
                            }
                        }
                    }

                } else {

                    //
                    //  If we are at the start of Pass 3 then make sure we have the parent
                    //  acquired and can perform any necessary quota operations.
                    //

                    if ((Attribute->TypeCode == $STANDARD_INFORMATION) &&
                        (Pass == 3)) {

                        if (!*AcquiredParentScb ||
                            NtfsPerformQuotaOperation( Fcb ) ||
                            ReparsePointIsPresent ||
                            ObjectIdIsPresent) {

                            //
                            //  See if we need to acquire any resources, and if so, get
                            //  them in the right order.  We need to do this carefully.
                            //  If the Mft is acquired by this thread then checkpoint
                            //  the transaction and release the Mft before we go any
                            //  further.
                            //

                            if (Vcb->MftScb->Fcb->ExclusiveFcbLinks.Flink != NULL &&
                                NtfsIsExclusiveScb( Vcb->MftScb )) {

                                NtfsCheckpointCurrentTransaction( IrpContext );
                                NtfsReleaseScb( IrpContext, Vcb->MftScb );
                            }

                            ASSERT(!NtfsIsExclusiveScb( Vcb->MftScb ));

                            //
                            //  Now acquire the parent if not already acquired.
                            //

                            if (!*AcquiredParentScb) {

                                NtfsAcquireExclusiveScb( IrpContext, ParentScb );
                                *AcquiredParentScb = TRUE;
                            }

                            if (ObjectIdIsPresent) {

                                NtfsAcquireExclusiveScb( IrpContext, Vcb->ObjectIdTableScb );
                                AcquiredObjectIdIndex = TRUE;
                            }

                            //
                            //  Also acquire reparse & object id if necessary in
                            //  the correct bottom-up Vcb order.
                            //

                            if (ReparsePointIsPresent && !AcquiredReparseIndex) {

                                NtfsAcquireExclusiveScb( IrpContext, Vcb->ReparsePointTableScb );
                                AcquiredReparseIndex = TRUE;
                            }

                            //
                            //  We may acquire the quota index in here.
                            //

                            if (Attribute->Form.Resident.ValueLength == sizeof( STANDARD_INFORMATION )) {

                                //
                                //  Capture all of the user's quota for this file.
                                //

                                //
                                //  The quota resource cannot be acquired before the streams
                                //  are deleted because we can deadlock with the mapped page
                                //  writer when CcSetFileSizes is called.
                                //

                                if (NtfsPerformQuotaOperation( Fcb )) {

                                    ASSERT(!NtfsIsExclusiveScb( Vcb->MftScb ));

                                    Delta = -(LONGLONG) ((PSTANDARD_INFORMATION)
                                                         NtfsAttributeValue( Attribute ))->QuotaCharged;

                                    NtfsUpdateFileQuota( IrpContext,
                                                         Fcb,
                                                         &Delta,
                                                         TRUE,
                                                         FALSE );
                                }
                            }
                        }
                    }
                }

                //
                //  If we are deleting the object id attribute, we need to
                //  update the object id index as well.
                //

                if (Attribute->TypeCode == $OBJECT_ID) {

                    if (Pass == 1) {

                        //
                        //  On pass 1, it is only necessary to remember we have
                        //  an object id so we remember to acquire the oid index
                        //  on pass 3.
                        //

                        ObjectIdIsPresent = TRUE;

                    } else if (Pass == 3) {

                        //
                        //  We'd better be holding the object id index and parent
                        //  directory already, or else there is a potential for
                        //  deadlock.
                        //

                        ASSERT(NtfsIsExclusiveScb( Vcb->ObjectIdTableScb ));
                        ASSERT(*AcquiredParentScb);

                        if (ARGUMENT_PRESENT(TunneledData)) {

                            //
                            //  We need to lookup the object id so we can tunnel it.
                            //

                            TunneledData->HasObjectId = TRUE;

                            ObjectId = (UCHAR *) NtfsAttributeValue( Attribute );

                            RtlCopyMemory( TunneledData->ObjectIdBuffer.ObjectId,
                                           ObjectId,
                                           sizeof(TunneledData->ObjectIdBuffer.ObjectId) );

                            NtfsGetObjectIdExtendedInfo( IrpContext,
                                                         Fcb->Vcb,
                                                         ObjectId,
                                                         TunneledData->ObjectIdBuffer.ExtendedInfo );
                        }

                        //
                        //  We need to delete the object id from the index
                        //  to keep everything consistent.  The FALSE means
                        //  don't delete the attribute itself, that would
                        //  lead to some ugly recursion.
                        //

                        NtfsDeleteObjectIdInternal( IrpContext,
                                                    Fcb,
                                                    Vcb,
                                                    FALSE );
                    }
                }

                //
                //  If we are in the second pass then remove extra named data streams.
                //

                if (Pass == 2) {

                    //
                    //  The record is large enough to consider.  Only do this for named
                    //  data streams
                    //

                    if ((Attribute->TypeCode == $DATA) &&
                        (Attribute->NameLength != 0)) {

                        PSCB DeleteScb;
                        UNICODE_STRING AttributeName;

                        //
                        //  Get the Scb so we can mark it as deleted.
                        //

                        AttributeName.Buffer = Add2Ptr( Attribute, Attribute->NameOffset );
                        AttributeName.Length = Attribute->NameLength * sizeof( WCHAR );

                        DeleteScb = NtfsCreateScb( IrpContext,
                                                   Fcb,
                                                   Attribute->TypeCode,
                                                   &AttributeName,
                                                   TRUE,
                                                   NULL );

                        NtfsDeleteAttributeRecord( IrpContext,
                                                   Fcb,
                                                   (DELETE_LOG_OPERATION |
                                                    DELETE_RELEASE_FILE_RECORD),
                                                   &Context );

                        if (DeleteScb != NULL) {

                            SetFlag( DeleteScb->ScbState, SCB_STATE_ATTRIBUTE_DELETED );
                            DeleteScb->AttributeTypeCode = $UNUSED;
                        }

                        //
                        //  Let's checkpoint periodically after each attribute.  Since
                        //  the attribute list is large and we are removing and
                        //  entry from the beginning of the list the log records
                        //  can be very large.
                        //

                        NtfsCheckpointCurrentTransaction( IrpContext );
                    }

                } else if (Pass == 3) {

                    //
                    //  If the attribute is a file name, then it must be from our
                    //  caller's parent directory, or else we cannot delete.
                    //

                    if (Attribute->TypeCode == $FILE_NAME) {

                        PFILE_NAME FileName;

                        FileName = (PFILE_NAME)NtfsAttributeValue( Attribute );

                        ASSERT( ARGUMENT_PRESENT( ParentScb ));

                        ASSERT(NtfsEqualMftRef(&FileName->ParentDirectory,
                                               &ParentScb->Fcb->FileReference));

                        if (ARGUMENT_PRESENT(NamePair)) {

                            //
                            //  Squirrel away names
                            //

                            NtfsCopyNameToNamePair( NamePair,
                                                    FileName->FileName,
                                                    FileName->FileNameLength,
                                                    FileName->Flags );
                        }

                        NtfsDeleteIndexEntry( IrpContext,
                                              ParentScb,
                                              (PVOID)FileName,
                                              &Fcb->FileReference );
                    }

                    //
                    //  If this file record is not already deleted, then do it now.
                    //  Note, we are counting on its contents not to change.
                    //

                    FileRecord = NtfsContainingFileRecord( &Context );

                    //
                    //  See if this is the same as the last one we remembered, else remember it.
                    //

                    if (Context.AttributeList.Bcb != NULL) {

                        RecordNumber = NtfsUnsafeSegmentNumber( &Context.AttributeList.Entry->SegmentReference );
                    } else {
                        RecordNumber = NtfsUnsafeSegmentNumber( &Fcb->FileReference );
                    }

                    //
                    //  Now loop to see if we already remembered this record.
                    //  This reduces our pool allocation and also prevents us
                    //  from deleting file records twice.
                    //

                    TempNukem = Nukem;
                    while (TempNukem != NULL) {

                        for (i = 0; i < 4; i++) {

                            if (TempNukem->RecordNumbers[i] == RecordNumber) {

                                RecordNumber = 0;
                                break;
                            }
                        }

                        TempNukem = TempNukem->Next;
                    }

                    if (RecordNumber != 0) {

                        //
                        //  Is the list full?  If so allocate and initialize a new one.
                        //

                        if (NukemIndex > 3) {

                            TempNukem = (PNUKEM)ExAllocateFromPagedLookasideList( &NtfsNukemLookasideList );
                            RtlZeroMemory( TempNukem, sizeof(NUKEM) );
                            TempNukem->Next = Nukem;
                            Nukem = TempNukem;
                            NukemIndex = 0;
                        }

                        //
                        //  Remember to delete this guy.  (Note we can possibly list someone
                        //  more than once, but NtfsDeleteFileRecord handles that.)
                        //

                        Nukem->RecordNumbers[NukemIndex] = RecordNumber;
                        NukemIndex += 1;
                    }

                //
                //  When we have the first attribute, check for the existance of
                //  a non-resident attribute list.
                //

                } else if ((Attribute->TypeCode == $STANDARD_INFORMATION) &&
                           (Context.AttributeList.Bcb != NULL) &&
                           (!NtfsIsAttributeResident( Context.AttributeList.AttributeList ))) {

                    NonresidentAttributeList = TRUE;
                }


                //
                //  Go to the next attribute.
                //

                MoreToGo = NtfsLookupNextAttribute( IrpContext,
                                                    Fcb,
                                                    &Context );
            }

            NtfsCleanupAttributeContext( IrpContext, &Context );

            //
            //  Skip pass 2 unless there is a large attribute list.
            //

            if (Pass == 1) {

                if (RtlPointerToOffset( Context.AttributeList.FirstEntry,
                                        Context.AttributeList.BeyondFinalEntry ) > 0x1000) {

                    //
                    //  Go ahead and checkpoint now so we will make progress in Pass 2.
                    //

                    NtfsCheckpointCurrentTransaction( IrpContext );

                } else {

                    //
                    //  Skip pass 2.
                    //

                    Pass += 1;
                }
            }
        }

        //
        //  Handle the unusual nonresident attribute list case
        //

        if (NonresidentAttributeList) {

            NtfsInitializeAttributeContext( &Context );

            NtfsLookupAttributeByCode( IrpContext,
                                       Fcb,
                                       &Fcb->FileReference,
                                       $ATTRIBUTE_LIST,
                                       &Context );

            NtfsDeleteAllocationFromRecord( IrpContext, Fcb, &Context, FALSE, FALSE );
            NtfsCleanupAttributeContext( IrpContext, &Context );
        }

        //
        //  Post the delete to the Usn Journal.
        //

        NtfsPostUsnChange( IrpContext, Fcb, USN_REASON_FILE_DELETE | USN_REASON_CLOSE );

        //
        //  Now loop to delete the file records.
        //

        while (Nukem != NULL) {

            for (i = 0; i < 4; i++) {

                if (Nukem->RecordNumbers[i] != 0) {


                    NtfsDeallocateMftRecord( IrpContext,
                                             Vcb,
                                             Nukem->RecordNumbers[i] );
                }
            }

            TempNukem = Nukem->Next;
            if (Nukem != &LocalNuke) {
                ExFreeToPagedLookasideList( &NtfsNukemLookasideList, Nukem );
            }
            Nukem = TempNukem;
        }

        //
        //  Commit the delete - this has the nice effect of writing out all usn journal records for the
        //  delete after this we can safely remove the in memory structures (esp. the fcbtable)
        //  and not worry about retrying the request due to a logfilefull
        //

        NtfsCheckpointCurrentTransaction( IrpContext );

        if (ParentScb != NULL) {

            NtfsUpdateFcb( ParentScb->Fcb,
                           (FCB_INFO_CHANGED_LAST_CHANGE |
                            FCB_INFO_CHANGED_LAST_MOD |
                            FCB_INFO_UPDATE_LAST_ACCESS) );
        }

        SetFlag( Fcb->FcbState, FCB_STATE_FILE_DELETED );

        //
        //  We need to mark all of the links on the file as gone.
        //

        for (Links = Fcb->LcbQueue.Flink;
             Links != &Fcb->LcbQueue;
             Links = Links->Flink) {

            PLCB ThisLcb;

            ThisLcb = CONTAINING_RECORD( Links, LCB, FcbLinks );

            if (ThisLcb->Scb == ParentScb) {

                //
                //  Remove all remaining prefixes on this link.
                //  Make sure the resource is acquired.
                //

                if (!(*AcquiredParentScb)) {

                    NtfsAcquireExclusiveScb( IrpContext, ParentScb );
                    *AcquiredParentScb = TRUE;
                }

                NtfsRemovePrefix( ThisLcb );

                //
                //  Remove any hash table entries for this Lcb.
                //

                NtfsRemoveHashEntriesForLcb( ThisLcb );

                SetFlag( ThisLcb->LcbState, LCB_STATE_LINK_IS_GONE );

                //
                //  We don't need to report any changes on this link.
                //

                ThisLcb->InfoFlags = 0;
            }
        }

        //
        //  We need to mark all of the Scbs as gone.
        //

        for (Links = Fcb->ScbQueue.Flink;
             Links != &Fcb->ScbQueue;
             Links = Links->Flink) {

            PSCB ThisScb;

            ThisScb = CONTAINING_RECORD( Links, SCB, FcbLinks );

            ClearFlag( ThisScb->ScbState,
                       SCB_STATE_NOTIFY_ADD_STREAM |
                       SCB_STATE_NOTIFY_REMOVE_STREAM |
                       SCB_STATE_NOTIFY_RESIZE_STREAM |
                       SCB_STATE_NOTIFY_MODIFY_STREAM );

            //
            //  Clear any remaining reservation - we didn't get rid of when deleting
            //  allocation. I.e the file is resident
            //

            if (NtfsIsTypeCodeUserData( ThisScb->AttributeTypeCode ) &&
                (ThisScb->ScbType.Data.ReservedBitMap != NULL)) {

#ifdef BENL_DBG
                ASSERT( !FlagOn( ThisScb->ScbState, SCB_STATE_ATTRIBUTE_DELETED ) );
#endif

                NtfsDeleteReservedBitmap( ThisScb );
            }

            if (!FlagOn( ThisScb->ScbState, SCB_STATE_ATTRIBUTE_DELETED )) {

                ThisScb->ValidDataToDisk =
                ThisScb->Header.AllocationSize.QuadPart =
                ThisScb->Header.FileSize.QuadPart =
                ThisScb->Header.ValidDataLength.QuadPart = 0;

                ThisScb->AttributeTypeCode = $UNUSED;

                SetFlag( ThisScb->ScbState, SCB_STATE_ATTRIBUTE_DELETED );
            }
        }

        //
        //  We certainly don't need to any on disk update for this
        //  file now.
        //

        Fcb->InfoFlags = 0;
        ClearFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );

    } finally {

        DebugUnwind( NtfsDeleteFile );

        NtfsCleanupAttributeContext( IrpContext, &Context );

        ClearFlag( IrpContext->State, IRP_CONTEXT_STATE_QUOTA_DISABLE );

        //
        //  Release the reparse point index Scb and the map handle.
        //

        if (AcquiredReparseIndex) {

            NtfsReleaseScb( IrpContext, Vcb->ReparsePointTableScb );
        }

        if (InitializedMapHandle) {

            NtOfsReleaseMap( IrpContext, &MapHandle );
        }

        //
        //  Drop the object id index if necessary.
        //

        if (AcquiredObjectIdIndex) {

            NtfsReleaseScb( IrpContext, Vcb->ObjectIdTableScb );
        }

        //
        //  Need to roll-back the value of the file attributes and the reparse point
        //  flag in case of problems.
        //

        if (AbnormalTermination()) {

            Fcb->Info.FileAttributes = IncomingFileAttributes;
            Fcb->Info.ReparsePointTag = IncomingReparsePointTag;
        }
    }

    return;
}


VOID
NtfsPrepareForUpdateDuplicate (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PLCB *Lcb,
    IN OUT PSCB *ParentScb,
    IN BOOLEAN AcquireShared
    )

/*++

Routine Description:

    This routine is called to prepare for updating the duplicate information.
    At the conclusion of this routine we will have the Lcb and Scb for the
    update along with the Scb acquired.  This routine will look at
    the existing values for the input parameters in deciding what actions
    need to be done.

Arguments:

    Fcb - Fcb for the file.  The file must already be acquired exclusively.

    Lcb - This is the address to store the link to update.  This may already
        have a value.

    ParentScb - This is the address to store the parent Scb for the update.
        This may already point to a valid Scb.

    AcquireShared - Indicates how to acquire the parent Scb.

Return Value:

    None

--*/

{
    PLIST_ENTRY Links;
    PLCB ThisLcb;

    PAGED_CODE();

    //
    //  Start by trying to guarantee we have an Lcb for the update.
    //

    if (*Lcb == NULL) {

        Links = Fcb->LcbQueue.Flink;

        while (Links != &Fcb->LcbQueue) {

            ThisLcb = CONTAINING_RECORD( Links,
                                         LCB,
                                         FcbLinks );

            //
            //  We can use this link if it is still present on the
            //  disk and if we were passed a parent Scb, it matches
            //  the one for this Lcb.
            //

            if (!FlagOn( ThisLcb->LcbState, LCB_STATE_LINK_IS_GONE ) &&
                ((*ParentScb == NULL) ||
                 (*ParentScb == ThisLcb->Scb) ||
                 ((ThisLcb == Fcb->Vcb->RootLcb) &&
                  (*ParentScb == Fcb->Vcb->RootIndexScb)))) {

                *Lcb = ThisLcb;
                break;
            }

            Links = Links->Flink;
        }
    }

    //
    //  If we have an Lcb, try to find the correct Scb.
    //

    if ((*Lcb != NULL) && (*ParentScb == NULL)) {

        if (*Lcb == Fcb->Vcb->RootLcb) {

            *ParentScb = Fcb->Vcb->RootIndexScb;

        } else {

            *ParentScb = (*Lcb)->Scb;
        }
    }

    //
    //  Acquire the parent Scb and put it in the transaction queue in the
    //  IrpContext.
    //

    if (*ParentScb != NULL) {

        if (AcquireShared) {

            NtfsAcquireSharedScbForTransaction( IrpContext, *ParentScb );

        } else {

            NtfsAcquireExclusiveScb( IrpContext, *ParentScb );
        }
    }

    return;
}


VOID
NtfsUpdateDuplicateInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PLCB Lcb OPTIONAL,
    IN PSCB ParentScb OPTIONAL
    )

/*++

Routine Description:

    This routine is called to update the duplicate information for a file
    in the duplicated information of its parent.  If the Lcb is specified
    then this parent is the parent to update.  If the link is either an
    NTFS or DOS only link then we must update the complementary link as
    well.  If no Lcb is specified then this open was by file id or the
    original link has been deleted.  In that case we will try to find a different
    link to update.

Arguments:

    Fcb - Fcb for the file.

    Lcb - This is the link to update.  Specified only if this is not
        an open by Id operation.

    ParentScb - This is the parent directory for the Lcb link if specified.

Return Value:

    None

--*/

{
    PQUICK_INDEX QuickIndex = NULL;

    UCHAR Buffer[sizeof( FILE_NAME ) + 11 * sizeof( WCHAR )];
    PFILE_NAME FileNameAttr;

    BOOLEAN AcquiredFcbTable = FALSE;

    BOOLEAN ReturnedExistingFcb = TRUE;
    BOOLEAN Found;
    UCHAR FileNameFlags;
    ATTRIBUTE_ENUMERATION_CONTEXT Context;
    PVCB Vcb = Fcb->Vcb;

    PFCB ParentFcb = NULL;

    PAGED_CODE();

    ASSERT_EXCLUSIVE_FCB( Fcb );

    //
    //  Return immediately if the volume is locked or
    //  is mounted readonly.
    //

    if (FlagOn( Vcb->VcbState, (VCB_STATE_LOCKED |
                                VCB_STATE_MOUNT_READ_ONLY ))) {

        return;
    }

    NtfsInitializeAttributeContext( &Context );

    try {

        //
        //  If we are updating the entry for the root then we know the
        //  file name attribute to build.
        //

        if (Fcb == Fcb->Vcb->RootIndexScb->Fcb) {

            Lcb = Fcb->Vcb->RootLcb;
            ParentScb = Fcb->Vcb->RootIndexScb;

            QuickIndex = &Fcb->Vcb->RootLcb->QuickIndex;

            FileNameAttr = (PFILE_NAME) Buffer;

            RtlZeroMemory( FileNameAttr,
                           sizeof( FILE_NAME ));

            NtfsBuildFileNameAttribute( IrpContext,
                                        &Fcb->FileReference,
                                        NtfsRootIndexString,
                                        FILE_NAME_DOS | FILE_NAME_NTFS,
                                        FileNameAttr );

        //
        //  If we have and Lcb then it is either present or we noop this update.
        //

        } else if (ARGUMENT_PRESENT( Lcb )) {

            if (!FlagOn( Lcb->LcbState, LCB_STATE_LINK_IS_GONE )) {

                QuickIndex = &Lcb->QuickIndex;
                FileNameAttr = Lcb->FileNameAttr;

            } else {

                leave;
            }

        //
        //  If there is no Lcb then lookup the first filename attribute
        //  and update its index entry.  If there is a parent Scb then we
        //  must find a file name attribute for the same parent or we could
        //  get into a deadlock situation.
        //

        } else {

            //
            //  We now have a name link to update.  We will now need
            //  an Scb for the parent index.  Remember that we may
            //  have to teardown the Scb.  If we already have a ParentScb
            //  then we must find a link to the same parent or to the root.
            //  Otherwise we could hit a deadlock.
            //

            Found = NtfsLookupAttributeByCode( IrpContext,
                                               Fcb,
                                               &Fcb->FileReference,
                                               $FILE_NAME,
                                               &Context );

            if (!Found) {

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
            }

            //
            //  Loop until we find a suitable link or there are no more on the file.
            //

            do {

                FileNameAttr = (PFILE_NAME) NtfsAttributeValue( NtfsFoundAttribute( &Context ));

                //
                //  If there is a parent and this attribute has the same parent we are
                //  done.  Our caller will always have acquired the ParentScb.
                //

                if (ARGUMENT_PRESENT( ParentScb )) {

                    if (NtfsEqualMftRef( &FileNameAttr->ParentDirectory,
                                         &ParentScb->Fcb->FileReference )) {

                        ASSERT_SHARED_SCB( ParentScb );
                        break;
                    }

                //
                //  If this is the parent of this link is the root then
                //  acquire the root directory.
                //

                } else if (NtfsEqualMftRef( &FileNameAttr->ParentDirectory,
                                            &Vcb->RootIndexScb->Fcb->FileReference )) {

                    ParentScb = Vcb->RootIndexScb;
                    NtfsAcquireSharedScbForTransaction( IrpContext, ParentScb );
                    break;

                //
                //  We have a link for this file.  If we weren't given a parent
                //  Scb then create one here.
                //

                } else if (!ARGUMENT_PRESENT( ParentScb )) {

                    NtfsAcquireFcbTable( IrpContext, Vcb );
                    AcquiredFcbTable = TRUE;

                    ParentFcb = NtfsCreateFcb( IrpContext,
                                               Vcb,
                                               FileNameAttr->ParentDirectory,
                                               FALSE,
                                               TRUE,
                                               &ReturnedExistingFcb );

                    ParentFcb->ReferenceCount += 1;

                    if (!NtfsAcquireExclusiveFcb( IrpContext, ParentFcb, NULL, ACQUIRE_NO_DELETE_CHECK | ACQUIRE_DONT_WAIT )) {

                        NtfsReleaseFcbTable( IrpContext, Vcb );
                        NtfsAcquireExclusiveFcb( IrpContext, ParentFcb, NULL, ACQUIRE_NO_DELETE_CHECK );
                        NtfsAcquireFcbTable( IrpContext, Vcb );
                    }

                    ParentFcb->ReferenceCount -= 1;

                    NtfsReleaseFcbTable( IrpContext, Vcb );
                    AcquiredFcbTable = FALSE;

                    ParentScb = NtfsCreateScb( IrpContext,
                                               ParentFcb,
                                               $INDEX_ALLOCATION,
                                               &NtfsFileNameIndex,
                                               FALSE,
                                               NULL );

                    NtfsAcquireExclusiveScb( IrpContext, ParentScb );
                    break;
                }

            } while (Found = NtfsLookupNextAttributeByCode( IrpContext,
                                                             Fcb,
                                                             $FILE_NAME,
                                                             &Context ));

            //
            //  If we didn't find anything then return.
            //

            if (!Found) { leave; }
        }

        //
        //  Now update the filename in the parent index.
        //

        NtfsUpdateFileNameInIndex( IrpContext,
                                   ParentScb,
                                   FileNameAttr,
                                   &Fcb->Info,
                                   QuickIndex );

        //
        //  If this filename is either NTFS-ONLY or DOS-ONLY then
        //  we need to find the other link.
        //

        if ((FileNameAttr->Flags == FILE_NAME_NTFS) ||
            (FileNameAttr->Flags == FILE_NAME_DOS)) {

            //
            //  Find out which flag we should be looking for.
            //

            if (FlagOn( FileNameAttr->Flags, FILE_NAME_NTFS )) {

                FileNameFlags = FILE_NAME_DOS;

            } else {

                FileNameFlags = FILE_NAME_NTFS;
            }

            if (!ARGUMENT_PRESENT( Lcb )) {

                NtfsCleanupAttributeContext( IrpContext, &Context );
                NtfsInitializeAttributeContext( &Context );
            }

            //
            //  Now scan for the filename attribute we need.
            //

            Found = NtfsLookupAttributeByCode( IrpContext,
                                               Fcb,
                                               &Fcb->FileReference,
                                               $FILE_NAME,
                                               &Context );

            while (Found) {

                FileNameAttr = (PFILE_NAME) NtfsAttributeValue( NtfsFoundAttribute( &Context ));

                if (FileNameAttr->Flags == FileNameFlags) {

                    break;
                }

                Found = NtfsLookupNextAttributeByCode( IrpContext,
                                                       Fcb,
                                                       $FILE_NAME,
                                                       &Context );
            }

            //
            //  We should have found the entry.
            //

            if (!Found) {

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
            }

            NtfsUpdateFileNameInIndex( IrpContext,
                                       ParentScb,
                                       FileNameAttr,
                                       &Fcb->Info,
                                       NULL );
        }

    } finally {

        DebugUnwind( NtfsUpdateDuplicateInfo );

        if (AcquiredFcbTable) {

            NtfsReleaseFcbTable( IrpContext, Vcb );
        }

        //
        //  Cleanup the attribute context for this attribute search.
        //

        NtfsCleanupAttributeContext( IrpContext, &Context );

        //
        //  If we created the ParentFcb here then release it and
        //  call teardown on it.
        //

        if (!ReturnedExistingFcb && (ParentFcb != NULL)) {

            NtfsTeardownStructures( IrpContext,
                                    ParentFcb,
                                    NULL,
                                    FALSE,
                                    0,
                                    NULL );
        }
    }

    return;
}


VOID
NtfsUpdateLcbDuplicateInfo (
    IN PFCB Fcb,
    IN PLCB Lcb
    )

/*++

Routine Description:

    This routine is called after updating duplicate information via an Lcb.
    We want to clear the info flags for this Lcb and any complementary Lcb
    it may be part of.  We also want to OR in the Info flags in the Fcb with
    any other Lcb's attached to the Fcb so we will update those in a timely
    fashion as well.

Arguments:

    Fcb - Fcb for the file.

    Lcb - Lcb used to update duplicate information.  It may not be present but
        that would be a rare case and we will perform that test here.

Return Value:

    None

--*/

{
    UCHAR FileNameFlags;
    PLCB NextLcb;
    PLIST_ENTRY Links;

    PAGED_CODE();

    //
    //  No work to do unless we were passed an Lcb.
    //

    if (Lcb != NULL) {

        //
        //  Check if this is an NTFS only or DOS only link.
        //

        if (Lcb->FileNameAttr->Flags == FILE_NAME_NTFS) {

            FileNameFlags = FILE_NAME_DOS;

        } else if (Lcb->FileNameAttr->Flags == FILE_NAME_DOS) {

            FileNameFlags = FILE_NAME_NTFS;

        } else {

            FileNameFlags = (UCHAR) -1;
        }

        Lcb->InfoFlags = 0;

        Links = Fcb->LcbQueue.Flink;

        do {

            NextLcb = CONTAINING_RECORD( Links,
                                         LCB,
                                         FcbLinks );

            if (NextLcb != Lcb) {

                if (NextLcb->FileNameAttr->Flags == FileNameFlags) {

                    NextLcb->InfoFlags = 0;

                } else {

                    SetFlag( NextLcb->InfoFlags, Fcb->InfoFlags );
                }
            }

            Links = Links->Flink;

        } while (Links != &Fcb->LcbQueue);
    }

    return;
}


VOID
NtfsUpdateFcb (
    IN PFCB Fcb,
    IN ULONG ChangeFlags
    )

/*++

Routine Description:

    This routine is called when a timestamp may be updated on an Fcb which
    may have no open handles.  We update the time stamps for the flags passed
    in.

Arguments:

    Fcb - Fcb for the file.

    ChangeFlags - Flags indicating which times to update.

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    //  We need to update the parent directory's time stamps
    //  to reflect this change.
    //

    //
    //  The change flag should always be set.
    //

    ASSERT( FlagOn( ChangeFlags, FCB_INFO_CHANGED_LAST_CHANGE ));
    KeQuerySystemTime( (PLARGE_INTEGER)&Fcb->Info.LastChangeTime );

    SetFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );

    //
    //  Test for the other flags which may be set.
    //

    if (FlagOn( ChangeFlags, FCB_INFO_CHANGED_LAST_MOD )) {

        Fcb->Info.LastModificationTime = Fcb->Info.LastChangeTime;
    }

    if (FlagOn( ChangeFlags, FCB_INFO_UPDATE_LAST_ACCESS )) {

        Fcb->CurrentLastAccess = Fcb->Info.LastChangeTime;
    }

    SetFlag( Fcb->InfoFlags, ChangeFlags );

    return;
}


VOID
NtfsAddLink (
    IN PIRP_CONTEXT IrpContext,
    IN BOOLEAN CreatePrimaryLink,
    IN PSCB ParentScb,
    IN PFCB Fcb,
    IN PFILE_NAME FileNameAttr,
    IN PBOOLEAN LogIt OPTIONAL,
    OUT PUCHAR FileNameFlags,
    OUT PQUICK_INDEX QuickIndex OPTIONAL,
    IN PNAME_PAIR NamePair OPTIONAL,
    IN PINDEX_CONTEXT IndexContext OPTIONAL
    )

/*++

Routine Description:

    This routine adds a link to a file by adding the filename attribute
    for the filename to the file and inserting the name in the parent Scb
    index.  If we are creating the primary link for the file and need
    to generate an auxilary name, we will do that here. Use the optional
    NamePair to suggest auxilary names if provided.

Arguments:

    CreatePrimaryLink - Indicates if we are creating the main Ntfs name
        for the file.

    ParentScb - This is the Scb to add the index entry for this link to.

    Fcb - This is the file to add the hard link to.

    FileNameAttr - File name attribute which is guaranteed only to have the
        name in it.

    LogIt - Indicates whether we should log the creation of this name.  If not
        specified then we always log the name creation.  On exit we will
        update this to TRUE if we logged the name creation because it
        might cause a split.

    FileNameFlags - We return the file name flags we use to create the link.

    QuickIndex - If specified, supplies a pointer to a quik lookup structure
        to be updated by this routine.

    NamePair - If specified, supplies names that will be checked first as
        possible auxilary names

    IndexContext - Previous result of doing the lookup for the name in the index.

Return Value:

    None

--*/

{
    BOOLEAN LocalLogIt = TRUE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsAddLink:  Entered\n") );

    if (!ARGUMENT_PRESENT( LogIt )) {

        LogIt = &LocalLogIt;
    }

    *FileNameFlags = 0;

    //
    //  Next add this entry to parent.  It is possible that this is a link,
    //  an Ntfs name, a DOS name or Ntfs/Dos name.  We use the filename
    //  attribute structure from earlier, but need to add more information.
    //

    FileNameAttr->ParentDirectory = ParentScb->Fcb->FileReference;

    RtlCopyMemory( &FileNameAttr->Info,
                   &Fcb->Info,
                   sizeof( DUPLICATED_INFORMATION ));

    FileNameAttr->Flags = 0;

    //
    //  We will override the CreatePrimaryLink with the value in the
    //  registry.
    //

    NtfsAddNameToParent( IrpContext,
                         ParentScb,
                         Fcb,
                         (BOOLEAN) (FlagOn( NtfsData.Flags,
                                            NTFS_FLAGS_CREATE_8DOT3_NAMES ) &&
                                    CreatePrimaryLink),
                         LogIt,
                         FileNameAttr,
                         FileNameFlags,
                         QuickIndex,
                         NamePair,
                         IndexContext );

    //
    //  If the name is Ntfs only, we need to generate the DOS name.
    //

    if (*FileNameFlags == FILE_NAME_NTFS) {

        UNICODE_STRING NtfsName;

        NtfsName.Length = (USHORT)(FileNameAttr->FileNameLength * sizeof(WCHAR));
        NtfsName.Buffer = FileNameAttr->FileName;

        NtfsAddDosOnlyName( IrpContext,
                            ParentScb,
                            Fcb,
                            NtfsName,
                            *LogIt,
                            (NamePair ? &NamePair->Short : NULL) );
    }

    DebugTrace( -1, Dbg, ("NtfsAddLink:  Exit\n") );

    return;
}


VOID
NtfsRemoveLink (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB ParentScb,
    IN UNICODE_STRING LinkName,
    IN OUT PNAME_PAIR NamePair OPTIONAL,
    IN OUT PNTFS_TUNNELED_DATA TunneledData OPTIONAL
    )

/*++

Routine Description:

    This routine removes a hard link to a file by removing the filename attribute
    for the filename from the file and removing the name from the parent Scb
    index.  It will also remove the other half of a primary link pair.

    A name pair may be used to capture the names.

Arguments:

    Fcb - This is the file to remove the hard link from

    ParentScb - This is the Scb to remove the index entry for this link from

    LinkName - This is the file name to remove.  It will be exact case.

    NamePair - optional name pair for capture

Return Value:

    None

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    ATTRIBUTE_ENUMERATION_CONTEXT OidAttrContext;
    PFILE_NAME FoundFileName;
    UCHAR FileNameFlags;
    UCHAR *ObjectId;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsRemoveLink:  Entered\n") );

    NtfsInitializeAttributeContext( &AttrContext );
    NtfsInitializeAttributeContext( &OidAttrContext );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Now loop through the filenames and find a match.
        //  We better find at least one.
        //

        if (!NtfsLookupAttributeByCode( IrpContext,
                                        Fcb,
                                        &Fcb->FileReference,
                                        $FILE_NAME,
                                        &AttrContext )) {

            DebugTrace( 0, Dbg, ("Can't find filename attribute Fcb @ %08lx\n", Fcb) );

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
        }

        //
        //  Now keep looking until we find a match.
        //

        while (TRUE) {

            FoundFileName = (PFILE_NAME) NtfsAttributeValue( NtfsFoundAttribute( &AttrContext ));

            //
            //  Do an exact memory comparison.
            //

            if ((*(PLONGLONG)&FoundFileName->ParentDirectory ==
                 *(PLONGLONG)&ParentScb->Fcb->FileReference ) &&

                ((FoundFileName->FileNameLength * sizeof( WCHAR )) == (ULONG)LinkName.Length) &&

                (RtlEqualMemory( LinkName.Buffer,
                                 FoundFileName->FileName,
                                 LinkName.Length ))) {

                break;
            }

            //
            //  Get the next filename attribute.
            //

            if (!NtfsLookupNextAttributeByCode( IrpContext,
                                                Fcb,
                                                $FILE_NAME,
                                                &AttrContext )) {

                DebugTrace( 0, Dbg, ("Can't find filename attribute Fcb @ %08lx\n", Fcb) );

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
            }
        }

        //
        //  Capture the name into caller's area
        //

        if (ARGUMENT_PRESENT(NamePair)) {

            NtfsCopyNameToNamePair( NamePair,
                                    FoundFileName->FileName,
                                    FoundFileName->FileNameLength,
                                    FoundFileName->Flags );
        }

        //
        //  It's important to do any object id operations now, before we
        //  acquire the Mft.  Otherwise we risk a deadlock.
        //

        if (ARGUMENT_PRESENT(TunneledData)) {

            //
            //  Find and store the object id, if any, for this file.
            //

            if (NtfsLookupAttributeByCode( IrpContext,
                                           Fcb,
                                           &Fcb->FileReference,
                                           $OBJECT_ID,
                                           &OidAttrContext )) {

                TunneledData->HasObjectId = TRUE;

                ObjectId = (UCHAR *) NtfsAttributeValue( NtfsFoundAttribute( &OidAttrContext ));

                RtlCopyMemory( TunneledData->ObjectIdBuffer.ObjectId,
                               ObjectId,
                               sizeof(TunneledData->ObjectIdBuffer.ObjectId) );

                NtfsGetObjectIdExtendedInfo( IrpContext,
                                             Fcb->Vcb,
                                             ObjectId,
                                             TunneledData->ObjectIdBuffer.ExtendedInfo );
            }
        }

        //
        //  Now delete the name from the parent Scb.
        //

        NtfsDeleteIndexEntry( IrpContext,
                              ParentScb,
                              FoundFileName,
                              &Fcb->FileReference );

        //
        //  Remember the filename flags for this entry.
        //

        FileNameFlags = FoundFileName->Flags;

        //
        //  Now delete the entry.  Log the operation, discard the file record
        //  if empty, and release any and all allocation.
        //

        NtfsDeleteAttributeRecord( IrpContext,
                                   Fcb,
                                   (DELETE_LOG_OPERATION |
                                    DELETE_RELEASE_FILE_RECORD |
                                    DELETE_RELEASE_ALLOCATION),
                                   &AttrContext );

        //
        //  If the link is a partial link, we need to remove the second
        //  half of the link.
        //

        if (FlagOn( FileNameFlags, (FILE_NAME_NTFS | FILE_NAME_DOS) )
            && (FileNameFlags != (FILE_NAME_NTFS | FILE_NAME_DOS))) {

            NtfsRemoveLinkViaFlags( IrpContext,
                                    Fcb,
                                    ParentScb,
                                    (UCHAR)(FlagOn( FileNameFlags, FILE_NAME_NTFS )
                                     ? FILE_NAME_DOS
                                     : FILE_NAME_NTFS),
                                    NamePair,
                                    NULL );
        }

    } finally {

        DebugUnwind( NtfsRemoveLink );

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );
        NtfsCleanupAttributeContext( IrpContext, &OidAttrContext );

        DebugTrace( -1, Dbg, ("NtfsRemoveLink:  Exit\n") );
    }

    return;
}


VOID
NtfsRemoveLinkViaFlags (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB Scb,
    IN UCHAR FileNameFlags,
    IN OUT PNAME_PAIR NamePair OPTIONAL,
    OUT PUNICODE_STRING FileName OPTIONAL
    )

/*++

Routine Description:

    This routine is called to remove only a Dos name or only an Ntfs name.  We
    already must know that these will be described by separate filename attributes.

    A name pair may be used to capture the name.

Arguments:

    Fcb - This is the file to remove the hard link from

    ParentScb - This is the Scb to remove the index entry for this link from

    FileNameFlags - This is the single name flag that we must match exactly.

    NamePair - Optional name pair for capture

    FileName - Optional pointer to unicode string.  If specified we allocate a buffer and
        return the name deleted.

Return Value:

    None

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    PFILE_NAME FileNameAttr;

    PFILE_NAME FoundFileName;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsRemoveLinkViaFlags:  Entered\n") );

    NtfsInitializeAttributeContext( &AttrContext );

    FileNameAttr = NULL;

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Now loop through the filenames and find a match.
        //  We better find at least one.
        //

        if (!NtfsLookupAttributeByCode( IrpContext,
                                        Fcb,
                                        &Fcb->FileReference,
                                        $FILE_NAME,
                                        &AttrContext )) {

            DebugTrace( 0, Dbg, ("Can't find filename attribute Fcb @ %08lx\n", Fcb) );

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
        }

        //
        //  Now keep looking until we find a match.
        //

        while (TRUE) {

            FoundFileName = (PFILE_NAME) NtfsAttributeValue( NtfsFoundAttribute( &AttrContext ));

            //
            //  Check for an exact flag match.
            //

            if ((*(PLONGLONG)&FoundFileName->ParentDirectory ==
                 *(PLONGLONG)&Scb->Fcb->FileReference) &&

                (FoundFileName->Flags == FileNameFlags)) {


                break;
            }

            //
            //  Get the next filename attribute.
            //

            if (!NtfsLookupNextAttributeByCode( IrpContext,
                                                Fcb,
                                                $FILE_NAME,
                                                &AttrContext )) {

                DebugTrace( 0, Dbg, ("Can't find filename attribute Fcb@ %08lx\n", Fcb) );

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
            }
        }

        //
        //  Capture the name into caller's area
        //

        if (ARGUMENT_PRESENT(NamePair)) {

            NtfsCopyNameToNamePair( NamePair,
                                    FoundFileName->FileName,
                                    FoundFileName->FileNameLength,
                                    FoundFileName->Flags );

        }

        FileNameAttr = NtfsAllocatePool( PagedPool,
                                         sizeof( FILE_NAME ) + (FoundFileName->FileNameLength << 1) );

        //
        //  We build the file name attribute for the search.
        //

        RtlCopyMemory( FileNameAttr,
                       FoundFileName,
                       NtfsFileNameSize( FoundFileName ));

        //
        //  Now delete the entry.
        //

        NtfsDeleteAttributeRecord( IrpContext,
                                   Fcb,
                                   (DELETE_LOG_OPERATION |
                                    DELETE_RELEASE_FILE_RECORD |
                                    DELETE_RELEASE_ALLOCATION),
                                   &AttrContext );

        //
        //  Now delete the name from the parent Scb.
        //

        NtfsDeleteIndexEntry( IrpContext,
                              Scb,
                              FileNameAttr,
                              &Fcb->FileReference );

    } finally {

        DebugUnwind( NtfsRemoveLinkViaFlags );

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );

        if (FileNameAttr != NULL) {

            //
            //  If the user passed in a unicode string then make this look like the name
            //  and store the buffer into the input pointer.
            //

            if (ARGUMENT_PRESENT( FileName )) {

                ASSERT( FileName->Buffer == NULL );

                FileName->MaximumLength = FileName->Length = FileNameAttr->FileNameLength * sizeof( WCHAR );
                RtlMoveMemory( FileNameAttr,
                               FileNameAttr->FileName,
                               FileName->Length );

                FileName->Buffer = (PVOID) FileNameAttr;

            } else {

                NtfsFreePool( FileNameAttr );
            }
        }

        DebugTrace( -1, Dbg, ("NtfsRemoveLinkViaFlags:  Exit\n") );
    }

    return;
}


VOID
NtfsUpdateFileNameFlags (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB ParentScb,
    IN UCHAR FileNameFlags,
    IN PFILE_NAME FileNameLink
    )

/*++

Routine Description:

    This routine is called to perform the file name flag update on a name
    link.  Nothing else about the name is changing except for the flag
    changes.

Arguments:

    Fcb - This is the file to change the link flags on.

    ParentScb - This is the Scb which contains the link.

    FileNameFlags - This is the single name flag that we want to change to.

    FileNameLink - Pointer to a copy of the link to change.

Return Value:

    None

--*/

{
    PFILE_NAME FoundFileName;
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    BOOLEAN CleanupContext = FALSE;

    PAGED_CODE();

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Look up the correct attribute in the file record.
        //

        NtfsInitializeAttributeContext( &AttrContext );
        CleanupContext = TRUE;

        if (!NtfsLookupAttributeByCode( IrpContext,
                                        Fcb,
                                        &Fcb->FileReference,
                                        $FILE_NAME,
                                        &AttrContext )) {

            DebugTrace( 0, Dbg, ("Can't find filename attribute Fcb @ %08lx\n", Fcb) );
            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
        }

        //
        //  Now keep looking till we find the one we want.
        //

        while (TRUE) {

            FoundFileName = (PFILE_NAME) NtfsAttributeValue( NtfsFoundAttribute( &AttrContext ));

            //
            //  If the names match exactly and the parent directories match then
            //  we have a match.
            //

            if (NtfsEqualMftRef( &FileNameLink->ParentDirectory,
                                 &FoundFileName->ParentDirectory ) &&
                (FileNameLink->FileNameLength == FoundFileName->FileNameLength) &&
                RtlEqualMemory( FileNameLink->FileName,
                                FoundFileName->FileName,
                                FileNameLink->FileNameLength * sizeof( WCHAR ))) {

                break;
            }

            //
            //  Get the next filename attribute.
            //

            if (!NtfsLookupNextAttributeByCode( IrpContext,
                                                Fcb,
                                                $FILE_NAME,
                                                &AttrContext )) {

                //
                //  This is bad.  We should have found a match.
                //

                DebugTrace( 0, Dbg, ("Can't find filename attribute Fcb @ %08lx\n", Fcb) );
                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
            }
        }

        //
        //  Unfortunately we can't log the change to the file name flags only so we will have to remove
        //  and reinsert the index entry.
        //

        NtfsDeleteIndexEntry( IrpContext,
                              ParentScb,
                              FoundFileName,
                              &Fcb->FileReference );

        //
        //  Update just the flags field.
        //

        NtfsChangeAttributeValue( IrpContext,
                                  Fcb,
                                  FIELD_OFFSET( FILE_NAME, Flags ),
                                  &FileNameFlags,
                                  sizeof( UCHAR ),
                                  FALSE,
                                  TRUE,
                                  FALSE,
                                  TRUE,
                                  &AttrContext );

        //
        //  Now reinsert the name in the index.
        //

        NtfsAddIndexEntry( IrpContext,
                           ParentScb,
                           FoundFileName,
                           NtfsFileNameSize( FoundFileName ),
                           &Fcb->FileReference,
                           NULL,
                           NULL );

    } finally {

        DebugUnwind( NtfsUpdateFileNameFlags );

        if (CleanupContext) {

            NtfsCleanupAttributeContext( IrpContext, &AttrContext );
        }
    }

    return;
}


//
//  This routine is intended only for RESTART.
//

VOID
NtfsRestartInsertAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN ULONG RecordOffset,
    IN PATTRIBUTE_RECORD_HEADER Attribute,
    IN PUNICODE_STRING AttributeName OPTIONAL,
    IN PVOID ValueOrMappingPairs OPTIONAL,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine performs a simple insert of an attribute record into a
    file record, without worrying about Bcbs or logging.

Arguments:

    FileRecord - File record into which the attribute is to be inserted.

    RecordOffset - ByteOffset within the file record at which insert is to occur.

    Attribute - The attribute record to be inserted.

    AttributeName - May pass an optional attribute name in the running system
                    only.

    ValueOrMappingPairs - May pass a value or mapping pairs pointer in the
                          running system only.

    Length - Length of the value or mapping pairs array in bytes - nonzero in
             the running system only.  If nonzero and the above pointer is NULL,
             then a value is to be zeroed.

Return Value:

    None

--*/

{
    PVOID From, To;
    ULONG MoveLength;
    ULONG AttributeHeaderSize;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT( IsQuadAligned( Attribute->RecordLength ) );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsRestartInsertAttribute\n") );
    DebugTrace( 0, Dbg, ("FileRecord = %08lx\n", FileRecord) );
    DebugTrace( 0, Dbg, ("RecordOffset = %08lx\n", RecordOffset) );
    DebugTrace( 0, Dbg, ("Attribute = %08lx\n", Attribute) );

    //
    //  First make room for the attribute
    //

    From = (PCHAR)FileRecord + RecordOffset;
    To = (PCHAR)From + Attribute->RecordLength;
    MoveLength = FileRecord->FirstFreeByte - RecordOffset;

    RtlMoveMemory( To, From, MoveLength );

    //
    //  If there is either an attribute name or Length is nonzero, then
    //  we are in the running system, and we are to assemble the attribute
    //  in place.
    //

    if ((Length != 0) || ARGUMENT_PRESENT(AttributeName)) {

        //
        //  First move the attribute header in.
        //

        if (Attribute->FormCode == RESIDENT_FORM) {

            AttributeHeaderSize = SIZEOF_RESIDENT_ATTRIBUTE_HEADER;

        } else if (Attribute->NameOffset != 0) {

            AttributeHeaderSize = Attribute->NameOffset;

        } else {

            AttributeHeaderSize = Attribute->Form.Nonresident.MappingPairsOffset;
        }

        RtlCopyMemory( From,
                       Attribute,
                       AttributeHeaderSize );

        if (ARGUMENT_PRESENT(AttributeName)) {

            RtlCopyMemory( (PCHAR)From + Attribute->NameOffset,
                            AttributeName->Buffer,
                            AttributeName->Length );
        }

        //
        //  If a value was specified, move it in.  Else the caller just wants us
        //  to clear for that much.
        //

        if (ARGUMENT_PRESENT(ValueOrMappingPairs)) {

            RtlCopyMemory( (PCHAR)From +
                             ((Attribute->FormCode == RESIDENT_FORM) ?
                                Attribute->Form.Resident.ValueOffset :
                                Attribute->Form.Nonresident.MappingPairsOffset),
                           ValueOrMappingPairs,
                           Length );

        //
        //  Only the resident form will pass a NULL pointer.
        //

        } else {

            RtlZeroMemory( (PCHAR)From + Attribute->Form.Resident.ValueOffset,
                           Length );
        }

    //
    //  For the restart case, we really only have to insert the attribute.
    //  (Note we can also hit this case in the running system when a resident
    //  attribute is being created with no name and a null value.)
    //

    } else {

        //
        //  Now move the attribute in.
        //

        RtlCopyMemory( From, Attribute, Attribute->RecordLength );
    }

    //
    //  Update the file record.
    //

    FileRecord->FirstFreeByte += Attribute->RecordLength;

    //
    //  We only need to do this if we would be incrementing the instance
    //  number.  In the abort or restart case, we don't need to do this.
    //

    if (FileRecord->NextAttributeInstance <= Attribute->Instance) {

        FileRecord->NextAttributeInstance = Attribute->Instance + 1;
    }

    //
    //  Remember to increment the reference count if this attribute is indexed.
    //

    if (FlagOn(Attribute->Form.Resident.ResidentFlags, RESIDENT_FORM_INDEXED)) {
        FileRecord->ReferenceCount += 1;
    }

    DebugTrace( -1, Dbg, ("NtfsRestartInsertAttribute -> VOID\n") );

    return;
}


//
//  This routine is intended only for RESTART.
//

VOID
NtfsRestartRemoveAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN ULONG RecordOffset
    )

/*++

Routine Description:

    This routine performs a simple remove of an attribute record from a
    file record, without worrying about Bcbs or logging.

Arguments:

    FileRecord - File record from which the attribute is to be removed.

    RecordOffset - ByteOffset within the file record at which remove is to occur.

Return Value:

    None

--*/

{
    PATTRIBUTE_RECORD_HEADER Attribute;

    ASSERT_IRP_CONTEXT( IrpContext );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsRestartRemoveAttribute\n") );
    DebugTrace( 0, Dbg, ("FileRecord = %08lx\n", FileRecord) );
    DebugTrace( 0, Dbg, ("RecordOffset = %08lx\n", RecordOffset) );

    //
    //  Calculate the address of the attribute we are removing.
    //

    Attribute = (PATTRIBUTE_RECORD_HEADER)((PCHAR)FileRecord + RecordOffset);
    ASSERT( IsQuadAligned( Attribute->RecordLength ) );

    //
    //  Reduce first free byte by the amount we removed.
    //

    FileRecord->FirstFreeByte -= Attribute->RecordLength;

    //
    //  Remember to decrement the reference count if this attribute is indexed.
    //

    if (FlagOn(Attribute->Form.Resident.ResidentFlags, RESIDENT_FORM_INDEXED)) {
        FileRecord->ReferenceCount -= 1;
    }

    //
    //  Remove the attribute by moving the rest of the record down.
    //

    RtlMoveMemory( Attribute,
                   (PCHAR)Attribute + Attribute->RecordLength,
                   FileRecord->FirstFreeByte - RecordOffset );

    DebugTrace( -1, Dbg, ("NtfsRestartRemoveAttribute -> VOID\n") );

    return;
}


//
//  This routine is intended only for RESTART.
//

VOID
NtfsRestartChangeAttributeSize (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN PATTRIBUTE_RECORD_HEADER Attribute,
    IN ULONG NewRecordLength
    )

/*++

Routine Description:

    This routine changes the size of an attribute, and makes the related
    changes in the attribute record.

Arguments:

    FileRecord - Pointer to the file record in which the attribute resides.

    Attribute - Pointer to the attribute whose size is changing.

    NewRecordLength - New attribute record length.

Return Value:

    None.

--*/

{
    LONG SizeChange = NewRecordLength - Attribute->RecordLength;
    PVOID AttributeEnd = Add2Ptr(Attribute, Attribute->RecordLength);

    UNREFERENCED_PARAMETER( IrpContext );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsRestartChangeAttributeSize\n") );
    DebugTrace( 0, Dbg, ("FileRecord = %08lx\n", FileRecord) );
    DebugTrace( 0, Dbg, ("Attribute = %08lx\n", Attribute) );
    DebugTrace( 0, Dbg, ("NewRecordLength = %08lx\n", NewRecordLength) );

    //
    //  First move the end of the file record after the attribute we are changing.
    //

    RtlMoveMemory( Add2Ptr(Attribute, NewRecordLength),
                   AttributeEnd,
                   FileRecord->FirstFreeByte - PtrOffset(FileRecord, AttributeEnd) );

    //
    //  Now update the file and attribute records.
    //

    FileRecord->FirstFreeByte += SizeChange;
    Attribute->RecordLength = NewRecordLength;

    DebugTrace( -1, Dbg, ("NtfsRestartChangeAttributeSize -> VOID\n") );
}


//
//  This routine is intended only for RESTART.
//

VOID
NtfsRestartChangeValue (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN ULONG RecordOffset,
    IN ULONG AttributeOffset,
    IN PVOID Data,
    IN ULONG Length,
    IN BOOLEAN SetNewLength
    )

/*++

Routine Description:

    This routine performs a simple change of an attribute value in a
    file record, without worrying about Bcbs or logging.

Arguments:

    FileRecord - File record in which the attribute is to be changed.

    RecordOffset - ByteOffset within the file record at which the attribute starts.

    AttributeOffset - Offset within the attribute record at which data is to
                   be changed.

    Data - Pointer to the new data.

    Length - Length of the new data.

    SetNewLength - TRUE if the attribute length should be changed.

Return Value:

    None

--*/

{
    PATTRIBUTE_RECORD_HEADER Attribute;
    BOOLEAN AlreadyMoved = FALSE;
    BOOLEAN DataInFileRecord = FALSE;

    ASSERT_IRP_CONTEXT( IrpContext );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsRestartChangeValue\n") );
    DebugTrace( 0, Dbg, ("FileRecord = %08lx\n", FileRecord) );
    DebugTrace( 0, Dbg, ("RecordOffset = %08lx\n", RecordOffset) );
    DebugTrace( 0, Dbg, ("AttributeOffset = %08lx\n", AttributeOffset) );
    DebugTrace( 0, Dbg, ("Data = %08lx\n", Data) );
    DebugTrace( 0, Dbg, ("Length = %08lx\n", Length) );
    DebugTrace( 0, Dbg, ("SetNewLength = %02lx\n", SetNewLength) );

    //
    //  Calculate the address of the attribute being changed.
    //

    Attribute = (PATTRIBUTE_RECORD_HEADER)((PCHAR)FileRecord + RecordOffset);
    ASSERT( IsQuadAligned( Attribute->RecordLength ) );
    ASSERT( IsQuadAligned( RecordOffset ) );

    //
    //  First, if we are setting a new length, then move the data after the
    //  attribute record and change FirstFreeByte accordingly.
    //

    if (SetNewLength) {

        ULONG NewLength = QuadAlign( AttributeOffset + Length );

        //
        //  If we are shrinking the attribute, we need to move the data
        //  first to support caller's who are shifting data down in the
        //  attribute value, like DeleteFromAttributeList.  If we were
        //  to shrink the record first in this case, we would clobber some
        //  of the data to be moved down.
        //

        if (NewLength < Attribute->RecordLength) {

            //
            //  Now move the new data in and remember we moved it.
            //

            AlreadyMoved = TRUE;

            //
            //  If there is data to modify do so now.
            //

            if (Length != 0) {

                if (ARGUMENT_PRESENT(Data)) {

                    RtlMoveMemory( (PCHAR)Attribute + AttributeOffset, Data, Length );

                } else {

                    RtlZeroMemory( (PCHAR)Attribute + AttributeOffset, Length );
                }
            }
        }

        //
        //  First move the tail of the file record to make/eliminate room.
        //

        RtlMoveMemory( Add2Ptr( Attribute, NewLength ),
                       Add2Ptr( Attribute, Attribute->RecordLength ),
                       FileRecord->FirstFreeByte - RecordOffset - Attribute->RecordLength );

        //
        //  Now update fields to reflect the change.
        //

        FileRecord->FirstFreeByte += (NewLength - Attribute->RecordLength);

        Attribute->RecordLength = NewLength;
        Attribute->Form.Resident.ValueLength =
          (USHORT)(AttributeOffset + Length -
                   (ULONG)Attribute->Form.Resident.ValueOffset);
    }

    //
    //  Now move the new data in.
    //

    if (!AlreadyMoved) {

        if (ARGUMENT_PRESENT(Data)) {

            RtlMoveMemory( Add2Ptr( Attribute, AttributeOffset ),
                           Data,
                           Length );

        } else {

            RtlZeroMemory( Add2Ptr( Attribute, AttributeOffset ),
                           Length );
        }
    }

    DebugTrace( -1, Dbg, ("NtfsRestartChangeValue -> VOID\n") );

    return;
}


//
//  This routine is intended only for RESTART.
//

VOID
NtfsRestartChangeMapping (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN ULONG RecordOffset,
    IN ULONG AttributeOffset,
    IN PVOID Data,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine performs a simple change of an attribute's mapping pairs in a
    file record, without worrying about Bcbs or logging.

Arguments:

    Vcb - Vcb for volume

    FileRecord - File record in which the attribute is to be changed.

    RecordOffset - ByteOffset within the file record at which the attribute starts.

    AttributeOffset - Offset within the attribute record at which mapping is to
                   be changed.

    Data - Pointer to the new mapping.

    Length - Length of the new mapping.

Return Value:

    None

--*/

{
    PATTRIBUTE_RECORD_HEADER Attribute;
    VCN HighestVcn;
    PCHAR MappingPairs;
    ULONG NewLength = QuadAlign( AttributeOffset + Length );

    ASSERT_IRP_CONTEXT( IrpContext );

    UNREFERENCED_PARAMETER( Vcb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsRestartChangeMapping\n") );
    DebugTrace( 0, Dbg, ("FileRecord = %08lx\n", FileRecord) );
    DebugTrace( 0, Dbg, ("RecordOffset = %08lx\n", RecordOffset) );
    DebugTrace( 0, Dbg, ("AttributeOffset = %08lx\n", AttributeOffset) );
    DebugTrace( 0, Dbg, ("Data = %08lx\n", Data) );
    DebugTrace( 0, Dbg, ("Length = %08lx\n", Length) );

    //
    //  Calculate the address of the attribute being changed.
    //

    Attribute = (PATTRIBUTE_RECORD_HEADER)((PCHAR)FileRecord + RecordOffset);
    ASSERT( IsQuadAligned( Attribute->RecordLength ) );
    ASSERT( IsQuadAligned( RecordOffset ) );

    //
    //  First, if we are setting a new length, then move the data after the
    //  attribute record and change FirstFreeByte accordingly.
    //

    //
    //  First move the tail of the file record to make/eliminate room.
    //

    RtlMoveMemory( (PCHAR)Attribute + NewLength,
                   (PCHAR)Attribute + Attribute->RecordLength,
                   FileRecord->FirstFreeByte - RecordOffset -
                     Attribute->RecordLength );

    //
    //  Now update fields to reflect the change.
    //

    FileRecord->FirstFreeByte += NewLength -
                                   Attribute->RecordLength;

    Attribute->RecordLength = NewLength;

    //
    //  Now move the new data in.
    //

    RtlCopyMemory( (PCHAR)Attribute + AttributeOffset, Data, Length );


    //
    //  Finally update HighestVcn and (optionally) AllocatedLength fields.
    //

    MappingPairs = (PCHAR)Attribute + (ULONG)Attribute->Form.Nonresident.MappingPairsOffset;
    HighestVcn = NtfsGetHighestVcn( IrpContext,
                                    Attribute->Form.Nonresident.LowestVcn,
                                    (PCHAR)Attribute + (ULONG)Attribute->RecordLength,
                                    MappingPairs );

    ASSERT( IsCharZero( *MappingPairs ) || HighestVcn != -1 );

    Attribute->Form.Nonresident.HighestVcn = HighestVcn;

    DebugTrace( -1, Dbg, ("NtfsRestartChangeMapping -> VOID\n") );

    return;
}


VOID
NtfsAddToAttributeList (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN MFT_SEGMENT_REFERENCE SegmentReference,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    )

/*++

Routine Description:

    This routine adds an attribute list entry for a newly inserted attribute.
    It is assumed that the context variable is pointing to the attribute
    record in the file record where it has been inserted, and also to the place
    in the attribute list where the new attribute list entry is to be inserted.

Arguments:

    Fcb - Requested file.

    SegmentReference - Segment reference of the file record the new attribute
                       is in.

    Context - Describes the current attribute.

Return Value:

    None

--*/

{
    //
    //  Allocate an attribute list entry which hopefully has enough space
    //  for the name.
    //

    struct {

        ATTRIBUTE_LIST_ENTRY EntryBuffer;

        WCHAR Name[10];

    } NewEntry;

    ATTRIBUTE_ENUMERATION_CONTEXT ListContext;

    ULONG EntrySize;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    PATTRIBUTE_RECORD_HEADER Attribute;
    PATTRIBUTE_LIST_ENTRY ListEntry = &NewEntry.EntryBuffer;
    BOOLEAN SetNewLength = TRUE;

    ULONG EntryOffset;
    ULONG BeyondEntryOffset;

    PAGED_CODE();

    //
    //  First construct the attribute list entry.
    //

    FileRecord = NtfsContainingFileRecord( Context );
    Attribute = NtfsFoundAttribute( Context );
    EntrySize = QuadAlign( FIELD_OFFSET( ATTRIBUTE_LIST_ENTRY, AttributeName )
                           + ((ULONG) Attribute->NameLength << 1));

    //
    //  Allocate the list entry if the one we have is not big enough.
    //

    if (EntrySize > sizeof(NewEntry)) {

        ListEntry = (PATTRIBUTE_LIST_ENTRY)NtfsAllocatePool( NonPagedPool,
                                                              EntrySize );
    }

    RtlZeroMemory( ListEntry, EntrySize );

    NtfsInitializeAttributeContext( &ListContext );

    //
    //  Use try-finally to insure cleanup.
    //

    try {

        ULONG OldQuadAttrListSize;
        PATTRIBUTE_RECORD_HEADER ListAttribute;
        PFILE_RECORD_SEGMENT_HEADER ListFileRecord;

        //
        //  Now fill in the list entry.
        //

        ListEntry->AttributeTypeCode = Attribute->TypeCode;
        ListEntry->RecordLength = (USHORT)EntrySize;
        ListEntry->AttributeNameLength = Attribute->NameLength;
        ListEntry->Instance = Attribute->Instance;
        ListEntry->AttributeNameOffset =
          (UCHAR)PtrOffset( ListEntry, &ListEntry->AttributeName[0] );

        if (Attribute->FormCode == NONRESIDENT_FORM) {

            ListEntry->LowestVcn = Attribute->Form.Nonresident.LowestVcn;
        }

        ASSERT( (Fcb != Fcb->Vcb->MftScb->Fcb) ||
                (Attribute->TypeCode != $DATA) ||
                ((ULONGLONG)(ListEntry->LowestVcn) > (NtfsFullSegmentNumber( &SegmentReference ) >> Fcb->Vcb->MftToClusterShift)) );

        ListEntry->SegmentReference = SegmentReference;

        if (Attribute->NameLength != 0) {

            RtlCopyMemory( &ListEntry->AttributeName[0],
                           Add2Ptr(Attribute, Attribute->NameOffset),
                           Attribute->NameLength << 1 );
        }

        //
        //  Lookup the list context so that we can modify the attribute list.
        //

        if (!NtfsLookupAttributeByCode( IrpContext,
                                        Fcb,
                                        &Fcb->FileReference,
                                        $ATTRIBUTE_LIST,
                                        &ListContext )) {

            ASSERT( FALSE );
            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
        }

        ListAttribute = NtfsFoundAttribute( &ListContext );
        ListFileRecord = NtfsContainingFileRecord( &ListContext );

        OldQuadAttrListSize = ListAttribute->RecordLength;

        //
        //  Remember the relative offsets of list entries.
        //

        EntryOffset = (ULONG) PtrOffset( Context->AttributeList.FirstEntry,
                                         Context->AttributeList.Entry );

        BeyondEntryOffset = (ULONG) PtrOffset( Context->AttributeList.FirstEntry,
                                               Context->AttributeList.BeyondFinalEntry );

        //
        //  If this operation is possibly going to make the attribute list go
        //  non-resident, or else move other attributes around, then we will
        //  reserve the space first in the attribute list and then map the
        //  value.  Note that some of the entries we need to shift up may
        //  be modified as a side effect of making space!
        //

        if (NtfsIsAttributeResident( ListAttribute ) &&
            (ListFileRecord->BytesAvailable - ListFileRecord->FirstFreeByte) < EntrySize) {

            ULONG Length;

            //
            //  Add enough zeros to the end of the attribute to accommodate
            //  the new attribute list entry.
            //

            NtfsChangeAttributeValue( IrpContext,
                                      Fcb,
                                      BeyondEntryOffset,
                                      NULL,
                                      EntrySize,
                                      TRUE,
                                      TRUE,
                                      FALSE,
                                      TRUE,
                                      &ListContext );

            //
            //  We now don't have to set the new length.
            //

            SetNewLength = FALSE;

            //
            //  In case the attribute list went non-resident on this call, then we
            //  need to update both list entry pointers in the found attribute.
            //  (We do this "just in case" all the time to avoid a rare code path.)
            //

            //
            //  Map the non-resident attribute list.
            //

            NtfsMapAttributeValue( IrpContext,
                                   Fcb,
                                   (PVOID *) &Context->AttributeList.FirstEntry,
                                   &Length,
                                   &Context->AttributeList.NonresidentListBcb,
                                   &ListContext );

            //
            //  If the list is still resident then unpin the current Bcb in
            //  the original context to keep our pin counts in sync.
            //

            if (Context->AttributeList.Bcb == Context->AttributeList.NonresidentListBcb) {

                NtfsUnpinBcb( IrpContext, &Context->AttributeList.NonresidentListBcb );
            }

            Context->AttributeList.Entry = Add2Ptr( Context->AttributeList.FirstEntry,
                                                    EntryOffset );

            Context->AttributeList.BeyondFinalEntry = Add2Ptr( Context->AttributeList.FirstEntry,
                                                               BeyondEntryOffset );
        }

        //
        //  Check for adding duplicate entries...
        //

        ASSERT(
                //  Not enough room for previous entry to = inserted entry
                ((EntryOffset < EntrySize) ||
                //  Previous entry doesn't equal inserted entry
                 (!RtlEqualMemory((PVOID)((PCHAR)Context->AttributeList.Entry - EntrySize),
                                  ListEntry,
                                  EntrySize)))

                    &&

                //  At end of attribute list
                ((BeyondEntryOffset == EntryOffset) ||
                //  This entry doesn't equal inserted entry
                 (!RtlEqualMemory(Context->AttributeList.Entry,
                                  ListEntry,
                                  EntrySize))) );

        //
        //  Now shift the old contents up to make room for our new entry.  We don't let
        //  the attribute list grow larger than a cache view however.
        //

        if (EntrySize + BeyondEntryOffset > VACB_MAPPING_GRANULARITY) {

            NtfsRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES, NULL, NULL );
        }

        NtfsChangeAttributeValue( IrpContext,
                                  Fcb,
                                  EntryOffset + EntrySize,
                                  Context->AttributeList.Entry,
                                  BeyondEntryOffset - EntryOffset,
                                  SetNewLength,
                                  TRUE,
                                  FALSE,
                                  TRUE,
                                  &ListContext );
        //
        //  Now write in the new entry.
        //

        NtfsChangeAttributeValue( IrpContext,
                                  Fcb,
                                  EntryOffset,
                                  (PVOID)ListEntry,
                                  EntrySize,
                                  FALSE,
                                  TRUE,
                                  FALSE,
                                  FALSE,
                                  &ListContext );

        //
        //  Reload the attribute list values from the list context.
        //

        ListAttribute = NtfsFoundAttribute( &ListContext );

        //
        //  Now fix up the context for return
        //

        if (*(PLONGLONG)&FileRecord->BaseFileRecordSegment == 0) {

            //
            //  We need to update the attribute pointer for the target attribute
            //  by the amount of the change in the attribute list attribute.
            //

            Context->FoundAttribute.Attribute =
              Add2Ptr( Context->FoundAttribute.Attribute,
                       ListAttribute->RecordLength - OldQuadAttrListSize );
        }

        Context->AttributeList.BeyondFinalEntry =
          Add2Ptr( Context->AttributeList.BeyondFinalEntry, EntrySize );

#if DBG
{
    PATTRIBUTE_LIST_ENTRY LastEntry, Entry;

    for (LastEntry = Context->AttributeList.FirstEntry, Entry = NtfsGetNextRecord(LastEntry);
         Entry < Context->AttributeList.BeyondFinalEntry;
         LastEntry = Entry, Entry = NtfsGetNextRecord(LastEntry)) {

        ASSERT( (LastEntry->RecordLength != Entry->RecordLength) ||
                (!RtlEqualMemory(LastEntry, Entry, Entry->RecordLength)) );
    }
}
#endif

    } finally {

        //
        //  If we had to allocate a list entry buffer, deallocate it.
        //

        if (ListEntry != &NewEntry.EntryBuffer) {

            NtfsFreePool(ListEntry);
        }

        //
        //  Cleanup the enumeration context for the list entry.
        //

        NtfsCleanupAttributeContext( IrpContext, &ListContext);
    }
}


VOID
NtfsDeleteFromAttributeList (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    )

/*++

Routine Description:

    This routine deletes an attribute list entry for a recently deleted attribute.
    It is assumed that the context variable is pointing to the place in
    the attribute list where the attribute list entry is to be deleted.

Arguments:

    Fcb - Requested file.

    Context - Describes the current attribute.

Return Value:

    None

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT ListContext;

    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    PATTRIBUTE_LIST_ENTRY ListEntry, NextListEntry;
    ULONG EntrySize;

    ULONG SavedListSize;

    PAGED_CODE();

    FileRecord = NtfsContainingFileRecord( Context );

    //
    //  Lookup the list context so that we can modify the attribute list.
    //

    NtfsInitializeAttributeContext( &ListContext );

    if (!NtfsLookupAttributeByCode( IrpContext,
                                    Fcb,
                                    &Fcb->FileReference,
                                    $ATTRIBUTE_LIST,
                                    &ListContext )) {

        ASSERT( FALSE );
        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
    }

    //
    //  Use try-finally to insure cleanup.
    //

    try {

        SavedListSize = NtfsFoundAttribute(&ListContext)->RecordLength;

        //
        //  Now shift the old contents down to make room for our new entry.
        //

        ListEntry = Context->AttributeList.Entry;
        EntrySize = ListEntry->RecordLength;
        NextListEntry = Add2Ptr(ListEntry, EntrySize);
        NtfsChangeAttributeValue( IrpContext,
                                  Fcb,
                                  PtrOffset( Context->AttributeList.FirstEntry,
                                             Context->AttributeList.Entry ),
                                  NextListEntry,
                                  PtrOffset( NextListEntry,
                                             Context->AttributeList.BeyondFinalEntry ),
                                  TRUE,
                                  TRUE,
                                  FALSE,
                                  TRUE,
                                  &ListContext );

        //
        //  Now fix up the context for return
        //

        if (*(PLONGLONG)&FileRecord->BaseFileRecordSegment == 0) {

            SavedListSize -= NtfsFoundAttribute(&ListContext)->RecordLength;
            Context->FoundAttribute.Attribute =
              Add2Ptr( Context->FoundAttribute.Attribute, -(LONG)SavedListSize );
        }

        Context->AttributeList.BeyondFinalEntry =
          Add2Ptr( Context->AttributeList.BeyondFinalEntry, -(LONG)EntrySize );

    } finally {

        //
        //  Cleanup the enumeration context for the list entry.
        //

        NtfsCleanupAttributeContext( IrpContext, &ListContext );
    }
}


BOOLEAN
NtfsRewriteMftMapping (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine is called to rewrite the mapping for the Mft file.  This is done
    in the case where either hot-fixing or Mft defragging has caused us to spill
    into the reserved area of a file record.  This routine will rewrite the
    mapping from the beginning, using the reserved record if necessary.  On return
    it will indicate whether any work was done and if there is more work to do.

Arguments:

    Vcb - This is the Vcb for the volume to defrag.

    ExcessMapping - Address to store whether there is still excess mapping in
        the file.

Return Value:

    BOOLEAN - TRUE if we made any changes to the file.  FALSE if we found no
        work to do.

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;

    PUCHAR MappingPairs = NULL;
    PBCB FileRecordBcb = NULL;

    BOOLEAN MadeChanges = FALSE;
    BOOLEAN ExcessMapping = FALSE;
    BOOLEAN LastFileRecord = FALSE;
    BOOLEAN SkipLookup = FALSE;

    PAGED_CODE();

    NtfsInitializeAttributeContext( &AttrContext );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        VCN CurrentVcn;             //  Starting Vcn for the next file record
        VCN MinimumVcn;             //  This Vcn must be in the current mapping
        VCN LastVcn;                //  Last Vcn in the current mapping
        VCN LastMftVcn;             //  Last Vcn in the file
        VCN NextVcn;                //  First Vcn past the end of the mapping

        ULONG ReservedIndex;        //  Reserved index in Mft
        ULONG NextIndex;            //  Next file record available for Mft mapping

        PFILE_RECORD_SEGMENT_HEADER FileRecord;
        MFT_SEGMENT_REFERENCE FileRecordReference;
        ULONG RecordOffset;

        PATTRIBUTE_RECORD_HEADER Attribute;
        ULONG AttributeOffset;

        ULONG MappingSizeAvailable;
        ULONG MappingPairsSize;

        //
        //  Find the initial file record for the Mft.
        //

        NtfsLookupAttributeForScb( IrpContext, Vcb->MftScb, NULL, &AttrContext );

        //
        //  Compute some initial values.  If this is the only file record
        //  for the file then we are done.
        //

        ReservedIndex = Vcb->MftScb->ScbType.Mft.ReservedIndex;

        Attribute = NtfsFoundAttribute( &AttrContext );

        LastMftVcn = Int64ShraMod32(Vcb->MftScb->Header.AllocationSize.QuadPart, Vcb->ClusterShift) - 1;

        CurrentVcn = Attribute->Form.Nonresident.HighestVcn + 1;

        if (CurrentVcn >= LastMftVcn) {

            try_return( NOTHING );
        }

        //
        //  Loop while there are more file records.  We will insert any
        //  additional file records needed within the loop so that this
        //  call should succeed until the remapping is done.
        //

        while (SkipLookup ||
               NtfsLookupNextAttributeForScb( IrpContext,
                                              Vcb->MftScb,
                                              &AttrContext )) {

            BOOLEAN ReplaceFileRecord;
            BOOLEAN ReplaceAttributeListEntry;

            ReplaceAttributeListEntry = FALSE;

            //
            //  If we just looked up this entry then pin the current
            //  attribute.
            //

            if (!SkipLookup) {

                //
                //  Always pin the current attribute.
                //

                NtfsPinMappedAttribute( IrpContext,
                                        Vcb,
                                        &AttrContext );
            }

            //
            //  Extract some pointers from the current file record.
            //  Remember if this was the last record.
            //

            ReplaceFileRecord = FALSE;

            FileRecord = NtfsContainingFileRecord( &AttrContext );
            FileRecordReference = AttrContext.AttributeList.Entry->SegmentReference;

            Attribute = NtfsFoundAttribute( &AttrContext );
            AttributeOffset = Attribute->Form.Nonresident.MappingPairsOffset;

            RecordOffset = PtrOffset( FileRecord, Attribute );

            //
            //  Remember if we are at the last attribute.
            //

            if (Attribute->Form.Nonresident.HighestVcn == LastMftVcn) {

                LastFileRecord = TRUE;
            }

            //
            //  If we have already remapped this entire file record then
            //  remove the attribute and it list entry.
            //

            if (!SkipLookup &&
                (CurrentVcn > LastMftVcn)) {

                PATTRIBUTE_LIST_ENTRY ListEntry;
                ULONG Count;

                Count = 0;

                //
                //  We want to remove this entry and all subsequent entries.
                //

                ListEntry = AttrContext.AttributeList.Entry;

                while ((ListEntry != AttrContext.AttributeList.BeyondFinalEntry) &&
                       (ListEntry->AttributeTypeCode == $DATA) &&
                       (ListEntry->AttributeNameLength == 0)) {

                    Count += 1;

                    NtfsDeallocateMftRecord( IrpContext,
                                             Vcb,
                                             NtfsUnsafeSegmentNumber( &ListEntry->SegmentReference ) );

                    NtfsDeleteFromAttributeList( IrpContext,
                                                 Vcb->MftScb->Fcb,
                                                 &AttrContext );

                    ListEntry = AttrContext.AttributeList.Entry;
                }

                //
                //  Clear out the reserved index in case one of these
                //  will do.
                //

                NtfsAcquireCheckpoint( IrpContext, Vcb );

                ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_MFT_REC_RESERVED );
                ClearFlag( Vcb->MftReserveFlags, VCB_MFT_RECORD_RESERVED );

                NtfsReleaseCheckpoint( IrpContext, Vcb );

                Vcb->MftScb->ScbType.Mft.ReservedIndex = 0;
                try_return( NOTHING );
            }

            //
            //  Check if we are going to replace this file record with
            //  the reserved record.
            //

            if (ReservedIndex < NtfsSegmentNumber( &FileRecordReference )) {

                PATTRIBUTE_RECORD_HEADER NewAttribute;
                PATTRIBUTE_TYPE_CODE NewEnd;

                //
                //  Remember this index for our computation for the Minimum mapped
                //  Vcn.
                //

                NextIndex = NtfsUnsafeSegmentNumber( &FileRecordReference );

                FileRecord = NtfsCloneFileRecord( IrpContext,
                                                  Vcb->MftScb->Fcb,
                                                  TRUE,
                                                  &FileRecordBcb,
                                                  &FileRecordReference );

                ReservedIndex = MAXULONG;

                //
                //  Now lets create an attribute in the new file record.
                //

                NewAttribute = Add2Ptr( FileRecord,
                                        FileRecord->FirstFreeByte
                                        - QuadAlign( sizeof( ATTRIBUTE_TYPE_CODE )));

                NewAttribute->TypeCode = Attribute->TypeCode;
                NewAttribute->RecordLength = SIZEOF_PARTIAL_NONRES_ATTR_HEADER;
                NewAttribute->FormCode = NONRESIDENT_FORM;
                NewAttribute->Flags = Attribute->Flags;
                NewAttribute->Instance = FileRecord->NextAttributeInstance++;

                NewAttribute->Form.Nonresident.LowestVcn = CurrentVcn;
                NewAttribute->Form.Nonresident.HighestVcn = 0;
                NewAttribute->Form.Nonresident.MappingPairsOffset = (USHORT) NewAttribute->RecordLength;

                NewEnd = Add2Ptr( NewAttribute, NewAttribute->RecordLength );
                *NewEnd = $END;

                //
                //  Now fix up the file record with this new data.
                //

                FileRecord->FirstFreeByte = PtrOffset( FileRecord, NewEnd )
                                            + QuadAlign( sizeof( ATTRIBUTE_TYPE_CODE ));

                FileRecord->SequenceNumber += 1;

                if (FileRecord->SequenceNumber == 0) {

                    FileRecord->SequenceNumber = 1;
                }

                FileRecordReference.SequenceNumber = FileRecord->SequenceNumber;

                //
                //  Now switch this new file record into the attribute context.
                //

                NtfsUnpinBcb( IrpContext, &NtfsFoundBcb( &AttrContext ));

                NtfsFoundBcb( &AttrContext ) = FileRecordBcb;
                AttrContext.FoundAttribute.MftFileOffset = LlBytesFromFileRecords( Vcb, NextIndex );
                AttrContext.FoundAttribute.Attribute = NewAttribute;
                AttrContext.FoundAttribute.FileRecord = FileRecord;

                FileRecordBcb = NULL;

                //
                //  Now add an attribute list entry for this entry.
                //

                NtfsAddToAttributeList( IrpContext,
                                        Vcb->MftScb->Fcb,
                                        FileRecordReference,
                                        &AttrContext );

                //
                //  Reload our pointers for this file record.
                //

                Attribute = NewAttribute;
                AttributeOffset = SIZEOF_PARTIAL_NONRES_ATTR_HEADER;

                RecordOffset = PtrOffset( FileRecord, Attribute );

                //
                //  We must include either the last Vcn of the file or
                //  the Vcn for the next file record to use for the Mft.
                //  At this point MinimumVcn is the first Vcn that doesn't
                //  have to be in the current mapping.
                //

                if (Vcb->FileRecordsPerCluster == 0) {

                    MinimumVcn = (NextIndex + 1) << Vcb->MftToClusterShift;

                } else {

                    MinimumVcn = (NextIndex + Vcb->FileRecordsPerCluster - 1) << Vcb->MftToClusterShift;
                }

                ReplaceFileRecord = TRUE;

            //
            //  We will be using the current attribute.
            //

            } else {

                //
                //  The mapping we write into this page must go
                //  to the current end of the page or to the reserved
                //  or spare file record, whichever is earlier.
                //  If we are adding the reserved record to the end then
                //  we know the final Vcn already.
                //

                if (SkipLookup) {

                    NextVcn = LastMftVcn;

                } else {

                    NextVcn = Attribute->Form.Nonresident.HighestVcn;
                }

                if (Vcb->FileRecordsPerCluster == 0) {

                    NextIndex = (ULONG)Int64ShraMod32((NextVcn + 1), Vcb->MftToClusterShift);

                } else {

                    NextIndex = (ULONG)Int64ShllMod32((NextVcn + 1), Vcb->MftToClusterShift);
                }

                if (ReservedIndex < NextIndex) {

                    NextIndex = ReservedIndex + 1;
                    ReplaceFileRecord = TRUE;
                }

                //
                //  If we can use this file record unchanged then continue on.
                //  Start by checking that it starts on the same Vcn boundary.
                //

                if (!SkipLookup) {

                    //
                    //  If it starts on the same boundary then we check if we
                    //  can do any work with this.
                    //

                    if (CurrentVcn == Attribute->Form.Nonresident.LowestVcn) {

                        ULONG RemainingFileRecordBytes;

                        RemainingFileRecordBytes = FileRecord->BytesAvailable - FileRecord->FirstFreeByte;

                        //
                        //  Check if we have less than the desired cushion
                        //  left.
                        //

                        if (RemainingFileRecordBytes < Vcb->MftCushion) {

                            //
                            //  If we have no more file records there is no
                            //  remapping we can do.
                            //

                            if (!ReplaceFileRecord) {

                                //
                                //  Remember if we used part of the reserved
                                //  portion of the file record.
                                //

                                if (RemainingFileRecordBytes < Vcb->MftReserved) {

                                    ExcessMapping = TRUE;
                                }

                                CurrentVcn = Attribute->Form.Nonresident.HighestVcn + 1;
                                continue;
                            }
                        //
                        //  We have more than our cushion left.  If this
                        //  is the last file record we will skip this.
                        //

                        } else if (Attribute->Form.Nonresident.HighestVcn == LastMftVcn) {

                            CurrentVcn = Attribute->Form.Nonresident.HighestVcn + 1;
                            continue;
                        }

                    //
                    //  If it doesn't start on the same boundary then we have to
                    //  delete and reinsert the attribute list entry.
                    //

                    } else {

                        ReplaceAttributeListEntry = TRUE;
                    }
                }

                ReplaceFileRecord = FALSE;

                //
                //  Log the beginning state of this file record.
                //

                NtfsLogMftFileRecord( IrpContext,
                                      Vcb,
                                      FileRecord,
                                      LlBytesFromFileRecords( Vcb, NtfsSegmentNumber( &FileRecordReference ) ),
                                      NtfsFoundBcb( &AttrContext ),
                                      FALSE );

                //
                //  Compute the Vcn for the file record past the one we will use
                //  next.  At this point this is the first Vcn that doesn't have
                //  to be in the current mapping.
                //

                if (Vcb->FileRecordsPerCluster == 0) {

                    MinimumVcn = NextIndex << Vcb->MftToClusterShift;

                } else {

                    MinimumVcn = (NextIndex + Vcb->FileRecordsPerCluster - 1) << Vcb->MftToClusterShift;
                }
            }

            //
            //  Move back one vcn to adhere to the mapping pairs interface.
            //  This is now the last Vcn which MUST appear in the current
            //  mapping.
            //

            MinimumVcn = MinimumVcn - 1;

            //
            //  Get the available size for the mapping pairs.  We won't
            //  include the cushion here.
            //

            MappingSizeAvailable = FileRecord->BytesAvailable + Attribute->RecordLength - FileRecord->FirstFreeByte - SIZEOF_PARTIAL_NONRES_ATTR_HEADER;

            //
            //  We know the range of Vcn's the mapping must cover.
            //  Compute the mapping pair size.  If they won't fit and
            //  leave our desired cushion then use whatever space is
            //  needed.  The NextVcn value is the first Vcn (or xxMax)
            //  for the run after the last run in the current mapping.
            //

            MappingPairsSize = NtfsGetSizeForMappingPairs( &Vcb->MftScb->Mcb,
                                                           MappingSizeAvailable - Vcb->MftCushion,
                                                           CurrentVcn,
                                                           NULL,
                                                           &NextVcn );

            //
            //  If this mapping doesn't include the file record we will
            //  be using next then extend the mapping to include it.
            //

            if (NextVcn <= MinimumVcn) {

                //
                //  Compute the mapping pairs again.  This must fit
                //  since it already fits.
                //

                MappingPairsSize = NtfsGetSizeForMappingPairs( &Vcb->MftScb->Mcb,
                                                               MappingSizeAvailable,
                                                               CurrentVcn,
                                                               &MinimumVcn,
                                                               &NextVcn );

                //
                //  Remember if we still have excess mapping.
                //

                if (MappingSizeAvailable - MappingPairsSize < Vcb->MftReserved) {

                    ExcessMapping = TRUE;
                }
            }

            //
            //  Remember the last Vcn for the current run.  If the NextVcn
            //  is xxMax then we are at the end of the file.
            //

            if (NextVcn == MAXLONGLONG) {

                LastVcn = LastMftVcn;

            //
            //  Otherwise it is one less than the next vcn value.
            //

            } else {

                LastVcn = NextVcn - 1;
            }

            //
            //  Check if we have to rewrite this attribute.  We will write the
            //  new mapping if any of the following are true.
            //
            //      We are replacing a file record
            //      The attribute's LowestVcn doesn't match
            //      The attributes's HighestVcn doesn't match.
            //

            if (ReplaceFileRecord ||
                (CurrentVcn != Attribute->Form.Nonresident.LowestVcn) ||
                (LastVcn != Attribute->Form.Nonresident.HighestVcn )) {

                Attribute->Form.Nonresident.LowestVcn = CurrentVcn;

                //
                //  Replace the attribute list entry at this point if needed.
                //

                if (ReplaceAttributeListEntry) {

                    NtfsDeleteFromAttributeList( IrpContext,
                                                 Vcb->MftScb->Fcb,
                                                 &AttrContext );

                    NtfsAddToAttributeList( IrpContext,
                                            Vcb->MftScb->Fcb,
                                            FileRecordReference,
                                            &AttrContext );
                }

                //
                //  Allocate a buffer for the mapping pairs if we haven't
                //  done so.
                //

                if (MappingPairs == NULL) {

                    MappingPairs = NtfsAllocatePool(PagedPool, NtfsMaximumAttributeSize( Vcb->BytesPerFileRecordSegment ));
                }

                NtfsBuildMappingPairs( &Vcb->MftScb->Mcb,
                                       CurrentVcn,
                                       &NextVcn,
                                       MappingPairs );

                Attribute->Form.Nonresident.HighestVcn = NextVcn;

                NtfsRestartChangeMapping( IrpContext,
                                          Vcb,
                                          FileRecord,
                                          RecordOffset,
                                          AttributeOffset,
                                          MappingPairs,
                                          MappingPairsSize );

                //
                //  Log the changes to this page.
                //

                NtfsLogMftFileRecord( IrpContext,
                                      Vcb,
                                      FileRecord,
                                      LlBytesFromFileRecords( Vcb, NtfsSegmentNumber( &FileRecordReference ) ),
                                      NtfsFoundBcb( &AttrContext ),
                                      TRUE );

                MadeChanges = TRUE;
            }

            //
            //  Move to the first Vcn of the following record.
            //

            CurrentVcn = Attribute->Form.Nonresident.HighestVcn + 1;

            //
            //  If we reached the last file record and have more mapping to do
            //  then use the reserved record.  It must be available or we would
            //  have written out the entire mapping.
            //

            if (LastFileRecord && (CurrentVcn < LastMftVcn)) {

                PATTRIBUTE_RECORD_HEADER NewAttribute;
                PATTRIBUTE_TYPE_CODE NewEnd;

                //
                //  Start by moving to the next file record.  It better not be
                //  there or the file is corrupt.  This will position us to
                //  insert the new record.
                //

                if (NtfsLookupNextAttributeForScb( IrpContext,
                                                   Vcb->MftScb,
                                                   &AttrContext )) {

                    NtfsAcquireCheckpoint( IrpContext, Vcb );
                    ClearFlag( Vcb->MftDefragState, VCB_MFT_DEFRAG_PERMITTED );
                    NtfsReleaseCheckpoint( IrpContext, Vcb );

                    NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Vcb->MftScb->Fcb );
                }

                FileRecord = NtfsCloneFileRecord( IrpContext,
                                                  Vcb->MftScb->Fcb,
                                                  TRUE,
                                                  &FileRecordBcb,
                                                  &FileRecordReference );

                ReservedIndex = MAXULONG;

                //
                //  Now lets create an attribute in the new file record.
                //

                NewAttribute = Add2Ptr( FileRecord,
                                        FileRecord->FirstFreeByte
                                        - QuadAlign( sizeof( ATTRIBUTE_TYPE_CODE )));

                NewAttribute->TypeCode = Attribute->TypeCode;
                NewAttribute->RecordLength = SIZEOF_PARTIAL_NONRES_ATTR_HEADER;
                NewAttribute->FormCode = NONRESIDENT_FORM;
                NewAttribute->Flags = Attribute->Flags;
                NewAttribute->Instance = FileRecord->NextAttributeInstance++;

                NewAttribute->Form.Nonresident.LowestVcn = CurrentVcn;
                NewAttribute->Form.Nonresident.HighestVcn = 0;
                NewAttribute->Form.Nonresident.MappingPairsOffset = (USHORT) NewAttribute->RecordLength;

                NewEnd = Add2Ptr( NewAttribute, NewAttribute->RecordLength );
                *NewEnd = $END;

                //
                //  Now fix up the file record with this new data.
                //

                FileRecord->FirstFreeByte = PtrOffset( FileRecord, NewEnd )
                                            + QuadAlign( sizeof( ATTRIBUTE_TYPE_CODE ));

                FileRecord->SequenceNumber += 1;

                if (FileRecord->SequenceNumber == 0) {

                    FileRecord->SequenceNumber = 1;
                }

                FileRecordReference.SequenceNumber = FileRecord->SequenceNumber;

                //
                //  Now switch this new file record into the attribute context.
                //

                NtfsUnpinBcb( IrpContext, &NtfsFoundBcb( &AttrContext ));

                NtfsFoundBcb( &AttrContext ) = FileRecordBcb;
                AttrContext.FoundAttribute.MftFileOffset =
                    LlBytesFromFileRecords( Vcb, NtfsSegmentNumber( &FileRecordReference ) );
                AttrContext.FoundAttribute.Attribute = NewAttribute;
                AttrContext.FoundAttribute.FileRecord = FileRecord;

                FileRecordBcb = NULL;

                //
                //  Now add an attribute list entry for this entry.
                //

                NtfsAddToAttributeList( IrpContext,
                                        Vcb->MftScb->Fcb,
                                        FileRecordReference,
                                        &AttrContext );

                SkipLookup = TRUE;
                LastFileRecord = FALSE;

            } else {

                SkipLookup = FALSE;
            }

        } // End while more file records

        //
        //  If we didn't rewrite all of the mapping then there is some error.
        //

        if (CurrentVcn <= LastMftVcn) {

            NtfsAcquireCheckpoint( IrpContext, Vcb );
            ClearFlag( Vcb->MftDefragState, VCB_MFT_DEFRAG_PERMITTED );
            NtfsReleaseCheckpoint( IrpContext, Vcb );

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Vcb->MftScb->Fcb );
        }

    try_exit:  NOTHING;

        //
        //  Clear the excess mapping flag if no changes were made.
        //

        if (!ExcessMapping) {

            NtfsAcquireCheckpoint( IrpContext, Vcb );
            ClearFlag( Vcb->MftDefragState, VCB_MFT_DEFRAG_EXCESS_MAP );
            NtfsReleaseCheckpoint( IrpContext, Vcb );
        }

    } finally {

        DebugUnwind( NtfsRewriteMftMapping );

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );

        NtfsUnpinBcb( IrpContext, &FileRecordBcb );

        if (MappingPairs != NULL) {

            NtfsFreePool( MappingPairs );
        }
    }

    return MadeChanges;
}


VOID
NtfsSetTotalAllocatedField (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN USHORT TotalAllocatedNeeded
    )

/*++

Routine Description:

    This routine is called to insure that first attribute of a stream has
    the correct size attribute header based on the compression state of the
    file.  Compressed streams will have a field for the total allocated space
    in the file in the nonresident header.

    This routine will see if the header is in a valid state and make space
    if necessary.  Then it will rewrite any of the attribute data after
    the header.

Arguments:

    Scb - Scb for affected stream

    TotalAllocatedPresent - 0 if the TotalAllocated field not needed (this would
        be an uncompressed, non-sparse file), nonzero if the TotalAllocated field
        is needed.

Return Value:

    None.

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    PATTRIBUTE_RECORD_HEADER Attribute;
    PATTRIBUTE_RECORD_HEADER NewAttribute = NULL;
    PUNICODE_STRING NewAttributeName = NULL;

    ULONG OldHeaderSize;
    ULONG NewHeaderSize;

    LONG SizeChange;

    PAGED_CODE();

    //
    //  This must be a non-resident user data file.
    //

    if (!NtfsIsTypeCodeUserData( Scb->AttributeTypeCode ) ||
        FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

        return;
    }

    NtfsInitializeAttributeContext( &AttrContext );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        while (TRUE) {

            //
            //  Find the current and the new size for the attribute.
            //

            NtfsLookupAttributeForScb( IrpContext, Scb, NULL, &AttrContext );

            FileRecord = NtfsContainingFileRecord( &AttrContext );
            Attribute = NtfsFoundAttribute( &AttrContext );

            OldHeaderSize = Attribute->Form.Nonresident.MappingPairsOffset;

            if (Attribute->NameOffset != 0) {

                OldHeaderSize = Attribute->NameOffset;
            }

            if (TotalAllocatedNeeded) {

                NewHeaderSize = SIZEOF_FULL_NONRES_ATTR_HEADER;

            } else {

                NewHeaderSize = SIZEOF_PARTIAL_NONRES_ATTR_HEADER;
            }

            SizeChange = NewHeaderSize - OldHeaderSize;

            //
            //  Make space if we need to do so.  Lookup the attribute again
            //  if necessary.
            //

            if (SizeChange > 0) {

                VCN StartingVcn;
                VCN ClusterCount;

                //
                //  If the attribute is alone in the file record and there isn't
                //  enough space available then the call to ChangeAttributeSize
                //  can't make any space available.  In that case we call
                //  NtfsChangeAttributeAllocation and let that routine rewrite
                //  the mapping to make space available.
                //

                if ((FileRecord->BytesAvailable - FileRecord->FirstFreeByte < (ULONG) SizeChange) &&
                    (NtfsFirstAttribute( FileRecord ) == Attribute) &&
                    (((PATTRIBUTE_RECORD_HEADER) NtfsGetNextRecord( Attribute ))->TypeCode == $END)) {

                    NtfsLookupAllocation( IrpContext,
                                          Scb,
                                          Attribute->Form.Nonresident.HighestVcn,
                                          &StartingVcn,
                                          &ClusterCount,
                                          NULL,
                                          NULL );

                    StartingVcn = 0;
                    ClusterCount = Attribute->Form.Nonresident.HighestVcn + 1;

                    NtfsAddAttributeAllocation( IrpContext,
                                                Scb,
                                                &AttrContext,
                                                &StartingVcn,
                                                &ClusterCount );

                } else if (NtfsChangeAttributeSize( IrpContext,
                                                    Scb->Fcb,
                                                    Attribute->RecordLength + SizeChange,
                                                    &AttrContext)) {

                    break;
                }

                NtfsCleanupAttributeContext( IrpContext, &AttrContext );
                NtfsInitializeAttributeContext( &AttrContext );
                continue;
            }

            break;
        }

        NtfsPinMappedAttribute( IrpContext, Scb->Vcb, &AttrContext );

        //
        //  Make a copy of the existing attribute and modify the total allocated field
        //  if necessary.
        //

        NewAttribute = NtfsAllocatePool( PagedPool, Attribute->RecordLength + SizeChange );

        RtlCopyMemory( NewAttribute,
                       Attribute,
                       SIZEOF_PARTIAL_NONRES_ATTR_HEADER );

        if (Attribute->NameOffset != 0) {

            NewAttribute->NameOffset += (USHORT) SizeChange;
            NewAttributeName = &Scb->AttributeName;

            RtlCopyMemory( Add2Ptr( NewAttribute, NewAttribute->NameOffset ),
                           NewAttributeName->Buffer,
                           NewAttributeName->Length );
        }

        NewAttribute->Form.Nonresident.MappingPairsOffset += (USHORT) SizeChange;
        NewAttribute->RecordLength += SizeChange;

        RtlCopyMemory( Add2Ptr( NewAttribute, NewAttribute->Form.Nonresident.MappingPairsOffset ),
                       Add2Ptr( Attribute, Attribute->Form.Nonresident.MappingPairsOffset ),
                       Attribute->RecordLength - Attribute->Form.Nonresident.MappingPairsOffset );

        if (TotalAllocatedNeeded) {

            NewAttribute->Form.Nonresident.TotalAllocated = Scb->TotalAllocated;
        }

        //
        //  We now have the before and after image to log.
        //

        FileRecord->Lsn =
        NtfsWriteLog( IrpContext,
                      Scb->Vcb->MftScb,
                      NtfsFoundBcb( &AttrContext ),
                      DeleteAttribute,
                      NULL,
                      0,
                      CreateAttribute,
                      Attribute,
                      Attribute->RecordLength,
                      NtfsMftOffset( &AttrContext ),
                      PtrOffset( FileRecord, Attribute ),
                      0,
                      Scb->Vcb->BytesPerFileRecordSegment );

        NtfsRestartRemoveAttribute( IrpContext, FileRecord, PtrOffset( FileRecord, Attribute ));

        FileRecord->Lsn =
        NtfsWriteLog( IrpContext,
                      Scb->Vcb->MftScb,
                      NtfsFoundBcb( &AttrContext ),
                      CreateAttribute,
                      NewAttribute,
                      NewAttribute->RecordLength,
                      DeleteAttribute,
                      NULL,
                      0,
                      NtfsMftOffset( &AttrContext ),
                      PtrOffset( FileRecord, Attribute ),
                      0,
                      Scb->Vcb->BytesPerFileRecordSegment );

        NtfsRestartInsertAttribute( IrpContext,
                                    FileRecord,
                                    PtrOffset( FileRecord, Attribute ),
                                    NewAttribute,
                                    NewAttributeName,
                                    Add2Ptr( NewAttribute, NewAttribute->Form.Nonresident.MappingPairsOffset ),
                                    NewAttribute->RecordLength - NewAttribute->Form.Nonresident.MappingPairsOffset );

    } finally {

        DebugUnwind( NtfsSetTotalAllocatedField );

        if (NewAttribute != NULL) {

            NtfsFreePool( NewAttribute );
        }

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );
    }

    return;
}


VOID
NtfsSetSparseStream (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ParentScb OPTIONAL,
    IN PSCB Scb
    )

/*++

Routine Description:

    This routine is called change the state of a stream to sparse.  It may be
    called on behalf of a user or internally to Ntfs (i.e. for the USN
    journal).  Our caller may already have begun a transaction but in any
    case will have acquired the main resource and paging resource for the
    stream exclusively.

    This routine will add the TotalAllocated field to the non-resident attribute
    header and fully allocate (or deallocate) the final compression unit of
    the stream.  It will set the SPARSE flag in the attribute header as well as
    in standard information and the directory entry for this stream.

    NOTE - This routine will checkpoint the current transaction in order
    to safely change the compression unit size and shift value in the Scb.
    We also will update the Fcb duplicate information which is not protected
    under transaction control.

Arguments:

    ParentScb - Scb for the parent.  If present we will update the directory
        entry for the parent.  Otherwise we simply set the FcbInfo flags and
        let the update happen when the handle is closed.

    Scb - Scb for the stream.  Caller should have acquired this already.

Return Value:

    None.

--*/

{
    PFCB Fcb = Scb->Fcb;
    PVCB Vcb = Scb->Vcb;
    PLCB Lcb;

    ULONG OriginalFileAttributes;
    USHORT OriginalStreamAttributes;
    UCHAR OriginalCompressionUnitShift;
    ULONG OriginalCompressionUnit;
    LONGLONG OriginalFileAllocatedLength;

    UCHAR NewCompressionUnitShift;
    ULONG NewCompressionUnit;

    LONGLONG StartVcn;
    LONGLONG FinalVcn;

    ULONG AttributeSizeChange;
    PATTRIBUTE_RECORD_HEADER Attribute;
    ATTRIBUTE_RECORD_HEADER NewAttribute;
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;

    ASSERT( (Scb->Header.PagingIoResource == NULL) ||
            ExIsResourceAcquiredExclusiveLite( Scb->Header.PagingIoResource ));
    ASSERT_EXCLUSIVE_SCB( Scb );
    ASSERT( NtfsIsTypeCodeCompressible( Scb->AttributeTypeCode ));

    PAGED_CODE();

    //
    //  Return immediately if the stream is already sparse.
    //

    if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

        return;
    }

    //
    //  Remember the current compression unit and flags.
    //

    OriginalFileAttributes = Fcb->Info.FileAttributes;
    OriginalStreamAttributes = Scb->AttributeFlags;
    OriginalCompressionUnitShift = Scb->CompressionUnitShift;
    OriginalCompressionUnit = Scb->CompressionUnit;
    OriginalFileAllocatedLength = Fcb->Info.AllocatedLength;

    //
    //  Use a try-finally to facilitate cleanup.
    //

    NtfsInitializeAttributeContext( &AttrContext );

    try {

        //
        //  Post the change to the Usn Journal
        //

        NtfsPostUsnChange( IrpContext, Scb, USN_REASON_BASIC_INFO_CHANGE );

        //
        //  Acquire the parent now for the update duplicate call.
        //

        if (ARGUMENT_PRESENT( ParentScb )) {

            NtfsPrepareForUpdateDuplicate( IrpContext, Fcb, &Lcb, &ParentScb, TRUE );
        }

        //
        //  If the file is not already compressed then we need to add a total allocated
        //  field and adjust the allocation length.
        //

        NewCompressionUnitShift = Scb->CompressionUnitShift;
        NewCompressionUnit = Scb->CompressionUnit;

        if (!FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

            //
            //  Compute the new compression unit and shift.
            //

            NewCompressionUnitShift = NTFS_CLUSTERS_PER_COMPRESSION;
            NewCompressionUnit = BytesFromClusters( Vcb,
                                                    1 << NTFS_CLUSTERS_PER_COMPRESSION );

            //
            //  If the compression unit is larger than 64K then find the correct
            //  compression unit to reach exactly 64k.
            //

            while (NewCompressionUnit > Vcb->SparseFileUnit) {

                NewCompressionUnitShift -= 1;
                NewCompressionUnit /= 2;
            }

            if (!FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

                //
                //  Fully allocate the final compression unit.
                //

                if (Scb->Header.AllocationSize.LowPart & (NewCompressionUnit - 1)) {

                    StartVcn = LlClustersFromBytesTruncate( Vcb, Scb->Header.AllocationSize.QuadPart );
                    FinalVcn = Scb->Header.AllocationSize.QuadPart + NewCompressionUnit - 1;
                    ((PLARGE_INTEGER) &FinalVcn)->LowPart &= ~(NewCompressionUnit - 1);
                    FinalVcn = LlClustersFromBytesTruncate( Vcb, FinalVcn );

                    NtfsAddAllocation( IrpContext,
                                       NULL,
                                       Scb,
                                       StartVcn,
                                       FinalVcn - StartVcn,
                                       FALSE,
                                       NULL );

                    if (FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA )) {

                        Fcb->Info.AllocatedLength = Scb->TotalAllocated;
                        SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_ALLOC_SIZE );
                    }
                }

                //
                //  Add a total allocated field to the attribute record header.
                //

                NtfsSetTotalAllocatedField( IrpContext, Scb, ATTRIBUTE_FLAG_SPARSE );
            }
        }

        //
        //  Look up the existing attribute.
        //

        NtfsLookupAttributeForScb( IrpContext, Scb, NULL, &AttrContext );
        NtfsPinMappedAttribute( IrpContext, Vcb, &AttrContext );
        Attribute = NtfsFoundAttribute( &AttrContext );

        //
        //  Now we need to set the bits in the attribute flag field.
        //

        if (NtfsIsAttributeResident( Attribute )) {

            RtlCopyMemory( &NewAttribute, Attribute, SIZEOF_RESIDENT_ATTRIBUTE_HEADER );

            AttributeSizeChange = SIZEOF_RESIDENT_ATTRIBUTE_HEADER;

        //
        //  Else if it is nonresident, copy it here, set the compression parameter,
        //  and remember its size.
        //

        } else {

            AttributeSizeChange = Attribute->Form.Nonresident.MappingPairsOffset;

            if (Attribute->NameOffset != 0) {

                AttributeSizeChange = Attribute->NameOffset;
            }

            ASSERT( AttributeSizeChange <= sizeof( NewAttribute ));
            RtlCopyMemory( &NewAttribute, Attribute, AttributeSizeChange );
            NewAttribute.Form.Nonresident.CompressionUnit = NewCompressionUnitShift;
        }

        SetFlag( NewAttribute.Flags, ATTRIBUTE_FLAG_SPARSE );

        //
        //  Now, log the changed attribute.
        //

        (VOID)NtfsWriteLog( IrpContext,
                            Vcb->MftScb,
                            NtfsFoundBcb( &AttrContext ),
                            UpdateResidentValue,
                            &NewAttribute,
                            AttributeSizeChange,
                            UpdateResidentValue,
                            Attribute,
                            AttributeSizeChange,
                            NtfsMftOffset( &AttrContext ),
                            PtrOffset(NtfsContainingFileRecord( &AttrContext ), Attribute),
                            0,
                            Vcb->BytesPerFileRecordSegment );

        //
        //  Change the attribute by calling the same routine called at restart.
        //

        NtfsRestartChangeValue( IrpContext,
                                NtfsContainingFileRecord( &AttrContext ),
                                PtrOffset( NtfsContainingFileRecord( &AttrContext ), Attribute ),
                                0,
                                &NewAttribute,
                                AttributeSizeChange,
                                FALSE );

        //
        //  If the file is not already marked sparse then update the standard information
        //  and the parent directory (if specified).  Also report the change via
        //  dirnotify if there is a Ccb with a name.
        //

        ASSERTMSG( "conflict with flush",
                   ExIsResourceAcquiredSharedLite( Fcb->Resource ) ||
                   (Fcb->PagingIoResource != NULL &&
                    ExIsResourceAcquiredSharedLite( Fcb->PagingIoResource )));

        SetFlag( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_SPARSE_FILE );
        SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_FILE_ATTR );
        SetFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );

        //
        //  Update the attributes in standard information.
        //

        NtfsUpdateStandardInformation( IrpContext, Fcb );

        if (ARGUMENT_PRESENT( ParentScb )) {

            //
            //  Update the directory entry for this file.
            //

            NtfsUpdateDuplicateInfo( IrpContext, Fcb, NULL, NULL );
            NtfsUpdateLcbDuplicateInfo( Fcb, Lcb );
            Fcb->InfoFlags = 0;
        }

        //
        //  Update the compression values and the sparse flag in the Scb.
        //

        Scb->CompressionUnit = NewCompressionUnit;
        Scb->CompressionUnitShift = NewCompressionUnitShift;

        SetFlag( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE );

        //
        //  Set the FastIo state.
        //

        NtfsAcquireFsrtlHeader( Scb );
        Scb->Header.IsFastIoPossible = NtfsIsFastIoPossible( Scb );
        SetFlag( Scb->Header.Flags2, FSRTL_FLAG2_PURGE_WHEN_MAPPED );
        NtfsReleaseFsrtlHeader( Scb );

        //
        //  Commit this change.
        //

        NtfsCheckpointCurrentTransaction( IrpContext );

    } finally {

        DebugUnwind( NtfsSetSparseStream );

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );

        //
        //  Backout the changes to the non-logged structures on abort.
        //

        if (AbnormalTermination()) {

            Fcb->Info.FileAttributes = OriginalFileAttributes;
            Scb->AttributeFlags = OriginalStreamAttributes;
            if (!FlagOn( OriginalStreamAttributes, ATTRIBUTE_FLAG_SPARSE )) {
                NtfsAcquireFsrtlHeader( Scb );
                ClearFlag( Scb->Header.Flags2, FSRTL_FLAG2_PURGE_WHEN_MAPPED );
                NtfsReleaseFsrtlHeader( Scb );
            }
            Scb->CompressionUnitShift = OriginalCompressionUnitShift;
            Scb->CompressionUnit = OriginalCompressionUnit;
            Fcb->Info.AllocatedLength = OriginalFileAllocatedLength;
        }
    }

    return;
}


NTSTATUS
NtfsZeroRangeInStream (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PSCB Scb,
    IN PLONGLONG StartingOffset,
    IN LONGLONG FinalZero
    )

/*++

Routine Description:

    This routine is the worker routine which will zero a range of a stream and
    (if sparse) deallocate any space in the stream that is convenient.  We only
    perform this operation on $DATA streams where there are no user maps.  We
    will zero, flush and purge any partial pages.  We will zero full pages except
    for sparse streams where we will purge the data and deallocate the
    disk backing for this range.

    This routine will fail if the stream has a user map.  Note that if the user
    is zeroing the end of the stream we can choose to simply move valid data length
    and purge the existing data instead of performing extensive flush operations.

Arguments:

    FileObject - A file object for the stream.  We can use this to follow the
        caller's preference for write through.

    Scb - This is the Scb for the stream we are to zero.  The user may have acquired
        the paging io resource prior to this call but the main resource should
        not be acquired.

    StartingOffset - Offset in the file to start the zero operation.  This may
        lie outside of the file size.  We update this to reflect the current
        position through the file.  That way if this routine should raise log
        file full our caller can resume from the point where we left off.

    FinalZero - Offset of last byte in the file to zero.

Return Value:

    NTSTATUS - Result of this operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    BOOLEAN ReleaseScb = FALSE;
    BOOLEAN UnlockHeader = FALSE;

    LONGLONG LastOffset = -1;
    LONGLONG CurrentBytes;
    LONGLONG CurrentOffset;
    LONGLONG CurrentFinalByte;
    LONGLONG ClusterCount;

    ULONG ClustersPerCompressionUnit;

    BOOLEAN ThrottleWrites;

    VCN NextVcn;
    VCN CurrentVcn;
    LCN Lcn;

    PBCB ZeroBufferBcb = NULL;
    PVOID ZeroBuffer;

    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    BOOLEAN CleanupAttrContext = FALSE;

    PAGED_CODE();

    //
    //  We better not be holding the main resource without also holding
    //  the paging resource, if any.
    //

    ASSERT( !NtfsIsSharedScb( Scb ) ||
            (Scb->Header.PagingIoResource == NULL) ||
            NtfsIsExclusiveScbPagingIo( Scb ) );

    //
    //  We will loop through the requested zero range.  We will checkpoint
    //  periodically and drop all resources so we don't become a bottle neck
    //  in the system.
    //

    try {

        while (TRUE) {

            //
            //  Acquire either the paging Io resource if present and lock the header
            //  or simply acquire the main resource.
            //

            if (Scb->Header.PagingIoResource != NULL) {

                if (IrpContext->CleanupStructure != NULL) {
                    ASSERT( (PFCB)IrpContext->CleanupStructure == Scb->Fcb );
                } else {
                    NtfsAcquirePagingResourceExclusive( IrpContext, Scb, TRUE );

                    FsRtlLockFsRtlHeader( &Scb->Header );
                    IrpContext->CleanupStructure = Scb;
                    UnlockHeader = TRUE;
                }
            } else {

                NtfsAcquireExclusiveScb( IrpContext, Scb );
                ReleaseScb = TRUE;
            }

            //
            //  Verify that the file and volume are still present.
            //

            if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED | SCB_STATE_VOLUME_DISMOUNTED)) {

                if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED )) {

                    Status = STATUS_FILE_DELETED;

                } else {

                    Status = STATUS_VOLUME_DISMOUNTED;
                }

                leave;
            }

            if (!FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED )) {

                NtfsUpdateScbFromAttribute( IrpContext, Scb, NULL );
            }

            //
            //  If we are past the end of the file or the length is zero we can break out.
            //

            if ((*StartingOffset >= Scb->Header.FileSize.QuadPart) ||
                (*StartingOffset >= FinalZero)) {

                try_return( NOTHING );
            }

            ThrottleWrites = FALSE;

            //
            //  Check for the oplock and file state.
            //

            if (ARGUMENT_PRESENT( FileObject )) {

                CurrentBytes = FinalZero - *StartingOffset;

                if (FinalZero > Scb->Header.FileSize.QuadPart) {

                    CurrentBytes = Scb->Header.FileSize.QuadPart - *StartingOffset;
                }

                if (CurrentBytes > NTFS_MAX_ZERO_RANGE) {

                    CurrentBytes = NTFS_MAX_ZERO_RANGE;
                }

                Status = NtfsCheckLocksInZeroRange( IrpContext,
                                                    IrpContext->OriginatingIrp,
                                                    Scb,
                                                    FileObject,
                                                    StartingOffset,
                                                    (ULONG) CurrentBytes );

                if (Status != STATUS_SUCCESS) {

                    leave;
                }
            }

            //
            //  Post the change to the Usn Journal
            //

            NtfsPostUsnChange( IrpContext, Scb, USN_REASON_DATA_OVERWRITE );

            //
            //  We are going to make the changes.  Make sure we set the file object
            //  flag to indicate we are making changes.
            //

            if (ARGUMENT_PRESENT( FileObject )) {

                SetFlag( FileObject->Flags, FO_FILE_MODIFIED );
            }

            //
            //  If the file is resident then flush and purge the stream and
            //  then change the attribute itself.
            //

            if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

                //
                //  Trim the remaining bytes to file size.
                //

                CurrentBytes = FinalZero - *StartingOffset;

                if (FinalZero > Scb->Header.FileSize.QuadPart) {

                    CurrentBytes = Scb->Header.FileSize.QuadPart - *StartingOffset;
                }

                Status = NtfsFlushUserStream( IrpContext, Scb, NULL, 0 );

                NtfsNormalizeAndCleanupTransaction( IrpContext,
                                                    &Status,
                                                    TRUE,
                                                    STATUS_UNEXPECTED_IO_ERROR );

                //
                //  Proceed if there is nothing to purge or the purge succeeds.
                //

                if ((Scb->NonpagedScb->SegmentObject.DataSectionObject != NULL) &&
                    !CcPurgeCacheSection( &Scb->NonpagedScb->SegmentObject,
                                          NULL,
                                          0,
                                          FALSE )) {

                    Status = STATUS_UNABLE_TO_DELETE_SECTION;
                    leave;
                }

                //
                //  Acquire the main resource to change the attribute.
                //

                if (!ReleaseScb) {

                    NtfsAcquireExclusiveScb( IrpContext, Scb );
                    ReleaseScb = TRUE;
                }

                //
                //  Now look up the attribute and zero the requested range.
                //

                NtfsInitializeAttributeContext( &AttrContext );
                CleanupAttrContext = TRUE;

                NtfsLookupAttributeForScb( IrpContext,
                                           Scb,
                                           NULL,
                                           &AttrContext );

                NtfsChangeAttributeValue( IrpContext,
                                          Scb->Fcb,
                                          (ULONG) *StartingOffset,
                                          NULL,
                                          (ULONG) CurrentBytes,
                                          FALSE,
                                          TRUE,
                                          FALSE,
                                          FALSE,
                                          &AttrContext );

                NtfsCheckpointCurrentTransaction( IrpContext );

                *StartingOffset += CurrentBytes;
                try_return( NOTHING );
            }

            //
            //  Make sure there are no mapped sections in the range we are trying to
            //  zero.
            //

            if (!MmCanFileBeTruncated( &Scb->NonpagedScb->SegmentObject,
                                       (PLARGE_INTEGER) StartingOffset )) {

                Status = STATUS_USER_MAPPED_FILE;
                try_return( NOTHING );
            }

            //
            //  If the file is either sparse or compressed then we look for ranges
            //  we need to flush, purge or deallocate.
            //

            if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE )) {

                ClustersPerCompressionUnit = 1 << Scb->CompressionUnitShift;

                //
                //  Move our starting point back to a compression unit boundary.  If our
                //  ending point is past the end of the file then set it to the compression
                //  unit past the EOF.
                //

                CurrentOffset = *StartingOffset & ~((LONGLONG) (Scb->CompressionUnit - 1));

                CurrentFinalByte = FinalZero;

                if (CurrentFinalByte >= Scb->Header.FileSize.QuadPart) {

                    CurrentFinalByte = BlockAlign( Scb->Header.FileSize.QuadPart, (LONG)Scb->CompressionUnit );
                }

                //
                //  Then look forward for either an allocated range or a reserved compression
                //  unit.  We may have to flush and/or purge data at that offset.
                //

                NextVcn =
                CurrentVcn = LlClustersFromBytesTruncate( Scb->Vcb, CurrentOffset );

                while (!NtfsLookupAllocation( IrpContext,
                                              Scb,
                                              NextVcn,
                                              &Lcn,
                                              &ClusterCount,
                                              NULL,
                                              NULL )) {

                    //
                    //  Move the current Vcn forward by the size of the hole.
                    //  Break out if we are beyond the final byte.
                    //

                    NextVcn += ClusterCount;

                    if ((LONGLONG) LlBytesFromClusters( Scb->Vcb, NextVcn ) >= CurrentFinalByte) {

                        //
                        //  Trim the final Vcn to the beginning of the last compression unit.
                        //

                        NextVcn = LlClustersFromBytesTruncate( Scb->Vcb, CurrentFinalByte );
                        break;
                    }
                }

                //
                //  Back up to a compression unit.
                //

                NextVcn = BlockAlignTruncate( NextVcn, (LONG)ClustersPerCompressionUnit );

                //
                //  If we found a hole then we need to look for reserved clusters within
                //  the range.
                //

                if (NextVcn != CurrentVcn) {

                    ClusterCount = NextVcn - CurrentVcn;

                    if (Scb->NonpagedScb->SegmentObject.DataSectionObject != NULL) {

                        NtfsCheckForReservedClusters( Scb, CurrentVcn, &ClusterCount );
                    }

                    CurrentVcn += ClusterCount;
                }

                //
                //  CurrentVcn - points to the first range we might have to zero in memory.
                //  NextVcn - points to the first range we might choose to deallocate.
                //
                //  Proceed if we aren't beyond the final byte to zero.
                //

                CurrentOffset = LlBytesFromClusters( Scb->Vcb, CurrentVcn );

                if (CurrentOffset >= CurrentFinalByte) {

                    ASSERT( IrpContext->TransactionId == 0 );

                    *StartingOffset = CurrentFinalByte;
                    try_return( NOTHING );
                }

                //
                //  If we find a range which is less than our starting offset then we will
                //  have to zero this range in the data section.
                //

                ASSERT( ((ULONG) CurrentOffset & (Scb->CompressionUnit - 1)) == 0 );

                if (CurrentOffset < *StartingOffset) {

                    //
                    //  Reserve a cluster to perform the write.
                    //

                    if (!NtfsReserveClusters( IrpContext, Scb, CurrentOffset, Scb->CompressionUnit )) {

                        Status = STATUS_DISK_FULL;
                        try_return( NOTHING );
                    }

                    //
                    //  Limit the zero range.
                    //

                    CurrentBytes = Scb->CompressionUnit - (*StartingOffset - CurrentOffset);

                    if (CurrentOffset + Scb->CompressionUnit > CurrentFinalByte) {

                        CurrentBytes = CurrentFinalByte - *StartingOffset;
                    }

                    //
                    //  See if we have to create an internal attribute stream.
                    //

                    if (Scb->FileObject == NULL) {
                        NtfsCreateInternalAttributeStream( IrpContext,
                                                           Scb,
                                                           FALSE,
                                                           &NtfsInternalUseFile[ZERORANGEINSTREAM_FILE_NUMBER] );
                    }

                    //
                    //  Zero the data in the cache.
                    //

                    CcPinRead( Scb->FileObject,
                               (PLARGE_INTEGER) &CurrentOffset,
                               Scb->CompressionUnit,
                               TRUE,
                               &ZeroBufferBcb,
                               &ZeroBuffer );
#ifdef MAPCOUNT_DBG
                    IrpContext->MapCount++;
#endif

                    RtlZeroMemory( Add2Ptr( ZeroBuffer,
                                            ((ULONG) *StartingOffset) & (Scb->CompressionUnit - 1)),
                                   (ULONG) CurrentBytes );
                    CcSetDirtyPinnedData( ZeroBufferBcb, NULL );
                    NtfsUnpinBcb( IrpContext, &ZeroBufferBcb );

                    //
                    //  Update the current offset to our position within the compression unit.
                    //

                    CurrentOffset += ((ULONG) *StartingOffset) & (Scb->CompressionUnit - 1);

                //
                //  If the current compression unit includes the last byte to zero
                //  then we need flush and/or purge this compression unit.
                //

                } else if (CurrentOffset + Scb->CompressionUnit > CurrentFinalByte) {

                    //
                    //  Reserve a cluster to perform the write.
                    //

                    if (!NtfsReserveClusters( IrpContext, Scb, CurrentOffset, Scb->CompressionUnit )) {

                        Status = STATUS_DISK_FULL;
                        try_return( NOTHING );
                    }

                    //
                    //  Limit the zero range.
                    //

                    CurrentBytes = (ULONG) CurrentFinalByte & (Scb->CompressionUnit - 1);

                    //
                    //  See if we have to create an internal attribute stream.
                    //

                    if (Scb->FileObject == NULL) {
                        NtfsCreateInternalAttributeStream( IrpContext,
                                                           Scb,
                                                           FALSE,
                                                           &NtfsInternalUseFile[ZERORANGEINSTREAM2_FILE_NUMBER] );
                    }

                    //
                    //  Zero the data in the cache.
                    //

                    CcPinRead( Scb->FileObject,
                               (PLARGE_INTEGER) &CurrentOffset,
                               (ULONG) CurrentBytes,
                               TRUE,
                               &ZeroBufferBcb,
                               &ZeroBuffer );
#ifdef MAPCOUNT_DBG
                    IrpContext->MapCount++;
#endif


                    RtlZeroMemory( ZeroBuffer, (ULONG) CurrentBytes );
                    CcSetDirtyPinnedData( ZeroBufferBcb, NULL );
                    NtfsUnpinBcb( IrpContext, &ZeroBufferBcb );

                } else {

                    //
                    //  Compute the range we want to purge.  We will process a maximum of 2Gig
                    //  at a time.
                    //

                    CurrentBytes = CurrentFinalByte - CurrentOffset;

                    if (CurrentBytes > NTFS_MAX_ZERO_RANGE) {

                        CurrentBytes = NTFS_MAX_ZERO_RANGE;
                    }

                    //
                    //  Round the size to a compression unit.
                    //

                    CurrentBytes = BlockAlignTruncate( CurrentBytes, (LONG)Scb->CompressionUnit );

                    //
                    //  If this is the retry case then let's reduce the amount to
                    //  zero.
                    //

                    if ((*StartingOffset == LastOffset) &&
                        (CurrentBytes > Scb->CompressionUnit)) {

                        CurrentBytes = Scb->CompressionUnit;
                        CurrentFinalByte = CurrentOffset + CurrentBytes;
                    }

                    //
                    //  Purge the data in this range.
                    //

                    if ((Scb->NonpagedScb->SegmentObject.DataSectionObject != NULL) &&
                        !CcPurgeCacheSection( &Scb->NonpagedScb->SegmentObject,
                                              (PLARGE_INTEGER) &CurrentOffset,
                                              (ULONG) CurrentBytes,
                                              FALSE )) {

                        //
                        //  There may be a section in the cache manager which is being
                        //  flushed.  Go ahead and see if we can force the data out
                        //  so the purge will succeed.
                        //

                        Status = NtfsFlushUserStream( IrpContext,
                                                      Scb,
                                                      &CurrentOffset,
                                                      (ULONG) CurrentBytes );

                        NtfsNormalizeAndCleanupTransaction( IrpContext,
                                                            &Status,
                                                            TRUE,
                                                            STATUS_UNEXPECTED_IO_ERROR );

                        //
                        //  If this is the retry case then let's reduce the amount to
                        //  zero.
                        //

                        if (CurrentBytes > Scb->CompressionUnit) {

                            CurrentBytes = Scb->CompressionUnit;
                            CurrentFinalByte = CurrentOffset + CurrentBytes;
                        }

                        //
                        //  Now try the purge again.
                        //

                        if (!CcPurgeCacheSection( &Scb->NonpagedScb->SegmentObject,
                                                  (PLARGE_INTEGER) &CurrentOffset,
                                                  (ULONG) CurrentBytes,
                                                  FALSE )) {

                            //
                            //  If our retry failed then give up.
                            //

                            if (*StartingOffset == LastOffset) {

                                Status = STATUS_UNABLE_TO_DELETE_SECTION;
                                leave;
                            }

                            //
                            //  Otherwise show that we haven't advanced, but we
                            //  will take one more crack at this.
                            //

                            CurrentBytes = 0;
                        }
                    }

                    //
                    //  Delete the allocation if we have any bytes to work with.
                    //

                    if (CurrentBytes != 0) {

                        //
                        //  Acquire the main resource to change the allocation.
                        //

                        if (!ReleaseScb) {

                            NtfsAcquireExclusiveScb( IrpContext, Scb );
                            ReleaseScb = TRUE;
                        }

                        //
                        //  Now deallocate the clusters in this range if we have some to delete.
                        //  Use ClusterCount to indicate the last Vcn to deallocate.
                        //

                        ClusterCount = CurrentVcn + LlClustersFromBytesTruncate( Scb->Vcb, CurrentBytes ) - 1;

                        if (NextVcn <= ClusterCount) {

                            NtfsDeleteAllocation( IrpContext,
                                                  FileObject,
                                                  Scb,
                                                  NextVcn,
                                                  ClusterCount,
                                                  TRUE,
                                                  TRUE );

                            //
                            //  Move VDD fwd to protect this hole for compressed files
                            //

                            if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {
                                if ((ULONGLONG)Scb->ValidDataToDisk < LlBytesFromClusters( Scb->Vcb, ClusterCount )) {
                                    Scb->ValidDataToDisk = LlBytesFromClusters( Scb->Vcb, ClusterCount );
                                }
                            }
                        }

                        //
                        //  Free up the reserved bitmap if there are any bits to clear.
                        //

                        NtfsFreeReservedClusters( Scb, CurrentOffset, (ULONG) CurrentBytes );
                    }
                }

            //
            //  Otherwise the file is uncompressed/non-sparse, we need to zero partial
            //  cluster and then we need to flush and/or purge the existing pages.
            //

            } else {

                //
                //  Remember the current offset within the stream and
                //  the length to zero now.
                //

                CurrentOffset = *StartingOffset;
                CurrentFinalByte = (CurrentOffset + 0x40000) & ~((LONGLONG) (0x40000 - 1));

                if (CurrentFinalByte > Scb->Header.FileSize.QuadPart) {

                    CurrentFinalByte = Scb->Header.FileSize.QuadPart;
                }

                if (CurrentFinalByte > FinalZero) {

                    CurrentFinalByte = FinalZero;
                }

                //
                //  Determine the number of bytes remaining in the current cache view.
                //

                CurrentBytes = CurrentFinalByte - CurrentOffset;

                //
                //  If this is the retry case then let's reduce the amount to
                //  zero.
                //

                if ((*StartingOffset == LastOffset) &&
                    (CurrentBytes > PAGE_SIZE)) {

                    CurrentBytes = PAGE_SIZE;
                    CurrentFinalByte = CurrentOffset + CurrentBytes;
                }

                //
                //  Purge the data in this range.
                //

                if (Scb->NonpagedScb->SegmentObject.DataSectionObject &&
                    !CcPurgeCacheSection( &Scb->NonpagedScb->SegmentObject,
                                          (PLARGE_INTEGER) &CurrentOffset,
                                          (ULONG) CurrentBytes,
                                          FALSE )) {

                    //
                    //  There may be a section in the cache manager which is being
                    //  flushed.  Go ahead and see if we can force the data out
                    //  so the purge will succeed.
                    //

                    Status = NtfsFlushUserStream( IrpContext,
                                                  Scb,
                                                  &CurrentOffset,
                                                  (ULONG) CurrentBytes );

                    NtfsNormalizeAndCleanupTransaction( IrpContext,
                                                        &Status,
                                                        TRUE,
                                                        STATUS_UNEXPECTED_IO_ERROR );

                    //
                    //  Let's trim back the amount of data to purge at once.
                    //

                    if (CurrentBytes > PAGE_SIZE) {

                        CurrentBytes = PAGE_SIZE;
                        CurrentFinalByte = CurrentOffset + CurrentBytes;
                    }

                    //
                    //  Now try the purge again.
                    //

                    if (!CcPurgeCacheSection( &Scb->NonpagedScb->SegmentObject,
                                              (PLARGE_INTEGER) &CurrentOffset,
                                              (ULONG) CurrentBytes,
                                              FALSE )) {

                        //
                        //  If our retry failed then give up.
                        //

                        if (*StartingOffset == LastOffset) {

                            Status = STATUS_UNABLE_TO_DELETE_SECTION;
                            leave;
                        }

                        //
                        //  Otherwise show that we haven't advanced, but we
                        //  will take one more crack at this.
                        //

                        CurrentBytes = 0;
                    }
                }

                //
                //  Continue if we have bytes to zero.
                //

                if (CurrentBytes != 0) {

                    //
                    //  If we are within valid data length then zero the data.
                    //

                    if (CurrentOffset < Scb->Header.ValidDataLength.QuadPart) {

                        //
                        //  See if we have to create an internal attribute stream.
                        //

                        if (Scb->FileObject == NULL) {
                            NtfsCreateInternalAttributeStream( IrpContext,
                                                               Scb,
                                                               FALSE,
                                                               &NtfsInternalUseFile[ZERORANGEINSTREAM3_FILE_NUMBER] );
                        }

                        //
                        //  Zero the data in the cache.
                        //

                        CcPinRead( Scb->FileObject,
                                   (PLARGE_INTEGER) &CurrentOffset,
                                   (ULONG) CurrentBytes,
                                   TRUE,
                                   &ZeroBufferBcb,
                                   &ZeroBuffer );
#ifdef MAPCOUNT_DBG
                        IrpContext->MapCount++;
#endif

                        RtlZeroMemory( ZeroBuffer, (ULONG) CurrentBytes );
                        CcSetDirtyPinnedData( ZeroBufferBcb, NULL );
                        NtfsUnpinBcb( IrpContext, &ZeroBufferBcb );
                    }

                    //
                    //  We want to throttle the writes if there is more to do.
                    //

                    if (CurrentFinalByte < FinalZero) {

                        ThrottleWrites = TRUE;
                    }
                }
            }

            //
            //  Check and see if we can advance valid data length.
            //

            if ((CurrentOffset + CurrentBytes > Scb->Header.ValidDataLength.QuadPart) &&
                (*StartingOffset <= Scb->Header.ValidDataLength.QuadPart)) {

                NtfsAcquireFsrtlHeader( Scb );
                Scb->Header.ValidDataLength.QuadPart = CurrentOffset + CurrentBytes;

                if (Scb->Header.ValidDataLength.QuadPart > Scb->Header.FileSize.QuadPart) {
                    Scb->Header.ValidDataLength.QuadPart = Scb->Header.FileSize.QuadPart;
                }

#ifdef SYSCACHE_DEBUG
                if (ScbIsBeingLogged( Scb )) {

                    FsRtlLogSyscacheEvent( Scb, SCE_ZERO_STREAM, SCE_FLAG_SET_VDL, Scb->Header.ValidDataLength.QuadPart, 0, 0 );
                }
#endif

                NtfsReleaseFsrtlHeader( Scb );
            }

            //
            //  Checkpoint and past the current bytes.
            //

            if (NtfsIsExclusiveScb( Scb->Vcb->MftScb )) {

                SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_RELEASE_MFT );
            }

            NtfsCheckpointCurrentTransaction( IrpContext );

            LastOffset = *StartingOffset;
            if (CurrentBytes != 0) {

                *StartingOffset = CurrentOffset + CurrentBytes;
            }

            //
            //  Release all of the resources so we don't create a bottleneck.
            //

            if (UnlockHeader) {

                FsRtlUnlockFsRtlHeader( &Scb->Header );
                IrpContext->CleanupStructure = NULL;
                ExReleaseResourceLite( Scb->Header.PagingIoResource );
                UnlockHeader = FALSE;
            }

            if (ReleaseScb) {

                NtfsReleaseScb( IrpContext, Scb );
                ReleaseScb = FALSE;
            }

            //
            //  Now throttle the writes if we are accessing an uncompressed/non-sparse file.
            //

            if (ARGUMENT_PRESENT( FileObject ) && ThrottleWrites) {

                CcCanIWrite( FileObject, 0x40000, TRUE, FALSE );
            }
        }

    try_exit: NOTHING;

        //
        //  If we have a user file object then check if we need to write any
        //  data to disk.
        //

        if ((Status == STATUS_SUCCESS) && ARGUMENT_PRESENT( FileObject )) {

            if ((FlagOn( FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING ) ||
                 IsFileWriteThrough( FileObject, Scb->Vcb ))) {

                //
                //  We either want to flush the Scb or flush and purge the Scb.
                //

                if ((Scb->CleanupCount == Scb->NonCachedCleanupCount) &&
                    !FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

                    //
                    //  Flush and purge will alter filesizes on disk so preacquire the file exclusive
                    //

                    if (!ReleaseScb) {
                        NtfsAcquireExclusiveScb( IrpContext, Scb );
                        ReleaseScb = TRUE;
                    }
                    NtfsFlushAndPurgeScb( IrpContext, Scb, NULL );

                } else {

                    Status = NtfsFlushUserStream( IrpContext, Scb, NULL, 0 );
                    NtfsNormalizeAndCleanupTransaction( IrpContext,
                                                        &Status,
                                                        TRUE,
                                                        STATUS_UNEXPECTED_IO_ERROR );
                }
            }

            //
            //  If this is write through or non-cached then flush the log file as well.
            //

            if (IsFileWriteThrough( FileObject, Scb->Vcb ) ||
                FlagOn( FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING )) {

                LfsFlushToLsn( Scb->Vcb->LogHandle, LiMax );
            }
        }

    } finally {

        DebugUnwind( NtfsZeroRangeInStream );

        if (Status != STATUS_PENDING) {

            //
            //  Release any held resources.
            //

            if (UnlockHeader) {

                FsRtlUnlockFsRtlHeader( &Scb->Header );
                IrpContext->CleanupStructure = NULL;
                ExReleaseResourceLite( Scb->Header.PagingIoResource );

            }

            if (ReleaseScb) {

                NtfsReleaseScb( IrpContext, Scb );
            }

        //
        //  Even if STATUS_PENDING is returned we need to release the paging io
        //  resource.  PrePostIrp will clear the IoAtEOF bit.
        //

        } else if (UnlockHeader) {

            ExReleaseResourceLite( Scb->Header.PagingIoResource );
        }

        //
        //  Cleanup the attribute context if used.
        //

        if (CleanupAttrContext) {

            NtfsCleanupAttributeContext( IrpContext, &AttrContext );
        }

        NtfsUnpinBcb( IrpContext, &ZeroBufferBcb );
    }

    return Status;
}


BOOLEAN
NtfsModifyAttributeFlags (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN USHORT NewAttributeFlags
    )

/*++

Routine Description:

    This routine is called to change the attribute for an Scb.  It changes the values
    associated with the AttributeFlags (Encryption, Sparse, Compressed).

    This routine does not commit so our caller must know how to unwind changes to the Scb and
    Fcb (compression fields and Fcb Info).

    NOTE - This routine will update the Fcb duplicate info and flags as well as the compression unit
        fields in the Scb.  The caller is responsible for cleaning these up on error.

Arguments:

    Scb - Scb for the stream being modified.

    NewAttributeFlags - New flags to associate with the stream.

    FcbInfoFlags - Pointer to store changes to apply to the Fcb Info flags.

Return Value:

    BOOLEAN - TRUE if our caller needs to update duplicate info.  FALSE otherwise.

--*/

{
    PFCB Fcb = Scb->Fcb;
    PVCB Vcb = Scb->Vcb;

    ATTRIBUTE_RECORD_HEADER NewAttribute;
    PATTRIBUTE_RECORD_HEADER Attribute;
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    ULONG AttributeSizeChange;
    BOOLEAN ChangeTotalAllocated = FALSE;
    BOOLEAN ChangeCompression = FALSE;
    BOOLEAN ChangeSparse = FALSE;
    BOOLEAN ChangeEncryption = FALSE;
    ULONG NewCompressionUnit;
    UCHAR NewCompressionUnitShift;

    BOOLEAN UpdateDuplicate = FALSE;

    PAGED_CODE();

    ASSERT( Scb->AttributeFlags != NewAttributeFlags );

    NtfsInitializeAttributeContext( &AttrContext );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Lookup the attribute and pin it so that we can modify it.
        //

        if ((Scb->Header.NodeTypeCode == NTFS_NTC_SCB_INDEX) ||
            (Scb->Header.NodeTypeCode == NTFS_NTC_SCB_ROOT_INDEX)) {

            //
            //  Lookup the attribute record from the Scb.
            //

            if (!NtfsLookupAttributeByName( IrpContext,
                                            Fcb,
                                            &Fcb->FileReference,
                                            $INDEX_ROOT,
                                            &Scb->AttributeName,
                                            NULL,
                                            FALSE,
                                            &AttrContext )) {

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, NULL );
            }

            Attribute = NtfsFoundAttribute( &AttrContext );

        } else {

            NtfsLookupAttributeForScb( IrpContext, Scb, NULL, &AttrContext );
            Attribute = NtfsFoundAttribute( &AttrContext );

            //
            //  If the new state is encrypted and the file is not currently encrypted then convert to
            //  non-resident.
            //

            if (FlagOn( NewAttributeFlags, ATTRIBUTE_FLAG_ENCRYPTED ) &&
                NtfsIsAttributeResident( Attribute )) {

                NtfsConvertToNonresident( IrpContext,
                                          Fcb,
                                          Attribute,
                                          FALSE,
                                          &AttrContext );
            }
        }

        //
        //  Remember which flags are changing.
        //

        if (FlagOn( NewAttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK ) !=
            FlagOn( Attribute->Flags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

            ChangeCompression = TRUE;
        }

        if (FlagOn( NewAttributeFlags, ATTRIBUTE_FLAG_SPARSE ) !=
            FlagOn( Attribute->Flags, ATTRIBUTE_FLAG_SPARSE )) {

            ChangeSparse = TRUE;
        }

        if (FlagOn( NewAttributeFlags, ATTRIBUTE_FLAG_ENCRYPTED ) !=
            FlagOn( Attribute->Flags, ATTRIBUTE_FLAG_ENCRYPTED )) {

            ChangeEncryption = TRUE;
        }

        //
        //  Point to the current attribute and save the current flags.
        //

        NtfsPinMappedAttribute( IrpContext, Vcb, &AttrContext );

        Attribute = NtfsFoundAttribute( &AttrContext );

        //
        //  Compute the new compression size.  Use the following to determine this
        //
        //      - New state is not compressed/sparse - Unit/UnitShift = 0
        //      - New state includes compressed/sparse
        //          - Current state includes compressed/sparse - No change
        //          - Stream is compressible - Default values (64K max)
        //          - Stream is not compressible - Unit/UnitShift = 0
        //

        NewCompressionUnit = Scb->CompressionUnit;
        NewCompressionUnitShift = Scb->CompressionUnitShift;

        //
        //  Set the correct compression unit but only for data streams.  We
        //  don't want to change this value for the Index Root.
        //

        if (NtfsIsTypeCodeCompressible( Attribute->TypeCode )) {

            //
            //  We need a compression unit for the attribute now.
            //

            if (FlagOn( NewAttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE )) {

                if (!FlagOn( Attribute->Flags, ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE )) {

                    ChangeTotalAllocated = TRUE;
                    NewCompressionUnit = BytesFromClusters( Scb->Vcb, 1 << NTFS_CLUSTERS_PER_COMPRESSION );
                    NewCompressionUnitShift = NTFS_CLUSTERS_PER_COMPRESSION;

                    //
                    //  If the compression unit is larger than 64K then find the correct
                    //  compression unit to reach exactly 64k.
                    //

                    while (NewCompressionUnit > Vcb->SparseFileUnit) {

                        NewCompressionUnitShift -= 1;
                        NewCompressionUnit /= 2;
                    }
                }

            } else {

                //
                //  Check if we to remove the extra total allocated field.
                //

                if (FlagOn( Attribute->Flags, ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE )) {

                    ChangeTotalAllocated = TRUE;
                }

                NewCompressionUnit = 0;
                NewCompressionUnitShift = 0;
            }
        }

        //
        //  If the attribute is resident, copy it here and remember its
        //  header size.
        //

        if (NtfsIsAttributeResident( Attribute )) {

            RtlCopyMemory( &NewAttribute, Attribute, SIZEOF_RESIDENT_ATTRIBUTE_HEADER );

            AttributeSizeChange = SIZEOF_RESIDENT_ATTRIBUTE_HEADER;

        //
        //  Else if it is nonresident, copy it here, set the compression parameter,
        //  and remember its size.
        //

        } else {

            ASSERT( NtfsIsTypeCodeCompressible( Attribute->TypeCode ));

            //
            //  Pad the allocation if the new type includes sparse or compressed and file is
            //  not sparse or compressed (non-resident only).
            //

            if (FlagOn( NewAttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE ) &&
                !FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE )) {

                LONGLONG Temp;
                ULONG CompressionUnitInClusters;

                //
                //  If we are turning compression on, then we need to fill out the
                //  allocation of the compression unit containing file size, or else
                //  it will be interpreted as compressed when we fault it in.  This
                //  is peanuts compared to the dual copies of clusters we keep around
                //  in the loop below when we rewrite the file.  We don't do this
                //  work if the file is sparse because the allocation has already
                //  been rounded up.
                //

                CompressionUnitInClusters = 1 << NewCompressionUnitShift;

                Temp = LlClustersFromBytesTruncate( Vcb, Scb->Header.AllocationSize.QuadPart );

                //
                //  If FileSize is not already at a cluster boundary, then add
                //  allocation.
                //

                if ((ULONG) Temp & (CompressionUnitInClusters - 1)) {

                    NtfsAddAllocation( IrpContext,
                                       NULL,
                                       Scb,
                                       Temp,
                                       CompressionUnitInClusters - ((ULONG)Temp & (CompressionUnitInClusters - 1)),
                                       FALSE,
                                       NULL );

                    //
                    //  Update the duplicate info.
                    //

                    if (FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA )) {

                        Scb->Fcb->Info.AllocatedLength = Scb->TotalAllocated;
                        SetFlag( Scb->Fcb->InfoFlags, FCB_INFO_CHANGED_ALLOC_SIZE );

                        UpdateDuplicate = TRUE;
                    }

                    NtfsWriteFileSizes( IrpContext,
                                        Scb,
                                        &Scb->Header.ValidDataLength.QuadPart,
                                        FALSE,
                                        TRUE,
                                        TRUE );

                    //
                    //  The attribute may have moved.  We will cleanup the attribute
                    //  context and look it up again.
                    //

                    NtfsCleanupAttributeContext( IrpContext, &AttrContext );
                    NtfsInitializeAttributeContext( &AttrContext );

                    NtfsLookupAttributeForScb( IrpContext, Scb, NULL, &AttrContext );
                    NtfsPinMappedAttribute( IrpContext, Vcb, &AttrContext );
                    Attribute = NtfsFoundAttribute( &AttrContext );
                }
            }

            AttributeSizeChange = Attribute->Form.Nonresident.MappingPairsOffset;

            if (Attribute->NameOffset != 0) {

                AttributeSizeChange = Attribute->NameOffset;
            }

            RtlCopyMemory( &NewAttribute, Attribute, AttributeSizeChange );
        }

        //
        //  Set the new attribute flags.
        //

        NewAttribute.Flags = NewAttributeFlags;

        //
        //  Now, log the changed attribute.
        //

        (VOID)NtfsWriteLog( IrpContext,
                            Vcb->MftScb,
                            NtfsFoundBcb( &AttrContext ),
                            UpdateResidentValue,
                            &NewAttribute,
                            AttributeSizeChange,
                            UpdateResidentValue,
                            Attribute,
                            AttributeSizeChange,
                            NtfsMftOffset( &AttrContext ),
                            PtrOffset( NtfsContainingFileRecord( &AttrContext ), Attribute),
                            0,
                            Vcb->BytesPerFileRecordSegment );

        //
        //  Change the attribute by calling the same routine called at restart.
        //

        NtfsRestartChangeValue( IrpContext,
                                NtfsContainingFileRecord( &AttrContext ),
                                PtrOffset( NtfsContainingFileRecord( &AttrContext ), Attribute ),
                                0,
                                &NewAttribute,
                                AttributeSizeChange,
                                FALSE );

        //
        //  See if we need to either add or remove a total allocated field.
        //

        if (ChangeTotalAllocated) {

            NtfsSetTotalAllocatedField( IrpContext,
                                        Scb,
                                        (USHORT) FlagOn( NewAttributeFlags,
                                                         ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE ));
        }

        //
        //  If this is the main stream for a file we want to change the file attribute
        //  for this stream in both the standard information and duplicate
        //  information structure.
        //

        if (ChangeCompression &&
            (FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA ) ||
             (Attribute->TypeCode == $INDEX_ALLOCATION))) {

            if (FlagOn( NewAttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

                SetFlag( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_COMPRESSED );

            } else {

                ClearFlag( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_COMPRESSED );
            }

            ASSERTMSG( "conflict with flush",
                        NtfsIsSharedFcb( Fcb ) ||
                        (Fcb->PagingIoResource != NULL &&
                        NtfsIsSharedFcbPagingIo( Fcb )) );

            SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_FILE_ATTR );
            SetFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );

            UpdateDuplicate = TRUE;
        }

        if (ChangeSparse &&
            FlagOn( NewAttributeFlags, ATTRIBUTE_FLAG_SPARSE ) &&
            !FlagOn( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_SPARSE_FILE )) {

            ASSERTMSG( "conflict with flush",
                       NtfsIsSharedFcb( Fcb ) ||
                       (Fcb->PagingIoResource != NULL &&
                       NtfsIsSharedFcbPagingIo( Fcb )) );

            SetFlag( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_SPARSE_FILE );
            SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_FILE_ATTR );
            SetFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );

            UpdateDuplicate = TRUE;
        }

        if (ChangeEncryption &&
            FlagOn( NewAttributeFlags, ATTRIBUTE_FLAG_ENCRYPTED ) &&
            !FlagOn( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_ENCRYPTED )) {

            ASSERTMSG( "conflict with flush",
                       NtfsIsSharedFcb( Fcb ) ||
                       (Fcb->PagingIoResource != NULL &&
                       NtfsIsSharedFcbPagingIo( Fcb )) );

            SetFlag( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_ENCRYPTED );
            SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_FILE_ATTR );
            SetFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );

            UpdateDuplicate = TRUE;
        }

        //
        //  Now put the new compression values in the Scb.
        //

        Scb->CompressionUnit = NewCompressionUnit;
        Scb->CompressionUnitShift = NewCompressionUnitShift;
        Scb->AttributeFlags = NewAttributeFlags;

    } finally {

        DebugUnwind( NtfsModifyAttributeFlags );

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );
    }

    return UpdateDuplicate;
}


PFCB
NtfsInitializeFileInExtendDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PCUNICODE_STRING FileName,
    IN BOOLEAN ViewIndex,
    IN ULONG CreateIfNotExist
    )

/*++

Routine Description:

    This routine creates/opens a file in the $Extend directory, by file name,
    and returns an Fcb for the file.

Arguments:

    Vcb - Pointer to the Vcb for the volume

    FileName - Name of file to create in extend directory

    ViewIndex - Indicates that the file is a view index.

    CreateIfNotExist - Supplies TRUE if file should be created if it does not
                       already exist, or FALSE if file should not be created.

Return Value:

    Fcb file existed or was created, NULL if file did not exist and was not created.

--*/

{
    struct {
        FILE_NAME FileName;
        WCHAR FileNameChars[10];
    } FileNameAttr;
    FILE_REFERENCE FileReference;
    LONGLONG FileRecordOffset;
    PINDEX_ENTRY IndexEntry;
    PBCB FileRecordBcb = NULL;
    PBCB IndexEntryBcb = NULL;
    PBCB ParentSecurityBcb = NULL;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    UCHAR FileNameFlags;
    BOOLEAN FoundEntry;
    PFCB ExtendFcb = Vcb->ExtendDirectory->Fcb;
    PFCB Fcb = NULL;
    BOOLEAN AcquiredFcbTable = FALSE;
    BOOLEAN ReturnedExistingFcb = TRUE;
    ATTRIBUTE_ENUMERATION_CONTEXT Context;

    PAGED_CODE();

    ASSERT( NtfsIsExclusiveScb( Vcb->ExtendDirectory ) );

    //
    //  Initialize the FileName.
    //

    ASSERT((FileName->Length / sizeof( WCHAR )) <= 10);
    RtlZeroMemory( &FileNameAttr, sizeof(FileNameAttr) );
    FileNameAttr.FileName.ParentDirectory = ExtendFcb->FileReference;
    FileNameAttr.FileName.FileNameLength = (UCHAR)(FileName->Length / sizeof( WCHAR ));
    RtlCopyMemory( FileNameAttr.FileName.FileName, FileName->Buffer, FileName->Length );

    NtfsInitializeAttributeContext( &Context );

    try {

        //
        //  Does the file already exist?
        //

        FoundEntry = NtfsFindIndexEntry( IrpContext,
                                         Vcb->ExtendDirectory,
                                         &FileNameAttr,
                                         FALSE,
                                         NULL,
                                         &IndexEntryBcb,
                                         &IndexEntry,
                                         NULL );

        //
        //  Only procede if we either found the file or are supposed to create it.
        //

        if (FoundEntry || CreateIfNotExist) {

            //
            //  If we did not find it, then start creating the file.
            //

            if (!FoundEntry) {

                //
                //  We will now try to do all of the on-disk operations.  This means first
                //  allocating and initializing an Mft record.  After that we create
                //  an Fcb to use to access this record.
                //

                FileReference = NtfsAllocateMftRecord( IrpContext, Vcb, FALSE );

                //
                //  Pin the file record we need.
                //

                NtfsPinMftRecord( IrpContext,
                                  Vcb,
                                  &FileReference,
                                  TRUE,
                                  &FileRecordBcb,
                                  &FileRecord,
                                  &FileRecordOffset );

                //
                //  Initialize the file record header.
                //

                NtfsInitializeMftRecord( IrpContext,
                                         Vcb,
                                         &FileReference,
                                         FileRecord,
                                         FileRecordBcb,
                                         FALSE );

            //
            //  If we found the file, then just get its FileReference out of the
            //  IndexEntry.
            //

            } else {

                FileReference = IndexEntry->FileReference;
            }

            //
            //  Now that we know the FileReference, we can create the Fcb.
            //

            NtfsAcquireFcbTable( IrpContext, Vcb );
            AcquiredFcbTable = TRUE;

            Fcb = NtfsCreateFcb( IrpContext,
                                 Vcb,
                                 FileReference,
                                 FALSE,
                                 ViewIndex,
                                 &ReturnedExistingFcb );

            //
            //  Reference the Fcb so it doesn't go away.
            //

            Fcb->ReferenceCount += 1;
            NtfsReleaseFcbTable( IrpContext, Vcb );
            AcquiredFcbTable = FALSE;

            //
            //  Try to do a fast acquire, otherwise we need to release
            //  the parent extend directory and acquire in the canonical order
            //  child and then parent.
            //  Use AcquireWithPaging for don't wait functionality. Since the flag
            //  isn't set despite its name this will only acquire main
            //

            if (!NtfsAcquireFcbWithPaging( IrpContext, Fcb, ACQUIRE_DONT_WAIT )) {

                NtfsReleaseScb( IrpContext, Vcb->ExtendDirectory );
                NtfsAcquireExclusiveFcb( IrpContext, Fcb, NULL, 0 );
                NtfsAcquireExclusiveScb( IrpContext, Vcb->ExtendDirectory );
            }

            NtfsAcquireFcbTable( IrpContext, Vcb );
            Fcb->ReferenceCount -= 1;
            NtfsReleaseFcbTable( IrpContext, Vcb );

            //
            //  If we are creating this file, then carry on.
            //

            if (!FoundEntry) {

                BOOLEAN LogIt = FALSE;

                //
                //  Just copy the Security Id from the parent.
                //

                NtfsAcquireFcbSecurity( Fcb->Vcb );
                Fcb->SecurityId = ExtendFcb->SecurityId;
                ASSERT( Fcb->SharedSecurity == NULL );
                Fcb->SharedSecurity = ExtendFcb->SharedSecurity;
                Fcb->SharedSecurity->ReferenceCount++;
                NtfsReleaseFcbSecurity( Fcb->Vcb );

                //
                //  The changes to make on disk are first to create a standard information
                //  attribute.  We start by filling the Fcb with the information we
                //  know and creating the attribute on disk.
                //

                NtfsInitializeFcbAndStdInfo( IrpContext,
                                             Fcb,
                                             FALSE,
                                             ViewIndex,
                                             FALSE,
                                             FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM,
                                             NULL );

                //
                //  Now link the file into the $Extend directory.
                //

                NtfsAddLink( IrpContext,
                             TRUE,
                             Vcb->ExtendDirectory,
                             Fcb,
                             (PFILE_NAME)&FileNameAttr,
                             &LogIt,
                             &FileNameFlags,
                             NULL,
                             NULL,
                             NULL );

                //
                //  Set this flag to indicate that the file is to be locked via the Scb
                //  pointers in the Vcb.
                //

                SetFlag( FileRecord->Flags, FILE_SYSTEM_FILE );

                //
                //  Log the file record.
                //

                FileRecord->Lsn = NtfsWriteLog( IrpContext,
                                                Vcb->MftScb,
                                                FileRecordBcb,
                                                InitializeFileRecordSegment,
                                                FileRecord,
                                                FileRecord->FirstFreeByte,
                                                Noop,
                                                NULL,
                                                0,
                                                FileRecordOffset,
                                                0,
                                                0,
                                                Vcb->BytesPerFileRecordSegment );

            //
            //  Verify that the file record for this file is valid.
            //

            } else {

                ULONG CorruptHint;

                if (!NtfsLookupAttributeByCode( IrpContext,
                                                Fcb,
                                                &Fcb->FileReference,
                                                $STANDARD_INFORMATION,
                                                &Context ) ||

                    !NtfsCheckFileRecord( Vcb, NtfsContainingFileRecord( &Context ), &Fcb->FileReference, &CorruptHint )) {

                    NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, &Fcb->FileReference, NULL );
                }
            }

            //
            //  Update Fcb fields from disk.
            //

            SetFlag( Fcb->FcbState, FCB_STATE_SYSTEM_FILE );
            NtfsUpdateFcbInfoFromDisk( IrpContext, TRUE, Fcb, NULL );
        }

    } finally {

        NtfsCleanupAttributeContext( IrpContext, &Context );
        NtfsUnpinBcb( IrpContext, &FileRecordBcb );
        NtfsUnpinBcb( IrpContext, &IndexEntryBcb );
        NtfsUnpinBcb( IrpContext, &ParentSecurityBcb );

        //
        //  On any kind of error, nuke the Fcb.
        //

        if (AbnormalTermination()) {

            //
            //  If some error caused us to abort, then delete
            //  the Fcb, because we are the only ones who will.
            //

            if (!ReturnedExistingFcb && Fcb) {

                if (!AcquiredFcbTable) {

                    NtfsAcquireFcbTable( IrpContext, Vcb );
                    AcquiredFcbTable = TRUE;
                }
                NtfsDeleteFcb( IrpContext, &Fcb, &AcquiredFcbTable );

                ASSERT(!AcquiredFcbTable);
            }

            if (AcquiredFcbTable) {

                NtfsReleaseFcbTable( IrpContext, Vcb );
            }
        }
    }

    return Fcb;
}


VOID
NtfsFillBasicInfo (
    OUT PFILE_BASIC_INFORMATION Buffer,
    IN PSCB Scb
    )

/*++

Routine Description:

    This is the common routine which transfers data from the Scb/Fcb to the BasicInfo structure.

Arguments:

    Buffer - Pointer to structure to fill in.  Our caller has already validated it.

    Scb - Stream the caller has a handle to.

Return Value:

    None

--*/

{
    PFCB Fcb = Scb->Fcb;

    PAGED_CODE();

    //
    //  Zero the output buffer.
    //

    RtlZeroMemory( Buffer, sizeof( FILE_BASIC_INFORMATION ));

    //
    //  Fill in the basic information fields
    //

    Buffer->CreationTime.QuadPart = Fcb->Info.CreationTime;
    Buffer->LastWriteTime.QuadPart = Fcb->Info.LastModificationTime;
    Buffer->ChangeTime.QuadPart = Fcb->Info.LastChangeTime;
    Buffer->LastAccessTime.QuadPart = Fcb->CurrentLastAccess;

    //
    //  Capture the attributes from the Fcb except for the stream specific values.
    //  Also mask out any private Ntfs attribute flags.
    //

    Buffer->FileAttributes = Fcb->Info.FileAttributes;

    ClearFlag( Buffer->FileAttributes,
               (~FILE_ATTRIBUTE_VALID_FLAGS |
                FILE_ATTRIBUTE_COMPRESSED |
                FILE_ATTRIBUTE_TEMPORARY |
                FILE_ATTRIBUTE_SPARSE_FILE |
                FILE_ATTRIBUTE_ENCRYPTED) );

    //
    //  Pick up the sparse, encrypted and temp bits for this stream from the Scb.
    //

    if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

        SetFlag( Buffer->FileAttributes, FILE_ATTRIBUTE_SPARSE_FILE );
    }

    if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_ENCRYPTED )) {

        SetFlag( Buffer->FileAttributes, FILE_ATTRIBUTE_ENCRYPTED );
    }

    if (FlagOn( Scb->ScbState, SCB_STATE_TEMPORARY )) {

        SetFlag( Buffer->FileAttributes, FILE_ATTRIBUTE_TEMPORARY );
    }

    //
    //  If this is an index stream then mark it as a directory.  Capture the compressed
    //  state from either the Fcb or Scb.
    //

    if (Scb->AttributeTypeCode == $INDEX_ALLOCATION) {

        if (IsDirectory( &Fcb->Info ) || IsViewIndex( &Fcb->Info )) {

            SetFlag( Buffer->FileAttributes, FILE_ATTRIBUTE_DIRECTORY );

            //
            //  Capture the compression state from the Fcb.
            //

            SetFlag( Buffer->FileAttributes,
                     FlagOn( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_COMPRESSED ));

        //
        //  Otherwise capture the value in the Scb itself.
        //

        } else if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

            SetFlag( Buffer->FileAttributes, FILE_ATTRIBUTE_COMPRESSED );
        }

    //
    //  In all other cases we can use the value in the Scb.
    //

    } else {

        if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

            SetFlag( Buffer->FileAttributes, FILE_ATTRIBUTE_COMPRESSED );
        }
    }

    //
    //  If there are no flags set then explicitly set the NORMAL flag.
    //

    if (Buffer->FileAttributes == 0) {

        Buffer->FileAttributes = FILE_ATTRIBUTE_NORMAL;
    }

    return;
}


VOID
NtfsFillStandardInfo (
    OUT PFILE_STANDARD_INFORMATION Buffer,
    IN PSCB Scb,
    IN PCCB Ccb OPTIONAL
    )

/*++

Routine Description:

    This is the common routine which transfers data from the Scb/Fcb to the StandardInfo structure.

Arguments:

    Buffer - Pointer to structure to fill in.  Our caller has already validated it.

    Scb - Stream the caller has a handle to.

    Ccb - Ccb for the user's open.

Return Value:

    None

--*/

{
    PFCB Fcb = Scb->Fcb;
    PAGED_CODE();

    //
    //  Zero out the output buffer.
    //

    RtlZeroMemory( Buffer, sizeof( FILE_STANDARD_INFORMATION ));

    //
    //  Fill in the buffer from the Scb, Fcb and Ccb.
    //

    //
    //  Return sizes only for non-index streams.
    //

    if ((Scb->AttributeTypeCode != $INDEX_ALLOCATION) ||
        (!IsDirectory( &Fcb->Info ) && !IsViewIndex( &Fcb->Info ))) {

        Buffer->AllocationSize.QuadPart = Scb->TotalAllocated;
        Buffer->EndOfFile = Scb->Header.FileSize;
    }

    Buffer->NumberOfLinks = Fcb->LinkCount;

    //
    //  Let's initialize these boolean fields.
    //

    Buffer->DeletePending = Buffer->Directory = FALSE;

    //
    //  Get the delete and directory flags from the Fcb/Scb state.  Note that
    //  the sense of the delete pending bit refers to the file if opened as
    //  file.  Otherwise it refers to the attribute only.
    //
    //  But only do the test if the Ccb has been supplied.
    //

    if (ARGUMENT_PRESENT( Ccb )) {

        if (FlagOn( Ccb->Flags, CCB_FLAG_OPEN_AS_FILE )) {

            if ((Scb->Fcb->LinkCount == 0) ||
                ((Ccb->Lcb != NULL) && FlagOn( Ccb->Lcb->LcbState, LCB_STATE_DELETE_ON_CLOSE ))) {

                Buffer->DeletePending = TRUE;
            }

            Buffer->Directory = BooleanIsDirectory( &Scb->Fcb->Info );

        } else {

            Buffer->DeletePending = BooleanFlagOn( Scb->ScbState, SCB_STATE_DELETE_ON_CLOSE );
        }

    } else {

        Buffer->Directory = BooleanIsDirectory( &Scb->Fcb->Info );
    }

    return;
}


VOID
NtfsFillNetworkOpenInfo (
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    IN PSCB Scb
    )

/*++

Routine Description:

    This is the common routine which transfers data from the Scb/Fcb to the NetworkOpenInfo structure.

Arguments:

    Buffer - Pointer to structure to fill in.  Our caller has already validated it.

    Scb - Stream the caller has a handle to.

Return Value:

    None

--*/

{
    PFCB Fcb = Scb->Fcb;

    PAGED_CODE();

    //
    //  Zero the output buffer.
    //

    RtlZeroMemory( Buffer, sizeof( FILE_NETWORK_OPEN_INFORMATION ));

    //
    //  Fill in the basic information fields
    //

    Buffer->CreationTime.QuadPart = Fcb->Info.CreationTime;
    Buffer->LastWriteTime.QuadPart = Fcb->Info.LastModificationTime;
    Buffer->ChangeTime.QuadPart = Fcb->Info.LastChangeTime;
    Buffer->LastAccessTime.QuadPart = Fcb->CurrentLastAccess;

    //
    //  Capture the attributes from the Fcb except for the stream specific values.
    //  Also mask out any private Ntfs attribute flags.
    //

    Buffer->FileAttributes = Fcb->Info.FileAttributes;

    ClearFlag( Buffer->FileAttributes,
               (~FILE_ATTRIBUTE_VALID_FLAGS |
                FILE_ATTRIBUTE_COMPRESSED |
                FILE_ATTRIBUTE_TEMPORARY |
                FILE_ATTRIBUTE_SPARSE_FILE |
                FILE_ATTRIBUTE_ENCRYPTED) );

    //
    //  Pick up the sparse, encrypted and temp bits for this stream from the Scb.
    //

    if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

        SetFlag( Buffer->FileAttributes, FILE_ATTRIBUTE_SPARSE_FILE );
    }

    if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_ENCRYPTED )) {

        SetFlag( Buffer->FileAttributes, FILE_ATTRIBUTE_ENCRYPTED );
    }

    if (FlagOn( Scb->ScbState, SCB_STATE_TEMPORARY )) {

        SetFlag( Buffer->FileAttributes, FILE_ATTRIBUTE_TEMPORARY );
    }

    //
    //  If this is an index stream then mark it as a directory.  Capture the compressed
    //  state from either the Fcb or Scb.
    //

    if (Scb->AttributeTypeCode == $INDEX_ALLOCATION) {

        if (IsDirectory( &Fcb->Info ) || IsViewIndex( &Fcb->Info )) {

            SetFlag( Buffer->FileAttributes, FILE_ATTRIBUTE_DIRECTORY );

            //
            //  Capture the compression state from the Fcb.
            //

            SetFlag( Buffer->FileAttributes,
                     FlagOn( Fcb->Info.FileAttributes, FILE_ATTRIBUTE_COMPRESSED ));

        //
        //  Otherwise capture the value in the Scb itself.
        //

        } else if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

            SetFlag( Buffer->FileAttributes, FILE_ATTRIBUTE_COMPRESSED );
        }

    //
    //  In all other cases we can use the value in the Scb.
    //

    } else {

        if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

            SetFlag( Buffer->FileAttributes, FILE_ATTRIBUTE_COMPRESSED );
        }

        //
        //  In the non-index case we use the sizes from the Scb.
        //

        Buffer->AllocationSize.QuadPart = Scb->TotalAllocated;
        Buffer->EndOfFile = Scb->Header.FileSize;
    }

    //
    //  If there are no flags set then explicitly set the NORMAL flag.
    //

    if (Buffer->FileAttributes == 0) {

        Buffer->FileAttributes = FILE_ATTRIBUTE_NORMAL;
    }

    return;
}


//
//  Internal support routine
//

BOOLEAN
NtfsLookupInFileRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PFILE_REFERENCE BaseFileReference OPTIONAL,
    IN ATTRIBUTE_TYPE_CODE QueriedTypeCode,
    IN PCUNICODE_STRING QueriedName OPTIONAL,
    IN PVCN Vcn OPTIONAL,
    IN BOOLEAN IgnoreCase,
    IN PVOID QueriedValue OPTIONAL,
    IN ULONG QueriedValueLength,
    OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    )

/*++

Routine Description:

    This routine attempts to find the fist occurrence of an attribute with
    the specified AttributeTypeCode and the specified QueriedName in the
    specified BaseFileReference.  If we find one, its attribute record is
    pinned and returned.

Arguments:

    Fcb - Requested file.

    BaseFileReference - The base entry for this file in the MFT.  Only needed
        on initial invocation.

    QueriedTypeCode - The attribute code to search for, if present.

    QueriedName - The attribute name to search for, if present.

    Vcn - Search for the nonresident attribute instance that has this Vcn

    IgnoreCase - Ignore case while comparing names.  Ignored if QueriedName
        not present.

    QueriedValue - The actual attribute value to search for, if present.

    QueriedValueLength - The length of the attribute value to search for.
        Ignored if QueriedValue is not present.

    Context - Describes the prior found attribute on invocation (if
        this was not the initial enumeration), and contains the next found
        attribute on return.

Return Value:

    BOOLEAN - True if we found an attribute, false otherwise.

--*/

{
    PATTRIBUTE_RECORD_HEADER Attribute;
    BOOLEAN Result = FALSE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsLookupInFileRecord\n") );
    DebugTrace( 0, Dbg, ("Fcb = %08lx\n", Fcb) );
    DebugTrace( 0, Dbg, ("BaseFileReference = %08I64x\n",
                        ARGUMENT_PRESENT(BaseFileReference) ?
                        NtfsFullSegmentNumber( BaseFileReference ) :
                        0xFFFFFFFFFFFF) );
    DebugTrace( 0, Dbg, ("QueriedTypeCode = %08lx\n", QueriedTypeCode) );
    DebugTrace( 0, Dbg, ("QueriedName = %08lx\n", QueriedName) );
    DebugTrace( 0, Dbg, ("IgnoreCase = %02lx\n", IgnoreCase) );
    DebugTrace( 0, Dbg, ("QueriedValue = %08lx\n", QueriedValue) );
    DebugTrace( 0, Dbg, ("QueriedValueLength = %08lx\n", QueriedValueLength) );
    DebugTrace( 0, Dbg, ("Context = %08lx\n", Context) );

    //
    //  Is this the initial enumeration?  If so start at the beginning.
    //

    if (Context->FoundAttribute.Bcb == NULL) {

        PBCB Bcb;
        PFILE_RECORD_SEGMENT_HEADER FileRecord;
        PATTRIBUTE_RECORD_HEADER TempAttribute;

        ASSERT(!ARGUMENT_PRESENT(QueriedName) || !ARGUMENT_PRESENT(QueriedValue));

        NtfsReadFileRecord( IrpContext,
                            Fcb->Vcb,
                            BaseFileReference,
                            &Bcb,
                            &FileRecord,
                            &TempAttribute,
                            &Context->FoundAttribute.MftFileOffset );

        Attribute = TempAttribute;

        //
        //  Initialize the found attribute context
        //

        Context->FoundAttribute.Bcb = Bcb;
        Context->FoundAttribute.FileRecord = FileRecord;

        //
        //  And show that we have neither found nor used the External
        //  Attributes List attribute.
        //

        Context->AttributeList.Bcb = NULL;
        Context->AttributeList.AttributeList = NULL;

        //
        //  The Usn Journal support uses the Usn Journal Fcb to look up $STANDARD_INFORMATION
        //  in an arbitrary file.  We will detect the case of $STANDARD_INFORMATION and the
        //  "wrong" Fcb and get out.
        //

        if (ARGUMENT_PRESENT( BaseFileReference ) &&
            !NtfsEqualMftRef( BaseFileReference, &Fcb->FileReference ) &&
            (QueriedTypeCode == $STANDARD_INFORMATION) &&
            (Attribute->TypeCode == $STANDARD_INFORMATION)) {

            //
            //  We found it.  Return it in the enumeration context.
            //

            Context->FoundAttribute.Attribute = Attribute;

            DebugTrace( 0, Dbg, ("Context->FoundAttribute.Attribute < %08lx\n",
                               Attribute ));
            DebugTrace( -1, Dbg, ("NtfsLookupInFileRecord -> TRUE (No code or SI)\n") );

            try_return( Result = TRUE );
        }

        //
        //  Scan to see if there is an attribute list, and if so, defer
        //  immediately to NtfsLookupExternalAttribute - we must guide the
        //  enumeration by the attribute list.
        //

        while (TempAttribute->TypeCode <= $ATTRIBUTE_LIST) {

            if (TempAttribute->RecordLength == 0) {

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
            }

            if (TempAttribute->TypeCode == $ATTRIBUTE_LIST) {

                ULONG AttributeListLength;
                PATTRIBUTE_LIST_CONTEXT Ex = &Context->AttributeList;

                Context->FoundAttribute.Attribute = TempAttribute;

                if ((QueriedTypeCode != $UNUSED) &&
                    (QueriedTypeCode == $ATTRIBUTE_LIST)) {

                    //
                    //  We found it.  Return it in the enumeration context.
                    //

                    DebugTrace( 0, Dbg, ("Context->FoundAttribute.Attribute < %08lx\n",
                                        TempAttribute) );
                    DebugTrace( -1, Dbg, ("NtfsLookupInFileRecord -> TRUE (attribute list)\n") );

                    try_return( Result = TRUE );
                }

                //
                //  Build up the context for the attribute list by hand here
                //  for efficiency, so that we can call NtfsMapAttributeValue.
                //

                Ex->AttributeList = TempAttribute;

                NtfsMapAttributeValue( IrpContext,
                                       Fcb,
                                       (PVOID *)&Ex->FirstEntry,
                                       &AttributeListLength,
                                       &Ex->Bcb,
                                       Context );

                Ex->Entry = Ex->FirstEntry;
                Ex->BeyondFinalEntry = Add2Ptr( Ex->FirstEntry, AttributeListLength );

                //
                //  If the list is non-resident then remember the correct Bcb for
                //  the list.
                //

                if (!NtfsIsAttributeResident( TempAttribute )) {

                    Ex->NonresidentListBcb = Ex->Bcb;
                    Ex->Bcb = Context->FoundAttribute.Bcb;
                    Context->FoundAttribute.Bcb = NULL;

                //
                //  Otherwise unpin the Bcb for the current attribute.
                //

                } else {

                    NtfsUnpinBcb( IrpContext, &Context->FoundAttribute.Bcb );
                }

                //
                //  We are now ready to iterate through the external attributes.
                //  The Context->FoundAttribute.Bcb being NULL signals
                //  NtfsLookupExternalAttribute that is should start at
                //  Context->External.Entry instead of the entry immediately following.
                //

                Result = NtfsLookupExternalAttribute( IrpContext,
                                                    Fcb,
                                                    QueriedTypeCode,
                                                    QueriedName,
                                                    Vcn,
                                                    IgnoreCase,
                                                    QueriedValue,
                                                    QueriedValueLength,
                                                    Context );

                try_return( NOTHING );
            }

            TempAttribute = NtfsGetNextRecord( TempAttribute );
            NtfsCheckRecordBound( TempAttribute, FileRecord, Fcb->Vcb->BytesPerFileRecordSegment );
        }

        if ((QueriedTypeCode == $UNUSED) ||
            ((QueriedTypeCode == $STANDARD_INFORMATION) &&
             (Attribute->TypeCode == $STANDARD_INFORMATION))) {

            //
            //  We found it.  Return it in the enumeration context.
            //

            Context->FoundAttribute.Attribute = Attribute;

            DebugTrace( 0, Dbg, ("Context->FoundAttribute.Attribute < %08lx\n",
                               Attribute ));
            DebugTrace( -1, Dbg, ("NtfsLookupInFileRecord -> TRUE (No code or SI)\n") );

            try_return( Result = TRUE );
        }

    } else {

        //
        //  Special case if the prior found attribute was $END, this is
        //  because we cannot search for the next entry after $END.
        //

        Attribute = Context->FoundAttribute.Attribute;

        if (!Context->FoundAttribute.AttributeDeleted) {
            Attribute = NtfsGetNextRecord( Attribute );
        }

        NtfsCheckRecordBound( Attribute, Context->FoundAttribute.FileRecord, Fcb->Vcb->BytesPerFileRecordSegment );
        Context->FoundAttribute.AttributeDeleted = FALSE;

        if (Attribute->TypeCode == $END) {

            DebugTrace( -1, Dbg, ("NtfsLookupInFileRecord -> FALSE ($END)\n") );

            try_return( Result = FALSE );
        }

        if (Attribute->RecordLength == 0) {

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
        }

        if (QueriedTypeCode == $UNUSED) {

            //
            //  We found it.  Return it in the enumeration context.
            //

            Context->FoundAttribute.Attribute = Attribute;

            DebugTrace( 0, Dbg, ("Context->FoundAttribute.Attribute < %08lx\n",
                                Attribute) );
            DebugTrace( -1, Dbg, ("NtfsLookupInFileRecord -> TRUE (No code)\n") );

            try_return( Result = TRUE );
        }
    }

    Result = NtfsFindInFileRecord( IrpContext,
                                   Attribute,
                                   &Context->FoundAttribute.Attribute,
                                   QueriedTypeCode,
                                   QueriedName,
                                   IgnoreCase,
                                   QueriedValue,
                                   QueriedValueLength );

    try_exit: NOTHING;

    DebugTrace( -1, Dbg, ("NtfsLookupInFileRecord ->\n") );
    return Result;
}


//
//  Internal support routine
//

BOOLEAN
NtfsFindInFileRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PATTRIBUTE_RECORD_HEADER Attribute,
    OUT PATTRIBUTE_RECORD_HEADER *ReturnAttribute,
    IN ATTRIBUTE_TYPE_CODE QueriedTypeCode,
    IN PCUNICODE_STRING QueriedName OPTIONAL,
    IN BOOLEAN IgnoreCase,
    IN PVOID QueriedValue OPTIONAL,
    IN ULONG QueriedValueLength
    )

/*++

Routine Description:

    This routine looks up an attribute in a file record.  It returns
    TRUE if the attribute was found, or FALSE if not found.  If FALSE
    is returned, the return attribute pointer points to the spot where
    the described attribute should be inserted.  Thus this routine
    determines how attributes are collated within file records.

Arguments:

    Attribute - The attribute within the file record at which the search
                should begin.

    ReturnAttribute - Pointer to the found attribute if returning TRUE,
                      or to the position to insert the attribute if returning
                      FALSE.

    QueriedTypeCode - The attribute code to search for, if present.

    QueriedName - The attribute name to search for, if present.

    IgnoreCase - Ignore case while comparing names.  Ignored if QueriedName
        not present.

    QueriedValue - The actual attribute value to search for, if present.

    QueriedValueLength - The length of the attribute value to search for.
        Ignored if QueriedValue is not present.

Return Value:

    BOOLEAN - True if we found an attribute, false otherwise.

--*/

{
    PWCH UpcaseTable = IrpContext->Vcb->UpcaseTable;
    ULONG UpcaseTableSize = IrpContext->Vcb->UpcaseTableSize;

    PAGED_CODE();

    //
    //  Now walk through the base file record looking for the atttribute.  If
    //  the query is "exhausted", i.e., if a type code, attribute name, or
    //  value is encountered which is greater than the one we are querying for,
    //  then we return FALSE immediately out of this loop.  If an exact match
    //  is seen, we break, and return the match at the end of this routine.
    //  Otherwise we keep looping while the query is not exhausted.
    //
    //  IMPORTANT NOTE:
    //
    //  The exact semantics of this loop are important, as they determine the
    //  exact details of attribute ordering within the file record.  A change
    //  in the order of the tests within this loop CHANGES THE FILE STRUCTURE,
    //  and possibly makes older NTFS volumes unreadable.
    //

    while ( TRUE ) {

        //
        //  Mark this attribute position, since we may be returning TRUE
        //  or FALSE below.
        //

        *ReturnAttribute = Attribute;

        //
        //  Leave with the correct current position intact, if we hit the
        //  end or a greater attribute type code.
        //
        //  COLLATION RULE:
        //
        //      Attributes are ordered by increasing attribute type code.
        //

        if (QueriedTypeCode < Attribute->TypeCode) {

            DebugTrace( -1, Dbg, ("NtfsLookupInFileRecord->FALSE (Type Code)\n") );

            return FALSE;

        }

        if (Attribute->RecordLength == 0) {

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, NULL );
        }

        //
        //  If the attribute type code is a match, then need to check either
        //  the name or the value or return a match.
        //
        //  COLLATION RULE:
        //
        //      Within equal attribute type codes, attribute names are ordered
        //      by increasing lexigraphical order ignoring case.  If two names
        //      exist which are equal when case is ignored, they must not be
        //      equal when compared with exact case, and within such equal
        //      names they are ordered by increasing lexical value with exact
        //      case.
        //

        if (QueriedTypeCode == Attribute->TypeCode) {

            //
            //  Handle name-match case
            //

            if (ARGUMENT_PRESENT(QueriedName)) {

                UNICODE_STRING AttributeName;
                FSRTL_COMPARISON_RESULT Result;

                NtfsInitializeStringFromAttribute( &AttributeName, Attribute );

                //
                //  See if we have a name match.
                //

                if (NtfsAreNamesEqual( UpcaseTable,
                                       &AttributeName,
                                       QueriedName,
                                       IgnoreCase )) {

                    break;
                }

                //
                //  Compare the names ignoring case.
                //

                Result = NtfsCollateNames( UpcaseTable,
                                           UpcaseTableSize,
                                           QueriedName,
                                           &AttributeName,
                                           GreaterThan,
                                           TRUE);

                //
                //  Break out if the result is LessThan, or if the result
                //  is Equal to *and* the exact case compare yields LessThan.
                //

                if ((Result == LessThan) || ((Result == EqualTo) &&
                    (NtfsCollateNames( UpcaseTable,
                                       UpcaseTableSize,
                                       QueriedName,
                                       &AttributeName,
                                       GreaterThan,
                                       FALSE) == LessThan))) {

                    return FALSE;
                }

            //
            //  Handle value-match case
            //
            //  COLLATION RULE:
            //
            //      Values are collated by increasing values with unsigned-byte
            //      compares.  I.e., the first different byte is compared unsigned,
            //      and the value with the highest byte comes second.  If a shorter
            //      value is exactly equal to the first part of a longer value, then
            //      the shorter value comes first.
            //
            //      Note that for values which are actually Unicode strings, the
            //      collation is different from attribute name ordering above.  However,
            //      attribute ordering is visible outside the file system (you can
            //      query "openable" attributes), whereas the ordering of indexed values
            //      is not visible (for example you cannot query links).  In any event,
            //      the ordering of values must be considered up to the system, and
            //      *must* be considered nondetermistic from the standpoint of a user.
            //

            } else if (ARGUMENT_PRESENT( QueriedValue )) {

                ULONG Diff, MinLength;

                //
                //  Form the minimum of the ValueLength and the Attribute Value.
                //

                MinLength = Attribute->Form.Resident.ValueLength;

                if (QueriedValueLength < MinLength) {

                    MinLength = QueriedValueLength;
                }

                //
                //  Find the first different byte.
                //

                Diff = (ULONG)RtlCompareMemory( QueriedValue,
                                                NtfsGetValue(Attribute),
                                                MinLength );

                //
                //  The first substring was equal.
                //

                if (Diff == MinLength) {

                    //
                    //  If the two lengths are equal, then we have an exact
                    //  match.
                    //

                    if (QueriedValueLength == Attribute->Form.Resident.ValueLength) {

                        break;
                    }

                    //
                    //  Otherwise the shorter guy comes first; we can return
                    //  FALSE if the queried value is shorter.
                    //

                    if (QueriedValueLength < Attribute->Form.Resident.ValueLength) {

                        return FALSE;
                    }

                //
                //  Otherwise some byte was different.  Do an unsigned compare
                //  of that byte to determine the ordering.  Time to leave if
                //  the queried value byte is less.
                //

                } else if (*((PUCHAR)QueriedValue + Diff) <
                           *((PUCHAR)NtfsGetValue(Attribute) + Diff)) {

                    return FALSE;
                }

            //
            //  Otherwise we have a simple match on code
            //

            } else {

                break;
            }
        }

        Attribute = NtfsGetNextRecord( Attribute );
        NtfsCheckRecordBound( Attribute,
                              (ULONG_PTR)*ReturnAttribute & ~((ULONG_PTR)IrpContext->Vcb->BytesPerFileRecordSegment - 1),
                              IrpContext->Vcb->BytesPerFileRecordSegment );
    }



    return TRUE;
}


//
//  Internal support routine
//

BOOLEAN
NtfsLookupExternalAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ATTRIBUTE_TYPE_CODE QueriedTypeCode,
    IN PCUNICODE_STRING QueriedName OPTIONAL,
    IN PVCN Vcn OPTIONAL,
    IN BOOLEAN IgnoreCase,
    IN PVOID QueriedValue OPTIONAL,
    IN ULONG QueriedValueLength,
    OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    )

/*++

Routine Description:

    This routine attempts to find the first occurrence of an attribute with
    the specified AttributeTypeCode and the specified QueriedName and Value
    among the external attributes described by the Context.  If we find one,
    its attribute record is pinned and returned.

Arguments:

    Fcb - Requested file.

    QueriedTypeCode - The attribute code to search for, if present.

    QueriedName - The attribute name to search for, if present.

    Vcn - Lookup nonresident attribute instance with this Vcn

    IgnoreCase - Ignore case while comparing names.  Ignored if QueriedName
        not present.

    QueriedValue - The actual attribute value to search for, if present.

    QueriedValueLength - The length of the attribute value to search for.
        Ignored if QueriedValue is not present.

    Context - Describes the prior found attribute on invocation (if
        this was not the initial enumeration), and contains the next found
        attribute on return.

Return Value:

    BOOLEAN - True if we found an attribute, false otherwise.

--*/

{
    PATTRIBUTE_LIST_ENTRY Entry, LastEntry;
    PWCH UpcaseTable = IrpContext->Vcb->UpcaseTable;
    ULONG UpcaseTableSize = IrpContext->Vcb->UpcaseTableSize;
    BOOLEAN Terminating = FALSE;
    BOOLEAN TerminateOnNext = FALSE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsLookupExternalAttribute\n") );
    DebugTrace( 0, Dbg, ("Fcb = %08lx\n", Fcb) );
    DebugTrace( 0, Dbg, ("QueriedTypeCode = %08lx\n", QueriedTypeCode) );
    DebugTrace( 0, Dbg, ("QueriedName = %08lx\n", QueriedName) );
    DebugTrace( 0, Dbg, ("IgnoreCase = %02lx\n", IgnoreCase) );
    DebugTrace( 0, Dbg, ("QueriedValue = %08lx\n", QueriedValue) );
    DebugTrace( 0, Dbg, ("QueriedValueLength = %08lx\n", QueriedValueLength) );
    DebugTrace( 0, Dbg, ("Context = %08lx\n", Context) );

    //
    //  Check that our list is kosher.
    //

    if ((Context->AttributeList.Entry >= Context->AttributeList.BeyondFinalEntry) &&
        !Context->FoundAttribute.AttributeDeleted) {

        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
    }

    //
    //  Is this the initial enumeration?  If so start at the beginning.
    //

    LastEntry = NULL;
    if (Context->FoundAttribute.Bcb == NULL) {

        Entry = Context->AttributeList.Entry;

    //
    //  Else set Entry and LastEntry appropriately.
    //

    } else if (!Context->FoundAttribute.AttributeDeleted) {

        LastEntry = Context->AttributeList.Entry;
        Entry = NtfsGetNextRecord( LastEntry );

    } else {

        Entry = Context->AttributeList.Entry;
        Context->FoundAttribute.AttributeDeleted = FALSE;

        //
        //  If we are beyond the attribute list, we return false.  This will
        //  happen in the case where have removed an attribute record and
        //  there are no entries left in the attribute list.
        //

        if (Context->AttributeList.Entry >= Context->AttributeList.BeyondFinalEntry) {

            //
            //  In case the caller is doing an insert, we will position him at the end
            //  of the first file record, an always try to insert new attributes there.
            //

            NtfsUnpinBcb( IrpContext, &Context->FoundAttribute.Bcb );

            if (QueriedTypeCode != $UNUSED) {

                NtfsReadFileRecord( IrpContext,
                                    Fcb->Vcb,
                                    &Fcb->FileReference,
                                    &Context->FoundAttribute.Bcb,
                                    &Context->FoundAttribute.FileRecord,
                                    &Context->FoundAttribute.Attribute,
                                    &Context->FoundAttribute.MftFileOffset );

                //
                //  If returning FALSE, then take the time to really find the
                //  correct position in the file record for a subsequent insert.
                //

                NtfsFindInFileRecord( IrpContext,
                                      Context->FoundAttribute.Attribute,
                                      &Context->FoundAttribute.Attribute,
                                      QueriedTypeCode,
                                      QueriedName,
                                      IgnoreCase,
                                      QueriedValue,
                                      QueriedValueLength );
            }

            DebugTrace( -1, Dbg, ("NtfsLookupExternalAttribute -> FALSE\n") );

            return FALSE;
        }
    }

    //
    //  Now walk through the entries looking for an atttribute.
    //

    while (TRUE) {

        PATTRIBUTE_RECORD_HEADER Attribute;

        UNICODE_STRING EntryName;
        UNICODE_STRING AttributeName;

        PATTRIBUTE_LIST_ENTRY NextEntry;

        BOOLEAN CorrespondingAttributeFound;

        //
        //  Check to see if we are now pointing beyond the final entry
        //  and if so fall in to the loop to terminate pointing just
        //  after the last entry.
        //

        if (Entry >= Context->AttributeList.BeyondFinalEntry) {

            Terminating = TRUE;
            TerminateOnNext = TRUE;
            Entry = Context->AttributeList.Entry;

        } else {

            NtfsCheckRecordBound( Entry,
                                  Context->AttributeList.FirstEntry,
                                  PtrOffset( Context->AttributeList.FirstEntry,
                                             Context->AttributeList.BeyondFinalEntry ));

            if (Entry->RecordLength == 0) {

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
            }

            NextEntry = NtfsGetNextRecord( Entry );
        }

        Context->AttributeList.Entry = Entry;

        //
        //  Compare the type codes.  The external attribute entry list is
        //  ordered by type code, so if the queried type code is less than
        //  the entry type code we continue the while(), if it is
        //  greater than we break out of the while() and return failure.
        //  If equal, we move on to compare names.
        //

        if ((QueriedTypeCode != $UNUSED) &&
            !Terminating &&
            (QueriedTypeCode != Entry->AttributeTypeCode)) {

            if (QueriedTypeCode > Entry->AttributeTypeCode) {

                Entry = NextEntry;
                continue;

            //
            //  Set up to terminate on seeing a higher type code.
            //

            } else {

                Terminating = TRUE;
            }
        }

        //
        //  At this point we are OK by TypeCode, compare names.
        //

        EntryName.Length = EntryName.MaximumLength = Entry->AttributeNameLength * sizeof( WCHAR );
        EntryName.Buffer = Add2Ptr( Entry, Entry->AttributeNameOffset );

        if (ARGUMENT_PRESENT( QueriedName ) && !Terminating) {

            FSRTL_COMPARISON_RESULT Result;

            //
            //  See if we have a name match.
            //

            if (!NtfsAreNamesEqual( UpcaseTable,
                                    &EntryName,
                                    QueriedName,
                                    IgnoreCase )) {

                //
                //  Compare the names ignoring case.
                //

                Result = NtfsCollateNames( UpcaseTable,
                                           UpcaseTableSize,
                                           QueriedName,
                                           &EntryName,
                                           GreaterThan,
                                           TRUE);

                //
                //  Break out if the result is LessThan, or if the result
                //  is Equal to *and* the exact case compare yields LessThan.
                //

                if ((Result == LessThan) || ((Result == EqualTo) &&
                    (NtfsCollateNames( UpcaseTable,
                                       UpcaseTableSize,
                                       QueriedName,
                                       &EntryName,
                                       GreaterThan,
                                       FALSE) == LessThan))) {

                    Terminating = TRUE;

                } else {

                    Entry = NextEntry;
                    continue;
                }
            }
        }

        //
        //  Now search for the right Vcn range, if specified.  If we were passed a
        //  Vcn then look for the matching range in the current attribute.  In some
        //  cases we may be looking for the lowest range in the following complete
        //  attribute.  In those cases skip forward.
        //

        if (ARGUMENT_PRESENT( Vcn ) && !Terminating) {

            //
            //  Skip to the next attribute record under the following conditions.
            //
            //      1 - We are already past the Vcn point we are looking for in the current
            //          attribute.  Typically this happens when the caller is looking for
            //          the first attribute record for each of the attributes in the file.
            //
            //      2 - The desired Vcn for the current attribute falls in one of the
            //          subsequent attribute records.
            //

            if ((Entry->LowestVcn > *Vcn) ||

                ((NextEntry < Context->AttributeList.BeyondFinalEntry) &&
                 (NextEntry->LowestVcn <= *Vcn) &&
                 (NextEntry->AttributeTypeCode == Entry->AttributeTypeCode) &&
                 (NextEntry->AttributeNameLength == Entry->AttributeNameLength) &&
                 (RtlEqualMemory( Add2Ptr( NextEntry, NextEntry->AttributeNameOffset ),
                                  Add2Ptr( Entry, Entry->AttributeNameOffset ),
                                  Entry->AttributeNameLength * sizeof( WCHAR ))))) {

                Entry = NextEntry;
                continue;
            }
        }

        //
        //  Now we are also OK by name and Vcn, so now go find the attribute and
        //  compare against value, if specified.
        //

        if ((LastEntry == NULL) ||
            !NtfsEqualMftRef( &LastEntry->SegmentReference, &Entry->SegmentReference )) {

            PFILE_RECORD_SEGMENT_HEADER FileRecord;

            NtfsUnpinBcb( IrpContext, &Context->FoundAttribute.Bcb );

            NtfsReadFileRecord( IrpContext,
                                Fcb->Vcb,
                                &Entry->SegmentReference,
                                &Context->FoundAttribute.Bcb,
                                &FileRecord,
                                &Attribute,
                                &Context->FoundAttribute.MftFileOffset );

            Context->FoundAttribute.FileRecord = FileRecord;

        //
        //  If we already have the right record pinned, reload this pointer.
        //

        } else {

            Attribute = NtfsFirstAttribute( Context->FoundAttribute.FileRecord );
        }

        //
        //  Now quickly loop through looking for the correct attribute
        //  instance.
        //

        CorrespondingAttributeFound = FALSE;

        while (TRUE) {

            //
            //  Check that we can safely access this attribute.
            //

            NtfsCheckRecordBound( Attribute,
                                  Context->FoundAttribute.FileRecord,
                                  Fcb->Vcb->BytesPerFileRecordSegment );

            //
            //  Exit the loop if we have reached the $END record.
            //

            if (Attribute->TypeCode == $END) {

                break;
            }

            //
            //  Check that the attribute has a non-zero length.
            //

            if (Attribute->RecordLength == 0) {

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
            }

            if (Entry->Instance == Attribute->Instance) {

                //
                //  Well, the attribute list saved us from having to compare
                //  type code and name as we went through this file record,
                //  however now that we have found our attribute by its
                //  instance number, we will do a quick check to see that
                //  we got the right one.  Else the file is corrupt.
                //

                if (Entry->AttributeTypeCode != Attribute->TypeCode) {
                    break;
                }

                if (ARGUMENT_PRESENT( QueriedName )) {

                    NtfsInitializeStringFromAttribute( &AttributeName, Attribute );

                    if (!NtfsAreNamesEqual( UpcaseTable, &AttributeName, &EntryName, FALSE )) {
                        break;
                    }
                }

                //
                //  Show that we correctly found the attribute described in
                //  the attribute list.
                //

                CorrespondingAttributeFound = TRUE;

                Context->FoundAttribute.Attribute = Attribute;

                //
                //  Now we may just be here because we are terminating the
                //  scan on seeing the end, a higher attribute code, or a
                //  higher name.  If so, return FALSE here.
                //

                if (Terminating) {

                    //
                    //  If we hit the end of the attribute list, then we
                    //  are supposed to terminate after advancing the
                    //  attribute list entry.
                    //

                    if (TerminateOnNext) {

                        Context->AttributeList.Entry = NtfsGetNextRecord(Entry);
                    }

                    //
                    //  In case the caller is doing an insert, we will position him at the end
                    //  of the first file record, an always try to insert new attributes there.
                    //

                    NtfsUnpinBcb( IrpContext, &Context->FoundAttribute.Bcb );

                    if (QueriedTypeCode != $UNUSED) {

                        NtfsReadFileRecord( IrpContext,
                                            Fcb->Vcb,
                                            &Fcb->FileReference,
                                            &Context->FoundAttribute.Bcb,
                                            &Context->FoundAttribute.FileRecord,
                                            &Context->FoundAttribute.Attribute,
                                            &Context->FoundAttribute.MftFileOffset );

                        //
                        //  If returning FALSE, then take the time to really find the
                        //  correct position in the file record for a subsequent insert.
                        //

                        NtfsFindInFileRecord( IrpContext,
                                              Context->FoundAttribute.Attribute,
                                              &Context->FoundAttribute.Attribute,
                                              QueriedTypeCode,
                                              QueriedName,
                                              IgnoreCase,
                                              QueriedValue,
                                              QueriedValueLength );
                    }

                    DebugTrace( 0, Dbg, ("Context->FoundAttribute.Attribute < %08lx\n",
                                        Attribute) );
                    DebugTrace( -1, Dbg, ("NtfsLookupExternalAttribute -> FALSE\n") );

                    return FALSE;
                }

                //
                //  Now compare the value, if so queried.
                //

                if (!ARGUMENT_PRESENT( QueriedValue ) ||
                    NtfsEqualAttributeValue( Attribute,
                                             QueriedValue,
                                             QueriedValueLength ) ) {

                    //
                    //  It matches.  Return it in the enumeration context.
                    //

                    DebugTrace( 0, Dbg, ("Context->FoundAttribute.Attribute < %08lx\n",
                                        Attribute ));
                    DebugTrace( -1, Dbg, ("NtfsLookupExternalAttribute -> TRUE\n") );


                    //
                    //  Do basic attribute consistency check
                    //

                    if ((NtfsIsAttributeResident( Attribute )) &&
                        (Attribute->Form.Resident.ValueOffset + Attribute->Form.Resident.ValueLength > Attribute->RecordLength)) {
                        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
                    }

                    return TRUE;
                }
            }

            //
            //  Get the next attribute, and continue.
            //

            Attribute = NtfsGetNextRecord( Attribute );
        }

        //
        //  Did we even find the attribute corresponding to the entry?
        //  If not, something is messed up.  Raise file corrupt error.
        //

        if (!CorrespondingAttributeFound) {

            //
            //  For the moment, ASSERT this falsehood so that we may have
            //  a chance to peek before raising.
            //

            ASSERT( CorrespondingAttributeFound );

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
        }

        Entry = NtfsGetNextRecord( Entry );
    }
}


//
//  Internal support routine
//

BOOLEAN
NtfsGetSpaceForAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG Length,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    )

/*++

Routine Description:

    This routine gets space for a new attribute record at the position indicated
    in the Context structure.  As required, it will move attributes around,
    allocate an additional record in the Mft, or convert some other existing
    attribute to nonresident form.  The caller should already have checked if
    the new attribute he is inserting should be stored resident or nonresident.

    On return, it is invalid to continue to use any previously-retrieved pointers,
    Bcbs, or other position-dependent information retrieved from the Context
    structure, as any of these values are liable to change.  The file record in
    which the space has been found will already be pinned.

    Note, this routine DOES NOT actually make space for the attribute, it only
    verifies that sufficient space is there.  The caller may call
    NtfsRestartInsertAttribute to actually insert the attribute in place.

Arguments:

    Fcb - Requested file.

    Length - Quad-aligned length required in bytes.

    Context - Describes the position for the new attribute, as returned from
              the enumeration which failed to find an existing occurrence of
              the attribute.  This pointer will either be pointing to some
              other attribute in the record, or to the first free quad-aligned
              byte if the new attribute is to go at the end.

Return Value:

    FALSE - if a major move was necessary, and the caller should look up
            its desired position again and call back.
    TRUE - if the space was created

--*/

{
    PATTRIBUTE_RECORD_HEADER NextAttribute;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsGetSpaceForAttribute\n") );
    DebugTrace( 0, Dbg, ("Fcb = %08lx\n", Fcb) );
    DebugTrace( 0, Dbg, ("Length = %08lx\n", Length) );
    DebugTrace( 0, Dbg, ("Context = %08lx\n", Context) );

    ASSERT( IsQuadAligned( Length ) );

    NextAttribute = NtfsFoundAttribute( Context );
    FileRecord = NtfsContainingFileRecord( Context );

    //
    //  Make sure the buffer is pinned.
    //

    NtfsPinMappedAttribute( IrpContext, Fcb->Vcb, Context );

    //
    //  If the space is not there now, then make room and return with FALSE
    //

    if ((FileRecord->BytesAvailable - FileRecord->FirstFreeByte) < Length ) {

        MakeRoomForAttribute( IrpContext, Fcb, Length, Context );

        DebugTrace( -1, Dbg, ("NtfsGetSpaceForAttribute -> FALSE\n") );
        return FALSE;
    }

    DebugTrace( -1, Dbg, ("NtfsGetSpaceForAttribute -> TRUE\n") );
    return TRUE;
}


//
//  Internal support routine
//

BOOLEAN
NtfsChangeAttributeSize (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG Length,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    )

/*++

Routine Description:

    This routine adjustss the space occupied by the current attribute record
    in the Context structure.  As required, it will move attributes around,
    allocate an additional record in the Mft, or convert some other existing
    attribute to nonresident form.  The caller should already have checked if
    the current attribute he is inserting should rather be converted to
    nonresident.

    When done, this routine has updated any file records whose allocation was
    changed, and also the RecordLength field in the adjusted attribute.  No
    other attribute fields are updated.

    On return, it is invalid to continue to use any previously-retrieved pointers,
    Bcbs, or other position-dependent information retrieved from the Context
    structure, as any of these values are liable to change.  The file record in
    which the space has been found will already be pinned.

Arguments:

    Fcb - Requested file.

    Length - New quad-aligned length of attribute record in bytes

    Context - Describes the current attribute.

Return Value:

    FALSE - if a major move was necessary, and the caller should look up
            its desired position again and call back.
    TRUE - if the space was created

--*/

{
    PATTRIBUTE_RECORD_HEADER Attribute;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    LONG SizeChange;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsChangeAttributeSize\n") );
    DebugTrace( 0, Dbg, ("Fcb = %08lx\n", Fcb) );
    DebugTrace( 0, Dbg, ("Length = %08lx\n", Length) );
    DebugTrace( 0, Dbg, ("Context = %08lx\n", Context) );

    ASSERT( IsQuadAligned( Length ) );

    Attribute = NtfsFoundAttribute( Context );
    FileRecord = NtfsContainingFileRecord( Context );

    //
    //  Make sure the buffer is pinned.
    //

    NtfsPinMappedAttribute( IrpContext, Fcb->Vcb, Context );

    //
    //  Calculate the change in attribute record size.
    //

    ASSERT( IsQuadAligned( Attribute->RecordLength ) );
    SizeChange = Length - Attribute->RecordLength;

    //
    //  If there is not currently enough space, then we have to make room
    //  and return FALSE to our caller.
    //

    if ( (LONG)(FileRecord->BytesAvailable - FileRecord->FirstFreeByte) < SizeChange ) {

        MakeRoomForAttribute( IrpContext, Fcb, SizeChange, Context );

        DebugTrace( -1, Dbg, ("NtfsChangeAttributeSize -> FALSE\n") );

        return FALSE;
    }

    DebugTrace( -1, Dbg, ("NtfsChangeAttributeSize -> TRUE\n") );

    return TRUE;
}


//
//  Internal support routine
//

VOID
MakeRoomForAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG SizeNeeded,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    )

/*++

Routine Description:

    This routine attempts to make additional room for a new attribute or
    a growing attribute in a file record.  The algorithm is as follows.

    First continuously loop through the record looking at the largest n
    attributes, from the largest down, to see which one of these attributes
    is big enough to move, and which one qualifies for one of the following
    actions:

        1.  For an index root attribute, the indexing package may be called
            to "push" the index root, i.e., add another level to the BTree
            leaving only an end index record in the root.

        2.  For a resident attribute which is allowed to be made nonresident,
            the attribute is made nonresident, leaving only run information
            in the root.

        3.  If the attribute is already nonresident, then it can be moved to
            a separate file record.

    If none of the above operations can be performed, or not enough free space
    is recovered, then as a last resort the file record is split in two.  This
    would typically indicate that the file record is populated with a large
    number of small attributes.

    The first time step 3 above or a split of the file record occurs, the
    attribute list must be created for the file.

Arguments:

    Fcb - Requested file.

    SizeNeeded - Supplies the total amount of free space needed, in bytes.

    Context - Describes the insertion point for the attribute which does
              not fit.  NOTE -- This context is not valid on return.

Return Value:

    None

--*/

{
    PATTRIBUTE_RECORD_HEADER LargestAttributes[MAX_MOVEABLE_ATTRIBUTES];
    PATTRIBUTE_RECORD_HEADER Attribute;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    ULONG i;
    PVCB Vcb = Fcb->Vcb;

    PAGED_CODE();

    //
    //  Here is the current threshhold at which a move of an attribute will
    //  be considered.
    //

    FileRecord = NtfsContainingFileRecord( Context );

    //
    //  Find the largest attributes for this file record.
    //

    FindLargestAttributes( FileRecord, MAX_MOVEABLE_ATTRIBUTES, LargestAttributes );

    //
    //  Now loop from largest to smallest of the largest attributes,
    //  and see if there is something we can do.
    //

    for (i = 0; i < MAX_MOVEABLE_ATTRIBUTES; i += 1) {

        Attribute = LargestAttributes[i];

        //
        //  Look to the next attribute if there is no attribute at this array
        //  position.
        //

        if (Attribute == NULL) {

            continue;

        //
        //  If this is the Mft then any attribute that is 'BigEnoughToMove'
        //  except $DATA attributes outside the base file record.
        //  We need to keep those where they are in order to enforce the
        //  boot-strap mapping.
        //

        } else if (Fcb == Vcb->MftScb->Fcb) {

            if (Attribute->TypeCode == $DATA &&
                ((*(PLONGLONG) &FileRecord->BaseFileRecordSegment != 0) ||
                 (Attribute->RecordLength < Vcb->BigEnoughToMove))) {

                continue;
            }

        //
        //  Any attribute in a non-Mft file which is 'BigEnoughToMove' can
        //  be considered.  We also accept an $ATTRIBUTE_LIST attribute
        //  in a non-Mft file which must go non-resident in order for
        //  the attribute name to fit.  Otherwise we could be trying to
        //  add an attribute with a large name into the base file record.
        //  We will need space to store the name twice, once for the
        //  attribute list entry and once in the attribute.  This can take
        //  up 1024 bytes by itself.  We want to force the attribute list
        //  non-resident first so that the new attribute will fit.  We
        //  look at whether the attribute list followed by just the new data
        //  will fit in the file record.
        //

        } else if (Attribute->RecordLength < Vcb->BigEnoughToMove) {

            if ((Attribute->TypeCode != $ATTRIBUTE_LIST) ||
                ((PtrOffset( FileRecord, Attribute ) + Attribute->RecordLength + SizeNeeded + sizeof( LONGLONG)) <= FileRecord->BytesAvailable)) {

                continue;
            }
        }

        //
        //  If this attribute is an index root, then we can just call the
        //  indexing support to allocate a new index buffer and push the
        //  current resident contents down.
        //

        if (Attribute->TypeCode == $INDEX_ROOT) {

            PSCB IndexScb;
            UNICODE_STRING IndexName;

            //
            //  Don't push the root now if we previously deferred pushing the root.
            //  Set the IrpContext flag to indicate we should do the push
            //  and raise CANT_WAIT.
            //

            if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_DEFERRED_PUSH )) {

                SetFlag( IrpContext->State, IRP_CONTEXT_STATE_FORCE_PUSH );
                NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
            }

            IndexName.Length =
            IndexName.MaximumLength = (USHORT)Attribute->NameLength << 1;
            IndexName.Buffer = Add2Ptr( Attribute, Attribute->NameOffset );

            IndexScb = NtfsCreateScb( IrpContext,
                                      Fcb,
                                      $INDEX_ALLOCATION,
                                      &IndexName,
                                      FALSE,
                                      NULL );

            NtfsPushIndexRoot( IrpContext, IndexScb );

            return;

        //
        //  Otherwise, if this is a resident attribute which can go nonresident,
        //  then make it nonresident now.
        //

        } else if ((Attribute->FormCode == RESIDENT_FORM) &&
                   !FlagOn(NtfsGetAttributeDefinition(Vcb,
                                                      Attribute->TypeCode)->Flags,
                           ATTRIBUTE_DEF_MUST_BE_RESIDENT)) {

            NtfsConvertToNonresident( IrpContext, Fcb, Attribute, FALSE, NULL );

            return;

        //
        //  Finally, if the attribute is nonresident already, move it to its
        //  own record unless it is an attribute list.
        //

        } else if ((Attribute->FormCode == NONRESIDENT_FORM)
                   && (Attribute->TypeCode != $ATTRIBUTE_LIST)) {

            LONGLONG MftFileOffset;

            MftFileOffset = Context->FoundAttribute.MftFileOffset;

            MoveAttributeToOwnRecord( IrpContext,
                                      Fcb,
                                      Attribute,
                                      Context,
                                      NULL,
                                      NULL );

            return;
        }
    }

    //
    //  If we get here, it is because we failed to find enough space above.
    //  Our last resort is to split into two file records, and this has
    //  to work.  We should never reach this point for the Mft.
    //

    if (Fcb == Vcb->MftScb->Fcb) {

        NtfsRaiseStatus( IrpContext, STATUS_DISK_FULL, NULL, NULL );
    }

    SplitFileRecord( IrpContext, Fcb, SizeNeeded, Context );
}


//
//  Internal support routine
//

VOID
FindLargestAttributes (
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN ULONG Number,
    OUT PATTRIBUTE_RECORD_HEADER *AttributeArray
    )

/*++

Routine Description:

    This routine returns the n largest attributes from a file record in an
    array, ordered from largest to smallest.

Arguments:

    FileRecord - Supplies file record to scan for largest attributes.

    Number - Supplies the number of entries in the array.

    AttributeArray - Supplies the array which is to receive pointers to the
                     largest attributes.  This array must be zeroed prior
                     to calling this routine.

Return Value:

    None

--*/

{
    ULONG i, j;
    PATTRIBUTE_RECORD_HEADER Attribute;

    PAGED_CODE();

    RtlZeroMemory( AttributeArray, Number * sizeof(PATTRIBUTE_RECORD_HEADER) );

    Attribute = Add2Ptr( FileRecord, FileRecord->FirstAttributeOffset );

    while (Attribute->TypeCode != $END) {

        for (i = 0; i < Number; i++) {

            if ((AttributeArray[i] == NULL)

                    ||

                (AttributeArray[i]->RecordLength < Attribute->RecordLength)) {

                for (j = Number - 1; j != i; j--) {

                    AttributeArray[j] = AttributeArray[j-1];
                }

                AttributeArray[i] = Attribute;
                break;
            }
        }

        Attribute = Add2Ptr( Attribute, Attribute->RecordLength );
    }
}


//
//  Internal support routine
//

LONGLONG
MoveAttributeToOwnRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PATTRIBUTE_RECORD_HEADER Attribute,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context,
    OUT PBCB *NewBcb OPTIONAL,
    OUT PFILE_RECORD_SEGMENT_HEADER *NewFileRecord OPTIONAL
    )

/*++

Routine Description:

    This routine may be called to move a particular attribute to a separate
    file record.  If the file does not already have an attribute list, then
    one is created (else it is updated).

Arguments:

    Fcb - Requested file.

    Attribute - Supplies a pointer to the attribute which is to be moved.

    Context - Supplies a pointer to a context which was used to look up
              another attribute in the same file record.  If this is an Mft
              $DATA split we will point to the part that was split out of the
              first file record on return.  The call from NtfsAddAttributeAllocation
              depends on this.

    NewBcb - If supplied, returns the Bcb address for the file record
             that the attribute was moved to.  NewBcb and NewFileRecord must
             either both be specified or neither specified.

    NewFileRecord - If supplied, returns a pointer to the file record
                    that the attribute was moved to.  The caller may assume
                    that the moved attribute is the first one in the file
                    record.  NewBcb and NewFileRecord must either both be
                    specified or neither specified.

Return Value:

    LONGLONG - Segment reference number of new record without a sequence number.

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT ListContext;
    ATTRIBUTE_ENUMERATION_CONTEXT MoveContext;
    PFILE_RECORD_SEGMENT_HEADER FileRecord1, FileRecord2;
    PATTRIBUTE_RECORD_HEADER Attribute2;
    BOOLEAN FoundListContext;
    MFT_SEGMENT_REFERENCE Reference2;
    LONGLONG MftRecordNumber2;
    WCHAR NameBuffer[8];
    UNICODE_STRING AttributeName;
    ATTRIBUTE_TYPE_CODE AttributeTypeCode;
    VCN LowestVcn;
    BOOLEAN IsNonresident = FALSE;
    PBCB Bcb = NULL;
    PATTRIBUTE_TYPE_CODE NewEnd;
    PVCB Vcb = Fcb->Vcb;
    ULONG NewListSize = 0;
    BOOLEAN MftData = FALSE;
    PATTRIBUTE_RECORD_HEADER OldPosition = NULL;

    PAGED_CODE();

    //
    //  Make sure the attribute is pinned.
    //

    NtfsPinMappedAttribute( IrpContext,
                            Vcb,
                            Context );

    //
    //  See if we are being asked to move the Mft Data.
    //

    if ((Fcb == Vcb->MftScb->Fcb) && (Attribute->TypeCode == $DATA)) {

        MftData = TRUE;
    }

    NtfsInitializeAttributeContext( &ListContext );
    NtfsInitializeAttributeContext( &MoveContext );
    FileRecord1 = NtfsContainingFileRecord(Context);

    //
    //  Save a description of the attribute to help us look it up
    //  again, and to make clones if necessary.
    //

    ASSERT( IsQuadAligned( Attribute->RecordLength ) );
    AttributeTypeCode = Attribute->TypeCode;
    AttributeName.Length =
    AttributeName.MaximumLength = (USHORT)Attribute->NameLength << 1;
    AttributeName.Buffer = NameBuffer;

    if (AttributeName.Length > sizeof(NameBuffer)) {

        AttributeName.Buffer = NtfsAllocatePool( NonPagedPool, AttributeName.Length );
    }

    RtlCopyMemory( AttributeName.Buffer,
                   Add2Ptr(Attribute, Attribute->NameOffset),
                   AttributeName.Length );

    if (Attribute->FormCode == NONRESIDENT_FORM) {

        IsNonresident = TRUE;
        LowestVcn = Attribute->Form.Nonresident.LowestVcn;
    }

    try {

        //
        //  Lookup the list context so that we know where it is at.
        //

        FoundListContext =
          NtfsLookupAttributeByCode( IrpContext,
                                     Fcb,
                                     &Fcb->FileReference,
                                     $ATTRIBUTE_LIST,
                                     &ListContext );

        //
        //  If we do not already have an attribute list, then calculate
        //  how big it must be.  Note, there must only be one file record
        //  at this point.
        //

        if (!FoundListContext) {

            ASSERT( FileRecord1 == NtfsContainingFileRecord(&ListContext) );

            NewListSize = GetSizeForAttributeList( FileRecord1 );

        //
        //  Now if the attribute list already exists, we have to look up
        //  the first one we are going to move in order to update the
        //  attribute list later.
        //

        } else {

            if (!NtfsLookupAttributeByName( IrpContext,
                                            Fcb,
                                            &Fcb->FileReference,
                                            Attribute->TypeCode,
                                            &AttributeName,
                                            IsNonresident ?
                                              &LowestVcn :
                                              NULL,
                                            FALSE,
                                            &MoveContext )) {

                ASSERT( FALSE );
                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
            }

            ASSERT(Attribute == NtfsFoundAttribute(&MoveContext));
        }

        //
        //  Allocate a new file record and move the attribute over.
        //

        FileRecord2 = NtfsCloneFileRecord( IrpContext, Fcb, MftData, &Bcb, &Reference2 );

        //
        //  Remember the file record number for the new file record.
        //

        MftRecordNumber2 = NtfsFullSegmentNumber( &Reference2 );

        Attribute2 = Add2Ptr( FileRecord2, FileRecord2->FirstAttributeOffset );
        RtlCopyMemory( Attribute2, Attribute, (ULONG)Attribute->RecordLength );
        Attribute2->Instance = FileRecord2->NextAttributeInstance++;
        NewEnd = Add2Ptr( Attribute2, Attribute2->RecordLength );
        *NewEnd = $END;
        FileRecord2->FirstFreeByte = PtrOffset(FileRecord2, NewEnd)
                                     + QuadAlign( sizeof( ATTRIBUTE_TYPE_CODE ));

        //
        //  If this is the Mft Data attribute, we cannot really move it, we
        //  have to move all but the first part of it.
        //

        if (MftData) {

            PCHAR MappingPairs;
            ULONG NewSize;
            VCN OriginalLastVcn;
            VCN LastVcn;
            LONGLONG SavedFileSize = Attribute->Form.Nonresident.FileSize;
            LONGLONG SavedValidDataLength = Attribute->Form.Nonresident.ValidDataLength;
            PNTFS_MCB Mcb = &Vcb->MftScb->Mcb;

            NtfsCleanupAttributeContext( IrpContext, Context );
            NtfsInitializeAttributeContext( Context );

            if (!NtfsLookupAttributeByCode( IrpContext,
                                            Fcb,
                                            &Fcb->FileReference,
                                            $DATA,
                                            Context )) {

                ASSERT( FALSE );
                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
            }

            //
            //  Calculate the number of clusters in the Mft up to (possibly past) the
            //  first user file record, and decrement to get LastVcn to stay in first
            //  file record.
            //

            LastVcn = LlClustersFromBytes( Vcb,
                                           FIRST_USER_FILE_NUMBER *
                                           Vcb->BytesPerFileRecordSegment ) - 1;
            OriginalLastVcn = Attribute->Form.Nonresident.HighestVcn;

            //
            //  Now truncate the first Mft record.
            //

            NtfsDeleteAttributeAllocation( IrpContext,
                                           Vcb->MftScb,
                                           TRUE,
                                           &LastVcn,
                                           Context,
                                           FALSE );

            //
            //  Now get the first Lcn for the new file record.
            //

            LastVcn = Attribute->Form.Nonresident.HighestVcn + 1;
            Attribute2->Form.Nonresident.LowestVcn = LastVcn;

            //
            //  Calculate the size of the attribute record we will need.
            //  We only create mapping pairs through the highest Vcn on the
            //  disk.  We don't include any that are being added through the
            //  Mcb yet.
            //

            NewSize = SIZEOF_PARTIAL_NONRES_ATTR_HEADER
                      + QuadAlign( AttributeName.Length )
                      + QuadAlign( NtfsGetSizeForMappingPairs( Mcb,
                                                               MAXULONG,
                                                               LastVcn,
                                                               &OriginalLastVcn,
                                                               &LastVcn ));

            Attribute2->RecordLength = NewSize;

            //
            //  Assume no attribute name, and calculate where the Mapping Pairs
            //  will go.  (Update below if we are wrong.)
            //

            MappingPairs = (PCHAR)Attribute2 + SIZEOF_PARTIAL_NONRES_ATTR_HEADER;

            //
            //  If the attribute has a name, take care of that now.
            //

            if (AttributeName.Length != 0) {

                Attribute2->NameLength = (UCHAR)(AttributeName.Length / sizeof(WCHAR));
                Attribute2->NameOffset = (USHORT)PtrOffset(Attribute2, MappingPairs);
                RtlCopyMemory( MappingPairs,
                               AttributeName.Buffer,
                               AttributeName.Length );
                MappingPairs += QuadAlign( AttributeName.Length );
            }

            //
            //  We always need the mapping pairs offset.
            //

            Attribute2->Form.Nonresident.MappingPairsOffset =
              (USHORT)PtrOffset(Attribute2, MappingPairs);
            NewEnd = Add2Ptr( Attribute2, Attribute2->RecordLength );
            *NewEnd = $END;
            FileRecord2->FirstFreeByte = PtrOffset(FileRecord2, NewEnd)
                                         + QuadAlign( sizeof( ATTRIBUTE_TYPE_CODE ));

            //
            //  Now add the space in the file record.
            //

            *MappingPairs = 0;
            NtfsBuildMappingPairs( Mcb,
                                   Attribute2->Form.Nonresident.LowestVcn,
                                   &LastVcn,
                                   MappingPairs );

            Attribute2->Form.Nonresident.HighestVcn = LastVcn;

        } else {

            //
            //  Now log these changes and fix up the first file record.
            //

            FileRecord1->Lsn =
            NtfsWriteLog( IrpContext,
                          Vcb->MftScb,
                          NtfsFoundBcb(Context),
                          DeleteAttribute,
                          NULL,
                          0,
                          CreateAttribute,
                          Attribute,
                          Attribute->RecordLength,
                          NtfsMftOffset( Context ),
                          (ULONG)((PCHAR)Attribute - (PCHAR)FileRecord1),
                          0,
                          Vcb->BytesPerFileRecordSegment );

            //
            //  Remember the old position for the CreateAttributeList
            //

            OldPosition = Attribute;

            NtfsRestartRemoveAttribute( IrpContext,
                                        FileRecord1,
                                        (ULONG)((PCHAR)Attribute - (PCHAR)FileRecord1) );
        }

        FileRecord2->Lsn =
        NtfsWriteLog( IrpContext,
                      Vcb->MftScb,
                      Bcb,
                      InitializeFileRecordSegment,
                      FileRecord2,
                      FileRecord2->FirstFreeByte,
                      Noop,
                      NULL,
                      0,
                      LlBytesFromFileRecords( Vcb, MftRecordNumber2 ),
                      0,
                      0,
                      Vcb->BytesPerFileRecordSegment );

        //
        //  Finally, create the attribute list attribute if needed.
        //

        if (!FoundListContext) {

            NtfsCleanupAttributeContext( IrpContext, &ListContext );
            NtfsInitializeAttributeContext( &ListContext );
            CreateAttributeList( IrpContext,
                                 Fcb,
                                 FileRecord1,
                                 MftData ? NULL : FileRecord2,
                                 Reference2,
                                 OldPosition,
                                 NewListSize,
                                 &ListContext );
        //
        //  Otherwise we have to update the existing attribute list, but only
        //  if this is not the Mft data.  In that case the attribute list is
        //  still correct since we haven't moved the attribute entirely.
        //

        } else if (!MftData) {

            UpdateAttributeListEntry( IrpContext,
                                      Fcb,
                                      &MoveContext.AttributeList.Entry->SegmentReference,
                                      MoveContext.AttributeList.Entry->Instance,
                                      &Reference2,
                                      Attribute2->Instance,
                                      &ListContext );
        }

        NtfsCleanupAttributeContext( IrpContext, Context );
        NtfsInitializeAttributeContext( Context );

        if (!NtfsLookupAttributeByName( IrpContext,
                                        Fcb,
                                        &Fcb->FileReference,
                                        AttributeTypeCode,
                                        &AttributeName,
                                        IsNonresident ? &LowestVcn : NULL,
                                        FALSE,
                                        Context )) {

            ASSERT( FALSE );
            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
        }

        ASSERT(!IsNonresident || (LowestVcn == NtfsFoundAttribute(Context)->Form.Nonresident.LowestVcn));

        //
        //  For the case of the Mft split, we now add the final entry.
        //

        if (MftData) {

            //
            //  Finally, we have to add the entry to the attribute list.
            //  The routine we have to do this gets most of its inputs
            //  out of an attribute context.  Our context at this point
            //  does not have quite the right information, so we have to
            //  update it here before calling AddToAttributeList.
            //

            Context->FoundAttribute.FileRecord = FileRecord2;
            Context->FoundAttribute.Attribute = Attribute2;
            Context->AttributeList.Entry =
              NtfsGetNextRecord(Context->AttributeList.Entry);

            NtfsAddToAttributeList( IrpContext, Fcb, Reference2, Context );

            NtfsCleanupAttributeContext( IrpContext, Context );
            NtfsInitializeAttributeContext( Context );

            if (!NtfsLookupAttributeByCode( IrpContext,
                                            Fcb,
                                            &Fcb->FileReference,
                                            $DATA,
                                            Context )) {

                ASSERT( FALSE );
                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
            }

            while (IsNonresident &&
                   (Attribute2->Form.Nonresident.LowestVcn !=
                    NtfsFoundAttribute(Context)->Form.Nonresident.LowestVcn)) {

                if (!NtfsLookupNextAttributeByCode( IrpContext,
                                                    Fcb,
                                                    $DATA,
                                                    Context )) {

                    ASSERT( FALSE );
                    NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
                }
            }
        }

    } finally {

        if (AttributeName.Buffer != NameBuffer) {
            NtfsFreePool(AttributeName.Buffer);
        }

        if (ARGUMENT_PRESENT(NewBcb)) {

            ASSERT(ARGUMENT_PRESENT(NewFileRecord));

            *NewBcb = Bcb;
            *NewFileRecord = FileRecord2;

        } else {

            ASSERT(!ARGUMENT_PRESENT(NewFileRecord));

            NtfsUnpinBcb( IrpContext, &Bcb );
        }

        NtfsCleanupAttributeContext( IrpContext, &ListContext );
        NtfsCleanupAttributeContext( IrpContext, &MoveContext );
    }

    return MftRecordNumber2;
}


//
//  Internal support routine
//

VOID
SplitFileRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG SizeNeeded,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    )

/*++

Routine Description:

    This routine splits a file record in two, when it has been found that
    there is no room for a new attribute.  If the file does not already have
    an attribute list attribute then one is created.

    Essentially this routine finds the midpoint in the current file record
    (accounting for a potential new attribute list and also the space needed).
    Then it copies the second half of the file record over and fixes up the
    first record.  The attribute list is created at the end if required.

Arguments:

    Fcb - Requested file.

    SizeNeeded - Supplies the additional size needed, which is causing the split
                 to occur.

    Context - Supplies the attribute enumeration context pointing to the spot
              where the new attribute is to be inserted or grown.

Return Value:

    None

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT ListContext;
    ATTRIBUTE_ENUMERATION_CONTEXT MoveContext;
    PFILE_RECORD_SEGMENT_HEADER FileRecord1, FileRecord2;
    PATTRIBUTE_RECORD_HEADER Attribute1, Attribute2, Attribute;
    ULONG NewListOffset = 0;
    ULONG NewListSize = 0;
    ULONG NewAttributeOffset;
    ULONG SizeToStay;
    ULONG CurrentOffset, FutureOffset;
    ULONG SizeToMove;
    BOOLEAN FoundListContext;
    MFT_SEGMENT_REFERENCE Reference1, Reference2;
    LONGLONG MftFileRecord2;
    PBCB Bcb = NULL;
    ATTRIBUTE_TYPE_CODE EndCode = $END;
    PVCB Vcb = Fcb->Vcb;
    ULONG AdjustedAvailBytes;

    PAGED_CODE();

    //
    //  Make sure the attribute is pinned.
    //

    NtfsPinMappedAttribute( IrpContext,
                            Vcb,
                            Context );

    //
    //  Something is broken if we decide to split an Mft record.
    //

    ASSERT(Fcb != Vcb->MftScb->Fcb);

    NtfsInitializeAttributeContext( &ListContext );
    NtfsInitializeAttributeContext( &MoveContext );
    FileRecord1 = NtfsContainingFileRecord(Context);
    Attribute1 = NtfsFoundAttribute(Context);

    try {

        //
        //  Lookup the list context so that we know where it is at.
        //

        FoundListContext =
          NtfsLookupAttributeByCode( IrpContext,
                                     Fcb,
                                     &Fcb->FileReference,
                                     $ATTRIBUTE_LIST,
                                     &ListContext );

        //
        //  If we do not already have an attribute list, then calculate
        //  where it will go and how big it must be.  Note, there must
        //  only be one file record at this point.
        //

        if (!FoundListContext) {

            ASSERT( FileRecord1 == NtfsContainingFileRecord(&ListContext) );

            NewListOffset = PtrOffset( FileRecord1,
                                       NtfsFoundAttribute(&ListContext) );

            NewListSize = GetSizeForAttributeList( FileRecord1 ) +
                          SIZEOF_RESIDENT_ATTRIBUTE_HEADER;
        }

        //
        //  Similarly describe where the new attribute is to go, and how
        //  big it is (already in SizeNeeded).
        //

        NewAttributeOffset = PtrOffset( FileRecord1, Attribute1 );

        //
        //  Now calculate the approximate number of bytes that is to be split
        //  across two file records, and divide it in two, and that should give
        //  the amount that is to stay in the first record.
        //

        SizeToStay = (FileRecord1->FirstFreeByte + NewListSize +
                      SizeNeeded + sizeof(FILE_RECORD_SEGMENT_HEADER)) / 2;

        //
        //  We know that since we called this routine we need to split at
        //  least one entry from this file record.  We also base our
        //  split logic by finding the first attribute which WILL lie beyond
        //  the split point (after adding an attribute list and possibly
        //  an intermediate attribute).  We shrink the split point to the
        //  position at the end of where the current last attribute will be
        //  after adding the attribute list.  If we also add space before
        //  the last attribute then we know the last attribute will surely
        //  be split out.
        //

        if (SizeToStay > (FileRecord1->FirstFreeByte - sizeof( LONGLONG ) + NewListSize)) {

            SizeToStay = FileRecord1->FirstFreeByte - sizeof( LONGLONG ) + NewListSize;
        }

        //
        //  Now begin the loop through the attributes to find the splitting
        //  point.  We stop when we reach the end record or are past the attribute
        //  which contains the split point.  We will split at the current attribute
        //  if the remaining bytes after this attribute won't allow us to add
        //  the bytes we need for the caller or create an attribute list if
        //  it doesn't exist.
        //
        //  At this point the following variables indicate the following:
        //
        //      FutureOffset - This the offset of the current attribute
        //          after adding an attribute list and the attribute we
        //          are making space for.
        //
        //      CurrentOffset - Current position in the file record of
        //          of attribute being examined now.
        //
        //      NewListOffset - Offset to insert new attribute list into
        //          file record (0 indicates the list already exists).
        //
        //      NewAttributeOffset - Offset in the file record of the new
        //          attribute.  This refers to the file record as it exists
        //          when this routine is called.
        //

        FutureOffset =
        CurrentOffset = (ULONG)FileRecord1->FirstAttributeOffset;
        Attribute1 = Add2Ptr( FileRecord1, CurrentOffset );
        AdjustedAvailBytes = FileRecord1->BytesAvailable
                             - QuadAlign( sizeof( ATTRIBUTE_TYPE_CODE ));

        while (Attribute1->TypeCode != $END) {

            //
            //  See if the attribute list goes here.
            //

            if (CurrentOffset == NewListOffset) {

                //
                //  This attribute and all later attributes will be moved
                //  by the size of attribute list.
                //

                FutureOffset += NewListSize;
            }

            //
            //  See if the new attribute goes here.
            //

            if (CurrentOffset == NewAttributeOffset) {

                //
                //  This attribute and all later attributes will be moved
                //  by the size of new attribute.
                //

                FutureOffset += SizeNeeded;
            }

            FutureOffset += Attribute1->RecordLength;

            //
            //  Check if we are at the split point.  We split at this point
            //  if the end of the current attribute will be at or beyond the
            //  split point after adjusting for adding either an attribute list
            //  or new attribute.  We make this test >= since these two values
            //  will be equal if we reach the last attribute without finding
            //  the split point.  This way we guarantee a split will happen.
            //
            //  Note that we will go to the next attribute if the current attribute
            //  is the first attribute in the file record.  This can happen if the
            //  first attribute is resident and must stay resident but takes up
            //  half the file record or more (i.e. large filename attribute).
            //  We must make sure to split at least one attribute out of this
            //  record.
            //
            //  Never split when pointing at $STANDARD_INFORMATION or $ATTRIBUTE_LIST.
            //

            if ((Attribute1->TypeCode > $ATTRIBUTE_LIST) &&
                (FutureOffset >= SizeToStay) &&
                (CurrentOffset != FileRecord1->FirstAttributeOffset)) {

                break;
            }

            CurrentOffset += Attribute1->RecordLength;

            Attribute1 = Add2Ptr( Attribute1, Attribute1->RecordLength );
        }

        SizeToMove = FileRecord1->FirstFreeByte - CurrentOffset;

        //
        //  If we are pointing at the attribute list or at the end record
        //  we don't do the split.  Raise INSUFFICIENT_RESOURCES so our caller
        //  knows that we can't do the split.
        //

        if ((Attribute1->TypeCode == $END) || (Attribute1->TypeCode <= $ATTRIBUTE_LIST)) {

            NtfsRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES, NULL, NULL );
        }

        //
        //  Now if the attribute list already exists, we have to look up
        //  the first one we are going to move in order to update the
        //  attribute list later.
        //

        if (FoundListContext) {

            UNICODE_STRING AttributeName;
            BOOLEAN FoundIt;

            AttributeName.Length =
            AttributeName.MaximumLength = (USHORT)Attribute1->NameLength << 1;
            AttributeName.Buffer = Add2Ptr( Attribute1, Attribute1->NameOffset );

            FoundIt = NtfsLookupAttributeByName( IrpContext,
                                                 Fcb,
                                                 &Fcb->FileReference,
                                                 Attribute1->TypeCode,
                                                 &AttributeName,
                                                 (Attribute1->FormCode == NONRESIDENT_FORM) ?
                                                   &Attribute1->Form.Nonresident.LowestVcn :
                                                   NULL,
                                                 FALSE,
                                                 &MoveContext );

            //
            //  If we are splitting the file record between multiple attributes with
            //  the same name (i.e.  FILE_NAME attributes) then we need to find the
            //  correct attribute.  Since this is an unusual case we will just scan
            //  forwards from the current attribute until we find the correct attribute.
            //

            while (FoundIt && (Attribute1 != NtfsFoundAttribute( &MoveContext ))) {

                FoundIt = NtfsLookupNextAttributeByName( IrpContext,
                                                         Fcb,
                                                         Attribute1->TypeCode,
                                                         &AttributeName,
                                                         FALSE,
                                                         &MoveContext );
            }

            if (!FoundIt) {

                ASSERT( FALSE );
                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );

            }

            ASSERT(Attribute1 == NtfsFoundAttribute(&MoveContext));
        }

        //
        //  Now Attribute1 is pointing to the first attribute to move.
        //  Allocate a new file record and move the rest of our attributes
        //  over.
        //

        if (FoundListContext) {
            Reference1 = MoveContext.AttributeList.Entry->SegmentReference;
        }

        FileRecord2 = NtfsCloneFileRecord( IrpContext, Fcb, FALSE, &Bcb, &Reference2 );

        //
        //  Capture the file record number of the new file record.
        //

        MftFileRecord2 = NtfsFullSegmentNumber( &Reference2 );

        Attribute2 = Add2Ptr( FileRecord2, FileRecord2->FirstAttributeOffset );
        RtlCopyMemory( Attribute2, Attribute1, SizeToMove );
        FileRecord2->FirstFreeByte = (ULONG)FileRecord2->FirstAttributeOffset +
                                     SizeToMove;

        //
        //  Loop to update all of the attribute instance codes
        //

        for (Attribute = Attribute2;
             Attribute < (PATTRIBUTE_RECORD_HEADER)Add2Ptr(FileRecord2, FileRecord2->FirstFreeByte)
             && Attribute->TypeCode != $END;
             Attribute = NtfsGetNextRecord(Attribute)) {

            NtfsCheckRecordBound( Attribute, FileRecord2, Vcb->BytesPerFileRecordSegment );

            if (FoundListContext) {

                UpdateAttributeListEntry( IrpContext,
                                          Fcb,
                                          &Reference1,
                                          Attribute->Instance,
                                          &Reference2,
                                          FileRecord2->NextAttributeInstance,
                                          &ListContext );
            }

            Attribute->Instance = FileRecord2->NextAttributeInstance++;
        }

        //
        //  Now log these changes and fix up the first file record.
        //

        FileRecord2->Lsn = NtfsWriteLog( IrpContext,
                                         Vcb->MftScb,
                                         Bcb,
                                         InitializeFileRecordSegment,
                                         FileRecord2,
                                         FileRecord2->FirstFreeByte,
                                         Noop,
                                         NULL,
                                         0,
                                         LlBytesFromFileRecords( Vcb, MftFileRecord2 ),
                                         0,
                                         0,
                                         Vcb->BytesPerFileRecordSegment );

        FileRecord1->Lsn = NtfsWriteLog( IrpContext,
                                         Vcb->MftScb,
                                         NtfsFoundBcb(Context),
                                         WriteEndOfFileRecordSegment,
                                         &EndCode,
                                         sizeof(ATTRIBUTE_TYPE_CODE),
                                         WriteEndOfFileRecordSegment,
                                         Attribute1,
                                         SizeToMove,
                                         NtfsMftOffset( Context ),
                                         CurrentOffset,
                                         0,
                                         Vcb->BytesPerFileRecordSegment );

        NtfsRestartWriteEndOfFileRecord( FileRecord1,
                                         Attribute1,
                                         (PATTRIBUTE_RECORD_HEADER)&EndCode,
                                         sizeof(ATTRIBUTE_TYPE_CODE) );

        //
        //  Finally, create the attribute list attribute if needed.
        //

        if (!FoundListContext) {

            NtfsCleanupAttributeContext( IrpContext, &ListContext );
            NtfsInitializeAttributeContext( &ListContext );
            CreateAttributeList( IrpContext,
                                 Fcb,
                                 FileRecord1,
                                 FileRecord2,
                                 Reference2,
                                 NULL,
                                 NewListSize - SIZEOF_RESIDENT_ATTRIBUTE_HEADER,
                                 &ListContext );
        }

    } finally {

        NtfsUnpinBcb( IrpContext, &Bcb );

        NtfsCleanupAttributeContext( IrpContext, &ListContext );
        NtfsCleanupAttributeContext( IrpContext, &MoveContext );
    }
}


VOID
NtfsRestartWriteEndOfFileRecord (
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN PATTRIBUTE_RECORD_HEADER OldAttribute,
    IN PATTRIBUTE_RECORD_HEADER NewAttributes,
    IN ULONG SizeOfNewAttributes
    )

/*++

Routine Description:

    This routine is called both in the running system and at restart to
    modify the end of a file record, such as after it was split in two.

Arguments:

    FileRecord - Supplies the pointer to the file record.

    OldAttribute - Supplies a pointer to the first attribute to be overwritten.

    NewAttributes - Supplies a pointer to the new attribute(s) to be copied to
                    the spot above.

    SizeOfNewAttributes - Supplies the size to be copied in bytes.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    RtlMoveMemory( OldAttribute, NewAttributes, SizeOfNewAttributes );

    FileRecord->FirstFreeByte = PtrOffset(FileRecord, OldAttribute) +
                                SizeOfNewAttributes;

    //
    //  The size coming in may not be quad aligned.
    //

    FileRecord->FirstFreeByte = QuadAlign( FileRecord->FirstFreeByte );
}


//
//  Internal support routine
//

PFILE_RECORD_SEGMENT_HEADER
NtfsCloneFileRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN BOOLEAN MftData,
    OUT PBCB *Bcb,
    OUT PMFT_SEGMENT_REFERENCE FileReference
    )

/*++

Routine Description:

    This routine allocates an additional file record for an already existing
    and open file, for the purpose of overflowing attributes to this record.

Arguments:

    Fcb - Requested file.

    MftData - TRUE if the file record is being cloned to describe the
              $DATA attribute for the Mft.

    Bcb - Returns a pointer to the Bcb for the new file record.

    FileReference - returns the file reference for the new file record.

Return Value:

    Pointer to the allocated file record.

--*/

{
    LONGLONG FileRecordOffset;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    PVCB Vcb = Fcb->Vcb;

    PAGED_CODE();

    //
    //  First allocate the record.
    //

    *FileReference = NtfsAllocateMftRecord( IrpContext,
                                            Vcb,
                                            MftData );

    //
    //  Read it in and pin it.
    //

    NtfsPinMftRecord( IrpContext,
                      Vcb,
                      FileReference,
                      TRUE,
                      Bcb,
                      &FileRecord,
                      &FileRecordOffset );

    //
    //  Initialize it.
    //

    NtfsInitializeMftRecord( IrpContext,
                             Vcb,
                             FileReference,
                             FileRecord,
                             *Bcb,
                             BooleanIsDirectory( &Fcb->Info ));

    FileRecord->BaseFileRecordSegment = Fcb->FileReference;
    FileRecord->ReferenceCount = 0;
    FileReference->SequenceNumber = FileRecord->SequenceNumber;

    return FileRecord;
}


//
//  Internal support routine
//

ULONG
GetSizeForAttributeList (
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord
    )

/*++

Routine Description:

    This routine is designed to calculate the size that will be required for
    an attribute list attribute, for a base file record which is just about
    to split into two file record segments.

Arguments:

    FileRecord - Pointer to the file record which is just about to split.

Return Value:

    Size in bytes of the attribute list attribute that will be required,
    not including the attribute header size.

--*/

{
    PATTRIBUTE_RECORD_HEADER Attribute;
    ULONG Size = 0;

    PAGED_CODE();

    //
    //  Point to first attribute.
    //

    Attribute = Add2Ptr(FileRecord, FileRecord->FirstAttributeOffset);

    //
    //  Loop to add up size of required attribute list entries.
    //

    while (Attribute->TypeCode != $END) {

        Size += QuadAlign( FIELD_OFFSET( ATTRIBUTE_LIST_ENTRY, AttributeName )
                           + ((ULONG) Attribute->NameLength << 1));

        Attribute = Add2Ptr( Attribute, Attribute->RecordLength );
    }

    return Size;
}


//
//  Internal support routine
//

VOID
CreateAttributeList (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord1,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord2 OPTIONAL,
    IN MFT_SEGMENT_REFERENCE SegmentReference2,
    IN PATTRIBUTE_RECORD_HEADER OldPosition OPTIONAL,
    IN ULONG SizeOfList,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT ListContext
    )

/*++

Routine Description:

    This routine is intended to be called to create the attribute list attribute
    the first time.  The caller must have already calculated the size required
    for the list to pass into this routine.  The caller must have already
    removed any attributes from the base file record (FileRecord1) which are
    not to remain there.  He must then pass in a pointer to the base file record
    and optionally a pointer to a second file record from which the new
    attribute list is to be created.

Arguments:

    Fcb - Requested file.

    FileRecord1 - Pointer to the base file record, currently holding only those
                  attributes to be described there.

    FileRecord2 - Optionally points to a second file record from which the
                  second half of the attribute list is to be constructed.

    SegmentReference2 - The Mft segment reference of the second file record,
                        if one was supplied.

    OldPosition - Should only be specified if FileRecord2 is specified.  In this
                  case it must point to an attribute position in FileRecord1 from
                  which a single attribute was moved to file record 2.  It will be
                  used as an indication of where the attribute list entry should
                  be inserted.

    SizeOfList - Exact size of the attribute list which will be required.

    ListContext - Context resulting from an attempt to look up the attribute
                  list attribute, which failed.

Return Value:

    None

--*/

{
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    PATTRIBUTE_RECORD_HEADER Attribute;
    PATTRIBUTE_LIST_ENTRY AttributeList, ListEntry;
    MFT_SEGMENT_REFERENCE SegmentReference;

    PAGED_CODE();

    //
    //  Allocate space to construct the attribute list.  (The list
    //  cannot be constructed in place, because that would destroy error
    //  recovery.)
    //

    ListEntry =
    AttributeList = (PATTRIBUTE_LIST_ENTRY) NtfsAllocatePool(PagedPool, SizeOfList );

    //
    //  Use try-finally to deallocate on the way out.
    //

    try {

        //
        //  Loop to fill in the attribute list from the two file records
        //

        for (FileRecord = FileRecord1, SegmentReference = Fcb->FileReference;
             FileRecord != NULL;
             FileRecord = ((FileRecord == FileRecord1) ? FileRecord2 : NULL),
             SegmentReference = SegmentReference2) {

            //
            //  Point to first attribute.
            //

            Attribute = Add2Ptr( FileRecord, FileRecord->FirstAttributeOffset );

            //
            //  Loop to add up size of required attribute list entries.
            //

            while (Attribute->TypeCode != $END) {

                PATTRIBUTE_RECORD_HEADER NextAttribute;

                //
                //  See if we are at the remembered position.  If so:
                //
                //      Save this attribute to be the next one.
                //      Point to the single attribute in FileRecord2 instead
                //      Clear FileRecord2, as we will "consume" it here.
                //      Set the Segment reference in the ListEntry
                //

                if ((Attribute == OldPosition) && (FileRecord2 != NULL)) {

                    NextAttribute = Attribute;
                    Attribute = Add2Ptr(FileRecord2, FileRecord2->FirstAttributeOffset);
                    FileRecord2 = NULL;
                    ListEntry->SegmentReference = SegmentReference2;

                //
                //  Otherwise, this is the normal loop case.  So:
                //
                //      Set the next attribute pointer accordingly.
                //      Set the Segment reference from the loop control
                //

                } else {

                    NextAttribute = Add2Ptr(Attribute, Attribute->RecordLength);
                    ListEntry->SegmentReference = SegmentReference;
                }

                //
                //  Now fill in the list entry.
                //

                ListEntry->AttributeTypeCode = Attribute->TypeCode;
                ListEntry->RecordLength = (USHORT) QuadAlign( FIELD_OFFSET( ATTRIBUTE_LIST_ENTRY, AttributeName )
                                                              + ((ULONG) Attribute->NameLength << 1));
                ListEntry->AttributeNameLength = Attribute->NameLength;
                ListEntry->AttributeNameOffset =
                  (UCHAR)PtrOffset( ListEntry, &ListEntry->AttributeName[0] );

                ListEntry->Instance = Attribute->Instance;

                ListEntry->LowestVcn = 0;

                if (Attribute->FormCode == NONRESIDENT_FORM) {

                    ListEntry->LowestVcn = Attribute->Form.Nonresident.LowestVcn;
                }

                if (Attribute->NameLength != 0) {

                    RtlCopyMemory( &ListEntry->AttributeName[0],
                                   Add2Ptr(Attribute, Attribute->NameOffset),
                                   Attribute->NameLength << 1 );
                }

                ListEntry = Add2Ptr(ListEntry, ListEntry->RecordLength);
                Attribute = NextAttribute;
            }
        }

        //
        //  Now create the attribute list attribute.
        //

        NtfsCreateAttributeWithValue( IrpContext,
                                      Fcb,
                                      $ATTRIBUTE_LIST,
                                      NULL,
                                      AttributeList,
                                      SizeOfList,
                                      0,
                                      NULL,
                                      TRUE,
                                      ListContext );

    } finally {

        NtfsFreePool( AttributeList );
    }
}


//
//  Internal support routine
//

VOID
UpdateAttributeListEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PMFT_SEGMENT_REFERENCE OldFileReference,
    IN USHORT OldInstance,
    IN PMFT_SEGMENT_REFERENCE NewFileReference,
    IN USHORT NewInstance,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT ListContext
    )

/*++

Routine Description:

    This routine may be called to update a range of the attribute list
    as required by the movement of a range of attributes to a second record.
    The caller must supply a pointer to the file record to which the attributes
    have moved, along with the segment reference of that record.

Arguments:

    Fcb - Requested file.

    OldFileReference - Old File Reference for attribute

    OldInstance - Old Instance number for attribute

    NewFileReference - New File Reference for attribute

    NewInstance - New Instance number for attribute

    ListContext - The attribute enumeration context which was used to locate
                  the attribute list.

Return Value:

    None

--*/

{
    PATTRIBUTE_LIST_ENTRY AttributeList, ListEntry, BeyondList;
    PBCB Bcb = NULL;
    ULONG SizeOfList;
    ATTRIBUTE_LIST_ENTRY NewEntry;
    PATTRIBUTE_RECORD_HEADER Attribute;

    PAGED_CODE();

    //
    //  Map the attribute list if the attribute is non-resident.  Otherwise the
    //  attribute is already mapped and we have a Bcb in the attribute context.
    //

    Attribute = NtfsFoundAttribute( ListContext );

    if (!NtfsIsAttributeResident( Attribute )) {

        NtfsMapAttributeValue( IrpContext,
                               Fcb,
                               (PVOID *) &AttributeList,
                               &SizeOfList,
                               &Bcb,
                               ListContext );

    //
    //  Don't call the Map attribute routine because it NULLs the Bcb in the
    //  attribute list.  This Bcb is needed for ChangeAttributeValue to mark
    //  the page dirty.
    //

    } else {

        AttributeList = (PATTRIBUTE_LIST_ENTRY) NtfsAttributeValue( Attribute );
        SizeOfList = Attribute->Form.Resident.ValueLength;
    }

    //
    //  Make sure we unpin the list.
    //

    try {

        //
        //  Point beyond the end of the list.
        //

        BeyondList = (PATTRIBUTE_LIST_ENTRY)Add2Ptr( AttributeList, SizeOfList );

        //
        //  Loop through all of the attribute list entries until we find the one
        //  we need to change.
        //

        for (ListEntry = AttributeList;
             ListEntry < BeyondList;
             ListEntry = NtfsGetNextRecord(ListEntry)) {

            if ((ListEntry->Instance == OldInstance) &&
                NtfsEqualMftRef(&ListEntry->SegmentReference, OldFileReference)) {

                break;
            }
        }

        //
        //  Check that an update the the mft preserves the self-describing property
        //

        ASSERT( (Fcb != Fcb->Vcb->MftScb->Fcb) ||
                (ListEntry->AttributeTypeCode != $DATA) ||
                ((ULONGLONG)(ListEntry->LowestVcn) > (NtfsFullSegmentNumber( NewFileReference ) >> Fcb->Vcb->MftToClusterShift)) );

        //
        //  We better have found it!
        //

        ASSERT(ListEntry < BeyondList);

        if (ListEntry >= BeyondList) {

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
        }

        //
        //  Make a copy of the fixed portion of the attribute list entry,
        //  and update to describe the new attribute location.
        //

        RtlCopyMemory( &NewEntry, ListEntry, sizeof(ATTRIBUTE_LIST_ENTRY) );

        NewEntry.SegmentReference = *NewFileReference;
        NewEntry.Instance = NewInstance;

        //
        //  Update the attribute list entry.
        //

        NtfsChangeAttributeValue( IrpContext,
                                  Fcb,
                                  PtrOffset(AttributeList, ListEntry),
                                  &NewEntry,
                                  sizeof(ATTRIBUTE_LIST_ENTRY),
                                  FALSE,
                                  TRUE,
                                  FALSE,
                                  TRUE,
                                  ListContext );

    } finally {

        NtfsUnpinBcb( IrpContext, &Bcb );
    }
}


//
//  Local support routine
//

VOID
NtfsAddNameToParent (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ParentScb,
    IN PFCB ThisFcb,
    IN BOOLEAN IgnoreCase,
    IN PBOOLEAN LogIt,
    IN PFILE_NAME FileNameAttr,
    OUT PUCHAR FileNameFlags,
    OUT PQUICK_INDEX QuickIndex OPTIONAL,
    IN PNAME_PAIR NamePair OPTIONAL,
    IN PINDEX_CONTEXT IndexContext OPTIONAL
    )

/*++

Routine Description:

    This routine will create the filename attribute with the given name.
    Depending on the IgnoreCase flag, this is either a link or an Ntfs
    name.  If it is an Ntfs name, we check if it is also the Dos name.

    We build a file name attribute and then add it via ThisFcb, we then
    add this entry to the parent.

    If the name is a Dos name and we are given tunneling information on
    the long name, we will add the long name attribute as well.

Arguments:

    ParentScb - This is the parent directory for the file.

    ThisFcb - This is the file to add the filename to.

    IgnoreCase - Indicates if this name is case insensitive.  Only for Posix
        will this be FALSE.

    LogIt - Indicates if we should log this operation.  If FALSE and this is a large
        name then log the file record and begin logging.

    FileNameAttr - This contains a file name attribute structure to use.

    FileNameFlags - We store a copy of the File name flags used in the file
        name attribute.

    QuickIndex - If specified, we store the information about the location of the
        index entry added.

    NamePair - If specified, we add the tunneled NTFS-only name if the name we are
        directly adding is DOS-only.

    IndexContext - Previous result of doing the lookup for the name in the index.

Return Value:

    None - This routine will raise on error.

--*/

{
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsAddNameToParent:  Entered\n") );

    NtfsInitializeAttributeContext( &AttrContext );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Decide whether the name is a link, Ntfs-Only or Ntfs/8.3 combined name.
        //  Update the filename attribute to reflect this.
        //

        if (!IgnoreCase) {

            *FileNameFlags = 0;

        } else {

            UNICODE_STRING FileName;

            FileName.Length = FileName.MaximumLength = (USHORT)(FileNameAttr->FileNameLength * sizeof(WCHAR));
            FileName.Buffer = FileNameAttr->FileName;

            *FileNameFlags = FILE_NAME_NTFS;

            if (NtfsIsFatNameValid( &FileName, FALSE )) {

                *FileNameFlags |= FILE_NAME_DOS;
            }

            //
            //  If the name is DOS and there was a tunneled NTFS name, add it first if both names
            //  exist in the pair (there may only be one in the long side). Note that we
            //  really need to do this first so we lay down the correct filename flags.
            //

            if (NamePair &&
                (NamePair->Long.Length > 0) &&
                (NamePair->Short.Length > 0) &&
                (*FileNameFlags == (FILE_NAME_NTFS | FILE_NAME_DOS))) {

                if (NtfsAddTunneledNtfsOnlyName(IrpContext,
                                                ParentScb,
                                                ThisFcb,
                                                &NamePair->Long,
                                                LogIt )) {

                    //
                    //  Name didn't conflict and was added, so fix up the FileNameFlags
                    //

                    *FileNameFlags = FILE_NAME_DOS;

                    //
                    //  Make sure we reposition in the index for the actual insertion.
                    //

                    IndexContext = NULL;

                    //
                    //  We also need to upcase the short DOS name since we don't know the
                    //  case of what the user handed us and all DOS names are upcase. Note
                    //  that prior to tunneling being supported it was not possible for a user
                    //  to specify a short name, so this is a new situation.
                    //

                    RtlUpcaseUnicodeString(&FileName, &FileName, FALSE);
                }
            }
        }

        //
        //  Now update the file name attribute.
        //

        FileNameAttr->Flags = *FileNameFlags;

        //
        //  If we haven't been logging and this is a large name then begin logging.
        //

        if (!(*LogIt) &&
            (FileNameAttr->FileNameLength > 100)) {

            //
            //  Look up the file record and log its current state.
            //

            if (!NtfsLookupAttributeByCode( IrpContext,
                                            ThisFcb,
                                            &ThisFcb->FileReference,
                                            $STANDARD_INFORMATION,
                                            &AttrContext )) {

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, ThisFcb );
            }

            NtfsPinMappedAttribute( IrpContext, ThisFcb->Vcb, &AttrContext );
            FileRecord = NtfsContainingFileRecord( &AttrContext );

            //
            //  Log the current state of the file record.
            //

            FileRecord->Lsn = NtfsWriteLog( IrpContext,
                                            ThisFcb->Vcb->MftScb,
                                            NtfsFoundBcb( &AttrContext ),
                                            InitializeFileRecordSegment,
                                            FileRecord,
                                            FileRecord->FirstFreeByte,
                                            Noop,
                                            NULL,
                                            0,
                                            NtfsMftOffset( &AttrContext ),
                                            0,
                                            0,
                                            ThisFcb->Vcb->BytesPerFileRecordSegment );

            *LogIt = TRUE;
            NtfsCleanupAttributeContext( IrpContext, &AttrContext );
            NtfsInitializeAttributeContext( &AttrContext );
        }

        //
        //  Put it in the file record.
        //

        NtfsCreateAttributeWithValue( IrpContext,
                                      ThisFcb,
                                      $FILE_NAME,
                                      NULL,
                                      FileNameAttr,
                                      NtfsFileNameSize( FileNameAttr ),
                                      0,
                                      &FileNameAttr->ParentDirectory,
                                      *LogIt,
                                      &AttrContext );

        //
        //  Now put it in the index entry.
        //

        NtfsAddIndexEntry( IrpContext,
                           ParentScb,
                           FileNameAttr,
                           NtfsFileNameSize( FileNameAttr ),
                           &ThisFcb->FileReference,
                           IndexContext,
                           QuickIndex );

    } finally {

        DebugUnwind( NtfsAddNameToParent );

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );

        DebugTrace( -1, Dbg, ("NtfsAddNameToParent:  Exit\n") );
    }

    return;
}


//
//  Local support routine
//

VOID
NtfsAddDosOnlyName (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ParentScb,
    IN PFCB ThisFcb,
    IN UNICODE_STRING FileName,
    IN BOOLEAN LogIt,
    IN PUNICODE_STRING SuggestedDosName OPTIONAL
    )

/*++

Routine Description:

    This routine is called to build a Dos only name attribute an put it in
    the file record and the parent index.  We need to allocate pool large
    enough to hold the name (easy for 8.3) and then check that the generated
    names don't already exist in the parent. Use the suggested name first if
    possible.

Arguments:

    ParentScb - This is the parent directory for the file.

    ThisFcb - This is the file to add the filename to.

    FileName - This is the file name to add.

    LogIt - Indicates if we should log this operation.

    SuggestedDosName - If supplied, a name to try to use before auto-generation

Return Value:

    None - This routine will raise on error.

--*/

{
    GENERATE_NAME_CONTEXT NameContext;
    PFILE_NAME FileNameAttr;
    UNICODE_STRING Name8dot3;

    PINDEX_ENTRY IndexEntry;
    PBCB IndexEntryBcb;
    UCHAR TrailingDotAdj;

    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;

    BOOLEAN TrySuggestedDosName = TRUE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsAddDosOnlyName:  Entered\n") );

    IndexEntryBcb = NULL;

    RtlZeroMemory( &NameContext, sizeof( GENERATE_NAME_CONTEXT ));

    if (SuggestedDosName == NULL || SuggestedDosName->Length == 0) {

        //
        //  The SuggestedDosName can be zero length if we have a tunneled
        //  link or a tunneled file which was created whilst short name
        //  generation was disabled. It is a bad thing to drop down null
        //  filenames ...
        //

        TrySuggestedDosName = FALSE;
    }

    //
    //  The maximum length is 24 bytes, but 2 are already defined with the
    //  FILE_NAME structure.
    //

    FileNameAttr = NtfsAllocatePool(PagedPool, sizeof( FILE_NAME ) + 22 );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        NtfsInitializeAttributeContext( &AttrContext );

        //
        //  Set up the string to hold the generated name.  It will be part
        //  of the file name attribute structure.
        //

        Name8dot3.Buffer = FileNameAttr->FileName;
        Name8dot3.MaximumLength = 24;

        FileNameAttr->ParentDirectory = ParentScb->Fcb->FileReference;
        FileNameAttr->Flags = FILE_NAME_DOS;

        //
        //  Copy the info values into the filename attribute.
        //

        RtlCopyMemory( &FileNameAttr->Info,
                       &ThisFcb->Info,
                       sizeof( DUPLICATED_INFORMATION ));

        //
        //  We will loop indefinitely.  We generate a name, look in the parent
        //  for it.  If found we continue generating.  If not then we have the
        //  name we need.  Attempt to use the suggested name first.
        //

        while( TRUE ) {

            TrailingDotAdj = 0;

            if (TrySuggestedDosName) {

                Name8dot3.Length = SuggestedDosName->Length;
                RtlCopyMemory(Name8dot3.Buffer, SuggestedDosName->Buffer, SuggestedDosName->Length);
                Name8dot3.MaximumLength = SuggestedDosName->MaximumLength;

            } else {

                RtlGenerate8dot3Name( &FileName,
                                      BooleanFlagOn(NtfsData.Flags,NTFS_FLAGS_ALLOW_EXTENDED_CHAR),
                                      &NameContext,
                                      &Name8dot3 );

                if ((Name8dot3.Buffer[(Name8dot3.Length / sizeof( WCHAR )) - 1] == L'.') &&
                    (Name8dot3.Length > sizeof( WCHAR ))) {

                    TrailingDotAdj = 1;
                }
            }

            FileNameAttr->FileNameLength = (UCHAR)(Name8dot3.Length / sizeof( WCHAR )) - TrailingDotAdj;

            if (!NtfsFindIndexEntry( IrpContext,
                                     ParentScb,
                                     FileNameAttr,
                                     TRUE,
                                     NULL,
                                     &IndexEntryBcb,
                                     &IndexEntry,
                                     NULL )) {

                break;
            }

            NtfsUnpinBcb( IrpContext, &IndexEntryBcb );

            if (TrySuggestedDosName) {

                //
                //  Failed to use the suggested name, so fix up the 8.3 space
                //

                Name8dot3.Buffer = FileNameAttr->FileName;
                Name8dot3.MaximumLength = 24;

                TrySuggestedDosName = FALSE;
            }
        }

        //
        //  We add this entry to the file record.
        //

        NtfsCreateAttributeWithValue( IrpContext,
                                      ThisFcb,
                                      $FILE_NAME,
                                      NULL,
                                      FileNameAttr,
                                      NtfsFileNameSize( FileNameAttr ),
                                      0,
                                      &FileNameAttr->ParentDirectory,
                                      LogIt,
                                      &AttrContext );

        //
        //  We add this entry to the parent.
        //

        NtfsAddIndexEntry( IrpContext,
                           ParentScb,
                           FileNameAttr,
                           NtfsFileNameSize( FileNameAttr ),
                           &ThisFcb->FileReference,
                           NULL,
                           NULL );

    } finally {

        DebugUnwind( NtfsAddDosOnlyName );

        NtfsFreePool( FileNameAttr );

        NtfsUnpinBcb( IrpContext, &IndexEntryBcb );

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );

        DebugTrace( -1, Dbg, ("NtfsAddDosOnlyName:  Exit  ->  %08lx\n") );
    }

    return;
}


//
//  Local support routine
//

BOOLEAN
NtfsAddTunneledNtfsOnlyName (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ParentScb,
    IN PFCB ThisFcb,
    IN PUNICODE_STRING FileName,
    IN PBOOLEAN LogIt
    )

/*++

Routine Description:

    This routine is called to attempt to insert a tunneled NTFS-only name
    attribute and put it in the file record and the parent index. If the
    name collides with an existing name nothing occurs.

Arguments:

    ParentScb - This is the parent directory for the file.

    ThisFcb - This is the file to add the filename to.

    FileName - This is the file name to add.

    LogIt - Indicates if we should log this operation.  If FALSE and this is a large
        name then log the file record and begin logging.

Return Value:

    Boolean true if the name is added, false otherwise

--*/

{
    PFILE_NAME FileNameAttr;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;

    PINDEX_ENTRY IndexEntry;
    PBCB IndexEntryBcb;

    BOOLEAN Added = FALSE;

    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsAddTunneledNtfsOnlyName:  Entered\n") );

    IndexEntryBcb = NULL;

    //
    //  One WCHAR is already defined with the FILE_NAME structure. It is unfortunate
    //  that we need to go to pool to do this ...
    //

    FileNameAttr = NtfsAllocatePool(PagedPool, sizeof( FILE_NAME ) + FileName->Length - sizeof(WCHAR) );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        NtfsInitializeAttributeContext( &AttrContext );

        RtlCopyMemory( FileNameAttr->FileName,
                       FileName->Buffer,
                       FileName->Length );

        FileNameAttr->FileNameLength = (UCHAR)(FileName->Length / sizeof(WCHAR));

        FileNameAttr->ParentDirectory = ParentScb->Fcb->FileReference;
        FileNameAttr->Flags = FILE_NAME_NTFS;

        //
        //  Copy the info values into the filename attribute.
        //

        RtlCopyMemory( &FileNameAttr->Info,
                       &ThisFcb->Info,
                       sizeof( DUPLICATED_INFORMATION ));

        //
        //  Try out the name
        //

        if (!NtfsFindIndexEntry( IrpContext,
                                ParentScb,
                                FileNameAttr,
                                TRUE,
                                NULL,
                                &IndexEntryBcb,
                                &IndexEntry,
                                NULL )) {

            //
            //  Restore the case of the tunneled name
            //

            RtlCopyMemory( FileNameAttr->FileName,
                           FileName->Buffer,
                           FileName->Length );

            //
            //  If we haven't been logging and this is a large name then begin logging.
            //

            if (!(*LogIt) &&
                (FileName->Length > 200)) {

                //
                //  Look up the file record and log its current state.
                //

                if (!NtfsLookupAttributeByCode( IrpContext,
                                                ThisFcb,
                                                &ThisFcb->FileReference,
                                                $STANDARD_INFORMATION,
                                                &AttrContext )) {

                    NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, ThisFcb );
                }

                NtfsPinMappedAttribute( IrpContext, ThisFcb->Vcb, &AttrContext );

                FileRecord = NtfsContainingFileRecord( &AttrContext );

                //
                //  Log the current state of the file record.
                //

                FileRecord->Lsn = NtfsWriteLog( IrpContext,
                                                ThisFcb->Vcb->MftScb,
                                                NtfsFoundBcb( &AttrContext ),
                                                InitializeFileRecordSegment,
                                                FileRecord,
                                                FileRecord->FirstFreeByte,
                                                Noop,
                                                NULL,
                                                0,
                                                NtfsMftOffset( &AttrContext ),
                                                0,
                                                0,
                                                ThisFcb->Vcb->BytesPerFileRecordSegment );

                *LogIt = TRUE;
                NtfsCleanupAttributeContext( IrpContext, &AttrContext );
                NtfsInitializeAttributeContext( &AttrContext );
            }

            //
            //  We add this entry to the file record.
            //

            NtfsCreateAttributeWithValue( IrpContext,
                                          ThisFcb,
                                          $FILE_NAME,
                                          NULL,
                                          FileNameAttr,
                                          NtfsFileNameSize( FileNameAttr ),
                                          0,
                                          &FileNameAttr->ParentDirectory,
                                          *LogIt,
                                          &AttrContext );

            //
            //  We add this entry to the parent.
            //

            NtfsAddIndexEntry( IrpContext,
                               ParentScb,
                               FileNameAttr,
                               NtfsFileNameSize( FileNameAttr ),
                               &ThisFcb->FileReference,
                               NULL,
                               NULL );

            //
            //  Flag the addition
            //

            Added = TRUE;
         }

    } finally {

        DebugUnwind( NtfsAddTunneledNtfsOnlyName );

        NtfsFreePool( FileNameAttr );

        NtfsUnpinBcb( IrpContext, &IndexEntryBcb );

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );

        DebugTrace( -1, Dbg, ("NtfsAddTunneledNtfsOnlyName:  Exit  ->  %08lx\n", Added) );
    }

    return Added;
}


//
//  Local support routine
//

USHORT
NtfsScanForFreeInstance (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord
    )

/*++

Routine Description:

    This routine is called when we are adding a new attribute to this file record
    but the instance number is significant.  We don't want the instance numbers
    to roll over so we will scan for a free instance number.

Arguments:

    Vcb - Vcb for this volume.

    FileRecord - This is the file record to look at.

Return Value:

    USHORT - Return the lowest free instance in the file record.

--*/

{
    PATTRIBUTE_RECORD_HEADER Attribute;
    ULONG AttributeCount = 0;
    ULONG CurrentIndex;
    ULONG MinIndex;
    ULONG LowIndex;
    USHORT CurrentMinInstance;
    USHORT CurrentInstances[0x80];
    USHORT LastInstance = 0xffff;

    PAGED_CODE();

    //
    //  Insert the existing attributes into our array.
    //

    Attribute = NtfsFirstAttribute( FileRecord );

    while (Attribute->TypeCode != $END) {

        //
        //  Store this instance in the current position in the array.
        //

        CurrentInstances[AttributeCount] = Attribute->Instance;
        AttributeCount += 1;

        Attribute = NtfsGetNextRecord( Attribute );
        NtfsCheckRecordBound( Attribute, FileRecord, Vcb->BytesPerFileRecordSegment );
    }

    //
    //  If there are no entries then return 0 as the instance to use.
    //

    if (AttributeCount == 0) {

        return 0;

    //
    //  If there is only one entry then either return 0 or 1.
    //

    } else if (AttributeCount == 1) {

        if (CurrentInstances[0] == 0) {

            return 1;

        } else {

            return 0;
        }
    }

    //
    //  We will start sorting the array.  We can stop as soon as we find a gap.
    //

    LowIndex = 0;

    while (LowIndex < AttributeCount) {

        //
        //  Walk through from our current position and find the lowest value.
        //

        MinIndex = LowIndex;
        CurrentMinInstance = CurrentInstances[MinIndex];
        CurrentIndex = LowIndex + 1;

        while (CurrentIndex < AttributeCount) {

            if (CurrentInstances[CurrentIndex] < CurrentMinInstance) {

                CurrentMinInstance = CurrentInstances[CurrentIndex];
                MinIndex = CurrentIndex;
            }

            CurrentIndex += 1;
        }

        //
        //  If there is a gap between the previous value and the current instance then
        //  we are done.
        //

        if ((USHORT) (LastInstance + 1) != CurrentMinInstance) {

            return LastInstance + 1;
        }

        //
        //  Otherwise move to the next index.
        //

        CurrentInstances[MinIndex] = CurrentInstances[LowIndex];
        CurrentInstances[LowIndex] = CurrentMinInstance;
        LastInstance = CurrentMinInstance;
        LowIndex += 1;
    }

    //
    //  We walked through all of the existing without finding a free entry.  Go ahead and
    //  return the next known instance.
    //

    return (USHORT) AttributeCount;
}


//
//  Local support routine
//

VOID
NtfsMergeFileRecords (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN BOOLEAN RestoreContext,
    IN PATTRIBUTE_ENUMERATION_CONTEXT Context
    )

/*++

Routine Description:

    This routine is called to possibly merge two file records which each consist of a single hole.
    We are given a context which points to either the first of second record.  We always
    remove the second and update the first if we can find the holes.

    NOTE - We always want to remove the second attribute not the first.  The first may have a
    TotalAllocated field which we can't lose.

Arguments:

    Scb - Scb for the stream being modified.

    RestoreContext - Indicates if we should be pointing at the merged record on exit.

    Context - This points to either the first or second record of the merge.  On return it will
        be in an indeterminant state unless our caller has specified that we should be pointing
        to the combined record.

Return Value:

    None

--*/

{
    PATTRIBUTE_RECORD_HEADER NewAttribute = NULL;
    PATTRIBUTE_RECORD_HEADER Attribute;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;

    ULONG MappingPairsSize;
    VCN LastVcn;
    VCN RestoreVcn;

    ULONG PassCount = 0;

    VCN NewFinalVcn;
    VCN NewStartVcn;

    PUCHAR NextMappingPairs;
    UCHAR VLength;
    UCHAR LLength;
    ULONG BytesAvail;

    BOOLEAN TryPrior = TRUE;

    PAGED_CODE();

    //
    //  Use a try finally to facilitate cleanup.
    //

    try {

        //
        //  Capture the file record and attribute.
        //

        Attribute = NtfsFoundAttribute( Context );
        FileRecord = NtfsContainingFileRecord( Context );

        //
        //  Remember the end of the current file record and the space available.
        //

        NewFinalVcn = Attribute->Form.Nonresident.HighestVcn;
        RestoreVcn = NewStartVcn = Attribute->Form.Nonresident.LowestVcn;
        BytesAvail = FileRecord->BytesAvailable - FileRecord->FirstFreeByte;

        //
        //  Start by checking if we can merge with the following file record.
        //

        if (NtfsLookupNextAttributeForScb( IrpContext, Scb, Context )) {

            Attribute = NtfsFoundAttribute( Context );

            //
            //  If this attribute also consists entirely of a hole then merge the
            //  previous hole.
            //

            NextMappingPairs = Add2Ptr( Attribute, Attribute->Form.Nonresident.MappingPairsOffset );
            LLength = *NextMappingPairs >> 4;
            VLength = *NextMappingPairs & 0x0f;
            NextMappingPairs = Add2Ptr( NextMappingPairs, LLength + VLength + 1);

            //
            //  Perform the merge if the current file record is a hole and
            //  there is space in the previous record.  There is space if the
            //  prior record has at least 8 available bytes or we know that
            //  the mapping pairs will only take 8 bytes (6 bytes for the Vcn).
            //  We don't want to deal with the rare (if not nonexistent) case
            //  where we need to grow the attribute in a full file record.
            //  Also check that the next range is contiguous.  In some cases we
            //  may split an existing filerecord into a hole and an allocated
            //  range.  We don't want to look ahead if we haven't written the
            //  next range.
            //

            if ((Attribute->Form.Nonresident.LowestVcn == NewFinalVcn + 1) &&
                (LLength == 0) &&
                (*NextMappingPairs == 0) &&
                ((BytesAvail >= 8) ||
                 (Attribute->Form.Nonresident.HighestVcn - NewStartVcn <= 0x7fffffffffff))) {

                TryPrior = FALSE;

                //
                //  Update the new highest vcn value.
                //

                NewFinalVcn = Attribute->Form.Nonresident.HighestVcn;
            }
        }

        //
        //  If we couldn't find a following file record then check for a
        //  previous file record.
        //

        if (TryPrior) {

            //
            //  Reinitialize the context and look up the attribute again if there
            //  is no previous or look up the previous attribute.
            //

            if (NewStartVcn != 0) {

                //
                //  Back up to the previous file record.
                //

                NewStartVcn -= 1;

            //
            //  If we were already at the first file record then there is
            //  nothing more to try.
            //

            } else {

                try_return( NOTHING );
            }

            NtfsCleanupAttributeContext( IrpContext, Context );
            NtfsInitializeAttributeContext( Context );

            NtfsLookupAttributeForScb( IrpContext, Scb, &NewStartVcn, Context );

            Attribute = NtfsFoundAttribute( Context );
            FileRecord = NtfsContainingFileRecord( Context );

            NextMappingPairs = Add2Ptr( Attribute, Attribute->Form.Nonresident.MappingPairsOffset );
            LLength = *NextMappingPairs >> 4;
            VLength = *NextMappingPairs & 0x0f;
            NextMappingPairs = Add2Ptr( NextMappingPairs, LLength + VLength + 1);
            BytesAvail = FileRecord->BytesAvailable - FileRecord->FirstFreeByte;

            //
            //  Update the new lowest vcn value.
            //

            NewStartVcn = Attribute->Form.Nonresident.LowestVcn;

            //
            //  Perform the merge if the current file record is a hole and
            //  there is space in the current record.  There is space if the
            //  current record has at least 8 available bytes or we know that
            //  the mapping pairs will only take 8 bytes (6 bytes for the Vcn).
            //

            if ((LLength != 0) ||
                (*NextMappingPairs != 0) ||
                ((BytesAvail < 8) &&
                 (NewFinalVcn - NewStartVcn > 0x7fffffffffff))) {

                try_return( NOTHING );
            }
        }

        //
        //  Now update the NtfsMcb to reflect the merge.  Start by unloading the existing
        //  ranges and then define a new range.
        //

        NtfsUnloadNtfsMcbRange( &Scb->Mcb,
                                NewStartVcn,
                                NewFinalVcn,
                                FALSE,
                                FALSE );

        NtfsDefineNtfsMcbRange( &Scb->Mcb,
                                NewStartVcn,
                                NewFinalVcn,
                                FALSE );

        NtfsAddNtfsMcbEntry( &Scb->Mcb,
                             NewStartVcn,
                             UNUSED_LCN,
                             NewFinalVcn - NewStartVcn + 1,
                             FALSE );

        //
        //  We need two passes through this loop, one for each record.
        //

        while (TRUE) {

            //
            //  Update our pointers to point to the attribute and file record.
            //

            Attribute = NtfsFoundAttribute( Context );

            //
            //  If we are at the first record then update the entry.
            //

            if (Attribute->Form.Nonresident.LowestVcn == NewStartVcn) {

                FileRecord = NtfsContainingFileRecord( Context );

                //
                //  Allocate a buffer to hold the new attribute.  Copy the existing attribute
                //  into this buffer and update the final vcn field.
                //

                NewAttribute = NtfsAllocatePool( PagedPool, Attribute->RecordLength + 8 );

                RtlCopyMemory( NewAttribute, Attribute, Attribute->RecordLength );
                LastVcn = NewAttribute->Form.Nonresident.HighestVcn = NewFinalVcn;

                //
                //  Now get the new mapping pairs size and build the mapping pairs.
                //  We could easily do it by hand but we want to always use the same
                //  routines to build these.
                //

                MappingPairsSize = NtfsGetSizeForMappingPairs( &Scb->Mcb,
                                                               0x10,
                                                               NewStartVcn,
                                                               &LastVcn,
                                                               &LastVcn );

                ASSERT( LastVcn > NewFinalVcn );

                NtfsBuildMappingPairs( &Scb->Mcb,
                                       NewStartVcn,
                                       &LastVcn,
                                       Add2Ptr( NewAttribute,
                                                NewAttribute->Form.Nonresident.MappingPairsOffset ));

                NewAttribute->RecordLength = QuadAlign( NewAttribute->Form.Nonresident.MappingPairsOffset + MappingPairsSize );

                //
                //  Make sure the current attribute is pinned.
                //

                NtfsPinMappedAttribute( IrpContext, Scb->Vcb, Context );

                //
                //  Now log the old and new attribute.
                //

                FileRecord->Lsn =
                NtfsWriteLog( IrpContext,
                              Scb->Vcb->MftScb,
                              NtfsFoundBcb( Context ),
                              DeleteAttribute,
                              NULL,
                              0,
                              CreateAttribute,
                              Attribute,
                              Attribute->RecordLength,
                              NtfsMftOffset( Context ),
                              PtrOffset( FileRecord, Attribute ),
                              0,
                              Scb->Vcb->BytesPerFileRecordSegment );

                //
                //  Now update the file record.
                //

                NtfsRestartRemoveAttribute( IrpContext, FileRecord, PtrOffset( FileRecord, Attribute ));

                FileRecord->Lsn =
                NtfsWriteLog( IrpContext,
                              Scb->Vcb->MftScb,
                              NtfsFoundBcb( Context ),
                              CreateAttribute,
                              NewAttribute,
                              NewAttribute->RecordLength,
                              DeleteAttribute,
                              NULL,
                              0,
                              NtfsMftOffset( Context ),
                              PtrOffset( FileRecord, Attribute ),
                              0,
                              Scb->Vcb->BytesPerFileRecordSegment );

                NtfsRestartInsertAttribute( IrpContext,
                                            FileRecord,
                                            PtrOffset( FileRecord, Attribute ),
                                            NewAttribute,
                                            NULL,
                                            NULL,
                                            0 );

                //
                //  Now we want to move to the next attribute and remove it if we
                //  haven't already.
                //

                if (PassCount == 0) {

                    if (!NtfsLookupNextAttributeForScb( IrpContext, Scb, Context )) {

                        ASSERTMSG( "Could not find next attribute for Scb\n", FALSE );
                        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
                    }

                //
                //  We are pointing to the correct file record in this case.
                //

                } else {

                    RestoreContext = FALSE;
                }

            } else {

                //
                //  Tell the delete routine to log the data and free the file record if
                //  possible but not to deallocate any clusters.  Since there are no
                //  clusters we can save the overhead of calling DeleteAllocation.
                //

                NtfsDeleteAttributeRecord( IrpContext,
                                           Scb->Fcb,
                                           DELETE_LOG_OPERATION | DELETE_RELEASE_FILE_RECORD,
                                           Context );

                //
                //  If this is our first pass then move to the previous file record
                //

                if (PassCount == 0) {

                    NtfsCleanupAttributeContext( IrpContext, Context );
                    NtfsInitializeAttributeContext( Context );

                    NtfsLookupAttributeForScb( IrpContext, Scb, &NewStartVcn, Context );
                }
            }

            if (PassCount == 1) { break; }

            PassCount += 1;
        }

    try_exit: NOTHING;

        //
        //  Restore the context if required.
        //

        if (RestoreContext) {

            NtfsCleanupAttributeContext( IrpContext, Context );
            NtfsInitializeAttributeContext( Context );

            NtfsLookupAttributeForScb( IrpContext, Scb, &RestoreVcn, Context );
        }

    } finally {

        DebugUnwind( NtfsMergeFileRecords );

        if (NewAttribute != NULL) {

            NtfsFreePool( NewAttribute );
        }
    }

    return;
}


//
//  Local support routine
//

NTSTATUS
NtfsCheckLocksInZeroRange (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PSCB Scb,
    IN PFILE_OBJECT FileObject,
    IN PLONGLONG StartingOffset,
    IN ULONG ByteCount
    )

/*++

Routine Description:

    This routine is called from ZeroRangeInStream to verify that we can modify the data
    in the specified range.  We check both oplocks and filelocks here.

Arguments:

    Irp - This is the Irp for the request.  We set the next stack location to look like
        a write so that the file lock package has some context to use.

    Scb - Scb for the stream being modified.

    FileObject - File object used to originate the request.

    StartingOffset - This is the offset for the start of the request.

    ByteCount - This is the length of the current request.

Return Value:

    NTSTATUS - STATUS_PENDING if the request is posted for an oplock operation, STATUS_SUCCESS
        if the operation can proceed.  Otherwise this is the status to fail the request with.

--*/

{
    PIO_STACK_LOCATION IrpSp;
    NTSTATUS Status;
    PAGED_CODE();

    Status = FsRtlCheckOplock( &Scb->ScbType.Data.Oplock,
                               Irp,
                               IrpContext,
                               NtfsOplockComplete,
                               NtfsPrePostIrp );

    //
    //  Proceed if we have SUCCESS.
    //

    if (Status == STATUS_SUCCESS) {

        //
        //  This oplock call can affect whether fast IO is possible.
        //  We may have broken an oplock to no oplock held.  If the
        //  current state of the file is FastIoIsNotPossible then
        //  recheck the fast IO state.
        //

        if (Scb->Header.IsFastIoPossible == FastIoIsNotPossible) {

            NtfsAcquireFsrtlHeader( Scb );
            Scb->Header.IsFastIoPossible = NtfsIsFastIoPossible( Scb );
            NtfsReleaseFsrtlHeader( Scb );
        }

        //
        // We have to check for write access according to the current
        // state of the file locks.
        //

        if (Scb->ScbType.Data.FileLock != NULL) {

            //
            //  Update the Irp to point to the next stack location.
            //

            try {

                IoSetNextIrpStackLocation( Irp );
                IrpSp = IoGetCurrentIrpStackLocation( Irp );

                IrpSp->MajorFunction = IRP_MJ_WRITE;
                IrpSp->MinorFunction = 0;
                IrpSp->Flags = 0;
                IrpSp->Control = 0;

                IrpSp->Parameters.Write.Length = ByteCount;
                IrpSp->Parameters.Write.Key = 0;
                IrpSp->Parameters.Write.ByteOffset.QuadPart = *StartingOffset;

                IrpSp->DeviceObject = Scb->Vcb->Vpb->DeviceObject;
                IrpSp->FileObject = FileObject;

                if (!FsRtlCheckLockForWriteAccess( Scb->ScbType.Data.FileLock, Irp )) {

                    Status = STATUS_FILE_LOCK_CONFLICT;
                }

            //
            //  Always handle the exception initially in order to restore the Irp.
            //

            } except( EXCEPTION_EXECUTE_HANDLER ) {

                //
                //  Zero out the current stack location and back up one position.
                //

                Status = GetExceptionCode();
            }

            //
            //  Restore the Irp to its previous state.
            //

            IoSkipCurrentIrpStackLocation( Irp );

            //
            //  Raise any non-success status.
            //

            if (Status != STATUS_SUCCESS) {

                NtfsRaiseStatus( IrpContext, Status, NULL, Scb->Fcb );
            }
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\cleanup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Cleanup.c

Abstract:

    This module implements the File Cleanup routine for Ntfs called by the
    dispatch driver.

Author:

    Your Name       [Email]         dd-Mon-Year

Revision History:

--*/

#include "NtfsProc.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (NTFS_BUG_CHECK_CLEANUP)

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_CLEANUP)

#ifdef BRIANDBG
ULONG NtfsCleanupDiskFull = 0;
ULONG NtfsCleanupNoPool = 0;
#endif

#ifdef BRIANDBG
LONG
NtfsFsdCleanupExceptionFilter (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PEXCEPTION_POINTERS ExceptionPointer
    );
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsCommonCleanup)
#pragma alloc_text(PAGE, NtfsFsdCleanup)
#pragma alloc_text(PAGE, NtfsTrimNormalizedNames)
#endif


NTSTATUS
NtfsFsdCleanup (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of Cleanup.

Arguments:

    VolumeDeviceObject - Supplies the volume device object where the
        file exists

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/

{
    TOP_LEVEL_CONTEXT TopLevelContext;
    PTOP_LEVEL_CONTEXT ThreadTopLevelContext;

    NTSTATUS Status = STATUS_SUCCESS;
    PIRP_CONTEXT IrpContext = NULL;
    IRP_CONTEXT LocalIrpContext;

    ULONG LogFileFullCount = 0;

    ASSERT_IRP( Irp );

    PAGED_CODE();

    //
    //  If we were called with our file system device object instead of a
    //  volume device object, just complete this request with STATUS_SUCCESS
    //

    if (VolumeDeviceObject->DeviceObject.Size == (USHORT)sizeof(DEVICE_OBJECT)) {

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = FILE_OPENED;

        IoCompleteRequest( Irp, IO_DISK_INCREMENT );

        return STATUS_SUCCESS;
    }

    DebugTrace( +1, Dbg, ("NtfsFsdCleanup\n") );

    //
    //  Call the common Cleanup routine
    //

    FsRtlEnterFileSystem();

    ThreadTopLevelContext = NtfsInitializeTopLevelIrp( &TopLevelContext, FALSE, FALSE );

    //
    //  Do the following in a loop to catch the log file full and cant wait
    //  calls.
    //

    do {

        try {

            //
            //  We are either initiating this request or retrying it.
            //

            if (IrpContext == NULL) {

                //
                //  Allocate and initialize the Irp.  Always use the local IrpContext
                //  for cleanup.  It is never posted.
                //

                IrpContext = &LocalIrpContext;
                NtfsInitializeIrpContext( Irp, TRUE, &IrpContext );

                //
                //  Initialize the thread top level structure, if needed.
                //

                NtfsUpdateIrpContextWithTopLevel( IrpContext, ThreadTopLevelContext );

            } else if (Status == STATUS_LOG_FILE_FULL) {

                NtfsCheckpointForLogFileFull( IrpContext );

                if (++LogFileFullCount >= 2) {

                    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_EXCESS_LOG_FULL );
                }
            }
            Status = NtfsCommonCleanup( IrpContext, Irp );
            break;

#ifdef BRIANDBG
        } except(NtfsFsdCleanupExceptionFilter( IrpContext, GetExceptionInformation() )) {
#else
        } except(NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {
#endif

            //
            //  We had some trouble trying to perform the requested
            //  operation, so we'll abort the I/O request with
            //  the error status that we get back from the
            //  exception code
            //

            Status = NtfsProcessException( IrpContext, Irp, GetExceptionCode() );
        }

    } while (Status == STATUS_CANT_WAIT ||
             Status == STATUS_LOG_FILE_FULL);

    ASSERT( IoGetTopLevelIrp() != (PIRP) &TopLevelContext );
    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace( -1, Dbg, ("NtfsFsdCleanup -> %08lx\n", Status) );

    return Status;
}



NTSTATUS
NtfsCommonCleanup (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for Cleanup called by both the fsd and fsp
    threads.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PSCB Scb;
    PCCB Ccb;
    PLCB Lcb;
    PLCB LcbForUpdate;
    PLCB LcbForCounts;
    PSCB ParentScb = NULL;
    PFCB ParentFcb = NULL;

    PLCB ThisLcb;
    PSCB ThisScb;
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;

    PLONGLONG TruncateSize = NULL;
    LONGLONG LocalTruncateSize;

    BOOLEAN DeleteFile = FALSE;
    BOOLEAN DeleteStream = FALSE;
    BOOLEAN OpenById;
    BOOLEAN RemoveLink = FALSE;

    BOOLEAN AcquiredParentScb = FALSE;
    BOOLEAN VolumeMounted = TRUE;
    LOGICAL VolumeMountedReadOnly;
    BOOLEAN AcquiredObjectID = FALSE;

    BOOLEAN CleanupAttrContext = FALSE;

    BOOLEAN UpdateDuplicateInfo = FALSE;
    BOOLEAN AddToDelayQueue = TRUE;
    BOOLEAN UnlockedVolume = FALSE;
    BOOLEAN DeleteFromFcbTable = FALSE;

    USHORT TotalLinkAdj = 0;
    PLIST_ENTRY Links;

    NAME_PAIR NamePair;
    NTFS_TUNNELED_DATA TunneledData;

    BOOLEAN DecrementScb = FALSE;
    PSCB ImageScb;

#if (defined(DBG) || defined(NTFS_FREE_ASSERTS))
    BOOLEAN DecrementedCleanupCount = FALSE;
#endif

    PSCB CurrentParentScb;
    BOOLEAN AcquiredCheckpoint = FALSE;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );
    ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));

    PAGED_CODE();

    NtfsInitializeNamePair( &NamePair );

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace( +1, Dbg, ("NtfsCommonCleanup\n") );
    DebugTrace( 0, Dbg, ("IrpContext = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp        = %08lx\n", Irp) );

    //
    //  Extract and decode the file object
    //

    FileObject = IrpSp->FileObject;

    TypeOfOpen = NtfsDecodeFileObject( IrpContext, FileObject, &Vcb, &Fcb, &Scb, &Ccb, FALSE );

    Status = STATUS_SUCCESS;

#ifdef BENL_DBG
     SetFlag( FileObject->Flags, 0x1000000 );
#endif

    //
    //  Special case the unopened file object and stream files.
    //

    if ((TypeOfOpen == UnopenedFileObject) ||
        (TypeOfOpen == StreamFileOpen)) {

        //
        //  Just set the FO_CLEANUP_COMPLETE flag, and get out
        //

        SetFlag( FileObject->Flags, FO_CLEANUP_COMPLETE );

        //
        //  Theoretically we should never hit this case.  It means an app
        //  tried to close a handle he didn't open (call NtClose with a handle
        //  value that happens to be in the handle table).  It is safe to
        //  simply return SUCCESS in this case.
        //
        //  Trigger an assert so we can find the bad app though.
        //

        ASSERT( TypeOfOpen != StreamFileOpen );

        DebugTrace( -1, Dbg, ("NtfsCommonCleanup -> %08lx\n", Status) );
        NtfsCompleteRequest( IrpContext, Irp, Status );
        return Status;
    }

    //
    //  Remember if this is an open by file Id open.
    //

    OpenById = BooleanFlagOn( Ccb->Flags, CCB_FLAG_OPEN_BY_FILE_ID );

    //
    //  Remember the source info flags in the Ccb.
    //

    IrpContext->SourceInfo = Ccb->UsnSourceInfo;

    //
    //  Acquire exclusive access to the Vcb and enqueue the irp if we didn't
    //  get access
    //

    if (TypeOfOpen == UserVolumeOpen) {

        if (FlagOn( IrpContext->State, IRP_CONTEXT_STATE_DASD_UNLOCK )) {

            //
            //  Start by locking out all other checkpoint
            //  operations.
            //

            NtfsAcquireCheckpointSynchronization( IrpContext, Vcb );
            AcquiredCheckpoint = TRUE;
        }

        ASSERTMSG( "Acquire could fail.\n", FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT ) );

        NtfsAcquireExclusiveVcb( IrpContext, Vcb, FALSE );

    } else {

        //
        //  We will never have the checkpoint here so we can raise if dismounted
        //

        ASSERT( !AcquiredCheckpoint );
        NtfsAcquireSharedVcb( IrpContext, Vcb, TRUE );
    }

    //
    //  Remember if the volume has been dismounted.  No point in makeing any disk
    //  changes in that case.
    //

    if (!FlagOn( Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED )) {

        VolumeMounted = FALSE;
    }

    VolumeMountedReadOnly =  (LOGICAL)NtfsIsVolumeReadOnly( Vcb );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Acquire Paging I/O first, since we may be deleting or truncating.
        //  Testing for the PagingIoResource is not really safe without
        //  holding the main resource, so we correct for that below.
        //

        if (Fcb->PagingIoResource != NULL) {

            NtfsAcquireExclusivePagingIo( IrpContext, Fcb );
            NtfsAcquireExclusiveScb( IrpContext, Scb );

        } else {

            NtfsAcquireExclusiveScb( IrpContext, Scb );

            //
            //  If we now do not see a paging I/O resource we are golden,
            //  othewise we can absolutely release and acquire the resources
            //  safely in the right order, since a resource in the Fcb is
            //  not going to go away.
            //

            if (Fcb->PagingIoResource != NULL) {
                NtfsReleaseScb( IrpContext, Scb );
                NtfsAcquireExclusivePagingIo( IrpContext, Fcb );
                NtfsAcquireExclusiveScb( IrpContext, Scb );
            }
        }

        LcbForUpdate = LcbForCounts = Lcb = Ccb->Lcb;

        if (Lcb != NULL) {

            ParentScb = Lcb->Scb;

            if (ParentScb != NULL) {

                ParentFcb = ParentScb->Fcb;
            }
        }

        if (VolumeMounted && !VolumeMountedReadOnly) {

            //
            //  Update the Lcb/Scb to reflect the case where this opener had
            //  specified delete on close.
            //

            if (FlagOn( Ccb->Flags, CCB_FLAG_DELETE_ON_CLOSE )) {

                if (FlagOn( Ccb->Flags, CCB_FLAG_OPEN_AS_FILE )) {

                    BOOLEAN LastLink;
                    BOOLEAN NonEmptyIndex;

                    //
                    //  It is ok to get rid of this guy.  All we need to do is
                    //  mark this Lcb for delete and decrement the link count
                    //  in the Fcb.  If this is a primary link, then we
                    //  indicate that the primary link has been deleted.
                    //

                    if (!LcbLinkIsDeleted( Lcb ) &&
                        (!IsDirectory( &Fcb->Info ) ||
                         NtfsIsLinkDeleteable( IrpContext, Fcb, &NonEmptyIndex, &LastLink))) {

                        //
                        //  Walk through all of the Scb's for this stream and
                        //  make sure there are no active image sections.
                        //

                        ImageScb = NULL;

                        while ((ImageScb = NtfsGetNextChildScb( Fcb, ImageScb )) != NULL) {

                            InterlockedIncrement( &ImageScb->CloseCount );
                            DecrementScb = TRUE;

                            if (NtfsIsTypeCodeUserData( ImageScb->AttributeTypeCode ) &&
                                !FlagOn( ImageScb->ScbState, SCB_STATE_ATTRIBUTE_DELETED ) &&
                                (ImageScb->NonpagedScb->SegmentObject.ImageSectionObject != NULL)) {

                                if (!MmFlushImageSection( &ImageScb->NonpagedScb->SegmentObject,
                                                          MmFlushForDelete )) {

                                    InterlockedDecrement( &ImageScb->CloseCount );
                                    DecrementScb = FALSE;
                                    break;
                                }
                            }

                            InterlockedDecrement( &ImageScb->CloseCount );
                            DecrementScb = FALSE;
                        }

                        if (ImageScb == NULL) {

                            if (FlagOn( Lcb->FileNameAttr->Flags, FILE_NAME_DOS | FILE_NAME_NTFS )) {

                                SetFlag( Fcb->FcbState, FCB_STATE_PRIMARY_LINK_DELETED );
                            }

                            Fcb->LinkCount -= 1;

                            SetFlag( Lcb->LcbState, LCB_STATE_DELETE_ON_CLOSE );

                            //
                            //  Call into the notify package to close any handles on
                            //  a directory being deleted.
                            //

                            if (IsDirectory( &Fcb->Info )) {

                                FsRtlNotifyFilterChangeDirectory( Vcb->NotifySync,
                                                                  &Vcb->DirNotifyList,
                                                                  FileObject->FsContext,
                                                                  NULL,
                                                                  FALSE,
                                                                  FALSE,
                                                                  0,
                                                                  NULL,
                                                                  NULL,
                                                                  NULL,
                                                                  NULL );
                            }
                        }
                    }

                //
                //  Otherwise we are simply removing the attribute.
                //

                } else {

                    ImageScb = Scb;
                    InterlockedIncrement( &ImageScb->CloseCount );
                    DecrementScb = TRUE;

                    if ((ImageScb->NonpagedScb->SegmentObject.ImageSectionObject == NULL) ||
                        MmFlushImageSection( &ImageScb->NonpagedScb->SegmentObject,
                                             MmFlushForDelete )) {

                        SetFlag( Scb->ScbState, SCB_STATE_DELETE_ON_CLOSE );
                    }

                    InterlockedDecrement( &ImageScb->CloseCount );
                    DecrementScb = FALSE;
                }

                //
                //  Clear the flag so we will ignore it in the log file full case.
                //

                ClearFlag( Ccb->Flags, CCB_FLAG_DELETE_ON_CLOSE );
            }

            //
            //  If we are going to try and delete something, anything, knock the file
            //  size and valid data down to zero.  Then update the snapshot
            //  so that the sizes will be zero even if the operation fails.
            //
            //  If we're deleting the file, go through all of the Scb's.
            //

            if ((Fcb->LinkCount == 0) &&
                (Fcb->CleanupCount == 1)) {

                DeleteFile = TRUE;
                NtfsFreeSnapshotsForFcb( IrpContext, Scb->Fcb );

                for (Links = Fcb->ScbQueue.Flink;
                     Links != &Fcb->ScbQueue;
                     Links = Links->Flink) {

                    ThisScb = CONTAINING_RECORD( Links, SCB, FcbLinks );

                    //
                    //  Set the Scb sizes to zero except for the attribute list.
                    //

                    if ((ThisScb->AttributeTypeCode != $ATTRIBUTE_LIST) &&
                        (ThisScb->AttributeTypeCode != $REPARSE_POINT)) {

                        //
                        //  If the file is non-resident we will need a file object
                        //  when we delete the allocation.  Create it now
                        //  so that CC will know the stream is shrinking to zero
                        //  and will purge the data.
                        //

                        if ((ThisScb->FileObject == NULL) &&
                            (ThisScb->AttributeTypeCode == $DATA) &&
                            (ThisScb->NonpagedScb->SegmentObject.DataSectionObject != NULL) &&
                            !FlagOn( ThisScb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

                            //
                            //  Use a try-finally here in case we get an
                            //  INSUFFICIENT_RESOURCES.  We still need to
                            //  proceed with the delete.
                            //

                            try {

                                NtfsCreateInternalAttributeStream( IrpContext,
                                                                   ThisScb,
                                                                   TRUE,
                                                                   &NtfsInternalUseFile[COMMONCLEANUP_FILE_NUMBER] );

                            } except( NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {

                                if (Status == STATUS_INSUFFICIENT_RESOURCES) {

                                    Status = STATUS_SUCCESS;
                                }
                            }
                        }

                        ThisScb->Header.FileSize =
                        ThisScb->Header.ValidDataLength = Li0;
                    }

                    if (FlagOn( ThisScb->ScbState, SCB_STATE_FILE_SIZE_LOADED )) {

                        NtfsSnapshotScb( IrpContext, ThisScb );
                    }
                }

            //
            //  Otherwise we may only be deleting this stream.
            //

            } else if (FlagOn( Scb->ScbState, SCB_STATE_DELETE_ON_CLOSE ) &&
                       (Scb->CleanupCount == 1)) {

                try {

                    //
                    //  We may have expanded the quota here and currently own some
                    //  quota resource.  We want to release them now so we don't
                    //  deadlock with resources acquired later.
                    //

                    NtfsCheckpointCurrentTransaction( IrpContext );

                    if (IrpContext->SharedScb != NULL) {

                        NtfsReleaseSharedResources( IrpContext );
                    }

                    DeleteStream = TRUE;
                    Scb->Header.FileSize =
                    Scb->Header.ValidDataLength = Li0;

                    NtfsFreeSnapshotsForFcb( IrpContext, Scb->Fcb );

                    if (FlagOn( Scb->ScbState, SCB_STATE_FILE_SIZE_LOADED )) {

                        NtfsSnapshotScb( IrpContext, Scb );
                    }

                } except( NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {

                    NOTHING;
                }
            }
        }

        //
        //  Let's do a sanity check.
        //

        ASSERT( Fcb->CleanupCount != 0 );
        ASSERT( Scb->CleanupCount != 0 );

        //
        //  Case on the type of open that we are trying to cleanup.
        //

        switch (TypeOfOpen) {

        case UserVolumeOpen :

            DebugTrace( 0, Dbg, ("Cleanup on user volume\n") );

            //
            //  First set the FO_CLEANUP_COMPLETE flag.
            //

            SetFlag( FileObject->Flags, FO_CLEANUP_COMPLETE );

            //
            //  For a volume open, we check if this open locked the volume.
            //  All the other work is done in common code below.
            //

            if (FlagOn( Vcb->VcbState, VCB_STATE_LOCKED ) &&
                (((ULONG_PTR)Vcb->FileObjectWithVcbLocked & ~1) == (ULONG_PTR)FileObject)) {

                //
                //  Note its unlock attempt and retry so we can serialize with checkpoints
                //

                if (!FlagOn( IrpContext->State, IRP_CONTEXT_STATE_DASD_UNLOCK )) {
                    SetFlag( IrpContext->State, IRP_CONTEXT_STATE_DASD_UNLOCK );
                    NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
                }

                if ((ULONG_PTR)Vcb->FileObjectWithVcbLocked == ((ULONG_PTR)FileObject)+1) {

                    NtfsPerformDismountOnVcb( IrpContext, Vcb, TRUE, NULL );

                //
                //  Purge the volume for the autocheck case.
                //

                } else if (FlagOn( FileObject->Flags, FO_FILE_MODIFIED )) {

                    if (VolumeMounted && !VolumeMountedReadOnly) {

                        //
                        //  Drop the Scb for the volume Dasd around this call.
                        //

                        NtfsReleaseScb( IrpContext, Scb );

                        try {

                            NtfsFlushVolume( IrpContext, Vcb, FALSE, TRUE, TRUE, FALSE );

                        } except( NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {

                            NOTHING;
                        }

                        NtfsAcquireExclusiveScb( IrpContext, Scb );
                    }

                    //
                    //  If this is not the boot partition then dismount the Vcb.
                    //

#ifdef SYSCACHE_DEBUG
                    if ((((Vcb->SyscacheScb) && (Vcb->CleanupCount == 2)) || (Vcb->CleanupCount == 1)) &&

#else
                    if ((Vcb->CleanupCount == 1) &&
#endif
                        ((Vcb->CloseCount - Vcb->SystemFileCloseCount) == 1)) {

                        try {

                            NtfsPerformDismountOnVcb( IrpContext, Vcb, TRUE, NULL );

                        } except( NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {

                            NOTHING;
                        }
                    }
                }

                ClearFlag( Vcb->VcbState, VCB_STATE_LOCKED | VCB_STATE_EXPLICIT_LOCK );
                Vcb->FileObjectWithVcbLocked = NULL;
                UnlockedVolume = TRUE;

                //
                //  If the quota tracking has been requested and the quotas
                //  need to be repaired then try to repair them now.  Also restart
                //  the Usn journal deletion if it was underway.
                //

                if (VolumeMounted && !VolumeMountedReadOnly) {

                    if ((Status == STATUS_SUCCESS) &&
                        (Vcb->DeleteUsnData.FinalStatus == STATUS_VOLUME_DISMOUNTED)) {

                        Vcb->DeleteUsnData.FinalStatus = STATUS_SUCCESS;

                        try {

                            NtfsPostSpecial( IrpContext, Vcb, NtfsDeleteUsnSpecial, &Vcb->DeleteUsnData );

                        } except( NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {

                            NOTHING;
                        }
                    }

                    if ((Status == STATUS_SUCCESS) &&
                        FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_TRACKING_REQUESTED) &&
                        FlagOn( Vcb->QuotaFlags, QUOTA_FLAG_OUT_OF_DATE |
                                                 QUOTA_FLAG_CORRUPT |
                                                 QUOTA_FLAG_PENDING_DELETES)) {

                        try {
                            NtfsPostRepairQuotaIndex( IrpContext, Vcb );

                        } except( NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {

                            NOTHING;
                        }
                    }
                }
            }

            break;

        case UserViewIndexOpen :
        case UserDirectoryOpen :

            DebugTrace( 0, Dbg, ("Cleanup on user directory/file\n") );

            NtfsSnapshotScb( IrpContext, Scb );

            //
            //  Capture any changes to the time stamps for this file.
            //

            NtfsUpdateScbFromFileObject( IrpContext, FileObject, Scb, TRUE );

            //
            //  Now set the FO_CLEANUP_COMPLETE flag.
            //

            SetFlag( FileObject->Flags, FO_CLEANUP_COMPLETE );

            //
            //  To perform cleanup on a directory, we first complete any
            //  Irps watching from this directory.  If we are deleting the
            //  file then we remove all prefix entries for all the Lcb's going
            //  into this directory and delete the file.  We then report to
            //  dir notify that this file is going away.
            //

            //
            //  Complete any Notify Irps on this file handle.
            //

            if (FlagOn( Ccb->Flags, CCB_FLAG_DIR_NOTIFY )) {

                //
                //  Both the notify count and notify list are separate for view
                //  indices versus file name indices (directories).
                //

                if (TypeOfOpen == UserViewIndexOpen) {

                    FsRtlNotifyCleanup( Vcb->NotifySync, &Vcb->ViewIndexNotifyList, Ccb );
                    ClearFlag( Ccb->Flags, CCB_FLAG_DIR_NOTIFY );
                    InterlockedDecrement( &Vcb->ViewIndexNotifyCount );

                } else {

                    FsRtlNotifyCleanup( Vcb->NotifySync, &Vcb->DirNotifyList, Ccb );
                    ClearFlag( Ccb->Flags, CCB_FLAG_DIR_NOTIFY );
                    InterlockedDecrement( &Vcb->NotifyCount );
                }
            }

            //
            //  Try to remove normalized name if its long and  if no handles active (only this 1 left)
            //  and no lcbs are active - all notifies farther down in function
            //  use parent Scb's normalized name.  If we don't remove it here
            //  this always goes away during a close
            //

            if ((Scb->ScbType.Index.NormalizedName.MaximumLength > LONGNAME_THRESHOLD) &&
                (Fcb->CleanupCount == 1)) {

                //
                //  Cleanup the current scb node and then trim its parents
                //

                NtfsDeleteNormalizedName( Scb );

                if (Lcb != NULL) {
                    CurrentParentScb = Lcb->Scb;
                } else {
                    CurrentParentScb = NULL;
                }

                if ((CurrentParentScb != NULL) &&
                    (CurrentParentScb->ScbType.Index.NormalizedName.MaximumLength > LONGNAME_THRESHOLD)) {

                    NtfsTrimNormalizedNames( IrpContext, Fcb, CurrentParentScb );
                }
            }

            //
            //  When cleaning up a user directory, we always remove the
            //  share access and modify the file counts.  If the Fcb
            //  has been marked as delete on close and this is the last
            //  open file handle, we remove the file from the Mft and
            //  remove it from it's parent index entry.
            //

            if (VolumeMounted &&
               (!VolumeMountedReadOnly) &&
               ((SafeNodeType( Scb ) == NTFS_NTC_SCB_INDEX))) {

                if (DeleteFile) {

                    BOOLEAN AcquiredFcbTable = FALSE;

                    ASSERT( (Lcb == NULL) ||
                            (LcbLinkIsDeleted( Lcb ) && Lcb->CleanupCount == 1 ));

                    //
                    //  If we don't have an Lcb and there is one on the Fcb then
                    //  let's use it.
                    //

                    if ((Lcb == NULL) && !IsListEmpty( &Fcb->LcbQueue )) {

                        Lcb = CONTAINING_RECORD( Fcb->LcbQueue.Flink,
                                                 LCB,
                                                 FcbLinks );

                        ParentScb = Lcb->Scb;
                        if (ParentScb != NULL) {

                            ParentFcb = ParentScb->Fcb;
                        }
                    }

                    try {

                        //
                        //  In a very rare case the handle on a file may be an
                        //  OpenByFileID handle.  In that case we need to find
                        //  the parent for the remaining link on the file.
                        //

                        if (ParentScb == NULL) {

                            PFILE_NAME FileNameAttr;
                            UNICODE_STRING FileName;

                            NtfsInitializeAttributeContext( &AttrContext );
                            CleanupAttrContext = TRUE;

                            if (!NtfsLookupAttributeByCode( IrpContext,
                                                            Fcb,
                                                            &Fcb->FileReference,
                                                            $FILE_NAME,
                                                            &AttrContext )) {

                                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
                            }

                            //
                            //  Now we need an Fcb and then an Scb for the directory.
                            //

                            FileNameAttr = (PFILE_NAME) NtfsAttributeValue( NtfsFoundAttribute( &AttrContext ));

                            NtfsAcquireFcbTable( IrpContext, Vcb );
                            AcquiredFcbTable = TRUE;

                            ParentFcb = NtfsCreateFcb( IrpContext,
                                                       Vcb,
                                                       FileNameAttr->ParentDirectory,
                                                       FALSE,
                                                       TRUE,
                                                       NULL );

                            ParentFcb->ReferenceCount += 1;

                            if (!NtfsAcquireExclusiveFcb( IrpContext, ParentFcb, NULL, ACQUIRE_NO_DELETE_CHECK | ACQUIRE_DONT_WAIT )) {

                                NtfsReleaseFcbTable( IrpContext, Vcb );
                                NtfsAcquireExclusiveFcb( IrpContext, ParentFcb, NULL, ACQUIRE_NO_DELETE_CHECK );
                                NtfsAcquireFcbTable( IrpContext, Vcb );
                            }

                            ParentFcb->ReferenceCount -= 1;

                            NtfsReleaseFcbTable( IrpContext, Vcb );
                            AcquiredFcbTable = FALSE;

                            ParentScb = NtfsCreateScb( IrpContext,
                                                       ParentFcb,
                                                       $INDEX_ALLOCATION,
                                                       &NtfsFileNameIndex,
                                                       FALSE,
                                                       NULL );

                            if (FlagOn(Scb->ScbState, SCB_STATE_FILE_SIZE_LOADED)) {

                                NtfsSnapshotScb( IrpContext, Scb );
                            }

                            //
                            //  Make sure this new Scb is connected to our Fcb so teardown
                            //  will happen.
                            //

                            FileName.Buffer = &FileNameAttr->FileName[0];
                            FileName.MaximumLength =
                            FileName.Length = FileNameAttr->FileNameLength * sizeof( WCHAR );

                            NtfsCreateLcb( IrpContext,
                                           ParentScb,
                                           Fcb,
                                           FileName,
                                           FileNameAttr->Flags,
                                           NULL );

                            AcquiredParentScb = TRUE;
                        }

                        NtfsDeleteFile( IrpContext, Fcb, ParentScb, &AcquiredParentScb, NULL, NULL );

                        TotalLinkAdj += 1;

                        //
                        //  Remove all tunneling entries for this directory
                        //

                        FsRtlDeleteKeyFromTunnelCache( &Vcb->Tunnel,
                                                       *(PULONGLONG) &Fcb->FileReference );

                    } except( NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {

                        NOTHING;
                    }

                    if (AcquiredFcbTable) {

                        NtfsReleaseFcbTable( IrpContext, Vcb );
                    }

                    if (STATUS_SUCCESS == Status) {

                        if (!OpenById && (Vcb->NotifyCount != 0)) {

                            NtfsReportDirNotify( IrpContext,
                                                 Vcb,
                                                 &Ccb->FullFileName,
                                                 Ccb->LastFileNameOffset,
                                                 NULL,
                                                 ((FlagOn( Ccb->Flags, CCB_FLAG_PARENT_HAS_DOS_COMPONENT ) &&
                                                   (Ccb->Lcb != NULL) &&
                                                   (Ccb->Lcb->Scb->ScbType.Index.NormalizedName.Length != 0)) ?
                                                  &Ccb->Lcb->Scb->ScbType.Index.NormalizedName :
                                                  NULL),
                                                 FILE_NOTIFY_CHANGE_DIR_NAME,
                                                 FILE_ACTION_REMOVED,
                                                 ParentFcb );
                        }

                        DeleteFromFcbTable = TRUE;

                        //
                        //  We certainly don't need to any on disk update for this
                        //  file now.
                        //

                        ClearFlag( Ccb->Flags,
                                   CCB_FLAG_USER_SET_LAST_MOD_TIME |
                                   CCB_FLAG_USER_SET_LAST_CHANGE_TIME |
                                   CCB_FLAG_USER_SET_LAST_ACCESS_TIME );

                    }


                } else {

                    //
                    //  Determine if we should put this on the delayed close list.
                    //  The following must be true.
                    //
                    //  - This is not the root directory
                    //  - This directory is not about to be deleted
                    //  - This is the last handle and last file object for this
                    //      directory.
                    //  - There are no other file objects on this file.
                    //  - We are not currently reducing the delayed close queue.
                    //

                    if ((Fcb->CloseCount == 1) &&
                        (NtfsData.DelayedCloseCount <= NtfsMaxDelayedCloseCount)) {

                        NtfsAcquireFsrtlHeader( Scb );
                        SetFlag( Scb->ScbState, SCB_STATE_DELAY_CLOSE );
                        NtfsReleaseFsrtlHeader( Scb );
                    }
                }
            }

            break;

        case UserFileOpen :

            DebugTrace( 0, Dbg, ("Cleanup on user file\n") );

            //
            //  If the Scb is uninitialized, we read it from the disk.
            //

            if (!FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED ) &&
                VolumeMounted &&
                !VolumeMountedReadOnly) {

                try {

                    NtfsUpdateScbFromAttribute( IrpContext, Scb, NULL );

                } except( NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {

                    NOTHING;
                }
            }

            NtfsSnapshotScb( IrpContext, Scb );

            //
            //  Coordinate the cleanup operation with the oplock state.
            //  Cleanup operations can always cleanup any oplocks immediately.
            //

            if (SafeNodeType( Scb ) == NTFS_NTC_SCB_DATA) {
                FsRtlCheckOplock( &Scb->ScbType.Data.Oplock,
                                  Irp,
                                  IrpContext,
                                  NULL,
                                  NULL );
            }

            //
            //  In this case, we have to unlock all the outstanding file
            //  locks, update the time stamps for the file and sizes for
            //  this attribute, and set the archive bit if necessary.
            //

            if ((SafeNodeType( Scb ) == NTFS_NTC_SCB_DATA) &&
                (Scb->ScbType.Data.FileLock != NULL)) {

                (VOID) FsRtlFastUnlockAll( Scb->ScbType.Data.FileLock,
                                           FileObject,
                                           IoGetRequestorProcess( Irp ),
                                           NULL );
            }

            //
            //  Update the FastIoField.
            //

            NtfsAcquireFsrtlHeader( Scb );
            Scb->Header.IsFastIoPossible = NtfsIsFastIoPossible( Scb );
            NtfsReleaseFsrtlHeader( Scb );

            //
            //  Trim normalized names of parent dirs if they are over the threshold
            //

            ASSERT( IrpContext->TransactionId == 0 );

            if (Fcb->CleanupCount == 1) {

                if (Lcb != NULL) {
                    CurrentParentScb = Lcb->Scb;
                } else {
                    CurrentParentScb = NULL;
                }

                if ((CurrentParentScb != NULL) &&
                    (CurrentParentScb->ScbType.Index.NormalizedName.MaximumLength > LONGNAME_THRESHOLD)) {

                    NtfsTrimNormalizedNames( IrpContext, Fcb, CurrentParentScb );
                }

            } //  endif cleanupcnt == 1

            //
            //  If the Fcb is in valid shape, we check on the cases where we delete
            //  the file or attribute.
            //

            if (VolumeMounted && !VolumeMountedReadOnly) {

                //
                //  Capture any changes to the time stamps for this file.
                //

                NtfsUpdateScbFromFileObject( IrpContext, FileObject, Scb, TRUE );

                //
                //  Now set the FO_CLEANUP_COMPLETE flag.
                //

                SetFlag( FileObject->Flags, FO_CLEANUP_COMPLETE );

                if (Status == STATUS_SUCCESS) {

                    //
                    //  We are checking here for special actions we take when
                    //  we have the last user handle on a link and the link has
                    //  been marked for delete.  We could either be removing the
                    //  file or removing a link.
                    //

                    if ((Lcb == NULL) || (LcbLinkIsDeleted( Lcb ) && (Lcb->CleanupCount == 1))) {

                        if (DeleteFile) {

                            BOOLEAN AcquiredFcbTable = FALSE;

                            //
                            //  If we don't have an Lcb and the Fcb has some entries then
                            //  grab one of these to do the update.
                            //

                            if (Lcb == NULL) {

                                for (Links = Fcb->LcbQueue.Flink;
                                     Links != &Fcb->LcbQueue;
                                     Links = Links->Flink) {

                                    ThisLcb = CONTAINING_RECORD( Fcb->LcbQueue.Flink,
                                                                 LCB,
                                                                 FcbLinks );

                                    if (!FlagOn( ThisLcb->LcbState, LCB_STATE_LINK_IS_GONE )) {

                                        Lcb = ThisLcb;

                                        ParentScb = Lcb->Scb;
                                        if (ParentScb != NULL) {

                                            ParentFcb = ParentScb->Fcb;
                                        }

                                        break;
                                    }
                                }
                            }

                            try {

                                //
                                //  In a very rare case the handle on a file may be an
                                //  OpenByFileID handle.  In that case we need to find
                                //  the parent for the remaining link on the file.
                                //

                                if (ParentScb == NULL) {

                                    PFILE_NAME FileNameAttr;
                                    UNICODE_STRING FileName;

                                    NtfsInitializeAttributeContext( &AttrContext );
                                    CleanupAttrContext = TRUE;

                                    if (!NtfsLookupAttributeByCode( IrpContext,
                                                                    Fcb,
                                                                    &Fcb->FileReference,
                                                                     $FILE_NAME,
                                                                    &AttrContext )) {

                                        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
                                    }

                                    //
                                    //  Now we need an Fcb and then an Scb for the directory.
                                    //

                                    FileNameAttr = (PFILE_NAME) NtfsAttributeValue( NtfsFoundAttribute( &AttrContext ));

                                    NtfsAcquireFcbTable( IrpContext, Vcb );
                                    AcquiredFcbTable = TRUE;

                                    ParentFcb = NtfsCreateFcb( IrpContext,
                                                               Vcb,
                                                               FileNameAttr->ParentDirectory,
                                                               FALSE,
                                                               TRUE,
                                                               NULL );

                                    ParentFcb->ReferenceCount += 1;

                                    if (!NtfsAcquireExclusiveFcb( IrpContext, ParentFcb, NULL, ACQUIRE_NO_DELETE_CHECK | ACQUIRE_DONT_WAIT )) {

                                        NtfsReleaseFcbTable( IrpContext, Vcb );
                                        NtfsAcquireExclusiveFcb( IrpContext, ParentFcb, NULL, ACQUIRE_NO_DELETE_CHECK );
                                        NtfsAcquireFcbTable( IrpContext, Vcb );
                                    }

                                    ParentFcb->ReferenceCount -= 1;

                                    NtfsReleaseFcbTable( IrpContext, Vcb );
                                    AcquiredFcbTable = FALSE;

                                    ParentScb = NtfsCreateScb( IrpContext,
                                                               ParentFcb,
                                                               $INDEX_ALLOCATION,
                                                               &NtfsFileNameIndex,
                                                               FALSE,
                                                               NULL );

                                    if (FlagOn(Scb->ScbState, SCB_STATE_FILE_SIZE_LOADED)) {

                                        NtfsSnapshotScb( IrpContext, Scb );
                                    }

                                    //
                                    //  Make sure this new Scb is connected to our Fcb so teardown
                                    //  will happen.
                                    //

                                    FileName.Buffer = &FileNameAttr->FileName[0];
                                    FileName.MaximumLength =
                                    FileName.Length = FileNameAttr->FileNameLength * sizeof( WCHAR );

                                    NtfsCreateLcb( IrpContext,
                                                   ParentScb,
                                                   Fcb,
                                                   FileName,
                                                   FileNameAttr->Flags,
                                                   NULL );

                                    AcquiredParentScb = TRUE;
                                }

                                AddToDelayQueue = FALSE;
                                TunneledData.HasObjectId = FALSE;
                                NtfsDeleteFile( IrpContext, Fcb, ParentScb, &AcquiredParentScb,  &NamePair, &TunneledData );

                                TotalLinkAdj += 1;

                                //
                                //  Stash property information in the tunnel if the object was
                                //  opened by name, has a parent directory caller was treating it
                                //  as a non-POSIX object and we had an good, active link
                                //

                                if (!OpenById &&
                                    ParentScb &&
                                    Ccb->Lcb &&
                                    !FlagOn(FileObject->Flags, FO_OPENED_CASE_SENSITIVE)) {

                                    NtfsGetTunneledData( IrpContext,
                                                         Fcb,
                                                         &TunneledData );

                                    FsRtlAddToTunnelCache(  &Vcb->Tunnel,
                                                            *(PULONGLONG)&ParentScb->Fcb->FileReference,
                                                            &NamePair.Short,
                                                            &NamePair.Long,
                                                            BooleanFlagOn(Ccb->Lcb->FileNameAttr->Flags, FILE_NAME_DOS),
                                                            sizeof(NTFS_TUNNELED_DATA),
                                                            &TunneledData);
                                }

                            } except( NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {

                                NOTHING;
                            }

                            if (AcquiredFcbTable) {

                                NtfsReleaseFcbTable( IrpContext, Vcb );
                            }

                            if (Status == STATUS_SUCCESS) {

                                if ((Vcb->NotifyCount != 0) &&
                                    !OpenById) {

                                    NtfsReportDirNotify( IrpContext,
                                                         Vcb,
                                                         &Ccb->FullFileName,
                                                         Ccb->LastFileNameOffset,
                                                         NULL,
                                                         ((FlagOn( Ccb->Flags, CCB_FLAG_PARENT_HAS_DOS_COMPONENT ) &&
                                                           (Ccb->Lcb != NULL) &&
                                                           (Ccb->Lcb->Scb->ScbType.Index.NormalizedName.Length != 0)) ?
                                                          &Ccb->Lcb->Scb->ScbType.Index.NormalizedName :
                                                          NULL),
                                                         FILE_NOTIFY_CHANGE_FILE_NAME,
                                                         FILE_ACTION_REMOVED,
                                                         ParentFcb );
                                }

                                DeleteFromFcbTable = TRUE;

                                //
                                //  We certainly don't need to any on disk update for this
                                //  file now.
                                //

                                ClearFlag( Ccb->Flags,
                                           CCB_FLAG_USER_SET_LAST_MOD_TIME |
                                           CCB_FLAG_USER_SET_LAST_CHANGE_TIME |
                                           CCB_FLAG_USER_SET_LAST_ACCESS_TIME );

                                //
                                //  We will truncate the attribute to size 0.
                                //

                                TruncateSize = (PLONGLONG)&Li0;
                            }

                        //
                        //  Now we want to check for the last user's handle on a
                        //  link (or the last handle on a Ntfs/8.3 pair).  In this
                        //  case we want to remove the links from the disk.
                        //

                        } else if (Lcb != NULL) {

                            ThisLcb = NULL;
                            RemoveLink = TRUE;

                            if (FlagOn( Lcb->FileNameAttr->Flags, FILE_NAME_DOS | FILE_NAME_NTFS ) &&
                                (Lcb->FileNameAttr->Flags != (FILE_NAME_NTFS | FILE_NAME_DOS))) {

                                //
                                //  Walk through all the links looking for a link
                                //  with a flag set which is not the same as the
                                //  link we already have.
                                //

                                for (Links = Fcb->LcbQueue.Flink;
                                     Links != &Fcb->LcbQueue;
                                     Links = Links->Flink) {

                                    ThisLcb = CONTAINING_RECORD( Links, LCB, FcbLinks );

                                    //
                                    //  If this has a flag set and is not the Lcb
                                    //  for this cleanup, then we check if there
                                    //  are no Ccb's left for this.
                                    //

                                    if (FlagOn( ThisLcb->FileNameAttr->Flags, FILE_NAME_DOS | FILE_NAME_NTFS )

                                                &&

                                        (ThisLcb != Lcb)) {

                                        if (ThisLcb->CleanupCount != 0) {

                                             RemoveLink = FALSE;
                                        }

                                        break;
                                    }

                                    ThisLcb = NULL;
                                }
                            }

                            //
                            //  If we are to remove the link, we do so now.  This removes
                            //  the filename attributes and the entries in the parent
                            //  indexes for this link.  In addition, we mark the links
                            //  as having been removed and decrement the number of links
                            //  left on the file.  We don't remove the link if this the
                            //  last link on the file.  This means that someone has the
                            //  file open by FileID.  We don't want to remove the last
                            //  link until all the handles are closed.
                            //

                            if (RemoveLink && (Fcb->TotalLinks > 1)) {

                                NtfsAcquireExclusiveScb( IrpContext, ParentScb );
                                AcquiredParentScb = TRUE;

                                //
                                //  We might end up with deallocating or even allocating an MFT
                                //  record in the process of deleting this entry. So, it's wise to preacquire
                                //  QuotaControl resource, lest we deadlock with the MftScb resource.
                                //  Unfortunately, it's not easy to figure out whether any of those will
                                //  actually happen at this point.
                                //
                                //  We must have acquired all the other resources except $ObjId
                                //  at this point. QuotaControl must get acquired after ObjId Scb.
                                //

                                if (NtfsPerformQuotaOperation( Fcb )) {

                                    NtfsAcquireSharedScb( IrpContext, Vcb->ObjectIdTableScb );
                                    AcquiredObjectID = TRUE;
                                    NtfsAcquireQuotaControl( IrpContext, Fcb->QuotaControl );
                                }

                                try {

                                    AddToDelayQueue = FALSE;
                                    TunneledData.HasObjectId = FALSE;

                                    //
                                    //  Post the link change.
                                    //

                                    NtfsPostUsnChange( IrpContext, Fcb, USN_REASON_HARD_LINK_CHANGE );
                                    NtfsRemoveLink( IrpContext,
                                                    Fcb,
                                                    ParentScb,
                                                    Lcb->ExactCaseLink.LinkName,
                                                    &NamePair,
                                                    &TunneledData );

                                    //
                                    //  It's possible that this is the link that was used for the
                                    //  Usn name.  Make sure we look up the Usn name on the
                                    //  next operation.
                                    //

                                    ClearFlag( Fcb->FcbState, FCB_STATE_VALID_USN_NAME );

                                    //
                                    //  Stash property information in the tunnel if caller opened the
                                    //  object by name and was treating it as a non-POSIX object
                                    //

                                    if (!OpenById && !FlagOn(FileObject->Flags, FO_OPENED_CASE_SENSITIVE)) {

                                        NtfsGetTunneledData( IrpContext,
                                                             Fcb,
                                                             &TunneledData );

                                        FsRtlAddToTunnelCache(  &Vcb->Tunnel,
                                                                *(PULONGLONG)&ParentScb->Fcb->FileReference,
                                                                &NamePair.Short,
                                                                &NamePair.Long,
                                                                BooleanFlagOn(Lcb->FileNameAttr->Flags, FILE_NAME_DOS),
                                                                sizeof(NTFS_TUNNELED_DATA),
                                                                &TunneledData);
                                    }

                                    TotalLinkAdj += 1;
                                    NtfsUpdateFcb( ParentFcb,
                                                   (FCB_INFO_CHANGED_LAST_CHANGE |
                                                    FCB_INFO_CHANGED_LAST_MOD |
                                                    FCB_INFO_UPDATE_LAST_ACCESS) );

                                } except( NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {

                                    NOTHING;
                                }

                                if ((Vcb->NotifyCount != 0) &&
                                    !OpenById &&
                                    (Status == STATUS_SUCCESS)) {

                                    NtfsReportDirNotify( IrpContext,
                                                         Vcb,
                                                         &Ccb->FullFileName,
                                                         Ccb->LastFileNameOffset,
                                                         NULL,
                                                         ((FlagOn( Ccb->Flags, CCB_FLAG_PARENT_HAS_DOS_COMPONENT ) &&
                                                           (Ccb->Lcb != NULL) &&
                                                           (Ccb->Lcb->Scb->ScbType.Index.NormalizedName.Length != 0)) ?
                                                          &Ccb->Lcb->Scb->ScbType.Index.NormalizedName :
                                                          NULL),
                                                         FILE_NOTIFY_CHANGE_FILE_NAME,
                                                         FILE_ACTION_REMOVED,
                                                         ParentFcb );
                                }

                                LcbForUpdate = NULL;

                                //
                                //  Update the time stamps for removing the link.  Clear the
                                //  FO_CLEANUP_COMPLETE flag around this call so the time
                                //  stamp change is not nooped.
                                //

                                SetFlag( Ccb->Flags, CCB_FLAG_UPDATE_LAST_CHANGE );
                                ClearFlag( FileObject->Flags, FO_CLEANUP_COMPLETE );
                                NtfsUpdateScbFromFileObject( IrpContext, FileObject, Scb, TRUE );
                                SetFlag( FileObject->Flags, FO_CLEANUP_COMPLETE );
                            } else {

                                RemoveLink = FALSE;
                            }
                        }
                    }

                    //
                    //  If the file/attribute is not going away, we update the
                    //  attribute size now rather than waiting for the Lazy
                    //  Writer to catch up.  If the cleanup count isn't 1 then
                    //  defer the following actions.
                    //

                    if ((Scb->CleanupCount == 1) &&
                        (Fcb->LinkCount != 0) &&
                        (Status == STATUS_SUCCESS)) {

                        //
                        //  We may also have to delete this attribute only.
                        //

                        if (DeleteStream) {

                            //
                            //  If this stream is subject to quota then we need to acquire the
                            //  parent now.  Other we will acquire quota control during the
                            //  delete operation and then try to acquire the parent to
                            //  perform the update duplicate info.
                            //

                            if (NtfsPerformQuotaOperation( Fcb ) && (!RemoveLink) && (!FlagOn( Fcb->FcbState, FCB_STATE_SYSTEM_FILE ))) {

                                NtfsPrepareForUpdateDuplicate( IrpContext,
                                                               Fcb,
                                                               &LcbForUpdate,
                                                               &ParentScb,
                                                               TRUE );
                            }

                            //
                            //  We might be retrying the delete stream operation due to a log file
                            //  full.  If the attribute type code is $UNUSED then the stream has
                            //  already been deleted.
                            //

                            if (Scb->AttributeTypeCode != $UNUSED) {

                                try {

                                    //
                                    //  Delete the attribute only.
                                    //

                                    if (CleanupAttrContext) {

                                        NtfsCleanupAttributeContext( IrpContext, &AttrContext );
                                    }

                                    NtfsInitializeAttributeContext( &AttrContext );
                                    CleanupAttrContext = TRUE;

                                    NtfsLookupAttributeForScb( IrpContext, Scb, NULL, &AttrContext );

                                    do {

                                        NtfsDeleteAttributeRecord( IrpContext,
                                                                   Fcb,
                                                                   (DELETE_LOG_OPERATION |
                                                                    DELETE_RELEASE_FILE_RECORD |
                                                                    DELETE_RELEASE_ALLOCATION),
                                                                   &AttrContext );

                                    } while (NtfsLookupNextAttributeForScb( IrpContext, Scb, &AttrContext ));

                                } except( NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {

                                    NOTHING;
                                }

                                NtfsPostUsnChange( IrpContext, Fcb, USN_REASON_STREAM_CHANGE );
                            }

                            //
                            //  Now that we're done deleting the attribute, we need to checkpoint
                            //  so that the Mft resource can be released.  First we need to set
                            //  the appropriate IrpContext flag to indicate whether we really need
                            //  to release the Mft.
                            //

                            if ((Vcb->MftScb != NULL) &&
                                (Vcb->MftScb->Fcb->ExclusiveFcbLinks.Flink != NULL) &&
                                NtfsIsExclusiveScb( Vcb->MftScb )) {

                                SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_RELEASE_MFT );
                            }

                            try {

                                NtfsCheckpointCurrentTransaction( IrpContext );

                            } except( NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {

                                NOTHING;
                            }

                            //
                            //  Set the Scb flag to indicate that the attribute is
                            //  gone. Setting $UNUSED means we won't roll this back
                            //

                            Scb->ValidDataToDisk =
                            Scb->Header.AllocationSize.QuadPart =
                            Scb->Header.FileSize.QuadPart =
                            Scb->Header.ValidDataLength.QuadPart = 0;

                            Scb->AttributeTypeCode = $UNUSED;
                            SetFlag( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED );

                            SetFlag( Scb->ScbState, SCB_STATE_NOTIFY_REMOVE_STREAM );

                            ClearFlag( Scb->ScbState,
                                       SCB_STATE_NOTIFY_RESIZE_STREAM |
                                       SCB_STATE_NOTIFY_MODIFY_STREAM |
                                       SCB_STATE_NOTIFY_ADD_STREAM );

                            //
                            //  Update the time stamps for removing the link.  Clear the
                            //  FO_CLEANUP_COMPLETE flag around this call so the time
                            //  stamp change is not nooped.
                            //

                            SetFlag( Ccb->Flags,
                                     CCB_FLAG_UPDATE_LAST_CHANGE | CCB_FLAG_SET_ARCHIVE );
                            ClearFlag( FileObject->Flags, FO_CLEANUP_COMPLETE );
                            NtfsUpdateScbFromFileObject( IrpContext, FileObject, Scb, TRUE );
                            SetFlag( FileObject->Flags, FO_CLEANUP_COMPLETE );

                            TruncateSize = (PLONGLONG)&Li0;

                        //
                        //  Check if we're to modify the allocation size or file size.
                        //

                        } else {

                            if (FlagOn( Scb->ScbState, SCB_STATE_CHECK_ATTRIBUTE_SIZE )) {

                                //
                                //  Acquire the parent now so we enforce our locking
                                //  rules that the Mft Scb must be acquired after
                                //  the normal file resources.
                                //

                                if (!RemoveLink && !FlagOn( Fcb->FcbState, FCB_STATE_SYSTEM_FILE )) {
                                    NtfsPrepareForUpdateDuplicate( IrpContext,
                                                                   Fcb,
                                                                   &LcbForUpdate,
                                                                   &ParentScb,
                                                                   TRUE );
                                }


                                //
                                //  For the non-resident streams we will write the file
                                //  size to disk.
                                //


                                if (!FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

                                    //
                                    //  Setting AdvanceOnly to FALSE guarantees we will not
                                    //  incorrectly advance the valid data size.
                                    //

                                    try {

                                        NtfsWriteFileSizes( IrpContext,
                                                            Scb,
                                                            &Scb->Header.ValidDataLength.QuadPart,
                                                            FALSE,
                                                            TRUE,
                                                            TRUE );

                                    } except( NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {

                                        NOTHING;
                                    }

                                //
                                //  For resident streams we will write the correct size to
                                //  the resident attribute.
                                //

                                } else {

                                    //
                                    //  We need to lookup the attribute and change
                                    //  the attribute value.  We can point to
                                    //  the attribute itself as the changing
                                    //  value.
                                    //

                                    NtfsInitializeAttributeContext( &AttrContext );
                                    CleanupAttrContext = TRUE;

                                    try {

                                        NtfsLookupAttributeForScb( IrpContext, Scb, NULL, &AttrContext );

                                        NtfsChangeAttributeValue( IrpContext,
                                                                  Fcb,
                                                                  Scb->Header.FileSize.LowPart,
                                                                  NULL,
                                                                  0,
                                                                  TRUE,
                                                                  TRUE,
                                                                  FALSE,
                                                                  FALSE,
                                                                  &AttrContext );

                                    } except( NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {

                                        NOTHING;
                                    }

                                    //
                                    //  Verify the allocation size is now correct.
                                    //

                                    if (QuadAlign( Scb->Header.FileSize.LowPart ) != Scb->Header.AllocationSize.LowPart) {

                                        Scb->Header.AllocationSize.LowPart = QuadAlign(Scb->Header.FileSize.LowPart);
                                    }
                                }

                                //
                                //  Update the size change to the Fcb.
                                //

                                NtfsUpdateScbFromFileObject( IrpContext, FileObject, Scb, TRUE );
                            }

                            if (Status == STATUS_SUCCESS) {

                                if (FlagOn( Scb->ScbState, SCB_STATE_TRUNCATE_ON_CLOSE ) &&
                                    (Status == STATUS_SUCCESS)) {

                                    //
                                    //  Acquire the parent now so we enforce our locking
                                    //  rules that the Mft Scb must be acquired after
                                    //  the normal file resources.
                                    //

                                    if (!RemoveLink && !FlagOn( Fcb->FcbState, FCB_STATE_SYSTEM_FILE)) {
                                        NtfsPrepareForUpdateDuplicate( IrpContext,
                                                                       Fcb,
                                                                       &LcbForUpdate,
                                                                       &ParentScb,
                                                                       TRUE );
                                    }


                                    //
                                    //  We have two cases:
                                    //
                                    //      Resident:  We are looking for the case where the
                                    //          valid data length is less than the file size.
                                    //          In this case we shrink the attribute.
                                    //
                                    //      NonResident:  We are looking for unused clusters
                                    //          past the end of the file.
                                    //
                                    //  We skip the following if we had any previous errors.
                                    //

                                    if (!FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT )) {

                                        //
                                        //  We don't need to truncate if the file size is 0.
                                        //

                                        if (Scb->Header.AllocationSize.QuadPart != 0) {

                                            VCN StartingCluster;
                                            VCN EndingCluster;
                                            LONGLONG AllocationSize;

                                            //
                                            //  ****    Do we need to give up the Vcb for this
                                            //          call.
                                            //

                                            StartingCluster = LlClustersFromBytes( Vcb, Scb->Header.FileSize.QuadPart );
                                            EndingCluster = LlClustersFromBytes( Vcb, Scb->Header.AllocationSize.QuadPart );
                                            AllocationSize = Scb->Header.AllocationSize.QuadPart;

                                            //
                                            //  If there are clusters to delete, we do so now.
                                            //

                                            if (EndingCluster != StartingCluster) {

                                                try {
                                                    NtfsDeleteAllocation( IrpContext,
                                                                          FileObject,
                                                                          Scb,
                                                                          StartingCluster,
                                                                          MAXLONGLONG,
                                                                          TRUE,
                                                                          TRUE );

                                                } except( NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {

                                                    NOTHING;
                                                }
                                            }

                                            LocalTruncateSize = Scb->Header.FileSize.QuadPart;
                                            TruncateSize = &LocalTruncateSize;
                                        }

                                    //
                                    //  This is the resident case.
                                    //

                                    } else {

                                        //
                                        //  Check if the file size length is less than
                                        //  the allocated size.
                                        //

                                        if (QuadAlign( Scb->Header.FileSize.LowPart ) < Scb->Header.AllocationSize.LowPart) {

                                            //
                                            //  We need to lookup the attribute and change
                                            //  the attribute value.  We can point to
                                            //  the attribute itself as the changing
                                            //  value.
                                            //

                                            if (CleanupAttrContext) {

                                                NtfsCleanupAttributeContext( IrpContext, &AttrContext );
                                            }

                                            NtfsInitializeAttributeContext( &AttrContext );
                                            CleanupAttrContext = TRUE;

                                            try {

                                                NtfsLookupAttributeForScb( IrpContext, Scb, NULL, &AttrContext );

                                                NtfsChangeAttributeValue( IrpContext,
                                                                          Fcb,
                                                                          Scb->Header.FileSize.LowPart,
                                                                          NULL,
                                                                          0,
                                                                          TRUE,
                                                                          TRUE,
                                                                          FALSE,
                                                                          FALSE,
                                                                          &AttrContext );

                                            } except( NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {

                                                NOTHING;
                                            }

                                            //
                                            //  Remember the smaller allocation size
                                            //

                                            Scb->Header.AllocationSize.LowPart = QuadAlign( Scb->Header.FileSize.LowPart );
                                            Scb->TotalAllocated = Scb->Header.AllocationSize.QuadPart;
                                        }
                                    }

                                    NtfsUpdateScbFromFileObject( IrpContext, FileObject, Scb, TRUE );
                                }
                            }
                        }
                    }

                    //
                    //  If this was the last cached open, and there are open
                    //  non-cached handles, attempt a flush and purge operation
                    //  to avoid cache coherency overhead from these non-cached
                    //  handles later.  We ignore any I/O errors from the flush
                    //  except for CANT_WAIT and LOG_FILE_FULL.
                    //
                    //  Skip for the remove link case because we need to hold onto the parent
                    //  and this is optional
                    //

                    if ((Scb->NonCachedCleanupCount != 0) &&
                        (Scb->CleanupCount == (Scb->NonCachedCleanupCount + 1)) &&
                        (Scb->CompressionUnit == 0) &&
                        (Scb->NonpagedScb->SegmentObject.ImageSectionObject == NULL) &&
                        !FlagOn( FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING ) &&
                        (Status == STATUS_SUCCESS) &&
                        MmCanFileBeTruncated( &Scb->NonpagedScb->SegmentObject, NULL ) &&
                        !FlagOn( Scb->Fcb->FcbState, FCB_STATE_SYSTEM_FILE ) &&
                        !RemoveLink) {

                        //
                        //  FlushAndPurge may release the parent.  Go ahead and explicitly
                        //  release it.  Otherwise we may overrelease it later before uninitializing
                        //  the cache map. At the same time release the quota control if necc. via
                        //  release shared resources
                        //

                        try {
                            NtfsCheckpointCurrentTransaction( IrpContext );

                        } except( NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {

                            NOTHING;
                        }

                        if (AcquiredParentScb) {

                            NtfsReleaseScb( IrpContext, ParentScb );
                            AcquiredParentScb = FALSE;
                        }
                        if (IrpContext->SharedScbSize > 0) {
                            NtfsReleaseSharedResources( IrpContext );
                        }

                        //
                        //  Flush and purge the stream.
                        //

                        try {

                            NtfsFlushAndPurgeScb( IrpContext,
                                                  Scb,
                                                  NULL );

                        } except( NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {

                            NOTHING;
                        }

                        //
                        //  Ignore any errors in this path.
                        //

                        IrpContext->ExceptionStatus = STATUS_SUCCESS;
                    }

                    if ((Fcb->CloseCount == 1) &&
                        AddToDelayQueue &&
                        (NtfsData.DelayedCloseCount <= NtfsMaxDelayedCloseCount) &&
                        (Status == STATUS_SUCCESS) &&
                        !FlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE )) {

                        NtfsAcquireFsrtlHeader( Scb );
                        SetFlag( Scb->ScbState, SCB_STATE_DELAY_CLOSE );
                        NtfsReleaseFsrtlHeader( Scb );
                    }
                }

            //
            //  If the Fcb is bad, we will truncate the cache to size zero.
            //

            } else {

                //
                //  Now set the FO_CLEANUP_COMPLETE flag.
                //

                SetFlag( FileObject->Flags, FO_CLEANUP_COMPLETE );

                TruncateSize = (PLONGLONG)&Li0;
            }

            break;

        default :

            NtfsBugCheck( TypeOfOpen, 0, 0 );
        }

        //
        //  If any of the Fcb Info flags are set we call the routine
        //  to update the duplicated information in the parent directories.
        //  We need to check here in case none of the flags are set but
        //  we want to update last access time.
        //

        if (Fcb->Info.LastAccessTime != Fcb->CurrentLastAccess) {

            ASSERT( TypeOfOpen != UserVolumeOpen );

            if (FlagOn( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO )) {

                ASSERT( !FlagOn( Fcb->FcbState, FCB_STATE_FILE_DELETED ));

                Fcb->Info.LastAccessTime = Fcb->CurrentLastAccess;
                SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_LAST_ACCESS );

            } else if (!FlagOn( Fcb->FcbState, FCB_STATE_FILE_DELETED )) {

                if (NtfsCheckLastAccess( IrpContext, Fcb )) {

                    SetFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );
                    SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_LAST_ACCESS );
                }
            }
        }

        if (VolumeMounted && !VolumeMountedReadOnly) {

            //
            //  We check if we have the standard information attribute.
            //  We can only update attributes on mounted volumes.
            //

            if (FlagOn( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO ) &&
                (Status == STATUS_SUCCESS)) {

                ASSERT( !FlagOn( Fcb->FcbState, FCB_STATE_FILE_DELETED ));
                ASSERT( TypeOfOpen != UserVolumeOpen );

                try {

                    NtfsUpdateStandardInformation( IrpContext, Fcb );

                } except( NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {

                    NOTHING;
                }
            }

            //
            //  Now update the duplicate information as well for volumes that are still mounted.
            //

            if ((FlagOn( Fcb->InfoFlags, FCB_INFO_DUPLICATE_FLAGS ) ||
                         ((LcbForUpdate != NULL) &&
                          FlagOn( LcbForUpdate->InfoFlags, FCB_INFO_DUPLICATE_FLAGS ))) &&
                (Status == STATUS_SUCCESS) &&
                !RemoveLink &&  
                (!FlagOn( Fcb->FcbState, FCB_STATE_SYSTEM_FILE))) {

                ASSERT( TypeOfOpen != UserVolumeOpen );
                ASSERT( !FlagOn( Fcb->FcbState, FCB_STATE_FILE_DELETED ));

                NtfsPrepareForUpdateDuplicate( IrpContext, Fcb, &LcbForUpdate, &ParentScb, TRUE );

                //
                //  Now update the duplicate info.
                //

                try {

                    NtfsUpdateDuplicateInfo( IrpContext, Fcb, LcbForUpdate, ParentScb );

                } except( NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {

                    NOTHING;
                }

                UpdateDuplicateInfo = TRUE;
            }

            //
            //  If we have modified the Info structure or security, we report this
            //  to the dir-notify package (except for OpenById cases).
            //

            if (!OpenById && (Status == STATUS_SUCCESS)) {

                ULONG FilterMatch;

                //
                //  Check whether we need to report on file changes.
                //

                if ((Vcb->NotifyCount != 0) &&
                    (UpdateDuplicateInfo || FlagOn( Fcb->InfoFlags, FCB_INFO_MODIFIED_SECURITY ))) {

                    ASSERT( TypeOfOpen != UserVolumeOpen );

                    //
                    //  We map the Fcb info flags into the dir notify flags.
                    //

                    FilterMatch = NtfsBuildDirNotifyFilter( IrpContext,
                                                            (Fcb->InfoFlags |
                                                             (LcbForUpdate ? LcbForUpdate->InfoFlags : 0) ));

                    //
                    //  If the filter match is non-zero, that means we also need to do a
                    //  dir notify call.
                    //

                    if (FilterMatch != 0) {

                        ASSERT( TypeOfOpen != UserVolumeOpen );
                        ASSERT( !FlagOn( Fcb->FcbState, FCB_STATE_FILE_DELETED ));

                        NtfsReportDirNotify( IrpContext,
                                             Vcb,
                                             &Ccb->FullFileName,
                                             Ccb->LastFileNameOffset,
                                             NULL,
                                             ((FlagOn( Ccb->Flags, CCB_FLAG_PARENT_HAS_DOS_COMPONENT ) &&
                                               (Ccb->Lcb != NULL) &&
                                               (Ccb->Lcb->Scb->ScbType.Index.NormalizedName.Length != 0)) ?
                                              &Ccb->Lcb->Scb->ScbType.Index.NormalizedName :
                                              NULL),
                                             FilterMatch,
                                             FILE_ACTION_MODIFIED,
                                             ParentFcb );
                    }
                }

                ClearFlag( Fcb->InfoFlags, FCB_INFO_MODIFIED_SECURITY );

                //
                //  If this is a named stream with changes then report them as well.
                //

                if ((Scb->AttributeName.Length != 0) &&
                    NtfsIsTypeCodeUserData( Scb->AttributeTypeCode )) {

                    if ((Vcb->NotifyCount != 0) &&
                        FlagOn( Scb->ScbState,
                                SCB_STATE_NOTIFY_REMOVE_STREAM |
                                SCB_STATE_NOTIFY_RESIZE_STREAM |
                                SCB_STATE_NOTIFY_MODIFY_STREAM )) {

                        ULONG Action;

                        FilterMatch = 0;

                        //
                        //  Start by checking for a delete.
                        //

                        if (FlagOn( Scb->ScbState, SCB_STATE_NOTIFY_REMOVE_STREAM )) {

                            FilterMatch = FILE_NOTIFY_CHANGE_STREAM_NAME;
                            Action = FILE_ACTION_REMOVED_STREAM;

                        } else {

                            //
                            //  Check if the file size changed.
                            //

                            if (FlagOn( Scb->ScbState, SCB_STATE_NOTIFY_RESIZE_STREAM )) {

                                FilterMatch = FILE_NOTIFY_CHANGE_STREAM_SIZE;
                            }

                            //
                            //  Now check if the stream data was modified.
                            //

                            if (FlagOn( Scb->ScbState, SCB_STATE_NOTIFY_MODIFY_STREAM )) {

                                SetFlag( FilterMatch, FILE_NOTIFY_CHANGE_STREAM_WRITE );
                            }

                            Action = FILE_ACTION_MODIFIED_STREAM;
                        }

                        NtfsReportDirNotify( IrpContext,
                                             Vcb,
                                             &Ccb->FullFileName,
                                             Ccb->LastFileNameOffset,
                                             &Scb->AttributeName,
                                             ((FlagOn( Ccb->Flags, CCB_FLAG_PARENT_HAS_DOS_COMPONENT ) &&
                                               (Ccb->Lcb != NULL) &&
                                               (Ccb->Lcb->Scb->ScbType.Index.NormalizedName.Length != 0)) ?
                                              &Ccb->Lcb->Scb->ScbType.Index.NormalizedName :
                                              NULL),
                                             FilterMatch,
                                             Action,
                                             ParentFcb );
                    }

                    ClearFlag( Scb->ScbState,
                               SCB_STATE_NOTIFY_ADD_STREAM |
                               SCB_STATE_NOTIFY_REMOVE_STREAM |
                               SCB_STATE_NOTIFY_RESIZE_STREAM |
                               SCB_STATE_NOTIFY_MODIFY_STREAM );
                }
            }

            if (UpdateDuplicateInfo) {

                NtfsUpdateLcbDuplicateInfo( Fcb, LcbForUpdate );
                Fcb->InfoFlags = 0;
            }
        }

        //
        //  Always clear the update standard information flag.
        //

        ClearFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );

        //
        //  Let's give up the parent Fcb if we have acquired it.  This will
        //  prevent deadlocks in any uninitialize code below.
        //

        if (AcquiredParentScb) {

            NtfsReleaseScb( IrpContext, ParentScb );
            AcquiredParentScb = FALSE;
        }

        //
        //  Uninitialize the cache map if this file has been cached or we are
        //  trying to delete.
        //

        if ((FileObject->PrivateCacheMap != NULL) || (TruncateSize != NULL)) {

            CcUninitializeCacheMap( FileObject, (PLARGE_INTEGER)TruncateSize, NULL );
        }

        //
        //  Check that the non-cached handle count is consistent.
        //

        ASSERT( !FlagOn( FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING ) ||
                (Scb->NonCachedCleanupCount != 0 ));

        if (CleanupAttrContext) {

            NtfsCleanupAttributeContext( IrpContext, &AttrContext );
            CleanupAttrContext = FALSE;
        }

        //
        //  On final cleanup, post the close to the Usn Journal, if other changes have been
        //  posted.
        //

        if ((Fcb->CleanupCount == 1) &&
            (Fcb->FcbUsnRecord != NULL) &&
            ((Fcb->FcbUsnRecord->UsnRecord.Reason != 0) ||
             ((IrpContext->Usn.CurrentUsnFcb != NULL) && (IrpContext->Usn.NewReasons != 0)))) {

            PSCB TempScb;

            //
            //  Leave if there are any streams with user-mapped files.
            //

            TempScb = (PSCB)CONTAINING_RECORD( Fcb->ScbQueue.Flink,
                                               SCB,
                                               FcbLinks );

            while (&TempScb->FcbLinks != &Fcb->ScbQueue) {

                if (FlagOn(TempScb->Header.Flags, FSRTL_FLAG_USER_MAPPED_FILE)) {
                    goto NoPost;
                }

                TempScb = (PSCB)CONTAINING_RECORD( TempScb->FcbLinks.Flink,
                                                   SCB,
                                                   FcbLinks );
            }

            //
            //  Now try to actually post the change.
            //

            NtfsPostUsnChange( IrpContext, Fcb, USN_REASON_CLOSE );

            //
            //  Escape here if we are not posting the close due to a user-mapped file.
            //

        NoPost: NOTHING;
        }

        //
        //  Now, if anything at all is posted to the Usn Journal, we must write it now
        //  so that we do not get a log file full later.
        //

        ASSERT( IrpContext->Usn.NextUsnFcb == NULL );
        if ((IrpContext->Usn.CurrentUsnFcb != NULL) &&
            (Status == STATUS_SUCCESS)) {

            //
            //  Now write the journal, checkpoint the transaction, and free the UsnJournal to
            //  reduce contention.
            //

            try {

                NtfsWriteUsnJournalChanges( IrpContext );
                NtfsCheckpointCurrentTransaction( IrpContext );

            } except( NtfsCleanupExceptionFilter( IrpContext, GetExceptionInformation(), &Status )) {

                NOTHING;
            }
        }

        //
        //  Make sure the TRUNCATE and ATTRIBUTE_SIZE flags in the Scb are cleared.
        //

        if (FlagOn( Scb->ScbState,
                    SCB_STATE_CHECK_ATTRIBUTE_SIZE | SCB_STATE_TRUNCATE_ON_CLOSE ) &&
                    (Scb->CleanupCount == 1)) {

            NtfsAcquireFsrtlHeader( Scb );
            ClearFlag( Scb->ScbState,
                       SCB_STATE_CHECK_ATTRIBUTE_SIZE | SCB_STATE_TRUNCATE_ON_CLOSE );
            NtfsReleaseFsrtlHeader( Scb );
        }

        //
        //  Now decrement the cleanup counts.
        //
        //  NOTE - DO NOT ADD CODE AFTER THIS POINT THAT CAN CAUSE A RETRY.
        //

        NtfsDecrementCleanupCounts( Scb,
                                    LcbForCounts,
                                    BooleanFlagOn( FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING ));

#if (defined(DBG) || defined(NTFS_FREE_ASSERTS))
        DecrementedCleanupCount = TRUE;
#endif

        //
        //  Fixup the in memory lcb if we removed a link - this will not roll back
        //  so it must done at a point where we won't abort
        //  

        if (RemoveLink) {

            //
            //  Remove all remaining prefixes on this link.
            //

            ASSERT( NtfsIsExclusiveScb( Lcb->Scb ) );

            NtfsRemovePrefix( Lcb );

            //
            //  Remove any hash table entries for this Lcb.
            //

            NtfsRemoveHashEntriesForLcb( Lcb );

            //
            //  Mark the links as being removed.
            //

            SetFlag( Lcb->LcbState, LCB_STATE_LINK_IS_GONE );

            //
            //  We depend on ThisLcb being unused between the removelink 
            //  section and here. It should point to the other part of a pair
            //  of 8.3 links if there is one
            //  

#if DBG || defined( NTFS_FREE_ASSERTS )
            {
                PLIST_ENTRY Links;
                PLCB LcbPair = NULL;


                if (FlagOn( Lcb->FileNameAttr->Flags, FILE_NAME_DOS | FILE_NAME_NTFS )) {

                    for (Links = Fcb->LcbQueue.Flink;
                         Links != &Fcb->LcbQueue;
                         Links = Links->Flink) {

                        LcbPair = CONTAINING_RECORD( Links, LCB, FcbLinks );

                        //
                        //  If this has a flag set and is not the Lcb
                        //  for this cleanup, then we check if there
                        //  are no Ccb's left for this.
                        //

                        if (FlagOn( LcbPair->FileNameAttr->Flags, FILE_NAME_DOS | FILE_NAME_NTFS )

                                    &&

                            (LcbPair != Lcb)) {

                            break;
                        }

                        LcbPair = NULL;
                    }
                }

                ASSERT( LcbPair == ThisLcb );
            }
#endif

            if (ThisLcb != NULL) {

                //
                //  Remove all remaining prefixes on this link.
                //

                ASSERT( NtfsIsExclusiveScb( ThisLcb->Scb ) );
                NtfsRemovePrefix( ThisLcb );

                //
                //  Remove any hash table entries for this Lcb.
                //

                NtfsRemoveHashEntriesForLcb( ThisLcb );

                SetFlag( ThisLcb->LcbState, LCB_STATE_LINK_IS_GONE );
                ThisLcb->InfoFlags = 0;
            }

            //
            //  Since the link is gone we don't want to update the
            //  duplicate information for this link.
            //

            Lcb->InfoFlags = 0;
        }

        //
        //  We remove the share access from the Scb.
        //

        IoRemoveShareAccess( FileObject, &Scb->ShareAccess );

        //
        //  Modify the delete counts in the Fcb.
        //

        if (FlagOn( Ccb->Flags, CCB_FLAG_DELETE_FILE )) {

            Fcb->FcbDeleteFile -= 1;
            ClearFlag( Ccb->Flags, CCB_FLAG_DELETE_FILE );
        }

        if (FlagOn( Ccb->Flags, CCB_FLAG_DENY_DELETE )) {

            Fcb->FcbDenyDelete -= 1;
            ClearFlag( Ccb->Flags, CCB_FLAG_DENY_DELETE );
        }

        if (FlagOn( Ccb->Flags, CCB_FLAG_DENY_DEFRAG)) {
            ClearFlag( Ccb->Flags, CCB_FLAG_DENY_DEFRAG );
            ClearFlag( Scb->ScbPersist, SCB_PERSIST_DENY_DEFRAG );
        }

        //
        //  Since this request has completed we can adjust the total link count
        //  in the Fcb.
        //

        Fcb->TotalLinks -= TotalLinkAdj;

        //
        //  Release the quota control block.  This does not have to be done
        //  here however, it allows us to free up the quota control block
        //  before the fcb is removed from the table.  This keeps the assert
        //  about quota table empty from triggering in
        //  NtfsClearAndVerifyQuotaIndex.
        //

        if (NtfsPerformQuotaOperation(Fcb) &&
            FlagOn( Fcb->FcbState, FCB_STATE_FILE_DELETED )) {
            NtfsDereferenceQuotaControlBlock( Vcb,
                                              &Fcb->QuotaControl );
        }

        //
        //  If we hit some failure in modifying the disk then make sure to roll back
        //  all of the changes.
        //

        if (Status != STATUS_SUCCESS) {

            NtfsRaiseStatus( IrpContext, STATUS_SUCCESS, NULL, NULL );
        }

    } finally {

        DebugUnwind( NtfsCommonCleanup );

        //
        //  Remove this fcb from the Fcb table if neccessary. We delay this for
        //  synchronization with usn delete worker. By finishing the delete now we're
        //  guarranteed our usn work occured safely
        //

        if (DeleteFromFcbTable && FlagOn( Fcb->FcbState, FCB_STATE_IN_FCB_TABLE )) {

            NtfsAcquireFcbTable( IrpContext, Vcb );
            NtfsDeleteFcbTableEntry( Fcb->Vcb, Fcb->FileReference );
            NtfsReleaseFcbTable( IrpContext, Vcb );
            ClearFlag( Fcb->FcbState, FCB_STATE_IN_FCB_TABLE );
        }

        //
        //  We clear the file object pointer in the Ccb.
        //  This prevents us from trying to access this in a
        //  rename operation.
        //

        SetFlag( Ccb->Flags, CCB_FLAG_CLEANUP );

        //
        //  Release any resources held.
        //

        if (AcquiredObjectID) {

            NtfsReleaseScb( IrpContext, Vcb->ObjectIdTableScb );
        }

        NtfsReleaseVcb( IrpContext, Vcb );

        if (AcquiredCheckpoint) {
            NtfsReleaseCheckpointSynchronization( IrpContext, Vcb );
            AcquiredCheckpoint = FALSE;
        }

        if (CleanupAttrContext) {

            NtfsCleanupAttributeContext( IrpContext, &AttrContext );
        }

        if (NamePair.Long.Buffer != NamePair.LongBuffer) {

            NtfsFreePool(NamePair.Long.Buffer);
        }

        if (DecrementScb) {

            InterlockedDecrement( &ImageScb->CloseCount );
        }

        //
        //  If we just cleaned up a volume handle and in so doing unlocked the
        //  volume, notify anyone who might be interested.  We can't do this
        //  until we've released all our resources, since there's no telling
        //  what services might do when they get notified, and we don't want
        //  to introduce potential deadlocks.
        //

        if (UnlockedVolume) {

            ASSERT( !AbnormalTermination() );
            ASSERT( IrpContext->TransactionId == 0 );

            NtfsReleaseScb( IrpContext, Scb );

            FsRtlNotifyVolumeEvent( FileObject, FSRTL_VOLUME_UNLOCK );
        }

        ASSERT( !AbnormalTermination() ||
                !DeleteFile ||
                FlagOn( Fcb->FcbState, FCB_STATE_IN_FCB_TABLE ) ||
                (IrpContext->TransactionId == 0) );

        //
        //  After a file is deleted and committed no more usn reasons should be left
        //  whether or not the journal is active
        //

        ASSERT( AbnormalTermination() ||
                !FlagOn( Fcb->FcbState, FCB_STATE_FILE_DELETED ) ||
                (Fcb->FcbUsnRecord == NULL) ||
                (Fcb->FcbUsnRecord->UsnRecord.Reason == 0) );

        //
        //  And return to our caller
        //

        DebugTrace( -1, Dbg, ("NtfsCommonCleanup -> %08lx\n", Status) );
    }

#if (defined(DBG) || defined(NTFS_FREE_ASSERTS))
    ASSERT( DecrementedCleanupCount );
#endif

    NtfsCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


VOID
NtfsTrimNormalizedNames (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PSCB ParentScb
    )
/*++

Routine Description:

    Walk up the FCB/SCB chain removing all normalized names longer than
    the threshold size in inactive directories

    Try to remove parent dir normalized name if its long and  if no handles active (only this 1 left)
    and no lcbs are active - all notifies farther down in function (NtfsCommonCleanup)
    use parent Scb's normalized name.  If we don't remove it here
    this always goes away during a close

Arguments:

    IrpContext --

    Fcb -- The fcb of the starting node should already be acquired

    ParentScb - The scb of the parent of the current node

Return Value:

    none

--*/
{
    BOOLEAN DirectoryActive = FALSE;
    PFCB CurrentFcb;
    PSCB CurrentParentScb;
    PLCB ChildLcb;
    PLCB ParentLcb;
    PLIST_ENTRY Links;

    PAGED_CODE()

    //
    //  We may be occuring during a transaction so be careful to not acquire resources
    //  for the life of the transaction while traversing the tree
    //

    CurrentFcb = Fcb;
    CurrentParentScb = ParentScb;
    NtfsAcquireResourceExclusive( IrpContext, CurrentParentScb, TRUE );

    while ((CurrentParentScb->ScbType.Index.NormalizedName.MaximumLength > LONGNAME_THRESHOLD) &&
           (CurrentParentScb->CleanupCount == 0)) {

        ASSERT( (CurrentParentScb->Header.NodeTypeCode == NTFS_NTC_SCB_INDEX) ||
                (CurrentParentScb->Header.NodeTypeCode == NTFS_NTC_SCB_ROOT_INDEX) );

        //
        //  Determine that directory has no active links or handles
        //

        for (Links = CurrentParentScb->ScbType.Index.LcbQueue.Flink;
             Links != &(CurrentParentScb->ScbType.Index.LcbQueue);
             Links = Links->Flink) {

            ChildLcb = CONTAINING_RECORD( Links, LCB, ScbLinks );

            //
            //  We know the Fcb we were called with has a single cleanup count left.
            //

            if ((ChildLcb->CleanupCount != 0) &&
                (ChildLcb->Fcb != CurrentFcb)) {

                DirectoryActive = TRUE;
                break;
            }
        }

        if (!DirectoryActive) {

            //
            //  Now acquire and free name in SCB
            //

            NtfsDeleteNormalizedName( CurrentParentScb );

            //
            //  Move up to next level
            //

            if (CurrentFcb != Fcb) {
                NtfsReleaseResource( IrpContext, CurrentFcb );
            }

            CurrentFcb = CurrentParentScb->Fcb;
            if (CurrentFcb->CleanupCount != 0) {

                //
                //  Setting equal to FCB just means don't release it when we exit below
                //

                CurrentFcb = Fcb;
                break;
            }

            if (!(IsListEmpty( &(CurrentFcb->LcbQueue) ))) {


                ParentLcb = CONTAINING_RECORD( CurrentFcb->LcbQueue.Flink,
                                               LCB,
                                               FcbLinks );
                CurrentParentScb = ParentLcb->Scb;
                if (CurrentParentScb != NULL) {
                    NtfsAcquireResourceExclusive( IrpContext, CurrentParentScb, TRUE );
                } else {
                    break;
                }
            } else {
                CurrentParentScb = NULL;
                break;
            }
        } else {
            break;
        } //  endif directory active
    } //  endwhile longname in currentparentscb

    //
    //   Release last node if it isn't the starting one
    //

    if (CurrentFcb != Fcb) {
        ASSERT( CurrentFcb != NULL );
        NtfsReleaseResource( IrpContext, CurrentFcb );
    }

    if (CurrentParentScb != NULL) {
        NtfsReleaseResource( IrpContext, CurrentParentScb );
    }

    return;

} // NtfsTrimNormalizedNames


//
//  Local support routine
//

LONG
NtfsCleanupExceptionFilter (
    IN PIRP_CONTEXT IrpContext,
    IN PEXCEPTION_POINTERS ExceptionPointer,
    OUT PNTSTATUS Status
    )

/*++

Routine Description:

    Exception filter for errors during cleanup.  We want to raise if this is
    a retryable condition or fatal error, plow on as best we can if not.

Arguments:

    IrpContext  - IrpContext

    ExceptionPointer - Pointer to the exception context.

    Status - Address to store the error status.

Return Value:

    Exception status - EXCEPTION_CONTINUE_SEARCH if we want to raise to another handler,
        EXCEPTION_EXECUTE_HANDLER if we plan to proceed on.

--*/

{
    *Status = ExceptionPointer->ExceptionRecord->ExceptionCode;

    NtfsCorruptionBreakPointTest( IrpContext, *Status );

    if ((*Status == STATUS_LOG_FILE_FULL) ||
        (*Status == STATUS_CANT_WAIT) ||
        !FsRtlIsNtstatusExpected( *Status )) {

        return EXCEPTION_CONTINUE_SEARCH;
    }

    NtfsMinimumExceptionProcessing( IrpContext );

#ifdef BRIANDBG
#ifndef LFS_CLUSTER_CHECK
    //
    //  Some errors are acceptable in this path.
    //

    if (*Status == STATUS_DISK_FULL) {

        NtfsCleanupDiskFull += 1;

    } else if (*Status == STATUS_INSUFFICIENT_RESOURCES) {

        NtfsCleanupNoPool += 1;

    } else {

        //
        //  Cluster systems can hit inpage errors here because of DEVICE_OFFLINE
        //  for log I/O.
        //
        
        ASSERT( FALSE );
    }
#endif
#endif

    return EXCEPTION_EXECUTE_HANDLER;
}

#ifdef BRIANDBG
LONG
NtfsFsdCleanupExceptionFilter (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PEXCEPTION_POINTERS ExceptionPointer
    )
{
    NTSTATUS ExceptionCode = ExceptionPointer->ExceptionRecord->ExceptionCode;

    ASSERT( NT_SUCCESS( ExceptionCode ) ||
            (ExceptionCode == STATUS_CANT_WAIT) ||
            (ExceptionCode == STATUS_LOG_FILE_FULL) );

    return NtfsExceptionFilter( IrpContext, ExceptionPointer );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\cachesup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    CacheSup.c

Abstract:

    This module implements the cache management routines for Ntfs

Author:

    Your Name       [Email]         dd-Mon-Year

Revision History:

--*/

#include "NtfsProc.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (NTFS_BUG_CHECK_CACHESUP)

#define MAX_ZERO_THRESHOLD               (0x00400000)

//
//  Local debug trace level
//

#define Dbg                              (DEBUG_TRACE_CACHESUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsCompleteMdl)
#pragma alloc_text(PAGE, NtfsCreateInternalStreamCommon)
#pragma alloc_text(PAGE, NtfsDeleteInternalAttributeStream)
#pragma alloc_text(PAGE, NtfsMapStream)
#pragma alloc_text(PAGE, NtfsPinMappedData)
#pragma alloc_text(PAGE, NtfsPinStream)
#pragma alloc_text(PAGE, NtfsPreparePinWriteStream)
#pragma alloc_text(PAGE, NtfsZeroData)
#endif


VOID
NtfsCreateInternalStreamCommon (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN BOOLEAN UpdateScb,
    IN BOOLEAN CompressedStream,
    IN UNICODE_STRING const *StreamName
    )

/*++

Routine Description:

    This routine is called to prepare a stream file associated with a
    particular attribute of a file.  On return, the Scb for the attribute
    will have an associated stream file object.  On return, this
    stream file will have been initialized through the cache manager.

    TEMPCODE  The following assumptions have been made or if open issue,
    still unresolved.

        - Assume.  The call to create Scb will initialize the Mcb for
          the non-resident case.

        - Assume.  When this file is created I increment the open count
          but not the unclean count for this Scb.  When we are done with
          the stream file, we should uninitialize it and dereference it.
          We also set the file object pointer to NULL.  Close will then
          do the correct thing.

        - Assume.  Since this call is likely to be followed shortly by
          either a read or write, the cache map is initialized here.

Arguments:

    Scb - Supplies the address to store the Scb for this attribute and
          stream file.  This will exist on return from this function.

    UpdateScb - Indicates if the caller wants to update the Scb from the
                attribute.

    CompressedStream - Supplies TRUE if caller wishes to create the
                       compressed stream.

    StreamName - Internal stream name or NULL is there isn't one available.
                 This is a constant value so we don't have to allocate any pool.

Return Value:

    None.

--*/

{
    PVCB Vcb = Scb->Vcb;

    CC_FILE_SIZES CcFileSizes;
    PFILE_OBJECT CallersFileObject;
    PFILE_OBJECT *FileObjectPtr = &Scb->FileObject;
    PFILE_OBJECT UnwindStreamFile = NULL;

    BOOLEAN UnwindInitializeCacheMap = FALSE;
    BOOLEAN DecrementScbCleanup = FALSE;

    BOOLEAN AcquiredMutex = FALSE;

    ASSERT_IRP_CONTEXT( IrpContext );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsCreateInternalAttributeStream\n") );
    DebugTrace( 0, Dbg, ("Scb        -> %08lx\n", Scb) );

    //
    //  Change FileObjectPtr if he wants the compressed stream
    //

#ifdef  COMPRESS_ON_WIRE
    if (CompressedStream) {
        FileObjectPtr = &Scb->Header.FileObjectC;
    }
#endif

    //
    //  If there is no file object, we create one and initialize
    //  it.
    //

    if (*FileObjectPtr == NULL) {

        //
        //  Only acquire the mutex if we don't have the file exclusive.
        //

        if (!NtfsIsExclusiveScb( Scb )) {

            KeWaitForSingleObject( &StreamFileCreationMutex, Executive, KernelMode, FALSE, NULL );
            AcquiredMutex = TRUE;
        }

        try {

            //
            //  Someone could have gotten there first.
            //

            if (*FileObjectPtr == NULL) {

                UnwindStreamFile = IoCreateStreamFileObjectLite( NULL, Scb->Vcb->Vpb->RealDevice);

                if (ARGUMENT_PRESENT( StreamName )) {
                    UnwindStreamFile->FileName.MaximumLength = StreamName->MaximumLength;
                    UnwindStreamFile->FileName.Length = StreamName->Length;
                    UnwindStreamFile->FileName.Buffer = StreamName->Buffer;
                }

                //
                //  Propagate any flags from the caller's FileObject to our
                //  stream file that the Cache Manager may look at, so we do not
                //  miss hints like sequential only or temporary.
                //

                if (!FlagOn(Scb->ScbState, SCB_STATE_MODIFIED_NO_WRITE) &&
                    (IrpContext->OriginatingIrp != NULL) &&
                    (CallersFileObject = IoGetCurrentIrpStackLocation(IrpContext->OriginatingIrp)->FileObject)) {

                    SetFlag( UnwindStreamFile->Flags,
                             CallersFileObject->Flags & NTFS_FO_PROPAGATE_TO_STREAM );
                }

                UnwindStreamFile->SectionObjectPointer = &Scb->NonpagedScb->SegmentObject;

                //
                //  For a compressed stream, we have to use separate section
                //  object pointers.
                //

#ifdef  COMPRESS_ON_WIRE
                if (CompressedStream) {
                    UnwindStreamFile->SectionObjectPointer = &Scb->NonpagedScb->SegmentObjectC;

                }
#endif

                //
                //  If we have created the stream file, we set it to type
                //  'StreamFileOpen'
                //

                NtfsSetFileObject( UnwindStreamFile,
                                   StreamFileOpen,
                                   Scb,
                                   NULL );

                if (FlagOn( Scb->ScbState, SCB_STATE_TEMPORARY )) {

                    SetFlag( UnwindStreamFile->Flags, FO_TEMPORARY_FILE );
                }

                //
                //  Initialize the fields of the file object.
                //

                UnwindStreamFile->ReadAccess = TRUE;
                UnwindStreamFile->WriteAccess = TRUE;
                UnwindStreamFile->DeleteAccess = TRUE;

                //
                //  Increment the open count and set the section
                //  object pointers.  We don't set the unclean count as the
                //  cleanup call has already occurred.
                //

                NtfsIncrementCloseCounts( Scb, TRUE, FALSE );

                //
                //  Increment the cleanup count in this Scb to prevent the
                //  Scb from going away if the cache call fails.
                //

                InterlockedIncrement( &Scb->CleanupCount );
                DecrementScbCleanup = TRUE;

                //
                //  If the Scb header has not been initialized, we will do so now.
                //

                if (UpdateScb && 
                    !FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED )) {

                    NtfsUpdateScbFromAttribute( IrpContext, Scb, NULL );
                }

                //
                //  If this is a compressed stream and the file is not already
                //  marked as MODIFIED_NO_WRITE then do it now.  Use the
                //  Extended flag field in the Fsrtl header for this.  Since this
                //  is the only place we make this call with FsContext2 == NULL,
                //  it does not matter how we leave the FsRtl header flag.!
                //

                NtfsAcquireFsrtlHeader( Scb );
                ClearFlag(Scb->Header.Flags2, FSRTL_FLAG2_DO_MODIFIED_WRITE);
                if (!FlagOn( Scb->ScbState, SCB_STATE_MODIFIED_NO_WRITE ) &&
                    !FlagOn( Scb->Header.Flags2, FSRTL_FLAG2_DO_MODIFIED_WRITE ) &&
                    !CompressedStream) {

                    SetFlag(Scb->Header.Flags2, FSRTL_FLAG2_DO_MODIFIED_WRITE);
                }
                NtfsReleaseFsrtlHeader( Scb );

                //
                //  Check if we need to initialize the cache map for the stream file.
                //  The size of the section to map will be the current allocation
                //  for the stream file.
                //

                if (UnwindStreamFile->PrivateCacheMap == NULL) {

                    BOOLEAN PinAccess;

                    CcFileSizes = *(PCC_FILE_SIZES)&Scb->Header.AllocationSize;

                    //
                    //  If this is a stream with Usa protection, we want to tell
                    //  the Cache Manager we do not need to get any valid data
                    //  callbacks.  We do this by having xxMax sitting in
                    //  ValidDataLength for the call, but we have to restore the
                    //  correct value afterwards.
                    //
                    //  We also do this for all of the stream files created during
                    //  restart.  This has the effect of telling Mm to always
                    //  fault the page in from disk.  Don't generate a zero page if
                    //  push up the file size during restart.
                    //

                    if (FlagOn( Scb->ScbState, SCB_STATE_MODIFIED_NO_WRITE )) {

                        CcFileSizes.ValidDataLength.QuadPart = MAXLONGLONG;
                    }

                    PinAccess =
                        (BOOLEAN) (Scb->AttributeTypeCode != $DATA ||
                                   FlagOn(Scb->Fcb->FcbState, FCB_STATE_PAGING_FILE | FCB_STATE_SYSTEM_FILE) ||
                                   FlagOn( Scb->Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS ) ||
                                   CompressedStream);

                    //
                    //  Bias this for the Usn journal.
                    //

                    if (FlagOn( Scb->ScbPersist, SCB_PERSIST_USN_JOURNAL )) {

                        CcFileSizes.AllocationSize.QuadPart -= Vcb->UsnCacheBias;
                        CcFileSizes.FileSize.QuadPart -= Vcb->UsnCacheBias;
                    }

                    CcInitializeCacheMap( UnwindStreamFile,
                                          &CcFileSizes,
                                          PinAccess,
                                          &NtfsData.CacheManagerCallbacks,
                                          (PCHAR)Scb + CompressedStream );

                    UnwindInitializeCacheMap = TRUE;
                }

                //
                //  Now call Cc to set the log handle for the file.
                //

                if (FlagOn( Scb->ScbState, SCB_STATE_MODIFIED_NO_WRITE ) &&
                    (Scb != Vcb->LogFileScb)) {

                    CcSetLogHandleForFile( UnwindStreamFile,
                                           Vcb->LogHandle,
                                           &LfsFlushToLsn );
                }

                //
                //  It is now safe to store the stream file in the Scb.  We wait
                //  until now because we don't want an unsafe tester to use the
                //  file object until the cache is initialized.
                //

                *FileObjectPtr = UnwindStreamFile;
            }

        } finally {

            DebugUnwind( NtfsCreateInternalAttributeStream );

            //
            //  Undo our work if an error occurred.
            //

            if (AbnormalTermination()) {

                //
                //  Uninitialize the cache file if we initialized it.
                //

                if (UnwindInitializeCacheMap) {

                    CcUninitializeCacheMap( UnwindStreamFile, NULL, NULL );
                }

                //
                //  Dereference the stream file if we created it.
                //

                if (UnwindStreamFile != NULL) {

                    //
                    //  Clear the internal file name constant
                    //

                    NtfsClearInternalFilename( UnwindStreamFile );

                    ObDereferenceObject( UnwindStreamFile );
                }
            }

            //
            //  Restore the Scb cleanup count.
            //

            if (DecrementScbCleanup) {

                InterlockedDecrement( &Scb->CleanupCount );
            }

            if (AcquiredMutex) {

                KeReleaseMutant( &StreamFileCreationMutex, IO_NO_INCREMENT, FALSE, FALSE );
            }

            DebugTrace( -1, Dbg, ("NtfsCreateInternalAttributeStream -> VOID\n") );
        }
    }

    return;
}


BOOLEAN
NtfsDeleteInternalAttributeStream (
    IN PSCB Scb,
    IN ULONG ForceClose,
    IN ULONG CompressedStreamOnly
    )

/*++

Routine Description:

    This routine is the inverse of NtfsCreateInternalAttributeStream.  It
    uninitializes the cache map and dereferences the stream file object.
    It is coded defensively, in case the stream file object does not exist
    or the cache map has not been initialized.

Arguments:

    Scb - Supplies the Scb for which the stream file is to be deleted.

    ForceClose - Indicates if we to immediately close everything down or
        if we are willing to let Mm slowly migrate things out.

    CompressedStreamOnly - Indicates if we only want to delete the compressed
        stream.

Return Value:

    BOOLEAN - TRUE if we dereference a file object, FALSE otherwise.

--*/

{
    PFILE_OBJECT FileObject;
#ifdef  COMPRESS_ON_WIRE
    PFILE_OBJECT FileObjectC;
#endif

    BOOLEAN Dereferenced = FALSE;

    PAGED_CODE();

    //
    //  We normally already have the paging Io resource.  If we do
    //  not, then it is typically some cleanup path of create or
    //  whatever.  This code assumes that if we cannot get the paging
    //  Io resource, then there is other activity still going on,
    //  and it is ok to not delete the stream!  For example, it could
    //  be the lazy writer, who definitely needs the stream.
    //

    if (
#ifdef  COMPRESS_ON_WIRE
        ((Scb->FileObject != NULL) || (Scb->Header.FileObjectC != NULL)) &&
#else
        (Scb->FileObject != NULL) &&
#endif
        ((Scb->Header.PagingIoResource == NULL) ||
         ExAcquireResourceExclusiveLite( Scb->Header.PagingIoResource, FALSE ))) {


        KeWaitForSingleObject( &StreamFileCreationMutex, Executive, KernelMode, FALSE, NULL );

        //
        //  Capture both file objects and clear the fields so no one else
        //  can access them.
        //

        if (CompressedStreamOnly) {

            FileObject = NULL;

        } else {

            FileObject = Scb->FileObject;
            Scb->FileObject = NULL;

            //
            //  Clear the internal file name constant
            //

            NtfsClearInternalFilename( FileObject );
        }

#ifdef  COMPRESS_ON_WIRE
        FileObjectC = Scb->Header.FileObjectC;
        Scb->Header.FileObjectC = NULL;
#endif

        KeReleaseMutant( &StreamFileCreationMutex, IO_NO_INCREMENT, FALSE, FALSE );

        if (Scb->Header.PagingIoResource != NULL) {
            ExReleaseResourceLite( Scb->Header.PagingIoResource );
        }

        //
        //  Now dereference each file object.
        //

        if (FileObject != NULL) {

            //
            //  We shouldn't be deleting the internal stream objects of the MFT & co, unless
            //  we are in the dismounting, restarting or mounting path.
            //

            ASSERT( (((PSCB) FileObject->FsContext)->Header.NodeTypeCode != NTFS_NTC_SCB_MFT) ||
                     FlagOn( Scb->Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS ) ||
                     FlagOn( Scb->Vcb->VcbState, VCB_STATE_PERFORMED_DISMOUNT ) ||
                     !FlagOn( Scb->Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED ) ||
                     Scb->Vcb->RootIndexScb == NULL );

            if (FileObject->PrivateCacheMap != NULL) {

                CcUninitializeCacheMap( FileObject,
                                        (ForceClose ? &Li0 : NULL),
                                        NULL );
            }

            ObDereferenceObject( FileObject );
            Dereferenced = TRUE;
        }

#ifdef  COMPRESS_ON_WIRE
        if (FileObjectC != NULL) {

            if (FileObjectC->PrivateCacheMap != NULL) {

                CcUninitializeCacheMap( FileObjectC,
                                        (ForceClose ? &Li0 : NULL),
                                        NULL );
            }

            //
            //  For the compressed stream, deallocate the additional
            //  section object pointers.
            //

            ObDereferenceObject( FileObjectC );
            Dereferenced = TRUE;
        }
#endif
    }

    return Dereferenced;
}


VOID
NtfsMapStream (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN LONGLONG FileOffset,
    IN ULONG Length,
    OUT PVOID *Bcb,
    OUT PVOID *Buffer
    )

/*++

Routine Description:

    This routine is called to map a range of bytes within the stream file
    for an Scb.  The allowed range to map is bounded by the allocation
    size for the Scb.  This operation is only valid on a non-resident
    Scb.

    TEMPCODE - The following need to be resolved for this routine.

        - Can the caller specify either an empty range or an invalid range.
          In that case we need to able to return the actual length of the
          mapped range.

Arguments:

    Scb - This is the Scb for the operation.

    FileOffset - This is the offset within the Scb where the data is to
                 be pinned.

    Length - This is the number of bytes to pin.

    Bcb - Returns a pointer to the Bcb for this range of bytes.

    Buffer - Returns a pointer to the range of bytes.  We can fault them in
             by touching them, but they aren't guaranteed to stay unless
             we pin them via the Bcb.

Return Value:

    None.

--*/

{
    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( Scb );
    ASSERT( Length != 0 );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsMapStream\n") );
    DebugTrace( 0, Dbg, ("Scb        = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("FileOffset = %016I64x\n", FileOffset) );
    DebugTrace( 0, Dbg, ("Length     = %08lx\n", Length) );

    //
    //  The file object should already exist in the Scb.
    //

    ASSERT( Scb->FileObject != NULL );

    //
    //  If we are trying to go beyond the end of the allocation, assume
    //  we have some corruption.
    //

    if ((FileOffset + Length) > Scb->Header.AllocationSize.QuadPart) {

        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
    }

    //
    //  Call the cache manager to map the data.  This call may raise, but
    //  will never return an error (including CANT_WAIT).
    //

    if (!CcMapData( Scb->FileObject,
                    (PLARGE_INTEGER)&FileOffset,
                    Length,
                    TRUE,
                    Bcb,
                    Buffer )) {

        NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
    }
#ifdef MAPCOUNT_DBG
    IrpContext->MapCount++;
#endif

    DebugTrace( 0, Dbg, ("Buffer -> %08lx\n", *Buffer) );
    DebugTrace( -1, Dbg, ("NtfsMapStream -> VOID\n") );

    return;
}


VOID
NtfsPinMappedData (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN LONGLONG FileOffset,
    IN ULONG Length,
    IN OUT PVOID *Bcb
    )

/*++

Routine Description:

    This routine is called to pin a previously mapped range of bytes
    within the stream file for an Scb, for the purpose of subsequently
    modifying this byte range.  The allowed range to map is
    bounded by the allocation size for the Scb.  This operation is only
    valid on a non-resident Scb.

    The data is guaranteed to stay at the same virtual address as previously
    returned from NtfsMapStream.

    TEMPCODE - The following need to be resolved for this routine.

        - Can the caller specify either an empty range or an invalid range.
          In that case we need to able to return the actual length of the
          mapped range.

Arguments:

    Scb - This is the Scb for the operation.

    FileOffset - This is the offset within the Scb where the data is to
                 be pinned.

    Length - This is the number of bytes to pin.

    Bcb - Returns a pointer to the Bcb for this range of bytes.

Return Value:

    None.

--*/

{
    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( Scb );
    ASSERT( Length != 0 );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsPinMappedData\n") );
    DebugTrace( 0, Dbg, ("Scb        = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("FileOffset = %016I64x\n", FileOffset) );
    DebugTrace( 0, Dbg, ("Length     = %08lx\n", Length) );

    //
    //  The file object should already exist in the Scb.
    //

    ASSERT( Scb->FileObject != NULL );

    //
    //  If we are trying to go beyond the end of the allocation, assume
    //  we have some corruption.
    //

    if ((FileOffset + Length) > Scb->Header.AllocationSize.QuadPart) {

        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
    }

    //
    //  Call the cache manager to map the data.  This call may raise, but
    //  will never return an error (including CANT_WAIT).
    //

    if (!CcPinMappedData( Scb->FileObject,
                          (PLARGE_INTEGER)&FileOffset,
                          Length,
                          FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT ),
                          Bcb )) {

        NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
    }

    DebugTrace( -1, Dbg, ("NtfsMapStream -> VOID\n") );

    return;
}


VOID
NtfsPinStream (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN LONGLONG FileOffset,
    IN ULONG Length,
    OUT PVOID *Bcb,
    OUT PVOID *Buffer
    )

/*++

Routine Description:

    This routine is called to pin a range of bytes within the stream file
    for an Scb.  The allowed range to pin is bounded by the allocation
    size for the Scb.  This operation is only valid on a non-resident
    Scb.

    TEMPCODE - The following need to be resolved for this routine.

        - Can the caller specify either an empty range or an invalid range.
          In that case we need to able to return the actual length of the
          pinned range.

Arguments:

    Scb - This is the Scb for the operation.

    FileOffset - This is the offset within the Scb where the data is to
                 be pinned.

    Length - This is the number of bytes to pin.

    Bcb - Returns a pointer to the Bcb for this range of bytes.

    Buffer - Returns a pointer to the range of bytes pinned in memory.

Return Value:

    None.

--*/

{
    NTSTATUS OldStatus = IrpContext->ExceptionStatus;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( Scb );
    ASSERT( Length != 0 );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsPinStream\n") );
    DebugTrace( 0, Dbg, ("Scb        = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("FileOffset = %016I64x\n", FileOffset) );
    DebugTrace( 0, Dbg, ("Length     = %08lx\n", Length) );

    //
    //  The file object should already exist in the Scb.
    //

    ASSERT( Scb->FileObject != NULL );

    //
    //  If we are trying to go beyond the end of the allocation, assume
    //  we have some corruption.
    //

    if ((FileOffset + Length) > Scb->Header.AllocationSize.QuadPart) {

        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
    }

    //
    //  Call the cache manager to map the data.  This call may raise, or
    //  will return FALSE if waiting is required.
    //

    if (FlagOn( Scb->ScbPersist, SCB_PERSIST_USN_JOURNAL )) {

        FileOffset -= Scb->Vcb->UsnCacheBias;
    }

    if (!CcPinRead( Scb->FileObject,
                    (PLARGE_INTEGER)&FileOffset,
                    Length,
                    FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT ),
                    Bcb,
                    Buffer )) {

        ASSERT( !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT ));

        //
        // Could not pin the data without waiting (cache miss).
        //

        NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
    }

    //
    //  We don't want to propagate wether or not we hit eof. Its assumed the code pinning is
    //  already filesize synchronized
    //

    if (IrpContext->ExceptionStatus == STATUS_END_OF_FILE) {
        IrpContext->ExceptionStatus = OldStatus;
    }

#ifdef MAPCOUNT_DBG
    IrpContext->MapCount++;
#endif


    DebugTrace( 0, Dbg, ("Bcb -> %08lx\n", *Bcb) );
    DebugTrace( 0, Dbg, ("Buffer -> %08lx\n", *Buffer) );
    DebugTrace( -1, Dbg, ("NtfsMapStream -> VOID\n") );

    return;
}


VOID
NtfsPreparePinWriteStream (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN LONGLONG FileOffset,
    IN ULONG Length,
    IN BOOLEAN Zero,
    OUT PVOID *Bcb,
    OUT PVOID *Buffer
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( Scb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsPreparePinWriteStream\n") );
    DebugTrace( 0, Dbg, ("Scb        = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("FileOffset = %016I64x\n", FileOffset) );
    DebugTrace( 0, Dbg, ("Length     = %08lx\n", Length) );

    //
    //  The file object should already exist in the Scb.
    //

    ASSERT( Scb->FileObject != NULL );

    //
    //  If we are trying to go beyond the end of the allocation, assume
    //  we have some corruption.
    //

    if ((FileOffset + Length) > Scb->Header.AllocationSize.QuadPart) {

        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
    }

    //
    //  Call the cache manager to do it.  This call may raise, or
    //  will return FALSE if waiting is required.
    //

    if (!CcPreparePinWrite( Scb->FileObject,
                            (PLARGE_INTEGER)&FileOffset,
                            Length,
                            Zero,
                            FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT ),
                            Bcb,
                            Buffer )) {

        ASSERT( !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT ));

        //
        // Could not pin the data without waiting (cache miss).
        //

        NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
    }
#ifdef MAPCOUNT_DBG
    IrpContext->MapCount++;
#endif

    DebugTrace( 0, Dbg, ("Bcb -> %08lx\n", *Bcb) );
    DebugTrace( 0, Dbg, ("Buffer -> %08lx\n", *Buffer) );
    DebugTrace( -1, Dbg, ("NtfsPreparePinWriteStream -> VOID\n") );

    return;
}


NTSTATUS
NtfsCompleteMdl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the function of completing Mdl read and write
    requests.  It should be called only from NtfsFsdRead and NtfsFsdWrite.

Arguments:

    Irp - Supplies the originating Irp.

Return Value:

    NTSTATUS - Will always be STATUS_PENDING or STATUS_SUCCESS.

--*/

{
    PFILE_OBJECT FileObject;
    PIO_STACK_LOCATION IrpSp;
    PNTFS_ADVANCED_FCB_HEADER Header;

    ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));
    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsCompleteMdl\n") );
    DebugTrace( 0, Dbg, ("IrpContext = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp        = %08lx\n", Irp) );

    //
    // Do completion processing.
    //

    FileObject = IoGetCurrentIrpStackLocation( Irp )->FileObject;

    switch( IrpContext->MajorFunction ) {

    case IRP_MJ_READ:

        CcMdlReadComplete( FileObject, Irp->MdlAddress );
        break;

    case IRP_MJ_WRITE:

        try {

            PSCB Scb;
            VBO StartingVbo;
            LONGLONG ByteCount;
            LONGLONG ByteRange;
            BOOLEAN DoingIoAtEof = FALSE;

            ASSERT( FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT ));

            IrpSp = IoGetCurrentIrpStackLocation( Irp );
            Scb = (PSCB)(IrpSp->FileObject->FsContext);
            Header = &(Scb->Header);

            //
            //  Now synchronize with the FsRtl Header and Scb.
            //

            if (Header->PagingIoResource != NULL) {

                StartingVbo = IrpSp->Parameters.Write.ByteOffset.QuadPart;
                ByteCount = (LONGLONG) IrpSp->Parameters.Write.Length;
                ByteRange = StartingVbo + ByteCount + PAGE_SIZE - 1;
                ClearFlag( ((ULONG) ByteRange), PAGE_SIZE - 1 );

                ExAcquireResourceSharedLite( Header->PagingIoResource, TRUE );
                NtfsAcquireFsrtlHeader( Scb );

                //
                //  Now see if this is at EOF.
                //  Recursive flush will generate IO which ends on page boundary
                //  which is why we rounded the range
                //

                if (ByteRange > Header->ValidDataLength.QuadPart) {

                    //
                    //  Mark that we are writing to EOF.  If someone else is currently
                    //  writing to EOF, wait for them.
                    //

                    ASSERT( ByteRange - StartingVbo < MAXULONG );

                    DoingIoAtEof = !FlagOn( Header->Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE ) ||
                                   NtfsWaitForIoAtEof( Header, (PLARGE_INTEGER)&StartingVbo, (ULONG)(ByteRange - StartingVbo) );

                    if (DoingIoAtEof) {

                        SetFlag( Header->Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE );

#if (DBG || defined( NTFS_FREE_ASSERTS ))
                        ((PSCB) Header)->IoAtEofThread = (PERESOURCE_THREAD) ExGetCurrentResourceThread();
#endif
                        //
                        //  Store this in the IrpContext until commit or post.
                        //

                        IrpContext->CleanupStructure = Scb;
                    }
                }

                NtfsReleaseFsrtlHeader( Scb );
            }

            CcMdlWriteComplete( FileObject, &IrpSp->Parameters.Write.ByteOffset, Irp->MdlAddress );

        } finally {

            if (Header->PagingIoResource != NULL) {

                ExReleaseResourceLite( Header->PagingIoResource );
            }
        }

        break;

    default:

        DebugTrace( DEBUG_TRACE_ERROR, 0, ("Illegal Mdl Complete.\n") );

        ASSERTMSG("Illegal Mdl Complete, About to bugcheck ", FALSE);
        NtfsBugCheck( IrpContext->MajorFunction, 0, 0 );
    }

    //
    // Mdl is now deallocated.
    //

    Irp->MdlAddress = NULL;

    //
    //  Ignore errors.  CC has already cleaned up his structures.
    //

    IrpContext->ExceptionStatus = STATUS_SUCCESS;
    NtfsMinimumExceptionProcessing( IrpContext );

    //
    // Complete the request and exit right away.
    //

    NtfsCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );

    DebugTrace( -1, Dbg, ("NtfsCompleteMdl -> STATUS_SUCCESS\n") );

    return STATUS_SUCCESS;
}


BOOLEAN
NtfsZeroData (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PFILE_OBJECT FileObject,
    IN LONGLONG StartingZero,
    IN LONGLONG ByteCount,
    IN OUT PLONGLONG CommittedFileSize OPTIONAL
    )

/*++

Routine Description:

    This routine is called to zero a range of a file in order to
    advance valid data length.

Arguments:

    Scb - Scb for the stream to zero.

    FileObject - FileObject for the stream.

    StartingZero - Offset to begin the zero operation.

    ByteCount - Length of range to zero.

    CommittedFileSize - If we write the file sizes and commit the
        transaction then we want to let our caller know what
        point to roll back file size on a subsequent failure.  On entry
        it has the size our caller wants to roll back the file size to.
        On exit it has the new size to roll back to which takes into
        account any updates to the file size which have been logged.

Return Value:

    BOOLEAN - TRUE if the entire range was zeroed, FALSE if the request
        is broken up or the cache manager would block.

--*/

{
    LONGLONG Temp;

#ifdef  COMPRESS_ON_WIRE
    IO_STATUS_BLOCK IoStatus;
#endif

    ULONG SectorSize;

    BOOLEAN Finished;
    BOOLEAN CompleteZero = TRUE;
    BOOLEAN ScbAcquired = FALSE;

    PVCB Vcb = Scb->Vcb;

    LONGLONG ZeroStart;
    LONGLONG BeyondZeroEnd;
    ULONG CompressionUnit = Scb->CompressionUnit;

    BOOLEAN Wait;

    PAGED_CODE();

    Wait = (BOOLEAN) FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

    //
    //  We don't expect to ever be explicitly zeroing system files 
    //  

    ASSERT( !FlagOn( Scb->Fcb->FcbState, FCB_STATE_SYSTEM_FILE ) );

    SectorSize = Vcb->BytesPerSector;

    //
    //  We may be able to simplify the zero operation (sparse file or when writing
    //  compressed) by deallocating large ranges of the file.  Otherwise we have to
    //  generate zeroes for the entire range.  If that is the case we want to split
    //  this operation up.
    //

    if ((ByteCount > MAX_ZERO_THRESHOLD) &&
        !FlagOn( Scb->ScbState, SCB_STATE_WRITE_COMPRESSED ) &&
        !FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

        ByteCount = MAX_ZERO_THRESHOLD;
        CompleteZero = FALSE;
    }

    ZeroStart = BlockAlign( StartingZero, (LONG)SectorSize );
    BeyondZeroEnd = BlockAlign( StartingZero + ByteCount, (LONG)SectorSize );

    ASSERT( BeyondZeroEnd >= (StartingZero + ByteCount) );

    //
    //  Directly zero from startingzero to zerostart on disk for vanilla nonresident 
    //  files.  Compressed files always write out compression units worth of data 
    //  which would cover this range. Resident files are always changed in
    //  NtfsChangeAttributeValue which also also zeroes any gaps
    //  

    if ((CompressionUnit == 0) && 
        (ZeroStart != StartingZero) &&
        (!FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT ))) {

        //
        //   Writing directly to disk is always safe - we can go through the
        //   cachemap if the file is cached and its not mapped. If its mapped
        //   there may be data between vdl and fs we don't know about yet
        //   We also must go non cached if we're not the top level request to avoid
        //   a recursive flush if mm is initiating the initial write via the deref seg thread or
        //   if an initial cache coherency flush caused this 
        //  
        
        BOOLEAN CachedWrite = NtfsIsTopLevelRequest( IrpContext ) && (FileObject->PrivateCacheMap != NULL) && !FlagOn( Scb->Header.Flags, FSRTL_FLAG_USER_MAPPED_FILE );

        NtfsZeroEndOfSector( IrpContext, IrpContext->OriginatingIrp, Scb, StartingZero, CachedWrite );

#ifdef SYSCACHE_DEBUG
        if (ScbIsBeingLogged( Scb )) {
            FsRtlLogSyscacheEvent( Scb, SCE_ZERO_HEAD_SECTOR, CachedWrite, StartingZero, ZeroStart, Scb->Header.ValidDataLength.QuadPart );
        }
#endif

    }

    //
    //  We must flush the first compression unit in case it is partially populated
    //  in the compressed stream.
    //

#ifdef  COMPRESS_ON_WIRE

    if ((Scb->NonpagedScb->SegmentObjectC.DataSectionObject != NULL) &&
        ((StartingZero & (CompressionUnit - 1)) != 0)) {

        StartingZero = BlockAlignTruncate( StartingZero, (LONG)CompressionUnit );
        CcFlushCache( &Scb->NonpagedScb->SegmentObjectC,
                      (PLARGE_INTEGER)&StartingZero,
                      CompressionUnit,
                      &IoStatus );

        if (!NT_SUCCESS(IoStatus.Status)) {
            NtfsNormalizeAndRaiseStatus( IrpContext, IoStatus.Status, STATUS_UNEXPECTED_IO_ERROR );
        }
    }
#endif

    //
    //  If this is a sparse or compressed file and we are zeroing a lot, then let's
    //  just delete the space instead of writing tons of zeros and deleting
    //  the space in the noncached path!  If we are currently decompressing
    //  a compressed file we can't take this path.
    //

    if ((FlagOn( Scb->ScbState, SCB_STATE_WRITE_COMPRESSED ) ||
         FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) &&
        (ByteCount > (Scb->CompressionUnit * 2))) {

        //
        //  Find the end of the first compression unit being zeroed.
        //

        Temp = BlockAlign( ZeroStart, (LONG)CompressionUnit );

        //
        //  Zero the first compression unit.
        //

        if ((ULONG)Temp != (ULONG)ZeroStart) {

            Finished = CcZeroData( FileObject, (PLARGE_INTEGER)&ZeroStart, (PLARGE_INTEGER)&Temp, Wait );

#ifdef SYSCACHE_DEBUG
            if (ScbIsBeingLogged( Scb )) {
                FsRtlLogSyscacheEvent( Scb, SCE_ZERO_HEAD_COMPRESSED, 0, ZeroStart, Temp, Finished );
            }
#endif

            if (!Finished) {return FALSE;}

            ZeroStart = Temp;
        }

        //
        //  Now delete all of the compression units in between.
        //

        //
        //  Calculate the start of the last compression unit in bytes.
        //

        Temp = BeyondZeroEnd;
        (ULONG)Temp &= ~(CompressionUnit - 1);

        //
        //  If the caller has not already started a transaction (like write.c),
        //  then let's just do the delete as an atomic action.
        //

        if (!NtfsIsExclusiveScb( Scb )) {

            NtfsAcquireExclusiveScb( IrpContext, Scb );
            ScbAcquired = TRUE;

            if (ARGUMENT_PRESENT( CommittedFileSize )) {

                NtfsMungeScbSnapshot( IrpContext, Scb, *CommittedFileSize );
            }
        }

        try {

            //
            //  Delete the space.
            //

            NtfsDeleteAllocation( IrpContext,
                                  FileObject,
                                  Scb,
                                  LlClustersFromBytes( Vcb, ZeroStart ),
                                  LlClustersFromBytesTruncate( Vcb, Temp ) - 1,
                                  TRUE,
                                  TRUE );

            //
            
            //  If we didn't raise then update the Scb values for compressed files.
            //

            if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {
                Scb->ValidDataToDisk = Temp;
            }

            //
            //  If we succeed, commit the atomic action.  Release all of the exclusive
            //  resources if our user explicitly acquired the Fcb here.
            //

            if (ScbAcquired) {
                NtfsCheckpointCurrentTransaction( IrpContext );

                if (ARGUMENT_PRESENT( CommittedFileSize )) {

                    ASSERT( Scb->ScbSnapshot != NULL );
                    *CommittedFileSize = Scb->ScbSnapshot->FileSize;
                }

                while (!IsListEmpty( &IrpContext->ExclusiveFcbList )) {

                    NtfsReleaseFcb( IrpContext,
                                    (PFCB)CONTAINING_RECORD( IrpContext->ExclusiveFcbList.Flink,
                                                             FCB,
                                                             ExclusiveFcbLinks ));
                }

                ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_RELEASE_USN_JRNL |
                                              IRP_CONTEXT_FLAG_RELEASE_MFT );

                ScbAcquired = FALSE;
            }

            if (FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA )) {

                Scb->Fcb->Info.AllocatedLength = Scb->TotalAllocated;
                SetFlag( Scb->Fcb->InfoFlags, FCB_INFO_CHANGED_ALLOC_SIZE );
            }

        } finally {

            if (ScbAcquired) {
                NtfsReleaseScb( IrpContext, Scb );
            }
        }

        //
        //  Zero the beginning of the last compression unit.
        //

        if ((ULONG)Temp != (ULONG)BeyondZeroEnd) {

            Finished = CcZeroData( FileObject, (PLARGE_INTEGER)&Temp, (PLARGE_INTEGER)&BeyondZeroEnd, Wait );

#ifdef SYSCACHE_DEBUG
            if (ScbIsBeingLogged( Scb )) {
                FsRtlLogSyscacheEvent( Scb, SCE_ZERO_TAIL_COMPRESSED, 0, Temp, BeyondZeroEnd, Finished );
            }
#endif

            if (!Finished) {return FALSE;}

            BeyondZeroEnd = Temp;
        }

        return TRUE;
    }

    //
    //  If we were called to just zero part of a sector we are in trouble.
    //

    if (ZeroStart == BeyondZeroEnd) {

        return TRUE;
    }

    Finished = CcZeroData( FileObject,
                           (PLARGE_INTEGER)&ZeroStart,
                           (PLARGE_INTEGER)&BeyondZeroEnd,
                           Wait );

    //
    //  If we are breaking this request up then commit the current
    //  transaction (including updating the valid data length in
    //  in the Scb) and return FALSE.
    //

    if (Finished && !CompleteZero) {

        //
        //  Synchronize the valid data length change using the mutex.
        //

        ExAcquireFastMutex( Scb->Header.FastMutex );
        Scb->Header.ValidDataLength.QuadPart = BeyondZeroEnd;

        //
        //  Move the rollback point up to include the range of zeroed
        //  data.
        //

        if (ARGUMENT_PRESENT( CommittedFileSize )) {

            if (BeyondZeroEnd > *CommittedFileSize) {

                *CommittedFileSize = BeyondZeroEnd;
            }
        }

        ASSERT( Scb->Header.ValidDataLength.QuadPart <= Scb->Header.FileSize.QuadPart );

        ExReleaseFastMutex( Scb->Header.FastMutex );
        NtfsCheckpointCurrentTransaction( IrpContext );
        return FALSE;
    }

    return Finished;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\bitmpsup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    BitmpSup.c

Abstract:

    This module implements the general bitmap allocation & deallocation
    routines for Ntfs.  It is defined into two main parts the first
    section handles the bitmap file for clusters on the disk.  The
    second part is for bitmap attribute allocation (e.g., the mft bitmap).

    So unlike other modules this one has local procedure prototypes and
    definitions followed by the exported bitmap file routines, followed
    by the local bitmap file routines, and then followed by the bitmap
    attribute routines, followed by the local bitmap attribute allocation
    routines.

Author:

    Gary Kimura     [GaryKi]        23-Nov-1991

Revision History:

--*/

#include "NtfsProc.h"

#ifdef NTFS_FRAGMENT_DISK
BOOLEAN NtfsFragmentDisk = FALSE;
ULONG NtfsFragmentLength = 2;
BOOLEAN NtfsFragmentMft = FALSE;
#endif

#ifdef NTFS_CHECK_CACHED_RUNS
BOOLEAN NtfsDoVerifyCachedRuns = FALSE;
#endif

#define NTFS_MFT_ZONE_DEFAULT_SHIFT         (3)
#define BITMAP_VOLATILE_FREE_COUNT          (0x400)

//
//  Define stack overflow threshhold.
//

#define OVERFLOW_RECORD_THRESHHOLD         (0xF00)

//
//  A mask of single bits used to clear and set bits in a byte
//

static UCHAR BitMask[] = { 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80 };

//
//  Local debug trace level
//

#define Dbg                              (DEBUG_TRACE_BITMPSUP)

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('BFtN')

#define MIN3(A,B,C) ((((A) < (B)) && ((A) < (C))) ? (A) : ((((B) < (A)) && ((B) < (C))) ? (B) : (C)))

#define CollectAllocateClusterStats(VCB,SIZE,HINT) {            \
    (VCB)->Statistics->Ntfs.Allocate.Calls += 1;                \
    (VCB)->Statistics->Ntfs.Allocate.Clusters += (ULONG)(SIZE); \
    if (HINT) { (VCB)->Statistics->Ntfs.Allocate.Hints += 1; }  \
}

#define IncrementAllocateClusterStats(VCB) {            \
    (VCB)->Statistics->Ntfs.Allocate.RunsReturned += 1; \
}

#define IncrementHintHonoredStats(VCB,SIZE) {                        \
    (VCB)->Statistics->Ntfs.Allocate.HintsHonored += 1;              \
    (VCB)->Statistics->Ntfs.Allocate.HintsClusters += (ULONG)(SIZE); \
}

#define IncrementCacheHitStats(VCB,SIZE) {                           \
    (VCB)->Statistics->Ntfs.Allocate.Cache += 1;                     \
    (VCB)->Statistics->Ntfs.Allocate.CacheClusters += (ULONG)(SIZE); \
}

#define IncrementCacheMissStats(VCB,SIZE) {                              \
    (VCB)->Statistics->Ntfs.Allocate.CacheMiss += 1;                     \
    (VCB)->Statistics->Ntfs.Allocate.CacheMissClusters += (ULONG)(SIZE); \
}


//
//  Local routines to manage the cached free clusters.
//

BOOLEAN
NtfsLookupCachedLcn (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN LCN Lcn,
    OUT PLCN StartingLcn,
    OUT PLONGLONG RunLength,
    OUT PUSHORT Index OPTIONAL
    );

BOOLEAN
NtfsGetNextCachedLcn (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN USHORT Index,
    OUT PLCN StartingLcn,
    OUT PLONGLONG RunLength
    );

BOOLEAN
NtfsLookupCachedLcnByLength (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN LONGLONG Length,
    IN BOOLEAN AllowShorter,
    IN LCN Lcn,
    OUT PLCN StartingLcn,
    OUT PLONGLONG RunLength,
    OUT PUSHORT Index OPTIONAL
    );

VOID
NtfsInsertCachedLcn (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN LCN Lcn,
    IN LONGLONG Length
    );

VOID
NtfsRemoveCachedLcn (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN LCN Lcn,
    IN LONGLONG Length
    );

//
//  The following are the internal routines we use to manage this.
//

BOOLEAN
NtfsGrowCachedRuns (
    IN PNTFS_CACHED_RUNS CachedRuns
    );

VOID
NtfsCompactCachedRuns (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN USHORT FirstIndex,
    IN USHORT LastIndex,
    IN BOOLEAN LcnSortedList
    );

VOID
NtfsAddCachedRunMult (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LCN StartingLcn,
    IN RTL_BITMAP_RUN *RunArray,
    IN ULONG RunCount
    );

VOID
NtfsDeleteCachedRun (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN USHORT LcnIndex,
    IN USHORT LenIndex
    );

VOID
NtfsGrowLengthInCachedLcn (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN PNTFS_LCN_CLUSTER_RUN ThisEntry,
    IN USHORT LcnIndex
    );

VOID
NtfsShrinkLengthInCachedLcn (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN PNTFS_LCN_CLUSTER_RUN ThisEntry,
    IN USHORT LcnIndex
    );

USHORT
NtfsGetCachedLengthInsertionPoint (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN LCN Lcn,
    IN LONGLONG Length
    );

VOID
NtfsInsertCachedRun (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN LCN Lcn,
    IN LONGLONG Length,
    IN USHORT LcnIndex
    );

BOOLEAN
NtfsPositionCachedLcn (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN LCN Lcn,
    OUT PUSHORT Index
    );

BOOLEAN
NtfsPositionCachedLcnByLength (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN LONGLONG RunLength,
    IN PLCN Lcn OPTIONAL,
    IN PUSHORT StartIndex OPTIONAL,
    IN BOOLEAN SearchForward,
    OUT PUSHORT RunIndex
    );

#ifdef NTFS_CHECK_CACHED_RUNS
VOID
NtfsVerifyCachedLcnRuns (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN USHORT FirstIndex,
    IN USHORT LastIndex,
    IN BOOLEAN SkipSortCheck,
    IN BOOLEAN SkipBinCheck
    );

VOID
NtfsVerifyCachedLenRuns (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN USHORT FirstIndex,
    IN USHORT LastIndex,
    IN BOOLEAN SkipSortCheck
    );

VOID
NtfsVerifyCachedRuns (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN BOOLEAN SkipSortCheck,
    IN BOOLEAN SkipBinCheck
    );
#endif

//
//  Macros to manipulate the cached run structures.
//

//
//  VOID
//  NtfsModifyCachedBinArray (
//      IN PNTFS_CACHED_RUNS CachedRuns,
//      IN LONGLONG OldLength
//      IN LONGLONG NewLength
//      );
//

#define NtfsModifyCachedBinArray(C,OL,NL) {         \
    ASSERT( (NL) != 0 );                            \
    ASSERT( (OL) != 0 );                            \
    if ((OL) <= (C)->Bins) {                        \
        (C)->BinArray[ (OL) - 1 ] -= 1;             \
    }                                               \
    if ((NL) <= (C)->Bins) {                        \
        (C)->BinArray[ (NL) - 1 ] += 1;             \
    }                                               \
}



//
//  Some local manifest constants
//

#define BYTES_PER_PAGE                   (PAGE_SIZE)
#define BITS_PER_PAGE                    (BYTES_PER_PAGE * 8)

//
//  Local procedure prototypes for direct bitmap manipulation
//

VOID
NtfsAllocateBitmapRun (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LCN StartingLcn,
    IN LONGLONG ClusterCount,
    IN BOOLEAN FromCachedRuns
    );

VOID
NtfsFreeBitmapRun (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LCN StartingLcn,
    IN OUT PLONGLONG ClusterCount
    );

BOOLEAN
NtfsFindFreeBitmapRun (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LONGLONG NumberToFind,
    IN LCN StartingSearchHint,
    IN BOOLEAN ReturnAnyLength,
    IN BOOLEAN IgnoreMftZone,
    OUT PLCN ReturnedLcn,
    OUT PLONGLONG ClusterCountFound
    );

BOOLEAN
NtfsScanBitmapRange (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LCN StartLcn,
    IN LCN BeyondLcn,
    IN LONGLONG NumberToFind,
    OUT PLCN ReturnedLcn,
    OUT PLONGLONG ClusterCountFound
    );

BOOLEAN
NtfsAddRecentlyDeallocated (
    IN PVCB Vcb,
    IN LCN Lcn,
    IN OUT PRTL_BITMAP Bitmap
    );

//
//  The following two prototype are macros for calling map or pin data
//
//  VOID
//  NtfsMapPageInBitmap (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb,
//      IN LCN Lcn,
//      OUT PLCN StartingLcn,
//      IN OUT PRTL_BITMAP Bitmap,
//      OUT PBCB *BitmapBcb,
//      );
//
//  VOID
//  NtfsPinPageInBitmap (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb,
//      IN LCN Lcn,
//      OUT PLCN StartingLcn,
//      IN OUT PRTL_BITMAP Bitmap,
//      OUT PBCB *BitmapBcb,
//      );
//

#define NtfsMapPageInBitmap(A,B,C,D,E,F) NtfsMapOrPinPageInBitmap(A,B,C,D,E,F,FALSE)

#define NtfsPinPageInBitmap(A,B,C,D,E,F) NtfsMapOrPinPageInBitmap(A,B,C,D,E,F,TRUE)

VOID
NtfsMapOrPinPageInBitmap (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LCN Lcn,
    OUT PLCN StartingLcn,
    IN OUT PRTL_BITMAP Bitmap,
    OUT PBCB *BitmapBcb,
    IN BOOLEAN AlsoPinData
    );

//
//  Local procedure prototype for doing read ahead on our cached
//  run information
//

VOID
NtfsReadAheadCachedBitmap (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LCN StartingLcn
    );

//
//  Local procedure prototypes for routines that help us find holes
//  that need to be filled with MCBs
//

BOOLEAN
NtfsGetNextHoleToFill (
    IN PIRP_CONTEXT IrpContext,
    IN PNTFS_MCB Mcb,
    IN VCN StartingVcn,
    IN VCN EndingVcn,
    OUT PVCN VcnToFill,
    OUT PLONGLONG ClusterCountToFill,
    OUT PLCN PrecedingLcn
    );

LONGLONG
NtfsScanMcbForRealClusterCount (
    IN PIRP_CONTEXT IrpContext,
    IN PNTFS_MCB Mcb,
    IN VCN StartingVcn,
    IN VCN EndingVcn
    );

//
//  A local procedure prototype for masking out recently deallocated records
//

BOOLEAN
NtfsAddDeallocatedRecords (
    IN PVCB Vcb,
    IN PSCB Scb,
    IN ULONG StartingIndexOfBitmap,
    IN OUT PRTL_BITMAP Bitmap
    );

//
//  Local procedure prototypes for managing the Mft zone.
//

LCN
NtfsInitializeMftZone (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

BOOLEAN
NtfsReduceMftZone (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

//
//  Local procedure prototype to check the stack usage in the record
//  package.
//

VOID
NtfsCheckRecordStackUsage (
    IN PIRP_CONTEXT IrpContext
    );

//
//  Local procedure prototype to check for a continuos volume bitmap run
//

VOID
NtfsRunIsClear (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LCN StartingLcn,
    IN LONGLONG RunLength
    );

//
//  Local procedure prototypes for managing windows of deleted entries.
//

VOID
NtfsAddDelWindow (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN USHORT FirstIndex,
    IN USHORT LastIndex,
    IN BOOLEAN LcnList
    );

PNTFS_DELETED_RUNS
NtfsGetDelWindow (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN USHORT FirstIndex,
    IN USHORT LastIndex,
    IN BOOLEAN LcnList,
    OUT PUSHORT WindowIndex OPTIONAL
    );

VOID
NtfsShrinkDelWindow (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN BOOLEAN ShrinkFromStart,
    IN BOOLEAN LcnWindow,
    IN USHORT WindowIndex
    );

VOID
NtfsDeleteDelWindow (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN BOOLEAN LcnWindow,
    IN USHORT WindowIndex
    );

VOID
NtfsMakeSpaceCachedLcn (
    IN PNTFS_CACHED_RUNS CachedRuns,
    IN LCN StartingLcn,
    IN RTL_BITMAP_RUN *RunArray,
    IN ULONG RunCount,
    IN PUSHORT LcnSorted OPTIONAL
    );

//
//  Local procedure prototype for dumping cached bitmap information
//

#ifdef NTFSDBG
ULONG
NtfsDumpCachedMcbInformation (
    IN PVCB Vcb
    );

#else

#define NtfsDumpCachedMcbInformation(V) (0)

#endif // NTFSDBG

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsAddBadCluster)
#pragma alloc_text(PAGE, NtfsAddCachedRun)
#pragma alloc_text(PAGE, NtfsAddCachedRunMult)
#pragma alloc_text(PAGE, NtfsAddDeallocatedRecords)
#pragma alloc_text(PAGE, NtfsAddDelWindow)
#pragma alloc_text(PAGE, NtfsAddRecentlyDeallocated)
#pragma alloc_text(PAGE, NtfsAllocateBitmapRun)
#pragma alloc_text(PAGE, NtfsAllocateClusters)
#pragma alloc_text(PAGE, NtfsAllocateMftReservedRecord)
#pragma alloc_text(PAGE, NtfsAllocateRecord)
#pragma alloc_text(PAGE, NtfsGrowLengthInCachedLcn)
#pragma alloc_text(PAGE, NtfsShrinkLengthInCachedLcn)
#pragma alloc_text(PAGE, NtfsCheckRecordStackUsage)
#pragma alloc_text(PAGE, NtfsCleanupClusterAllocationHints)
#pragma alloc_text(PAGE, NtfsCompactCachedRuns)
#pragma alloc_text(PAGE, NtfsCreateMftHole)
#pragma alloc_text(PAGE, NtfsDeallocateClusters)
#pragma alloc_text(PAGE, NtfsDeallocateRecord)
#pragma alloc_text(PAGE, NtfsDeallocateRecordsComplete)
#pragma alloc_text(PAGE, NtfsDeleteCachedRun)
#pragma alloc_text(PAGE, NtfsDeleteDelWindow)
#pragma alloc_text(PAGE, NtfsFindFreeBitmapRun)
#pragma alloc_text(PAGE, NtfsFindMftFreeTail)
#pragma alloc_text(PAGE, NtfsFreeBitmapRun)
#pragma alloc_text(PAGE, NtfsGetCachedLengthInsertionPoint)
#pragma alloc_text(PAGE, NtfsGetDelWindow)
#pragma alloc_text(PAGE, NtfsGetNextCachedLcn)
#pragma alloc_text(PAGE, NtfsGetNextHoleToFill)
#pragma alloc_text(PAGE, NtfsGrowCachedRuns)
#pragma alloc_text(PAGE, NtfsInitializeCachedRuns)
#pragma alloc_text(PAGE, NtfsInitializeClusterAllocation)
#pragma alloc_text(PAGE, NtfsInitializeMftZone)
#pragma alloc_text(PAGE, NtfsInitializeRecordAllocation)
#pragma alloc_text(PAGE, NtfsInsertCachedLcn)
#pragma alloc_text(PAGE, NtfsInsertCachedRun)
#pragma alloc_text(PAGE, NtfsIsRecordAllocated)
#pragma alloc_text(PAGE, NtfsLookupCachedLcn)
#pragma alloc_text(PAGE, NtfsLookupCachedLcnByLength)
#pragma alloc_text(PAGE, NtfsMakeSpaceCachedLcn)
#pragma alloc_text(PAGE, NtfsMapOrPinPageInBitmap)
#pragma alloc_text(PAGE, NtfsModifyBitsInBitmap)
#pragma alloc_text(PAGE, NtfsPositionCachedLcn)
#pragma alloc_text(PAGE, NtfsPositionCachedLcnByLength)
#pragma alloc_text(PAGE, NtfsPreAllocateClusters)
#pragma alloc_text(PAGE, NtfsReadAheadCachedBitmap)
#pragma alloc_text(PAGE, NtfsReduceMftZone)
#pragma alloc_text(PAGE, NtfsReinitializeCachedRuns)
#pragma alloc_text(PAGE, NtfsRemoveCachedLcn)
#pragma alloc_text(PAGE, NtfsReserveMftRecord)
#pragma alloc_text(PAGE, NtfsRestartClearBitsInBitMap)
#pragma alloc_text(PAGE, NtfsRestartSetBitsInBitMap)
#pragma alloc_text(PAGE, NtfsRunIsClear)
#pragma alloc_text(PAGE, NtfsScanBitmapRange)
#pragma alloc_text(PAGE, NtfsScanEntireBitmap)
#pragma alloc_text(PAGE, NtfsScanMcbForRealClusterCount)
#pragma alloc_text(PAGE, NtfsScanMftBitmap)
#pragma alloc_text(PAGE, NtfsShrinkDelWindow)
#pragma alloc_text(PAGE, NtfsUninitializeCachedRuns)
#pragma alloc_text(PAGE, NtfsUninitializeRecordAllocation)

#ifdef NTFS_CHECK_CACHED_RUNS
#pragma alloc_text(PAGE, NtfsVerifyCachedLcnRuns)
#pragma alloc_text(PAGE, NtfsVerifyCachedLenRuns)
#pragma alloc_text(PAGE, NtfsVerifyCachedRuns)
#endif

#endif


VOID
NtfsInitializeClusterAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine initializes the cluster allocation structures within the
    specified Vcb.  It reads in as necessary the bitmap and scans it for
    free space and builds the free space mcb based on this scan.

    This procedure is multi-call save.  That is, it can be used to
    reinitialize the cluster allocation without first calling the
    uninitialize cluster allocation routine.

Arguments:

    Vcb - Supplies the Vcb being initialized

Return Value:

    None.

--*/

{
    LONGLONG ClusterCount;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsInitializeClusterAllocation\n") );

    NtfsAcquireExclusiveScb( IrpContext, Vcb->BitmapScb );

    try {

        //
        //  The bitmap file currently doesn't have a paging IO resource.
        //  Create one here so that we won't serialize synchronization
        //  of the bitmap package with the lazy writer.
        //

        Vcb->BitmapScb->Header.PagingIoResource =
        Vcb->BitmapScb->Fcb->PagingIoResource = NtfsAllocateEresource();

        //
        //  We didn't mark the Scb for the volume bitmap as MODIFIED_NO_WRITE
        //  when creating it.  Do so now.
        //

        SetFlag( Vcb->BitmapScb->ScbState, SCB_STATE_MODIFIED_NO_WRITE );

        //
        //  Now call a bitmap routine to scan the entire bitmap.  This
        //  routine will compute the number of free clusters in the
        //  bitmap and set the largest free runs that we find into the
        //  cached bitmap structures.
        //

        NtfsScanEntireBitmap( IrpContext, Vcb, FALSE );

        //
        //  Our last operation is to set the hint lcn which is used by
        //  our allocation routine as a hint on where to find free space.
        //  In the running system it is the last lcn that we've allocated.
        //  But for startup we'll put it to be the first free run that
        //  is stored in the free space mcb.
        //

        NtfsGetNextCachedLcn( &Vcb->CachedRuns,
                              0,
                              &Vcb->LastBitmapHint,
                              &ClusterCount );
        NtfsInitializeMftZone( IrpContext, Vcb );

    } finally {

        DebugUnwind( NtfsInitializeClusterAllocation );

        NtfsReleaseScb( IrpContext, Vcb->BitmapScb );
    }

    DebugTrace( -1, Dbg, ("NtfsInitializeClusterAllocation -> VOID\n") );

    return;
}


BOOLEAN
NtfsAllocateClusters (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN OUT PSCB Scb,
    IN VCN OriginalStartingVcn,
    IN BOOLEAN AllocateAll,
    IN LONGLONG ClusterCount,
    IN PLCN TargetLcn OPTIONAL,
    IN OUT PLONGLONG DesiredClusterCount
    )

/*++

Routine Description:

    This routine allocates disk space.  It fills in the unallocated holes in
    input mcb with allocated clusters from starting Vcn to the cluster count.

    The basic algorithm used by this procedure is as follows:

    1. Compute the EndingVcn from the StartingVcn and cluster count

    2. Compute the real number of clusters needed to allocate by scanning
       the mcb from starting to ending vcn seeing where the real holes are

    3. If the real cluster count is greater than the known free cluster count
       then the disk is full

    4. Call a routine that takes a starting Vcn, ending Vcn, and the Mcb and
       returns the first hole that needs to be filled and while there is a hole
       to be filled...

       5. Check if the run preceding the hole that we are trying to fill
          has an ending Lcn and if it does then with that Lcn see if we
          get a cache hit, if we do then allocate the cluster

       6. If we are still looking then enumerate through the cached free runs
          and if we find a suitable one.  Allocate the first suitable run we find that
          satisfies our request.  Also in the loop remember the largest
          suitable run we find.

       8. If we are still looking then bite the bullet and scan the bitmap on
          the disk for a free run using either the preceding Lcn as a hint if
          available or the stored last bitmap hint in the Vcb.

       9. At this point we've located a run of clusters to allocate.  To do the
          actual allocation we allocate the space from the bitmap, decrement
          the number of free clusters left, and update the hint.

       10. Before going back to step 4 we move the starting Vcn to be the point
           one after the run we've just allocated.

    11. With the allocation complete we update the last bitmap hint stored in
        the Vcb to be the last Lcn we've allocated, and we call a routine
        to do the read ahead in the cached bitmap at the ending lcn.

Arguments:

    Vcb - Supplies the Vcb used in this operation

    Scb - Supplies an Scb whose Mcb contains the current retrieval information
        for the file and on exit will contain the updated retrieval
        information

    StartingVcn - Supplies a starting cluster for us to begin allocation

    AllocateAll - If TRUE, allocate all the clusters here.  Don't break
        up request.

    ClusterCount - Supplies the number of clusters to allocate

    TargetLcn - If supplied allocate at this lcn rather than searching for free space
                used by the movefile defragging code

    DesiredClusterCount - Supplies the number of clusters we would like allocated
        and will allocate if it doesn't require additional runs.  On return
        this value is the number of clusters allocated.

Return Value:

    FALSE - if no clusters were allocated (they were already allocated)
    TRUE - if clusters were allocated

Important Note:

    This routine will stop after allocating MAXIMUM_RUNS_AT_ONCE runs, in order
    to limit the size of allocating transactions.  The caller must be aware that
    he may not get all of the space he asked for if the disk is real fragmented.

--*/

{
    VCN StartingVcn = OriginalStartingVcn;
    VCN EndingVcn;
    VCN DesiredEndingVcn;

    PNTFS_MCB Mcb = &Scb->Mcb;

    LONGLONG RemainingDesiredClusterCount;

    VCN VcnToFill;
    LONGLONG ClusterCountToFill;
    LCN PrecedingLcn;

    BOOLEAN FoundClustersToAllocate;
    LCN FoundLcn;
    LONGLONG FoundClusterCount;
    LONGLONG LargestBitmapClusterCount = 0;
    BOOLEAN FromCachedRuns;

    USHORT RunIndex;

    LCN HintLcn;

    ULONG LoopCount = 0;
    ULONG RunCount = 0;

    BOOLEAN ClustersAllocated = FALSE;
    BOOLEAN GotAHoleToFill = TRUE;
    BOOLEAN FoundRun = FALSE;
    BOOLEAN ExtendingMft = FALSE;
    BOOLEAN AllocateFromBitmap = FALSE;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsAllocateClusters\n") );
    DebugTrace( 0, Dbg, ("StartVcn            = %0I64x\n", StartingVcn) );
    DebugTrace( 0, Dbg, ("ClusterCount        = %0I64x\n", ClusterCount) );
    DebugTrace( 0, Dbg, ("DesiredClusterCount = %0I64x\n", *DesiredClusterCount) );

    NtfsAcquireExclusiveScb( IrpContext, Vcb->BitmapScb );

    try {

        if (FlagOn( Vcb->VcbState, VCB_STATE_RELOAD_FREE_CLUSTERS )) {

            NtfsScanEntireBitmap( IrpContext, Vcb, FALSE );
        }

        //
        //  Check to see if we are defragmenting
        //

        if (ARGUMENT_PRESENT( TargetLcn )) {

            FoundLcn = *TargetLcn;

            //
            //  Ensure that the run is NOT already allocated
            //

            NtfsRunIsClear( IrpContext, Vcb, FoundLcn, ClusterCount );

            //
            //  Get the allocation data from the Scb
            //

            VcnToFill = OriginalStartingVcn;
            FoundClusterCount = ClusterCount;
            *DesiredClusterCount = ClusterCount;

            GotAHoleToFill = FALSE;
            ClustersAllocated = TRUE;
            FoundRun = TRUE;
            FromCachedRuns = FALSE;

            //
            //  Initialize PrecedingLcn in this case to skip any special action.
            //

            PrecedingLcn = 0;

            //
            //  We already have the allocation so skip over the allocation section
            //

            goto Defragment;
        }

        //
        //  Compute the ending vcn, and the cluster count of how much we really
        //  need to allocate (based on what is already allocated).  Then check if we
        //  have space on the disk.
        //

        EndingVcn = (StartingVcn + ClusterCount) - 1;

        ClusterCount = NtfsScanMcbForRealClusterCount( IrpContext, Mcb, StartingVcn, EndingVcn );

        if ((ClusterCount + IrpContext->DeallocatedClusters) > Vcb->FreeClusters) {

            NtfsRaiseStatus( IrpContext, STATUS_DISK_FULL, NULL, NULL );
        }

        //
        //  Let's see if it is ok to allocate clusters for this Scb now,
        //  in case compressed files have over-reserved the space.  This
        //  calculation is done in such a way as to guarantee we do not
        //  have either of the terms subtracting through zero, even if
        //  we were to over-reserve the free space on the disk due to a
        //  hot fix or something.  Always satisfy this request if we are
        //  in the paging IO write path because we know we are using clusters
        //  already reserved for this stream.
        //

        NtfsAcquireReservedClusters( Vcb );

        //
        //  Do the fast test to see if there is even a chance of failing the reservation test
        //  or if we will allocate this space anyway.
        //  If there is no Irp or this is the Usn journal then allocate the space anyway.
        //

        if ((ClusterCount + Vcb->TotalReserved > Vcb->FreeClusters) &&
#ifdef BRIANDBG
            !NtfsIgnoreReserved &&
#endif
            (IrpContext->OriginatingIrp != NULL) &&
            !FlagOn( Scb->Fcb->FcbState, FCB_STATE_USN_JOURNAL )) {

            //
            //  If this is not a write then fail this unless this is an fsctl which
            //  may have reserved space.
            //

            if (IrpContext->MajorFunction != IRP_MJ_WRITE) {

                //
                //  If this is an Fsctl for a data file then account for the reservation.
                //  All other non-writes will fail because we already checked whether
                //  they conflicted with the volume reservation.
                //

                if ((IrpContext->MajorFunction != IRP_MJ_FILE_SYSTEM_CONTROL) ||
                    (Scb->Header.NodeTypeCode != NTFS_NTC_SCB_DATA) ||
                    (ClusterCount + Vcb->TotalReserved - LlClustersFromBytesTruncate( Vcb, Scb->ScbType.Data.TotalReserved ) > Vcb->FreeClusters)) {

                    NtfsReleaseReservedClusters( Vcb );
                    NtfsRaiseStatus( IrpContext, STATUS_DISK_FULL, NULL, NULL );
                }

            //
            //  If we are in user write path then check the reservation.  Otherwise
            //  satisfy the request.  It will be some other stream which supports the
            //  write (i.e. Mft record for a secondary file record).
            //

            } else if ((Scb->Header.NodeTypeCode == NTFS_NTC_SCB_DATA) &&
                       !FlagOn( IrpContext->OriginatingIrp->Flags, IRP_PAGING_IO ) &&
                       (ClusterCount + Vcb->TotalReserved - LlClustersFromBytesTruncate( Vcb, Scb->ScbType.Data.TotalReserved ) > Vcb->FreeClusters)) {

                NtfsReleaseReservedClusters( Vcb );
                NtfsRaiseStatus( IrpContext, STATUS_DISK_FULL, NULL, NULL );
            }
        }

        NtfsReleaseReservedClusters( Vcb );

        //
        //  We need to check that the request won't fail because of clusters
        //  in the recently deallocated lists.
        //

        if (Vcb->FreeClusters < (Vcb->DeallocatedClusters + ClusterCount)) {

#ifdef PERF_STATS
            IrpContext->LogFullReason = LF_DEALLOCATED_CLUSTERS;
#endif

            NtfsRaiseStatus( IrpContext, STATUS_LOG_FILE_FULL, NULL, NULL );
        }

        //
        //  Remember if we are extending the Mft.
        //

        if ((Scb == Vcb->MftScb) &&
            (LlBytesFromClusters( Vcb, StartingVcn ) == (ULONGLONG) Scb->Header.AllocationSize.QuadPart)) {

            ExtendingMft = TRUE;
        }

        //
        //  Now compute the desired ending vcn and the real desired cluster count
        //

        DesiredEndingVcn = (StartingVcn + *DesiredClusterCount) - 1;
        RemainingDesiredClusterCount = NtfsScanMcbForRealClusterCount( IrpContext, Mcb, StartingVcn, DesiredEndingVcn );

        //
        //  While there are holes to fill we will do the following loop
        //

        while ((AllocateAll || (LoopCount < MAXIMUM_RUNS_AT_ONCE))

                &&

               (GotAHoleToFill = NtfsGetNextHoleToFill( IrpContext,
                                                        Mcb,
                                                        StartingVcn,
                                                        DesiredEndingVcn,
                                                        &VcnToFill,
                                                        &ClusterCountToFill,
                                                        &PrecedingLcn))) {

            //
            //  Assume we will find this in the cached runs array.
            //

            FromCachedRuns = TRUE;

            //
            //  If this is our first time through the loop then record out bitmap stats
            //  then always bump up the run count stat.
            //

            if (!ClustersAllocated) {

                CollectAllocateClusterStats( Vcb,
                                             RemainingDesiredClusterCount,
                                             PrecedingLcn != UNUSED_LCN );
            }

            IncrementAllocateClusterStats( Vcb );

            //
            //  First indicate that we haven't found anything suitable yet
            //

            FoundClustersToAllocate = FALSE;

            //
            //  Remember that we are will be allocating clusters.
            //

            ClustersAllocated = TRUE;

            //
            //  Initialize HintLcn to a value that sorts lower than any other
            //  Lcn.  If we have no PrecedingLcn to use as a hint, the
            //  allocation will preferentially use an Lcn that is as small
            //  as possible for the desired cluster count.  This will left
            //  pack things as much as possible.
            //

            HintLcn = UNUSED_LCN;

            //
            //  Check if the preceding lcn is anything other than -1 then with
            //  that as a hint check if we have a cache hit on a free run
            //

            if (PrecedingLcn != UNUSED_LCN) {

                if (NtfsLookupCachedLcn( &Vcb->CachedRuns,
                                         PrecedingLcn + 1,
                                         &FoundLcn,
                                         &FoundClusterCount,
                                         NULL )) {

                    //
                    //  Increment the stats and say we've found something to allocate
                    //

                    IncrementHintHonoredStats( Vcb, MIN3(FoundClusterCount, RemainingDesiredClusterCount, ClusterCountToFill));

#ifdef NTFS_FRAGMENT_DISK
                    if (NtfsFragmentMft &&
                        (Scb == Vcb->MftScb) &&
                        (FoundClusterCount > 1)) {

                        FoundLcn += 1;
                        FoundClusterCount -= 1;
                    }
#endif

                    if ((Scb->AttributeTypeCode == $INDEX_ALLOCATION) &&
                        (FoundClusterCount * Vcb->BytesPerCluster < Scb->ScbType.Index.BytesPerIndexBuffer)) {
                    } else {
                        FoundClustersToAllocate = TRUE;
                    }
                }

                if (!FoundClustersToAllocate && !ExtendingMft ) {

                    //
                    //  Set up the hint LCN for the lookup by length
                    //  call below.
                    //

                    HintLcn = PrecedingLcn + 1;
                }
            }

            //
            //  If we are still looking to allocate something then hit the cache.
            //  Skip this for the Mft zone as we are willing to go to disk for it.
            //

            while (!FoundClustersToAllocate &&
                   !ExtendingMft &&
                    NtfsLookupCachedLcnByLength( &Vcb->CachedRuns,
                                                 RemainingDesiredClusterCount,
                                                 (BOOLEAN)(Scb->AttributeTypeCode != $INDEX_ALLOCATION),
                                                 HintLcn,
                                                 &FoundLcn,
                                                 &FoundClusterCount,
                                                 &RunIndex )) {

                if ((FoundLcn < Vcb->MftZoneEnd) &&
                    ((FoundLcn + FoundClusterCount) > Vcb->MftZoneStart)) {

                    //
                    //  This run overlaps the Mft zone.  Remove the zone from
                    //  the cache.
                    //

                    NtfsRemoveCachedLcn( &Vcb->CachedRuns,
                                         Vcb->MftZoneStart,
                                         Vcb->MftZoneEnd - Vcb->MftZoneStart );
                    //
                    //  Retry the lookup.
                    //

                    continue;
                }

                //
                //  This run will do.
                //

                FoundClustersToAllocate = TRUE;
            }

            //
            //  this code tries to prevent the paging file allocations
            //  from becoming fragmented.
            //
            //  if the clusters we just found are smaller than half
            //  the of the remaining cluster to allocate then we force
            //  a look at the bitmap.
            //

            if (FlagOn( Scb->Fcb->FcbState, FCB_STATE_PAGING_FILE ) &&
                FoundClustersToAllocate &&
                FoundClusterCount < (RemainingDesiredClusterCount >> 1)) {

                if (LargestBitmapClusterCount > 0) {
                    if (LargestBitmapClusterCount >= RemainingDesiredClusterCount) {
                        FoundClustersToAllocate = FALSE;
                    }
                } else {
                    FoundClustersToAllocate = FALSE;
                }
            }

            //
            //  Check if we've allocated from our cache and increment the stats
            //

            if (FoundClustersToAllocate) {

                IncrementCacheHitStats( Vcb,
                                        MIN3( FoundClusterCount,
                                              RemainingDesiredClusterCount,
                                              ClusterCountToFill ));

            //
            //  We've done everything we can with the cached bitmap information so
            //  now bite the bullet and scan the bitmap for a free cluster.  If
            //  we have an hint lcn then use it otherwise use the hint stored in the
            //  vcb.  But never use a hint that is part of the mft zone, and because
            //  the mft always has a preceding lcn we know we'll hint in the zone
            //  for the mft.
            //

            } else {

                BOOLEAN AllocatedFromZone;
                BOOLEAN ReturnAnyLength;

                //
                //  The clusters aren't coming from the cached runs array.
                //

                FromCachedRuns = FALSE;

                //
                //  First check if we have already satisfied the core requirements
                //  and are now just going for the desired ending vcn.  If so then
                //  we will not waste time hitting the disk
                //

                if (StartingVcn > EndingVcn) {

                    //
                    //  Set the loop count to MAXIMUM_RUNS_AT_ONCE to indicate we bailed early
                    //  without finding all of the requested clusters.
                    //

                    LoopCount = MAXIMUM_RUNS_AT_ONCE;
                    break;
                }

                if (PrecedingLcn != UNUSED_LCN) {

                    HintLcn = PrecedingLcn + 1;
                    ReturnAnyLength = TRUE;

                } else {

                    //
                    //  We shouldn't be here if we are extending the Mft.
                    //

                    ASSERT( !ExtendingMft );

                    HintLcn = Vcb->LastBitmapHint;
                    ReturnAnyLength = FALSE;

                    if ((HintLcn >= Vcb->MftZoneStart) &&
                        (HintLcn < Vcb->MftZoneEnd)) {

                        HintLcn = Vcb->MftZoneEnd;
                    }
                }

                AllocatedFromZone = NtfsFindFreeBitmapRun( IrpContext,
                                                           Vcb,
                                                           ClusterCountToFill,
                                                           HintLcn,
                                                           ReturnAnyLength,
                                                           ExtendingMft,
                                                           &FoundLcn,
                                                           &FoundClusterCount );

                if (LargestBitmapClusterCount == 0) {

                    //
                    //  remember the first cluster count that we get from
                    //  the bitmap as this will be the largest.  this is used
                    //  to optimize the pagefile case.
                    //

                    LargestBitmapClusterCount = FoundClusterCount;
                }

                AllocateFromBitmap = TRUE;

                IncrementCacheMissStats(Vcb, MIN3(FoundClusterCount, RemainingDesiredClusterCount, ClusterCountToFill));

                if (FoundClusterCount == 0) {

                    NtfsRaiseStatus( IrpContext, STATUS_DISK_FULL, NULL, NULL );
                }

                //
                //  Check if we need to reduce the zone.
                //

                if (!ExtendingMft) {

                    if (AllocatedFromZone) {

                        //
                        //  If there is space to reduce the zone then do so now
                        //  and rescan the bitmap.
                        //

                        if (NtfsReduceMftZone( IrpContext, Vcb )) {

                            FoundClusterCount = 0;

                            NtfsFindFreeBitmapRun( IrpContext,
                                                   Vcb,
                                                   ClusterCountToFill,
                                                   Vcb->MftZoneEnd,
                                                   FALSE,
                                                   FALSE,
                                                   &FoundLcn,
                                                   &FoundClusterCount );

                            if (FoundClusterCount == 0) {

                                NtfsRaiseStatus( IrpContext, STATUS_DISK_FULL, NULL, NULL );
                            }
                        }
                    }

                //
                //  We are extending the Mft.  If we didn't get a contiguous run then
                //  set up a new zone.
                //

                } else if (PrecedingLcn + 1 != FoundLcn) {

                    NtfsScanEntireBitmap( IrpContext, Vcb, TRUE );

                    ASSERT( Vcb->CachedRuns.Used != 0 );

                    FoundLcn = NtfsInitializeMftZone( IrpContext, Vcb );

                    NtfsFindFreeBitmapRun( IrpContext,
                                           Vcb,
                                           ClusterCountToFill,
                                           FoundLcn,
                                           TRUE,
                                           TRUE,
                                           &FoundLcn,
                                           &FoundClusterCount );
                }
            }

            //
            //  At this point we have found a run to allocate denoted by the
            //  values in FoundLcn and FoundClusterCount.  We need to trim back
            //  the cluster count to be the amount we really need and then
            //  do the allocation.  To do the allocation we zap the bitmap,
            //  decrement the free count, and add the run to the mcb we're
            //  using
            //

#ifdef NTFS_FRAGMENT_DISK
            if (NtfsFragmentDisk && ((ULONG) FoundClusterCount > NtfsFragmentLength)) {

                FoundLcn += 1;
                FoundClusterCount = NtfsFragmentLength;

            } else if (NtfsFragmentMft &&
                       (Scb == Vcb->MftScb) &&
                       (FoundClusterCount > NtfsFragmentLength)) {

                FoundLcn += 1;
                FoundClusterCount = NtfsFragmentLength;
            }
#endif

            if (FoundClusterCount > RemainingDesiredClusterCount) {

                FoundClusterCount = RemainingDesiredClusterCount;
            }

            if (FoundClusterCount > ClusterCountToFill) {

                FoundClusterCount = ClusterCountToFill;
            }

            ASSERT( Vcb->FreeClusters >= FoundClusterCount );

            SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_MODIFIED_BITMAP );

Defragment:

            NtfsAllocateBitmapRun( IrpContext, Vcb, FoundLcn, FoundClusterCount, FromCachedRuns );

            //
            //  Modify the total allocated for this file.
            //

            NtfsAcquireReservedClusters( Vcb );
            Scb->TotalAllocated += (LlBytesFromClusters( Vcb, FoundClusterCount ));
            NtfsReleaseReservedClusters( Vcb );

            //
            //  Adjust the count of free clusters.  Only store the change in
            //  the top level irp context in case of aborts.
            //

            Vcb->FreeClusters -= FoundClusterCount;

            IrpContext->FreeClusterChange -= FoundClusterCount;

            ASSERT_LCN_RANGE_CHECKING( Vcb, (FoundLcn + FoundClusterCount) );

            ASSERT( FoundClusterCount != 0 );

            NtfsAddNtfsMcbEntry( Mcb, VcnToFill, FoundLcn, FoundClusterCount, FALSE );

            //
            //  If this is the Mft file then put these into our AddedClusters Mcb
            //  as well.
            //

            if (Mcb == &Vcb->MftScb->Mcb) {

                FsRtlAddLargeMcbEntry( &Vcb->MftScb->ScbType.Mft.AddedClusters,
                                       VcnToFill,
                                       FoundLcn,
                                       FoundClusterCount );
            }

            //
            //  And update the last bitmap hint, but only if we used the hint to begin with
            //

            if (PrecedingLcn == UNUSED_LCN) {

                Vcb->LastBitmapHint = FoundLcn;
            }

            //
            //  Now move the starting Vcn to the Vcn that we've just filled plus the
            //  found cluster count
            //

            StartingVcn = VcnToFill + FoundClusterCount;

            LoopCount += 1;

            RunCount += 1;

            if (FoundRun == TRUE) {

                break;
            }

            //
            //  Decrement the remaining desired cluster count by the amount we just allocated
            //

            RemainingDesiredClusterCount = RemainingDesiredClusterCount - FoundClusterCount;
        }

        //
        //  Now we need to compute the total cluster that we've just allocated
        //  We'll call get next hole to fill.  If the result is false then we
        //  allocated everything.  If the result is true then we do some quick
        //  math to get the size allocated
        //

        if (GotAHoleToFill && NtfsGetNextHoleToFill( IrpContext,
                                                     Mcb,
                                                     OriginalStartingVcn,
                                                     DesiredEndingVcn,
                                                     &VcnToFill,
                                                     &ClusterCountToFill,
                                                     &PrecedingLcn)) {

            //
            //  If this is a sparse file and we didn't get all that we asked for
            //  then trim the allocation back to a compression boundary.
            //

            if ((LoopCount >= MAXIMUM_RUNS_AT_ONCE) &&
                !AllocateAll &&
                (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE ) == ATTRIBUTE_FLAG_SPARSE )) {

                ULONG ClustersPerCompressionMask;

                ClustersPerCompressionMask = (1 << Scb->CompressionUnitShift) - 1;

                //
                //  We should end on a compression unit boundary.
                //

                if ((ULONG) VcnToFill & ClustersPerCompressionMask) {

                    //
                    //  Back up to a compression unit boundary.
                    //

                    StartingVcn = VcnToFill & ~((LONGLONG) ClustersPerCompressionMask);

                    ASSERT( StartingVcn > OriginalStartingVcn );

                    NtfsDeallocateClusters( IrpContext,
                                            Vcb,
                                            Scb,
                                            StartingVcn,
                                            VcnToFill - 1,
                                            &Scb->TotalAllocated );

                    //
                    //  We don't want these clusters to be reflected in the clusters
                    //  deallocated for this transaction.  Otherwise our caller may
                    //  assume he can get them with a log file full.
                    //

                    IrpContext->DeallocatedClusters -= (VcnToFill - StartingVcn);
                    VcnToFill = StartingVcn;
                }
            }

            *DesiredClusterCount = VcnToFill - OriginalStartingVcn;
        }

        //
        //  At this point we've allocated everything we were asked to do
        //  so now call a routine to read ahead into our cache the disk
        //  information at the last lcn we allocated.  But only do the readahead
        //  if we allocated clusters and we couldn't satisfy the request in one
        //  run.
        //

        if (ClustersAllocated &&
            ((RunCount > 1) || AllocateFromBitmap) &&
            (FoundLcn + FoundClusterCount < Vcb->TotalClusters)) {

            NtfsReadAheadCachedBitmap( IrpContext, Vcb, FoundLcn + FoundClusterCount );
        }

    } finally {

        DebugUnwind( NtfsAllocateClusters );

        DebugTrace( 0, Dbg, ("%d\n", NtfsDumpCachedMcbInformation(Vcb)) );

        NtfsReleaseScb(IrpContext, Vcb->BitmapScb);
    }

    DebugTrace( -1, Dbg, ("NtfsAllocateClusters -> %08lx\n", ClustersAllocated) );

    return ClustersAllocated;
}


VOID
NtfsAddBadCluster (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LCN Lcn
    )

/*++

Routine Description:

    This routine helps append a bad cluster to the bad cluster file.
    It marks it as allocated in the volume bitmap and also adds
    the Lcn to the MCB for the bad cluster file.

Arguments:

    Vcb - Supplies the Vcb used in this operation

    Lcn - Supplies the Lcn of the new bad cluster

Return:

    None.

--*/

{
    PNTFS_MCB Mcb;
    LONGLONG FoundLcn;
    LONGLONG FoundClusters;
    PDEALLOCATED_CLUSTERS Clusters;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsAddBadCluster\n") );
    DebugTrace( 0, Dbg, ("Lcn = %0I64x\n", Lcn) );

    //
    //  Reference the bad cluster mcb and grab exclusive access to the
    //  bitmap scb
    //

    Mcb = &Vcb->BadClusterFileScb->Mcb;

    NtfsAcquireExclusiveScb( IrpContext, Vcb->BitmapScb );

    try {

        //
        //  We are given the bad Lcn so all we need to do is
        //  allocate it in the bitmap, and take care of some
        //  bookkeeping
        //

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_MODIFIED_BITMAP );

        NtfsAllocateBitmapRun( IrpContext, Vcb, Lcn, 1, FALSE );

        //
        //  Go ahead and remove this cluster from the recently deallocated arrays.
        //  We don't want to give this back to the bitmap package.
        //
        //  Best odds are that these are in the active deallocated clusters.
        //

        Clusters = (PDEALLOCATED_CLUSTERS)Vcb->DeallocatedClusterListHead.Flink;
        do {

            if (FsRtlLookupLargeMcbEntry( &Clusters->Mcb,
                                          Lcn,
                                          &FoundLcn,
                                          &FoundClusters,
                                          NULL,
                                          NULL,
                                          NULL ) &&
                (FoundLcn != UNUSED_LCN)) {

                FsRtlRemoveLargeMcbEntry( &Clusters->Mcb,
                                          Lcn,
                                          1 );

                //
                //  Removing one from Dealloc and Vcb.  Operation above
                //  could fail leaving entry in Deallocated cluster.  OK because the
                //  entry is still deallocated this operation will abort.
                //

                Clusters->ClusterCount -= 1;
                Vcb->DeallocatedClusters -= 1;
                break;
            }

            Clusters = (PDEALLOCATED_CLUSTERS)Clusters->Link.Flink;
        } while ( &Clusters->Link != &Vcb->DeallocatedClusterListHead );



        Vcb->FreeClusters -= 1;
        IrpContext->FreeClusterChange -= 1;

        ASSERT_LCN_RANGE_CHECKING( Vcb, (Lcn + 1) );

        //
        //  Vcn == Lcn in the bad cluster file.
        //

        NtfsAddNtfsMcbEntry( Mcb, Lcn, Lcn, (LONGLONG)1, FALSE );

    } finally {

        DebugUnwind( NtfsAddBadCluster );

        NtfsReleaseScb(IrpContext, Vcb->BitmapScb);
    }

    DebugTrace( -1, Dbg, ("NtfsAddBadCluster -> VOID\n") );

    return;
}


BOOLEAN
NtfsDeallocateClusters (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PSCB Scb,
    IN VCN StartingVcn,
    IN VCN EndingVcn,
    OUT PLONGLONG TotalAllocated OPTIONAL
    )

/*++

Routine Description:

    This routine deallocates (i.e., frees) disk space.  It free any clusters that
    are specified as allocated in the input mcb with the specified range of starting
    vcn to ending vcn inclusive.

    The basic algorithm used by this procedure is as follows:

    1. With a Vcn value beginning at starting vcn and progressing to ending vcn
       do the following steps...

       2. Lookup the Mcb entry at the vcn this will yield an lcn and a cluster count
          if the entry exists (even if it is a hole).  If the entry does not exist
          then we are completely done because we have run off the end of allocation.

       3. If the entry is a hole (i.e., Lcn == -1) then add the cluster count to
          Vcn and go back to step 1.

       4. At this point we have a real run of clusters that need to be deallocated but
          the cluster count might put us over the ending vcn so adjust the cluster
          count to keep us within the ending vcn.

       5. Now deallocate the clusters from the bitmap, and increment the free cluster
          count stored in the vcb.

       6. Add (i.e., change) any cached bitmap information concerning this run to indicate
          that it is now free.

       7. Remove the run from the mcb.

       8. Add the cluster count that we've just freed to Vcn and go back to step 1.

Arguments:

    Vcb - Supplies the vcb used in this operation

    Mcb - Supplies the mcb describing the runs to be deallocated

    StartingVcn - Supplies the vcn to start deallocating at in the input mcb

    EndingVcn - Supplies the vcn to end deallocating at in the input mcb

    TotalAllocated - If specified we will modifify the total allocated clusters
        for this file.

Return Value:

    FALSE - if nothing was deallocated.
    TRUE - if some space was deallocated.

--*/

{
    VCN Vcn;
    LCN Lcn;
    LONGLONG ClusterCount;
    LONGLONG ClustersRemoved = 0;
    BOOLEAN ClustersDeallocated = FALSE;
    LCN LastLcnAdded;
    BOOLEAN RaiseLogFull;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsDeallocateClusters\n") );
    DebugTrace( 0, Dbg, ("StartingVcn = %016I64x\n", StartingVcn) );
    DebugTrace( 0, Dbg, ("EndingVcn   = %016I64\n", EndingVcn) );

    NtfsAcquireExclusiveScb( IrpContext, Vcb->BitmapScb );

    try {

        if (FlagOn( Vcb->VcbState, VCB_STATE_RELOAD_FREE_CLUSTERS )) {

            NtfsScanEntireBitmap( IrpContext, Vcb, FALSE );
        }

        //
        //  The following loop scans through the mcb from starting vcn to ending vcn
        //  with a step of cluster count.
        //

        for (Vcn = StartingVcn; Vcn <= EndingVcn; Vcn = Vcn + ClusterCount) {

            //
            //  Get the run information from the Mcb, and if this Vcn isn't specified
            //  in the mcb then return now to our caller
            //

            if (!NtfsLookupNtfsMcbEntry( &Scb->Mcb, Vcn, &Lcn, &ClusterCount, NULL, NULL, NULL, NULL )) {
                
                leave;
            }

            //
            //  Make sure that the run we just looked up is not a hole otherwise
            //  if it is a hole we'll just continue with out loop continue with our
            //  loop
            //

            if (Lcn != UNUSED_LCN) {

                PDEALLOCATED_CLUSTERS CurrentClusters;

                ASSERT_LCN_RANGE_CHECKING( Vcb, (Lcn + ClusterCount) );

                //
                //  Now we have a real run to deallocate, but it might be too large
                //  to check for that the vcn plus cluster count must be less than
                //  or equal to the ending vcn plus 1.
                //

                if ((Vcn + ClusterCount) > EndingVcn) {

                    ClusterCount = (EndingVcn - Vcn) + 1;
                }

                //
                //  And to hold us off from reallocating the clusters right away we'll
                //  add this run to the recently deallocated mcb in the vcb.  If this fails
                //  because we are growing the mapping then change the code to
                //  LOG_FILE_FULL to empty the mcb.
                //

                RaiseLogFull = FALSE;

                try {

                    CurrentClusters = NtfsGetDeallocatedClusters( IrpContext, Vcb );
                    FsRtlAddLargeMcbEntry( &CurrentClusters->Mcb,
                                           Lcn,
                                           Lcn,
                                           ClusterCount );

                } except ((GetExceptionCode() == STATUS_INSUFFICIENT_RESOURCES) ?
                          EXCEPTION_EXECUTE_HANDLER :
                          EXCEPTION_CONTINUE_SEARCH) {

                    RaiseLogFull = TRUE;
                }

                if (RaiseLogFull) {

#ifdef PERF_STATS
                    IrpContext->LogFullReason = LF_DEALLOCATED_CLUSTERS_MEM;
#endif
                    NtfsRaiseStatus( IrpContext, STATUS_LOG_FILE_FULL, NULL, NULL );
                }

                //
                //  Correct here because we increment only if successfully
                //  adding the clusters.  It is also added to dealloc and Vcb together.
                //

                CurrentClusters->ClusterCount += ClusterCount;

                Vcb->DeallocatedClusters += ClusterCount;
                IrpContext->DeallocatedClusters += ClusterCount;

                ClustersRemoved = ClusterCount;
                LastLcnAdded = Lcn + ClusterCount;

                //
                //  Now zap the bitmap, increment the free cluster count, and change
                //  the cached information on this run to indicate that it is now free
                //

                SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_MODIFIED_BITMAP );

                NtfsFreeBitmapRun( IrpContext, Vcb, Lcn, &ClustersRemoved);
                ASSERT( ClustersRemoved == 0 );
                ClustersDeallocated = TRUE;

                //
                //  Reserve newly freed clusters if necc. to maintain balance for
                //  mapped data files
                //

                if (($DATA == Scb->AttributeTypeCode) &&
                    (Scb->CompressionUnit != 0) &&
                    FlagOn( Scb->Header.Flags, FSRTL_FLAG_USER_MAPPED_FILE )) {

                    LONGLONG FileOffset;
                    ULONG ByteCount;
                    LONGLONG TempL;

                    TempL= NtfsCalculateNeededReservedSpace( Scb );

                    if (Scb->ScbType.Data.TotalReserved <= TempL) {

                        FileOffset = LlBytesFromClusters( Vcb, Vcn );
                        ByteCount =  BytesFromClusters( Vcb, ClusterCount );

                        //
                        //  If we're deallocating beyond allocation size as a result of DeallocateInternal
                        //  optimization (split and remove at back) compensate.
                        //

                        if (FileOffset >= Scb->Header.AllocationSize.QuadPart ) {
                            FileOffset = Scb->Header.AllocationSize.QuadPart - ByteCount;
                        }

                        //
                        //  Round attempted reservation down to needed amount if its larger
                        //

                        if (ByteCount > TempL - Scb->ScbType.Data.TotalReserved) {
                            ByteCount = (ULONG)(TempL - Scb->ScbType.Data.TotalReserved);
                        }

                        NtfsReserveClusters( IrpContext, Scb, FileOffset, ByteCount );
                    }
                }

                //
                //  Adjust the count of free clusters and adjust the IrpContext
                //  field for the change this transaction.
                //

                Vcb->FreeClusters += ClusterCount;

                //
                //  If we had shrunk the Mft zone and there is at least 1/16
                //  of the volume now available, then grow the zone back.
                //  Acquire MftScb so we can can manipulate its mcb. Use ex routines so we
                //  always drop it at the end in the finally clause. If we can't get it
                //  we'll just skip resizing the zone
                //

                if (FlagOn( Vcb->VcbState, VCB_STATE_REDUCED_MFT ) &&
                    (Int64ShraMod32( Vcb->TotalClusters, 4 ) < Vcb->FreeClusters)) {

                    if (NtfsAcquireResourceExclusive( IrpContext, Vcb->MftScb, FALSE )) {

                        try {
                            NtfsScanEntireBitmap( IrpContext, Vcb, TRUE );
                            NtfsInitializeMftZone( IrpContext, Vcb );
                        } finally {
                            NtfsReleaseResource( IrpContext, Vcb->MftScb );
                        }
                    }
                }

                IrpContext->FreeClusterChange += ClusterCount;

                //
                //  Modify the total allocated amount if the pointer is specified.
                //

                if (ARGUMENT_PRESENT( TotalAllocated )) {

                    NtfsAcquireReservedClusters( Vcb );
                    *TotalAllocated -= (LlBytesFromClusters( Vcb, ClusterCount ));

                    if (*TotalAllocated < 0) {

                        *TotalAllocated = 0;
                    }
                    NtfsReleaseReservedClusters( Vcb );
                }

                //
                //  Now remove this entry from the mcb and go back to the top of the
                //  loop
                //

                NtfsRemoveNtfsMcbEntry( &Scb->Mcb, Vcn, ClusterCount );

                //
                //  If this is the Mcb for the Mft file then remember this in the
                //  RemovedClusters Mcb.
                //

                if (&Scb->Mcb == &Vcb->MftScb->Mcb) {

                    FsRtlAddLargeMcbEntry( &Vcb->MftScb->ScbType.Mft.RemovedClusters,
                                           Vcn,
                                           Lcn,
                                           ClusterCount );
                }
            }
        }

    } finally {

        DebugUnwind( NtfsDeallocateClusters );

        DebugTrace( 0, Dbg, ("%d\n", NtfsDumpCachedMcbInformation(Vcb)) );

        //
        //  Remove the entries from the recently deallocated entries
        //  if we didn't modify the bitmap.  ClustersRemoved contains
        //  the number we didn't insert in the last attempt to free bits
        //  in the bitmap.
        //

        if (ClustersRemoved != 0) {

            PDEALLOCATED_CLUSTERS Clusters = (PDEALLOCATED_CLUSTERS) Vcb->DeallocatedClusterListHead.Flink;

            FsRtlRemoveLargeMcbEntry( &Clusters->Mcb,
                                      LastLcnAdded - ClustersRemoved,
                                      ClustersRemoved );

            //
            //  This should be OK. We are backing out an insert above.
            //  Whatever space needed should be present because we are reverting to
            //  a known state.
            //

            Clusters->ClusterCount -= ClustersRemoved;
            Vcb->DeallocatedClusters -= ClustersRemoved;
        }

        NtfsReleaseScb( IrpContext, Vcb->BitmapScb );
    }

    DebugTrace( -1, Dbg, ("NtfsDeallocateClusters -> %02lx\n", ClustersDeallocated) );

    return ClustersDeallocated;
}

VOID
NtfsPreAllocateClusters (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LCN StartingLcn,
    IN LONGLONG ClusterCount,
    OUT PBOOLEAN AcquiredBitmap,
    OUT PBOOLEAN AcquiredMft
    )

/*++

Routine Description:

    This routine pre-allocates clusters in the bitmap within the specified range.
    All changes are made only in memory and neither logged nor written to disk.
    We allow  exceptions to flow out possibly with all the files acquired. At the end we hold
    the bitmap and mft exclusive to mark the reservation if we succeed

Arguments:

    Vcb - Supplies the vcb used in this operation

    StartingLcn - Supplies the starting Lcn index within the bitmap to
        start allocating (i.e., setting to 1).

    ClusterCount - Supplies the number of bits to set to 1 within the bitmap.

    AcquiredBitmap - set to true if we leave with bitmap acquired

    AcquiredMft - set to true if we leave with the mft acquired


Return Value:

    None.

--*/

{
    PAGED_CODE()

    NtfsAcquireExclusiveScb( IrpContext, Vcb->MftScb );
    *AcquiredMft = TRUE;

    NtfsAcquireExclusiveScb( IrpContext, Vcb->BitmapScb );
    *AcquiredBitmap = TRUE;

    NtfsRunIsClear( IrpContext, Vcb, StartingLcn, ClusterCount );
}


VOID
NtfsScanEntireBitmap (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LOGICAL CachedRunsOnly
    )

/*++

Routine Description:

    This routine scans in the entire bitmap,  It computes the number of free clusters
    available, and at the same time remembers the largest free runs that it
    then inserts into the cached bitmap structure.

Arguments:

    Vcb - Supplies the vcb used by this operation

    CachedRunsOnly - Indicates that we only want to look for the longest runs.

Return Value:

    None.

--*/

{
    LCN Lcn;

    RTL_BITMAP Bitmap;
    PBCB BitmapBcb;

    BOOLEAN StuffAdded = FALSE;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsScanEntireBitmap\n") );

    BitmapBcb = NULL;

    try {

        //
        //  If we are only reloading cached runs then check if there is any real work to do.
        //  We don't want to constantly rescan the bitmap if we are growing the Mft and never
        //  have any suitable runs available.
        //

        if (CachedRunsOnly) {

            USHORT RunIndex;
            BOOLEAN FoundRun;

            //
            //  If there hasn't been a lot of activity freeing clusters then
            //  don't do this work unless the cached run structure is empty.
            //

            if (Vcb->ClustersRecentlyFreed < BITMAP_VOLATILE_FREE_COUNT) {

                //
                //  Determine if there is a cached run that is at least as
                //  large as LongestFreedRun.
                //

                FoundRun = NtfsPositionCachedLcnByLength( &Vcb->CachedRuns,
                                                          Vcb->CachedRuns.LongestFreedRun,
                                                          NULL,
                                                          NULL,
                                                          TRUE,
                                                          &RunIndex );

                if (!FoundRun &&
                    (RunIndex < Vcb->CachedRuns.Used) &&
                    (Vcb->CachedRuns.LengthArray[ RunIndex ] != NTFS_CACHED_RUNS_DEL_INDEX) ) {

                    //
                    //  RunIndex points to a larger entry.
                    //

                    FoundRun = TRUE;

                    ASSERT( FoundRun ||
                            (RunIndex >= Vcb->CachedRuns.Used) ||
                            (Vcb->CachedRuns.LengthArray[ RunIndex ] == NTFS_CACHED_RUNS_DEL_INDEX) );
                }

                if (FoundRun) {

                    //
                    //  Use the entries we already have.
                    //

                    leave;
                }
            }

        //
        //  Set the current total free space to zero and the following loop will compute
        //  the actual number of free clusters.
        //

        } else {

            Vcb->FreeClusters = 0;
        }

        NtfsReinitializeCachedRuns( &Vcb->CachedRuns );

        //
        //  For every bitmap page we read it in and check how many free clusters there are.
        //  While we have the page in memory we also scan for a large chunks of free space.
        //

        for (Lcn = 0; Lcn < Vcb->TotalClusters; Lcn = Lcn + Bitmap.SizeOfBitMap) {

            LCN StartingLcn;

            RTL_BITMAP_RUN RunArray[64];
            ULONG RunArrayIndex;

            //
            //  Read in the bitmap page and make sure that we haven't messed up the math
            //

            if (StuffAdded) { NtfsFreePool( Bitmap.Buffer ); StuffAdded = FALSE; }

            NtfsUnpinBcb( IrpContext, &BitmapBcb );
            NtfsMapPageInBitmap( IrpContext, Vcb, Lcn, &StartingLcn, &Bitmap, &BitmapBcb );
            ASSERTMSG("Math wrong for bits per page of bitmap", (Lcn == StartingLcn));

            //
            //  Compute the number of clear bits in the bitmap each clear bit denotes
            //  a free cluster.
            //

            if (!CachedRunsOnly) {

                Vcb->FreeClusters += RtlNumberOfClearBits( &Bitmap );
            }

            //
            //  Now bias the bitmap with the RecentlyDeallocatedMcb.
            //

            StuffAdded = NtfsAddRecentlyDeallocated( Vcb, StartingLcn, &Bitmap );

            //
            //  Find the 64 longest free runs in the bitmap and add them to the
            //  cached bitmap.
            //

            RunArrayIndex = RtlFindClearRuns( &Bitmap, RunArray, 64, TRUE );

            if (RunArrayIndex > 0) {

                NtfsAddCachedRunMult( IrpContext,
                                      Vcb,
                                      Lcn,
                                      RunArray,
                                      RunArrayIndex );
            }
        }

        Vcb->ClustersRecentlyFreed = 0;
        Vcb->CachedRuns.LongestFreedRun = 0;

    } finally {

        DebugUnwind( NtfsScanEntireBitmap );

        if (!AbnormalTermination() && !CachedRunsOnly) {

            ClearFlag( Vcb->VcbState, VCB_STATE_RELOAD_FREE_CLUSTERS );
        }

        if (StuffAdded) { NtfsFreePool( Bitmap.Buffer ); }

        NtfsUnpinBcb( IrpContext, &BitmapBcb );
    }

    DebugTrace( -1, Dbg, ("NtfsScanEntireBitmap -> VOID\n") );

    return;
}

VOID
NtfsModifyBitsInBitmap (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LONGLONG FirstBit,
    IN LONGLONG BeyondFinalBit,
    IN ULONG RedoOperation,
    IN ULONG UndoOperation
    )

/*++

Routine Description:

    This routine is called to directly modify a specific range of bits in the volume bitmap.
    It should only be called by someone who is directly manipulating the volume bitmap
    (i.e. ExtendVolume).

Arguments:

    Vcb - This is the volume being modified.

    FirstBit - First bit in the bitmap to set.

    BeyondFinalBit - Indicates where to stop modifying.

    RedoOperation - Indicates whether we are setting or clearing the bits.

    UndoOperation - Indicates whether we need to back out the Redo operation above.

Return Value:

    None.

--*/

{
    RTL_BITMAP Bitmap;
    PBCB BitmapBcb = NULL;

    LONGLONG CurrentLcn;
    LONGLONG BaseLcn;
    BITMAP_RANGE BitmapRange;

    PVOID UndoBuffer = NULL;
    ULONG UndoBufferLength = 0;

    PAGED_CODE();

    //
    //  Use a try-finally to facilate cleanup.
    //

    try {

        //
        //  Loop and perform the necessary operations on each affected page
        //  in the bitmap.
        //

        for (CurrentLcn = FirstBit; CurrentLcn < BeyondFinalBit; CurrentLcn = BaseLcn + Bitmap.SizeOfBitMap) {

            //
            //  Read in the page of the bitmap.
            //

            NtfsUnpinBcb( IrpContext, &BitmapBcb );
            NtfsPinPageInBitmap( IrpContext, Vcb, CurrentLcn, &BaseLcn, &Bitmap, &BitmapBcb );

            //
            //  Determine how many bits to clear on the current page.
            //

            BitmapRange.BitMapOffset = (ULONG) (CurrentLcn - BaseLcn);
            BitmapRange.NumberOfBits = BITS_PER_PAGE - BitmapRange.BitMapOffset;

            if (BitmapRange.NumberOfBits > (ULONG) (BeyondFinalBit - CurrentLcn)) {

                BitmapRange.NumberOfBits = (ULONG) (BeyondFinalBit - CurrentLcn);
            }

            //
            //  Write the log record to clear or set the bits.
            //

            if (UndoOperation != Noop) {

                ASSERT( (UndoOperation == SetBitsInNonresidentBitMap) ||
                        (UndoOperation == ClearBitsInNonresidentBitMap) );

                UndoBuffer = &BitmapRange;
                UndoBufferLength = sizeof( BITMAP_RANGE );
            }

            (VOID)
            NtfsWriteLog( IrpContext,
                          Vcb->BitmapScb,
                          BitmapBcb,
                          RedoOperation,
                          &BitmapRange,
                          sizeof( BITMAP_RANGE ),
                          UndoOperation,
                          UndoBuffer,
                          UndoBufferLength,
                          Int64ShraMod32( BaseLcn, 3 ),
                          0,
                          0,
                          Bitmap.SizeOfBitMap >> 3 );

            //
            //  Call the appropriate routine to modify the bits.
            //

            if (RedoOperation == SetBitsInNonresidentBitMap) {

                NtfsRestartSetBitsInBitMap( IrpContext,
                                            &Bitmap,
                                            BitmapRange.BitMapOffset,
                                            BitmapRange.NumberOfBits );

            } else {

                NtfsRestartClearBitsInBitMap( IrpContext,
                                              &Bitmap,
                                              BitmapRange.BitMapOffset,
                                              BitmapRange.NumberOfBits );
            }
        }

    } finally {

        DebugUnwind( NtfsModifyBitsInBitmap );

        NtfsUnpinBcb( IrpContext, &BitmapBcb );
    }

    return;
}


BOOLEAN
NtfsCreateMftHole (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine is called to create a hole within the Mft.

Arguments:

    Vcb - Vcb for volume.

Return Value:

    None.

--*/

{
    BOOLEAN FoundHole = FALSE;
    PBCB BitmapBcb = NULL;
    BOOLEAN StuffAdded = FALSE;
    RTL_BITMAP Bitmap;
    PUCHAR BitmapBuffer;
    ULONG SizeToMap;

    ULONG BitmapOffset;
    ULONG BitmapSize;
    ULONG BitmapIndex;

    ULONG StartIndex;
    ULONG HoleCount;

    ULONG MftVcn;
    ULONG MftClusterCount;

    PAGED_CODE();

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Compute the number of records in the Mft file and the full range to
        //  pin in the Mft bitmap.
        //

        BitmapIndex = (ULONG) LlFileRecordsFromBytes( Vcb, Vcb->MftScb->Header.FileSize.QuadPart );

        //
        //  Knock this index down to a hole boundary.
        //

        BitmapIndex &= Vcb->MftHoleInverseMask;

        //
        //  Compute the values for the bitmap.
        //

        BitmapSize = (BitmapIndex + 7) / 8;

        //
        //  Convert the index to the number of bits on this page.
        //

        BitmapIndex &= (BITS_PER_PAGE - 1);

        if (BitmapIndex == 0) {

            BitmapIndex = BITS_PER_PAGE;
        }

        //
        //  Set the Vcn count to the full size of the bitmap.
        //

        BitmapOffset = (ULONG) ROUND_TO_PAGES( BitmapSize );

        //
        //  Loop through all of the pages of the Mft bitmap looking for an appropriate
        //  hole.
        //

        while (BitmapOffset != 0) {

            //
            //  Move to the beginning of this page.
            //

            BitmapOffset -= BITS_PER_PAGE;

            if (StuffAdded) { NtfsFreePool( Bitmap.Buffer ); StuffAdded = FALSE; }

            //
            //  Compute the number of bytes to map in the current page.
            //

            SizeToMap = BitmapSize - BitmapOffset;

            if (SizeToMap > PAGE_SIZE) {

                SizeToMap = PAGE_SIZE;
            }

            //
            //  Unmap any pages from a previous page and map the current page.
            //

            NtfsUnpinBcb( IrpContext, &BitmapBcb );

            //
            //  Initialize the bitmap for this page.
            //

            NtfsMapStream( IrpContext,
                           Vcb->MftBitmapScb,
                           BitmapOffset,
                           SizeToMap,
                           &BitmapBcb,
                           &BitmapBuffer );

            RtlInitializeBitMap( &Bitmap, (PULONG) BitmapBuffer, SizeToMap * 8 );

            StuffAdded = NtfsAddDeallocatedRecords( Vcb,
                                                    Vcb->MftScb,
                                                    BitmapOffset * 8,
                                                    &Bitmap );

            //
            //  Walk through the current page looking for a hole.  Continue
            //  until we find a hole or have reached the beginning of the page.
            //

            do {

                //
                //  Go back one Mft index and look for a clear run.
                //

                BitmapIndex -= 1;

                HoleCount = RtlFindLastBackwardRunClear( &Bitmap,
                                                         BitmapIndex,
                                                         &BitmapIndex );

                //
                //  If we couldn't find any run then break out of the loop.
                //

                if (HoleCount == 0) {

                    break;

                //
                //  If this is too small to make a hole then continue on.
                //

                } else if (HoleCount < Vcb->MftHoleGranularity) {

                    BitmapIndex &= Vcb->MftHoleInverseMask;
                    continue;
                }

                //
                //  Round up the starting index for this clear run and
                //  adjust the hole count.
                //

                StartIndex = (BitmapIndex + Vcb->MftHoleMask) & Vcb->MftHoleInverseMask;
                HoleCount -= (StartIndex - BitmapIndex);

                //
                //  Round the hole count down to a hole boundary.
                //

                HoleCount &= Vcb->MftHoleInverseMask;

                //
                //  If we couldn't find enough records for a hole then
                //  go to a previous index.
                //

                if (HoleCount < Vcb->MftHoleGranularity) {

                    BitmapIndex &= Vcb->MftHoleInverseMask;
                    continue;
                }

                //
                //  Convert the hole count to a cluster count.
                //

                if (Vcb->FileRecordsPerCluster == 0) {

                    HoleCount <<= Vcb->MftToClusterShift;

                } else {

                    HoleCount = 1;
                }

                //
                //  Loop by finding the run at the given Vcn and walk through
                //  subsequent runs looking for a hole.
                //

                do {

                    PVOID RangePtr;
                    ULONG McbIndex;
                    VCN ThisVcn;
                    LCN ThisLcn;
                    LONGLONG ThisClusterCount;

                    //
                    //  Find the starting Vcn for this hole and initialize
                    //  the cluster count for the current hole.
                    //

                    ThisVcn = StartIndex + (BitmapOffset * 3);

                    if (Vcb->FileRecordsPerCluster == 0) {

                        ThisVcn <<= Vcb->MftToClusterShift;

                    } else {

                        ThisVcn >>= Vcb->MftToClusterShift;
                    }

                    MftVcn = (ULONG) ThisVcn;
                    MftClusterCount = 0;

                    //
                    //  Lookup the run at the current Vcn.
                    //

                    NtfsLookupNtfsMcbEntry( &Vcb->MftScb->Mcb,
                                            ThisVcn,
                                            &ThisLcn,
                                            &ThisClusterCount,
                                            NULL,
                                            NULL,
                                            &RangePtr,
                                            &McbIndex );

                    //
                    //  Now walk through this bitmap run and look for a run we
                    //  can deallocate to create a hole.
                    //

                    do {

                        //
                        //  Go to the next run in the Mcb.
                        //

                        McbIndex += 1;

                        //
                        //  If this run extends beyond the end of the of the
                        //  hole then truncate the clusters in this run.
                        //

                        if (ThisClusterCount > HoleCount) {

                            ThisClusterCount = HoleCount;
                            HoleCount = 0;

                        } else {

                            HoleCount -= (ULONG) ThisClusterCount;
                        }

                        //
                        //  Check if this run is a hole then clear the count
                        //  of clusters.
                        //

                        if (ThisLcn == UNUSED_LCN) {

                            //
                            //  We want to skip this hole.  If we have found a
                            //  hole then we are done.  Otherwise we want to
                            //  find the next range in the Mft starting at the point beyond
                            //  the current run (which is a hole).  Nothing to do if we don't
                            //  have enough clusters for a full hole.
                            //

                            if (!FoundHole &&
                                (HoleCount >= Vcb->MftClustersPerHole)) {

                                //
                                //  Find the Vcn after the current Mft run.
                                //

                                ThisVcn += ThisClusterCount;

                                //
                                //  If this isn't on a hole boundary then
                                //  round up to a hole boundary.  Adjust the
                                //  available clusters for a hole.
                                //

                                MftVcn = (ULONG) (ThisVcn + Vcb->MftHoleClusterMask);
                                MftVcn = (ULONG) ThisVcn & Vcb->MftHoleClusterInverseMask;

                                //
                                //  Now subtract this from the HoleClusterCount.
                                //

                                HoleCount -= MftVcn - (ULONG) ThisVcn;

                                //
                                //  We need to convert the Vcn at this point to an Mft record
                                //  number.
                                //

                                if (Vcb->FileRecordsPerCluster == 0) {

                                    StartIndex = MftVcn >> Vcb->MftToClusterShift;

                                } else {

                                    StartIndex = MftVcn << Vcb->MftToClusterShift;
                                }
                            }

                            break;

                        //
                        //  We found a run to deallocate.
                        //

                        } else {

                            //
                            //  Add these clusters to the clusters already found.
                            //  Set the flag indicating we found a hole if there
                            //  are enough clusters to create a hole.
                            //

                            MftClusterCount += (ULONG) ThisClusterCount;

                            if (MftClusterCount >= Vcb->MftClustersPerHole) {

                                FoundHole = TRUE;
                            }
                        }

                    } while ((HoleCount != 0) &&
                             NtfsGetSequentialMcbEntry( &Vcb->MftScb->Mcb,
                                                        &RangePtr,
                                                        McbIndex,
                                                        &ThisVcn,
                                                        &ThisLcn,
                                                        &ThisClusterCount ));

                } while (!FoundHole && (HoleCount >= Vcb->MftClustersPerHole));

                //
                //  Round down to a hole boundary for the next search for
                //  a hole candidate.
                //

                BitmapIndex &= Vcb->MftHoleInverseMask;

            } while (!FoundHole && (BitmapIndex >= Vcb->MftHoleGranularity));

            //
            //  If we found a hole then deallocate the clusters and record
            //  the hole count change.
            //

            if (FoundHole) {

                IO_STATUS_BLOCK IoStatus;
                LONGLONG MftFileOffset;

                //
                //  We want to flush the data in the Mft out to disk in
                //  case a lazywrite comes in during a window where we have
                //  removed the allocation but before a possible abort.
                //

                MftFileOffset = LlBytesFromClusters( Vcb, MftVcn );

                //
                //  Round the cluster count and hole count down to a hole boundary.
                //


                MftClusterCount &= Vcb->MftHoleClusterInverseMask;

                if (Vcb->FileRecordsPerCluster == 0) {

                    HoleCount = MftClusterCount >> Vcb->MftToClusterShift;

                } else {

                    HoleCount = MftClusterCount << Vcb->MftToClusterShift;
                }

                CcFlushCache( &Vcb->MftScb->NonpagedScb->SegmentObject,
                              (PLARGE_INTEGER) &MftFileOffset,
                              BytesFromClusters( Vcb, MftClusterCount ),
                              &IoStatus );

                ASSERT( IoStatus.Status == STATUS_SUCCESS );

                //
                //  Remove the clusters from the Mcb for the Mft.
                //

                NtfsDeleteAllocation( IrpContext,
                                      Vcb->MftScb->FileObject,
                                      Vcb->MftScb,
                                      MftVcn,
                                      (LONGLONG) MftVcn + (MftClusterCount - 1),
                                      TRUE,
                                      FALSE );

                //
                //  Record the change to the hole count.
                //

                Vcb->MftHoleRecords += HoleCount;
                Vcb->MftScb->ScbType.Mft.HoleRecordChange += HoleCount;

                //
                //  Exit the loop.
                //

                break;
            }

            //
            //  Look at all of the bits on the previous page.
            //

            BitmapIndex = BITS_PER_PAGE;
        }

    } finally {

        DebugUnwind( NtfsCreateMftHole );

        if (StuffAdded) { NtfsFreePool( Bitmap.Buffer ); }
        NtfsUnpinBcb( IrpContext, &BitmapBcb );
    }

    return FoundHole;
}


BOOLEAN
NtfsFindMftFreeTail (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    OUT PLONGLONG FileOffset
    )

/*++

Routine Description:

    This routine is called to find the file offset where the run of free records at
    the end of the Mft file begins.  If we can't find a minimal run of file records
    we won't perform truncation.

Arguments:

   