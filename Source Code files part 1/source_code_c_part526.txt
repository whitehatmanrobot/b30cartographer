COUNTER_DEFINITION     W3TotalMove;
    PERF_COUNTER_DEFINITION     W3TotalMoveSec;
    PERF_COUNTER_DEFINITION     W3TotalCopy;
    PERF_COUNTER_DEFINITION     W3TotalCopySec;

    PERF_COUNTER_DEFINITION     W3TotalMkcol;
    PERF_COUNTER_DEFINITION     W3TotalMkcolSec;
    PERF_COUNTER_DEFINITION     W3TotalPropfind;
    PERF_COUNTER_DEFINITION     W3TotalPropfindSec;
    PERF_COUNTER_DEFINITION     W3TotalProppatch;

    PERF_COUNTER_DEFINITION     W3TotalProppatchSec;
    PERF_COUNTER_DEFINITION     W3TotalSearch;
    PERF_COUNTER_DEFINITION     W3TotalSearchSec;

    PERF_COUNTER_DEFINITION     W3TotalLock;
    PERF_COUNTER_DEFINITION     W3TotalLockSec;
    PERF_COUNTER_DEFINITION     W3TotalUnlock;
    PERF_COUNTER_DEFINITION     W3TotalUnlockSec;
    PERF_COUNTER_DEFINITION     W3TotalOthers;

    PERF_COUNTER_DEFINITION     W3TotalOthersSec;
    PERF_COUNTER_DEFINITION     W3TotalRequests;
    PERF_COUNTER_DEFINITION     W3TotalRequestsSec;
    PERF_COUNTER_DEFINITION     W3TotalCGIRequests;
    PERF_COUNTER_DEFINITION     W3CGIRequestsSec;

    PERF_COUNTER_DEFINITION     W3TotalBGIRequests;
    PERF_COUNTER_DEFINITION     W3BGIRequestsSec;
    PERF_COUNTER_DEFINITION     W3TotalNotFoundErrors;
    PERF_COUNTER_DEFINITION     W3TotalNotFoundErrorsSec;
    PERF_COUNTER_DEFINITION     W3TotalLockedErrors;

    PERF_COUNTER_DEFINITION     W3TotalLockedErrorsSec;
    PERF_COUNTER_DEFINITION     W3CurrentCGIRequests;
    PERF_COUNTER_DEFINITION     W3CurrentBGIRequests;
    PERF_COUNTER_DEFINITION     W3MaxCGIRequests;
    PERF_COUNTER_DEFINITION     W3MaxBGIRequests;

    PERF_COUNTER_DEFINITION     W3CurrentCalAuth;
    PERF_COUNTER_DEFINITION     W3MaxCalAuth;
    PERF_COUNTER_DEFINITION     W3TotalFailedCalAuth;
    PERF_COUNTER_DEFINITION     W3CurrentCalSsl;
    PERF_COUNTER_DEFINITION     W3MaxCalSsl;

    PERF_COUNTER_DEFINITION     W3TotalFailedCalSsl;
    PERF_COUNTER_DEFINITION     W3BlockedRequests;
    PERF_COUNTER_DEFINITION     W3AllowedRequests;
    PERF_COUNTER_DEFINITION     W3RejectedRequests;
    PERF_COUNTER_DEFINITION     W3CurrentBlockedRequests;

    PERF_COUNTER_DEFINITION     W3MeasuredBandwidth;
    PERF_COUNTER_DEFINITION     W3TotalBlockedBandwidthBytes;
    PERF_COUNTER_DEFINITION     W3CurrentBlockedBandwidthBytes;
    PERF_COUNTER_DEFINITION     W3ServiceUptime;

} W3_DATA_DEFINITION;

//
//  The counter structure returned.
//

typedef struct _W3_GLOBAL_DATA_DEFINITION
{
    PERF_OBJECT_TYPE            W3GlobalObjectType;

    PERF_COUNTER_DEFINITION     CurrentFilesCached;
    PERF_COUNTER_DEFINITION     TotalFilesCached;
    PERF_COUNTER_DEFINITION     FileCacheHits;
    PERF_COUNTER_DEFINITION     FileCacheMisses;
    PERF_COUNTER_DEFINITION     FileCacheHitRatio;
    PERF_COUNTER_DEFINITION     FileCacheHitRatioDenom;

    PERF_COUNTER_DEFINITION     FileCacheFlushes;
    PERF_COUNTER_DEFINITION     CurrentFileCacheMemoryUsage;
    PERF_COUNTER_DEFINITION     MaxFileCacheMemoryUsage;
    PERF_COUNTER_DEFINITION     ActiveFlushedFiles;
    PERF_COUNTER_DEFINITION     TotalFlushedFiles;

    PERF_COUNTER_DEFINITION     CurrentUrisCached;
    PERF_COUNTER_DEFINITION     TotalUrisCached;
    PERF_COUNTER_DEFINITION     UriCacheHits;
    PERF_COUNTER_DEFINITION     UriCacheMisses;
    PERF_COUNTER_DEFINITION     UriCacheHitRatio;
    PERF_COUNTER_DEFINITION     UriCacheHitRatioDenom;

    PERF_COUNTER_DEFINITION     UriCacheFlushes;
    PERF_COUNTER_DEFINITION     TotalFlushedUris;
    PERF_COUNTER_DEFINITION     CurrentBlobsCached;
    PERF_COUNTER_DEFINITION     TotalBlobsCached;
    PERF_COUNTER_DEFINITION     BlobCacheHits;

    PERF_COUNTER_DEFINITION     BlobCacheMisses;
    PERF_COUNTER_DEFINITION     BlobCacheHitRatio;
    PERF_COUNTER_DEFINITION     BlobCacheHitRatioDenom;
    PERF_COUNTER_DEFINITION     BlobCacheFlushes;
    PERF_COUNTER_DEFINITION     TotalFlushedBlobs;

    PERF_COUNTER_DEFINITION     UlCurrentUrisCached;
    PERF_COUNTER_DEFINITION     UlTotalUrisCached;
    PERF_COUNTER_DEFINITION     UlUriCacheHits; 
    PERF_COUNTER_DEFINITION     UlUriCacheHitsPerSec; 
    PERF_COUNTER_DEFINITION     UlUriCacheMisses; 

    PERF_COUNTER_DEFINITION     UlUriCacheHitRatio; 
    PERF_COUNTER_DEFINITION     UlUriCacheHitRatioDenom; 
    PERF_COUNTER_DEFINITION     UlUriCacheFlushes;
    PERF_COUNTER_DEFINITION     UlTotalFlushedUris;

} W3_GLOBAL_DATA_DEFINITION;

extern  W3_GLOBAL_DATA_DEFINITION    W3GlobalDataDefinition;
extern  W3_DATA_DEFINITION           W3DataDefinition;

extern  W3_COUNTER_BLOCK             w3c;
extern  W3_GLOBAL_COUNTER_BLOCK      W3Global;

#define NUMBER_OF_W3_COUNTERS ((sizeof(W3_DATA_DEFINITION) -        \
                                  sizeof(PERF_OBJECT_TYPE)) /           \
                                  sizeof(PERF_COUNTER_DEFINITION))

#define NUMBER_OF_W3_GLOBAL_COUNTERS ((sizeof(W3_GLOBAL_DATA_DEFINITION) -        \
                                        sizeof(PERF_OBJECT_TYPE)) /           \
                                         sizeof(PERF_COUNTER_DEFINITION))

//
//  Restore default packing & alignment.
//

#pragma pack()


#endif  // _W3DATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\inc\dirmon.h ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    dirmon.h

Abstract:

    Public header for directory monitor

Author:

    Bilal Alam (balam)          Jan-24-2000

Revision History:

--*/

#ifndef _DIRMON_H_
#define _DIRMON_H_

#include <thread_pool.h>
#include "lkrhash.h"

class CDirMonitor;

class CDirMonitorEntry
{
    friend class CDirMonitor;

public:
    CDirMonitorEntry(
        VOID
    );

    virtual
    ~CDirMonitorEntry(
        VOID
    );

    virtual
    VOID
    AddRef()
    {
        // This ref count tracks how many templates
        // and applications are depending on this monitor entry.

        InterlockedIncrement(&m_cDirRefCount);
    };

    virtual
    BOOL
    Release(
        VOID
    );    // return FALSE if last release
    
    virtual
    BOOL
    Init(
        DWORD               cbBufferSize
    );
    
 protected:
    DWORD               m_cPathLength;
    LPWSTR              m_pszPath;
    BYTE*               m_pbBuffer;
    LONG                m_cDirRefCount; // Ref count for external usage
    LONG                m_cIORefCount;  // Ref count of Asynch IO
    HANDLE              m_hDir;
    BOOL                m_fWatchSubdirectories;

    DWORD
    GetBufferSize(
        VOID
    );
    
    BOOL
    SetBufferSize(
        DWORD               cbBufferSize
    );
    
    BOOL
    ResetDirectoryHandle(
        VOID
    );

 private:
    DWORD               m_dwNotificationFlags;
    OVERLAPPED          m_ovr;
    DWORD               m_cBufferSize;
    CDirMonitor*        m_pDirMonitor;
    BOOL                m_fInCleanup;

    VOID
    IOAddRef(
        VOID
    );
    
    BOOL
    IORelease(
        VOID
    );       // return FALSE if last release
    
    BOOL
    RequestNotification(
        VOID
    );
    
    BOOL
    Cleanup(
        VOID
    );
    
    virtual
    BOOL
    ActOnNotification(
        DWORD dwStatus,
        DWORD dwBytesWritten
    ) = 0;
} ;


class CDirMonitor : public CTypedHashTable<CDirMonitor, CDirMonitorEntry, const WCHAR*>
{
public:
    CDirMonitor(
        VOID
    );
    
    ~CDirMonitor(
        VOID
    );



    CDirMonitorEntry *
    FindEntry(
        WCHAR *             pszPath
    );
    
    BOOL
    Monitor(
        CDirMonitorEntry *  pDME,
        WCHAR *             pszDirectory,
        BOOL                fWatchSubDirectories,
        DWORD               dwFlags
    );
    
    VOID
    Cleanup(
        VOID
    );
    
    LK_RETCODE
    InsertEntry(
        CDirMonitorEntry *  pDME
    );
    
    LK_RETCODE
    RemoveEntry(
        CDirMonitorEntry *  pDME
    );
    
    LONG
    AddRef(
        VOID
    )
    {
        return InterlockedIncrement( &m_cRefs );
    }
    
    
    LONG Release(
        VOID
    )
    {
        return InterlockedDecrement( &m_cRefs);
    }
    
    static const
    WCHAR *
    CDirMonitor::ExtractKey(
        const CDirMonitorEntry*     pDME
    )
    {
        return pDME->m_pszPath;
    };

    static
    DWORD
    CDirMonitor::CalcKeyHash(
        const WCHAR*                pszKey
    )
    {
        return HashStringNoCase( pszKey );
    }

    static
    bool
    CDirMonitor::EqualKeys(
        const WCHAR*                pszKey1,
        const WCHAR*                pszKey2
    )
    {
        return _wcsicmp(pszKey1, pszKey2) == 0;
    };

    static
    VOID
    CDirMonitor::AddRefRecord(
        CDirMonitorEntry*,
        int
    )
    {
    }

private:
    CRITICAL_SECTION    m_csSerialComplLock;
    LONG                m_cRefs;
    BOOL                m_fShutdown;

    CDirMonitor(
        const CDirMonitor &
    );

    VOID operator=(
        const CDirMonitor &
    );

    VOID
    SerialComplLock(
        VOID
    )
    {
        EnterCriticalSection( &m_csSerialComplLock);
    }
    
    VOID
    SerialComplUnlock(
        VOID
    )
    {
        LeaveCriticalSection( &m_csSerialComplLock);
    }

public:
    static
    VOID
    DirMonitorCompletionFunction(
        PVOID                       pCtxt,
        DWORD                       dwBytesWritten,
        DWORD                       dwCompletionStatus,
        OVERLAPPED *                pOvr
    );

    static
    VOID
    OverlappedCompletionRoutine(
        DWORD                       dwErrorCode,
        DWORD                       dwNumberOfBytesTransfered,
        LPOVERLAPPED                lpOverlapped
    );
};


inline
BOOL
CDirMonitorEntry::Release(
    VOID
)
{
    BOOL fRet = TRUE;
    CDirMonitor *pDirMonitor = m_pDirMonitor;
    LONG     cRefs;

    //
    // Guard against someone doing a FindEntry on an entry we are releasing
    //
    if (pDirMonitor != NULL)
    {
        pDirMonitor->WriteLock();
    }
    cRefs = InterlockedDecrement(&m_cDirRefCount);

    if (cRefs == 0)
    {
        // When ref count reaches 0, clean up resources
        
        BOOL fDeleteNeeded = Cleanup();

        // Cleanup said that we need to handle the deletion,
        // probably because there were no Asynch operations outstanding
        
        if (fDeleteNeeded)
        {
            delete this;
        }
        
        fRet = FALSE;
    }

    if (pDirMonitor != NULL)
    {
        pDirMonitor->WriteUnlock();
    }

    return fRet;
}

inline
VOID
CDirMonitorEntry::IOAddRef(
    VOID
)
{
    // This refcount track how many
    // asynch IO requests are oustanding
    
    InterlockedIncrement( &m_cIORefCount );
}

inline
BOOL
CDirMonitorEntry::IORelease(
    VOID
)
{
    BOOL fRet = TRUE;
    CDirMonitor *pDirMonitor = m_pDirMonitor;

    //
    // Guard against someone doing a FindEntry on an entry we are releasing
    //
    if (pDirMonitor != NULL)
    {
        pDirMonitor->WriteLock();
    }
    InterlockedDecrement(&m_cIORefCount);

    // When both IO and external ref counts reaches 0,
    // free this object
    if (m_cIORefCount == 0 &&
        m_cDirRefCount == 0)
    {
        delete this;
        
        fRet = FALSE;
    }

    if (pDirMonitor != NULL)
    {
        pDirMonitor->WriteUnlock();
    }

    return fRet;
}

inline
DWORD
CDirMonitorEntry::GetBufferSize(
    VOID
)
{
    return m_cBufferSize;
}


#endif /* _DIRMON_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\core\w3ctrs\w3ctrs.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    w3ctrs.h

    Offset definitions for the W3 Server's Site counter object & counters
    as well as the W3 Server's Cache counter object and counters

    This file is used in conjunction with the w3ctrs.ini file
    by the LODCTR utility to load the object & counter names of the
    w3ctrs into the registry.
*/


#ifndef _W3CTRS_H_
#define _W3CTRS_H_


//
//  The W3 Server counter object.
//

#define W3_COUNTER_OBJECT                     0

//
//  The individual counters.
//
#define W3_BYTES_SENT_COUNTER                          2
#define W3_BYTES_SENT_PER_SEC                          4
#define W3_BYTES_RECEIVED_COUNTER                      6
#define W3_BYTES_RECEIVED_PER_SEC                      8

#define W3_BYTES_TOTAL_COUNTER                         10
#define W3_BYTES_TOTAL_PER_SEC                         12
#define W3_FILES_SENT_COUNTER                          14

#define W3_FILES_SENT_SEC                              16
#define W3_FILES_RECEIVED_COUNTER                      18
#define W3_FILES_RECEIVED_SEC                          20
#define W3_FILES_TOTAL_COUNTER                         22
#define W3_FILES_SEC                                   24

#define W3_CURRENT_ANONYMOUS_COUNTER                   26
#define W3_CURRENT_NONANONYMOUS_COUNTER                28
#define W3_TOTAL_ANONYMOUS_COUNTER                     30
#define W3_ANONYMOUS_USERS_SEC                         32
#define W3_TOTAL_NONANONYMOUS_COUNTER                  34

#define W3_NON_ANONYMOUS_USERS_SEC                     36
#define W3_MAX_ANONYMOUS_COUNTER                       38
#define W3_MAX_NONANONYMOUS_COUNTER                    40
#define W3_CURRENT_CONNECTIONS_COUNTER                 42
#define W3_MAX_CONNECTIONS_COUNTER                     44

#define W3_CONNECTION_ATTEMPTS_COUNTER                 46
#define W3_CONNECTION_ATTEMPTS_SEC                     48
#define W3_LOGON_ATTEMPTS_COUNTER                      50
#define W3_LOGON_ATTEMPTS_SEC                          52
#define W3_TOTAL_OPTIONS_COUNTER                       54

#define W3_TOTAL_OPTIONS_SEC                           56
#define W3_TOTAL_GETS_COUNTER                          58
#define W3_TOTAL_GETS_SEC                              60
#define W3_TOTAL_POSTS_COUNTER                         62
#define W3_TOTAL_POSTS_SEC                             64

#define W3_TOTAL_HEADS_COUNTER                         66
#define W3_TOTAL_HEADS_SEC                             68
#define W3_TOTAL_PUTS_COUNTER                          70
#define W3_TOTAL_PUTS_SEC                              72
#define W3_TOTAL_DELETES_COUNTER                       74

#define W3_TOTAL_DELETES_SEC                           76
#define W3_TOTAL_TRACES_COUNTER                        78
#define W3_TOTAL_TRACES_SEC                            80
#define W3_TOTAL_MOVE_COUNTER                          82
#define W3_TOTAL_MOVE_SEC                              84

#define W3_TOTAL_COPY_COUNTER                          86
#define W3_TOTAL_COPY_SEC                              88
#define W3_TOTAL_MKCOL_COUNTER                         90
#define W3_TOTAL_MKCOL_SEC                             92
#define W3_TOTAL_PROPFIND_COUNTER                      94

#define W3_TOTAL_PROPFIND_SEC                          96
#define W3_TOTAL_PROPPATCH_COUNTER                     98
#define W3_TOTAL_PROPPATCH_SEC                         100
#define W3_TOTAL_SEARCH_COUNTER                        102
#define W3_TOTAL_SEARCH_SEC                            104

#define W3_TOTAL_LOCK_COUNTER                          106
#define W3_TOTAL_LOCK_SEC                              108
#define W3_TOTAL_UNLOCK_COUNTER                        110
#define W3_TOTAL_UNLOCK_SEC                            112
#define W3_TOTAL_OTHERS_COUNTER                        114

#define W3_TOTAL_OTHERS_SEC                            116
#define W3_TOTAL_REQUESTS_COUNTER                      118
#define W3_TOTAL_REQUESTS_SEC                          120
#define W3_TOTAL_CGI_REQUESTS_COUNTER                  122
#define W3_CGI_REQUESTS_SEC                            124

#define W3_TOTAL_BGI_REQUESTS_COUNTER                  126
#define W3_BGI_REQUESTS_SEC                            128
#define W3_TOTAL_NOT_FOUND_ERRORS_COUNTER              130
#define W3_TOTAL_NOT_FOUND_ERRORS_SEC                  132
#define W3_TOTAL_LOCKED_ERRORS_COUNTER                 134

#define W3_TOTAL_LOCKED_ERRORS_SEC                     136
#define W3_CURRENT_CGI_COUNTER                         138
#define W3_CURRENT_BGI_COUNTER                         140
#define W3_MAX_CGI_COUNTER                             142
#define W3_MAX_BGI_COUNTER                             144

#define W3_CURRENT_CAL_AUTH_COUNTER                    146
#define W3_MAX_CAL_AUTH_COUNTER                        148
#define W3_TOTAL_FAILED_CAL_AUTH_COUNTER               150
#define W3_CURRENT_CAL_SSL_COUNTER                     152
#define W3_MAX_CAL_SSL_COUNTER                         154

#define W3_BLOCKED_REQUESTS_COUNTER                    156
#define W3_ALLOWED_REQUESTS_COUNTER                    158
#define W3_REJECTED_REQUESTS_COUNTER                   160
#define W3_CURRENT_BLOCKED_REQUESTS_COUNTER            162
#define W3_TOTAL_FAILED_CAL_SSL_COUNTER                164

#define W3_MEASURED_BANDWIDTH_COUNTER                  166
#define W3_TOTAL_BLOCKED_BANDWIDTH_BYTES_COUNTER       168
#define W3_CURRENT_BLOCKED_BANDWIDTH_BYTES_COUNTER     170
#define W3_SERVICE_UPTIME_COUNTER                      172


//
//  The IIS Global Counters
//

#define W3_GLOBAL_COUNTER_OBJECT             174


//
//  The individual counters.
//

#define W3_GLOBAL_CURRENT_FILES_CACHED_COUNTER              176
#define W3_GLOBAL_TOTAL_FILES_CACHED_COUNTER                178
#define W3_GLOBAL_FILE_CACHE_HITS_COUNTER                   180
#define W3_GLOBAL_FILE_CACHE_MISSES_COUNTER                 182

#define W3_GLOBAL_FILE_CACHE_HIT_RATIO_COUNTER              184
#define W3_GLOBAL_FILE_CACHE_HIT_RATIO_COUNTER_DENOM        186
#define W3_GLOBAL_FILE_CACHE_FLUSHES_COUNTER                188
#define W3_GLOBAL_CURRENT_FILE_CACHE_MEMORY_USAGE_COUNTER   190
#define W3_GLOBAL_MAX_FILE_CACHE_MEMORY_USAGE_COUNTER       192

#define W3_GLOBAL_ACTIVE_FLUSHED_FILES_COUNTER              194
#define W3_GLOBAL_TOTAL_FLUSHED_FILES_COUNTER               196
#define W3_GLOBAL_CURRENT_URIS_CACHED_COUNTER               198
#define W3_GLOBAL_TOTAL_URIS_CACHED_COUNTER                 200
#define W3_GLOBAL_URI_CACHE_HITS_COUNTER                    202

#define W3_GLOBAL_URI_CACHE_MISSES_COUNTER                  204
#define W3_GLOBAL_URI_CACHE_HIT_RATIO_COUNTER               206
#define W3_GLOBAL_URI_CACHE_HIT_RATIO_COUNTER_DENOM         208
#define W3_GLOBAL_URI_CACHE_FLUSHES_COUNTER                 210
#define W3_GLOBAL_TOTAL_FLUSHED_URIS_COUNTER                212

#define W3_GLOBAL_CURRENT_METADATA_CACHED_COUNTER               214
#define W3_GLOBAL_TOTAL_METADATA_CACHED_COUNTER                 216
#define W3_GLOBAL_METADATA_CACHE_HITS_COUNTER                   218
#define W3_GLOBAL_METADATA_CACHE_MISSES_COUNTER                 220
#define W3_GLOBAL_METADATA_CACHE_HIT_RATIO_COUNTER              222

#define W3_GLOBAL_METADATA_CACHE_HIT_RATIO_COUNTER_DENOM        224
#define W3_GLOBAL_METADATA_CACHE_FLUSHES_COUNTER                226
#define W3_GLOBAL_TOTAL_FLUSHED_METADATA_COUNTER                228
#define W3_GLOBAL_KERNEL_CURRENT_URIS_CACHED_COUNTER            230
#define W3_GLOBAL_KERNEL_TOTAL_URIS_CACHED_COUNTER              232

#define W3_GLOBAL_KERNEL_URI_CACHE_HITS_COUNTER                 234
#define W3_GLOBAL_KERNEL_URI_CACHE_HITS_PER_SEC                 236
#define W3_GLOBAL_KERNEL_URI_CACHE_MISSES_COUNTER               238
#define W3_GLOBAL_KERNEL_URI_CACHE_HIT_RATIO_COUNTER            240
#define W3_GLOBAL_KERNEL_URI_CACHE_HIT_RATIO_COUNTER_DENOM      242

#define W3_GLOBAL_KERNEL_URI_CACHE_FLUSHES_COUNTER              244
#define W3_GLOBAL_KERNEL_TOTAL_FLUSHED_URIS_COUNTER             246

#endif  // _W3CTRS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\inc\logging.h ===
/*++

   Copyright    (c)   2000    Microsoft Corporation

   Module Name :
     logging.h

   Abstract:
     Logging classes

   Author:
     Anil Ruia (AnilR)                  1-Jul-2000

   Environment:
     Win32 - User Mode
--*/

#ifndef _LOGGING_H_
#define _LOGGING_H_

#ifndef LOGGING_DLLEXP
# ifdef DLL_IMPLEMENTATION
#  define LOGGING_DLLEXP __declspec(dllexport)
#  ifdef IMPLEMENTATION_EXPORT
#   define LOGGING_EXPIMP
#  else
#   undef  LOGGING_EXPIMP
#  endif 
# elif defined LIB_IMPLEMENTATION
#  define LOGGING_DLLEXP
#  define LOGGING_EXPIMP extern
# else 
#  define LOGGING_DLLEXP __declspec(dllimport)
#  define LOGGING_EXPIMP extern
# endif // !DLL_IMPLEMENTATION 
#endif // !LOGGING_DLLEXP

enum LAST_IO_PENDING
{
    LOG_READ_IO,
    LOG_WRITE_IO,

    LOG_NO_IO
};

class LOG_CONTEXT
{
 public:
    LOG_CONTEXT()
        : m_msStartTickCount (0),
          m_msProcessingTime (0),
          m_dwBytesRecvd     (0),
          m_dwBytesSent      (0),
          m_ioPending        (LOG_NO_IO),
          m_strLogParam      (m_achLogParam, sizeof m_achLogParam)
    {
        ZeroMemory(&m_UlLogData, sizeof m_UlLogData);
    }

    HTTP_LOG_FIELDS_DATA *QueryUlLogData()
    {
        return &m_UlLogData;
    }

    //
    // The querystring to be logged, may differ from the original querystring
    // because of ISAPI doing HSE_APPEND_LOG_PARAMETER
    //
    STRA               m_strLogParam;
    CHAR               m_achLogParam[64];

    //
    // The data UL is interested in
    //
    HTTP_LOG_FIELDS_DATA m_UlLogData;

    //
    // Couple other things for custom logging
    //
    STRA               m_strVersion;

    MULTISZA           m_mszHTTPHeaders;

    //
    // Keep track whether the last I/O was a read or a write so that we
    // know on completion whether to increment bytes read or bytes written
    //
    LAST_IO_PENDING    m_ioPending;

    DWORD              m_msStartTickCount;
    DWORD              m_msProcessingTime;

    DWORD              m_dwBytesRecvd;
    DWORD              m_dwBytesSent;
};

class LOGGING_DLLEXP LOGGING
{
 public:

    LOGGING();

    HRESULT ActivateLogging(IN LPCSTR  pszInstanceName,
                            IN LPCWSTR pszMetabasePath,
                            IN IMSAdminBase *pMDObject,
                            IN BOOL fDoCentralBinaryLogging);

    void LogInformation(IN LOG_CONTEXT *pLogData);

    BOOL IsRequiredExtraLoggingFields() const
    {
        return !m_mszExtraLoggingFields.IsEmpty();
    }

    const MULTISZA *QueryExtraLoggingFields() const
    {
        return &m_mszExtraLoggingFields;
    }

    void LogCustomInformation(IN DWORD            cCount, 
                              IN CUSTOM_LOG_DATA *pCustomLogData,
                              IN LPSTR            szHeaderSuffix);

    static HRESULT Initialize();
    static VOID    Terminate();

    BOOL QueryDoUlLogging() const
    {
        return m_fUlLogType;
    }

    BOOL QueryDoCustomLogging() const
    {
        return (m_pComponent != NULL);
    }

    VOID AddRef();

    VOID Release();

  private:

    ~LOGGING();

    DWORD        m_Signature;
    LONG         m_cRefs;

    BOOL         m_fUlLogType;
    ILogPlugin  *m_pComponent;

    MULTISZA     m_mszExtraLoggingFields;
};

#endif // _LOGGING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\inc\streamfilt.h ===
#ifndef _STREAMFILT_H_
#define _STREAMFILT_H_

/*++

   Copyright    (c)    2000    Microsoft Corporation

   Module  Name :
     streamfilt.h

   Abstract:
    public interface of the strmfilt.dll

   Author:
     Bilal Alam         (BAlam)         29-March-2000

   Environment:
     Win32 - User Mode

   Project:
     Stream Filter Worker Process
--*/



#include <http.h>
#include <httpp.h>

//
// Structure containing friendly local/remote information
//

struct _RAW_STREAM_INFO;

typedef HRESULT (*PFN_SEND_DATA_BACK)
(
    PVOID                    pvStreamContext,
    _RAW_STREAM_INFO *       pRawStreamInfo
);

typedef union SockAddress {
    SOCKADDR_IN      ipv4SockAddress;
    SOCKADDR_IN6     ipv6SockAddress;    
} SockAddress;


typedef struct _CONNECTION_INFO {
    USHORT                  LocalAddressType;  // AF_INET or AF_INET6
    USHORT                  RemoteAddressType; // AF_INET or AF_INET6

    SockAddress             SockLocalAddress;
    SockAddress             SockRemoteAddress;
    
    BOOL                    fIsSecure;
    HTTP_RAW_CONNECTION_ID  RawConnectionId;
    PFN_SEND_DATA_BACK      pfnSendDataBack;
    PVOID                   pvStreamContext;
    ULONG                   ClientSSLContextLength;
    HTTP_CLIENT_SSL_CONTEXT *pClientSSLContext;
} CONNECTION_INFO, *PCONNECTION_INFO;

//
// Structure used to access/alter raw data stream (read/write)
//

typedef struct _RAW_STREAM_INFO {
    PBYTE               pbBuffer;
    DWORD               cbData;
    DWORD               cbBuffer;
} RAW_STREAM_INFO, *PRAW_STREAM_INFO;

//
// Called to handle read raw notifications
//

typedef HRESULT (*PFN_PROCESS_RAW_READ)
(
    RAW_STREAM_INFO *       pRawStreamInfo,
    PVOID                   pvContext,
    BOOL *                  pfReadMore,
    BOOL *                  pfComplete,
    DWORD *                 pcbNextReadSize
);

//
// Called to handle write raw notifications
//

typedef HRESULT (*PFN_PROCESS_RAW_WRITE)
(
    RAW_STREAM_INFO *       pRawStreamInfo,
    PVOID                   pvContext,
    BOOL *                  pfComplete
);

//
// Called when a connection goes away
//

typedef VOID (*PFN_PROCESS_CONNECTION_CLOSE)
(
    PVOID                   pvContext
);

//
// Called when a connection is created
//

typedef HRESULT (*PFN_PROCESS_NEW_CONNECTION)
(
    CONNECTION_INFO *       pConnectionInfo,
    PVOID *                 ppvContext
);

//
// Called to release context
//

typedef VOID (*PFN_RELEASE_CONTEXT)
(
    PVOID                   pvContext
);

//
// Callbacks used to implement Raw ISAPI Filter Support
//

typedef struct _ISAPI_FILTERS_CALLBACKS {
    PFN_PROCESS_RAW_READ            pfnRawRead;
    PFN_PROCESS_RAW_WRITE           pfnRawWrite;
    PFN_PROCESS_CONNECTION_CLOSE    pfnConnectionClose;
    PFN_PROCESS_NEW_CONNECTION      pfnNewConnection;
    PFN_RELEASE_CONTEXT             pfnReleaseContext;
} ISAPI_FILTERS_CALLBACKS, *PISAPI_FILTERS_CALLBACKS;

HRESULT
StreamFilterInitialize(
    VOID
);

HRESULT
StreamFilterStart(
    VOID
);

HRESULT
StreamFilterStop( 
    VOID
);

VOID
StreamFilterTerminate(
    VOID
);

HRESULT
IsapiFilterInitialize(
    ISAPI_FILTERS_CALLBACKS *      pCallbacks
);

VOID
IsapiFilterTerminate(
    VOID
);


//
// typedefs for strmfilt entrypoints
//

typedef HRESULT ( * PFN_STREAM_FILTER_INITIALIZE ) ( VOID );

typedef VOID ( * PFN_STREAM_FILTER_TERMINATE ) ( VOID );

typedef HRESULT ( * PFN_STREAM_FILTER_START ) ( VOID );

typedef HRESULT ( * PFN_STREAM_FILTER_STOP ) ( VOID );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\inc\ulw3.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    ulw3.h

Abstract:

    Defines the public ULW3.DLL entry point

Author:

    Bilal Alam (balam)      12-Dec-1999

Revision History:

--*/

#ifndef _ULW3_H_
#define _ULW3_H_

#define ULW3_DLL_NAME               (L"w3core.dll")
#define ULW3_DLL_ENTRY              ("UlW3Start")

#define SERVER_SOFTWARE_STRING      ("Microsoft-IIS/6.0")

typedef HRESULT (*PFN_ULW3_ENTRY)( INT argc, LPWSTR* argv, BOOL fCompat );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\inc\ulatq.h ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    ulatq.h

Abstract:

    Exported ULATQ.DLL routines.

    ULATQ contains the thread queue and UL support routines for
    IISPLUS.

Author:

    Taylor Weiss (TaylorW)       15-Dec-1999

Revision History:

--*/


#ifndef _ULATQ_H_
#define _ULATQ_H_

//
// The magic context that makes the world turn
//

typedef VOID*               ULATQ_CONTEXT;

//
// Some callbacks specified by user of ULATQ to catch certain events
//

typedef VOID
(*PFN_ULATQ_NEW_REQUEST)
(
    ULATQ_CONTEXT           pContext
);

typedef VOID
(*PFN_ULATQ_IO_COMPLETION)
(
    PVOID                   pvContext,
    DWORD                   cbWritten,
    DWORD                   dwCompletionStatus,
    OVERLAPPED *            lpo
);

typedef VOID
(*PFN_ULATQ_DISCONNECT)
(
    PVOID                   pvContext
);

typedef VOID
(*PFN_ULATQ_ON_SHUTDOWN)
(
    BOOL                    fImmediate
);

typedef HRESULT
(* PFN_ULATQ_COLLECT_PERF_COUNTERS)(
    OUT PBYTE *             ppCounterData,
    OUT DWORD *             pdwCounterData
);

typedef struct _ULATQ_CONFIG
{
    PFN_ULATQ_IO_COMPLETION         pfnIoCompletion;
    PFN_ULATQ_NEW_REQUEST           pfnNewRequest;
    PFN_ULATQ_DISCONNECT            pfnDisconnect;
    PFN_ULATQ_ON_SHUTDOWN           pfnOnShutdown;
    PFN_ULATQ_COLLECT_PERF_COUNTERS pfnCollectCounters;
}
ULATQ_CONFIG, *PULATQ_CONFIG;

//
// ULATQ_CONTEXT properties
//

typedef enum
{
    ULATQ_PROPERTY_COMPLETION_CONTEXT = 0,
    ULATQ_PROPERTY_HTTP_REQUEST,
    ULATQ_PROPERTY_APP_POOL_ID,
    ULATQ_PROPERTY_IS_COMMAND_LINE_LAUNCH,
    ULATQ_PROPERTY_DO_CENTRAL_BINARY_LOGGING
} ULATQ_CONTEXT_PROPERTY_ID;

HRESULT
UlAtqInitialize(
    INT                 argc,
    LPWSTR              argv[],
    ULATQ_CONFIG *      pConfig
);

HRESULT
UlAtqStartListen(
    VOID
);

VOID
UlAtqTerminate(
    HRESULT hrToSend
);

VOID *
UlAtqGetContextProperty(
    ULATQ_CONTEXT               pContext,
    ULATQ_CONTEXT_PROPERTY_ID   ContextPropertyId
);

VOID
UlAtqSetContextProperty(
    ULATQ_CONTEXT               pContext,
    ULATQ_CONTEXT_PROPERTY_ID   ContextPropertyId,
    PVOID                       pvData
);

VOID *
UlAtqAllocateMemory(
    ULATQ_CONTEXT               pContext,
    DWORD                       cbData
);

VOID
UlAtqFreeContext(
    ULATQ_CONTEXT               pContext
);

HRESULT
UlAtqSendEntityBody(
    ULATQ_CONTEXT               pContext,
    BOOL                        fAsync,
    DWORD                       dwFlags,
    USHORT                      cChunks,
    HTTP_DATA_CHUNK *           pChunks,
    DWORD                      *pcbSent,
    HTTP_LOG_FIELDS_DATA       *pUlLogData
);

HRESULT
UlAtqReceiveEntityBody(
    ULATQ_CONTEXT               pContext,
    BOOL                        fAsync,
    DWORD                       dwFlags,
    VOID *                      pBuffer,
    DWORD                       cbBuffer,
    DWORD *                     pBytesReceived
);

HRESULT
UlAtqSendHttpResponse(
    ULATQ_CONTEXT               pContext,
    BOOL                        fAsync,
    DWORD                       dwFlags,
    HTTP_RESPONSE *             pResponse,
    HTTP_CACHE_POLICY *         pCachePolicy,
    DWORD *                     pcbSent,
    HTTP_LOG_FIELDS_DATA *      pUlLogData
);

HRESULT
UlAtqWaitForDisconnect(
    HTTP_CONNECTION_ID          connectionId,
    BOOL                        fAsync,
    VOID *                      pvContext,
    BOOL *                      pfAlreadyCompleted = NULL
);

HRESULT
UlAtqReceiveClientCertificate(
    ULATQ_CONTEXT               pContext,
    BOOL                        fAsync,
    BOOL                        fDoCertMap,
    HTTP_SSL_CLIENT_CERT_INFO **ppClientCertInfo
);

HRESULT
UlAtqInduceShutdown(
    BOOL fImmediate
);

HRESULT
UlAtqFlushUlCache(
    WCHAR *                     pszURLPrefix
);

VOID
UlAtqSetUnhealthy(
    VOID
);

HRESULT
UlAtqAddFragmentToCache(
    HTTP_DATA_CHUNK * pDataChunk,
    WCHAR           * pszFragmentName);

HRESULT
UlAtqReadFragmentFromCache(
    WCHAR           * pszFragmentName,
    BYTE            * pvBuffer,
    DWORD             cbSize,
    DWORD           * pcbCopied);

HRESULT
UlAtqRemoveFragmentFromCache(
    WCHAR           * pszFragmentName);

#endif // _ULATQ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\inc\w3isapi.h ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     w3isapi.h

   Abstract:
     IIS+ ISAPI handler.
 
   Author:
     Taylor Weiss (TaylorW)             03-Feb-2000

   Project:
     w3isapi.dll

--*/

#ifndef _W3ISAPI_H_
#define _W3ISAPI_H_

#include <http.h>
#include <httpp.h>
#include <iisextp.h>
#include <iisapicore.h>

#define SIZE_CLSID_STRING 40

/* ISAPI_CORE_DATA -
   This structure contains the request data necessary to process
   an ISAPI request.
   
   For an "in process" request, this structure's pointers could
   potentially point to memory allocated by the server core.  To
   support "out of process" requests, it's necessary to append
   the important data to the structure itself in a single block.

   The _cbSize member should reflect the size of both the structure,
   and any such appended data.
*/
struct ISAPI_CORE_DATA
{
    //
    // Structure size information
    //
    
    DWORD       cbSize;

    //
    // CLSID of the WAM to handle the request - If
    // the value is an empty string, then the request
    // will be handled inproc.
    //

    WCHAR       szWamClsid[SIZE_CLSID_STRING];
    BOOL        fIsOop;

    //
    // Secure request?
    //

    BOOL        fSecure;

    //
    // Client HTTP version
    //

    DWORD       dwVersionMajor;
    DWORD       dwVersionMinor;

    //
    // Web site instance ID
    //

    DWORD       dwInstanceId;

    //
    // Request content-length
    //

    DWORD       dwContentLength;

    //
    // Authenticated client impersonation token
    //

    HANDLE      hToken;
    PSID        pSid;

    //
    // Request ID
    //

    HTTP_REQUEST_ID RequestId;

    //
    // Embedded string sizes
    //

    DWORD       cbGatewayImage;
    DWORD       cbPhysicalPath;
    DWORD       cbPathInfo;
    DWORD       cbMethod;
    DWORD       cbQueryString;
    DWORD       cbPathTranslated;
    DWORD       cbContentType;
    DWORD       cbConnection;
    DWORD       cbUserAgent;
    DWORD       cbCookie;
    DWORD       cbApplMdPath;
    DWORD       cbApplMdPathW;
    DWORD       cbPathTranslatedW;

    //
    // Request string data
    //

    LPWSTR      szGatewayImage;
    LPSTR       szPhysicalPath;
    LPSTR       szPathInfo;
    LPSTR       szMethod;
    LPSTR       szQueryString;
    LPSTR       szPathTranslated;
    LPSTR       szContentType;
    LPSTR       szConnection;
    LPSTR       szUserAgent;
    LPSTR       szCookie;
    LPSTR       szApplMdPath;

    //
    // Unicode data used by ASP
    //
    // This is only populated in the OOP case so that
    // we can avoid an RPC call when ASP calls GetServerVariable
    // for them.  Inproc, they are NULL.
    //

    LPWSTR      szApplMdPathW;
    LPWSTR      szPathTranslatedW;

    //
    // Entity data
    //

    DWORD       cbAvailableEntity;
    LPVOID      pAvailableEntity;

    //
    // Site config data
    //

    BOOL        fAllowKeepAlive;
};

typedef HRESULT(* PFN_ISAPI_INIT_MODULE)( LPSTR, LPSTR, DWORD );
typedef VOID(* PFN_ISAPI_TERM_MODULE)( VOID );
typedef HRESULT(* PFN_ISAPI_PROCESS_REQUEST)( IIsapiCore *, ISAPI_CORE_DATA *, DWORD * );
typedef HRESULT(* PFN_ISAPI_PROCESS_COMPLETION)( DWORD64, DWORD, DWORD );

#define ISAPI_INIT_MODULE           "InitModule"
#define ISAPI_TERM_MODULE           "TerminateModule"
#define ISAPI_PROCESS_REQUEST       "ProcessIsapiRequest"
#define ISAPI_PROCESS_COMPLETION    "ProcessIsapiCompletion"

#define ISAPI_MODULE_NAME       L"w3isapi.dll"

#endif // _W3ISAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\inetinfo\main.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    main.c

Abstract:

    This is the main routine for the Internet Services suite.

Author:

    David Treadwell (davidtr)   7-27-93

Revision History:
    Murali Krishnan ( Muralik)  16-Nov-1994  Added Gopher service
    Murali Krishnan ( Muralik)  3-July-1995  Removed non-internet info + trims
    Sophia Chung     (sophiac)  09-Oct-1995  Splitted internet services into
                                             access and info services
    Murali Krishnan ( Muralik)  20-Feb-1996  Enabled to run on NT Workstation
    Emily Kruglick  ( EmilyK)   14-Jun-2000  Moved file from iis 5 tree to iis 6.
                                             Removed all Win95 support.
                                             Added support for WAS controlling W3SVC.

--*/

//
// INCLUDES
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsvc.h>             // Service control APIs
#include <rpc.h>
#include <stdlib.h>
#include <inetsvcs.h>
#include <iis64.h>
#include "waslaunch.hxx"

#include "iisadmin.hxx"
#include <objbase.h>
#include "regconst.h"

//
// Functions used to start/stop the RPC server
//

typedef   DWORD ( *PFN_INETINFO_START_RPC_SERVER)   ( VOID );
typedef   DWORD ( *PFN_INETINFO_STOP_RPC_SERVER)    ( VOID );

//
// Local function used by the above to load and invoke a service DLL.
//

VOID
InetinfoStartService (
    IN DWORD argc,
    IN LPSTR argv[]
    );

VOID
StartDispatchTable(
    VOID
    );


//
// Functions used to preload dlls into the inetinfo process
//

BOOL
LoadPreloadDlls(
    HMODULE * * ppPreloadDllHandles
    );

VOID
UnloadPreloadDlls(
    HMODULE * * ppPreloadDllHandles
    );


//
// Used if the services Dll or entry point can't be found
//

VOID
AbortService(
    LPSTR  ServiceName,
    DWORD   Error
    );

//
// Dispatch table for all services. Passed to NetServiceStartCtrlDispatcher.
//
// Add new service entries here and in the DLL name list.
// Also add an entry in the following table InetServiceDllTable
//

SERVICE_TABLE_ENTRY InetServiceDispatchTable[] = {
                        { "MSFtpSvc",  InetinfoStartService  },
                        { "W3Svc",     InetinfoStartService  },
                        { "IISADMIN",  InetinfoStartService  },
                        { "HTTPFilter",     InetinfoStartService  },
                        { NULL,              NULL  },
                        };
//
// DLL names for all services.
//  (should correspond exactly with above InetServiceDispatchTable)
//

struct SERVICE_DLL_TABLE_ENTRY
{

    LPSTR               lpServiceName;
    LPSTR               lpDllName;
    CRITICAL_SECTION    csLoadLock;
} InetServiceDllTable[] = {
    { "MSFtpSvc",       "ftpsvc2.dll" },
    { "W3Svc",          "w3svc.dll" },
    { "IISADMIN",       "iisadmin.dll" },
    { "HTTPFilter",     "w3ssl.dll" },
    { NULL,             NULL }
};

//
// Global parameter data passed to each service.
//

TCPSVCS_GLOBAL_DATA InetinfoGlobalData;

#include <initguid.h>

DEFINE_GUID(IisExeGuid,
0x784d8901, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);

#include "dbgutil.h"
#include "pudebug.h"

DECLARE_DEBUG_PRINTS_OBJECT()

DWORD __cdecl
main(
    IN DWORD,
    IN LPSTR
    )

/*++

Routine Description:

    This is the main routine for the iisadmin services.  It starts up the
    main thread that is going to handle the control requests from the
    service controller.

    It basically sets up the ControlDispatcher and, on return, exits
    from this main thread.  The call to NetServiceStartCtrlDispatcher
    does not return until all services have terminated, and this process
    can go away.

    The ControlDispatcher thread will start/stop/pause/continue any
    services.  If a service is to be started, it will create a thread
    and then call the main routine of that service.  The "main routine"
    for each service is actually an intermediate function implemented in
    this module that loads the DLL containing the server being started
    and calls its entry point.


Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD dwIndex;
    HINSTANCE  hRpcRef = NULL;
    HMODULE * pPreloadDllHandles = NULL;
    struct SERVICE_DLL_TABLE_ENTRY * pEntry;
    DWORD err = ERROR_SUCCESS;
    BOOL fInitializedCriticalSections = FALSE;

    //
    // Initialize OLE
    //

    CREATE_DEBUG_PRINT_OBJECT("Inetinfo.exe");

    //
    // Initialize Global Data.
    //
    //
    // Use the rpcref library, so that multiple services can
    // independently "start" the rpc server
    //

    hRpcRef = LoadLibrary("rpcref.dll");
    if ( hRpcRef != NULL )
    {
        InetinfoGlobalData.StartRpcServerListen =
            (PFN_INETINFO_START_RPC_SERVER)
            GetProcAddress(hRpcRef,"InetinfoStartRpcServerListen");

        InetinfoGlobalData.StopRpcServerListen =
            (PFN_INETINFO_STOP_RPC_SERVER)
            GetProcAddress(hRpcRef,"InetinfoStopRpcServerListen");
    }
    else
    {
        IIS_PRINTF((buff,
                   "Error %d loading rpcref.dll\n",
                   GetLastError() ));

        err = GetLastError();
        goto exit;
    }

    //
    //  Initialize service entry locks
    //

    for ( dwIndex = 0 ; ; dwIndex++ )
    {
        pEntry = &( InetServiceDllTable[ dwIndex ] );
        if ( pEntry->lpServiceName == NULL )
        {
            break;
        }

        InitializeCriticalSection( &( pEntry->csLoadLock ) );
    }

    fInitializedCriticalSections = TRUE;

    //
    //  Disable hard-error popups.
    //

    SetErrorMode( SEM_FAILCRITICALERRORS | SEM_NOGPFAULTERRORBOX | SEM_NOOPENFILEERRORBOX );

    //
    // Preload Dlls specified in the registry
    //

    if ( !LoadPreloadDlls( &pPreloadDllHandles ) )
    {
        IIS_PRINTF(( buff, "Error pre-loading DLLs\n" ));
    }

    StartDispatchTable( );

    //
    // Make sure that none of the service entry locks are still being held, if
    // they are, then wait for them, so that we do not cleanup while services
    // are still shutting down
    //

    for ( dwIndex = 0 ; ; dwIndex++ )
    {
        pEntry = &( InetServiceDllTable[ dwIndex ] );
        if ( pEntry->lpServiceName == NULL )
        {
            break;
        }

        EnterCriticalSection( &( pEntry->csLoadLock ) );
        LeaveCriticalSection( &( pEntry->csLoadLock ) );
    }

    //
    // Unload pre-loaded Dlls
    //

    UnloadPreloadDlls( &pPreloadDllHandles );

exit:
    //
    // Free the admin service dll
    // Note: this must happen after CoUninitialize or it causes
    // a crash on Win95
    //

    if ( hRpcRef != NULL )
    {
        FreeLibrary( hRpcRef );
        hRpcRef = NULL;
    }

    //
    //  Terminate service entry locks
    //

    if ( fInitializedCriticalSections )
    {
        for ( dwIndex = 0 ; ; dwIndex++ )
        {
            pEntry = &( InetServiceDllTable[ dwIndex ] );
            if ( pEntry->lpServiceName == NULL )
            {
                break;
            }

            DeleteCriticalSection( &( pEntry->csLoadLock ) );
        }
    }

    IIS_PRINTF((buff,"Exiting inetinfo.exe\n"));
    DELETE_DEBUG_PRINT_OBJECT();

    return err;

} // main

DWORD
FindEntryFromDispatchTable(
            IN LPSTR pszService
            )
{
    SERVICE_TABLE_ENTRY  * pService;

    for(pService = InetServiceDispatchTable;
        pService->lpServiceName != NULL;
        pService++)
    {
        if ( !lstrcmpi( pService->lpServiceName, pszService))
        {
            // gambling on the difference not being more than the
            // size of a DWORD, if it is we support a lot of services.
            return (DWORD) DIFF(pService - InetServiceDispatchTable);
        }
    }

    //
    // We have not found the entry. Set error and return
    //

    SetLastError( ERROR_INVALID_PARAMETER );
    return 0xFFFFFFFF;

} // FindEntryFromDispatchTable()

BOOL
GetDLLNameForDispatchEntryService(
    IN LPSTR                    pszService,
    IN OUT CHAR *               pszDllName,
    IN DWORD                    cbDllName
)
/*++

Routine Description:

    If the image name is not in the static dispatch table, then it might be
    in the registry under the value "IISDllName" under the key for the
    service.  This routine reads the registry for the setting (if existing).

    This code allows the exchange folks to install their service DLLs in a
    location other than "%systemroot%\inetsrv".

Arguments:

    pszService - Service name
    pszDllName - Filled with image name
    cbDllName - Size of buffer pointed to by pszDllName

Return Value:

    TRUE if successful, else FALSE.

--*/
{
    HKEY hkey = NULL;
    HKEY hkeyService = NULL;
    DWORD err;
    DWORD valType;
    DWORD nBytes;
    BOOL ret = FALSE;

    err = RegOpenKeyEx(
                 HKEY_LOCAL_MACHINE,
                 REGISTRY_SERVICES_KEY_A,
                 0,
                 KEY_READ,
                 &hkeyService
                 );

    if (err != ERROR_SUCCESS) {

        IIS_PRINTF((buff,
            "Inetinfo: Failed to open service key: %ld\n", err));

        goto Cleanup;
    }

    err = RegOpenKeyEx(
                 hkeyService,
                 pszService,
                 0,
                 KEY_READ,
                 &hkey
                 );

    if (err != ERROR_SUCCESS) {

        IIS_PRINTF((buff,
            "Inetinfo: Failed to open service key for %s: %ld\n",
                pszService, err));

        goto Cleanup;
    }

    nBytes = cbDllName;

    err = RegQueryValueEx(
                hkey,
                REGISTRY_VALUE_IISSERVICE_DLL_PATH_NAME_A,
                NULL,
                &valType,
                (LPBYTE)pszDllName,
                &nBytes);

    if ( err == ERROR_SUCCESS &&
         ( valType == REG_SZ || valType == REG_EXPAND_SZ ) )
    {
        IIS_PRINTF((buff,
            "Service Dll is %s", pszDllName));

        ret = TRUE;
    }

Cleanup:

    if (hkey != NULL) {
        RegCloseKey( hkey );
    }

    if (hkeyService != NULL) {
        RegCloseKey( hkeyService );
    }

    return ret;
}

VOID
InetinfoStartService (
    IN DWORD argc,
    IN LPSTR argv[]
    )

/*++

Routine Description:

    This routine loads the DLL that contains a service and calls its
    main routine.

Arguments:

    DllName - name of the DLL

    argc, argv - Passed through to the service

Return Value:

    None.

--*/

{
    HMODULE dllHandle;
    PINETSVCS_SERVICE_DLL_ENTRY serviceEntry;
    BOOL ok;
    DWORD Error;
    CHAR tmpDllName[MAX_PATH+1];
    LPSTR DllName;
    DWORD dwIndex;

    //
    // Find the Dll Name for requested service
    //

    dwIndex = FindEntryFromDispatchTable( argv[0] );
    if ( dwIndex == 0xFFFFFFFF )
    {
        if ( GetDLLNameForDispatchEntryService( argv[0],
                                                tmpDllName,
                                                sizeof( tmpDllName ) ) )
        {
            IIS_PRINTF((buff,
                        "Service %s has path set in registry.  Assuming %s\n",
                        argv[0],
                        tmpDllName));
            DllName = tmpDllName;
        }
        else if ( strlen(argv[0]) < (MAX_PATH-4) )
        {
            strcpy(tmpDllName, argv[0]);
            strcat(tmpDllName, ".dll");

            IIS_PRINTF((buff,"Service %s not on primary list.  Assuming %s\n",
                argv[0], tmpDllName));
            DllName = tmpDllName;
        }
        else
        {
            Error = ERROR_INSUFFICIENT_BUFFER;
            IIS_PRINTF((buff,
                    "Inetinfo: Failed To Find Dll For %s : %ld\n",
                    argv[0], Error));
            AbortService( argv[0], Error);
            return;
        }
    }
    else
    {
        DllName = InetServiceDllTable[ dwIndex ].lpDllName;
    }

    //
    // Load the DLL that contains the service.
    //

    if ( dwIndex != 0xFFFFFFFF )
    {
        EnterCriticalSection( &( InetServiceDllTable[ dwIndex ].csLoadLock ) );
    }

    dllHandle = LoadLibraryEx( DllName, NULL, LOAD_WITH_ALTERED_SEARCH_PATH );
    if ( dllHandle == NULL )
    {
        Error = GetLastError();
        IIS_PRINTF((buff,
                 "Inetinfo: Failed to load DLL %s: %ld\n",
                 DllName, Error));
        AbortService(argv[0], Error);

        if ( dwIndex != 0xFFFFFFFF )
        {
            LeaveCriticalSection( &( InetServiceDllTable[ dwIndex ].csLoadLock ) );
        }

        return;
    }

    //
    // Get the address of the service's main entry point.  This
    // entry point has a well-known name.
    //

    serviceEntry = (PINETSVCS_SERVICE_DLL_ENTRY)GetProcAddress(
                                                dllHandle,
                                                INETSVCS_ENTRY_POINT_STRING
                                                );

    if ( serviceEntry == NULL )
    {
        Error = GetLastError();
        IIS_PRINTF((buff,
                 "Inetinfo: Can't find entry %s in DLL %s: %ld\n",
                 INETSVCS_ENTRY_POINT_STRING, DllName, Error));
        AbortService(argv[0], Error);
    } else {

        //
        // Call the service's main entry point.  This call doesn't return
        // until the service exits.
        //

        serviceEntry( argc, argv, &InetinfoGlobalData );

    }

    if ( dwIndex != 0xFFFFFFFF )
    {
        LeaveCriticalSection( &( InetServiceDllTable[ dwIndex ].csLoadLock ) );
    }

    //
    // wait for the control dispatcher routine to return.  This
    // works around a problem where simptcp was crashing because the
    // FreeLibrary() was happenning before the control routine returned.
    //

    Sleep( 500 );

    //
    // Unload the DLL.
    //

    ok = FreeLibrary( dllHandle );
    if ( !ok ) {
        IIS_PRINTF((buff,
                 "INETSVCS: Can't unload DLL %s: %ld\n",
                 DllName, GetLastError()));
    }

    return;

} // InetinfoStartService


VOID
DummyCtrlHandler(
    DWORD
    )
/*++

Routine Description:

    This is a dummy control handler which is only used if we can't load
    a services DLL entry point.  Then we need this so we can send the
    status back to the service controller saying we are stopped, and why.

Arguments:

    OpCode - Ignored

Return Value:

    None.

--*/

{
    return;

} // DummyCtrlHandler

VOID
AbortService(
    LPSTR  ServiceName,
    DWORD  Error)
/*++

Routine Description:

    This is called if we can't load the entry point for a service.  It
    gets a handle so it can call SetServiceStatus saying we are stopped
    and why.

Arguments:

    ServiceName - the name of the service that couldn't be started
    Error - the reason it couldn't be started

Return Value:

    None.

--*/
{
    SERVICE_STATUS_HANDLE GenericServiceStatusHandle;
    SERVICE_STATUS GenericServiceStatus;

    GenericServiceStatus.dwServiceType        = SERVICE_WIN32;
    GenericServiceStatus.dwCurrentState       = SERVICE_STOPPED;
    GenericServiceStatus.dwControlsAccepted   = SERVICE_CONTROL_STOP;
    GenericServiceStatus.dwCheckPoint         = 0;
    GenericServiceStatus.dwWaitHint           = 0;
    GenericServiceStatus.dwWin32ExitCode      = Error;
    GenericServiceStatus.dwServiceSpecificExitCode = 0;

    GenericServiceStatusHandle = RegisterServiceCtrlHandler(
                ServiceName,
                DummyCtrlHandler);

    if (GenericServiceStatusHandle == (SERVICE_STATUS_HANDLE)0) {

        IIS_PRINTF((buff,
                 "[Inetinfo]RegisterServiceCtrlHandler[%s] failed %d\n",
                 ServiceName, GetLastError()));

    } else if (!SetServiceStatus (GenericServiceStatusHandle,
                &GenericServiceStatus)) {

        IIS_PRINTF((buff,
                 "[Inetinfo]SetServiceStatus[%s] error %ld\n",
                 ServiceName, GetLastError()));
    }
}

VOID
StartDispatchTable(
    VOID
    )
/*++

Routine Description:

    Returns the dispatch table to use.  It uses the default if
    the DispatchEntries value key does not exist

Arguments:

    None.

Return Value:

    Pointer to the dispatch table to use.

--*/
{
    LPSERVICE_TABLE_ENTRY dispatchTable = InetServiceDispatchTable;
    LPSERVICE_TABLE_ENTRY tableEntry = NULL;

    LPBYTE buffer = NULL;
    HKEY hKey = NULL;

    DWORD i;
    DWORD err;
    DWORD valType;
    DWORD nBytes = 0;
    DWORD nEntries = 0;
    PCHAR entry;

    //
    // See if need to augment the dispatcher table
    //

    err = RegOpenKeyEx(
                 HKEY_LOCAL_MACHINE,
                 REGISTRY_KEY_INETINFO_PARAMETERS_A,
                 0,
                 KEY_READ,
                 &hKey
                 );

    if ( err != ERROR_SUCCESS ) {
        hKey = NULL;
        goto start_dispatch;
    }

    //
    // See if the value exists and get the size of the buffer needed
    //

    nBytes = 0;
    err = RegQueryValueEx(
                    hKey,
                    REGISTRY_VALUE_INETINFO_DISPATCH_ENTRIES_A,
                    NULL,
                    &valType,
                    NULL,
                    &nBytes
                    );

    if ( (err != ERROR_SUCCESS) || (nBytes < 2 * sizeof(CHAR)) )
    {
        goto start_dispatch;
    }

    //
    // Allocate nBytes to query the buffer
    //

    buffer = (LPBYTE)LocalAlloc(0, nBytes);
    if ( buffer == NULL )
    {
        goto start_dispatch;
    }

    //
    // Get the values
    //

    err = RegQueryValueEx(
                    hKey,
                    REGISTRY_VALUE_INETINFO_DISPATCH_ENTRIES_A,
                    NULL,
                    &valType,
                    buffer,
                    &nBytes
                    );

    if ( (err != ERROR_SUCCESS) ||
         (valType != REG_MULTI_SZ) ||
         (nBytes < ( 2 * sizeof(CHAR))) )
    {
        LocalFree(buffer);
        buffer = NULL;
        goto start_dispatch;
    }

    // Make sure that it is doubly null terminated just to be safe.
    buffer[nBytes/(sizeof(CHAR))-1] = '\0';
    buffer[nBytes/(sizeof(CHAR))-2] = '\0';

    //
    // Walk the list and see how many entries we have. Remove the list
    // terminator from the byte count
    //

    nBytes -= sizeof(CHAR);
    for ( i = 0, entry = (PCHAR)buffer;
        i < nBytes;
        i += sizeof(CHAR) )
   {
        if ( *entry++ == '\0' )
        {
            nEntries++;
        }
    }

    if ( nEntries == 0 )
    {
        LocalFree(buffer);
        buffer = NULL;

        goto start_dispatch;
    }

    //
    // Add the number of entries in the default list (including the NULL entry)
    //

    nEntries += sizeof(InetServiceDispatchTable) / sizeof(SERVICE_TABLE_ENTRY);

    //
    // Now we need to allocate the new dispatch table
    //

    tableEntry = (LPSERVICE_TABLE_ENTRY)
        LocalAlloc(0, nEntries * sizeof(SERVICE_TABLE_ENTRY));

    if ( tableEntry == NULL )
    {
        LocalFree(buffer);
        buffer = NULL;
        goto start_dispatch;
    }

    //
    // set the dispatch table pointer to the new table
    //

    dispatchTable = tableEntry;

    //
    // Populate the table starting with the defaults
    //

    for (i=0; InetServiceDispatchTable[i].lpServiceName != NULL; i++ )
    {
        tableEntry->lpServiceName =
            InetServiceDispatchTable[i].lpServiceName;
        tableEntry->lpServiceProc =
            InetServiceDispatchTable[i].lpServiceProc;
        tableEntry++;
    }

    //
    // Now let's add the ones specified in the registry
    //

    entry = (PCHAR)buffer;

    tableEntry->lpServiceName = entry;
    tableEntry->lpServiceProc = InetinfoStartService;
    tableEntry++;

    //
    // Skip the first char and the last NULL terminator.
    // This is needed because we already added the first one.
    //

    for ( i = 2*sizeof(CHAR); i < nBytes; i += sizeof(CHAR) )
    {
        if ( *entry++ == '\0' )
        {
            tableEntry->lpServiceName = entry;
            tableEntry->lpServiceProc = InetinfoStartService;
            tableEntry++;
        }
    }

    //
    // setup sentinel entry
    //

    tableEntry->lpServiceName = NULL;
    tableEntry->lpServiceProc = NULL;

start_dispatch:

    if ( hKey != NULL )
    {
        RegCloseKey(hKey);
    }

    W3SVCLauncher* pLauncher = new W3SVCLauncher();
    if (pLauncher==NULL)
    {
        err = GetLastError();

        IIS_PRINTF((buff,
                 "Inetinfo: Can not launch the W3SVC launching class %lu\n",
                  err));

        goto exit;
    }
    else
    {
        err = pLauncher->StartListening();
        if ( err != ERROR_SUCCESS )
        {
            //
            // If there is an error we
            // will let iisadmin come up
            // but w3svc will not be able
            // to launch in BC mode.
            //
            delete pLauncher;
            pLauncher = NULL;
            err = ERROR_SUCCESS;
        }
    }

    //
    // Call StartServiceCtrlDispatcher to set up the control interface.
    // The API won't return until all services have been terminated. At that
    // point, we just exit.
    //

    if (! StartServiceCtrlDispatcher (
                dispatchTable
                )) {
        //
        // Log an event for failing to start control dispatcher
        //

        IIS_PRINTF((buff,
                 "Inetinfo: Failed to start control dispatcher %lu\n",
                  GetLastError()));

    }

    if ( pLauncher )
    {
        pLauncher->StopListening();
        delete pLauncher;
        pLauncher = NULL;
    }

exit:

    // Now that we have returned from the StartServiceCtrlDispatcher it means
    // that even IISAdmin has shutdown.  This means that W3svc is no longer running
    // and that we do not need to keep listening for WAS to tell us to start W3WP.
    // Therefore we need to single the thread to complete so that inetinfo.exe shutsdown
    // correctly.

    //
    // free table if allocated
    //

    if ( dispatchTable != InetServiceDispatchTable )
    {
        LocalFree( dispatchTable );

        if ( buffer )
        {
            LocalFree( buffer );
            buffer = NULL;
        }
    }

    return;

} // StartDispatchTable




BOOL
LoadPreloadDlls(
    HMODULE * * ppPreloadDllHandles
    )
/*++

Routine Description:

    Force pre-loading of any DLLs listed in the associated registry key.
    This is to support DLLs that have code which must run before other parts
    of inetinfo start.

Arguments:

    On input, an (uninitialized) pointer to an array of module handles. This
    array is allocated, filled out, and returned to the caller by this
    function. The caller must eventually call UnloadPreloadDlls on this array
    in order to close the handles and release the memory.

Return Value:

    TRUE on success, FALSE on failure.

--*/
{
    BOOL bSuccess = TRUE;
    HKEY hKey = NULL;
    DWORD err;
    DWORD cbBufferLen;
    DWORD valType;
    LPBYTE pbBuffer = NULL;
    DWORD i;
    PCHAR pszTemp = NULL;
    DWORD nEntries;
    PCHAR pszEntry = NULL;
    DWORD curEntry;


    *ppPreloadDllHandles = NULL;


    err = RegOpenKeyEx(
                 HKEY_LOCAL_MACHINE,
                 REGISTRY_KEY_INETINFO_PARAMETERS_A,
                 0,
                 KEY_QUERY_VALUE,
                 &hKey
                 );

    if ( err != ERROR_SUCCESS )
    {
        // Note: not considered an error if the key is not there

        hKey = NULL;

        goto Exit;
    }


    //
    // See if the value exists and get the size of the buffer needed
    //

    cbBufferLen = 0;

    err = RegQueryValueEx(
                    hKey,
                    REGISTRY_VALUE_INETINFO_PRELOAD_DLLS_A,
                    NULL,
                    &valType,
                    NULL,
                    &cbBufferLen
                    );

    //
    // Check for no value or an empty value (double null terminated).
    //
    if ( ( err != ERROR_SUCCESS ) || ( cbBufferLen <= 2 * sizeof(CHAR) ) )
    {
        // Note: not considered an error if the value is not there

        goto Exit;
    }

    //
    // Allocate cbBufferLen in order to fetch the data
    //

    pbBuffer = (LPBYTE)LocalAlloc(
                        0,
                        cbBufferLen
                        );

    if ( pbBuffer == NULL )
    {
        bSuccess = FALSE;
        goto Exit;
    }

    //
    // Get the values
    //

    err = RegQueryValueEx(
                    hKey,
                    REGISTRY_VALUE_INETINFO_PRELOAD_DLLS_A,
                    NULL,
                    &valType,
                    pbBuffer,
                    &cbBufferLen
                    );

    if ( ( err != ERROR_SUCCESS )
         || ( valType != REG_MULTI_SZ )
         || ( cbBufferLen <= 2 * sizeof(CHAR) ))
    {
        bSuccess = FALSE;
        goto Exit;
    }

    // Make sure that it is doubly null terminated just to be safe.
    pbBuffer[cbBufferLen/(sizeof(CHAR))-1] = '\0';
    pbBuffer[cbBufferLen/(sizeof(CHAR))-2] = '\0';

    //
    // Walk the list and see how many entries we have. Ignore the list
    // terminator in the last byte of the buffer.
    //

    nEntries = 0;
    pszTemp = (PCHAR)pbBuffer;

    for ( i = 0; i < ( cbBufferLen - sizeof(CHAR) ) ; i += sizeof(CHAR) )
    {
        if ( *pszTemp == '\0' )
        {
            nEntries++;
        }

        pszTemp++;
    }


    //
    // Allocate the array of handles, with room for a sentinel entry
    //

    *ppPreloadDllHandles = (HMODULE *)LocalAlloc(
                                            0,
                                            ( nEntries + 1 ) * sizeof(HMODULE)
                                            );

    if ( *ppPreloadDllHandles == NULL )
    {
        bSuccess = FALSE;
        goto Exit;
    }


    //
    // Now attempt to load each DLL, and save the handle in the array
    //

    pszTemp = (PCHAR)pbBuffer;
    pszEntry = (PCHAR)pbBuffer;
    curEntry = 0;

    for ( i = 0; i < ( cbBufferLen - sizeof(CHAR) ) ; i += sizeof(CHAR) )
    {
        if ( *pszTemp == '\0' )
        {
            //
            // We've hit the end of one of the SZs in the Multi-SZ;
            // Load the DLL
            //

            (*ppPreloadDllHandles)[curEntry] = LoadLibrary( pszEntry );

            if ( (*ppPreloadDllHandles)[curEntry] == NULL )
            {
                IIS_PRINTF(( buff, "Preloading FAILED for DLL: %s\n", pszEntry ));
            }
            else
            {
                IIS_PRINTF(( buff, "Preloaded DLL: %s\n", pszEntry ));

                // Only move to the next slot if we got a valid handle
                curEntry++;
            }


            // Set the next entry pointer past the current null char
            pszEntry = pszTemp + sizeof(CHAR);
        }

        pszTemp++;
    }


    // Put in a sentinel at the end of the array

    (*ppPreloadDllHandles)[curEntry] = NULL;


Exit:

    if ( hKey != NULL )
    {
        RegCloseKey( hKey );
    }

    if ( pbBuffer != NULL )
    {
        LocalFree( pbBuffer );
    }


    return bSuccess;

} // LoadPreloadDlls


VOID
UnloadPreloadDlls(
    HMODULE * * ppPreloadDllHandles
    )
/*++

Routine Description:

    Unload any DLLs which were preloaded by LoadPreloadDlls.

Arguments:

    Pointer to an array of module handles. Each handle will be freed,
    and then the memory of the array will be LocalFree()ed by this function.

Return Value:

    None.

--*/
{
    HMODULE * pHandleArray = *ppPreloadDllHandles;

    if ( pHandleArray != NULL )
    {

        IIS_PRINTF(( buff, "Unloading Preloaded DLLs\n" ));


        while ( *pHandleArray != NULL )
        {
            FreeLibrary( *pHandleArray );

            pHandleArray++;
        }


        LocalFree( *ppPreloadDllHandles );

        *ppPreloadDllHandles = NULL;
    }

    return;

} // UnloadPreloadDlls
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\inc\thread_pool.h ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    thread_pool.h

Abstract:

    Public routines for the iisplus worker process thread pool.

    This thread pool is based on the IIS5 atq implementation.

Author:

    Taylor Weiss (TaylorW)       12-Jan-2000

Revision History:

--*/

#ifndef _THREAD_POOL_H_
#define _THREAD_POOL_H_

//
// For the static library version of w3tp, the consumer must set
// this value to be the HINSTANCE of the DLL linking w3tp_static
//
extern HMODULE g_hmodW3TPDLL;

//
// ThreadPoolBindIoCompletionCallback:
//
// The real public API. Clients that wish to queue io completions
// to the process Thread Pool should use this call as they would
// the NT5 thread pool call.
//

BOOL
ThreadPoolBindIoCompletionCallback(
    IN HANDLE FileHandle,                         // handle to file
    IN LPOVERLAPPED_COMPLETION_ROUTINE Function,  // callback
    IN ULONG Flags                                // reserved
    );

//
// ThreadPoolPostCompletion:
//
// Use this function to get one of the process worker threads
// to call your completion function.
//

BOOL ThreadPoolPostCompletion(
    IN DWORD dwBytesTransferred,
    IN LPOVERLAPPED_COMPLETION_ROUTINE Function,
    IN LPOVERLAPPED lpo
    );


// forward declarations
enum THREAD_POOL_INFO;
class THREAD_POOL_DATA;
struct THREAD_POOL_CONFIG;

//
// To use a thread pool other than the per process thread pool
// Use the class THREAD_POOL instead of the global functions
//
class dllexp THREAD_POOL
{
public:
    static BOOL CreateThreadPool(OUT THREAD_POOL ** ppThreadPool,
                                 IN THREAD_POOL_CONFIG * pThreadPoolConfig);
    VOID TerminateThreadPool();

    BOOL BindIoCompletionCallback(IN HANDLE hFileHandle,
                                  IN LPOVERLAPPED_COMPLETION_ROUTINE function,
                                  IN ULONG flags);

    BOOL PostCompletion(IN DWORD dwBytesTransferred,
                        IN LPOVERLAPPED_COMPLETION_ROUTINE function,
                        IN LPOVERLAPPED lpo);

    ULONG_PTR SetInfo(IN THREAD_POOL_INFO InfoId,
                      IN ULONG_PTR        Data);

private:
    // use create and terminate
    THREAD_POOL();
    ~THREAD_POOL();

    // not implemented
    THREAD_POOL(const THREAD_POOL&);
    THREAD_POOL& operator=(const THREAD_POOL&);

    // private data
    THREAD_POOL_DATA * m_pData;
};


struct THREAD_POOL_CONFIG
{

    // the initial number of threads to have in the pool
    // valid values are 1->DWORD_MAX
    DWORD dwInitialThreadCount;

    // the absolute maximum number of threads to ever have in the thread pool
    DWORD dwAbsoluteMaximumThreadCount;

    // the number of threads to allow without calling SetInfo(ThreadPoolIncMaxPoolThreads)
    // before doing synchronous operations
    DWORD dwSoftLimitThreadCount;

    // How long a thread should stay alive if no I/O completions have occurred for it.
    DWORD dwThreadTimeout;
    
    // initial stack size for thread creation.  Zero will create a default process stack size.
    DWORD dwInitialStackSize;

    // CPU usage backoff numebr
    DWORD dwMaxCPUUsage;

    // Maximum CPU concurrency.  Zero will equal the # of processors
    DWORD dwConcurrency;

    // Per second per processor context switch rate maximum.
    // we double this number for # of processors > 1
    DWORD dwPerSecondContextSwitchMax;

    // Before we create a thread, we sample on two sides of a timer
    // this determines what the timer period is.
    DWORD dwTimerPeriod;

    // The exact number of threads to create
    // If this is set to something, no new threads will ever be created beyond the startup count here.
    DWORD dwExactThreadCount;

    // Just some padding to avoid changing a public structure size
    // when additional variables are added here
    DWORD dwPadding[10];
    
};

// to get some reasonable defaults for thread pool configuration
HRESULT
InitializeThreadPoolConfigWithDefaults(THREAD_POOL_CONFIG * pThreadPoolConfig);

//
// Override defaults with registry settings
//

HRESULT
OverrideThreadPoolConfigWithRegistry(
    IN OUT THREAD_POOL_CONFIG * pThreadPoolConfig,
    IN     WCHAR * pszRegistryPath );


//
// Configuration API calls. ONLY ULATQ should call these.
//

HRESULT
ThreadPoolInitialize( DWORD cbInitialStackSize );

HRESULT
ThreadPoolTerminate( VOID );

ULONG_PTR
ThreadPoolSetInfo(
    IN THREAD_POOL_INFO InfoId,
    IN ULONG_PTR        Data
    );

//
// IDs for getting and setting configuration options
//
enum THREAD_POOL_INFO
{
    ThreadPoolIncMaxPoolThreads, // Up the max thread count - set only
    ThreadPoolDecMaxPoolThreads, // Decrease the max thread count - set only
};

#endif // !_THREAD_POOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\isapips\iisapicore_i_stub.c ===
#include "IIsapiCore_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\inetinfo\waslaunch.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    waslaunch.cxx

Abstract:

    These are the classes used to communicate between
    inetinfo and WAS for launching a worker process in
    inetinfo.

Author:

    Emily Kruglick (EmilyK) 14-Jun-2000

Revision History:

--*/

//
// INCLUDES
//
#include <iis.h>
#include <winsvc.h>             // Service control APIs
#include <rpc.h>
#include <stdlib.h>
#include <inetsvcs.h>
#include <iis64.h>
#include <wpif.h>
#include "waslaunch.hxx"
#include "regconst.h"
#include "secfcns.h"
#include "helpfunc.hxx"
#include <objbase.h>

//
// System related headers
//
#include "dbgutil.h"
#include "pudebug.h"

#include "ulw3.h"
#include "string.hxx"

// for the well known pipename
#include "pipedata.hxx"

DECLARE_DEBUG_VARIABLE();

class DEBUG_WRAPPER {

public:
    DEBUG_WRAPPER( IN LPCSTR pszModule)
    {
        UNREFERENCED_PARAMETER( pszModule );
        CREATE_DEBUG_PRINT_OBJECT(pszModule);
    }

    ~DEBUG_WRAPPER(void)
    { 
        DELETE_DEBUG_PRINT_OBJECT(); 
    }
};

VOID LaunchWorkerProcess()
{
    DEBUG_WRAPPER   dbgWrapper( "w3wp" );
    HRESULT         hr = S_OK;
    HMODULE         hModule = NULL;
    PFN_ULW3_ENTRY  pEntry = NULL;
    
    BUFFER  bufIPMName;
    DWORD   cbNeeded = bufIPMName.QuerySize();

    // This should all be there because we have all ready gotten the iisadmin interface.
    // So inetinfo should of setup all the event stuff by now.
    hr = ReadStringParameterValueFromAnyService( REGISTRY_KEY_W3SVC_PARAMETERS_W,
                                                 REGISTRY_VALUE_INETINFO_W3WP_IPM_NAME_W,
                                                 (LPWSTR) bufIPMName.QueryPtr(),
                                                 &cbNeeded );

    if ( hr == HRESULT_FROM_WIN32( ERROR_MORE_DATA ))
    {
        if ( !bufIPMName.Resize(cbNeeded) )
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = ReadStringParameterValueFromAnyService( REGISTRY_KEY_W3SVC_PARAMETERS_W,
                                                         REGISTRY_VALUE_INETINFO_W3WP_IPM_NAME_W,
                                                         (LPWSTR) bufIPMName.QueryPtr(),
                                                         &cbNeeded );
        }
    }

    if ( FAILED ( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error getting name of the ipm to use.  Error = %d\n",
                    GetLastError() ));

        goto Finished;
    }


    // Establish the parameters to pass in when starting
    // the worker process inside inetinfo.
    LPWSTR lpParameters[] =
    {
          { L"" }
        , { L"-a" }
        , { (LPWSTR) bufIPMName.QueryPtr() }
        , { L"-ap" }
        , { L"DefaultAppPool" }
    };
    DWORD cParameters = 5;

    //
    // Load the ULW3 DLL which does all the work
    //

    hModule = LoadLibraryW( ULW3_DLL_NAME );
    if ( hModule == NULL )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error loading W3 service dll '%ws'.  Error = %d\n",
                    ULW3_DLL_NAME,
                    GetLastError() ));
        goto Finished;
    }

    pEntry = (PFN_ULW3_ENTRY) GetProcAddress( hModule,
                                              ULW3_DLL_ENTRY );
    if ( pEntry == NULL )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Could not find entry point '%s'.  Error = %d\n",
                    ULW3_DLL_ENTRY,
                    GetLastError() ));
        goto Finished;
    }

    hr = pEntry( cParameters,
                 lpParameters,
                 TRUE );                    // Compatibility mode = TRUE
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error executing W3WP.  hr = %x\n",
                    hr ));

        goto Finished;
    }

Finished:

    if ( hModule != NULL )
    {
        FreeLibrary( hModule );
    }

}

DWORD WaitOnIISAdminStartup(W3SVCLauncher* pLauncher)
{
    DWORD dwErr = ERROR_SUCCESS;
    BOOL  IISAdminIsStarted = FALSE;
    SC_HANDLE hService = NULL;
    SERVICE_STATUS ServiceStatus;

    SC_HANDLE hManager = OpenSCManager(NULL, NULL, GENERIC_READ);
    if ( hManager == NULL )
    {
        dwErr = GetLastError();
        IIS_PRINTF((buff,
             "Failed to open the scm manager, can't wait on iisadmin %x\n",
              HRESULT_FROM_WIN32(dwErr)));

        goto exit;
    };

    hService = OpenServiceA( hManager, "IISADMIN", SERVICE_QUERY_STATUS);
    if ( hService == NULL )
    {
        dwErr = GetLastError();
        goto exit;
    };

    //
    // Make sure iisadmin has not started, and also verify that we are
    // still running ( so we don't hang the thread ).
    //
    while  ( !IISAdminIsStarted && pLauncher->StillRunning() )
    {

        if ( QueryServiceStatus( hService, &ServiceStatus ) )
        {
            if ( ServiceStatus.dwCurrentState == SERVICE_RUNNING )
            {
                IISAdminIsStarted = TRUE;
            }
            else
            {
                Sleep ( 1000 );
            }
        }
        else
        {
            dwErr = GetLastError();
            goto exit;
        }

    }; // end of loop

exit:

    if  ( hService )
    {
        CloseServiceHandle ( hService );
        hService = NULL;
    };

    if  ( hManager )
    {
        CloseServiceHandle ( hManager );
        hManager = NULL;
    };

    return dwErr;
};

// Global Functions.
DWORD WINAPI W3SVCThreadEntry(LPVOID lpParameter)
{
    W3SVCLauncher* pLauncher = (W3SVCLauncher*) lpParameter;
    DWORD   dwErr = ERROR_SUCCESS;

    dwErr = WaitOnIISAdminStartup(pLauncher);

    DBG_ASSERT (pLauncher);
    if ( pLauncher && dwErr == ERROR_SUCCESS )
    {
        // Wait on the W3SVCStartW3SP
        // If we are in shutdown mode just end, otherwise launch W3WP and wait
        // for it to return.  Then loop back around.

        while (pLauncher->StillRunning())
        {
            // Do not care what the wait returns, just know that we did signal so we should
            // either end or start a W3WP in inetinfo.
            WaitForSingleObject(pLauncher->GetLaunchEvent(), INFINITE);

            // Once inetinfo has heard the event reset it.
            if (!ResetEvent(pLauncher->GetLaunchEvent()))
            {
                dwErr = GetLastError();
                IIS_PRINTF((buff,
                     "Inetinfo: Failed to reset the event %x\n",
                      HRESULT_FROM_WIN32(dwErr)));
                break;
            }

            // Assuming we are still running we need
            // to start up the W3WP code now.
            if (pLauncher->StillRunning())
            {
                LaunchWorkerProcess();
            }


        }
    }

    return dwErr;
};

W3SVCLauncher::W3SVCLauncher() :
    m_hW3SVCThread (NULL),
    m_hW3SVCStartEvent(NULL),
    m_dwW3SVCThreadId(0),
    m_bShutdown(FALSE)
{};


DWORD 
W3SVCLauncher::StartListening()
{
    DWORD err = ERROR_SUCCESS;
    DWORD iCount = 0;
    STRU  strFullName;

    // Make sure this function is not called twice
    // without a StopListening in between.
    DBG_ASSERT (m_hW3SVCStartEvent == NULL);
    DBG_ASSERT (m_hW3SVCThread == NULL);

    do 
    {
        err = GenerateNameWithGUID( WEB_ADMIN_SERVICE_START_EVENT_W,
                                    &strFullName );
        if ( err != ERROR_SUCCESS )
        {
            goto exit;
        }

        m_hW3SVCStartEvent = CreateEventW(NULL, TRUE, FALSE, strFullName.QueryStr());
        if (m_hW3SVCStartEvent != NULL)
        {
            if ( GetLastError() == ERROR_ALREADY_EXISTS )
            {
                CloseHandle( m_hW3SVCStartEvent );
                m_hW3SVCStartEvent = NULL;
                err = ERROR_ALREADY_EXISTS;
            }
        }
        else
        {
            err = GetLastError();
        }

        // Just counting to make sure we don't loop forever.
        iCount++;

    } while ( m_hW3SVCStartEvent == NULL && iCount < 10 );


    if ( m_hW3SVCStartEvent == NULL )
    {
        IIS_PRINTF((buff,
                 "Inetinfo: Failed to create the W3SVC shutdown event so we can not start W3svc %lu\n",
                  err));

        DBG_ASSERT ( err != ERROR_SUCCESS );

        goto exit;
    }

    // At this point we know we have the event name, so we can write it to the registry.
    err = SetStringParameterValueInAnyService(
                REGISTRY_KEY_IISADMIN_W, 
                REGISTRY_VALUE_IISADMIN_W3CORE_LAUNCH_EVENT_W,
                strFullName.QueryStr() );

    if ( err != ERROR_SUCCESS )
    {
        CloseHandle( m_hW3SVCStartEvent );
        m_hW3SVCStartEvent = NULL;

        goto exit;
    }

    // Before going off to the Service Controller set up a thread
    // that will allow WAS to contact inetinfo.exe if we need to start
    // w3wp inside of it for backward compatibility.

    m_hW3SVCThread = CreateThread(   NULL           // use current threads security
                                        // Big initial size to prevent stack overflows
                                        , IIS_DEFAULT_INITIAL_STACK_SIZE
                                        , &W3SVCThreadEntry
                                        , this      // pass this object in.
                                        , 0         // don't create suspended
                                        , &m_dwW3SVCThreadId);
    if (m_hW3SVCThread == NULL)
    {
        err = GetLastError();
        
        IIS_PRINTF((buff,
             "Inetinfo: Failed to start W3SVC listening thread %lu\n",
              err));

    }

exit:

    return err;
};

VOID W3SVCLauncher::StopListening()
{
    if (m_hW3SVCStartEvent && m_hW3SVCThread)
    {
        m_bShutdown = TRUE;
        if (!SetEvent(m_hW3SVCStartEvent))
        {
            IIS_PRINTF((buff, "Inetinfo: Failed to shutdown the W3SVC waiting thread %lu\n",
                        GetLastError()));
        }

        // Now wait on the thread to exit, so we don't allow
        // the caller to delete this object
        // before the thread is done deleting it's pieces.

        // BUGBUG: adjust the wait time to like 2 minutes
        // and use TerminateThread if we timeout.
        WaitForSingleObject(m_hW3SVCThread, INFINITE);
        CloseHandle(m_hW3SVCThread);
        m_hW3SVCThread = NULL;

    }

    // Close down our handle to this event,
    // so the kernel can release it.
    if (m_hW3SVCStartEvent)
    {
        CloseHandle(m_hW3SVCStartEvent);
        m_hW3SVCStartEvent = NULL;
    }

};

BOOL W3SVCLauncher::StillRunning()
{
    return (m_bShutdown == FALSE);
}

HANDLE W3SVCLauncher::GetLaunchEvent()
{
    DBG_ASSERT(m_hW3SVCStartEvent);
    return (m_hW3SVCStartEvent);
}

W3SVCLauncher::~W3SVCLauncher()
{
    // Stop Listening should of been called first
    // which should of freed all of this.
    DBG_ASSERT(m_hW3SVCStartEvent == NULL);
    DBG_ASSERT(m_hW3SVCThread == NULL);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\isapips\dlldata_stub.c ===
#include "dlldata.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\isapips\iisapicore_p_stub.c ===
#include "IIsapiCore_p.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\logging\logging.cxx ===
#include "precomp.hxx"
#define DLL_IMPLEMENTATION
#include <initguid.h>
#include <ilogobj.hxx>
#include <http.h>
#include <httpp.h>
#include "logging.h"
#include "colog.hxx"

DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();
DECLARE_PLATFORM_TYPE();

#define LOGGING_SIGNATURE      'GGOL'
#define LOGGING_SIGNATURE_FREE 'fgol'

CHAR g_pszComputerName[MAX_COMPUTERNAME_LENGTH + 1];

LOGGING::LOGGING()
    : m_fUlLogType (FALSE),
      m_pComponent (NULL),
      m_cRefs      (1),
      m_Signature  (LOGGING_SIGNATURE)
{}

LOGGING::~LOGGING()
{
    m_Signature = LOGGING_SIGNATURE_FREE;

    //
    // end of logging object
    //
    if (m_pComponent != NULL)
    {
        m_pComponent->TerminateLog();
        m_pComponent->Release();
        m_pComponent = NULL;
    }
}

VOID LOGGING::AddRef()
{
    InterlockedIncrement(&m_cRefs);
}

VOID LOGGING::Release()
{
    DBG_ASSERT(m_cRefs > 0);

    if (InterlockedDecrement(&m_cRefs) == 0)
    {
        delete this;
    }
}

HRESULT LOGGING::ActivateLogging(IN LPCSTR  pszInstanceName,
                                 IN LPCWSTR pszMetabasePath,
                                 IN IMSAdminBase *pMDObject,
                                 IN BOOL fDoCentralBinaryLogging)
{
    HRESULT hr = S_OK;
    DWORD   cbSize;
    STACK_STRU (strPlugin, 64);
    BOOL fInitializedLog = FALSE;
    STACK_STRA (strMetabasePath, 24);

    MB mb(pMDObject);
    if (!mb.Open(pszMetabasePath))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    //
    // If Logging is disabled, bail
    //
    DWORD dwLogType;
    if (mb.GetDword(L"", MD_LOG_TYPE, IIS_MD_UT_SERVER, &dwLogType))
    {
        if (dwLogType == MD_LOG_TYPE_DISABLED)
        {
            DBGPRINTF((DBG_CONTEXT, "Site %S has logging disabled\n",
                       pszInstanceName));
            hr = S_OK;
            goto Exit;
        }
    }

    if (fDoCentralBinaryLogging)
    {
        m_fUlLogType = TRUE;
        hr = S_OK;
        goto Exit;
    }

    if (!mb.GetStr(L"", MD_LOG_PLUGIN_ORDER, IIS_MD_UT_SERVER, &strPlugin))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }
    mb.Close();

    //
    // Check if it is one of the built-in logging type handled by UL
    //
    if (!_wcsicmp(strPlugin.QueryStr(), NCSALOG_CLSID) ||
        !_wcsicmp(strPlugin.QueryStr(), ASCLOG_CLSID) ||
        !_wcsicmp(strPlugin.QueryStr(), EXTLOG_CLSID))
    {
        m_fUlLogType = TRUE;
        hr = S_OK;
        goto Exit;
    }
    m_fUlLogType = FALSE;

    //
    // It is custom/ODBC logging.  We handle it in usermode
    //
    CLSID clsid;
    if (FAILED(hr = CLSIDFromString(strPlugin.QueryStr(), &clsid)))
    {
        DBGPRINTF((DBG_CONTEXT, "Could not convert string %S to CLSID\n",
                   strPlugin.QueryStr()));
        goto Exit;
    }

    LPUNKNOWN punk;
    if (FAILED(hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER,
                                     IID_IUnknown, (void **)&punk)))
    {
        DBGPRINTF((DBG_CONTEXT, "Could not create instance of %S\n",
                   strPlugin.QueryStr()));
        goto Exit;
    }

    hr = punk->QueryInterface(IID_ILogPlugin, (void **)&m_pComponent);
    punk->Release();

    if (FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Failed to get interface for %S\n",
                   strPlugin.QueryStr()));
        goto Exit;
    }

    if (FAILED(hr = strMetabasePath.CopyW(pszMetabasePath)))
    {
        goto Exit;
    }

    if (FAILED(hr = m_pComponent->InitializeLog(pszInstanceName,
                                                strMetabasePath.QueryStr(),
                                                (PCHAR)pMDObject)))
    {
        goto Exit;
    }
    fInitializedLog = TRUE;

    //
    // Make it at least MAX_PATH before the first call
    //
    if (!m_mszExtraLoggingFields.Resize(MAX_PATH))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }
    cbSize = m_mszExtraLoggingFields.QuerySize();
    if (FAILED(m_pComponent->QueryExtraLoggingFields(
                   &cbSize,
                   m_mszExtraLoggingFields.QueryStr())))
    {
        if (!m_mszExtraLoggingFields.Resize(cbSize))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }

        cbSize = m_mszExtraLoggingFields.QuerySize();
        if (FAILED(hr = m_pComponent->QueryExtraLoggingFields(
                            &cbSize,
                            m_mszExtraLoggingFields.QueryStr())))
        {
            goto Exit;
        }
    }
    m_mszExtraLoggingFields.RecalcLen();

 Exit:
    if (FAILED(hr))
    {
        if (m_pComponent != NULL)
        {
            if (fInitializedLog)
            {
                m_pComponent->TerminateLog();
            }

            m_pComponent->Release();
            m_pComponent = NULL;
        }

        m_fUlLogType = FALSE;
    }

    return hr;
}


void LOGGING::LogInformation(
                  IN LOG_CONTEXT *pInetLogInfo)
{
    CInetLogInformation inetLog;

    inetLog.CanonicalizeLogRecord(pInetLogInfo);

    m_pComponent->LogInformation(&inetLog);
}


// static
HRESULT LOGGING::Initialize()
/*++

Routine Description:
    Initialize the logging object by loading the ComLog dll and
    set up all the dll entry point

Return Value:
    HRESULT
--*/
{
    DWORD cbSize = sizeof g_pszComputerName;
    if (!GetComputerNameA(g_pszComputerName, &cbSize))
    {
        strcpy(g_pszComputerName, "<Server>");
    }

    return S_OK;
}

// static
VOID LOGGING::Terminate()
{
    // nothing to do now
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\logging\logobj.cxx ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :
        logobj.cxx

   Abstract:
        Log COM Object

   Author:

       Johnson Apacible (JohnsonA)      02-April-1997


--*/

#include "precomp.hxx"
#define DLL_IMPLEMENTATION
#include <ilogobj.hxx>
#include <http.h>
#include <httpp.h>
#include "logging.h"
#include "colog.hxx"

LPSTR ReturnStringInfo(LPSTR   pBuf,
                       LPDWORD pcbBuf,
                       LPCSTR  pszInfo,
                       DWORD   cchInfo)
/*--
    Support the weird custom logging semantics.  Do the copy of the
    string from the value we have to the buffer provided if it is big
    enough or return the value if no buffer is provided
++*/
{
    if (pBuf != NULL)
    {
        if (*pcbBuf >= cchInfo)
        {
            memcpy(pBuf, pszInfo, cchInfo);
        }
        else
        {
            *pcbBuf = cchInfo;
            return NULL;
        }
    }

    *pcbBuf = cchInfo;
    return (LPSTR) pszInfo;
}


LPSTR STDMETHODCALLTYPE
CInetLogInformation::GetSiteName(IN PCHAR    pszSiteName,
                                 IN PDWORD   pcbSize)
{
    return ReturnStringInfo(pszSiteName,
                            pcbSize,
                            m_pLogContext->QueryUlLogData()->ServiceName,
                            m_pLogContext->QueryUlLogData()->ServiceNameLength);
} // GetSiteName


LPSTR STDMETHODCALLTYPE
CInetLogInformation::GetComputerName(IN PCHAR    pszComputerName,
                                     IN PDWORD   pcbSize)
{
    return ReturnStringInfo(pszComputerName,
                            pcbSize,
                            g_pszComputerName,
                            (DWORD)strlen(g_pszComputerName));
} // GetComputerName


LPSTR STDMETHODCALLTYPE
CInetLogInformation::GetClientHostName(IN PCHAR    pszClientHostName,
                                       IN PDWORD   pcbSize)
{
    return ReturnStringInfo(pszClientHostName,
                            pcbSize,
                            m_pLogContext->QueryUlLogData()->ClientIp,
                            m_pLogContext->QueryUlLogData()->ClientIpLength);
} // GetClientHostName


LPSTR STDMETHODCALLTYPE
CInetLogInformation::GetClientUserName(IN PCHAR    pszClientUserName,
                                       IN PDWORD   pcbSize)
{
    return ReturnStringInfo(pszClientUserName,
                            pcbSize,
                            m_strUserName.QueryStr(),
                            m_strUserName.QueryCCH());
} // GetClientUserName


LPSTR STDMETHODCALLTYPE
CInetLogInformation::GetServerAddress(IN PCHAR    pszServerAddress,
                                      IN PDWORD   pcbSize)
{
    return ReturnStringInfo(pszServerAddress,
                            pcbSize,
                            m_pLogContext->QueryUlLogData()->ServerIp,
                            m_pLogContext->QueryUlLogData()->ServerIpLength);
} // GetServerIPAddress


LPSTR STDMETHODCALLTYPE
CInetLogInformation::GetOperation(IN PCHAR    pszOperation,
                                  IN PDWORD   pcbSize)
{
    return ReturnStringInfo(pszOperation,
                            pcbSize,
                            m_pLogContext->QueryUlLogData()->Method,
                            m_pLogContext->QueryUlLogData()->MethodLength);
} // GetOperation


LPSTR STDMETHODCALLTYPE
CInetLogInformation::GetTarget(IN PCHAR    pszTarget,
                               IN PDWORD   pcbSize)
{
    return ReturnStringInfo(pszTarget,
                            pcbSize,
                            m_strTarget.QueryStr(),
                            m_strTarget.QueryCCH());
} // GetTarget


LPSTR STDMETHODCALLTYPE
CInetLogInformation::GetParameters(IN PCHAR    pszParameters,
                                   IN PDWORD   pcbSize)
{
    return ReturnStringInfo(pszParameters,
                            pcbSize,
                            m_pLogContext->QueryUlLogData()->UriQuery,
                            m_pLogContext->QueryUlLogData()->UriQueryLength);
} // GetParameters


LPSTR STDMETHODCALLTYPE
CInetLogInformation::GetVersionString(
    IN PCHAR    pszVersionString,
    IN PDWORD   pcbSize
    )
{
    return ReturnStringInfo(pszVersionString,
                            pcbSize,
                            m_pLogContext->m_strVersion.QueryStr(),
                            m_pLogContext->m_strVersion.QueryCCH());
} //GetVersionString


LPSTR STDMETHODCALLTYPE
CInetLogInformation::GetExtraHTTPHeaders(IN PCHAR    pszHTTPHeaders,
                                         IN PDWORD   pcbSize)
{
    return ReturnStringInfo(pszHTTPHeaders,
                            pcbSize,
                            m_pLogContext->m_mszHTTPHeaders.QueryStr(),
                            m_pLogContext->m_mszHTTPHeaders.QueryCCH());
} // GetExtraHTTPHeaders



VOID
CInetLogInformation::CanonicalizeLogRecord(
        IN LOG_CONTEXT *pInetLogRecord)
{
    m_pLogContext = pInetLogRecord;

    HTTP_LOG_FIELDS_DATA *pUlLogData = pInetLogRecord->QueryUlLogData();

    if (pUlLogData->UriStem &&
        FAILED(m_strTarget.CopyW(pUlLogData->UriStem,
                                 pUlLogData->UriStemLength / sizeof(WCHAR))))
    {
        m_strTarget.Reset();
    }

    if (pUlLogData->UserName &&
        FAILED(m_strUserName.CopyW(pUlLogData->UserName,
                                   pUlLogData->UserNameLength / sizeof(WCHAR))))
    {
        m_strUserName.Reset();
    }

} // CanonicalizeLogRecord
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\mbid\mbid.cxx ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    mbid.cxx

Abstract:

    Builds a library that defines the MB guids.

Author:

    Taylor Weiss  (TaylorW)       13-Dec-1999

Revision History:

--*/

#include <windows.h>
#include <initguid.h>
#include <iadmw.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\odbc\dbgutil.h ===
/*++

Copyright (c) 1994-1998 Microsoft Corporation

Module Name:

    dbgutil.h

Abstract:

    This module declares the macros to wrap around DEBUG_PRINTS class
    defined in pudebug.h	
  
    This is the exported header file, that the users are allowed to modify.
    If there are no custom definitions, please use the templated version
    in the root iisrearc\inc\dbgutil.h
 
Author:

    Murali R. Krishnan (MuraliK)    22-Sept-1994

--*/

# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_

// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputKdb )

// end_user_modifiable

//
// include standard debug support
//
// note: define DEFAULT_OUTPUT_FLAGS before including pudebug.h
//

# include <pudebug.h>

// begin_user_modifiable

// Use the default constants from pudebug.h: 0x00000001 to 0x00000100

//
//  Define the debugging constants as bit-flag values
//  Example: # define DEBUG_FOOBAR 0x00010000
//  Note: All debugging bit-values below 0x00001000 are reserved!
// 

#define DEBUG_ODBC                 0x02000000L
#define DEBUG_DLL_MANAGER          0x80000000L

// end_user_modifiable

# endif  /* _DBGUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\odbc\festrcnv.cxx ===
#include "precomp.hxx"

int PC_to_UNIX ( int CodePage, 
                 int CodeSet,
                 UCHAR *pPCChar, 
                 int PCChar_len,
                 UCHAR *pUNIXChar, 
                 int UNIXChar_len 
                 )

// The PC_to_UNIX function convert a character string as PC code
// set string to a UNIX code set string.
//
// int   CodePage       Country Code Page.
//                      If this value is -1, the function use OS CodePage from
//                      Operating System automatically.
//
//                      Value           Meaning
//                      -1              Auto Detect Mode.
//                      932             Japan.
//                      ???             Taiwan.
//                      ???             Korea.
//                      ???             PRC(Chaina)?
//
// int   CodeSet        Code Set Type.
//                      There are three Japanese Code set in UNIX world.
//                      These code sets are JIS, EUC and Shift JIS.
//                      When CodePage is Japanese, the following Code set
//                      constants are defined:
//
//                      Value           Meaning
//                      CODE_JPN_JIS    JIS Code Set. The function convert
//                                      pPCChar string
//                                      to a JIS code set string.
//                      CODE_JPN_EUC    EUC Code Set. The function convert
//                                      pPCChar string
//                                      to a EUC code set string.
//                      CODE_JPN_SJIS   Shift JIS Code Set.
//
// UCHAR *pPCChar       Points to the character string to be converted.
//
// int   PCChar_len     Specifies the size in bytes of the string pointed
//                      to by the pPCChar parameter. If this value is -1,
//                      the string is assumed to be NULL terminated and the
//                      length is calculated automatically.
//
//
// UCHAR *pUNIXChar     Points to a buffer that receives the convert string
//                      from PC Code to UNIX Code.
//
// int   UNIXChar_len   Specifies the size, in UNIX characters of the buffer
//                      pointed to by the pUNIXChar parameter. If the value is
//                      zero, the function returns the number of UNIX characters
//                      required for the buffer, and makes no use of the
//                      pUNIXChar buffer.
//
// Return Value
// If the function succeeds, and UNIXChar_len is nonzero, the return value is
// the number of UNIX characters written to the buffer pointed to by pUNIXChar.
//
// If the function succeeds, and UNIXChar_len is zero, the return value is the
// required size, in UNIX characters, for a buffer that can receive the
// converted string.
//
// If the function fails, the return value is -1. The error mean pUNIXChar
// buffer is small for setting converted strings.
//
//@
{
        int     re;

        if ( CodePage == -1 ) 
        {
            CodePage = ( int )GetOEMCP();
        }
        switch ( CodePage ) {
        case 932:    // Japanese Code Page
//          re = PC_to_JPNUNIX ( CodeSet, 
//                               pPCChar, 
//                               PCChar_len,
//                               pUNIXChar, 
//                               UNIXChar_len );
//          break;
//      case ???:    // Taiwan Code Page
//          re = PC_to_TAIWANUNIX (,,,,,,);
//          break;
//      case ???:    // Korea Code Page
//          re = PC_to_KOREAUNIX (,,,,,,);
//          break;
//      case ???:    // PRC Code Page
//          re = PC_to_PRCUNIX (,,,,,,);
//          break;
        default:
            // Start Only Copy Process
            if ( PCChar_len == -1 ) 
            {
                PCChar_len = strlen ( ( CHAR * )pPCChar ) + 1;
            }
            if ( UNIXChar_len != 0 ) 
            {
                if ( PCChar_len > UNIXChar_len ) 
                {  
                    // Is the buffer small?
                    return ( -1 );
                }

                memmove ( pUNIXChar, pPCChar, PCChar_len );
            }
            re = PCChar_len;
            break;
        }
        return ( re );
}

int UNIX_to_PC ( 
    int CodePage, 
    int CodeSet,
    UCHAR *pUNIXChar, 
    int UNIXChar_len,
    UCHAR *pPCChar, 
    int PCChar_len 
    )

// The UNIX_to_PC function convert a character string as UNIX code 
// set string to a PC code set string. 
//
// int   CodePage       Country Code Page.
//                      If this value is -1, the function use OS CodePage from 
//                      Operating System automatically.
//                      
//                      Value           Meaning
//                      -1              Auto Detect Mode.
//                      932             Japan.
//                      ???             Taiwan.
//                      ???             Korea.
//                      ???             PRC(Chaina)?
//                      
// int   CodeSet        Code Set Type.
//                      There are three Japanese Code set in UNIX world.
//                      These code sets are JIS, EUC and Shift JIS.
//                      When CodePage is Japanese, the following Code set
//                      constants are defined:
//                      
//                      Value           Meaning
//                      CODE_UNKNOWN    Unknown. If this value is CODE_UNKNOWN,
//                                      Code Type is checked automatically. 
//                                      
//                      CODE_JPN_JIS    JIS Code Set. The function convert 
//                                      pUNIXChar string as JIS code set string
//                                      to a PC code set string.
//                      CODE_JPN_EUC    EUC Code Set. The function convert 
//                                      pUNIXChar string as EUC code set string
//                                      to a PC code set string.
//                      CODE_JPN_SJIS   Shift JIS Code Set. 
//
// UCHAR *pUNIXChar     Points to the character string to be converted.
//
// int   UNIXChar_len   Specifies the size in bytes of the string pointed
//                      to by the pUNIXChar parameter. If this value is -1,
//                      the string is assumed to be NULL terminated and the
//                      length is calculated automatically.
//
// UCHAR *pPCChar       Points to a buffer that receives the convert string
//                      from UNIX Code to PC Code.
//         
// int   PCChar_len     Specifies the size, in PC characters of the buffer
//                      pointed to by the pPCChar parameter. If the value is zero,
//                      the function returns the number of PC characters 
//                      required for the buffer, and makes no use of the pPCChar
//                      buffer.
//
// Return Value
// If the function succeeds, and PCChar_len is nonzero, the return value is the 
// number of PC characters written to the buffer pointed to by pPCChar.
//
// If the function succeeds, and PCChar_len is zero, the return value is the
// required size, in PC characters, for a buffer that can receive the 
// converted string.
//
// If the function fails, the return value is -1. The error mean pPCChar buffer
// is small for setting converted strings.
//
//@
{
        int     re;

        if ( CodePage == -1 ) {
            CodePage = (int)GetOEMCP();
        }
        switch ( CodePage ) {
        case 932:    // Japanese Code Page
//            re = JPNUNIX_to_PC ( CodeSet, pUNIXChar, UNIXChar_len,
//                                           pPCChar, PCChar_len );
//            break;
//      case ???:    // Taiwan Code Page
//          re = TAIWANUNIX_to_PC (,,,,,,);
//          break;
//      case ???:    // Korea Code Page
//          re = KOREAUNIX_to_PC (,,,,,,);
//          break;
//      case ???:    // PRC Code Page
//          re = PRCUNIX_to_PC (,,,,,,);
//          break;
        default:
            // Start Only Copy Process
            if ( UNIXChar_len == -1 ) 
            {
                UNIXChar_len = strlen ( ( CHAR * )pUNIXChar ) + 1;
            }
            if ( PCChar_len != 0 ) 
            {
                if ( UNIXChar_len > PCChar_len ) 
                {  
                    // Is the buffer small?
                    return ( -1 );
                }

                memmove ( pPCChar, pUNIXChar, UNIXChar_len );
            }
            re = UNIXChar_len;
            break;
        }
        return ( re );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\odbc\odbcconn.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

       odbcconn.cxx

   Abstract:

       This module defines member functions for ODBC_CONNECTION object.

   Author:

       Murali R. Krishnan    ( MuraliK )     16-Feb-1995

   Environment:

       User Mode - Win32.

   Project:

       Internet Services Common DLL

   Functions Exported:

       ODBC_PARAMETER::CopyValue( IN LPCWSTR pwszValue);
       ODBC_PARAMETER::Bind( IN HSTMT hstmt);

       ODBC_STATEMENT::~ODBC_STATEMENT()
       ODBC_STATEMENT::PrepareStatement( IN LPCSTR  pszStatement)
       ODBC_STATEMENT::PrepareStatement( IN LPCWSTR pwszStatement)
       ODBC_STATEMENT::BindParameter( IN PODBC_PARAMETER pOdbcParam)
       ODBC_STATEMENT::ExecuteStatement( VOID)
       ODBC_STATEMENT::ExecDirect( IN LPCSTR pwszSqlCommand,  IN DWORD cch)
       ODBC_STATEMENT::ExecDirect( IN LPCWSTR pwszSqlCommand, IN DWORD cch)
       ODBC_STATEMENT::QueryColNames( OUT STRA * *  apstrCols,
                                      OUT DWORD *  cCols,
                                      IN  DWORD    cchMaxFieldSize = 0 );
       ODBC_STATEMENT::QueryValuesAsStr( OUT STR * *   apstrValues,
                                         OUT DWORD * * apcbValues,
                                         OUT BOOL *    pfLast );


       ODBC_CONNECTION::~ODBC_CONNECTION();
       ODBC_CONNECTION::Open();
       ODBC_CONNECTION::Close();
       ODBC_CONNECTION::GetLastErrorCode();
       ODBC_CONNECTION::AllocStatement();


   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "precomp.hxx"

#define TCP_ALLOC(cb)             (VOID *)LocalAlloc( LPTR, cb ) 
#define TCP_FREE(p)               LocalFree( (HLOCAL) p )

//
// Since the ODBC does not support UNICODE APIs, we convert unicode to 
// ANSI to call the APIs. This will have to go away once we find some 
// other better way to do manage the same
//

//
//  Constants for display widths
//

#define MAX_NUM_PRECISION         15

//
//  Constant for all non string and non binary data.  40 is chosen to 
//  account for things such as Oracle's numeric types, which can have 
//  up to 38 digits of precision
//

#define MAX_NONCHAR_DATA_LEN      40

//
//  If no default maximum field size is specified, then use this value
//  as the maximum
//

#define DEFAULT_MAX_FIELD_SIZE    8192

ALLOC_CACHE_HANDLER *   ODBC_STATEMENT::sm_pachOdbcStatements;

/************************************************************
 *  Local Functions
 ************************************************************/

static 
inline 
VOID
CheckAndPrintErrorMessage( 
    IN ODBC_CONNECTION * poc,
    IN RETCODE           rc
    )
{

# if DBG
    if ( !ODBC_CONNECTION::Success( rc))  {

        STRA str;
        poc->GetLastErrorText( &str, NULL, rc );

        DBGPRINTF( ( DBG_CONTEXT,
                    "ODBC Error Code( %d). Text: %s\n",
                    rc,
                    str.QueryStr() ));
    }
# endif // DBG

    return;

} // CheckAndPrintErrorMessage()


static inline VOID
CheckAndPrintErrorMessage( 
    IN ODBC_STATEMENT * pos,
    IN RETCODE rc)
{

# if DBG
    if ( !ODBC_CONNECTION::Success( rc))  {

        STRA str;
        pos->GetLastErrorText( &str );

        DBGPRINTF( ( DBG_CONTEXT,
                    "ODBC Error Code( %d). Text: %s\n",
                    rc,
                    str.QueryStr() ));
    }
# endif // DBG

    return;

} // CheckAndPrintErrorMessage()

# if DBG

# if 0

static VOID
PrintMultiString( 
    IN char * pszMsg, 
    IN DWORD cbLen, 
    IN char * pmsz
    )
{

    DBGPRINTF( ( DBG_CONTEXT,
                "Values of %s. %d bytes.\n", pszMsg, cbLen));
    for( char * psz = pmsz; 
         *psz != '\0'; 
         psz += (strlen( psz) + 1)) 
    {

        DBGPRINTF( ( DBG_CONTEXT, "%s\n", psz));
    }

    return;
} // PrintMultiString()

static VOID
AuxOdbcFunctions( IN HENV henv, IN HDBC hdbc)
/*++

  Function useful in walking throug a few additional ODBC functions
    to find out the ODBC setup information.
  Not to be part of the shipped code. Useful for development purposes.
  - MuraliK
--*/
{
    RETCODE rc;

    //
    // Set the trace file to a standard file.
    //
    rc = SQLSetConnectOption( hdbc, SQL_OPT_TRACE, SQL_OPT_TRACE_ON);
    DBG_ASSERT( ODBC_CONNECTION::Success( rc));

    rc = SQLSetConnectOption( hdbc, SQL_OPT_TRACEFILE,
                     ( SQLULEN )"%systemroot%\\system32\\gophsql.log" );
    DBG_ASSERT( ODBC_CONNECTION::Success( rc));

    UCHAR szDriverDesc[ 300];
    UCHAR szDriverAttrib[ 300];
    SWORD cbDD = 300;
    SWORD cbDA = 300;
    SWORD cbDDCur = 0;
    SWORD cbDACur = 0;

    szDriverDesc[0] = szDriverAttrib[0] = '\0';
    rc = SQLDriversA( henv, SQL_FETCH_FIRST,
                      szDriverDesc, cbDD, &cbDDCur,
                      szDriverAttrib, cbDA, &cbDACur);
    DBG_ASSERT( ODBC_CONNECTION::Success( rc));

    DBGPRINTF( ( DBG_CONTEXT,
                " SQLDrivers( %08x) ==> RetCode = %d."
                " Driver Desc. = ( %d bytes) %s. ",
                henv, rc, cbDDCur, szDriverDesc));
    PrintMultiString( " Driver Attributes", 
                      cbDACur, 
                      (char *) szDriverAttrib);


    szDriverDesc[0] = szDriverAttrib[0] = '\0';
    cbDDCur = cbDACur = 0;
    rc = SQLDataSourcesA( henv, SQL_FETCH_FIRST,
                          szDriverDesc, cbDD, &cbDDCur,
                          szDriverAttrib, cbDA, &cbDACur);
    DBG_ASSERT( ODBC_CONNECTION::Success( rc));

    DBGPRINTF( ( DBG_CONTEXT,
                " SQLDataSources( %08x) ==> RetCode = %d."
                " Data Sources. = ( %d bytes) %s. ",
                henv, rc, cbDDCur, szDriverDesc));
    PrintMultiString( " Data Source Description", cbDACur,
                     (char *) szDriverAttrib);

    return;
} // AuxOdbcFunctions()

# endif // 0

# endif // DBG

/************************************************************
 *    Member Functions of ODBC_PARAMETER
 ************************************************************/

HRESULT
ODBC_PARAMETER::CopyValue( 
    IN LPCWSTR  pwszValue
    )
/*++
  Description:
    This function copies the given Unicode string as the value 
    into current parameter marker to be used for future insertion.

  Arguments:
    pwszValue - pointer to null-terminated string containing 
                Unicode value to be copied into the parameter 
                marker.

  Returns:
    TRUE on success and FALSE if there is any error.

  Note:
    Since ODBC does not support Unicode directly right now, we 
    convert string value to be ANSI before copying the value over.
--*/
{
    HRESULT hr;
    STRA    strValue;

    hr = strValue.CopyW( pwszValue );
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error copying data, hr = 0x%x.\n",
            hr ));

        return hr;
    }

    return this->CopyValue( strValue.QueryStr() );

} // ODBC_PARAMETER::CopyValue()

HRESULT
ODBC_PARAMETER::CopyValue( 
    IN LPSYSTEMTIME lpst
    )
/*++
  Description:
    This function copies the given system time into the ODBC 
    timestamp structure for the current parameter marker to be 
    used for future insertion.

  Arguments:
    lpSystemTime - pointer to System Time structure containing 
                   current time.

  Returns:
    TRUE on success and FALSE if there is any error.

--*/
{
    TIMESTAMP_STRUCT * ptsOdbc;

    DBG_ASSERT( lpst != NULL);
    DBG_ASSERT( m_CType == SQL_C_TIMESTAMP);
    DBG_ASSERT( m_SqlType == SQL_TIMESTAMP);
    DBG_ASSERT( m_cbValueMax >= sizeof(TIMESTAMP_STRUCT));

    ptsOdbc = ( TIMESTAMP_STRUCT * ) m_pValue;

    DBG_ASSERT( m_pValue != NULL);

    //
    // Copy the individual fields over properly
    // The types used in ODBC/Win32 are different
    //  So do a type specific copy of the values.
    //

    ptsOdbc->year   = (SWORD ) lpst->wYear;
    ptsOdbc->month  = (UWORD ) lpst->wMonth;
    ptsOdbc->day    = (UWORD ) lpst->wDay;
    ptsOdbc->hour   = (UWORD ) lpst->wHour;
    ptsOdbc->minute = (UWORD ) lpst->wMinute;
    ptsOdbc->second = (UWORD ) lpst->wSecond;
    ptsOdbc->fraction = (UDWORD ) lpst->wMilliseconds;

    return S_OK;

} // ODBC_PARAMETER::CopyValue()

RETCODE
ODBC_PARAMETER::Bind( 
    IN HSTMT hStmt
    )
/*++
  Description:

    This functions binds the data about the parameter marker 'this'
     ( this object) represents to the statement provided.

  Arguments:
    hStmt        HANDLE for the statement to which this parameter
                  is to be bound.

  Returns:
    RETCODE value returned by SQLBindParamater().
--*/
{
    RETCODE  rc;
    DBG_ASSERT( hStmt != SQL_NULL_HSTMT);

    rc = SQLBindParameter( hStmt,              // statement
                           QueryParamNumber(),
                           QueryParamType(),
                           QueryCType(),
                           QuerySqlType(),
                           QueryPrecision(),
                           QueryScale(),
                           QueryValue(),
                           QueryMaxCbValue(),
                           &(QueryCbValueRef())
                           );

    return ( rc);

} // ODBC_STATEMENT::BindParameter()

# if DBG

VOID
ODBC_PARAMETER::Print( 
    VOID
    ) const
{
    DBGPRINTF( ( DBG_CONTEXT,
                "Printing ODBC_PARAMETER ( %08x).\n"
                " Num=%u; Type=%d; CType=%d; SqlType=%d; Prec=%u;"
                " Scale=%d; CbMax=%d; Cb=%d.\n",
                this,
                QueryParamNumber(),
                QueryParamType(),
                QueryCType(),
                QuerySqlType(),
                QueryPrecision(),
                QueryScale(),
                QueryMaxCbValue(),
                QueryCbValue()));

    switch ( QuerySqlType() ) 
    {
      case SQL_INTEGER:
        {    
            DWORD  dwValue = *(DWORD *) QueryValue();
            DBGPRINTF( ( DBG_CONTEXT, 
                       " Integer Value = %u\n", 
                       dwValue ) );
            break;
        }
      case SQL_CHAR:
        {
            LPCSTR pszValue = (LPCSTR ) QueryValue();
            DBGPRINTF( ( DBG_CONTEXT, 
                       "String Value( %08x) = %s\n",
                       pszValue, 
                       pszValue ) );
            break;
        }
      default:
 
            DBGPRINTF( ( DBG_CONTEXT, 
                       " Type=%d. Unknown value at %08x\n",
                       QuerySqlType(), 
                       QueryValue() ) );
            break;

    } // switch

    return;

} // ODBC_PARAMETER::Print()

# endif // DBG

/************************************************************
 * ODBC_STATEMENT  member functions
 ************************************************************/


ODBC_STATEMENT::~ODBC_STATEMENT( VOID)
{
    //
    // Free the statement handle
    //
    if ( m_hStmt != SQL_NULL_HSTMT) {

        m_rc = SQLFreeStmt( m_hStmt, SQL_DROP);
        m_hStmt = SQL_NULL_HSTMT;

        // Ignore the error code here.
        DBG_ASSERT( ODBC_CONNECTION::Success( m_rc));

        IF_DEBUG( ODBC) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "SqlFreeStmt() return code %d.\n",
                        m_rc));

            CheckAndPrintErrorMessage( this, m_rc);
        }
    }

    FreeColumnMemory();

    m_dwSignature = ODBC_STATEMENT_FREE_SIGNATURE;

} // ODBC_STATEMENT::~ODBC_STATEMENT()

HRESULT
ODBC_STATEMENT::ExecDirect(
    IN LPCSTR pszSqlCommand,
    IN DWORD cchSqlCommand
    )
{
    DBG_ASSERT( CheckSignature() );

    BOOL fReturn;

    IF_DEBUG( ODBC ) 
    {
        DBGPRINTF( ( DBG_CONTEXT,
                    " Executing the SQL command (%d bytes) %s.\n",
                    cchSqlCommand * sizeof( CHAR),
                    pszSqlCommand));
    }

    //
    //  SQLExecDirect only likes Unsigned chars !
    //
    m_rc = SQLExecDirectA( m_hStmt, 
                           (UCHAR FAR *) pszSqlCommand, 
                           cchSqlCommand);

    fReturn = ODBC_CONNECTION::Success( m_rc);

    IF_DEBUG( ODBC) 
    {
        DBGPRINTF( ( DBG_CONTEXT,
                    " SQLExecDirect() returns code %d\n",
                    m_rc));

        CheckAndPrintErrorMessage( this, m_rc);
    }

    if( fReturn )
    {
        return S_OK;
    }
    
    return E_FAIL;

} // ODBC_STATEMENT::ExecDirect()



HRESULT
ODBC_STATEMENT::ExecDirect(
    IN LPCWSTR pszSqlCommand,
    IN DWORD cchSqlCommand
    )
{
    HRESULT  hr;
    STRA     strCommand;

    DBG_ASSERT( CheckSignature() );

    hr = strCommand.CopyW( pszSqlCommand );
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error copying sql command, hr = 0x%x.\n",
            hr ));

        return hr;
    }

    return ExecDirect( strCommand.QueryStr(), strCommand.QueryCCH() );

} // ODBC_STATEMENT::ExecDirect()

HRESULT
ODBC_STATEMENT::PrepareStatement(
    IN LPCSTR    pszStatement
    )
/*++

  This function prepares the SQL statement for future execution.

  Arguments:
    pszStatement - pointer to null terminated string containing the
                   statement.

  Returns:
     HRESULT
--*/
{

    DBG_ASSERT( CheckSignature() );

    DBG_ASSERT( QueryErrorCode() == SQL_SUCCESS && 
                pszStatement != NULL);

    m_rc = SQLPrepareA( m_hStmt, (UCHAR FAR *) pszStatement, SQL_NTS);

    IF_DEBUG( ODBC ) 
    {

        DBGPRINTF( ( DBG_CONTEXT,
                    " SQLPrepare( %s) returns ErrorCode = %d.\n",
                     pszStatement, m_rc));

        CheckAndPrintErrorMessage( this, m_rc);
    }

    m_fPreparedStmt = ODBC_CONNECTION::Success( m_rc );

    if( m_fPreparedStmt )
    {
        return S_OK;
    }

    return E_FAIL;

} // ODBC_STATEMENT::PrepareStatment()

HRESULT
ODBC_STATEMENT::PrepareStatement( 
    IN LPCWSTR   pwszCommand
    )
/*++

  This function prepares an ODBC statement for execution.
  Since ODBC does not support UNICODE, we convert the statement 
  into ANSI before calling the APIs.

  Arguments:
    pwszCommand - pointer to null-terminated string containing the
                  statement to be prepared.

  Returns:
    HRESULT
--*/
{
    STRA    strCommand;
    HRESULT hr;

    DBG_ASSERT( CheckSignature() );

    hr = strCommand.CopyW( pwszCommand );
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error copying command, hr = 0x%x.\n",
            hr ));

        return hr;
    }

    return PrepareStatement( strCommand.QueryStr() );

} // ODBC_STATEMENT::PrepareStatement()

HRESULT
ODBC_STATEMENT::BindParameter( 
    IN PODBC_PARAMETER pOdbcParameter
    )
{

    DBG_ASSERT( CheckSignature() );

    DBG_ASSERT( ODBC_CONNECTION::Success( m_rc) && 
                pOdbcParameter != NULL);

    m_rc = pOdbcParameter->Bind( m_hStmt);

    IF_DEBUG( ODBC) {

        CheckAndPrintErrorMessage( this, m_rc );
    }

    if( ODBC_CONNECTION::Success( m_rc ) )
    {
        return S_OK;
    }

    return E_FAIL;

} // ODBC_STATEMENT::BindParameter()

HRESULT
ODBC_STATEMENT::ExecuteStatement( 
    VOID
    )
/*++

  This function executes a prepared ODBC statement. At the end of 
  execution, the transaction is also committed to ensure that the 
  record is automatically written to the database.

  Arguments:
    None

  Returns:
    HRESULT

--*/
{
    DBG_ASSERT( CheckSignature() );

    DBG_ASSERT( m_fPreparedStmt != FALSE);

    if ( !ODBC_CONNECTION::Success( QueryErrorCode()) ) 
    {
        DBGPRINTF(( DBG_CONTEXT,
         "!!WARNING!! - Attempting to use Invalid ODBC Connection!\n" ));
    }

    m_rc = SQLExecute( m_hStmt);

    IF_DEBUG( ODBC) 
    {
        CheckAndPrintErrorMessage( this, m_rc);
    }

    if( ODBC_CONNECTION::Success( m_rc ) )
    {
        return S_OK;
    }

    return E_FAIL;

} // ODBC_STATEMENT::ExecuteStatement()

HRESULT
ODBC_STATEMENT::QueryRowCount(
    OUT SQLLEN *pcRows
    )
/*++

  Calls SQLRowCount on the current result set.

  NOTE: Not all database implementations support this!!

  Arguments:

    pcRows - Receives count of rows

  Returns:
    TRUE on success and FALSE if there are any failures.

  Note:

--*/
{
    DBG_ASSERT( CheckSignature() );

    m_rc = SQLRowCount( m_hStmt,
                        pcRows );

    if( ODBC_CONNECTION::Success( m_rc ) )
    {
        return S_OK;
    }

    return E_FAIL;
}

HRESULT
ODBC_STATEMENT::QueryColNames(
    STRA * *  pastrCols,
    DWORD  *  cCols,
    DWORD     cchMaxFieldSize,
    BOOL *    pfHaveResultSet
    )
/*++

  This method returns the list of column names from the result table

  Arguments:

    pastrCols - Receives an array of STRAs containing the column names
    cCols - Count of columns returned (zero for no result set)
    cchMaxFieldSize - Maximum buffer size to allocate for any data 
                      fields, zero means use the default value.
    pfHaveResultSet - Set to TRUE if the current query was a SELECT 
                      and thus has rows that can be enumerated

  Returns:
    TRUE on success and FALSE if there are any failures.

  Note:

--*/
{
    HRESULT hr;
    SWORD   nresultcols;
    SWORD   i;
    CHAR    achColName[64];
    SWORD   cchColName;
    SWORD   ColType;
    DWORD   cchColLength;
    SWORD   scale;
    SWORD   nullable;

    *pastrCols       = NULL;
    *cCols           = 0;
    *pfHaveResultSet = TRUE;

    DBG_ASSERT( CheckSignature() );

    //
    //  Return the old binding info if we already have it
    //

    if ( m_astrColNames )
    {
        *pastrCols = m_astrColNames;
        *cCols = m_cCols;

        return S_OK;
    }

    //
    //  Provide a default maximum field size if none was specified
    //

    if ( !cchMaxFieldSize )
    {
        cchMaxFieldSize = DEFAULT_MAX_FIELD_SIZE;
    }

    //
    //  See what kind of statement it was.  If there are no result
    //  columns, the statement is not a SELECT statement.
    //

    m_rc = SQLNumResultCols( m_hStmt,
                             &nresultcols );

    if ( !ODBC_CONNECTION::Success( m_rc ) )
    {
        return E_FAIL;
    }

    if ( nresultcols > 0 )
    {
        //
        //  Allocate an array of strings for the column names and 
        //  the column values
        //

        m_cCols = nresultcols;
        *cCols  = m_cCols;

        m_astrColNames = new STRA[m_cCols];
        m_astrValues   = new STRA[m_cCols];
        m_acbValue     = new SQLLEN[m_cCols];

        if( m_astrColNames == NULL ||
            m_astrValues == NULL   ||
            m_acbValue == NULL )
        {
            return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        }

        //
        //  Otherwise, get the column names of the result set and 
        //  use the display_size() function to compute the length 
        //  needed by each data type.  Next, bind the columns and 
        //  specify all data will be converted to char.
        //

        for (i = 0; i < m_cCols; i++ )
        {
            m_rc = SQLDescribeColA( m_hStmt,
                                    i + 1,
                                    (UCHAR *) achColName,
                                    (SWORD)sizeof(achColName),
                                    &cchColName,
                                    &ColType,
                                    &cchColLength,
                                    &scale,
                                    &nullable );

            if ( !ODBC_CONNECTION::Success( m_rc ) )
            {
                return E_FAIL;
            }

            //
            //  Select the buffer size for the retrieved data for 
            //  this column
            //

            cchColLength = ODBC_CONNECTION::DisplaySize( ColType,
                             min( cchColLength, cchMaxFieldSize ) );

            //
            //  Copy the column name and set the column data size
            //

            hr = m_astrColNames[i].Copy( achColName );
            if( FAILED( hr ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                    "Error copying colume name, hr = 0x%x.\n",
                    hr ));

                return hr;
            }

            hr = m_astrValues[i].Resize( cchColLength + 1 );
            if ( FAILED( hr ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                    "Error resizing string buffer, hr = 0x%x.\n",
                    hr ));

                return hr;
            }

            m_rc = SQLBindCol( m_hStmt,
                               i + 1,
                               SQL_C_CHAR,
                               m_astrValues[i].QueryStr(),
                               cchColLength,
                               &m_acbValue[i] );

            if ( !ODBC_CONNECTION::Success( m_rc ) )
            {
                return E_FAIL;
            }
        }

        *pastrCols = m_astrColNames;
        *cCols     = m_cCols;
    }
    else
    {
        *pfHaveResultSet = FALSE;
    }

    return S_OK;
}

HRESULT
ODBC_STATEMENT::QueryValuesAsStr(
    STRA * *      pastrValues,
    OUT DWORD * * pacbValues,
    BOOL *        pfLast
    )
/*++

  This method gets the data at the current position.

  Arguments:

    pastrValues - Receives a pointer to an array of strings that contains
        the alphanumeric representation of that field
    pacbValues - Receives pointer to array of DWORDs that contain the length
        of the field
    pfLast - Set to TRUE if there are no more values to retrieve

  Returns:

    HRESULT

  Note:

--*/
{
    HRESULT hr;

    DBG_ASSERT( CheckSignature() );

    *pastrValues = NULL;

    //
    //  Build the bindings if we haven't already
    //

    if ( !m_astrColNames )
    {
        STRA * astrCols;
        DWORD cCols;
        BOOL  fHaveResultSet;

        hr = QueryColNames( &astrCols,
                             &cCols,
                             0,
                             &fHaveResultSet );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }

    //
    //  If there are columns to enumerate, get them now
    //

    if ( m_astrColNames )
    {
        DWORD i;

        //
        //  Zero terminate the columns as some drivers don't write 
        //  anything for NULL fields
        //

        for ( i = 0; i < m_cCols; i++ )
        {
            *((CHAR *) m_astrValues[i].QueryStr()) = '\0';
            m_acbValue[i] = 0;
        }

        //
        //  Fill in the binding values
        //

        m_rc = SQLFetch( m_hStmt );

        if ( m_rc == SQL_NO_DATA_FOUND )
        {
            *pfLast = TRUE;
        }
        else
        {
            if ( !ODBC_CONNECTION::Success( m_rc ) )
            {
                return E_FAIL;
            }

            *pfLast = FALSE;
        }

        *pastrValues = m_astrValues;
        *pacbValues  = ( DWORD * ) m_acbValue;
    }
    else
    {
        *pfLast = TRUE;
    }

    return S_OK;
}

HRESULT
ODBC_STATEMENT::MoreResults(
    BOOL * pfMoreResults
    )
/*++

    Determines if there are any more results sets to return to 
    the user

    pfMoreResults - Set to TRUE if there are more results in the 
                    result set

--*/
{
    DBG_ASSERT( CheckSignature() );

    *pfMoreResults = TRUE;

    m_rc = SQLMoreResults( m_hStmt );

    if ( m_rc == SQL_NO_DATA_FOUND )
    {
        *pfMoreResults = FALSE;
        return S_OK;
    }

    if ( !ODBC_CONNECTION::Success( m_rc ))
    {
        return E_FAIL;
    }

    return S_OK;
}

VOID
ODBC_STATEMENT::FreeColumnMemory(
    VOID
    )
/*++
    This method frees memory allocated by the QueryColNames and
    QueryValuesAsStr methods.

--*/
{
    DBG_ASSERT( CheckSignature() );

    if ( m_astrColNames ) delete [] m_astrColNames;
    if ( m_astrValues )   delete [] m_astrValues;
    if ( m_acbValue )     delete [] m_acbValue;

    m_astrColNames = NULL;
    m_astrValues = NULL;
    m_acbValue = NULL;
}

//static
HRESULT
ODBC_STATEMENT::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize ODBC_STATEMENT lookaside

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ALLOC_CACHE_CONFIGURATION       acConfig;

    acConfig.nConcurrency = 1;
    acConfig.nThreshold = 100;
    acConfig.cbSize = sizeof( ODBC_STATEMENT );

    DBG_ASSERT( sm_pachOdbcStatements == NULL );
    
    sm_pachOdbcStatements = new ALLOC_CACHE_HANDLER( "ODBC_STATEMENT",  
                                                     &acConfig );

    if ( sm_pachOdbcStatements == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }
    
    return NO_ERROR;
}

//static
VOID
ODBC_STATEMENT::Terminate(
    VOID
)
/*++

Routine Description:

    Terminate ODBC_STATEMENT lookaside

Arguments:

    None

Return Value:

    None

--*/
{
    if ( sm_pachOdbcStatements != NULL )
    {
        delete sm_pachOdbcStatements;
        sm_pachOdbcStatements = NULL;
    }
}

# if DBG

VOID
ODBC_STATEMENT::Print( VOID) const
{
    DBGPRINTF( ( DBG_CONTEXT,
                " Printing ODBC_STATEMENT( %08x)."
                " HStmt = %08x. OdbcConn=%08x. RetCode = %d\n",
                m_hStmt, m_pOdbcConnection, m_rc));

} // ODBC_STATEMENT::Print()

# endif // DBG

/**************************************************
 *  Member Functions of class ODBC_CONNECTION
 **************************************************/


ODBC_CONNECTION::~ODBC_CONNECTION( VOID)
/*++
   This function closes the odbc connection ( if open) and cleans up.

--*/
{
    DBG_REQUIRE( SUCCEEDED( Close() ) );

    return;
} // ODBC_CONNECTION::~ODBC_CONNECTION()

HRESULT
ODBC_CONNECTION::Open(
    IN LPCSTR   pszDataSource,
    IN LPCSTR   pszUserName,
    IN LPCSTR   pszPassword
    )
/*++
  This function opens a new odbc connection to given data source
  using the user name and password supplied.

  Arguments:
    pszDataSource - pointer to null-terminated string containing ODBC
                    data source name
    pszUserName   - pointer to null-terminated string containing 
                    UserName
    pszPassword   - pointer to null-terminated string containing 
                    Password

  Returns:

    HRESULT
--*/
{
    HRESULT   hr = S_OK;
    BOOL      fReturn = FALSE;

    DBG_ASSERT( pszDataSource != NULL &&
                pszUserName != NULL &&
                pszPassword != NULL );

    //
    //  Allocate an ODBC environment
    //

    m_rc = SQLAllocEnv( &m_henv );
    fReturn = Success( m_rc );

    IF_DEBUG( ODBC ) {

        DBGPRINTF( ( DBG_CONTEXT,
               "SQLAllocEnv() returned ErrorCode %d. henv = %08x\n",
               m_rc, m_henv));

        CheckAndPrintErrorMessage( this, m_rc);
    }

    if ( fReturn ) {

        //
        // Establish memory for connection handle within the environment
        //

        m_rc = SQLAllocConnect( m_henv, &m_hdbc);
        fReturn = Success( m_rc);

        IF_DEBUG( ODBC) {

            DBGPRINTF( ( DBG_CONTEXT,
                   "SQLAllocConnect() returns code %d. hdbc = %08x\n",
                   m_rc, m_hdbc));

            CheckAndPrintErrorMessage( this, m_rc);
        }
    }

    if ( fReturn) {

        //
        // Use Following call to just printout the dynamic values for ODBC
        //
        // AuxOdbcFunctions( m_henv, m_hdbc);

#if 0
        {
            STRA str;
            STRA strOut;
            SWORD swStrOut;

            if ( FAILED( str.Append( pszDataSource ) )  ||
                 FAILED( str.Append( ";UID=" ) )        ||
                 FAILED( str.Append( pszUserName ) )    ||
                 FAILED( str.Append( ";PWD=" ) )        ||
                 FAILED( str.Append( pszPassword ) )    ||
                 FAILED( str.Append( ";APP=Internet Services") ) ||
                 FAILED( strOut.Resize( 255 ) ) )
            {
                return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
            }

            m_rc = SQLDriverConnect( m_hdbc,
                                     NULL,
                                     (UCHAR *) str.QueryStr(),
                                     SQL_NTS,
                                     (UCHAR *) strOut.QueryStr(),
                                     strOut.QuerySize(),
                                     &swStrOut,
                                     SQL_DRIVER_NOPROMPT );
        }
#else
        {
            m_rc = SQLConnectA( m_hdbc,
                                (UCHAR FAR *) pszDataSource, SQL_NTS,
                                (UCHAR FAR *) pszUserName,   SQL_NTS,
                                (UCHAR FAR *) pszPassword,   SQL_NTS );
        }
#endif

        fReturn = Success( m_rc);

        IF_DEBUG( ODBC) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "SQLConnect( %s, %s, %s) returns code %d.\n",
                        pszDataSource,
                        pszUserName,
                        pszPassword,
                        m_rc ) );

            CheckAndPrintErrorMessage( this, m_rc );
        }
    }

    m_fValid = fReturn;

    if ( !fReturn ) {
        hr = HRESULT_FROM_WIN32( ERROR_GEN_FAILURE );
    }

    return hr;

} // ODBC_CONNECTION::Open()

HRESULT
ODBC_CONNECTION::Open(
    IN LPCWSTR  pwszDataSource,
    IN LPCWSTR  pwszUserName,
    IN LPCWSTR  pwszPassword
    )
/*++
  This function opens a new odbc connection to given data source
    using the user name and password supplied.

  Arguments:
    pwszDataSource - pointer to null-terminated string containing ODBC
                     data source name
    pwszUserName   - pointer to null-terminated string containing 
                     UserName
    pwszPassword   - pointer to null-terminated string containing 
                     Password

  Returns:
    TRUE on success and FALSE if there is an error.

  Note:
     Poor me.  ODBC Does not take UNICODE strings :(. 2/15/95
     So we will explicitly convert parameters to ANSI on stack.
--*/
{
    HRESULT hr;
    STRA    strDataSource;
    STRA    strUserName;
    STRA    strPassword;

    //
    // Convert all parameters from UNICODE to ANSI
    //
    hr = strDataSource.CopyW( pwszDataSource );
    if( FAILED( hr ) )
    {
        return hr;
    }

    hr = strUserName.CopyW( pwszUserName );
    if( FAILED( hr ) )
    {
        return hr;
    }

    hr = strPassword.CopyW( pwszPassword );
    if( FAILED( hr ) )
    {
        return hr;
    }

    //
    // Make an ANSI open call.
    //
    hr = Open( strDataSource.QueryStr(), 
               strUserName.QueryStr(), 
               strPassword.QueryStr() );

    //
    // Zero the password for security reasons.
    //
    SecureZeroMemory( strPassword.QueryStr(), strPassword.QueryCB() );

    return hr;

} // ODBC_CONNECTION::Open()


HRESULT
ODBC_CONNECTION::Close( 
    VOID
    )
/*++
  This function closes the connection established with the ODBC
  and frees up and dynamic memory used.

  Returns:
    TRUE on success and FALSE if there are any failures.

  Note:
    Intermediate failures are ignored. Normally they should not occur.

--*/
{
    BOOL fReturn = TRUE;

    //
    // Disconnect and free the connection.
    //
    if ( m_hdbc != SQL_NULL_HDBC) 
    {
        m_rc = SQLDisconnect( m_hdbc );

        //
        //  Disconnect is allowed to fail w/o being fatal so don't set
        //  fReturn
        //

        IF_DEBUG( ODBC) 
        {
            DBGPRINTF( ( DBG_CONTEXT,
                        "Warning: SQLDisconnect() returns code %d.\n",
                        m_rc));
            CheckAndPrintErrorMessage( this, m_rc);
        }

        m_rc = SQLFreeConnect( m_hdbc);

        m_hdbc = SQL_NULL_HDBC;

        fReturn = fReturn && Success( m_rc);

        IF_DEBUG( ODBC) 
        {
            DBGPRINTF( ( DBG_CONTEXT,
                        "SQLFreeConnect() returns code %d.\n",
                        m_rc));

            CheckAndPrintErrorMessage( this, m_rc);
        }

        if( !fReturn )
        {
            return E_FAIL;
        }
    }

    //
    //  Free the ODBC environment handle.
    //
    if ( m_henv != SQL_NULL_HENV) {

        m_rc = SQLFreeEnv( m_henv);
        m_henv = SQL_NULL_HENV;
        fReturn = fReturn && Success( m_rc);

        IF_DEBUG( ODBC) 
        {
            DBGPRINTF( ( DBG_CONTEXT,
                        "SQLFreeEnv() returns code %d.\n",
                        m_rc));

            CheckAndPrintErrorMessage( this, m_rc);
        }

        if( !fReturn )
        {
            return E_FAIL;
        }
    }

    return S_OK;

} // ODBC_CONNECTION::Close()

PODBC_STATEMENT
ODBC_CONNECTION::AllocStatement( VOID)
/*++
  Description:
    This function allocates a new ODBC statement object and also 
    calls SQLAllocStatement to create the state required for 
    establishing the statement in the ODBC Manager.

  Arguments:
    None

  Returns:
    TRUE on success and FALSE if there is any failure.
--*/
{
    PODBC_STATEMENT pOdbcStmt = NULL;
    HSTMT   hstmt = SQL_NULL_HSTMT;

    DBG_ASSERT( Success( m_rc));

    //
    // Allocate a statement handle and associate it with the connection.
    //
    m_rc = SQLAllocStmt( m_hdbc, &hstmt);

    IF_DEBUG( ODBC) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "SqlAllocStmt() returns code %d."
                    " New Hstmt is : %08x\n",
                    m_rc, hstmt));
        CheckAndPrintErrorMessage( this, m_rc);
    }

    if ( ODBC_CONNECTION::Success( m_rc)) {

        pOdbcStmt = new ODBC_STATEMENT( this, hstmt);
    }

    return ( pOdbcStmt );

} // ODBC_CONNECTION::AllocStatement()


HRESULT
ODBC_CONNECTION::SetConnectOption(
    IN UWORD   Option,
    IN SQLULEN Param
    )
/*++

  Sets various options on this connection

  Arguments:

    Option - Option to set
    Param - Option value (32 bit dword or pointer to null terminated 
            string )

  Returns:
    HRESULT. Failures are considered to be soft errors as the problem 
    may be the driver doesn't support the option etc.

  Note:

--*/
{
    BOOL    fReturn = TRUE;
    RETCODE rc;

    if ( m_hdbc != SQL_NULL_HDBC)
    {
        rc = SQLSetConnectOption( m_hdbc, Option, Param );

        fReturn = Success( rc );

        IF_DEBUG( ODBC ) 
        {

            DBGPRINTF( ( DBG_CONTEXT,
                      "SQLSetConnectOption( %d, %d ) returns code %d.\n",
                      Option,
                      Param,
                      rc ) );

            CheckAndPrintErrorMessage( this, rc);
        }
    }
    else
    {
        DBGPRINTF( ( DBG_CONTEXT,
                     "[SetConnectOption] Warning: "
                     "Setting option on closed connection\n" ));
    }

    if( fReturn )
    {
        return S_OK;
    }

    return E_FAIL;
}

BOOL
ODBC_CONNECTION::GetLastErrorText(
    OUT STRA *    pstrError,
    IN  HSTMT    hstmt,
    IN  RETCODE  rc
    ) const
/*++

  This method returns the textual representation of the last ODBC or 
  windows error that occurred.  Even though the ODBC methods return 
  FALSE on failure, if it was an ODBC call that failed, then 
  GetLastError won't return the needed error code.  Clients of this 
  class should call this method to get a descriptive text string of 
  the failure.

  Returns:

    TRUE on success and FALSE if there are any failures.

  Note:
    If this function returns FALSE, then a client should call 
    GetLastError for the error code.

--*/
{
    BOOL fReturn = TRUE;

    if ( ODBC_CONNECTION::Success( rc)) {

        fReturn = SUCCEEDED(pstrError->LoadString( GetLastError() ));

    } 
    else 
    {
        CHAR     rgchMsg[ SQL_MAX_MESSAGE_LENGTH + 10];
        CHAR     achState[30];
        CHAR     rgchFullMsg[ sizeof(rgchMsg) + sizeof(achState) + 60];
        SWORD    cbMsg;
        LONG     lError;

        //
        //  If we're formatting as HTML, we bullet list the items
        //

        pstrError->Reset();

        //
        //  Loop to pick up all of the errors
        //

        do {
            cbMsg = SQL_MAX_MESSAGE_LENGTH;

            rc = SQLErrorA( m_henv,
                            m_hdbc,
                            hstmt,
                            (UCHAR *) achState,
                            &lError,
                            (UCHAR *) rgchMsg,
                            cbMsg,
                            &cbMsg );

            if ( ODBC_CONNECTION::Success( rc)) 
            {
                wsprintfA( rgchFullMsg,
                           "[State=%s][Error=%d]%s\n",
                           achState, lError, rgchMsg);

                if ( FAILED( pstrError->Append( rgchFullMsg ) ) )
                {

                    fReturn = FALSE;
                    break;
                }
            } 
            else 
            {
                //
                //  This is indicates there are no more error strings
                //  to pick up so we should get out
                //

                if ( rc == SQL_NO_DATA_FOUND ) 
                {
                    //
                    //  Append the end of unorder list marker
                    //

                    rc = SQL_SUCCESS;
                    break;
                }
            }

        } while ( ODBC_CONNECTION::Success( rc ) );

        if ( !ODBC_CONNECTION::Success( rc ) )
        {
            DBGPRINTF( ( DBG_CONTEXT,
                        "[GetLastErrorText] SqlError() returned error %d.\n",
                        rc));

            SetLastError( ERROR_GEN_FAILURE );
            fReturn = FALSE;
        }
    }

    return ( fReturn);

} // ODBC_CONNECTION::GetLastErrorText()

/*******************************************************************

    NAME:       EncodeStringToHTML2

    SYNOPSIS:   Enode string in HTML format - same as w3/server/doget.cxx:EncodeStringToHTML

    ENTRY:      szSrc - Source string to be encoded, in system codepage
                szDest - Space to output HTML (in system codepage)
                cbDest - Size of space in szDest (number of bytes)

    RETURNS:    number of bytes required for HTML text

    NOTES:      If cbDest is less than target HTML, then we fit
                as much characters as possible into szDest. But the
                return value remains the same and is greater than
                cbDest. szDest is not zero terminated in this case.

    HISTORY:
        markzh       17-Jan-2002 Created
        minglu       17-Jan-2002 Ported to IIS6

********************************************************************/
UINT EncodeStringToHTML2(CHAR *szSrc, CHAR *szDest, UINT cbDest)
{
    CHAR *pSrc = szSrc;
    CHAR *pDest = szDest;
    BOOL isSecondByte=FALSE;
    
    do {
        CHAR *szAppend = pSrc;
        UINT cbAppend = 1;

        // We may be running on DBCS. Ideally we should encode them to &#nnnnn
        // but we dont want that many code here

        if (isSecondByte)
        {
            isSecondByte = FALSE;
        }
        else if (IsDBCSLeadByte(*pSrc))
        {
            isSecondByte = TRUE;
        }
        else switch (*pSrc)
        {
        #define SetAppend(s)  (szAppend=(s), cbAppend=sizeof(s)-1)
            case '&': SetAppend("&amp;");
                break;
            case '"': SetAppend("&quot;");
                break;
            case '<': SetAppend("&lt;");
                break;
            case '>': SetAppend("&gt;");
                break;
            default:
                break;
        #undef SetAppend
        }

        if (pDest - szDest + cbAppend <= cbDest)
        {
            memcpy(pDest, szAppend, cbAppend);
        }

        pDest += cbAppend;

    }while (*pSrc++);

    return (UINT) (pDest - szDest);
}

BOOL
ODBC_CONNECTION::GetLastErrorTextAsHtml(
    OUT STRA *    pstrError,
    IN  HSTMT    hstmt,
    IN  RETCODE  rc
    ) const
/*++

  This method returns the textual representation of the last ODBC or 
  windows error that occurred.  Even though the ODBC methods return 
  FALSE on failure, if it was an ODBC call that failed, then 
  GetLastError won't return the needed error code.  Clients of this 
  class should call this method to get a descriptive text string of 
  the failure.

  Returns:

    TRUE on success and FALSE if there are any failures.

  Note:
    If this function returns FALSE, then a client should call 
    GetLastError for the error code.

--*/
{
    BOOL    fReturn = TRUE;
    HRESULT hr;

    if ( ODBC_CONNECTION::Success( rc)) {

        fReturn = SUCCEEDED(pstrError->LoadString( GetLastError()));

    } else {

        CHAR     rgchMsg[ SQL_MAX_MESSAGE_LENGTH + 10];
        CHAR     achState[30];
        CHAR     rgchFullMsg[ sizeof(rgchMsg) + sizeof(achState) + 60];
        SWORD    cbMsg;
        LONG     lError;

        //
        //  If we're formatting as HTML, we bullet list the items
        //

        if ( FAILED( hr = pstrError->Copy( "<UL>" ) ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                "Error copying error data, hr = 0x%x.\n",
                hr ));

            return FALSE;
        }

        //
        //  Loop to pick up all of the errors
        //

        do {
            cbMsg = SQL_MAX_MESSAGE_LENGTH;

            rc = SQLErrorA( m_henv,
                            m_hdbc,
                            hstmt,
                            (UCHAR *) achState,
                            &lError,
                            (UCHAR *) rgchMsg,
                            cbMsg,
                            &cbMsg );

            if ( ODBC_CONNECTION::Success( rc)) 
            {
                wsprintfA( rgchFullMsg,
                           "<LI>[State=%s][Error=%d]",
                           achState, lError);

                if ( FAILED( hr = pstrError->Append( rgchFullMsg ) ) ) 
                {
                    DBGPRINTF(( DBG_CONTEXT,
                        "Error appending error msg, hr = 0x%x.\n",
                        hr ));

                    fReturn = FALSE;
                    break;
                }

                //
                // since we call it "AsHTML", we need to encode it as such
                //

                DWORD cbRequired = EncodeStringToHTML2(rgchMsg, rgchFullMsg, sizeof(rgchFullMsg));
                if (cbRequired > sizeof(rgchFullMsg)-1)
                {
                    //truncate error message when overflow
                    strcpy(&rgchFullMsg[ sizeof(rgchFullMsg)-5 ], "...\n");
                }
                else
                {
                    strcpy(&rgchFullMsg[ cbRequired-1 ], "\n");
                }

                if ( FAILED( hr = pstrError->Append( rgchFullMsg ) ) ) 
                {
                    DBGPRINTF(( DBG_CONTEXT,
                        "Error appending error msg, hr = 0x%x.\n",
                        hr ));

                    fReturn = FALSE;
                    break;
                }
            } 
            else 
            {
                //
                //  This is indicates there are no more error strings
                //  to pick up so we should get out
                //

                if ( rc == SQL_NO_DATA_FOUND ) 
                {
                    //
                    //  Append the end of unorder list marker
                    //

                    if ( FAILED( hr = pstrError->Append( "</UL>" ) ) ) 
                    {
                        DBGPRINTF(( DBG_CONTEXT,
                            "Error appending error, hr = 0x%x.\n",
                            hr ));

                        return FALSE;
                    }

                    rc = SQL_SUCCESS;
                    break;
                }
            }

        } while ( ODBC_CONNECTION::Success( rc ) );

        if ( !ODBC_CONNECTION::Success( rc) )
        {
            DBGPRINTF( ( DBG_CONTEXT,
                   "[GetLastErrorText] SqlError() returned error %d.\n",
                   rc ) );

            SetLastError( ERROR_GEN_FAILURE );
            fReturn = FALSE;
        }
    }

    return ( fReturn);

} // ODBC_CONNECTION::GetLastErrorTextAsHtml()

BOOL
ODBC_CONNECTION::GetInfo(IN DWORD fInfoType,
                         IN PVOID rgbInfoValue,
                         IN DWORD cbInfoValueMax,
                         IN OUT DWORD * pcbInfoValue)
/*++
  This function obtains the value of the fInfoType for a specific
  ODBC Connection. It mimicks the SQLGetInfo() and uses it to obtain
  this value. On successful return the pointer rgbInfoValue contains
  the requested value and pcbInfoValue contains the size in bytes of
  data.

  Arguments:
    fInfoType - flag containing the Information Type (name) to be 
                fetched.
    rgbInfoValue - pointer to buffer which will contain the return 
                   data.
    cbInfoValue  - size of rgbInfoValue in bytes.
    pcbInfoValue - pointer to location that will contain the size of
                   information stored in rgbInfoValue, on successful 
                   return. If buffer is insufficient, this location 
                   will contain the required number of bytes.

  Returns:
    TRUE on success and FALSE if there is any failure.

--*/
{
    BOOL fReturn = FALSE;

    if ( m_hdbc != SQL_NULL_HDBC) 
    {
        RETCODE rc;

        rc = SQLGetInfo( m_hdbc, (UWORD ) fInfoType,
                         (PTR)   rgbInfoValue,
                         (SWORD) cbInfoValueMax,
                         (SWORD FAR *) pcbInfoValue );

        fReturn = Success( rc );

        IF_DEBUG( ODBC) 
        {
            DBGPRINTF( ( DBG_CONTEXT,
               "SQLGetInfo( %08x, %d, %08x, %d, %08x) returns %d.\n",
               m_hdbc, fInfoType, rgbInfoValue, cbInfoValueMax,
               pcbInfoValue, rc ) );

            CheckAndPrintErrorMessage( this, rc );
        }
    } 
    else 
    {
        DBGPRINTF( ( DBG_CONTEXT,
                    "[SQLGetInfo] Invalid Connection to ODBC\n"));
    }

    return ( fReturn );

} // ODBC_CONNECTION::GetInfo()

DWORD
ODBC_CONNECTION::DisplaySize(
    SWORD coltype,
    DWORD collen
    )
{
    DWORD cbSize = MAX_NONCHAR_DATA_LEN;

    //
    //  Note that we always set the size to at least four bytes.  
    //  This prevents any possible problems if the column to be 
    //  bound is NULLable, which can cause a NULL to be written 
    //  for the data during a fetch
    //

    switch ( coltype )
    {
      case SQL_CHAR:
      case SQL_VARCHAR:
      case SQL_LONGVARCHAR:
      case SQL_BINARY:
      case SQL_VARBINARY:
      case SQL_LONGVARBINARY:
        cbSize = max(collen + sizeof(CHAR), sizeof(PVOID));
        break;

      default:
        break;
    }

    return ( cbSize);

} // ODBC_CONNECTION::DisplaySize()

# if DBG
VOID
ODBC_CONNECTION::Print( 
    VOID
    ) const
{
    DBGPRINTF( ( DBG_CONTEXT,
                "Printing ODBC_CONNECTION ( %08x). fValid = %d\n"
                " HENV = %08x. HDBC = %08x. ReturnCode =%d\n",
                this, m_fValid,
                m_henv, m_hdbc, m_rc));
    return;

} // ODBC_CONNECTION::Print()

# endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\odbc\main.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    main.cxx

Abstract:

    This is the HTTP ODBC gateway

Author:

    John Ludeman (johnl)   20-Feb-1995

Revision History:
	Tamas Nemeth (t-tamasn)  12-Jun-1998

--*/

//
//  System include files.
//

#include "precomp.hxx"
#include "iadmw.h"
#include <ole2.h>
#include <lmcons.h>

DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();

#ifndef ARRAYSIZE
    #define ARRAYSIZE(_a) (sizeof((_a))/sizeof(*(_a)))
#endif

extern "C" {

BOOL
WINAPI
DllMain(
    HINSTANCE hDll,
    DWORD     dwReason,
    LPVOID    lpvReserved
    );

}

//
//  Globals
//

IMSAdminBase *  g_pMetabase = NULL;

//
// Is this system DBCS?
//
BOOL            g_fIsSystemDBCS;

//
//  Prototypes
//

HRESULT
ODBCInitialize(
    VOID
    );

VOID
ODBCTerminate(
    VOID
    );

HRESULT
DoQuery(
    EXTENSION_CONTROL_BLOCK * pecb,
    const CHAR *              pszQueryFile,
    const CHAR *              pszParamList,
    STRA *                    pstrError,
    int                       nCharset,
    BOOL *                    pfAccessDenied
    );


DWORD
OdbcExtensionOutput(
    EXTENSION_CONTROL_BLOCK * pecb,
    const CHAR *              pchOutput,
    DWORD                     cbOutput
    );

BOOL
OdbcExtensionHeader(
    EXTENSION_CONTROL_BLOCK * pecb,
    const CHAR *              pchStatus,
    const CHAR *              pchHeaders
    );

BOOL LookupHttpSymbols(  // eliminated, check its functionality
    const CHAR *   pszSymbolName,
    STRA *         pstrSymbolValue
    );


HRESULT
GetIDCCharset(
    CONST CHAR *   pszPath,
    int *          pnCharset,
    STRA *         pstrError
    );

HRESULT
ConvertUrlEncodedStringToSJIS(
    int            nCharset,
    STRA *          pstrParams
    );

BOOL
IsSystemDBCS(
    VOID
    );

CHAR *
FlipSlashes(
	CHAR * pszPath
	);

HRESULT
GetPoolIDCTimeout(
    unsigned char * szMdPath,
    DWORD *         pdwPoolIDCTimeout
    );

HRESULT
SendCustomError(
    EXTENSION_CONTROL_BLOCK *pecb,
    const CHAR              *pszStatus
    );

VOID WINAPI
CustomErrorCompletion(
    EXTENSION_CONTROL_BLOCK *pECB,
    PVOID                   pContext,
    DWORD                   cbIO,
    DWORD                   dwError
    );

HRESULT
SendErrorResponse(
    EXTENSION_CONTROL_BLOCK *pecb,
    const CHAR              *pszStatus,
    DWORD                   dwResID,
    const CHAR              *pszParam
    );

HRESULT
SendErrorResponseFromHr(
    EXTENSION_CONTROL_BLOCK *pecb,
    const CHAR              *pszStatus,
    DWORD                   dwResID,
    HRESULT                 hrError
    );

static const CHAR       c_sz500InternalServerError[] = "500 Internal Server Error";

DWORD
HttpExtensionProc(
    EXTENSION_CONTROL_BLOCK * pecb
    )
{
    STACK_STRA(     strPath, MAX_PATH);
    STACK_STRA(     strParams, MAX_PATH);
    STRA            strError;
    CHAR *          pch;
    DWORD           cch;
    int             nCharset;
    HRESULT         hr;

	//
    //  Make sure ODBC is loaded
    //

    if ( !LoadODBC() )
    {
        hr = SendErrorResponse( pecb,
                                "500 Unable to load ODBC",
                                ODBCMSG_CANT_LOAD_ODBC,
                                NULL);
        if ( FAILED( hr ) )
        {
            goto FatalError;
        }

        return HSE_STATUS_ERROR;
    }

    //
    //  We currently only support the GET and POST methods
    //

    if ( !strcmp( pecb->lpszMethod, "POST" ))
    {
        if ( _stricmp( pecb->lpszContentType,
                       "application/x-www-form-urlencoded" ) )
        {
            // Try to send custom error
            hr = SendCustomError( pecb, "400 Bad Request" );
            if ( FAILED( hr ) )
            {
                goto FatalError;
            }

            return HSE_STATUS_PENDING;
        }

        //
        //  The query params are in the extra data, add a few bytes in
        //  case we need to double "'"
        //

        hr = strParams.Resize( pecb->cbAvailable + sizeof(TCHAR) + 3);

        if ( SUCCEEDED( hr ) )
        {
            hr = strParams.Copy( ( const char * ) pecb->lpbData,
                                 pecb->cbAvailable );
        }

        if ( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                "Error resizing param buffer, hr = 0x%x.\n",
                hr ));

            hr = SendErrorResponseFromHr( pecb,
                                          "500 Error performing Query",
                                          ODBCMSG_ERROR_PERFORMING_QUERY,
                                          hr);
            if ( FAILED( hr ) )
            {
                goto FatalError;
            }

            return HSE_STATUS_ERROR;
        }

    }
    else if ( !strcmp( pecb->lpszMethod, "GET" ) )
    {
        hr = strParams.Copy( pecb->lpszQueryString );
        if ( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                "Error copying params, hr = 0x%x.\n",
                hr ));

            hr = SendErrorResponseFromHr( pecb,
                                          "500 Error performing Query",
                                          ODBCMSG_ERROR_PERFORMING_QUERY,
                                          hr);
            if ( FAILED( hr ) )
            {
                goto FatalError;
            }

            return HSE_STATUS_ERROR;
        }
    }
    else
    {
        // Try to send custom error
        hr = SendCustomError( pecb, "400 Method Not Allowed" );
        if ( FAILED( hr ) )
        {
            goto FatalError;
        }

        return HSE_STATUS_PENDING;
    }

    //
    //  "Charset" field is enabled for CP932 (Japanese) only in
    //  this version.
    //

    if ( 932 != GetACP() )
    {
        nCharset = CODE_ONLY_SBCS;
    }
    else
    {
        //
        //  Get the charset from .idc file
        //
        hr = GetIDCCharset( pecb->lpszPathTranslated,
                                            &nCharset,
                                            &strError );
        if ( FAILED( hr ) )
        {
            // If the file was not found
            if ( ( hr == HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ) ) ||
                 ( hr == HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ) ) ||
                 ( hr == HRESULT_FROM_WIN32( ERROR_INVALID_NAME ) ) )
            {
                // Try to send custom error
                hr = SendCustomError( pecb, "404 Not Found" );
                if ( FAILED( hr ) )
                {
                    goto FatalError;
                }

                return HSE_STATUS_PENDING;
            }

            hr = SendErrorResponse( pecb,
                                    "500 Error performing Query",
                                    ODBCMSG_ERROR_PERFORMING_QUERY,
                                    strError.QueryStr() );
            if ( FAILED( hr ) )
            {
                goto FatalError;
            }

            return HSE_STATUS_ERROR;
        }

        if ( strParams.QueryCB() )
        {
            if ( CODE_ONLY_SBCS != nCharset )
            {
                //
                //  Convert the charset of Parameters to SJIS
                //
                hr = ConvertUrlEncodedStringToSJIS( nCharset,
                                                    &strParams );
                if ( FAILED( hr ) )
                {
                    hr = SendErrorResponseFromHr( pecb,
                                                  "500 Error performing Query",
                                                  ODBCMSG_ERROR_PERFORMING_QUERY,
                                                  hr);
                    if ( FAILED( hr ) )
                    {
                        goto FatalError;
                    }

                    return HSE_STATUS_ERROR;
                }
            }
        }
    }

    //
    //  Walk the parameter string to do two things:
    //
    //    1) Remove escaped '\n's so we don't break parameter parsing
    //       later on
    //    2) Replace all '&' parameter delimiters with real '\n' so
    //       escaped '&'s won't get confused later on
    //

    pch = strParams.QueryStr();
    cch = strParams.QueryCCH();

    while ( *pch )
    {
        switch ( *pch )
        {
        case '%':
            if ( pch[1] == '0' && toupper(pch[2]) == 'A' )
            {
                pch[1] = '2';
                pch[2] = '0';
            }

            pch += 3;
            break;

        case '&':
            *pch = '\n';
            pch++;
            break;

        default:
            pch++;
        }
    }

    //
    //  The path info contains the location of the query file
    //

    hr = strPath.Copy( pecb->lpszPathTranslated );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error copying query file path, hr = 0x%x.\n",
            hr ));

        hr = SendErrorResponseFromHr( pecb,
                                      "500 Error performing Query",
                                      ODBCMSG_ERROR_PERFORMING_QUERY,
                                      hr);
        if ( FAILED( hr ) )
        {
            goto FatalError;
        }

        return HSE_STATUS_ERROR;
    }

    FlipSlashes( strPath.QueryStr() );

    //
    //  Attempt the query
    //

    BOOL fAccessDenied = FALSE;

    hr = DoQuery( pecb,
                  strPath.QueryStr(),
                  strParams.QueryStr(),
                  &strError,
                  nCharset,
                  &fAccessDenied );
    if ( FAILED( hr ) )
    {
        // If the file was not found
        if ( ( hr == HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ) ) ||
             ( hr == HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ) ) ||
             ( hr == HRESULT_FROM_WIN32( ERROR_INVALID_NAME ) ) )
        {
            // Try to send custom error
            hr = SendCustomError( pecb, "404 Not Found" );
            if ( FAILED( hr ) )
            {
                goto FatalError;
            }

            return HSE_STATUS_PENDING;
        }

        if ( fAccessDenied )
        {
            // Try to send custom error
            hr = SendCustomError( pecb, "401 Unauthorized" );
            if ( FAILED( hr ) )
            {
                goto FatalError;
            }

            return HSE_STATUS_PENDING;
        }
        else
        {
            hr = SendErrorResponse( pecb,
                                    "500 Error performing Query",
                                    ODBCMSG_ERROR_PERFORMING_QUERY,
                                    strError.QueryStr() );
            if ( FAILED( hr ) )
            {
                goto FatalError;
            }

            return HSE_STATUS_ERROR;
        }
    }

    return HSE_STATUS_SUCCESS;

FatalError:
        pecb->ServerSupportFunction(
                            pecb->ConnID,
                            HSE_REQ_SEND_RESPONSE_HEADER,
                            (VOID*)c_sz500InternalServerError,
                            NULL,
                            NULL );

        return HSE_STATUS_ERROR;
}

HRESULT
DoQuery(
    EXTENSION_CONTROL_BLOCK * pecb,
    const CHAR *              pszQueryFile,
    const CHAR *              pszParamList,
    STRA *                    pstrError,
    int                       nCharset,
    BOOL *                    pfAccessDenied
    )
/*++

Routine Description:

    Performs the actual query or retrieves the same query from the
    query cache

Arguments:

    pecb - Extension context
    pTsvcInfo - Server info class
    pszQueryFile - .wdg file to use for query
    pszParamList - Client supplied param list
    pstrError - Error text to return errors in
    pfAccessDenied - Set to TRUE if the user was denied access

Return Value:

    HRESULT

--*/
{
    HRESULT                 hr;
    ODBC_REQ *              podbcreq;
    STACK_STRA(             strHeaders, MAX_PATH );
    CHAR                    achInstanceMetaPath[ MAX_PATH ];
    DWORD                   dwInstanceMetaPath =
                              sizeof( achInstanceMetaPath );
    CHAR                    achURL[ MAX_PATH ];
    DWORD                   dwURL = sizeof( achURL );
    STACK_STRA(             strMetaPath, MAX_PATH );
    DWORD                   dwPoolIDCTimeout;

    //
    // Get the metapath for the current request
    //
    if( !pecb->GetServerVariable( pecb->ConnID,
                                  "INSTANCE_META_PATH",
                                  achInstanceMetaPath,
                                  &dwInstanceMetaPath ) ||
        !pecb->GetServerVariable( pecb->ConnID,
                                  "URL",
                                  achURL,
                                  &dwURL ) )
    {
        return E_FAIL;
    }

    hr = strMetaPath.Copy( achInstanceMetaPath, dwInstanceMetaPath - 1 );
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error copying InstanceMetaPath, hr = 0x%x.\n",
            hr ));

        return hr;
    }

    hr = strMetaPath.Append( "/Root" );
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error appending metapath, hr = 0x%x.\n",
            hr ));

        return hr;
    }

    hr = strMetaPath.Append( achURL, dwURL - 1 );
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error appending URL, hr = 0x%x.\n",
            hr ));

        return hr;
    }

    //
    // Get the HTTPODBC metadata PoolIDCTimeout
    //

    hr = GetPoolIDCTimeout( ( unsigned char * )strMetaPath.QueryStr(),
                            &dwPoolIDCTimeout );
    if( FAILED( hr ) )
    {
        dwPoolIDCTimeout = IDC_POOL_TIMEOUT;
    }

    //
    //  Create an odbc request as we will either use it for the query
    //  or as the key for the cache lookup
    //

	podbcreq = new ODBC_REQ( pecb,
                             dwPoolIDCTimeout,
                             nCharset );

    if( !podbcreq )
    {
        pstrError->LoadString( ERROR_NOT_ENOUGH_MEMORY );
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }

    hr = podbcreq->Create( pszQueryFile, pszParamList );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error creating ODBC_REQ object, hr = 0x%x.\n",
            hr ));

        // Best effort
        pstrError->LoadString( GetLastError() );

        delete podbcreq;
        podbcreq = NULL;

        return hr;
    }

    //
    //  Check to see if user already authentified
    //

    CHAR  achLoggedOnUser[UNLEN + 1];
    DWORD dwLoggedOnUser = sizeof( achLoggedOnUser );
    BOOL  fIsAuth = pecb->GetServerVariable( (HCONN)pecb->ConnID,
                                             "LOGON_USER",
                                             achLoggedOnUser,
                                             &dwLoggedOnUser ) &&
                                             achLoggedOnUser[0] != '\0';

    //
    //  Check to see if the client specified "Pragma: no-cache"
    //
    /* We don't do cache on HTTPODBC any more
    if ( pecb->GetServerVariable( pecb->ConnID,
                                  "HTTP_PRAGMA",
                                  achPragmas,
                                  &cbPragmas ))
    {
        CHAR * pch;

        //
        //  Look for "no-cache"
        //

        pch = _strupr( achPragmas );

        while ( pch = strchr( pch, 'N' ))
        {
            if ( !memcmp( pch, "NO-CACHE", 8 ))
            {
                fRetrieveFromCache = FALSE;
                goto Found;
            }

            pch++;
        }
    }*/

    //
    //  Open the query file and do the query
    //

    hr = podbcreq->OpenQueryFile( pfAccessDenied );
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error opening query file, hr = 0x%x.\n",
            hr ));

        goto Exit;
    }

    hr = podbcreq->ParseAndQuery( achLoggedOnUser );
    if( FAILED( hr ) )
    {
        goto Exit;
    }

    hr = podbcreq->AppendHeaders( &strHeaders );
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error appending headers, hr = 0x%x.\n",
            hr ));

        goto Exit;
    }

    hr = podbcreq->OutputResults( (ODBC_REQ_CALLBACK)OdbcExtensionOutput,
                                   pecb, &strHeaders,
                                   (ODBC_REQ_HEADER)OdbcExtensionHeader,
                                   fIsAuth,
                                   pfAccessDenied );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error in OutputResults(), hr = 0x%x.\n",
            hr ));

        goto Exit;
    }

	delete podbcreq;
	podbcreq = NULL;

	return S_OK;

Exit:

    //
	// Get the ODBC error to report to client
	//
	podbcreq->GetLastErrorText( pstrError );

    delete podbcreq;
    podbcreq = NULL;

    return hr;
}


DWORD
OdbcExtensionOutput(
    EXTENSION_CONTROL_BLOCK * pecb,
    const CHAR *              pchOutput,
    DWORD                     cbOutput
    )
{
    if ( !pecb->WriteClient( pecb->ConnID,
                             (VOID *) pchOutput,
                             &cbOutput,
                             0 ))

    {
        return GetLastError();
    }

    return NO_ERROR;
}


BOOL
OdbcExtensionHeader(
    EXTENSION_CONTROL_BLOCK * pecb,
    const CHAR *              pchStatus,
    const CHAR *              pchHeaders
    )
{
    return pecb->ServerSupportFunction(
                pecb->ConnID,
                HSE_REQ_SEND_RESPONSE_HEADER,
                (LPDWORD) "200 OK",
                NULL,
                (LPDWORD) pchHeaders );
}

BOOL
WINAPI
DllMain(
    HINSTANCE hDll,
    DWORD     dwReason,
    LPVOID    lpvReserved
    )
{
    switch ( dwReason )
    {
    case DLL_PROCESS_ATTACH:

        CREATE_DEBUG_PRINT_OBJECT( "httpodbc.dll");
        SET_DEBUG_FLAGS( 0 );

        DisableThreadLibraryCalls( hDll );
        break;

    case DLL_PROCESS_DETACH:

        DELETE_DEBUG_PRINT_OBJECT();
        break;

    default:
        break;
    }

    return TRUE;
}

BOOL
GetExtensionVersion(
    HSE_VERSION_INFO * pver
    )
{
    HRESULT hr;
    pver->dwExtensionVersion = MAKELONG( 0, 3 );
    strcpy( pver->lpszExtensionDesc,
            "Microsoft HTTP ODBC Gateway, v3.0" );

    hr = ODBCInitialize();
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error on HTTPODBC initialization." ));

        SetLastError( hr );

        return FALSE;
    }

    hr = CoCreateInstance(
        CLSID_MSAdminBase,
        NULL,
        CLSCTX_ALL,
        IID_IMSAdminBase,
        (void**)&g_pMetabase
        );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error getting IMSAdminBase interface." ));

        SetLastError( hr );

        ODBCTerminate();

        return FALSE;
    }

    return TRUE;
}

BOOL
TerminateExtension(
    DWORD   dwFlags
    )
{
    ODBCTerminate();

    if ( g_pMetabase )
    {
        g_pMetabase->Release();
        g_pMetabase = NULL;
    }

    return TRUE;
}

HRESULT
ODBCInitialize(
    VOID
    )
{
    HRESULT  hr = E_FAIL;
    HKEY     hKey;

    if( !InitializeOdbcPool() )
    {
        return hr;
    }

    hr = ODBC_REQ::Initialize();
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error initializing ODBC_REQ, hr = 0x%x.\n",
            hr ));

        TerminateOdbcPool();
        return hr;
    }

    hr = ODBC_STATEMENT::Initialize();
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error initializing ODBC_STATEMENT, hr = 0x%x.\n",
            hr ));

        TerminateOdbcPool();
        ODBC_REQ::Terminate();
        return hr;
    }

    hr = ODBC_CONN_POOL::Initialize();
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error initializing ODBC_CONN_POOL, hr = 0x%x.\n",
            hr ));

        TerminateOdbcPool();
        ODBC_REQ::Terminate();
        ODBC_STATEMENT::Terminate();
        return hr;
    }

    g_fIsSystemDBCS = IsSystemDBCS();

    return hr;
}

VOID
ODBCTerminate(
    VOID
    )
{
    TerminateOdbcPool();
    ODBC_REQ::Terminate();
    ODBC_STATEMENT::Terminate();
    ODBC_CONN_POOL::Terminate();
}

CHAR * skipwhite( CHAR * pch )
{
    CHAR ch;

    while ( 0 != (ch = *pch) )
    {
        if ( ' ' != ch && '\t' != ch )
            break;
        ++pch;
    }

    return pch;
}


CHAR * nextline( CHAR * pch )
{
    CHAR ch;

    while ( 0 != (ch = *pch) )
    {
        ++pch;

        if ( '\n' == ch )
        {
            break;
        }
    }

    return pch;
}


HRESULT
GetIDCCharset(
    CONST CHAR *   pszPath,
    int *          pnCharset,
    STRA *         pstrError
    )
{
    BUFFER           buff;
    HANDLE           hFile;
    DWORD            dwSize;
    DWORD            dwErr;

#define QUERYFILE_READSIZE  4096

    if ( (!pnCharset)  ||  (!pszPath) )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    *pnCharset = CODE_ONLY_SBCS;

    if ( !buff.Resize( QUERYFILE_READSIZE + sizeof(TCHAR) ) )
    {
        pstrError->LoadString( ERROR_NOT_ENOUGH_MEMORY );
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }

    hFile = CreateFileA( pszPath,
                         GENERIC_READ,
                         FILE_SHARE_READ,
                         NULL,
                         OPEN_EXISTING,
                         FILE_ATTRIBUTE_NORMAL |
                         FILE_FLAG_SEQUENTIAL_SCAN,
                         NULL );

    if ( ( INVALID_HANDLE_VALUE == hFile ) ||
         ( NULL == hFile ) )
    {
        LPCSTR apsz[1];

        DBGPRINTF(( DBG_CONTEXT,
            "Error opening query file, hr = 0x%x.\n",
            HRESULT_FROM_WIN32( GetLastError() )
            ));

        apsz[0] = pszPath;
        pstrError->FormatString( ODBCMSG_QUERY_FILE_NOT_FOUND,
                               apsz,
                               IIS_RESOURCE_DLL_NAME_A );
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    if ( !ReadFile( hFile,
                    buff.QueryPtr(),
                    QUERYFILE_READSIZE,
                    &dwSize,
                    NULL ) )
    {
        dwErr = GetLastError();
        pstrError->LoadString( dwErr );
        CloseHandle( hFile );
        return HRESULT_FROM_WIN32( dwErr );
    }

    CloseHandle( hFile );

    *((CHAR *) buff.QueryPtr() + dwSize) = '\0';

    CHAR * pch = (CHAR *)buff.QueryPtr();

    while ( *pch )
    {
        pch = skipwhite( pch );

        if ( 'C' == toupper( *pch ) &&
              !_strnicmp( IDC_FIELDNAME_CHARSET,
                          pch,
                          sizeof(IDC_FIELDNAME_CHARSET)-1 ) )
        {
            pch += sizeof(IDC_FIELDNAME_CHARSET) - 1;
            pch = skipwhite( pch );
            if ( 932 == GetACP() )
            {
                if ( !_strnicmp( IDC_CHARSET_JIS1,
                                 pch,
                                 sizeof(IDC_CHARSET_JIS1)-1 ) ||
                     !_strnicmp( IDC_CHARSET_JIS2,
                                 pch,
                                 sizeof(IDC_CHARSET_JIS2)-1 ) )
                {
                    *pnCharset = CODE_JPN_JIS;
                    break;
                }
                else if ( !_strnicmp( IDC_CHARSET_EUCJP,
                                      pch,
                                      sizeof(IDC_CHARSET_EUCJP)-1 ) )
                {
                    *pnCharset = CODE_JPN_EUC;
                    break;
                }
                else if ( !_strnicmp( IDC_CHARSET_SJIS,
                                      pch,
                                      sizeof(IDC_CHARSET_SJIS)-1 ) )
                {
                    *pnCharset = CODE_ONLY_SBCS;
                    break;
                }
                else
                {
                    LPCSTR apsz[1];
                    //
                    //  illegal value for Charset: field
                    //
                    apsz[0] = pszPath;
                    pstrError->FormatString( ODBCMSG_UNREC_FIELD,
                                             apsz,
                                             IIS_RESOURCE_DLL_NAME_A );
                    return E_FAIL;
                }
            }

//
//          please add code here to support other FE character encoding(FEFEFE)
//
//          else if ( 949 == GetACP() )
//          ...

        }
        pch = nextline( pch );
    }

    return S_OK;
}

HRESULT
ConvertUrlEncodedStringToSJIS(
    int            nCharset,
    STRA *         pstrParams
    )
{
    STACK_STRA( strTemp, MAX_PATH);
    int         cbSJISSize;
    int         nResult;
    HRESULT     hr;

    //
    //  Pre-process the URL encoded parameters
    //

    for ( char * pch = pstrParams->QueryStr(); *pch; ++pch )
    {
        if ( *pch == '&' )
        {
            *pch = '\n';
        }
        else if ( *pch == '+' )
        {
            *pch = ' ';
        }
    }

    //
    //  URL decoding (decode %nn only)
    //

    hr = pstrParams->Unescape();
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error unescaping param string, hr = 0x%x.\n",
            hr ));

        return hr;
    }

    //
    //  charset conversion
    //

    hr = pstrParams->Clone( &strTemp );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error cloning param string, hr = 0x%x.\n",
            hr ));

        return hr;
    }

    hr = strTemp.Copy( pstrParams->QueryStr() );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error copying param string, hr = 0x%x.\n",
            hr ));

        return hr;
    }

    cbSJISSize = UNIX_to_PC( GetACP(),
                             nCharset,
                             (UCHAR *)strTemp.QueryStr(),
                             strTemp.QueryCB(),
                             NULL,
                             0 );

    hr = pstrParams->Resize( cbSJISSize + sizeof(TCHAR) );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error resizing param string buffer, hr = 0x%x.\n",
            hr ));

        return hr;
    }

    nResult = UNIX_to_PC( GetACP(),
                          nCharset,
                          (UCHAR *)strTemp.QueryStr(),
                          strTemp.QueryCB(),
                          (UCHAR *)pstrParams->QueryStr(),
                          cbSJISSize );
    if ( -1 == nResult || nResult != cbSJISSize )
    {
        return E_FAIL;
    }

    DBG_REQUIRE ( pstrParams->SetLen( cbSJISSize) );

    //
    //  URL encoding
    //

    hr = pstrParams->Escape();
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error escaping param string, hr = 0x%x.\n",
            hr ));

        return hr;
    }

    return S_OK;
}

BOOL
IsSystemDBCS(
    VOID
    )
{
    WORD wPrimaryLangID = PRIMARYLANGID( GetSystemDefaultLangID() );

    return ( wPrimaryLangID == LANG_JAPANESE ||
             wPrimaryLangID == LANG_CHINESE  ||
             wPrimaryLangID == LANG_KOREAN );
}

CHAR * FlipSlashes( CHAR * pszPath )
{
    CHAR   ch;
    CHAR * pszScan = pszPath;

    while( ( ch = *pszScan ) != '\0' )
    {
        if( ch == '/' )
        {
            *pszScan = '\\';
        }

        pszScan++;
    }

    return pszPath;

}   // FlipSlashes

HRESULT
GetPoolIDCTimeout(
    unsigned char * szMdPath,
    DWORD *         pdwPoolIDCTimeout
    )
{
    HRESULT         hr = NOERROR;
    DWORD           cbBufferRequired;

    const DWORD     dwTimeout = 2000;

    STACK_STRU(     strMetaPath, MAX_PATH );

    if ( g_pMetabase == NULL )
    {
        return E_NOINTERFACE;
    }

    hr = strMetaPath.CopyA( (LPSTR)szMdPath );
    if( FAILED(hr) )
    {
        return hr;
    }

    METADATA_HANDLE     hKey = NULL;
    METADATA_RECORD     MetadataRecord;

    hr = g_pMetabase->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                               strMetaPath.QueryStr(),
                               METADATA_PERMISSION_READ,
                               dwTimeout,
                               &hKey
                               );

    if( SUCCEEDED(hr) )
    {
        MetadataRecord.dwMDIdentifier = MD_POOL_IDC_TIMEOUT;
        MetadataRecord.dwMDAttributes = METADATA_INHERIT;
        MetadataRecord.dwMDUserType = IIS_MD_UT_FILE;
        MetadataRecord.dwMDDataType = DWORD_METADATA;
        MetadataRecord.dwMDDataLen = sizeof( DWORD );
        MetadataRecord.pbMDData = (unsigned char *) pdwPoolIDCTimeout;
        MetadataRecord.dwMDDataTag = 0;

        hr = g_pMetabase->GetData( hKey,
                                   L"",
                                   &MetadataRecord,
                                   &cbBufferRequired
                                   );

        g_pMetabase->CloseKey( hKey );
    }

    return hr;
}

HRESULT
SendCustomError(
    EXTENSION_CONTROL_BLOCK *pecb,
    const CHAR              *pszStatus
)
/*++
Routine Description:

    reports custom error

Arguments:
    pecb
    pszStatus - Status to be reported. If NULL "500" will be sent.

Return Value:

    HRESULT
--*/
{
    // Locals
    HRESULT                 hr = S_OK;
    BOOL                    fRet;
    HSE_CUSTOM_ERROR_INFO   *pCustomErrorInfo = NULL;
    DWORD                   cch;

    // Check args
    DBG_ASSERT( pecb );

    if ( !pecb )
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    // If supplied status
    if (pszStatus)
    {
        cch = strlen( pszStatus )+1;
    }
    else
    {
        pszStatus = c_sz500InternalServerError;
        cch = ARRAYSIZE( c_sz500InternalServerError );
    }

    // Allocate
    pCustomErrorInfo = (HSE_CUSTOM_ERROR_INFO*)(new BYTE[sizeof(HSE_CUSTOM_ERROR_INFO)+cch]);
    if ( !pCustomErrorInfo )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Exit;
    }
    pCustomErrorInfo->pszStatus = (CHAR*)pCustomErrorInfo+sizeof(HSE_CUSTOM_ERROR_INFO);

    // Set the callback
    fRet = pecb->ServerSupportFunction( pecb->ConnID,
                                        HSE_REQ_IO_COMPLETION,
                                        CustomErrorCompletion,
                                        0,
                                        (DWORD*)pCustomErrorInfo );
    if ( !fRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Exit;
    }

    // All custom errors must be asynchronous
    pCustomErrorInfo->fAsync = TRUE;

    // Copy the status
    memmove( pCustomErrorInfo->pszStatus,
             pszStatus,
             cch*sizeof(CHAR));
    pCustomErrorInfo->uHttpSubError = 0;

    fRet = pecb->ServerSupportFunction( pecb->ConnID,
                                        HSE_REQ_SEND_CUSTOM_ERROR,
                                        pCustomErrorInfo,
                                        NULL,
                                        NULL );
    if ( !fRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Exit;
    }

    // Don't free
    pCustomErrorInfo = NULL;

Exit:
    // Cleanup
    if (pCustomErrorInfo)
    {
        delete[] (BYTE*)pCustomErrorInfo;
        pCustomErrorInfo = NULL;
    }

    return hr;
}

VOID WINAPI
CustomErrorCompletion(
    EXTENSION_CONTROL_BLOCK *pecb,
    PVOID                   pContext,
    DWORD                   /*cbIO*/,
    DWORD                   /*dwError*/
    )
/*++
Routine Description:

    completion routine (for async custom error send)

Arguments:

Return Value:
    VOID
--*/
{
    HRESULT                 hr = S_OK;
    BOOL                    fRet;

    // Check args
    if ( pecb == NULL)
    {
        hr = E_INVALIDARG;

        DBGPRINTF(( DBG_CONTEXT,
                    "NULL pecb in CustomErrorCompletion().\n"));

        goto Exit;
    }

    // Notify IIS that we are done with processing
    fRet = pecb->ServerSupportFunction( pecb->ConnID,
                                        HSE_REQ_DONE_WITH_SESSION,
                                        NULL,
                                        NULL,
                                        NULL );
    if ( !fRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        DBGPRINTF(( DBG_CONTEXT,
                    "HSE_REQ_DONE_WITH_SESSION failed, hr = 0x%x.\n",
                    hr ));
        goto Exit;
    }

Exit:

    // Cleanup
    if ( pContext )
    {
        // Free
        delete[] (BYTE*)pContext;
        pContext = NULL;
    }
}

HRESULT
SendErrorResponse(
    EXTENSION_CONTROL_BLOCK *pecb,
    const CHAR              *pszStatus,
    DWORD                   dwResID,
    const CHAR              *pszParam
)
/*++
Routine Description:

    reports error via HSE_REQ_SEND_RESPONSE_HEADER

Arguments:
    pecb
    pszStatus   - Status to be reported. If NULL "500" will be sent.
    dwResID     - Error message to be sent in the body.
    pszParam    - string parameter for the message. Can NULL.

Return Value:

    HRESULT
--*/
{
    // Locals
    HRESULT                 hr=S_OK;
    BOOL                    fRet;
    STRA                    str;
    CHAR                    szParam[1024];
    const CHAR              *rgszT[1] = { szParam };

    // Check args
    if ( !pecb )
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    // If no status given set "500 Internal Server Error"
    if ( !pszStatus )
    {
        pszStatus = c_sz500InternalServerError;
    }

    if ( !pszParam )
    {
        // If no parameter given set emtpy string
        *szParam = '\0';
    }
    else
    {
        //
        //  Note we terminate the error message (ODBC sometimes generates
        //  22k errors)
        //
        strncpy( szParam,
                 pszParam,
                 ARRAYSIZE( szParam )-1 );

        szParam[ ARRAYSIZE( szParam )-1 ] = '\0';

    }

    //
    //  *and* we double the buffer size we pass to FormatString()
    //  because the win32 API FormatMessage() has a bug that doesn't
    //  account for Unicode conversion
    //
    hr = str.FormatString( dwResID,
                           rgszT,
                           IIS_RESOURCE_DLL_NAME_A,
                           2*ARRAYSIZE( szParam ) );
    if ( FAILED( hr ) )
    {
        goto Exit;
    }

    // Send the error
    fRet = pecb->ServerSupportFunction( pecb->ConnID,
                                        HSE_REQ_SEND_RESPONSE_HEADER,
                                        (DWORD*)pszStatus,
                                        NULL,
                                        (DWORD*)str.QueryStr() );
    if ( !fRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Exit;
    }

Exit:
    // Done
    return hr;
}

HRESULT
SendErrorResponseFromHr(
    EXTENSION_CONTROL_BLOCK *pecb,
    const CHAR              *pszStatus,
    DWORD                   dwResID,
    HRESULT                 hrError
    )
/*++
Routine Description:

    reports error via HSE_REQ_SEND_RESPONSE_HEADER

Arguments:
    pecb
    pszStatus   - Status to be reported. If NULL "500" will be sent.
    dwResID     - Error message to be sent in the body.
    hrError     - HRESULT to be reported. The description of the error will be
                  used as a parameter for the message. MUST be a failure.

Return Value:

    HRESULT
--*/
{
    // Locals
    HRESULT                 hr=S_OK;
    STRA                    strError;

    // Check args
    if ( !pecb )
    {
        hr = E_INVALIDARG;
        goto Exit;
    }
    if ( SUCCEEDED( hrError ) )
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    // Get the description of the last error
    hr = strError.LoadString( WIN32_FROM_HRESULT( hrError ),
                              (LPCSTR)NULL );
    if ( FAILED( hr ) )
    {
        goto Exit;
    }

    // Call SendErrorResponse
    hr = SendErrorResponse( pecb,
                            pszStatus,
                            dwResID,
                            strError.QueryStr() );

Exit:
    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\odbc\odbcpool.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    odbcpool.cxx

Abstract:

    Provides simple ODBC connection pooling for IDC.  The only keys 
    used for the connection pooling is the datasource name, the 
    username and password. ODBC options and other connection state 
    are not taken into consideration.

Author:

    John Ludeman (johnl)   01-Apr-1996

Revision History:
--*/

#include "precomp.hxx"

//
//  Globals
//

CRITICAL_SECTION               g_csPoolLock;

LIST_ENTRY                     g_PoolList;

DWORD                          g_dwTimeoutID = 0;

//
// Various counters
//

DWORD                          g_cFree;
DWORD                          g_cUsed;

ALLOC_CACHE_HANDLER *          ODBC_CONN_POOL::sm_pachOdbcConnPools;

//static
HRESULT
ODBC_CONN_POOL::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize ODBC_CONN_POOL lookaside

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ALLOC_CACHE_CONFIGURATION       acConfig;

    acConfig.nConcurrency = 1;
    acConfig.nThreshold = 100;
    acConfig.cbSize = sizeof( ODBC_CONN_POOL );

    DBG_ASSERT( sm_pachOdbcConnPools == NULL );
    
    sm_pachOdbcConnPools = new ALLOC_CACHE_HANDLER( "ODBC_CONN_POOL",  
                                                     &acConfig );

    if ( sm_pachOdbcConnPools == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }
    
    return NO_ERROR;
}

//static
VOID
ODBC_CONN_POOL::Terminate(
    VOID
)
/*++

Routine Description:

    Terminate ODBC_CONN_POOL lookaside

Arguments:

    None

Return Value:

    None

--*/
{
    if ( sm_pachOdbcConnPools != NULL )
    {
        delete sm_pachOdbcConnPools;
        sm_pachOdbcConnPools = NULL;
    }
}

VOID
WINAPI
IDCPoolScavenger(
    PVOID pContext
    );

BOOL
InitializeOdbcPool(
    VOID
    )
{
    InitializeListHead( &g_PoolList );
    INITIALIZE_CRITICAL_SECTION( &g_csPoolLock );

    //
    //  Kick off the pool scavenger
    //

    g_dwTimeoutID = ScheduleWorkItem( IDCPoolScavenger,
                                      NULL,
                                      IDC_POOL_TIMEOUT * 1000,
                                      TRUE );

    return TRUE;
}

VOID
TerminateOdbcPool(
    VOID
    )
{
    ODBC_CONN_POOL * pOCPool;

    if ( g_dwTimeoutID )
    {
        RemoveWorkItem( g_dwTimeoutID );
        g_dwTimeoutID = 0;
    }

    EnterCriticalSection( &g_csPoolLock );

    while ( !IsListEmpty( &g_PoolList ))
    {
        LIST_ENTRY * pEntry = g_PoolList.Flink;

        RemoveEntryList( pEntry );

        pOCPool = CONTAINING_RECORD( pEntry,
                                     ODBC_CONN_POOL,
                                     m_ListEntry );

        delete pOCPool;
        pOCPool = NULL;
    }

    LeaveCriticalSection( &g_csPoolLock );
    DeleteCriticalSection( &g_csPoolLock );
}

HRESULT
OpenConnection(
    IN  ODBC_CONNECTION *   podbcconnNonPooled,
    OUT ODBC_CONNECTION * * ppodbcconnToUse,
    IN  DWORD               csecPoolTimeout,
    IN  const CHAR *        pszDataSource,
    IN  const CHAR *        pszUsername,
    IN  const CHAR *        pszPassword,
    IN  const CHAR *        pszLoggedOnUser
    )
/*++

Routine Description:

    This function opens an odbc connection, optionally from a pool of
    ODBC connections.

Arguments:

    podbcconnNonPooled - If pooling wasn't requested or the open 
                         failed, we use this odbc connection object
    ppodbcconnToUse - Receives pointer to either a pooled ODBC 
                      connection object or podbcconnNonPooled if a 
                      pooled object couldn't be used
    csecPoolTimeout - Amount of time to pool a connection, 0 to not 
                      pool
    pszDataSource - ODBC Datasource
    pszUsername - Username for datasource access
    pszPassword - Password for use with this username
    pszLoggedOnUser - The NT account this user is running under

Return Value:

    HRESULT

    ppodbcconnToUse will be set to the ODBC connection to use for the
        request

--*/
{
    LIST_ENTRY *     pEntry;
    ODBC_CONN_POOL * pOCPool;
    HRESULT          hr;

    //
    //  Don't pool this connection if it wasn't requested
    //

    if ( !csecPoolTimeout )
    {
        *ppodbcconnToUse = podbcconnNonPooled;

        return podbcconnNonPooled->Open( pszDataSource,
                                         pszUsername,
                                         pszPassword );
    }

    //
    //  Look in the pool cache for an existing connection
    //

    EnterCriticalSection( &g_csPoolLock );

    for ( pEntry  = g_PoolList.Flink;
          pEntry != &g_PoolList;
          pEntry  = pEntry->Flink )
    {
        pOCPool = CONTAINING_RECORD( pEntry,
                                     ODBC_CONN_POOL,
                                     m_ListEntry );

        if ( pOCPool->IsFree()                        &&
             !lstrcmpiA( pOCPool->QueryDataSource(), 
                         pszDataSource )               &&
             !lstrcmpiA( pOCPool->QueryUsername(), 
                         pszUsername )                 &&
             !lstrcmpiA( pOCPool->QueryLoggedOnUser(), 
                         pszLoggedOnUser )             &&
             !strcmp( pOCPool->QueryPassword(),
                      pszPassword ))

        {
            //
            //  We have a match
            //

            pOCPool->MarkAsUsed();
            *ppodbcconnToUse = pOCPool->QueryOdbcConnection();
            pOCPool->SetTTL( csecPoolTimeout );
            LeaveCriticalSection( &g_csPoolLock );

            return S_OK;
        }
    }

    LeaveCriticalSection( &g_csPoolLock );

    //
    //  Allocate a new connection pool and if we connect successfully, 
    //  put it in the pool list
    //

    pOCPool = new ODBC_CONN_POOL();
    
    if( pOCPool == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }

    hr = pOCPool->Create( pszDataSource,
                         pszUsername,
                         pszPassword,
                         pszLoggedOnUser );
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error creating pool connection, hr = 0x%x.\n",
            hr ));

        return hr;
    }

    if ( FAILED( pOCPool->Open() ) )
    {
        delete pOCPool;
        pOCPool = NULL;

        *ppodbcconnToUse = podbcconnNonPooled;

        return podbcconnNonPooled->Open( pszDataSource,
                                         pszUsername,
                                         pszPassword );
    }

    *ppodbcconnToUse = pOCPool->QueryOdbcConnection();

    EnterCriticalSection( &g_csPoolLock );

    //
    //  Account for the new pool item but we have to do it 
    //  with in the critical section
    //

    g_cFree++;

    pOCPool->MarkAsUsed();
    pOCPool->SetTTL( csecPoolTimeout );
    InsertHeadList( &g_PoolList, &pOCPool->m_ListEntry );

    LeaveCriticalSection( &g_csPoolLock );

    return S_OK;
}

VOID
CloseConnection(
    IN  ODBC_CONNECTION *   podbcconnPooled,
    IN  BOOL                fDelete
    )
/*++

Routine Description:

    This routine frees an ODBC connection back to the pool, 
    optionally deleting it

Arguments:

    podbcconnPooled - ODBC connection that is pooled, can be NULL
    fDelete - TRUE if the item should be delete rather then returned 
              to the pool
--*/
{
    LIST_ENTRY *     pEntry;
    ODBC_CONN_POOL * pOCPool;

    if ( !podbcconnPooled )
    {
        return;
    }

    //
    //  Look in the pool list to mark it as free
    //

    EnterCriticalSection( &g_csPoolLock );

    for ( pEntry  = g_PoolList.Flink;
          pEntry != &g_PoolList;
          pEntry  = pEntry->Flink )
    {
        pOCPool = CONTAINING_RECORD( pEntry,
                                     ODBC_CONN_POOL,
                                     m_ListEntry );

        if ( podbcconnPooled == pOCPool->QueryOdbcConnection() )
        {
            pOCPool->MarkAsFree();

            if ( fDelete )
            {
                RemoveEntryList( pEntry );
                g_cFree--;
                delete pOCPool;
                pOCPool = NULL;
            }

            break;
        }
    }

    LeaveCriticalSection( &g_csPoolLock );
}

VOID
WINAPI
IDCPoolScavenger(
    PVOID pContext
    )
/*++

Routine Description:

    Walks the list of pooled connections and removes any that have 
    timed out

--*/
{
    LIST_ENTRY *     pEntry;
    LIST_ENTRY *     pNext;
    ODBC_CONN_POOL * pOCPool;

    //
    //  Look through the list and remove any old items
    //

    EnterCriticalSection( &g_csPoolLock );

    for ( pEntry  = g_PoolList.Flink;
          pEntry != &g_PoolList;
          pEntry  = pNext )
    {
        pNext = pEntry->Flink;

        pOCPool = CONTAINING_RECORD( pEntry,
                                     ODBC_CONN_POOL,
                                     m_ListEntry );

        if ( pOCPool->IsFree() && !pOCPool->DecrementTTL() )
        {
            RemoveEntryList( pEntry );
            g_cFree--;
            delete pOCPool;
            pOCPool = NULL;
        }
    }

    LeaveCriticalSection( &g_csPoolLock );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\odbc\parmlist.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    parmlist.cxx

Abstract:

    Simple class for parsing and storing parameter list pairs

Author:

    John Ludeman (johnl)   22-Feb-1995

Revision History:

--*/

//
//  System include files.
//

#include "precomp.hxx"

inline
HRESULT
UnescapeStr( 
    STRA * pstr 
    )
{
    CHAR * pch;

    pch = pstr->QueryStr();
    pch = strchr( pch, '+' );
    while ( pch )
    {
        *pch = ' ';
        pch = strchr( pch, '+' );
    }

    return pstr->Unescape();
}

PARAM_LIST::~PARAM_LIST(
    VOID
    )
/*++

Routine Description:

    Param list destructor

--*/
{
    FIELD_VALUE_PAIR * pFVP;

    while ( !IsListEmpty( &_FieldListHead ) )
    {
        pFVP = CONTAINING_RECORD( _FieldListHead.Flink,
                                  FIELD_VALUE_PAIR,
                                  ListEntry );

        DBG_ASSERT( pFVP != NULL );

        RemoveEntryList( &pFVP->ListEntry );

        delete( pFVP );
        pFVP = NULL;
    }

    while ( !IsListEmpty( &_FreeHead ))
    {
        pFVP = CONTAINING_RECORD( _FreeHead.Flink,
                                  FIELD_VALUE_PAIR,
                                  ListEntry );

        DBG_ASSERT( pFVP != NULL );

        RemoveEntryList( &pFVP->ListEntry );

        delete( pFVP );
        pFVP = NULL;
    }
}

VOID
PARAM_LIST::Reset(
    VOID
    )
/*++

Routine Description:

    Resets the parameter list back to its initially constructed state

--*/
{
    FIELD_VALUE_PAIR * pFVP;

    while ( !IsListEmpty( &_FieldListHead ) )
    {
        pFVP = CONTAINING_RECORD( _FieldListHead.Flink,
                                  FIELD_VALUE_PAIR,
                                  ListEntry );

        DBG_ASSERT( pFVP != NULL );

        RemoveEntryList( &pFVP->ListEntry );

        //
        //  Put the removed item on the end so the same entry will 
        //  tend to be used for the same purpose on the next use
        //

        InsertTailList( &_FreeHead, &pFVP->ListEntry );
    }

    _fCanonicalized = FALSE;
}

HRESULT
PARAM_LIST::ParsePairs(
    const CHAR * pszList,
    BOOL         fDefaultParams,
    BOOL         fAddBlankValues,
    BOOL         fCommaIsDelim
    )
/*++

Routine Description:

    Puts the text list into a linked list of field/value pairs

    This can be used to parse lists in the form of:

    "a=b,c=d,e=f" (with fCommaIsDelim = TRUE)
    "name=Joe, Billy\nSearch=tom, sue, avery"(with fCommaIsDelim = FALSE)

    Duplicates will be appended and tab separated

Arguments:

    pszList - list of comma separated field/value pairs
    fDefaultParams - If TRUE, means these parameters are only defaults 
                     and shouldn't be added to the list if the field 
                     name is already in the list and the value is 
                     non-empty.
    fAddBlankValues - if TRUE, allow fields with empty values to be 
                      added to the list, else ignore empty values.
    fCommaIsDelim - if TRUE, a comma acts as a separator between two 
                    sets of fields values, otherwise the comma is 
                    ignored

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    CHAR *             pch;
    DWORD              cParams = 0;
    DWORD              i;
    STRA               strParams;
    STRA               strField;
    HRESULT            hr;

    //
    //  Make a copy we can muck with
    //

    hr = strParams.Copy( pszList );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "Error copying field/value pairs list, hr = 0x%x.\n",
                   hr ));

        return hr;
    }

    //
    //  Replace all of the equal signs and commas with '\n's for 
    //  easier parsing
    //

    pch = strParams.QueryStr();
    pch = strchr( pch, '=' );
    while ( pch )
    {
        *pch = '\n';
        cParams++;
        pch = strchr( pch, '=' );
    }

    if ( fCommaIsDelim )
    {
        pch = strParams.QueryStr();
        pch = strchr( pch, ',' );
        while ( pch )
        {
            *pch = '\n';
            cParams++;
            pch = strchr( pch, ',' );
        }
    }

    //
    //  Pick out the fields and values and build the associative list
    //

    ODBC_PARSER Parser( strParams.QueryStr() );

    for ( i = 0; i < cParams; i++ )
    {
        hr = strField.Copy( Parser.QueryToken() );
        if ( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                       "Error copying token, hr = 0x%x.\n",
                       hr ));
            return hr;
        }

        Parser.NextLine();

        pch = Parser.QueryToken();

        //
        //  If we aren't supposed to add blanks, then just go to the next
        //  line
        //

        if ( !fAddBlankValues && !*pch )
        {
            Parser.NextLine();
            continue;
        }

        if ( !fDefaultParams )
        {
            FIELD_VALUE_PAIR * pFVP;
            LIST_ENTRY *       ple;

            //
            //  Look for an existing field with this name and append
            //  the value there if we find it, otherwise add a new entry
            //

            for ( ple  = _FieldListHead.Flink;
                  ple != &_FieldListHead;
                  ple  = ple->Flink )
            {
                pFVP = CONTAINING_RECORD( ple, 
                                          FIELD_VALUE_PAIR, 
                                          ListEntry );

                if ( !_stricmp( pFVP->QueryField(),
                               strField.QueryStr() ))
                {
                    //
                    //  CODEWORK - Remove this allocation
                    //

                    STRA strtmp;

                    hr = strtmp.Copy( pch );
                    if( FAILED( hr ) )
                    {
                        DBGPRINTF(( DBG_CONTEXT,
                                    "Error copying, hr = 0x%x.\n",
                                    hr ));
                        return hr;
                    }

                    //
                    //  Found this header, append the new value
                    //

                    pFVP->_cValues++;

                    hr = UnescapeStr( &strtmp );
                    if( FAILED( hr ) )
                    {
                        DBGPRINTF(( DBG_CONTEXT,
                            "Error unescaping string, hr = 0x%x.\n",
                            hr ));

                        return hr;
                    }       
                    
                    hr = pFVP->_strValue.Append( "\t" );
                    if( FAILED( hr ) )
                    {
                        DBGPRINTF(( DBG_CONTEXT,
                            "Error appending '\t', hr = 0x%x.\n",
                            hr ));
                        return hr;
                    } 
                         
                    hr = pFVP->_strValue.Append( strtmp );

                    goto Found;
                }
            }

            hr = AddEntry( strField.QueryStr(),
                           pch,
                           TRUE );
Found:
            ;
        }
        else
        {
            //
            //  Don't add if already in list
            //

            hr = AddParam( strField.QueryStr(),
                             pch );
        }

        if ( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                   "Error parsing pairs list, hr = 0x%x.\n",
                   hr ));

            return hr;
        }

        Parser.NextLine();
    }

    return hr;
}

HRESULT
PARAM_LIST::AddEntryUsingConcat(
    const CHAR * pszField,
    const CHAR * pszValue,
    BOOL  fPossibleFastMap
)
/*++

Routine Description:

    Concatenate value with existing entry of same name
    or call AddEntry if none exists

Arguments:

    pszField         - Field to add
    pszValue         - Value to add
    fPossibleFastMap - TRUE if entry is not known not to be
                       in the fast map


Return Value:

    TRUE if successful, FALSE on error

--*/
{
    //
    //  Look for an existing field with this name
    //  and add the value there
    //

    FIELD_VALUE_PAIR * pFVP;
    LIST_ENTRY *       ple;
    HRESULT            hr;

    //
    //  Find the field
    //

    for ( ple  = _FieldListHead.Flink;
          ple != &_FieldListHead;
          ple  = ple->Flink )
    {
        pFVP = CONTAINING_RECORD( ple, FIELD_VALUE_PAIR, ListEntry );

        if ( !_stricmp( pFVP->QueryField(),
                       pszField ))
        {
            //
            //  Found this header, append the new value
            //

            pFVP->_cValues++;

            hr = pFVP->_strValue.Append( "," );
            if( FAILED( hr ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                   "Error appending ',', hr = 0x%x.\n",
                   hr ));

                return hr;
            } 
            
            hr = pFVP->_strValue.Append( pszValue );

            goto Found;
        }
    }

    hr = AddEntry( pszField,
                   pszValue,
                   FALSE,
                   fPossibleFastMap );

Found:

    return hr;
}



HRESULT
PARAM_LIST::ParseSimpleList(
    const CHAR * pszList
    )
/*++

Routine Description:

    Puts the comma separated list into a linked list of field/value pairs
    where the value is always NULL

Arguments:

    pszList - list of comma separated fields

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    CHAR *             pch;
    HRESULT            hr = S_OK;

    //
    //  Pick out the fields and values and build the associative list
    //

    ODBC_PARSER Parser( (CHAR *) pszList );

    Parser.SetListMode( TRUE );

    while ( *(pch = Parser.QueryToken()) )
    {
        hr = AddEntry( pch,
                       NULL,
                       TRUE );

        if ( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                   "Error AddEntry, hr = 0x%x.\n",
                   hr ));

            return hr;
        }

        Parser.NextItem();
    }

    return hr;
}

CHAR *
PARAM_LIST::FindValue(
    const CHAR * pszField,
    BOOL *       pfIsMultiValue  OPTIONAL,
    DWORD *      pcbValue OPTIONAL
    )
/*++

Routine Description:

    Returns the value associated with pszField or NULL of no value was
    found

Arguments:

    pszField - field to search for value for
    pfIsMultiValue - Set to TRUE if this value is a composite of multiple fields
    pcbValue - Set to size of value (excluding nul terminator)


Return Value:

    Pointer to value or NULL if not found

--*/
{
    FIELD_VALUE_PAIR * pFVP;
    LIST_ENTRY *       ple;

    //
    // Do we need to canon?
    //

    if ( !IsCanonicalized() )
    {
        CanonList( );
    }

    //
    //  Find the field
    //

    for ( ple  = _FieldListHead.Flink;
          ple != &_FieldListHead;
          ple  = ple->Flink )
    {
        pFVP = CONTAINING_RECORD( ple, FIELD_VALUE_PAIR, ListEntry );

        if ( !_stricmp( pFVP->QueryField(),
                       pszField ))
        {
            if ( pfIsMultiValue )
            {
                *pfIsMultiValue = pFVP->IsMultiValued();
            }

            if ( pcbValue )
            {
                *pcbValue = pFVP->_strValue.QueryCB();
            }

            return pFVP->QueryValue();
        }
    }


    return NULL;
}

HRESULT
PARAM_LIST::AddEntry(
    const CHAR * pszField,
    const CHAR * pszValue,
    BOOL         fUnescape,
    BOOL         fPossibleFastMap
    )
/*++

Routine Description:

    Unconditionally adds the field/value pair to the end of the list

Arguments:

    pszField         - Field to add
    pszValue         - Value to add
    fPossibleFastMap - TRUE if entry is not known not to be
                   in the fast map


Return Value:

    TRUE if successful, FALSE on error

--*/
{
    FIELD_VALUE_PAIR * pFVP;
    HRESULT            hr;

    if ( !IsListEmpty( &_FreeHead ) )
    {
        LIST_ENTRY * pEntry;

        pEntry = _FreeHead.Flink;

        RemoveEntryList( _FreeHead.Flink );

        pFVP = CONTAINING_RECORD( pEntry, FIELD_VALUE_PAIR, ListEntry );

        pFVP->_strField.Reset();
        pFVP->_strValue.Reset();
    }
    else
    {
        pFVP = new FIELD_VALUE_PAIR;

        if ( !pFVP )
        {
            hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
            DBGPRINTF(( DBG_CONTEXT,
                   "Error creating new FIELD_VALUE_PAIR, hr = 0x%x.\n",
                   hr ));

            return hr;
        }
    }

    pFVP->_cValues = 1;

    //
    //  Add it to the list now so we don't have to worry about deleting it
    //  if one of the below copies fail
    //

    InsertTailList( &_FieldListHead, &pFVP->ListEntry );

    hr = pFVP->_strField.Copy( pszField );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "Error copying field, hr = 0x%x.\n",
                   hr ));
        return hr;
    }

    hr = pFVP->_strValue.Copy( pszValue );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "Error copying value, hr = 0x%x.\n",
                   hr ));
        return hr;
    }

    if ( fUnescape )
    {
        //
        //  Normalize the fields and values (unescape and replace
        //  '+' with ' ')
        //

        hr = UnescapeStr( &pFVP->_strField );
        if( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                   "Error unescaping field, hr = 0x%x.\n",
                   hr ));
            return hr;
        }

        hr = UnescapeStr( &pFVP->_strValue );
        if( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                   "Error unescaping value, hr = 0x%x.\n",
                   hr ));
            return hr;
        }
    }

    return hr;
}

HRESULT
PARAM_LIST::AddEntry(
    const CHAR * pszField,
    DWORD        cbField,
    const CHAR * pszValue,
    DWORD        cbValue
    )
/*++

Routine Description:

    Unconditionally adds the field/value pair to the end of the list

    The fast map is not used and the fields are not unescaped

Arguments:

    pszField         - Field to add
    cbField          - Number of bytes in pszField
    pszValue         - Value to add
    cbValue          - Number of bytes in pszValue

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    FIELD_VALUE_PAIR *  pFVP;
    PLIST_ENTRY         listEntry;
    HRESULT             hr;

    listEntry = RemoveHeadList( &_FreeHead );

    if ( listEntry != &_FreeHead )
    {
        pFVP = CONTAINING_RECORD(
                            listEntry,
                            FIELD_VALUE_PAIR,
                            ListEntry );

        pFVP->_strField.Reset();
        pFVP->_strValue.Reset();
    }
    else
    {
        pFVP = new FIELD_VALUE_PAIR;

        if ( !pFVP )
        {
            hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
            DBGPRINTF(( DBG_CONTEXT,
                   "Error creating new FIELD_VALUE_PAIR, hr = 0x%x.\n",
                   hr ));

            return hr;
        }
    }

    pFVP->_cValues = 1;

    //
    //  Add it to the list now so we don't have to worry about deleting it
    //  if one of the below copies fail
    //

    InsertTailList( &_FieldListHead, &pFVP->ListEntry );

    hr = pFVP->_strField.Copy( pszField, cbField );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "Error copying field, hr = 0x%x.\n",
                   hr ));
        return hr;
    }

    hr = pFVP->_strValue.Copy( pszValue, cbValue );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "Error copying value, hr = 0x%x.\n",
                   hr ));
        return hr;
    }

    return hr;
}

HRESULT 
PARAM_LIST::AddParam(
    const CHAR * pszField,
    const CHAR * pszValue
    )
/*++

Routine Description:

    Adds a field/value pair to the list if the field isn't already in the list
    or the value is empty

    The fields added through this method will be escaped

Arguments:

    pszField - Field to add
    pszValue - Value to add


Return Value:

    TRUE if successful, FALSE on error

--*/
{
    FIELD_VALUE_PAIR * pFVP;
    LIST_ENTRY *       ple;

    //
    //  Find the field
    //

    for ( ple  = _FieldListHead.Flink;
          ple != &_FieldListHead;
          ple  = ple->Flink )
    {
        pFVP = CONTAINING_RECORD( ple, FIELD_VALUE_PAIR, ListEntry );

        if ( !_stricmp( pFVP->QueryField(),
                        pszField ) )
        {
            //
            //  We found the field, replace the value if it is empty
            //

            if ( !*pFVP->QueryValue() )
            {
                return pFVP->_strValue.Copy( pszValue );
            }

            return S_OK;
        }
    }

    //
    //  The field name wasn't found, add it
    //

    return AddEntry( pszField,
                     pszValue,
                     TRUE );
}

BOOL
PARAM_LIST::RemoveEntry(
    const CHAR * pszFieldName
    )
/*++

Routine Description:

    Removes all occurrences of the specified fieldname from the list

Arguments:

    pszField - Field to remove

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    FIELD_VALUE_PAIR * pFVP;
    LIST_ENTRY *       ple;
    LIST_ENTRY *       pleNext;
    BOOL               fFound = FALSE;

    //
    // Do we need to canon?
    //

    if ( !IsCanonicalized() )
    {
        CanonList( );
    }

    //
    //  Find the field
    //

    for ( ple  = _FieldListHead.Flink;
          ple != &_FieldListHead;
          ple  = pleNext )
    {
        pleNext = ple->Flink;

        pFVP = CONTAINING_RECORD( ple, FIELD_VALUE_PAIR, ListEntry );

        if ( !_stricmp( pFVP->QueryField(),
                       pszFieldName ))
        {
            //
            //  We found a matching field, remove it
            //

            RemoveEntryList( ple );

            InsertHeadList( &_FreeHead, ple );

            fFound = TRUE;
        }
    }

    return (fFound);
}


VOID *
PARAM_LIST::NextPair(
    VOID *   pCookie,
    CHAR * * ppszField,
    CHAR * * ppszValue
    )
/*++

Routine Description:

    Enumerates the field and values in this parameter list

Arguments:

    pCookie - Stores location in enumeration, set to NULL for new enumeration
    ppszField - Receives field
    ppszValue - Receives corresponding value

Return Value:

    NULL when the enumeration is complete

--*/
{
    FIELD_VALUE_PAIR * pFVP;

    //
    // Do we need to canon?
    //

    if ( !IsCanonicalized() )
    {
        CanonList( );
    }

    //
    //  pCookie points to the ListEntry in the FIELD_VALUE_PAIR class
    //
    if ( pCookie == NULL )
    {

        if ( IsListEmpty( &_FieldListHead ))
        {
            return NULL;
        }

        //
        //  Start a new enumeration
        //

        pCookie = (VOID *) _FieldListHead.Flink;
    }
    else
    {
        //
        //  Have we finished the current enumeration?
        //

        if ( pCookie == (VOID *) &_FieldListHead )
        {
            return NULL;
        }
    }

    pFVP = CONTAINING_RECORD( pCookie, FIELD_VALUE_PAIR, ListEntry );

    *ppszField = pFVP->QueryField();
    *ppszValue = pFVP->QueryValue();

    pCookie = pFVP->ListEntry.Flink;

    return pCookie;
}

VOID *
PARAM_LIST::NextPair(
    VOID *   pCookie,
    CHAR * * ppszField,
    DWORD *  pcbField,
    CHAR * * ppszValue,
    DWORD *  pcbValue
    )
/*++

Routine Description:

    Enumerates the field and values in this parameter list

Arguments:

    pCookie - Stores location in enumeration, set to NULL for new enumeration
    ppszField - Receives field
    pcbField -  Receives pointer to length of field
    ppszValue - Receives corresponding value
    pcbValue -  Receives pointer to length of value

Return Value:

    NULL when the enumeration is complete

--*/
{
    FIELD_VALUE_PAIR * pFVP;

    //
    // Do we need to canon?
    //

    if ( !IsCanonicalized() )
    {
        CanonList( );
    }

    //
    //  pCookie points to the ListEntry in the FIELD_VALUE_PAIR class
    //

    if ( pCookie == NULL )
    {

        if ( IsListEmpty( &_FieldListHead ))
        {
            return NULL;
        }

        //
        //  Start a new enumeration
        //

        pCookie = (VOID *) _FieldListHead.Flink;
    }
    else
    {
        //
        //  Have we finished the current enumeration?
        //

        if ( pCookie == (VOID *) &_FieldListHead )
        {
            return NULL;
        }
    }

    pFVP = CONTAINING_RECORD( pCookie, FIELD_VALUE_PAIR, ListEntry );

    *ppszField = pFVP->QueryField();
    *pcbField  = pFVP->_strField.QueryCB();

    *ppszValue = pFVP->QueryValue();
    *pcbValue  = pFVP->_strValue.QueryCB();

    pCookie = pFVP->ListEntry.Flink;

    return pCookie;
}

DWORD
PARAM_LIST::GetCount(
    VOID
    )
{
    LIST_ENTRY * pEntry;
    DWORD        cParams = 0;

    //
    // Do we need to canon?
    //

    if ( !IsCanonicalized() )
    {
        CanonList( );
    }

    for ( pEntry = _FieldListHead.Flink;
          pEntry != &_FieldListHead;
          pEntry = pEntry->Flink )
    {
        cParams++;
    }

    return cParams;
}


VOID
PARAM_LIST::CanonList(
    VOID
    )
{
    FIELD_VALUE_PAIR * pFVP;
    PLIST_ENTRY        listEntry;
    PLIST_ENTRY        nextEntry;
    PLIST_ENTRY        tmpEntry;

    DBG_ASSERT(!_fCanonicalized);

    //
    // Go through the list and make sure that there are no dups.
    // if there are, convert them into comma separated lists.
    //

    for ( listEntry  = _FieldListHead.Flink;
          listEntry != &_FieldListHead;
          listEntry  = nextEntry
          )
    {
        DWORD fieldLen;
        PCHAR fieldName;

        nextEntry = listEntry->Flink;

        pFVP = CONTAINING_RECORD( listEntry, FIELD_VALUE_PAIR, ListEntry );


        //
        // if field or value is empty, zap it
        //

        if ( (*pFVP->QueryField() == '\0') ||
             (*pFVP->QueryValue() == '\0') )
        {

            RemoveEntryList( listEntry );
            InsertHeadList( &_FreeHead, listEntry );
            continue;
        }

        fieldName = pFVP->QueryField();
        fieldLen = pFVP->_strField.QueryCB();

        //
        // Walk the rest of the list and look for dup fields
        //

        tmpEntry = nextEntry;

        while ( tmpEntry != &_FieldListHead )
        {

            FIELD_VALUE_PAIR * pTmpFVP;
            pTmpFVP = CONTAINING_RECORD(
                                tmpEntry,
                                FIELD_VALUE_PAIR,
                                ListEntry );

            //
            // combine the two fields
            //

            if ( (pTmpFVP->_strField.QueryCB() == fieldLen) &&
                 (_stricmp(pTmpFVP->QueryField(), fieldName) == 0) &&
                 (*pTmpFVP->QueryValue() != '\0') )
            {

                pFVP->_cValues++;

                pFVP->_strValue.Append( "," );
                pFVP->_strValue.Append( pTmpFVP->QueryValue() );

                pTmpFVP->_strField.Reset();
            }

            tmpEntry = tmpEntry->Flink;
        }
    }

    _fCanonicalized = TRUE;
    return;

} // PARAM_LIST::CanonList
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\odbc\odbcreq.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    odbcreq.cxx

Abstract:

    ODBC Request class used for ODBC requests from a query file

Author:

    John Ludeman (johnl)   22-Feb-1995

Revision History:

    MuraliK    25-Aug-1995     Fixed a heap corruption problem
    Phillich   24-Jan-1996     Fixed nested Ifs problem

--*/

#include "precomp.hxx"

//
//  Accumulate and output data in chunks of this size
//

#define OUTPUT_BUFFER_SIZE         8192

//
//  This is the maximum value for the expires time.  It's 10 years in seconds
//

#define MAX_EXPIRES_TIME           0x12cc0300

//
//  The special tag names for marking the beginning and ending of the
//  special tag sections
//

#define BEGIN_DETAIL_TEXT          "begindetail"
#define END_DETAIL_TEXT            "enddetail"
#define IF_TEXT                    "if"
#define ELSE_TEXT                  "else"
#define END_IF_TEXT                "endif"

//
// Character set that SQL statement has to have to be valid
//

#define FULLCHARSET                " ;([{\"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a  \
                                    \x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15     \
                                    \x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f"

//
// Some important and dangerous SQL keywords
//
                                    
CHAR * g_pSQLKeywords[] = { "ALTER", "CREATE", "DELETE", "DROP", "EXEC", 
                            "INSERT", "SELECT", "UPDATE", NULL };

//
//  Does a case insensitive compare of a .idc field name
//

#define COMP_FIELD( pchName, pchField, cch )  ((toupper(*(pchName)) == \
                                              toupper(*(pchField))) && \
                              !_strnicmp( (pchName), (pchField), (cch)))

//
//  Given a pointer to a token, skips to the next white space 
//  delimited token
//

#define NEXT_TOKEN( pchToken )   SkipWhite( SkipNonWhite( pchToken ) )

ALLOC_CACHE_HANDLER *   ODBC_REQ::sm_pachOdbcRequests;

//
//  Globals
//

extern BOOL             g_fIsSystemDBCS;   // Is this system DBCS?

//
//  Local Function Prototypes
//

HRESULT
DoSynchronousReadFile(
    IN HANDLE hFile,
    IN PCHAR  Buffer,
    IN DWORD  nBuffer,
    OUT PDWORD nRead,
    IN LPOVERLAPPED Overlapped
    );

HRESULT
GetFileData(
    IN     const CHAR *             pchFile,
	OUT    BYTE * *                 ppbData,
	OUT    DWORD *                  pcbData,
	IN     int                      nCharset,
	IN     BOOL                     fUseWin32Canon
    );


HRESULT
SetOdbcOptions(
    ODBC_CONNECTION * pOdbcConn,
    STRA *             pStrOptions
    );

HRESULT
BuildMultiValue(
    const CHAR * pchValue,
    STRA *       pstrMulti,
    BOOL         fQuoteElements
    );

HRESULT
PreProcParams(
    CHAR **      ppchValue,
    STRA *       pstrValue
    );

BOOL
SQLKeywordInParam(
    CHAR *       pchParam
    );

const CHAR *
SkipNonWhite(
    const CHAR * pch
    );

const CHAR *
SkipTo(
    const CHAR * pch,
    CHAR ch
    );

const CHAR *
SkipWhite(
    const CHAR * pch
    );

ODBC_REQ::ODBC_REQ(
    EXTENSION_CONTROL_BLOCK * pECB,
    DWORD                     csecConnPool,
    int                       nCharset
    )
    : _dwSignature        ( ODBC_REQ_SIGNATURE ),
      _pECB               ( pECB ),
      _cchMaxFieldSize    ( 0 ),
      _cMaxRecords        ( 0xffffffff ),
      _cCurrentRecordNum  ( 0 ),
      _cClientParams      ( 0 ),
      _podbcstmt          ( NULL ),
      _podbcconnPool      ( NULL ),
      _cbQueryFile        ( 0 ),
      _cNestedIfs         ( 0 ),
      _fDirect            ( FALSE ),
      _fValid             ( FALSE ),
      _pbufOut            ( NULL ),
      _csecExpires        ( 0 ),
      _csecExpiresAt      ( 0 ),
      _pstrValues         ( NULL ),
      _pcbValues          ( NULL ),
      _cQueries           ( 0 ),
      _csecConnPool       ( csecConnPool ),
      _pSecDesc           ( NULL ),
      _pstrCols           ( NULL ),
      _nCharset           ( nCharset )
{}

ODBC_REQ::~ODBC_REQ()
{
    DBG_ASSERT( CheckSignature() );

    if ( _podbcstmt )
    {
        delete _podbcstmt;
        _podbcstmt = NULL;
    }

    Close();

    if ( _pbufOut )
    {
        delete _pbufOut;
        _pbufOut = NULL;
    }

    if ( _pSecDesc )
    {
        LocalFree( _pSecDesc );
        _pSecDesc = NULL;
    }

    _dwSignature = ODBC_REQ_FREE_SIGNATURE;
}

HRESULT
ODBC_REQ::Create(
    CONST CHAR *         pszQueryFile,
    CONST CHAR *         pszParameters
    )
{
    HRESULT    hr;

    DBG_ASSERT( CheckSignature() );

    hr = _strQueryFile.Copy( pszQueryFile );
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "Error copying QueryFile name, hr = 0x%x.\n",
                   hr ));
        return hr;
    }

    hr = _plParams.ParsePairs( pszParameters, FALSE, FALSE, FALSE );
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "Error parsing param pairs, hr = 0x%x.\n",
                   hr ));
        return hr;
    }

    if ( _strQueryFile.IsValid() )
    {
        _fValid = TRUE;
    }

    _cClientParams = _plParams.GetCount();

    return hr;
}

HRESULT
ODBC_REQ::OpenQueryFile(
    BOOL * pfAccessDenied
    )
{
    CHAR *            pchQueryFile;
    HRESULT           hr;

    DBG_ASSERT( CheckSignature() );

    hr = GetFileData( _strQueryFile.QueryStr(),
                      (BYTE **) &pchQueryFile,
                      &_cbQueryFile,
                      _nCharset,
					  TRUE );
    if ( FAILED( hr ) )
    {
        STRA strError;
        LPCSTR apsz[1];

        apsz[0] = _pECB->lpszPathInfo;

        strError.FormatString( ODBCMSG_QUERY_FILE_NOT_FOUND,
                               apsz,
                               IIS_RESOURCE_DLL_NAME_A );
        SetErrorText( strError.QueryStr() );

        DWORD dwE = GetLastError();
        if ( dwE == ERROR_ACCESS_DENIED || dwE == ERROR_LOGON_FAILURE )
        {
            *pfAccessDenied = TRUE;
        }

        DBGPRINTF(( DBG_CONTEXT,
                   "Error in GetFileData(), hr = 0x%x.\n",
                   hr ));
        return hr;
    }

    //
    //  CODEWORK - It is possible to avoid this copy by not modifying the
    //  contents of the query file.  Would save a buffer copy
    //

    if( !_bufQueryFile.Resize( _cbQueryFile ) )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }

    memcpy( _bufQueryFile.QueryPtr(),
            pchQueryFile,
            _cbQueryFile );

    return S_OK;
}


HRESULT
ODBC_REQ::ParseAndQuery(
    CHAR *  pszLoggedOnUser
    )
/*++

Routine Description:

    This method parses the query file and executes the SQL statement

Arguments:

    pchLoggedOnUser - The NT user account this user is running under

Return Value:

    HRESULT

--*/
{
    STACK_STRA( strDatasource, 64 );
    STACK_STRA( strUsername, 64 );
    STACK_STRA( strPassword, 64 );
    CHAR *     pch;
    CHAR *     pchEnd;
    CHAR *     pszField;
    CHAR *     pszValue;
    VOID *     pCookie = NULL;
    DWORD      csecPoolConnection = _csecConnPool;
    BOOL       fRetried;
    HRESULT    hr;

    DBG_ASSERT( CheckSignature() );

    //
    //  We don't allow some security related parameters to be 
    //  specified from the client so remove those now
    //

    _plParams.RemoveEntry( "REMOTE_USER" );
    _plParams.RemoveEntry( "LOGON_USER" );
    _plParams.RemoveEntry( "AUTH_USER" );

    //
    //  Do a quick Scan for the DefaultParameters value to fill 
    //  in the blanks in the parameter list from the web browser
    //

    {
        pch = (CHAR *) _bufQueryFile.QueryPtr();
        pchEnd = pch + strlen(pch);

        ODBC_PARSER Parser( (CHAR *) _bufQueryFile.QueryPtr() );

        while ( ( pszField = Parser.QueryToken() ) < pchEnd )
        {
            if ( COMP_FIELD( "DefaultParameters:", pszField, 18 ))
            {
                Parser.SkipTo( ':' );
                Parser += 1;
                Parser.EatWhite();

                hr = _plParams.ParsePairs( Parser.QueryLine(), TRUE );
                if ( FAILED( hr ) )
                {
                    DBGPRINTF(( DBG_CONTEXT,
                           "Error parsing param pairs, hr = 0x%x.\n",
                           hr ));
                    return hr;
                }

                break;
            }

            Parser.NextLine();
        }
    }

    //
    //  Replace any %XXX% fields with the corresponding parameter.  
    //  Note we reassign pch in case of a pointer shift during 
    //  ReplaceParams
    //

    hr = ReplaceParams( &_bufQueryFile, &_plParams );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "Error in ReplaceParams(), hr = 0x%x.\n",
                   hr ));
        return hr;
    }

    pch = (CHAR *) _bufQueryFile.QueryPtr();
    pchEnd = pch + strlen(pch);

    //
    //  Loop through the fields looking for values we recognize
    //

    {
        ODBC_PARSER Parser( pch );

        while ( (pszField = Parser.QueryToken()) < pchEnd )
        {
            //
            //  Ignore blank lines and Ctrl-Zs
            //

            if ( !*pszField || *pszField == 0x1a)
            {
                Parser.NextLine();
                continue;
            }

            Parser.SkipTo( ':' );
            Parser += 1;
            Parser.EatWhite();

            //
            //  Ignore comment fields
            //

            if ( *pszField == '#' || *pszField == ';' )
            {
                Parser.NextLine();
                continue;
            }

            if ( COMP_FIELD( "Datasource:", pszField, 11 ))
            {
                hr = Parser.CopyToEOL( &strDatasource );
            }
            else if ( COMP_FIELD( "Username:", pszField, 9 ))
            {
                hr = Parser.CopyToEOL( &strUsername );
            }
            else if ( COMP_FIELD( "Password:", pszField, 9 ))
            {
                hr = Parser.CopyToEOL( &strPassword );
            }
            else if ( COMP_FIELD( "Template:", pszField, 9 ))
            {
                hr = Parser.CopyToEOL( &_strTemplateFile );

                //
                //  Specifying a template of "Direct" means return the
                //  first column of data as raw data to the client
                //

                if ( !_stricmp( _strTemplateFile.QueryStr(), "Direct" ))
                {
                    _fDirect = TRUE;
                }
            }
            else if ( COMP_FIELD( "MaxFieldSize:", pszField, 13 ))
            {
                _cchMaxFieldSize = atoi( Parser.QueryPos() );
            }
            else if ( COMP_FIELD( "MaxRecords:", pszField, 11 ))
            {
                _cMaxRecords = atoi( Parser.QueryPos() );
            }
            else if ( COMP_FIELD( "RequiredParameters:", pszField, 12 ))
            {
                hr = _plReqParams.ParseSimpleList( Parser.QueryLine() );
            }
            else if ( COMP_FIELD( "Content-Type:", pszField, 13 ))
            {
                hr = Parser.CopyToEOL( &_strContentType );
            }
            else if ( COMP_FIELD( "DefaultParameters:", pszField, 18 ))
            {
                //
                //  Ignore, already processed
                //
            }
            else if ( COMP_FIELD( "Expires:", pszField, 8 ))
            {
//                _csecExpires = min( (DWORD) atoi( Parser.QueryPos() ),
//                                    MAX_EXPIRES_TIME );
			}
            else if ( COMP_FIELD( "ODBCOptions:", pszField, 12 ))
            {
                hr = Parser.CopyToEOL( &_strOdbcOptions );
            }
            else if ( COMP_FIELD( "ODBCConnection:", pszField, 15 ))
            {
                //
                //  Is there an override to the default?
                //

                if ( !_strnicmp( Parser.QueryToken(), "Pool", 4 ))
                {
                    if ( !csecPoolConnection )
                    {
                        // This is bogus - if somebody has turned off connection
                        // pooling on the vroot and enabled it in the idc,
                        // there's no defined way to set the timeout
                        // need to add a timeout here

                        csecPoolConnection = 30;
                    }
                }
                else if ( !_strnicmp( Parser.QueryToken(), "NoPool", 6 ))
                {
                    csecPoolConnection = 0;
                }
            }
            else if ( COMP_FIELD( "SQLStatement:", pszField, 13 ))
            {
                if ( _cQueries >= MAX_QUERIES )
                {
                    STRA strError;
                    strError.FormatString( ODBCMSG_TOO_MANY_SQL_STATEMENTS,
                                           NULL,
                                           IIS_RESOURCE_DLL_NAME_A );

                    SetErrorText( strError.QueryStr() );

                    return E_FAIL;
                }

                for( ; ; )
                {
                    hr = _strQueries[_cQueries].Append( 
                                                  Parser.QueryLine() );
                    if ( FAILED( hr ) )
                    {
                        DBGPRINTF(( DBG_CONTEXT,
                               "Error appeinding value, hr = 0x%x.\n",
                               hr ));
                        return hr;
                    }

                    Parser.NextLine();

                    //
                    //  Line continuation is signified by putting a '+' at
                    //  the beginning of the line
                    //

                    if ( *Parser.QueryLine() == '+' )
                    {
                        hr = _strQueries[_cQueries].Append( " " );
                        if ( FAILED( hr ) )
                        {
                            DBGPRINTF(( DBG_CONTEXT,
                                "Error appending space, hr = 0x%x.\n",
                                hr ));
                            return hr;
                        }

                        Parser += 1;
                    }
                    else
                    {
                        //
                        //  Ignore blank line
                        //

                        if ( !*Parser.QueryLine() &&
                             Parser.QueryLine() < pchEnd )
                        {
                            continue;
                        }
                        break;
                    }

                }

                _cQueries++;
                continue;
            }
            else if ( COMP_FIELD( IDC_FIELDNAME_CHARSET, 
                                  pszField, 
                                  sizeof(IDC_FIELDNAME_CHARSET)-1 ))
            {
                //
                // Ignore "Charset:" field
                //

                Parser.NextLine();
                continue;
            }
            else if ( COMP_FIELD( "TranslationFile:", pszField, 16 ))
            {
                hr = Parser.CopyToEOL( &_strTranslationFile );
            }
            else
            {
                //
                //  Unrecognized field, generate an error
                //

                STRA strError;
                LPCSTR apsz[1];

                apsz[0] = pszField;

                strError.FormatString( ODBCMSG_UNREC_FIELD,
                                       apsz,
                                       IIS_RESOURCE_DLL_NAME_A );

                SetErrorText( strError.QueryStr() );

                hr = E_FAIL;
            }

            if ( FAILED( hr ) )
            {
                return hr;
            }

            Parser.NextLine();
        }
    }

    //
    //  Make sure the Datasource and SQLStatement fields are non-empty
    //

    if ( strDatasource.IsEmpty() || 
         !_cQueries              || 
         _strQueries[0].IsEmpty() )
    {
        STRA strError;
        strError.FormatString( ODBCMSG_DSN_AND_SQLSTATEMENT_REQ,
                               NULL,
                               IIS_RESOURCE_DLL_NAME_A );

        SetErrorText( strError.QueryStr() );

        return E_FAIL;
    }

    //
    //  Make sure all of the required parameters have been supplied
    //

    while ( pCookie = _plReqParams.NextPair( pCookie,
                                             &pszField,
                                             &pszValue ))
    {
        if ( !_plParams.FindValue( pszField ))
        {
            STRA strError;
            LPCSTR apsz[1];

            apsz[0] = pszField;

            if ( FAILED( hr = strError.FormatString( ODBCMSG_MISSING_REQ_PARAM,
                                                     apsz,
                                                     IIS_RESOURCE_DLL_NAME_A )))
            {
                return hr;
            }

            //
            //  Set the error text to return the user and indicate we 
            //  couldn't continue the operation
            //

            SetErrorText( strError.QueryStr() );

            return E_FAIL;
        }
    }

    //
    //  Don't retry the connection/query if not pooling.  The reason
    //  we do the retry is to report the error that occurred (this
    //  requires the ODBC connection object).
    //

    fRetried = csecPoolConnection == 0;

RetryConnection:

    //
    //  Open the database
    //

	if ( FAILED( OpenConnection( &_odbcconn,
                                 &_podbcconnPool,
                                 csecPoolConnection,
                                 strDatasource.QueryStr(),
                                 strUsername.QueryStr(),
                                 strPassword.QueryStr(),
                                 pszLoggedOnUser ) )               ||
         FAILED( SetOdbcOptions( QueryOdbcConnection(), 
                                 &_strOdbcOptions ) )              ||
         !( _podbcstmt = QueryOdbcConnection()->AllocStatement() ) ||
         FAILED( _podbcstmt->ExecDirect( _strQueries[0].QueryStr(),
                                         _strQueries[0].QueryCCH() ) ) )
    {
        //
        //  Delete the pooled connection and retry the open
        //

        if ( csecPoolConnection )
        {
            delete _podbcstmt;
            _podbcstmt = NULL;

            CloseConnection( _podbcconnPool, TRUE );

            _podbcconnPool = NULL;
            csecPoolConnection = 0;
        }

        if ( !fRetried )
        {
            fRetried = TRUE;
            goto RetryConnection;
        }

        return E_FAIL;
    }
	
    return S_OK;
}


HRESULT
ODBC_REQ::OutputResults(
    ODBC_REQ_CALLBACK pfnCallback,
    PVOID             pvContext,
    STRA *            pstrHeaders,
    ODBC_REQ_HEADER   pfnSendHeader,
    BOOL              fIsAuth,
    BOOL *            pfAccessDenied
    )
/*++

Routine Description:

    This method reads the template file and does the necessary
    result set column substitution

Arguments:

    pfnCallback - Send callback function
    pvContext - Context for send callback

Return Value:

    HRESULT

--*/
{
    DWORD               cbOut;
    DWORD               BytesRead = 0;
    DWORD               cbToSend;
    BOOL                fLastRow = FALSE;
    const CHAR *        pchStartDetail;
    const CHAR *        pchIn;
    const CHAR *        pchEOF;
    const CHAR *        pchBOF = NULL;
    CHAR *              pchTag;
    const CHAR *        pchValue;
    DWORD               cbValue;
    enum TAG_TYPE       TagType;
    DWORD               err;
    BOOL                fTriedRelative = FALSE;
    BOOL                fExpr;
    STRA                 strError;
    const CHAR *        CharacterMap[256];
    BOOL                fMoreResults;
    BOOL                fHaveResultSet = FALSE;
    DWORD               iQuery = 1;
    HRESULT             hr;

    DBG_ASSERT( CheckSignature() );

    //
    //  Set up the first buffer in the output chain
    //

    if ( !_pbufOut )
    {
        _pbufOut = new BUFFER_CHAIN_ITEM( OUTPUT_BUFFER_SIZE );

        if ( !_pbufOut || !_pbufOut->QueryPtr() )
        {
            return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        }
    }

    if ( !_fDirect )
    {
        CHAR * pchLastSlash;
        STACK_STRA( str, MAX_PATH );

TryAgain:
        //
        //  Open and read the template file (automatically zero terminated)
        //

        hr = GetFileData( ( fTriedRelative ? str.QueryStr() :
                                             _strTemplateFile.QueryStr() ),
                          ( BYTE ** )&pchBOF,
                          &BytesRead,
                          _nCharset,
                          TRUE );
        if ( FAILED( hr ) )
        {
            //
            //  If the open fails with a not found error, then make the
            //  template file relative to the query file and try again
            //

            if ( fTriedRelative                                    ||
                 ( ( GetLastError() != ERROR_FILE_NOT_FOUND )  
                   && ( GetLastError() != ERROR_PATH_NOT_FOUND ) ) ||
                 FAILED( str.Copy( _strQueryFile ) ) )
            {
                LPCSTR apsz[1];
                DWORD dwE = GetLastError();

                apsz[0] = _strTemplateFile.QueryStr();

                strError.FormatString( ODBCMSG_QUERY_FILE_NOT_FOUND,
                                       apsz,
                                       IIS_RESOURCE_DLL_NAME_A );
                SetErrorText( strError.QueryStr() );

                if ( ( dwE == ERROR_ACCESS_DENIED || 
                     dwE == ERROR_LOGON_FAILURE) )
                {
                    *pfAccessDenied = TRUE;
                    return HRESULT_FROM_WIN32( dwE );
                }

                if (!pfnSendHeader( pvContext, 
                                    "500 IDC Query Error", 
                                    pstrHeaders->QueryStr() ))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    DBGPRINTF(( DBG_CONTEXT,
                           "Error in SendHeader(), hr = 0x%x.\n",
                           hr ));
                    return hr;
                }

                goto ErrorExit;
            }

            pchLastSlash = ( PCHAR )_mbsrchr( ( PUCHAR )str.QueryStr(), 
                                              '\\' );

            if ( !pchLastSlash )
            {
                return HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
            }

            str.SetLen( DIFF(pchLastSlash - str.QueryStr()) + 1 );

            hr = str.Append( _strTemplateFile );
            if ( FAILED( hr ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                   "Error appending template file name, hr = 0x%x.\n",
                   hr ));

                return hr;
            }

            fTriedRelative = TRUE;
            goto TryAgain;
        }
        else
        {
            //
            //  Update our template file path if it changed
            //

            if ( fTriedRelative )
            {
                hr = _strTemplateFile.Copy( str );
                if ( FAILED( hr ) )
                {
                    DBGPRINTF(( DBG_CONTEXT,
                      "Error updating template file path, hr = 0x%x.\n",
                      hr ));
                    
                    return hr;
                }
            }
        }
    }

    //
    //  Open the translation file if one was specified
    //

    if ( !_strTranslationFile.IsEmpty() )
    {
        CHAR * pchLastSlash;
        CHAR * pchTranslationFile;
        STACK_STRA( str, MAX_PATH );
        VOID * pvCookie = NULL;
        CHAR * pchField;
        DWORD  cbRead = 0;

        fTriedRelative = FALSE;

TranslationTryAgain:
        //
        //  Open and read the template file (automatically zero terminated)
        //

        hr = GetFileData( ( fTriedRelative ? str.QueryStr() :
                                  _strTranslationFile.QueryStr()),
                          ( BYTE ** )&pchTranslationFile,
                          &cbRead,
                          _nCharset,
                          TRUE );
        if ( FAILED( hr ) )
        {
            //
            //  If the open fails with a not found error, then make the
            //  template file relative to the query file and try again
            //

            if ( fTriedRelative                             ||
                 ( GetLastError() != ERROR_FILE_NOT_FOUND 
                 && GetLastError() != ERROR_PATH_NOT_FOUND) ||
                 FAILED( str.Copy( _strQueryFile ) ) )
            {
                LPCSTR apsz[1];
                DWORD dwE = GetLastError();

                apsz[0] = _strTranslationFile.QueryStr();

                strError.FormatString( ODBCMSG_QUERY_FILE_NOT_FOUND,
                                       apsz,
                                       IIS_RESOURCE_DLL_NAME_A );
                SetErrorText( strError.QueryStr());

                if ( ( dwE == ERROR_ACCESS_DENIED || 
                     dwE == ERROR_LOGON_FAILURE ) )
                {
                    *pfAccessDenied = TRUE;
                    return HRESULT_FROM_WIN32( dwE );
                }

                goto ErrorExit;
            }

            pchLastSlash = (PCHAR)_mbsrchr( ( PUCHAR )str.QueryStr(), 
                                            '\\' );

            if ( !pchLastSlash )
            {
                return HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
            }

            str.SetLen( DIFF(pchLastSlash - str.QueryStr()) + 1 );

            hr = str.Append( _strTranslationFile );
            if ( FAILED( hr ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                  "Error appending translation file name, hr = 0x%x.\n",
                  hr ));

                return hr;
            }

            fTriedRelative = TRUE;
            goto TranslationTryAgain;
        }
        else
        {
            //
            //  Update our template file path if it changed
            //

            if ( fTriedRelative )
            {
                hr = _strTranslationFile.Copy( str );
                if ( FAILED( hr ) )
                {
                    return hr;
                }
            }
        }

        hr = _plTransList.ParsePairs( pchTranslationFile,
                                      FALSE,
                                      TRUE,
                                      FALSE );  

        if ( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                   "Error in ParsePairs(), hr = 0x%x.\n",
                   hr ));

            return hr;
        }

        //
        //  Build the character map
        //

        memset( CharacterMap, 0, sizeof( CharacterMap ) );

        while ( pvCookie = _plTransList.NextPair( pvCookie,
                                                  &pchField,
                                                  (LPSTR *)&pchValue ))
        {
            CharacterMap[ (BYTE) *pchField ] = pchValue;
        }
    }

    //
    //  We've already performed the first query at this point
    //

NextResultSet:

    //
    //  Get the list of column names in the initial result set.  
    //  The initial set must be initialized for compatibility 
    //  with previous versions of IDC (i.e., column variables 
    //  can be referenced outside the detail section ).
    //

    hr = _podbcstmt->QueryColNames( &_pstrCols,
                                    &_cCols,
                                    _cchMaxFieldSize,
                                    &fHaveResultSet );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "Error in QueryColNames, hr = 0x%x.\n",
                   hr ));

        return hr;
    }

    if ( !fHaveResultSet )
    {
        //
        //  Check to see if there are anymore result sets for this query
        //

        hr = _podbcstmt->MoreResults( &fMoreResults );
        if ( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                   "Error in MoreResults, hr = 0x%x.\n",
                   hr ));
            return hr;
        }

        if ( fMoreResults )
        {
            goto NextResultSet;
        }
        else if ( iQuery < _cQueries )
        {
            //
            //  If there are no more result sets, see if there
            //  are more queries.  Note calling SQLMoreResults
            //  will discard this result set
            //

            hr = _podbcstmt->ExecDirect(
                               _strQueries[iQuery].QueryStr(),
                               _strQueries[iQuery].QueryCCH() );
            if ( FAILED( hr ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                       "Error in ExecDirect(), hr = 0x%x.\n",
                       hr ));
                return hr;
            }

            iQuery++;

            goto NextResultSet;
        }
    }


    //
    //  Get the first row of values
    //

    hr = NextRow( &fLastRow );
    if ( fHaveResultSet && FAILED( hr ) )
    {
        //
        //  Some SQL statements don't generate any rows (i.e.,
        //  insert, delete etc.).  So don't bail if there's a column in
        //  the result set
        //

        if ( !_cCols )
        {
            return hr;
        }
    }

    // Send reply header

    if (!pfnSendHeader( pvContext, "200 OK", pstrHeaders->QueryStr() ))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DBGPRINTF(( DBG_CONTEXT,
                   "Error in SendHeader(), hr = 0x%x.\n",
                   hr ));

        return hr;
    }

    //
    //  Copy the template to the output buffer while scanning for column
    //  fields that need to be replaced
    //

    #define SEND_DATA( pchData, cbData )  SendData( pfnCallback,     \
                                                    pvContext,       \
                                                    (pchData),       \
                                                    (DWORD)(cbData), \
                                                    &_pbufOut,       \
                                                    &cbOut )

    #define SEND_DATA_CHECK_ESC( pchData, cbData )  \
            ((TagType == TAG_TYPE_VALUE_TO_ESCAPE)  \
            ? SendEscapedData( pfnCallback,         \
                    pvContext,                      \
                    pchData,                        \
                    (DWORD)(cbData),                \
                    &cbOut )                        \
            : SEND_DATA( pchData,                   \
                    (DWORD)(cbData) ) )

    cbOut  = 0;
    pchStartDetail = NULL;

    if( pchBOF == NULL )
    {
        return E_FAIL;
    }

    pchIn  = pchBOF;
    pchEOF = pchBOF + BytesRead;

    while ( pchIn < pchEOF )
    {
        //
        //  Look for the start of a "<!--%" or <%" tag
        //

        pchTag = strchr( pchIn, '<' );

        if ( pchTag )
        {
            //
            //  Send any data preceding the tag
            //

            cbToSend = DIFF(pchTag - pchIn);

            hr = SEND_DATA( pchIn, cbToSend );
            if ( FAILED( hr ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                   "Error sending data, hr = 0x%x.\n",
                   hr ));

                return hr;
            }

            pchIn += cbToSend;


            if ( !memcmp( pchTag, "<!--%", 5 ) ||
                 !memcmp( pchTag, "<%", 2 ) )
            {
                //
                //  Is this a tag we care about?  pchIn is advanced 
                //  except in the unknown case
                //

                LookupTag( pchTag,
                           &pchIn,
                           &pchValue,
                           &cbValue,
                           &TagType );

                switch( TagType )
                {
                case TAG_TYPE_VALUE:
                case TAG_TYPE_VALUE_TO_ESCAPE:

                    //
                    //  Map any characters if there was a translation file
                    //

                    if ( _strTranslationFile.IsEmpty() )
                    {
                        hr = SEND_DATA_CHECK_ESC( pchValue, (DWORD) -1 );
                        if ( FAILED( hr ) )
                        {
                            DBGPRINTF(( DBG_CONTEXT,
                                "Error sending esc data, hr = 0x%x.\n",
                                hr ));

                            return hr;
                        }
                    }
                    else
                    {
                        const CHAR * pchStart = pchValue;

                        while ( *pchValue )
                        {
                            if ( CharacterMap[ (BYTE) *pchValue ] )
                            {
                                hr = SEND_DATA_CHECK_ESC( pchStart,
                                        pchValue - pchStart );
                                if( FAILED( hr ) )
                                {
                                    DBGPRINTF(( DBG_CONTEXT,
                                     "Error sending data, hr = 0x%x.\n",
                                     hr ));

                                    return hr;
                                }

                                hr = SEND_DATA_CHECK_ESC(
                                        CharacterMap[ (BYTE) *pchValue],
                                        (DWORD) -1 );
                                if( FAILED( hr ) )
                                {
                                    DBGPRINTF(( DBG_CONTEXT,
                                     "Error sending data, hr = 0x%x.\n",
                                     hr ));

                                    return hr;
                                }

                                pchStart = pchValue = pchValue + 1;
                            }
                            else
                            {
                                pchValue++;
                            }
                        }

                        hr = SEND_DATA_CHECK_ESC( pchStart, 
                                                  pchValue - pchStart );
                        if( FAILED( hr ) )
                        {
                            DBGPRINTF(( DBG_CONTEXT,
                                "Error sending data, hr = 0x%x.\n",
                                hr ));

                            return hr;
                        }
                    }

                    break;

                case TAG_TYPE_BEGIN_DETAIL:

                    //
                    //  If we don't have a result set, get one now
                    //

                    if ( !fHaveResultSet )
                    {
                        fLastRow = TRUE;
                        _podbcstmt->FreeColumnMemory();
                        _cCurrentRecordNum = 0;
                        _pstrCols = _pstrValues = NULL;

NextResultSet2:
                        hr = _podbcstmt->MoreResults( &fMoreResults );
                        if ( FAILED( hr ) )
                        {
                            DBGPRINTF(( DBG_CONTEXT,
                                "Error in MoreResults(), hr = 0x%x.\n",
                                hr ));

                            return hr;
                        }

                        if ( fMoreResults )
                        {
NewQuery:
                            hr = _podbcstmt->QueryColNames( 
                                                &_pstrCols,
                                                &_cCols,
                                                _cchMaxFieldSize,
                                                &fHaveResultSet );
                            if ( FAILED( hr ) )
                            {
                                DBGPRINTF(( DBG_CONTEXT,
                                  "Error in QueryColNames, hr = 0x%x.\n",
                                  hr ));

                                return hr;
                            }

                            if ( !fHaveResultSet )
                                goto NextResultSet2;

                            hr = NextRow( &fLastRow );
                            if ( FAILED( hr ) )
                            {
                                //
                                //  Some SQL statements don't generate 
                                //  any rows (i.e., insert, delete etc.).  
                                //  So don't bail if there's a column in 
                                //  the result set
                                //

                                if ( !_cCols )
                                {
                                    DBGPRINTF(( DBG_CONTEXT,
                                     "Error in NextRow(), hr = 0x%x.\n",
                                     hr ));

                                    return hr;
                                }
                            }
                        }
                        else if ( iQuery < _cQueries )
                        {
                            //
                            //  If there are no more result sets, see if 
                            //  there are more queries.  Note calling 
                            //  SQLMoreResults will discard this result 
                            //  set
                            //

                            hr = _podbcstmt->ExecDirect(
                                       _strQueries[iQuery].QueryStr(),
                                       _strQueries[iQuery].QueryCCH() );
                            if ( FAILED( hr ) )
                            {
                                DBGPRINTF(( DBG_CONTEXT,
                                     "Error in ExecDirect(), hr = 0x%x.\n",
                                     hr ));
                                return hr;
                            }

                            iQuery++;

                            goto NewQuery;
                        }
                    }

                    if ( !fLastRow )
                    {
                        pchStartDetail = pchIn;
                    }
                    else
                    {
                        //
                        //  If no more data, then skip the detail section
                        //

                        SkipToTag( &pchIn, END_DETAIL_TEXT );

                        fHaveResultSet = FALSE;
                    }

                    break;

                case TAG_TYPE_END_DETAIL:

                    hr = NextRow( &fLastRow );
                    if ( FAILED( hr ) )
                    {
                        DBGPRINTF(( DBG_CONTEXT,
                            "Error in NextRow(), hr = 0x%x.\n",
                            hr ));
                        return hr;
                    }

                    _cCurrentRecordNum++;

                    if ( !fLastRow && _cCurrentRecordNum < _cMaxRecords )
                    {
                        pchIn = pchStartDetail;
                    }
                    else
                    {
                        fHaveResultSet = FALSE;
                    }

                    break;

                case TAG_TYPE_IF:

                    //
                    //  pchIn points to the first character of the 
                    //  expression on the way in, the first character 
                    //  after the tag on the way out
                    //

                    hr = EvaluateExpression( (const CHAR **)&pchIn, 
                                             &fExpr );
                    if ( FAILED( hr ) )
                    {
                        DBGPRINTF(( DBG_CONTEXT,
                          "Error in EvaluateExpression(), hr = 0x%x.\n",
                          hr ));

                        return hr;
                    }

                    //
                    //  If the expression is FALSE, then skip the 
                    //  intervening data till the endif tag
                    //

                    if ( !fExpr )
                    {
                        //
                        //  Look for a closing else or endif
                        //

                        if ( SkipConditionalBlock( &pchIn, 
                                                   pchEOF, 
                                                   ELSE_TEXT ) )
                        {
                            _cNestedIfs++;
                        }
                    }
                    else
                    {
                        _cNestedIfs++;
                    }
                    break;

                case TAG_TYPE_ELSE:

                    if ( _cNestedIfs == 0 )
                    {
                        //
                        //  else w/o an if
                        //

                        strError.FormatString( ODBCMSG_TOO_MANY_ELSES,
                                               NULL,
                                               IIS_RESOURCE_DLL_NAME_A );
                        SetErrorText( strError.QueryStr());

                        goto ErrorExit;
                    }

                    //
                    //  We got here because we just finished processing a
                    //  TRUE expression, so skip the else portion of the if
                    //

                    SkipConditionalBlock( &pchIn, pchEOF, NULL );

                    _cNestedIfs--;
                    break;

                case TAG_TYPE_END_IF:

                    if ( _cNestedIfs == 0 )
                    {
                        //
                        //  endif w/o an if
                        //

                        strError.FormatString( ODBCMSG_TOO_MANY_ENDIFS,
                                               NULL,
                                               IIS_RESOURCE_DLL_NAME_A );
                        SetErrorText( strError.QueryStr());

                        goto ErrorExit;
                    }

                    _cNestedIfs--;
                    break;

                default:
                case TAG_TYPE_UNKNOWN:
                    goto UnknownTag;

                }
            }
            else
            {
UnknownTag:
                //
                //  Move past the beginning of the tag so the next
                //  search skips this tag
                //

                hr = SEND_DATA( pchIn, 1 );
                if ( FAILED( hr ) )
                {
                    DBGPRINTF(( DBG_CONTEXT,
                        "Error sending data, hr = 0x%x.\n",
                        hr ));

                    return hr;
                }

                pchIn += 1;
            }
        }
        else
        {
            //
            //  No more tags, copy the rest of the data to the output
            //  buffer.
            //

            hr = SEND_DATA( pchIn, (DWORD) -1 );
            if ( FAILED( hr ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                    "Error sending data, hr = 0x%x.\n",
                    hr ));

                return hr;
            }

            break;
        }
    }

    //
    //  Send the last of the data and append the last buffer chain 
    //  if we're caching
    //

    err = pfnCallback( pvContext,
                       (CHAR *)_pbufOut->QueryPtr(),
                       cbOut );

    if ( err )
    {
        SetLastError( err );
        goto ErrorExit;
    }


    return S_OK;

ErrorExit:

    //
    //  We've already sent the HTTP headers at this point, so just 
    //  append the error text to the end of this document.
    //

    {
        STRA str;
        
        if ( !GetLastErrorText( &strError ) )
        {
            return E_FAIL;
        }                 
        
        hr = str.Append( "<h1>Error performing operation</h1>");
        if( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                    "Error appending error msg, hr = 0x%x.\n",
                    hr ));

            return hr;
        }

        hr = str.Append( strError );
        if( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                    "Error appending error msg, hr = 0x%x.\n",
                    hr ));

            return hr;
        }

        hr = str.Append( "</body>" );
        if( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                    "Error appending error msg, hr = 0x%x.\n",
                    hr ));

            return hr;
        }

        err = pfnCallback( pvContext,
                           str.QueryStr(),
                           str.QueryCB() );

        if ( err )
        {
            hr = HRESULT_FROM_WIN32( err );

            DBGPRINTF(( DBG_CONTEXT,
                    "Error sending data, hr = 0x%x.\n",
                    hr ));

            return hr;
        }
    }

    return S_OK;
}

HRESULT
ODBC_REQ::NextRow(
    BOOL * pfLast
    )
/*++

Routine Description:

    Advances the result set to the next row

Arguments:

    pfLast - Set to TRUE if there is no more data

Return Value:

    HRESULT

--*/
{
    DBG_ASSERT( CheckSignature() );

    return _podbcstmt->QueryValuesAsStr( &_pstrValues,
                                         &_pcbValues,
                                         pfLast );
}

HRESULT
ODBC_REQ::ReplaceParams(
    BUFFER * pbufFile,
    PARAM_LIST* pParamList
    )
/*++

Routine Description:

    This method looks at the query file and replaces any occurrences
    of %xxx% with the specified replacement value from pszParams

Arguments:

    pbufFile - Contents of file buffer
    ParamList - List of parameters to replace in the query file

Return Value:

    HRESULT

--*/
{
    CHAR *     pch;
    BOOL       fIsMultiValue = FALSE;
    CHAR *     pchValue;
    CHAR *     pchTag;
    CHAR *     pchTerm;
    CHAR *     pchOldPointer;
    CHAR *     pchQuoteOrPercent;
    STACK_STRA( strMultiValue, MAX_PATH );
    STACK_STRA( strQuotedValue, MAX_PATH );
    STACK_STRA( strDoubleValue, MAX_PATH );
    STACK_STRA( strUpperParam, MAX_PATH );
    DWORD      cbFile;
    DWORD      cbTag;
    DWORD      cbValue;
    HRESULT    hr;
    CHAR       szSymbolValue[ 256 ];
    CHAR     * achSymbolValue = szSymbolValue;
    DWORD      dwSymbolValue = sizeof( szSymbolValue );
    BOOL       fInQuote = FALSE;

    DBG_ASSERT( CheckSignature() );

    //
    //  Scan the query file looking for %xxx% replacements
    //

    pch = pchOldPointer = (CHAR *) pbufFile->QueryPtr();
    cbFile = strlen( pch ) + sizeof( CHAR );

    while ( *pch )
    {
        if( pchQuoteOrPercent = strpbrk( pch, "\'%" ) )
        {
            if( *pchQuoteOrPercent == '\'' )
            {
                //
                // fInQuote always presents if the next tag is 
                // in quote or not
                //
                
                fInQuote = !fInQuote;
                pch = pchQuoteOrPercent + 1;
                continue;
            }
            else
            {
                pchTag = pchQuoteOrPercent;

                if( pchTerm = strchr( pchTag + 1, '%' ) )
                {
                    *pchTerm = '\0';

                    //
                    //  Was this a '%' escape (i.e., '%%')?
                    //

                    if ( (pchTag + 1) == pchTerm )
                    {
                        pchValue = "%";
                        goto Found;
                    }

                    //
                    //  Look through the replacement list for a matching param
                    //

                    pchValue = pParamList->FindValue( pchTag + 1, 
                                                      &fIsMultiValue );

                    if ( !pchValue )
                    {
                        //
                        //  Check to see if it's something the client has 
                        //  defined
                        //

                        if( _pECB->GetServerVariable( _pECB->ConnID,
                                                      pchTag + 1,
                                                      achSymbolValue,
                                                      &dwSymbolValue ) )
                        {
                            hr = _strSymbolValue.Copy( achSymbolValue, dwSymbolValue );
                            if( FAILED( hr ) )
                            {
                                DBGPRINTF(( DBG_CONTEXT,
                                    "Error copying symbol value, hr = 0x%x.\n",
                                    hr ));

                                return hr;
                            }

                            pchValue = _strSymbolValue.QueryStr();
                            fIsMultiValue = FALSE;
                            goto Found;
                        }
                
                        if( dwSymbolValue > sizeof( szSymbolValue ) )
                        {
                            achSymbolValue = ( CHAR * )LocalAlloc( LMEM_FIXED, dwSymbolValue );
                            if( !achSymbolValue )
                            {
                                return HRESULT_FROM_WIN32( GetLastError() );
                            }

                            if( _pECB->GetServerVariable( _pECB->ConnID,
                                                          pchTag + 1,
                                                          achSymbolValue,
                                                          &dwSymbolValue ) )
                            {
                                hr = _strSymbolValue.Copy( achSymbolValue, dwSymbolValue );

                                LocalFree( achSymbolValue );

                                if( FAILED( hr ) )
                                {
                                    DBGPRINTF(( DBG_CONTEXT,
                                        "Error copying symbol value, hr = 0x%x.\n",
                                        hr ));

                                    return hr;
                                }

                                pchValue = _strSymbolValue.QueryStr();
                                fIsMultiValue = FALSE;
                                goto Found;
                            }

                            LocalFree( achSymbolValue );
                        }

                        //
                        //  We didn't find a match, nuke the tag
                        //

                        memmove( pchTag,
                                 pchTerm + 1,
                                 strlen( pchTerm + 1 ) + sizeof( CHAR ) );

                        pch = pchTag;
                        continue;
                    }

Found:
                    //
                    // Pre-process the params
                    //

                    hr = PreProcParams( &pchValue, &strDoubleValue );
                    if( FAILED( hr ) )
                    {
                        return hr;
                    }

                    if ( fIsMultiValue )
                    {
                        hr = BuildMultiValue( pchValue,
                                              &strMultiValue,
                                              fInQuote );
                        if ( FAILED( hr ) )
                        {
                            DBGPRINTF(( DBG_CONTEXT,
                                    "Error in BuildMultiValue(), hr = 0x%x.\n",
                                    hr ));

                            return hr;
                        }

                        pchValue = strMultiValue.QueryStr();
                    }

                    //
                    // Get an upper case of the paramter
                    //

                    hr = strUpperParam.Copy( pchValue );
                    if( FAILED( hr ) )
                    {
                        return hr;
                    }

                    _strupr( strUpperParam.QueryStr() );

                    //
                    // If we find dangerous chars or SQL keywords in the 
                    // params, we will single quote the params as a sql 
                    // string if the tag is not quoted. 
                    //
                    
                    if( !fInQuote && 
                        ( SQLKeywordInParam( strUpperParam.QueryStr() ) || 
                          strpbrk( pchValue, FULLCHARSET ) ) )
                    {
                        hr = strQuotedValue.Append( "\'" );
                        if( FAILED( hr ) )
                        {
                            return hr;
                        }

                        hr = strQuotedValue.Append( pchValue );
                        if( FAILED( hr ) )
                        {
                            return hr;
                        }

                        hr = strQuotedValue.Append( "\'" );                
                        if( FAILED( hr ) )
                        {
                            return hr;
                        }

                        pchValue = strQuotedValue.QueryStr();
                    }

                    //
                    //  We have a match, replace the tag with the value.
                    //  Note we count the surrounding '%'s with cbTag.
                    //

                    cbTag    = DIFF( pchTerm - pchTag ) + sizeof( CHAR );
                    cbValue  = strlen( pchValue );

                    if ( cbValue > cbTag )
                    {
                        //
                        //  Resize if needed but watch for pointer shift
                        //

                        if ( pbufFile->QuerySize() < (cbFile + cbValue - cbTag))
                        {
                            if ( !pbufFile->Resize( cbFile + cbValue - cbTag, 
                                                    512 ) )
                            {
                                DBGPRINTF(( DBG_CONTEXT,
                                    "Error resizing the buffer.\n" ));

                                return HRESULT_FROM_WIN32( 
                                               ERROR_NOT_ENOUGH_MEMORY );
                            }

                            if ( pbufFile->QueryPtr() != pchOldPointer )
                            {
                                CHAR * pchNewPointer = 
                                             ( CHAR * ) pbufFile->QueryPtr();
                                DWORD  cchLen = strlen( pchNewPointer);

                                pch     = pchNewPointer + 
                                          ( pch - pchOldPointer );
                                pchTag  = pchNewPointer + 
                                          ( pchTag - pchOldPointer );
                                pchTerm = pchNewPointer + 
                                          ( pchTerm - pchOldPointer );
                                pchOldPointer = pchNewPointer;

                                DBG_ASSERT( pch >= pchNewPointer &&
                                           pch < pchNewPointer + cchLen);
                                DBG_ASSERT( pchTag >= pchNewPointer &&
                                           pchTag < pchNewPointer + cchLen);
                                DBG_ASSERT( pchTerm >= pchNewPointer &&
                                           pchTerm <= pchNewPointer + cchLen);
                            }
                        }

                        //
                        //  Expand the space for the value
                        //

                        memmove( pchTerm + 1 + cbValue - cbTag,
                                 pchTerm + 1,
                                 strlen( pchTerm + 1 ) + sizeof( CHAR ) );

                        cbFile += cbValue - cbTag;
                    }
                    else
                    {
                        //
                        //  Collapse the space since tag is longer then the 
                        //  value
                        //

                        memmove( pchTag + cbValue,
                                 pchTerm + 1,
                                 strlen( pchTerm + 1 ) + sizeof( CHAR ) );

                        cbFile -= cbTag - cbValue;
                    }

                    //
                    //  Replace the tag value with the replacement value
                    //

                    memcpy( pchTag,
                            pchValue,
                            cbValue );
                    pch = pchTag + cbValue;
                }
                else
                {
                    //
                    // No more tags to replace so get out
                    //

                    break;
                }
            }
        }
        else
        {
            //
            // No more tags to replace so get out
            //

            break;
        }
    }

    return S_OK;
}

VOID
ODBC_REQ::LookupTag(
    CHAR *          pchBeginTag,
    const CHAR * *  ppchAfterTag,
    const CHAR * *  ppchValue,
    DWORD *         pcbValue,
    enum TAG_TYPE * pTagType
    )
/*++

Routine Description:

    This method looks at the tag, determines the tag type and
    returns the associated value.  This is used only for the .htx file.

Arguments:

    pchBeginTag - Points to first character of tag (i.e., '<')
    ppchAfterTag - Receives the first character after the tag if
        the tag
    ppchValue - If the tag is a value, returns the database value
    pcbValue - Receives number of bytes in the value being returned
    pTagType - Returns the tag type

Return Value:

    NONE

--*/
{
    CHAR * pchTerm;
    BOOL   fLongTagMarker;
    STACK_STRA( strTagName, 128);
    DWORD  cchToCopy;
    BOOL   fDoEsc = FALSE;

    DBG_ASSERT( CheckSignature() );

    *pTagType = TAG_TYPE_UNKNOWN;
    *ppchAfterTag = pchBeginTag;
    *pcbValue = (DWORD) -1;

    DBG_ASSERT( !memcmp( pchBeginTag, "<!--%", 5 ) ||
                !memcmp( pchBeginTag, "<%", 2 ) );

    fLongTagMarker = pchBeginTag[1] == '!';

    //
    //  Move past the tag marker, 5 for "<!--%" and 2 for "<%"
    //

    pchBeginTag += (fLongTagMarker ? 5 : 2);

    if ( *pchBeginTag == '"' )
    {
        if ( !memcmp( pchBeginTag, "\"%z\",", sizeof("\"%z\",") - 1 ) )
        {
            fDoEsc = TRUE;
            pchBeginTag += sizeof("\"%z\",") - 1;
        }
        else
        {
            return;
        }
    }

    //
    //  Find the end of the tag and make a copy.
    //

    pchTerm = strchr( pchBeginTag, '%' );

    if ( !pchTerm )
    {
        return;
    }

    cchToCopy = DIFF(pchTerm - pchBeginTag);

    if ( FAILED( strTagName.Copy( pchBeginTag, 
                                  cchToCopy * sizeof( CHAR ) ) ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error copying BeginTag." ));

        return;
    }

    LookupSymbol( strTagName.QueryStr(),
                  pTagType,
                  ppchValue,
                  pcbValue );

    if ( fDoEsc && *pTagType == TAG_TYPE_VALUE )
    {
        *pTagType = TAG_TYPE_VALUE_TO_ESCAPE;
    }

    if ( *pTagType != TAG_TYPE_IF )
    {
        *ppchAfterTag = pchTerm + (fLongTagMarker ? 4 : 2);
    }
    else
    {
        //
        //  We leave the pointer on the expression if this was an if
        //

        *ppchAfterTag = NEXT_TOKEN(pchBeginTag);
    }

    *pchTerm = '%';
}

HRESULT
ODBC_REQ::LookupSymbol(
    const CHAR *    pchSymbolName,
    enum TAG_TYPE * pTagType,
    const CHAR * *  ppchValue,
    DWORD *         pcbValue
    )
/*++

Routine Description:

    Looks to see if the specified symbol name is defined and what 
    the type value of the symbol is.

    The "if" symbols is special cased to allow the expression to 
    follow it

    If the symbol is a multi-value field (from command line) then 
    the tabs in the value in will be replaced by commas.

Arguments:

    pchSymbolName - Name of zero terminated symbol to find
    pTagType - Returns the tag type of the symbol
    ppchValue - Returns a pointer to the string value of the symbol
                if it has one
    pcbValue - Returns length of value

Return Value:

    HRESULT

--*/
{
    BOOL     fIsMultiValue;
    CHAR     szSymbolValue[ 256 ];
    CHAR   * achSymbolValue = szSymbolValue;
    DWORD    dwSymbolValue = sizeof( szSymbolValue );
    HRESULT  hr;

    DBG_ASSERT( CheckSignature() );

    //
    //  Does the symbol match one of the column names?
    //

    if ( _pstrCols && _pstrValues )
    {
        for ( DWORD i = 0; i < _cCols; i++ )
        {
            if ( !lstrcmpiA( _pstrCols[i].QueryStr(),
                            pchSymbolName ))
            {
                *pTagType = TAG_TYPE_VALUE;
                *ppchValue = _pstrValues[i].QueryStr();
                *pcbValue  = _pcbValues[i];

                //
                //  BugID 33406 - Don't return half DBCS char at end 
                //  of data
                //

                if ( g_fIsSystemDBCS )
                {
                    CHAR * pch;
                    for ( pch = (CHAR *)*ppchValue; *pch; pch++ )
                    {
                        if ( IsDBCSLeadByte( *pch ) )
                        {
                            if ( !*(pch+1) )
                            {
                                *pch = '\0';
                                (*pcbValue)--;
                                break;
                            }
                            pch++;
                        }
                    }
                }
                return S_OK;
            }
        }
    }

    //
    //  Does it match any of the special values?
    //

    if ( !_stricmp( pchSymbolName, BEGIN_DETAIL_TEXT ))
    {
        *pTagType = TAG_TYPE_BEGIN_DETAIL;
        return S_OK;
    }
    else if ( !_stricmp( pchSymbolName, END_DETAIL_TEXT ))
    {
        *pTagType = TAG_TYPE_END_DETAIL;
        return S_OK;
    }
    else if ( !_strnicmp( pchSymbolName, IF_TEXT, sizeof(IF_TEXT) - 1 ))
    {
        //
        //  The IF tag is treated a little bit differently cause we 
        //  expect the expression to be included as part of the 
        //  symbol
        //

        *pTagType = TAG_TYPE_IF;
        return S_OK;
    }
    else if ( !_stricmp( pchSymbolName, END_IF_TEXT ))
    {
        *pTagType = TAG_TYPE_END_IF;
        return S_OK;
    }
    else if ( !_stricmp( pchSymbolName, ELSE_TEXT ))
    {
        *pTagType = TAG_TYPE_ELSE;
        return S_OK;
    }

    //
    //  Is it one of the parameters from the query (either one of the 
    //  form fields or from the DefaultParameters field in the wdg 
    //  file)?  These must be prefixed by "idc.", that is 
    //  "<%idc.Assign%>"
    //

    if ( !_strnicmp( pchSymbolName, "idc.", 4 )    &&
         (*ppchValue = _plParams.FindValue( pchSymbolName + 4,
                                            &fIsMultiValue,
                                            pcbValue )) ) 
    {
        *pTagType = TAG_TYPE_VALUE;

        //
        //  If this is a multi-value field, replace all the tabs with 
        //  commas. This is somewhat of a hack as it breaks the use of 
        //  this field when multiple queries are supported
        //

        if ( fIsMultiValue )
        {
            CHAR * pchtmp = (CHAR *) *ppchValue;

            while ( pchtmp = strchr( pchtmp, '\t' ))
            {
                *pchtmp = ',';
            }
        }

        return S_OK;
    }

    //
    //  Lastly, check to see if it's something the client has defined
    //

    if( !_pECB->GetServerVariable( _pECB->ConnID,
                                   ( LPSTR )pchSymbolName,
                                   achSymbolValue,
                                   &dwSymbolValue ) &&
        dwSymbolValue <= sizeof( szSymbolValue ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error getting server variable." ));

        return E_FAIL;
    }

    if( dwSymbolValue > sizeof( szSymbolValue ) )
    {
        achSymbolValue = ( CHAR * )LocalAlloc( LMEM_FIXED, dwSymbolValue );
        if( !achSymbolValue )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }

        if( !_pECB->GetServerVariable( _pECB->ConnID,
                                       ( LPSTR )pchSymbolName,
                                       achSymbolValue,
                                       &dwSymbolValue ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                "Error getting server variable." ));

            LocalFree( achSymbolValue );
            achSymbolValue = NULL;

            return E_FAIL;
        }
    }

    hr = _strSymbolValue.Copy( achSymbolValue, dwSymbolValue );

    if( dwSymbolValue > sizeof( szSymbolValue ) )
    {
        LocalFree( achSymbolValue );
        achSymbolValue = NULL;
    }

    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error copying symbol value, hr = 0x%x.\n",
            hr ));

        return hr;
    }

    *pTagType  = TAG_TYPE_VALUE;
    *ppchValue = _strSymbolValue.QueryStr();
    *pcbValue  = _strSymbolValue.QueryCB();

    return S_OK;
}

HRESULT
ODBC_REQ::EvaluateExpression(
    const CHAR * * ppchExpression,
    BOOL *         pfExprValue
    )
/*++

Routine Description:

    Performs simple expression evaluation for an 'if' tag in the
    template file.  Valid expressions are:

    <%if <V1> <OP> <V2>%>

    where V1, V2 can be one of:
        Positive integer
        TotalRecords - Total records contained in result set
        MaxRecords - The maximum records specified in the query file

    OP can be one of:
        EQ - Equal
        LT - Less then
        GT - Greater then

Arguments:

    ppchExpression - Points to V1 on entry, set to the first character
                     after the end tag on exit
    pfExprValue - TRUE if the expression is TRUE, FALSE otherwise

Return Value:

    HRESULT

--*/
{
    EXPR_VALUE v1( this );
    EXPR_VALUE v2( this );
    TAG_TYPE   OpType;
    STRA       strError;
    CHAR *     pch;

    DBG_ASSERT( CheckSignature() );

    if ( !v1.Evaluate( ppchExpression )               ||
         FAILED(EvaluateOperator( ppchExpression, &OpType )) ||
         !v2.Evaluate( ppchExpression ))
    {
        return E_FAIL;
    }

    //
    //  If the symbols weren't found, default them to empty
    //  strings
    //

    if ( v1.QueryType() == TAG_TYPE_UNKNOWN )
    {
        v1.SetType( TAG_TYPE_STRING );
    }

    if ( v2.QueryType() == TAG_TYPE_UNKNOWN )
    {
        v2.SetType( TAG_TYPE_STRING );
    }

    //
    //  The value types must match
    //

    if ( v1.QueryType() != v2.QueryType() )
    {
        BOOL fSt = FALSE;

        if ( v1.QueryType() == TAG_TYPE_STRING && v2.QueryType() == TAG_TYPE_INTEGER )
            fSt = v1.ConvertToInteger();
        else if ( v1.QueryType() == TAG_TYPE_INTEGER && v2.QueryType() == TAG_TYPE_STRING )
            fSt = v2.ConvertToInteger();

        if ( !fSt )
        {
            strError.FormatString( ODBCMSG_MISMATCHED_VALUES,
                                   NULL,
                                   IIS_RESOURCE_DLL_NAME_A );
            SetErrorText( strError.QueryStr());

            return E_FAIL;
        }
    }

    //
    //  Move the current position to the end of this tag
    //

    if ( pch = strchr( *ppchExpression, '>' ))
    {
        *ppchExpression = pch + 1;
    }

    switch ( OpType )
    {
    case TAG_TYPE_OP_LT:

        *pfExprValue = v1.LT( v2 );
        break;

    case TAG_TYPE_OP_GT:

        *pfExprValue = v1.GT( v2 );
        break;

    case TAG_TYPE_OP_EQ:

        *pfExprValue = v1.EQ( v2 );
        break;

    case TAG_TYPE_OP_CONTAINS:

        //
        //  Contains is only valid for string values
        //

        if ( v1.QueryType() != TAG_TYPE_STRING )
        {
            strError.FormatString( 
                           ODBCMSG_CONTAINS_ONLY_VALID_ON_STRINGS,
                           NULL,
                           IIS_RESOURCE_DLL_NAME_A );
            SetErrorText( strError.QueryStr());

            return E_FAIL;
        }

        *pfExprValue = v1.CONTAINS( v2 );
        break;

    default:

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    return S_OK;
}

HRESULT
ODBC_REQ::EvaluateOperator(
    const CHAR * * ppchExpression,
    TAG_TYPE *     pTagType
    )
/*++

Routine Description:

    Determines which operator is being used in this expression

Arguments:

    ppchExpression - Points to the operator on entry, set to the
        next token on exit
    pTagType - Receives operator type

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    DBG_ASSERT( CheckSignature() );

    if ( COMP_FIELD( *ppchExpression, "GT", 2 ))
    {
        *pTagType = TAG_TYPE_OP_GT;
    }
    else if ( COMP_FIELD( *ppchExpression, "LT", 2 ))
    {
        *pTagType = TAG_TYPE_OP_LT;
    }
    else if ( COMP_FIELD( *ppchExpression, "EQ", 2 ))
    {
        *pTagType = TAG_TYPE_OP_EQ;
    }
    else if ( COMP_FIELD( *ppchExpression, "CONTAINS", 8 ))
    {
        *pTagType = TAG_TYPE_OP_CONTAINS;
    }
    else
    {
        //
        //  Unknown operator specified
        //

        STRA strError;

        strError.FormatString( ODBCMSG_UNRECOGNIZED_OPERATOR,
                               NULL,
                               IIS_RESOURCE_DLL_NAME_A );
        SetErrorText( strError.QueryStr());
        return E_FAIL;
    }

    *ppchExpression = NEXT_TOKEN( *ppchExpression );

    return S_OK;
}

HRESULT
ODBC_REQ::SendData(
    ODBC_REQ_CALLBACK        pfnCallback,
    PVOID                    pvContext,
    const CHAR *             pbData,
    DWORD                    cbData,
    BUFFER_CHAIN_ITEM  * *   ppbufOut,
    DWORD *                  pcbOut
    )
/*++

Routine Description:

    This method buffers the outgoing data and sends it when the
    output buffer is full

Arguments:

    pfnCallback - Send callback function
    pvContext - Context for send callback
    pbData - Pointer to data to send
    cbData - Number of bytes to send
    ppbufOut - Output buffer to buffer nonsent and cached data in
    pcbOut - Number of valid bytes in output buffer

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    DWORD               cbToCopy;
    DWORD               err;
    BUFFER_CHAIN_ITEM * pbufOut = *ppbufOut;
    STACK_STRA(         strTemp, MAX_PATH);
    HRESULT             hr;

    DBG_ASSERT( CheckSignature() );

    //
    //  if cbData is -1 then assume the data is zero terminated
    //

    if ( cbData == -1 )
    {
        cbData = strlen( pbData );
    }

    //
    //  Convert the string from shift_jis to iso-2022-jp or euc-jp
    //

    if ( CODE_ONLY_SBCS != _nCharset )
    {
        int cbUNIXSize;
        int nResult;

        //
        //  Get the size after Conversion
        //

        cbUNIXSize = PC_to_UNIX( GetACP(),
                                 _nCharset,
                                 (UCHAR *)pbData,
                                 (int)cbData,
                                 NULL,
                                 0 );

        hr = strTemp.Resize( cbUNIXSize + sizeof(CHAR) );
        if ( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                "Error resizing string buffer, hr = 0x%x.\n",
                hr ));

            return hr;
        }

        //
        //  Do conversion
        //

        nResult = PC_to_UNIX( GetACP(),
                              _nCharset,
                              (UCHAR *)pbData,
                              (int)cbData,
                              (UCHAR *)strTemp.QueryStr(),
                              cbUNIXSize );
        if ( -1 == nResult || nResult != cbUNIXSize )
        {
            DBGPRINTF(( DBG_CONTEXT,
                "Error converting data.\n" ));

            return E_FAIL;
        }

        //
        //  update the string pointer and count
        //

        pbData = strTemp.QueryStr();
        cbData = cbUNIXSize;

        *(strTemp.QueryStr() + cbUNIXSize) = '\0';
    }

    //
    //  Append the new data onto the old data
    //

    cbToCopy = min( cbData, OUTPUT_BUFFER_SIZE - *pcbOut );

    memcpy( (BYTE *) pbufOut->QueryPtr() + *pcbOut,
            pbData,
            cbToCopy );

    *pcbOut += cbToCopy;
    cbData  -= cbToCopy;
    pbData  += cbToCopy;

    //
    //  If we filled up the buffer, send the data
    //

    if ( cbData )
    {
        err = pfnCallback( pvContext,
                           (CHAR *) pbufOut->QueryPtr(),
                           *pcbOut );

        if ( err )
        {
            hr = HRESULT_FROM_WIN32( err );
            
            DBGPRINTF(( DBG_CONTEXT,
                "Error sending the data, hr = 0x%x.\n",
                hr ));

            return hr;
        }

        *pcbOut = 0;
    }
    else
    {
        return S_OK;
    }

    //
    //  We know at this point the output buffer is empty
    //

    while ( cbData )
    {
        //
        //  If the input data will fill the output buffer, send the
        //  data directly from the input buffer
        //

        if ( cbData > OUTPUT_BUFFER_SIZE  )
        {
            err = pfnCallback( pvContext,
                               pbData,
                               OUTPUT_BUFFER_SIZE );

            if ( err )
            {
                hr = HRESULT_FROM_WIN32( err );
                DBGPRINTF(( DBG_CONTEXT,
                    "Error sending the data, hr = 0x%x.\n",
                    hr ));

                return hr;
            }

            cbData -= OUTPUT_BUFFER_SIZE;
            pbData += OUTPUT_BUFFER_SIZE;
        }
        else
        {
            //
            //  We don't have enough to send so put it in the output buffer
            //

            memcpy( pbufOut->QueryPtr(),
                    pbData,
                    cbData );

            *pcbOut = cbData;
            break;
        }
    }

    return S_OK;
}


BOOL
ODBC_REQ::SkipConditionalBlock(
    const CHAR * *  ppchIn,
    const CHAR *    pchEOF,
    const CHAR *    pchSearchTag
    )
/*++

Routine Description:

    Skip a conditional block delimited by ENDIF or specified Tag
    returns TRUE if specified Tag found instead of ENDIF or end 
    of text

Arguments:

    ppchIn - Text stream to scan for tag
    pchTag - Name of tag (w/o '<%%>') to find and skip

--*/
{
    const CHAR * pchIn = *ppchIn;
    const CHAR * pchIf;
    const CHAR * pchEndif;
    const CHAR * pchTag;
    int cLev = 0;

    DBG_ASSERT( CheckSignature() );

    for ( ; pchIn < pchEOF ; )
    {
        pchEndif = pchIf = pchIn;
        SkipToTag( &pchIf, IF_TEXT );
        SkipToTag( &pchEndif, END_IF_TEXT );
        if ( pchSearchTag == NULL )
        {
            pchTag = pchEOF;
        }
        else
        {
            pchTag = pchIn;
            SkipToTag( &pchTag,  pchSearchTag );
        }
        if ( pchIf < pchTag && pchIf < pchEndif )
        {
            ++cLev;
            pchIn = pchIf;
        }
        else if ( pchTag < pchIf && pchTag < pchEndif )
        {
            if ( !cLev )
            {
                *ppchIn = pchTag;
                return TRUE;
            }
            pchIn = pchTag;
        }
        else    // END_IF_TEXT or nothing found
        {
            if ( !cLev )
            {
                *ppchIn = pchEndif;
                return FALSE;
            }
            --cLev;
            pchIn = pchEndif;
        }
    }

    // else/endif not found

    *ppchIn = pchEOF;

    return FALSE;
}


VOID
ODBC_REQ::SkipToTag(
    const CHAR * *  ppchIn,
    const CHAR *    pchTag
    )
/*++

Routine Description:

    Given the name of a tag, skips to the first character after the tag

Arguments:

    ppchIn - Text stream to scan for tag
    pchTag - Name of tag (w/o '<%%>') to find and skip

--*/
{
    const CHAR * pchIn = *ppchIn;
    DWORD  cchTag;

    DBG_ASSERT( CheckSignature() );

    cchTag = strlen( pchTag );

    while ( pchIn = strchr( pchIn, '<' ))
    {
        if ( (!memcmp( pchIn, "<!--%", 5 ) ||
              !memcmp( pchIn, "<%", 2 ))   &&
              !_strnicmp( pchIn + (pchIn[1] == '!' ? 5 : 2),
                         pchTag,
                         cchTag ))
        {
            goto Found;
        }
        else
            pchIn++;
    }

    //
    //  Not found, return the end of file
    //

    *ppchIn += strlen( *ppchIn );

    return;

Found:

    pchIn = strchr( pchIn + cchTag, '>' );
    if ( !pchIn )
    {
        *ppchIn += strlen( *ppchIn );
    }
    else
    {
        *ppchIn = pchIn + 1;
    }

    return;
}

BOOL
ODBC_REQ::IsEqual(
    ODBC_REQ * podbcreq
    )
/*++

Routine Description:

    Determines if the passed query's parameter would make it equivalent
    to this query

    A query is deemed equal if:

        1) The query has the same number of parameters passed from the 
           client
        2) The query's parameters match

    Note parameter comparison is case insensitive for both the field 
    and the value

    The template can be different if it's parameterized, but we'll pick 
    up the difference in the parameter list in this case.

    Since podbcreq is a query that has already been processed, it may 
    contain additional values from the .wdg default list.

Arguments:

    podbcreq - Query to check for equality

--*/
{
    VOID * pCookie = NULL;
    CHAR * pszField;
    CHAR * pszValue1, * pszValue2;

    DBG_ASSERT( CheckSignature() );

    //
    //  First compare the number of parameters passed from the client
    //

    if ( QueryClientParamCount() != podbcreq->QueryClientParamCount() )
    {
        return FALSE;
    }

    //
    //  Walk the list of parameters making sure they all match
    //

    while ( pCookie = podbcreq->_plParams.NextPair( pCookie,
                                                    &pszField,
                                                    &pszValue1 ))
    {
        if ( !(pszValue2 = _plParams.FindValue( pszField )) ||
             lstrcmpiA( pszValue1, pszValue2 ) )
        {
            //
            //  Either the value wasn't found or it doesn't match,
            //  the queries are not equal
            //

            return FALSE;
        }
    }

    //
    //  The queries are equal
    //

    return TRUE;
}

HRESULT
ODBC_REQ::AppendHeaders(
    STRA * pstrHeaders
    )
/*++

Routine Description:

    Adds any headers required for this query, this will generally be
    the content type and an Expires header if this query is cached

Arguments:

    pstrHeaders - String to append headers to

--*/
{
    CHAR *     pszTail;
    HRESULT    hr;

    DBG_ASSERT( CheckSignature() );

    //
    // The length of the content type is less than 255
    //
    DWORD dwMaxContentTypeLength = 255;

    hr = pstrHeaders->Resize( dwMaxContentTypeLength );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error resizing the header string buffer, hr = 0x%x.\n",
            hr ));

        return hr;
    }

    pszTail = pstrHeaders->QueryStr();


    pszTail += _snprintf( pszTail,
                          dwMaxContentTypeLength,
                          "Content-Type: %s\r\n\r\n",
                          QueryContentType() );

    return S_OK;
}

BOOL
ODBC_REQ::GetLastErrorText(
    STRA * pstrError
    )
{
    DBG_ASSERT( CheckSignature() );

    //
    //  If we stored an error explanation return that, otherwise fall back
    //  to an ODBC error
    //

    if ( !_strErrorText.IsEmpty() )
    {
        if( FAILED( pstrError->Copy( _strErrorText ) ) )
        {
            return FALSE;
        }

        return TRUE;
    }
    else if ( _podbcstmt )
    {
        return _podbcstmt->GetLastErrorTextAsHtml( pstrError );
    }
    else
    {
        return QueryOdbcConnection()->GetLastErrorTextAsHtml( pstrError,
                                       SQL_NULL_HSTMT,
                                       QueryOdbcConnection()->QueryErrorCode() );
    }
}

//static
HRESULT
ODBC_REQ::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize ODBC_REQ lookaside

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ALLOC_CACHE_CONFIGURATION       acConfig;

    acConfig.nConcurrency = 1;
    acConfig.nThreshold = 100;
    acConfig.cbSize = sizeof( ODBC_REQ );

    DBG_ASSERT( sm_pachOdbcRequests == NULL );
    
    sm_pachOdbcRequests = new ALLOC_CACHE_HANDLER( "ODBC_REQ",  
                                                   &acConfig );

    if ( sm_pachOdbcRequests == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }
    
    return NO_ERROR;
}

//static
VOID
ODBC_REQ::Terminate(
    VOID
)
/*++

Routine Description:

    Terminate ODBC_REQ lookaside

Arguments:

    None

Return Value:

    None

--*/
{
    if ( sm_pachOdbcRequests != NULL )
    {
        delete sm_pachOdbcRequests;
        sm_pachOdbcRequests = NULL;
    }
}

BOOL
EXPR_VALUE::ConvertToInteger(
    VOID )
{
    if ( _tagType == TAG_TYPE_STRING )
    {
        PSTR pS =_strValue.QueryStr();
        if ( *pS == '-' || isdigit(*(UCHAR *)pS) )
        {
            _dwValue = atoi( pS );
            _tagType = TAG_TYPE_INTEGER;

            return TRUE;
        }
    }

    return FALSE;
}

BOOL
EXPR_VALUE::Evaluate(
    const CHAR * * ppchIn
    )
/*++

Routine Description:

    Determines the type of value and retrieves the value appropriately

Arguments:

    ppchIn - Pointer to first character of value on way in, next token
        on they way out

--*/
{
    const CHAR * pchIn = *ppchIn;
    const CHAR * pchEnd;
    const CHAR * pchValue;
    DWORD        cbValue;
    STRA         strError;
    DWORD        cchToCopy;

    if ( isdigit( *(UCHAR *)pchIn ) )
    {
        //
        //  Simple number
        //

        _tagType = TAG_TYPE_INTEGER;
        _dwValue = atoi( pchIn );
        while ( isdigit( *(UCHAR *)pchIn ) )
        {
            pchIn++;
        }

        *ppchIn  = SkipWhite( pchIn );
    }
    else if ( *pchIn == '"' )
    {
        //
        //  Simple string, find the closing quote
        //

        pchEnd = strchr( ++pchIn, '\"' );

        if ( !pchEnd )
        {
            strError.FormatString( ODBCMSG_UNBALANCED_STRING,
                                   NULL,
                                   IIS_RESOURCE_DLL_NAME_A );
            _podbcreq->SetErrorText( strError.QueryStr());

            return FALSE;
        }

        cchToCopy = DIFF(pchEnd - pchIn);

        if ( FAILED( _strValue.Copy( pchIn, 
                                     cchToCopy * sizeof(CHAR) ) ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                "Error copying the value." ));

            return FALSE;
        }

        _tagType = TAG_TYPE_STRING;
        *ppchIn = SkipWhite( pchEnd + 1 );
    }
    else
    {
        STACK_STRA( strSymbol, 64 );

        //
        //  This is a keyword we need to interpret
        //

        //
        //  These fields are delimited with either white space
        //  or '\'' or the closing %>
        //

        pchEnd = pchIn;

        if ( *pchEnd == '\'' )
        {
            ++pchIn;
            ++pchEnd;
            while ( *pchEnd && *pchEnd != '\'' && *pchEnd != '%' )
            {
                pchEnd++;
            }
        }
        else
        {
            while ( *pchEnd && !ISWHITE( *pchEnd ) && *pchEnd != '%' )
            {
                pchEnd++;
            }
        }

        if ( COMP_FIELD( "MaxRecords", pchIn, 10 ))
        {
            _tagType = TAG_TYPE_INTEGER;
            _dwValue = _podbcreq->QueryMaxRecords();
        }
        else if ( COMP_FIELD( "CurrentRecord", pchIn, 12 ))
        {
            _tagType = TAG_TYPE_INTEGER;
            _dwValue = _podbcreq->QueryCurrentRecordNum();
        }
        else
        {
            //
            //  Isolate the symbol name
            //

            cchToCopy = DIFF(pchEnd - pchIn);

            if ( FAILED( strSymbol.Copy( pchIn, 
                                         cchToCopy * sizeof(CHAR) ) ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "Error copying symbol name." ));

                return FALSE;
            }

            //
            //  Look up the symbol
            //

            if ( FAILED( _podbcreq->LookupSymbol( 
                                           strSymbol.QueryStr(),
                                           &_tagType,
                                           &pchValue,
                                           &cbValue ) ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "Error in LookupSymbol()." ));

                return FALSE;
            }

            if ( _tagType == TAG_TYPE_VALUE ||
                 _tagType == TAG_TYPE_STRING )
            {
                if ( FAILED( _strValue.Copy( pchValue ) ) )
                { 
                    DBGPRINTF(( DBG_CONTEXT,
                                "Error copying tag value." ));
        
                    return FALSE;
                }

                _tagType = TAG_TYPE_STRING;
            }
        }

        if ( *pchEnd == '\'' )
        {
            ++pchEnd;
        }

        *ppchIn = SkipWhite( pchEnd );
    }

    return TRUE;
}

BOOL
EXPR_VALUE::GT(
    EXPR_VALUE & v1
    )
/*++

Routine Description:

    Returns TRUE if *this is Greater Then v1

Arguments:

    v1 - Value for right side of the expression

--*/
{
    if ( QueryType() == TAG_TYPE_INTEGER )
    {
        return QueryInteger() > v1.QueryInteger();
    }
    else
    {
        return lstrcmpiA( QueryStr(), v1.QueryStr() ) > 0;
    }
}

BOOL
EXPR_VALUE::LT(
    EXPR_VALUE & v1
    )
/*++

Routine Description:

    Returns TRUE if *this is Less Then v1

Arguments:

    v1 - Value for right side of the expression

--*/
{
    if ( QueryType() == TAG_TYPE_INTEGER )
    {
        return QueryInteger() < v1.QueryInteger();
    }
    else
    {
        return lstrcmpiA( QueryStr(), v1.QueryStr() ) < 0;
    }
}

BOOL
EXPR_VALUE::EQ(
    EXPR_VALUE & v1
    )
/*++

Routine Description:

    Returns TRUE if *this is Equal to v1

Arguments:

    v1 - Value for right side of the expression

--*/
{
    if ( QueryType() == TAG_TYPE_INTEGER )
    {
        return QueryInteger() == v1.QueryInteger();
    }
    else
    {
        return lstrcmpiA( QueryStr(), v1.QueryStr() ) == 0;
    }
}

BOOL
EXPR_VALUE::CONTAINS(
    EXPR_VALUE & v1
    )
/*++

Routine Description:

    Returns TRUE if *this contains the string in v1

Arguments:

    v1 - Value for right side of the expression

--*/
{
    if ( QueryType() != TAG_TYPE_STRING     ||
         v1.QueryType() != TAG_TYPE_STRING )
    {
        return FALSE;
    }

    //
    //  Upper case the strings then do a search
    //

    UpperCase();
    v1.UpperCase();

    return strstr( QueryStr(), v1.QueryStr() ) != NULL;
}


const CHAR * SkipNonWhite( const CHAR * pch )
{
    while ( *pch && !ISWHITE( *pch ) && *pch != '\n' )
        pch++;

    return pch;
}

const CHAR * SkipTo( const CHAR * pch, CHAR ch )
{
    while ( *pch && *pch != '\n' && *pch != ch )
        pch++;

    return pch;
}

const CHAR * SkipWhite( const CHAR * pch )
{
    while ( ISWHITE( *pch ) )
    {
        pch++;
    }

    return pch;
}

struct _ODBC_OPTIONS
{
    CHAR *   pszOptionName;
    DWORD    dwOption;
    BOOL     fNumeric;
}

OdbcOptions[] =
{
    //
    //  Order roughly in order of likelihood of being used
    //

    "SQL_OPT_TRACEFILE",       SQL_OPT_TRACEFILE,     FALSE,
    "SQL_QUERY_TIMEOUT",       SQL_QUERY_TIMEOUT,     TRUE,
    "SQL_MAX_ROWS",            SQL_MAX_ROWS,          TRUE,
    "SQL_LOGIN_TIMEOUT",       SQL_LOGIN_TIMEOUT,     TRUE,
    "SQL_PACKET_SIZE",         SQL_PACKET_SIZE,       TRUE,

    "SQL_NOSCAN",              SQL_NOSCAN,            TRUE,
    "SQL_MAX_LENGTH",          SQL_MAX_LENGTH,        TRUE,
    "SQL_ASYNC_ENABLE",        SQL_ASYNC_ENABLE,      TRUE,
    "SQL_ACCESS_MODE",         SQL_ACCESS_MODE,       TRUE,
    "SQL_OPT_TRACE",           SQL_OPT_TRACE,         TRUE,
    "SQL_TRANSLATE_OPTION",    SQL_TRANSLATE_OPTION,  TRUE,
    "SQL_TXN_ISOLATION",       SQL_TXN_ISOLATION,     TRUE,
    "SQL_TRANSLATE_DLL",       SQL_TRANSLATE_DLL,     FALSE,
    "SQL_CURRENT_QUALIFIER",   SQL_CURRENT_QUALIFIER, FALSE,
    NULL,                      0,                     0
};

HRESULT
SetOdbcOptions(
    ODBC_CONNECTION * pOdbcConn,
    STRA *            pStrOptions
    )
/*++

Routine Description:

    Sets the options specified in the OdbcOptions: keyword of the 
    .idc file

Arguments:

    pOdbcConn - ODBC connection to set options on
    pStrOptions - List of options in "v=f,y=z" format.  

--*/
{
    PARAM_LIST OptionList;
    VOID *     pvCookie = NULL;
    CHAR *     pszField;
    CHAR *     pszValue;
    DWORD      dwOption;
    SQLULEN    dwValue;
    DWORD      i;
    HRESULT    hr;

    hr = OptionList.ParsePairs( pStrOptions->QueryStr(),
                                FALSE,
                                FALSE );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error in ParsePairs(), hr = 0x%x.\n",
            hr ));

        return hr;
    }

    while ( pvCookie = OptionList.NextPair( pvCookie,
                                            &pszField,
                                            &pszValue ))
    {
        //
        //  If the field is a digit, then this is a driver specific 
        //  option. convert the value and field as appropriate,
        //  otherwise look it up in our option table
        //

        if ( isdigit( *(UCHAR *)pszField ))
        {
            dwOption = atoi( pszField );

            if ( isdigit( *(UCHAR *)pszValue ))
            {
                dwValue = ( SQLULEN )atoi( pszValue );
            }
            else
            {
                dwValue = ( SQLULEN ) pszValue;    
            }
        }
        else
        {
            i = 0;

            while ( OdbcOptions[i].pszOptionName )
            {
                if ( !_stricmp( OdbcOptions[i].pszOptionName,
                               pszField ))
                {
                    goto Found;
                }

                i++;
            }

            //
            //  Not found, skip this value
            //

            continue;

Found:
            dwOption = OdbcOptions[i].dwOption;

            if ( OdbcOptions[i].fNumeric )
            {
                //
                //  Numeric option, convert the value
                //

                dwValue = ( SQLULEN )atoi( pszValue );
            }
            else
            {
                dwValue = ( SQLULEN ) pszValue;     
            }
        }

        pOdbcConn->SetConnectOption( ( UWORD ) dwOption, 
                                     dwValue );
    }

    return S_OK;
}

HRESULT
BuildMultiValue(
    const CHAR * pchValue,
    STRA *        pstrMulti,
    BOOL         fQuoteElements
    )
{
    CHAR *  pchtmp = (CHAR *) pchValue;
    DWORD   cElements = 0;
    HRESULT hr;

    //
    //  If we're going to have to expand the size of the string, 
    //  figure out the total size we'll need now
    //

    if ( fQuoteElements )
    {
        while ( pchtmp = strchr( pchtmp, '\t' ))
        {
            cElements++;
            pchtmp++;
        }

        hr = pstrMulti->Resize( strlen( pchValue ) + 1 + 2 * cElements );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }

    hr = pstrMulti->Copy( pchValue );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error copying value, hr = 0x%x.\n",
            hr ));

        return hr;
    }

    //
    //  Replace tabs with "','" if fQuoteElements is TRUE, 
    //  otherwise just ','
    //

    pchtmp = pstrMulti->QueryStr();

    while ( pchtmp = strchr( pchtmp, '\t' ))
    {
        if ( fQuoteElements )
        {
            memmove( pchtmp + 3,
                     pchtmp + 1,
                     strlen( pchtmp + 1 ) + sizeof(CHAR));

            memcpy( pchtmp, "','", 3 );
        }
        else
        {
            *pchtmp = ',';
        }
    }

    return S_OK;
}

HRESULT
PreProcParams(
    CHAR **  ppchValue,
    STRA *   pstrValue
    )
/*++

Routine Description:

    This method doubles every single quote in string. If
    it sees /* or --, it'll consider it as some sort of 
    SQL attack cause params shouldn't include comments.

Arguments:

    ppchValue - the original string and the output string
    pstrValue - the destination string

Return Value:

    HRESLUT

--*/
{
    HRESULT hr;
    DWORD   dwNumOfQuote = 0;
    DWORD   dwValueLen = 0;
    CHAR *  pchSrc = *ppchValue;
    CHAR *  pchDest;

    while( *pchSrc )
    {        
        if( ( *pchSrc == '-' && *( pchSrc + 1 ) == '-' ) || 
            ( *pchSrc == '/' && *( pchSrc + 1 ) == '*' ) )
        {
            return E_FAIL;
        }
        
        dwValueLen++;

        if( *pchSrc == '\'' )
        {
            dwNumOfQuote++;
        }

        pchSrc++;
    }

    if( !dwNumOfQuote )
    {
        return S_OK;
    }
    
    hr = pstrValue->Resize( dwNumOfQuote + dwValueLen + 1 );
    if( FAILED( hr ) )
    {
        return hr;
    }

    pchSrc = *ppchValue;
    pchDest = pstrValue->QueryStr();

    while( *pchDest++ = *pchSrc )
    {
        if( *pchSrc == '\'' )
        {
            *pchDest++ = '\'';
        }

        pchSrc++;
    }

    *ppchValue = pstrValue->QueryStr();

    return hr;
}

BOOL
SQLKeywordInParam(
    CHAR *       pchParam
    )
/*++

Routine Description:

    Detect if there is any dangerous SQL keyword in the params

Arguments:

    pchParam - The parameter that possibly contains SQL keyword
               assume it's upper case here.

Return Value:

    BOOL - TRUE if there is, FALSE if there isn't any

--*/
{
    
    
    DWORD   i = 0;

    while( g_pSQLKeywords[i] )
    {
        if( strstr( pchParam, g_pSQLKeywords[i++] ) )
        {
            return TRUE;
        }
    }

    return FALSE;
}

//
//  Converts a value between zero and fifteen to the appropriate hex digit
//

#define HEXDIGIT( nDigit )                              \
     (CHAR)((nDigit) > 9 ?                              \
          (nDigit) - 10 + 'A'                           \
        : (nDigit) + '0')


HRESULT 
ODBC_REQ::SendEscapedData(
    ODBC_REQ_CALLBACK pfnCallback,
    PVOID             pvContext,
    PCSTR             pch,
    DWORD             cbIn,
    LPDWORD           pcbOut 
    )
/*++

Routine Description:

    This method escape the outgoing data and then send it to the
    SendData() function

Arguments:

    pfnCallback - Send callback function
    pvContext - Context for send callback
    pch - Pointer to data to send
    cbIn - Number of bytes to send
    pcbOut - Number of valid bytes in output buffer

Return Value:

    HRESLUT

--*/
{
    CHAR    ch;
    int     cNonEscaped = 0;
    HRESULT hr;

    #define SEND_DATA2( pchData, cbData )  SendData( pfnCallback,  \
                                                    pvContext,     \
                                                    (pchData),     \
                                                    (cbData),      \
                                                    &_pbufOut,     \
                                                    pcbOut )

    if ( cbIn == (DWORD)-1 )
    {
        cbIn = strlen( pch );
    }

    while ( cbIn-- )
    {
        ch = *pch;

        //
        //  Escape characters that are in the non-printable range
        //  but ignore CR and LF
        //

        if ( (((ch >= 0)   && (ch <= 32)) ||
              ((ch >= 128) && (ch <= 159))||
              (ch == '%') || (ch == '?') || (ch == '+') || (ch == '&')) 
              && !(ch == TEXT('\n') || ch == TEXT('\r'))  )
        {
            CHAR achTmp[3];

            //
            //  Insert the escape character
            //

            achTmp[0] = TEXT('%');

            //
            //  Convert the low then the high character to hex
            //

            UINT nDigit = (UINT)(ch % 16);

            achTmp[2] = HEXDIGIT( nDigit );

            ch /= 16;
            nDigit = (UINT)(ch % 16);

            achTmp[1] = HEXDIGIT( nDigit );

            hr = SEND_DATA2( pch-cNonEscaped, cNonEscaped );
            if ( cNonEscaped && FAILED( hr ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                    "Error sending data, hr = 0x%x.\n",
                    hr ));

                return hr;
            }

            hr = SEND_DATA2( achTmp, sizeof(achTmp) );
            if ( FAILED( hr ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                    "Error sending data, hr = 0x%x.\n",
                    hr ));

                return hr;
            }

            cNonEscaped = 0;
        }
        else
        {
            ++cNonEscaped;
        }

        ++pch;
    }

    hr = SEND_DATA2( pch-cNonEscaped, cNonEscaped );
    if ( cNonEscaped && FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error sending data, hr = 0x%x.\n",
            hr ));

        return hr;
    }

    return S_OK;
}

HRESULT
GetFileData(
    IN     const CHAR *             pchFile,
    OUT    BYTE * *                 ppbData,
    OUT    DWORD *                  pcbData,
    IN     int                      nCharset,
    IN     BOOL                     fUseWin32Canon
    )
/*++
    Description:

        Attempts to retrieve the passed file from the cache.  If it's 
        not cached, then we read the file and add it to the cache.

    Arguments:

        pchFile - Fully qualified file to retrieve
        pcbData - Receives pointer to first byte of data, used as handle 
                  to free data
        pcbSize - Size of output buffer
        pCacheFileInfo - File cache information
        nCharset - Charset (if this isn't SJIS, we convert it to SJIS
            before Check-In)
        ppSecDesc - Returns security descriptor if not null
        fUseWin32Canon - The resource has not been canonicalized and 
                         it's ok to use the win32 canonicalization code

    Returns:
        HRESULT

    Notes:

        The file is extended by two bytes and is appended with two zero 
        bytes,thus callers are guaranteed of a zero terminated text file.

--*/
{
    DWORD                   cbLow, cbHigh;
    BYTE *                  pbData = NULL;
    BYTE *                  pbBuff = NULL;
    int                     cbSJISSize;
    HRESULT                 hr;

    HANDLE hFile = CreateFileA( pchFile,
                                GENERIC_READ,
                                FILE_SHARE_READ  | 
                                FILE_SHARE_WRITE | 
                                FILE_SHARE_DELETE,
                                NULL,
                                OPEN_EXISTING,
                                FILE_FLAG_SEQUENTIAL_SCAN | 
                                FILE_FLAG_OVERLAPPED      | 
                                FILE_FLAG_BACKUP_SEMANTICS,
                                NULL );

	if ( hFile == INVALID_HANDLE_VALUE)
	{
		hr = HRESULT_FROM_WIN32( GetLastError() );

		goto ErrorExit;
	}
	else
	{
		WIN32_FILE_ATTRIBUTE_DATA    FileAttributes; 		
		
		if ( !GetFileAttributesExA( pchFile,
							        GetFileExInfoStandard, 
								    &FileAttributes ) )
		{
            hr = HRESULT_FROM_WIN32( GetLastError() );
            DBGPRINTF(( DBG_CONTEXT,
                "Error in GetFileAttributesExA, hr = 0x%x.\n",
                hr ));

			goto ErrorExit;
		}
	
		cbHigh = FileAttributes.nFileSizeHigh;
		cbLow = FileAttributes.nFileSizeLow;
	}
    //
    //  Limit the file size to 128k
    //

    if ( cbHigh || cbLow > 131072L )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
        goto ErrorExit;
    }

    if ( CODE_ONLY_SBCS != nCharset )
    {
        if ( !( pbBuff = pbData = (BYTE *) LocalAlloc( LPTR, cbLow ) ) )
        {
            hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY);
            DBGPRINTF(( DBG_CONTEXT,
                "Error allocating memory, hr = 0x%x.\n",
                hr ));

            goto ErrorExit;
        }
    }
    else 
	{
        if ( !(pbData = (BYTE *) LocalAlloc( LPTR, 
                                             cbLow + sizeof(WCHAR)) ) )
        {
            hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
            DBGPRINTF(( DBG_CONTEXT,
                "Error allocating memory, hr = 0x%x.\n",
                hr ));

            goto ErrorExit;
        }
    }        

    //
    //  Read the file data
    //

    hr = DoSynchronousReadFile( hFile,
                                ( PCHAR )pbData,
                                cbLow,
                                pcbData,
                                NULL );
    if ( FAILED( hr ) ) 
	{
        DBGPRINTF(( DBG_CONTEXT,
        "Error in DoSynchronousReadFile(), hr = 0x%x.\n",
        hr ));

        goto ErrorExit;
    }
	
	if ( CODE_ONLY_SBCS != nCharset )
    {
        pbData = NULL;

        //
        //  get the length after conversion
        //

        cbSJISSize = UNIX_to_PC( GetACP(),
                                 nCharset,
                                 pbBuff,
                                 *pcbData,
                                 NULL,
                                 0 );
        DBG_ASSERT( cbSJISSize <= (int)cbLow );
		
        if ( !(pbData = (BYTE *) LocalAlloc( 
                                      LPTR, 
                                      cbSJISSize + sizeof(WCHAR)) ) )
        {
            hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
            DBGPRINTF(( DBG_CONTEXT,
                "Error allocating memory, hr = 0x%x.\n",
                hr ));

            goto ErrorExit;
        }
        
        //
        //  conversion
        //

        UNIX_to_PC( GetACP(),
                    nCharset,
                    pbBuff,
                    *pcbData,
                    pbData,
                    cbSJISSize );
        *pcbData = cbLow = cbSJISSize;
    }

    DBG_ASSERT( *pcbData <= cbLow );

    //
    //  Zero terminate the file for both ANSI and Unicode files
    //

    *((WCHAR UNALIGNED *)(pbData + cbLow)) = L'\0';

    *pcbData += sizeof(WCHAR);

	*ppbData = pbData;

	DBG_REQUIRE( CloseHandle(hFile) );

    if ( pbBuff )
    {
        LocalFree( pbBuff );
    }

    return S_OK;

ErrorExit:

    if ( hFile != INVALID_HANDLE_VALUE )
    {
        DBG_REQUIRE( CloseHandle(hFile) );
    }

    if ( pbBuff )
    {
        if ( pbBuff == pbData )
        {
             pbData = NULL;
        }
        LocalFree( pbBuff );
    }

    if ( pbData )
    {
       DBG_REQUIRE( LocalFree(pbData));
    }

    return hr;
}

HRESULT
DoSynchronousReadFile(
    IN HANDLE hFile,
    IN PCHAR  Buffer,
    IN DWORD  nBuffer,
    OUT PDWORD nRead,
    IN LPOVERLAPPED Overlapped
    )
/*++

    Description:
        Does Asynchronous file reads.  Assumes that NT handles are
        opened for OVERLAPPED I/O, win95 handles are not.

    Arguments:
        hFile - Handle to use for the read
        Buffer - Buffer to read with
        nBuffer - size of buffer
        nRead - returns the number of bytes read
        Overlapped - user supplied overlapped structure

    Returns:
        TRUE/FALSE
--*/
{
    BOOL        fNewEvent = FALSE;
    OVERLAPPED  ov;
    DWORD       err = NO_ERROR;
    
	if ( Overlapped == NULL ) 
	{

        Overlapped = &ov;
        ov.Offset = 0;
        ov.OffsetHigh = 0;
        ov.hEvent = IIS_CREATE_EVENT(
                        "OVERLAPPED::hEvent",
                        &ov,
                        TRUE,
                        FALSE
                        );

        if ( ov.hEvent == NULL ) 
        {    
            err = GetLastError();
            DBGPRINTF( ( DBG_CONTEXT,
                         "CreateEvent failed with %d\n",
                         err ) );
            goto ErrorExit;
        }

        fNewEvent = TRUE;
    }

    if ( !ReadFile( hFile,
                    Buffer,
                    nBuffer,
                    nRead,
                    Overlapped )) 
	{

        err = GetLastError();

        if ( ( err != ERROR_IO_PENDING ) &&
             ( err != ERROR_HANDLE_EOF ) ) 
		{

            DBGPRINTF( ( DBG_CONTEXT,
                         "Error %d in ReadFile\n",
                         err));

            goto ErrorExit;
        }
    }

    if ( err == ERROR_IO_PENDING ) 
	{

        if ( !GetOverlappedResult( hFile,
                                   Overlapped,
                                   nRead,
                                   TRUE )) 
		{

            err = GetLastError();

            DBGPRINTF( ( DBG_CONTEXT,
                         "Error %d in GetOverlappedResult\n",
                         err ) );

            if ( err != ERROR_HANDLE_EOF ) 
			{
                goto ErrorExit;
            }
        }
    }

    DBG_REQUIRE( CloseHandle( ov.hEvent ) );
    
    return S_OK;

ErrorExit:

    if ( fNewEvent ) {
        DBG_REQUIRE( CloseHandle( ov.hEvent ) );
    }

    return HRESULT_FROM_WIN32( err );

} // DoSynchronousReadFile
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\sfwp\dll\dbgutil.h ===
/*++

Copyright (c) 1994-1998 Microsoft Corporation

Module Name:

    dbgutil.h

Abstract:

    This module declares the macros to wrap around DEBUG_PRINTS class
    defined in pudebug.h    
  
    This is the exported header file, that the users are allowed to modify.
    If there are no custom definitions, please use the templated version
    in the root iisrearc\inc\dbgutil.h
 
Author:

    Murali R. Krishnan (MuraliK)    22-Sept-1994

--*/


# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_



// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputKdb )


// end_user_modifiable


//
// include standard debug support
//
// note: define DEFAULT_OUTPUT_FLAGS before including pudebug.h
//

# include <pudebug.h>


// begin_user_modifiable

// Use the default constants from pudebug.h: 0x00000001 to 0x00000100

//
//  Define the debugging constants as bit-flag values
//  Example: # define DEBUG_FOOBAR 0x00010000
//  Note: All debugging bit-values below 0x00001000 are reserved!
// 
//  If you add or change a flag, please update FlagTableWp
//  in core\common\dtflags\dtflags.c
//

# define    DEBUG_SCHANNEL_CALLS       0x00010000
# define    DEBUG_CLIENT_CERT_INFO     0x00020000
# define    DEBUG_APP_RAW_READWRITE    0x00080000



//# define    DEBUG_TRACE                0x10000000
//# define    DEBUG_DUMPS                0x20000000



// end_user_modifiable


# endif  /* _DBGUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\odbc\parse.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

        parse.hxx

   Abstract:

        Simple parser class for extrapolating HTTP headers information

   Author:
           John Ludeman     (JohnL)    18-Jan-1995

   Project:
           HTTP server

   Revision History:

--*/

#include "precomp.hxx"

ODBC_PARSER::ODBC_PARSER(
    CHAR * pszStart
    )
/*++

Routine Description:

    Sets the initial position of the buffer for parsing

Arguments:

    pszStart - start of character buffer
    pszEnd - End of buffer

Return Value:

--*/
    : m_fListMode   ( FALSE ),
      m_pszPos      ( pszStart ),
      m_pszTokenTerm( NULL ),
      m_pszLineTerm ( NULL )
{
    DBG_ASSERT( pszStart );

    //
    //  Chew up any initial white space at the beginning of the buffer
    //  and terminate the first token in the string.
    //

    EatWhite();

    TerminateToken();
}


ODBC_PARSER::~ODBC_PARSER(
    VOID
    )
/*++

Routine Description:

    Restores any changes we made to the string while parsing

Arguments:

--*/
{
    RestoreBuffer();
}


CHAR *
ODBC_PARSER::QueryPos(
    VOID
    )
/*++

Routine Description:

    Removes the terminators and returns the current parser position

Arguments:

Return Value:

    Zero terminated string if we've reached the end of the buffer

--*/
{
    RestoreToken();
    RestoreLine();

    return m_pszPos;
}

VOID
ODBC_PARSER::SetPtr(
    CHAR * pch
    )
/*++

Routine Description:

    Sets the parser to point at a new location

Arguments:

    pch - New position for parser to start parsing from

Return Value:

--*/
{
    RestoreToken();
    RestoreLine();

    m_pszPos = pch;
}


CHAR *
ODBC_PARSER::QueryToken(
    VOID
    )
/*++

Routine Description:

    Returns a pointer to the current zero terminated token

    If list mode is on, then a comma is considered a delimiter.

Arguments:

Return Value:

    Zero terminated string if we've reached the end of the buffer

--*/
{
    if ( !m_pszTokenTerm )
    {
        TerminateToken( m_fListMode ? ',' : '\0' );
    }

    return m_pszPos;
}


CHAR *
ODBC_PARSER::QueryLine(
    VOID
    )
/*++

Routine Description:

    Returns a pointer to the current zero terminated line

Arguments:

Return Value:

    Zero terminated string if we've reached the end of the buffer

--*/
{
    RestoreToken();

    if ( !m_pszLineTerm )
    {
        TerminateLine();
    }

    return m_pszPos;
}


HRESULT
ODBC_PARSER::CopyToken(
    STRA * pStr,
    BOOL  fAdvanceToken
    )
/*++

Routine Description:

    Copies the token at the current position to *pStr

Arguments:

    pStr - Receives token
    fAdvanceToken - True if we should advance to the next token

Return Value:

    TRUE if successful, FALSE otherwise

--*/
{
    HRESULT hr;

    DBG_ASSERT( pStr );

    if ( !m_pszTokenTerm )
    {
        TerminateToken();
    }

    hr = pStr->Copy( m_pszPos );

    if ( fAdvanceToken )
    {
        NextToken();
    }

    return hr;
}


HRESULT
ODBC_PARSER::CopyToEOL(
    STRA   * pstr,
    BOOL    fAdvance
    )
/*++

Routine Description:

    Copies the token at the current character position

Arguments:

--*/
{
    HRESULT hr;

    RestoreToken();

    if ( !m_pszLineTerm )
    {
        TerminateLine();
    }

    hr = pstr->Copy( m_pszPos );

    if ( fAdvance )
    {
        NextLine();
    }

    return hr;
}

HRESULT
ODBC_PARSER::AppendToEOL(
    STRA   * pstr,
    BOOL    fAdvance
    )
/*++

Routine Description:

    Same as CopyToEOL except the text from the current line is appended to
    pstr

Arguments:

--*/
{
    HRESULT hr;

    RestoreToken();

    if ( !m_pszLineTerm )
    {
        TerminateLine();
    }

    hr = pstr->Append( m_pszPos );

    if ( fAdvance )
    {
        NextLine();
    }

    return hr;
}


CHAR *
ODBC_PARSER::NextLine(
    VOID
    )
/*++

Routine Description:

    Sets the current position to the first non-white character after the
    next '\n' (or terminating '\0').

--*/
{
    RestoreToken();
    RestoreLine();

    m_pszPos = AuxSkipTo( '\n' );

    if ( *m_pszPos )
    {
        m_pszPos++;
    }

    return EatWhite();
}

CHAR *
ODBC_PARSER::NextToken(
    VOID
    )
/*++

Routine Description:

    Sets the current position to the next non-white character after the
    current token

--*/
{
    //
    //  Make sure the line is terminated so a '\0' will be returned after
    //  the last token is found on this line
    //

    RestoreToken();

    if ( !m_pszLineTerm )
    {
        TerminateLine();
    }

    //
    //  Skip the current token
    //

    EatNonWhite();

    EatWhite();

    TerminateToken();

    return m_pszPos;
}


CHAR *
ODBC_PARSER::NextToken(
    CHAR ch
    )
/*++

Routine Description:

    Advances the position to the next token after ch (stopping
    at the end of the line)

--*/
{
    //
    //  Make sure the line is terminated so a '\0' will be returned after
    //  the last token is found on this line
    //

    RestoreToken();

    if ( !m_pszLineTerm )
    {
        TerminateLine();
    }

    //
    //  Look for the specified character (generally ',' or ';')
    //

    SkipTo( ch );

    if ( *m_pszPos )
    {
        m_pszPos++;
    }

    EatWhite();

    TerminateToken( ch );

    return m_pszPos;
}


CHAR *
ODBC_PARSER::SkipTo(
    CHAR ch
    )
/*++

Routine Description:

    Skips to the specified character or returns a null terminated string
    if the end of the line is reached


--*/
{
    //
    //  Make sure the line is terminated so a '\0' will be returned after
    //  the last token is found on this line
    //

    RestoreToken();

    if ( !m_pszLineTerm )
    {
        TerminateLine();
    }

    m_pszPos = AuxSkipTo( ch );

    return m_pszPos;
}


VOID
ODBC_PARSER::SetListMode(
    BOOL fListMode
    )
/*++

Routine Description:

    Resets the parser mode to list mode or non-list mode

Arguments:

--*/
{
    RestoreToken();

    if ( !m_pszLineTerm )
    {
        TerminateLine();
    }

    m_fListMode = fListMode;
}

VOID
ODBC_PARSER::TerminateToken(
    CHAR ch
    )
/*++

Routine Description:

    Zero terminates after the white space of the current token

Arguments:

--*/
{
    DBG_ASSERT( !m_pszTokenTerm );

    m_pszTokenTerm = AuxEatNonWhite( ch );

    m_chTokenTerm = *m_pszTokenTerm;

    *m_pszTokenTerm = '\0';
}

VOID
ODBC_PARSER::RestoreToken(
    VOID
    )
/*++

Routine Description:

    Restores the character replaced by the zero terminator

Arguments:

--*/
{
    if ( m_pszTokenTerm )
    {
        *m_pszTokenTerm = m_chTokenTerm;
        m_pszTokenTerm = NULL;
    }
}

VOID
ODBC_PARSER::TerminateLine(
    VOID
    )
/*++

Routine Description:

    Zero terminates at the end of this line

Arguments:

--*/
{
    DBG_ASSERT( !m_pszLineTerm );

    m_pszLineTerm = AuxSkipTo( '\n' );

    //
    //  Now trim any trailing white space on the line
    //

    if ( m_pszLineTerm > m_pszPos )
    {
        m_pszLineTerm--;

        while ( m_pszLineTerm >= m_pszPos &&
                ISWHITEA( *m_pszLineTerm ) )
        {
            m_pszLineTerm--;
        }
    }

    //
    //  Go forward one (trimming found the last non-white
    //  character)
    //

    if ( *m_pszLineTerm &&
         *m_pszLineTerm != '\n' &&
         !ISWHITEA( *m_pszLineTerm ))
    {
        m_pszLineTerm++;
    }

    m_chLineTerm = *m_pszLineTerm;

    *m_pszLineTerm = '\0';
}

VOID
ODBC_PARSER::RestoreLine(
    VOID
    )
/*++

Routine Description:

    Restores the character replaced by the zero terminator

Arguments:

--*/
{
    if ( m_pszLineTerm )
    {
        *m_pszLineTerm = m_chLineTerm;
        m_pszLineTerm = NULL;
    }
}




CHAR *
ODBC_PARSER::AuxEatNonWhite(
    CHAR ch
    )
/*++

Routine Description:

    In non list mode returns the first white space character after 
    the current parse position
    In list mode returns the first delimiter ( "';\n" ) character after 
    the current parse position

Arguments:

    ch - Optional character that is considered white space (such as ',' or ';'
        when doing list processing).

--*/
{
    CHAR * psz = m_pszPos;

    //
    //  Note that ISWHITEA includes '\r'.  In list mode, comma and semi-colon
    //  are considered delimiters
    //

    if ( !m_fListMode )
    {
        while ( *psz           &&
                *psz != '\n'   &&
                !ISWHITEA(*psz)&&
                *psz != ch )
        {
            psz++;
        }

        return psz;
    }
    else
    {
        while ( *psz           &&
                *psz != '\n'   &&
                *psz != ','    &&
                *psz != ';'    &&
                *psz != ch )
        {
            psz++;
        }

        return psz;
    }
}


CHAR *
ODBC_PARSER::AuxEatWhite(
    VOID
    )
/*++

Routine Description:

    Returns the first non-white space character after the current parse
    position

Arguments:

--*/
{
    CHAR * psz = m_pszPos;

    //
    //  Note that ISWHITEA includes '\r'
    //

    while ( *psz           &&
            *psz != '\n'   &&
            ISWHITEA(*psz))
    {
        psz++;
    }

    return psz;
}


CHAR *
ODBC_PARSER::AuxSkipTo(
    CHAR ch
    )
/*++

Routine Description:

    Skips to the specified character or returns a null terminated string
    if the end of the line is reached


--*/
{
    CHAR * psz = m_pszPos;

    while ( *psz           &&
            *psz != '\n'   &&
            *psz != ch )
    {
        psz++;
    }

    return psz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\sfwp\dll\certstore.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     certstore.cxx

   Abstract:
     Wrapper of a certificate store
 
   Author:
     Bilal Alam         (BAlam)         29-March-2000

   Environment:
     Win32 - User Mode

   Project:
     Stream Filter Worker Process
--*/

#include "precomp.hxx"

LIST_ENTRY              CERT_STORE::sm_ToBeDeletedListHead;
CRITICAL_SECTION        CERT_STORE::sm_csToBeDeletedList;
BOOL                    CERT_STORE::sm_fInitcsToBeDeletedList;
CERT_STORE_HASH *       CERT_STORE::sm_pCertStoreHash;
HANDLE                  CERT_STORE::sm_hDeletionThread = NULL;
BOOL                    CERT_STORE::sm_fDeletionThreadShutdown = FALSE;
HANDLE                  CERT_STORE::sm_hWakeupEvent = NULL;

CERT_STORE::CERT_STORE()
    : _cRefs( 1 ),
      _hStore( NULL ),
      _hWaitHandle( NULL ),
      _hStoreChangeEvent( NULL )
{
    _dwSignature = CERT_STORE_SIGNATURE;
}

CERT_STORE::~CERT_STORE()
{
    _dwSignature = CERT_STORE_SIGNATURE_FREE;
    if ( _hWaitHandle != NULL )
    {
        // don't continue until callback completed
        UnregisterWaitEx( _hWaitHandle,
                          INVALID_HANDLE_VALUE );
       _hWaitHandle = NULL;
    }
    
    if ( _hStoreChangeEvent != NULL )
    {
        CloseHandle( _hStoreChangeEvent );
        _hStoreChangeEvent = NULL;
    }
    
    if ( _hStore != NULL )
    {
        CertCloseStore( _hStore, 0 );
        _hStore = NULL;
    }
}

//static
VOID
WINAPI
CERT_STORE::CertStoreChangeRoutine(
    VOID *                  pvContext,
    BOOLEAN                 fTimedOut
)
/*++

Routine Description:

    Called when a certificate store has changed

Arguments:

    pvContext - Points to CERT_STORE which changed
    fTimedOut - Should always be FALSE since our wait is INFINITE

Return Value:

    HRESULT

Warning:

    Do not touch anything inside pCertStore (pvContext)
    This callback may happen when pCertStore is already being destroyed

    It is still safe to flush caches based on pCertStore because
    nothing inside pCertStore is accessed when flushing caches
    and in the case that the old pCertStore address got reused
    and placed in the cache again, in the worst case fresh item is flushed
    and will be reloaded again
    
--*/
{
    
    UNREFERENCED_PARAMETER( fTimedOut );
    CERT_STORE *            pCertStore = NULL;
    
    DBG_ASSERT( pvContext != NULL );
    DBG_ASSERT( fTimedOut == FALSE );
    
    pCertStore = (CERT_STORE*) pvContext;

    //
    // Remove the thing from the hash table for one
    //
    
    sm_pCertStoreHash->DeleteRecord( pCertStore );

    //
    // Instruct the server certificate cache to flush any certs which 
    // were referencing this cert store.  
    // Also flush all CTLs that were referencing cert store
    //
    SERVER_CERT::FlushByStore( pCertStore );
    IIS_CTL::FlushByStore( pCertStore );

    
}


//static
DWORD
WINAPI
CERT_STORE::DeletionWorkerThread(
    VOID *                  pvContext
)
/*++

Routine Description:

    thread handling deletion of the CERT_STORE instances
    to prevent deadlocks that would happen if deletion of the 
    CERT_STORE instance happened on the Change notification
    callback thread

Arguments:

    pvContext - not used

Return Value:

    HRESULT

Warning:


--*/
{

    UNREFERENCED_PARAMETER( pvContext );
      
    for(;;)
    {
        
        DWORD dwWaitStatus; 
        
        dwWaitStatus =
              WaitForSingleObject( sm_hWakeupEvent, 
                                   INFINITE  // time-out interval
                                 );

        DBG_ASSERT ( dwWaitStatus  == WAIT_OBJECT_0 );

        if( sm_fDeletionThreadShutdown == TRUE )
        {
            return NO_ERROR;
        }

        //
        // handle the Wakeup event
        //

        DeleteAllPendingInstances();

    }
}


//static
VOID
CERT_STORE::DeleteAllPendingInstances(    
    VOID
)
/*++

Routine Description:

    delete all CERT_STORE instances that are on the ToBeDeleted list
    
Arguments:

    none

Return Value:

    HRESULT

--*/

{
    LIST_ENTRY *    pCurrentEntry = NULL;

    for(;;)
    {
        //
        // Loop through each element on the list and call destructor on it
        //
        pCurrentEntry = NULL;
        
        EnterCriticalSection( &sm_csToBeDeletedList );
        if (! IsListEmpty( &sm_ToBeDeletedListHead ) )
        {
            pCurrentEntry = RemoveHeadList( &sm_ToBeDeletedListHead );
        }
        LeaveCriticalSection( &sm_csToBeDeletedList );      
        
        if ( pCurrentEntry == NULL )
        {
            break;
        }
        
        CERT_STORE * pCertStore = 
                CONTAINING_RECORD( pCurrentEntry,
                                   CERT_STORE,
                                   _ToBeDeletedListEntry );
        //
        // Note: Never call the destructor under the
        // critical section because that may cause deadlock 
        // Destructor is waiting for completion callback to return and there 
        // used to be a deadlock with sm_csToBeDeletedList, WriteLock on the 
        // IIS_CTL hash table and the wait on the change notification callback completion
        //
        delete pCertStore;
    }
}


HRESULT
CERT_STORE::Open(    
    STRU &              strStoreName
)
/*++

Routine Description:

    Open specified certificate store

Arguments:

    strStoreName - name of certificate store to open

Return Value:

    HRESULT

--*/
{
    HRESULT             hr = NO_ERROR;
    BOOL                fRet = TRUE;
    
    DBG_ASSERT( CheckSignature() );

    //
    // Remember the name
    //
    
    hr = _strStoreName.Copy( strStoreName );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    DBG_ASSERT( _hStore == NULL );

    //
    // Get the handle
    //
 
    _hStore = CertOpenStore( CERT_STORE_PROV_SYSTEM,
                             0,
                             NULL,
                             CERT_SYSTEM_STORE_LOCAL_MACHINE,
                             strStoreName.QueryStr() );
    if ( _hStore == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    //
    // Setup a change notification so that we are informed the cert store
    // has changed
    //
    
    _hStoreChangeEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
    if ( _hStoreChangeEvent == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    fRet = RegisterWaitForSingleObject( &_hWaitHandle,
                                        _hStoreChangeEvent,
                                        CERT_STORE::CertStoreChangeRoutine,
                                        this,
                                        INFINITE,
                                        WT_EXECUTEONLYONCE );
    if ( !fRet )
    {
        DBG_ASSERT( _hWaitHandle == NULL );
        
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    fRet = CertControlStore( _hStore,
                             0,
                             CERT_STORE_CTRL_NOTIFY_CHANGE,
                             &_hStoreChangeEvent );
    if ( !fRet )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
                             
    return NO_ERROR;
}

//static
HRESULT
CERT_STORE::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize CERT_STORE globals

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HRESULT   hr = E_FAIL;

    InitializeListHead( &sm_ToBeDeletedListHead );

    BOOL fRet = InitializeCriticalSectionAndSpinCount(
                                &sm_csToBeDeletedList,
                                0x80000000 /* precreate event */ |
                                IIS_DEFAULT_CS_SPIN_COUNT );
    if ( !fRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failed;

    }
    sm_fInitcsToBeDeletedList = TRUE;

    //
    // Setup wakeup event used for communication
    // with the thread handling deletion of CERT_STORE instances
    //
    
    sm_hWakeupEvent = CreateEvent( NULL,  // event attributes 
                                   FALSE, // FALSE mean auto reset event
                                   FALSE, // initial state
                                   NULL   // name
                                 );
    if ( sm_hWakeupEvent == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failed;
    }

    
    DBG_ASSERT( sm_pCertStoreHash == NULL );
    
    sm_pCertStoreHash = new CERT_STORE_HASH();
    if ( sm_pCertStoreHash == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failed;
    }

    sm_fDeletionThreadShutdown = FALSE;

    sm_hDeletionThread = ::CreateThread( 
                                 NULL,     // default security descriptor
                                 16000,    // Initial size as configured
                                 CERT_STORE::DeletionWorkerThread, // thread function
                                 NULL,     // thread argument
                                 0,        // create running
                                 NULL      // don't care for thread identifier
                              );
    if ( sm_hDeletionThread == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failed;
    }
   
    return NO_ERROR;
    
Failed:
    Terminate();
    return hr;
}

//static
VOID
CERT_STORE::Terminate(
    VOID
)
/*++

Routine Description:

    Terminate CERT_STORE globals

    Cleanup is expected to be called before Terminate() 
    if Initialize() completed with success

Arguments:

    None

Return Value:

    None

--*/
{
    DWORD dwWaitStatus = 0;

    
    if ( sm_hDeletionThread != NULL )
    {
        DBG_ASSERT( sm_ToBeDeletedListHead.Flink == NULL );
        
        InterlockedExchange( (LPLONG) &sm_fDeletionThreadShutdown, 1 );

        SetEvent( sm_hWakeupEvent );
        
        //
        // Issue: Jaroslad
        // what is SetEvent fails?
        //
        
        dwWaitStatus = WaitForSingleObject( sm_hDeletionThread,
                                            INFINITE );
        
        DBG_ASSERT( dwWaitStatus == WAIT_OBJECT_0 );
        CloseHandle( sm_hDeletionThread );
        sm_hDeletionThread = NULL;  

    }
    
    if ( sm_pCertStoreHash != NULL )
    {
        delete sm_pCertStoreHash;
        sm_pCertStoreHash = NULL;
    }

    if ( sm_hWakeupEvent != NULL )
    {
        CloseHandle( sm_hWakeupEvent );
        sm_hWakeupEvent = NULL;
    }
    
    if ( sm_fInitcsToBeDeletedList )
    {
        DeleteCriticalSection( &sm_csToBeDeletedList );
        sm_fInitcsToBeDeletedList = FALSE;
    }
}

//static
VOID
CERT_STORE::Cleanup(
    VOID
)
/*++

Routine Description:

    Cleanup CERT_STORE hash table

    This function must be called before the Terminate() call
    When Cleanup() is called, the overall cleanup should have reached
    the stage where there are no more external references 
    to a CERT_STORE instance
    

Arguments:

    None

Return Value:

    None

--*/
{
    DWORD dwWaitStatus = 0;

    //
    // delete all the cached CERT_STORE instances
    //
    sm_pCertStoreHash->Clear();

    //
    // indicate that Deletion thread is to shut down
    //

    InterlockedExchange( (LPLONG) &sm_fDeletionThreadShutdown, 1 );

    SetEvent( sm_hWakeupEvent );
    
    //
    // Issue: Jaroslad
    // what is SetEvent fails?
    //

    //
    // Wait for Deletion thread to shut down
    //
    dwWaitStatus = WaitForSingleObject( sm_hDeletionThread,
                                        INFINITE );
    
    DBG_ASSERT( dwWaitStatus == WAIT_OBJECT_0 );
    CloseHandle( sm_hDeletionThread );
    sm_hDeletionThread = NULL;  

    //
    // delete all the deletion pending instances of CERT_STORE
    //
    DeleteAllPendingInstances();

}

//static
HRESULT
CERT_STORE::OpenStore(
    STRU &              strStoreName,
    CERT_STORE **       ppStore
)
/*++

Routine Description:

    Open certificate store from cache

Arguments:

    strStoreName - Store name to open
    ppStore - Filled with store on success

Return Value:

    HRESULT

--*/
{
    HRESULT             hr = NO_ERROR;
    CERT_STORE *        pCertStore = NULL;
    LK_RETCODE          lkrc;
    
    if ( ppStore == NULL )
    {
        DBG_ASSERT( FALSE );
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        goto Finished;
    }
    *ppStore = NULL;
    
    //
    // Lookup in cache first
    //
    
    DBG_ASSERT( sm_pCertStoreHash != NULL );
    
    lkrc = sm_pCertStoreHash->FindKey( strStoreName.QueryStr(),
                                       &pCertStore );
    if ( lkrc != LK_SUCCESS )
    {
        //
        // OK.  Create one and add to cache
        //
        
        pCertStore = new CERT_STORE();
        if ( pCertStore == NULL )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Finished;
        }
        
        hr = pCertStore->Open( strStoreName );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }
        
        lkrc = sm_pCertStoreHash->InsertRecord( pCertStore );

        //
        // Ignore the error.  We will do the right thing if we couldn't 
        // add to hash (i.e. no extra reference happens and callers deref
        // will delete the object as desired)
        //        
    }
    
    DBG_ASSERT( pCertStore != NULL );
    
    *ppStore = pCertStore;

    return NO_ERROR;
    
Finished:
    if ( pCertStore != NULL )
    {
        pCertStore->DereferenceStore();
        pCertStore = NULL;
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\sfwp\dll\iisctl.cxx ===
/*++

   Copyright    (c)    2001    Microsoft Corporation

   Module  Name :
     iisctl.cxx

   Abstract:
     IIS CTL (Certificate Trust List) handler
     This gets used only with SSL client certificates
 
   Author:
     Jaroslav Dunajsky

   Environment:
     Win32 - User Mode

   Project:
     Stream Filter Worker Process
--*/

#include "precomp.hxx"

IIS_CTL_HASH *      IIS_CTL::sm_pIisCtlHash;

IIS_CTL::IIS_CTL( 
    IN  CREDENTIAL_ID *         pCredentialId 
) : _pCredentialId( pCredentialId ),
    _pCtlContext( NULL ),
    _pCtlStore( NULL ),
    _cRefs( 1 )
{
    _dwSignature = IIS_CTL_SIGNATURE;
}

IIS_CTL::~IIS_CTL()
{
    if ( _pCtlContext != NULL )
    {
        CertFreeCTLContext( _pCtlContext );
        _pCtlContext = NULL;
    }
    
    if ( _pCtlStore != NULL )
    {
        _pCtlStore->DereferenceStore();
        _pCtlStore = NULL;
    }

    if ( _pCredentialId != NULL )
    {
        delete _pCredentialId;
        _pCredentialId = NULL;
    }

    
    _dwSignature = IIS_CTL_SIGNATURE_FREE;
}

//static
HRESULT
IIS_CTL::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize IIS CTL globals

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    sm_pIisCtlHash = new IIS_CTL_HASH();
    if ( sm_pIisCtlHash == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_OUTOFMEMORY );
    }
    
    return NO_ERROR;
}

//static
VOID
IIS_CTL::Terminate(
    VOID
)
/*++

Routine Description:

    Cleanup IIS Ctl globals

Arguments:

    None

Return Value:

    None

--*/
{
    if ( sm_pIisCtlHash != NULL )
    {
        delete sm_pIisCtlHash;
        sm_pIisCtlHash = NULL;
    }
}

//static
HRESULT
IIS_CTL::GetIisCtl(
    IN  WCHAR *          pszSslCtlIdentifier,
    IN  WCHAR *          pszSslCtlStoreName,
    OUT IIS_CTL **       ppIisCtl
)
/*++

Routine Description:

    Find a suitable Ctl for use with the site represented by
    given site SslConfig

Arguments:

    pzsSslCtlIdentifier - identifies CTL
    pszSslCtlStoreName -  store name where CTL is to be located (in the LOCAL_MACHINE context)
                        If NULL, then default "CA" store is assumed
    ppIisCtl -          pointer to IIS CTL

Return Value:

    HRESULT

--*/
{
    IIS_CTL *               pIisCtl = NULL;
    CREDENTIAL_ID *         pCredentialId = NULL;
    HRESULT                 hr = NO_ERROR;
    LK_RETCODE              lkrc;
    
    if ( ppIisCtl == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    *ppIisCtl = NULL;

    if ( pszSslCtlStoreName == NULL )
    {
        //
        // assume default store name
        //
        pszSslCtlStoreName = L"CA";
    }
    
    //
    // First build up a Credential ID to use in looking up in our
    // server cert cache
    //
    
    pCredentialId = new CREDENTIAL_ID;
    if ( pCredentialId == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_OUTOFMEMORY );
    }
    
    hr = IIS_CTL::BuildCredentialId( pszSslCtlIdentifier,
                                     pCredentialId );
    if ( FAILED( hr ) )
    {
        //
        // Regardless of error, we are toast because we couldn't find
        // a server cert
        //
        
        delete pCredentialId;
        return hr;
    }
    
    DBG_ASSERT( sm_pIisCtlHash != NULL );
    
    lkrc = sm_pIisCtlHash->FindKey( pCredentialId,
                                    &pIisCtl );
    if ( lkrc == LK_SUCCESS )
    {
        //
        // Server already contains a credential ID
        //
        
        delete pCredentialId;
        
        *ppIisCtl = pIisCtl; 
        
        return NO_ERROR;
    }    
    
    //
    // Ok.  It wasn't in our case, we need to do it there
    // 
    // if IIS_CTL construction succeeds then IIS_CTL 
    // takes ownership of pCredentialId and is responsible for freeing it
    //
    
    pIisCtl = new IIS_CTL( pCredentialId );
    if ( pIisCtl == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_OUTOFMEMORY );

        delete pCredentialId;
        
        return hr;
    }
    
    hr = pIisCtl->SetupIisCtl( pszSslCtlIdentifier,
                               pszSslCtlStoreName );
    if ( FAILED( hr ) )
    {
        //
        // Server certificate owns the reference to pCredentialId now
        //
        
        delete pIisCtl;
        
        return hr;
    }
    
    //
    // Now try to add cert to hash.  
    //
    
    lkrc = sm_pIisCtlHash->InsertRecord( pIisCtl );

    //
    // Ignore the error.  If it didn't get added then we will naturally 
    // clean it up on the callers dereference
    //

    *ppIisCtl = pIisCtl;    
    
    return NO_ERROR;
}

//static
HRESULT
IIS_CTL::BuildCredentialId(
    IN  WCHAR *            pszSslCtlIdentifier,
    OUT CREDENTIAL_ID *    pCredentialId
)
/*++

Routine Description:

    Read the configured server cert and CTL hash.  This forms the identifier
    for the credentials we need for this site

Arguments:

    pszSslCtlIdentifier - CTL identifier
    pCredentialId - Filled with credential ID 

Return Value:

    HRESULT

--*/
{
    STACK_BUFFER(       buff, 64 );
    HRESULT             hr = NO_ERROR;

    if ( pCredentialId == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    if ( pszSslCtlIdentifier == NULL ||
         pszSslCtlIdentifier[0] == '\0' )
    {
        //
        // No CTL
        //
        
        return HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
    }        
    else
    {
        //
        // Add to our credential ID
        //
        
        hr = pCredentialId->Append( (BYTE*) pszSslCtlIdentifier,
                                    (DWORD) wcslen( pszSslCtlIdentifier ) * sizeof(WCHAR)  );
        if ( FAILED( hr ) )
        {
            return hr;
        }    
    }    

    return NO_ERROR;
}


//private
//static
HRESULT
IIS_CTL::SetupIisCtl(
    IN WCHAR *       pszSslCtlIdentifier,
    IN WCHAR *       pszSslCtlStoreName
)
/*++

Routine Description:

    Build CTL context for the site based on SiteSslConfig Info
  
Arguments:

    pszSslCtlIdentifier - identifies CTL
    pszSslCtlStoreName  - store name where CTL is to be located (in the LOCAL_MACHINE context)


 
Return Value:

    HRESULT

--*/
{
    HRESULT             hr = E_FAIL;
    PCCTL_CONTEXT       pCtlContext = NULL;
    CERT_STORE *        pCertStore = NULL;
    STACK_STRU(         strStoreName, 256 );


    if ( pszSslCtlIdentifier == NULL ||
         pszSslCtlStoreName == NULL ||
         pszSslCtlStoreName == L'\0' )

    {
        // CTLs not configured
        _pCtlContext = NULL;
        return S_OK;
    }

    //
    // First get the desired store and store it away for later!
    //

    hr = strStoreName.Copy( pszSslCtlStoreName );
    if ( FAILED( hr ) )
    {
        goto Finished;
    }
    
    hr = CERT_STORE::OpenStore( strStoreName,
                                &pCertStore );
    if ( FAILED( hr ) )
    {
        goto Finished;
    }
    
    DBG_ASSERT( pCertStore != NULL );
    _pCtlStore = pCertStore;        

    
    CTL_FIND_USAGE_PARA CtlFindUsagePara;
    ZeroMemory( &CtlFindUsagePara, 
                sizeof(CtlFindUsagePara) );

    CtlFindUsagePara.cbSize = sizeof(CtlFindUsagePara);
    CtlFindUsagePara.ListIdentifier.cbData = 
            ( (DWORD) wcslen( pszSslCtlIdentifier ) + 1 ) * sizeof(WCHAR);
    CtlFindUsagePara.ListIdentifier.pbData = (PBYTE) pszSslCtlIdentifier;


    //
    // Try to find CTL in specified store
    //
    pCtlContext = CertFindCTLInStore( _pCtlStore->QueryStore(),
                                      X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                      0,
                                      CTL_FIND_USAGE,
                                      (LPVOID) &CtlFindUsagePara,
                                      NULL );

    if ( pCtlContext == NULL )
    {
        
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Finished;
 
    }
    _pCtlContext = pCtlContext;
    hr = S_OK;
    
Finished:
    return hr;
    
}

//static
LK_PREDICATE
IIS_CTL::CertStorePredicate(
    IN IIS_CTL *           pIisCtl,
    IN void *              pvState
)
/*++

  Description:

    DeleteIf() predicate used to find items which reference the 
    CERT_STORE pointed to by pvState    

  Arguments:

    pIisCtl - Server cert
    pvState - Points to CERT_STORE

  Returns:

    LK_PREDICATE   - LKP_PERFORM indicates removing the current 
                                 token from token cache

                     LKP_NO_ACTION indicates doing nothing.

--*/
{
    LK_PREDICATE          lkpAction;
    CERT_STORE *          pCtlStore;

    DBG_ASSERT( pIisCtl != NULL );
    
    pCtlStore = (CERT_STORE*) pvState;
    DBG_ASSERT( pCtlStore != NULL );
    
    if ( pIisCtl->_pCtlStore == pCtlStore ) 
    {
        //
        // Before we delete the cert, flush any site which is referencing
        // it
        //
        
        ENDPOINT_CONFIG::FlushByIisCtl( pIisCtl );
        
        lkpAction = LKP_PERFORM;
    }
    else
    {
        lkpAction = LKP_NO_ACTION;
    }

    return lkpAction;
} 

//static
HRESULT
IIS_CTL::FlushByStore(
    IN CERT_STORE *    pCertStore
)
/*++

Routine Description:

    Flush any server certs which reference the given store
    
Arguments:

    pCertStore - Cert store to check

Return Value:

    HRESULT

--*/
{
    DBG_ASSERT( sm_pIisCtlHash != NULL );
    
    sm_pIisCtlHash->DeleteIf( IIS_CTL::CertStorePredicate, 
                                  pCertStore );
                                  
    return NO_ERROR;
}



HRESULT
IIS_CTL::VerifyContainsCert(
    IN  PCCERT_CONTEXT  pChainTop,
    OUT BOOL *          pfContainsCert
)
/*++

Routine Description:

    Verify is CTL contains given certificate

Arguments:

    pChainTop - top certificate of the chain to be found in CTL
    pfContainsCert - TRUE if contains, FALSE if it doesn't
                     (valuse valid only if function returns SUCCESS)
Return Value:

    HRESULT
    
--*/

{
    HRESULT         hr = E_FAIL;
    const int       SHA1_HASH_SIZE = 20;
    BYTE            rgbChainTopHash[ SHA1_HASH_SIZE ];
    DWORD           cbSize = SHA1_HASH_SIZE;

    if ( _pCtlContext == NULL )
    {
        //
        // pCTLContext could be NULL if there was failure in building
        // CTL context in the SITE CONFIG setup
        //
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // get hash of the certificate to be verified
    //
    if ( !CertGetCertificateContextProperty( pChainTop,
                                             CERT_SHA1_HASH_PROP_ID,
                                             rgbChainTopHash,
                                             &cbSize ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        DBGPRINTF((DBG_CONTEXT,
                   "Failed to get cert hash for CTL check: 0x%x\n",
                   hr));
        return hr;
    }

    //
    // Iterate through all the cert hashes in the CTL and compare hashes
    //

    for ( DWORD dwIndex = 0; dwIndex< _pCtlContext->pCtlInfo->cCTLEntry; dwIndex++ )
    {
        CRYPT_DATA_BLOB CertInCTLHashBlob = 
                _pCtlContext->pCtlInfo->rgCTLEntry[dwIndex].SubjectIdentifier;
        //
        // CODEWORK: checking hash size is a bit simplistic way of
        // verifying that SHA1 hash is used in CTL
        //
        if ( CertInCTLHashBlob.cbData != SHA1_HASH_SIZE || 
             CertInCTLHashBlob.pbData == NULL )
        {
            //
            // hash in the CTL is no SHA1 because size is different
            // or invalid CTL
            //
            DBG_ASSERT( FALSE );
            return CRYPT_E_NOT_FOUND;            
        }
        if ( memcmp( CertInCTLHashBlob.pbData, 
                      rgbChainTopHash, 
                      SHA1_HASH_SIZE ) == 0 )
        {
            *pfContainsCert = TRUE;
            return S_OK;
        }
    }
    
    *pfContainsCert = FALSE;
    return S_OK;
}

//static
VOID
IIS_CTL::Cleanup(
    VOID
)
/*++

Routine Description:

    Cleanup must be called before Terminate
    
Arguments:

    none

Return Value:

    VOID

--*/
{
    sm_pIisCtlHash->Clear();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\sfwp\dll\isapicontext.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     isapicontext.cxx

   Abstract:
     ISAPI stream context
     - used for Raw ISAPI notifications
       (applies only in the IIS backward compatibility mode)
 
   Author:
     Bilal Alam         (BAlam)         29-March-2000

   Environment:
     Win32 - User Mode

   Project:
     Stream Filter Worker Process
--*/

#include "precomp.hxx"

//static 
ALLOC_CACHE_HANDLER * ISAPI_STREAM_CONTEXT::sm_pachIsapiStreamContexts = NULL;


PFN_PROCESS_RAW_READ         ISAPI_STREAM_CONTEXT::sm_pfnRawRead;
PFN_PROCESS_RAW_WRITE        ISAPI_STREAM_CONTEXT::sm_pfnRawWrite;
PFN_PROCESS_CONNECTION_CLOSE ISAPI_STREAM_CONTEXT::sm_pfnConnectionClose;
PFN_PROCESS_NEW_CONNECTION   ISAPI_STREAM_CONTEXT::sm_pfnNewConnection;
PFN_RELEASE_CONTEXT          ISAPI_STREAM_CONTEXT::sm_pfnReleaseContext;

LIST_ENTRY                   ISAPI_STREAM_CONTEXT::sm_ListHead;
CRITICAL_SECTION             ISAPI_STREAM_CONTEXT::sm_csIsapiStreamContexts;
BOOL                         ISAPI_STREAM_CONTEXT::sm_fInitcsIsapiStreamContexts = FALSE;
LONG                         ISAPI_STREAM_CONTEXT::sm_lIsapiContexts = 0;
BOOL                         ISAPI_STREAM_CONTEXT::sm_fEnabledISAPIFilters = FALSE;

//static
HRESULT
ISAPI_STREAM_CONTEXT::Initialize(
    VOID
)
/*++

Routine Description:

    Global initialization for ISAPI raw filtering support

Arguments:

    pConfig - Configuration from W3CORE

Return Value:

    HRESULT

--*/
{
    HRESULT hr = E_FAIL;

    InitializeListHead( &sm_ListHead );
  
    ALLOC_CACHE_CONFIGURATION       acConfig;

    //
    // Setup allocation lookaside
    //

    acConfig.nConcurrency = 1;
    acConfig.nThreshold = 100;
    acConfig.cbSize = sizeof( ISAPI_STREAM_CONTEXT );

    DBG_ASSERT( sm_pachIsapiStreamContexts == NULL );

    sm_pachIsapiStreamContexts = new ALLOC_CACHE_HANDLER( "ISAPI_STREAM_CONTEXT",  
                                                &acConfig );

    if ( sm_pachIsapiStreamContexts == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto Finished;
    }

    BOOL fRet = InitializeCriticalSectionAndSpinCount(
                                &sm_csIsapiStreamContexts,
                                0x80000000 /* precreate event */ |
                                IIS_DEFAULT_CS_SPIN_COUNT );
    if ( !fRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Finished;

    }
    sm_fInitcsIsapiStreamContexts = TRUE;
    hr = S_OK;
    
Finished:
    if ( FAILED( hr ) )
    {
        Terminate();
    }
    return hr;
}

//static
VOID
ISAPI_STREAM_CONTEXT::Terminate(
    VOID
)
{
    DBG_ASSERT( !sm_fEnabledISAPIFilters );
    DBG_ASSERT( sm_lIsapiContexts == 0 );


    if ( sm_fInitcsIsapiStreamContexts )
    {
        DeleteCriticalSection( &sm_csIsapiStreamContexts );
        sm_fInitcsIsapiStreamContexts = FALSE;
    }
    
    if ( sm_pachIsapiStreamContexts != NULL )
    {
        delete sm_pachIsapiStreamContexts;
        sm_pachIsapiStreamContexts = NULL;
    }

}

HRESULT
ISAPI_STREAM_CONTEXT::ProcessNewConnection(
    CONNECTION_INFO *           pConnectionInfo,
    ENDPOINT_CONFIG *           /*pEndpointConfig*/
)
/*++

Routine Description:

    Handle a new raw connection

Arguments:

    pConnectionInfo - Raw connection info

Return Value:

    HRESULT

--*/
{
    HRESULT                 hr;
    PVOID                   pContext;
    
    if ( pConnectionInfo == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    DBG_ASSERT( sm_pfnNewConnection != NULL );
    
    hr = sm_pfnNewConnection( pConnectionInfo,
                              &pContext );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    _pvContext = pContext;
    
    return NO_ERROR;
}

HRESULT
ISAPI_STREAM_CONTEXT::ProcessRawReadData(
    RAW_STREAM_INFO *           pRawStreamInfo,
    BOOL *                      pfReadMore,
    BOOL *                      pfComplete
)
/*++

Routine Description:

    Handle data being read from the client

Arguments:

    pRawStreamInfo - Raw stream info describing incoming data
    pfReadMode - Set to TRUE if we want to read more data
    pfComplete - Set to TRUE if we should just disconnect

Return Value:

    HRESULT

--*/
{
    HRESULT             hr;
    DWORD               cbNextReadSize = 0;
    
    if ( pRawStreamInfo == NULL ||
         pfReadMore == NULL ||
         pfComplete == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    DBG_ASSERT( sm_pfnRawRead != NULL );
    
    hr = sm_pfnRawRead( pRawStreamInfo,
                        _pvContext,
                        pfReadMore,
                        pfComplete,
                        &cbNextReadSize );

    if ( cbNextReadSize )
    {
        QueryFiltChannelContext()->SetNextRawReadSize( cbNextReadSize );
    }

    return hr;
}

HRESULT
ISAPI_STREAM_CONTEXT::ProcessRawWriteData(
    RAW_STREAM_INFO *           pRawStreamInfo,
    BOOL *                      pfComplete
)
/*++

Routine Description:

    Handle data being sent to the client

Arguments:

    pRawStreamInfo - Raw stream info describing incoming data
    pfComplete - Set to TRUE if we should just disconnect

Return Value:

    HRESULT

--*/
{
    HRESULT             hr;
    
    if( pRawStreamInfo == NULL ||
        pfComplete == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    DBG_ASSERT( sm_pfnRawWrite != NULL );
    
    hr = sm_pfnRawWrite( pRawStreamInfo,
                         _pvContext,
                         pfComplete );
    
    return hr;
}
    
VOID
ISAPI_STREAM_CONTEXT::ProcessConnectionClose(
    VOID
)
/*++

Routine Description:

    Handle connection closure

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    DBG_ASSERT( sm_pfnConnectionClose != NULL );
    
    sm_pfnConnectionClose( _pvContext );
}

//static
HRESULT
ISAPI_STREAM_CONTEXT::SendDataBack(
    PVOID                       pvStreamContext,
    RAW_STREAM_INFO *           pRawStreamInfo
)
{
    FILTER_CHANNEL_CONTEXT *    pFiltChannelContext;
    
    if ( pRawStreamInfo == NULL || 
         pvStreamContext == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    pFiltChannelContext = (FILTER_CHANNEL_CONTEXT*) pvStreamContext;
    DBG_ASSERT( pFiltChannelContext->CheckSignature() );
    
    return pFiltChannelContext->SendDataBack( pRawStreamInfo );
}

//static
HRESULT
ISAPI_STREAM_CONTEXT::CreateContext( 
    IN  FILTER_CHANNEL_CONTEXT * pFilterChannelContext,
    OUT STREAM_CONTEXT ** ppIsapiContext )
/*++

Routine Description:

    Create ISAPI Context.

    ISAPI Contexts are to be created only in the
    IIS5 compatibility mode when Raw ISAPI Filter are enabled

    Each ISAPI context is added to the list. 
    Upon DisableISAPIFilters() call all connections with ISAPI contexts
    will be closed.

Arguments:

    pFilterChannelContext
    ppIsapiContext

Return Value:

    HRESULT

--*/
    
{
    HRESULT hr = S_OK;
    DBG_ASSERT( pFilterChannelContext != NULL );

    ISAPI_STREAM_CONTEXT * pIsapiContext =
                            new ISAPI_STREAM_CONTEXT( pFilterChannelContext );
    if ( pIsapiContext == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_OUTOFMEMORY );
    }

    EnterCriticalSection( &sm_csIsapiStreamContexts );
    if ( sm_fEnabledISAPIFilters )
    {
        pIsapiContext->_pFilterChannelContext = pFilterChannelContext;
        InsertHeadList( &sm_ListHead, &pIsapiContext->_ListEntry );
        sm_lIsapiContexts++;
    }
    else
    {
        //
        // W3SVC service must be shutting down
        // This is a rare path so it is OK to have it
        // under critical section
        //
        delete pIsapiContext;
        pIsapiContext = NULL;
        hr = HRESULT_FROM_WIN32( ERROR_SERVICE_NOT_ACTIVE );
    }

    LeaveCriticalSection( &sm_csIsapiStreamContexts );

    if ( SUCCEEDED( hr ) )
    {
        *ppIsapiContext = pIsapiContext;
    }
    return hr;
}

//static
HRESULT
ISAPI_STREAM_CONTEXT::EnableISAPIFilters(
    ISAPI_FILTERS_CALLBACKS *      pCallbacks
)
/*++

Routine Description:

    Enable ISAPI Filters

Arguments:

    pCallbacks - Configuration from W3CORE

Return Value:

    HRESULT

--*/
{
    if ( pCallbacks == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    sm_pfnRawRead = pCallbacks->pfnRawRead;
    sm_pfnRawWrite = pCallbacks->pfnRawWrite;
    sm_pfnConnectionClose = pCallbacks->pfnConnectionClose;
    sm_pfnNewConnection = pCallbacks->pfnNewConnection;
    sm_pfnReleaseContext = pCallbacks->pfnReleaseContext;

    EnterCriticalSection( &sm_csIsapiStreamContexts );
    sm_fEnabledISAPIFilters = TRUE;
    LeaveCriticalSection( &sm_csIsapiStreamContexts );
    return S_OK;
}
   

//static
VOID
ISAPI_STREAM_CONTEXT::DisableISAPIFilters( 
    VOID 
)
/*++

Routine Description:

    Trigger all connections that have ISAPI Context associated to be disconnected.
    Wait till all ISAPI contexts are deleted
    
Arguments:

    None

Return Value:

    HRESULT

--*/
    
{
    LIST_ENTRY *    pCurrentEntry = NULL;
    LIST_ENTRY *    pNextEntry = NULL;

    //
    // forcefully close all current connections that
    // include ISAPI filter context
    //

    //
    // Critical section doesn't guarantee that
    // Filter Channel Contexts on the list are still active
    // They may be in progress of being deleted waiting
    // to be taken out of the list. That's why caution must be
    // used when accessing Filter Channel Contexts
    //

    EnterCriticalSection( &sm_csIsapiStreamContexts );

    sm_fEnabledISAPIFilters = FALSE;

    pCurrentEntry =  &sm_ListHead;

    //
    // Move CurrentEntry pointer to next element
    //
    pCurrentEntry = pCurrentEntry->Flink;

    //
    // Loop through each element and forcefully close all
    // that have ISAPI_STREAM_CONTEXT context
    //

    while( pCurrentEntry != &sm_ListHead )
    {
        ISAPI_STREAM_CONTEXT * pIsapiContext = 
                CONTAINING_RECORD( pCurrentEntry,
                                   ISAPI_STREAM_CONTEXT,
                                   _ListEntry );
       
        pNextEntry = pCurrentEntry->Flink;
        
        //
        // Initiate closing of the connection
        // Warning: StartClose() may actually reentrantly enter
        // critical section and cause pIsapiContext deletion
        // Don't access anything in pIsapiContext or
        // _pFilterChannelContext after StartClose() call
        // Also be aware that _pFilterChannelContext may
        // be executing it's destructor however it's memory is still accesible
        // because in the worst case would block on the 
        // sm_csIsapiStreamContexts when trying to destroy it's _pIsapiContext
        // Accessing _pFilterChannelContext that is partially destroyed
        // is ugly but under controlled circumstances it works. 
        //
        
        pIsapiContext->QueryFilterChannelContext()->StartClose();
        //
        // Move CurrentEntry pointer to next element
        //
        pCurrentEntry = pNextEntry;

    }

    LeaveCriticalSection( &sm_csIsapiStreamContexts );

    //
    // Wait till all connections with ISAPI_STREAM_CONTEXT
    // are destroyed
    //

    while ( sm_lIsapiContexts != 0 )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Waiting for %d ISAPI CONTEXTs to drain\n",
                    sm_lIsapiContexts ));

        Sleep( 1000 );
    }

    sm_pfnRawRead = NULL;
    sm_pfnRawWrite = NULL;
    sm_pfnConnectionClose = NULL;
    sm_pfnNewConnection = NULL;
    sm_pfnReleaseContext = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\sfwp\dll\servercert.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     servercert.cxx

   Abstract:
     Server Certificate wrapper
 
   Author:
     Bilal Alam         (BAlam)         29-March-2000

   Environment:
     Win32 - User Mode

   Project:
     Stream Filter Worker Process
--*/

#include "precomp.hxx"

SERVER_CERT_HASH *      SERVER_CERT::sm_pServerCertHash;

SERVER_CERT::SERVER_CERT( 
    IN CREDENTIAL_ID *         pCredentialId 
) : _pCredentialId( pCredentialId ),
    _pCertContext( NULL ),
    _pCertStore( NULL ),
    _cRefs( 1 ),
    _usPublicKeySize( 0 ),
    _fUsesHardwareAccelerator( FALSE )
{
    _dwSignature = SERVER_CERT_SIGNATURE;
}

SERVER_CERT::~SERVER_CERT()
{
    if ( _pCertContext != NULL )
    {
        CertFreeCertificateContext( _pCertContext );
        _pCertContext = NULL;
    }
    
    if ( _pCertStore != NULL )
    {
        _pCertStore->DereferenceStore();
        _pCertStore = NULL;
    }

    if ( _pCredentialId != NULL )
    {
        delete _pCredentialId;
        _pCredentialId = NULL;
    }
    
    _dwSignature = SERVER_CERT_SIGNATURE_FREE;
}

//static
HRESULT
SERVER_CERT::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize server certificate globals

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    sm_pServerCertHash = new SERVER_CERT_HASH();
    if ( sm_pServerCertHash == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_OUTOFMEMORY );
    }
    
    return NO_ERROR;
}

//static
VOID
SERVER_CERT::Terminate(
    VOID
)
/*++

Routine Description:

    Cleanup server certificate globals

Arguments:

    None

Return Value:

    None

--*/
{

    if ( sm_pServerCertHash != NULL )
    {
        delete sm_pServerCertHash;
        sm_pServerCertHash = NULL;
    }
}

//static
HRESULT
SERVER_CERT::GetServerCertificate(
    IN  PBYTE                     pbSslCertHash,
    IN  DWORD                     cbSslCertHash,
    IN  WCHAR *                   pszSslCertStoreName,
    OUT SERVER_CERT **            ppServerCert
)
/*++

Routine Description:

    Find a suitable server certificate for use with the site represented by
    given site id

Arguments:


    pbSslCertHash - certificate hash
    cbSslCertHash - certificate hash size
    pszSslCertStoreName - store name where certificate is stored (under LOCAL_MACHINE context)
                         if NULL then the default MY store is assumed
    ppServerCert - Filled with a pointer to server certificate

Return Value:

    HRESULT

--*/
{
    SERVER_CERT *           pServerCert = NULL;
    CREDENTIAL_ID *         pCredentialId = NULL;
    HRESULT                 hr = NO_ERROR;
    LK_RETCODE              lkrc;
    STACK_STRU(             strMBPath, 64 );
    
    if ( ppServerCert == NULL ||
         pbSslCertHash == NULL ||
         cbSslCertHash == 0 )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    *ppServerCert = NULL;

    if ( pszSslCertStoreName == NULL )
    {
        //
        // Assume default store name
        //
        pszSslCertStoreName = L"MY";
    }
    
    //
    // First build up a Credential ID to use in looking up in our
    // server cert cache
    //
    
    pCredentialId = new CREDENTIAL_ID;
    if ( pCredentialId == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_OUTOFMEMORY );
    }
    
    hr = SERVER_CERT::BuildCredentialId( pbSslCertHash,
                                         cbSslCertHash,
                                         pCredentialId );
    if ( FAILED( hr ) )
    {
        //
        // Regardless of error, we are toast because we couldn't find
        // a server cert
        //
        
        delete pCredentialId;
        return hr;
    }
    
    DBG_ASSERT( sm_pServerCertHash != NULL );
    
    lkrc = sm_pServerCertHash->FindKey( pCredentialId,
                                        &pServerCert );
    if ( lkrc == LK_SUCCESS )
    {
        //
        // Server already contains a credential ID
        //
        
        delete pCredentialId;
        
        *ppServerCert = pServerCert; 
        
        return NO_ERROR;
    }    
    
    //
    // Ok.  It wasn't in our case, we need to it there
    //
    // if SERVER_CERT construction succeeds then SERVER_CERT
    // takes ownership of pCredentialId and is responsible for freeing it
    //
    pServerCert = new SERVER_CERT( pCredentialId );
    if ( pServerCert == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_OUTOFMEMORY );

        delete pCredentialId;
        
        return hr;
    }
    
    hr = pServerCert->SetupCertificate( pbSslCertHash,
                                        cbSslCertHash,
                                        pszSslCertStoreName );
    if ( FAILED( hr ) )
    {
        //
        // Server certificate owns the reference to pCredentialId now
        //
        
        delete pServerCert;
        
        return hr;
    }

    hr = pServerCert->DetermineUseOfSSLHardwareAccelerator();
    if ( FAILED( hr ) )
    {
        //
        // We will not take this failure for fatal.
        // Information about the presence of SSL Hardware accelerator is 
        // used only for performance tuning
        //
        hr = S_OK;
    }
    
    //
    // Now try to add cert to hash.  
    //
    
    lkrc = sm_pServerCertHash->InsertRecord( pServerCert );

    //
    // Ignore the error.  If it didn't get added then we will naturally 
    // clean it up on the callers dereference
    //

    *ppServerCert = pServerCert;    
    
    return NO_ERROR;
}

//static
HRESULT
SERVER_CERT::BuildCredentialId(
    IN  PBYTE                     pbSslCertHash,
    IN  DWORD                     cbSslCertHash,
    OUT CREDENTIAL_ID *           pCredentialId
)
/*++

Routine Description:

    Read the configured server cert and CTL hash.  This forms the identifier
    for the credentials we need for this site

Arguments:

    pbSslCertHash  - server certificate hash
    cbSslCertHash  - size of the hash
    pCredentialId - Filled with credential ID 

Return Value:

    HRESULT

--*/
{
    BYTE                abBuff[ 64 ];
    BUFFER              buff( abBuff, sizeof( abBuff ) );
    HRESULT             hr = NO_ERROR;

    if ( pCredentialId == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    if ( cbSslCertHash == 0 )
    {
        //
        // No server cert.  Then we can't setup SSL
        //
        
        return HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
    }        
    else
    {
        //
        // Add to our credential ID
        //
        
        hr = pCredentialId->Append( pbSslCertHash,
                                    cbSslCertHash );
        if ( FAILED( hr ) )
        {
            return hr;
        }    
    }    

    return NO_ERROR;
}

HRESULT
SERVER_CERT::SetupCertificate(
    IN PBYTE   pbSslCertHash,
    IN DWORD   cbSslCertHash,
    IN WCHAR * pszSslCertStoreName
)
/*++

Routine Description:

    Find certificate in the given store
    
Arguments:

    pbSslCertHash - certificate hash
    cbSslCertHash - certificate hash size
    pszSslCertStoreName - store name where certificate is stored (under LOCAL_MACHINE context)


Return Value:

    HRESULT

--*/
{
    HRESULT                 hr = NO_ERROR;
    BYTE                    abBuff[ 128 ];
    BUFFER                  buff( abBuff, sizeof( abBuff ) );
    STACK_STRU(             strStoreName, 256 );
    CERT_STORE *            pCertStore = NULL;
    CRYPT_HASH_BLOB         hashBlob;
    PCERT_PUBLIC_KEY_INFO   pPublicKey;
    DWORD                   cbX500Name = 0;
    
    
    //
    // Get the required server certificate hash
    //
    if ( cbSslCertHash == 0 ||
         pszSslCertStoreName == NULL || 
         pszSslCertStoreName[0] == 0 )
         
    {
        //
        // No server cert.  Then we can't setup SSL
        //
        
        return HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
    }
    
    //
    // OK.  We are ready to retrieve the certificate using CAPI APIs
    //
    
    //
    // First get the desired store and store it away for later!
    //
    hr = strStoreName.Copy( pszSslCertStoreName );
    if ( FAILED( hr ) )
    {
        goto Finished;
    }
    
    hr = CERT_STORE::OpenStore( strStoreName,
                                &pCertStore );
    if ( FAILED( hr ) )
    {
        goto Finished;
    }
    
    DBG_ASSERT( pCertStore != NULL );
    _pCertStore = pCertStore;
    
    //
    // Now find the certificate hash in the store
    //
    
    hashBlob.cbData = cbSslCertHash;
    hashBlob.pbData = pbSslCertHash;

    _pCertContext = CertFindCertificateInStore( _pCertStore->QueryStore(),
                                                X509_ASN_ENCODING,
                                                0,
                                                CERT_FIND_SHA1_HASH,
                                                (VOID*) &hashBlob,
                                                NULL );
    if ( _pCertContext == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Finished;
    } 


    //
    // Get certificate public key size
    //
    
    DBG_ASSERT( _usPublicKeySize == 0 );
    
    pPublicKey = &(_pCertContext->pCertInfo->SubjectPublicKeyInfo);

    _usPublicKeySize = (USHORT) CertGetPublicKeyLength( PKCS_7_ASN_ENCODING | X509_ASN_ENCODING, 
                                                        pPublicKey );

    if ( _usPublicKeySize == 0 )
    {
        //
        // Failed to receive public key size
        //
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Finished; 

    }

    //
    // Get issuer string
    //
    
    DBG_ASSERT( _pCertContext->pCertInfo != NULL );

    //
    // First find out the size of buffer required for issuer
    //

    cbX500Name = CertNameToStrA( PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
                                &_pCertContext->pCertInfo->Issuer,
                                CERT_X500_NAME_STR,
                                NULL,
                                0);
    if( !buff.Resize( cbX500Name ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Finished; 
    }    
    
    cbX500Name = CertNameToStrA( PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
                                &_pCertContext->pCertInfo->Issuer,
                                CERT_X500_NAME_STR,
                                (LPSTR) buff.QueryPtr(),
                                buff.QuerySize() );

    hr = _strIssuer.Copy( (LPSTR) buff.QueryPtr() );
    if ( FAILED( hr ) )
    {
        goto Finished; 
    }
    
    //
    // Get subject string
    //
    
    //
    // First find out the size of buffer required for subject
    //

    cbX500Name = CertNameToStrA( PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
                                &_pCertContext->pCertInfo->Subject,
                                CERT_X500_NAME_STR,
                                NULL,
                                0);
    if( !buff.Resize( cbX500Name ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Finished; 
    }    
    cbX500Name = CertNameToStrA( PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
                                &_pCertContext->pCertInfo->Subject,
                                CERT_X500_NAME_STR,
                                (LPSTR) buff.QueryPtr(),
                                buff.QuerySize() );
    
    hr = _strSubject.Copy( (LPSTR) buff.QueryPtr() );
    if ( FAILED( hr ) )
    {
        goto Finished; 
    }
    
Finished:
        
    return hr;    
}



HRESULT
SERVER_CERT::DetermineUseOfSSLHardwareAccelerator(
    VOID
    )
/*++

Routine Description:

    
    Find out if SSL hardware accelerator is used.
    
    Currently there is no reliable way to ask
    schannel or CAPI if SSL hardware accelerator is indeed used
    we use optimistic lookup of config info based on magic
    instructions from John Banes (see Windows Bugs 510131)
    and based on that we make educated guess
    The only purpose to care about this is for performance tuning
    of the threadpool
    
    
Arguments:
    none
    
Return Value:

    HRESULT

--*/    
    
{
    HRESULT hr = E_FAIL;
    HCRYPTPROV hProv = NULL;
    BOOL fUsesHardwareAccelerator = FALSE;
    CHAR *pszCSPName = NULL;
    DWORD dwKeySpec;
    DWORD dwImpType;
    DWORD cbData = 0;
    HKEY  hKeyParam = NULL;


    
    if (!CryptAcquireCertificatePrivateKey(
                                            *QueryCertContext(),
                                            0,      // dwFlags
                                            NULL,   // pvReserved
                                            &hProv,
                                            &dwKeySpec,
                                            NULL))  // pfCallerFreeProv
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Finished;
    }

    cbData = sizeof( dwImpType );
    if (!CryptGetProvParam( hProv, 
                            PP_IMPTYPE, 
                            (PBYTE) &dwImpType, 
                            &cbData, 0))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Finished;
    }
    //
    // Check implementation type.
    //
    if (dwImpType == CRYPT_IMPL_HARDWARE || dwImpType == CRYPT_IMPL_MIXED )
    {
        //
        // We can safely assume that hardware accelerator is used
        //
        fUsesHardwareAccelerator = TRUE;
        hr = S_OK;
        goto Finished;
    
    }
    
    //
    // lookup CSP Name
    // if  MS_DEF_RSA_SCHANNEL_PROV_W then we will have to check registry
    // to find out if hardware accelerator is registered
    //
    
    
    if( !CryptGetProvParam( hProv,
                            PP_NAME,
                            NULL,
                            &cbData,
                            0 ) )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Finished;
    }
    
    pszCSPName = new char [ cbData ];
    if ( pszCSPName == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_OUTOFMEMORY );
        goto Finished;
    }

    if( !CryptGetProvParam( hProv,
                            PP_NAME,
                            (BYTE *)pszCSPName,
                            &cbData,
                            0 ))
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Finished;
    }

    if ( _stricmp ( pszCSPName,  MS_DEF_RSA_SCHANNEL_PROV_A ) != 0 )
    {
        //
        // we cannot determine so we assume the answer is no
        //
        fUsesHardwareAccelerator = FALSE;
        hr = S_OK;
        goto Finished;            
    }
    if ( RegOpenKeyExA( HKEY_LOCAL_MACHINE,
                       "Software\\Microsoft\\Cryptography\\Offload",
                       0,
                       KEY_READ,
                       &hKeyParam ) == ERROR_SUCCESS )
    {
        DWORD dwType;

        cbData = 0;
        DWORD dwError = RegQueryValueExA(   hKeyParam,
                                            EXPO_OFFLOAD_REG_VALUE,
                                            NULL,
                                            &dwType,
                                            ( LPBYTE ) NULL,
                                            &cbData
                                            );

        if ( ( dwError == ERROR_SUCCESS ) ) 
        {
            //
            // We don't really care to read the value
            // this is good enough indication that value exists
            // It means that we assume hardware accelerator is present
            //
            
           
            fUsesHardwareAccelerator = TRUE;
            hr = S_OK;
            goto Finished;
        }

        RegCloseKey( hKeyParam );
        fUsesHardwareAccelerator = FALSE;
        hr = S_OK;
        goto Finished;
    }

    Finished:

    if ( hKeyParam != NULL )
    {
        RegCloseKey( hKeyParam );
    }

    if ( pszCSPName != NULL )
    {
        delete [] pszCSPName;
    }

    if ( hProv != NULL )
    {
        CryptReleaseContext(hProv, 0);
    }

    _fUsesHardwareAccelerator = fUsesHardwareAccelerator;
    return hr;  
        
 }


//static
LK_PREDICATE
SERVER_CERT::CertStorePredicate(
    IN SERVER_CERT *           pServerCert,
    IN void *                  pvState
)
/*++

  Description:

    DeleteIf() predicate used to find items which reference the 
    CERT_STORE pointed to by pvState    

  Arguments:

    pServerCert - Server cert
    pvState - Points to CERT_STORE

  Returns:

    LK_PREDICATE   - LKP_PERFORM indicates removing the current 
                                 cert store from certstore cache

                     LKP_NO_ACTION indicates doing nothing.

--*/
{
    LK_PREDICATE          lkpAction;
    CERT_STORE *          pCertStore;

    DBG_ASSERT( pServerCert != NULL );
    
    pCertStore = (CERT_STORE*) pvState;
    DBG_ASSERT( pCertStore != NULL );
    
    if ( pServerCert->_pCertStore == pCertStore ) 
    {
        //
        // Before we delete the cert, flush any site which is referencing
        // it
        //
        
        ENDPOINT_CONFIG::FlushByServerCert( pServerCert );
        
        lkpAction = LKP_PERFORM;
    }
    else
    {
        lkpAction = LKP_NO_ACTION;
    }

    return lkpAction;
} 

//static
HRESULT
SERVER_CERT::FlushByStore(
    IN CERT_STORE *            pCertStore
)
/*++

Routine Description:

    Flush any server certs which reference the given store
    
Arguments:

    pCertStore - Cert store to check

Return Value:

    HRESULT

--*/
{
    DBG_ASSERT( sm_pServerCertHash != NULL );
    
    sm_pServerCertHash->DeleteIf( SERVER_CERT::CertStorePredicate, 
                                  pCertStore );
                                  
    return NO_ERROR;
}

//static
VOID
SERVER_CERT::Cleanup(
    VOID
)
/*++

Routine Description:

    Cleanup must be called before Terminate
    
Arguments:

    none

Return Value:

    VOID

--*/
{
    sm_pServerCertHash->Clear();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\sfwp\dll\uccontext.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     uccontext.cxx

   Abstract:
     Implementation of SSL_CLIENT_FILTER_CHANNEL_CONTEXT.
     One such object for every connection

   Environment:
     Win32 - User Mode

   Project:
     Stream Filter Worker Process
--*/

#include "precomp.hxx"


SSL_CLIENT_FILTER_CHANNEL_CONTEXT::SSL_CLIENT_FILTER_CHANNEL_CONTEXT(
    FILTER_CHANNEL *pManager
    )
    : FILTER_CHANNEL_CONTEXT(pManager)
{
    _dwSignature = SSL_CLIENT_FILTER_CHANNEL_CONTEXT_SIGNATURE;
}


SSL_CLIENT_FILTER_CHANNEL_CONTEXT::~SSL_CLIENT_FILTER_CHANNEL_CONTEXT()
{
    _dwSignature = SSL_CLIENT_FILTER_CHANNEL_CONTEXT_SIGNATURE_FREE;
}


HRESULT
SSL_CLIENT_FILTER_CHANNEL_CONTEXT::Create()
{
    DBG_ASSERT(_pSSLContext == NULL);

    _pSSLContext = new UC_SSL_STREAM_CONTEXT( this );
    if ( _pSSLContext == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\sfwp\dll\sitecred.cxx ===
/*++

   Copyright    (c)    2000    Microsoft Corporation

   Module  Name :
     sitecred.cxx

   Abstract:
     SChannel site credentials
 
   Author:
     Bilal Alam         (BAlam)         29-March-2000

   Environment:
     Win32 - User Mode

   Project:
     Stream Filter Worker Process
--*/

#include "precomp.hxx"

SITE_CREDENTIALS::SITE_CREDENTIALS()
    : _fInitCreds( FALSE )
{
    ZeroMemory( &_hCreds, sizeof( _hCreds ) );
}

SITE_CREDENTIALS::~SITE_CREDENTIALS()
{
    if ( _fInitCreds )
    {
        FreeCredentialsHandle( &_hCreds );
        _fInitCreds = FALSE;
    }
}

//static
HRESULT
SITE_CREDENTIALS::Initialize(
    VOID
)
/*++

Routine Description:

    Credentials global init

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    return NO_ERROR;
}

//static
VOID
SITE_CREDENTIALS::Terminate(
    VOID
)
/*++

Routine Description:

    Cleanup globals

Arguments:

    None

Return Value:

    None

--*/
{
}

HRESULT
SITE_CREDENTIALS::AcquireCredentials(
    SERVER_CERT *           pServerCert,
    BOOL                    fUseDsMapper
)
/*++

Routine Description:

    Acquire SChannel credentials for the given server certificate and 
    certificate mapping configuration

Arguments:

    pServerCert - Server certificate
    fUseDsMapper - enable Ds mappings

Return Value:

    HRESULT

--*/
{
    SCHANNEL_CRED               schannelCreds;
    SECURITY_STATUS             secStatus;
    TimeStamp                   tsExpiry;
    
    if ( pServerCert == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // If DS mapper is enabled (global setting) then create credentials
    // that always enable DS mapping (see schannelCreds.dwFlags)
    // Mapped Token will be used optionally
    // if certificate mapping is enabled for requested file
    //
    // This approach may cause performance problems
    // for scenarios where Ds mapping is enabled but requested
    // file doesn't enable certificate mappings.
    // Currently there is no workaround because schannel performs
    // ds mapping during the ssl handshake. Ideally schannel should 
    // map only if QuerySecurityContextToken() is called
    // 
    
    ZeroMemory( &schannelCreds, sizeof( schannelCreds ) );
    schannelCreds.dwVersion = SCHANNEL_CRED_VERSION;
    schannelCreds.cCreds = 1;
    schannelCreds.paCred = pServerCert->QueryCertContext();
    schannelCreds.cMappers = 0;
    schannelCreds.aphMappers = NULL;
    schannelCreds.hRootStore = NULL;
    if ( fUseDsMapper )
    {
        schannelCreds.dwFlags = 0;
    }
    else
    {
        schannelCreds.dwFlags = SCH_CRED_NO_SYSTEM_MAPPER;
    }
    
    secStatus = AcquireCredentialsHandle( NULL,
                                          UNISP_NAME_W,
                                          SECPKG_CRED_INBOUND,
                                          NULL,
                                          &schannelCreds,
                                          NULL,
                                          NULL,
                                          &_hCreds,
                                          &tsExpiry ); 
    
    if ( FAILED( secStatus ) )
    {
        //
        // If we can't even establish plain-jane credentials, then bail
        //
        
        return secStatus;
    }
    _fInitCreds = TRUE;
    
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\sfwp\dll\ucsslcontext.cxx ===
/*++

Copyright (c) 2000-2001 Microsoft Corporation

Module  Name :
     sslcontext.cxx

Abstract:
     SSL stream context for the client SSL support.
 
Author:
    Rajesh Sundaram (rajeshsu)          1-April-2001.

Environment:
     Win32 - User Mode

Project:
     Stream Filter Worker Process
--*/




#include "precomp.hxx"


// BUGBUG: close connection to server thro SSPI when cert validation fails
// BUGBUG: Explore - server cert alert messages


SECURITY_STATUS
CreateCredentialsHandle(
    IN  DWORD          dwProtocolType,
    IN  DWORD          dwFlags,
    IN  PCCERT_CONTEXT pCertContext,
    OUT PCredHandle    phClienCred
    );


UC_SSL_STREAM_CONTEXT::UC_SSL_STREAM_CONTEXT(
    FILTER_CHANNEL_CONTEXT *pUcContext
    )
    : STREAM_CONTEXT          (pUcContext),
      _pServerName            (0),
      _ServerNameLength       (0),
      _SslProtocolVersion     (0),
      _sslState               (UC_SSL_STATE_HANDSHAKE_START),
      _fRenegotiate           (FALSE),
      _fValidContext          (FALSE),
      _fValidClientCred       (FALSE),
      _cbReReadOffset         (0),
      _pServerCert            (NULL),
      _pSerializedCert        (NULL),
      _SerializedCertLength   (0),
      _pSerializedStore       (NULL),
      _SerializedStoreLength  (0),
      _pClientCert            (NULL),
      _cbDecrypted            (0),
      _ValidateServerCertFlag (0),
      _fValidServerCertInfo    (FALSE)
{
    //
    // Initialize security buffer structs
    //
    
    //
    // Setup buffer to hold incoming raw data
    //

    _Message.ulVersion = SECBUFFER_VERSION;
    _Message.cBuffers = 4;
    _Message.pBuffers = _Buffers;

    _Buffers[0].BufferType = SECBUFFER_EMPTY;
    _Buffers[1].BufferType = SECBUFFER_EMPTY;
    _Buffers[2].BufferType = SECBUFFER_EMPTY;
    _Buffers[3].BufferType = SECBUFFER_EMPTY;

    //
    // Setup buffer for ISC to return raw data to be sent to client
    //

    _MessageOut.ulVersion = SECBUFFER_VERSION;
    _MessageOut.cBuffers = 4;
    _MessageOut.pBuffers = _OutBuffers;

    _OutBuffers[0].BufferType = SECBUFFER_EMPTY;
    _OutBuffers[1].BufferType = SECBUFFER_EMPTY;
    _OutBuffers[2].BufferType = SECBUFFER_EMPTY;
    _OutBuffers[3].BufferType = SECBUFFER_EMPTY;

    //
    // Setup buffer for app data to be encrypted
    //
    
    _EncryptMessage.ulVersion = SECBUFFER_VERSION;
    _EncryptMessage.cBuffers = 4;
    _EncryptMessage.pBuffers = _EncryptBuffers;
     
    _EncryptBuffers[0].BufferType = SECBUFFER_EMPTY;
    _EncryptBuffers[1].BufferType = SECBUFFER_EMPTY;
    _EncryptBuffers[2].BufferType = SECBUFFER_EMPTY;
    _EncryptBuffers[3].BufferType = SECBUFFER_EMPTY;

    //
    // Zero out data structures
    //

    ZeroMemory(&_hContext, sizeof(_hContext));
    ZeroMemory(&_hClientCred, sizeof(_hClientCred));
    ZeroMemory(&_ucServerCertInfo, sizeof(_ucServerCertInfo));
    ZeroMemory(&_IssuerListInfo, sizeof(_IssuerListInfo));
}


UC_SSL_STREAM_CONTEXT::~UC_SSL_STREAM_CONTEXT()
{
    if (_fValidContext)
    {
        DeleteSecurityContext(&_hContext);
        _fValidContext = FALSE;
    }

    if (_fValidClientCred)
    {
        FreeCredentialsHandle(&_hClientCred);
        _fValidClientCred = FALSE;
    }

    if (_pServerCert != NULL)
    {
        CertFreeCertificateContext(_pServerCert);
        _pServerCert = NULL;
    }

    if (_pClientCert != NULL)
    {
        CertFreeCertificateContext(_pClientCert);
        _pClientCert = NULL;
    }

    if (_pServerName != _ServerNameBuffer && _pServerName)
    {
        delete[] _pServerName;
        _pServerName = NULL;
    }

    if (_IssuerListInfo.aIssuers)
    {
        DBG_ASSERT(_IssuerListInfo.cIssuers);
        FreeContextBuffer(_IssuerListInfo.aIssuers);
        _IssuerListInfo.aIssuers = NULL;
    }

    if (_pSerializedCert)
    {
        delete[] _pSerializedCert;
        _pSerializedCert = NULL;
        _SerializedCertLength = 0;
    }

    if (_pSerializedStore)
    {
        delete[] _pSerializedStore;
        _pSerializedStore = NULL;
        _SerializedStoreLength = 0;
    }
}


/****************************************************************************++

Routine Description:

    Handle a new raw connection

Arguments:

    pConnectionInfo - The magic connection information

Return Value:

    HRESULT

--****************************************************************************/
HRESULT
UC_SSL_STREAM_CONTEXT::ProcessNewConnection(
    CONNECTION_INFO *pConnectionInfo,
    ENDPOINT_CONFIG * /*pEndpointConfig*/
    )
{
    SECURITY_STATUS secStatus;

    DBG_ASSERT(_sslState == UC_SSL_STATE_HANDSHAKE_START);

    QueryFiltChannelContext()->SetIsSecure( TRUE );

    DBG_ASSERT(pConnectionInfo->pClientSSLContext);

    // Protocol version
    _SslProtocolVersion = (DWORD)
        pConnectionInfo->pClientSSLContext->SslProtocolVersion;

    if (_SslProtocolVersion == 0)
    {
        // By default, all protocols are enabled.
        _SslProtocolVersion = SP_PROT_CLIENTS;
    }

    // Client Cert
    _pClientCert = (PCCERT_CONTEXT)
        pConnectionInfo->pClientSSLContext->pClientCertContext;

    if (_pClientCert)
    {
        // Bump up the reference count on the certificate context
        _pClientCert = CertDuplicateCertificateContext(_pClientCert);
    }

    // Server cert validation
    switch (pConnectionInfo->pClientSSLContext->ServerCertValidation)
    {
    case HttpSslServerCertValidationIgnore:
    case HttpSslServerCertValidationManual:
    case HttpSslServerCertValidationManualOnce:
        _ValidateServerCertFlag = SCH_CRED_MANUAL_CRED_VALIDATION;
        break;
    case HttpSslServerCertValidationAutomatic:
        _ValidateServerCertFlag = SCH_CRED_AUTO_CRED_VALIDATION;
        break;

    default:
        // Catch this invalid case
        DBG_ASSERT( FALSE );

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );

        break;
    }

    //
    // Store the server name.
    //

    _ServerNameLength = pConnectionInfo->pClientSSLContext->ServerNameLength+1;
 
    if (_ServerNameLength <= UC_SERVER_NAME_BUFFER_SIZE * sizeof(WCHAR))
    {
        _pServerName = _ServerNameBuffer;
    }
    else
    {
        _pServerName = new WCHAR [_ServerNameLength];

        if (!_pServerName)
        {
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    // Copy server name
    memcpy(_pServerName,
           pConnectionInfo->pClientSSLContext->ServerName,
           pConnectionInfo->pClientSSLContext->ServerNameLength);

    // Null termination
    _pServerName[_ServerNameLength] = L'\0';


    //
    // Now create client credential handle
    //
    secStatus = CreateCredentialsHandle(_SslProtocolVersion,
                                        _ValidateServerCertFlag,
                                        _pClientCert,
                                        &_hClientCred);

    if (secStatus != SEC_E_OK)
    {
        DBGPRINTF((DBG_CONTEXT, "CreateCredentialsHandle failed 0x%x\n",
                   secStatus));
        return secStatus;
    }

    _fValidClientCred = TRUE;
        
    DBGPRINTF((DBG_CONTEXT,
          "ProcessNewConnection: Got a new connection for server %ws \n",
           _pServerName)); 

    // Everything was Okay
    return S_OK;
}


/****************************************************************************++

Routine Description:

    Handle an SSL read completion off the wire

Arguments:

    pRawStreamInfo - Points to input stream and size
    pfReadMore - Set to TRUE if we should read more
    pfComplete - Set to TRUE if we should disconnect

Return Value:

    HRESULT

--****************************************************************************/
HRESULT
UC_SSL_STREAM_CONTEXT::ProcessRawReadData(
    RAW_STREAM_INFO *pRawStreamInfo,
    BOOL            *pfReadMore,
    BOOL            *pfComplete
    )
{
    HRESULT hr = S_OK;
    BOOL    fExtraData = FALSE;


    //
    // Loop for extra data 
    // Sometimes one RawStreamInfo buffer may contain multiple blobs 
    // some to be processed by DoHandshake() and some by DoDecrypt()
    // The do-while loop enables switching between these 2 functions as needed
    //

    do
    {
        fExtraData  = FALSE;
        *pfReadMore = FALSE;
        *pfComplete = FALSE;

        //
        // Either continue handshake or immediate decrypt data
        // 

        switch (_sslState)
        {
        case  UC_SSL_STATE_HANDSHAKE_START:
        case  UC_SSL_STATE_HANDSHAKE_IN_PROGRESS:

            DBGPRINTF((DBG_CONTEXT,
                       "ProcessRawReadData (Wire): _sslState %d, Handshake \n",
                       _sslState));

            hr = DoHandshake(pRawStreamInfo,
                             pfReadMore,
                             pfComplete,
                             &fExtraData);
            break;

        case  UC_SSL_STATE_HANDSHAKE_COMPLETE:

            DBGPRINTF((DBG_CONTEXT,
                       "ProcessRawReadData (Wire): _sslState %d, Decrypt \n",
                       _sslState));

            hr = DoDecrypt(pRawStreamInfo,
                           pfReadMore,
                           pfComplete,
                           &fExtraData);
            break;

        default:
            DBG_ASSERT(FALSE);
        }

        if (FAILED(hr))
        {
            DBGPRINTF((DBG_CONTEXT,
                       "ProcessRawReadData (Wire): _sslState %d, failed %x\n",
                       _sslState, hr));
            break;
        }

    //
    // Is there still some extra data to be processed?
    //
    
    } while(fExtraData);

    return hr;
}

    
/****************************************************************************++

Routine Description:

    Called on read completion from app

Arguments:

    pRawStreamInfo - Points to input stream and size
    pfComplete     - Set to TRUE if we should disconnect

Return Value:

    HRESULT

--****************************************************************************/
HRESULT
UC_SSL_STREAM_CONTEXT::ProcessRawWriteData(
    RAW_STREAM_INFO *pRawStreamInfo,
    BOOL            *pfComplete
    )
{
    HRESULT                 hr;

    DBG_ASSERT(QueryFiltChannelContext()->QueryFilterBufferType() == 
               HttpFilterBufferHttpStream);

    DBGPRINTF((DBG_CONTEXT,
          "ProcessRawWriteData (App): _sslState %d, Encrypt \n", _sslState));

    hr = DoEncrypt(pRawStreamInfo,
                   pfComplete);

    if (FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT,
                   "ProcessRawWriteData(App): _sslState %d, failed %x\n",
                   _sslState,hr));
    }

    return hr;
}


HRESULT
UC_SSL_STREAM_CONTEXT::DoHandshakeCompleted()
{
    HRESULT                     hr = S_OK;
    SECURITY_STATUS             secStatus = SEC_E_OK;
    SecPkgContext_StreamSizes   StreamSizes;
    HTTP_FILTER_BUFFER          ulFilterBuffer;


    _sslState = UC_SSL_STATE_HANDSHAKE_COMPLETE;

    DBGPRINTF((DBG_CONTEXT, "DoHandShakeCompleted Enter\n"));

    //
    // Get some buffer size info for this connection.  We only need
    // to do this on completion of the initial handshake, and NOT
    // subsequent renegotiation handshake (if any)
    //

    if (!_cbHeader && !_cbTrailer)
    {
        secStatus = QueryContextAttributes(&_hContext,
                                           SECPKG_ATTR_STREAM_SIZES,
                                           &StreamSizes);
        if (FAILED(secStatus))
        {
            DBGPRINTF((DBG_CONTEXT, "QueryContextAttributes failed! - 0x%x\n",
                       secStatus ));

            return secStatus;
        }

        _cbHeader = StreamSizes.cbHeader;
        _cbTrailer = StreamSizes.cbTrailer;
        _cbBlockSize = StreamSizes.cbBlockSize;
        _cbMaximumMessage = StreamSizes.cbMaximumMessage;
    }

    if (!_fValidServerCertInfo)
    {
        //
        // Build up a message for the application indicating stuff
        // about the negotiated connection
        //

        hr = BuildServerCertInfo(SEC_E_OK, TRUE, FALSE);

        if ( FAILED( hr ) )
        {
            DBGPRINTF((DBG_CONTEXT,
                       "BuildServerCertInfo failed! - 0x%x\n",
                       hr));

            return hr;
        }
    }

    DBG_ASSERT(_fValidServerCertInfo);

    ulFilterBuffer.BufferType = HttpFilterBufferSslServerCert;
    ulFilterBuffer.pBuffer    = (PBYTE) &_ucServerCertInfo;
    ulFilterBuffer.BufferSize = sizeof( _ucServerCertInfo );

    //
    // Write the message to the application
    //

    hr = QueryFiltChannelContext()->DoAppWrite(UL_CONTEXT_FLAG_SYNC,
                                               &ulFilterBuffer,
                                               NULL);

    // No longer have a valid server cert info.
    _fValidServerCertInfo = FALSE;

    return hr;
}


/****************************************************************************++

Routine Description:

    Do the SSL handshake for the client. 

Arguments:

    pRawStreamInfo - Raw data buffer
    pfReadMore     - Set to true if more data should be read
    pfComplete     - Set to true if we should disconnect

Return Value:

    HRESULT

--****************************************************************************/
HRESULT
UC_SSL_STREAM_CONTEXT::DoHandshake(
    RAW_STREAM_INFO *pRawStreamInfo,
    BOOL            *pfReadMore,
    BOOL            *pfComplete,
    BOOL            *pfExtraData
    )
{
    DWORD              dwSSPIFlags;
    DWORD              dwSSPIOutFlags;
    SECURITY_STATUS    scRet   = SEC_E_OK;
    TimeStamp          tsExpiry;
    HRESULT            hr = S_OK;
    HTTP_FILTER_BUFFER ulFilterBuffer;


    *pfReadMore  = FALSE;
    *pfComplete  = FALSE;
    *pfExtraData = FALSE;

    //
    // Setup a call to InitializeSecurityContext
    //

    dwSSPIFlags = UC_SSL_ISC_FLAGS |
        ((_ValidateServerCertFlag == SCH_CRED_MANUAL_CRED_VALIDATION)?
        ISC_REQ_MANUAL_CRED_VALIDATION : 0);

    //
    // First, set up the InBuffers.
    //

    _Buffers[0].pvBuffer    = pRawStreamInfo->pbBuffer + _cbReReadOffset;
    _Buffers[0].BufferType  = SECBUFFER_TOKEN;
    _Buffers[0].cbBuffer    = pRawStreamInfo->cbData   - _cbReReadOffset;

    _Buffers[1].BufferType  = SECBUFFER_EMPTY;
    _Buffers[2].BufferType  = SECBUFFER_EMPTY;
    _Buffers[3].BufferType  = SECBUFFER_EMPTY;

    //
    // Then, the out buffers.
    //
    _OutBuffers[0].pvBuffer   = NULL;
    _OutBuffers[0].cbBuffer   = 0;
    _OutBuffers[0].BufferType = SECBUFFER_EMPTY;

    _OutBuffers[1].BufferType = SECBUFFER_EMPTY;
    _OutBuffers[2].BufferType = SECBUFFER_EMPTY;
    _OutBuffers[3].BufferType = SECBUFFER_EMPTY;


    if (_sslState == UC_SSL_STATE_HANDSHAKE_START)
    {
        scRet = InitializeSecurityContext(
                    &_hClientCred,
                    NULL,
                    _pServerName,
                    dwSSPIFlags,
                    0,
                    SECURITY_NATIVE_DREP,
                    NULL, 
                    0,
                    &_hContext,
                    &_MessageOut,
                    &dwSSPIOutFlags,
                    &tsExpiry
                   );

        DBGPRINTF((DBG_CONTEXT,
              "[DoHandshake]:1st InitializeSecurityContext : Return 0x%x \n",
               scRet));

        if (SUCCEEDED(scRet))
        {
            _cbHeader         = 0;
            _cbTrailer        = 0;
            _cbBlockSize      = 0;
            _cbMaximumMessage = 0;
            _fValidContext    = TRUE;
            _sslState         = UC_SSL_STATE_HANDSHAKE_IN_PROGRESS;
        }
    }
    else
    {
        DBG_ASSERT(_sslState == UC_SSL_STATE_HANDSHAKE_IN_PROGRESS);

        //
        // We have already called InitializeSecurityContext once.
        //

        scRet = InitializeSecurityContext(
                    &_hClientCred,
                    &_hContext,
                    _pServerName,
                    dwSSPIFlags,
                    0,
                    SECURITY_NATIVE_DREP,
                    &_Message,
                    0,
                    &_hContext,
                    &_MessageOut,
                    &dwSSPIOutFlags,
                    &tsExpiry
                    );

        DBGPRINTF((DBG_CONTEXT,
                   "[DoHandshake]:2nd InitializeSecurityContext 0x%x\n",
                   scRet));
    }

    if (SUCCEEDED(scRet))
    {
        //
        // Send response to the server if there is one.
        //

        if (_OutBuffers[0].pvBuffer && _OutBuffers[0].cbBuffer != 0)
        {
            hr = QueryFiltChannelContext()->DoRawWrite(UL_CONTEXT_FLAG_SYNC,
                                                       _OutBuffers[0].pvBuffer,
                                                       _OutBuffers[0].cbBuffer,
                                                       NULL);
            if (FAILED(hr))
            {
                goto ExitPoint;
            }
        }

        if (scRet == SEC_E_OK)
        {
            //
            // Done with handshake.
            //
            hr = DoHandshakeCompleted();

            if (FAILED(hr))
            {
                goto ExitPoint;
            }
        }

        else if (scRet == SEC_I_INCOMPLETE_CREDENTIALS)
        {
            DBGPRINTF((DBG_CONTEXT, "[DoHandshake]:Client cert needed!\n"));

            if (_fRenegotiate)
            {
                //
                // Get issuer list from schannel
                //
                hr = BuildServerCertInfo(SEC_E_OK, TRUE, TRUE);

                if (FAILED(hr))
                {
                    goto ErrorPoint;
                }
            }

            //
            // Caller will resume handshake
            //
            *pfExtraData = TRUE;

            //
            // caller has to detect that some data is
            // still in the buffer not processed and
            //
            hr = S_OK;
            goto ExitPoint;
        }

        //
        // If the input buffer has more info to be SChannelized, then do it 
        // now. If we haven't completed the handshake, call DoHandshake again,
        // else, call DoEncrypt
        //

        if (_Buffers[1].BufferType == SECBUFFER_EXTRA)
        {
            //
            // We better have valid extra data
            // only cbBuffer is used, pvBuffer is not used with SECBUFFER_EXTRA
            //
            DBG_ASSERT( _Buffers[ 1 ].cbBuffer != 0 );

            //
            // Move extra data right after decrypted data (if any)
            //

            memmove( pRawStreamInfo->pbBuffer + _cbDecrypted,
                     pRawStreamInfo->pbBuffer + pRawStreamInfo->cbData
                     - _Buffers[ 1 ].cbBuffer,
                     _Buffers[ 1 ].cbBuffer);

            //
            // Now we have to adjust pRawStreamInfo->cbData and _cbReReadOffset
            //

            pRawStreamInfo->cbData = ( _cbDecrypted + _Buffers[ 1 ].cbBuffer );

            _cbReReadOffset = _cbDecrypted;

            *pfExtraData = TRUE;

            //
            // caller has to detect that some data is
            // still in the buffer not processed and
            //
            hr = S_OK;
            goto ExitPoint;
        }
        else
        {
            //
            // There is no extra data to be processed
            // If we got here as the result of renegotiation
            // there may be some decrypted data in StreamInfo buffer already

            //
            // (without renegotiation _cbDecrypted must always be 0
            // because SEC_I_RENEGOTIATE is the only way to get
            // from DoDecrypt() to DoHandshake() )
            //

            DBG_ASSERT ( _fRenegotiate || _cbDecrypted == 0 );

            pRawStreamInfo->cbData = _cbDecrypted;
            _cbReReadOffset = _cbDecrypted;

            if ( _sslState != UC_SSL_STATE_HANDSHAKE_COMPLETE )
            {
                //
                // If we have no more data, and we still haven't completed the
                // handshake, then read some more data
                //

                *pfReadMore = TRUE;
                hr = S_OK;
                goto ExitPoint;
            }
        }

        //
        // final return from DoHandshake on handshake completion
        // Cleanup _cbDecrypted and _cbReReadOffset to make
        // sure that next ProcessRawReadData() will work fine
        //

        _cbReReadOffset = 0;
        _cbDecrypted = 0;

        hr = S_OK;
        goto ExitPoint;
    }
    else
    {
        //
        //  Does Schannel requires more data?
        //
        if ( scRet == SEC_E_INCOMPLETE_MESSAGE )
        {
            *pfReadMore = TRUE;
            hr = S_OK;
            goto ExitPoint;
        }

        if (dwSSPIOutFlags & ISC_RET_EXTENDED_ERROR)
        {
            if (_OutBuffers[ 0 ].pvBuffer!= NULL &&
                _OutBuffers[ 0 ].cbBuffer != 0 )
            {
                hr = QueryFiltChannelContext()->DoRawWrite(
                         UL_CONTEXT_FLAG_SYNC,
                         _OutBuffers[ 0 ].pvBuffer,
                         _OutBuffers[ 0 ].cbBuffer,
                         NULL);
            }
        }

        //
        //  InitializeSecurityContext failed!
        //
        goto ErrorPoint;
    }





 ErrorPoint:
    {
        //
        // InitializeSecurityContext failed!
        //
        ZeroMemory(&_ucServerCertInfo, sizeof(_ucServerCertInfo));
        _ucServerCertInfo.Status = scRet;

        ulFilterBuffer.BufferType = HttpFilterBufferSslServerCert;
        ulFilterBuffer.pBuffer = (PBYTE) &_ucServerCertInfo;
        ulFilterBuffer.BufferSize = sizeof( _ucServerCertInfo );

        //
        // Write the message to the application
        //

        QueryFiltChannelContext()->DoAppWrite( UL_CONTEXT_FLAG_SYNC,
                                               &ulFilterBuffer,
                                               NULL );

        hr = scRet;
    }

ExitPoint:
    if ( _OutBuffers[ 0 ].pvBuffer != NULL )
    {
        FreeContextBuffer( _OutBuffers[ 0 ].pvBuffer );
        _OutBuffers[ 0 ].pvBuffer = NULL;
    }
    return hr;
}


/****************************************************************************++

Routine Description:

    Encrypt data from the application

Arguments:

    pRawStreamInfo - Raw data buffer
    pfComplete - Set to true if we should disconnect

Return Value:

    HRESULT

--****************************************************************************/
HRESULT
UC_SSL_STREAM_CONTEXT::DoEncrypt(
    RAW_STREAM_INFO *pRawStreamInfo,
    BOOL            *pfComplete
    )
{
    SECURITY_STATUS         secStatus = SEC_E_OK;
    // number of chunks the data to be encrypted will be split to
    DWORD                   dwChunks = 0;
    // current Data chunk size to be encrypted
    DWORD                   cbDataChunk = 0;
    // bytes already encrypted from the source
    DWORD                   cbDataProcessed = 0;
    // offset to _buffRawWrite where new chunk should be placed
    DWORD                   cbRawWriteOffset = 0;


    if ( pRawStreamInfo == NULL || pfComplete == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    *pfComplete = FALSE;

    //
    // Each protocol has limit on maximum size of message 
    // that can be encrypted with one EncryptMessage() call
    //

    DBG_ASSERT( _cbMaximumMessage != 0 );

    //
    // Calculate number of chunks based on _cbMaximumMessage
    //

    dwChunks = pRawStreamInfo->cbData / _cbMaximumMessage;
    if ( pRawStreamInfo->cbData % _cbMaximumMessage != 0 )
    {
        dwChunks++;
    }

    //
    // Allocate a large enough buffer for encrypted data
    // ( remember that each chunk needs header and trailer )
    //
    
    if ( !_buffRawWrite.Resize( pRawStreamInfo->cbData + 
                                dwChunks  * _cbHeader + 
                                dwChunks  * _cbTrailer ) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    //
    // Loop to encrypt required data in chunks each not exceeding
    // _cbMaximumMessage
    //
    
    for( UINT dwCurrentChunk = 0; dwCurrentChunk < dwChunks; dwCurrentChunk++ )
    {
        DBG_ASSERT( _buffRawWrite.QuerySize() > cbRawWriteOffset );
    
        cbDataChunk = min( pRawStreamInfo->cbData - cbDataProcessed, 
                           _cbMaximumMessage ); 


        memcpy( (PBYTE) _buffRawWrite.QueryPtr() + _cbHeader + cbRawWriteOffset,
                pRawStreamInfo->pbBuffer + cbDataProcessed,
                cbDataChunk );
    
        _EncryptBuffers[ 0 ].pvBuffer = (PBYTE) _buffRawWrite.QueryPtr() +
                                        cbRawWriteOffset;
        _EncryptBuffers[ 0 ].cbBuffer = _cbHeader;
        _EncryptBuffers[ 0 ].BufferType = SECBUFFER_STREAM_HEADER;
    
        _EncryptBuffers[ 1 ].pvBuffer = (PBYTE) _buffRawWrite.QueryPtr() +
                                        _cbHeader +
                                        cbRawWriteOffset; 
        _EncryptBuffers[ 1 ].cbBuffer = cbDataChunk;
        _EncryptBuffers[ 1 ].BufferType = SECBUFFER_DATA;
    
        _EncryptBuffers[ 2 ].pvBuffer = (PBYTE) _buffRawWrite.QueryPtr() +
                                        _cbHeader +
                                        cbDataChunk +
                                        cbRawWriteOffset;
        _EncryptBuffers[ 2 ].cbBuffer = _cbTrailer;
        _EncryptBuffers[ 2 ].BufferType = SECBUFFER_STREAM_TRAILER;

        _EncryptBuffers[ 3 ].BufferType = SECBUFFER_EMPTY;

        secStatus = EncryptMessage( &_hContext,
                                 0,
                                 &_EncryptMessage,
                                 0 );

        DBGPRINTF((DBG_CONTEXT,
              "EncryptMessage() secStatus=0x%x\n", secStatus));
    

        if (SUCCEEDED(secStatus))
        {
            //
            // next chunk was successfully encrypted
            //
            
            cbDataProcessed  += cbDataChunk;
            cbRawWriteOffset += _EncryptBuffers[ 0 ].cbBuffer +
                                _EncryptBuffers[ 1 ].cbBuffer +
                                _EncryptBuffers[ 2 ].cbBuffer;
        }
        else
        {
            //
            // Set cbData to 0 just for the case that caller ignored error 
            // and tried to send not encrypted data to client 
            //

            pRawStreamInfo->cbData = 0;

            return secStatus;
        }
    }

    //
    // Replace the raw stream buffer with the encrypted data
    //

    pRawStreamInfo->pbBuffer = (PBYTE) _buffRawWrite.QueryPtr();
    pRawStreamInfo->cbBuffer = _buffRawWrite.QuerySize();
    pRawStreamInfo->cbData   = cbRawWriteOffset;
   
    return S_OK;
}


/****************************************************************************++

Routine Description:

    Decrypt some data

Arguments:

    pRawStreamInfo - Raw data buffer
    pfReadMore - Set to true if we should read more data
    pfComplete - Set to true if we should disconnect

Return Value:

    HRESULT

--****************************************************************************/
HRESULT
UC_SSL_STREAM_CONTEXT::DoDecrypt(
    RAW_STREAM_INFO *pRawStreamInfo,
    BOOL            *pfReadMore,
    BOOL            *pfComplete,
    BOOL            *pfExtraData
    )
{
    SECURITY_STATUS         secStatus = SEC_E_OK;
    INT                     iExtra;

    if ( pRawStreamInfo == NULL ||
         pfReadMore == NULL ||
         pfComplete == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    *pfReadMore  = FALSE;
    *pfComplete  = FALSE;
    *pfExtraData = FALSE;

    DBGPRINTF((DBG_CONTEXT,
           "DoDecrypt(): _cbDecrypted = %d, _cbReReadOffset=%d\n",
           _cbDecrypted, _cbReReadOffset));

    //
    // Setup an DecryptMessage call.  The input buffer is the _buffRaw plus 
    // an offset.  The offset is non-zero if we had to do another read to
    // get more data for a previously incomplete message
    //

    DBG_ASSERT( pRawStreamInfo->cbData > _cbReReadOffset );

    _Buffers[ 0 ].pvBuffer = pRawStreamInfo->pbBuffer + _cbReReadOffset;
    _Buffers[ 0 ].cbBuffer = pRawStreamInfo->cbData - _cbReReadOffset;
    _Buffers[ 0 ].BufferType = SECBUFFER_DATA;
    
    _Buffers[ 1 ].BufferType = SECBUFFER_EMPTY;
    _Buffers[ 2 ].BufferType = SECBUFFER_EMPTY;
    _Buffers[ 3 ].BufferType = SECBUFFER_EMPTY;

DecryptAgain:

    secStatus = DecryptMessage( &_hContext,
                               &_Message,
                               0,
                               NULL );
    DBGPRINTF((DBG_CONTEXT,
            "DecryptMessage( bytes:%d) secStatus=0x%x\n",
             pRawStreamInfo->cbData - _cbReReadOffset,
             secStatus
             ));

    if ( FAILED( secStatus ) )
    {
        if ( secStatus == SEC_E_INCOMPLETE_MESSAGE )
        {
            //
            // Setup another read since the message is incomplete.  Remember
            // where the new data is going to since we only pass this data
            // to the next DecryptMessage call
            //
            
            _cbReReadOffset = (DWORD) DIFF( (BYTE *)_Buffers[ 0 ].pvBuffer -
                                    pRawStreamInfo->pbBuffer );

            QueryFiltChannelContext()->SetNextRawReadSize( _Buffers[ 1 ].cbBuffer );
            
            *pfReadMore = TRUE;
            
            return S_OK; 
        }                

        return secStatus;
    }

    if (secStatus != SEC_E_OK &&
        secStatus != SEC_I_RENEGOTIATE)
    {
        return secStatus;
    }

    if ( secStatus == SEC_E_OK )
    {
        DBG_ASSERT( _Buffers[ 1 ].BufferType == SECBUFFER_DATA );

        //
        // Take decrypted data and fit it into read buffer
        //
        memmove( pRawStreamInfo->pbBuffer + _cbDecrypted,
                 _Buffers[ 1 ].pvBuffer,
                 _Buffers[ 1 ].cbBuffer );

        _cbDecrypted += _Buffers[ 1 ].cbBuffer;
    }

    //
    // Locate extra data (may be available)
    //
    
    iExtra = 0;
    for ( int i = 1; i < 4; i++ )
    {     
        if ( _Buffers[ i ].BufferType == SECBUFFER_EXTRA )
        {
            iExtra = i;
            break;
        }
    }
    
    if ( iExtra != 0 )
    {
        //
        // process extra buffer
        //
        
        _cbReReadOffset = (DWORD) DIFF( (PBYTE) _Buffers[ iExtra ].pvBuffer - 
                                pRawStreamInfo->pbBuffer );
        
        if ( secStatus != SEC_I_RENEGOTIATE )
        {
            _Buffers[ 0 ].pvBuffer = _Buffers[ iExtra ].pvBuffer;
            _Buffers[ 0 ].cbBuffer = _Buffers[ iExtra ].cbBuffer;
            _Buffers[ 0 ].BufferType = SECBUFFER_DATA;
            _Buffers[ 1 ].BufferType = SECBUFFER_EMPTY;
            _Buffers[ 2 ].BufferType = SECBUFFER_EMPTY;
            _Buffers[ 3 ].BufferType = SECBUFFER_EMPTY;

            goto DecryptAgain;
        }
    }


    if ( secStatus == SEC_I_RENEGOTIATE )
    {
        //
        // If a renegotiation is triggered, resume the handshake state
        //

        _fRenegotiate = TRUE;

        _sslState = UC_SSL_STATE_HANDSHAKE_IN_PROGRESS;
    
        //
        // Caller has to detect that some data is
        // still in the buffer not processed and
        // That will signal to call DoHandshake() 
        // for that extra data
        //

        *pfExtraData = TRUE;
        return S_OK;
    }

    //
    // there would have been extra data with SEC_I_RENEGOTIATE
    // so we must never get here when renegotiating
    //
    DBG_ASSERT( secStatus != SEC_I_RENEGOTIATE );

    //
    // Adjust cbData to include only decrypted data
    //
    pRawStreamInfo->cbData = _cbDecrypted;

    //
    // We have final decrypted buffer and no extra data left
    // Cleanup _cbDecrypted and _cbReReadOffset to make sure that 
    // next ProcessRawReadData() will work fine.    
    //
    
    _cbDecrypted = 0;
    _cbReReadOffset = 0;

    return S_OK;
}


/****************************************************************************++

Routine Description:

    Initialize SSL 

Arguments:

    None

Return Value:

    HRESULT

--****************************************************************************/
//static
HRESULT
UC_SSL_STREAM_CONTEXT::Initialize(
    VOID
    )
{
    return S_OK;
}


/****************************************************************************++

Routine Description:

    Terminate SSL 

Arguments:

    None

Return Value:

    None

--****************************************************************************/
//static
VOID
UC_SSL_STREAM_CONTEXT::Terminate(
    VOID
    )
{
}


/*++

Routine Description:

    Build UL_SSL_INFO structure given Schannel context handle

Arguments:

    None

Return Value:

    HRESULT

--*/
HRESULT
UC_SSL_STREAM_CONTEXT::BuildServerCertInfo(
    SECURITY_STATUS InfoStatus,
    BOOL            fServerCert,
    BOOL            fIssuerList
    )
{
    SECURITY_STATUS         secStatus;


    DBG_ASSERT(_fValidServerCertInfo == FALSE);

    if (fServerCert)
    {
        secStatus = GetServerCert();

        if (FAILED(secStatus))
        {
            DBGPRINTF((DBG_CONTEXT, "Failed GetServerCert 0x%x\n", secStatus));
            return secStatus;
        }
    }

    // Is issuer list required?
    if (fIssuerList)
    {
        secStatus = GetIssuerList();

        if (FAILED(secStatus))
        {
            DBGPRINTF((DBG_CONTEXT, "Failed GetIssuerList 0x%x\n", secStatus));
            return secStatus;
        }
    }

    //
    // Build Server cert Info
    //
    ZeroMemory(&_ucServerCertInfo, sizeof(_ucServerCertInfo));

    // Issuer list required?
    if (fIssuerList)
    {
        _ucServerCertInfo.IssuerInfo.IssuerCount = _IssuerListInfo.cIssuers;
        _ucServerCertInfo.IssuerInfo.pIssuerList = _IssuerListInfo.aIssuers;

        _ucServerCertInfo.IssuerInfo.IssuerListLength  =
            _IssuerListInfo.aIssuers[_IssuerListInfo.cIssuers-1].pbData -
            (PBYTE)_IssuerListInfo.aIssuers +
            _IssuerListInfo.aIssuers[_IssuerListInfo.cIssuers-1].cbData;

    }
    else
    {
        _ucServerCertInfo.IssuerInfo.IssuerListLength = 0;
        _ucServerCertInfo.IssuerInfo.IssuerCount      = 0;
        _ucServerCertInfo.IssuerInfo.pIssuerList      = 0;
    }

    if (fServerCert)
    {
        BuildServerCert();
    }

    // Ssl handshake was completed
    _ucServerCertInfo.Status = InfoStatus;

    // We now have a valid server cert info
    _fValidServerCertInfo = TRUE;

    return S_OK;
}


HRESULT
UC_SSL_STREAM_CONTEXT::GetServerCert(
    VOID
    )
{
    SECURITY_STATUS secStatus;
    PUCHAR          pbCertContext;
    DWORD           cbCertContext;
    CRYPT_DATA_BLOB CertStoreData;


    // Free server cert before getting a new server cert
    if (_pServerCert != NULL)
    {
        CertFreeCertificateContext(_pServerCert);
        _pServerCert = NULL;
    }

    // Free serialized cert
    if (_pSerializedCert)
    {
        delete[] _pSerializedCert;
        _pSerializedCert = NULL;
        _SerializedCertLength = 0;
    }

    // Free serialized store
    if (_pSerializedStore)
    {
        delete[] _pSerializedStore;
        _pSerializedStore = NULL;
        _SerializedStoreLength = 0;
    }

    // Retrieve the server certificate
    secStatus = QueryContextAttributes(&_hContext,
                                       SECPKG_ATTR_REMOTE_CERT_CONTEXT,
                                       (PVOID)&_pServerCert);

    if (!SUCCEEDED(secStatus))
    {
        DBGPRINTF((DBG_CONTEXT,
                   "Error 0x%x querying server certificate\n",
                   secStatus));

        return secStatus;
    }

    //
    // Serialize Server Certificate
    //

    pbCertContext = NULL;
    cbCertContext = 0;

    // First find the length of serialized cert
    if (!CertSerializeCertificateStoreElement(_pServerCert,
                                              0,
                                              NULL,
                                              &cbCertContext))
    {
        secStatus = GetLastError();

        DBGPRINTF((DBG_CONTEXT,
                   "Error 0x%x serialize cert store element\n",
                   secStatus));

        return secStatus;
    }

    // Allocate memory for serialized cert
    pbCertContext = new UCHAR[cbCertContext];

    if (!pbCertContext)
    {
        DBGPRINTF((DBG_CONTEXT, "Error allocating memory for cert context\n"));
        return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    // Now get the serialized cert
    if (!CertSerializeCertificateStoreElement(_pServerCert,
                                              0,
                                              pbCertContext,
                                              &cbCertContext))
    {
        secStatus = GetLastError();

        DBGPRINTF((DBG_CONTEXT,
                   "Error 0x%x serialize cert store element\n",
                   secStatus));

        return secStatus;
    }

    // Store away the serialized cert
    _pSerializedCert      = pbCertContext;
    _SerializedCertLength = cbCertContext;

    //
    // Serialize Server Certificate's store
    //

    CertStoreData.pbData = NULL;
    CertStoreData.cbData = 0;

    if (_pServerCert->hCertStore)
    {
        // Find the length of serialized store
        if (!CertSaveStore(_pServerCert->hCertStore,
                           X509_ASN_ENCODING,
                           CERT_STORE_SAVE_AS_STORE,
                           CERT_STORE_SAVE_TO_MEMORY,
                           (PVOID)&CertStoreData,
                           0))
        {
            secStatus = GetLastError();

            DBGPRINTF((DBG_CONTEXT, "CertSaveStore failed 0x%x\n", secStatus));

            return secStatus;
        }

        // Allocate memory for serialized store
        CertStoreData.pbData = new UCHAR[CertStoreData.cbData];

        if (!CertStoreData.pbData)
        {
            DBGPRINTF((DBG_CONTEXT, "Error allocating memory cert store\n"));

            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }

        // Now get the serialized store
        if (!CertSaveStore(_pServerCert->hCertStore,
                           X509_ASN_ENCODING,
                           CERT_STORE_SAVE_AS_STORE,
                           CERT_STORE_SAVE_TO_MEMORY,
                           (PVOID)&CertStoreData,
                           0))
        {
            secStatus = GetLastError();

            DBGPRINTF((DBG_CONTEXT, "CertSaveStore failed 0x%x\n", secStatus));

            return secStatus;
        }

        _pSerializedStore = CertStoreData.pbData;
        _SerializedStoreLength = CertStoreData.cbData;
    }

    return S_OK;
}


HRESULT
UC_SSL_STREAM_CONTEXT::GetIssuerList(
    VOID
    )
{
    SECURITY_STATUS secStatus;

    // If there is a previous issuer list, free it now
    if (_IssuerListInfo.aIssuers)
    {
        DBG_ASSERT(_IssuerListInfo.cIssuers);

        FreeContextBuffer(_IssuerListInfo.aIssuers);

        ZeroMemory(&_IssuerListInfo, sizeof(_IssuerListInfo));
    }

    // Get Issuer list from schannel
    secStatus = QueryContextAttributes(&_hContext,
                                       SECPKG_ATTR_ISSUER_LIST_EX,
                                       (PVOID)&_IssuerListInfo);
    if (secStatus != SEC_E_OK)
    {
        DBGPRINTF((DBG_CONTEXT,
                   "Error 0x%x querying issuer list info\n", secStatus));
    }

    return secStatus;
}


HRESULT
UC_SSL_STREAM_CONTEXT::BuildServerCert(
    VOID
    )
{
    SECURITY_STATUS secStatus = SEC_E_OK;
    DWORD           CertHashLength;


    DBG_ASSERT(_pServerCert);

    //
    // Server certificate
    //
    //_ucServerCertInfo.Cert.pCertContext = (PVOID)_pServerCert;

    //
    // Get server certificate hash
    //

    CertHashLength = sizeof(_ucServerCertInfo.Cert.CertHash);

    // Certificate hash
    if (!CertGetCertificateContextProperty(_pServerCert,
                                           CERT_SHA1_HASH_PROP_ID,
                                           _ucServerCertInfo.Cert.CertHash,
                                           &CertHashLength))
    {
        secStatus = GetLastError();

        DBGPRINTF((DBG_CONTEXT,
                   "Error 0x%x getting server certificate hash\n",
                   secStatus));

        return secStatus;
    }

    DBG_ASSERT(CertHashLength <= sizeof(_ucServerCertInfo.Cert.CertHash));

    // Server certificate hash length
    _ucServerCertInfo.Cert.CertHashLength = CertHashLength;

    // Serialized server cert
    _ucServerCertInfo.Cert.pSerializedCert      = _pSerializedCert;
    _ucServerCertInfo.Cert.SerializedCertLength = _SerializedCertLength;

    DBGPRINTF((DBG_CONTEXT, "Cert 0x%x, Length 0x%x\n",
               _pSerializedCert,
               _SerializedCertLength));

    // Serialized cert store
    _ucServerCertInfo.Cert.pSerializedCertStore      = _pSerializedStore;
    _ucServerCertInfo.Cert.SerializedCertStoreLength = _SerializedStoreLength;

    DBGPRINTF((DBG_CONTEXT, "Store 0x%x, Length 0x%x\n",
               _pSerializedStore,
               _SerializedStoreLength));

    return S_OK;
}


/****************************************************************************++

Routine Description:

    Calls AcquireCredentialsHandle & returns the handle to the caller. 

Arguments:

    dwProtocolType - Supported protocol types by SSPI.
                     (SP_PROT_SSL2_CLIENT, SP_PROT_SSL3_CLIENT,
                      SP_PROT_TLS1_CLIENT, etc)
    dwFlags        - Additional flags that are passed to
                     AcquireCredentialsHandle
    pCertContext   - Client certificate, if any

    phClientCred   - client credentials handle (returned)

Return Value:

    SECURITY_STATUS

--****************************************************************************/
SECURITY_STATUS
CreateCredentialsHandle(
    IN  DWORD          dwProtocolType,
    IN  DWORD          dwFlags,
    IN  PCCERT_CONTEXT pCertContext,
    OUT PCredHandle    phClientCred
    )
{
    SCHANNEL_CRED   SChannelCred;
    SECURITY_STATUS Status;
    TimeStamp       tsExpiry;

    ZeroMemory(&SChannelCred, sizeof(SCHANNEL_CRED));

    SChannelCred.dwVersion = SCHANNEL_CRED_VERSION;

    if (pCertContext)
    {
        SChannelCred.paCred = &pCertContext;
        SChannelCred.cCreds = 1;
    }

    SChannelCred.grbitEnabledProtocols  = dwProtocolType;

#if 0

    //
    // This is used to pick RSA over DH, I don't think we need this for 
    // HTTP client (IE does not use this)
    //

    if (aiKeyExch)
    {
        rgbSupportedAlgs[cSupportedAlgs++] = aiKeyExch;
    }

    if (cSupportedAlgs)
    {
        SChannelCred.cSupportedAlgs    = cSupportedAlgs;
        SChannelCred.palgSupportedAlgs = rgbSupportedAlgs;
    }
#endif

    SChannelCred.dwFlags |= SCH_CRED_NO_DEFAULT_CREDS;

    // dwFlags can be either
    //    SCH_CRED_MANUAL_CRED_VALIDATION   or
    //    SCH_CRED_AUTO_CRED_VALIDATION 
    //
    SChannelCred.dwFlags |= dwFlags;

    //
    // Create an SSPI handle.
    //

    Status = AcquireCredentialsHandle(
                NULL,                 // name of principal
                UNISP_NAME,           // Name of package
                SECPKG_CRED_OUTBOUND, // Flags indicating use 
                NULL,                 // LogonID
                &SChannelCred,        // Package specific data
                NULL,                 // GetKey() function
                NULL,                 // GetKey context
                phClientCred,         // (out) Cred handle
                &tsExpiry             // (out) lifetime
                );

    if (Status != SEC_E_OK)
    {
        DBGPRINTF((DBG_CONTEXT,
                   "AcquireCredentialsHandle failed with 0x%x \n",
                   Status));
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\sfwp\dll\siteconfig.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     siteconfig.cxx

   Abstract:
     SSL configuration for a given site
 
   Author:
     Bilal Alam         (BAlam)         29-March-2000

   Environment:
     Win32 - User Mode

   Project:
     Stream Filter Worker Process
--*/

#include "precomp.hxx"

ENDPOINT_CONFIG_HASH *       ENDPOINT_CONFIG::sm_pEndpointConfigHash;
ENDPOINT_CONFIG::INIT_STATE  ENDPOINT_CONFIG::sm_InitState = INIT_NONE;
HANDLE                       ENDPOINT_CONFIG::sm_hHttpApiConfigChangeEvent = NULL;
HKEY                         ENDPOINT_CONFIG::sm_hHttpApiConfigKey = NULL;
HANDLE                       ENDPOINT_CONFIG::sm_hWaitHandle = NULL;



//static
HRESULT
ENDPOINT_CONFIG::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize site configuration globals

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HRESULT hr = E_FAIL;
    DWORD   dwError = NO_ERROR;
    HTTPAPI_VERSION HttpApiVersion = HTTPAPI_VERSION_1;

    //
    // Initialize HttpApi to be able to retrieve SSL config
    //
    dwError = HttpInitialize( HttpApiVersion, HTTP_INITIALIZE_CONFIG, NULL );

    if ( dwError != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( dwError );
        goto Failed;
    }

    sm_InitState = INIT_HTTPAPI;
    
    sm_pEndpointConfigHash = new ENDPOINT_CONFIG_HASH();
    if ( sm_pEndpointConfigHash == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto Failed;
    }
    sm_InitState = INIT_HASH;

    //
    // Create event for HttpApi config store change notifications
    //
    
    sm_hHttpApiConfigChangeEvent = CreateEvent( NULL,   // SD
                                                FALSE,  // fManualReset
                                                FALSE,  //fInitialState
                                                NULL ); // name*/
    if( sm_hHttpApiConfigChangeEvent == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );

        DBGPRINTF(( DBG_CONTEXT,
                    "CreateEvent() failed. hr = 0x%x\n", 
                    hr ));

        goto Failed;
    }

    dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            L"System\\CurrentControlSet\\Services\\HTTP\\Parameters\\SslBindingInfo",
                            0,
                            KEY_READ,
                            &sm_hHttpApiConfigKey );
    if ( dwError != ERROR_SUCCESS )
    {
        // backup plan
        // if SslBindingInfo doesn't extst yet, simply listen on
        // parent node. HTTP\Parameters is guaranteed to exist on valid install
        //
        dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            L"System\\CurrentControlSet\\Services\\HTTP\\Parameters",
                            0,
                            KEY_READ,
                            &sm_hHttpApiConfigKey );
        if ( dwError != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( dwError );
            DBGPRINTF(( DBG_CONTEXT,
                        "Failed to open registry. hr = 0x%x\n", 
                        hr ));

            CloseHandle( sm_hHttpApiConfigChangeEvent );
            sm_hHttpApiConfigChangeEvent = NULL;
            goto Failed;
        }
    }    
    DBG_ASSERT( sm_hHttpApiConfigKey != NULL );
    
   
    //
    // Watch the registry key for a change 
    //


    dwError = RegNotifyChangeKeyValue( sm_hHttpApiConfigKey, 
                                       TRUE, 
                                       REG_NOTIFY_CHANGE_LAST_SET | 
                                       REG_NOTIFY_CHANGE_NAME, 
                                       sm_hHttpApiConfigChangeEvent, 
                                       TRUE );

    if( dwError != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dwError );

        RegCloseKey( sm_hHttpApiConfigKey );
        sm_hHttpApiConfigKey = NULL;
        CloseHandle( sm_hHttpApiConfigChangeEvent );
        sm_hHttpApiConfigChangeEvent = NULL;

        DBGPRINTF(( DBG_CONTEXT,
                    "RegNotifyChangeKeyValue failed. hr = 0x%x\n", 
                    hr ));

        goto Failed;
    }

    //
    // Register a callback function to wait on the event
    //
   
    
    if( !RegisterWaitForSingleObject( 
           &sm_hWaitHandle,
           sm_hHttpApiConfigChangeEvent,
           ( WAITORTIMERCALLBACK )ENDPOINT_CONFIG::ConfigStoreChangeCallback,
           NULL,
           INFINITE,
           WT_EXECUTEDEFAULT ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        
        RegCloseKey( sm_hHttpApiConfigKey );
        sm_hHttpApiConfigKey = NULL;
        CloseHandle( sm_hHttpApiConfigChangeEvent );
        sm_hHttpApiConfigChangeEvent = NULL;

        DBGPRINTF(( DBG_CONTEXT,
                    "RegisterWaitForSingleObject failed. hr = 0x%x\n", 
                    hr ));

        goto Failed;
    }
    sm_InitState = INIT_CHANGE_NOTIF;
    return NO_ERROR;

Failed:
    Terminate();
    return hr;
}

//static
VOID
ENDPOINT_CONFIG::Terminate(
    VOID
)
/*++

Routine Description:

    Cleanup site configuration globals

Arguments:

    None

Return Value:

    None

--*/
{
    switch( sm_InitState )
    {
    case INIT_CHANGE_NOTIF:


        if ( sm_hWaitHandle != NULL )
        {
            UnregisterWaitEx( sm_hWaitHandle,
                              INVALID_HANDLE_VALUE );
            sm_hWaitHandle = NULL;
        }

        //
        // NOTE:
        // registry key must be closed before event is destroyed
        // because closing handle will assure that sm_hHttpApiConfigChangeEvent event 
        // will not be used any more
        //
        
        if ( sm_hHttpApiConfigKey != NULL )
        {
            CloseHandle( sm_hHttpApiConfigKey );
            sm_hHttpApiConfigKey = NULL;
        }
        
        if ( sm_hHttpApiConfigChangeEvent != NULL )
        {
            CloseHandle( sm_hHttpApiConfigChangeEvent );
            sm_hHttpApiConfigChangeEvent = NULL;
        }
    case INIT_HASH:
        if ( sm_pEndpointConfigHash != NULL )
        {
            //
            // Clear hash table before deleting it
            //
            sm_pEndpointConfigHash->Clear();
            delete sm_pEndpointConfigHash;
            sm_pEndpointConfigHash = NULL;
        }
    case INIT_HTTPAPI:
        HttpTerminate( HTTP_INITIALIZE_CONFIG, NULL );
    case INIT_NONE:
        break;
    }
}


//private
//static
HRESULT
ENDPOINT_CONFIG::GetEndpointConfigData(
    IN  DWORD                           LocalAddress,
    IN  USHORT                          LocalPort,
    OUT PHTTP_SERVICE_CONFIG_SSL_SET *  ppEndpointConfigData,
    OUT BOOL *                          pfWildcardMatch
)
/*++

Routine Description:

    lookup SSL configuration

Arguments:

    LocalAddress - IP address in network order
    LocalPort - Port in network order
    ppEndpointConfigData - allocated within this function - delete[] must be used to free it
    pfWildcardMatch - was wildcard IP address match used?
)


Return Value:

    HRESULT

--*/

{
    DWORD                          dwError;
    DWORD                          ReturnLength = 0;
    HTTP_SERVICE_CONFIG_SSL_QUERY  QueryParam;
    PHTTP_SERVICE_CONFIG_SSL_SET   pSetParam = NULL;
    HRESULT                        hr = NO_ERROR;
    SOCKADDR_IN                    SockAddr;


    if ( ppEndpointConfigData == NULL ||
         pfWildcardMatch == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    ZeroMemory( &SockAddr, sizeof(SockAddr) );
    ZeroMemory( &QueryParam, sizeof(QueryParam) );

    *pfWildcardMatch = FALSE;

    QueryParam.QueryDesc = HttpServiceConfigQueryExact;

    //
    // build sock addr for HTTPAPI lookup
    //
    
    SockAddr.sin_family = AF_INET;
    SockAddr.sin_port = LocalPort;
    SockAddr.sin_addr.s_addr = LocalAddress;

    QueryParam.KeyDesc.pIpPort = (PSOCKADDR) &SockAddr;

    // Loop - check nonwildcard info first, if it fails then try wildcard
    //

    for(;;) 
    {
    
        dwError = HttpQueryServiceConfiguration(
                                NULL,
                                HttpServiceConfigSSLCertInfo,
                                &QueryParam,
                                sizeof(QueryParam),
                                NULL,
                                0,
                                &ReturnLength,
                                NULL
                                );

        if ( dwError == ERROR_INSUFFICIENT_BUFFER )
        {
            pSetParam = (PHTTP_SERVICE_CONFIG_SSL_SET) new BYTE[ReturnLength];

            if ( pSetParam == NULL )
            {
                hr = HRESULT_FROM_WIN32( ERROR_OUTOFMEMORY );
                goto Finished;
            }
            
            dwError = HttpQueryServiceConfiguration(
                            NULL,
                            HttpServiceConfigSSLCertInfo,
                            &QueryParam,
                            sizeof(QueryParam),
                            pSetParam,
                            ReturnLength,
                            &ReturnLength,
                            NULL
                            );
            //
            // It is possible that the size returned on the first call may
            // have changed between first and second call.
            // It would be caused by configuration change. 
            // Probability of it happening is very low.
            // If it happens then one connection attempt will fail and it is
            // acceptable
            //
        }

        // If not found (and other error will mean end of trying)
        // or if wildcard lookup already executed
        // then leave the loop
        //
        if ( dwError != ERROR_FILE_NOT_FOUND || SockAddr.sin_addr.s_addr == INADDR_ANY )
        {
            break;
        }
        else
        {
            //
            // continue loop for wildcard lookup
            //
            SockAddr.sin_addr.s_addr = INADDR_ANY;
        }
        
    }

    
    if ( dwError != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( dwError );
        goto Finished;
    }
    
    if ( SockAddr.sin_addr.s_addr == INADDR_ANY )
    {
        *pfWildcardMatch = TRUE;
    }

    *ppEndpointConfigData = pSetParam;

    hr = S_OK;
   
Finished:
    
    return hr;
}





//static
HRESULT
ENDPOINT_CONFIG::GetEndpointConfig(
    CONNECTION_INFO *       pConnectionInfo,
    ENDPOINT_CONFIG **      ppEndpointConfig,
    BOOL                    fCreateEmptyIfNotFound 
)
/*++

Routine Description:

    Lookup site configuration in hash table.  If not there then create it
    and add it to table

Arguments:

    dwSiteId - Site ID to lookup
    ppEndpointConfig - Filled with pointer to site config on success
    fCreateEmptyIfNotFound - if endpoint config was not located 
                             in the persistent store, create empty
                             endpoint config and stick it to cache
                             That will optimize lookup for EnableRawFilter
                             checks

Return Value:

    HRESULT
    HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ) when endpoint config not found

--*/
{
    LK_RETCODE                      lkrc; 
    ENDPOINT_CONFIG *               pEndpointConfig = NULL;
    SERVER_CERT *                   pServerCert = NULL;
    IIS_CTL *                       pIisCtl     = NULL;
    HRESULT                         hr = NO_ERROR;
    STACK_STRU(                     strMBPath, 64 );
    DWORD                           LocalAddress = 0;
    USHORT                          LocalPort = 0;
    BOOL                            fWildcardMatch = FALSE;
    PHTTP_SERVICE_CONFIG_SSL_SET    pEndpointConfigData = NULL;
    
    if ( ppEndpointConfig == NULL ||
         pConnectionInfo == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    *ppEndpointConfig = NULL;

    //
    // Figure out Ip Address and Port
    //
    
    //
    // Pass Port and IP address in network order
    // (HTTP service will return them in network order so no changes are needed)
    //
    
    if( pConnectionInfo->LocalAddressType == TDI_ADDRESS_TYPE_IP )
    {
        LocalAddress = pConnectionInfo->SockLocalAddress.ipv4SockAddress.sin_addr.s_addr;
        LocalPort = pConnectionInfo->SockLocalAddress.ipv4SockAddress.sin_port;
    }
    else if ( pConnectionInfo->LocalAddressType == TDI_ADDRESS_TYPE_IP6 )
    {
        //
        // IPv6 connections will be able to handle SSL connections only
        // in the case when all IP addresses on the machine are configured to
        // listen on secure port (IPv4 wildcard binding must be configured).
        // CODEWORK: Once in the future there may be a need to implement
        // for IPv6 support.
        //
        LocalAddress = INADDR_ANY;  // Wildcard IP
        LocalPort = pConnectionInfo->SockLocalAddress.ipv6SockAddress.sin6_port;
    }
    else
    {
        //
        // We support only IPv4 and IPv6. Any other value means error
        //
        DBG_ASSERT( FALSE );
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        goto ExitPoint;

    }
    
    //
    // First lookup in the cache
    // Because we don't preread all the endpoint configuration stored in HttpAPI Config
    // store in out hash table, it is not straightforward to handle wildcard endpoint
    // configuration
    // If endpoint configuration lookup returned data based on wildcard endpoint config
    // we will still store it in the hash table for the specific endpoint we looked up
    // Otherwise there is is risk that wildcard endpoint config stored in the hash table
    // could override individual endpoint settings that exist in the HttpAPI config store
    // but were not yet read and stored in our hash table
    //
    
    DBG_ASSERT( sm_pEndpointConfigHash != NULL );

    ENDPOINT_KEY EndpointKey = GenerateEndpointKey( LocalAddress, LocalPort );
    
    lkrc = sm_pEndpointConfigHash->FindKey( 
                                    &EndpointKey,
                                    &pEndpointConfig );
    if ( lkrc == LK_SUCCESS )
    {
        DBG_ASSERT( pEndpointConfig != NULL );
        *ppEndpointConfig = pEndpointConfig;
        hr = S_OK;
        goto ExitPoint;
    }

    //
    // Ok, nothing cached.  We will have to make a lookup in the persistent store
    //

       
    //
    // Try to lookup config info through HTTPAPI
    // fWildcardMatch is currently ignored we will store retrieved config data
    // for the specific endpoint
    //
    hr = GetEndpointConfigData(      
                LocalAddress,
                LocalPort,
                &pEndpointConfigData,
                &fWildcardMatch );

   
    if ( hr == HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ) && fCreateEmptyIfNotFound )
    {
         // 
         // Create empty endpoint info 
         // This will optimize the EnableRawFilter lookups
         // because without cached entry for each new raw Filter connection
         // we would need to make HttpApi config lookup
         // (empty endpoint indicates that it is OK to do Raw Filter handling)
         // 

         pEndpointConfigData = NULL;
         
         pEndpointConfig = new ENDPOINT_CONFIG( LocalAddress, 
                                           LocalPort,
                                           NULL, // no Server Cert info
                                           NULL, // No Ctl info
                                           pEndpointConfigData );
        if ( pEndpointConfig == NULL )
        {
            hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
            goto ExitPoint;
        }
        else
        {
            // ENDPOINT_CONFIG took ownership of pEndpointConfigData
            pEndpointConfigData = NULL;
        }
    }
    else if ( FAILED( hr ) )
    {
       //
       // Not finding the site just means this is not an SSL site
       //

       goto ExitPoint;
    }
    else if ( pEndpointConfigData != NULL && 
              pEndpointConfigData->ParamDesc.SslHashLength == 0 ) 
    {
        //
        // Store endpoint config for nonsecure Endpoint
        // to flag if Raw Filters are enabled or disabled
        //
        
        pEndpointConfig = new ENDPOINT_CONFIG(  LocalAddress, 
                                                LocalPort,
                                                NULL,
                                                NULL,
                                                pEndpointConfigData );
        if ( pEndpointConfig == NULL )
        {
            hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
            goto ExitPoint;
        }
        else
        {
            // ENDPOINT_CONFIG took ownership of pEndpointConfigData
            pEndpointConfigData = NULL;
        }
    }
    else
    {
        //
        // To get this far means that we expect correct SSL endpoint info
        // to be available
        //
        
        //
        // We have enough to lookup in SERVER_CERT cache
        //
        
        hr = SERVER_CERT::GetServerCertificate( (PBYTE) pEndpointConfigData->ParamDesc.pSslHash,
                                                pEndpointConfigData->ParamDesc.SslHashLength,
                                                pEndpointConfigData->ParamDesc.pSslCertStoreName,
                                                &pServerCert );
        if ( FAILED( hr ) )
        {
            //
            // If we couldn't get a server cert,  SSL will
            // not be enablable for this site 
            //
            
            goto ExitPoint;
        }
        
        DBG_ASSERT( pServerCert != NULL );
        

        hr = IIS_CTL::GetIisCtl( pEndpointConfigData->ParamDesc.pDefaultSslCtlIdentifier,
                                 pEndpointConfigData->ParamDesc.pDefaultSslCtlStoreName,
                                 &pIisCtl );
        //
        // if CTL context creation failed, we must not fail site config creation
        // because CTLs are not mandatory for all scenarios (only client certificate
        // scenarios require them, so we have to make sure that those would be failing )
        //
        if ( FAILED( hr ) )
        {
            pIisCtl = NULL;
            //
            // BUGBUG: Error loading CTL should be logged into event log
            //
            hr = S_OK;
        }
        
      
        //
        // OK.  Create the config and attempt to add it to the cache
        //

        pEndpointConfig = new ENDPOINT_CONFIG( ( LocalAddress ), 
                                                 LocalPort,
                                                 pServerCert,
                                                 pIisCtl,
                                                 pEndpointConfigData );
        
        if ( pEndpointConfig == NULL )
        {
            if ( pServerCert != NULL )
            {
                pServerCert->DereferenceServerCert();
                pServerCert = NULL;
            }
            if ( pIisCtl != NULL )
            {
                pIisCtl->DereferenceIisCtl();
                pIisCtl = NULL;
            }
            hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
            goto ExitPoint;
        }
        else
        {
            // ENDPOINT_CONFIG took ownership of pEndpointConfigData
            pEndpointConfigData = NULL;
        }
        
        //
        // Acquire credentials
        //
        
        hr = pEndpointConfig->AcquireCredentials();
        if ( FAILED( hr ) )
        {
            delete pEndpointConfig;
            pEndpointConfig = NULL;
            goto ExitPoint;
        }
    }    
    //
    // We don't care what the success of the insertion was.  If it failed,
    // then the pEndpointConfig will not be extra referenced and the caller
    // will clean it up when it derefs
    //
     
    sm_pEndpointConfigHash->InsertRecord( pEndpointConfig ); 
    
    *ppEndpointConfig = pEndpointConfig;
    hr = S_OK;
    
ExitPoint:
    if ( pEndpointConfigData != NULL )
    {
        delete [] pEndpointConfigData;
        pEndpointConfigData = NULL;
    }
    
    return hr;
}

//static
LK_PREDICATE
ENDPOINT_CONFIG::ServerCertPredicate(
    ENDPOINT_CONFIG *       pEndpointConfig,
    void *                  pvState
)
/*++

  Description:

    DeleteIf() predicate used to find items which reference the 
    SERVER_CERT pointed to by pvState    

  Arguments:

    pEndpointConfig - SSL endpoint config 
    pvState - SERVER_CERT to check for

  Returns:

    LK_PREDICATE   - LKP_PERFORM indicates removing the current 
                                 token from token cache

                     LKP_NO_ACTION indicates doing nothing.

--*/
{
    LK_PREDICATE          lkpAction;
    SERVER_CERT *         pServerCert;

    DBG_ASSERT( pEndpointConfig != NULL );
    
    pServerCert = (SERVER_CERT*) pvState;
    DBG_ASSERT( pServerCert != NULL );
    DBG_ASSERT( pServerCert->CheckSignature() );
  
    
    if ( pEndpointConfig->QueryServerCert() == pServerCert )
    {
        lkpAction = LKP_PERFORM;
    }
    else
    {
        lkpAction = LKP_NO_ACTION;
    }

    return lkpAction;
} 

//static
HRESULT
ENDPOINT_CONFIG::FlushByServerCert(
    SERVER_CERT *           pServerCert
)
/*++

Routine Description:

    Flush the ENDPOINT_CONFIG cache of anything referecing the given server
    certificate

Arguments:

    pServerCert - Server certificate to reference

Return Value:

    HRESULT

--*/
{
    DBG_ASSERT( sm_pEndpointConfigHash != NULL );
    
    sm_pEndpointConfigHash->DeleteIf( ENDPOINT_CONFIG::ServerCertPredicate,
                                      pServerCert );
    
    return NO_ERROR;
}

//static
LK_PREDICATE
ENDPOINT_CONFIG::IisCtlPredicate(
    ENDPOINT_CONFIG *       pEndpointConfig,
    void *                  pvState
)
/*++

  Description:

    DeleteIf() predicate used to find items which reference the 
    SERVER_CERT pointed to by pvState    

  Arguments:

    pEndpointConfig - SSL endpoint config
    pvState - IIS_CTL to check for

  Returns:

    LK_PREDICATE   - LKP_PERFORM indicates removing the current 
                                 token from token cache

                     LKP_NO_ACTION indicates doing nothing.

--*/
{
    LK_PREDICATE          lkpAction;
    IIS_CTL *             pIisCtl;

    DBG_ASSERT( pEndpointConfig != NULL );
    
    pIisCtl = (IIS_CTL*) pvState;
    DBG_ASSERT( pIisCtl != NULL );
    DBG_ASSERT( pIisCtl->CheckSignature() );
    
    if ( pEndpointConfig->QueryIisCtl() == pIisCtl )
    {
        lkpAction = LKP_PERFORM;
    }
    else
    {
        lkpAction = LKP_NO_ACTION;
    }

    return lkpAction;
} 

//static
HRESULT
ENDPOINT_CONFIG::FlushByIisCtl(
    IIS_CTL *           pIisCtl
)
/*++

Routine Description:

    Flush the ENDPOINT_CONFIG cache of anything referecing the given CTL

Arguments:

    pIisCtl - 

Return Value:

    HRESULT

--*/
{
    DBG_ASSERT( sm_pEndpointConfigHash != NULL );
    
    sm_pEndpointConfigHash->DeleteIf( ENDPOINT_CONFIG::IisCtlPredicate,
                                      pIisCtl );
    
    return NO_ERROR;
}

//static
LK_PREDICATE
ENDPOINT_CONFIG::SiteIdPredicate(
    ENDPOINT_CONFIG *       /*pEndpointConfig*/,
    void *                  pvState
)
/*++

  Description:

    DeleteIf() predicate to delete config specified by site id (pvState)

  Arguments:

    pEndpointConfig - SSL Endpoint config 
    pvState - Site ID

  Returns:

    LK_PREDICATE   - LKP_PERFORM indicates removing the current 
                                 token from token cache

                     LKP_NO_ACTION indicates doing nothing.

--*/
{
    LK_PREDICATE            lkpAction;
    DWORD                   dwSiteId;

    
    dwSiteId = PtrToUlong(pvState);

    //
    // Site Id is legacy value - all endpoints will be deleted
    // upon change because we don't internally track site ID any more
    // CODEWORK: Site concept should be completely removed from the code
    // Remove before RC1
    
    lkpAction = LKP_PERFORM;
    return lkpAction;
} 


//static
LK_PREDICATE
ENDPOINT_CONFIG::EndpointPredicate(
    ENDPOINT_CONFIG *       pEndpointConfig,
    void *                  pvState
)
/*++

  Description:

    DeleteIf() predicate to delete config specified by site id (pvState)

  Arguments:

    pEndpointConfig - SSL Endpoint config 
    pvState - Endpoint key

  Returns:

    LK_PREDICATE   - LKP_PERFORM indicates removing the current 
                                 token from token cache

                     LKP_NO_ACTION indicates doing nothing.

--*/
{
    LK_PREDICATE            lkpAction;
    ENDPOINT_KEY *          pEndpointKey;

    DBG_ASSERT( pEndpointConfig != NULL );
    
    pEndpointKey = (ENDPOINT_KEY *) (pvState);
    
    if ( *( pEndpointConfig->QueryEndpointKey() ) == *pEndpointKey ||
         *pEndpointKey == GenerateEndpointKey( INADDR_ANY, 0 ) )
    {
        // 0 means to delete all the endpoint info 
        lkpAction = LKP_PERFORM;
    }
    else
    {
        lkpAction = LKP_NO_ACTION;
    }

    return lkpAction;
} 

//static
HRESULT
ENDPOINT_CONFIG::FlushByEndpoint(
    DWORD                   LocalAddress,
    USHORT                  LocalPort
)
/*++

Routine Description:

    Flush specified site configuration.  If dwSiteId is 0, then flush all

Arguments:

    LocalAddress - IP Address
    LocalPort  -   Port
    if LocalAddress=INADDR_ANY and LocalPort=0 then all endpoints will be flushed

Return Value:

    HRESULT

--*/
{
    DBG_ASSERT( sm_pEndpointConfigHash != NULL );

    ENDPOINT_KEY EndpointKey = GenerateEndpointKey( LocalAddress, LocalPort );  
    
    sm_pEndpointConfigHash->DeleteIf( ENDPOINT_CONFIG::EndpointPredicate,
                                  (PVOID) &EndpointKey );

    return NO_ERROR;
}

ENDPOINT_CONFIG::~ENDPOINT_CONFIG()
{
    if ( _pServerCert != NULL )
    {
        _pServerCert->DereferenceServerCert();
        _pServerCert = NULL;
    }

    if ( _pIisCtl != NULL )
    {
        _pIisCtl->DereferenceIisCtl();
        _pIisCtl = NULL;
    }

    if ( _pEndpointConfigData != NULL )
    {
        delete [] _pEndpointConfigData;
        _pEndpointConfigData = NULL;
    }
    
    _dwSignature = ENDPOINT_CONFIG_SIGNATURE_FREE;
}

HRESULT
ENDPOINT_CONFIG::AcquireCredentials(
    VOID
)
/*++

Routine Description:

    Do the Schannel thing to get credentials handle representing the 
    server cert/mapping configuration of this site

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    DBG_ASSERT( _pServerCert != NULL );
    
    return _SiteCreds.AcquireCredentials( _pServerCert,
                                          QueryUseDSMapper() );
                                        
}


// static
VOID
WINAPI
ENDPOINT_CONFIG::ConfigStoreChangeCallback(
    PVOID       /*pParam*/,
    BOOL        /*fWaitFired*/
)
/*++

Routine Description:

    Callback when HttpApi config store change occurs

    Note: Currently we listen directly on registry changes
    CODEWORK: once httpapi provides change notification mechanism
    we have to use that one
    

Arguments:

    not used

Return Value:

--*/

{
    //
    // If we fail to re-register for change notifications
    // we will ignore it. This will unfortunately stop all 
    // the future change notifications
    // CODEWORK: consider if there is anything else we can do
    //
    
    RegNotifyChangeKeyValue( sm_hHttpApiConfigKey, 
                             TRUE, 
                             REG_NOTIFY_CHANGE_LAST_SET | 
                             REG_NOTIFY_CHANGE_NAME, 
                             sm_hHttpApiConfigChangeEvent, 
                             TRUE );

    //
    // There is no straightforward mechanism to figure out individual change
    // that happened. That's why we will flush all endpoints config
    // ( Changes in the endpoint config are not frequent so this should not be
    // a performance problem at all )
    //
    
    FlushByEndpoint( INADDR_ANY, 0 );


}

//static
VOID
ENDPOINT_CONFIG::Cleanup(
    VOID
)
/*++

Routine Description:

    Cleanup must be called before Terminate
    
Arguments:

    none

Return Value:

    VOID

--*/
{
    sm_pEndpointConfigHash->Clear();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\sfwp\dll\streamfilter.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     streamfilter.cxx

   Abstract:
     Wraps all the globals of the stream filter process

   Author:
     Bilal Alam         (BAlam)         29-March-2000

   Environment:
     Win32 - User Mode

   Project:
     Stream Filter Worker Process
--*/

#include "precomp.hxx"


//
//  Configuration parameters registry key.
//
#define HTTPFILTER_KEY \
            "System\\CurrentControlSet\\Services\\HTTPFilter"

#define HTTPFILTER_PARAMETERS_KEY \
            HTTPFILTER_KEY "\\Parameters"

#define FILT_TRACE_MOF_FILE     L"StrmFiltMofResource"
#define FILT_IMAGE_PATH         L"strmfilt.dll"


DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();
DECLARE_PLATFORM_TYPE();


const CHAR g_pszStrmfiltRegLocation[] =
    HTTPFILTER_PARAMETERS_KEY ;

//
// simple verification that function prototypes has not changed
// the following entrypoints get called when strmfilt is loaded dynamically
// to assure that declared type matches we simply try to assign function pointers
// to matching types
//
PFN_STREAM_FILTER_INITIALIZE       s_pfnStreamFilterInitialize = StreamFilterInitialize;
PFN_STREAM_FILTER_START            s_pfnStreamFilterStart = StreamFilterStart;
PFN_STREAM_FILTER_STOP             s_pfnStreamFilterStop = StreamFilterStop;
PFN_STREAM_FILTER_TERMINATE        s_pfnStreamFilterTerminate = StreamFilterTerminate;




static STREAM_FILTER *             g_pStreamFilter;

static CRITICAL_SECTION            g_csStrmfiltInit;
static BOOL                        g_fInitcsStrmfiltInit = FALSE;
    

STREAM_FILTER::STREAM_FILTER(
    VOID
) 
{
    _pEtwTracer = NULL;
    _InitStatusCommon = INIT_NONE;

    _fListeningServer = FALSE;
    _InitStatusServer = INIT_NONE_SERVER;
    _pSslServerFilterChannel = NULL;

    _fListeningClient = FALSE;
    _InitStatusClient = INIT_NONE_CLIENT;
    _pSslClientFilterChannel = NULL;
}

STREAM_FILTER::~STREAM_FILTER( VOID )
{
}


HRESULT
STREAM_FILTER::Initialize(
    BOOL fClient
)
/*++

Routine Description:

    Initialize the stream filter globals

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HRESULT             hr = NO_ERROR;

    

    // global data initialization used by both client and server
    // (must be initialized only once)
    
    if ( _InitStatusCommon == INIT_NONE )
    {
        //
        // setup DEBUG structures
        //

        CREATE_DEBUG_PRINT_OBJECT("strmfilt");
        if (!VALID_DEBUG_PRINT_OBJECT())
        {
            hr = E_FAIL;
            goto Finished;
        }

        LOAD_DEBUG_FLAGS_FROM_REG_STR( g_pszStrmfiltRegLocation, DEBUG_ERROR );

        INITIALIZE_PLATFORM_TYPE();

        _InitStatusCommon = INIT_DEBUG;

        //
        // Initialization of the utility modules that originate from iisutil
        //

        if ( !Locks_Initialize() )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            if ( SUCCEEDED( hr ) )
            {
                hr = E_FAIL;
            }
            goto Finished;
        }
        _InitStatusCommon = INIT_IIS_LOCKS;
    
        if ( !ALLOC_CACHE_HANDLER::Initialize() )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            if ( SUCCEEDED( hr ) )
            {
                hr = E_FAIL;
            }
            goto Finished;
        }
        if ( ! ALLOC_CACHE_HANDLER::SetLookasideCleanupInterval() )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            if ( SUCCEEDED( hr ) )
            {
                hr = E_FAIL;
            }
            goto Finished;
        }
        _InitStatusCommon = INIT_IIS_ALLOC_CACHE_HANDLER;
    
        if ( !LKRHashTableInit() )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            if ( SUCCEEDED( hr ) )
            {
                hr = E_FAIL;
            }
            goto Finished;
        }
        _InitStatusCommon = INIT_IIS_LKRHASH;

        //
        // Intialize tracing stuff so that its available to initialization
        //

        _pEtwTracer = new CEtwTracer;
        if ( _pEtwTracer == NULL )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Finished;
        }

        hr = _pEtwTracer->Register( &StrmFiltControlGuid,
                                     FILT_IMAGE_PATH,
                                     FILT_TRACE_MOF_FILE );
        if ( FAILED( hr ) )
        {
            delete _pEtwTracer;
            _pEtwTracer = NULL;
            goto Finished;
        }

       _InitStatusCommon = INIT_ETWTRACE;

        //
        // Initialize STREAM_CONTEXTs
        //

        hr = STREAM_CONTEXT::Initialize();
        if ( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Error initializing STREAM_CONTEXT globals.  hr = %x\n",
                        hr ));
            goto Finished;
        }
        _InitStatusCommon = INIT_STREAM_CONTEXT;

        hr = UL_OVERLAPPED_CONTEXT::Initialize();
        if ( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Error initializing UL_OVERLAPPED_CONTEXT globals.  hr = %x\n",
                        hr ));
            goto Finished;
        }
        _InitStatusCommon = INIT_UL_OVERLAPPED_CONTEXT;

    }
    
    //
    // Initialize FILTER_CHANNEL
    //

    if ( fClient )
    {
        //
        // Initialize SSL_CLIENT_FILTER_CHANNEL
        //
  
        _pSslClientFilterChannel = new SSL_CLIENT_FILTER_CHANNEL();
        if ( _pSslClientFilterChannel == NULL)
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Error creating SSL_CLIENT_FILTER_CHANNEL\n" ));
            goto Finished;
        }

        hr = _pSslClientFilterChannel->Initialize();
        if ( FAILED( hr ) )
        {
            delete _pSslClientFilterChannel;
            _pSslClientFilterChannel = NULL;
            DBGPRINTF(( DBG_CONTEXT,
                        "Error initializing SSL_CLIENT_FILTER_CHANNEL.  hr = %x\n",
                        hr ));
            goto Finished;
        }
        _InitStatusClient = INIT_SSL_CLIENT_FILTER_CHANNEL;

        hr = UC_SSL_STREAM_CONTEXT::Initialize();
        if ( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Error initializing UC_SSL_CONTEXT globals.  hr = %x\n",
                        hr ));
            goto Finished;
        }
        _InitStatusClient = INIT_UC_SSL_STREAM_CONTEXT;

    }
    else
    {
        //
        // Initialize SSL_SERVER_FILTER_CHANNEL
        //
  
        hr = SSL_SERVER_FILTER_CHANNEL_CONTEXT::Initialize();
        if ( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Error initializing SSL_SERVER_FILTER_CHANNEL_CONTEXT globals.  hr = %x\n",
                        hr ));
            goto Finished;
        }
        _InitStatusServer = INIT_SSL_SERVER_FILTER_CHANNEL_CONTEXT;

        
        hr = SSL_STREAM_CONTEXT::Initialize();
        if ( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Error initializing SSL_STREAM_CONTEXT globals.  hr = %x\n",
                        hr ));
            goto Finished;
        }
        _InitStatusServer = INIT_SSL_STREAM_CONTEXT;

        hr = ISAPI_STREAM_CONTEXT::Initialize();
        if ( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Error initializing ISAPI_STREAM_CONTEXT globals.  hr = %x\n",
                        hr ));
            goto Finished;
        }
        _InitStatusServer = INIT_ISAPI_STREAM_CONTEXT;

        _pSslServerFilterChannel = new SSL_SERVER_FILTER_CHANNEL();
        if (_pSslServerFilterChannel == NULL)
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Error creating SSL_SERVER_FILTER_CHANNEL\n" ));
            goto Finished;
        }

        hr = _pSslServerFilterChannel->Initialize();
        if ( FAILED( hr ) )
        {
            delete _pSslServerFilterChannel;
            _pSslServerFilterChannel = NULL;

            DBGPRINTF(( DBG_CONTEXT,
                        "Error initializing HTTP_SSL_SERVER_FILTER_CHANNEL.  hr = %x\n",
                        hr ));
            goto Finished;
        }
        _InitStatusServer = INIT_SSL_SERVER_FILTER_CHANNEL;


    }

    DBG_ASSERT( hr == NO_ERROR );

    return hr;

Finished:
    STREAM_FILTER::Terminate( fClient );
    return hr;
}


VOID
STREAM_FILTER::Terminate(
    BOOL fClient
)
/*++

Routine Description:

    Terminate the stream filter globals

Arguments:

    None

Return Value:

    None

--*/
{
    if ( fClient )
    {
        switch( _InitStatusClient )
        {
        // FILTER_CHANNEL owns the threadpool
        // _pSslClientFilterChannel->Terminate() must be called before any
        // other cleanup so that all the threads are completed
        case INIT_SSL_CLIENT_FILTER_CHANNEL:
            _pSslClientFilterChannel->Terminate();
            delete _pSslClientFilterChannel;
            _pSslClientFilterChannel = NULL;
        case INIT_UC_SSL_STREAM_CONTEXT:
            UC_SSL_STREAM_CONTEXT::Terminate();
        }
    }
    else
    {   
        // FILTER_CHANNEL owns the threadpool
        // _pSslClientFilterChannel->Terminate() must be called before any
        // other cleanup so that all the threads are completed

        switch( _InitStatusServer )
        {
        case INIT_SSL_SERVER_FILTER_CHANNEL:
            _pSslServerFilterChannel->Terminate();
            delete _pSslServerFilterChannel;
            _pSslServerFilterChannel = NULL;
        case INIT_ISAPI_STREAM_CONTEXT:
            ISAPI_STREAM_CONTEXT::Terminate();
        case INIT_SSL_STREAM_CONTEXT:
            SSL_STREAM_CONTEXT::Terminate();
        case INIT_SSL_SERVER_FILTER_CHANNEL_CONTEXT:
            SSL_SERVER_FILTER_CHANNEL_CONTEXT::Terminate();
        }
    }
        
    if ( !IsInUse() )
    {
        //
        // neither client nor server needs common data
        // we can cleanup now.
        //
        
        switch( _InitStatusCommon )
        {
        case INIT_UL_OVERLAPPED_CONTEXT:            
            UL_OVERLAPPED_CONTEXT::Terminate();

        case INIT_STREAM_CONTEXT:
            STREAM_CONTEXT::Terminate();

        case INIT_ETWTRACE:
        if ( _pEtwTracer != NULL )
        {
            _pEtwTracer->UnRegister();
            delete _pEtwTracer;
            _pEtwTracer = NULL;
        }
        case INIT_IIS_LKRHASH:
            LKRHashTableUninit();
        
        case INIT_IIS_ALLOC_CACHE_HANDLER:
            DBG_REQUIRE( ALLOC_CACHE_HANDLER::ResetLookasideCleanupInterval() );
            ALLOC_CACHE_HANDLER::Cleanup();
    
        case INIT_IIS_LOCKS:
            Locks_Cleanup();
            
        case INIT_DEBUG:
            DELETE_DEBUG_PRINT_OBJECT();
        }
    }  
}

HRESULT
STREAM_FILTER::StopListening(
    BOOL fClient
)
/*++

Routine Description:

    Stop listening for UL filter channel

Arguments:

    fClient - TRUE if client is to be initialized, otherwise Server is assumed

Return Value:

    HRESULT

--*/
{
    //
    // cancel pending calls so that FILTER_CHANNEL_CONTEXT worker threads
    // that may be blocked on pipe call will not cause problems
    // for StopListening ( CancelPendingCalls() also stops change callbacks )
    //


    if ( fClient )
    {
        _pSslClientFilterChannel->StopListening();
        _fListeningClient = FALSE;
    }        
    else
    {
        _pSslServerFilterChannel->StopListening();
        _fListeningServer = FALSE;
    }
    return NO_ERROR;
}

HRESULT
STREAM_FILTER::StartListening(
    BOOL fClient
)
/*++

Routine Description:

    Start listening for incoming connections

Arguments:

    None

Return Value:

    None

--*/
{
    HRESULT                 hr = NO_ERROR;

    if ( fClient )
    {
        DBG_ASSERT( !_fListeningClient );
        hr = _pSslClientFilterChannel->StartListening();
        if ( FAILED( hr ) )
        {
            return hr;
        }
        _fListeningClient = TRUE;
    }
    else
    {
        //
        // This will kick off enough filter accepts to keep our threshold
        // of outstanding accepts avail
        //
        DBG_ASSERT( !_fListeningServer );
        hr = _pSslServerFilterChannel->StartListening();
        if ( FAILED( hr ) )
        {
            return hr;
        }
        _fListeningServer = TRUE;
    }
    return hr;
}


//
// Export function which allows the stream filter to be used for client or server side 
// http.sys FILTER Channel handling
//

HRESULT
StreamFilterInitialize(
    VOID
)
/*++

Routine Description:

    Initialize the Server side of the stream filter

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HRESULT                 hr = NO_ERROR;

    
    //
    // Global global STREAM_FILTER object
    //
    EnterCriticalSection( &g_csStrmfiltInit );
    if ( g_pStreamFilter == NULL )
    {
        g_pStreamFilter = new STREAM_FILTER( );
        if ( g_pStreamFilter == NULL )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Finished;
        }
    }
    hr = g_pStreamFilter->Initialize( FALSE /*means server*/ );
    if ( FAILED( hr ) )
    {
        delete g_pStreamFilter;
        g_pStreamFilter = NULL;

        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to initialize global STREAM_FILTER object.  hr = %x\n",
                    hr ));
        goto Finished;
    }

Finished:
    LeaveCriticalSection( &g_csStrmfiltInit );
    return hr;
}

HRESULT
StreamFilterStart(
    VOID
)
/*++

Routine Description:

    Start listening for filter requests on the server side

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    if ( g_pStreamFilter == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    return g_pStreamFilter->StartListening( FALSE /*means server*/ );
}

HRESULT
StreamFilterStop(
    VOID
)
/*++

Routine Description:

    Stop listening for filter requests on the server side

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    if ( g_pStreamFilter == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    return g_pStreamFilter->StopListening( FALSE /*means server*/ );
}

VOID
StreamFilterTerminate(
    VOID
)
/*++

Routine Description:

    Cleanup server side of the stream filter

Arguments:

    None

Return Value:

    None

--*/
{
    EnterCriticalSection( &g_csStrmfiltInit );
    if ( g_pStreamFilter != NULL )
    {
        g_pStreamFilter->Terminate( FALSE /* means server */ );

        if ( !g_pStreamFilter->IsInUse() )
        {
            delete g_pStreamFilter;
            g_pStreamFilter = NULL;
        }
    }
    else
    {
        DBG_ASSERT( FALSE );
    }
    LeaveCriticalSection( &g_csStrmfiltInit );
}


HRESULT
StreamFilterClientInitialize(
    VOID
)
/*++

Routine Description:

    Initialize the client side related part of the stream filter

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HRESULT                 hr = NO_ERROR;

    
    //
    // Global global STREAM_FILTER object
    //
    EnterCriticalSection( &g_csStrmfiltInit );
    if ( g_pStreamFilter == NULL )
    {
        g_pStreamFilter = new STREAM_FILTER( );
        if ( g_pStreamFilter == NULL )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Finished;
        }
    }
    hr = g_pStreamFilter->Initialize( TRUE /*means client*/ );
    if ( FAILED( hr ) )
    {
        delete g_pStreamFilter;
        g_pStreamFilter = NULL;

        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to initialize global STREAM_FILTER object.  hr = %x\n",
                    hr ));
        goto Finished;
    }

Finished:
    LeaveCriticalSection( &g_csStrmfiltInit );
    return hr;
}

HRESULT
StreamFilterClientStart(
    VOID
)
/*++

Routine Description:

    Start listening for filter requests on the client side

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    if ( g_pStreamFilter == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    return g_pStreamFilter->StartListening( TRUE /*means client*/ );
}

HRESULT
StreamFilterClientStop(
    VOID
)
/*++

Routine Description:

    Stop listening for filter requests on the client side

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    if ( g_pStreamFilter == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    return g_pStreamFilter->StopListening( TRUE /*means client*/ );
}

VOID
StreamFilterClientTerminate(
    VOID
)
/*++

Routine Description:

    Cleanup client side of the stream filter

Arguments:

    None

Return Value:

    None

--*/
{
    EnterCriticalSection( &g_csStrmfiltInit );
    if ( g_pStreamFilter != NULL )
    {
        g_pStreamFilter->Terminate( TRUE /* means client */ );

        if ( !g_pStreamFilter->IsInUse() )
        {
            delete g_pStreamFilter;
            g_pStreamFilter = NULL;
        }
    }
    else
    {
        DBG_ASSERT( FALSE );
    }
    LeaveCriticalSection( &g_csStrmfiltInit );
}



HRESULT
IsapiFilterInitialize(
    ISAPI_FILTERS_CALLBACKS *      pStreamConfig
)
/*++

Routine Description:

    Initialize the Isapi Filter

Arguments:

    pStreamConfig - Stream configuration

Return Value:

    HRESULT

--*/
{
    if ( pStreamConfig == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    if ( g_pStreamFilter != NULL )
    {
        //
        // Enable ISAPI Filters notification
        // ( after this call returns then all raw filter completions
        // will be processed by ISAPI filters )
        //
        return g_pStreamFilter->EnableISAPIFilters( pStreamConfig );

    }
    else
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to enable Raw ISAPI FILTERS. HTTPFILTER doesn't seem to be loaded in inetinfo.exe\n"
                    ));

        return HRESULT_FROM_WIN32( ERROR_INVALID_STATE );
    }
}



VOID
IsapiFilterTerminate(
    VOID
)
/*++

Routine Description:

    Cleanup Isapi filter

Arguments:

    None

Return Value:

    None

--*/
{
    if ( g_pStreamFilter == NULL )
    {
        DBG_ASSERT( FALSE );
        return;
    }

    //
    // Disable ISAPI filter notifications
    // ( all connections with ISAPI filter context
    // will be destroyed )
    //
    g_pStreamFilter->DisableISAPIFilters();
}



extern "C"
BOOL
WINAPI
DllMain(
    HINSTANCE                   hInstance,
    DWORD                       dwReason,
    LPVOID                      /*lpvReserved*/
)
/*++

Routine Description:

    Dllmain - handling process attach and detach

Arguments:
    
Return Value:

    BOOL

--*/
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        BOOL fRet = FALSE;
        
        // w3tp_static.lib needs to know the hinstance of the dll it is linked into
        g_hmodW3TPDLL = hInstance;
        
        DisableThreadLibraryCalls( hInstance );


        fRet = InitializeCriticalSectionAndSpinCount(
                                &g_csStrmfiltInit,
                                0x80000000 /* precreate event */ |
                                IIS_DEFAULT_CS_SPIN_COUNT );
        g_fInitcsStrmfiltInit = TRUE;

        return fRet;

    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        DeleteCriticalSection( &g_csStrmfiltInit );
        g_fInitcsStrmfiltInit = FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\sfwp\dll\streamcontext.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     streamcontext.cxx

   Abstract:
     Implementation of STREAM_CONTEXT.  One such object for every connection
 
   Author:
     Bilal Alam         (BAlam)         29-March-2000

   Environment:
     Win32 - User Mode

   Project:
     Stream Filter Worker Process
--*/

#include "precomp.hxx"



STREAM_CONTEXT::STREAM_CONTEXT(
    FILTER_CHANNEL_CONTEXT *   pContext
)
{
    DBG_ASSERT( pContext != NULL );
    _pFiltChannelContext = pContext;
    
    _dwSignature = STREAM_CONTEXT_SIGNATURE;
}

STREAM_CONTEXT::~STREAM_CONTEXT()
{
    _dwSignature = STREAM_CONTEXT_SIGNATURE_FREE;
}
   
//static
HRESULT
STREAM_CONTEXT::Initialize(
    VOID
)
/*++

Routine Description:

    Global Initialization

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    return NO_ERROR;
}

//static
VOID
STREAM_CONTEXT::Terminate(
    VOID
)
/*++

Routine Description:

    Global termination    

Arguments:

    None

Return Value:

    None

--*/
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\sfwp\dll\sslcontext.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     sslcontext.cxx

   Abstract:
     SSL stream context
 
   Author:
     Bilal Alam         (BAlam)         29-March-2000

   Environment:
     Win32 - User Mode

   Project:
     Stream Filter Worker Process
--*/

#include "precomp.hxx"


//static 
ALLOC_CACHE_HANDLER * SSL_STREAM_CONTEXT::sm_pachSslStreamContexts = NULL;

//
// By default we don't allow CAPI to automatically download intermediate certificates
// off the network
//
//static 
BOOL SSL_STREAM_CONTEXT::sm_fCertChainCacheOnlyUrlRetrieval = TRUE;


enum SSL_STREAM_CONTEXT::INIT_STATE   
            SSL_STREAM_CONTEXT::s_InitState = INIT_NONE;

//static
HRESULT
SSL_STREAM_CONTEXT::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize all SSL global data

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HRESULT                         hr = S_OK;
    ALLOC_CACHE_CONFIGURATION       acConfig;
    HKEY                            hKeyParam = NULL;
    DWORD                           dwType = 0;
    DWORD                           dwValue = 0;

    
    hr = CERT_STORE::Initialize();
    if ( FAILED( hr ) )
    {
        goto Finished;
    }
    s_InitState = INIT_CERT_STORE;
    
    hr = SERVER_CERT::Initialize();
    if ( FAILED( hr ) )
    {
        goto Finished;
    }
    s_InitState = INIT_SERVER_CERT;
    
    hr = IIS_CTL::Initialize();
    if ( FAILED( hr ) )
    {
        goto Finished;
    }
    s_InitState = INIT_IIS_CTL;
    
    hr = SITE_CREDENTIALS::Initialize();
    if ( FAILED( hr ) )
    {
        goto Finished;
    }
    s_InitState = INIT_SITE_CREDENTIALS;
    
    //
    // ENDPOINT_CONFIG uses 
    //      SERVER_CERT, 
    //      SITE_CREDENTIALS and 
    //

    hr = ENDPOINT_CONFIG::Initialize();
    if ( FAILED( hr ) )
    {
        goto Finished;
    }
    s_InitState = INIT_ENDPOINT_CONFIG;

    //
    // Setup allocation lookaside
    //

    acConfig.nConcurrency = 1;
    acConfig.nThreshold = 100;
    acConfig.cbSize = sizeof( SSL_STREAM_CONTEXT );

    DBG_ASSERT( sm_pachSslStreamContexts == NULL );

    sm_pachSslStreamContexts = new ALLOC_CACHE_HANDLER( "SSL_STREAM_CONTEXT",  
                                                &acConfig );

    if ( sm_pachSslStreamContexts == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto Finished;
    }

    s_InitState = INIT_ACACHE;

    //
    // Read registry parameters
    //
    
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       REGISTRY_KEY_HTTPFILTER_PARAMETERS_W,
                       0,
                       KEY_READ,
                       &hKeyParam ) == NO_ERROR )
        {
            DWORD dwBytes = sizeof( dwValue );
            DWORD dwErr = RegQueryValueExW( hKeyParam,
                                    SZ_REG_CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL,
                                    NULL,
                                    &dwType,
                                    ( LPBYTE )&dwValue,
                                    &dwBytes
                                    );

            if ( ( dwErr == ERROR_SUCCESS ) && 
                 ( dwType == REG_DWORD ) ) 
            {
                //
                // Do double negation to convert DWORD to BOOL
                //
                sm_fCertChainCacheOnlyUrlRetrieval = !!dwValue;
            }

            RegCloseKey( hKeyParam );
        }


Finished:
    if ( FAILED( hr ) )
    {
        Terminate();
    }
      
    return hr;
}


//static
VOID
SSL_STREAM_CONTEXT::Terminate(
    VOID
)
/*++

Routine Description:

    Terminate SSL

Arguments:

    None

Return Value:

    None

--*/
{

    // This call must happen after the main threadpool has shutdown
    // However there still may be threads executing because of the change notification
    // callbacks
    //
    // ENDPOINT_CONFIG gets notified on http config changes but callbacks touch only
    // the ENDPOINT_CONFIG itself
    //
    // CERT_STORE gets notified on CAPI store changes. Callback function will
    // cause access to CERT_STORE, SERVER_CERT, IIS_CTL, ENDPOINT_CONFIG
    // That's why all the change notification handling for CERT_STORE
    // must be completed before all of the classes mentioned above are Terminated
    // Cleanup of ENDPOINT_CONFIG, IIS_CTL, SERVER_CERT and CERT_STORE will
    // assure that when Terminate is called, there are no outstanding threads partying
    // on any data owned by those classes and so it is indeed safe to terminate

    // Cleanup phase
    // Note: all INIT_* tags must be present in both Cleanup and Termination part

    switch ( s_InitState )
    {
    case INIT_ACACHE:
    case INIT_ENDPOINT_CONFIG:
        ENDPOINT_CONFIG::Cleanup();
    case INIT_SITE_CREDENTIALS:        
    case INIT_IIS_CTL:
        IIS_CTL::Cleanup();
    case INIT_SERVER_CERT:
        SERVER_CERT::Cleanup();
    case INIT_CERT_STORE:
        CERT_STORE::Cleanup();
    case INIT_NONE:
        break;
    default:
        DBG_ASSERT( FALSE );
    }
        

    // Termination phase

    switch ( s_InitState )
    {
    case INIT_ACACHE:
        if ( sm_pachSslStreamContexts != NULL )
        {
            delete sm_pachSslStreamContexts;
            sm_pachSslStreamContexts = NULL;
        }
    case INIT_ENDPOINT_CONFIG:
        ENDPOINT_CONFIG::Terminate();
    case INIT_SITE_CREDENTIALS:
        SITE_CREDENTIALS::Terminate();
    case INIT_IIS_CTL:
        IIS_CTL::Terminate();
    case INIT_SERVER_CERT:
        SERVER_CERT::Terminate();
    case INIT_CERT_STORE:
        CERT_STORE::Terminate();
    case INIT_NONE:
        break;
    default:
        DBG_ASSERT( FALSE );
    }
}    


SSL_STREAM_CONTEXT::SSL_STREAM_CONTEXT(
    FILTER_CHANNEL_CONTEXT *            pFiltChannelContext
)
    : STREAM_CONTEXT( pFiltChannelContext ),
      _pEndpointConfig( NULL ),
      _sslState( SSL_STATE_HANDSHAKE_START ),
      _fRenegotiate( FALSE ),
      _fExpectRenegotiationFromClient( FALSE ),
      _fValidContext( FALSE ),
      _cbToBeProcessedOffset( 0 ),
      _pClientCert( NULL ),
      _fDoCertMap( FALSE ),
      _cbDecrypted( 0 )      
{
    //
    // Initialize security buffer structs
    //
    
    //
    // Setup buffer to hold incoming raw data
    //

    DBG_ASSERT( s_InitState != INIT_NONE );
    
   
    ZeroMemory( &_hContext, sizeof( _hContext ) );
    ZeroMemory( &_ulSslInfo, sizeof( _ulSslInfo ) );
    ZeroMemory( &_ulCertInfo, sizeof( _ulCertInfo ) );
    _ulCertInfo.Token = NULL;
}

SSL_STREAM_CONTEXT::~SSL_STREAM_CONTEXT()
{
    if ( _fValidContext ) 
    {
        DeleteSecurityContext( &_hContext );
        _fValidContext = FALSE;
    }
    
    if ( _pEndpointConfig != NULL )
    {
        _pEndpointConfig->DereferenceEndpointConfig();
        _pEndpointConfig = NULL;
    }

    if( _ulCertInfo.Token != NULL )
    {
        CloseHandle( _ulCertInfo.Token );
        _ulCertInfo.Token = NULL;
    }

    if( _pClientCert != NULL )
    {
        CertFreeCertificateContext( _pClientCert );
        _pClientCert = NULL;
    }
}


HRESULT
SSL_STREAM_CONTEXT::ProcessNewConnection(
    CONNECTION_INFO *           pConnectionInfo,
    ENDPOINT_CONFIG *           pEndpointConfig
)
/*++

Routine Description:

    Handle a new raw connection

Arguments:

    pConnectionInfo - The magic connection information (not used)
    pEndpointConfig - endpoint configuration

Return Value:

    HRESULT

--*/
{
    BOOL fLocalEndpointConfigReference = FALSE;
    DBG_ASSERT( _sslState == SSL_STATE_HANDSHAKE_START );

    if ( pEndpointConfig == NULL )
    {
        HRESULT hr = ENDPOINT_CONFIG::GetEndpointConfig( pConnectionInfo,
                                                         &pEndpointConfig );

        if ( SUCCEEDED( hr ) )
        {
            fLocalEndpointConfigReference = TRUE;
        }
        else if ( hr == HRESULT_FROM_WIN32 ( ERROR_FILE_NOT_FOUND ) )
        {
            //
            // not found means that SSL is not enabled
            //
            QueryFiltChannelContext()->SetIsSecure( FALSE );
            return S_OK;
        }
        else if ( FAILED( hr ) )
        {
            return hr;
        }
    }

    DBG_ASSERT( pEndpointConfig != NULL );

    if ( !pEndpointConfig->QuerySslConfigured() )
    {
        // no endpoint config was found 
        // or endpoint config was found built doesn't contain SSL stuff
        //
        QueryFiltChannelContext()->SetIsSecure( FALSE );
    }
    else 
    {
        QueryFiltChannelContext()->SetIsSecure( TRUE );
        //
        // Store away the site config for this connection
        //
    
        pEndpointConfig->ReferenceEndpointConfig();
        _pEndpointConfig = pEndpointConfig;
    }

    if ( fLocalEndpointConfigReference )
    {
        // Local Endpoint Config lookup was made
        // within this function.
        // release the reference
        //
        pEndpointConfig->DereferenceEndpointConfig();
        pEndpointConfig = NULL;
    }
    return S_OK;
}

    
HRESULT
SSL_STREAM_CONTEXT::ProcessRawReadData(
    RAW_STREAM_INFO *               pRawStreamInfo,
    BOOL *                          pfReadMore,
    BOOL *                          pfComplete
)
/*++

Routine Description:

    Handle an SSL read completion off the wire

Arguments:

    pRawStreamInfo - Points to input stream and size
    pfReadMore - Set to TRUE if we should read more
    pfComplete - Set to TRUE if we should disconnect

Return Value:

    HRESULT

--*/
{
    HRESULT                 hr = S_OK;
    BOOL                    fExtraData = FALSE;
    //
    // Do we have site config?  If not, then this isn't an SSL connection
    //
    
    if ( _pEndpointConfig == NULL )
    {
        return S_OK;
    }

    //
    // Loop for extra data 
    // Sometimes one RawStreamInfo buffer may contain multiple blobs 
    // some to be processed by DoHandshake() and some by DoDecrypt()
    // The do-while loop enables switching between these 2 functions as needed
    //

    do
    {
        fExtraData  = FALSE;
        *pfReadMore = FALSE;
        *pfComplete = FALSE;
        //
        // Either continue handshake or immediate decrypt data
        // 

        switch ( _sslState )
        {
        case  SSL_STATE_HANDSHAKE_START:
        case  SSL_STATE_HANDSHAKE_IN_PROGRESS:

            hr = DoHandshake( pRawStreamInfo,
                              pfReadMore,
                              pfComplete,
                              &fExtraData );
            break;                              
        case  SSL_STATE_HANDSHAKE_COMPLETE:
        
            hr = DoDecrypt( pRawStreamInfo,
                            pfReadMore,
                            pfComplete,
                            &fExtraData );
            break;
        default:
            DBG_ASSERT( FALSE );
        }

        if ( FAILED( hr ) )
        {
            break;
        }

    //
    // Is there still some extra data to be processed?
    //
    
    }while( fExtraData ); 
    return hr;
}


HRESULT
SSL_STREAM_CONTEXT::ProcessRawWriteData(
    RAW_STREAM_INFO *               pRawStreamInfo,
    BOOL *                          pfComplete
)
/*++

Routine Description:

    Called on read completion from app. Data received 
    from application must be encrypted and sent to client
    using RawWrite.
    Application may have also requested renegotiation 
    (with or without mapping) if client certificate
    is not yet present

Arguments:

    pRawStreamInfo - Points to input stream and size
    pfComplete - Set to TRUE if we should disconnect

Return Value:

    HRESULT

--*/
{
    HRESULT                 hr;
    HTTP_FILTER_BUFFER_TYPE bufferType; 

    if ( _pEndpointConfig == NULL )
    {
        //
        // We never found SSL to be relevent for this connection.  Do nothing
        //
        
        return S_OK;
    }
    
    if ( _sslState != SSL_STATE_HANDSHAKE_COMPLETE )
    {
        //
        // HttpFilter is not able to reliably handle state
        // where renegotiation is in progress and response data is 
        // requested to be sent to client
        // Ideally HttpFilter should not have any pending AppReads
        // for the duration of the renegotiation handshake
        // however in that case http.sys would not be able to inform
        // us about client closing connection.
        // So there are 2 ways around this problem
        //
        // a) the easy and cheesy is to detect that SSL handshake is
        // not complete and close connection
        //
        // b) we could buffer data to be sent and send it after handshake is done
        //
        // Option b) is ultimately more decent but due to the fact that
        // there is not much practical need for sending response data while renegotiating
        // we will implement the option a)
        //
        // One example of the scenario where data to be sent to client is received while in 
        // the middle of the renegotiation is the following
        // a) Client sends Post with part of the response body
        // b) Http.sys gets headers and part of the response body and 
        //    passes it to IIS
        // c) Http.sys will keep receiving response
        // d) IIS will ask for renegotiation (because URL requires client cert)
        // e) while in the middle of renegotiation, http.sys finds out that
        //    client closed it's end of the socket before all the bytes of the 
        //    response were sent. 
        // f) Http.sys sends "400 Bad Request"
        // g) HttpFilter will eventually not be able to send the response because
        //    we are in the middle of renegotiation. However there is not much
        //    loss of the information if HttpFilter simply decides to close connection
        //    because specific error will be stored in the http error log

        IF_DEBUG ( FLAG_ERROR ) 
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Error: HttpFilter doesn't allow responses while in the middle of ssl handshake (connection will be closed)\n"
                        ));
        }
        return HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
    }

    bufferType = QueryFiltChannelContext()->QueryFilterBufferType();

    //
    // Is this data from the application, or a request for renegotiation?
    //
    
    if ( bufferType == HttpFilterBufferSslRenegotiate ||
         bufferType == HttpFilterBufferSslRenegotiateAndMap )
    {
        //
        // If we have already renegotiated a client certificate, then there
        // is nothing to do, but read again for stream data
        //
        
        if ( _fRenegotiate )
        {
            hr = S_OK;
        }
        else
        {
            if ( bufferType == HttpFilterBufferSslRenegotiateAndMap )
            {
                _fDoCertMap = TRUE;
            }

            hr = DoRenegotiate();
        }    
    }
    else if ( bufferType == HttpFilterBufferHttpStream )
    {
        hr = DoEncrypt( pRawStreamInfo,
                        pfComplete );
    }
    else
    {
        DBG_ASSERT( FALSE );
        hr = E_FAIL;
    }
    
    return hr;
}


HRESULT
SSL_STREAM_CONTEXT::SendDataBack(
    RAW_STREAM_INFO *           pRawStreamInfo
)
/*++

Routine Description:

    Send back data (different then ProcessRawWrite because in this case
    the data was not received by the application, but rather a raw filter)

Arguments:

    pRawStreamInfo - Points to input stream and size

Return Value:

    HRESULT

--*/
{
    BOOL                    fComplete;
    HRESULT                 hr;
    
    if ( pRawStreamInfo == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    if ( _pEndpointConfig != NULL )
    {
        //
        // We must have completed the handshake to get here, since this path
        // is only invoked by ISAPI filters 
        //
    
        DBG_ASSERT( _sslState == SSL_STATE_HANDSHAKE_COMPLETE );
        
        hr = DoEncrypt( pRawStreamInfo,
                        &fComplete );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }
    
    //
    // caller is responsible to send data    
    //
    return S_OK;
}

//static
HRESULT
SSL_STREAM_CONTEXT::OnHandshakeRawWriteCompletion(
    PVOID pParam
)

/*++

Routine Description:

    perform cleanup after RawWrite Completion

Arguments:

    pParam - parameter passed by the caller of DoRawWrite along with completion function

Return Value:

    HRESULT

--*/
{
    if ( pParam != NULL )
    {
        FreeContextBuffer( pParam );
        pParam = NULL;
    }
    return S_OK;
}
    

HRESULT
SSL_STREAM_CONTEXT::DoHandshake(
    RAW_STREAM_INFO *           pRawStreamInfo,
    BOOL *                      pfReadMore,
    BOOL *                      pfComplete,
    BOOL *                      pfExtraData

)
/*++

Routine Description:

    Do the handshake thing with AcceptSecurityContext()

Arguments:

    pRawStreamInfo - Raw data buffer
    pfReadMore - Set to true if more data should be read
    pfComplete - Set to true if we should disconnect

Return Value:

    HRESULT

--*/
{
    SECURITY_STATUS             secStatus = SEC_E_OK;
    HRESULT                     hr = E_FAIL;
    DWORD                       dwFlags = SSL_ASC_FLAGS;
    DWORD                       dwContextAttributes;
    TimeStamp                   tsExpiry;
    CtxtHandle                  hOutContext;

    // Buffers used for SSL Handshake (incoming handshake blob)
    // 4 is the schannel magic number
    SecBufferDesc               MessageIn;
    SecBuffer                   InBuffers[ 4 ];
    // Buffers used for SSL Handshake (outgoing handshake blob)    
    // 4 is the schannel magic number
    SecBufferDesc               MessageOut;
    SecBuffer                   OutBuffers[ 4 ];
        

    if ( pRawStreamInfo == NULL ||
         pfReadMore == NULL ||
         pfComplete == NULL ||
         pfExtraData == NULL )
    {
        DBG_ASSERT( FALSE );
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        goto ExitPoint;
    }
    
    *pfReadMore  = FALSE;
    *pfComplete  = FALSE;
    *pfExtraData = FALSE;

    IF_DEBUG( SCHANNEL_CALLS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "DoHandshake(): _cbDecrypted = %d, _cbToBeProcessedOffset=%d\n",
                    _cbDecrypted,
                    _cbToBeProcessedOffset
                 ));
    }



    DBG_ASSERT( _pEndpointConfig != NULL );

    if( pRawStreamInfo->cbData < _cbToBeProcessedOffset )
    {
        //
        // Inconsisent state of the SSL_STREAM_CONTEXT
        // This should never really happen, but because we
        // execute in lsass we don't want to see wrong offset calculations
        // cause much trouble in lsass
        //
        IF_DEBUG ( FLAG_ERROR ) 
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Error: HttpFilter detected unexpected offset in it's internal data (connection will be closed)\n"
                        ));
        }
        
        DBG_ASSERT( FALSE );
        
        return HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
    }
    
    //
    // Setup input & output buffers for AcceptSecurityContext call
    //
    
    MessageIn.ulVersion = SECBUFFER_VERSION;
    MessageIn.cBuffers = 4;
    MessageIn.pBuffers = InBuffers;

    InBuffers[0].BufferType = SECBUFFER_TOKEN;
    InBuffers[0].pvBuffer   = pRawStreamInfo->pbBuffer + _cbToBeProcessedOffset;
    InBuffers[0].cbBuffer   = pRawStreamInfo->cbData - _cbToBeProcessedOffset;
    InBuffers[1].BufferType = SECBUFFER_EMPTY;
    InBuffers[2].BufferType = SECBUFFER_EMPTY;
    InBuffers[3].BufferType = SECBUFFER_EMPTY;

    
    MessageOut.ulVersion = SECBUFFER_VERSION;
    MessageOut.cBuffers = 4;
    MessageOut.pBuffers = OutBuffers;

    //
    // Note: OutBuffers[ 0 ].pvBuffer may get changed in AcceptSecurityContext
    // even if error is returned. In that case _OutBuffers[ 0 ].pvBuffer must
    // not be freed
    
    OutBuffers[0].pvBuffer = NULL;
    OutBuffers[0].cbBuffer = NULL;
    OutBuffers[0].BufferType = SECBUFFER_EMPTY;
    OutBuffers[1].BufferType = SECBUFFER_EMPTY;
    OutBuffers[2].BufferType = SECBUFFER_EMPTY;
    OutBuffers[3].BufferType = SECBUFFER_EMPTY;


    //
    // Are we renegotiating for client cert?
    // if _pEndpointConfig->QueryNegotiateClientCert() is TRUE
    // it means that Client certificates are enabled on root level
    // of the site. In that case we enable optimization where
    // client certificates are negotiated right away to eliminate
    // expensive renegotiation

    DBG_ASSERT( _pEndpointConfig != NULL );
    if ( _fRenegotiate || _pEndpointConfig->QueryNegotiateClientCert() )
    {
        dwFlags |= ASC_REQ_MUTUAL_AUTH;
    }

    if ( _sslState == SSL_STATE_HANDSHAKE_START )
    {
        ConditionalAddWorkerThread();
        secStatus = AcceptSecurityContext( QueryCredentials(),
                                           NULL,
                                           &MessageIn,
                                           dwFlags,
                                           SECURITY_NATIVE_DREP,
                                           &_hContext,
                                           &MessageOut,
                                           &dwContextAttributes,
                                           &tsExpiry );
        ConditionalRemoveWorkerThread();
        IF_DEBUG( SCHANNEL_CALLS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "AcceptSecurityContext() secStatus=0x%x\n",
                        secStatus
                        ));
        }

        if ( SUCCEEDED( secStatus ) )
        {
            _cbHeader = 0;
            _cbTrailer = 0;
            _cbBlockSize = 0;
            _cbMaximumMessage = 0;
                
            _fValidContext = TRUE;
            _sslState = SSL_STATE_HANDSHAKE_IN_PROGRESS;
        }                                               
    }
    else
    {
        DBG_ASSERT( _sslState == SSL_STATE_HANDSHAKE_IN_PROGRESS );
        
        //
        // We already have a valid context.  We can directly call 
        // AcceptSecurityContext()!
        //
            
        hOutContext = _hContext;
        
        DBG_ASSERT( _fValidContext );
        
        ConditionalAddWorkerThread();
        secStatus = AcceptSecurityContext( QueryCredentials(),
                                           &_hContext,
                                           &MessageIn,
                                           dwFlags,
                                           SECURITY_NATIVE_DREP,
                                           &hOutContext,
                                           &MessageOut,
                                           &dwContextAttributes,
                                           &tsExpiry );
        ConditionalRemoveWorkerThread();                                   
        IF_DEBUG( SCHANNEL_CALLS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "AcceptSecurityContext() secStatus=0x%x\n",
                        secStatus
                        ));
        }

        
        if ( SUCCEEDED( secStatus ) )
        {
        if ( memcmp(&_hContext,
                    &hOutContext,
                    sizeof( _hContext ) != 0 ) )
        {
            //
            // we always expect schannel to return same context handle
            // if it doesn't then we better bail out
            //
            IF_DEBUG( FLAG_ERROR )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "AcceptSecurityContext() return context different from the one on input\n"
                            ));
            }
            DBG_ASSERT( FALSE );            
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
            goto ExitPoint;
        }
        }
    }
    
    //
    // Either way, the secStatus tells us how to proceed
    //

    if ( SUCCEEDED( secStatus ) )
    {
        //
        // AcceptSecurityContext succeeded
        //
        //
        // We haven't failed yet.  But we may not be complete.  First 
        // send back any data to the client
        //  

        if ( OutBuffers[ 0 ].pvBuffer != NULL &&   
             OutBuffers[ 0 ].cbBuffer != 0 )
        {
            //
            // the following asynchronous Write will not do anything
            // upon completion other then to simply delete OVERLAPPED_CONTEXT
            // There will be no outstanding RawRead (that would cause trouble)
            // because we are in RawRead completion handling phase
            // That's why it is safe to continue with execution
            // (typically after async there is return and all the cleanup
            // or whatever needs to be done happens in completion)
            // This async call was originally synchronous and by making
            // it ASYNC we eliminate long blocking problem with
            // slow client while leaving the rest of original synchronous
            // execution intact.  
            //

            //
            // FreeContextBuffer will have to be called in the callback function
            // upon completion
            //
            hr = QueryFiltChannelContext()->DoRawWrite( 
                                               UL_CONTEXT_FLAG_ASYNC |
                                               UL_CONTEXT_FLAG_COMPLETION_CALLBACK,
                                               OutBuffers[ 0 ].pvBuffer,
                                               OutBuffers[ 0 ].cbBuffer,
                                               NULL, // pcbWritten 
                                               OnHandshakeRawWriteCompletion,
                                               OutBuffers[ 0 ].pvBuffer );
            
            if ( FAILED( hr ) )
            {
                goto ExitPoint;
            }
            else
            {
                //
                // DoRawWrite completion will take care of cleanup
                //
                OutBuffers[ 0 ].pvBuffer = NULL;
                OutBuffers[ 0 ].cbBuffer = 0;
            }
        }
        
        if ( secStatus == SEC_E_OK )
        {
            //
            // We must be done with handshake
            //

            hr = DoHandshakeCompleted();

            if ( FAILED( hr ) )
            {
                goto ExitPoint;
            }
        }
        
        //
        // If the input buffer has more info to be SChannel'ized, then do 
        // so now.  If we haven't completed handshake, then call DoHandShake
        // again.  Otherwise, call DoDecrypt
        //
        
        if ( InBuffers[ 1 ].BufferType == SECBUFFER_EXTRA )
        {

            IF_DEBUG( SCHANNEL_CALLS )
            {
                for ( int i = 1; i < 4; i++ )
                {
                    if( InBuffers[ i ].BufferType != 0 )
                    {
                        DBGPRINTF(( DBG_CONTEXT,
                                    "AcceptSecurityContext returned extra buffer"
                                    " - %d bytes buffer type: %d\n",
                                    InBuffers[ i ].cbBuffer,
                                    InBuffers[ i ].BufferType
                        ));
                    }
                }
            }

            //
            // We better have valid extra data
            // only cbBuffer is used, pvBuffer is not used with SECBUFFER_EXTRA 
            //
            DBG_ASSERT( InBuffers[ 1 ].cbBuffer != 0 );

            //    
            // Move extra data right after decrypted data (if any)
            //
            
            memmove( pRawStreamInfo->pbBuffer + _cbDecrypted,
                     pRawStreamInfo->pbBuffer + pRawStreamInfo->cbData 
                     - InBuffers[ 1 ].cbBuffer,
                       InBuffers[ 1 ].cbBuffer
                   );

            //
            // Now we have to adjust pRawStreamInfo->cbData and _cbToBeProcessedOffset
            // 
            
            pRawStreamInfo->cbData = ( _cbDecrypted +
                                       InBuffers[ 1 ].cbBuffer );

            _cbToBeProcessedOffset = _cbDecrypted;
            
            *pfExtraData = TRUE;

            //
            // caller has to detect that some data is
            // still in the buffer not processed and
            //
            hr = S_OK;
            goto ExitPoint;
        }
        else  // no extra buffer
        {
            //
            // There is no extra data to be processed
            // If we got here as the result of renegotiation
            // there may be some decrypted data in StreamInfo buffer already

            //
            // (without renegotiation _cbDecryted must always be 0
            // because SEC_I_RENEGOTIATE is the only way to get 
            // from DoDecrypt() to DoHandshake() )
            //
            
            DBG_ASSERT ( _fRenegotiate || _cbDecrypted == 0 );
            
            pRawStreamInfo->cbData = _cbDecrypted;
            _cbToBeProcessedOffset = _cbDecrypted;

            if ( _sslState != SSL_STATE_HANDSHAKE_COMPLETE )
            {
                //
                // If we have no more data, and we still haven't completed the
                // handshake, then read some more data
                //
        
                *pfReadMore = TRUE;
                hr = S_OK;
                goto ExitPoint;
            }
        }
        //
        // final return from DoHandshake on handshake completion
        // Cleanup _cbDecrypted and _cbToBeProcessedOffset to make 
        // sure that next ProcessRawReadData() will work fine    
        //
        
        _cbToBeProcessedOffset = 0;
        _cbDecrypted = 0;
        
        hr = S_OK;
        goto ExitPoint;
    }
    else
    {
        //
        // Note: _OutBuffers[ 0 ].pvBuffer may be changed in AcceptSecurityContext
        // even if error is returned. 
        // Per JBanes, FreeContextBuffer() should be called in the case of error
        // only if ASC_RET_EXTENDED_ERROR flag is set in ContextAttributes.
        // Otherwise value should be ignored. We will NULL it out to prevent problems
        //

        if ( !( dwContextAttributes & ASC_RET_EXTENDED_ERROR ) )
        {
            OutBuffers[0].pvBuffer = NULL;
            OutBuffers[0].cbBuffer = 0;

        }   
        
        //
        // AcceptSecurityContext() failed!
        //

        if ( secStatus == SEC_E_INCOMPLETE_MESSAGE )
        {
            *pfReadMore = TRUE;
            hr = S_OK;
            goto ExitPoint;
        }
        else
        {
            IF_DEBUG( FLAG_ERROR )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "AcceptSecurityContext() failed with secStatus=0x%x\n",
                            secStatus
                            ));
            }
            
        
            //
            // Maybe we can send a more useful message to the client
            //
        
            if ( dwContextAttributes & ASC_RET_EXTENDED_ERROR )
            {
                if ( OutBuffers[ 0 ].pvBuffer!= NULL &&
                     OutBuffers[ 0 ].cbBuffer != 0 )
                {    
                    //
                    // FreeContextBuffer will have to be called in the callback function
                    // upon completion
                    //
                    hr = QueryFiltChannelContext()->DoRawWrite( 
                                                       UL_CONTEXT_FLAG_ASYNC |
                                                       UL_CONTEXT_FLAG_COMPLETION_CALLBACK,
                                                       OutBuffers[ 0 ].pvBuffer,
                                                       OutBuffers[ 0 ].cbBuffer,
                                                       NULL, // pcbWritten 
                                                       OnHandshakeRawWriteCompletion,
                                                       OutBuffers[ 0 ].pvBuffer );
            
                    if ( FAILED( hr ) )
                    {
                        goto ExitPoint;
                    }
                    else
                    {
                        //
                        // DoRawWrite completion will take care of cleanup
                        //
                        OutBuffers[ 0 ].pvBuffer = NULL;
                        OutBuffers[ 0 ].cbBuffer = 0;
                    }
                }
            }
        }
        hr = secStatus;
    }
    
ExitPoint:    
    if ( OutBuffers[ 0 ].pvBuffer != NULL )
    {   
        FreeContextBuffer( OutBuffers[ 0 ].pvBuffer );
        OutBuffers[ 0 ].pvBuffer = NULL;
        OutBuffers[ 0 ].cbBuffer = 0;
    }    
    return hr;    
}


HRESULT
SSL_STREAM_CONTEXT::DoHandshakeCompleted()
{
    HRESULT                     hr          = S_OK;
    SECURITY_STATUS             secStatus   = SEC_E_OK;
    SecPkgContext_StreamSizes   StreamSizes;
    HTTP_FILTER_BUFFER          ulFilterBuffer;

    
    _sslState = SSL_STATE_HANDSHAKE_COMPLETE;

    //
    // Get some buffer size info for this connection.  We only need
    // to do this on completion of the initial handshake, and NOT
    // subsequent renegotiation handshake (if any)
    //             

    if ( !_cbHeader && !_cbTrailer )
    {
        secStatus = QueryContextAttributes( &_hContext,
                                            SECPKG_ATTR_STREAM_SIZES,
                                            &StreamSizes );
        if ( FAILED( secStatus ) )
        {
            return secStatus;
        }            
    
        _cbHeader = StreamSizes.cbHeader;
        _cbTrailer = StreamSizes.cbTrailer;
        _cbBlockSize = StreamSizes.cbBlockSize;
        _cbMaximumMessage = StreamSizes.cbMaximumMessage;
    }

    //
    // Build up a message for the application indicating stuff
    // about the negotiated connection
    //
    // If this is a renegotiate request, then we have already sent
    // and calculated the SSL_INFO, so just send the CERT_INFO
    //

    if ( !_fRenegotiate )
    {
        //
        // send SSL info only if not in renegotiation loop 
        // because otherwise http.sys has the info already
        //
        
        hr = BuildSslInfo();
        if ( FAILED( hr ) )
        {
            return hr;
        }
    
        ulFilterBuffer.BufferType = HttpFilterBufferSslInitInfo;
        ulFilterBuffer.pBuffer = (PBYTE) &_ulSslInfo;
        ulFilterBuffer.BufferSize = sizeof( _ulSslInfo );

        hr = QueryFiltChannelContext()->DoAppWrite( UL_CONTEXT_FLAG_SYNC,
                                       &ulFilterBuffer,
                                       NULL );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }

    //
    // Pass client certificate information to http.sys
    // if client certificates are required on the site level then
    // inform about client certificate even in the case when 
    // client cert is not present not to cause double negotiation
    // 
    
    if ( _pClientCert != NULL || 
         _fRenegotiate || 
         _pEndpointConfig->QueryNegotiateClientCert() )
    {
        //
        // Renegotiation time is monitored by timer
        // because http.sys doesn't monitor this particular
        // code path because of the way filter works
        // 

        QueryFiltChannelContext()->StopTimeoutTimer();

        if ( SUCCEEDED( RetrieveClientCertAndToken() ) )
        {
            hr = BuildClientCertInfo();
            if ( FAILED( hr ) )
            {
                return hr;
            }
        }

        //
        // CODEWORK:
        // It would be better to eliminate HttpFilterBufferSslClientCertAndMap
        // and let HTTP.SYS to check on token value. If it is NULL then mapping
        // did not happen
        //
        
        if ( _ulCertInfo.Token != NULL )
        {
            ulFilterBuffer.BufferType = HttpFilterBufferSslClientCertAndMap;
        }
        else
        {
            ulFilterBuffer.BufferType = HttpFilterBufferSslClientCert;
        }

        //
        // If client certificate was not negotiated, then  structure will be empty.
        // HTTP.SYS is able to handle it.
        //
    
        ulFilterBuffer.pBuffer = (PBYTE) &_ulCertInfo;
        ulFilterBuffer.BufferSize = sizeof( _ulCertInfo );

        //
        // Write the client certificate information to the application
        // (it will be cached by HTTP.sys for the lifetime of the connection)
        //

        hr = QueryFiltChannelContext()->DoAppWrite( UL_CONTEXT_FLAG_SYNC,
                                                    &ulFilterBuffer,
                                                    NULL );
        if ( FAILED( hr ) )
        {
            return hr;
        }

    }

    return hr;

}


HRESULT
SSL_STREAM_CONTEXT::DoRenegotiate(
    VOID
)
/*++

Routine Description:

    Trigger a renegotiate for a client certificate

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    SECURITY_STATUS             secStatus = SEC_E_OK;
    CtxtHandle                  hOutContext;
    DWORD                       dwContextAttributes = 0;
    TimeStamp                   tsExpiry;
    DWORD                       dwFlags = SSL_ASC_FLAGS | 
                                          ASC_REQ_MUTUAL_AUTH;
    HRESULT                     hr = S_OK;
    
    // Buffers used for SSL Handshake (incoming handshake blob)
    // 4 is the schannel magic number
    SecBufferDesc               MessageIn;
    SecBuffer                   InBuffers[ 4 ];
    // Buffers used for SSL Handshake (outgoing handshake blob)    
    // 4 is the schannel magic number
    SecBufferDesc               MessageOut;
    SecBuffer                   OutBuffers[ 4 ];
        
    DBG_ASSERT( _pEndpointConfig != NULL );
    
    //
    // Remember that we're renegotiating since we now have to pass the 
    // MUTUAL_AUTH flag into AcceptSecurityContext() from here on out.  Also
    // we can only request renegotiation once per connection
    //

    DBG_ASSERT( _fRenegotiate == FALSE );

    _fRenegotiate = TRUE;

    QueryFiltChannelContext()->StartTimeoutTimer();

    //
    // Try to get the client certificate.  If we don't, that's OK. We will 
    // renegotiate
    //

    hr = RetrieveClientCertAndToken();
    if ( SUCCEEDED ( hr ) )
    {
        //
        // we have client certificate available for this session
        // there is no need to continue with renegotiation
        //
        
        hr = DoHandshakeCompleted();
        return hr;
    }

    //
    // Reset the HRESULT 
    // Previous error failing to retrieve client certificate is OK,
    // it just means that renegotiation is necessary since
    // no client certificate is currently available
    
    hr = S_OK;
    
    //
    // Restart the handshake
    //

    //
    // Setup input & output buffers for AcceptSecurityContext call
    //
    
    MessageIn.ulVersion = SECBUFFER_VERSION;
    MessageIn.cBuffers = 4;
    MessageIn.pBuffers = InBuffers;

    InBuffers[0].BufferType = SECBUFFER_TOKEN;
    InBuffers[0].pvBuffer   = "";
    InBuffers[0].cbBuffer   = 0;
    InBuffers[1].BufferType = SECBUFFER_EMPTY;
    InBuffers[2].BufferType = SECBUFFER_EMPTY;
    InBuffers[3].BufferType = SECBUFFER_EMPTY;

    
    MessageOut.ulVersion = SECBUFFER_VERSION;
    MessageOut.cBuffers = 4;
    MessageOut.pBuffers = OutBuffers;

    OutBuffers[0].pvBuffer = NULL;
    OutBuffers[0].cbBuffer = NULL;
    OutBuffers[0].BufferType = SECBUFFER_EMPTY;
    OutBuffers[1].BufferType = SECBUFFER_EMPTY;
    OutBuffers[2].BufferType = SECBUFFER_EMPTY;
    OutBuffers[3].BufferType = SECBUFFER_EMPTY;

    
    hOutContext = _hContext;
    ConditionalAddWorkerThread();
    secStatus = AcceptSecurityContext( QueryCredentials(),
                                       &_hContext,
                                       &MessageIn,
                                       dwFlags,
                                       SECURITY_NATIVE_DREP,
                                       &hOutContext,
                                       &MessageOut,
                                       &dwContextAttributes,
                                       &tsExpiry );
    ConditionalRemoveWorkerThread();
    IF_DEBUG( SCHANNEL_CALLS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "AcceptSecurityContext() secStatus=0x%x\n",
                    secStatus
                    ));
    }


    if ( secStatus == SEC_E_UNSUPPORTED_FUNCTION )
    {
        //
        //  Renegotiation is not suppported for current protocol
        // (SSL2 would be example of such protocol)
        //  Change state to HandhakeCompleted        
        //
        hr = DoHandshakeCompleted();
    }
    else if ( SUCCEEDED( secStatus ) )
    {
        if ( memcmp( &_hContext,
                     &hOutContext,
                     sizeof( _hContext ) != 0 ) )
        {
            //
            // we always expect schannel to return same context handle
            // if it doesn't then we better bail out
            //
            IF_DEBUG( FLAG_ERROR )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "AcceptSecurityContext() return context different from the one on input\n"
                            ));
            }
            DBG_ASSERT( FALSE );            
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
            goto ExitPoint;
        }
       
            
        if ( OutBuffers[0].pvBuffer != NULL &&
             OutBuffers[0].cbBuffer != 0 )
        {   
            //
            // _fExpectRenegotiationFromClient flag will be used to eliminate
            // client triggered renegotiation by enabling client data to cause
            // renegotiation only if fExpectRenegotiationFromClient is already set
            // That will prove that it is server initiated renegotiation
            // If we don't prevent client triggered renegotiation there may
            // be some wierd race conditions because client triggered renegotiation
            // could interfere with the outgoing data stream (due to full duplex 
            // for incoming and outgoing data)
            // Do interlocked because we check the value on the incoming data handling path
            // in the DecryptMessage() 
            //
            // Note: It is possible that after _fExpectRenegotiationFromClient is set
            // client may try to send renegotiation request (client initiated renegotiation)
            // Our flag is set already so that before we execute DoRawWrite
            // there could be a thread executing DoHandshake
            // Care must be used when modifying anything past the InterlockedExchange
            // to eliminate any potential race with DoHandhshake function
            //

            InterlockedExchange( (LONG *)&_fExpectRenegotiationFromClient, (LONG) TRUE );

            hr = QueryFiltChannelContext()->DoRawWrite( 
                                               UL_CONTEXT_FLAG_ASYNC |
                                               UL_CONTEXT_FLAG_COMPLETION_CALLBACK,
                                               OutBuffers[0].pvBuffer,
                                               OutBuffers[0].cbBuffer,
                                               NULL, // pcbWritten 
                                               OnHandshakeRawWriteCompletion,
                                               OutBuffers[0].pvBuffer );
    
            if ( FAILED( hr ) )
            {
                goto ExitPoint;
            }
            else
            {
                // callback after DoRawWrite is responsible to cleanup pvOutBuffer
                OutBuffers[0].pvBuffer = NULL;
                OutBuffers[0].cbBuffer = 0;
            }

        }
        hr = secStatus;
    }
    else
    {
        IF_DEBUG( FLAG_ERROR )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "AcceptSecurityContext() for renegotiation failed with secStatus=0x%x\n",
                        secStatus
                        ));
        }
  
        if ( dwContextAttributes & ASC_RET_EXTENDED_ERROR )
        {
            if ( OutBuffers[0].pvBuffer != NULL &&
                 OutBuffers[0].cbBuffer != 0 )
            {    
                 hr = QueryFiltChannelContext()->DoRawWrite( 
                                               UL_CONTEXT_FLAG_ASYNC |
                                               UL_CONTEXT_FLAG_COMPLETION_CALLBACK,
                                               OutBuffers[0].pvBuffer,
                                               OutBuffers[0].cbBuffer,
                                               NULL, // pcbWritten 
                                               OnHandshakeRawWriteCompletion,
                                               OutBuffers[0].pvBuffer );
                if ( FAILED( hr ) )
                {
                    goto ExitPoint;
                }
                else
                {
                    // callback after DoRawWrite is responsible to cleanup pvOutBuffer
                    OutBuffers[0].pvBuffer = NULL;
                    OutBuffers[0].cbBuffer = 0;
                }

            }
        }
        else
        {
            //
            // Note: _OutBuffers[ 0 ].pvBuffer may be changed in AcceptSecurityContext
            // even if error is returned. 
            // Per JBanes, FreeContextBuffer() should be called in the case of error
            // only if ASC_RET_EXTENDED_ERROR flag is set in ContextAttributes.
            // Otherwise value should be ignored. We will NULL it out to prevent problems
            //
            OutBuffers[0].pvBuffer = NULL;
            OutBuffers[0].cbBuffer = 0;
        }
        hr = secStatus;
    }

ExitPoint:
    if ( OutBuffers[0].pvBuffer != NULL )
    {
        FreeContextBuffer( OutBuffers[0].pvBuffer );
        OutBuffers[0].pvBuffer = NULL;
    }
    return hr;
}


HRESULT
SSL_STREAM_CONTEXT::DoDecrypt(
    RAW_STREAM_INFO *           pRawStreamInfo,
    BOOL *                      pfReadMore,
    BOOL *                      pfComplete,
    BOOL *                      pfExtraData
)
/*++

Routine Description:

    Decrypt some data

Arguments:

    pRawStreamInfo - Raw data buffer
    pfReadMore - Set to true if we should read more data
    pfComplete - Set to true if we should disconnect

Return Value:

    HRESULT

--*/
{
    SECURITY_STATUS         secStatus = SEC_E_OK;
    INT                     iExtra;
    BOOL                    fDecryptAgain = TRUE;
    UCHAR                   FirstByte = 0;   //used only for debug output 

    // Buffers used for SSL Handshake (incoming handshake blob)
    // 4 is the schannel magic number
    SecBufferDesc           Message;
    SecBuffer               Buffers[ 4 ];

    if ( pRawStreamInfo == NULL ||
         pfReadMore == NULL ||
         pfComplete == NULL ||
         pfExtraData == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    *pfReadMore  = FALSE;
    *pfComplete  = FALSE;
    *pfExtraData = FALSE;

    IF_DEBUG( SCHANNEL_CALLS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "DoDecrypt(): _cbDecrypted = %d, _cbToBeProcessedOffset=%d\n",
                    _cbDecrypted,
                    _cbToBeProcessedOffset
                 ));
    }

    //
    // Setup an DecryptMessage call.  The input buffer is the _buffRaw plus 
    // an offset.  The offset is non-zero if we had to do another read to
    // get more data for a previously incomplete message
    //

    if( pRawStreamInfo->cbData < _cbToBeProcessedOffset )
    {
        //
        // Inconsisent state of the SSL_STREAM_CONTEXT
        // This should never really happen, but because we
        // execute in lsass we don't want to see wrong offset calculations
        // cause much trouble in lsass
        //
        IF_DEBUG ( FLAG_ERROR ) 
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Error: HttpFilter detected unexpected offset in it's internal data (connection will be closed)\n"
                        ));
        }

        
        DBG_ASSERT( FALSE );
        
        return HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
    }

    //
    // Prepare message buffers to be passed to the DecryptMessage
    //
    
    Message.ulVersion = SECBUFFER_VERSION;
    Message.cBuffers = 4;
    Message.pBuffers = Buffers;

    Buffers[ 0 ].pvBuffer = pRawStreamInfo->pbBuffer + _cbToBeProcessedOffset;
    Buffers[ 0 ].cbBuffer = pRawStreamInfo->cbData - _cbToBeProcessedOffset;
    Buffers[ 0 ].BufferType = SECBUFFER_DATA;
    
    Buffers[ 1 ].BufferType = SECBUFFER_EMPTY;
    Buffers[ 2 ].BufferType = SECBUFFER_EMPTY;
    Buffers[ 3 ].BufferType = SECBUFFER_EMPTY;

    while ( fDecryptAgain )
    {
        fDecryptAgain = FALSE;
        
        IF_DEBUG( SCHANNEL_CALLS )
        {
            //
            // remember first byte because Decrypt will alter it
            //
            FirstByte = (unsigned char) *((char *)Buffers[ 0 ].pvBuffer);
        }

        secStatus = DecryptMessage( &_hContext,
                                   &Message,
                                   0,
                                   NULL );
        IF_DEBUG( SCHANNEL_CALLS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "DecryptMessage( bytes:%d, first byte:0x%x ) secStatus=0x%x\n",
                        pRawStreamInfo->cbData - _cbToBeProcessedOffset,
                        FirstByte,
                        secStatus
                        ));
        }

        if ( FAILED( secStatus ) )
        {
            if ( secStatus == SEC_E_INCOMPLETE_MESSAGE )
            {
                //
                // Setup another read since the message is incomplete.  Remember
                // where the new data is going to since we only pass this data
                // to the next DecryptMessage call
                //
                
                _cbToBeProcessedOffset = (DWORD) DIFF( (BYTE *)Buffers[ 0 ].pvBuffer -
                                                pRawStreamInfo->pbBuffer );

                QueryFiltChannelContext()->SetNextRawReadSize( Buffers[ 1 ].cbBuffer );
                
                *pfReadMore = TRUE;
                
                return S_OK; 
            }                
            IF_DEBUG( FLAG_ERROR )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "DecryptMessage() failed with secStatus=0x%x\n",
                            secStatus
                            ));
            }

            return secStatus;
        }

        if ( secStatus == SEC_E_OK )
        { 
            //
            // Encrypted data contains header and trailer
            // AppWrite expects continuous buffer
            // so we have to move currently decrypted message block
            // just after the already Decrypted data (if any - otherwise the 
            // begining of the buffer)
            //
        
            memmove( pRawStreamInfo->pbBuffer + _cbDecrypted,
                     Buffers[ 1 ].pvBuffer,
                     Buffers[ 1 ].cbBuffer );
                 
            _cbDecrypted += Buffers[ 1 ].cbBuffer;
        }

        //
        // Locate extra data (may be available)
        //
        
        iExtra = 0;
        for ( int i = 1; i < 4; i++ )
        {     
            IF_DEBUG( SCHANNEL_CALLS )
            {
                if( Buffers[ i ].BufferType != 0 )
                {
                    DBGPRINTF(( DBG_CONTEXT,
                                "DecryptMessage returned extra buffer"
                                " - %d bytes buffer type: %d\n",
                                Buffers[ i ].cbBuffer,
                                Buffers[ i ].BufferType
                                ));
                }
            }
            
            if ( Buffers[ i ].BufferType == SECBUFFER_EXTRA )
            {
                iExtra = i;
                break;
            }
        }
        
        if ( iExtra != 0 )
        {
            //
            // Process extra buffer 
            //
            
            _cbToBeProcessedOffset = (DWORD) DIFF( (PBYTE) Buffers[ iExtra ].pvBuffer - 
                                            pRawStreamInfo->pbBuffer );
            
            if ( secStatus != SEC_I_RENEGOTIATE )
            {
                //
                // There are more message blocks in the blob received from client
                //
                Buffers[ 0 ].pvBuffer = Buffers[ iExtra ].pvBuffer;
                Buffers[ 0 ].cbBuffer = Buffers[ iExtra ].cbBuffer;
                Buffers[ 0 ].BufferType = SECBUFFER_DATA;
                Buffers[ 1 ].BufferType = SECBUFFER_EMPTY;
                Buffers[ 2 ].BufferType = SECBUFFER_EMPTY;
                Buffers[ 3 ].BufferType = SECBUFFER_EMPTY;

                fDecryptAgain = TRUE;
                continue;
            }     
            else    // secStatus == SEC_I_RENEGOTIATE 
            {
                //
                // we will accept renegotiation
                // only if _fExpectRenegotiationFromClient is already set
                // That means that renegotiation was started by server
                // We reject client initiated renegotiations because
                // that may cause problems with our state handling
                // and could possibly make us prone to attacks
                // Also reset _fExpectRenegotiationFromClient to FALSE so that
                // client is not allowed to try more than once

                if ( InterlockedExchange( (LONG *)&_fExpectRenegotiationFromClient, (LONG) FALSE ) )
                {
                    //
                    // If a renegotiation is triggered, resume the handshake state
                    //

                    _sslState = SSL_STATE_HANDSHAKE_IN_PROGRESS;
                    //
                    // Caller has to detect that some data is
                    // still in the buffer not processed and
                    // That will signal to call DoHandshake() 
                    // for that extra data
                    //
                    *pfExtraData = TRUE;
                    return S_OK;
                }
                else
                {
                    secStatus = SEC_E_UNSUPPORTED_FUNCTION;
                    if ( ( DEBUG_FLAG_ERROR & GET_DEBUG_FLAGS() ) 
                           && FAILED(secStatus) )
                    {
                        DBGPRINTF(( DBG_CONTEXT,
                            "Client initiated renegotiation is not supported by IIS. secStatus=0x%x\n",
                            secStatus
                            ));
                    }
                    
                    return secStatus;
                    
                }
        
            }
        }
    }
    //
    // there would have been extra data with SEC_I_RENEGOTIATE
    // so we must never get here when renegotiating
    //
    DBG_ASSERT( secStatus != SEC_I_RENEGOTIATE );

    //
    // Adjust cbData to include only decrypted data
    //
    pRawStreamInfo->cbData = _cbDecrypted;

    //
    // We have final decrypted buffer and no extra data left
    // Cleanup _cbDecrypted and _cbToBeProcessedOffset to make sure that 
    // next ProcessRawReadData() will work fine.    
    //
    
    _cbDecrypted = 0;
    _cbToBeProcessedOffset = 0;

 
    return S_OK;
}


HRESULT
SSL_STREAM_CONTEXT::DoEncrypt(
    RAW_STREAM_INFO *           pRawStreamInfo,
    BOOL *                      pfComplete
)
/*++

Routine Description:

    Encrypt data from the application

Arguments:

    pRawStreamInfo - Raw data buffer
    pfComplete - Set to true if we should disconnect

Return Value:

    HRESULT

--*/
{
    SECURITY_STATUS         secStatus = SEC_E_OK;
    // number of chunks the data to be encrypted will be split to
    DWORD                   dwChunks = 0;
    // current Data chunk size to be encrypted
    DWORD                   cbDataChunk = 0;
    // bytes already encrypted from the source
    DWORD                   cbDataProcessed = 0;
    // offset to *pbufRawWrite where new chunk should be placed
    DWORD                   cbRawWriteOffset = 0;
    // buffer acquired from FILTER_CHANNEL_CONTEXT to store data for RawWrite
    // it is necessary to use buffer owned by FILTER_CHANNEL_CONTEXT to 
    // allow 2 outstanding RawWrites
    PBYTE                   pbRawWrite = NULL;
    DWORD                   cbRawWrite = 0;
    HRESULT                 hr = E_FAIL;
    // Buffer for encrypting clear text data from application
    // to be sent back to client
    // 4 is magic number coming from schannel
    SecBufferDesc           Message;
    SecBuffer               EncryptBuffers[ 4 ];


    if ( pRawStreamInfo == NULL ||
         pfComplete == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    *pfComplete = FALSE;

    //
    // Each protocol has limit on maximum size of message 
    // that can be encrypted with one EncryptMessage() call
    //

    DBG_ASSERT( _cbMaximumMessage != 0 );

    //
    // Calculate number of chunks based on _cbMaximumMessage
    //

    dwChunks = pRawStreamInfo->cbData / _cbMaximumMessage;
    if ( pRawStreamInfo->cbData % _cbMaximumMessage != 0 )
    {
        dwChunks++;
    }

    //
    // ask FILTER_CHANNEL_CONTEXT for one buffer for RawWrite
    // (FILTER_CHANNEL_CONTEXT maintains 2 buffer to allow 2 outstanding RawWrites
    // to handle the TCP's DELAYED_ACK issue - see Windows Bugs 394511)
    // buffer doesn't have to be released in the error case because
    // error will cause connection to get closed and FILTER_CHANNEL_CONTEXT will
    // handle cleanup. 
    //

    //
    // Allocate a large enough buffer for encrypted data
    // ( remember that each chunk needs header and trailer )
    //

    cbRawWrite = pRawStreamInfo->cbData + 
                 dwChunks  * _cbHeader + 
                 dwChunks  * _cbTrailer;
    
    hr = QueryFiltChannelContext()->AcquireRawWriteBuffer(
                                &pbRawWrite,
                                cbRawWrite );

    if ( FAILED ( hr ) )
    {
        return hr;
    }

    DBG_ASSERT( pbRawWrite != NULL );


    //
    // Loop to encrypt required data in chunks each not exceeding _cbMaximumMessage
    //
    
    for ( DWORD dwCurrentChunk = 0; dwCurrentChunk < dwChunks; dwCurrentChunk++ )
    {
        DBG_ASSERT( cbRawWrite > cbRawWriteOffset );
    
        cbDataChunk = min( pRawStreamInfo->cbData - cbDataProcessed, 
                           _cbMaximumMessage ); 


        memcpy( pbRawWrite + _cbHeader + cbRawWriteOffset,
                pRawStreamInfo->pbBuffer + cbDataProcessed,
                cbDataChunk );

        //
        // Setup buffer for app data to be encrypted
        //

        Message.ulVersion = SECBUFFER_VERSION;
        Message.cBuffers = 4;
        Message.pBuffers = EncryptBuffers;

    
        EncryptBuffers[ 0 ].pvBuffer = pbRawWrite +
                                        cbRawWriteOffset;
        EncryptBuffers[ 0 ].cbBuffer = _cbHeader;
        EncryptBuffers[ 0 ].BufferType = SECBUFFER_STREAM_HEADER;
    
        EncryptBuffers[ 1 ].pvBuffer = pbRawWrite +
                                        _cbHeader +
                                        cbRawWriteOffset; 
        EncryptBuffers[ 1 ].cbBuffer = cbDataChunk;
        EncryptBuffers[ 1 ].BufferType = SECBUFFER_DATA;
    
        EncryptBuffers[ 2 ].pvBuffer = pbRawWrite +
                                        _cbHeader +
                                        cbDataChunk +
                                        cbRawWriteOffset;
        EncryptBuffers[ 2 ].cbBuffer = _cbTrailer;
        EncryptBuffers[ 2 ].BufferType = SECBUFFER_STREAM_TRAILER;

        EncryptBuffers[ 3 ].BufferType = SECBUFFER_EMPTY;

        secStatus = EncryptMessage( &_hContext,
                                 0,
                                 &Message,
                                 0 );

        IF_DEBUG( SCHANNEL_CALLS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "EncryptMessage() secStatus=0x%x\n",
                        secStatus
                        ));
        }
    

        if(SUCCEEDED(secStatus))
        {
            //
            // next chunk was successfully encrypted
            //
            
            cbDataProcessed  += cbDataChunk;
            cbRawWriteOffset += EncryptBuffers[ 0 ].cbBuffer +
                                EncryptBuffers[ 1 ].cbBuffer +
                                EncryptBuffers[ 2 ].cbBuffer;
        }
        else
        {
            //
            // Set cbData to 0 just for the case that caller ignored error 
            // and tried to send not encrypted data to client 
            //

            pRawStreamInfo->cbData = 0;

            IF_DEBUG( FLAG_ERROR )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "EncryptMessage() failed with secStatus=0x%x\n",
                            secStatus
                            ));
            }

            return secStatus;
        }
    }

    //
    // Replace the raw stream buffer with the encrypted data
    //

    pRawStreamInfo->pbBuffer = pbRawWrite;
    pRawStreamInfo->cbBuffer = cbRawWrite;
    pRawStreamInfo->cbData   = cbRawWriteOffset;
   
    return S_OK;
}


HRESULT
SSL_STREAM_CONTEXT::BuildSslInfo(
    VOID
)
/*++

Routine Description:

    Build UL_SSL_INFO structure based on Schannel context handle

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    SECURITY_STATUS                 secStatus;
    SecPkgContext_ConnectionInfo    ConnectionInfo;
    SERVER_CERT *                   pServerCert = NULL;
    HRESULT                         hr = S_OK;

    //
    // Negotiated key size
    // 

    //
    // Negotiated key size
    // 
    
    if ( _ulSslInfo.ConnectionKeySize == 0 )
    {
        secStatus = QueryContextAttributes( &_hContext,
                                            SECPKG_ATTR_CONNECTION_INFO,
                                            &ConnectionInfo );
        if ( SUCCEEDED( secStatus ) )
        {
            _ulSslInfo.ConnectionKeySize = (USHORT) ConnectionInfo.dwCipherStrength;
        }
    }
    
    //
    // A bunch of parameters are based off the server certificate.  Get that
    // cert now
    //
    
    DBG_ASSERT( _pEndpointConfig != NULL );
    
    pServerCert = _pEndpointConfig->QueryServerCert();
    DBG_ASSERT( pServerCert != NULL );
    
    //
    // Server cert strength
    //
    
    if ( _ulSslInfo.ServerCertKeySize == 0 )
    {
        _ulSslInfo.ServerCertKeySize = pServerCert->QueryPublicKeySize();
    }

    //
    // Server Cert Issuer
    //
    
    if ( _ulSslInfo.pServerCertIssuer == NULL )
    {
        DBG_ASSERT( _ulSslInfo.ServerCertIssuerSize == 0 );
        
        _ulSslInfo.pServerCertIssuer = pServerCert->QueryIssuer()->QueryStr();
        _ulSslInfo.ServerCertIssuerSize = pServerCert->QueryIssuer()->QueryCCH();
    }
    
    //
    // Server Cert subject
    //
    
    if ( _ulSslInfo.pServerCertSubject == NULL )
    {
        DBG_ASSERT( _ulSslInfo.ServerCertSubjectSize == 0 );
        
        _ulSslInfo.pServerCertSubject = pServerCert->QuerySubject()->QueryStr(),
        _ulSslInfo.ServerCertSubjectSize = pServerCert->QuerySubject()->QueryCCH();
    }
    
    return hr;
}


HRESULT
SSL_STREAM_CONTEXT::RetrieveClientCertAndToken(
    VOID
)
/*++

Routine Description:

    Query client certificate and token from the SSL context

Arguments:

    none
    
Return Value:

    HRESULT

--*/
{
    SECURITY_STATUS secStatus = SEC_E_OK;

    //
    // If client certificate has already been retrieved then simply return
    // with success
    //
    
    if ( _pClientCert != NULL )
    {
        return SEC_E_OK;
    }

    secStatus = QueryContextAttributes( &_hContext,
                                        SECPKG_ATTR_REMOTE_CERT_CONTEXT,
                                        &_pClientCert );
    if ( SUCCEEDED( secStatus ) )
    {
        DBG_ASSERT( _pClientCert != NULL );
    }
    else
    {
        goto ExitPoint;
    }

    //
    // If we got a client cert and mapping is enabled, then
    // request Schannel mapping
    //

    if( _ulCertInfo.Token != NULL )
    {
        CloseHandle( _ulCertInfo.Token );
        _ulCertInfo.Token = NULL;
    }

    //
    // Only DS mapper is executed in streamfilt
    // IIS mapper is executed in w3core as part of IISCertmap Auth Provider
    //

    DBG_ASSERT( _pEndpointConfig != NULL );

    //
    // If DSMapper is enabled, we have to query the token and pass it 
    // to HTTP service regardless if mapping was requested by worker process
    // for this specific request
    // the reason is that http.sys will cache client certificate and token 
    // for the connection and next time new request in worker process coming through
    // the same connection may require DS certificate mappings and if http.sys doesn't 
    // have token cached for the connection only client certificate, 
    // the worker process will not be able to retrieve it any more
    //
    
    if ( _pEndpointConfig->QueryUseDSMapper() )
    {
        secStatus = QuerySecurityContextToken( &_hContext,
                                                  &_ulCertInfo.Token );
        if ( SUCCEEDED( secStatus ) )
        {
            DBG_ASSERT( _ulCertInfo.Token != NULL );
        }
    }

    if ( FAILED ( secStatus ) )
    {
       //
       // if token from mapping is not available
       // it is OK, no mapping was found or 
       // denied access mapping was used
       //
       // BUGBUG - some errors should probably be logged
       //
       secStatus = SEC_E_OK;
    }
    
ExitPoint:
    return secStatus;
}


HRESULT
SSL_STREAM_CONTEXT::BuildClientCertInfo(
    VOID
)
/*++

Routine Description:

    Get client certificate info

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HCERTCHAINENGINE            hCertEngine = NULL;
    HRESULT                     hr = S_OK;
    CERT_CHAIN_PARA             chainPara;
    BOOL                        fRet;
    PCCERT_CHAIN_CONTEXT        pChainContext = NULL;
    DWORD                       dwRevocationFlags = 0;
    DWORD                       dwCacheFlags = 0;
    HTTPSPolicyCallbackData     HTTPSPolicy;
    CERT_CHAIN_POLICY_PARA      PolicyPara;
    CERT_CHAIN_POLICY_STATUS    PolicyStatus;


    DBG_ASSERT( _pClientCert != NULL );
    
    //
    // Do the easy stuff!
    //
    
    _ulCertInfo.CertEncodedSize = _pClientCert->cbCertEncoded;
    _ulCertInfo.pCertEncoded = _pClientCert->pbCertEncoded;

    _ulCertInfo.CertFlags = 0;

    //
    // Now for the hard stuff.  We need to validate the server does indeed
    // accept the client certificate.  Accept means we trusted the 
    // transitive trust chain to the CA, that the cert isn't revoked, etc.
    //
    // We use CAPI chaining functionality to check the certificate.
    //
    
    DBG_ASSERT( _pEndpointConfig != NULL );
    
    //
    // Default chain engine
    //
    
    hCertEngine = HCCE_LOCAL_MACHINE;

    if ( !( _pEndpointConfig->QueryCertCheckMode() & 
            MD_CERT_NO_REVOC_CHECK ) )
    {
        dwRevocationFlags |= CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT;
    }
    
    if ( _pEndpointConfig->QueryCertCheckMode() & 
         MD_CERT_CACHE_RETRIEVAL_ONLY )
    {
        dwCacheFlags |= CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY;
    }
    
    if ( sm_fCertChainCacheOnlyUrlRetrieval )
    {
        dwCacheFlags |= CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL;
    }
    
    //
    // Let'r rip
    //

    ZeroMemory( &chainPara, sizeof( chainPara ) );
    chainPara.cbSize = sizeof( chainPara );    
    chainPara.dwUrlRetrievalTimeout = 
                            _pEndpointConfig->QueryRevocationUrlRetrievalTimeout();
    chainPara.dwRevocationFreshnessTime = 
                            _pEndpointConfig->QueryRevocationFreshnessTime();
    chainPara.fCheckRevocationFreshnessTime =
                            !!( _pEndpointConfig->QueryCertCheckMode() & 
                            MD_CERT_CHECK_REVOCATION_FRESHNESS_TIME );

    LPSTR UsageIdentifiers[1] = { szOID_PKIX_KP_CLIENT_AUTH };
    
    if ( !(_pEndpointConfig->QueryCertCheckMode() & 
                            MD_CERT_NO_USAGE_CHECK ) )
    {

        chainPara.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;
        chainPara.RequestedUsage.Usage.cUsageIdentifier = 1;
        chainPara.RequestedUsage.Usage.rgpszUsageIdentifier = 
                                              UsageIdentifiers;
    }

    //
    // CertGetCertificateChain may eventually block
    // such as in the case of the CRL retrieval.
    // We got to bump up the soft thread limit
    //
    QueryFiltChannelContext()->AddWorkerThread();
    
    fRet = CertGetCertificateChain( hCertEngine,
                                    _pClientCert,
                                    NULL,
                                    NULL,
                                    &chainPara,
                                    dwRevocationFlags | dwCacheFlags,
                                    NULL,
                                    &pChainContext );
    
    QueryFiltChannelContext()->RemoveWorkerThread();
    
    if ( !fRet )
    {
        //
        // Bad.  Couldn't get the chain at all.
        //
        
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto ExitPoint;
    }    
    
    //
    // Validate certificate chain using CertVerifyCertificateChainPolicy.
    // 

    ZeroMemory( &HTTPSPolicy, sizeof(HTTPSPolicy));
    HTTPSPolicy.cbStruct           = sizeof(HTTPSPolicyCallbackData);
    HTTPSPolicy.dwAuthType         = AUTHTYPE_CLIENT;
    HTTPSPolicy.fdwChecks          = 0;
    HTTPSPolicy.pwszServerName     = NULL;

    ZeroMemory( &PolicyPara, sizeof( PolicyPara ) );
    PolicyPara.cbSize            = sizeof( PolicyPara );
    PolicyPara.pvExtraPolicyPara = &HTTPSPolicy;

    ZeroMemory( &PolicyStatus, sizeof( PolicyStatus) );
    PolicyStatus.cbSize = sizeof( PolicyStatus );

    if ( !CertVerifyCertificateChainPolicy( CERT_CHAIN_POLICY_SSL,
                                            pChainContext,
                                            &PolicyPara,
                                            &PolicyStatus ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        DBGPRINTF((DBG_CONTEXT,
            "CertVerifyCertificateChainPolicy failed. hr = 0x%x\n", 
            hr ));
        goto ExitPoint;
    }

    if ( PolicyStatus.dwError == CRYPT_E_NO_REVOCATION_CHECK )
    {
        {
            //
            // If a cert in the chain has no CDP we will NOT take it as error
            // reset the dwError
            // Note: This is based on the advice from Crypto team
            //   
            PolicyStatus.dwError = ERROR_SUCCESS;
        }
    }
    
    if ( PolicyStatus.dwError != ERROR_SUCCESS )
    {
        //
        // Client certificate
        // 
        _ulCertInfo.CertFlags = PolicyStatus.dwError;
    }
    else
    {
        //
        // Now verify CTL  - IIS uses unsigned CTLs 
        // and since CAPI doesn't support unsigned CTL verification
        // it is necessary to verify manually
        //
        
        if ( _pEndpointConfig->IsCtlRequired() )
        {
            PCERT_SIMPLE_CHAIN pSimpleChain = pChainContext->rgpChain[pChainContext->cChain - 1];

            PCERT_CHAIN_ELEMENT pChainElement = 
                pSimpleChain->rgpElement[pSimpleChain->cElement - 1];

            PCCERT_CONTEXT pChainTop = pChainElement->pCertContext;
            DBG_ASSERT( pChainTop != NULL );

            IIS_CTL * pIisCtl = _pEndpointConfig->QueryIisCtl();
            BOOL fCtlContainsCert = FALSE;
            if ( pIisCtl != NULL )
            {
                hr = pIisCtl->VerifyContainsCert( pChainTop, &fCtlContainsCert );
                if ( FAILED( hr ) || !fCtlContainsCert )
                {   
                    _ulCertInfo.CertFlags = (ULONG) CERT_E_UNTRUSTEDROOT;
                }
            }
            else
            {
                //
                // CTL not available but site requires it.
                // Request must fail
                //
                _ulCertInfo.CertFlags = (ULONG) CERT_E_UNTRUSTEDROOT;
            }
            
        }
    }

    
    IF_DEBUG( CLIENT_CERT_INFO )
    {
  
        //
        // Dump out some debug info about the certificate
        //  
    
        DumpCertDebugInfo( PolicyStatus.dwError );
    }

    //
    // the mapped user token was already assigned (in RetrieveClientCertAndToken)
    //
    
    hr = S_OK;

ExitPoint:

    if ( pChainContext != NULL )
    {
        CertFreeCertificateChain( pChainContext );
    }
    return hr;
    
}



VOID
SSL_STREAM_CONTEXT::DumpCertDebugInfo(
    DWORD dwPolicyStatus
)
/*++

Routine Description:

    On checked builds, dumps certificate (and chain) information to
    debugger

Arguments:

    dwPolicyStatus - policy status (result of CertVerifyCertificateChainPolicy)

Return Value:

    None

--*/
{
    PCERT_PUBLIC_KEY_INFO   pPublicKey;
    DWORD                   cbKeyLength;
    WCHAR                   achBuffer[ 512 ];
    
    //
    // Get certificate public key size
    //
    
    pPublicKey = &(_pClientCert->pCertInfo->SubjectPublicKeyInfo);

    cbKeyLength = CertGetPublicKeyLength( X509_ASN_ENCODING, 
                                          pPublicKey );
    
    DBGPRINTF(( DBG_CONTEXT,
                "Client cert key length = %d bits\n",
                cbKeyLength ));
                
    //
    // Get issuer string
    //
    
    if ( CertGetNameString( _pClientCert,
                             CERT_NAME_SIMPLE_DISPLAY_TYPE,
                             CERT_NAME_ISSUER_FLAG,
                             NULL,
                             achBuffer,
                             sizeof( achBuffer ) / sizeof( WCHAR ) ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Client cert issuer = %ws\n",
                    achBuffer ));
    }    
    else
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error determining client cert issuer.  Win32 = %d\n",
                    GetLastError() ));
    }
    
    //
    // Get subject string
    //
    
    if ( CertGetNameString( _pClientCert,
                            CERT_NAME_SIMPLE_DISPLAY_TYPE,
                            0,
                            NULL,
                            achBuffer,
                            sizeof( achBuffer ) / sizeof( WCHAR ) ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Client cert subject = %ws\n",
                    achBuffer ));
    }    
    else
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error determining client cert subject.  Win32 = %d\n",
                    GetLastError() ));
    }


    //
    // Dump Policy Status
    //

    LPSTR pszName = NULL;

    switch( dwPolicyStatus )
    {
    case CERT_E_EXPIRED:
        pszName = "CERT_E_EXPIRED"; break;
    case CERT_E_VALIDITYPERIODNESTING:
        pszName = "CERT_E_VALIDITYPERIODNESTING"; break;
    case CERT_E_ROLE:
        pszName = "CERT_E_ROLE"; break;
    case CERT_E_PATHLENCONST:
        pszName = "CERT_E_PATHLENCONST"; break;
    case CERT_E_CRITICAL:
        pszName = "CERT_E_CRITICAL"; break;
    case CERT_E_PURPOSE:
        pszName = "CERT_E_PURPOSE"; break;
    case CERT_E_ISSUERCHAINING:
        pszName = "CERT_E_ISSUERCHAINING"; break;
    case CERT_E_MALFORMED:
        pszName = "CERT_E_MALFORMED"; break;
    case CERT_E_UNTRUSTEDROOT:
        pszName = "CERT_E_UNTRUSTEDROOT"; break;
    case CERT_E_CHAINING:
        pszName = "CERT_E_CHAINING"; break;
    case TRUST_E_FAIL:
        pszName = "TRUST_E_FAIL"; break;
    case CERT_E_REVOKED:
        pszName = "CERT_E_REVOKED"; break;
    case CERT_E_UNTRUSTEDTESTROOT:
        pszName = "CERT_E_UNTRUSTEDTESTROOT"; break;
    case CERT_E_REVOCATION_FAILURE:
        pszName = "CERT_E_REVOCATION_FAILURE"; break;
    case CERT_E_CN_NO_MATCH:
        pszName = "CERT_E_CN_NO_MATCH"; break;
    case CERT_E_WRONG_USAGE:
        pszName = "CERT_E_WRONG_USAGE"; break;
    case CRYPT_E_NO_REVOCATION_CHECK:
        pszName = "CRYPT_E_NO_REVOCATION_CHECK";break;
    case CRYPT_E_REVOKED:
        pszName = "CRYPT_E_REVOKED";break;
    case CRYPT_E_REVOCATION_OFFLINE:
        pszName = "CRYPT_E_REVOCATION_OFFLINE";break;
    case ERROR_SUCCESS:
        pszName = "SUCCESS";break;
    default:
        pszName = "(unknown)"; break;
    }

    DBGPRINTF((DBG_CONTEXT,
        "Client cert verification result = 0x%x (%s)\n", 
        dwPolicyStatus, pszName));
}


CredHandle *
SSL_STREAM_CONTEXT::QueryCredentials(
    VOID
)
/*++

Routine Description:

    Get the applicable credentials (depending on whether we're mapping or not)

Arguments:

    None

Return Value:

    CredHandle *

--*/
{
    DBG_ASSERT( _pEndpointConfig != NULL );
    
    return _pEndpointConfig->QueryCredentials();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\sfwp\dll\ulcontext.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     ulcontext.cxx

   Abstract:
     Implementation of FILTER_CHANNEL_CONTEXT.  One such object for every connection

   Environment:
     Win32 - User Mode

   Project:
     Stream Filter Worker Process
--*/


#include "precomp.hxx"

#ifndef MAXDWORD
#define MAXDWORD  0xFFFFFFFFul
#endif

//static 
ALLOC_CACHE_HANDLER * 
    SSL_SERVER_FILTER_CHANNEL_CONTEXT::sm_pachFilterChannelContexts = NULL;

//static 
ALLOC_CACHE_HANDLER * 
    UL_OVERLAPPED_CONTEXT::sm_pachUlOverlappedContexts = NULL;

//static 
ALLOC_CACHE_HANDLER * 
    UL_OVERLAPPED_CONTEXT::sm_pachRawWriteBuffers = NULL;
//static 
ALLOC_CACHE_HANDLER * 
    UL_OVERLAPPED_CONTEXT::sm_pachRawReadBuffers = NULL;
//static 
ALLOC_CACHE_HANDLER * 
    UL_OVERLAPPED_CONTEXT::sm_pachAppReadBuffers = NULL;
    
//static
DWORD    
FILTER_CHANNEL::sm_dwDefaultRawReadSize = DEFAULT_RAW_READ_SIZE ;
//static
DWORD   
FILTER_CHANNEL::sm_dwDefaultAppReadSize = DEFAULT_APP_READ_SIZE;
//static
DWORD   
FILTER_CHANNEL::sm_dwContextDesiredOutstanding = UL_CONTEXT_DESIRED_OUTSTANDING;
//static
BOOL   
FILTER_CHANNEL::sm_fEnableTemporaryBuffers = TRUE;

//static
DWORD   
FILTER_CHANNEL::sm_dwHandshakeTimeoutInSec = DEFAULT_RENEGOTIATION_TIMEOUT_IN_SEC;



UL_OVERLAPPED_CONTEXT::UL_OVERLAPPED_CONTEXT(
    UL_OVERLAPPED_CONTEXT_TYPE    type,
    UL_OVERLAPPED_CONTEXT_SUBTYPE subtype 
) 
{
    _type = type;
    _subtype = subtype;
    _pCallback = NULL;
    _pCallbackParam = NULL;
    ZeroMemory( &_Overlapped, sizeof(_Overlapped) );


    // internal Data buffer related initialization

    _pbData = NULL;
    _cbData = 0;
    _fDynAllocated = FALSE;

    switch ( QueryType() )
    {
    case UL_OVERLAPPED_CONTEXT_RAW_READ:
        _pCurrentACache = sm_pachRawReadBuffers;
        _cbCurrentACacheElementSize =
            FILTER_CHANNEL::QueryDefaultRawReadSize();
        break;
    case UL_OVERLAPPED_CONTEXT_RAW_WRITE:
        _pCurrentACache = sm_pachRawWriteBuffers;
        _cbCurrentACacheElementSize =
            FILTER_CHANNEL::QueryDefaultRawWriteSize();
   
        break;
    case UL_OVERLAPPED_CONTEXT_APP_READ:
        _pCurrentACache = sm_pachAppReadBuffers;
        _cbCurrentACacheElementSize =
            FILTER_CHANNEL::QueryDefaultAppReadSize();
   
        break;
    case UL_OVERLAPPED_CONTEXT_APP_WRITE:
    default:
        _pCurrentACache = NULL;
        _cbCurrentACacheElementSize = 0;
        break;
    }

}

//static
HRESULT
UL_OVERLAPPED_CONTEXT::Initialize(
    VOID
)
/*++

Routine Description:

    Global initialization routine for UL_OVERLAPPED_CONTEXT

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ALLOC_CACHE_CONFIGURATION       acConfig;

    //
    // Setup allocation lookaside
    //

    acConfig.nConcurrency = 1;
    acConfig.nThreshold = 100;

    // UL_OVERLAPPED_CONTEXT ACACHE
    
    acConfig.cbSize = sizeof( UL_OVERLAPPED_CONTEXT );

    DBG_ASSERT( sm_pachUlOverlappedContexts == NULL );

    sm_pachUlOverlappedContexts = new ALLOC_CACHE_HANDLER( "UL_OVERLAPPED_CONTEXT",  
                                                &acConfig );

    if ( sm_pachUlOverlappedContexts == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }

    // Raw Write Buffers ACACHE

    acConfig.cbSize = 
        FILTER_CHANNEL::QueryDefaultRawWriteSize();
    
    DBG_ASSERT( sm_pachRawWriteBuffers == NULL );

    sm_pachRawWriteBuffers = new ALLOC_CACHE_HANDLER( "RAW_WRITE_BUFFERS",  
                                                &acConfig );

    if ( sm_pachRawWriteBuffers == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }


    // Raw Read Buffers ACACHE

    acConfig.cbSize = 
        FILTER_CHANNEL::QueryDefaultRawReadSize();
   
    DBG_ASSERT( sm_pachRawReadBuffers == NULL );

    sm_pachRawReadBuffers = new ALLOC_CACHE_HANDLER( "RAW_READ_BUFFERS",  
                                                &acConfig );

    if ( sm_pachRawReadBuffers == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }

    // App Read Buffers ACACHE

    acConfig.cbSize = 
        FILTER_CHANNEL::QueryDefaultAppReadSize();
   
    DBG_ASSERT( sm_pachAppReadBuffers == NULL );

    sm_pachAppReadBuffers = new ALLOC_CACHE_HANDLER( "APP_READ_BUFFERS",  
                                                &acConfig );

    if ( sm_pachAppReadBuffers == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }

    
    return NO_ERROR;
}


//static
VOID
UL_OVERLAPPED_CONTEXT::Terminate(
    VOID
)
/*++

Routine Description:

    Terminate UL_OVERLAPPED_CONTEXT globals

Arguments:

    None

Return Value:

    None

--*/
{
    if ( sm_pachAppReadBuffers != NULL )
    {
        delete sm_pachAppReadBuffers;
        sm_pachAppReadBuffers = NULL;
    }

    if ( sm_pachRawReadBuffers != NULL )
    {
        delete sm_pachRawReadBuffers;
        sm_pachRawReadBuffers = NULL;
    }

    if ( sm_pachRawWriteBuffers != NULL )
    {
        delete sm_pachRawWriteBuffers;
        sm_pachRawWriteBuffers = NULL;
    }


    if ( sm_pachUlOverlappedContexts != NULL )
    {
        delete sm_pachUlOverlappedContexts;
        sm_pachUlOverlappedContexts = NULL;
    }

}



BOOL
UL_OVERLAPPED_CONTEXT::ResizeDataBuffer(
    DWORD cbNewSize
)
/*++

Routine Description:

    Resize internal data buffer
    - if requested size fits within the range of the
    ACACHE entry size then ACACHEd entry is returned
    Otherwise heap allocation is made.

    Content of the previous buffer is copied to the new one

Arguments:

    None

Return Value:

    BOOL  (this is just to follow the legacy of the BUFFER type that
    was used previously)

--*/
{
    if ( _cbData >= cbNewSize )
    {
        return TRUE;
    }


    PBYTE pbPrevData = _pbData;
    DWORD cbPrevData = _cbData;
    BOOL fPrevDynAllocated = _fDynAllocated;
        
    if ( _cbCurrentACacheElementSize >= cbNewSize &&
         _pCurrentACache != NULL )
    {
        //
        // use ACACHE
        //
        _pbData = (PBYTE) _pCurrentACache->Alloc();
        
        if ( _pbData != NULL )
        {
            _cbData = _cbCurrentACacheElementSize;
            _fDynAllocated = FALSE;
        }
    }
    else
    {
        //
        // Requested size was too big for ACACHE
        // We have to allocate on the heap
        // round up the allocation unit to minimize access to the heap
        //
        DWORD cbAllocIncrement = 4096;
        DWORD cbNewAllocSize = cbAllocIncrement * 
                               ( ( cbNewSize / cbAllocIncrement ) + 1 );
       
        _pbData = new BYTE[ cbNewAllocSize ];

        if (_pbData != NULL )
        {
            _cbData = cbNewAllocSize;
            _fDynAllocated = TRUE;
        }
    }

    if ( _pbData == NULL )
    {
        _pbData = pbPrevData;
        _cbData = cbPrevData;
        _fDynAllocated = fPrevDynAllocated;
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    //
    // Copy previous content if necessary
    //
    
    if ( cbPrevData != 0 && pbPrevData != NULL )
    {
        memcpy( _pbData, pbPrevData, cbPrevData );
    }

    if ( pbPrevData != NULL )
    {
        if ( fPrevDynAllocated )
        {
            delete [] pbPrevData;
        }
        else
        {
            _pCurrentACache->Free( pbPrevData );
            
        }
    }
    
    return TRUE;    
}

VOID
UL_OVERLAPPED_CONTEXT::FreeDataBuffer(
    VOID
)
/*++

Routine Description:

    free the internal data buffer's memory

Arguments:

    None

Return Value:

    none

--*/
{
    if ( _pbData == NULL )
    {
        return;
    }

    if ( _fDynAllocated )
    {
        delete [] _pbData;
    }
    else
    {
        _pCurrentACache->Free( _pbData );
    }
    _pbData = NULL;
    _cbData = 0;
}
    


FILTER_CHANNEL_CONTEXT::FILTER_CHANNEL_CONTEXT(
    FILTER_CHANNEL *pManager
    )
    : _RawWriteData1Overlapped( UL_OVERLAPPED_CONTEXT_RAW_WRITE,
                                UL_OVERLAPPED_CONTEXT_DATA ),
      _RawWriteData2Overlapped( UL_OVERLAPPED_CONTEXT_RAW_WRITE,
                                UL_OVERLAPPED_CONTEXT_DATA ),
      _RawReadOverlapped( UL_OVERLAPPED_CONTEXT_RAW_READ ),
      _AppWriteOverlapped( UL_OVERLAPPED_CONTEXT_APP_WRITE ),
      _AppReadOverlapped( UL_OVERLAPPED_CONTEXT_APP_READ ),
      _CloseOverlapped( UL_OVERLAPPED_CONTEXT_CLOSE ),
      _buffConnectionInfo( _abConnectionInfo, sizeof( _abConnectionInfo ) ),
      _fCloseConnection( FALSE ),
      _cRefs( 1 ),
      _cbRawReadData( 0 ),
      _fNewConnection( TRUE ),
      _pSSLContext( NULL ),
      _lQueuedAppReads( 0 ),
      _fAppReadInProgress( FALSE ),
      _pISAPIContext( NULL ),
      _cbNextRawReadSize( FILTER_CHANNEL::QueryDefaultRawReadSize() ),
      _ulFilterBufferType( (HTTP_FILTER_BUFFER_TYPE) -1 ),
      _pManager( pManager ),
      _pEndpointConfig( NULL ),
      _pLastAcquiredRawWriteOverlapped( NULL ),
      _fTimerTickCountSet( FALSE )
{
    _RawWriteData1Overlapped.SetContext( this );
    _RawWriteData2Overlapped.SetContext( this );
    _RawReadOverlapped.SetContext( this );
    _AppWriteOverlapped.SetContext( this );
    _AppReadOverlapped.SetContext( this );
    _CloseOverlapped.SetContext( this ),
    
    _RawWriteOverlappedFreeList.Next = NULL;
    
    PushEntryList( &_RawWriteOverlappedFreeList, _RawWriteData1Overlapped.QueryListEntry() );
    PushEntryList( &_RawWriteOverlappedFreeList, _RawWriteData2Overlapped.QueryListEntry() );

    _dwLockIndex = 0;

    _pManager->InsertFiltChannelContext(this);

    _pConnectionInfo = (HTTP_RAW_CONNECTION_INFO*) _buffConnectionInfo.QueryPtr();
    _pConnectionInfo->pInitialData = (PBYTE)_pConnectionInfo +
                                     sizeof(HTTP_RAW_CONNECTION_INFO);
    _pConnectionInfo->InitialDataSize = _buffConnectionInfo.QuerySize() -
                                        sizeof(HTTP_RAW_CONNECTION_INFO);

    // signature will be added by inheriting class
}

FILTER_CHANNEL_CONTEXT::~FILTER_CHANNEL_CONTEXT()
{

    //
    // Cleanup any attached stream context
    //

    if ( _pISAPIContext != NULL )
    {
        
        delete _pISAPIContext;
        _pISAPIContext = NULL;
    }

    if ( _pSSLContext != NULL )
    {
        delete _pSSLContext;
        _pSSLContext = NULL;
    }

    if ( _pEndpointConfig != NULL )
    {
        _pEndpointConfig->DereferenceEndpointConfig();
        _pEndpointConfig = NULL;
    }

    //
    // Manage the list of active UL_CONTEXTs
    //

    _pManager->RemoveFiltChannelContext(this);
}


VOID
FILTER_CHANNEL_CONTEXT::ReferenceFiltChannelContext(
    VOID
)
/*++

Routine Description:

    Reference the FILTER_CHANNEL_CONTEXT

Arguments:

    none

Return Value:

    none

--*/
{
    LONG                cRefs;

    cRefs = InterlockedIncrement( &_cRefs );

    #if DBG
    //
    // Log the reference ( sm_pTraceLog!=NULL if DBG=1)
    //

    _pManager->WriteRefTraceLog( cRefs,
                                 this );
    #endif
}

VOID
FILTER_CHANNEL_CONTEXT::DereferenceFiltChannelContext(
    VOID
)
/*++

Routine Description:

    Dereference (and possible destroy) the FILTER_CHANNEL_CONTEXT

Arguments:

    none

Return Value:

    none

--*/
{
    LONG                cRefs;

    #if DBG
    //
    // We have to store pManager before Decrementing reference
    // because after dereferencing it's illegal to access the data
    // of the class because there is no guarantee that the instance
    // still exists. Also it's necessary to guarantee that
    // pManager will not be deleted before any thread executing
    // this code is completed
    // (Threadpool must be destroyed first - see the Terminate() call)
    //

    FILTER_CHANNEL *    pManager = _pManager;
    #endif

    cRefs = InterlockedDecrement( &_cRefs );

    #if DBG
    pManager->WriteRefTraceLog( cRefs,
                                this );
    #endif

    if ( cRefs == 0 )
    {
        //
        // CONTEXT is to be destroyed
        // Remove it from the timer list so that there are
        // are only valid entries on the list
        //
        
        StopTimeoutTimer();
        delete this;
    }
}

HRESULT
FILTER_CHANNEL_CONTEXT::OnAppReadCompletion(
    DWORD                   /*cbCompletion*/,
    DWORD                   dwCompletionStatus
)
/*++

Routine Description:

    Completion for reads from an application

Arguments:

    cbCompletion - Bytes of completion (currently not used)
    dwCompletionStatus - Completion error

Return Value:

    HRESULT

--*/
{
    HTTP_FILTER_BUFFER *        pFilterBuffer;
    HRESULT                     hr = E_FAIL;
    RAW_STREAM_INFO             rawStreamInfo;
    BOOL                        fComplete = FALSE;
    BOOL                        fPostAppRead = FALSE;

    
    //
    // Just bail on errors
    //

    if ( dwCompletionStatus != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( dwCompletionStatus );
        goto ExitPoint;
    }

    pFilterBuffer = (HTTP_FILTER_BUFFER *) _ulAppReadFilterBuffer.pBuffer;
    _ulFilterBufferType = pFilterBuffer->BufferType;

    DBG_ASSERT( !_fNewConnection );

    //
    // If HTTP.SYS is telling us to close the connection, then do so now
    //

    if ( _ulFilterBufferType == HttpFilterBufferCloseConnection )
    {
        //
        // Connection is to be closed gracefully
        // One outstanding overlapped Raw Write may exists. 
        // Since HTTP.SYS will perform
        // graceful disconnect it is safe to call StartClose() right now
        // and no data from the outstanding RawWrite will be lost.
        // Also the delayed ACK problem on the last send will not apply if close
        // is requested while one RawWrite may still be outstanding
        //

        StartClose();
        hr = S_OK;
        goto ExitPoint;
    }

    //
    // Setup raw stream descriptor
    //

    rawStreamInfo.pbBuffer = (PBYTE) pFilterBuffer->pBuffer;
    rawStreamInfo.cbBuffer = pFilterBuffer->BufferSize;
    rawStreamInfo.cbData = pFilterBuffer->BufferSize;


    //
    // First notify ISAPI filters if this is a stream from the application
    // if _pISAPIContext is null then notification is disabled

    if ( _ulFilterBufferType == HttpFilterBufferHttpStream &&
         _pISAPIContext != NULL )
    {
        DBG_ASSERT( _pISAPIContext != NULL );

        //
        // We don't know what the raw write filter will do so we better
        // have a thead available to prevent blocking
        //
        AddWorkerThread();
        hr = _pISAPIContext->ProcessRawWriteData( &rawStreamInfo,
                                                  &fComplete );
        RemoveWorkerThread();
        if ( FAILED( hr ) )
        {
            goto ExitPoint;
        }

        if ( fComplete )
        {
            StartClose();
            hr = S_OK;
            goto ExitPoint;
        }
    }

    //
    // Next notify SSL filter always
    //

    DBG_ASSERT( _pSSLContext != NULL );

    hr = _pSSLContext->ProcessRawWriteData( &rawStreamInfo,
                                            &fComplete );
    if ( FAILED( hr ) )
    {
        goto ExitPoint;
    }

    if ( fComplete )
    {
        StartClose();
        hr = S_OK;
        goto ExitPoint;
    }

    //
    // If there is data to send to the client, then do so now.
    // This check is done because the filter may decide to eat up all the
    // data to be sent
    //

    if ( _ulFilterBufferType == HttpFilterBufferHttpStream &&
         rawStreamInfo.pbBuffer != NULL &&
         rawStreamInfo.cbData != 0 )
    {
        //
        // If we got to here, then we have processed data to send to the client
        //

        //
        // The processed data that is passed along will be written 
        // before our read buffer is posted.
        //

        hr = DoRawWrite( UL_CONTEXT_FLAG_ASYNC,
                         rawStreamInfo.pbBuffer,
                         rawStreamInfo.cbData,
                         NULL );
        if ( FAILED( hr ) )
        {
            goto ExitPoint;
        }

        //
        // Try to post another AppRead if there is one queued
        // (by other words if multiple overlapped RawWrites limit was not reached)
        //

        fPostAppRead = FALSE;

        _AppReadQueueLock.WriteLock();
    
        if( _lQueuedAppReads != 0 )
        {
            fPostAppRead = TRUE;
            //
            // Only one thread a time is allowed to post new AppRead
            //
            _lQueuedAppReads--;
        }
        else
        {
            //
            // We are not allowed to post new AppRead now because there are
            // probably 2 outstanding RawWrites at this moment
            //
            _fAppReadInProgress = FALSE;
        }
        
        _AppReadQueueLock.WriteUnlock();
    }
    else
    {
        //
        // No data was written
        // we can safely make another AppRead
        // because we still hold _fAppReadInProgress set to TRUE
        //
        fPostAppRead = TRUE;
    }

    if ( fPostAppRead )     
    {
         //
         // Kick off another app read
         //

         _ulAppReadFilterBuffer.pBuffer =    _AppReadOverlapped.QueryDataBuffer();
         _ulAppReadFilterBuffer.BufferSize = _AppReadOverlapped.QueryDataBufferSize();

         hr = DoAppRead( UL_CONTEXT_FLAG_ASYNC,
                         &_ulAppReadFilterBuffer,
                         NULL );
         goto ExitPoint;
    }
    else
    {
        //
        // Raw Write completion will post app read
        //
        hr = S_OK;
        goto ExitPoint;
    }

ExitPoint:
    
    //
    // Close connection if error was detected
    //
    if ( FAILED( hr ) )
    {
        StartClose();
    }
    
    //
    // Async App Read grabbed the reference. It is time to dereference now
    //
    DereferenceFiltChannelContext();
    return hr;
}


HRESULT
FILTER_CHANNEL_CONTEXT::TryAppRead(
    VOID
)
/*++

Routine Description:

    Only up to one outstanding AppRead is allowed in any moment
    because otherwise the order of data blocks sent out is not guaranteed
    This method takes care of handling queued AppReads(). If there
    is no AppRead in progress, it will try to get exclusive right
    to process AppRead and if it succeeds then new AppRead is posted
    Otherwise it will simply return with NO_ERROR;

Arguments:


Return Value:

    HRESULT

--*/

{
    BOOL fPostAppRead = FALSE;

    _AppReadQueueLock.WriteLock();
    
    if( !_fAppReadInProgress )
    {
        _fAppReadInProgress = TRUE;
        //
        // This thread was chosen to post app read
        //
        fPostAppRead = TRUE;
    }
    else
    {
        //
        // Queue AppRead. 
        // Currently there is AppRead in progress and new one can start
        // only after it completed and made RawWrite call
        //

        _lQueuedAppReads++;
    }
    _AppReadQueueLock.WriteUnlock();

    if ( fPostAppRead )
    {
        //
        // Kick off another app read
        //
        _ulAppReadFilterBuffer.pBuffer = _AppReadOverlapped.QueryDataBuffer();
        _ulAppReadFilterBuffer.BufferSize = _AppReadOverlapped.QueryDataBufferSize();

        return DoAppRead( UL_CONTEXT_FLAG_ASYNC,
                          &_ulAppReadFilterBuffer,
                          NULL );
    }
    return NO_ERROR;
}

HRESULT
FILTER_CHANNEL_CONTEXT::OnNewConnection(
    VOID
)
/*++

Routine Description:

    Handle initial completion for the HttpFilterAccept()
    It is called from OnRawReadCompletion because New connection
    completion is special case of RawWriteCompletion

Arguments:

    cbCompletion - Bytes of completion
    dwCompletionStatus - Completion error

Return Value:

    HRESULT

--*/

{
     HRESULT                     hr = E_FAIL;
    _fNewConnection = FALSE;

    //
    // This is a new connection.  We have one less FILTER_CHANNEL_CONTEXT to
    // listen for incoming requests.  Correct that if necessary.
    //

    _pManager->DecrementAndManageOutstandingContexts();

    //
    // Convert the UL addresses into something nicer!
    //

    HTTP_TRANSPORT_ADDRESS *pAddress = &_pConnectionInfo->Address;
    _connectionContext.LocalAddressType  = pAddress->pLocalAddress->sa_family;
    _connectionContext.RemoteAddressType = pAddress->pRemoteAddress->sa_family;


    if( pAddress->pLocalAddress->sa_family == AF_INET )
    {
        _connectionContext.SockLocalAddress.ipv4SockAddress
             = * (PSOCKADDR_IN)pAddress->pLocalAddress;
    }
    else if( pAddress->pLocalAddress->sa_family == AF_INET6 )
    {
        _connectionContext.SockLocalAddress.ipv6SockAddress
             = * (PSOCKADDR_IN6)pAddress->pLocalAddress;
    }
    else
    {
        DBG_ASSERT( FALSE );
    }

    if( pAddress->pRemoteAddress->sa_family == AF_INET )
    {
        _connectionContext.SockRemoteAddress.ipv4SockAddress
             = * (PSOCKADDR_IN)pAddress->pRemoteAddress;
    }
    else if( pAddress->pRemoteAddress->sa_family == AF_INET6 )
    {
        _connectionContext.SockRemoteAddress.ipv6SockAddress
             = * (PSOCKADDR_IN6)pAddress->pRemoteAddress;
    }
    else
    {
        DBG_ASSERT( FALSE );
    }

    _connectionContext.fIsSecure = FALSE;
    _connectionContext.RawConnectionId = _pConnectionInfo->ConnectionId;

    //
    // create ISAPI_STREAM_CONTEXT
    // if ISAPI filters are enabled
    //
    // Endpoint config may contain information about explicitly
    // disabling raw ISAPI filter handling
    //

    if ( _pManager->QueryNotifyISAPIFilters() )
    {
        //
        // Lookup the endpoint config
        //

        hr = ENDPOINT_CONFIG::GetEndpointConfig( &_connectionContext,
                                                 &_pEndpointConfig,
                                                 TRUE /*fCreateEmptyIfNotFound*/);
        if ( FAILED( hr ) )
        {
            return hr;
        }

        DBG_ASSERT( _pEndpointConfig != NULL );

        //
        // HttpApi Config store may contain endpoint flag
        // that will prevent raw ISAPI Filter execution 
        // on the endpoint data
        // Create ISAPI context only if Raw Filter handling is enabled
        //

        if ( !_pEndpointConfig->QueryNoRawFilter() )
        {
            hr =ISAPI_STREAM_CONTEXT::CreateContext( 
                                         this, 
                                         &_pISAPIContext );
            
            if ( hr == HRESULT_FROM_WIN32( ERROR_SERVICE_NOT_ACTIVE ) )
            {
                //
                // this error means that w3svc is shutting down so
                // there is no more need to create ISAPI_STREAM_CONTEXT
                //
                _pISAPIContext = NULL;
            }
            else if ( FAILED( hr ) )
            {
                return hr;
            }
        }
    }

    if ( _pISAPIContext != NULL )
    {
        _connectionContext.pfnSendDataBack = ISAPI_STREAM_CONTEXT::SendDataBack;
    }
    _connectionContext.pvStreamContext = this;

    //
    // copy out the server name.
    //
    _connectionContext.ClientSSLContextLength =
        _pConnectionInfo->ClientSSLContextLength;
    _connectionContext.pClientSSLContext =
        _pConnectionInfo->pClientSSLContext;

    //
    // Fill in our read buffer (as if we had read it in directly)
    //

    _cbRawReadData = _pConnectionInfo->InitialDataSize;

    if ( !_RawReadOverlapped.ResizeDataBuffer( 
                                     max( _pConnectionInfo->InitialDataSize,
                                     QueryNextRawReadSize() ) ) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    memcpy( _RawReadOverlapped.QueryDataBuffer(),
            _pConnectionInfo->pInitialData,
            _pConnectionInfo->InitialDataSize );

    //
    // First indicate a new connection
    //

    DBG_ASSERT( _pSSLContext != NULL );

    //
    // We pass _pEndpointConfig but it may be empty. 
    // In that case SSL Context will have to make a lookup 
    //
    hr = _pSSLContext->ProcessNewConnection( &_connectionContext,
                                             _pEndpointConfig );
    if ( FAILED( hr ) )
    {
        return hr;
    }


    //
    // if _pISAPIContext == NULL then ISAPI notification
    // was not requested
    //

    if ( _pISAPIContext != NULL )
    {
        //
        // We don't know what the raw write filter will do so we better
        // have a thead available to prevent blocking
        //
        hr = _pISAPIContext->ProcessNewConnection(
                                 &_connectionContext,
                                 _pEndpointConfig
                                 );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }


    //
    // Adjust AppRead buffer size
    //

    if ( !_AppReadOverlapped.ResizeDataBuffer( 
                    FILTER_CHANNEL::QueryDefaultAppReadSize() ) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    //
    // Post one AppRead and queue another one
    // This will enable 2 outstanding RawWrites to exist
    // AppReads will be executed synchronously, so that
    // we don't lose order of incoming data but we will
    // not wait for completion of each RawWrite before
    // starting New AppRead
    //

    _lQueuedAppReads = 1;
    _fAppReadInProgress = TRUE;

    _ulAppReadFilterBuffer.pBuffer =    _AppReadOverlapped.QueryDataBuffer();
    _ulAppReadFilterBuffer.BufferSize = _AppReadOverlapped.QueryDataBufferSize();

    return DoAppRead( UL_CONTEXT_FLAG_ASYNC,
                      &_ulAppReadFilterBuffer,
                      NULL );
}

HRESULT
FILTER_CHANNEL_CONTEXT::OnRawReadCompletion(
    DWORD                   cbCompletion,
    DWORD                   dwCompletionStatus
)
/*++

Routine Description:

    Get read completions off the wire.  This includes the initial
    completion for the HttpFilterAccept()

Arguments:

    cbCompletion - Bytes of completion
    dwCompletionStatus - Completion error

Return Value:

    HRESULT

--*/
{
    HRESULT                     hr;
    BOOL                        fReadMore = FALSE;
    BOOL                        fComplete = FALSE;
    RAW_STREAM_INFO             rawStreamInfo;
    
    //
    // Handle errors
    //

    if ( dwCompletionStatus != NO_ERROR )
    {
        if ( _fNewConnection )
        {
            _pManager->DecrementAndManageOutstandingContexts();
        }
        hr = HRESULT_FROM_WIN32( dwCompletionStatus );
        goto ExitPoint;
    }

    if ( cbCompletion == 0 )
    {
        //
        // Handle graceful disconnect
        //

        _ulAppWriteFilterBuffer.BufferType = HttpFilterBufferNotifyDisconnect;
        _ulAppWriteFilterBuffer.pBuffer = NULL;
        _ulAppWriteFilterBuffer.BufferSize = 0;

        //
        // no more RawRead will be launched
        //

        hr = DoAppWrite(UL_CONTEXT_FLAG_ASYNC, &_ulAppWriteFilterBuffer, NULL);
        goto ExitPoint;
    }



    //
    // If this is a new connection, then grok connection information, and
    // maintain pending count
    //

    if ( _fNewConnection )
    {
        hr = OnNewConnection( );
        if ( FAILED( hr ) )
        {
            goto ExitPoint;
        }
    }        
    else
    {
        _cbRawReadData += cbCompletion;
    }

    //
    // reset default raw read size
    //

    SetNextRawReadSize( DEFAULT_RAW_READ_SIZE );

    rawStreamInfo.pbBuffer = _RawReadOverlapped.QueryDataBuffer();
    rawStreamInfo.cbBuffer = _RawReadOverlapped.QueryDataBufferSize();
    rawStreamInfo.cbData = _cbRawReadData;

    //
    // First, we will notify SSL
    //

    DBG_ASSERT( _pSSLContext != NULL );

    hr = _pSSLContext->ProcessRawReadData( &rawStreamInfo,
                                           &fReadMore,
                                           &fComplete );
    if ( FAILED( hr ) )
    {
        goto ExitPoint;
    }

    _cbRawReadData = rawStreamInfo.cbData;

    //
    // If we need to read more data, then do so now
    //

    if ( fReadMore )
    {

        //
        // rawStreamInfo.pbBuffer may have been replaced by different buffer
        // in ProcessRawReadData() call.
        // copy data back to pbuffRawReadData
        //

        if ( rawStreamInfo.pbBuffer != _RawReadOverlapped.QueryDataBuffer() )
        {
            if ( !_RawReadOverlapped.ResizeDataBuffer( rawStreamInfo.cbData +
                                                   QueryNextRawReadSize() ) )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
                goto ExitPoint;
            }

            memmove( _RawReadOverlapped.QueryDataBuffer(),
                     rawStreamInfo.pbBuffer,
                     rawStreamInfo.cbData
                   );
        }
        else
        {
            // no need to copy data but we still have to resize
            //
            if ( !_RawReadOverlapped.ResizeDataBuffer( rawStreamInfo.cbData +
                                                   QueryNextRawReadSize() ) )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
                goto ExitPoint;
            }
        }
        
        hr = DoRawRead( UL_CONTEXT_FLAG_ASYNC,
                        _RawReadOverlapped.QueryDataBuffer() + _cbRawReadData,
                        QueryNextRawReadSize(),
                        NULL );
        goto ExitPoint;
    }

    if ( fComplete )
    {
        StartClose();
        hr = S_OK;
        goto ExitPoint;
    }

    //
    // Reset the next read size before calling into filters since SSL may
    // have done a really small read, just previous to this.
    //

    SetNextRawReadSize( FILTER_CHANNEL::QueryDefaultRawReadSize() );


    //
    // Now we can start notifying ISAPI filters if needed (and there is
    // data to process)
    //

    if ( _pISAPIContext != NULL )
    {
        fComplete = FALSE;
        fReadMore = FALSE;

        AddWorkerThread(); 
        hr = _pISAPIContext->ProcessRawReadData( &rawStreamInfo,
                                                 &fReadMore,
                                                 &fComplete );
        RemoveWorkerThread(); 
        if ( FAILED( hr ) )
        {
            goto ExitPoint;
        }

        _cbRawReadData = rawStreamInfo.cbData;

        //
        // If we need to read more data, then do so now
        //

        if ( fReadMore )
        {
            //
            // rawStreamInfo may have been replaced by different buffer
            // in ProcessRawReadData() call.
            // copy data back to pbufRawReadData
            //

            if ( rawStreamInfo.pbBuffer != _RawReadOverlapped.QueryDataBuffer() )
            {
                if ( !_RawReadOverlapped.ResizeDataBuffer( rawStreamInfo.cbData +
                                                       QueryNextRawReadSize() ) )
                {
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                    goto ExitPoint;
                }
                memmove( _RawReadOverlapped.QueryDataBuffer(),
                         rawStreamInfo.pbBuffer,
                         rawStreamInfo.cbData
                    );
            }
            else
            {
                // no need to copy data but we still have to resize
                //
                if ( !_RawReadOverlapped.ResizeDataBuffer( rawStreamInfo.cbData +
                                                       QueryNextRawReadSize() ) )
                {
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                    goto ExitPoint;
                }
            }


            hr = DoRawRead( UL_CONTEXT_FLAG_ASYNC,
                            _RawReadOverlapped.QueryDataBuffer() + _cbRawReadData,
                            QueryNextRawReadSize(),
                            NULL );
            goto ExitPoint;
        }

        if ( fComplete )
        {
            StartClose();
            hr = S_OK;
            goto ExitPoint;
        }
    }

    //
    // If after filtering there is data remaining in our buffer, then that
    // data is destined to the application.  Send it asynchronously because
    // there is a risk that synchronous call gets blocked for a long time
    //

    _cbRawReadData = 0;

    if ( rawStreamInfo.cbData != 0 )
    {
        //
        // Reset default raw read size
        //
        SetNextRawReadSize( FILTER_CHANNEL::QueryDefaultRawReadSize() );
        if ( !_RawReadOverlapped.ResizeDataBuffer( QueryNextRawReadSize() ) )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto ExitPoint;
        }

        //
        // Initiate a raw read that will send the data before posting the read.
        //

        _ulAppWriteAndRawReadFilterBuffer.BufferType = HttpFilterBufferHttpStream;
        _ulAppWriteAndRawReadFilterBuffer.pBuffer = _RawReadOverlapped.QueryDataBuffer();
        _ulAppWriteAndRawReadFilterBuffer.BufferSize = QueryNextRawReadSize();
        _ulAppWriteAndRawReadFilterBuffer.pWriteBuffer = rawStreamInfo.pbBuffer;
        _ulAppWriteAndRawReadFilterBuffer.WriteBufferSize = rawStreamInfo.cbData;
        _ulAppWriteAndRawReadFilterBuffer.Reserved = _pConnectionInfo->ConnectionId;

        hr = DoAppWriteAndRawRead(UL_CONTEXT_FLAG_ASYNC, &_ulAppWriteAndRawReadFilterBuffer);

        if ( FAILED( hr ) )
        {
            goto ExitPoint;
        }

    }
    else
    {
        //
        // Kick off another raw read
        //

        //
        // reset default raw read size
        //
        SetNextRawReadSize( FILTER_CHANNEL::QueryDefaultRawReadSize() );

        if ( !_RawReadOverlapped.ResizeDataBuffer( QueryNextRawReadSize() ) )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto ExitPoint;
        }

        hr = DoRawRead( UL_CONTEXT_FLAG_ASYNC,
                        _RawReadOverlapped.QueryDataBuffer(),
                        QueryNextRawReadSize() ,
                        NULL );
        if ( FAILED( hr ) )
        {
            goto ExitPoint;
        }
    }


    hr = S_OK;
    
ExitPoint:    
    //
    // Close connection if error was detected
    //
    if ( FAILED( hr ) )
    {
        StartClose();
    }
    
    //
    // Async Raw Read grabbed the reference. 
    // It is time to dereference now
    //
    DereferenceFiltChannelContext();
    return hr;
}

HRESULT
FILTER_CHANNEL_CONTEXT::OnRawWriteCompletion(
    DWORD                   /*cbCompletion*/,
    DWORD                   dwCompletionStatus,
    UL_OVERLAPPED_CONTEXT *    pContextOverlapped
)
/*++

Routine Description:

    after raw write completes, this routine has to assure that new asynchronous AppRead request is
    made to continue properly in communication

    Note: This completion should be caused only by asynchronous DoRawWrite started in completion routine
    of AppRead (OnAppReadCompletion()).
    Please assure that NO RawWrite that is initiated by data coming from RawRead (SSL handshake)
    will be called asynchronously. That could cause race condition (multiple threads using the same buffer
    eg. for SSL data encryption)


Arguments:

    cbCompletion - Bytes of completion (currently not used)
    dwCompletionStatus - Completion error

Return Value:

    HRESULT

--*/
{

    HRESULT hr = E_FAIL;

    
    
    switch ( pContextOverlapped->QuerySubtype() )
    {
        case UL_OVERLAPPED_CONTEXT_COMPLETION_CALLBACK:
        {
            //
            // delete context buffer allocated by SSPI package
            //
            hr = pContextOverlapped->DoCallback();
            
            //
            // time to delete temporary overlapped context
            //
            delete pContextOverlapped;
            pContextOverlapped = NULL;

            // if completion status failed then return completion
            // status, otherwise hr of the DoCallback
            if ( dwCompletionStatus != NO_ERROR )
            {
                break;
            }
            else
            {
                goto ExitPoint;
            }
        }
        case UL_OVERLAPPED_CONTEXT_TEMPORARY:
            //
            // time to delete temporary overlapped context
            //
            delete pContextOverlapped;
            pContextOverlapped = NULL;
            break;
        case UL_OVERLAPPED_CONTEXT_DATA:

            //
            // make overlapped to be available for next useq
            //
            ReleaseRawWriteBuffer( pContextOverlapped );
            if ( dwCompletionStatus != NO_ERROR )
            {
                break;
            }
            //
            // raw write completion triggers new AppRead
            // but there is only one outstanding AppRead allowed
            // a time ( while we have 2 outstanding RawWrites
            // to emilinate the delayed ACK problem - see Windows Bugs 394511 )
            //

            hr = TryAppRead();
            goto ExitPoint;
        default:
            DBG_ASSERT(FALSE);
            hr = E_FAIL;
            goto ExitPoint;
    }
    
    //
    // completion status must be returned
    //
    hr = HRESULT_FROM_WIN32( dwCompletionStatus );
    
ExitPoint:
    //
    // Close connection if error was detected
    //
    if ( FAILED( hr ) )
    {
        StartClose();
    }
    
    //
    // Async Raw Write grabbed the reference. 
    // It is time to dereference now
    //
    DereferenceFiltChannelContext();
    return hr;

}


HRESULT
FILTER_CHANNEL_CONTEXT::OnAppWriteCompletion(
    DWORD                   /*cbCompletion*/,
    DWORD                   dwCompletionStatus
)
/*++

Routine Description:

    OnAppWrite completion should be called only after handling
    graceful disconnect. All the other AppWrites must happen with
    DoAppWriteAndRawRead()


Arguments:

    cbCompletion - Bytes of completion (currently not used)
    dwCompletionStatus - Completion error

Return Value:

    HRESULT

--*/
{

    HRESULT hr = HRESULT_FROM_WIN32( dwCompletionStatus );
    
    //
    // Close connection if error was detected
    //
    if ( FAILED( hr ) )
    {
        StartClose();
    }
    
    //
    // Async App Write grabbed the reference. 
    // It is time to dereference now
    //
    DereferenceFiltChannelContext();
    return hr;
}



HRESULT
FILTER_CHANNEL_CONTEXT::DoAppWriteAndRawRead(
    DWORD                    dwFlags,
    PHTTP_FILTER_BUFFER_PLUS pHttpBufferPlus
)
/*++

Routine Description:

    Write data to the app and read some bytes from the wire

Arguments:

    dwFlags - UL_CONTEXT_ASYNC for async
    pHttpBufferPlus - read and write buffers

Return Value:

    HRESULT

--*/
{
    BOOL            fAsync = !!( dwFlags & UL_CONTEXT_FLAG_ASYNC );
    ULONG           ulRet = ERROR_SUCCESS;
    HRESULT         hr = NO_ERROR;

    IF_DEBUG( APP_RAW_READWRITE )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "ENTER DoAppWriteAndRawRead( async:%d )\n",
                    fAsync
                    ));
    }

    if ( fAsync )
    {
        ReferenceFiltChannelContext();
    }

    ulRet = HttpFilterAppWriteAndRawRead( _pManager->QueryFilterHandle(),
                                          pHttpBufferPlus,
                                          fAsync ? QueryRawReadOverlapped() : NULL);

    if ( fAsync )
    {
        if ( ulRet == NO_ERROR )
        {
            ulRet = ERROR_IO_PENDING;
        }

        if ( ulRet != ERROR_IO_PENDING )
        {
            DereferenceFiltChannelContext();
            hr = HRESULT_FROM_WIN32( ulRet );
        }
    }
    else
    {
        if ( ulRet != NO_ERROR )
        {
            hr = HRESULT_FROM_WIN32( ulRet );
        }
    }

    IF_DEBUG( APP_RAW_READWRITE )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "LEAVE DoAppWriteAndRawRead( async:%d )\n",
                    fAsync
                    ));
    }

    return hr;
}


HRESULT
FILTER_CHANNEL_CONTEXT::DoRawWrite(
    DWORD                                dwFlags,
    PVOID                                pvBuffer,
    DWORD                                cbBuffer,
    DWORD *                              pcbWritten,
    UL_OVERLAPPED_CONTEXT::PFN_CALLBACK  pfnCallback,
    PVOID                                pCallbackParam
)
/*++

Routine Description:

    Write some bytes to the wire

Arguments:

    dwFlags - UL_CONTEXT_ASYNC for async
    pvBuffer - Buffer to send
    cbBuffer - bytes in buffer
    pcbWritten - Bytes written
    pfnCallback - optional Callback function - default is NULL
    pCallbackParam - callback parameter -default is NULL
Return Value:

    HRESULT

--*/
{
    BOOL            fAsync = !!( dwFlags & UL_CONTEXT_FLAG_ASYNC );
    ULONG           ulRet = ERROR_SUCCESS;
    HRESULT         hr = NO_ERROR;
    OVERLAPPED *    pOverlapped = NULL;
    UL_OVERLAPPED_CONTEXT * pContextOverlappedBuffered = NULL;

    IF_DEBUG( APP_RAW_READWRITE )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "ENTER DoRawWrite( async:%d, buffered:%d, bytes:%d )\n",
                    fAsync,
                    !!( dwFlags & UL_CONTEXT_FLAG_BUFFERED ),
                    cbBuffer
                    ));
    }

    if ( fAsync )
    {

        if ( dwFlags & UL_CONTEXT_FLAG_COMPLETION_CALLBACK )
        {
            //
            // Create new temporary overlapped context
            //

            pContextOverlappedBuffered
                = new UL_OVERLAPPED_CONTEXT( UL_OVERLAPPED_CONTEXT_RAW_WRITE,
                                             UL_OVERLAPPED_CONTEXT_COMPLETION_CALLBACK );
            if ( pContextOverlappedBuffered == NULL )
            {
                hr = HRESULT_FROM_WIN32( ERROR_OUTOFMEMORY );
                goto Finished;
            }
            //
            // Configure new overlapped context
            //

            pContextOverlappedBuffered->SetContext( this );

            pContextOverlappedBuffered->SetCallBack( pfnCallback,
                                                     pCallbackParam );

            //
            // retrieve overlapped to be used for this RawWrite
            //

            pOverlapped = pContextOverlappedBuffered->QueryOverlapped();

        }
        else if ( dwFlags & UL_CONTEXT_FLAG_BUFFERED )
        {
            //
            // BUFFERED flag is set - we will make private copy
            // of the data to be sent to enable caller to use
            // it's buffer upon completion
            //

            //
            // Create new temporary overlapped context
            //

            pContextOverlappedBuffered
                = new UL_OVERLAPPED_CONTEXT( UL_OVERLAPPED_CONTEXT_RAW_WRITE,
                                             UL_OVERLAPPED_CONTEXT_TEMPORARY );
            if ( pContextOverlappedBuffered == NULL )
            {
                hr = HRESULT_FROM_WIN32( ERROR_OUTOFMEMORY );
                goto Finished;
            }

            //
            // Configure new overlapped context
            //

            pContextOverlappedBuffered->SetContext( this );

            //
            // copy data to be sent to private buffer
            // that is member of UL_OVERLAPPED_CONTEXT
            //

            if ( !pContextOverlappedBuffered->ResizeDataBuffer( cbBuffer ) )
            {
                hr = HRESULT_FROM_WIN32( ERROR_OUTOFMEMORY );
                goto Finished;
            }

            memcpy( pContextOverlappedBuffered->QueryDataBuffer(),
                    (PBYTE) pvBuffer,
                    cbBuffer );

            //
            // instead of data buffer passed by caller our private
            // buffer will be used. Thus caller will be able to reclaim
            // it's buffer after returing from this call without
            // waiting for completion
            //

            pvBuffer = pContextOverlappedBuffered->QueryDataBuffer();

            //
            // retrieve overlapped to be used for this RawWrite
            //

            pOverlapped = pContextOverlappedBuffered->QueryOverlapped();

        }
        else
        {

            //
            // Not buffered send.
            // We have to determine which Overlapped context to use
            // If pvBuffer was acquired by AcquireRawWriteBuffer()
            // then _pLastAcquiredRawWriteOverlapped is not NULL
            // and is pointing to the structure that contains the acquired buffer 
            //

            UL_OVERLAPPED_CONTEXT * pRawWriteUlOverlapped = QueryLastAcquiredRawWriteBufferOverlapped();

            if ( pRawWriteUlOverlapped == NULL ||
                 pRawWriteUlOverlapped->QueryDataBuffer() != (PBYTE) pvBuffer )
            {
                //
                // This data must be coming from rawdata filter
                // when SSL is not used (SSL will always use
                // buffers that are returned by AcquireRawWriteBuffer())
                //
                // It is necessary to copy data to private buffer
                // in order to be able to maintain 2 outstanding
                // RawWrites
                //

                PBYTE pbRawWriteBuffer = NULL;
                hr = AcquireRawWriteBuffer( &pbRawWriteBuffer,
                                            cbBuffer );

                if ( FAILED( hr ) )
                {
                   goto Finished;
                }

                memcpy( pbRawWriteBuffer,
                        (PBYTE) pvBuffer,
                        cbBuffer );


                pvBuffer = (PVOID) pbRawWriteBuffer;

                //
                // now it's guaranteed that we use one of the
                // DATA1 or DATA2 buffers for RawWrite
                // let's find out the associated overlapped
                //

                pRawWriteUlOverlapped = 
                    QueryLastAcquiredRawWriteBufferOverlapped();
                DBG_ASSERT( pRawWriteUlOverlapped != NULL );

            }
            pOverlapped = pRawWriteUlOverlapped->QueryOverlapped();
        }

        //
        // For all asynchonous we have to reference FiltChannelContext
        //

        ReferenceFiltChannelContext();

    }
    else
    {
        pOverlapped = NULL;
    }

    ulRet = HttpFilterRawWrite( _pManager->QueryFilterHandle(),
                                _pConnectionInfo->ConnectionId,
                                pvBuffer,
                                cbBuffer,
                                pcbWritten,
                                pOverlapped );
    
    if ( fAsync )
    {
        if ( ulRet == NO_ERROR )
        {
            ulRet = ERROR_IO_PENDING;
        }

        if ( ulRet != ERROR_IO_PENDING )
        {
            DereferenceFiltChannelContext();
            hr = HRESULT_FROM_WIN32( ulRet );
            goto Finished;
        }
        else
        {
            hr = NO_ERROR;
        }
    }
    else
    {
        //
        // for synchronous sends the raw write buffers must 
        // be released if they are owned by the 
        // FILTER_CHANNEL_CONTEXT 
        //
        TryReleaseLastAcquiredRawWriteBuffer();
        
        if ( ulRet != NO_ERROR )
        {
            hr = HRESULT_FROM_WIN32( ulRet );
            goto Finished;
        }
    }
Finished:
    if ( FAILED( hr ) )
    {
        if ( pContextOverlappedBuffered != NULL )
        {
            delete pContextOverlappedBuffered;
            pContextOverlappedBuffered = NULL;
        }
    }
    IF_DEBUG( APP_RAW_READWRITE )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "LEAVE DoRawWrite( async:%d, bytes:%d ) hr=0x%x\n",
                    fAsync,
                    cbBuffer,
                    hr
                    ));
    }

    return hr;
}

HRESULT
FILTER_CHANNEL_CONTEXT::DoAppRead(
    DWORD                   dwFlags,
    HTTP_FILTER_BUFFER *    pFilterBuffer,
    DWORD *                 pcbRead
)
/*++

Routine Description:

    Read data from application

Arguments:

    dwFlags - UL_CONTEXT_ASYNC for async
    pFilterBuffer - Filter buffer
    pcbRead - Bytes read

Return Value:

    HRESULT

--*/
{
    BOOL            fAsync = !!( dwFlags & UL_CONTEXT_FLAG_ASYNC );
    ULONG           ulRet = ERROR_SUCCESS;
    HRESULT         hr = NO_ERROR;

    IF_DEBUG( APP_RAW_READWRITE )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "ENTER DoAppRead( async:%d )\n",
                    fAsync
                    ));
    }

    if ( fAsync )
    {
        ReferenceFiltChannelContext();
    }

    ulRet = HttpFilterAppRead( _pManager->QueryFilterHandle(),
                               _pConnectionInfo->ConnectionId,
                               pFilterBuffer,
                               pFilterBuffer->BufferSize,
                               pcbRead,
                               fAsync ? QueryAppReadOverlapped() : NULL);

    if ( fAsync )
    {
        if ( ulRet == NO_ERROR )
        {
            ulRet = ERROR_IO_PENDING;
        }

        if ( ulRet != ERROR_IO_PENDING )
        {
            DereferenceFiltChannelContext();
            hr = HRESULT_FROM_WIN32( ulRet );
        }
    }
    else
    {
        if ( ulRet != NO_ERROR )
        {
            hr = HRESULT_FROM_WIN32( ulRet );
        }
    }

    IF_DEBUG( APP_RAW_READWRITE )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "LEAVE DoAppRead( async:%d )\n",
                    fAsync
                    ));
    }


    return hr;
}


HRESULT
FILTER_CHANNEL_CONTEXT::DoAppWrite(
    DWORD                   dwFlags,
    HTTP_FILTER_BUFFER *    pFilterBuffer,
    DWORD *                 pcbWritten
)
/*++

Routine Description:

    Write data to the application

Arguments:

    dwFlags - UL_CONTEXT_ASYNC for async
    pFilterBuffer - Filter buffer
    pcbWritten - Bytes written

Return Value:

    HRESULT

--*/
{
    BOOL            fAsync = !!( dwFlags & UL_CONTEXT_FLAG_ASYNC );
    ULONG           ulRet = ERROR_SUCCESS;
    HRESULT         hr = NO_ERROR;

    DBG_ASSERT( pFilterBuffer != NULL );

    IF_DEBUG( APP_RAW_READWRITE )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "ENTER DoAppWrite( async:%d, bytes:%d, buffertype:%d )\n",
                    fAsync,
                    pFilterBuffer->BufferSize,
                    pFilterBuffer->BufferType
                    ));
    }

    if ( fAsync )
    {
        ReferenceFiltChannelContext();
    }

    ulRet = HttpFilterAppWrite( _pManager->QueryFilterHandle(),
                                _pConnectionInfo->ConnectionId,
                                pFilterBuffer,
                                pFilterBuffer->BufferSize,
                                pcbWritten,
                                fAsync ? QueryAppWriteOverlapped() : NULL );

    if ( fAsync )
    {
        if ( ulRet == NO_ERROR )
        {
            ulRet = ERROR_IO_PENDING;
        }

        if ( ulRet != ERROR_IO_PENDING )
        {
            DereferenceFiltChannelContext();
            hr = HRESULT_FROM_WIN32( ulRet );
        }
    }
    else
    {
        if ( ulRet != NO_ERROR )
        {
            hr = HRESULT_FROM_WIN32( ulRet );
        }
    }

    IF_DEBUG( APP_RAW_READWRITE )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "LEAVE DoAppWrite( async:%d, bytes:%d, buffertype:%d ) hr=0x%x\n",
                    fAsync,
                    pFilterBuffer->BufferSize,
                    pFilterBuffer->BufferType,
                    hr
                    ));
    }

    return hr;
}

HRESULT
FILTER_CHANNEL_CONTEXT::DoRawRead(
    DWORD                   dwFlags,
    PVOID                   pvBuffer,
    DWORD                   cbBuffer,
    DWORD *                 pcbWritten
)
/*++

Routine Description:

    Read some bytes from the wire

Arguments:

    dwFlags - UL_CONTEXT_ASYNC for async
    pvBuffer - buffer
    cbBuffer - bytes in buffer
    pcbWritten - Bytes written

Return Value:

    HRESULT

--*/
{
    BOOL            fAsync = !!( dwFlags & UL_CONTEXT_FLAG_ASYNC );
    ULONG           ulRet = ERROR_SUCCESS;
    HRESULT         hr = NO_ERROR;

    IF_DEBUG( APP_RAW_READWRITE )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "ENTER DoRawRead( async:%d )\n",
                    fAsync
                    ));
    }

    if ( fAsync )
    {
        ReferenceFiltChannelContext();
    }

    ulRet = HttpFilterRawRead( _pManager->QueryFilterHandle(),
                               _pConnectionInfo->ConnectionId,
                               pvBuffer,
                               cbBuffer,
                               pcbWritten,
                               fAsync ? QueryRawReadOverlapped() : NULL);

    if ( fAsync )
    {
        if ( ulRet == NO_ERROR )
        {
            ulRet = ERROR_IO_PENDING;
        }

        if ( ulRet != ERROR_IO_PENDING )
        {
            DereferenceFiltChannelContext();
            hr = HRESULT_FROM_WIN32( ulRet );
        }
    }
    else
    {
        if ( ulRet != NO_ERROR )
        {
            hr = HRESULT_FROM_WIN32( ulRet );
        }
    }

    IF_DEBUG( APP_RAW_READWRITE )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "LEAVE DoRawRead( async:%d )\n",
                    fAsync
                    ));
    }

    return hr;
}


VOID
FILTER_CHANNEL_CONTEXT::StartClose(
    VOID
)
/*++

Routine Description:

    Start the process of closing the connection (and cleaning up FILTER_CHANNEL_CONTEXT)

Arguments:

    None

Return Value:

    None

--*/
{
    BOOL                    fOld;

    fOld = (BOOL) InterlockedCompareExchange( (PLONG) &_fCloseConnection,
                                              TRUE,
                                              FALSE );

    if ( fOld == FALSE )
    {
        // _fNewConnection = TRUE indicates that
        // there should not be valid connection info so there is nothing to be closed

        if( _pManager->QueryFilterHandle() != NULL && !_fNewConnection )
        {
            ULONG           ulRet = ERROR_SUCCESS;
            //
            // We don't have to grab the reference because
            // we use the initial connection reference
            //
            ulRet = HttpFilterClose( _pManager->QueryFilterHandle(),
                                     _pConnectionInfo->ConnectionId,
                                     QueryCloseOverlapped() );
            if ( ulRet == NO_ERROR )
            {
                //
                // Both NO_ERROR and ERROR_IO_PENDING
                // are expected to go the completion path
                //
                ulRet = ERROR_IO_PENDING;
            }

            if ( ulRet != ERROR_IO_PENDING )
            {
                //
                // Note: ERROR_INVALID_PARAMETER may be received if client
                // already closed the connection (connection ID will be considered invalid
                // from the http.sys point of view).
                //
                // Notify about closing and do the final dereference
                //
                
                CloseNotify();
        
                DereferenceFiltChannelContext();
            }

        }
        else
        {
            //
            // We were the ones to set the flag.  Do the final dereference
            //

            DereferenceFiltChannelContext();
        }
    }
    else
    {
        //
        // Someone else has set the flag.  Let them dereference
        //
    }
}


HRESULT
FILTER_CHANNEL_CONTEXT::DoAccept(
    VOID
)
/*++

Routine Description:

    Accept an incoming connection by calling HttpFilterAccept()

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ULONG               ulRet;
    HRESULT             hr = NO_ERROR;

    ReferenceFiltChannelContext();

    ulRet = HttpFilterAccept( _pManager->QueryFilterHandle(),
                              _pConnectionInfo,
                              _buffConnectionInfo.QuerySize(),
                              NULL,
                              QueryRawReadOverlapped() );

    if ( ulRet != ERROR_IO_PENDING )
    {
        hr = HRESULT_FROM_WIN32( ulRet );

        DereferenceFiltChannelContext();

        DBGPRINTF(( DBG_CONTEXT,
                    "Error calling HttpFilterAccept().  hr = %x\n",
                    hr ));
    }
    else
    {
        //
        // Another outstanding context available!
        //

        _pManager->IncrementOutstandingContexts();
    }

    return hr;
}

HRESULT
FILTER_CHANNEL_CONTEXT::SendDataBack(
    RAW_STREAM_INFO *       pRawStreamInfo
)
/*++

Routine Description:

    Sends given data back to client, while going with the ssl filter
    if necessary

Arguments:

    pRawStreamInfo - Raw data to send back

Return Value:

    HRESULT

--*/
{
    if ( pRawStreamInfo == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    DBG_ASSERT( _pSSLContext != NULL );

    //
    // ISAPI filter has sent back some data in a raw notification.
    // Have SSL process it and then send it here
    //

    HRESULT hr = _pSSLContext->SendDataBack( pRawStreamInfo );

    if ( FAILED( hr ) )
    {
        return hr;
    }

    //
    // Send back the data
    //
    // bump up the number of threads because
    // this is synchronous call that may block our thread
    // for quite a while
    //
    AddWorkerThread(); 
    hr = DoRawWrite( UL_CONTEXT_FLAG_SYNC,
                       pRawStreamInfo->pbBuffer,
                       pRawStreamInfo->cbData,
                       NULL );
    RemoveWorkerThread();
    return hr;

}

VOID 
FILTER_CHANNEL_CONTEXT::CloseNotify(
    VOID
)
/*++

Routine Description:
    Notify ISAPI Filter (if present) or whoever else interested
    that connection was closed

Arguments:
    None
               

Return Value:

    VOID

--*/
    
    
{
    //
    // Notify ISAPIs of the close
    //

    if ( _pISAPIContext != NULL )
    {
        //
        // We don't know what the raw write filter will do so we better
        // have a thead available to prevent blocking
        //
        AddWorkerThread();
        _pISAPIContext->ProcessConnectionClose();
        RemoveWorkerThread();
    }
}


//
// Constructor
//

FILTER_CHANNEL::FILTER_CHANNEL(
    LPWSTR pwszFilterChannelName
)
{
    _dwInitcsFiltChannelContexts           = 0;
    _cFiltChannelContexts                  = 0;
    _hFilterHandle                         = NULL;
    _lStartedListening                     = 0;
    _pThreadPool                           = NULL;
    _cDesiredOutstanding                   = 0;
    _cOutstandingContexts                  = 0;
    _lEnteredOutstandingContextsAddingLoop = 0;
    _pTraceLog                             = NULL;
    _lNotifyISAPIFilters                   = 0;
    _pwszFilterChannelName                 = pwszFilterChannelName;
    _hTimer                                = NULL;
    _dwTotalFilterChannelContexts          = 0;
};

//
// Destructor
//
FILTER_CHANNEL::~FILTER_CHANNEL()
{
}

HRESULT
FILTER_CHANNEL::Initialize(
    VOID
)
/*++

Routine Description:

    Global Initialization

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ULONG                   ulRet = ERROR_SUCCESS;
    HRESULT                 hr = NO_ERROR;
    BOOL                    fRet = FALSE;
    HKEY                    hKeyParam = NULL;
    DWORD                   dwType = 0;
    DWORD                   dwValue = 0;


    
    for ( int i = 0; i < NUM_CS_FILT_CHANNEL_CONTEXTS; i ++ )
    {
    
        fRet = InitializeCriticalSectionAndSpinCount(
                                &_csFiltChannelContexts[ i ],
                                0x80000000 /* precreate event */ |
                                IIS_DEFAULT_CS_SPIN_COUNT );
    
        if ( !fRet )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Finished;

        }
        _dwInitcsFiltChannelContexts ++;

        InitializeListHead( &_ListHead[ i ] );

        InitializeListHead( &_TimerListHead[ i ] );

    }


    #if DBG
        _pTraceLog = CreateRefTraceLog( 2000, 0 );
    #endif

    //
    // Read registry parameters
    //
    
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       REGISTRY_KEY_HTTPFILTER_PARAMETERS_W,
                       0,
                       KEY_READ,
                       &hKeyParam ) == NO_ERROR )
        {
            DWORD dwBytes = sizeof( dwValue );
            DWORD dwErr = RegQueryValueExW( hKeyParam,
                                    SZ_REG_DEFAULT_RAW_READ_SIZE,
                                    NULL,
                                    &dwType,
                                    ( LPBYTE )&dwValue,
                                    &dwBytes
                                    );

            if ( ( dwErr == ERROR_SUCCESS ) && 
                 ( dwType == REG_DWORD ) ) 
            {
                sm_dwDefaultRawReadSize = dwValue;
            }

            dwBytes = sizeof( dwValue );
            dwErr = RegQueryValueExW( hKeyParam,
                                    SZ_REG_DEFAULT_APP_READ_SIZE,
                                    NULL,
                                    &dwType,
                                    ( LPBYTE )&dwValue,
                                    &dwBytes
                                    );

            if ( ( dwErr == ERROR_SUCCESS ) && 
                 ( dwType == REG_DWORD ) ) 
            {
                // sizeof(HTTP_FILTER_BUFFER) is added because
                // compacted structure HTTP_FILTER_BUFFER is 
                // placed to provided buffer
                //
                sm_dwDefaultAppReadSize = dwValue + sizeof( HTTP_FILTER_BUFFER );
            }
            
            dwBytes = sizeof( dwValue );
            dwErr = RegQueryValueExW( hKeyParam,
                                    SZ_REG_CONTEXT_DESIRED_OUTSTANDING,
                                    NULL,
                                    &dwType,
                                    ( LPBYTE )&dwValue,
                                    &dwBytes
                                    );

            if ( ( dwErr == ERROR_SUCCESS ) && 
                 ( dwType == REG_DWORD ) ) 
            {
                sm_dwContextDesiredOutstanding = dwValue;
            }
            
            dwBytes = sizeof( dwValue );
            dwErr = RegQueryValueExW( hKeyParam,
                                    SZ_REG_ENABLE_TEMPORARY_BUFFERS,
                                    NULL,
                                    &dwType,
                                    ( LPBYTE )&dwValue,
                                    &dwBytes
                                    );

            if ( ( dwErr == ERROR_SUCCESS ) && 
                 ( dwType == REG_DWORD ) ) 
            {
                sm_fEnableTemporaryBuffers = !!dwValue;
            }

            dwBytes = sizeof( dwValue );
            dwErr = RegQueryValueExW( hKeyParam,
                                    SZ_RENEGOTIATION_TIMEOUT,
                                    NULL,
                                    &dwType,
                                    ( LPBYTE )&dwValue,
                                    &dwBytes
                                    );

            if ( ( dwErr == ERROR_SUCCESS ) && 
                 ( dwType == REG_DWORD ) ) 
            {
                sm_dwHandshakeTimeoutInSec = dwValue;
                if ( sm_dwHandshakeTimeoutInSec > MAXDWORD / 1000 )
                {
                    // Disable timers because
                    // the configured value is too large
                    //
                    sm_dwHandshakeTimeoutInSec = 0;
                }
                if ( sm_dwHandshakeTimeoutInSec > 0 &&
                     sm_dwHandshakeTimeoutInSec < MINIMUM_RENEGOTIATION_TIMEOUT_IN_SEC  )
                {
                    //
                    // MINIMUM_RENEGOTIATION_TIMEOUT_IN_SEC
                    // seconds is minimum for the timeout
                    //
                    sm_dwHandshakeTimeoutInSec = MINIMUM_RENEGOTIATION_TIMEOUT_IN_SEC;
                }
            }

            RegCloseKey( hKeyParam );
        }


    //
    // Get a UL handle to the RawStreamPool (or whatever)
    //

    ulRet = HttpCreateFilter( &_hFilterHandle,
                                _pwszFilterChannelName,
                                NULL,
                                0 );
    if ( ulRet != ERROR_SUCCESS )
    {
        //
        // HTTPFilter service may have created Filter already
        // try just open it then
        //
        ulRet = HttpOpenFilter( &_hFilterHandle,
                                  _pwszFilterChannelName,
                                  0 );
        if ( ulRet != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( ulRet );
            goto Finished;
        }
    }

    //
    // Create private thread pool for strmfilt
    //

    THREAD_POOL_CONFIG ThreadPoolConfig;
    SYSTEM_INFO     si;

    //
    // we will use GetSystemInfo to retrieve number of processors
    //
    GetSystemInfo( &si );
    
    hr = InitializeThreadPoolConfigWithDefaults( &ThreadPoolConfig );

    if (FAILED(hr))
    {
        goto Finished;
    }

    //
    // Manual override of some parameters
    //
    
    // The time (in msecs) of how long the threads can stay alive with no activity
    ThreadPoolConfig.dwThreadTimeout =
                            STRMFILT_THREAD_POOL_DEF_THREAD_TIMEOUT * 1000; 
    
    // The number of threads to start 
    ThreadPoolConfig.dwInitialThreadCount =
                            STRMFILT_THREAD_POOL_DEF_THREAD_COUNT;
                            
    ThreadPoolConfig.dwInitialStackSize = 
                            IIS_DEFAULT_INITIAL_STACK_SIZE;

    // There is not much blocking on FILTER_CHANNEL execution
    // Performance tests suggested that setting #threads to match
    // # processors is the right thing to do
    // Note:  There are cases where soft thread limit is bumped up
    // such as before AcceptSecurityContext() when hardware
    // accelerator is used

    //
    // we need miminum of 2 threads because current thread pool manager implementation
    // will not allow to add new threads when soft thread limit is incremented
    //
    
    ThreadPoolConfig.dwSoftLimitThreadCount = max( 2, si.dwNumberOfProcessors );

    //
    // Override threadpool settings with registry values (if configured)
    //
    hr = OverrideThreadPoolConfigWithRegistry( &ThreadPoolConfig,
                                               REGISTRY_KEY_HTTPFILTER_PARAMETERS_W );

    if (FAILED(hr))
    {
        goto Finished;
    }
      
    fRet = THREAD_POOL::CreateThreadPool( &_pThreadPool,
                                          &ThreadPoolConfig );
    if ( !fRet )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to create ThreadPool for Strmfilt\n" ));

        hr = E_FAIL;
        goto Finished;
    }

    DBG_ASSERT( _pThreadPool != NULL );

    //
    // Associate a completion routine with the thread pool
    //

    DBG_ASSERT( _hFilterHandle != INVALID_HANDLE_VALUE );
    DBG_ASSERT( _hFilterHandle != NULL );

    if ( !_pThreadPool->BindIoCompletionCallback(_hFilterHandle,
                                                 OverlappedCompletionRoutine,
                                                 0 ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Finished;
    }

    //
    // Keep a set number of filter accepts outstanding
    //

    _cDesiredOutstanding = sm_dwContextDesiredOutstanding;

    //
    // If sm_dwHandshakeTimeoutInSec == 0 then timers are disabled
    //
    
    if ( sm_dwHandshakeTimeoutInSec != 0 )
    {
        fRet = CreateTimerQueueTimer( 
                    &_hTimer,
                    NULL,
                    FILTER_CHANNEL::TimerCallback,
                    this,
                    (( sm_dwHandshakeTimeoutInSec / 2 )) * 1000,
                    (( sm_dwHandshakeTimeoutInSec / 2 )) * 1000,
                    WT_EXECUTELONGFUNCTION );
        if ( !fRet )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Finished;
        }
    }

Finished:
    if ( FAILED( hr ) )
    {
        FILTER_CHANNEL::Terminate();
    }
    return hr;
}


VOID
FILTER_CHANNEL::Terminate(
    VOID
)
/*++

Routine Description:

    Global termination

Arguments:

    None

Return Value:

    None

--*/
{
    
    //
    // Thread pool must be terminated before any other objects get cleaned up
    // to assure that there are no worker threads still executing
    //

    if ( _hTimer != NULL )
    {
        DeleteTimerQueueTimer(
            NULL, //use default timer queue
            _hTimer,
            INVALID_HANDLE_VALUE /*wait for completion of the callback*/);
        _hTimer = NULL;
    }

    if ( _pThreadPool != NULL )
    {
        _pThreadPool->TerminateThreadPool();
        _pThreadPool = NULL;
    }

    if ( _hFilterHandle != NULL )
    {
        CloseHandle( _hFilterHandle );
        _hFilterHandle = NULL;
    }

    if ( _pTraceLog != NULL )
    {
        DestroyRefTraceLog( _pTraceLog );
        _pTraceLog = NULL;
    }

    for ( int i = 0; i < _dwInitcsFiltChannelContexts; i ++ )
    {
        DeleteCriticalSection( &_csFiltChannelContexts[ i ] );
    }
    _dwInitcsFiltChannelContexts = 0;
    

};


VOID
FILTER_CHANNEL::InsertFiltChannelContext(
    FILTER_CHANNEL_CONTEXT *pFiltChannelContext
    )
{
    DWORD dwFilterContextCount = (DWORD) 
               InterlockedIncrement( (PLONG) &_dwTotalFilterChannelContexts );
    //
    // Determine which lock, sublist will be used for this context
    // Use round robin 
    //
    DWORD dwLockIndex = dwFilterContextCount % NUM_CS_FILT_CHANNEL_CONTEXTS;
    pFiltChannelContext->SetLockIndex( dwLockIndex );
     
    EnterCriticalSection( &_csFiltChannelContexts[ dwLockIndex ] );
    InsertHeadList( &_ListHead[ dwLockIndex ], &pFiltChannelContext->_ListEntry );
    //
    // We have to interlocked increment the _cFiltChannelContexts
    // because the the lock we acquired
    // is only the lock to a sublist of contexts so there may be
    // multiple concurrent attempts to increment _cFiltChannelContexts
    //
    InterlockedIncrement( (LONG *)&_cFiltChannelContexts );
    LeaveCriticalSection( &_csFiltChannelContexts[ dwLockIndex ] );
}


VOID
FILTER_CHANNEL::RemoveFiltChannelContext(
    FILTER_CHANNEL_CONTEXT *pFiltChannelContext
    )
{
    DWORD dwLockIndex = pFiltChannelContext->QueryLockIndex();
    EnterCriticalSection( &_csFiltChannelContexts[ dwLockIndex ] );
    InterlockedDecrement( (LONG *)&_cFiltChannelContexts );
    RemoveEntryList( &pFiltChannelContext->_ListEntry );
    LeaveCriticalSection( &_csFiltChannelContexts[ dwLockIndex ] );
}

VOID
FILTER_CHANNEL::InsertFiltChannelContextToTimerList(
    FILTER_CHANNEL_CONTEXT *pFiltChannelContext
    )
/*++

Routine Description:

    Add context to the timeout timer list

Arguments:

    pFiltChannelContext - context to be added to the timeout timer list

Return Value:

    None

--*/
   
{
    DWORD dwCurrentTickCount = GetTickCount();

    if ( sm_dwHandshakeTimeoutInSec == 0 )
    {
        // 
        // timeouts are disabled
        //
        return;
    }
    
    DWORD dwLockIndex = pFiltChannelContext->QueryLockIndex();
    
    EnterCriticalSection( &_csFiltChannelContexts[ dwLockIndex ] );
    if ( pFiltChannelContext->QueryIsAlreadyOnTimerList() )
    {
        // Entry already on the list but
        // tickCount for the entry will be updated
        // We have to remove entry from the current position
        // so that it can be added to the end since
        // the list is ordered by the TickCounts
        //
        RemoveEntryList( &pFiltChannelContext->_TimerListEntry );        
    }
    //
    // New entries go to the end of the list
    //
    InsertTailList( &_TimerListHead[ dwLockIndex ], &pFiltChannelContext->_TimerListEntry );
    
    pFiltChannelContext->SetTimerTickCount( dwCurrentTickCount );
    LeaveCriticalSection( &_csFiltChannelContexts[ dwLockIndex ] );
    
}


VOID
FILTER_CHANNEL::RemoveFiltChannelContextFromTimerList(
    FILTER_CHANNEL_CONTEXT *pFiltChannelContext
    )
{
/*++

Routine Description:

    Remove context from the timeout timer list

Arguments:

    pFiltChannelContext - context to be removed from the timeout timer list

Return Value:

    None

--*/
    
    DWORD dwLockIndex = pFiltChannelContext->QueryLockIndex();
    EnterCriticalSection( &_csFiltChannelContexts[ dwLockIndex ] );
    RemoveEntryList( &pFiltChannelContext->_TimerListEntry );
    pFiltChannelContext->ResetTimerTickCount();
    LeaveCriticalSection( &_csFiltChannelContexts[ dwLockIndex ] );
}


VOID
FILTER_CHANNEL::WaitForContextDrain(
    VOID
)
/*++

Routine Description:

    Wait for all contexts to go away

Arguments:

    None

Return Value:

    None

--*/
{
    while ( _cFiltChannelContexts != 0 )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Waiting for %d CONTEXTs for %S to drain\n",
                    _cFiltChannelContexts,
                    _pwszFilterChannelName ));

        Sleep( 1000 );
    }

    //
    // there should be no outstanding contexts left
    //

    DBG_ASSERT( _cOutstandingContexts == 0 );
}


HRESULT
FILTER_CHANNEL::StartListening(
    VOID
)

/*++

Routine Description:

    Start listening - create initial UL_CONTEXTs

Arguments:

    None

Return Value:

    HRESULT

--*/

{
    HRESULT hr = ManageOutstandingContexts();
    if ( SUCCEEDED( hr ) )
    {
        InterlockedExchange( &_lStartedListening, 1 );
    }
    return hr;
}


VOID
FILTER_CHANNEL::StopListening(
    VOID
)
/*++

Routine Description:

    Stop listening and wait for contexts to drain

Arguments:

    None

Return Value:

    None

--*/
{
    DBG_REQUIRE( HttpShutdownFilter( _hFilterHandle ) == ERROR_SUCCESS );
    InterlockedExchange(&_lStartedListening, 0 );

    WaitForContextDrain();
}


//
// Keep enough UL_CONTEXTs listening
//
HRESULT
FILTER_CHANNEL::ManageOutstandingContexts(
    VOID
)
/*++

Routine Description:

    add sufficient number of new contexts

Arguments:

    None

Return Value:

    HRESULT

--*/

{
    LONG                            cRequired;
    FILTER_CHANNEL_CONTEXT *        pContext;
    HRESULT                         hr = NO_ERROR;

    if ( _cOutstandingContexts < _cDesiredOutstanding )
    {
        cRequired = _cDesiredOutstanding - _cOutstandingContexts;

        //
        // Make sure the value is not negative
        //

        cRequired = max( 0, cRequired );

        for ( LONG i = 0; i < cRequired; i++ )
        {
            hr = CreateContext( &pContext );
            if ( FAILED( hr ) )
            {
                break;
            }

            DBG_ASSERT( pContext );

            hr = pContext->DoAccept();
            if ( FAILED( hr ) )
            {
                pContext->DereferenceFiltChannelContext();
                break;
            }
        }
    }

    return hr;
}


HRESULT
FILTER_CHANNEL::DecrementAndManageOutstandingContexts(
    VOID
)
/*++

Routine Description:

    Decrement available outstanding Context and
    add sufficient number of new contexts

Arguments:

    None

Return Value:

    HRESULT

--*/

{
    HRESULT hr = E_FAIL;
    LONG lPreviousContexts =
            InterlockedDecrement( &_cOutstandingContexts );
    if ( _lStartedListening == 1 )
    {
        hr = ManageOutstandingContexts();

        if ( FAILED(hr) &&
            lPreviousContexts == 1 )
        {
            //
            // If there are no outstanding contexts
            // strmfilt will not be able to accept new connections
            // Keep retrying until we succeed
            // or until service get's shut down
            //
            // Note: this loop will be blocking processing
            // the completion of the new connection but if
            // we hit problems with adding new outstanding context
            // that is big enough problem so we can afford
            // to sacrifise this one connection until
            // adding of new outstanding contexts succeeds

            LONG lOldValue = InterlockedExchange(
                &_lEnteredOutstandingContextsAddingLoop,
                1 );
            //
            // Let's have only one thread trying to add
            // outstanding contexts to minimize impact on system
            // (in low memory or similar condition - under normal
            // circumstances contexts should have no problems to be added)
            //

            if ( lOldValue == 0 )
            {
                //
                // if lOldValue = 0 it means we are the first thread trying
                //
                do
                {
                    Sleep( 2000 );
                    hr = ManageOutstandingContexts();
                }while( FAILED( hr ) && _lStartedListening == 1 );

                InterlockedExchange(
                    &_lEnteredOutstandingContextsAddingLoop,
                    0 );
            }
        }
    }
    return hr;
}

HRESULT
FILTER_CHANNEL::EnableISAPIFilters(
    ISAPI_FILTERS_CALLBACKS *      pConfig
)
/*++

Routine Description:

    enable ISAPI Filters
    ( all new connections will notify ISAPI Filters )

Arguments:

    pStreamConfig - config info

Return Value:

    HRESULT

--*/

{
    HRESULT                 hr = E_FAIL;

    hr = ISAPI_STREAM_CONTEXT::EnableISAPIFilters( pConfig );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    SetNotifyISAPIFilters( TRUE );
    return S_OK;
}


VOID
FILTER_CHANNEL::DisableISAPIFilters(
    VOID
)
/*++

Routine Description:

    safely terminate ISAPI Filters
    ( all connections with ISAPI Filters must be closed )

Arguments:

    None

Return Value:

    None

--*/

{
    //
    // stop notifying ISAPI Filters
    //
    SetNotifyISAPIFilters( FALSE );

    ISAPI_STREAM_CONTEXT::DisableISAPIFilters();
}


//static
VOID
WINAPI
FILTER_CHANNEL::TimerCallback(
    PVOID      pParam,
    BOOLEAN    
)
/*++

Routine Description:

    Close all the connections that have timed out based on the
    timer settings

Arguments:

    None

Return Value:

    None

--*/

{
    //
    // slTimerCallbackEntryCount will guard against the case
    // where new timer callback comes in when the previous is still
    // executing
    //
    
    static LONG slTimerCallbackEntryCount = 0;
    if ( InterlockedIncrement (&slTimerCallbackEntryCount ) != 1 )
    {
        InterlockedDecrement ( &slTimerCallbackEntryCount );
        return;
    }
    
    DWORD dwCurrentTickCount = GetTickCount();
    
    DBG_ASSERT( pParam != NULL );
    FILTER_CHANNEL * pFilterChannel = reinterpret_cast<FILTER_CHANNEL *>( pParam );


    // Filter channel Context lock is split to minimize scaling problems
    // 
    
    for ( int dwLockIndex = 0; dwLockIndex < NUM_CS_FILT_CHANNEL_CONTEXTS; 
            dwLockIndex ++ )
    {
        EnterCriticalSection( &pFilterChannel->_csFiltChannelContexts[ dwLockIndex ] );
        while ( !IsListEmpty ( &pFilterChannel->_TimerListHead [ dwLockIndex ] ) )
        {
            LIST_ENTRY *pCurrentEntry = 
                pFilterChannel->_TimerListHead[ dwLockIndex ].Flink;
            FILTER_CHANNEL_CONTEXT * pFiltChannelContext = 
                    CONTAINING_RECORD( pCurrentEntry,
                                       FILTER_CHANNEL_CONTEXT,
                                       _TimerListEntry );
           
            DBG_ASSERT( pFiltChannelContext->CheckSignature() );

            DWORD dwElapsedTimeInMSec;
            if ( dwCurrentTickCount < pFiltChannelContext->QueryTimerTickCount() )
            {
                //
                // Wrap around
                //
                dwElapsedTimeInMSec = MAXDWORD - dwCurrentTickCount + 
                                      pFiltChannelContext->QueryTimerTickCount();
            }
            else
            {
                dwElapsedTimeInMSec = dwCurrentTickCount - 
                                      pFiltChannelContext->QueryTimerTickCount();
            }

            if ( dwElapsedTimeInMSec < sm_dwHandshakeTimeoutInSec * 1000 )
            {
                //
                // all the subsequent entries are newer the the current one
                // so we can safely assume that neither of them needs to 
                // expire at this point
                //
                break;
            }
            //
            // It is time to request closing the connection
            //
            pFilterChannel->RemoveFiltChannelContextFromTimerList( 
                                    pFiltChannelContext );
            //
            // Note: Do not use pFilterChannelContext passed the StartClose()
            // because it will not be guaranteed to be around any more
            //
            // Note2: StartClose() may reentrantly acquire the 
            // pFilterChannel->_csFiltChannelContexts lock if destructor
            // happens to be called on FiltChannelContext dereference
            // inside the StartClose()
            pFiltChannelContext->StartClose();

        }
        LeaveCriticalSection( &pFilterChannel->_csFiltChannelContexts[ dwLockIndex ] );
    }
    InterlockedDecrement ( &slTimerCallbackEntryCount );
}


SSL_SERVER_FILTER_CHANNEL_CONTEXT::SSL_SERVER_FILTER_CHANNEL_CONTEXT(
    SSL_SERVER_FILTER_CHANNEL *pManager
    )
    : FILTER_CHANNEL_CONTEXT(pManager)
{
    _dwSignature = SSL_SERVER_FILTER_CHANNEL_CONTEXT_SIGNATURE;
    
}


SSL_SERVER_FILTER_CHANNEL_CONTEXT::~SSL_SERVER_FILTER_CHANNEL_CONTEXT()
{
    _dwSignature = SSL_SERVER_FILTER_CHANNEL_CONTEXT_SIGNATURE_FREE;
}


//static
HRESULT
SSL_SERVER_FILTER_CHANNEL_CONTEXT::Initialize(
    VOID
)
/*++

Routine Description:

    Global initialization routine for FILTER_CHANNEL_CONTEXT

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ALLOC_CACHE_CONFIGURATION       acConfig;

    //
    // Setup allocation lookaside
    //

    acConfig.nConcurrency = 1;
    acConfig.nThreshold = 100;
    acConfig.cbSize = sizeof( SSL_SERVER_FILTER_CHANNEL_CONTEXT );

    DBG_ASSERT( sm_pachFilterChannelContexts == NULL );

    sm_pachFilterChannelContexts = new ALLOC_CACHE_HANDLER( "SSL_SERVER_FILTER_CHANNEL_CONTEXT",  
                                                &acConfig );

    if ( sm_pachFilterChannelContexts == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }

    return NO_ERROR;
}


//static
VOID
SSL_SERVER_FILTER_CHANNEL_CONTEXT::Terminate(
    VOID
)
/*++

Routine Description:

    Terminate FILTER_CHANNEL_CONTEXT globals

Arguments:

    None

Return Value:

    None

--*/
{
    if ( sm_pachFilterChannelContexts != NULL )
    {
        delete sm_pachFilterChannelContexts;
        sm_pachFilterChannelContexts = NULL;
    }
}


HRESULT
SSL_SERVER_FILTER_CHANNEL_CONTEXT::Create(
    VOID
)
/*++

Routine Description:

    Initialize a SSL_SERVER_FILTER_CHANNEL_CONTEXT

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    DBG_ASSERT( _pSSLContext == NULL );
    DBG_ASSERT( _pISAPIContext == NULL );


    _pSSLContext = new SSL_STREAM_CONTEXT( this );
    if ( _pSSLContext == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    return NO_ERROR;
}



VOID
OverlappedCompletionRoutine(
    DWORD               dwErrorCode,
    DWORD               dwNumberOfBytesTransfered,
    LPOVERLAPPED        lpOverlapped
)
/*++

Routine Description:

    Magic completion routine

Arguments:

    None

Return Value:

    None

--*/
{
    UL_OVERLAPPED_CONTEXT *         pContextOverlapped = NULL;
    HRESULT                         hr;
    FILTER_CHANNEL_CONTEXT *        pFiltChannelContext = NULL;

    DBG_ASSERT( lpOverlapped != NULL );

    pContextOverlapped = 
        UL_OVERLAPPED_CONTEXT::GetUlOverlappedContext( lpOverlapped );
    
    DBG_ASSERT( pContextOverlapped != NULL );

    //
    // pFiltChannelContext was referenced in the Async Read/Write call
    // Reference is still held and it is safe to access the object
    // Completion routines will release the reference
    //
    
    pFiltChannelContext = pContextOverlapped->QueryContext();

    //
    // Call the appropriate completion routine
    //

    //
    // Note: Completion routines may delete UL_OVERLAPPED_CONTEXT
    // at least OnRawWriteCompletion() deletes temporary contexts
    // Do not use pContextOverlapped after CompletionRoutines were called
    //

    switch( pContextOverlapped->QueryType() )
    {
    case UL_OVERLAPPED_CONTEXT_RAW_READ:
        IF_DEBUG( APP_RAW_READWRITE )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "ENTER OnRawReadCompletion( bytes:%d, dwErr:%d )\n",
                        dwNumberOfBytesTransfered,
                        dwErrorCode
                        ));
        }

        hr = pFiltChannelContext->OnRawReadCompletion( dwNumberOfBytesTransfered,
                                                       dwErrorCode );
        IF_DEBUG( APP_RAW_READWRITE )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "LEAVE OnRawReadCompletion( bytes:%d, dwErr:%d ) hr=0x%x\n",
                        dwNumberOfBytesTransfered,
                        dwErrorCode,
                        hr
                        ));
        }
        break;

    case UL_OVERLAPPED_CONTEXT_RAW_WRITE:
        IF_DEBUG( APP_RAW_READWRITE )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "ENTER OnRawWriteCompletion( bytes:%d, dwErr:%d )\n",
                        dwNumberOfBytesTransfered,
                        dwErrorCode
                        ));
        }

        hr = pFiltChannelContext->OnRawWriteCompletion( dwNumberOfBytesTransfered,
                                                        dwErrorCode,
                                                        pContextOverlapped );

        IF_DEBUG( APP_RAW_READWRITE )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "LEAVE OnRawWriteCompletion( bytes:%d, dwErr:%d ) hr=0x%x\n",
                        dwNumberOfBytesTransfered,
                        dwErrorCode,
                        hr
                        ));
        }
        break;

    case UL_OVERLAPPED_CONTEXT_APP_READ:
        IF_DEBUG( APP_RAW_READWRITE )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "ENTER OnAppReadCompletion( bytes:%d, dwErr:%d )\n",
                        dwNumberOfBytesTransfered,
                        dwErrorCode
                        ));
        }

        hr = pFiltChannelContext->OnAppReadCompletion( dwNumberOfBytesTransfered,
                                                       dwErrorCode );
        IF_DEBUG( APP_RAW_READWRITE )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "LEAVE OnAppReadCompletion ( bytes:%d, dwErr:%d ) hr=0x%x\n",
                        dwNumberOfBytesTransfered,
                        dwErrorCode,
                        hr
                        ));
        }

        break;

    case UL_OVERLAPPED_CONTEXT_APP_WRITE:
        IF_DEBUG( APP_RAW_READWRITE )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "ENTER OnAppWriteCompletion( bytes:%d, dwErr:%d )\n",
                        dwNumberOfBytesTransfered,
                        dwErrorCode
                        ));
        }

        hr = pFiltChannelContext->OnAppWriteCompletion( dwNumberOfBytesTransfered,
                                                        dwErrorCode );

        IF_DEBUG( APP_RAW_READWRITE )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "LEAVE OnAppWriteCompletion( bytes:%d, dwErr:%d ) hr=0x%x\n",
                        dwNumberOfBytesTransfered,
                        dwErrorCode,
                        hr
                        ));
        }

        break;
        case UL_OVERLAPPED_CONTEXT_CLOSE:
        IF_DEBUG( APP_RAW_READWRITE )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Connection close completed (there still may be outstanding I/Os unless the refcount is 1)\n"
                        ));
        }
        
        //
        // Closing the connection was completed
        // Notify whoever is interested
        //
        
        pFiltChannelContext->CloseNotify();

        //
        // Do the final dereference
        //
        
        pFiltChannelContext->DereferenceFiltChannelContext();
        
        break;
    default:
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        DBG_ASSERT( FALSE );
    }

    pFiltChannelContext = NULL;

    // Reference on the context was released in completion routine
    // don't use it past this point
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\sfwp\sslconfigprov\client\sslconfigchangeprovclient.cxx ===
/*++

   Copyright    (c)    2001    Microsoft Corporation

   Module  Name :
     sslconfigchangeprovclient.cxx

   Abstract:
     SSL CONFIG CHANGE PROV client

     Receives SSL configuration change parameters detected by server side

     User of this class shold inherit it class and implement 
     PipeListener() to process notifications

 
   Author:
     Jaroslav Dunajsky      April-24-2001

   Environment:
     Win32 - User Mode

   Project:
     Stream Filter Worker Process
--*/



#include "precomp.hxx"

HRESULT
SSL_CONFIG_CHANGE_PROV_CLIENT::StartListeningForChanges(
    IN SSL_CONFIG_CHANGE_CALLBACK * pSslConfigChangeCallback,
    IN OPTIONAL PVOID  pvParam
    )
/*++

Routine Description:
    Create thread to handle SSL configuration change notification
    
Arguments:
    pSslConfigChangeCallback - callback function that receives change details
    pvParam  - optional parameter that will be passed as first param to callback

Return Value:

    HRESULT

--*/    
{
    HRESULT hr = E_FAIL;

    IF_DEBUG( TRACE )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "SSL_CONFIG_CHANGE_PROV_CLIENT::StartListeningForChanges()\n"
                    ));
    }

    if ( pSslConfigChangeCallback == NULL )
    {
        DBG_ASSERT( pSslConfigChangeCallback != NULL );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    //
    // store the callback function pointer, and first parameter
    //
    _pSslConfigChangeCallback = pSslConfigChangeCallback;
    _pSslConfigChangeCallbackParameter = pvParam;
    
    //
    // Initialize parent (it will handle all the pipe initialization)
    //
    hr = SSL_CONFIG_PIPE::PipeInitializeClient( WSZ_SSL_CONFIG_CHANGE_PIPE );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    //
    // Connect pipe
    //
    hr = SSL_CONFIG_PIPE::PipeConnect( );
    if ( SUCCEEDED( hr ) )
    {
          _fConnected = TRUE;
    }
    
    return hr;
}
   
HRESULT
SSL_CONFIG_CHANGE_PROV_CLIENT::StopListeningForChanges(
    VOID
    )
/*++

Routine Description:
    Close named pipe for SSL config change notifications
    
Arguments:

Return Value:

    HRESULT

--*/    
{
    IF_DEBUG( TRACE )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "SSL_CONFIG_CHANGE_PROV_CLIENT::StopListeningForChanges\n"
                    ));
    }
    
    //
    // Disconnect pipe
    //
    
    SSL_CONFIG_PIPE::PipeDisconnect( );
    _fConnected = FALSE;
    
    return SSL_CONFIG_PIPE::PipeTerminate( );
}

//virtual
HRESULT
SSL_CONFIG_CHANGE_PROV_CLIENT::PipeListener(
    VOID
    )

/*++

Routine Description:

    Pipe listener on the client side handles SSL Config change notifications

    Function is started on private thread launched by 
    base class SSL_CONFIG_PIPE during pipe initialization
    
Arguments:

Return Value:

    HRESULT

--*/
{
    SSL_CONFIG_PIPE_COMMAND     Command;
    HRESULT                     hr = E_FAIL;
    DWORD                       dwSiteId;

    //
    // Listen on pipe to receive commands
    // and handle them
    //
    while ( TRUE )
    {
        hr = PipeReceiveCommand( &Command );
        if ( FAILED( hr ) )
        {
           //
           // failure may simply mean that 
           // termination has started and
           // pipe handle was closed
           //
           
           goto  Cleanup;
        }
        
        
        dwSiteId = Command.dwParameter1;

        //
        // make the callback
        //
        DBG_ASSERT( _pSslConfigChangeCallback != NULL );
        (* _pSslConfigChangeCallback) (
                _pSslConfigChangeCallbackParameter,
                static_cast<SSL_CONFIG_CHANGE_COMMAND_ID> 
                                ( Command.dwCommandId ),
                dwSiteId );
    }
    
    return S_OK;
Cleanup:
    _fConnected = FALSE;
    DBG_ASSERT( FAILED( hr ) );
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\sfwp\sslconfigprov\client\sslconfigprovclient.cxx ===
/*++

   Copyright    (c)    2001    Microsoft Corporation

   Module  Name :
     sslconfigprovclient.cxx

   Abstract:
     SSL CONFIG PROV client

     Client provides easy way of retrieving SSL related parameters
     through named pipes.
     Only one pipe connection is currently supported and 
     all client threads have to share it 
     ( exclusive access is maintained by locking )

     
     Client side is guaranteed not to use any COM stuff.
     Not using COM was requirement from NT Security folks
     to enable HTTPFilter be hosted in lsass
 
   Author:
     Jaroslav Dunajsky      April-24-2001

   Environment:
     Win32 - User Mode

   Project:
     Stream Filter Worker Process
--*/



#include "precomp.hxx"




HRESULT
SSL_CONFIG_PROV_CLIENT::Initialize(
    IN SSL_CONFIG_CHANGE_CALLBACK * pSslConfigChangeCallback,
    IN OPTIONAL PVOID  pvParam
    )
/*++

Routine Description:
    Connect to SSL_CONFIG_PIPE
    
Arguments:

Return Value:

    HRESULT

--*/    
{
    HRESULT hr = E_FAIL;

    IF_DEBUG( TRACE )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "SSL_CONFIG_PROV_CLIENT::Initialize()\n"
                    ));
    }

    //
    // store the callback function pointer, and first parameter
    //
    _pSslConfigChangeCallback = pSslConfigChangeCallback;
    _pSslConfigChangeCallbackParameter = pvParam;
    
  
    //
    // Initialize parent (it will handle all the pipe initialization)
    //
    return SSL_CONFIG_PIPE::PipeInitializeClient( WSZ_SSL_CONFIG_PIPE );
    

}
   
HRESULT
SSL_CONFIG_PROV_CLIENT::Terminate(
    VOID
    )
/*++

Routine Description:
    Cleanup
    
Arguments:

Return Value:

    HRESULT

--*/    
{
    IF_DEBUG( TRACE )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "SSL_CONFIG_PROV_CLIENT::Terminate()\n"
                    ));
    }
    
    _SslConfigChangeProvClient.StopListeningForChanges();
    SSL_CONFIG_PIPE::PipeDisconnect();
    
    return SSL_CONFIG_PIPE::PipeTerminate();
}

HRESULT
SSL_CONFIG_PROV_CLIENT::MaintainPipeConnection(
    VOID
    )
/*++

Routine Description:
    Maintain pipe connection. If connection is not opened
    then reopen it

    Caller must assure that Pipe is locked when this call is made
    
Arguments:

Return Value:

    HRESULT

--*/ 
{
    HRESULT  hr = E_FAIL;
    
    //
    // Config change provider has easy way to find out 
    // if pipe was disconnected because it is actively listening on it
    // we assume that if config change provider is connected already, then
    // the config provider is connected as well
    //
    
    if ( !_SslConfigChangeProvClient.IsConnected() )
    {
        //
        // Check if config provider was ever connected
        // If previous connection failed 
        // (the reason would most likely be crash of inetinfo)
        // it is safer to terminate all connections and
        // then try to reconnect
        //

        DBG_ASSERT( IsPipeLocked() );
        _SslConfigChangeProvClient.StopListeningForChanges();

        SSL_CONFIG_PIPE::PipeDisconnect();

        
        //
        // Connect to change notification pipe
        //
        
        hr = _SslConfigChangeProvClient.StartListeningForChanges(
                        _pSslConfigChangeCallback,
                        _pSslConfigChangeCallbackParameter );
        
        if ( FAILED( hr ) )
        {
            return hr;
        }

        //
        // Connect to ssl config pipe
        //
        
        hr = SSL_CONFIG_PIPE::PipeConnect();

        if (FAILED( hr ) )
        {
            _SslConfigChangeProvClient.StopListeningForChanges();

            return hr;
        }

        //
        // Notify user of the config provider
        // that all data received so far that may be cached
        // should be flushed
        //
        
        DBG_ASSERT( _pSslConfigChangeCallback != NULL );
        (* _pSslConfigChangeCallback) (
                _pSslConfigChangeCallbackParameter,
                CMD_CHANGED_ALL,
                0 );
        
            
        return hr;
    }
    return S_OK;
}

HRESULT 
SSL_CONFIG_PROV_CLIENT::GetOneSiteSecureBindings(
    IN  DWORD     dwSiteId,
    OUT MULTISZ * pSecureBindings
    )
/*++

Routine Description:
    Retrieve secure bindings for specified site
    
Arguments:

Return Value:

    HRESULT

--*/    
{
    DWORD dwReturnedSiteId = 0;
    IF_DEBUG( TRACE )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "GetOneSiteSecureBindings( %d )\n",
                    dwSiteId ));
    }

    SSL_CONFIG_PIPE_COMMAND   Command;
    HRESULT                   hr = E_FAIL;

    DBG_ASSERT( pSecureBindings != NULL );
    
    Command.dwCommandId = CMD_GET_ONE_SITE_SECURE_BINDINGS;
    Command.dwParameter1 = dwSiteId;

    PipeLock();

    //
    // assure that pipe will be open
    //
    hr = MaintainPipeConnection();
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
    
    hr = PipeSendCommand( &Command );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
    
    hr = ReceiveOneSiteSecureBindings( &dwReturnedSiteId , 
                                       pSecureBindings );

Cleanup:
    if( FAILED( hr ) )
    {
        IF_DEBUG( TRACE )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "GetOneSiteSecureBindings( %d ) leaving with error. hr = 0x%x\n",
                        hr ));
        }
    }
    PipeUnlock();
    return hr;

}

HRESULT 
SSL_CONFIG_PROV_CLIENT::ReceiveOneSiteSecureBindings(
    OUT DWORD *   pdwSiteId,
    OUT MULTISZ * pSecureBindings
    )
/*++

Routine Description:
    read secure bindings from pipe

    Note: it's caller's responsibility to have pipe access locked
    
Arguments:

Return Value:

    HRESULT

--*/    
{
    SSL_CONFIG_PIPE_RESPONSE_HEADER   ResponseHeader;
    HRESULT                           hr = E_FAIL;

    DBG_ASSERT( pSecureBindings != NULL );
    DBG_ASSERT( pdwSiteId != NULL );
    DBG_ASSERT( IsPipeLocked() );
    
    hr = PipeReceiveResponseHeader( &ResponseHeader );
    if ( FAILED( hr ) )
    {
        goto failed;
    }
    DBG_ASSERT( ResponseHeader.dwCommandId == CMD_GET_ONE_SITE_SECURE_BINDINGS );
    *pdwSiteId = ResponseHeader.dwParameter1;
    
    if ( FAILED ( ResponseHeader.hrErrorCode ) )
    {
        //
        // return error reported by ssl configuration info provider
        //
        //BUGBUG always read data to clean up pipe
        
        hr = ResponseHeader.hrErrorCode;
        goto failed;
    }
    if ( !pSecureBindings->Resize( ResponseHeader.dwResponseSize ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError());
        goto failed;
    }

    hr = PipeReceiveData( ResponseHeader.dwResponseSize,
                          reinterpret_cast<BYTE *>(pSecureBindings->QueryPtr()) );
    if ( FAILED( hr ) )
    {
        goto failed;
    }    
    return S_OK;
failed:
    DBG_ASSERT( FAILED( hr ) );
    return hr;    
    
}


HRESULT
SSL_CONFIG_PROV_CLIENT::StartAllSitesSecureBindingsEnumeration(
    VOID
    )
/*++

Routine Description:
    Lock named pipe for exclusive access
    Send command over named pipe to read all secure bindings

    Note: StopSiteSecureBindingsEnumeration() must be called
    to unlock named pipe (after successfull
    StartAllSitesSecureBindingsEnumeration() call )
Arguments:

Return Value:

    HRESULT

--*/    
{
    SSL_CONFIG_PIPE_COMMAND            Command;
    SSL_CONFIG_PIPE_RESPONSE_HEADER    ResponseHeader;
    HRESULT                            hr = E_FAIL;

    IF_DEBUG( TRACE )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "StartAllSitesSecureBindingsEnumeration\n",
                    hr ));
    }
   
    Command.dwCommandId = CMD_GET_ALL_SITES_SECURE_BINDINGS;
    Command.dwParameter1 = 0;

    PipeLock();
    
    //
    // assure that pipe will be open
    //
    hr = MaintainPipeConnection();
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    hr = PipeSendCommand( &Command );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    hr = PipeReceiveResponseHeader( &ResponseHeader );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }

    DBG_ASSERT( ResponseHeader.dwCommandId == Command.dwCommandId );
    //
    // Response size 0 means that reponse will be terminated by 
    // special termination record 
    //
    DBG_ASSERT( ResponseHeader.dwResponseSize == 0 );

    if ( FAILED( ResponseHeader.hrErrorCode ) )
    {
        hr = ResponseHeader.hrErrorCode;
        goto Failure;
    }
    
    hr = S_OK;
    return hr;
   
Failure:
    IF_DEBUG( TRACE )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "StartAllSitesSecureBindingsEnumeration() leaving with error. hr = 0x%x\n",
                    hr ));
    }

    PipeUnlock();
    return hr;
}

HRESULT
SSL_CONFIG_PROV_CLIENT::StopAllSitesSecureBindingsEnumeration(
    VOID
    )
/*++

Routine Description:
    If all enumerated data was not read using GetNextSiteSecureBindings()
    it will read the leftover. Then unlock access to named pipe

    Note: call only after successful StartAllSitesSecureBindingsEnumeration()

Arguments:

Return Value:

    HRESULT

--*/    
{
    IF_DEBUG( TRACE )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "StopAllSitesSecureBindingsEnumeration\n"
                   ));
    }
    
    PipeUnlock();
    return S_OK;
}

HRESULT
SSL_CONFIG_PROV_CLIENT::GetNextSiteSecureBindings( 
    OUT DWORD *   pdwId,
    OUT MULTISZ * pSecureBindings
    )
/*++

Routine Description:
    Enumerate all Secure Bindings after StartSiteSecureBindingsEnumeration()
    was called

    Note: StopSiteSecureBindingsEnumeration() must always be called
    afterwards to unlock named pipe

    Note: only those sites that contain secure bindings will be enumerated

Arguments:
    pdwId - ID of the enumerated site
    pSecureBindings - secure bindings

Return Value:

    HRESULT  
             HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) means that all Sites
             have been enumerated already. This signals the end of enumeration

--*/    
{
    return ReceiveOneSiteSecureBindings ( pdwId,
                                          pSecureBindings );
}

HRESULT
SSL_CONFIG_PROV_CLIENT::GetOneSiteSslConfiguration(
    IN  DWORD dwSiteId,
    OUT SITE_SSL_CONFIGURATION * pSiteSslConfiguration
    )
/*++

Routine Description:
    Get all SSL configuration parameters for specified site
    
Arguments:
    dwSiteId
    SiteSslConfiguration

Return Value:

    HRESULT

--*/    
{
    SSL_CONFIG_PIPE_COMMAND         Command;
    SSL_CONFIG_PIPE_RESPONSE_HEADER ResponseHeader;
    HRESULT                           hr = E_FAIL;

    IF_DEBUG( TRACE )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "GetOneSiteSslConfiguration( %d )\n",
                    dwSiteId ));
    }

    Command.dwCommandId = CMD_GET_SSL_CONFIGURATION;
    Command.dwParameter1 = dwSiteId;

    //
    // Get exclusive access to pipe
    //
    PipeLock();
    
    //
    // assure that pipe will be open
    //
    
    hr = MaintainPipeConnection();
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
    
    //
    // Send command to request SSL CONFIGURATION
    //
    
    hr = PipeSendCommand( &Command );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Receive response header and later addition response data if available
    //
    
    hr = PipeReceiveResponseHeader( &ResponseHeader );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    if ( ResponseHeader.dwCommandId != CMD_GET_SSL_CONFIGURATION ||
         ResponseHeader.dwResponseSize != sizeof(*pSiteSslConfiguration) )
    {
        DBG_ASSERT( FALSE );
        hr = E_FAIL;
        goto Cleanup;
    }

    if ( FAILED ( ResponseHeader.hrErrorCode ) )
    {
        //
        // return error reported by ssl configuration info provider
        //
        
        hr = ResponseHeader.hrErrorCode;

        //
        // Read data to cleanup the pipe
        //
        PipeReceiveData( sizeof(*pSiteSslConfiguration),
                          reinterpret_cast<BYTE *>(pSiteSslConfiguration) );
            
        goto Cleanup;
    }
    
    //
    // Receive additional data
    //
    
    hr = PipeReceiveData( sizeof(*pSiteSslConfiguration),
                          reinterpret_cast<BYTE *>(pSiteSslConfiguration) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }    
    
    hr = S_OK;

Cleanup:
    if ( FAILED( hr ) )
    {
        IF_DEBUG( TRACE )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "GetOneSiteSslConfiguration( %d ) leaving with error. hr = 0x%x\n",
                        dwSiteId,
                        hr ));
        }
    }
    //
    // Done with pipe
    //
    PipeUnlock();
    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\sfwp\sslconfigprov\inc\dbgutil.h ===
/*++

Copyright (c) 1994-1998 Microsoft Corporation

Module Name:

    dbgutil.h

Abstract:

    This module declares the macros to wrap around DEBUG_PRINTS class
    defined in pudebug.h    
  
    This is the exported header file, that the users are allowed to modify.
    If there are no custom definitions, please use the templated version
    in the root iisrearc\inc\dbgutil.h
 
Author:

    Murali R. Krishnan (MuraliK)    22-Sept-1994

--*/


# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_



// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputKdb )


// end_user_modifiable


//
// include standard debug support
//
// note: define DEFAULT_OUTPUT_FLAGS before including pudebug.h
//

# include <pudebug.h>


// begin_user_modifiable

// Use the default constants from pudebug.h: 0x00000001 to 0x00000100

//
//  Define the debugging constants as bit-flag values
//  Example: # define DEBUG_FOOBAR 0x00010000
//  Note: All debugging bit-values below 0x00001000 are reserved!
// 
//  If you add or change a flag, please update FlagTableWp
//  in core\common\dtflags\dtflags.c
//


# define    DEBUG_TRACE                0x10000000
# define    DEBUG_DUMPS                0x20000000


// end_user_modifiable


# endif  /* _DBGUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\sfwp\sslconfigprov\pipe\sslconfigpipe.cxx ===
/*++

   Copyright    (c)    2001    Microsoft Corporation

   Module  Name :
     sslconfigpipe.cxx

   Abstract:
     SSL CONFIG PIPE implementation

     simple blocking pipe implementation
     that enables
     - sending/receiving commands,
     - sending/receiving response headers
     - sending/receiving arbitrary data blocks
     - implementing pipe listener that runs on dedicated thread
     - safe cleanup for thread running pipe listener

   Author:
     Jaroslav Dunajsky      April-24-2001

   Environment:
     Win32 - User Mode

   Project:
     Stream Filter Worker Process
--*/


// BUGBUG - how to handle errors during pipe operations
// if there is some data left over on pipe unread then all subsequent
// users of the pipe will be toast. Should we just close and reopen pipe connection?



#include "precomp.hxx"


//static
DWORD
SSL_CONFIG_PIPE::PipeListenerThread(
    LPVOID ThreadParam
    )
/*++

Routine Description:
    start PipeListener() method on listener thread
Arguments:

Return Value:

    HRESULT

--*/

{
    DBG_ASSERT( ThreadParam != NULL );

    HRESULT                     hr = E_FAIL;
    SSL_CONFIG_PIPE *           pConfigPipe
                    = reinterpret_cast<SSL_CONFIG_PIPE *>(ThreadParam);

    do
    {
        if ( pConfigPipe->_fServer )
        {
            //
            // connect for server is blocking
            // (it has to wait for client to connect)
            // it is done on worker thread
            // (client always connects before thread is launched)
            //
            hr = pConfigPipe->PipeConnectServer();
            if ( FAILED( hr ) )
            {
                return WIN32_FROM_HRESULT( hr );
            }
        }
        hr = pConfigPipe->PipeListener();

        //
        // Ignore errors from PipeListener
        // Error may have happened due to the following reasons
        // - client has disconnected ( this is OK )
        // - there was some other error executing command
        // - SSL_INFO_PROVIDER_SERVER is terminating (pipe handle was closed)
        //

        if ( pConfigPipe->_fServer )
        {
            //
            // connect for server is blocking
            // (it has to wait for client to connect)
            // it is done on worker thread
            // (client always connects before thread is launched)
            //
            pConfigPipe->PipeDisconnectServer();
        }

    }while ( pConfigPipe->_fServer && !pConfigPipe->QueryPipeIsCancelled() );

    return NO_ERROR;
}


HRESULT
SSL_CONFIG_PIPE::PipeInitialize(
    IN const WCHAR * wszPipeName,
    IN BOOL          fServer
    )
/*++

Routine Description:
    Create/connect named pipe
    Create listener thread ( if PipeListener() implemented )

Arguments:

    wszPipeName - pipe name to create/connect
    fServer    - indicate server side pipe (determines whether to create
                 or connect to pipe )

Return Value:

    HRESULT

--*/
{
    HRESULT         hr = E_FAIL;
    BOOL            fRet = FALSE;

    DBG_ASSERT( _InitStatus == INIT_NONE );

    _fServer = fServer;

    if ( FAILED( hr = _strPipeName.Copy( wszPipeName ) ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to copy pipe name.  hr = %x\n",
                    hr ));

        goto Cleanup;
    }

    fRet = InitializeCriticalSectionAndSpinCount(
                                &_csPipeLock,
                                0x80000000 | IIS_DEFAULT_CS_SPIN_COUNT );
    if ( !fRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to initialize critical section.  hr = %x\n",
                    hr ));
        goto Cleanup;
    }
    _InitStatus = INIT_PIPE_LOCK_CREATED;
    //
    // Setup overlapped
    //

    ZeroMemory( &_OverlappedR,
                sizeof( _OverlappedR ) );

    ZeroMemory( &_OverlappedW,
                sizeof( _OverlappedW ) );


    // Create an event object for this instance.

    _OverlappedR.hEvent = CreateEvent(
                 NULL,    // no security attribute
                 TRUE,    // manual-reset event
                 TRUE,    // initial state = signaled
                 NULL);   // unnamed event object

    if ( _OverlappedR.hEvent == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to create Event.  hr = %x\n",
                    hr ));

        goto Cleanup;
    }
    _InitStatus = INIT_OVERLAPPED_R_CREATED;
    // Create an event object for this instance.

    _OverlappedW.hEvent = CreateEvent(
                 NULL,    // no security attribute
                 TRUE,    // manual-reset event
                 TRUE,    // initial state = signaled
                 NULL);   // unnamed event object

    if ( _OverlappedW.hEvent == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to create Event.  hr = %x\n",
                    hr ));

        goto Cleanup;
    }
    _InitStatus = INIT_OVERLAPPED_W_CREATED;

    _hCancelEvent = CreateEvent(
                 NULL,    // no security attribute
                 TRUE,    // manual-reset event = true
                 FALSE,   // initial state = not signaled
                 NULL);   // unnamed event object

    if ( _hCancelEvent == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to create _hCancelEvent.  hr = %x\n",
                    hr ));

        goto Cleanup;
    }
    _InitStatus = INIT_CANCEL_EVENT_CREATED;


    hr = S_OK;

    if( _fServer )
    {
        //
        // create a named pipe
        //

       _hSslConfigPipe = CreateNamedPipe(
                    wszPipeName,
                    PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED ,
                    PIPE_TYPE_BYTE | PIPE_READMODE_BYTE | PIPE_WAIT,
                    10, // number of instances
                    4096,
                    4096,
                    0,
                    NULL /* pSa */ );

        if ( _hSslConfigPipe == INVALID_HANDLE_VALUE )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            DBGPRINTF(( DBG_CONTEXT,
                        "Failed to create %S pipe.  hr = %x\n",
                        wszPipeName,
                        hr ));
            goto Cleanup;
        }
        _InitStatus = INIT_SERVER_END_PIPE_CREATED;

        //
        // only server side pipe is connected automatically
        // during initialization
        //
        if ( FAILED( hr = PipeConnect() ) )
        {
            goto Cleanup;
        }

        _InitStatus = INIT_PIPE_CONNECTED;
    }



    hr = S_OK;
Cleanup:
    if ( FAILED( hr ) )
    {
        PipeTerminate();
    }
    return hr;
}

HRESULT
SSL_CONFIG_PIPE::PipeTerminate(
    VOID
    )
/*++

Routine Description:
    close pipe, handle proper cleanup ot the listener thread

Arguments:
    none

Return Value:

    HRESULT

--*/
{

    switch ( _InitStatus )
    {
    case INIT_PIPE_CONNECTED:

        PipeDisconnect();

    case INIT_SERVER_END_PIPE_CREATED:
        if ( _fServer )
        {

            if ( _hSslConfigPipe != INVALID_HANDLE_VALUE )
            {
                CloseHandle( _hSslConfigPipe );
                _hSslConfigPipe = INVALID_HANDLE_VALUE;
            }
        }
    case INIT_CANCEL_EVENT_CREATED:
        if ( _hCancelEvent != NULL )
        {
            CloseHandle( _hCancelEvent );
            _hCancelEvent = NULL;
        }

    case INIT_OVERLAPPED_W_CREATED:
        if ( _OverlappedW.hEvent != NULL )
        {
            CloseHandle( _OverlappedW.hEvent );
            _OverlappedW.hEvent = NULL;
        }

    case INIT_OVERLAPPED_R_CREATED:

        if ( _OverlappedR.hEvent != NULL )
        {
            CloseHandle( _OverlappedR.hEvent );
            _OverlappedR.hEvent = NULL;
        }

    case INIT_PIPE_LOCK_CREATED:
        DeleteCriticalSection( &_csPipeLock );

    }

    _InitStatus = INIT_NONE;
    return S_OK;
}


VOID
SSL_CONFIG_PIPE::PipeLock(
    VOID
    )
/*++

Routine Description:
    Lock named pipe to guarantee exclusive access

Arguments:

Return Value:

    VOID

--*/
{
    EnterCriticalSection( &_csPipeLock );

    _dwCurrThreadId = GetCurrentThreadId();
    _dwLockRecursionLevel++;

    IF_DEBUG( TRACE )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    " Locked SSL_CONFIG_PIPE.\n" ));

    }

}

VOID
SSL_CONFIG_PIPE::PipeUnlock(
    VOID
    )
/*++

Routine Description:
    Unlock named pipe

Arguments:

Return Value:

    VOID

--*/
{
     _dwLockRecursionLevel--;
     if ( _dwLockRecursionLevel == 0 )
     {
        _dwCurrThreadId = 0;
     }

    LeaveCriticalSection( &_csPipeLock );
    IF_DEBUG( TRACE )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    " Unlocked SSL_CONFIG_PIPE.\n" ));

    }

}



HRESULT
SSL_CONFIG_PIPE::PipeConnect(
    VOID
    )
/*++

Routine Description:
    Connect pipe

Arguments:

Return Value:

    HRESULT

--*/
{
    HRESULT hr = E_FAIL;

    ResetEvent( _hCancelEvent );
    InterlockedExchange( &_CancelFlag, 0 );

    if ( _fServer )
    {
        if ( !QueryEnablePipeListener() )
        {
            hr = PipeConnectServer();
            if ( FAILED( hr ) )
            {
                return hr;
            }
        }
    }
    else
    {
        if ( _hSslConfigPipe != INVALID_HANDLE_VALUE )
        {
            DBG_ASSERT( FALSE );
            return HRESULT_FROM_WIN32( ERROR_PIPE_CONNECTED );
        }

        //
        // Client always connects before listener thread is launched
        // (server will connect on on worker thread - if pipe listener is implemented
        //
        hr = PipeConnectClient();
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }
    hr = S_OK;
    if ( QueryEnablePipeListener() )
    {
        _hPipeListenerThread =
              ::CreateThread(
                      NULL,     // default security descriptor
                      // Big initial size to prevent stack overflows
                      IIS_DEFAULT_INITIAL_STACK_SIZE,
                      SSL_CONFIG_PIPE::PipeListenerThread,
                      this,     // thread argument - pointer to this class
                      0,        // create running
                      NULL      // don't care for thread identifier
                      );
        if ( _hPipeListenerThread == NULL )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            DBGPRINTF(( DBG_CONTEXT,
                            "Failed to create thread for SSL_CONFIG_PIPE. hr=0x%x\n",
                            hr ));
            return hr;
        }
    }
    return hr;
}



VOID
SSL_CONFIG_PIPE::PipeCancel(
    VOID
    )
/*++

Routine Description:
    Cancel pipe

    After calling PipeCancel all currently pending operations will be canceled
    and any subsequent read, writes will be cancelled as well (until next PipeConnect)

Arguments:

Return Value:

    VOID

--*/
{

    InterlockedExchange( &_CancelFlag, 1 );
    SetEvent( _hCancelEvent );

}

HRESULT
SSL_CONFIG_PIPE::PipeDisconnect(
    VOID
    )
/*++

Routine Description:
    Disconnect pipe

    Caller is responsible to make sure that
    there are no threads (other then pipe worker thread) using this pipe

Arguments:

Return Value:

    HRESULT

--*/
{
    HRESULT hr = E_FAIL;
    //
    // check if pipe was disconnected already
    //
    if ( _hSslConfigPipe == INVALID_HANDLE_VALUE )
    {
        return S_OK;
    }

    //
    // Cancel all pending calls on pipe
    //
    PipeCancel();

    //
    // wait for listener thread to complete
    // because it may still be using pipe
    //

    if ( _hPipeListenerThread != NULL )
    {
        //
        // Wait till worker thread has completed
        //
        DWORD dwRet = WaitForSingleObject( _hPipeListenerThread,
                                           INFINITE );

        DBG_ASSERT( dwRet == WAIT_OBJECT_0 );
        CloseHandle( _hPipeListenerThread );
        _hPipeListenerThread = NULL;
    }

    if ( _fServer )
    {
        hr = PipeDisconnectServer();
    }
    else
    {
        hr = PipeDisconnectClient();
    }

    return hr;
}

//private
HRESULT
SSL_CONFIG_PIPE::PipeConnectServer(
    VOID
    )
/*++

Routine Description:
    Connect pipe on the server side
    Call is blocking until pipe connected


Arguments:

Return Value:

   HRESULT

--*/
{
    BOOL    fRet = FALSE;
    DWORD   cbBytes = 0;
    HRESULT hr = E_FAIL;

    DBG_ASSERT( _fServer );



    // Start an overlapped connection for this pipe instance.
    fRet = ConnectNamedPipe( _hSslConfigPipe,
                             &_OverlappedR );

    // Overlapped ConnectNamedPipe should return zero.
    if ( fRet )
    {
        return S_OK;
    }

    hr = HRESULT_FROM_WIN32( GetLastError() );
    hr = PipeWaitForCompletion( hr,
                                &_OverlappedR,
                                &cbBytes );
    if ( FAILED( hr ) && !QueryPipeIsCancelled() )
    {
         DBGPRINTF(( DBG_CONTEXT,
                    "Failed on ConnectNamedPipe().  hr = %x\n",
                    hr ));
    }
    return hr;
}

//private
HRESULT
SSL_CONFIG_PIPE::PipeDisconnectServer(
        VOID
        )
/*++

Routine Description:
    Disconnect server side pipe

Arguments:

Return Value:

    HRESULT

--*/
{
    DBG_ASSERT( _fServer );
    if( ! DisconnectNamedPipe( _hSslConfigPipe ) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    return S_OK;
}

//private
HRESULT
SSL_CONFIG_PIPE::PipeConnectClient(
    VOID
    )
/*++

Routine Description:
    Connect pipe on the client side

Arguments:

Return Value:

    VOID

--*/
{
    HRESULT  hr = E_FAIL;

    DBG_ASSERT( !_fServer );

    //
    // Client (connect to existing pipe)
    //
    _hSslConfigPipe = CreateFile( _strPipeName.QueryStr(),
                                GENERIC_READ | GENERIC_WRITE,
                                0,
                                NULL,//&sa,
                                OPEN_EXISTING,
                                FILE_FLAG_OVERLAPPED,
                                NULL );
    if ( _hSslConfigPipe == INVALID_HANDLE_VALUE )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to connect to %S pipe.  hr = %x\n",
                    _strPipeName.QueryStr(),
                    hr ));
        return hr;
    }


    return S_OK;
}

//private
HRESULT
SSL_CONFIG_PIPE::PipeDisconnectClient(
    VOID
    )
/*++

Routine Description:
    Disconnect pipe on the client side

Arguments:

Return Value:

    HRESULT

--*/
{
    //
    // _SSLConfigucationPipe is created before
    // _hSslConfigurationPipeHandlingThread is created
    // and based on typical cleanup logic it would be expected
    // that will be closed closed after thread completed
    // However, we have to close _SSLConfigucationPipe beforehand
    // because that will actually trigger thread to complete
    //
    DBG_ASSERT( !_fServer );

    if ( _hSslConfigPipe != INVALID_HANDLE_VALUE )
    {
        CloseHandle( _hSslConfigPipe );
        _hSslConfigPipe = INVALID_HANDLE_VALUE;
    }
    return S_OK;
}


HRESULT
SSL_CONFIG_PIPE::PipeSendData(
    IN DWORD  cbNumberOfBytesToWrite,
    IN BYTE * pbBuffer
    )
/*++

Routine Description:
      Send specified number of bytes from named pipe

Arguments:
    cbNumberOfBytesToWrite - bytes to write
    pbBuffer - data
Return Value:

    HRESULT

--*/
{
    DWORD                     cbNumberOfBytesWritten;
    BOOL                      fRet = FALSE;
    HRESULT                   hr = E_FAIL;

    if ( _hSslConfigPipe == INVALID_HANDLE_VALUE )
    {
        return HRESULT_FROM_WIN32( ERROR_PIPE_NOT_CONNECTED );
    }
    fRet = WriteFile ( _hSslConfigPipe,
                       pbBuffer,
                       cbNumberOfBytesToWrite,
                       &cbNumberOfBytesWritten,
                       &_OverlappedW );
    if ( !fRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        hr = PipeWaitForCompletion( hr,
                                    &_OverlappedW,
                                    &cbNumberOfBytesToWrite );
        IF_DEBUG( TRACE )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        " Wait for PipeSendData(%d bytes) completion.\n",
                        cbNumberOfBytesWritten ));
        }

        if ( FAILED( hr )  )
        {
            if ( !QueryPipeIsCancelled() &&
                 hr != HRESULT_FROM_WIN32( ERROR_PIPE_LISTENING ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "Failed to send response over named pipe SSL_CONFIG_PIPE.  hr = %x\n",
                            hr ));
            }
            return hr;
        }
    }
    if ( cbNumberOfBytesToWrite != cbNumberOfBytesWritten )
    {
        hr = E_FAIL;
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to send response over named pipe SSL_CONFIG_PIPE.  hr = %x\n",
                    hr ));
        return hr;

    }
    IF_DEBUG( TRACE )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "PipeSendData(%d bytes) completed.\n",
                    cbNumberOfBytesWritten ));
    }
    return S_OK;
}

HRESULT
SSL_CONFIG_PIPE::PipeReceiveData(
    IN  DWORD  cbBytesToRead,
    OUT BYTE * pbBuffer
    )
/*++

Routine Description:
    Receive specified number of bytes from named pipe

Arguments:
    cbNumberOfBytesToRead - number of bytes to read -
                            function will not return success unless
                            specified number of bytes was read
    pbBuffer              - allocated by caller

Return Value:
    HRESULT

--*/
{
    DWORD                     cbNumberOfBytesRead = 0;
    DWORD                     cbTotalNumberOfBytesRead = 0;
    BOOL                      fRet = FALSE;
    HRESULT                   hr = E_FAIL;

    DBG_ASSERT ( cbBytesToRead != 0 );

    if ( _hSslConfigPipe == INVALID_HANDLE_VALUE )
    {
        return HRESULT_FROM_WIN32( ERROR_PIPE_NOT_CONNECTED );
    }

    do
    {
        fRet = ReadFile(   _hSslConfigPipe,
                           pbBuffer,
                           cbBytesToRead - cbTotalNumberOfBytesRead,
                           &cbNumberOfBytesRead,
                           &_OverlappedR );
        if ( !fRet )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            IF_DEBUG( TRACE )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            " Wait for PipeReceiveData(%d bytes) completion.\n",
                            cbBytesToRead - cbTotalNumberOfBytesRead ));
            }
            hr = PipeWaitForCompletion( hr,
                                        &_OverlappedR,
                                        &cbNumberOfBytesRead );
            if ( FAILED( hr ) )
            {
                if ( !QueryPipeIsCancelled() &&
                     ( hr != HRESULT_FROM_WIN32( ERROR_BROKEN_PIPE ) ) )
                {
                    //
                    // do not dump broken pipe errors
                    //
                    DBGPRINTF(( DBG_CONTEXT,
                                "Failed to receive request over named pipe SSL_INFO_PROV.  hr = %x\n",
                                hr ));
                }

                PipeCleanup();
                return hr;
            }

        }
        if ( cbNumberOfBytesRead == 0 )
        {
            hr = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
            DBGPRINTF(( DBG_CONTEXT,
                    "Failed to receive request over named pipe SSL_INFO_PROV - end of pipe.  hr = %x\n",
                    hr ));

            PipeCleanup();
            return hr;

        }
        cbTotalNumberOfBytesRead += cbNumberOfBytesRead;

    } while ( cbTotalNumberOfBytesRead != cbBytesToRead );
    IF_DEBUG( TRACE )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "PipeReceiveData(%d bytes) completed.\n",
                    cbTotalNumberOfBytesRead ));
    }

    return S_OK;
}

HRESULT
SSL_CONFIG_PIPE::PipeWaitForCompletion(
    IN  HRESULT     hrLastError,
    IN OVERLAPPED * pOverlapped,
    OUT DWORD *     pcbTransferred
        )
/*++

Routine Description:
    Wait for completion of nonblocking operation
    used for CreateNamedPipe, ReadFile and WriteFile

    Note: To outside world this pipe implementation is blocking
    but internally we use OVERLAPPED and that wait for completion.
    That way it is possible to terminate pipe by closing handle

Arguments:

Return Value:

    VOID

--*/
{
    BOOL    fRet = FALSE;
    DWORD   dwRet = 0;
    HRESULT hr = E_FAIL;
    HANDLE events[2];

    switch ( hrLastError )
    {
    case HRESULT_FROM_WIN32( ERROR_IO_PENDING ):
        //
        // The overlapped connection in progress.
        // wait for event to be signalled
        //
        events[0] = pOverlapped->hEvent;
        events[1] = _hCancelEvent;
        dwRet = WaitForMultipleObjects( 2,
                                        events,
                                        FALSE,
                                        INFINITE );
        if ( dwRet == WAIT_OBJECT_0 )
        {

            fRet = GetOverlappedResult(
                            _hSslConfigPipe,              // handle to pipe
                            pOverlapped,                // OVERLAPPED structure
                            pcbTransferred,             // bytes transferred
                            FALSE );                    // do not wait
            if ( !fRet )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
                return hr;
            }
            return S_OK;
        }
        else if ( dwRet == WAIT_OBJECT_0 + 1 )
        {
            CancelIo( _hSslConfigPipe );
            // we had to cancel so return approppriate error

            return HRESULT_FROM_WIN32( ERROR_OPERATION_ABORTED );
        }
        else
        {
            DBG_ASSERT( FALSE );
        }
    case HRESULT_FROM_WIN32( ERROR_PIPE_CONNECTED ):
         // Client is already connected
         return S_OK;

    default:

         return hrLastError;

    }
}


HRESULT
SSL_CONFIG_PIPE::PipeReceiveCommand(
    OUT SSL_CONFIG_PIPE_COMMAND * pCommand
    )
/*++

Routine Description:
    Receive command to execute

Arguments:
    pCommand

Return Value:
    HRESULT

--*/
{
    return PipeReceiveData( sizeof(SSL_CONFIG_PIPE_COMMAND),
                            reinterpret_cast<BYTE *>(pCommand) );

}

HRESULT
SSL_CONFIG_PIPE::PipeReceiveResponseHeader(
    OUT SSL_CONFIG_PIPE_RESPONSE_HEADER * pResponseHeader
    )
/*++

Routine Description:
    after command was sent over named pipe, use PipeReceiveResponseHeader
    to retrieve initial header of the response (it contains all the relevant
    information to complete reading the whole response)

Arguments:
    ResponseHeader

Return Value:
    HRESULT

--*/
{
    return PipeReceiveData( sizeof(SSL_CONFIG_PIPE_RESPONSE_HEADER),
                            reinterpret_cast<BYTE *>(pResponseHeader) );

}

HRESULT
SSL_CONFIG_PIPE::PipeSendCommand(
    OUT SSL_CONFIG_PIPE_COMMAND * pCommand
    )
/*++

Routine Description:
    Send command to execute

Arguments:
    pCommand

Return Value:
    HRESULT

--*/
{
    return PipeSendData( sizeof(SSL_CONFIG_PIPE_COMMAND),
                         reinterpret_cast<BYTE *>(pCommand) );

}

HRESULT
SSL_CONFIG_PIPE::PipeSendResponseHeader(
    OUT SSL_CONFIG_PIPE_RESPONSE_HEADER * pResponseHeader
    )
/*++

Routine Description:
    send response header

Arguments:
    pResponseHeader

Return Value:
    HRESULT

--*/
{
    return PipeSendData( sizeof(SSL_CONFIG_PIPE_RESPONSE_HEADER),
                         reinterpret_cast<BYTE *>(pResponseHeader) );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\sfwp\sslconfigprov\iisadminextension\iisadminextension.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    extcom.cxx

Abstract:

    IIS Services IISADMIN Extension
    Main COM interface.
    Class CadmExt
    
    CLSID = CLSID_SSLCONFIGPROV
    IID = IID_IADMEXT

    extension is used to launch SSL CONFIGURATION PROVIDER in the inetinfo
    that would enable strmfilt.dll to connect to named pipes and retrieve
    metabase data rather than using COM based metabase (ABO). 

Author:

    Michael W. Thomas            16-Sep-97


--*/

#include "precomp.hxx"

//
//  Debug parameters registry key.
//

#define MODULE_NAME_A   "sslcfg"

#define REGISTRY_KEY_SSLCFG_PARAMETERS_A  \
                "System\\CurrentControlSet\\Services\\w3svc\\Parameters\\" MODULE_NAME_A


#include <initguid.h>


CAdmExt::CAdmExt():
    m_dwRefCount(0)
{
}

CAdmExt::~CAdmExt()
{
}

HRESULT
CAdmExt::QueryInterface(REFIID riid, void **ppObject) {
    if (riid==IID_IUnknown || riid==IID_IADMEXT) {
        *ppObject = (IADMEXT *) this;
    }
    else {
        *ppObject = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NO_ERROR;
}

ULONG
CAdmExt::AddRef()
{
    DWORD dwRefCount;
    InterlockedIncrement((long *)&g_dwRefCount);
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}

ULONG
CAdmExt::Release()
{
    DWORD dwRefCount;
    InterlockedDecrement((long *)&g_dwRefCount);
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    //
    // This is now a member of class factory.
    // It is not dynamically allocated, so don't delete it.
    //
/*
    if (dwRefCount == 0) {
        delete this;
        return 0;
    }
*/
    return dwRefCount;
}

HRESULT STDMETHODCALLTYPE
CAdmExt::Initialize(void)
{
    HRESULT hr = E_FAIL;
    CREATE_DEBUG_PRINT_OBJECT( MODULE_NAME_A );
    LOAD_DEBUG_FLAGS_FROM_REG_STR( REGISTRY_KEY_SSLCFG_PARAMETERS_A , 0 );

    if (!VALID_DEBUG_PRINT_OBJECT())
    {
        return E_FAIL;
    }


    hr = m_SslConfigProvServer.Initialize();
    if ( FAILED( hr ) )
    {
        return hr;
    } 

    hr = m_SslConfigChangeProvServer.Initialize();
    return hr;	    
}


HRESULT STDMETHODCALLTYPE
CAdmExt::EnumDcomCLSIDs(
    /* [size_is][out] */ CLSID *pclsidDcom,
    /* [in] */ DWORD dwEnumIndex)
{
    return HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
}

HRESULT STDMETHODCALLTYPE
CAdmExt::Terminate(void)
{
    HRESULT   hr = E_FAIL;
    hr = m_SslConfigChangeProvServer.Terminate();
    DBG_ASSERT( SUCCEEDED( hr ) );

    hr = m_SslConfigProvServer.Terminate();
    DBG_ASSERT( SUCCEEDED( hr ) );
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\sfwp\sslconfigprov\iisadminextension\classfactory.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    classfactory.cxx

Abstract:

    starts/stops SSL configuration provider 

Author:

    Michael W. Thomas            16-Sep-97

    Jaroslav DUnajsky            24-Apr-2001
    - used code brom svcext.dll to write new metabase extension that gets started
    - during iisadmin startup and starts SSL CONFIG PROVIDER


--*/

#define INITGUID
#include "precomp.hxx"


//
// Globals
//
ULONG g_dwRefCount;
CAdmExtSrvFactory g_aesFactory;


DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();
DECLARE_PLATFORM_TYPE();



#define SZ_EXTENSION_DESCRIPTION  TEXT("SSL CONFIG PROVIDER - IISAdmin extension")
#define SZ_DLLNAME		  TEXT("sslcfg.dll")

CAdmExtSrvFactory::CAdmExtSrvFactory()
    :m_admextObject()
{
    m_dwRefCount=0;
    g_dwRefCount = 0;
    //
    // Addref object, so refcount doesn't go to 0 if all clients release.
    //
    m_admextObject.AddRef();
}

CAdmExtSrvFactory::~CAdmExtSrvFactory()
{
    m_admextObject.Release();
}
HRESULT
CAdmExtSrvFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void ** ppObject)
{
    if (pUnkOuter != NULL) {
        return CLASS_E_NOAGGREGATION;
    }
    if (FAILED(m_admextObject.QueryInterface(riid, ppObject))) {
        return E_NOINTERFACE;
    }
    return NO_ERROR;
}

HRESULT
CAdmExtSrvFactory::LockServer(BOOL fLock)
{
    if (fLock) {
        InterlockedIncrement((long *)&g_dwRefCount);
    }
    else {
        InterlockedDecrement((long *)&g_dwRefCount);
    }
    return NO_ERROR;
}

HRESULT
CAdmExtSrvFactory::QueryInterface(REFIID riid, void **ppObject)
{
    if (riid==IID_IUnknown || riid == IID_IClassFactory) {
            *ppObject = (IClassFactory *) this;
    }
    else {
        *ppObject = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NO_ERROR;
}

ULONG
CAdmExtSrvFactory::AddRef()
{
    DWORD dwRefCount;
    InterlockedIncrement((long *)&g_dwRefCount);
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}

ULONG
CAdmExtSrvFactory::Release()
{
    DWORD dwRefCount;
    InterlockedDecrement((long *)&g_dwRefCount);
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    //
    // There must only be one copy of this. So keep the first one around regardless.
    //
    //    if (dwRefCount == 0) {
    //        delete this;
    //    }
    return dwRefCount;
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void** ppObject)
{
    if (rclsid != CLSID_SSLCONFIGPROV) {
        return CLASS_E_CLASSNOTAVAILABLE;
    }

    if (FAILED(g_aesFactory.QueryInterface(riid, ppObject))) {
        *ppObject = NULL;
        return E_INVALIDARG;
    }
    return NO_ERROR;
}

HRESULT _stdcall DllCanUnloadNow() {
        if (g_dwRefCount) {
                return S_FALSE;
                }
        else {
                return S_OK;
                }
}


STDAPI DllRegisterServer(void)
{
    HKEY hKeyCLSID, hKeyInproc32;
    DWORD dwDisposition;
    HMODULE hModule;
    DWORD dwReturn = ERROR_SUCCESS;

    dwReturn = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                              TEXT("CLSID\\") SZ_CLSID_SSLCONFIGPROV,
                              NULL,
                              TEXT(""),
                              REG_OPTION_NON_VOLATILE,
                              KEY_ALL_ACCESS,
                              NULL,
                              &hKeyCLSID,
                              &dwDisposition);
    if (dwReturn == ERROR_SUCCESS) {
        dwReturn = RegSetValueEx(hKeyCLSID,
                                 TEXT(""),
                                 NULL,
                                 REG_SZ,
                                 (BYTE*) SZ_EXTENSION_DESCRIPTION ,
                                 sizeof(SZ_EXTENSION_DESCRIPTION ));
        if (dwReturn == ERROR_SUCCESS) {
            dwReturn = RegCreateKeyEx(hKeyCLSID,
                TEXT("InprocServer32"),
                NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                &hKeyInproc32, &dwDisposition);

            if (dwReturn == ERROR_SUCCESS) {
                hModule=GetModuleHandle(SZ_DLLNAME);
                if (!hModule) {
                    dwReturn = GetLastError();
                }
                else {
                    TCHAR szName[MAX_PATH+1];
                    if (GetModuleFileName(hModule,
                                          szName,
                                          sizeof(szName)/sizeof(szName[0])) == NULL) {
                        dwReturn = GetLastError();
                    }
                    else {
                        dwReturn = RegSetValueEx(hKeyInproc32,
                                                 TEXT(""),
                                                 NULL,
                                                 REG_SZ,
                                                 (BYTE*) szName,
                                                 sizeof(TCHAR)*(lstrlen(szName)+1));
                        if (dwReturn == ERROR_SUCCESS) {
                            dwReturn = RegSetValueEx(hKeyInproc32,
                                                     TEXT("ThreadingModel"),
                                                     NULL,
                                                     REG_SZ,
                                                     (BYTE*) TEXT("Both"),
                                                     sizeof(TEXT("Both")));
                        }
                    }
                }
                RegCloseKey(hKeyInproc32);
            }
        }
        RegCloseKey(hKeyCLSID);
    }

    if (dwReturn == ERROR_SUCCESS) {

        dwReturn = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                  IISADMIN_EXTENSIONS_REG_KEY
                                  TEXT("\\") SZ_CLSID_SSLCONFIGPROV,
                                  NULL,
                                  TEXT(""),
                                  REG_OPTION_NON_VOLATILE,
                                  KEY_ALL_ACCESS,
                                  NULL,
                                  &hKeyCLSID,
                                  &dwDisposition);

        if (dwReturn == ERROR_SUCCESS) {
            RegCloseKey(hKeyCLSID);
        }

    }

    return HRESULT_FROM_WIN32(dwReturn);
}

STDAPI DllUnregisterServer(void)
{
    DWORD dwReturn = ERROR_SUCCESS;
    DWORD dwTemp;

    dwTemp = RegDeleteKey(HKEY_CLASSES_ROOT,
                          TEXT("CLSID\\") SZ_CLSID_SSLCONFIGPROV TEXT("\\InprocServer32"));
    if (dwTemp != ERROR_SUCCESS) {
        dwReturn = dwTemp;
    }
    dwTemp = RegDeleteKey(HKEY_CLASSES_ROOT,
                          TEXT("CLSID\\") SZ_CLSID_SSLCONFIGPROV);
    if (dwTemp != ERROR_SUCCESS) {
        dwReturn = dwTemp;
    }
    dwTemp = RegDeleteKey(HKEY_LOCAL_MACHINE,
                          IISADMIN_EXTENSIONS_REG_KEY
                          TEXT("\\") SZ_CLSID_SSLCONFIGPROV );
    if (dwTemp != ERROR_SUCCESS) {
        dwReturn = dwTemp;
    }
    return HRESULT_FROM_WIN32(dwReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\sfwp\sslconfigprov\server\sslconfigchangeprov.cxx ===
/*++

   Copyright    (c)    2001    Microsoft Corporation

   Module  Name :
     sslconfigchangeprov.cxx

   Abstract:
     SSL CONFIG PROV server

     Listens for metabase notifications related to SSL
     and informs connected client appropriately

 
   Author:
     Jaroslav Dunajsky      April-24-2001

   Environment:
     Win32 - User Mode

   Project:
     Stream Filter Worker Process
--*/




#include "precomp.hxx"

//
// Constants
//

#define W3_SERVER_MB_PATH       L"/LM/W3SVC/"
#define W3_SERVER_MB_PATH_CCH   10

//
// private declarations
//

class MB_LISTENER
    : public MB_BASE_NOTIFICATION_SINK
{
public:

    MB_LISTENER( SSL_CONFIG_CHANGE_PROV_SERVER * pSslConfigChangeProv  )
        :
        _pSslConfigChangeProv( pSslConfigChangeProv )
    {
    }

    STDMETHOD( SynchronizedSinkNotify )( 
        DWORD               dwMDNumElements,
        MD_CHANGE_OBJECT    pcoChangeList[]
        )
    {
        DBG_ASSERT( _pSslConfigChangeProv != NULL );
        return _pSslConfigChangeProv->MetabaseChangeNotification(
                                        dwMDNumElements,
                                        pcoChangeList );
    }

private:
    SSL_CONFIG_CHANGE_PROV_SERVER * _pSslConfigChangeProv;
};



//virtual
HRESULT
SSL_CONFIG_CHANGE_PROV_SERVER::PipeListener(
    VOID
    )
/*++

Routine Description:
    Listens on SslConfigPipe and executes commands
    
Arguments:

Return Value:

    HRESULT

--*/        
{
    HRESULT                     hr = E_FAIL;
    SSL_CONFIG_PIPE_COMMAND     Command;

    //
    // Even though change notification pipe doesn't expect 
    // any data received from client
    // we will use PipeReceiveCommand() for detection when pipe
    // get's closed so that we can recycle it
    //
    
    hr = PipeReceiveCommand( &Command );
    if ( FAILED( hr ) )
    {
       goto  Cleanup;
    }
    //
    // client should never send data over the change notification pipe
    //
    DBG_ASSERT( FAILED( hr ) );

    Cleanup: 
    //BUGBUG handle error    
    return S_OK;
}
 

 

HRESULT
SSL_CONFIG_CHANGE_PROV_SERVER::Initialize(
    VOID
    )
/*++

Routine Description:
    Initialize named pipe
    Connect to metabase
Arguments:

Return Value:

    HRESULT

--*/    
{
    HRESULT         hr = E_FAIL;
    HANDLE          hEvent = NULL;

    // 
    // Initialize the metabase access (ABO)
    //
    
    hr = CoCreateInstance( CLSID_MSAdminBase,
                           NULL,
                           CLSCTX_SERVER,
                           IID_IMSAdminBase,
                           reinterpret_cast<LPVOID *>(&_pAdminBase) );
    if( FAILED(hr) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error creating ABO object.  hr = %x\n",
                    hr ));
        goto Cleanup;
    }
    
    //
    // Initialize the metabase sink
    // (it will not start listening yet)
    //

    _pListener = new MB_LISTENER( this );
    if ( _pListener == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        
        DBGPRINTF(( DBG_CONTEXT,
                    "Error creating metabase listener.  hr = %x\n",
                    hr ));
        goto Cleanup;
    }   

    //
    // Initialize parent - it will create pipe and
    // start listener thread ( thread will execute PipeListener() )
    //
    hr = SSL_CONFIG_PIPE::PipeInitializeServer( WSZ_SSL_CONFIG_CHANGE_PIPE );
    if( FAILED(hr) )
    {
        goto Cleanup;
    }

    //
    // Start listening for metabase changes
    //
   
    DBG_ASSERT( _pAdminBase != NULL );
    
    hr = _pListener->StartListening( _pAdminBase );
    if ( FAILED( hr ) )  
    {
        return hr;
    }
    

    hr = S_OK;
Cleanup:
    if ( FAILED( hr ) )
    {
        Terminate();
    }
    return hr;    
}
   
HRESULT
SSL_CONFIG_CHANGE_PROV_SERVER::Terminate(
    VOID
    )
/*++

Routine Description:
    Close named pipe for metabase change notifications
    Close metabase named pipe
    
Arguments:

Return Value:

    HRESULT

--*/    
{
    HRESULT hr = E_FAIL;

    //
    // if there are any blocked pipe calls
    // they need to get cancelled not to block
    // metabase callbacks from completion
    //
    if ( SSL_CONFIG_PIPE::IsPipeInitialized() )
    {
        SSL_CONFIG_PIPE::PipeCancel();
    }
    //
    // Stop listening for metabase changes
    // all metabase change callbacks will be completed after
    // function returns
    //
    if ( _pListener != NULL )
    {
        _pListener->StopListening( _pAdminBase );
    }
    
    //
    // Terminate pipe
    //
    hr = SSL_CONFIG_PIPE::PipeTerminate();
    DBG_ASSERT( SUCCEEDED( hr ) );

    //
    // Terminate metabase listener
    //

    if ( _pListener != NULL )
    {
        _pListener->Release();
        _pListener = NULL;
    }
    
    // 
    // Terminate the metabase access (ABO)
    //
    
    if ( _pAdminBase != NULL )
    {
        _pAdminBase->Release();
        _pAdminBase = NULL;
    } 
    return S_OK;
}

HRESULT
SSL_CONFIG_CHANGE_PROV_SERVER::MetabaseChangeNotification(
    DWORD               dwMDNumElements,
    MD_CHANGE_OBJECT    pcoChangeList[]
)
/*++

Routine Description:

    Handle metabase change notifications

Arguments:

    dwMDNumElements - Number of elements changed
    pcoChangeList - Elements changed

Return Value:

    HRESULT

--*/
{
    LPWSTR                  pszSiteString;
    DWORD                   dwSiteId;
    LPWSTR                  pszAfter;
    BOOL                    fDoSiteConfigUpdate;
    BOOL                    fDoSiteBindingUpdate;
    SSL_CONFIG_PIPE_COMMAND Command;
    HRESULT                 hr = E_FAIL;

    
    DBG_ASSERT( dwMDNumElements != 0 );
    DBG_ASSERT( pcoChangeList != NULL );

    //
    // Only handle the W3SVC changes
    //
    
    for( DWORD i = 0; i < dwMDNumElements; ++i )
    {
        if( _wcsnicmp( pcoChangeList[i].pszMDPath,
                       W3_SERVER_MB_PATH,
                       W3_SERVER_MB_PATH_CCH ) == 0 )
        {
            fDoSiteConfigUpdate = FALSE;
            fDoSiteBindingUpdate = FALSE;
            
            //
            // Was this change made for a site, or for all of W3SVC
            //
    
            pszSiteString = pcoChangeList[i].pszMDPath + W3_SERVER_MB_PATH_CCH;
            if ( *pszSiteString != L'\0' )
            {
                dwSiteId = wcstoul( pszSiteString, &pszAfter, 10 );
            }
            else
            {
                //
                // A site id of 0 means we will flush all site config
                //
                
                dwSiteId = 0;
            }
            
            //
            // Now check whether the changed property was an SSL prop
            //
            
            for ( DWORD j = 0; j < pcoChangeList[ i ].dwMDNumDataIDs; j++ )
            {
                if ( fDoSiteConfigUpdate )
                {
                    break;
                }
                
                switch( pcoChangeList[ i ].pdwMDDataIDs[ j ] )
                {
                case MD_SSL_CERT_HASH:
                case MD_SSL_CERT_CONTAINER:
                case MD_SSL_CERT_PROVIDER:
                case MD_SSL_CERT_OPEN_FLAGS:
                case MD_SSL_CERT_STORE_NAME:
                case MD_SSL_CERT_IS_FORTEZZA:
                case MD_SSL_CERT_FORTEZZA_PIN:
                case MD_SSL_CERT_FORTEZZA_SERIAL_NUMBER:
                case MD_SSL_CERT_FORTEZZA_PERSONALITY:
                case MD_SSL_CERT_FORTEZZA_PROG_PIN:
                case MD_SSL_CTL_IDENTIFIER:
                case MD_SSL_CTL_CONTAINER:
                case MD_SSL_CTL_PROVIDER:
                case MD_SSL_CTL_PROVIDER_TYPE:
                case MD_SSL_CTL_OPEN_FLAGS:
                case MD_SSL_CTL_STORE_NAME:
                case MD_SSL_CTL_SIGNER_HASH:
                case MD_SSL_USE_DS_MAPPER:
                case MD_SSL_ACCESS_PERM:
                case MD_CERT_CHECK_MODE:
                case MD_REVOCATION_FRESHNESS_TIME:
                case MD_REVOCATION_URL_RETRIEVAL_TIMEOUT:
                    fDoSiteConfigUpdate = TRUE;
                    break;
                case MD_SECURE_BINDINGS:
                    fDoSiteBindingUpdate = TRUE;
                    break;
                case MD_SERVER_STATE:
                    fDoSiteConfigUpdate = TRUE;
                    fDoSiteBindingUpdate = TRUE;
                    break;
                    
                }
            }
            
            //
            // Update the site bindings if necessary
            //
            
            if ( fDoSiteBindingUpdate )
            {
                ZeroMemory( &Command,
                            sizeof( Command ) );
                Command.dwCommandId = CMD_CHANGED_SECURE_BINDINGS;
                Command.dwParameter1 = dwSiteId;

                hr = PipeSendCommand( &Command );
                if ( FAILED( hr ) )
                {
                    goto failed;
                }
            }
            
            //
            // Update the site configurations if necessary
            //
            
            if ( fDoSiteConfigUpdate )
            {
                //
                // dwSiteId == 0 means flush all sites
                //
                ZeroMemory( &Command,
                            sizeof( Command ) );
                Command.dwCommandId = CMD_CHANGED_SSL_CONFIGURATION;
                Command.dwParameter1 = dwSiteId;

                hr = PipeSendCommand( &Command );
                if ( FAILED( hr ) )
                {
                    goto failed;
                }
                
                if ( dwSiteId == 0 )
                {
                    //
                    // If we've already flushed every site, then no 
                    // reason to read any more changes
                    //
                    
                    break;
                }
            }
        }   
    }
    return S_OK;
failed:
    DBG_ASSERT( FAILED( hr ) );
    //
    // failure may have been caused by the fact 
    // that there is no client connected yet
    //
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\sfwp\w3ssl\dllmain.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     dllmain.cxx

   Abstract:
     Contains the standard definitions for a DLL

   Author:

     jaroslad  11/01/01

   Project:

     W3SSL

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "precomp.hxx"

#define HTTPFILTER_KEY \
            "System\\CurrentControlSet\\Services\\HTTPFilter"

#define HTTPFILTER_PARAMETERS_KEY \
            HTTPFILTER_KEY "\\Parameters"


DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();
DECLARE_PLATFORM_TYPE();

const CHAR g_pszW3SSLRegLocation[] =
    HTTPFILTER_PARAMETERS_KEY ;


/************************************************************
 *     DLL Entry Point
 ************************************************************/
extern "C"
BOOL WINAPI
DllMain(
    HINSTANCE hInstance,
    DWORD     dwReason,
    LPVOID    /*lpvReserved*/)
{

    if (dwReason == DLL_PROCESS_ATTACH)
    {       
        DisableThreadLibraryCalls(hInstance);

        CREATE_DEBUG_PRINT_OBJECT("w3ssl");
        if (!VALID_DEBUG_PRINT_OBJECT())
        {
            return FALSE;
        }

        LOAD_DEBUG_FLAGS_FROM_REG_STR( g_pszW3SSLRegLocation, DEBUG_ERROR );
        INITIALIZE_PLATFORM_TYPE();
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        if ( VALID_DEBUG_PRINT_OBJECT() )
        {
            DELETE_DEBUG_PRINT_OBJECT();
        }
    }
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\sfwp\sslconfigprov\server\sslconfigprov.cxx ===
/*++

   Copyright    (c)    2001    Microsoft Corporation

   Module  Name :
     sslconfigprovserver.cxx

   Abstract:
     SSL CONFIG PROV server

     Listens to commands sent from clients and executes
     SSL parameter lookups in the metabase
 
   Author:
     Jaroslav Dunajsky      April-24-2001

   Environment:
     Win32 - User Mode

   Project:
     Stream Filter Worker Process
--*/




#include "precomp.hxx"


//virtual
HRESULT
SSL_CONFIG_PROV_SERVER::PipeListener(
    VOID
    )
/*++

Routine Description:
    Listens on SslConfigPipe and executes commands
    
Arguments:

Return Value:

    HRESULT

--*/        
{
    SSL_CONFIG_PIPE_COMMAND   Command;
    HRESULT                   hr = E_FAIL;
    
    //
    // Listen on pipe to receive commands
    // and handle them
    //
    while ( TRUE )
    {
        hr = PipeReceiveCommand( &Command );
        if ( FAILED( hr ) )
        {
           goto  Cleanup;
        }
        switch( Command.dwCommandId )
        {
        
        case CMD_GET_SSL_CONFIGURATION:
            hr = SendSiteSslConfiguration( Command.dwParameter1 );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }
            break;
        case CMD_GET_ONE_SITE_SECURE_BINDINGS:
            hr = SendOneSiteSecureBindings( Command.dwParameter1 );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }
            break;
        case CMD_GET_ALL_SITES_SECURE_BINDINGS:
            hr = SendAllSitesSecureBindings();
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }
            break;
        case INVALID_SSL_CONFIGURATION_COMMAND:
        default:
            DBG_ASSERT(FALSE);
        }
    }
    
Cleanup:
    return hr;
}
 

HRESULT
SSL_CONFIG_PROV_SERVER::Initialize(
    VOID
)
/*++

Routine Description:
    Initialize named pipe
    Connect to metabase
Arguments:

Return Value:

    HRESULT

--*/    
{
    HRESULT         hr = E_FAIL;
    HANDLE          hEvent = NULL;

    DBG_ASSERT( _InitStatus == INIT_NONE );
    // 
    // Initialize the metabase access (ABO)
    //
    
    hr = CoCreateInstance( CLSID_MSAdminBase,
                           NULL,
                           CLSCTX_SERVER,
                           IID_IMSAdminBase,
                           reinterpret_cast<LPVOID *>(&_pAdminBase) );
    if( FAILED(hr) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error creating ABO object.  hr = %x\n",
                    hr ));
        goto Cleanup;
    }
    _InitStatus = INIT_METABASE;

    //
    // Initialize parent - it will create pipe and
    // start listener thread ( thread will execute PipeListener() )
    //
    hr = SSL_CONFIG_PIPE::PipeInitializeServer( WSZ_SSL_CONFIG_PIPE );
    if( FAILED(hr) )
    {
        goto Cleanup;
    }
    _InitStatus = INIT_CONFIG_PIPE;

    hr = S_OK;
Cleanup:
    if ( FAILED( hr ) )
    {
        Terminate();
    }
    return hr;    
}
   
HRESULT
SSL_CONFIG_PROV_SERVER::Terminate(
    VOID
    )
/*++

Routine Description:
    Close named pipe for metabase change notifications
    Close metabase named pipe
    
Arguments:

Return Value:

    HRESULT

--*/    
{
    HRESULT hr = E_FAIL;

    switch( _InitStatus )
    {
    case INIT_CONFIG_PIPE:
        
        //
        // Terminate Pipe
        //
        hr = SSL_CONFIG_PIPE::PipeTerminate();
        DBG_ASSERT( SUCCEEDED( hr ) );
    case INIT_METABASE:    
        // 
        // Terminate the metabase access (ABO)
        //
        
        if ( _pAdminBase != NULL )
        {
            _pAdminBase->Release();
            _pAdminBase = NULL;
        } 
    }
    return S_OK;
}


HRESULT 
SSL_CONFIG_PROV_SERVER::SendOneSiteSecureBindings(
    IN          DWORD     dwSiteId,
    OPTIONAL IN BOOL      fNoResponseOnNotFoundError,
    OPTIONAL IN MB *      pMb     
    )
/*++

Routine Description:
    Read secure bindings for the site from metabase and send them over 
    named pipe
    
Arguments:
    dwSiteId - site ID
    fNoResponseOnNotFoundError - in the case of error don't send response to client
                         it is used for multisite enumeration to not to send 
                         MD_ERROR_DATA_NOT_FOUND
    pMb - already opened metabase (used for multisite enumeration)


Return Value:

    HRESULT

--*/    
{
    SSL_CONFIG_PIPE_RESPONSE_HEADER ResponseHeader;
    HRESULT                           hr = E_FAIL;
    MB                                mb( _pAdminBase );
    BOOL                              fOpenedMetabase = FALSE;
    MULTISZ                           mszBindings;
    WCHAR                             achSitePath[ METADATA_MAX_NAME_LEN ];
    DWORD                             dwNumberOfStringsInMultisz;
    DWORD                             cbBindings;
    DWORD                             dwServerState = 0;
    BOOL                              fRet = FALSE;

    ZeroMemory( &ResponseHeader,
                sizeof( SSL_CONFIG_PIPE_RESPONSE_HEADER ) );
 
    //
    // Read secure bindings from metabase
    //

    if ( pMb == NULL )
    {
        fRet = mb.Open( L"/LM/W3SVC",
                        METADATA_PERMISSION_READ );
        if ( !fRet )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            DBGPRINTF(( DBG_CONTEXT,
                        "Failed to open metabase.  hr = %x\n",
                        hr ));

            goto SendResponse;
        }
        pMb = &mb;
        fOpenedMetabase = TRUE;
    }

    _snwprintf( achSitePath,
                sizeof( achSitePath ) / sizeof( WCHAR ) - 1,
                L"/%d/",
                dwSiteId );

    fRet = pMb->GetDword( achSitePath,
                          MD_SERVER_STATE,
                          IIS_MD_UT_SERVER,
                          &dwServerState,
                          0 );
    if ( !fRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to Server State.  hr = %x\n",
                    hr ));
        goto SendResponse;
    }

    if ( dwServerState != MD_SERVER_STATE_STARTED )
    {
        //
        // When site is not started we will communicate
        // DATA_NOT_FOUND so that caller doesn't use the site
        // bindings
        //
        hr = MD_ERROR_DATA_NOT_FOUND;
        goto SendResponse;    
    }

    fRet = pMb->GetMultisz( achSitePath,
                            MD_SECURE_BINDINGS,
                            IIS_MD_UT_SERVER,
                            &mszBindings,
                            0 );
    if ( !fRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        if ( hr != MD_ERROR_DATA_NOT_FOUND ) 
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Failed to Get Multisz.  hr = %x\n",
                        hr ));
        }
        goto SendResponse;
    }

    hr = S_OK;
    
SendResponse:

    // 
    // Close metabase handle
    //
    if ( fOpenedMetabase )
    {
        mb.Close();
    }
    if ( fNoResponseOnNotFoundError && 
         ( hr == MD_ERROR_DATA_NOT_FOUND ||
           hr == HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ) ) )
    {
        //
        // MD_ERROR_DATA_NOT_FOUND is OK
        // it is OK for site not to have secure bindings configured
        //
        // ERROR_PATH_NOT_FOUND may happen for example when site ID is greater
        // than max DWORD. Then conversion from string to DWORD may have truncated the actual Id.
        //
        return S_OK;
    }


    //
    // Prepare and send ResponseHeader
    //
    
    if ( FAILED( hr ) )
    {
        cbBindings = 0;
    }
    else
    {
        cbBindings =  sizeof(WCHAR) *
                        ( MULTISZ::CalcLength( 
                                reinterpret_cast<WCHAR *>(mszBindings.QueryPtr()),
                                &dwNumberOfStringsInMultisz ) +
                                   0 /*for Terminating 0*/);

    }
    
    ResponseHeader.dwCommandId = CMD_GET_ONE_SITE_SECURE_BINDINGS;
    ResponseHeader.dwParameter1 = dwSiteId;
    ResponseHeader.hrErrorCode = hr;
    ResponseHeader.dwResponseSize = cbBindings;
    
    hr = PipeSendResponseHeader( &ResponseHeader );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    if ( cbBindings != 0 )
    {
        //
        // Send Bindings data
        //

        hr = PipeSendData( 
                        cbBindings,
                        reinterpret_cast<BYTE *>(mszBindings.QueryPtr()) );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }
    hr = S_OK;
    return hr;

}

HRESULT
SSL_CONFIG_PROV_SERVER::SendAllSitesSecureBindings( 
    )
/*++

Routine Description:
    Enumerate all Secure Bindings and write it to named pipe

Arguments:

Return Value:
    HRESULT  
             

--*/    
{
    DWORD                           dwSiteId = 0;
    MB                              mb( _pAdminBase );
    DWORD                           dwIndex = 0;
    WCHAR                           achSitePath[ METADATA_MAX_NAME_LEN ];
    WCHAR *                         pchEndPtr;
    HRESULT                         hr = E_FAIL;
    HRESULT                         hrMB = E_FAIL;
    BOOL                            fRet = FALSE;
    SSL_CONFIG_PIPE_RESPONSE_HEADER ResponseHeader;

    ZeroMemory( &ResponseHeader,
                sizeof( SSL_CONFIG_PIPE_RESPONSE_HEADER ) );

    fRet = mb.Open( L"/LM/W3SVC",
                    METADATA_PERMISSION_READ );
    if ( !fRet )
    {
        hrMB = HRESULT_FROM_WIN32( GetLastError() );
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to open metabase.  hr = %x\n",
                    hrMB ));
        // Don't do goto Cleanup;
        //
        // Before returning from the function
        // report error over named pipe
        //
    }
    else
    {
        hrMB = S_OK;
    }

    //
    // First part of the response
    // - in the case of previous error this is the only response sent to client
    // - in the case of success, CMD_GET_ONE_SITE_SECURE_BINDINGS response will
    //   be returned for each site )
    //
    
    ResponseHeader.dwCommandId = CMD_GET_ALL_SITES_SECURE_BINDINGS;
    ResponseHeader.dwParameter1 = 0;
    ResponseHeader.hrErrorCode = hrMB;
    ResponseHeader.dwResponseSize = 0; // 0 indicates that

    hr = PipeSendResponseHeader( &ResponseHeader );

    if ( FAILED( hr ) || FAILED( hrMB ) )
    {
        goto Cleanup;
    }

    //
    // Enumerate all sites
    //
    dwIndex = 0;
    while ( mb.EnumObjects( L"", 
                            achSitePath,
                            dwIndex++ ) )
    {
        //
        // We only want the sites (w3svc/<number>)
        //
        
        dwSiteId = wcstoul( achSitePath, 
                            &pchEndPtr, 
                            10 );
        if ( * pchEndPtr != L'\0' )
        {
            //
            // Correct Site node must consist of digits only
            // if pchEndPtr is pointing to anything but 0, it means
            // invalid value. We will ignore
            continue;
        }
        
        //
        // Send bindings for current site
        //
        hr = SendOneSiteSecureBindings ( dwSiteId,
                                         TRUE, /*fNoResponseOnError*/
                                         &mb );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    }
    //
    // Terminating record
    // if everything went OK then EnumObjects() returned
    // ERROR_NO_MORE_ITEMS - That is indication for client
    // that all data has been retrieved
    //
    
    ResponseHeader.dwCommandId = CMD_GET_ONE_SITE_SECURE_BINDINGS;
    ResponseHeader.dwParameter1 = 0;
    ResponseHeader.hrErrorCode = HRESULT_FROM_WIN32( GetLastError() );
    ResponseHeader.dwResponseSize = 0;

    hr = PipeSendResponseHeader( &ResponseHeader );

    if ( FAILED( hr ) || FAILED( hrMB ) )
    {
        goto Cleanup;
    }
    
    hr = S_OK;
Cleanup:    
    mb.Close();
    return hr;
}

HRESULT
SSL_CONFIG_PROV_SERVER::SendSiteSslConfiguration(
    IN  DWORD dwSiteId
    )
/*++

Routine Description:
    Get all SSL configuration parameters for specified site
    
Arguments:
    dwSiteId
    SiteSslConfiguration

Return Value:

    HRESULT

--*/    
{
    SITE_SSL_CONFIGURATION            SiteSslConfig;
    SSL_CONFIG_PIPE_RESPONSE_HEADER ResponseHeader;
    HRESULT                           hr = E_FAIL;
    MB                                mb( _pAdminBase );
    WCHAR                             achMBSitePath[ 256 ];
    WCHAR                             achMBSiteRootPath[ 256 ];
    DWORD                             dwUseDsMapper = 0;
    DWORD                             cbRequired = 0;
    DWORD                             dwServerState = 0;
    BOOL                              fRet = FALSE;


    ZeroMemory( &SiteSslConfig, 
                sizeof(SiteSslConfig) );
    //
    // set configuration defaults
    //
    SiteSslConfig._dwRevocationFreshnessTime = 
                        DEFAULT_REVOCATION_FRESHNESS_TIME;
    
    ZeroMemory( &ResponseHeader,
                sizeof( SSL_CONFIG_PIPE_RESPONSE_HEADER ) );

    
    fRet = mb.Open( L"/LM/W3SVC/",
                    METADATA_PERMISSION_READ );
    if ( !fRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to open metabase.  hr = %x\n",
                    hr ));
        goto SendResponse;
    }

    _snwprintf( achMBSitePath,
                sizeof( achMBSitePath ) / sizeof( WCHAR ) - 1,
                L"/%d/",
                dwSiteId );

    _snwprintf( achMBSiteRootPath,
            sizeof( achMBSiteRootPath ) / sizeof( WCHAR ) - 1,
            L"/%d/root/",
            dwSiteId );

    fRet = mb.GetDword( achMBSitePath,
                        MD_SERVER_STATE,
                        IIS_MD_UT_SERVER,
                        &dwServerState,
                        0 );
    if ( !fRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to read Server State.  hr = %x\n",
                    hr ));
        goto SendResponse;
    }

    if ( dwServerState != MD_SERVER_STATE_STARTED )
    {
        //
        // When site is not started we will communicate
        // DATA_NOT_FOUND so that caller doesn't use the site
        // bindings
        //
        hr = MD_ERROR_DATA_NOT_FOUND;
        goto SendResponse;    
    }

    //
    // Lookup MD_SSL_USE_DS_MAPPER
    // SSLUseDsMapper is global setting that is not inherited to sites (IIS5 legacy)
    // We have to read it from lm/w3svc
    //    

    mb.GetDword( L"",
                 MD_SSL_USE_DS_MAPPER,
                 IIS_MD_UT_SERVER,
                 &dwUseDsMapper );
                 
    SiteSslConfig._fSslUseDsMapper = !!dwUseDsMapper;

    // MD_SSL_ACCESS_PERM
    mb.GetDword( achMBSiteRootPath,
                 MD_SSL_ACCESS_PERM,
                 IIS_MD_UT_FILE,
                 &SiteSslConfig._dwSslAccessPerm );
    // Lookup MD_SSL_CERT_HASH
    SiteSslConfig._cbSslCertHash= 
                sizeof(SiteSslConfig._SslCertHash);
    hr = ReadMetabaseBinary( &mb,
                             achMBSitePath,
                             MD_SSL_CERT_HASH,
                             &SiteSslConfig._cbSslCertHash,
                             SiteSslConfig._SslCertHash );
  
    // MD_SSL_CERT_STORE_NAME
    hr = ReadMetabaseString( &mb,
                             achMBSitePath,
                             MD_SSL_CERT_STORE_NAME,
                             sizeof(SiteSslConfig._SslCertStoreName),
                             SiteSslConfig._SslCertStoreName );
    // MD_SSL_CERT_CONTAINER
    hr = ReadMetabaseString( &mb,
                             achMBSitePath,
                             MD_SSL_CERT_CONTAINER,
                             sizeof(SiteSslConfig._SslCertContainer),
                             SiteSslConfig._SslCertContainer );
    // MD_SSL_CERT_PROVIDER
    mb.GetDword( achMBSitePath,
                 MD_SSL_CERT_PROVIDER,
                 IIS_MD_UT_SERVER,
                 &SiteSslConfig._dwSslCertProvider );
    // MD_SSL_CERT_OPEN_FLAGS
    mb.GetDword( achMBSitePath,
                 MD_SSL_CERT_OPEN_FLAGS,
                 IIS_MD_UT_SERVER,
                 &SiteSslConfig._dwSslCertOpenFlags );
    // MD_CERT_CHECK_MODE
    mb.GetDword( achMBSitePath,
                 MD_CERT_CHECK_MODE,
                 IIS_MD_UT_SERVER,
                 &SiteSslConfig._dwCertCheckMode );
    // MD_REVOCATION_FRESHNESS_TIME
    mb.GetDword( achMBSitePath,
                 MD_REVOCATION_FRESHNESS_TIME,
                 IIS_MD_UT_SERVER,
                 &SiteSslConfig._dwRevocationFreshnessTime );
    // MD_REVOCATION_URL_RETRIEVAL_TIMEOUT
    mb.GetDword( achMBSitePath,
                 MD_REVOCATION_URL_RETRIEVAL_TIMEOUT,
                 IIS_MD_UT_SERVER,
                 &SiteSslConfig._dwRevocationUrlRetrievalTimeout );
    // MD_SSL_CTL_IDENTIFIER
    hr = ReadMetabaseString( &mb,
                             achMBSitePath,
                             MD_SSL_CTL_IDENTIFIER,
                             sizeof(SiteSslConfig._SslCtlIdentifier),
                             SiteSslConfig._SslCtlIdentifier ); 
    // MD_SSL_CTL_PROVIDER
    mb.GetDword( achMBSitePath,
                 MD_SSL_CTL_PROVIDER,
                 IIS_MD_UT_SERVER,
                 &SiteSslConfig._dwSslCtlProvider );
    // MD_SSL_CTL_PROVIDER_TYPE
    mb.GetDword( achMBSitePath,
                 MD_SSL_CTL_PROVIDER_TYPE,
                 IIS_MD_UT_SERVER,
                 &SiteSslConfig._dwSslCtlProviderType );
    // MD_SSL_CTL_OPEN_FLAGS
    mb.GetDword( achMBSitePath,
                 MD_SSL_CTL_OPEN_FLAGS,
                 IIS_MD_UT_SERVER,
                 &SiteSslConfig._dwSslCtlOpenFlags );
    // MD_SSL_CTL_STORE_NAME
    hr = ReadMetabaseString( &mb,
                             achMBSitePath,
                             MD_SSL_CTL_STORE_NAME,
                             sizeof(SiteSslConfig._SslCtlStoreName),
                             SiteSslConfig._SslCtlStoreName );
    // MD_SSL_CTL_CONTAINER
    hr = ReadMetabaseString( &mb,
                             achMBSitePath,
                             MD_SSL_CTL_CONTAINER,
                             sizeof(SiteSslConfig._SslCtlContainerName),
                             SiteSslConfig._SslCtlContainerName );
    // MD_SSL_CTL_SIGNER_HASH
    SiteSslConfig._cbSslCtlSignerHash =
        sizeof(SiteSslConfig._SslCtlSignerHash);
    hr = ReadMetabaseBinary( &mb,
                             achMBSitePath,
                             MD_SSL_CTL_SIGNER_HASH,
                             &SiteSslConfig._cbSslCtlSignerHash,
                             SiteSslConfig._SslCtlSignerHash ); 
    hr = S_OK;
  SendResponse:

    // 
    // Close metabase handle
    //
    mb.Close();

    //
    // Prepare and send ResponseHeader
    //
    
    ResponseHeader.dwCommandId = CMD_GET_SSL_CONFIGURATION;
    ResponseHeader.dwParameter1 = dwSiteId;
    ResponseHeader.hrErrorCode = hr;
    ResponseHeader.dwResponseSize = sizeof(SiteSslConfig);

    hr = PipeSendResponseHeader( &ResponseHeader );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    //
    // Send Bindings data
    //

    hr = PipeSendData( ResponseHeader.dwResponseSize,
                       reinterpret_cast<BYTE *>(&SiteSslConfig) );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    return S_OK;
}

//static
HRESULT 
SSL_CONFIG_PROV_SERVER::ReadMetabaseString(
    IN      MB *        pMb,
    IN      WCHAR *     pszPath,
    IN      DWORD       dwPropId,
    IN      DWORD       cchMetabaseString,
    OUT     WCHAR *     pszMetabaseString
    )    
{
    DWORD cbRequired;
    BOOL  fRet = FALSE;
    
    cbRequired = cchMetabaseString;
    
    fRet = pMb->GetData( pszPath,
                         dwPropId,
                         IIS_MD_UT_SERVER,
                         STRING_METADATA,
                         pszMetabaseString,
                         &cbRequired,
                         METADATA_NO_ATTRIBUTES );
    if ( !fRet )
    {
        if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
        {
        }
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    return S_OK;
}

//static
HRESULT 
SSL_CONFIG_PROV_SERVER::ReadMetabaseBinary(
    IN      MB *        pMb,
    IN      WCHAR *     pszPath,
    IN      DWORD       dwPropId,
    IN OUT  DWORD *     pcbMetabaseBinary,
    OUT     BYTE *      pbMetabaseBinary
    )    
{
    BOOL  fRet = FALSE;
    
    fRet = pMb->GetData( pszPath,
                         dwPropId,
                         IIS_MD_UT_SERVER,
                         BINARY_METADATA,
                         pbMetabaseBinary,
                         pcbMetabaseBinary,
                         METADATA_NO_ATTRIBUTES  );
    if ( !fRet )
    {
        if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
        {
        }
        else
        {
            *pcbMetabaseBinary = 0;
        }
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\sfwp\w3ssl\scmmanager.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     scmmanager.cxx

   Abstract:
     Manage SCM
 
   Author:
     Bilal Alam (balam)             6-June-2000
     
   Environment:
     Win32 - User Mode

   Project:
     W3SSL.DLL
--*/

#include "precomp.hxx"

SCM_MANAGER::~SCM_MANAGER( VOID )
{
}

HRESULT
SCM_MANAGER::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize SCM_MANAGER 

Arguments:

    pszServiceName - Name of service
    pfnShutdown - Function to call on service shutdown

Return Value:

    HRESULT

--*/
{
    HKEY                hKey;
    DWORD               dwError = NO_ERROR;
    BOOL                fRet = FALSE;

    //
    // initialize critical section
    //
    
    fRet = InitializeCriticalSectionAndSpinCount( 
                                &_csSCMLock,
                                0x80000000 /* precreate event */ | 
                                IIS_DEFAULT_CS_SPIN_COUNT );
    if ( !fRet )
    {
        HRESULT hr = HRESULT_FROM_WIN32( GetLastError() ); 
        DBGPRINTF(( DBG_CONTEXT,
                    "Error calling InitializeCriticalSectionAndSpinCount().  hr = %x\n",
                    hr ));
        return hr;
    }
    _fInitcsSCMLock = TRUE;
     
    //
    // set default value
    //
    
    _dwStartupWaitHint = HTTPFILTER_SERVICE_STARTUP_WAIT_HINT;
    _dwStopWaitHint    = HTTPFILTER_SERVICE_STOP_WAIT_HINT;
    
    //
    // read wait hint from registry
    //

    dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            REGISTRY_KEY_HTTPFILTER_PARAMETERS_W,
                            0,
                            KEY_READ,
                            &hKey );
    if ( dwError == NO_ERROR )
    {
        DWORD dwValue = 0;
        DWORD dwType = 0;
        DWORD cbData = 0;
        DBG_ASSERT( hKey != NULL );

    
        cbData = sizeof( dwValue );
        dwError = RegQueryValueEx( hKey,
                                   REGISTRY_VALUE_HTTPFILTER_STARTUP_WAIT_HINT,
                                   NULL,
                                   &dwType,
                                   (LPBYTE) &dwValue,
                                   &cbData );
        if ( dwError == NO_ERROR && dwType == REG_DWORD )
        {
            _dwStartupWaitHint = dwValue;
        }

        cbData = sizeof( dwValue );
        dwError = RegQueryValueEx( hKey,
                                   REGISTRY_VALUE_HTTPFILTER_STOP_WAIT_HINT,
                                   NULL,
                                   &dwType,
                                   (LPBYTE) &dwValue,
                                   &cbData );
        if ( dwError == NO_ERROR && dwType == REG_DWORD )
        {
            _dwStopWaitHint = dwValue;
        }
        RegCloseKey( hKey );
    }

    //
    // Open SCM
    //
    
    _hService = RegisterServiceCtrlHandlerEx( _szServiceName,
                                              GlobalServiceControlHandler,
                                              this );
    if ( _hService == NULL )
    {
        HRESULT hr = HRESULT_FROM_WIN32( GetLastError() ); 
        DBGPRINTF(( DBG_CONTEXT,
                    "Error calling RegisterServiceCtrlHandlerEx().  hr = %x\n",
                    hr ));
        return hr;
    }
    
    //
    // create the event object. The control handler function signals
    // this event when it receives the "stop" control code.
    //
    _hServiceStopEvent = CreateEvent( NULL,    // no security attributes
                                     FALSE,    // manual reset event
                                     FALSE,    // not-signalled
                                     NULL );   // no name


    if ( _hServiceStopEvent == NULL )
    { 
        HRESULT hr = HRESULT_FROM_WIN32( GetLastError() );
        DBGPRINTF(( DBG_CONTEXT,
                    "Error in CreateEvent().  hr = %x\n",
                    hr ));
        return hr;
    }
    
    //
    // create the event object. The control handler function signals
    // this event when it receives the "pause" control code.
    //
    _hServicePauseEvent = CreateEvent( NULL,    // no security attributes
                                       FALSE,   // manual reset event
                                       FALSE,   // not-signalled
                                       NULL );  // no name


    if ( _hServicePauseEvent == NULL )
    { 
        HRESULT hr = HRESULT_FROM_WIN32( GetLastError() );
        DBGPRINTF(( DBG_CONTEXT,
                    "Error in CreateEvent().  hr = %x\n",
                    hr ));
        return hr;
    }
    
    //
    // create the event object. The control handler function signals
    // this event when it receives the "continue" control code.
    //
    _hServiceContinueEvent = CreateEvent( NULL,    // no security attributes
                                          FALSE,   // manual reset event
                                          FALSE,   // not-signalled
                                          NULL );  // no name


    if ( _hServiceContinueEvent == NULL )
    { 
        HRESULT hr = HRESULT_FROM_WIN32( GetLastError() );
        DBGPRINTF(( DBG_CONTEXT,
                    "Error in CreateEvent().  hr = %x\n",
                    hr ));
        return hr;
    }

    return NO_ERROR;
}

VOID
SCM_MANAGER::Terminate(
    VOID
)
/*++

Routine Description:

    Cleanup

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    if ( _hServiceStopEvent != NULL )
    {
        CloseHandle( _hServiceStopEvent );
        _hServiceStopEvent = NULL;
    }
    if ( _hServicePauseEvent != NULL )
    {
        CloseHandle( _hServicePauseEvent );
        _hServicePauseEvent = NULL;
    }
    
    if ( _hServiceContinueEvent != NULL )
    {
        CloseHandle( _hServiceContinueEvent );
        _hServiceContinueEvent = NULL;
    }
    
    if ( _fInitcsSCMLock )
    {
        DeleteCriticalSection( &_csSCMLock );
        _fInitcsSCMLock = FALSE;
    }
}

HRESULT
SCM_MANAGER::IndicatePending(
    DWORD                dwPendingState
)
/*++

Routine Description:

    Indicate (peridically) that we starting/stopping

Arguments:

    dwPendingState - 

Return Value:

    HRESULT

--*/
{
    DWORD               dwWaitHint;
    
    if ( dwPendingState != SERVICE_START_PENDING && 
         dwPendingState != SERVICE_STOP_PENDING &&
         dwPendingState != SERVICE_CONTINUE_PENDING &&
         dwPendingState != SERVICE_PAUSE_PENDING )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    if ( dwPendingState == SERVICE_START_PENDING ||
         dwPendingState == SERVICE_CONTINUE_PENDING )
    {
        dwWaitHint = _dwStartupWaitHint;        
    }
    else
    {
        dwWaitHint = _dwStopWaitHint;
    }
 
    EnterCriticalSection( &_csSCMLock );
    if( _serviceStatus.dwCurrentState == dwPendingState )
    {
        //
        // if last reported status is the same as the one to report now
        // then increment the checkpoint
        //
        _serviceStatus.dwCheckPoint ++;
    }
    else
    {
        _serviceStatus.dwCheckPoint = 1;
    }

    _serviceStatus.dwCurrentState = dwPendingState;
    _serviceStatus.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;                                                                       
    _serviceStatus.dwWin32ExitCode = NO_ERROR;
    _serviceStatus.dwWaitHint = dwWaitHint;
    
    SetServiceStatus( _hService, 
                      &_serviceStatus );
    
    LeaveCriticalSection( &_csSCMLock );    
    
    return NO_ERROR;
}

HRESULT
SCM_MANAGER::IndicateComplete(
    DWORD                   dwState,
    HRESULT                 hrErrorToReport
)
/*++

Routine Description:

    Indicate the service has started/stopped 
    This means stopping the periodic ping (if any)

Arguments:
    dwState      - new service state
    dwWin32Error - Win32 Error to report to SCM with completion

Return Value:

    HRESULT

--*/
{
    HRESULT     hr = E_FAIL;

    //
    // If error happened at the begining of the initialization
    // it is possible that Service status handle was not established yet.
    // In that case use the default reporting function
    //
    
    if ( !_fInitcsSCMLock || _hService == NULL )
    {
        SCM_MANAGER::ReportFatalServiceStartupError( 
            HTTPFILTER_SERVICE_NAME_W,
            ( FAILED( hrErrorToReport ) ? 
                                        WIN32_FROM_HRESULT( hrErrorToReport ) : 
                                        NO_ERROR ) );
        return S_OK;
    }


    
    if ( dwState != SERVICE_RUNNING && 
         dwState != SERVICE_STOPPED &&
         dwState != SERVICE_PAUSED )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    EnterCriticalSection( &_csSCMLock );
    
    _serviceStatus.dwCurrentState = dwState;
    _serviceStatus.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;                                                                       
    _serviceStatus.dwWin32ExitCode = ( FAILED( hrErrorToReport ) ? 
                                        WIN32_FROM_HRESULT( hrErrorToReport ) : 
                                        NO_ERROR );
    _serviceStatus.dwCheckPoint = 0;
    _serviceStatus.dwWaitHint = 0;
    
    if ( _serviceStatus.dwCurrentState == SERVICE_RUNNING )
    {
        _serviceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP |
                                            SERVICE_ACCEPT_PAUSE_CONTINUE |
                                            SERVICE_ACCEPT_SHUTDOWN;
    }
    
    DBG_ASSERT( _hService != NULL );
   
    if ( SetServiceStatus( _hService,
                           &_serviceStatus ) )
    {
        hr = S_OK;
    }
    else
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Address = %x\n",
                    &_serviceStatus ));
        hr = HRESULT_FROM_WIN32( GetLastError() );
    }
    
    LeaveCriticalSection( &_csSCMLock );
    
    return hr;
    
}

DWORD
SCM_MANAGER::ControlHandler(
    DWORD                   dwControlCode
)
/*++

Routine Description:

    Handle SCM command

Arguments:

    dwControlCode - SCM command

Return Value:

    None

--*/
{
    switch( dwControlCode )
    {
    case SERVICE_CONTROL_STOP:
    case SERVICE_CONTROL_SHUTDOWN:
        if ( _serviceStatus.dwCurrentState == SERVICE_STOPPED )
        {
            UpdateServiceStatus();
            return NO_ERROR;
        }
        IndicatePending( SERVICE_STOP_PENDING );
        //
        // Initiate shutdown
        //
        DBG_ASSERT( _hServiceStopEvent );
        SetEvent( _hServiceStopEvent );

        break;
    case SERVICE_CONTROL_PAUSE:
        if ( _serviceStatus.dwCurrentState == SERVICE_PAUSED )
        {
            UpdateServiceStatus();
            return NO_ERROR;
        }

        IndicatePending( SERVICE_PAUSE_PENDING );
        
        //
        // Initiate pause
        //
        DBG_ASSERT( _hServicePauseEvent );
        SetEvent( _hServicePauseEvent );
        break;

    case SERVICE_CONTROL_CONTINUE:
        if ( _serviceStatus.dwCurrentState == SERVICE_RUNNING )
        {
            UpdateServiceStatus();
            return NO_ERROR;
        }
        
        IndicatePending( SERVICE_CONTINUE_PENDING );
        //
        // Initiate continue
        //
        DBG_ASSERT( _hServiceContinueEvent );
        SetEvent( _hServiceContinueEvent );
        break;
        
    case SERVICE_CONTROL_INTERROGATE:
        UpdateServiceStatus();
        break;
    
    default:
        break;
    }

    return NO_ERROR;
}


HRESULT 
SCM_MANAGER::RunService(
    VOID
)
/*++

Routine Description:

    Executes the service (initialize, startup, stopping, reporting to SCM

    SERVICE implementation class that inherits from SCM_MANAGER 
    must implement OnStart() and OnStop()

Arguments:

    VOID

Return Value:

    None

--*/
{
    HRESULT     hr= E_FAIL;
    DWORD       dwRet = 0;
    HANDLE      events[2];
    
    hr = Initialize();
    if ( FAILED ( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error in SCM_MANAGER::Initialize().  hr = %x\n",
                    hr ));
        goto Finished;
    }
  
    hr = IndicatePending( SERVICE_START_PENDING );

    if ( FAILED ( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error in SCM_MANAGER::IndicatePending().  hr = %x\n",
                    hr ));
        goto Finished;
    }
    
    //
    // loop for SCM CONTINUE request
    //
    for(;;)
    {
        hr = OnServiceStart();
        if ( FAILED ( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Error in OnStart().  hr = %x\n",
                        hr ));
            goto Finished;
        }

        hr = IndicateComplete( SERVICE_RUNNING );

        if ( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Error in SCM_MANAGER::IndicateComplete().  hr = %x\n",
                        hr ));
            
            goto Finished;
        }

        //
        // Wait till service stop is requested
        //
        events[0] = _hServiceStopEvent;
        events[1] = _hServicePauseEvent;
        dwRet = WaitForMultipleObjects( 2,
                                        events, 
                                        FALSE, 
                                        INFINITE );

        if ( dwRet == WAIT_OBJECT_0 )
        {
            // transition from RUNNING to STOPPED
            hr = OnServiceStop();
            if ( FAILED ( hr ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "Error in OnStop().  hr = %x\n",
                            hr ));
                goto Finished;
            }

            hr = S_OK;
            goto Finished;
        }
        else if ( dwRet == WAIT_OBJECT_0 + 1 )
        {
            // transition from RUNNING to PAUSED
            // this is the request to pause
            // we implement pause being similar to stop
            // 
            hr = OnServiceStop();
            if ( FAILED ( hr ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "Error in OnStop() when trying to pause.  hr = %x\n",
                            hr ));
                goto Finished;
            }
            hr = IndicateComplete( SERVICE_PAUSED,
                                   hr );

            hr = S_OK;
        }
        else
        {
            DBG_ASSERT( FALSE );
            goto Finished;
        }


        //
        // Wait till service stop is requested
        //
        events[0] = _hServiceStopEvent;
        events[1] = _hServiceContinueEvent;
        dwRet = WaitForMultipleObjects( 2,
                                        events, 
                                        FALSE, 
                                        INFINITE );

        if ( dwRet == WAIT_OBJECT_0 )
        {
            // transition from PAUSED to STOPPED
            // we are in stopped state already
            //
            goto Finished;
        }
        else if ( dwRet == WAIT_OBJECT_0 + 1 )
        {
            // transition from PAUSED to CONTINUED
            // while (TRUE) loop will handle the continue 
        }
        else
        {
            DBG_ASSERT( FALSE );
            goto Finished;
        }
    }
Finished:
    
    //
    // Error means that we must report SCM that service is stopping
    // SCM will be notified of error that occured
    // Note: even though IndicateComplete received HRESULT for error
    // SCM accepts only Win32 errors and it truncates the upper word 
    // of HRESULT errors sent to it. Hence IndicateComplete
    // calls WIN32_FROM_HRESULT to convert hr, but that may mean
    // loss of error
    //
    hr = IndicateComplete( SERVICE_STOPPED,
                      hr );
    
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                "Error in IndicateComplete().  hr = %x\n",
                hr ));
    }

    Terminate();
    
    return hr;
}

//static
DWORD
WINAPI
SCM_MANAGER::GlobalServiceControlHandler(
    DWORD               dwControl,
    DWORD               /*dwEventType*/,
    LPVOID              /*pEventData*/,
    LPVOID              pServiceContext
)
/*++

Routine Description:

    SCM callback passed to RegisterServiceCtrlHandlerEx
    
Arguments:

    for details see LPHANDLER_FUNCTION_EX in MSDN

Return Value:

    DWORD

--*/

{
    if ( pServiceContext == NULL )
    {
        return ERROR_SUCCESS;
    }

    SCM_MANAGER *  pManager = reinterpret_cast<SCM_MANAGER*>(pServiceContext);
        
    DBG_ASSERT( pManager != NULL );

    return pManager->ControlHandler( dwControl );
    
}

VOID
SCM_MANAGER::UpdateServiceStatus(
    BOOL    fUpdateCheckpoint
) 
/*++

Routine Description:

    Resend the last serviceStatus
    
Arguments:

Return Value:

    None

--*/

{
    DBG_ASSERT( _hService != NULL );

    EnterCriticalSection( &_csSCMLock ); 
    if( fUpdateCheckpoint )
    {
        _serviceStatus.dwCheckPoint ++;
    }
    SetServiceStatus( _hService, 
                      &_serviceStatus ); 
    LeaveCriticalSection( &_csSCMLock ); 
}    

//static
VOID
SCM_MANAGER::ReportFatalServiceStartupError(
    WCHAR * pszServiceName,
    DWORD dwError )
    
{
    SERVICE_STATUS serviceStatus;
    ZeroMemory( &serviceStatus, sizeof( serviceStatus ) );
    
    SERVICE_STATUS_HANDLE hService = 
        RegisterServiceCtrlHandlerEx( pszServiceName,
                                      GlobalServiceControlHandler,
                                      NULL /* indicates that nothing should be 
                                              executed on callback*/ );
    if ( hService == NULL )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to get Service Ctrl Handler Win32 = %d\n",
                    GetLastError() ));
        return;  
    }
        
    serviceStatus.dwCurrentState = SERVICE_STOPPED;
    serviceStatus.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;                                                                       
    serviceStatus.dwWin32ExitCode = dwError;
    serviceStatus.dwCheckPoint = 0;
    serviceStatus.dwWaitHint = 0;
    
    if ( ! SetServiceStatus( hService,
                             &serviceStatus ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to set service status Win32 = %d\n",
                    GetLastError() ));
    }

    //
    // per MSDN the Service Status handle doesn't need to be closed
    //

    hService = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ssinc\ssinc.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ssinc.cxx

Abstract:

    This module contains the server side include processing code.  We 
    aim for support as specified by iis\spec\ssi.doc.  The code is based 
    on existing SSI support done in iis\svcs\w3\server\ssinc.cxx.

    Implementation of the ssinc ISAPI entrypoints.
    implementation of the custom error handling

Author:

    Ming Lu (MingLu)            10-Apr-2000

--*/

#include "precomp.hxx"

//
//  Prototypes
//

extern "C" {

BOOL
WINAPI
DllMain(
    HINSTANCE hDll,
    DWORD     dwReason,
    LPVOID    lpvReserved
    );
}

//
//  Global Data
//

DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();


//
// utility functions
//

DWORD
SsiFormatMessageA(
    IN  DWORD      dwMessageId, 
    IN  LPSTR      apszParms[],  
    OUT LPSTR *    ppchErrorBuff 
    )
/*++

    Routine Description:
        FormatMessage wrapper
    
    Arguments:

        dwMessageId - message Id to format 
        apszParms[] - parameters for message  
        ppchErrorBuff - formatted message text (caller must free it calling LocalFree) 
    
    Return Value:

        HRESULT

    --*/      
{
    DWORD            cch;

    
    //
    // FormatMessage uses SEH to determine when to resize and
    // this will cause debuggers to break on the 1st change exception
    // All the parameters must be limited in max output size using format string
    // in the message eg %1!.30s!would limit output of the parameter to max size
    // of 30 characters
    
    cch = ::FormatMessageA( FORMAT_MESSAGE_ARGUMENT_ARRAY  |
                            FORMAT_MESSAGE_ALLOCATE_BUFFER |
                            FORMAT_MESSAGE_FROM_HMODULE,
                            GetModuleHandle( IIS_RESOURCE_DLL_NAME ),
                            dwMessageId,
                            0,
                            ( LPSTR ) ppchErrorBuff, //see FormatMessage doc
                            0,
                            ( va_list *) apszParms );

    return cch;
}

//
// class that handles asynchronous sends of custom errors from
// the master level
//

class SSI_CUSTOM_ERROR
{
public:
    SSI_CUSTOM_ERROR();

    HRESULT
    SSI_CUSTOM_ERROR::SendCustomError(
        EXTENSION_CONTROL_BLOCK * pecb,
        HRESULT hrErrorToReport
        );
    
private:
    ~SSI_CUSTOM_ERROR();        

    VOID
    SSI_CUSTOM_ERROR::SetVectorResponseData(
        IN PCHAR pszStatus,
        IN PCHAR pszHeaders,
        IN PCHAR pszResponse 
        );

    static
    VOID WINAPI
    HseCustomErrorCompletion(
        IN EXTENSION_CONTROL_BLOCK * pECB,
        IN PVOID    pContext,
        IN DWORD    cbIO,
        IN DWORD    dwError
        );

    HSE_CUSTOM_ERROR_INFO _CustomErrorInfo;
    HSE_RESPONSE_VECTOR   _ResponseVector;
    HSE_VECTOR_ELEMENT    _VectorElement;
    PCHAR                 _pszFormattedMessage;
    BOOL                  _fHeadRequest;
};

SSI_CUSTOM_ERROR::SSI_CUSTOM_ERROR()
{
    ZeroMemory( &_ResponseVector, sizeof( _ResponseVector ) );
    ZeroMemory( &_VectorElement, sizeof( _VectorElement ) );
    _ResponseVector.lpElementArray = &_VectorElement;
    _ResponseVector.dwFlags = HSE_IO_ASYNC | 
                              HSE_IO_SEND_HEADERS |
                              HSE_IO_DISCONNECT_AFTER_SEND;
    _ResponseVector.pszStatus = "";
    _ResponseVector.pszHeaders = "";            
    _ResponseVector.nElementCount = 0;            

    _pszFormattedMessage = NULL;
    _fHeadRequest = FALSE;
}

SSI_CUSTOM_ERROR::~SSI_CUSTOM_ERROR()
{
    if ( _pszFormattedMessage != NULL )
    {
        LocalFree( _pszFormattedMessage );
        _pszFormattedMessage = NULL;
    }
}

VOID
SSI_CUSTOM_ERROR::SetVectorResponseData(
    IN PCHAR pszStatus,
    IN PCHAR pszHeaders,
    IN PCHAR pszResponse )
/*++

Routine Description:

    if custom error couldn't be used then Vector send is used
    This function is used internally to setup VectorSend structures

Arguments:

    pszStatus -
    pszHeaders -
    pszResponse - response body

Return Value:

    HRESULT

--*/
    
{
    _ResponseVector.pszStatus = pszStatus;
    _ResponseVector.pszHeaders = pszHeaders;
    if ( !_fHeadRequest )
    {
        _VectorElement.ElementType = HSE_VECTOR_ELEMENT_TYPE_MEMORY_BUFFER;
        _VectorElement.pvContext = pszResponse;
        _VectorElement.cbSize = strlen( pszResponse );
        _ResponseVector.nElementCount = 1;
    }
    else
    {
        _ResponseVector.nElementCount = 0; 
    }
}

//static
VOID WINAPI
SSI_CUSTOM_ERROR::HseCustomErrorCompletion(
        IN EXTENSION_CONTROL_BLOCK * pECB,
        IN PVOID    pContext,
        IN DWORD    /*cbIO*/,
        IN DWORD    /*dwError*/
        )
/*++

Routine Description:

    completion routine (for async custom error send or vector send

Arguments:



Return Value:

    HRESULT

--*/

{
    
    DBG_ASSERT( pContext != NULL );
    
    SSI_CUSTOM_ERROR * pSsiCustomError = 
        reinterpret_cast<SSI_CUSTOM_ERROR *> (pContext);
    delete pSsiCustomError;
    pSsiCustomError = NULL;

    //
    // Notify IIS that we are done with processing
    //

    pECB->ServerSupportFunction( pECB->ConnID,
                                 HSE_REQ_DONE_WITH_SESSION,
                                 NULL, 
                                 NULL, 
                                 NULL );
    
    return;
}


HRESULT
SSI_CUSTOM_ERROR::SendCustomError(
    EXTENSION_CONTROL_BLOCK * pecb,
    HRESULT hrErrorToReport
    )
/*++

Routine Description:

    reports error hrErrorToReport either as custom error if possible or 
    builds error response that gets send asynchronously using VectorSend

Arguments:
    pecb
    hrErrorToReport - error to be reported

Return Value:

    HRESULT

--*/
    
{
    HRESULT                 hr = E_FAIL;
    if ( !pecb->ServerSupportFunction( pecb->ConnID,
                                   HSE_REQ_IO_COMPLETION,
                                   SSI_CUSTOM_ERROR::HseCustomErrorCompletion,
                                   0,
                                   (LPDWORD ) this )  ) 
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto failed;    
    }

    if ( _stricmp( pecb->lpszMethod, "HEAD" ) == 0 )
    {   
        _fHeadRequest = TRUE;
    }
    
    DWORD dwError = WIN32_FROM_HRESULT( hrErrorToReport );

    _CustomErrorInfo.pszStatus = NULL;
    
    switch( dwError )
    {
    case ERROR_ACCESS_DENIED:

        _CustomErrorInfo.pszStatus = "401 Access Denied";
        _CustomErrorInfo.uHttpSubError = MD_ERROR_SUB401_LOGON_ACL;
        _CustomErrorInfo.fAsync = TRUE;

        break;
    case ERROR_FILE_NOT_FOUND:
    case ERROR_PATH_NOT_FOUND:
    case ERROR_INVALID_NAME:

        _CustomErrorInfo.pszStatus = "404 Object Not Found";
        _CustomErrorInfo.uHttpSubError = 0;
        _CustomErrorInfo.fAsync = TRUE;

        break;

    default:
        hr = HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
    }

    if ( _CustomErrorInfo.pszStatus != NULL )
    {
        BOOL fRet = pecb->ServerSupportFunction( pecb->ConnID,
                                     HSE_REQ_SEND_CUSTOM_ERROR,
                                     &_CustomErrorInfo,
                                     NULL,
                                     NULL );
        if ( !fRet )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
        }
        else
        {
            hr = S_OK; 
        }
    }
    
    //
    // Sending custom error failed, send our own error
    //

    if ( hr == HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ) )
    {
        
        switch( dwError )
        {
        case ERROR_ACCESS_DENIED:
            SetVectorResponseData(    
                                SSI_ACCESS_DENIED,
                                SSI_HEADER,
                                "<body><h1>"
                                SSI_ACCESS_DENIED
                                "</h1></body>" );
            break;

        case ERROR_FILE_NOT_FOUND:
        case ERROR_PATH_NOT_FOUND:
        case ERROR_INVALID_NAME:
            SetVectorResponseData(    
                                SSI_OBJECT_NOT_FOUND,
                                SSI_HEADER,
                                "<body><h1>"
                                SSI_OBJECT_NOT_FOUND
                                "</h1></body>" );
            break;  
        default:
         {
            STACK_BUFFER(   buffTemp, ( SSI_DEFAULT_URL_SIZE + 1 ) * sizeof(WCHAR) );
            STACK_STRA(     strURL,  SSI_DEFAULT_URL_SIZE );
            DWORD           cbSize = buffTemp.QuerySize();
            CHAR            pszNumBuf[ SSI_MAX_NUMBER_STRING ];
            LPSTR           apszParms[ 2 ] = { NULL, NULL };
            
            //
            // get the URL
            //
            if ( !pecb->GetServerVariable(  pecb->ConnID,
                                            "UNICODE_URL",
                                            buffTemp.QueryPtr(),
                                            &cbSize ) )
            {
                if (GetLastError() != ERROR_INSUFFICIENT_BUFFER ||
                    !buffTemp.Resize(cbSize))
                {
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                    goto failed;
                }

                //
                // Now, we should have enough buffer, try again
                //
                if ( !pecb->GetServerVariable( pecb->ConnID,
                                               "UNICODE_URL",
                                               buffTemp.QueryPtr(),
                                               &cbSize ) )
                {
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                    goto failed;
                }
            }
            if (FAILED( hr = strURL.CopyW((LPWSTR)buffTemp.QueryPtr())))
            {
                break;
            }
            
            _ultoa( dwError, pszNumBuf, 10 );
            
            apszParms[ 0 ] = strURL.QueryStr();
            apszParms[ 1 ] = pszNumBuf;

            DWORD cch = SsiFormatMessageA ( 
                                      SSINCMSG_REQUEST_ERROR,
                                      apszParms,
                                      &_pszFormattedMessage
                                    );
 
            if ( cch == 0 )
            {
                return HRESULT_FROM_WIN32( GetLastError() );
                goto failed;
            }

            SetVectorResponseData(  "", // means 200 OK
                                    SSI_HEADER,
                                    _pszFormattedMessage );
         } //end of default block
        } 
        //
        // perform the Vector send
        //
        if ( !pecb->ServerSupportFunction( 
                                   pecb->ConnID,
                                   HSE_REQ_VECTOR_SEND,
                                   &_ResponseVector,
                                   NULL,
                                   NULL) )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto failed;
        }

    }
    else if ( FAILED( hr ) )
    {
        goto failed;
    }
        
    return S_OK;
    
failed:
    DBG_ASSERT( FAILED( hr ) );
    return hr;
}
//
// ISAPI DLL Required Entry Points
//

DWORD
WINAPI
HttpExtensionProc(
    EXTENSION_CONTROL_BLOCK * pecb
    )
{
    HRESULT                 hr = E_FAIL;
    HRESULT                 hrToReport = E_FAIL;
    BOOL                    fAsyncPending = FALSE;
    SSI_REQUEST *           pssiReq = NULL;

    hrToReport = SSI_REQUEST::CreateInstance(
                        pecb,
                        &pssiReq );

    if( FAILED( hrToReport ) )
    {
        SSI_CUSTOM_ERROR * pSsiCustomError = new SSI_CUSTOM_ERROR;
        if ( pSsiCustomError == NULL )
        {
            hr = HRESULT_FROM_WIN32( ERROR_OUTOFMEMORY );
            goto failed;
        }
        //
        // in the case of success asynchronous custom error 
        // send will be executed
        //
        hr = pSsiCustomError->SendCustomError( 
                                pecb, 
                                hrToReport  );
        if ( FAILED ( hr ) )
        {
            goto failed;
        }
        else
        {
            //
            // No Cleanup, there is pending IO request.
            // completion routine is responsible perform proper cleanup
            //
            return HSE_STATUS_PENDING;
        }
    }

    DBG_ASSERT( pssiReq != NULL );

    //
    // Register completion callback since we will execute asynchronously
    //

    if ( !pecb->ServerSupportFunction( pecb->ConnID,
                                       HSE_REQ_IO_COMPLETION,
                                       SSI_REQUEST::HseIoCompletion,
                                       0,
                                       (LPDWORD ) pssiReq )
        ) 
    {
        goto failed;
    }

    //
    //  Continue processing SSI file
    //

    hr = pssiReq->DoWork( 0,
                          &fAsyncPending );
    
    if ( SUCCEEDED(hr) )
    {
        if( fAsyncPending )
        {
            //
            // No Cleanup, there is pending IO request.
            // completion routine is responsible perform proper cleanup
            //
            return HSE_STATUS_PENDING;
        }
        else
        {
            //
            // This request is completed. Do Cleanup before returning
            //
            delete pssiReq;
            pssiReq = NULL;
            return HSE_STATUS_SUCCESS;
        }
    }
    
failed:
    {
        LPCSTR                  apsz[ 1 ];
        DWORD                   cch;
        LPSTR                   pchBuff;

        apsz[ 0 ] = pecb->lpszPathInfo;
        
        cch = SsiFormatMessageA( SSINCMSG_LOG_ERROR,
                                 ( va_list *) apsz,
                                 &pchBuff );

        if( cch > 0 )
        {
            strncpy( pecb->lpszLogData,
                     pchBuff,
                     HSE_LOG_BUFFER_LEN );
            pecb->lpszLogData[ HSE_LOG_BUFFER_LEN - 1 ] = 0;
            ::LocalFree( ( VOID * )pchBuff );
        }
        
        //
        // This request is completed. Do Cleanup before returning
        //
        if ( pssiReq != NULL )
        {
            delete pssiReq;
            pssiReq = NULL;
        }
        return HSE_STATUS_ERROR;
    }
 }

BOOL
WINAPI
GetExtensionVersion(
    HSE_VERSION_INFO * pver
    )
{
    pver->dwExtensionVersion = MAKELONG( 0, 1 );
    strncpy( pver->lpszExtensionDesc, 
             "Server Side Include Extension DLL",
             HSE_MAX_EXT_DLL_NAME_LEN );
    pver->lpszExtensionDesc[ HSE_MAX_EXT_DLL_NAME_LEN - 1 ] = '\0';
            
    if ( FAILED( SSI_REQUEST::InitializeGlobals() ) )
    {
        return FALSE;
    }
    if ( FAILED( SSI_INCLUDE_FILE::InitializeGlobals() ) )
    {
        SSI_REQUEST::TerminateGlobals();
        return FALSE;
    }

    if ( FAILED( SSI_FILE::InitializeGlobals() ) )
    {
        SSI_INCLUDE_FILE::TerminateGlobals();
        SSI_REQUEST::TerminateGlobals();
        return FALSE;
    }
        
    return TRUE;
}

BOOL
WINAPI
TerminateExtension(
    DWORD /* dwFlags */
    )
{
    SSI_FILE::TerminateGlobals();
    SSI_INCLUDE_FILE::TerminateGlobals();
    SSI_REQUEST::TerminateGlobals();
    
    
    
    return TRUE;
}

BOOL
WINAPI
DllMain(
    HINSTANCE hDll,
    DWORD     dwReason,
    LPVOID    /*lpvReserved*/
    )
{
    switch ( dwReason )
    {
    case DLL_PROCESS_ATTACH:

        CREATE_DEBUG_PRINT_OBJECT( "ssinc" );

        DisableThreadLibraryCalls( hDll );
        break;

    case DLL_PROCESS_DETACH:
        DELETE_DEBUG_PRINT_OBJECT();
        break;

    default:
        break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ssinc\ssi_file.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    ssi_file.hxx

Abstract:

    This module contains the server side include processing code.  We 
    aim for support as specified by iis\spec\ssi.doc.  The code is based
    on existing SSI support done in iis\svcs\w3\gateways\ssinc\ssinc.cxx.


    SSI_FILE class handles all the details file access. 
    File cache of W3CORE  is leveraged  to cache STM files 
    ( using W3CORE file cache directly doesn't necessarily conform 
      with ISAPI rules because we use private hooks not officially 
      exposed to ISAPIs )

Author:

    Ming Lu (MingLu)       5-Apr-2000

Revision history
    Jaroslad               Dec-2000 
    - modified to execute asynchronously

    Jaroslad               Apr-2001
    - added VectorSend support, keepalive, split to multiple source files


--*/


#include "precomp.hxx"

//
//  access to W3CORE cache
//
//static 
W3_FILE_INFO_CACHE *    SSI_FILE::s_pFileCache = NULL;


//static
HRESULT 
SSI_FILE::InitializeGlobals(
    VOID
    )
/*++

Routine Description:

    Initialization of globals

Arguments:
    
Return Value:

    HRESULT

--*/    
{
    //
    // Get the cache instance for W3CORE.DLL
    //
    
    s_pFileCache = W3_FILE_INFO_CACHE::GetFileCache();
    if ( s_pFileCache == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_FOUND );
    }
    return S_OK;
}

//static
VOID 
SSI_FILE::TerminateGlobals(
    VOID
    )
/*++

Routine Description:

    Cleanup of globals

Arguments:
    
Return Value:

    VOID

--*/    

{
    //
    // ssinc.dll is using file cache from w3core
    // All objects associated with file cache must be cleaned up 
    // before letting to unload this DLL
    //
    
    W3CacheFlushAllCaches();
}



SSI_FILE::SSI_FILE( 
    IN  W3_FILE_INFO *     pOpenFile
 
    ) : 
        _hMapHandle   ( NULL ),
        _pvMappedBase ( NULL ),
        _fResponseHeadersIncludeContentLength( FALSE ),
        _strResponseHeaders( _abResponseHeaders, sizeof(_abResponseHeaders) ),
         _pFile ( pOpenFile )
{
    DBG_ASSERT( _pFile != NULL );
    _dwSignature = SSI_FILE_SIGNATURE;
}


SSI_FILE::~SSI_FILE()
{
    DBG_ASSERT( CheckSignature() );
    _dwSignature = SSI_FILE_SIGNATURE_FREED;

    //
    // delete File Memory Mapping if still happens to be around
    //
    
    SSIDeleteFileMapping();
        
    //
    // reset backpointer to W3_FILE_INFO,
    // no cleanup is needed, because W3_FILE_INFO actually
    // controls the lifetime of SSI_FILE (through the Cleanup() call)
    // once SSI_FILE instance is associated with W3_FILE_INFO
    //
    
    _pFile = NULL;
    
    if ( _pSsiElementList != NULL )
    {
        delete _pSsiElementList;
        _pSsiElementList = NULL;
    }
}



//static
HRESULT
SSI_FILE::GetReferencedInstance(  
    IN STRU& strFilename, 
    HANDLE   hUserToken,
    OUT SSI_FILE ** ppSsiFile
    )
    
/*++

Routine Description:

    Lookup SSI_FILE 
    It builds the Server Side Include Element List the first 
    time a .stm file is sent.  Subsequently, it is 
    checked out from the associated cache blob.

    SSI_FILE is refcounted indirectly by association with the 
    W3_FILE_INFO

    Once GetReferencedInstance() returns successfully then the 
    DereferenceSsiFile() must be called to assure proper cleanup
    

Arguments:
    
Return Value:

    HRESULT

--*/
{
    HRESULT                 hr = E_FAIL;
    CACHE_USER              fileUser;
    SSI_FILE *              pSsiFile = NULL;
    W3_FILE_INFO *          pOpenFile = NULL;
    
    DBG_ASSERT( ppSsiFile != NULL );

    fileUser._hToken = hUserToken;
    
    hr = s_pFileCache->GetFileInfo( strFilename,
                                    NULL,
                                    &fileUser,
                                    TRUE,
                                    &pOpenFile );
    if ( FAILED( hr ) )
    {
        goto failed;
    }

    DBG_ASSERT( pOpenFile != NULL );

    //
    // The source file is in the cache.  Check whether we have 
    // associated a SSI_FILE with it.
    //

    pSsiFile = reinterpret_cast<SSI_FILE *>
                    (pOpenFile->QueryAssociatedObject());

    if ( pSsiFile == NULL )
    {
        //
        // Create new instance. 
        //
        hr = SSI_FILE::CreateInstance( pOpenFile,
                                       &pSsiFile );
        if ( FAILED( hr ) )
        {
           goto failed;
        }

        DBG_ASSERT( pSsiFile != NULL );

        //
        // cache SsiFile
        //
        
        if ( !pSsiFile->AssociateWithFileCache() )
        {
            //
            // If we failed to set Associated object it means there is one
            // associated already. We can delete our copy and use that one
            //
            delete pSsiFile;
      
            pSsiFile = reinterpret_cast<SSI_FILE *>
                (pOpenFile->QueryAssociatedObject());
        }
    }     

    
    DBG_ASSERT( pSsiFile != NULL );
    DBG_ASSERT( pSsiFile->CheckSignature() );

    //
    // We will keep the reference to cache entry (W3_FILE_INFO)
    // because *ppSsiFile needs it
    // caller must call DereferenceSsiFile() to assure proper cleanup
    //
    
    pOpenFile = NULL;
    
    *ppSsiFile = pSsiFile;
    
    return S_OK;
        
failed:
    DBG_ASSERT ( FAILED( hr ) );
    if ( pOpenFile != NULL )
    {
        pOpenFile->DereferenceCacheEntry();
        pOpenFile = NULL;
    }

    *ppSsiFile = NULL;
    return hr;
}    

//static
HRESULT
SSI_FILE::CreateInstance( 
    IN  W3_FILE_INFO *     pOpenFile,
    OUT SSI_FILE **        ppSsiFile
    )
/*++

Routine Description:

    Private routine used by GetReferencedInstance
    It allocates and initializes SSI_FILE instance

Arguments:

    ppSsiFile   - newly created instance of SSI_FILE
    
Return Value:

    HRESULT

--*/    
{
    HRESULT     hr = E_FAIL;
    SSI_FILE *  pSsiFile = NULL;

    pSsiFile = new SSI_FILE( pOpenFile );
    if( pSsiFile == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_OUTOFMEMORY );
        goto failed;
    }

    hr = pSsiFile->Initialize();
    if ( FAILED( hr ) )
    {
        goto failed;
    }

    *ppSsiFile = pSsiFile;
    return S_OK;
    
failed:
    DBG_ASSERT( FAILED( hr ) );

    if ( pSsiFile != NULL )
    {
        delete pSsiFile;
        pSsiFile = NULL;
    }
    *ppSsiFile = NULL;
    return hr;
}

HRESULT
SSI_FILE::Initialize(
    VOID
    ) 
/*++

Routine Description:

    Private routine 
    It initializes SSI_FILE instance

Arguments:

    
Return Value:

    HRESULT

--*/      
{
    HRESULT     hr = E_FAIL;

    

    // File is memory mapped in this function only if 
    // W3core FILE CACHE doesn't cache the file in memory
    //
    
    if ( SSIGetFileData() == NULL )
    {
        if ( FAILED( hr = SSICreateFileMapping() ) )
        {
            goto failed;
        }
    }
    //
    // Build element list
    //

    hr = SSI_ELEMENT_LIST::CreateInstance(
                    this,
                    &_pSsiElementList );
                    
    if( FAILED( hr ) )
    {
        goto failed;
    }              
    DBG_ASSERT( _pSsiElementList != NULL );

    //
    // Build headers that would be sent in the case there are no directives
    // headers will be cached within SEL for optimized speed of stm files with no tags
    //

    if ( !_pSsiElementList->QueryHasDirectives() )
    {
        CHAR            achNum[ SSI_MAX_NUMBER_STRING + 1 ];
        DWORD           cbFileSize = 0;

        hr = SSIGetFileSize( &cbFileSize );
        if( FAILED( hr ) )
        {
            goto failed;
        }      
        
        _ultoa( cbFileSize,
                achNum,
                10 );
    
        hr = AddToResponseHeaders( "Content-Length: " );
        if ( FAILED( hr ) )
        {
            goto failed;
        }
        hr = AddToResponseHeaders( achNum );
        if ( FAILED( hr ) )
        {
            goto failed;
        }
        hr = AddToResponseHeaders( "\r\n",
                                   TRUE /*headers now include Content-Length*/);
        if ( FAILED( hr ) )
        {
            goto failed;
        }
        
        CHAR * pszHeaderValue = SSIGetFileETag();
        if ( pszHeaderValue != NULL )
        {
            hr = AddToResponseHeaders( "ETag: " );
            if ( FAILED( hr ) )
            {
                goto failed;
            }
            hr = AddToResponseHeaders( pszHeaderValue );
            if ( FAILED( hr ) )
            {
                goto failed;
            }
            hr = AddToResponseHeaders( "\r\n" );
            if ( FAILED( hr ) )
            {
                goto failed;
            }
        }
        pszHeaderValue = SSIGetLastModifiedString();
        if ( pszHeaderValue != NULL )
        {
            hr = AddToResponseHeaders( "Last-Modified: " );
            if ( FAILED( hr ) )
            {
                goto failed;
            }
            hr = AddToResponseHeaders( pszHeaderValue );
            if ( FAILED( hr ) )
            {
                goto failed;
            }
            hr = AddToResponseHeaders( "\r\n" );
            if ( FAILED( hr ) )
            {
                goto failed;
            }
        }
        //
        // Note: SSI_HEADER includes headers terminator!
        //
        AddToResponseHeaders( SSI_HEADER ); 
        
        if ( FAILED( hr ) )
        {
            goto failed;
        }
    }

    hr = S_OK;
    goto finished;
    
failed:
    DBG_ASSERT( FAILED( hr ) );
    //
    // Deletion of created data structures will be done in destructor
    //
    
finished:
    //
    // Cleanup
    //
    
    // file mapping in memory was needed only to perform parsing
    // it's time to delete it
    // File is memory mapped in this function only if 
    // W3core FILE CACHE doesn't cache the file in memory
    //
    SSIDeleteFileMapping();
    
    return hr;
    
}


HRESULT 
SSI_FILE::SSICreateFileMapping( 
    VOID 
    )
/*++

  Creates a mapping to a file

--*/
{
    HANDLE              hHandle;
    HRESULT             hr = E_FAIL;

    DBG_ASSERT( _pFile != NULL );

    //
    // check for empty file
    //
    ULARGE_INTEGER Size;
    _pFile->QuerySize( &Size );
    if ( Size.LowPart == 0 && Size.HighPart == 0 )
    {
        //
        // if file is empty then don't create mapping (it would fail with 1006)
        //
        _pvMappedBase = NULL;
        return S_OK;
    }
    
    //
    // file is not in cached in the memory by worker process
    // Map it to memory now
    //
    
    hHandle = _pFile->QueryFileHandle();
    if ( _hMapHandle != NULL )
    {
        if ( FAILED( hr = SSIDeleteFileMapping() ) )
        {
            goto failed;
        }
    }
    _hMapHandle = ::CreateFileMapping( hHandle,
                                       NULL,
                                       PAGE_READONLY,
                                       0,
                                       0,
                                       NULL );

    if ( _hMapHandle == NULL )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "CreateFileMapping failed with %d\n",
                    GetLastError() ));
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto failed;
    }
    
    DBG_ASSERT ( _pvMappedBase == NULL );
    
    _pvMappedBase = ::MapViewOfFile( _hMapHandle,
                                     FILE_MAP_READ,
                                     0,
                                     0,
                                     0 );
    if ( _pvMappedBase == NULL )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "MapViewOfFile() failed with %d\n",
                    GetLastError() ));
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto failed;
    }
    return S_OK;
    
failed:
    DBG_ASSERT( FAILED( hr ) );
    return hr;

}

HRESULT 
SSI_FILE::SSIDeleteFileMapping( 
    VOID 
    )
/*++

  Closes mapping to a file

--*/
{
    if ( _pvMappedBase != NULL )
    {
        ::UnmapViewOfFile( _pvMappedBase );
        _pvMappedBase = NULL;
    }
    
    if ( _hMapHandle != NULL )
    {
        ::CloseHandle( _hMapHandle );
        _hMapHandle = NULL;
    }
    return S_OK;
}

HRESULT
SSI_FILE::AddToResponseHeaders( 
    IN CHAR *       pszHeaderChunk,
    IN BOOL         fIncludesContentLength 
    )
{
    if ( fIncludesContentLength )
    {
        _fResponseHeadersIncludeContentLength = TRUE;
    }
    return _strResponseHeaders.Append( pszHeaderChunk );
}

HRESULT
SSI_FILE::GetResponseHeaders( 
    OUT CHAR **     ppszResponseHeaders,
    OUT BOOL *      pfIncludesContentLength
    )
{
    if ( _strResponseHeaders.IsEmpty() )
    {
        *ppszResponseHeaders = SSI_HEADER;
        *pfIncludesContentLength = FALSE;
    }
    else
    {
        *ppszResponseHeaders = _strResponseHeaders.QueryStr();
        *pfIncludesContentLength = _fResponseHeadersIncludeContentLength;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\sfwp\w3ssl\w3ssl_service.cxx ===
/*++

   Copyright    (c)    2001    Microsoft Corporation

   Module  Name :
     w3ssl.cxx

   Abstract:
     SSL service for W3SVC.
     New SSL service is introduced to IIS6.
     In the dedicated (new process mode) it will run
     in lsass. That should boost ssl performance by eliminating
     context switches and interprocess communication during
     SSL handshakes.

     In the backward compatibility mode it will not do much.
     Service will register with http for ssl processing, but w3svc
     will register it's strmfilt and http.sys always uses the
     last registered filter so that the one loaded by inetinfo.exe
     will be used.

     Note: W3SSL service was renamed to HTTPFilter.

   Author:
     Jaroslav Dunajsky  (Jaroslad)      04-16-2001

   Environment:
     Win32 - User Mode

   Project:
     Stream Filter Worker Process
--*/


#include "precomp.hxx"
#include  <inetsvcs.h>


HRESULT RunInSameProcessAsIISADMIN ( 
    BOOL * pfInIISAdminProcess 
    )
/*++

    Routine:
        Find out if HttpFilter service executes in the same process 
        as IISADMIN service
        
    Arguments:
        pfInIISAdminProcess - OUT parameter - set to TRUE current process is 
                              running in the same process as IISADMIN
    Returns:
        HRESULT

--*/    
{
    SC_HANDLE                 schSCManager = NULL;
    SC_HANDLE                 schIISADMINService = NULL;
    LPSERVICE_STATUS_PROCESS  pServiceStatus = NULL;
    DWORD                     dwBytesNeeded = 0;
    HRESULT                   hr = E_FAIL;

    *pfInIISAdminProcess = FALSE;

    // Open a handle to the SC Manager database.

    schSCManager = OpenSCManagerW(
                            NULL,                    // local machine
                            NULL,                    // ServicesActive database
                            SC_MANAGER_CONNECT );   

    if ( schSCManager == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Finished;
    }

    schIISADMINService = OpenServiceW(
                            schSCManager,          // SCM database
                            L"IISADMIN",           // IISADMIN service name
                            SERVICE_QUERY_STATUS );

    if ( schIISADMINService == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Finished;
    }

    //
    // Get the configuration information.
    // - to find out the current image path of the
    //   HTTPFilter service
    //


    if ( !QueryServiceStatusEx(
                              schIISADMINService,
                              SC_STATUS_PROCESS_INFO,
                              (LPBYTE) pServiceStatus, 
                              0,
                              &dwBytesNeeded ) )
    {
        if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
        {
            pServiceStatus = reinterpret_cast<LPSERVICE_STATUS_PROCESS> (
                                                    new char[dwBytesNeeded] );
            if ( pServiceStatus == NULL )
            {
                hr = HRESULT_FROM_WIN32( ERROR_OUTOFMEMORY );
                goto Finished;
            }
        if ( !QueryServiceStatusEx(
                              schIISADMINService,
                              SC_STATUS_PROCESS_INFO,
                              (LPBYTE)  pServiceStatus, 
                              dwBytesNeeded,
                              &dwBytesNeeded ) )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
                goto Finished;
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Finished;
        }
    }

    *pfInIISAdminProcess = ( pServiceStatus->dwProcessId == GetCurrentProcessId() );

    hr = S_OK;

    

Finished:

    if ( pServiceStatus != NULL )
    {
        delete [] pServiceStatus;
        pServiceStatus = NULL;
    }

    if ( schIISADMINService != NULL )
    {
        DBG_REQUIRE( CloseServiceHandle( schIISADMINService ) );
        schIISADMINService = NULL;
    }

    if ( schSCManager != NULL )
    {
        DBG_REQUIRE( CloseServiceHandle( schSCManager ) );
        schSCManager = NULL;
    }

    return hr;

}


//
// Implementation of W3SSL_SERVICE methods
//

//virtual
HRESULT
W3SSL_SERVICE::OnServiceStart(
    VOID
    )
/*++

    Routine:
        Initialize HTTPFilter and start service.
        It initializes necessary structures and modules. If there is no error then
        after returning from function HTTPFilter service will be in SERVICE_STARTED state

    Arguments:

    Returns:
        HRESULT

--*/
{

    HRESULT                 hr = S_OK;

    DBG_ASSERT( _InitStatus == INIT_NONE );

    hr = LoadStrmfilt();
    if ( FAILED ( hr ) )
    {
        goto Finished;
    }

    _InitStatus = INIT_STRMFILT_LOADED;

    //
    // Initialize stream filter
    //

    hr = _fnStreamFilterInitialize();
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error in StreamFilterInitialize().  hr = %x\n",
                    hr ));

        goto Finished;
    }

    _InitStatus = INIT_STREAMFILTER;


    //
    // Start listening
    //

    hr = _fnStreamFilterStart();
    if ( FAILED( hr ) )
    {
         DBGPRINTF(( DBG_CONTEXT,
                    "Error in StreamFilterStart().  hr = %x\n",
                    hr ));

        goto Finished;
    }
    _InitStatus = INIT_STREAMFILTER_STARTED;


    
    //
    // Write current mode of w3ssl
    // ( if it is executing in inetinfo.exe then it supports raw read filters )
    // This setting will be used by WAS to determine what mode to execute in.
    // That way W3SSL and W3SVC will always be running in the same mode
    //
    // CODEWORK: in the case that writing to registry fails we may want to do more
    // than just ignoring it. However to halt startup may not necessarily be the best way
    // to go in that case
    
    
    DWORD               dwRunningInInetinfo = 0;
    BOOL                fRunningInInetinfo = FALSE;
    DWORD               dwErr = NO_ERROR;
    HKEY                hKeyParam;

    if ( SUCCEEDED( hr = RunInSameProcessAsIISADMIN( &fRunningInInetinfo ) ) )
    {
        if ( ( dwErr = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                           REGISTRY_KEY_HTTPFILTER_PARAMETERS_W,
                           0,
                           KEY_WRITE,
                           &hKeyParam ) ) == NO_ERROR )
        {

            if ( fRunningInInetinfo )
            {
                dwRunningInInetinfo = 1;
            }
            else
            {
                dwRunningInInetinfo = 0;
            }

            dwErr = RegSetValueExW( hKeyParam,
                                    L"CurrentMode",
                                    NULL,
                                    REG_DWORD,
                                    ( LPBYTE )&dwRunningInInetinfo,
                                    sizeof( dwRunningInInetinfo )
                                    );
            if ( dwErr != NO_ERROR )
            {
                //
                // Ignore the error. 
                //
                DBGPRINTF(( DBG_CONTEXT,
                            "Failed to write registry value \"RunningInInetinfo\".  Win32 = %d\n",
                            dwErr ));

            }
            
            RegCloseKey( hKeyParam );
        }
        else
        {
            //
            // Ignore the error. 
            //
            DBGPRINTF(( DBG_CONTEXT,
                        "Failed to open registry key %s.  Win32 = %d\n",
                        REGISTRY_KEY_HTTPFILTER_PARAMETERS_W,
                        dwErr ));
            hr = S_OK;
        }
    }    
    else
    {
        //
        // Ignore the error. 
        //
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to call RunInSameProcessAsIISADMIN().  hr = %x\n",
                    hr ));
        hr = S_OK;
    }
 


Finished:

    if (FAILED ( hr ) )
    {
        //
        // OnServiceStop() will assure proper cleanup
        //
        OnServiceStop();
    }

    return hr;
}


//virtual
HRESULT
W3SSL_SERVICE::OnServiceStop(
    VOID
)
/*++

    Routine:
        Terminate HTTPFilter service. Performs cleanup

        _InitStatus is used to determine where to start with cleanup.

        OnServiceStop() is also used in OnServiceStart() for cleanup in the error case

    Arguments:


    Returns:
        HRESULT - will be reported to SCM

--*/
{
    HRESULT     hr = S_OK;

    //
    // Cases in the switch command don't have "break" command
    // on purpose. _InitStatus indicates how for the initialization has gone
    // and that indicates where cleanup should start
    //

    switch( _InitStatus )
    {

    case INIT_STREAMFILTER_STARTED:
        //
        // Stop Listening
        //
        hr = _fnStreamFilterStop();
        if ( FAILED( hr ) )
        {
             DBGPRINTF(( DBG_CONTEXT,
                        "Error in StreamFilterStop().  hr = %x\n",
                        hr ));
        }
    case INIT_STREAMFILTER:
        _fnStreamFilterTerminate();

    case INIT_STRMFILT_LOADED:
        //
        // time to unload strmfilt
        //
        UnloadStrmfilt();

    case INIT_NONE:
        break;
    default:
        DBG_ASSERT( FALSE );
    }

    _InitStatus = INIT_NONE;

    return hr;

}


HRESULT
W3SSL_SERVICE::LoadStrmfilt(
    VOID
)
/*++

    Routine:
        Dynamically load strmfilt.dll

    Arguments:


    Returns:
        HRESULT
--*/

{
    HRESULT hr = E_FAIL;
    DBG_ASSERT( _hStrmfilt == NULL );
    _hStrmfilt = LoadLibraryEx( L"strmfilt.dll", 
                                NULL, 
                                0 );
    if ( _hStrmfilt != NULL ) 
    {
        _fnStreamFilterInitialize = (PFN_STREAM_FILTER_INITIALIZE) 
                                        GetProcAddress(_hStrmfilt, "StreamFilterInitialize"); 
        if ( _fnStreamFilterInitialize == NULL) 
        { 
            hr = HRESULT_FROM_WIN32( GetLastError() ); 
            DBGPRINTF(( DBG_CONTEXT, 
                        "Error in loading strmfilt %s entrypoint().  hr = %x\n", 
                        "StreamFilterInitialize", 
                        hr )); 
            goto Failed; 
        }

        _fnStreamFilterStart = (PFN_STREAM_FILTER_START) 
                                    GetProcAddress(_hStrmfilt, "StreamFilterStart"); 
        if ( _fnStreamFilterStart == NULL) 
        { 
            hr = HRESULT_FROM_WIN32( GetLastError() ); 
            DBGPRINTF(( DBG_CONTEXT, 
                        "Error in loading strmfilt %s entrypoint().  hr = %x\n", 
                        "StreamFilterStart", 
                        hr )); 
            goto Failed; 
        }

        _fnStreamFilterStop = (PFN_STREAM_FILTER_STOP) 
                                    GetProcAddress(_hStrmfilt, "StreamFilterStop"); 
        if ( _fnStreamFilterStop == NULL) 
        { 
            hr = HRESULT_FROM_WIN32( GetLastError() ); 
            DBGPRINTF(( DBG_CONTEXT, 
                        "Error in loading strmfilt %s entrypoint().  hr = %x\n", 
                        "StreamFilterStop", 
                        hr )); 
            goto Failed; 
        }

        _fnStreamFilterTerminate = (PFN_STREAM_FILTER_TERMINATE) 
                                    GetProcAddress(_hStrmfilt, "StreamFilterTerminate"); 
        if ( _fnStreamFilterTerminate == NULL) 
        { 
            hr = HRESULT_FROM_WIN32( GetLastError() ); 
            DBGPRINTF(( DBG_CONTEXT, 
                        "Error in loading strmfilt %s entrypoint().  hr = %x\n", 
                        "StreamFilterTerminate", 
                        hr )); 
            goto Failed; 
        }

        return S_OK;
    }
    else
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to load strmfilt.dll.  hr = %x\n",
                    hr ));
        goto Failed;
    }

Failed:

    UnloadStrmfilt();
    return hr;
}

HRESULT
W3SSL_SERVICE::UnloadStrmfilt(
    VOID
)
/*++

    Routine:
        Dynamically load strmfilt.dll

    Arguments:


    Returns:
        HRESULT
--*/


{
    if ( _hStrmfilt != NULL )
    {
        BOOL fRet = FreeLibrary( _hStrmfilt );
        
        _fnStreamFilterInitialize = NULL;
        _fnStreamFilterStart = NULL;
        _fnStreamFilterStop  = NULL;
        _fnStreamFilterTerminate = NULL;
        
        if ( !fRet )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }
    }
    _hStrmfilt = NULL;
    return S_OK;
}

DWORD WINAPI
HTTPFilterServiceThreadProc(
    LPVOID              /*lpParameter*/
)
/*++

    Routine:
        This is the "real" proc for the service.
        When HTTPFilterServiceMain is called, to prevent stack overflows,
        it creates a thread that will begin executing this routine.

    Arguments:
        lpParameter - Not used, should be NULL.

    Returns:
        Win32 error.  Does not return until service is stopped.

--*/
{
    W3SSL_SERVICE *     pHTTPFilterServiceInstance;
    DWORD               dwError = ERROR_SUCCESS;

    
    //
    // There is a possibility that after service reported it stopped
    // there is a new request to start the service again.
    // That may cause new thread to enter this function
    // before previous one fully cleaned up and returned.
    //

    pHTTPFilterServiceInstance = new W3SSL_SERVICE;
    if( pHTTPFilterServiceInstance == NULL )
    {
        //
        // report fatal error to SCM
        // (otherwise service would hang on START_PENDING)
        //
        dwError = ERROR_OUTOFMEMORY;
        SCM_MANAGER::ReportFatalServiceStartupError( 
            HTTPFILTER_SERVICE_NAME_W,
            dwError );
        return dwError;
    }
    
    pHTTPFilterServiceInstance->RunService();

    //
    // return value will be ignored.
    // Return value has only informational value 
    // if anything failed, SCM would be informed about the error
    // within RunService() call
    //

    delete pHTTPFilterServiceInstance;
    pHTTPFilterServiceInstance = NULL;

    return dwError;
}

VOID
HTTPFilterServiceMain(
    DWORD                   /*argc*/,
    LPWSTR                  /*argv*/[]
    )
/*++

    Routine:
        This is the "real" entrypoint for the service.  When
        the Service Controller dispatcher is requested to
        start a service, it creates a thread that will begin
        executing this routine.

        Note: HTTPFilterServiceMain name is recognized by lsass as entrypoint
        for HTTPFilter service

    Arguments:
        argc - Number of command line arguments to this service.
        argv - Pointers to the command line arguments.

    Returns:
        None.  Does not return until service is stopped.

--*/
{
    HRESULT                         hr = S_OK;
    DWORD                           dwError = ERROR_SUCCESS;
    HANDLE                          hThread = NULL;
    DWORD                           dwThreadId = 0;

    // Create a separate thread
    hThread = CreateThread( NULL,
                            // Big initial size to prevent stack overflows
                            IIS_DEFAULT_INITIAL_STACK_SIZE,
                            HTTPFilterServiceThreadProc, 
                            NULL, 
                            0, 
                            &dwThreadId );

    // If failed
    if ( !hThread )
    {
        // Get the error
        dwError=GetLastError();

        // Convert it to HRESULT
        hr=HRESULT_FROM_WIN32(dwError);
        DBGPRINTF(( DBG_CONTEXT,
                    "CreateThread() failed.  hr = %x\n",
                    hr ));
        //
        // We have to report the through SCM
        // since otherwise service may end up
        // in START_PENDING forever
        //

        SCM_MANAGER::ReportFatalServiceStartupError( 
            HTTPFILTER_SERVICE_NAME_W,
            dwError );

        goto exit;
    }

    // Wait for the service shutdown
    if ( WaitForSingleObject(hThread, INFINITE) == WAIT_FAILED )
    {
        dwError = GetLastError();

        hr = HRESULT_FROM_WIN32( dwError );
        DBGPRINTF((
            DBG_CONTEXT,
            "WaitForSingleObject() failed.  hr = %x\n",
            hr
            ));

        goto exit;
    }

    // Get the exit code
    if ( !GetExitCodeThread(hThread, &dwError) )
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
        DBGPRINTF(( DBG_CONTEXT,
                    "GetExitCodeThread() failed.  hr = %x\n",
                    hr ));
        goto exit;
    }

    DBG_ASSERT( dwError != STILL_ACTIVE );

    // If HTTPFilterServiceThreadProc failed
    if ( dwError != ERROR_SUCCESS )
    {
        // Convert it to HRESULT
        hr = HRESULT_FROM_WIN32(dwError);
        DBGPRINTF(( DBG_CONTEXT,
                    "HTTPFilterServiceThreadProc() failed.  hr = %x\n",
                    hr ));
    }

exit:
    if ( hThread )
    {
        // Close the handle
        CloseHandle(hThread);
    }
}



VOID
ServiceEntry(
    DWORD                    /*cArgs*/,          // unused
    LPSTR                    /*pArgs[]*/,        // unused
    PTCPSVCS_GLOBAL_DATA     /*pGlobalData*/     // unused

    )
/*++
    Routine:
        IIS services use ServiceEntry for entry point while HTTPFilter has
        HTTPFilterServiceMain name chosen for default entry point by preference of lsass
        Let's support both entry points so that HTTPFilter gets easily loaded
        by both lsass and inetinfo.exe

--*/
{
    HTTPFilterServiceMain( 0,
                           NULL );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ssinc\ssi_element_list.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    ssi_element_list.cxx

Abstract:

    This module contains the server side include processing code.  We 
    aim for support as specified by iis\spec\ssi.doc.  The code is based
    on existing SSI support done in iis\svcs\w3\gateways\ssinc\ssinc.cxx.

    SSI_ELEMENT_LIST handles parsing of the STM file and breaking it down
    to the sequence of directives/commands and blocks of static text

Author:

    Ming Lu (MingLu)       5-Apr-2000

Revision history
    Jaroslad               Dec-2000 
    - modified to execute asynchronously

    Jaroslad               Apr-2001
    - added VectorSend support, keepalive, split to multiple source files


--*/


#include "precomp.hxx"

//
//  This is the list of supported commands
//

struct _SSI_CMD_MAP
{
    CHAR *       pszCommand;
    DWORD        cchCommand;
    SSI_COMMANDS ssiCmd;
}
SSICmdMap[] =
{
    "#include ",  9,  SSI_CMD_INCLUDE,
    "#echo ",     6,  SSI_CMD_ECHO,
    "#fsize ",    7,  SSI_CMD_FSIZE,
    "#flastmod ",10,  SSI_CMD_FLASTMOD,
    "#config ",   8,  SSI_CMD_CONFIG,
    "#exec ",     6,  SSI_CMD_EXEC,
    NULL,         0,  SSI_CMD_UNKNOWN
};

//
//  This is the list of supported tags
//

struct _SSI_TAG_MAP
{
    CHAR *    pszTag;
    DWORD     cchTag;
    SSI_TAGS  ssiTag;
}
SSITagMap[] =
{
    "var",      3,  SSI_TAG_VAR,
    "file",     4,  SSI_TAG_FILE,
    "virtual",  7,  SSI_TAG_VIRTUAL,
    "errmsg",   6,  SSI_TAG_ERRMSG,
    "timefmt",  7,  SSI_TAG_TIMEFMT,
    "sizefmt",  7,  SSI_TAG_SIZEFMT,
    "cmd",      3,  SSI_TAG_CMD,
    "cgi",      3,  SSI_TAG_CGI,
    "isa",      3,  SSI_TAG_ISA,
    NULL,       0,  SSI_TAG_UNKNOWN
};


//  Class SSI_ELEMENT_LIST
//
//  This object sits as a cache blob under a file to be processed as a
//  server side include.  It represents an interpreted list of data 
//  elements that make up the file itself.
//


SSI_ELEMENT_LIST::SSI_ELEMENT_LIST()
  : _fHasDirectives( FALSE )
{
    InitializeListHead( &_ListHead );
    _Signature = SIGNATURE_SEL;
}

SSI_ELEMENT_LIST::~SSI_ELEMENT_LIST()
{
    SSI_ELEMENT_ITEM * pSEI;
    _Signature = SIGNATURE_SEL_FREE;
    while ( !IsListEmpty( &_ListHead ))
    {
        pSEI = CONTAINING_RECORD( _ListHead.Flink,
                                  SSI_ELEMENT_ITEM,
                                  _ListEntry );

        RemoveEntryList( &pSEI->_ListEntry );
        pSEI->_ListEntry.Flink = NULL;
        delete pSEI;
    }
}


//static
HRESULT
SSI_ELEMENT_LIST::CreateInstance( 
    SSI_FILE * pSsiFile,
    SSI_ELEMENT_LIST ** ppSsiElementList
    )
    
/*++

Routine Description:

    Creates instance of SSI_ELEMENT_LIST
    use instead of constructor
    
Arguments:

    pSsiFile - file to create element list from
    ppSsiElementList - new SSI_ELEMENT_ITEM instance

Return Value:

    HRESULT
    
--*/
{
    HRESULT             hr = E_FAIL;
    SSI_ELEMENT_LIST *  pSsiElementList = NULL;

    DBG_ASSERT( pSsiFile != NULL );

    pSsiElementList = new SSI_ELEMENT_LIST();

    if ( pSsiElementList == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_OUTOFMEMORY );
        goto failed;
    }

    hr = pSsiElementList->Initialize( pSsiFile );
    if ( FAILED( hr ) )   
    {
        goto failed;
    }

    *ppSsiElementList = pSsiElementList;
    return S_OK;
    
failed:

    DBG_ASSERT( FAILED( hr ) );
    if ( pSsiElementList != NULL )
    {
        delete pSsiElementList;
        pSsiElementList = NULL;
    }
    *ppSsiElementList = NULL;
    return hr;

}

HRESULT
SSI_ELEMENT_LIST::Initialize( 
    SSI_FILE * pSsiFile
    ) 

/*++

Routine Description:

    Private routine to setup SSI_ELEMENT_LIST
    
Arguments:

    pSsiFile - file to create element list from
 
Return Value:

    HRESULT
--*/
{
    CHAR *              pchBeginRange = NULL;
    CHAR *              pchFilePos = NULL;
    CHAR *              pchBeginFile = NULL;
    CHAR *              pchEOF = NULL;
    DWORD               cbFileSize;
    HRESULT             hr = E_FAIL;
    
    DBG_ASSERT( pSsiFile != NULL );
    
    //
    //  Make sure a parent doesn't try and include a directory
    //

    if ( pSsiFile->SSIGetFileAttributes() & FILE_ATTRIBUTE_DIRECTORY )
    {
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        goto failed;
    }

    if ( pSsiFile->SSIGetFileData() == NULL )
    {
        //
        // the only cause of NULL should be empty file => nothing to parse
        //
        hr = S_OK;
        goto finished;
    }

    if ( FAILED( hr = pSsiFile->SSIGetFileSize( &cbFileSize ) ) )
    {
        goto failed;
    }


    pchFilePos = pchBeginFile = pchBeginRange = 
                reinterpret_cast<CHAR *> ( pSsiFile->SSIGetFileData() );
    pchEOF     = pchFilePos + cbFileSize;

    //
    //  Scan for "<!--" or "<%"
    //

    for(;;)
    {
        while ( pchFilePos < pchEOF && *pchFilePos != '<' )
        {
            pchFilePos++;
        }

        if ( pchFilePos + 4 >= pchEOF )
        {
            break;
        }

        //
        //  Is this one of our tags?
        //

        if ( pchFilePos[1] == '%' ||
             !strncmp( pchFilePos, "<!--", 4 ))
        {
            CHAR *        pchBeginTag = pchFilePos;
            SSI_COMMANDS  CommandType;
            SSI_TAGS      TagType;
            CHAR          achTagString[ SSI_MAX_PATH + 1 ];
            BOOL          fValidTag;

            //
            //  Get the tag info.  The file position will be advanced to the
            //  first character after the tag
            //

            if ( !ParseSSITag( &pchFilePos,
                               pchEOF,
                               &fValidTag,
                               &CommandType,
                               &TagType,
                               achTagString ) )
            {
                break;
            }

            //
            //  If it's a tag we don't recognize then ignore it
            //

            if ( !fValidTag )
            {
                pchFilePos++;
                continue;
            }

            SetHasDirectives();

            //
            //  Add the data up to the tag as a byte range
            //

            if ( pchBeginRange != pchBeginTag )
            {
                if ( !AppendByteRange( 
                                  (DWORD) DIFF(pchBeginRange - pchBeginFile),
                                  (DWORD) DIFF(pchBeginTag - pchBeginRange) ) )
                {
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                    goto failed;
                }
            }

            pchBeginRange = pchFilePos;

            //
            //  Add the tag
            //

            if ( !AppendCommand( CommandType,
                                 TagType,
                                 achTagString ))
            {
                hr = E_FAIL;
                goto failed;
            }
        }
        else
        {
            //
            //  Not one of our tags, skip the openning angle bracket
            //

            pchFilePos++;
        }
    }

    //
    //  Tack on the last byte range
    //

    if ( pchFilePos > pchBeginRange )
    {
        if ( !AppendByteRange(  (DWORD) DIFF(pchBeginRange - pchBeginFile),
                                (DWORD) DIFF(pchFilePos - pchBeginRange) ))
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto failed;
        }
    }

    hr = S_OK;
    goto finished;

failed:

    DBG_ASSERT( FAILED( hr ) );
    //
    // cleanup will be done when destructor is called
    //
finished:

    return hr;
}



//static
BOOL
SSI_ELEMENT_LIST::ParseSSITag(
    IN OUT CHAR * *        ppchFilePos,
    IN     CHAR *          /*pchEOF*/,
    OUT    BOOL *          pfValidTag,
    OUT    SSI_COMMANDS  * pCommandType,
    OUT    SSI_TAGS *      pTagType,
    OUT    CHAR *          pszTagString
    )
/*++

Routine Description:

    This function picks apart an NCSA style server side include 
    expression

    The general form of a server side include directive is:

    <[!-- or %]#[command] [tag]="[value]"[-- or %]>

    For example:

    <!--#include file="myfile.txt"-->
    <%#echo var="HTTP_USER_AGENT"%>
    <!--#fsize virtual="/dir/bar.htm"-->

    For valid commands and tags see \iis\specs\ssi.doc

Arguments:

    ppchFilePos - Pointer to first character of tag on way in, pointer
        to first character after tag on way out if the tag is valid
    pchEOF - Points to first byte beyond the end of the file
    pfValidTag - Set to TRUE if this is a tag we support and all of the
        parameters have been supplied
    pCommandType - Receives SSI command
    pTagType - Receives SSI tag
    pszTagString - Receives value of pTagType.  Must be > SSI_MAX_PATH.

Return Value:

    TRUE if no errors occurred.

--*/
{
    CHAR * pchFilePos = *ppchFilePos;
    CHAR * pchEOT;
    CHAR * pchEndQuote;
    DWORD   i;
    DWORD   cbToCopy;
    DWORD   cbJumpLen = 0;
    BOOL    fNewStyle;           // <% format

    DBG_ASSERT( *pchFilePos == '<' );

    //
    //  Assume this is bad tag
    //

    *pfValidTag = FALSE;

    if ( !strncmp( pchFilePos, "<!--", 4 ) )
    {
        fNewStyle = FALSE;
    }
    else if ( !strncmp( pchFilePos, "<%", 2 ) )
    {
        fNewStyle = TRUE;
    }
    else
    {
        return TRUE;
    }

    //
    //  Find the closing comment token (either --> or %>).  The reason
    //  why we shouldn't simply look for a > is because we want to allow
    //  the user to embed HTML <tags> in the directive
    //  (ex. <!--#CONFIG ERRMSG="<B>ERROR!!!</B>-->)
    //

    pchEOT = strstr( pchFilePos, fNewStyle ? "%>" : "-->" );
    if ( !pchEOT )
    {
        return FALSE;
    }
    cbJumpLen = fNewStyle ? 2 : 3;

    //
    //  Find the '#' that prefixes the command
    //

    pchFilePos = SSISkipTo( pchFilePos, '#', pchEOT );

    if ( !pchFilePos )
    {
        //
        //  No command, bail for this tag
        //
        //  CODEWORK - Check for if expression here
        //

        return TRUE;
    }

    //
    //  Lookup the command
    //

    i = 0;
    while ( SSICmdMap[i].pszCommand )
    {
        if ( *SSICmdMap[i].pszCommand == towlower( *pchFilePos ) &&
             !_strnicmp( SSICmdMap[i].pszCommand,
                         pchFilePos,
                         SSICmdMap[i].cchCommand ))
        {
            *pCommandType = SSICmdMap[i].ssiCmd;

            //
            //  Note the space after the command is included in 
            //  cchCommand
            //

            pchFilePos += SSICmdMap[i].cchCommand;
            goto FoundCommand;
        }

        i++;
    }

    //
    //  Unrecognized command, bail
    //

    return TRUE;

FoundCommand:

    //
    //  Next, find the tag name
    //

    pchFilePos = SSISkipWhite( pchFilePos, pchEOT );

    if ( !pchFilePos )
        return TRUE;

    i = 0;
    while ( SSITagMap[i].pszTag )
    {
        if ( *SSITagMap[i].pszTag == tolower( *pchFilePos ) &&
             !_strnicmp( SSITagMap[i].pszTag,
                         pchFilePos,
                         SSITagMap[i].cchTag ))
        {
            *pTagType = SSITagMap[i].ssiTag;
            pchFilePos += SSITagMap[i].cchTag;
            goto FoundTag;
        }

        i++;
    }

    //
    //  Tag not found, bail
    //

    return TRUE;

FoundTag:

    //
    //  Skip to the quoted tag value, then find the close quote
    //

    pchFilePos = SSISkipTo( pchFilePos, '"', pchEOT );

    if ( !pchFilePos )
        return TRUE;

    pchEndQuote = SSISkipTo( ++pchFilePos, '"', pchEOT );

    if ( !pchEndQuote )
        return TRUE;

    cbToCopy = min( (DWORD) DIFF( pchEndQuote - pchFilePos ), SSI_MAX_PATH );

    memcpy( pszTagString,
            pchFilePos,
            cbToCopy );

    pszTagString[ cbToCopy ] = '\0';

    *pfValidTag = TRUE;

    *ppchFilePos = pchEOT + cbJumpLen;

    return TRUE;
}

//static
CHAR *
SSI_ELEMENT_LIST::SSISkipTo(
    IN CHAR * pchFilePos,
    IN CHAR   ch,
    IN CHAR * pchEOF
    )
/*++

Routine Description:

    skip to next occurence of character ch
    
Arguments:

    pchFilePos - current position of the file in the memory
    ch - character to move to 
    pchEOF - end position of the file in the memory

 
Return Value:

    CHAR *
--*/
    
{
    return ( CHAR * ) memchr( pchFilePos, 
                              ch, 
                              DIFF( pchEOF - pchFilePos ) );
}

//static
CHAR *
SSI_ELEMENT_LIST::SSISkipWhite(
    IN CHAR * pchFilePos,
    IN CHAR * pchEOF
    )
/*++

Routine Description:

    move to next no-white character
    
Arguments:

    pchFilePos - current position of the file in the memory
    pchEOF - end position of the file in the memory

 
Return Value:

    CHAR *
--*/

{
    while ( pchFilePos < pchEOF )
    {
        if ( !SAFEIsSpace( *pchFilePos ) )
        {
            return pchFilePos;
        }
        pchFilePos++;
    }

    return NULL;
}
    
BOOL 
SSI_ELEMENT_LIST::AppendByteRange( 
    IN DWORD  cbStart,
    IN DWORD  cbLength 
    )
/*++

Routine Description:

    add new item to SSI_ELEMENT_LIST representing block of static text
    
Arguments:

    cbStart - position (in bytes) where the block of static tet starts
    cbLength - lenght of the static text in bytes
 
Return Value:

    BOOL
--*/

{
    SSI_ELEMENT_ITEM * pSEI;

    pSEI = new SSI_ELEMENT_ITEM;

    if ( !pSEI )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    pSEI->SetByteRange( cbStart,
                        cbLength );
    AppendItem( pSEI );

    return TRUE;
}

BOOL 
SSI_ELEMENT_LIST::AppendCommand( 
    IN SSI_COMMANDS  ssiCmd,
    IN SSI_TAGS      ssiTag,
    IN CHAR *        pszTag 
    )
/*++

Routine Description:

    add new item to SSI_ELEMENT_LIST representing command/directive
    
Arguments:

    ssiCmd - command
    ssiTag - tag
    pszTag - value of the tag
 
Return Value:

    BOOL
--*/
{
    SSI_ELEMENT_ITEM * pSEI = new SSI_ELEMENT_ITEM;

    if ( !pSEI )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    if ( !pSEI->SetCommand( ssiCmd,
                            ssiTag,
                            pszTag ))
    {
        delete pSEI;
        pSEI = NULL;
        
        return FALSE;
    }

    AppendItem( pSEI );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ssinc\ssi_include_file.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    ssi_include_file.cxx

Abstract:

    This module contains the server side include processing code.  We 
    aim for support as specified by iis\spec\ssi.doc.  The code is based
    on existing SSI support done in iis\svcs\w3\gateways\ssinc\ssinc.cxx.

    A STM file may include other files. Each of those files is represented
    by SSI_INCLUDE_FILE class instance
    Most of the output generation is happening in this file


Author:

    Ming Lu (MingLu)       5-Apr-2000

Revision history
    Jaroslad               Dec-2000 
    - modified to execute asynchronously

    Jaroslad               Apr-2001
    - added VectorSend support, keepalive, split to multiple source files


--*/


#include "precomp.hxx"

//
//   This is a list of #ECHO variables not supported by ISAPI
//

struct _SSI_VAR_MAP
{
    CHAR *      pszMap;
    DWORD       cchMap;
    SSI_VARS    ssiMap;
}
SSIVarMap[] =
{
    "DOCUMENT_NAME",            13, SSI_VAR_DOCUMENT_NAME,
    "DOCUMENT_URI",             12, SSI_VAR_DOCUMENT_URI,
    "QUERY_STRING_UNESCAPED",   22, SSI_VAR_QUERY_STRING_UNESCAPED,
    "DATE_LOCAL",               10, SSI_VAR_DATE_LOCAL,
    "DATE_GMT",                 8,  SSI_VAR_DATE_GMT,
    "LAST_MODIFIED",            13, SSI_VAR_LAST_MODIFIED,
    NULL,                       0,  SSI_VAR_UNKNOWN
};

//
// SSI_INCLUDE_FILE methods implementation
//

//static 
ALLOC_CACHE_HANDLER * SSI_INCLUDE_FILE::sm_pachSsiIncludeFiles = NULL;


SSI_INCLUDE_FILE::~SSI_INCLUDE_FILE( VOID )
/*++

Routine Description:

    Destructor

--*/

{
    if ( _pSsiFile != NULL )
    {
        _pSsiFile->DereferenceSsiFile();
        _pSsiFile = NULL;
    }
}    

// static
HRESULT
SSI_INCLUDE_FILE::CreateInstance( 
    IN  STRU &                   strFilename,
    IN  STRU &                   strURL,
    IN  SSI_REQUEST *            pRequest,
    IN  SSI_INCLUDE_FILE *       pParent,
    OUT SSI_INCLUDE_FILE **      ppSsiIncludeFile
    )
/*++

Routine Description:
    Instantiate SSI_INCLUDE_FILE

Arguments:


Return Value:

    HRESULT
    
--*/
{
    HRESULT     hr = E_FAIL;
    SSI_INCLUDE_FILE * pSsiIncludeFile = NULL;
    
    DBG_ASSERT( pRequest != NULL );
    
    pSsiIncludeFile = new SSI_INCLUDE_FILE( pRequest,
                                            pParent );
    if ( pSsiIncludeFile == NULL )
    {
        return HRESULT( ERROR_OUTOFMEMORY );
    }

    hr = pSsiIncludeFile->Initialize( strFilename,
                                      strURL );
    if ( FAILED( hr ) )
    {
        goto failed;
    }

    //
    // pass created SSI_INCLUDE_FILE through OUT parameter
    //
    *ppSsiIncludeFile = pSsiIncludeFile;
    return S_OK;
        
failed:
    DBG_ASSERT( FAILED( hr ) );

    if ( pSsiIncludeFile != NULL )
    {
        delete pSsiIncludeFile;
        pSsiIncludeFile = NULL;
    }
    *ppSsiIncludeFile = NULL;
    return hr;

}

HRESULT  
SSI_INCLUDE_FILE::Initialize(
    IN  STRU &                   strFilename,
    IN  STRU &                   strURL
    ) 
/*++

Routine Description:

    Private initialization rouinte for CreateInstance

Arguments:


Return Value:

    HRESULT
    
--*/        
{
    HRESULT     hr = E_FAIL;
    
    if ( FAILED( hr = _strFilename.Copy( strFilename ) ) )
    {
        goto failed;
    }

    if ( FAILED( hr =_strURL.Copy( strURL ) ) )
    {
        goto failed;
    }

    if ( FAILED( hr =_strTimeFmt.Copy( SSI_DEF_TIMEFMT ) ) )
    {
        goto failed;
    }
    
    //
    // get the SSI_FILE (it enables acces to file data and
    // also contains SSI_ELEMENT_LIST
    //

    hr = SSI_FILE::GetReferencedInstance( 
            _strFilename,
            _pRequest->GetUserToken(),
            &_pSsiFile );
    
    if ( FAILED( hr ) )
    {
        goto failed;
    }

    SetState( SIF_STATE_READY );
    
    return S_OK;
        
failed:
    DBG_ASSERT( FAILED( hr ) );

    //
    // In the case of error set state to Processed
    // Note: Don't set state to SIF_STATE_COMPLETED because that would cause
    // buffered data from the response not be sent 
    // (including the last error message)
    //
    SetState( SIF_STATE_PROCESSED );

    //
    // leftover data structures will be cleaned up in the destructor
    //

    return hr;
}    


HRESULT
SSI_INCLUDE_FILE::DoWork( 
    IN  HRESULT    hrLastOp,
    OUT BOOL       *pfAsyncPending
    )
/*++

Routine Description:

    This method walks the element list sending the appropriate chunks of
    data

Arguments:
    
    hrLastOp - error of the last asynchronous operation
    pfAsyncPending - TRUE if there is pending async operation
Return Value:

    HRESULT
--*/
{
    HSE_EXEC_URL_STATUS     ExecUrlStatus;
    SSI_ELEMENT_ITEM *      pSEI;
    DWORD                   dwID = 0;
    LPSTR                   apszParms[ 2 ] = { NULL, NULL };
    CHAR                    achNumberBuffer[ SSI_MAX_NUMBER_STRING ];
    HRESULT                 hr = E_FAIL;

    DBG_ASSERT( _pRequest != NULL );
    DBG_ASSERT( pfAsyncPending != NULL );
    
    *pfAsyncPending = FALSE;

    if ( FAILED( hrLastOp ) )
    {
        //
        // Last asynchronous operation failed
        // only in the state: SIF_STATE_EXEC_URL_PENDING we will proceed if error occured
        //

        if ( _State != SIF_STATE_EXEC_URL_PENDING )
        {
            //
            // Completion error means that we are forced to finish processing
            //
            SetState( SIF_STATE_COMPLETED );
            hr = hrLastOp;
        }
    }

    while( _State !=  SIF_STATE_COMPLETED )
    {

        switch( _State )
        {
        case SIF_STATE_READY:
            //
            // All the necessary data structures are ready
            //
            // Set the Response Headers and switch to PROCESSING state
            //

            //    
            // Set response headers if we are in the top level INCLUDE file
            //
            SetState( SIF_STATE_PROCESSING );
            
            if ( IsBaseFile() )
            {
                if ( _pSsiFile->QueryHasDirectives() )
                {
                    //
                    // there are SSI directives to be processesed
                    // send only SSI_HEADER
                    //
            
                    return _pRequest->GetVectorBuffer().AddVectorHeaders( 
                                                            SSI_HEADER );
                }
                else
                {
                    //
                    // There are no SSI directives, we will be able to send 
                    // the whole response at once
                    //
                    CHAR * pszResponseHeaders = NULL;
                    BOOL   fIncludesContentLength = FALSE;
                    DWORD  cbFileSize = 0;

                    hr = _pSsiFile->GetResponseHeaders( &pszResponseHeaders,
                                                        &fIncludesContentLength );
                    if( FAILED( hr ) )
                    {
                        return hr;
                    }

                    DBG_ASSERT( pszResponseHeaders != NULL );

                    hr = _pRequest->GetVectorBuffer().AddVectorHeaders( 
                                                    pszResponseHeaders,
                                                    fIncludesContentLength );
                    if( FAILED( hr ) )
                    {
                        return hr;
                    }

                    // Optimization: 
                    // If there are no directives in the file then AddToVector
                    // and set state to complete.
                    //
                    hr = _pSsiFile->SSIGetFileSize( &cbFileSize );
                    if( FAILED( hr ) )
                    {
                        return hr;
                    }
                    
                    if ( _pSsiFile->SSIGetFileData() != NULL )
                    {
                        //
                        // file cached in memory
                        //
                        hr = _pRequest->GetVectorBuffer().AddToVector( 
                                                 (PCHAR)_pSsiFile->SSIGetFileData(),
                                                 cbFileSize );  
                    }
                    else
                    {
                        hr = _pRequest->GetVectorBuffer().AddFileChunkToVector( 
                                        0,
                                        cbFileSize,
                                        _pSsiFile->SSIGetFileHandle() );
                    }

                    if ( FAILED( hr ) )
                    {
                        return( hr );
                    }
                    
                    SetState( SIF_STATE_PROCESSED );
                }
            }  
            break;

        case SIF_STATE_PROCESSING:
            //
            // There are few cases when ProcessElements() will return
            // a) request completed
            // b) pending operation
            // c) child include file to be processed
            //
            // in any case return back to caller
            //

            hr = ProcessSsiElements( pfAsyncPending );
            if ( SUCCEEDED( hr ) &&
                 !*pfAsyncPending )
            {
                if (_State == SIF_STATE_INCLUDE_CHILD_PENDING)
                {
                    return hr;
                }

                break;
            }
            else
            {
                return hr;
            }

        case SIF_STATE_INCLUDE_CHILD_PENDING:
            //
            // Child include completed. Restore processing of current include file
            //
            SetState( SIF_STATE_PROCESSING );
            break;

        case SIF_STATE_EXEC_URL_PENDING:
            
            //
            // We were able to spawn child request.  Get the status
            //
            pSEI = CONTAINING_RECORD( _pCurrentEntry, SSI_ELEMENT_ITEM, _ListEntry );    
            if( _pRequest->GetECB()->ServerSupportFunction(
                                _pRequest->GetECB()->ConnID,
                                HSE_REQ_GET_EXEC_URL_STATUS,
                                &ExecUrlStatus,
                                NULL,
                                NULL
                                ) )
            {
                if ( ExecUrlStatus.uHttpStatusCode >= 400 )
                {
                    apszParms[ 0 ] = ( CHAR* )pSEI->QueryTagValue()->QueryStr();                    
                    if ( ExecUrlStatus.uHttpStatusCode == 403 )
                    {
                        dwID = SSINCMSG_NO_EXECUTE_PERMISSION;
                    }
                    else if ( ExecUrlStatus.dwWin32Error != 0 )
                    {
                        //
                        // If there was a Win32 error return that rather than 
                        // HTTP error
                        //
                        
                        switch( pSEI->QueryTag() )
                        {
                        case SSI_TAG_CMD: 
                             dwID = SSINCMSG_CANT_EXEC_CMD;
                             break;
                        case SSI_TAG_CGI:
                             dwID = SSINCMSG_CANT_EXEC_CGI;
                             break;
                        case SSI_TAG_ISA:
                             dwID = SSINCMSG_CANT_EXEC_ISA;
                             break;
                        default:
                             DBG_ASSERT( FALSE );
                             break;

                        }
                        _itoa( ExecUrlStatus.dwWin32Error, achNumberBuffer, 10 );
                        apszParms[ 1 ] = achNumberBuffer;
                    }
                    else
                    {
                        dwID = SSINCMSG_CANT_EXEC_CGI_REPORT_HTTP_STATUS;
                        _itoa( ExecUrlStatus.uHttpStatusCode, achNumberBuffer, 10 );
                        apszParms[ 1 ] = achNumberBuffer;
                    }

                 }
                else
                {
                    dwID = 0;
                }
            }
            else
            {
                _ultoa( GetLastError(), achNumberBuffer, 10 );
                apszParms[ 0 ] = ( CHAR * )pSEI->QueryTagValue()->QueryStr();
                apszParms[ 1 ] = achNumberBuffer;
                dwID = SSINCMSG_CANT_EXEC_CGI;
            }

            //
            //  EXEC_URL completed. Adjust State back to PROCESSING
            //

            SetState( SIF_STATE_PROCESSING );

            if ( dwID != 0 )
            {
                hr = _pRequest->SSISendError( dwID, apszParms );
                if ( FAILED (hr) )
                {
                    return hr;
                }
            }
            break;
        case SIF_STATE_VECTOR_SEND_PENDING:
            
            //
            // Vector was sent. It's time to reset Vector data and continue processing
            //
            if ( FAILED( hr = _pRequest->GetVectorBuffer().Reset() ) )
            {
                return hr;
            }
            SetState( SIF_STATE_PROCESSING );
            break;
        case SIF_STATE_PROCESSED:
            //
            // All the data was processed
            // Make the VectorSend only for the Base file
            // 
            //
            if ( IsBaseFile() )
            {
                SetState( SIF_STATE_COMPLETE_PENDING );
                hr = _pRequest->GetVectorBuffer().VectorSend( 
                                  pfAsyncPending, 
                                  TRUE /*FinalSend*/ );
            }
            else
            {
                //
                // not a base file
                // SSI_INCLUDE_FILE processing is completed
                // however sending the response will happen later
                // (either at the very end for the Base file
                // of whenever ExecuteUrl is called)
                //
                SetState( SIF_STATE_COMPLETED );
                break;
            }
            
            if( FAILED(hr) || !*pfAsyncPending )
            {
                SetState( SIF_STATE_COMPLETED );
                _pRequest->GetVectorBuffer().Reset();
            }
            else
            {
                 // wait for the completion of VectorSend() or bail out on error
                 return hr;
            }
            break;

        case SIF_STATE_COMPLETE_PENDING:
            //
            // last VectorSend for SSI_INCLUDE_FILE of Sending Custom Error 
            // completed
            //
            if ( FAILED( hr = _pRequest->GetVectorBuffer().Reset() ) )
            {
                return hr;
            }
            SetState( SIF_STATE_COMPLETED );
            hr = S_OK;
            break;

        default:
            //
            // Unexpected State
            //
            DBG_ASSERT( _State > SIF_STATE_UNINITIALIZED && _State < SIF_STATE_UNKNOWN );
            return E_FAIL;
        } // switch( _State )
    } 
    
    return hr;
}
    

HRESULT
SSI_INCLUDE_FILE::ProcessSsiElements(
    OUT BOOL *      pfAsyncPending
    )
/*++

Routine Description:

    This method walks the element list sending the appropriate chunks of
    data

Arguments:


Return Value:

    HRESULT
--*/
{

    STACK_STRU(             strPath, SSI_DEFAULT_PATH_SIZE + 1 );
    SSI_ELEMENT_ITEM *      pSEI;
    DWORD                   dwID;
    LPSTR                   apszParms[ 2 ];
    CHAR                    achNumberBuffer[ SSI_MAX_NUMBER_STRING ];
    HRESULT                 hr = E_FAIL;
    SSI_ELEMENT_LIST *      pSEL = NULL; 
    SSI_EXEC_TYPE           ssiExecType;
   
    DBG_ASSERT( _pRequest != NULL );
    DBG_ASSERT( _pSsiFile != NULL );
    
    pSEL = _pSsiFile->GetSsiElementList();

    if ( pSEL == NULL )
    {
        //
        // empty list means empty file
        //
        SetState( SIF_STATE_PROCESSED );
        return NO_ERROR;    
    }
    
    DBG_ASSERT( pSEL != NULL );

   
    if( _pCurrentEntry == NULL )
    {
        _pCurrentEntry = pSEL->QueryListHead();
    }

    //
    // Move CurrentEntry pointer to next element
    //
    _pCurrentEntry = _pCurrentEntry->Flink;
    
    //
    //  Loop through each element and take the appropriate action
    //

    while( _pCurrentEntry != pSEL->QueryListHead() )
    {

        DBG_ASSERT( _State == SIF_STATE_PROCESSING );

        pSEI = CONTAINING_RECORD( _pCurrentEntry, 
                                  SSI_ELEMENT_ITEM, 
                                  _ListEntry );

        DBG_ASSERT( pSEI->CheckSignature() );

        //
        // Initialize error structures
        //
        
        dwID = 0;
        apszParms[ 0 ] = NULL;
        apszParms[ 1 ] = NULL;

        switch ( pSEI->QueryCommand() )
        {
        case SSI_CMD_BYTERANGE:
            // DBGPRINTF((DBG_CONTEXT, "SSI_CMD_BYTERANGE element, SSI_FILE %S, offset %d\n", _strFilename.QueryStr(), pSEI->QueryBegin()));
            //
            // SSIGetFileData() may be NULL if file is too large to be cached
            // in memory by w3core FILE CACHE
            //
            
            if ( _pSsiFile->SSIGetFileData() != NULL )
            {
                if ( FAILED( hr = _pRequest->GetVectorBuffer().AddToVector( 
                                        (PCHAR)_pSsiFile->SSIGetFileData() + 
                                            pSEI->QueryBegin(),
                                        pSEI->QueryLength() ) ) )
                {
                    return hr;
                }
            }
            else 
            {
                //
                // if file is not cached in memory then file handle must be available
                //
                DBG_ASSERT( _pSsiFile->SSIGetFileHandle() != NULL );
                if ( FAILED( hr = _pRequest->GetVectorBuffer().AddFileChunkToVector( 
                                        pSEI->QueryBegin(),
                                        pSEI->QueryLength(),
                                        _pSsiFile->SSIGetFileHandle() ) ) )
                {
                    return hr;
                }
            }
            break;

        case SSI_CMD_INCLUDE:
            // DBGPRINTF((DBG_CONTEXT, "SSI_CMD_INCLUDE element, SSI_FILE %S\n", _strFilename.QueryStr()));

            switch ( pSEI->QueryTag() )
            {
            case SSI_TAG_FILE:
            case SSI_TAG_VIRTUAL:
            {
                STACK_STRU(    strFullURL, SSI_DEFAULT_URL_SIZE + 1 );

                if ( FAILED ( hr = GetFullPath( pSEI,
                                   &strPath,
                                   HSE_URL_FLAGS_READ,
                                   &_strURL,
                                   &strFullURL ) ) )
                {
                    _ultoa( WIN32_FROM_HRESULT( hr ), 
                            achNumberBuffer, 
                            10 );
                    apszParms[ 0 ] = ( CHAR * )pSEI->QueryTagValue()->
                                                     QueryStr();
                    apszParms[ 1 ] = achNumberBuffer;
                    dwID = SSINCMSG_ERROR_HANDLING_FILE;
                    break;
                }

                if ( IsRecursiveInclude( strPath ) )
                {
                    apszParms[ 0 ] = ( CHAR * )pSEI->QueryTagValue()->
                                                     QueryStr();
                    apszParms[ 1 ] = NULL;
                    dwID = SSINCMSG_ERROR_RECURSIVE_INCLUDE;
                    break;
                }

                //
                // Nested STM include
                //
                
                SSI_INCLUDE_FILE * pChild = NULL;
                
                hr = SSI_INCLUDE_FILE::CreateInstance( 
                                        strPath, 
                                        strFullURL,
                                        _pRequest,
                                        this, /*Parent*/
                                        &pChild );

                if ( FAILED( hr ) ) 
                {
                    _ultoa( WIN32_FROM_HRESULT( hr ), achNumberBuffer, 10 );
                    apszParms[ 0 ] = ( CHAR * )pSEI->QueryTagValue()->
                                                     QueryStr();
                    apszParms[ 1 ] = achNumberBuffer;
                    dwID = SSINCMSG_ERROR_HANDLING_FILE;
                    break;
                }    

                //
                // _pRequest is taking over the ownership of the pChild
                // it will control it's lifetime
                //
                
                _pRequest->SetCurrentIncludeFile( pChild );

                SetState( SIF_STATE_INCLUDE_CHILD_PENDING );

                //
                // Return back to SSI_REQUEST (_pRequest)
                // SSI_REQUEST will start executing it just added SSI_INCLUDE_FILE (pChild)
                //
                // This way recursive function calls that were used in the previous
                // implementation can be avoided (to makes possible to implement 
                // asynchronous processing)
                //
                
                return NO_ERROR;
            }
            default:
                dwID = SSINCMSG_INVALID_TAG;
            }
            break;

        case SSI_CMD_FLASTMOD:
            // DBGPRINTF((DBG_CONTEXT, "SSI_CMD_FLASTMOD element, SSI_FILE %S\n", _strFilename.QueryStr()));

            switch( pSEI->QueryTag() )
            {
            case SSI_TAG_FILE:
            case SSI_TAG_VIRTUAL:
                if ( FAILED( hr = GetFullPath( pSEI,
                                   &strPath,
                                   0,
                                   &_strURL ) ) ||
                     FAILED( hr = DoFLastMod( &strPath ) ) )
                {
                 
                    _ultoa( WIN32_FROM_HRESULT( hr ), 
                            achNumberBuffer, 
                            10 );
                    apszParms[ 0 ] = ( CHAR * )pSEI->QueryTagValue()->
                                                     QueryStr();
                    apszParms[ 1 ] = achNumberBuffer;
                    dwID = SSINCMSG_CANT_DO_FLASTMOD;
                }
                break;
            default:
                dwID = SSINCMSG_INVALID_TAG;
            }
            break;

        case SSI_CMD_CONFIG:
            // DBGPRINTF((DBG_CONTEXT, "SSI_CMD_CONFIG element, SSI_FILE %S\n", _strFilename.QueryStr()));

            switch( pSEI->QueryTag() )
            {
            case SSI_TAG_ERRMSG:
                if ( !_pRequest->SetUserErrorMessage( 
                                       pSEI->QueryTagValue() ) )
                {
                    dwID = SSINCMSG_INVALID_TAG;
                }
                break;
            case SSI_TAG_TIMEFMT:
                if ( pSEI->QueryTagValue()->IsEmpty() || 
                     FAILED( _strTimeFmt.Resize( pSEI->QueryTagValue()->QueryCCH() ) ) )
                {
                    dwID = SSINCMSG_INVALID_TAG;
                }

                if ( FAILED( hr = _strTimeFmt.Copy( pSEI->QueryTagValue()->QueryStr() ) ) )
                {
                    return hr;
                }
                                
                break;
            case SSI_TAG_SIZEFMT:
                if ( _strnicmp( SSI_DEF_BYTES,
                             ( CHAR * )pSEI->QueryTagValue()->QueryStr(),
                             SSI_DEF_BYTES_LEN ) == 0 )
                {
                    _fSizeFmtBytes = TRUE;
                }
                else if ( _strnicmp( SSI_DEF_ABBREV,
                             ( CHAR * )pSEI->QueryTagValue()->QueryStr(),
                                     SSI_DEF_ABBREV_LEN ) == 0 )
                {
                    _fSizeFmtBytes = FALSE;
                }
                else
                {
                    dwID = SSINCMSG_INVALID_TAG;
                }
                break;
            default:
                dwID = SSINCMSG_INVALID_TAG;
            }
            break;

        case SSI_CMD_FSIZE:
            // DBGPRINTF((DBG_CONTEXT, "SSI_CMD_FSIZE element, SSI_FILE %S,\n", _strFilename.QueryStr()));

            switch( pSEI->QueryTag() )
            {
            case SSI_TAG_FILE:
            case SSI_TAG_VIRTUAL:
                if ( FAILED ( hr = GetFullPath( pSEI,
                                   &strPath,
                                   0,
                                   &_strURL ) ) ||
                     FAILED ( hr = DoFSize( &strPath ) ) )
                {
                    _ultoa( WIN32_FROM_HRESULT( hr ), 
                            achNumberBuffer, 
                            10 );
                    apszParms[ 0 ] = ( CHAR * )pSEI->QueryTagValue()->
                                                     QueryStr();
                    apszParms[ 1 ] = achNumberBuffer;
                    dwID = SSINCMSG_CANT_DO_FSIZE;
                                   
                }
                break;
            default:
                dwID = SSINCMSG_INVALID_TAG;
            }
        
            break;

        case SSI_CMD_ECHO:
            // DBGPRINTF((DBG_CONTEXT, "SSI_CMD_ECHO element, SSI_FILE %S\n", _strFilename.QueryStr()));

            if ( pSEI->QueryTag() == SSI_TAG_VAR )
            {
                // First let ISAPI try to evaluate variable.
                hr = DoEchoISAPIVariable( pSEI->QueryTagValue() );
                if ( SUCCEEDED (hr ) )                     
                {
                    break;
                }
                else
                {
                    DWORD               dwVar;
                    HRESULT             hrEcho = E_FAIL;

                    // if ISAPI couldn't resolve var, try internal list
                    if ( !FindInternalVariable( pSEI->QueryTagValue(),
                                               &dwVar ) )
                    {
                        apszParms[ 0 ] = ( CHAR * )pSEI->QueryTagValue()->
                                                        QueryStr();
                        apszParms[ 1 ] = NULL;
                        dwID = SSINCMSG_CANT_FIND_VARIABLE;
                    }
                    else
                    {
                        switch( dwVar )
                        {
                        case SSI_VAR_DOCUMENT_NAME:
                            hrEcho = DoEchoDocumentName();
                            break;
                        case SSI_VAR_DOCUMENT_URI:
                            hrEcho = DoEchoDocumentURI();
                            break;
                        case SSI_VAR_QUERY_STRING_UNESCAPED:
                            hrEcho = DoEchoQueryStringUnescaped();
                            break;
                        case SSI_VAR_DATE_LOCAL:
                            hrEcho = DoEchoDateLocal();
                            break;
                        case SSI_VAR_DATE_GMT:
                            hrEcho = DoEchoDateGMT();
                            break;
                        case SSI_VAR_LAST_MODIFIED:
                            hrEcho = DoEchoLastModified();
                            break;
                        default:
                            apszParms[ 0 ] = ( CHAR * )pSEI->
                                             QueryTagValue()->QueryStr();
                            apszParms[ 1 ] = NULL;
                            dwID = SSINCMSG_CANT_FIND_VARIABLE;
                        }
               
                        if ( FAILED ( hrEcho ) )
                        {
                            apszParms[ 0 ] = ( CHAR * )pSEI->
                                             QueryTagValue()->QueryStr();
                            apszParms[ 1 ] = NULL;
                            dwID = SSINCMSG_CANT_EVALUATE_VARIABLE;
                        }
                    }
                }
            }
            else
            {
                dwID = SSINCMSG_INVALID_TAG;
            }

            break;

        case SSI_CMD_EXEC:
            // DBGPRINTF((DBG_CONTEXT, "SSI_CMD_EXEC element, SSI_FILE %S\n", _strFilename.QueryStr()));

            ssiExecType = SSI_EXEC_UNKNOWN;

            if ( _pRequest->IsExecDisabled() )
            {
                dwID = SSINCMSG_EXEC_DISABLED;
            }
            else if ( pSEI->QueryTag() == SSI_TAG_CMD )
            {
                if ( !_pRequest->IsCmdDirectiveEnabled() )
                {
                    dwID = SSINCMSG_CMD_NOT_ENABLED;
                }
                else
                {
                    ssiExecType = SSI_EXEC_CMD;
                }
            }
            else if ( pSEI->QueryTag() == SSI_TAG_CGI )
            {
                ssiExecType = SSI_EXEC_CGI;
            }
            else if ( pSEI->QueryTag() == SSI_TAG_ISA )
            {
                ssiExecType = SSI_EXEC_ISA;
            }
            else
            {
                dwID = SSINCMSG_INVALID_TAG;
            }

            if ( ssiExecType != SSI_EXEC_UNKNOWN )
            {
                BOOL fOk = FALSE;

                //
                // We have to send all of the currently buffered Vector data 
                // before we start with Child Execute 
                //
                // If there is data to be sent then VectorSend will execute
                // asynchronously and we can proceed with EXEC_URL 
                // only after it is completed. That's why we have to move 
                // _pCurrentEntry back by one
                // After VectorSend completes, then the next call to VectorSend
                // will not have to send anything and it completes right away
                // and we can continue with EXEC_URL
                //
                // _pCurrentEntry must be changed before VectorSend is called
                // because VectorSend could complete on different thread
                // before this thread completed with the request
                //
                SetState( SIF_STATE_VECTOR_SEND_PENDING );
                
                _pCurrentEntry = _pCurrentEntry->Blink;
                
                hr = _pRequest->GetVectorBuffer().VectorSend( pfAsyncPending );

                if( SUCCEEDED( hr ) && !*pfAsyncPending )
                {
                    SetState( SIF_STATE_PROCESSING );
                    _pRequest->GetVectorBuffer().Reset();
                    //
                    // Restore _pCurrentEntry
                    //
                    _pCurrentEntry = _pCurrentEntry->Flink;
                }
                else
                {
                    //
                    // Wait for the completion of VectorSend() 
                    // or bail out on error
                    //
                    return hr;
                }

                ZeroMemory( &_ExecUrlInfo, 
                            sizeof( _ExecUrlInfo ) );

                //
                // Make asynchronous Child Execute
                //
                _ExecUrlInfo.dwExecUrlFlags = HSE_EXEC_URL_NO_HEADERS |
                                              HSE_EXEC_URL_DISABLE_CUSTOM_ERROR |
                                              HSE_EXEC_URL_IGNORE_VALIDATION_AND_RANGE;

                if ( ssiExecType == SSI_EXEC_CMD )
                {
                    _ExecUrlInfo.dwExecUrlFlags |= HSE_EXEC_URL_SSI_CMD;
                }
                
                _ExecUrlInfo.pszUrl = (LPSTR) pSEI->QueryTagValue()->QueryStr();

                DBG_ASSERT( _ExecUrlInfo.pszUrl != NULL );

                //
                // Avoid execution of empty URL
                //

          
                if ( _ExecUrlInfo.pszUrl[0] == '\0' )
                {                
                    _ultoa( ERROR_INVALID_NAME, achNumberBuffer, 10 );
                    apszParms[ 0 ] = _ExecUrlInfo.pszUrl;
                    apszParms[ 1 ] = achNumberBuffer;
                    switch( pSEI->QueryTag() )
                    {
                    case SSI_TAG_CMD: 
                         dwID = SSINCMSG_CANT_EXEC_CMD;
                         break;
                    case SSI_TAG_CGI:
                         dwID = SSINCMSG_CANT_EXEC_CGI;
                         break;
                    case SSI_TAG_ISA:
                         dwID = SSINCMSG_CANT_EXEC_ISA;
                         break;
                    default:
                         DBG_ASSERT( FALSE );
                         break;
                    }

                    break;
                }
                
                SetState( SIF_STATE_EXEC_URL_PENDING );
                fOk = _pRequest->GetECB()->ServerSupportFunction(
                                     _pRequest->GetECB()->ConnID,
                                     HSE_REQ_EXEC_URL,
                                     &_ExecUrlInfo,
                                     NULL,
                                     NULL
                                     );
                if ( !fOk )
                {
                    SetState( SIF_STATE_PROCESSING );
                    _ultoa( GetLastError(), achNumberBuffer, 10 );
                    apszParms[ 0 ] = ( CHAR * )pSEI->QueryTagValue()->QueryStr();
                    apszParms[ 1 ] = achNumberBuffer;
                    dwID = SSINCMSG_CANT_EXEC_CGI;
                }
                else
                {
                    hr = S_OK;
                    *pfAsyncPending = TRUE;
                    return hr;
                }
            }
            break;

        default:
            // DBGPRINTF((DBG_CONTEXT, "unknown element, SSI_FILE %S\n", _strFilename.QueryStr()));

            dwID = SSINCMSG_NOT_SUPPORTED;
            break;
        }
        if ( dwID )
        {
            hr = _pRequest->SSISendError( dwID, apszParms );
            if ( FAILED (hr) )
            {
                return hr;
            }
        }

        //
        // Before moving to next element of SSI_ELEMENT_LIST
        // check if there is a need to flush currently buffered VectorSend
        //


        if ( _pRequest->GetVectorBuffer().QueryCurrentNumberOfElements() > SSI_DEFAULT_NUM_VECTOR_ELEMENTS )
        {
            SetState( SIF_STATE_VECTOR_SEND_PENDING );

            hr = _pRequest->GetVectorBuffer().VectorSend( pfAsyncPending );

            if( SUCCEEDED( hr ) && !*pfAsyncPending )
            {
                SetState( SIF_STATE_PROCESSING );
                _pRequest->GetVectorBuffer().Reset();
            }
            else
            {
                //
                // Wait for the completion of VectorSend() 
                // or bail out on error
                //
                return hr;
            }

        }
        //
        // Move to next element of SSI_ELEMENT_LIST
        //

        _pCurrentEntry = _pCurrentEntry->Flink;
    }
    //
    // End of the list has been reached
    // It means that processing of the current SSI_INCLUDE_FILE has completed
    //
    SetState( SIF_STATE_PROCESSED );
    return NO_ERROR;
}

HRESULT
SSI_INCLUDE_FILE::GetFullPath(
    IN SSI_ELEMENT_ITEM *   pSEI,
    OUT STRU *              pstrPath,
    IN DWORD                dwPermission,
    IN STRU  *              pstrCurrentURL,
    OUT STRU *              pstrURL
)
/*++

Routine Description:

    Used to resolve FILE= and VIRTUAL= references.  Fills in the physical
    path of such file references and optionally checks the permissions
    of the virtual directory.

Arguments:

    pSEI - Element item ( either FILE or VIRTUAL )
    pstrPath - Filled in with physical path of file
    dwPermission - Contains permissions that the virtual
                   path must satisfy. For example HSE_URL_FLAGS_READ.
                   If 0, then no permissions are checked
    pstrCurrentURL - Current .STM URL being parsed
    pstrURL - Full URL filled in here (may be NULL if only pstrPath is to be retrieved)

Return Value:

    HRESULT
--*/
{
    WCHAR *             pszValue;
    STACK_STRU(         strValue, SSI_DEFAULT_TAG_SIZE + 1 );
    STACK_STRA(         straValue, SSI_DEFAULT_TAG_SIZE + 1 );
    STACK_STRU(         strPath, SSI_MAX_PATH + 1 ); 
    HRESULT             hr = E_FAIL;

    //
    //  We recalc the virtual root each time in case the root
    //  to directory mapping has changed
    //

    if ( FAILED( hr = strValue.CopyA( pSEI->QueryTagValue()->QueryStr() ) ) )
    {
        return hr;
    }

    pszValue = strValue.QueryStr();

    if ( *pszValue == L'/' )
    {
        if ( FAILED( hr = strPath.Copy( pszValue ) ) )
        {
            return hr;
        }
    }
    else if ( ( int )pSEI->QueryTag() == ( int )SSI_TAG_FILE )
    {
        if ( FAILED( hr = strPath.Copy( pstrCurrentURL->QueryStr() ) ) )
        {
            return hr;
        }
        
        LPWSTR pL = strPath.QueryStr() + strPath.QueryCCH();
        while ( pL > strPath.QueryStr() && pL[ -1 ] != L'/' )
        {
            --pL;
        }

        if ( pL == strPath.QueryStr() )
        {
            if ( FAILED( hr = strPath.Copy( L"/" ) ) )
            {
                return hr;
            }
        }
        else
        {
            //
            // truncate the path off the filename
            // (SetLen takes number of characters)
            //
            strPath.SetLen( (DWORD)DIFF( pL - strPath.QueryStr() ) );
        }
        if ( FAILED( hr = strPath.Append( pszValue ) ) )
        {
            return hr;
        }
    }
    else
    {
        if ( FAILED( hr = strPath.Copy( L"/" ) ) )
        {
            return hr;
        }
        if ( FAILED( hr = strPath.Append( pszValue ) ) )
        {
            return hr;
        }
    }

    //
    // Convert the URL into MBCS in the server's default codepage
    // for normalization.
    //
    // CODEWORK:  This is a bit extraneous, since the URL begins
    // in the SSI_ELEMENT_ITEM structure as ANSI.  The only reason
    // that it even needs to be handled as UNICODE above is that
    // pstrCurrentUrl comes in as UNICODE...
    //

    hr = straValue.CopyW( strPath.QueryStr() );

    if ( FAILED( hr ) )
    {
        return hr;
    }

    
    if( !_pRequest->GetECB()->ServerSupportFunction(
                                _pRequest->GetECB()->ConnID,
                                HSE_REQ_NORMALIZE_URL,
                                straValue.QueryStr(),
                                NULL,
                                NULL
                                ) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    hr = strPath.CopyA( straValue.QueryStr() );

    if ( FAILED( hr ) )
    {
        return hr;
    }

    //
    //  Map to a physical directory
    //

    if ( FAILED( hr =_pRequest->LookupVirtualRoot( 
                                       strPath.QueryStr(),
                                       pstrPath,
                                       dwPermission ) ) )
    {
        return hr;
    }
    
    if( pstrURL == NULL )
    {
        return NO_ERROR;
    }

    if( FAILED( hr = pstrURL->Copy( strPath ) ) )
    {
        return hr;
    }

    return NO_ERROR;
}

//static
BOOL
SSI_INCLUDE_FILE::FindInternalVariable(
    IN STRA *              pstrVariable,
    OUT PDWORD              pdwID
)
/*++

Routine Description:

    Lookup internal list of SSI variables that aren't supported by ISAPI.
    These include "DOCUMENT_NAME", "DATE_LOCAL", etc.

Arguments:

    pstrVariable - Variable to check
    pdwID - Variable ID (or SSI_VAR_UNKNOWN if not found)

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    DWORD                   dwCounter = 0;

    while ( ( SSIVarMap[ dwCounter ].pszMap != NULL ) &&
            _strnicmp( SSIVarMap[ dwCounter ].pszMap,
                       ( CHAR * )pstrVariable->QueryStr(),
                       SSIVarMap[ dwCounter ].cchMap ) )
    {
        dwCounter++;
    }
    if ( SSIVarMap[ dwCounter ].pszMap != NULL )
    {
        *pdwID = SSIVarMap[ dwCounter ].ssiMap;
        return TRUE;
    }
    else
    {
        *pdwID = SSI_VAR_UNKNOWN;
        return FALSE;
    }
}



HRESULT
SSI_INCLUDE_FILE::DoEchoISAPIVariable(
    IN STRA *            pstrVariable
)
/*++

Routine Description:

    Get ISAPI variable and if successful, send it to HTML stream

Arguments:

    pstrVariable - Variable

Return Value:

    HRESULT

--*/
{
   
    HRESULT             hr = E_FAIL;

    DWORD               dwBufLen = 0;
    PCHAR               pszVectorBufferSpace = NULL;
    BOOL                fRet;
 

    fRet = _pRequest->GetECB()->GetServerVariable( 
                                     _pRequest->GetECB()->ConnID,
                                     pstrVariable->QueryStr(),
                                     NULL,
                                     &dwBufLen );
    if ( !fRet )
    {
        DWORD   dwError = GetLastError();
        if ( dwError == ERROR_INSUFFICIENT_BUFFER )
        {
            if ( FAILED( hr = _pRequest->GetVectorBuffer().AllocateSpace( 
                                                    dwBufLen,
                                                    &pszVectorBufferSpace ) ) )
            {
                goto failed;
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32( dwError );
            goto failed;
        }
        
        fRet = _pRequest->GetECB()->GetServerVariable( 
                                         _pRequest->GetECB()->ConnID,
                                         pstrVariable->QueryStr(),
                                         pszVectorBufferSpace,
                                         &dwBufLen );
        if ( !fRet )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );        
            goto failed;
        }
    }
    //
    // dwBufLen includes terminating 0
    //
    if ( dwBufLen > 1 )
    {
        return _pRequest->GetVectorBuffer().AddToVector( 
                                                    pszVectorBufferSpace,
                                                    dwBufLen - sizeof('\0') );
    }
    else
    {
        //
        // Don't bother sending anything for empty variable
        //
        return S_OK;
    }
    

failed:
    DBG_ASSERT( FAILED( hr ) );      
    return hr;
   
}

HRESULT
SSI_INCLUDE_FILE::DoEchoDateLocal(
    VOID
)
/*++

Routine Description:

    Sends local time (#ECHO VAR="DATE_LOCAL")

    uses _strFileFmt - Format of time (follows strftime() convention)

Arguments:


Return Value:

    HRESULT

--*/
{
    SYSTEMTIME              sysTime;

    ::GetLocalTime( &sysTime );
    return  _pRequest->SendDate( &sysTime,
                                 &_strTimeFmt );
}

HRESULT
SSI_INCLUDE_FILE::DoEchoDateGMT(
    VOID
)
/*++

Routine Description:

    Sends GMT time (#ECHO VAR="DATE_GMT")

Arguments:

    pstrTimefmt - Format of time (follows strftime() convention)

Return Value:

    HRESULT

--*/
{
    SYSTEMTIME              sysTime;
    STACK_STRA(             straGmtTimeFmt, SSI_DEFAULT_TIME_FMT + 1 );
    CHAR *                  pszTimeFmt = _strTimeFmt.QueryStr();
    HRESULT                 hr = E_FAIL;
    CHAR                    szGMT[] = "GMT";


    //
    // for GMT time the time zone as displayes by strftime() will be incorrect
    // lets replace all the occurences with time zone string (%z,%Z, %#z, %#Z)
    // with hardcoded GMT value 
    //

    while ( *pszTimeFmt != '\0' )
    {
        if ( *pszTimeFmt == '%' )
        {
            if ( *( pszTimeFmt + 1 ) == 'z' || *( pszTimeFmt + 1 ) == 'Z' )
            {
                pszTimeFmt += 2;
                //
                // replace %z or %Z with GMT
                //
                if ( FAILED( hr = straGmtTimeFmt.Append( szGMT ) ) )
                {
                    return hr;
                }
                continue;
            }
            else if ( *( pszTimeFmt + 1 ) == '#' )
            {
                if ( *( pszTimeFmt + 2 ) == 'z' || *( pszTimeFmt + 2 ) == 'Z' )
                {
                    pszTimeFmt +=3 ;
                    //
                    // replace %z or %Z with GMT
                    //
                if ( FAILED( hr = straGmtTimeFmt.Append( szGMT ) ) )
                {
                    return hr;
                }
                    continue;
                }
            }
        }
        if ( FAILED( hr = straGmtTimeFmt.Append( pszTimeFmt++, 1 ) ) )
        {
            return hr;
        }
    }
    
        
    ::GetSystemTime( &sysTime );
    return _pRequest->SendDate( &sysTime,
                                &straGmtTimeFmt );
}

HRESULT
SSI_INCLUDE_FILE::DoEchoDocumentName(
    VOID
    )
/*++

Routine Description:

    Sends filename of current SSI document (#ECHO VAR="DOCUMENT_NAME")

Arguments:

    pstrFilename - filename to print

Return Value:

    HRESULT

--*/
{
    return _pRequest->GetVectorBuffer().CopyToVector( _strFilename );

}

HRESULT
SSI_INCLUDE_FILE::DoEchoDocumentURI(
    VOID
)
/*++

Routine Description:

    Sends URL of current SSI document (#ECHO VAR="DOCUMENT_URI")

Arguments:

    pstrURL - URL to print

Return Value:

    HRESULT
--*/
{
    return _pRequest->GetVectorBuffer().CopyToVector( _strURL );
}

HRESULT
SSI_INCLUDE_FILE::DoEchoQueryStringUnescaped(
    VOID
    )
/*++

Routine Description:

    Sends unescaped querystring to HTML stream (#ECHO VAR="QUERY_STRING_UNESCAPED")

Arguments:

    none

Return Value:

    HRESULT

--*/
{
    HRESULT                 hr = E_FAIL;
    STACK_STRA(             straQueryString, SSI_DEFAULT_URL_SIZE + 1 );
    
    if ( FAILED( hr = straQueryString.Copy( _pRequest->GetECB()->lpszQueryString ) ) )
    {
        return hr;
    }

    if ( FAILED( hr = straQueryString.Unescape()) )
    {
        return hr;
    }

    return _pRequest->GetVectorBuffer().CopyToVector( straQueryString );
}

HRESULT
SSI_INCLUDE_FILE::DoEchoLastModified(
    VOID
    )
/*++

Routine Description:

    Sends LastModTime of current document (#ECHO VAR="LAST_MODIFIED")

Arguments:

    pstrFilename - Filename of current SSI document
    pstrTimeFmt - Time format (follows strftime() convention)

Return Value:

    HRESULT

--*/
{
    return DoFLastMod( &_strFilename );
}

HRESULT
SSI_INCLUDE_FILE::DoFSize(
    IN STRU *                pstrFilename
)
/*++

Routine Description:

    Sends file size of file to HTML stream

Arguments:

    pstrfilename - Filename
    bSizeFmtBytes - TRUE if count is in Bytes, FALSE if in KBytes

Return Value:

    HRESULT

--*/
{
    DWORD               cbFileSize;
    CHAR                achInputNumber[ SSI_MAX_NUMBER_STRING + 1 ];
    NUMBERFMTA          nfNumberFormat;
    int                 iOutputSize;
    HRESULT             hr = E_FAIL;
    CHAR *              pszVectorBufferSpace = NULL;

    if ( wcscmp( pstrFilename->QueryStr(), 
                 _strFilename.QueryStr() ) )
    {
        //
        // FSize requested for the file different from this on
        //

        SSI_FILE *pSsiFile = NULL;
        hr = SSI_FILE::GetReferencedInstance( 
                *pstrFilename,
                _pRequest->GetUserToken(),
                &pSsiFile );
        if (FAILED( hr ))
        {
            return hr;
        }


        hr  = pSsiFile->SSIGetFileSize( &cbFileSize );

        pSsiFile->DereferenceSsiFile();

        if (FAILED(hr))
        {
            return hr;
        }
    }
    else
    {
        //
        // FSize requested for the current file
        //
        if ( FAILED( hr = _pSsiFile->SSIGetFileSize( &cbFileSize ) ) )
        {
            return hr;
        }
    }

    if ( !_fSizeFmtBytes )
    {
        //
        // express in terms of KB
        // most applications round up the size in KB (eg. 1B is shown as 1KB)
        // Let's do the same
        //
        cbFileSize = cbFileSize / 1024 + (( cbFileSize % 1024 != 0 )?1:0);
    }

    nfNumberFormat.NumDigits = 0;
    nfNumberFormat.LeadingZero = 0;
    nfNumberFormat.Grouping = 3;
    nfNumberFormat.lpThousandSep = ",";
    nfNumberFormat.lpDecimalSep = ".";
    nfNumberFormat.NegativeOrder = 2;

    _snprintf(  achInputNumber,
                SSI_MAX_NUMBER_STRING,
                "%ld",
                cbFileSize );
    achInputNumber[ SSI_MAX_NUMBER_STRING ] = '\0';

    if ( FAILED( hr = _pRequest->GetVectorBuffer().AllocateSpace( 
                                        SSI_MAX_NUMBER_STRING + 1,
                                        &pszVectorBufferSpace ) ) )
    {
        return hr;
    }
    
    iOutputSize = GetNumberFormatA( LOCALE_SYSTEM_DEFAULT,
                                   0,
                                   achInputNumber,
                                   &nfNumberFormat,
                                   pszVectorBufferSpace,
                                   SSI_MAX_NUMBER_STRING + 1 );
    if ( !iOutputSize )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    //
    // Do not count trailing '\0' 
    //
    
    iOutputSize--;

    return _pRequest->GetVectorBuffer().AddToVector( 
                                            pszVectorBufferSpace,
                                            iOutputSize );
}

HRESULT
SSI_INCLUDE_FILE::DoFLastMod(
    IN STRU *               pstrFilename
)
/*++

Routine Description:

    Send the LastModTime of file to HTML stream

Arguments:

    pstrFilename - Filename
    pstrTimeFmt - Format of time -> follows strftime() convention

Return Value:

    HRESULT

--*/
{
    FILETIME        ftTime;
    FILETIME        ftLocalTime;
    SYSTEMTIME      sysLocal;
    HRESULT         hr = E_FAIL;

    if ( wcscmp( pstrFilename->QueryStr(), 
                  _strFilename.QueryStr() ) )
    {
        //
        // FLastMod requested for file different from the current one
        //
  
        
        SSI_FILE *pSsiFile = NULL;
        hr = SSI_FILE::GetReferencedInstance( 
                *pstrFilename,
                _pRequest->GetUserToken(),
                &pSsiFile );
        if (FAILED( hr ))
        {
            return hr;
        }

        hr  = pSsiFile->SSIGetLastModTime( &ftTime );

        pSsiFile->DereferenceSsiFile();

        if (FAILED(hr))
        {
            return hr;
        }
    }
    else
    {
        //
        // FLastMod requested for the current file
        //
        hr = _pSsiFile->SSIGetLastModTime( &ftTime );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }

    if ( ( !FileTimeToLocalFileTime( &ftTime, &ftLocalTime ) ) ||
        ( !FileTimeToSystemTime( &ftLocalTime, &sysLocal ) ) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    return _pRequest->SendDate( &sysLocal,
                                &_strTimeFmt );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\testdt\makefile.inc ===
$(O)\testdt.res: testdt.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\testdt\apppool.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     AppPool.cxx

   Abstract:
     Defines the functions used to access the data channel.

   Author:

       Murali R. Krishnan    ( MuraliK )     20-Oct-1998
       Lei Jin               ( leijin  )     13-Apr-1999    Porting

   Project:

       IIS Worker Process

--*/

#include "precomp.hxx"
#include "AppPool.hxx"

#include "RwpFunctions.hxx"

UL_APP_POOL::UL_APP_POOL(
    VOID
) : _hAppPool( NULL )
{
}

UL_APP_POOL::~UL_APP_POOL(
    VOID
)
{
    Cleanup();
}

HRESULT
UL_APP_POOL::Initialize(
    LPCWSTR             pwszAppPoolName
)
/*++

Routine Description:

    Initialize UL AppPool

Arguments:

    pwszAppPoolName - AppPool Name

Return Value:

    HRESULT

--*/
{
    //WCHAR       pwszRWPAppPoolName[MAX_PATH];
    ULONG        rc;

    if ( _hAppPool != NULL )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "AppPool already open!\n" ));

        return HRESULT_FROM_WIN32( ERROR_DUP_NAME );
    }

    _Lock.WriteLock();
    if(RWP_AppPoolTest())
    {
        // open app pool with alternate name
        rc = HttpOpenAppPool( &_hAppPool,
                          L"fdwqofjew",                     // just use random bogus name
                          0 );
    }
    else
    {
        rc = HttpOpenAppPool( &_hAppPool,
                              pwszAppPoolName,
                              0 );
    }
    

    _Lock.WriteUnlock();

    if ( rc != NO_ERROR )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to open AppPool '%ws'.  rc = %d\n",
                    pwszAppPoolName,
                    rc ));

        return HRESULT_FROM_WIN32( rc );
    }

    return NO_ERROR;
}

HRESULT
UL_APP_POOL::Cleanup(
    VOID
)
/*++

Routine Description:

    Close data channel

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HRESULT             hr = NO_ERROR;
    HANDLE              hAppPool = NULL;

    if ( _hAppPool != NULL )
    {
        _Lock.WriteLock();

        hAppPool = _hAppPool;
        _hAppPool = NULL;

        _Lock.WriteUnlock();
        
        DBG_ASSERT( hAppPool != NULL );
    
        if ( !CloseHandle( hAppPool ) )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
        }
    }

    return hr;
}

HANDLE
UL_APP_POOL::QueryAndLockHandle(
    VOID
)
/*++

Routine Description:

    Read locks and returns the handle.

Arguments:

    None

Return Value:

    HANDLE

--*/
{
    _Lock.ReadLock();

    return _hAppPool;
}

HRESULT
UL_APP_POOL::UnlockHandle(
    VOID
)
/*++

Routine Description:

    Read unlocks.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    DBG_ASSERT(_Lock.IsReadLocked());

    _Lock.ReadUnlock();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ssinc\ssi_vector_buffer.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    ssi_vector_send.cxx

Abstract:

    wrapper for VectorSend related buffer manipulation
    Segments of final response of stm file processing 
    are buffered in the SSI_VECTOR_BUFFER to optimize the 
    "send response" path


Author:

    Jaroslad               Apr-2001

--*/

#include "precomp.hxx"

    
HRESULT 
SSI_VECTOR_BUFFER::AddVectorHeaders( 
    IN CHAR *   pszHeaders,
    IN BOOL     fIncludesContentLength,
    IN CHAR *   pszStatus
    )
/*++

Routine Description:
    add headers and status line to be sent in response

    Note: caller is responsible to ensure that
    pszHeaders and pszStatus will not be freed 
    If lifetime cannot be guaranteed or use AllocateSpace() to allocate memory
            
Arguments:

    pszHeaders - pointer to headers (including \r\n)
    fIncludesContentLength - flag that headers include "Content-Length" header
    pszStatus - if "" then it will be filled in automatically to "200 OK"

Return Value:
    HRESULT
--*/
{
    //
    // function is expected to be called not more than once per request
    //
    if ( !_fHeadersSent )
    {
        _RespVector.dwFlags    |= HSE_IO_SEND_HEADERS;

        DBG_ASSERT( _RespVector.pszHeaders == NULL );  

        _RespVector.pszHeaders  = pszHeaders; 
        _fVectorHeadersIncludeContentLength = fIncludesContentLength;

        //
        // pszStatus is required not to be NULL with HSE_IO_SEND_HEADERS
        // so set it to empty string
        //

        _RespVector.pszStatus   = pszStatus;  
    }
    else
    {
        DBG_ASSERT( FALSE );
        return( E_FAIL );
    }
    return S_OK;
}

HRESULT
SSI_VECTOR_BUFFER::AddToVector(
    IN PCHAR    pbData,
    IN DWORD    cbData
    )
/*++

Routine Description:
    add another chunk to response Vector

    Note: caller is responsible to ensure that
    buffer will not be freed until VectorSend completed
    If lifetime cannot be guaranteed use CopyToVector()
    instead (or use AllocateSpace() to allocate memory
    for pbData )
    
    
Arguments:

    pbData  - pointer to chunk
    cbData - size of chunk

Return Value:

    HRESULT

--*/
{
    
    DWORD nElementCount = _RespVector.nElementCount;
    if( cbData != 0 )
    {
        if (!_buffVectorElementArray.Resize( (nElementCount + 1)*sizeof(HSE_VECTOR_ELEMENT) , 256 ))
        {
            return HRESULT_FROM_WIN32(GetLastError());
        }
        _RespVector.lpElementArray = (HSE_VECTOR_ELEMENT *)_buffVectorElementArray.QueryPtr();
        _RespVector.lpElementArray[ nElementCount ].ElementType = HSE_VECTOR_ELEMENT_TYPE_MEMORY_BUFFER;
        _RespVector.lpElementArray[ nElementCount ].pvContext = pbData;
        _RespVector.lpElementArray[ nElementCount ].cbSize = cbData;
        _cbTotalBytesInVector += cbData;
        _RespVector.nElementCount++;
    }
    return S_OK;
}    

HRESULT
SSI_VECTOR_BUFFER::AddFileChunkToVector(
    IN DWORD    cbOffset,
    IN DWORD    cbData,
    IN HANDLE   hFile
    )
/*++

Routine Description:
    add another chunk to response Vector

    Note: caller is responsible to ensure that
    buffer will nt be freed until VectorSend completed
    If lifetime cannot be guaranteed use CopyToVector()
    instead (or use AllocateSpace() to allocate memory
    for pbData )
    
    
Arguments:

    pbOffset - offset within the file
    cbData - size of chunk
    hFile - file where file chunk is located

Return Value:

    HRESULT

--*/
{
    
    DWORD nElementCount = _RespVector.nElementCount;
    if( cbData != 0 )
    {
        if (!_buffVectorElementArray.Resize( (nElementCount + 1)*sizeof(HSE_VECTOR_ELEMENT) , 256 ))
        {
            return HRESULT_FROM_WIN32(GetLastError());
        }
        _RespVector.lpElementArray = (HSE_VECTOR_ELEMENT *)_buffVectorElementArray.QueryPtr();
        _RespVector.lpElementArray[ nElementCount ].ElementType = HSE_VECTOR_ELEMENT_TYPE_FILE_HANDLE;
        _RespVector.lpElementArray[ nElementCount ].pvContext = hFile;
        _RespVector.lpElementArray[ nElementCount ].cbOffset = cbOffset;
        _RespVector.lpElementArray[ nElementCount ].cbSize = cbData;
        _cbTotalBytesInVector += cbData;
        _RespVector.nElementCount++;
    }
    return S_OK;
}    


HRESULT 
SSI_VECTOR_BUFFER::CopyToVector( 
    IN PCHAR    pszData,
    IN DWORD    cchData
    
    )
/*++

Routine Description:
    Copy data to private buffer and then add it
    to response Vector

Arguments:

    pbData  - pointer to chunk
    cbData - size of chunk

Return Value:

    HRESULT

--*/        
{
    PCHAR pszVectorBufferSpace = NULL;
    HRESULT hr = E_FAIL;
    //
    // Allocate space in private buffer
    //
    if ( FAILED( hr = AllocateSpace( 
                              cchData,
                              &pszVectorBufferSpace
                              ) ) )
    {
        return hr;
    }    
    else
    {
        memcpy( pszVectorBufferSpace, 
                pszData, 
                cchData );
        
        hr = AddToVector( pszVectorBufferSpace, 
                          cchData );
    }    
    return hr;
}


HRESULT 
SSI_VECTOR_BUFFER::CopyToVector( 
    IN STRA& straSource
    )
/*++

Routine Description:
    Copy data to private buffer and then add it
    to response Vector

Arguments:

    straSource -string to be copied

Return Value:

    HRESULT

--*/        
    
{
    return CopyToVector( straSource.QueryStr(),
                         straSource.QueryCB() );
}

HRESULT 
SSI_VECTOR_BUFFER::CopyToVector( 
    IN STRU& struSource
    )
/*++

Routine Description:
    Copy data to private buffer and then add it
    to response Vector

Arguments:

    struSource - string to be copied

Return Value:

    HRESULT

--*/        
{
    HRESULT hr = E_FAIL;
    STRA    straSource;
    
    if ( FAILED( hr = straSource.CopyW( struSource.QueryStr() ) ) )
    {
        return hr;
    }
    else
    {
        return CopyToVector( straSource );
    }
}

HRESULT
SSI_VECTOR_BUFFER::VectorSend(
    OUT BOOL *      pfAsyncPending,
    IN  BOOL        fFinalSend
    )
/*++

Routine Description:
    HSE_REQ_VECTOR_SEND wrapper.
    
Arguments:

    pfAsyncPending - Set to TRUE if async is pending
    fFinalSend     - TRUE if this is the last send for the response
                     it can help to determine if Keep-alive can be used 

Return Value:

    HRESULT

--*/
{
    
    HRESULT             hr              = E_FAIL;

    DBG_ASSERT( pfAsyncPending != NULL );
    *pfAsyncPending = FALSE;


    //
    // check if there is any data to be sent
    //

    if (  ( _RespVector.pszHeaders == NULL &&
            _RespVector.nElementCount == 0 ) ||
          ( _fHeadersSent && 
            _fHeadRequest )  )
    {
        //
        // there is nothing to be sent 
        // Also handle HEAD requests. Never send body with them
        // handling HEAD request by processing whole SSI and only not 
        // sending data is not ideal, but this way it is guaranteed
        // that HEAD and GET will get same headers
        //
        *pfAsyncPending = FALSE;
        return S_OK;
    }


    if ( _fVectorHeadersIncludeContentLength )
    {
        //
        // remove the disconnect flag since we have content length
        //
        _RespVector.dwFlags   &= ( ~HSE_IO_DISCONNECT_AFTER_SEND );
    }
    else if ( !_fHeadersSent 
              && fFinalSend ) 
    {
        //
        // Optimization:
        // This is final send and headers were not yet sent
        // That means we can do keep-alive and specify Content-length
        //
        
        STACK_STRA(     straFinalHeaders, SSI_DEFAULT_RESPONSE_HEADERS_SIZE + 1 );
        CHAR            achNum[ SSI_MAX_NUMBER_STRING + 1 ];

    
        _ultoa( _cbTotalBytesInVector,
                achNum,
                10 );

        if ( FAILED( hr = _straFinalHeaders.Copy( "Content-Length: " ) ) )
        {
            return hr;
        }
        if ( FAILED( hr = _straFinalHeaders.Append( achNum ) ) )
        {
            return hr;
        }
        if ( FAILED( hr = _straFinalHeaders.Append( "\r\n" ) ) )
        {
            return hr;
        }
        if ( FAILED( hr = _straFinalHeaders.Append( _RespVector.pszHeaders ) ) )
        {
            return hr;
        }
                        
        _RespVector.pszHeaders = _straFinalHeaders.QueryStr();
        // remove the disconnect flag
        _RespVector.dwFlags   &= ( ~HSE_IO_DISCONNECT_AFTER_SEND );

    }

    //
    // Send Response Vector
    //

    if( _RespVector.dwFlags & HSE_IO_SEND_HEADERS )
    {
        _fHeadersSent = TRUE;
    }

    if ( _fHeadRequest )
    {
        // Handle HEAD requests. Never send body with them
        // Handling HEAD request by processing the whole SSI and only not 
        // sending data is not ideal, but this way it is guaranteed
        // that HEAD and GET will get the same headers
        //
        _RespVector.nElementCount  = 0;
    }
    if (! _pECB->ServerSupportFunction( 
                               _pECB->ConnID,
                               HSE_REQ_VECTOR_SEND,
                               &_RespVector,
                               NULL,
                               NULL) ) 
    {
        //
        // No use in trying to reset _fHeadersSent in case of failure
        //
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    *pfAsyncPending = TRUE;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\testdt\controlchannel.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     ControlChannel.cxx

   Abstract:
     Defines the functions used to access the control channel.

   Author:

       Murali R. Krishnan    ( MuraliK )     15-Oct-1998
       Lei Jin               ( leijin  )     13-Apr-1999    Porting

   Project:

       IIS Worker Process

--*/


# include "precomp.hxx"
# include "ControlChannel.hxx"

/********************************************************************++

  UL_CONTROL_CHANNEL::Initialize()

  Description:
     This function initializes the control channel for given address, NSGO, 
     and host name. It opens the control channel, registers a virtual host,
     and NSGO. After that it registers the URL for which notifications are 
     to be handled within the NSGO.

  Arguments:


  Returns:

++********************************************************************/

ULONG 
UL_CONTROL_CHANNEL::Initialize( 
    IN MULTISZ& mszURLList,
    IN LPCWSTR  pwszAppPoolName,
    IN DWORD    dwSiteId
    )
{
    ULONG   rc;
    LPCWSTR pwszURL;

    if ( m_hControlChannel != NULL) 
    {
        //
        // There is already a control channel
        //
        
        DBGPRINTF(( DBG_CONTEXT, "Duplicate open of control channel\n"));
        return ERROR_DUP_NAME;
    }
    
    //
    // 1. Open a control channel object from the UL driver
    //
    
    rc = HttpOpenControlChannel( &m_hControlChannel, 0);

    if ( NO_ERROR != rc) 
    {
        IF_DEBUG( ERROR)
        {
            DBGPRINTF(( DBG_CONTEXT, 
                        "UlOpenControlChannel() failed. Error = %08x. Returning\n", 
                        rc
                        ));
        }

        return (rc);
    }

    //
    // 2. Create a Config Group on this control channel
    //
    
    rc = HttpCreateConfigGroup( m_hControlChannel, &m_ConfigGroupId );

    if ( NO_ERROR != rc) 
    {
        IF_DEBUG(ERROR) 
        {
            DBGPRINTF(( DBG_CONTEXT, 
                       "UlCreateConfigGroup failed. Error=%08x. Returning\n",
                       rc
                       ));
        }

        return rc;
    }

    //
    // 3. Insert all specified URLs into the config group
    //

    pwszURL = mszURLList.First();

    while (NULL != pwszURL)
    {
        rc = AddURLToConfigGroup(pwszURL, dwSiteId);

        if (NO_ERROR != rc)
        {
            return rc;
        }

        pwszURL = mszURLList.Next(pwszURL);
    }

    //
    // 4. Activate the Control Channel and the Config Group
    //

    HTTP_ENABLED_STATE    ccState = HttpEnabledStateActive;

    rc = HttpSetControlChannelInformation( m_hControlChannel,
                                           HttpControlChannelStateInformation,
                                           &ccState,
                                           sizeof(ccState));

    if ( NO_ERROR != rc) 
    {
        IF_DEBUG(ERROR) 
        {
            DBGPRINTF(( DBG_CONTEXT, 
                       "Unable to activate ControlChannel. Error=%08x. Returning\n", rc
                        ));
        }

        return rc;
    }

    HTTP_CONFIG_GROUP_STATE   cgState;

    cgState.Flags.Present = 1;
    cgState.State         = HttpEnabledStateActive;  
                                         
    rc = HttpSetConfigGroupInformation( m_hControlChannel,
                                        m_ConfigGroupId,
                                        HttpConfigGroupStateInformation,
                                        &cgState,
                                        sizeof(cgState));

    if ( NO_ERROR != rc) 
    {
        IF_DEBUG(ERROR) 
        {
            DBGPRINTF(( DBG_CONTEXT, 
                       "Unable to activate Config Group. Error=%08x. Returning\n", rc
                        ));
        }

        return rc;
    }

    //
    // 5. Create an AppPool 
    //

    rc = HttpCreateAppPool( &m_hAppPool,
                            pwszAppPoolName,
                            0,
                            0
                          );

    if ( NO_ERROR != rc) 
    {
        IF_DEBUG(ERROR) 
        {
            DBGPRINTF(( DBG_CONTEXT, 
                       "UlCreateAppPool failed for AppPool '%ws'. Error=%08x. Returning\n",
                       pwszAppPoolName, rc
                        ));
        }

        return rc;
    }
    
    //
    // 6. Associate AppPool with the config group
    //

    HTTP_CONFIG_GROUP_APP_POOL    AppPoolConfig;

    AppPoolConfig.Flags.Present = 1;
    AppPoolConfig.AppPoolHandle = m_hAppPool;
    
    rc = HttpSetConfigGroupInformation( m_hControlChannel,
                                        m_ConfigGroupId,
                                        HttpConfigGroupAppPoolInformation,
                                        &AppPoolConfig,
                                        sizeof(AppPoolConfig)
                                      );
    if ( NO_ERROR != rc) 
    {
        IF_DEBUG(ERROR) 
        {
            DBGPRINTF(( DBG_CONTEXT, 
                       "UlSetConfigGroupInformation failed for AppPool '%ws'. Error=%08x. Returning\n",
                       pwszAppPoolName, rc
                        ));
        }

        return rc;
    }

    //
    //  7.  Enable the app pool
    //

    HTTP_APP_POOL_ENABLED_STATE NewHttpAppPoolState = HttpAppPoolEnabled;

    rc = HttpSetAppPoolInformation(
                        m_hAppPool,                // app pool handle
                        HttpAppPoolStateInformation,    // information class
                        reinterpret_cast <VOID *> ( &NewHttpAppPoolState ),  // data
                        sizeof( HTTP_APP_POOL_ENABLED_STATE )    // data length
                        );

    if ( rc != NO_ERROR )
    {
        IF_DEBUG(ERROR) 
        {
            DBGPRINTF(( DBG_CONTEXT, 
                       "HttpSetAppPoolInformation failed for AppPool '%ws'. Error=%08x. Returning\n",
                       pwszAppPoolName, rc
                        ));
        }

        return rc;

    }

    
    return (rc);
    
} // UL_CONTROL_CHANNEL::Initialize()

/********************************************************************++
++********************************************************************/


ULONG 
UL_CONTROL_CHANNEL::Cleanup(void)
{ 
    ULONG rc = NO_ERROR;

    if ( m_hControlChannel != NULL) 
    {
        if ( ! HTTP_IS_NULL_ID(&m_ConfigGroupId) )
        {
            rc = HttpDeleteConfigGroup( m_hControlChannel, m_ConfigGroupId);
            HTTP_SET_NULL_ID(&m_ConfigGroupId);
        }

        if ( NULL != m_hAppPool )
        {
            if ( !::CloseHandle( m_hAppPool))
            {
                rc = GetLastError();
            }
        }

        m_hAppPool = NULL;
        
        if (!::CloseHandle( m_hControlChannel)) 
        {
            rc = GetLastError();
        }
        
        m_hControlChannel = NULL;
    }
    
    return (rc);
    
} // UL_CONTROL_CHANNEL::Cleanup()

/********************************************************************++
++********************************************************************/

ULONG
UL_CONTROL_CHANNEL::AddURLToConfigGroup( IN LPCWSTR  pwszURL,
                                         IN DWORD    dwSiteId )
{
    //
    //  Add the URL to the Config Group
    //

    ULONG rc;

    HTTP_URL_CONTEXT UrlContext = dwSiteId;
    UrlContext = UrlContext << 32;

    rc = HttpAddUrlToConfigGroup( m_hControlChannel,
                                  m_ConfigGroupId,
                                  pwszURL,
                                  UrlContext
                                );
    
    if ( NO_ERROR != rc) 
    {
        IF_DEBUG (ERROR)
        {
            DBGPRINTF((DBG_CONTEXT, 
                       "UlAddUrlToConfigGroup() failed. Error=%08x\n",
                       rc));
        }
    }

    return (rc);
}

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\testdt\rwpfunctions.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     RwpFunctions.cxx

   Abstract:
     Implements the behaviors of the "Rogue Worker Process" -- 
     to test Application Manager

   Author:

       David Wang            ( t-dwang )     14-Jun-1999  Initial

   Project:

       Duct-Tape

--*/

/*********************************************************
* Include Headers
*********************************************************/
#include "precomp.hxx"
#include "RwpFunctions.hxx"

/*********************************************************
* local functions
*********************************************************/
BOOL DoGetPidTest(HRESULT* phr, IPM_MESSAGE_PIPE* pPipe);
BOOL DoPingReplyTest(HRESULT* phr, IPM_MESSAGE_PIPE* pPipe);
BOOL DoSendCountersTest(HRESULT* phr, IPM_MESSAGE_PIPE* pPipe);
BOOL DoHResultTest(HRESULT* phr, IPM_MESSAGE_PIPE* pPipe);
BOOL DoWorkerRequestShutdownTest(HRESULT* phr, IPM_MESSAGE_PIPE* pPipe);
BOOL DoInvalidOpcodeTest(HRESULT* phr, IPM_MESSAGE_PIPE* pPipe);
void RWP_Write_LONG_to_Registry(const WCHAR* szSubKey, LONG lValue);


// These are for the new RWP tests
LONG OpCodeToTest;
LONG DataLength;
LONG UseDataLength;
LONG DataPointerType;
LONG NumberOfCalls;
LONG AttackDuration;

LONG TestStarted;
LONG TestCompleted;

// These are for old RWP tests
LONG RwpBehaviorExhibited;

LONG PingBehavior, PingCount;
LONG ShutdownBehavior, ShutdownCount;
LONG RotationBehavior, RotationCount;
LONG StartupBehavior, StartupCount;
LONG HealthBehavior, HealthCount;
LONG RecycleBehavior, RecycleCount;
LONG AppPoolBehavior;

LONG RWP_EXTRA_DEBUG;

LONG RWP_AppPoolTest(void)
{
    return AppPoolBehavior == RWP_APPPOOL_BOGUS ? TRUE : FALSE;
}

LONG RWP_IPM_BadParamTest(LONG OpCode, HRESULT* phr, IPM_MESSAGE_PIPE* pPipe) 
{
    BOOL bRet = FALSE;
    
    DBGPRINTF((DBG_CONTEXT, "In RWP_IPM_BadParamTest()\n"));

    if(OpCode != OpCodeToTest)
        return FALSE;


    bRet = TRUE;

    // we need to indicate we have actually gotten to the
    // code in w3wp that calls our test
    if(OpCodeToTest != RWP_IPM_OP_NONE)
        RWP_Write_LONG_to_Registry(RWP_CONFIG_TEST_STARTED, 1);
        
    switch(OpCodeToTest)
    {
        case RWP_IPM_OP_NONE:
            bRet = FALSE;
            break;
        case RWP_IPM_OP_GETPID:
            bRet = DoGetPidTest(phr, pPipe);
            break;
        case RWP_IPM_OP_PING_REPLY:
            bRet = DoPingReplyTest(phr, pPipe);
            break;
        case RWP_IPM_OP_SEND_COUNTERS:
            bRet = DoSendCountersTest(phr, pPipe);
            break;
        case RWP_IPM_OP_HRESULT:
            bRet = DoHResultTest(phr, pPipe);
            break;
        case RWP_IPM_OP_WORKER_REQUESTS_SHUTDOWN:
            bRet = DoWorkerRequestShutdownTest(phr, pPipe);
            break;
        case RWP_IPM_OP_INVALID:
            bRet = DoInvalidOpcodeTest(phr, pPipe);
            break;
        default:
            bRet = FALSE;
            break;
    }

    if(bRet)
        RWP_Write_LONG_to_Registry(RWP_CONFIG_TEST_COMPLETION_STATUS,  RWP_TEST_STATUS_COMPLETE);
    else
        RWP_Write_LONG_to_Registry(RWP_CONFIG_TEST_COMPLETION_STATUS,  RWP_TEST_STATUS_ERROR);
    
    return bRet;
}

BOOL DoGetPidTest(HRESULT* phr, IPM_MESSAGE_PIPE* pPipe)
{
    DWORD dwDataLength;
    DWORD * pData = NULL;

    DBGPRINTF((DBG_CONTEXT, "In DoGetPidTest()\n"));

    DWORD dwId = GetCurrentProcessId();

    dwDataLength = UseDataLength ? DataLength : sizeof(dwId);

    switch(DataPointerType)
    {
        default:
        case RWP_DATA_POINTER_TYPE_VALID:
            pData = &dwId;
            break;
        case RWP_DATA_POINTER_TYPE_NULL:
            pData = NULL;
            break;
        case RWP_DATA_POINTER_TYPE_INVALID:
            pData = (DWORD*) 1;
            break;
    }
    
    *phr = pPipe->WriteMessage(IPM_OP_GETPID,
                    dwDataLength,
                    pData);

    return TRUE;
}

BOOL DoPingReplyTest(HRESULT* phr, IPM_MESSAGE_PIPE* pPipe)
{
    DWORD dwDataLength;
    DWORD * pData = NULL;

    DWORD dwData = 42; // just some random data

    DBGPRINTF((DBG_CONTEXT, "In DoPingReplyTest()\n"));

    dwDataLength = UseDataLength ? DataLength : 0;

    switch(DataPointerType)
    {
        default:
        case RWP_DATA_POINTER_TYPE_VALID:
            pData = &dwData;
            break;
        case RWP_DATA_POINTER_TYPE_NULL:
            pData = NULL;
            break;
        case RWP_DATA_POINTER_TYPE_INVALID:
            pData = (DWORD*) 1;
            break;
    }
    
    *phr = pPipe->WriteMessage(
                                IPM_OP_PING_REPLY,  // ping reply opcode
                                dwDataLength,
                                pData
                                );

    return TRUE;
}

BOOL DoSendCountersTest(HRESULT* phr, IPM_MESSAGE_PIPE* pPipe)
{
    DWORD dwDataLength;
    DWORD * pData = NULL;

    DWORD dwData = 42; // just some random data

    DBGPRINTF((DBG_CONTEXT, "In DoSendCountersTest()\n"));

    dwDataLength = UseDataLength ? DataLength : sizeof(dwData);

    BYTE* pBuffer = NULL;

    switch(DataPointerType)
    {
        default:
        case RWP_DATA_POINTER_TYPE_VALID:
            if((UseDataLength) && (DataLength > 0))
            {
                pBuffer = new BYTE[DataLength];
                pData = (DWORD*) pBuffer;
            }
            else
            {
                pData = &dwData;
            }
            break;
        case RWP_DATA_POINTER_TYPE_NULL:
            pData = NULL;
            break;
        case RWP_DATA_POINTER_TYPE_INVALID:
            pData = (DWORD*) 1;
            break;
    }

    for(int i = 0; i < NumberOfCalls; i++)
    {
    
        *phr = pPipe->WriteMessage(
                                    IPM_OP_SEND_COUNTERS,  // ping reply opcode
                                    dwDataLength,
                                    pData
                                    );
    }

    if(pBuffer)
        delete [] pBuffer;

    return TRUE;
}

BOOL DoHResultTest(HRESULT* phr, IPM_MESSAGE_PIPE* pPipe)
{
    // Test 67034 needs special processing
    DWORD dwDataLength;
    HRESULT * pData = NULL;
    DWORD dwTickCount;
    DWORD dwStopTickCount;
    DWORD dwAttackDurationMsec;

   HRESULT hrToSend = S_OK;

    DBGPRINTF((DBG_CONTEXT, "In DoHResultTest()\n"));

    dwDataLength = UseDataLength ? DataLength : sizeof(hrToSend);

    switch(DataPointerType)
    {
        default:
        case RWP_DATA_POINTER_TYPE_VALID:
            pData = &hrToSend;
            break;
        case RWP_DATA_POINTER_TYPE_NULL:
            pData = NULL;
            break;
        case RWP_DATA_POINTER_TYPE_INVALID:
            pData = (HRESULT*) 1;
            break;
    }

    if(AttackDuration == 0)
    {
        *phr = pPipe->WriteMessage(
                                IPM_OP_HRESULT,  // ping reply opcode
                                dwDataLength,
                                pData
                                );
    }
    else
    {
        // we're doing a DoS attack for some amount of time
        dwTickCount = GetTickCount();
        // convert duration to msec
        dwAttackDurationMsec = AttackDuration * 60 * 1000;
        dwStopTickCount = dwTickCount + dwAttackDurationMsec;
        while(dwTickCount < dwStopTickCount)
        {
            *phr = pPipe->WriteMessage(
                                    IPM_OP_HRESULT,  // ping reply opcode
                                    dwDataLength,
                                    pData
                                    );
                                    
            dwTickCount = GetTickCount();
        }
    }

    return TRUE;
}

BOOL DoWorkerRequestShutdownTest(HRESULT* phr, IPM_MESSAGE_PIPE* pPipe)
{
    DWORD dwDataLength;
    IPM_WP_SHUTDOWN_MSG * pData = NULL;

    IPM_WP_SHUTDOWN_MSG reason = IPM_WP_RESTART_COUNT_REACHED;

    DBGPRINTF((DBG_CONTEXT, "In DoWorkerRequestShutdownTest()\n"));

    dwDataLength = UseDataLength ? DataLength : sizeof(reason);

    switch(DataPointerType)
    {
        default:
        case RWP_DATA_POINTER_TYPE_VALID:
            pData = &reason;
            break;
        case RWP_DATA_POINTER_TYPE_NULL:
            pData = NULL;
            break;
        case RWP_DATA_POINTER_TYPE_INVALID:
            pData = (IPM_WP_SHUTDOWN_MSG *) 1;
            break;
        case RWP_DATA_POINTER_TYPE_INVALID_REASON:
            reason = (IPM_WP_SHUTDOWN_MSG) ((IPM_WP_SHUTDOWN_MSG)2*IPM_WP_MAXIMUM);
            pData = &reason;
            break;
    }
    
    *phr = pPipe->WriteMessage(
                                IPM_OP_WORKER_REQUESTS_SHUTDOWN,  // ping reply opcode
                                dwDataLength,
                                pData
                                );

    return TRUE;
}


BOOL DoInvalidOpcodeTest(HRESULT* phr, IPM_MESSAGE_PIPE* pPipe)
{
    // Just use params for a shutdown reply
    DWORD dwDataLength;
    IPM_WP_SHUTDOWN_MSG * pData = NULL;

    DBGPRINTF((DBG_CONTEXT, "In DoInvalidOpcodeTest()\n"));
    IPM_WP_SHUTDOWN_MSG reason = IPM_WP_RESTART_COUNT_REACHED;
    pData = &reason;
    dwDataLength = sizeof(reason);

    *phr = pPipe->WriteMessage(
                                (IPM_OPCODE) 50,
                                dwDataLength,
                                pData
                                );

    return TRUE;
}

    
LONG RWP_Ping_Behavior(HRESULT* hr, IPM_MESSAGE_PIPE* pPipe) 
{
    *hr = S_OK;
    int i = 0;
    
    switch (PingBehavior)
    {
        
    //
    //Don't respond to pings
    //
        
    case RWP_PING_NO_ANSWER:
        DBGPRINTF((DBG_CONTEXT, "Rogue: Not responding to Ping\n"));
        break;
        
    //
    //Responding with n pings
    //
        
    case RWP_PING_MULTI_ANSWER:
        DBGPRINTF((DBG_CONTEXT, "Rogue: Responding to Ping %d times", PingCount));
        
        for (i = 0; i < PingCount; i++) 
        {
            *hr = pPipe->WriteMessage(
                IPM_OP_PING_REPLY,  // ping reply opcode
                0,                  // no data to send
                NULL                // pointer to no data
                );
        }
        
        break;
        
    //
    //Respond after n seconds
    //
        
    case RWP_PING_DELAY_ANSWER:
        DBGPRINTF((DBG_CONTEXT, "Rogue: Delay responding to Ping for %d seconds", PingCount));
        
        RWP_Sleep_For(PingCount);
        
        //return 0 so that we'll keep going (this is a delay, not fail)
        return (RWP_NO_MISBEHAVE);
        break;
        
    default:
        DBGPRINTF((DBG_CONTEXT, "Rogue: Unknown Ping Behavior = %d\n", PingBehavior));
        break;
        
    }
    
    return (PingBehavior);
    
} // RWP_Ping_Behavior

LONG RWP_Shutdown_Behavior(HRESULT* hr) 
{
    *hr = S_OK;
    
    switch (ShutdownBehavior)
    {
        
    case RWP_SHUTDOWN_NOT_OBEY:
        
        //
        //Not shutting down, period
        //
        DBGPRINTF((DBG_CONTEXT, "Rogue: Not shutting down\n"));
        break;
        
    case RWP_SHUTDOWN_DELAY:
        
        //
        //Sleeping for n seconds before continuing on
        //
        DBGPRINTF((DBG_CONTEXT, "Rogue: Sleeping for %d seconds before shutdown\n", ShutdownCount));
        
        RWP_Sleep_For(ShutdownCount);
        
        //return 0 so that we'll keep going (this is a delay, not fail)
        return (RWP_NO_MISBEHAVE);
        break;
        
    default:
        DBGPRINTF((DBG_CONTEXT, "Rogue: Unknown Shutdown Behavior\n"));
        break;
    }
    
    return (ShutdownBehavior);
} // RWP_Shutdown_Behavior

LONG RWP_Rotation_Behavior(HRESULT* pHr, IPM_MESSAGE_PIPE* pPipe) 
{
    *pHr = S_OK;
    IPM_WP_SHUTDOWN_MSG reason;
    
    switch (RotationBehavior)
    {
    case RWP_ROTATION_INVALID_REASON:
        DBGPRINTF((DBG_CONTEXT, "Rogue: Sending Invalid shut-down reason\n"));
        reason = IPM_WP_MINIMUM;
        
        *pHr = pPipe->WriteMessage(
            IPM_OP_WORKER_REQUESTS_SHUTDOWN,  // sends shut-down message 
            sizeof(reason),                   // data to send
            (BYTE *)&reason                   // pointer to data
            );
        break;
    default:
        DBGPRINTF((DBG_CONTEXT, "Rogue: Unknown Rotation Behavior\n"));
        break;
    }
    
    return (RotationBehavior);
}

LONG RWP_Startup_Behavior(HRESULT* rc) 
{
    //
    //modify rc accordingly
    //
    
    *rc = NO_ERROR;
    
    switch (StartupBehavior)
    {
        
    case RWP_STARTUP_NOT_OBEY:
        //
        //Don't register with WAS
        //
        DBGPRINTF((DBG_CONTEXT, "Rogue: Not registering with WAS\n"));
        break;
        
    case RWP_STARTUP_DELAY:
        //
        //Delay starting up the thread message loop
        //
        DBGPRINTF((DBG_CONTEXT, "Rogue: Delay starting up for %d\n", StartupCount));
        
        RWP_Sleep_For(StartupCount);
        
        //return 0 so that we'll keep going (this is a delay, not fail)
        return (RWP_NO_MISBEHAVE);
        
    case RWP_STARTUP_NOT_REGISTER_FAIL:
        
        //
        //Quit before registering with UL
        //
        DBGPRINTF((DBG_CONTEXT, "Rogue: Not starting up (unregistered)... shutting down\n"));
        
        // BUGBUG - what is this?
        //wpContext->IndicateShutdown(SHUTDOWN_REASON_ADMIN);
        
        //return 0 so that it enters (and subsequently exits) the thread loop
        return (RWP_NO_MISBEHAVE);
        
        //
        //It looks like the place to modify is in wpcontext.cxx, 
        //when it tries to initialize IPM if requested
        //
        
    default:
        break;
    }
    
    return (StartupBehavior);
}

LONG RWP_Health_Behavior() 
{
    return 0;
}

/*

  LONG RWP_Recycle_Behavior() {
  }
  
*/

void RWP_Sleep_For(LONG lTime) {
    
    SleepEx(
        (DWORD)lTime * 1000,     //sleep for lTimeToSleep * 1000 milliseconds (4 second increments)
        FALSE);                             // not alertable
    
    DBGPRINTF((DBG_CONTEXT, "Done sleeping \n"));
}

void RWP_Display_Behavior() 
{
    
    DBGPRINTF((DBG_CONTEXT, "Rogue Behavior Status\n"));

    switch(PingBehavior)
        {
        case RWP_NO_MISBEHAVE:
            DBGPRINTF((DBG_CONTEXT, RWP_NO_PING_MISBEHAVE_MSG));
            break;
        case RWP_PING_NO_ANSWER:
            DBGPRINTF((DBG_CONTEXT, RWP_PING_NO_ANSWER_MSG));
            break;
        case RWP_PING_MULTI_ANSWER:
            DBGPRINTF((DBG_CONTEXT, "%s %d\n", RWP_PING_MULTI_ANSWER_MSG, PingCount));
            break;
        case RWP_PING_DELAY_ANSWER:
            DBGPRINTF((DBG_CONTEXT, "%s %d\n", RWP_PING_DELAY_ANSWER_MSG, PingCount));
            break;
        default:
            DBGPRINTF((DBG_CONTEXT, "Ping behavior set to unknown value"));
            break;
        }

    switch(StartupBehavior)
        {
        case RWP_NO_MISBEHAVE:
            DBGPRINTF((DBG_CONTEXT, RWP_NO_STARTUP_MISBEHAVE_MSG));
           break;
        case RWP_STARTUP_NOT_OBEY:
            DBGPRINTF((DBG_CONTEXT, RWP_STARTUP_NOT_OBEY_MSG));
            break;
        case RWP_STARTUP_DELAY:
            DBGPRINTF((DBG_CONTEXT, "%s %d\n", RWP_STARTUP_DELAY_MSG, StartupCount));
            break;
        case RWP_STARTUP_NOT_REGISTER_FAIL:
            DBGPRINTF((DBG_CONTEXT, RWP_STARTUP_NOT_REGISTER_FAIL_MSG));
            break;
        default:
            DBGPRINTF((DBG_CONTEXT, "Startup behavior set to unknown value"));
            break;
        }
    
    switch(ShutdownBehavior)
        {
        case RWP_NO_MISBEHAVE:
            DBGPRINTF((DBG_CONTEXT, RWP_NO_SHUTDOWN_MISBEHAVE_MSG));
            break;
        case RWP_SHUTDOWN_NOT_OBEY:
            DBGPRINTF((DBG_CONTEXT, RWP_SHUTDOWN_NOT_OBEY_MSG));
            break;
        case RWP_SHUTDOWN_DELAY:
            DBGPRINTF((DBG_CONTEXT, RWP_SHUTDOWN_DELAY_MSG, ShutdownCount));
            break;
        default:
            DBGPRINTF((DBG_CONTEXT, "Shutdown behavior set to unknown value"));
            break;
        }
            
    switch(RotationBehavior)
        {
        case RWP_NO_MISBEHAVE:
            DBGPRINTF((DBG_CONTEXT, RWP_NO_ROTATION_MISBEHAVE_MSG));
            break;
        case RWP_ROTATION_INVALID_REASON:
            DBGPRINTF((DBG_CONTEXT, RWP_ROTATION_INVALID_REASON_MSG));
           break;
        default:
            DBGPRINTF((DBG_CONTEXT, "Rotation behavior set to unknown value"));
            break;
        }
            
     switch(RecycleBehavior)
        {
        case RWP_NO_MISBEHAVE:
            DBGPRINTF((DBG_CONTEXT, RWP_NO_RECYCLE_MISBEHAVE_MSG));
            break;
        case RWP_RECYCLE_NOT_OBEY:
            DBGPRINTF((DBG_CONTEXT, RWP_RECYCLE_NOT_OBEY_MSG));
            break;
        case RWP_RECYCLE_DELAY:
            DBGPRINTF((DBG_CONTEXT, "%s %d\n", RWP_RECYCLE_DELAY_MSG, RecycleCount));
            break;
        default:
            DBGPRINTF((DBG_CONTEXT, "Shutdown behavior set to unknown value"));
            break;
        }

     switch(HealthBehavior)
        {
        case RWP_NO_MISBEHAVE:
            DBGPRINTF((DBG_CONTEXT, RWP_NO_HEALTH_MISBEHAVE_MSG));
            break;
        case RWP_HEALTH_OK:
            DBGPRINTF((DBG_CONTEXT, RWP_HEALTH_OK_MSG));
            break;
        case RWP_HEALTH_NOT_OK:
            DBGPRINTF((DBG_CONTEXT, RWP_HEALTH_NOT_OK_MSG));
            break;
        case RWP_HEALTH_TERMINALLY_ILL:
            DBGPRINTF((DBG_CONTEXT, RWP_HEALTH_TERMINALLY_ILL_MSG));
            break;
        default:
            break;
        }

}

void RWP_Read_LONG_from_Registry(HKEY hkey, const WCHAR* szSubKey, LONG* lValue) 
{
    LONG lResult;
    DWORD dwType;
    DWORD len = sizeof(lValue);
    HKEY myKey;
    
    lResult = RegQueryValueEx(
        hkey,
        szSubKey,
        0,
        &dwType,
        (LPBYTE)lValue,
        &len);
    
    if (lResult != ERROR_SUCCESS) 
    {     
        //sets default = 0 (no misbehave)
        *lValue = RWP_NO_MISBEHAVE;
        /*
        //key does not exist -- try to create it
        lResult = RegCreateKeyEx(
        hkey,
        szSubKey,
        0,
        NULL,
        REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS,
        NULL,
        &myKey,
        &dwType);
        */
    }
}

void RWP_Write_LONG_to_Registry(const WCHAR* szSubKey, LONG lValue) 
{
    LONG lResult;
    HKEY hkMyKey;
    
    lResult = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,     //root key
        RWP_CONFIG_LOCATION, //sub key
        0,                                     //reserved - must be 0
        KEY_ALL_ACCESS,            //SAM
        &hkMyKey);                      //my pointer to HKEY
    
    if (lResult != ERROR_SUCCESS) 
    {   
        DBGPRINTF((DBG_CONTEXT, "Unable to open configuration key. RegOpenKeyEx returned %d\n", lResult));
        return;
    }

    lResult = RegSetValueEx(
        hkMyKey,
        szSubKey,
        0,
        REG_DWORD,
        (LPBYTE)&lValue,
        sizeof(lValue));

    RegCloseKey(hkMyKey);

    ASSERT(lResult == ERROR_SUCCESS);
    return;
}

BOOL RWP_Read_Config(const WCHAR* szRegKey) 
{
    BOOL bSuccess = FALSE;
    HKEY hkMyKey;
    LONG lResult;
    DWORD dwDisp;
    DWORD dwLastError = 0;

    //
    // Initialize to default values
    //

    // New behavior
    OpCodeToTest = RWP_IPM_OP_NONE;
    DataLength  = 0;    // 0 means set it to the actual data length
    UseDataLength = FALSE; // by default we'll use the valid data length
    DataPointerType  = RWP_DATA_POINTER_TYPE_VALID;
    NumberOfCalls  = 1;
    AttackDuration  = 0;

    PingBehavior = RWP_NO_MISBEHAVE;
    ShutdownBehavior = RWP_NO_MISBEHAVE;
    StartupBehavior = RWP_NO_MISBEHAVE;
    HealthBehavior = RWP_NO_MISBEHAVE;
    RecycleBehavior = RWP_NO_MISBEHAVE;
    AppPoolBehavior = RWP_NO_MISBEHAVE;
    RWP_EXTRA_DEBUG = RWP_DEBUG_OFF;

    
    lResult = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,     //root key
        szRegKey,                       //sub key
        0,                                     //reserved - must be 0
        KEY_ALL_ACCESS,            //SAM
        &hkMyKey);                      //my pointer to HKEY
    
    if (lResult != ERROR_SUCCESS) 
    {   
        
        DBGPRINTF((DBG_CONTEXT, "Unable to open configuration key. RegOpenKeyEx returned %d\n", lResult));
        
    } 
    else 
    {   //my key exists.  Read in config info and validate
        DBGPRINTF((DBG_CONTEXT, "Key exists\n"));

        RWP_Read_LONG_from_Registry(hkMyKey, RWP_CONFIG_OPCODE_TO_TEST, &OpCodeToTest);
        RWP_Read_LONG_from_Registry(hkMyKey, RWP_CONFIG_IPM_DATA_LENGTH, &DataLength);
        RWP_Read_LONG_from_Registry(hkMyKey, RWP_CONFIG_IPM_USE_DATA_LENGTH, &UseDataLength);
        RWP_Read_LONG_from_Registry(hkMyKey, RWP_CONFIG_IPM_POINTER_TYPE, &DataPointerType);
        RWP_Read_LONG_from_Registry(hkMyKey, RWP_CONFIG_NUMBER_OF_CALLS, &NumberOfCalls);
        RWP_Read_LONG_from_Registry(hkMyKey, RWP_CONFIG_ATTACK_DURATION, &AttackDuration);
        
        RWP_Read_LONG_from_Registry(hkMyKey, RWP_CONFIG_PING_BEHAVIOR, &PingBehavior);
        RWP_Read_LONG_from_Registry(hkMyKey, RWP_CONFIG_SHUTDOWN_BEHAVIOR, &ShutdownBehavior);
        RWP_Read_LONG_from_Registry(hkMyKey, RWP_CONFIG_ROTATION_BEHAVIOR, &RotationBehavior);
        RWP_Read_LONG_from_Registry(hkMyKey, RWP_CONFIG_STARTUP_BEHAVIOR, &StartupBehavior);
        RWP_Read_LONG_from_Registry(hkMyKey, RWP_CONFIG_HEALTH_BEHAVIOR, &HealthBehavior);
        RWP_Read_LONG_from_Registry(hkMyKey, RWP_CONFIG_RECYCLE_BEHAVIOR, &RecycleBehavior);
        RWP_Read_LONG_from_Registry(hkMyKey, RWP_CONFIG_APP_POOL_BEHAVIOR, &AppPoolBehavior);
        
        RWP_Read_LONG_from_Registry(hkMyKey, RWP_CONFIG_PING_COUNT, &PingCount);
        RWP_Read_LONG_from_Registry(hkMyKey, RWP_CONFIG_SHUTDOWN_COUNT, &ShutdownCount);
        RWP_Read_LONG_from_Registry(hkMyKey, RWP_CONFIG_ROTATION_COUNT, &RotationCount);
        RWP_Read_LONG_from_Registry(hkMyKey, RWP_CONFIG_STARTUP_COUNT, &StartupCount);
        RWP_Read_LONG_from_Registry(hkMyKey, RWP_CONFIG_HEALTH_COUNT, &HealthCount);
        RWP_Read_LONG_from_Registry(hkMyKey, RWP_CONFIG_RECYCLE_COUNT, &RecycleCount);
        
        RWP_Read_LONG_from_Registry(hkMyKey, RWP_CONFIG_EXTRA_DEBUG, &RWP_EXTRA_DEBUG);
    }
    
    bSuccess = TRUE;
    
    RegCloseKey(hkMyKey);
    
    //
    //Declare our intentions
    //
    RWP_Display_Behavior();
    DBGPRINTF((DBG_CONTEXT, "Finished Configurations\n"));
    
    //TODO: Display PID and command line info...
    
    return (bSuccess);
}

/*
Methods modified:
iiswp.cxx
wpipm.cxx (3 places - handleping, handleshutdown, pipedisconnected)
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\testdt\dbgutil.h ===
/*++

Copyright (c) 1994-1998 Microsoft Corporation

Module Name:

    dbgutil.h

Abstract:

    This module declares the macros to wrap around DEBUG_PRINTS class
    defined in pudebug.h    
  
    This is the exported header file, that the users are allowed to modify.
    If there are no custom definitions, please use the templated version
    in the root iisrearc\inc\dbgutil.h
 
Author:

    Murali R. Krishnan (MuraliK)    22-Sept-1994

--*/


# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_



// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputKdb )

// end_user_modifiable


//
// include standard debug support
//
// note: define DEFAULT_OUTPUT_FLAGS before including pudebug.h
//

# include <pudebug.h>


// begin_user_modifiable

// Use the default constants from pudebug.h: 0x00000001 to 0x00000100

//
//  Define the debugging constants as bit-flag values
//  Example: # define DEBUG_FOOBAR 0x00010000
//  Note: All debugging bit-values below 0x00001000 are reserved!
// 
//  If you add or change a flag, please update FlagTableWp
//  in core\common\dtflags\dtflags.c
//

# define    DEBUG_UL_CALLS             0x00010000

# define    DEBUG_NREQ                 0x00040000
# define    DEBUG_WPIPM                0x00080000
# define    DEBUG_WPRECYCLER           0x00100000

# define    DEBUG_TRACE                0x10000000
# define    DEBUG_DUMPS                0x20000000

// end_user_modifiable


# endif  /* _DBGUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ssinc\ssi_request.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    ssi_request.hxx

Abstract:

    This module contains the server side include processing code.  We 
    aim for support as specified by iis\spec\ssi.doc.  The code is based
    on existing SSI support done in iis\svcs\w3\gateways\ssinc\ssinc.cxx.

    Master STM file handler ( STM file may include other files )
    Asynchronous send completions handler is implemented here

Author:

    Ming Lu (MingLu)       5-Apr-2000

Revision history
    Jaroslad               Dec-2000 
    - modified to execute asynchronously

    Jaroslad               Apr-2001
    - added VectorSend support, keepalive, split to multiple source files


--*/


#include "precomp.hxx"

//
// Globals
//
UINT g_MonthToDayCount[] = {
    0,
    31,
    31 + 28,
    31 + 28 + 31,
    31 + 28 + 31 + 30,
    31 + 28 + 31 + 30 + 31,
    31 + 28 + 31 + 30 + 31 + 30,
    31 + 28 + 31 + 30 + 31 + 30 + 31,
    31 + 28 + 31 + 30 + 31 + 30 + 31 + 31,
    31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30,
    31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31,
    31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30,
} ;


//
// SSI_REQUEST methods implementation
//

//static 
ALLOC_CACHE_HANDLER * SSI_REQUEST::sm_pachSsiRequests = NULL;

//
// #EXEC CMD is BAD.  Disable it by default
//

BOOL SSI_REQUEST::sm_fEnableCmdDirective = FALSE;


SSI_REQUEST::SSI_REQUEST( EXTENSION_CONTROL_BLOCK * pECB )
    : _pECB( pECB ),
      _strFilename( _achFilename, sizeof(_achFilename) ),
      _strURL( _achURL, sizeof(_achURL) ),
      _fIsLoadedSsiExecDisabled( FALSE ),
      _strUserMessage( _achUserMessage, sizeof(_achUserMessage) ),
      _VectorBuffer( pECB )
/*++

Routine Description:

    Constructor
    Use Create() method to setup the instance of this class

--*/

{
    InitializeListHead( &_DelayedSIFDeleteListHead );

} 

SSI_REQUEST::~SSI_REQUEST()
/*++

Routine Description:

    Destructor

--*/

{

    //
    // due to optimization all the child SSI_INCLUDE_FILE instances
    // are kept around until the request handling is finished
    // That way it is possible to optimize the number of VectorSend
    // calls to improve the response time (and also minimize problems caused
    // by delayed ACKs)
    //


    while (! IsListEmpty( &_DelayedSIFDeleteListHead ) )
    {
        LIST_ENTRY *  pCurrentEntry = RemoveHeadList( &_DelayedSIFDeleteListHead );
        SSI_INCLUDE_FILE * pSIF =
                    CONTAINING_RECORD( pCurrentEntry,
                                       SSI_INCLUDE_FILE,
                                       _DelayedDeleteListEntry
                                       );
        delete pSIF;
    }

}


//static
HRESULT
SSI_REQUEST::CreateInstance( 
    IN  EXTENSION_CONTROL_BLOCK * pECB,
    OUT SSI_REQUEST ** ppSsiRequest 
    )
/*++

Routine Description:

   Create instance of SSI_REQUEST
   (use instead of the constructor)
    
Arguments:

    pECB
    ppSsiRequest - newly created instance of SSI_REQUEST

Return Value:

    HRESULT

--*/
{
    HRESULT         hr = E_FAIL;
    SSI_REQUEST *   pSsiRequest = NULL;

    DBG_ASSERT( pECB != NULL );

    pSsiRequest = new SSI_REQUEST( pECB );

    if ( pSsiRequest == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_OUTOFMEMORY );
        goto failed;
    }

    hr = pSsiRequest->Initialize();
    if ( FAILED( hr ) )
    {
        goto failed;
    }
    
    *ppSsiRequest = pSsiRequest;
    return S_OK;
failed:
    DBG_ASSERT( FAILED( hr ) );
    if ( pSsiRequest != NULL )
    {
        delete pSsiRequest;
        pSsiRequest = NULL;
    }
    *ppSsiRequest = NULL;    
    return hr;

}
HRESULT
SSI_REQUEST::Initialize( 
    VOID
    ) 
/*++

Routine Description:

   private initialization routine used by CreateInstance
    
Arguments:

Return Value:

    HRESULT

--*/    
{
    HRESULT         hr = E_FAIL;
    STACK_BUFFER(   buffTemp, ( SSI_DEFAULT_URL_SIZE + 1 ) * sizeof(WCHAR) );
    DWORD           cbSize = buffTemp.QuerySize();
    DWORD           cchOffset = 0;
    SSI_INCLUDE_FILE * pSIF = NULL;
    
    DBG_ASSERT( _pECB != NULL );

    //
    // Lookup full url
    //

    if ( !_pECB->GetServerVariable(  _pECB->ConnID,
                                    "UNICODE_URL",
                                    buffTemp.QueryPtr(),
                                    &cbSize ) )
    {
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER ||
            !buffTemp.Resize(cbSize))
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto failed;
        }

        //
        // Now, we should have enough buffer, try again
        //
        if ( !_pECB->GetServerVariable( _pECB->ConnID,
                                       "UNICODE_URL",
                                       buffTemp.QueryPtr(),
                                       &cbSize ) )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto failed;
        }
    }
    if ( FAILED( hr = _strURL.Copy( (LPWSTR)buffTemp.QueryPtr() ) ) )
    {
        goto failed;
    }

    // Lookup physical path
    //
    
    cbSize = buffTemp.QuerySize();
    if ( !_pECB->GetServerVariable( _pECB->ConnID,
                                   "UNICODE_SCRIPT_TRANSLATED",
                                   buffTemp.QueryPtr(),
                                   &cbSize ) )
    {
        if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER ||
            !buffTemp.Resize( cbSize ) )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto failed;
        }

        //
        // Now, we should have enough buffer, try again
        //
        if ( !_pECB->GetServerVariable( _pECB->ConnID,
                                       "UNICODE_SCRIPT_TRANSLATED",
                                       buffTemp.QueryPtr(),
                                       &cbSize ) )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto failed;
        }
    }

    //
    // Remove the \\?\ or \\?\UNC\ stuff from the physical path
    // ( \\?\UNC\ is replaced by \\ )
    //

    static WCHAR s_achPrefixNoUnc[] = L"\\\\?\\";
    static DWORD s_cbPrefix1 = 
                    sizeof( s_achPrefixNoUnc ) - sizeof( s_achPrefixNoUnc[0] );
    static WCHAR s_achPrefixUnc[] =  L"\\\\?\\UNC\\";
    static DWORD s_cbPrefixUnc = 
                    sizeof( s_achPrefixUnc ) - sizeof( s_achPrefixUnc[0] );
    
    if ( cbSize >= s_cbPrefixUnc && 
         memcmp( buffTemp.QueryPtr(), 
                 s_achPrefixUnc, 
                 s_cbPrefixUnc ) == 0 )
    {
        //
        // this is UNC path
        //
        if ( FAILED( hr = _strFilename.Copy(L"\\\\") ) )
        {
            goto failed;
        }
        cchOffset = s_cbPrefixUnc / sizeof( s_achPrefixUnc[0] );
    }
    else  if ( cbSize >= s_cbPrefix1 && 
               memcmp( buffTemp.QueryPtr(), 
                       s_achPrefixNoUnc, 
                       s_cbPrefix1 ) == 0 )
    {
        cchOffset = s_cbPrefix1 / sizeof( s_achPrefixUnc[0] );
    }
    else
    {
        //
        // no prefix to get rid off was detected
        //
        cchOffset = 0;
    }


    if ( FAILED( hr = _strFilename.Append( (LPWSTR)buffTemp.QueryPtr() + cchOffset ) ) )
    {
        goto failed;
    }
    

    if ( !_pECB->ServerSupportFunction( 
                              _pECB->ConnID,
                              HSE_REQ_GET_IMPERSONATION_TOKEN,
                              &_hUser,
                              NULL,
                              NULL ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto failed;
    }

    //
    // Create SSI_INCLUDE_FILE instance
    //

    hr = SSI_INCLUDE_FILE::CreateInstance( 
                                _strFilename, 
                                _strURL,
                                this, 
                                NULL,  /* master file - no parent*/
                                &pSIF );

    if ( FAILED( hr ) ) 
    {
        goto failed;
    }

    //
    // pSIF lifetime will be now managed by SSI_REQUEST
    //
    SetCurrentIncludeFile( pSIF );

    if( FAILED( hr = _VectorBuffer.Init() ) )
    {
        goto failed;
    }
    
    return S_OK;
failed:
    DBG_ASSERT( FAILED( hr ) );
    //
    // Cleanup will happen in destructor
    //
    return hr;
}


HRESULT
SSI_REQUEST::DoWork( 
    IN  HRESULT     hrLastOp,
    OUT BOOL *      pfAsyncPending
    )
/*++

Routine Description:

    This is the top level routine for retrieving a server side include
    file.

Arguments:

    hrLastOp - error of the last asynchronous operation (the one received by completion routine)

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;

    DBG_ASSERT( _pSIF != NULL );
    DBG_ASSERT( pfAsyncPending != NULL );

    *pfAsyncPending = FALSE;
    
    while( _pSIF != NULL )
    {
        // In the case that hrLastOp contains failure
        // _pSIF->DoWork() will be called multiple times to unwind state machine
        // We will pass the same hrLastOp in the case of multiple calls
        // since that error is the primary reason why processing of this request
        // must finish 
        //
        hr = _pSIF->DoWork( hrLastOp,
                            pfAsyncPending );
        
        if ( SUCCEEDED(hr) && *pfAsyncPending )
        {
            // If there is pending IO return to caller
            return hr;
        }
        else
        {
            // to unwind state machine because of error it is important not to
            // loose the original error - hrLastOp will store that error

            if ( FAILED( hr ) && SUCCEEDED( hrLastOp ) )
            {
                hrLastOp = hr;
            }
            
            //
            // Either SSI_INCLUDE_FILE processing completed
            // or there is nested include
            //
            // In the case of error this block is used to unwind state machine
            //
            if ( _pSIF->IsCompleted() )
            {
                //
                // SSI_INCLUDE_FILE processing completed            
                // Continue with the parent SSI_INCLUDE_FILE
                // No cleanup needed for _pSIF because it is kept on the 
                // delayed delete list of SSI_REQUEST and it will be deleted
                // at the end of the SSI request processing after all the data was sent

                _pSIF = _pSIF->GetParent();
            }
            else
            {
                //
                // Current SSI_INCLUDE_FILE _pSIF hasn't been completed yet. Continue
                //
            }
        }
    } 
    
    return hr;
}

//static
VOID WINAPI
SSI_REQUEST::HseIoCompletion(
                IN EXTENSION_CONTROL_BLOCK * pECB,
                IN PVOID    pContext,
                IN DWORD    /*cbIO*/,
                IN DWORD    dwError
                )
/*++

 Routine Description:

   This is the callback function for handling completions of asynchronous IO.
   This function performs necessary cleanup and resubmits additional IO
    (if required).

 Arguments:

   pecb          pointer to ECB containing parameters related to the request.
   pContext      context information supplied with the asynchronous IO call.
   cbIO          count of bytes of IO in the last call.
   dwError       Error if any, for the last IO operation.

 Return Value:

   None.
--*/
{
    SSI_REQUEST *           pRequest = (SSI_REQUEST *) pContext;
    HRESULT                 hr = E_FAIL;
    BOOL                    fAsyncPending = FALSE;

    //
    //  Continue processing SSI file
    //

    hr = pRequest->DoWork( dwError,
                           &fAsyncPending );
    
    if ( SUCCEEDED(hr) && fAsyncPending )
    {
        // If there is pending IO return to caller
        return;
    }

    //
    // Processing of current SSI request completed
    // Do Cleanup
    //

    delete pRequest;

    //
    // Notify IIS that we are done with processing
    //
    
    pECB->ServerSupportFunction( pECB->ConnID,
                                 HSE_REQ_DONE_WITH_SESSION,
                                 NULL, 
                                 NULL, 
                                 NULL);
    
    return;

}

HRESULT
SSI_REQUEST::SSISendError(
    IN DWORD            dwMessageID,
    IN LPSTR            apszParms[] 
)
/*++

Routine Description:

    Send an SSI error

    Note: ssinc messages have been modified the way that most of them
    will ignore file names. It is to assure that there are no security
    issues such as allowing cross site scripting attack or exposing
    physical paths to files

Arguments:

    dwMessageId - Message ID
    apszParms - Array of parameters
    

Return Value:

    HRESULT (if couldn't find a error message, this will fail)

--*/
{
    
    if ( !_strUserMessage.IsEmpty() )
    {
        //
        // user specified message with #CONFIG ERRMSG=
        //
    
        return _VectorBuffer.CopyToVector( _strUserMessage );
    }
    else
    {
        DWORD            cch;
        HRESULT          hr = E_FAIL;
        CHAR *           pchErrorBuff = NULL;

        cch = SsiFormatMessageA( dwMessageID,
                                 apszParms,
                                 &pchErrorBuff );
        
        if( cch != 0 )
        {
            //
            // Add error message to vector
            //
            
            hr = _VectorBuffer.CopyToVector( 
                                       pchErrorBuff,
                                       cch );
        }
        else
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );        
        }
        
        if( pchErrorBuff != NULL )
        {
            ::LocalFree( reinterpret_cast<VOID *>( pchErrorBuff ) );
            pchErrorBuff = NULL;
        }
        
        return hr;

    }
}

HRESULT
SSI_REQUEST::SendCustomError(
    HSE_CUSTOM_ERROR_INFO * pCustomErrorInfo
)
/*++

Routine Description:

    Try to have IIS send custom error on our behalf

Arguments:

    pCustomErrorInfo - Describes custom error

Return Value:

    HRESULT (if couldn't find a custom error, this will fail)

--*/
{
    BOOL                    fRet;
    
    fRet = _pECB->ServerSupportFunction( _pECB->ConnID,
                                         HSE_REQ_SEND_CUSTOM_ERROR,
                                         pCustomErrorInfo,
                                         NULL,
                                         NULL );
    if ( !fRet )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    else
    {
        return NO_ERROR; 
    }
}

HRESULT
SSI_REQUEST::SendDate(
    IN SYSTEMTIME *         psysTime,
    IN STRA *               pstrTimeFmt
)
/*++

Routine Description:

    Sends a SYSTEMTIME in appropriate format to HTML stream
    The assumption is that pSysTime is in localtime, localtimezone/
    Otherwise the time zone in the format string will not be processed correctly

Arguments:

    psysTime - SYSTEMTIME containing time to send
    pstrTimeFmt - Format of time (follows strftime() convention)

Return Value:

    HRESULT

--*/
{
    struct tm                   tm;
    DWORD                       cbTimeBufferLen;
    HRESULT                     hr = E_FAIL;
    CHAR *                      pszVectorBufferSpace = NULL;
    TIME_ZONE_INFORMATION       tzi;
    
    // Convert SYSTEMTIME to 'struct tm'

    tm.tm_sec = psysTime->wSecond;
    tm.tm_min = psysTime->wMinute;
    tm.tm_hour = psysTime->wHour;
    tm.tm_mday = psysTime->wDay;
    tm.tm_mon = psysTime->wMonth - 1;
    tm.tm_year = psysTime->wYear - 1900;
    tm.tm_wday = psysTime->wDayOfWeek;
    tm.tm_yday = g_MonthToDayCount[ tm.tm_mon ] + tm.tm_mday - 1;

    //
    // Adjust for leap year - note that we do not handle 2100
    //

    if ( ( tm.tm_mon ) > 1 && !( psysTime->wYear & 3 ) )
    {
        ++tm.tm_yday;
    }

    DWORD dwTimeZoneInfo = GetTimeZoneInformation( &tzi );

    tm.tm_isdst = ( dwTimeZoneInfo == TIME_ZONE_ID_DAYLIGHT )?
                                            1 /*daylight time*/:
                                            0 /*standard time*/;

    if( FAILED( hr = _VectorBuffer.AllocateSpace( 
                          SSI_MAX_TIME_SIZE + 1,
                          &pszVectorBufferSpace ) ) )
    {
        return hr;
    }

    cbTimeBufferLen = (DWORD) strftime(  pszVectorBufferSpace,
                                         SSI_MAX_TIME_SIZE + 1,
                                         pstrTimeFmt->QueryStr(),
                                         &tm );

    if ( cbTimeBufferLen == 0 )
    {
        //
        // we have nothing to send - formating parameter must have been incorrect.
        //
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    return _VectorBuffer.AddToVector( pszVectorBufferSpace,
                                          cbTimeBufferLen );
}

HRESULT
SSI_REQUEST::LookupVirtualRoot( IN  WCHAR *      pszVirtual,
                                OUT STRU *       pstrPhysical,
                                IN  DWORD        dwAccess )
/*++

Routine Description:

    Lookup the given virtual path.  Optionally ensure that its access
    flags are valid for the require request.

Arguments:

    pszVirtual = Virtual path to lookup
    pstrPhysical = Contains the physical path
    dwAccess = Access flags required for a valid request

Return Value:

    HRESULT

--*/
{
    HSE_URL_MAPEX_INFO      URLMap;
    DWORD                   dwMask;

    DWORD                   dwURLSize = SSI_DEFAULT_PATH_SIZE + 1;
    STACK_STRA(             strURL, SSI_DEFAULT_PATH_SIZE + 1 );

    BUFFER                  buffURL;
    HRESULT                 hr = E_FAIL;
    CHAR                    achServerPortSecure[ 2 ]; // to store "1" or "0" 
    DWORD                   cchServerPortSecure = sizeof( achServerPortSecure );

    DBG_ASSERT( _pECB != NULL );


    //
    // ServerSupportFunction doesn't accept unicode strings. Convert    
    //

    if ( FAILED(hr = strURL.CopyW(pszVirtual)))
    {
        return hr;

    }

    //
    // lookup access flags, the actual translation of URL to physical path
    // will be done using HSE_REQ_MAP_URL_TO_PATH because
    // HSE_REQ_MAP_URL_TO_PATH_EX version doesn't support long file names (over MAX_PATH)
    //

    if ( !_pECB->ServerSupportFunction( _pECB->ConnID,
                                        HSE_REQ_MAP_URL_TO_PATH_EX,
                                        strURL.QueryStr(),
                                        &dwURLSize,
                                        (PDWORD) &URLMap ) )
    {
        if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
        {
            if( !buffURL.Resize( dwURLSize ) )
            {
                return HRESULT_FROM_WIN32( GetLastError() );
            }
            
            if ( !_pECB->ServerSupportFunction( _pECB->ConnID,
                                        HSE_REQ_MAP_URL_TO_PATH_EX,
                                        buffURL.QueryPtr(),
                                        &dwURLSize,
                                        (PDWORD) &URLMap ) )
            {
                return HRESULT_FROM_WIN32( GetLastError() );
            }

        }
        else
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }
    }

    //
    // translate URL to physical path
    // strURL will contain the physical path upon SSF completion
    //
    
    if ( !_pECB->ServerSupportFunction( _pECB->ConnID,
                                        HSE_REQ_MAP_URL_TO_PATH,
                                        strURL.QueryStr(),
                                        &dwURLSize,
                                        NULL ) )
    {
        if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
        {
            if( !buffURL.Resize( dwURLSize ) )
            {
                return HRESULT_FROM_WIN32( GetLastError() );
            }
            
            if ( !_pECB->ServerSupportFunction( _pECB->ConnID,
                                        HSE_REQ_MAP_URL_TO_PATH,
                                        buffURL.QueryPtr(),
                                        &dwURLSize,
                                        NULL ) )
            {
                return HRESULT_FROM_WIN32( GetLastError() );
            }

            if ( FAILED(hr = strURL.Copy(reinterpret_cast<CHAR *>( buffURL.QueryPtr() ) ) ) )
            {
                return hr;
            }
        }
        else
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }
    }

    //
    // find out if current connection is secure
    // SERVER_PORT_SECURE returns "1" if connection is secure 
    // and "0" if it is non-secure
    //     

    if ( !_pECB->GetServerVariable( _pECB->ConnID,
                                    "SERVER_PORT_SECURE",
                                    achServerPortSecure,
                                    &cchServerPortSecure ) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    //
    // verify access flags
    //
    dwMask = URLMap.dwFlags;

    if ( dwAccess & HSE_URL_FLAGS_READ )
    {
        if ( !( dwMask & HSE_URL_FLAGS_READ ) ||
             ( ( dwMask & HSE_URL_FLAGS_SSL ) && 
               strcmp( achServerPortSecure, "1" ) != 0 ) )
        {
            return HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
        }
    }
 
    if( FAILED( hr = pstrPhysical->CopyA( strURL.QueryStr() ) ) )
    {
        return HRESULT_FROM_WIN32( hr );
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\testdt\ulatq.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module Name :
     ulatq.cxx

   Abstract:
     Exported ULATQ.DLL routines

   Author:
     Bilal Alam (balam)             13-Dec-1999

   Environment:
     Win32 - User Mode

   Project:
     ULATQ.DLL
--*/

#include "precomp.hxx"
#include "rwpfunctions.hxx"

//
//  Configuration parameters registry key.
//

#define INET_INFO_KEY \
            "System\\CurrentControlSet\\Services\\w3svc"

#define INET_INFO_PARAMETERS_KEY \
            INET_INFO_KEY "\\Parameters"

const CHAR g_pszWpRegLocation[] =
    INET_INFO_PARAMETERS_KEY "\\w3dt";

DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();
DECLARE_PLATFORM_TYPE();


WP_CONTEXT *            g_pwpContext = NULL;

//
// Completion routines for new requests, io completions, and disconnect
// notifications.
//
// CODEWORK: Can we get away with these being global
//

PFN_ULATQ_NEW_REQUEST           g_pfnNewRequest = NULL;
PFN_ULATQ_IO_COMPLETION         g_pfnIoCompletion = NULL;
PFN_ULATQ_DISCONNECT            g_pfnDisconnect = NULL;
PFN_ULATQ_ON_SHUTDOWN           g_pfnOnShutdown = NULL;
PFN_ULATQ_COLLECT_PERF_COUNTERS g_pfnCollectCounters = NULL;


HRESULT
UlAtqInitialize(
    INT                 argc,
    LPWSTR              argv[],
    ULATQ_CONFIG *      pConfig
)
/*++

Routine Description:

    Initialize ULATQ

Arguments:

    argc - Number of command line parameters to worker process
    argv - Command line parameters
    pConfig - Configuration settings for ULATQ

Return Value:

    HRESULT

--*/
{
    HRESULT             rc = NO_ERROR;
    BOOL                fUlInit = FALSE;
    BOOL                fThreadPoolInit = FALSE;
    HTTPAPI_VERSION     HttpVersion = HTTPAPI_VERSION_1;

    CREATE_DEBUG_PRINT_OBJECT("w3dt");
#if DBG
    if (!VALID_DEBUG_PRINT_OBJECT())
    {
        return E_FAIL;
    }
#endif

    LOAD_DEBUG_FLAGS_FROM_REG_STR( g_pszWpRegLocation, DEBUG_ERROR );

    INITIALIZE_PLATFORM_TYPE();

    //
    // Honour ULATQ_CONFIG settings.  Set completion routines
    // Need to set this up before we do any other initialization
    //

    g_pfnNewRequest = pConfig->pfnNewRequest;
    g_pfnIoCompletion = pConfig->pfnIoCompletion;
    g_pfnDisconnect = pConfig->pfnDisconnect;
    g_pfnOnShutdown = pConfig->pfnOnShutdown;
    g_pfnCollectCounters = pConfig->pfnCollectCounters;

    //
    // Initialize the thread pool
    //

    rc = ThreadPoolInitialize( 0 ); // Use the process default stack size
    if ( FAILED( rc ) )
    {
        goto Finished;
    }
    fThreadPoolInit = TRUE;

    //
    // Init UL
    //

    rc = HttpInitialize( HttpVersion, 0, NULL );
    if ( rc != NO_ERROR )
    {
        rc = HRESULT_FROM_WIN32( rc );
    
        DBGPRINTF(( DBG_CONTEXT, "Error (rc=%08x) in UlInitialize. Exiting\n",
                    rc ));
        goto Finished;
    }
    fUlInit = TRUE;

    //
    // Determine if we should be deterministic or random, 
    // and declare our intentions
    //
    // Note: this needs to be called prior to attempting to run any rogue
    // tests. This appears to be a good early time to call it.
    //
    RWP_Read_Config(RWP_CONFIG_LOCATION);

    //
    // Create global state object
    //

    g_pwpContext = new WP_CONTEXT;
    if ( g_pwpContext == NULL )
    {
        rc = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto Finished;
    }

    //
    // Do global state initialization
    //

    rc = g_pwpContext->Initialize( argc, argv );
    if ( rc != NO_ERROR )
    {
        //
        // WP_CONTEXT::Initialize returns a Win32 error code
        //

        rc = HRESULT_FROM_WIN32( rc );
        goto Finished;
    }

Finished:
    if ( rc != NO_ERROR )
    {
        if ( g_pwpContext != NULL )
        {
            delete g_pwpContext;
            g_pwpContext = NULL;
        }

        if ( fUlInit )
        {
            HttpTerminate(0, NULL);
        }

        if ( fThreadPoolInit )
        {
            ThreadPoolTerminate();
        }
    }

    return rc;
}

HRESULT
UlAtqStartListen(
    VOID
)
/*++

Routine Description:

    Begin listening for HTTP requests from UL.  This call must happen only
    after ULATQ has been initialized correctly (for example, completion
    routines should be set).

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HRESULT         hr = NO_ERROR;

    DBG_ASSERT( g_pfnIoCompletion != NULL );
    DBG_ASSERT( g_pfnNewRequest != NULL );

    //
    // Make some UlReceiveHttpRequest calls
    //

    hr = g_pwpContext->Start();
    if ( FAILED(hr) )
    {
        //
        // If we failed to start, we may outstanding requests to cleanup. 
        //
        goto DoShutdown;
    }

    //
    // Send message to WAS that our initialization is complete
    //
    g_pwpContext->SendInitCompleteMessage( S_OK );

    //
    // Wait for shutdown because of WAS/request-count-max/etc.
    //

    g_pwpContext->RunMainThreadLoop();

DoShutdown:
    //
    // Do stuff needed to stop listening for new requests
    //
    UL_NATIVE_REQUEST::StopListening();

    //
    // Before connection drain, allow the user to execute some code
    //

    if ( g_pfnOnShutdown != NULL )
    {
        g_pfnOnShutdown( g_pwpContext->QueryDoImmediateShutdown() );
    }

    //
    // Before we return, wait for outstanding requests to drain.  This
    // prevents race before caller's shutdown and new requests coming in
    //

    g_pwpContext->CleanupOutstandingRequests();

    return hr;
}

VOID
UlAtqTerminate(
    HRESULT hrToSend
)
/*++

Routine Description:

    Terminate ULATQ

Arguments:

    None

Return Value:

    None

--*/
{
    if ( g_pwpContext != NULL )
    {
        if (FAILED(hrToSend))
        {
            g_pwpContext->SendInitCompleteMessage( hrToSend );
        }

        g_pwpContext->Terminate();
        delete g_pwpContext;
        g_pwpContext = NULL;
    }

    HttpTerminate(0, NULL);

    ThreadPoolTerminate();

    DELETE_DEBUG_PRINT_OBJECT();
}

VOID *
UlAtqGetContextProperty(
    ULATQ_CONTEXT               pContext,
    ULATQ_CONTEXT_PROPERTY_ID   PropertyId
)
/*++

Routine Description:

    Get the UL_HTTP_REQUEST from the ULATQ_CONTEXT

Arguments:

    pContext - ULATQ_CONTEXT
    PropertyId - Property Id to set

Return Value:

    The actual property

--*/
{
    switch (PropertyId)
    {
    case ULATQ_PROPERTY_HTTP_REQUEST:
        UL_NATIVE_REQUEST *         pRequest;
        pRequest = (UL_NATIVE_REQUEST*) pContext;
        DBG_ASSERT( pRequest != NULL );

        return pRequest->QueryHttpRequest();

    case ULATQ_PROPERTY_APP_POOL_ID:
        return (VOID *)g_pwpContext->QueryConfig()->QueryAppPoolName();

    case ULATQ_PROPERTY_IS_COMMAND_LINE_LAUNCH:
        return (VOID *)!(g_pwpContext->QueryConfig()->QueryRegisterWithWAS());

    case ULATQ_PROPERTY_DO_CENTRAL_BINARY_LOGGING:
        return (VOID *)(DWORD_PTR)g_pwpContext->QueryConfig()->QueryDoCentralBinaryLogging();

    default:
        DBG_ASSERT(FALSE);
    }

    return NULL;
}

VOID
UlAtqSetContextProperty(
    ULATQ_CONTEXT               pContext,
    ULATQ_CONTEXT_PROPERTY_ID   PropertyId,
    PVOID                       pvData
)
/*++

Routine Description:

    Set a property of the ULATQ_CONTEXT

Arguments:

    pContext - ULATQ_CONTEXT
    PropertyId - Property Id to set
    pvData - Data specific to the property being set

Return Value:

    None

--*/
{
    UL_NATIVE_REQUEST *         pRequest;

    pRequest = (UL_NATIVE_REQUEST*) pContext;
    DBG_ASSERT( pRequest != NULL );

    switch ( PropertyId )
    {
    case ULATQ_PROPERTY_COMPLETION_CONTEXT:
        pRequest->SetContext( pvData );
        break;

    default:
        DBG_ASSERT( FALSE );
    }
}

VOID
UlAtqFreeContext(
    ULATQ_CONTEXT               pContext
)
/*++

Routine Description:

    Frees the ULATQ_CONTEXT so that it can be used to retrieve next request

Arguments:

    pContext - ULATQ_CONTEXT

Return Value:

    None

--*/
{
    UL_NATIVE_REQUEST *         pRequest;

    pRequest = (UL_NATIVE_REQUEST*) pContext;
    DBG_ASSERT( pRequest != NULL );

    pRequest->ResetContext();
}

HRESULT
UlAtqSendHttpResponse(
    ULATQ_CONTEXT               pContext,
    BOOL                        fAsync,
    DWORD                       dwFlags,
    HTTP_RESPONSE *             pResponse,
    HTTP_CACHE_POLICY *         pCachePolicy,
    DWORD                      *pcbSent,
    HTTP_LOG_FIELDS_DATA       *pUlLogData
)
/*++

Routine Description:

    Send a response to the client

Arguments:

    pContext - ULATQ_CONTEXT
    fAsync - Asynchronous or not?
    dwFlags - Response flags (like killing the connection)
    pResponse - UL_HTTP_RESPONSE to send
    pCachePolicy - Cache policy

Return Value:

    Win32 Error

--*/
{
    UL_NATIVE_REQUEST *         pRequest;

    pRequest = (UL_NATIVE_REQUEST*) pContext;
    DBG_ASSERT( pRequest != NULL );

    return pRequest->SendResponse( fAsync,
                                   dwFlags,
                                   pResponse,
                                   pCachePolicy,
                                   pcbSent,
                                   pUlLogData );
}

HRESULT
UlAtqSendEntityBody(
    ULATQ_CONTEXT               pContext,
    BOOL                        fAsync,
    DWORD                       dwFlags,
    USHORT                      cChunks,
    HTTP_DATA_CHUNK *           pChunks,
    DWORD                      *pcbSent,
    HTTP_LOG_FIELDS_DATA       *pUlLogData
)
/*++

Routine Description:

    Send entity to the client

Arguments:

    pContext - ULATQ_CONTEXT
    fAsync - Asynchronous or not?
    dwFlags - Response flags (like killing the connection)
    cChunks - Number of chunks in the response
    pChunks - Points to array of chunks

Return Value:

    HRESULT

--*/
{
    UL_NATIVE_REQUEST *         pRequest;

    pRequest = (UL_NATIVE_REQUEST*) pContext;
    DBG_ASSERT( pRequest != NULL );

    return pRequest->SendEntity( fAsync,
                                 dwFlags,
                                 cChunks,
                                 pChunks,
                                 pcbSent,
                                 pUlLogData );
}

HRESULT
UlAtqReceiveEntityBody(
    ULATQ_CONTEXT               pContext,
    BOOL                        fAsync,
    DWORD                       dwFlags,
    VOID *                      pBuffer,
    DWORD                       cbBuffer,
    DWORD *                     pBytesReceived
)
/*++

Routine Description:

    Receive entity from the client

Arguments:

    pContext - ULATQ_CONTEXT
    fAsync - Asynchronous or not?
    dwFlags - Response flags (like killing the connection)
    pBuffer - Buffer to store the data
    cbBuffer - The size of the receive buffer
    pBytesReceived - The number of bytes copied to the buffer upon return

Return Value:

    HRESULT

--*/
{
    UL_NATIVE_REQUEST *         pRequest;

    pRequest = (UL_NATIVE_REQUEST*) pContext;
    DBG_ASSERT( pRequest != NULL );

    return pRequest->ReceiveEntity( fAsync,
                                    dwFlags,
                                    pBuffer,
                                    cbBuffer,
                                    pBytesReceived);
}

HRESULT
UlAtqWaitForDisconnect(
    HTTP_CONNECTION_ID              connectionId,
    BOOL                            fAsync,
    PVOID                           pvContext,
    BOOL *                          pfAlreadyCompleted
)
/*++

Routine Description:

    Used to wait for a connection to close.

Arguments:

    connectionId - connection in question
    fAsync - should we wait asynchronously?
    pvContext - context to pass back on async disconnect wait

Return Value:

    HRESULT

--*/
{
    UL_DISCONNECT_CONTEXT *         pContext;
    ULONG                           Status;
    HRESULT                         hr = NO_ERROR;
    HANDLE                          hAsync;

    //
    // Allocate an async context which will be freed once the connection
    // has been closed
    //

    pContext = new UL_DISCONNECT_CONTEXT( pvContext );
    if ( pContext == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }

    hAsync = g_pwpContext->GetAndLockAsyncHandle();

    pContext->ReferenceUlDisconnectContext();

    if ( hAsync != NULL )
    {

        //
        // Do the wait
        //

        Status = HttpWaitForDisconnect( hAsync,
                                        connectionId,
                                        fAsync ? &(pContext->_Overlapped) : NULL );
    }
    else
    {
        Status = ERROR_INVALID_HANDLE;
    }

    DBG_REQUIRE(SUCCEEDED(g_pwpContext->UnlockAsyncHandle()));

    if ( pfAlreadyCompleted )
    {
        *pfAlreadyCompleted = HasOverlappedIoCompleted( &(pContext->_Overlapped) );
    }

    if ( Status != ERROR_IO_PENDING && Status != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Status );
        pContext->DereferenceUlDisconnectContext();
    }

    pContext->DereferenceUlDisconnectContext();
    
    return hr;
}

HRESULT
UlAtqInduceShutdown(
    BOOL fImmediate
)
/*++

Routine Description:

    Induce shutdown (used when IIS+ hosted in inetinfo.exe).  Simulates
    WAS telling us to shutdown

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    DBG_ASSERT( g_pwpContext != NULL );

    if ( !g_pwpContext->IndicateShutdown( fImmediate ) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    return NO_ERROR;
}

HRESULT
UlAtqReceiveClientCertificate(
    ULATQ_CONTEXT               pContext,
    BOOL                        fAsync,
    BOOL                        fDoCertMap,
    HTTP_SSL_CLIENT_CERT_INFO **ppClientCertInfo
)
/*++

Routine Description:

    Receive client certificate

Arguments:

    pContext - ULATQ context
    fAsync - TRUE if we should do it asynchronously
    fDoCertMap - Map client certificate to token
    ppClientCertInfo - Set to point to client cert on success

Return Value:

    HRESULT

--*/
{
    UL_NATIVE_REQUEST *         pRequest;

    pRequest = (UL_NATIVE_REQUEST*) pContext;
    DBG_ASSERT( pRequest != NULL );
    DBG_ASSERT( pRequest->CheckSignature() );

    return pRequest->ReceiveClientCertificate( fAsync,
                                               fDoCertMap,
                                               ppClientCertInfo );
}

HRESULT
UlAtqFlushUlCache(
    WCHAR *                     pszUrlPrefix
)
/*++

Routine Description:

    Flush the UL cache at the given URL prefix

Arguments:

    pszUrlPrefix - UL prefix to flush

Return Value:

    HRESULT

--*/
{
    HANDLE              hAsync;

    if ( pszUrlPrefix == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    if ( g_pwpContext == NULL )
    {
        //
        // Before removing this assert, please think hard (and then
        // think again)
        //

        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
    }


    //
    // The AppPool handle may already have been closed, eg during shutdown
    //
    hAsync = g_pwpContext->GetAndLockAsyncHandle();

    if ( hAsync != NULL )
    {
        HttpFlushResponseCache( hAsync,
                                pszUrlPrefix,
                                0,
                                NULL );
    }

    DBG_REQUIRE(SUCCEEDED(g_pwpContext->UnlockAsyncHandle()));


    //
    // Mask the error since we may be flushing URLs which aren't
    // in the cache (that's OK)
    //

    return NO_ERROR;
}

VOID
UlAtqSetUnhealthy(
    VOID
    )
/*++

Routine Description:

    Marks the state of the process as unhealthy

Arguments:

    None

Return Value:

    None

--*/
{
    g_pwpContext->SetUnhealthy();
}


HRESULT
UlAtqAddFragmentToCache(
    HTTP_DATA_CHUNK * pDataChunk,
    WCHAR           * pszFragmentName
)
/*++

Routine Description:

    Add the fragment to cache

Arguments:

    pDataChunk - The chunk to be added
    pszFragmentName - name of the fragment

Return Value:

    HRESULT

--*/
{
    DWORD               err;
    HANDLE              hAsync;
    HTTP_CACHE_POLICY   cachePolicy = { HttpCachePolicyUserInvalidates, 0 };

    hAsync = g_pwpContext->GetAndLockAsyncHandle();

    if ( hAsync != NULL )
    {
        err = HttpAddFragmentToCache( hAsync,
                                      pszFragmentName,
                                      pDataChunk,
                                      &cachePolicy,
                                      NULL );
    }
    else
    {
        err = ERROR_INVALID_HANDLE;
    }

    DBG_REQUIRE(SUCCEEDED(g_pwpContext->UnlockAsyncHandle()));

    return HRESULT_FROM_WIN32(err);
}


HRESULT
UlAtqReadFragmentFromCache(
    WCHAR          * pszFragmentName,
    BYTE           * pvBuffer,
    DWORD            cbSize,
    DWORD          * pcbCopied
)
/*++

Routine Description:

    Read the fragment from cache

Arguments:

    pszFragmentName - name of the fragment
    pvBuffer - the buffer to read in
    cbSize - the size of the buffer
    pcbCopied - the amount copied in on return

Return Value:

    HRESULT

--*/
{
    DWORD               err;
    HANDLE              hAsync;

    hAsync = g_pwpContext->GetAndLockAsyncHandle();

    if ( hAsync != NULL )
    {
        err = HttpReadFragmentFromCache( hAsync,
                                         pszFragmentName,
                                         NULL,
                                         pvBuffer,
                                         cbSize,
                                         pcbCopied,
                                         NULL);
    }
    else
    {
        err = ERROR_INVALID_HANDLE;
    }

    DBG_REQUIRE(SUCCEEDED(g_pwpContext->UnlockAsyncHandle()));

    return HRESULT_FROM_WIN32(err);
}


HRESULT
UlAtqRemoveFragmentFromCache(
    WCHAR          * pszFragmentName
)
/*++

Routine Description:

    Remove the fragment from cache

Arguments:

    pszFragmentName - name of the fragment

Return Value:

    HRESULT

--*/
{
    DWORD               err;
    HANDLE              hAsync;

    hAsync = g_pwpContext->GetAndLockAsyncHandle();

    if ( hAsync != NULL )
    {
        err = HttpFlushResponseCache( hAsync,
                                      pszFragmentName,
                                      0,
                                      NULL);
    }
    else
    {
        err = ERROR_INVALID_HANDLE;
    }

    DBG_REQUIRE(SUCCEEDED(g_pwpContext->UnlockAsyncHandle()));

    return HRESULT_FROM_WIN32(err);
}

VOID *
UlAtqAllocateMemory(
    ULATQ_CONTEXT               pContext,
    DWORD                       cbSize
)
/*++

Routine Description:

    Allocate some memory associated with the native request

Arguments:

    pContext - ULATQ Context
    cbSize - Size to allocate

Return Value:

    Pointer to memory or NULL if failed

--*/
{
    UL_NATIVE_REQUEST *         pRequest;

    if ( pContext == NULL )
    {
        DBG_ASSERT( FALSE );
        SetLastError( ERROR_INVALID_PARAMETER );
        return NULL;
    }

    pRequest = (UL_NATIVE_REQUEST*) pContext;
    DBG_ASSERT( pRequest->CheckSignature() );
    
    return pRequest->AllocateMemory( cbSize );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\testdt\uldisconnect.cxx ===
/*++

   Copyright    (c)    2000    Microsoft Corporation

   Module Name :
     uldisconnect.cxx

   Abstract:
     UL_DISCONNECT_CONTEXT implementation
 
   Author:
     Bilal Alam             (balam)         15-Feb-2000

   Environment:
     Win32 - User Mode

   Project:
     W3DT.DLL
--*/

#include "precomp.hxx"

extern PFN_ULATQ_DISCONNECT         g_pfnDisconnect;

//
// UL_DISCONNECT_CONTEXT statics
//

LONG                    UL_DISCONNECT_CONTEXT::sm_cOutstanding;
ALLOC_CACHE_HANDLER *   UL_DISCONNECT_CONTEXT::sm_pachDisconnects;

VOID
UL_DISCONNECT_CONTEXT::DoWork( 
    DWORD,        
    DWORD,       
    LPOVERLAPPED 
)
/*++

Routine Description:

    Handles async calls to UlWaitForDisconnect

Arguments:

    All arguments unused
    
Return Value:

    None

--*/
{
    DBG_ASSERT( CheckSignature() );
    
    //
    // Our handling is simple.  We just call the disconnection completion
    // routine with the context passed thru UlAtqWaitForDisconnect
    //
    
    DBG_ASSERT( g_pfnDisconnect != NULL );
    
    g_pfnDisconnect( _pvContext );   
    
    //
    // We're done with the context, delete it now
    // 
    
    DereferenceUlDisconnectContext();
}   

//static
VOID
UL_DISCONNECT_CONTEXT::WaitForOutstandingDisconnects(
    VOID
)
/*++

Routine Description:

    Wait for the outstanding UL_DISCONNECT_CONTEXTs to drain.  This will 
    happen when we close the AppPool handle to begin shutdown

Arguments:

    None
    
Return Value:

    None

--*/
{
    while ( sm_cOutstanding != 0 )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Waiting for %d disconnect contexts to drain\n",
                    sm_cOutstanding ));
        
        Sleep( 1000 );
    }
}

//static
HRESULT
UL_DISCONNECT_CONTEXT::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize disconnect globals

Arguments:

    None
    
Return Value:

    HRESULT 

--*/
{
    ALLOC_CACHE_CONFIGURATION       acConfig;
    
    //
    // Setup allocation lookaside
    //
    
    acConfig.nConcurrency = 1;
    acConfig.nThreshold = 100;
    acConfig.cbSize = sizeof( UL_DISCONNECT_CONTEXT );

    DBG_ASSERT( sm_pachDisconnects == NULL );
    
    sm_pachDisconnects = new ALLOC_CACHE_HANDLER( "UL_DISCONNECT_CONTEXT",  
                                                   &acConfig );

    if ( sm_pachDisconnects == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }
    
    return NO_ERROR;
}

//static
VOID
UL_DISCONNECT_CONTEXT::Terminate(
    VOID
)
/*++

Routine Description:

    Cleanup disconnect globals

Arguments:

    None
    
Return Value:

    None

--*/
{
    if ( sm_pachDisconnects != NULL )
    {
        delete sm_pachDisconnects;
        sm_pachDisconnects = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\testdt\workerrequest.cxx ===
/*++

   Copyright    (c)    2000    Microsoft Corporation

   Module Name :
     workerrequest.cxx

   Abstract:
     UL_NATIVE_REQUEST implementation

   Author:
     Murali R. Krishnan    ( MuraliK )     23-Oct-1998
     Lei Jin               ( leijin  )     13-Apr-1999    (Porting)

   Environment:
     Win32 - User Mode

   Project:
     ULATQ.DLL
--*/

#include "precomp.hxx"

//
// User supplied completion routines
//

extern PFN_ULATQ_NEW_REQUEST        g_pfnNewRequest;
extern PFN_ULATQ_IO_COMPLETION      g_pfnIoCompletion;

//
// UL_NATIVE_REQUEST statics
//

ULONG            UL_NATIVE_REQUEST::sm_cRequestsServed;
ULONG            UL_NATIVE_REQUEST::sm_cRestart;
LONG             UL_NATIVE_REQUEST::sm_RestartMsgSent;
LIST_ENTRY       UL_NATIVE_REQUEST::sm_RequestListHead;
CRITICAL_SECTION UL_NATIVE_REQUEST::sm_csRequestList;
DWORD            UL_NATIVE_REQUEST::sm_cRequests;
PTRACE_LOG       UL_NATIVE_REQUEST::sm_pTraceLog;
DWORD            UL_NATIVE_REQUEST::sm_cRequestsPending;
DWORD            UL_NATIVE_REQUEST::sm_cDesiredPendingRequests;
BOOL             UL_NATIVE_REQUEST::sm_fAddingRequests;
ALLOC_CACHE_HANDLER * UL_NATIVE_REQUEST::sm_pachNativeRequests;
DWORD            UL_NATIVE_REQUEST::sm_cMaxFreeRequests = DEFAULT_MAX_FREE_REQUESTS;
DWORD            UL_NATIVE_REQUEST::sm_cFreeRequests;
#ifdef _WIN64
CSpinLock        UL_NATIVE_REQUEST::sm_FreeListLock;
SINGLE_LIST_ENTRY UL_NATIVE_REQUEST::sm_FreeList;
#else
SLIST_HEADER     UL_NATIVE_REQUEST::sm_FreeList;
#endif

UL_NATIVE_REQUEST::UL_NATIVE_REQUEST(
    VOID
) : _pbBuffer( _achBuffer ),
    _cbBuffer( sizeof( _achBuffer ) ),
    _pClientCertInfo( NULL ),
    _cbAllocateMemoryOffset( 0 ),
    _cRefs( 1 )
{
    InitializeListHead( &_ListEntry );
    
    _FreeListEntry.Next = NULL;

    AddToRequestList();

    Reset();

    _dwSignature = UL_NATIVE_REQUEST_SIGNATURE;
}

UL_NATIVE_REQUEST::~UL_NATIVE_REQUEST(
    VOID
)
{
    DBG_ASSERT( CheckSignature() );
    _dwSignature = UL_NATIVE_REQUEST_SIGNATURE_FREE;

    if ( !IsListEmpty( &_ListEntry ) )
    {
        RemoveFromRequestList();
    }

    DBG_ASSERT( _cRefs == 0 );

    Cleanup();
}

VOID
UL_NATIVE_REQUEST::Cleanup(
    VOID
)
/*++

Routine Description:

    Private helper method called by destructor and Reset()
    It assures that resources are cleaned up properly

Arguments:

    None

Return Value:

    None

--*/
{
    if ( _pbBuffer != _achBuffer )
    {
        LocalFree( _pbBuffer );
    }
    _pbBuffer           = _achBuffer;
    _cbBuffer           = sizeof( _achBuffer );

    //
    // http.sys returns token in HTTP_SSL_CLIENT_CERT_INFO structure
    // UL_NATIVE_REQUEST must take care of closing the token to avoid leak
    //

    if ( _pClientCertInfo != NULL &&
         _pClientCertInfo->Token != NULL )
    {
        CloseHandle( _pClientCertInfo->Token );
        _pClientCertInfo->Token = NULL;
    }
    
    //
    // Start allocating from the beginning of the buffer
    //
    
    _cbAllocateMemoryOffset = 0;
}


VOID
UL_NATIVE_REQUEST::Reset(
    VOID
)
/*++

Routine Description:

    Reset a UL_NATIVE_REQUEST for use in the request state machine

Arguments:

    None

Return Value:

    None

--*/
{
    Cleanup();

    _ExecState          = NREQ_STATE_START;
    _pvContext          = NULL;
    _cbAsyncIOData      = 0;
    _dwAsyncIOError     = NO_ERROR;
    _dwClientCertFlags  = 0;

    ZeroMemory( &_Overlapped, sizeof(_Overlapped) );
}

VOID *
UL_NATIVE_REQUEST::AllocateMemory(
    DWORD                   cbSize
)
/*++

Routine Description:

    Allocate some memory for use by W3DT.DLL user
    in our private buffer

Arguments:

    cbSize - Size to allocate

Return Value:

    Pointer to memory (NULL if failed)

--*/
{
    DWORD               cbSizeNeeded = 0;
    VOID *              pvRet;
    ULONG_PTR           ulPointer;
    
    cbSizeNeeded = _cbAllocateMemoryOffset + cbSize + sizeof( ULONG_PTR );

    if ( cbSizeNeeded <= sizeof( _abAllocateMemory ) )
    {
        //
        // Allocate inline
        //
        
        ulPointer = (ULONG_PTR) _abAllocateMemory + _cbAllocateMemoryOffset;
        ulPointer = ( ulPointer + 7 ) & ~7;
        pvRet = (VOID*) ulPointer;
        
        _cbAllocateMemoryOffset += cbSize + sizeof( ULONG_PTR );
    }
    else
    {
        pvRet = NULL;
    }
    
    return pvRet;
}

VOID
UL_NATIVE_REQUEST::DoWork(
    DWORD                   cbData,
    DWORD                   dwError,
    LPOVERLAPPED            lpo
)
/*++

Routine Description:

    The driver of the state machine.  It is called off async completions and
    initially (with lpo=NULL) to kick off the state machine.

Arguments:

    cbData - Bytes completed
    dwError - Win32 Error of completion
    lpo - Pointer to OVERLAPPED passed in async call

Return Value:

    None

--*/
{
    NREQ_STATUS             Status = NSTATUS_NEXT;
    BOOL                    fError = FALSE;

    ReferenceWorkerRequest();

    if ( lpo != NULL )
    {
        //
        // This is an async completion.  Dereference the request to match
        // the reference before posting async operation
        //

        DereferenceWorkerRequest();

        //
        // Save away the completion data for state handler use and debugging
        // purposes
        //
        
        _cbAsyncIOData = cbData;
        _dwAsyncIOError = dwError;

        ZeroMemory( &_Overlapped, sizeof( _Overlapped ) );
    }

    //
    // Keep on executing the state machine until a state handler returns
    // pending.  If so, the IO completion will continue the machine
    //
    // We also break out on error (typical case will be shutdown)
    //

    while ( !fError && Status == NSTATUS_NEXT )
    {
        switch ( _ExecState )
        {
        case NREQ_STATE_START:
            Status = DoStateStart();
            break;

        case NREQ_STATE_READ:
            Status = DoStateRead();
            break;

        case NREQ_STATE_PROCESS:
            Status = DoStateProcess();
            break;

        case NREQ_STATE_ERROR:
            fError = TRUE;
            DereferenceWorkerRequest();
            break;

        case NREQ_STATE_CLIENT_CERT:
            Status = DoStateClientCertificate();
            break;

        default:
            fError = TRUE;
            DBG_ASSERT( FALSE );
            break;
        }
    }

    DereferenceWorkerRequest();
}

NREQ_STATUS
UL_NATIVE_REQUEST::DoStateStart(
    VOID
)
/*++

Routine Description:

    The NREQ_START state.  This state does the initial read for a new HTTP
    request (it passes a NULL request ID).  Continuing the read process (
    for example if the buffer is too small) happens in the NREQ_READ state.

Arguments:

    None

Return Value:

    NSTATUS_PENDING if async IO pending, else NSTATUS_NEXT

--*/
{
    ULONG               rc;
    HTTP_REQUEST_ID     RequestId;
    HANDLE              hAsync;

    //
    // This is the initial read, therefore we don't know the request ID
    //

    HTTP_SET_NULL_ID( &RequestId );

    //
    // If we are in shutdown, then just bail with error
    //

    if ( g_pwpContext->IsInShutdown() )
    {
        _ExecState = NREQ_STATE_ERROR;
        return NSTATUS_NEXT;
    }

    //
    // Have we served enough requests?
    //

    if ( sm_cRestart &&
         sm_cRequestsServed >= sm_cRestart )
    {
        //
        // Indicate to WAS such and the error out
        //

        if ( NeedToSendRestartMsg() )
        {
            g_pwpContext->SendMsgToAdminProcess( IPM_WP_RESTART_COUNT_REACHED );
        }

        _ExecState = NREQ_STATE_ERROR;
        return NSTATUS_NEXT;
    }

    //
    // Make an async call to HttpReceiveHttpRequest to get the next request
    //

    _ExecState = NREQ_STATE_READ;

    InterlockedIncrement( (LPLONG) &sm_cRequestsPending );

    ReferenceWorkerRequest();

    hAsync = g_pwpContext->GetAndLockAsyncHandle();

    if ( hAsync != NULL )
    {
        rc = HttpReceiveHttpRequest( hAsync,
                                     RequestId,
                                     HTTP_RECEIVE_REQUEST_FLAG_COPY_BODY,
                                     (HTTP_REQUEST *) _pbBuffer,
                                     _cbBuffer,
                                     NULL,
                                     &_Overlapped );
    }
    else
    {
        rc = ERROR_INVALID_HANDLE;
    }

    DBG_REQUIRE(SUCCEEDED(g_pwpContext->UnlockAsyncHandle()));

    if ( rc == NO_ERROR )
    {
        rc = ERROR_IO_PENDING;
    }

    if ( rc != ERROR_IO_PENDING )
    {
        DBG_ASSERT( rc != NO_ERROR );

        InterlockedDecrement( (LPLONG) &sm_cRequestsPending );

        _ExecState = NREQ_STATE_ERROR;

        DereferenceWorkerRequest();

        return NSTATUS_NEXT;
    }
    else
    {
        return NSTATUS_PENDING;
    }
}


NREQ_STATUS
UL_NATIVE_REQUEST::DoStateRead(
    VOID
)
/*++

Routine Description:

    The NREQ_READ state.  This state is responsible for producing a complete
    UL_HTTP_REQUEST for consumption by the NREQ_PROCESS state.  Note that
    this may require another UlReceiveHttpRequest() if the initial was not
    supplied a large enough buffer.

Arguments:

    None

Return Value:

    NSTATUS_PENDING if async IO pending, else NSTATUS_NEXT

--*/
{
    HTTP_REQUEST_ID     RequestId;
    ULONG               cbRequired;
    DWORD               cCurrentRequestsPending;
    HANDLE              hAsync;


    //
    // The initial read is complete.  If the error is ERROR_MORE_DATA, then
    // our buffer was not large enough.  Resize and try again
    //

    if ( _dwAsyncIOError == ERROR_MORE_DATA )
    {
        //
        // Remember the request ID to retry the the UlReceiveHttpRequest
        //
        RequestId = QueryRequestId();
        DBG_ASSERT( RequestId != HTTP_NULL_ID );

        //
        // We need to allocate a larger buffer :(
        //

        if ( _pbBuffer != _achBuffer )
        {
            //
            // We shouldn't be getting ERROR_MORE_DATA if we already
            // resized due to an earlier ERROR_MORE_DATA
            //

            DBG_ASSERT( FALSE );
            LocalFree( _pbBuffer );
            _pbBuffer = NULL;
        }

        //
        // The completed bytes tells us the required size of our input
        // buffer
        //

        _cbBuffer = _cbAsyncIOData;
        _pbBuffer = (UCHAR*) LocalAlloc( LPTR, _cbBuffer );
        if ( _pbBuffer == NULL )
        {
            _ExecState = NREQ_STATE_ERROR;
            return NSTATUS_NEXT;
        }

        //
        // Read the HTTP request again (better to do it sychronously, since
        // it is all ready now)
        //

        hAsync = g_pwpContext->GetAndLockAsyncHandle();

        if ( hAsync != NULL )
        {
            _dwAsyncIOError = HttpReceiveHttpRequest(
                                     hAsync,
                                     RequestId,
                                     HTTP_RECEIVE_REQUEST_FLAG_COPY_BODY,
                                     (HTTP_REQUEST *)_pbBuffer,
                                     _cbBuffer,
                                     &cbRequired,
                                     NULL );
        }
        else
        {
            _dwAsyncIOError = ERROR_INVALID_HANDLE;
        }

        DBG_REQUIRE(SUCCEEDED(g_pwpContext->UnlockAsyncHandle()));

        //
        // No reason this should fail again with ERROR_MORE_DATA
        //
        DBG_ASSERT( _dwAsyncIOError != ERROR_MORE_DATA );
    }

    if ( _dwAsyncIOError == NO_ERROR )
    {
        //
        // We're done.  The read was successful and we have a full
        // UL_HTTP_REQUEST.  We can now pass off to the NREQ_PROCESS state
        //

        cCurrentRequestsPending = InterlockedDecrement( (LPLONG)
                                                        &sm_cRequestsPending );

        if ( cCurrentRequestsPending < sm_cDesiredPendingRequests / 2 )
        {
            AddPendingRequests( sm_cDesiredPendingRequests - cCurrentRequestsPending );
        }

        _ExecState = NREQ_STATE_PROCESS;
    }
    else
    {
        //
        // Some other error.  Try again
        //

        InterlockedDecrement( (LPLONG) &sm_cRequestsPending );

        Reset();
    }

    return NSTATUS_NEXT;
}

NREQ_STATUS
UL_NATIVE_REQUEST::DoStateProcess(
    VOID
)
/*++

Routine Description:

    The NREQ_PROCESS state.  This state actually calls consumer of the
    NewRequests and IoCompletions.  This state calls the set routines in
    W3CORE.DLL

Arguments:

    None

Return Value:

    NSTATUS_PENDING if async IO pending, else NSTATUS_NEXT

--*/
{
    WP_IDLE_TIMER *         pTimer;

    //
    // Reset idle tick since we're not idle if we're processing
    //

    pTimer = g_pwpContext->QueryIdleTimer();
    if ( pTimer != NULL )
    {
        pTimer->ResetCurrentIdleTick();
    }

    ReferenceWorkerRequest();

    if ( _pvContext == NULL )
    {
        //
        // Extra reference here.  The consumer must call UlAtqResetContext()
        // to finally cleanup.  This complication is brought on by
        // scenarios where non-IO-completions are required to finish a request
        // (example: async ISAPI)
        //

        ReferenceWorkerRequest();

        DBG_ASSERT( g_pfnNewRequest != NULL );

        g_pfnNewRequest( this );
    }
    else
    {
        DBG_ASSERT( g_pfnIoCompletion != NULL );

        g_pfnIoCompletion( _pvContext,
                           _cbAsyncIOData,
                           _dwAsyncIOError,
                           &_Overlapped );
    }

    DereferenceWorkerRequest();

    return NSTATUS_PENDING;
}

NREQ_STATUS
UL_NATIVE_REQUEST::DoStateClientCertificate(
    VOID
)
/*++

Routine Description:

    Handle a completion for receiving a client certificate

Arguments:

    None

Return Value:

    NSTATUS_PENDING if async IO pending, else NSTATUS_NEXT

--*/
{
    ULONG                   Status;
    HTTP_REQUEST    *       pRequest;
    HANDLE                  hAsync;

    DBG_ASSERT( _ExecState == NREQ_STATE_CLIENT_CERT );

    //
    // Is our buffer too small.  If so retry the request synchronously with
    // a bigger buffer
    // Note: STATUS_BUFFER_OVERFLOW is translated to WIN32 Error - ERROR_MORE_DATA

    if ( _dwAsyncIOError == ERROR_MORE_DATA )
    {
        //
        // If buffer is not big enough, HTTP.sys will return only HTTP_SSL_CLIENT_CERT_INFO
        // structure that contains the size of the client certificate
        // The following assert is to assure that HTTP.SYS returns back that
        // HTTP_SSL_CLIENT_CERT_INFO structure and nothing more

        DBG_ASSERT( _cbAsyncIOData == sizeof( HTTP_SSL_CLIENT_CERT_INFO ) );

        //
        // We need to allocate enough memory to contain HTTP_SSL_CLIENT_CERT_INFO
        // and certificate blob
        //
        DWORD dwRequiredSize = _pClientCertInfo->CertEncodedSize +
                              sizeof( HTTP_SSL_CLIENT_CERT_INFO );

        DBG_ASSERT(  dwRequiredSize > _buffClientCertInfo.QuerySize() );

        if ( !_buffClientCertInfo.Resize( dwRequiredSize ) )
        {
            //
            // Funnel the fatal error to the complete
            //

            _dwAsyncIOError = GetLastError();
        }
        else
        {
            //
            // Retry the request for client cert synchronously
            //
            _pClientCertInfo = reinterpret_cast<HTTP_SSL_CLIENT_CERT_INFO *>( _buffClientCertInfo.QueryPtr() );

            hAsync = g_pwpContext->GetAndLockAsyncHandle();

            if ( hAsync != NULL )
            {

                Status = HttpReceiveClientCertificate( hAsync,
                                                       QueryConnectionId(),
                                                       _dwClientCertFlags,
                                                       _pClientCertInfo,
                                                       _buffClientCertInfo.QuerySize(),
                                                       NULL,
                                                       NULL );

            }
            else
            {
                Status = ERROR_INVALID_HANDLE;
            }

            DBG_REQUIRE(SUCCEEDED(g_pwpContext->UnlockAsyncHandle()));

            if ( Status != NO_ERROR )
            {
                DBG_ASSERT( _dwAsyncIOError != ERROR_MORE_DATA );
            }

            _dwAsyncIOError = Status;
            _cbAsyncIOData = dwRequiredSize;

        }
    }

    if ( _dwAsyncIOError == NO_ERROR )
    {
        pRequest = QueryHttpRequest();

        DBG_ASSERT( pRequest->pSslInfo != NULL );
        DBG_ASSERT( pRequest->pSslInfo->pClientCertInfo == NULL );

        pRequest->pSslInfo->pClientCertInfo = _pClientCertInfo;
    }

    //
    // Regardless of what happened, we are no longer processing a client cert
    //

    _ExecState = NREQ_STATE_PROCESS;

    DBG_ASSERT( g_pfnIoCompletion != NULL );

    g_pfnIoCompletion( _pvContext,
                       _cbAsyncIOData,
                       _dwAsyncIOError,
                       &_Overlapped );

    return NSTATUS_PENDING;
}

VOID
UL_NATIVE_REQUEST::ResetContext(
    VOID
)
/*++

Routine Description:

    The implementation of UlAtqResetContext which the consumer of W3DT.DLL
    calls to cleanup the context.

Arguments:

    None

Return Value:

    None

--*/
{
    DereferenceWorkerRequest();
}

VOID
UL_NATIVE_REQUEST::ReferenceWorkerRequest(
    VOID
)
/*++

Routine Description:

    Increment the reference count on the worker request

Arguments:

    None

Return Value:

    None

--*/
{
    LONG cRefs = InterlockedIncrement( &_cRefs );

    //
    // Log the reference ( sm_pTraceLog!=NULL if DBG=1)
    //

    if ( sm_pTraceLog != NULL )
    {
        WriteRefTraceLog( sm_pTraceLog,
                          cRefs,
                          this );
    }
}

VOID
UL_NATIVE_REQUEST::DereferenceWorkerRequest(
    VOID
)
/*++

Routine Description:

    Dereference Request.  This routine will optionally reset the context
    for use for reading the next HTTP request.  Putting the reset code in
    one place (here) handles all the cases where we would want to reset.
    However, there are a few places where we definitely don't want to reset
    (in the case of error where the context will be going away)

    In either case, if the ref count goes to 0, we can delete the object.

Arguments:

    None

Return Value:

    None

--*/
{
    LONG cRefs = InterlockedDecrement( &_cRefs );

    if ( sm_pTraceLog != NULL )
    {
        WriteRefTraceLog( sm_pTraceLog,
                          cRefs,
                          this );
    }

    if ( cRefs == 0 )
    {
        //
        // If 0, we can definitely cleanup, regardless.  This is the error
        // case which is used to cleanup contexts on shutdown (on shutdown,
        // the apppool handle is closed which will error out all pending
        // UlReceiveHttpRequests
        //

        delete this;
    }
    else if ( cRefs == 1 && _ExecState != NREQ_STATE_ERROR )
    {
        //
        // Reset the state machine.  Now we can increment our served count
        //

        InterlockedIncrement( (PLONG) &sm_cRequestsServed );

        //
        // If we have too many outstanding requests, then don't pend
        // another receive.  Keep the request around ready to go
        //

        if ( sm_cRequestsPending > sm_cDesiredPendingRequests * 2 )
        {
            FreeWorkerRequest( this );
        }
        else
        {
            Reset();

            //
            // Re-kickoff the state machine
            //

            DoWork( 0, 0, NULL );
        }
    }
}

VOID
UL_NATIVE_REQUEST::RemoveFromRequestList(
    VOID
)
/*++

Routine Description:

    Remove this UL_NATIVE_REQUEST from the static list of requests.  Main
    purpose of the list is for debugging.

Arguments:

    None

Return Value:

    None

--*/
{
    EnterCriticalSection( &sm_csRequestList );

    RemoveEntryList( &_ListEntry );
    sm_cRequests--;

    LeaveCriticalSection( &sm_csRequestList ); 
}

VOID
UL_NATIVE_REQUEST::AddToRequestList(
    VOID
)
/*++

Routine Description:

    Add this request to the static list of requests.  The main purpose of the
    list is for debugging.

Arguments:

    None

Return Value:

    None

--*/
{
    EnterCriticalSection( &sm_csRequestList );

    sm_cRequests++;
    InsertTailList( &sm_RequestListHead, &_ListEntry );

    LeaveCriticalSection( &sm_csRequestList ); 
}

HRESULT
UL_NATIVE_REQUEST::SendResponse(
    BOOL                    fAsync,
    DWORD                   dwFlags,
    HTTP_RESPONSE *         pResponse,
    HTTP_CACHE_POLICY *     pCachePolicy,
    DWORD                  *pcbSent,
    HTTP_LOG_FIELDS_DATA   *pUlLogData
)
/*++

Routine Description:

    Send an HTTP response thru UL.

Arguments:

    fAsync - TRUE if send is async
    dwFlags - UlSendHttpResponse flags
    pResponse - Pointer to UL_HTTP_RESPONSE
    pCachePolicy - Cache policy
    pcbSent - Receives number of bytes send
    pULLogData - Logging information

Return Value:

    HRESULT (if pending, the return is NO_ERROR)

--*/
{
    ULONG                   Status = NO_ERROR;
    HRESULT                 hr = NO_ERROR;
    HANDLE                  hAsync;

    if ( pcbSent == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    if ( fAsync )
    {
        ReferenceWorkerRequest();
    }

    hAsync = g_pwpContext->GetAndLockAsyncHandle();

    if ( hAsync != NULL )
    {
        Status = HttpSendHttpResponse( hAsync,
                                       QueryRequestId(),
                                       dwFlags,
                                       pResponse,
                                       pCachePolicy,
                                       fAsync ? NULL : pcbSent,
                                       NULL,
                                       0,
                                       fAsync ? &(_Overlapped) : NULL ,
                                       pUlLogData );
    }
    else
    {
        Status = ERROR_INVALID_HANDLE;
    }

    DBG_REQUIRE(SUCCEEDED(g_pwpContext->UnlockAsyncHandle()));

    //
    // If the response is pending, then we return a successful error code.
    // This frees the caller from the ERROR_IO_PENDING checks in common
    // case
    //

    if ( fAsync )
    {
        if ( Status == NO_ERROR )
        {
            Status = ERROR_IO_PENDING;
        }

        DBG_ASSERT( Status != NO_ERROR );

        if ( Status != ERROR_IO_PENDING )
        {
            DereferenceWorkerRequest();
            hr = HRESULT_FROM_WIN32( Status );
        }
    }
    else if ( Status != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Status );
    }

    return hr;
}

HRESULT
UL_NATIVE_REQUEST::SendEntity(
    BOOL                    fAsync,
    DWORD                   dwFlags,
    USHORT                  cChunks,
    HTTP_DATA_CHUNK *       pChunks,
    DWORD                  *pcbSent,
    HTTP_LOG_FIELDS_DATA   *pUlLogData
)
/*++

Routine Description:

    Send an HTTP entity thru UL.

Arguments:

    fAsync - TRUE if send is async
    dwFlags - UlSendHttpResponse flags
    cChunks - Number of chunks in response
    pChunks - Pointer to array of UL_DATA_CHUNKs
    pcbSent - Receives number of bytes sent
    pUlLogData - Log information

Return Value:

    HRESULT (if pending, the return is NO_ERROR)

--*/
{
    ULONG                   Status = NO_ERROR;
    HRESULT                 hr = NO_ERROR;
    HANDLE                  hAsync;

    if ( pcbSent == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    if ( fAsync )
    {
        ReferenceWorkerRequest();
    }

    hAsync = g_pwpContext->GetAndLockAsyncHandle();

    if ( hAsync != NULL )
    {
        Status = HttpSendResponseEntityBody( hAsync,
                                             QueryRequestId(),
                                             dwFlags,
                                             cChunks,
                                             pChunks,
                                             fAsync ? NULL : pcbSent,
                                             NULL,
                                             0,
                                             fAsync ? &(_Overlapped) : NULL,
                                             pUlLogData );
    }
    else
    {
        Status = ERROR_INVALID_HANDLE;
    }

    DBG_REQUIRE(SUCCEEDED(g_pwpContext->UnlockAsyncHandle()));

    //
    // If the send is pending, then we return a successful error code.
    // This frees the caller from the ERROR_IO_PENDING checks in common
    // case
    //

    if ( fAsync )
    {
        if ( Status == NO_ERROR )
        {
            Status = ERROR_IO_PENDING;
        }

        DBG_ASSERT( Status != NO_ERROR );

        if ( Status != ERROR_IO_PENDING )
        {
            DereferenceWorkerRequest();
            hr = HRESULT_FROM_WIN32( Status );
        }
    }
    else if ( Status != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Status );
    }

    return hr;
}

HRESULT
UL_NATIVE_REQUEST::ReceiveEntity(
    BOOL                fAsync,
    DWORD               dwFlags,
    VOID *              pBuffer,
    DWORD               cbBuffer,
    DWORD *             pBytesReceived
)
/*++

Routine Description:

    Receive HTTP entity thru UL.

Arguments:

    fAsync - TRUE if receive is async
    dwFlags - UlSendHttpResponse flags
    pBuffer - A buffer to receive the data
    cbBuffer - The size of the receive buffer
    pBytesReceived - Upon return, the number of bytes
                     copied to the buffer

Return Value:

    HRESULT (if pending, the return is NO_ERROR)

--*/
{
    ULONG                   Status = NO_ERROR;
    HRESULT                 hr = NO_ERROR;
    HANDLE                  hAsync;

    if ( fAsync )
    {
        ReferenceWorkerRequest();
    }

    hAsync = g_pwpContext->GetAndLockAsyncHandle();

    if ( hAsync != NULL )
    {
        Status = HttpReceiveRequestEntityBody( hAsync,
                                               QueryRequestId(),
                                               dwFlags,
                                               pBuffer,
                                               cbBuffer,
                                               fAsync ? NULL : pBytesReceived,
                                               fAsync ? &(_Overlapped) : NULL );
    }
    else
    {
        Status = ERROR_INVALID_HANDLE;
    }

    DBG_REQUIRE(SUCCEEDED(g_pwpContext->UnlockAsyncHandle()));

    //
    // If the receive is pending, then we return a successful error code.
    // This frees the caller from the ERROR_IO_PENDING checks in common
    // case
    //

    if ( fAsync )
    {
        if ( Status == NO_ERROR )
        {
            Status = ERROR_IO_PENDING;
        }

        DBG_ASSERT( Status != NO_ERROR );

        if ( Status != ERROR_IO_PENDING )
        {
            DereferenceWorkerRequest();
            hr = HRESULT_FROM_WIN32( Status );
        }
    }
    else if ( Status != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Status );
    }

    return hr;
}

HRESULT
UL_NATIVE_REQUEST::ReceiveClientCertificate(
    BOOL                        fAsync,
    BOOL                        fDoCertMap,
    HTTP_SSL_CLIENT_CERT_INFO **ppClientCertInfo
)
/*++

Routine Description:

    Receive a client certificate

Arguments:

    fAsync - TRUE if receive should be async
    fDoCertMap - TRUE if we should map client certificate to token
    ppClientCertInfo - Set to point to client cert info on success

Return Value:

    HRESULT (if pending, the return is NO_ERROR)

--*/
{
    ULONG                   Status;
    HTTP_REQUEST *          pHttpRequest;
    HRESULT                 hr = NO_ERROR;
    HANDLE                  hAsync;

    if ( ppClientCertInfo == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    *ppClientCertInfo = NULL;

    //
    // If this request is not SSL enabled, then getting the client cert is
    // a no-go
    //

    pHttpRequest = QueryHttpRequest();
    DBG_ASSERT( pHttpRequest != NULL );

    if ( pHttpRequest->pSslInfo == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
    }

    //
    // Do we already have a cert associated with this request?
    //

    DBG_ASSERT( pHttpRequest->pSslInfo != NULL );

    if ( pHttpRequest->pSslInfo->pClientCertInfo != NULL )
    {
        if ( fAsync )
        {
            //
            // BUGBUG:  Probably should support this case.  And if I do, then
            //          need to fake a completion!
            //

            DBG_ASSERT( FALSE );
            return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        }

        *ppClientCertInfo = pHttpRequest->pSslInfo->pClientCertInfo;

        return NO_ERROR;
    }

    //
    // OK.  We'll have to ask UL to renegotiate.  We must be processing
    // a request
    //

    DBG_ASSERT( _ExecState == NREQ_STATE_PROCESS );

    if ( !_buffClientCertInfo.Resize( INITIAL_CERT_INFO_SIZE ) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    ZeroMemory( _buffClientCertInfo.QueryPtr(), INITIAL_CERT_INFO_SIZE );

    _pClientCertInfo = reinterpret_cast<HTTP_SSL_CLIENT_CERT_INFO *>( _buffClientCertInfo.QueryPtr() );

    //
    // Are we cert mapping?
    //

    if ( fDoCertMap )
    {
        _dwClientCertFlags = HTTP_RECEIVE_CLIENT_CERT_FLAG_MAP;
    }
    else
    {
        _dwClientCertFlags = 0;
    }

    //
    // If we're doing this async, then manage state such that
    // DoStateClientCert gets the completion
    //

    if ( fAsync )
    {
        ReferenceWorkerRequest();
        _ExecState = NREQ_STATE_CLIENT_CERT;
    }

    hAsync = g_pwpContext->GetAndLockAsyncHandle();

    if ( hAsync != NULL )
    {
        Status = HttpReceiveClientCertificate( hAsync,
                                               QueryConnectionId(),
                                               _dwClientCertFlags,
                                               _pClientCertInfo,
                                               _buffClientCertInfo.QuerySize(),
                                               NULL,
                                               fAsync ? &_Overlapped : NULL );
    }
    else
    {
        Status = ERROR_INVALID_HANDLE;
    }

    DBG_REQUIRE(SUCCEEDED(g_pwpContext->UnlockAsyncHandle()));

    if ( fAsync )
    {
        if ( Status == NO_ERROR )
        {
            Status = ERROR_IO_PENDING;
        }

        DBG_ASSERT( Status != NO_ERROR );

        if ( Status != ERROR_IO_PENDING )
        {
            DereferenceWorkerRequest();
            hr = HRESULT_FROM_WIN32( Status );
            _ExecState = NREQ_STATE_PROCESS;
        }
    }
    else if ( Status != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Status );
    }

    return hr;
}

//static
HRESULT
UL_NATIVE_REQUEST::Initialize(
    VOID
)
/*++

Routine Description:

    Static initialization of UL_NATIVE_REQUESTs

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ALLOC_CACHE_CONFIGURATION       acConfig;
    HKEY                            hKey;
    BOOL                            fRet;
    HRESULT                         hr;

    //
    // Setup allocation lookaside
    //

    acConfig.nConcurrency = 1;
    acConfig.nThreshold = 100;
    acConfig.cbSize = sizeof( UL_NATIVE_REQUEST );

    DBG_ASSERT( sm_pachNativeRequests == NULL );

    sm_pachNativeRequests = new ALLOC_CACHE_HANDLER( "UL_NATIVE_REQUEST",
                                                     &acConfig );
    if ( sm_pachNativeRequests == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    fRet = InitializeCriticalSectionAndSpinCount( &sm_csRequestList,
                                                  UL_NATIVE_REQUEST_CS_SPINS );
    if ( !fRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        delete sm_pachNativeRequests;
        sm_pachNativeRequests = NULL;
        
        return hr;
    }

    InitializeListHead( &sm_RequestListHead );

#ifdef _WIN64
    sm_FreeList.Next = NULL;
#else
    InitializeSListHead( &sm_FreeList );
#endif

    sm_cRequestsServed          = 0;
    sm_cRestart                 = 0;
    sm_RestartMsgSent           = 0;
    sm_cRequestsPending         = 0;

    //
    // If the number of pending HttpReceiveHttpRequest is configured, use
    // that rather than the default value
    //
    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      REGISTRY_KEY_W3SVC_PERFORMANCE_KEY_W,
                      0,
                      KEY_READ,
                      &hKey ) == ERROR_SUCCESS)
    {
        DWORD  cbBuffer = sizeof(DWORD);
        DWORD  dwType;

        if (RegQueryValueEx( hKey,
                             L"ReceiveRequestsPending",
                             NULL,
                             &dwType,
                             (LPBYTE)&sm_cDesiredPendingRequests,
                             &cbBuffer ) != NO_ERROR ||
            dwType != REG_DWORD)
        {
            sm_cDesiredPendingRequests  = DESIRED_PENDING_REQUESTS;
        }

        RegCloseKey( hKey );
    }
    else
    {
        sm_cDesiredPendingRequests  = DESIRED_PENDING_REQUESTS;
    }

    sm_fAddingRequests          = FALSE;

#if DBG
    sm_pTraceLog = CreateRefTraceLog( 2000, 0 );
#endif

    return NO_ERROR;
}

//static
VOID
UL_NATIVE_REQUEST::StopListening(
    VOID
)
/*++

Routine Description:

    Shutdown the apppool in preparation for shutdown

Arguments:

    None

Return Value:

    None

--*/
{
    HANDLE              hAsync;

    hAsync = g_pwpContext->GetAndLockAsyncHandle();

    if ( hAsync != NULL )
    {
        //
        // This will cause us to cancel all pending HttpReceiveHttpRequest calls
        // and not get any more but other operations will still go on
        //
        HttpShutdownAppPool( hAsync );
    }

    DBG_REQUIRE(SUCCEEDED(g_pwpContext->UnlockAsyncHandle()));

}

//static
VOID
UL_NATIVE_REQUEST::Terminate(
    VOID
)
/*++

Routine Description:

    Static termination

Arguments:

    None

Return Value:

    None

--*/
{
    if ( sm_pTraceLog != NULL )
    {
        DestroyRefTraceLog( sm_pTraceLog );
        sm_pTraceLog = NULL;
    }

    DeleteCriticalSection( &sm_csRequestList );

    if ( sm_pachNativeRequests != NULL )
    {
        delete sm_pachNativeRequests;
        sm_pachNativeRequests = NULL;
    }
}

//static
HRESULT
UL_NATIVE_REQUEST::AddPendingRequests(
    DWORD                   cRequests
)
/*++

Routine Description:

    Pools calls to UlReceiveHttpRequest by creating new UL_NATIVE_REQUESTs
    and kicking off their state machines

Arguments:

    cRequests - Number of requests to read

Return Value:

    HRESULT

--*/
{
    UL_NATIVE_REQUEST *         pRequest;

    if ( sm_fAddingRequests )
    {
        return NO_ERROR;
    }

    if ( InterlockedCompareExchange( (LPLONG) &sm_fAddingRequests,
                                     TRUE,
                                     FALSE ) == FALSE )
    {
        for ( DWORD i = 0; i < cRequests; i++ )
        {
            pRequest = AllocateWorkerRequest();
            if ( pRequest == NULL )
            {
                return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
            }

            pRequest->DoWork( 0, 0, NULL );
        }

        sm_fAddingRequests = FALSE;
    }

    return NO_ERROR;
}

//static
HRESULT
UL_NATIVE_REQUEST::ReleaseAllWorkerRequests(
    VOID
)
/*++

Routine Description:

    Wait for all outstanding UL_NATIVE_REQUESTs to drain

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    UL_NATIVE_REQUEST *         pRequest;
    
    //
    // First clear out any of our freelist items
    //
    
    for ( ; ; )
    {
        pRequest = PopFreeList();
        if ( pRequest == NULL )
        {
            break;
        }
        
        DBG_ASSERT( pRequest != NULL );
        DBG_ASSERT( pRequest->CheckSignature() );
        
        //
        // Free it up
        //
        
        pRequest->DereferenceWorkerRequest();
    }
    
    //
    // Now, wait for all requests to be destructed
    //
    
    while ( sm_cRequests )
    {
        Sleep( 1000 );

        DBGPRINTF(( DBG_CONTEXT,
                    "UL_NATIVE_REQUEST::ReleaseAllWorkerRequests waiting for %d requests to drain.\n",
                    sm_cRequests ));
    }

    return NO_ERROR;
}

//static
VOID
UL_NATIVE_REQUEST::FreeWorkerRequest(
    UL_NATIVE_REQUEST *             pWorkerRequest
)
/*++

Routine Description:

    Free worker request

Arguments:

    pNativeRequest - Worker request to retrieve

Return Value:

    None

--*/
{
    DBG_ASSERT( pWorkerRequest != NULL );
    
    if ( sm_cFreeRequests > sm_cMaxFreeRequests )
    {
        //
        // Don't keep too many around.  Just free this guy
        // by dereferencing one more time
        //
        
        pWorkerRequest->DereferenceWorkerRequest();
    }
    else
    {
        pWorkerRequest->Reset();
       
        PushFreeList( pWorkerRequest );
        
        sm_cFreeRequests++;
    }
}

//static
UL_NATIVE_REQUEST *
UL_NATIVE_REQUEST::AllocateWorkerRequest(
    VOID
)
/*++

Routine Description:

    Allocate a new request

Arguments:

    None

Return Value:

    Pointer to new request or NULL if error

--*/
{
    UL_NATIVE_REQUEST *     pRequest;
    
    if ( sm_cFreeRequests )
    {
        pRequest = PopFreeList();
        if ( pRequest != NULL )
        {
            DBG_ASSERT( pRequest->CheckSignature() );
            
            sm_cFreeRequests--;

            return pRequest;
        }
    }
    
    //
    // If we got to here, we have to allocate a new request
    //
    
    pRequest = new UL_NATIVE_REQUEST;
    
    return pRequest;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\testdt\wpconfig.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     WpConfig.cxx

   Abstract:
     Module implementing the Worker Process Configuration Data structure.
     WP_CONFIG object encapsulates configuration supplied from the commandline
     as well as remotely supplied from the admin process.

   Author:

       Murali R. Krishnan    ( MuraliK )     21-Oct-1998

   Environment:
       Win32 - User Mode

   Project:
       IIS Worker Process
--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "precomp.hxx"

/************************************************************
 Launch Parameters for W3WP:

 Private: ( one's only WAS uses )

 -r <N>  ( Number of requests to recycle wp after )
 -t <N>  ( Number of idle milliseconds to shutdown the WP after )
 -a <guid>   ( look for WAS and register with this namepipe  )
 -c      ( Use binary centralized logging )

 Public: ( one's that can be used by command line launch ( must have -Debug )

 -Debug         ( tells us that the user is trying to do the command line launch
                  for debugging purposes has the side affect of not registering with WAS )
 -d <URL List>  ( overrides the default url list of * port 80 with a specific list )
 -s <N>         ( indicates the site that we should assume when listening to these urls ( default is site 1 ) )


 Both: ( one's used by either command line or was )
 
 -ap <AppPoolName>  ( AppPool Name that the wp is serving )
 
 No one:  ( were originally here, but are not being used and are being disabled by my change )

 -l     ( log errors that stop the worker process into the event log )
 -ld    ( disables logging of errors of the worker process to the event log )
 -ad    ( don't look for WAS nor register with it )
 -p     ( tells COR to add IceCAP instrumentation )

 URL List looks like:
    {http[s]://IP:port/URL | http[s]://hostname:port/URL | http[s]://hostname:port:IP/URL}+
     with space as separator
     eg: -d http://localhost:80/  => listen for all HTTP requests on port 80
     eg: -d http://localhost:80/ http://localhost:81/  => listen on port 80 & 81
     eg: -d http://foo:80:111.11.ll.111/ => listen on port 80 to request to 111.11.11.111 with foo as a header.
 ************************************************************/

//
//  While the above shows all the usages for the w3wp command line parameters,
//  the print statment will only show the usage for the actual parameters that 
//  users can use.
//

const WCHAR g_rgwchUsage[] =
L"Usage: %ws [options] \n"
L"\n"
L"\t-debug \n"
L"\t\t This option is required for launching from the command line.\n"
L"\t\t If not provided the app pool name, default url, and site id \n"
L"\t\t will be defaulted to \n"
L"\t\t\t AppPoolName = StandAloneAppPool  \n"
L"\t\t\t URL list    = http://*:80/ \n"
L"\t\t\t Site Id     = 1 \n"
L"\n"
L"\t-ap <Application Pool Name>  \n"
L"\t\t Indicates the application pool name\n"
L"\t\t that will queue requests for the\n"
L"\t\t worker process.  No other worker processes \n"
L"\t\t with this name can be running at the \n"
L"\t\t same time as this one \n"
L"\n"
L"\t-d <URL List> \n"
L"\t\t Indicates the urls to listen to. \n"
L"\t\t Examples: \n"
L"\t\t\t http://*:80/ \n"
L"\t\t\t http://HostString:80/ \n"
L"\t\t\t http://111.11.111.11:80:111.11.111.11/ \n"
L"\t\t\t http://HostString:80:111.11.111.11/ \n"
L"\n"
L"\t-s <#> \n"
L"\t\t Which site are the urls provided associated with. \n"
L"\t\t The site number is used to access data from the metabase \n"
L"\t\t for processing the requests. \n"
;

/************************************************************
 *     Member functions of WP_CONFIG
 ************************************************************/

WP_CONFIG::WP_CONFIG(void)
    : _pwszAppPoolName     (AP_NAME),
      _fSetupControlChannel(FALSE),
      _fLogErrorsToEventLog(FALSE),
      _fRegisterWithWAS    (TRUE),
      _RestartCount    (0),
      _pwszNamedPipeId (NULL),
      _IdleTime        (0),
      _SiteId          (0),
      _fDoCentralBinaryLogging (FALSE)
{
    lstrcpy( _pwszProgram,  L"WP");
}

WP_CONFIG::~WP_CONFIG()
{
    _ulcc.Cleanup();

    delete[] _pwszNamedPipeId;
    _pwszNamedPipeId = NULL;
}


void
WP_CONFIG::PrintUsage() const
{
    wprintf( g_rgwchUsage, _pwszProgram );
}

/********************************************************************++

Routine Description:
    Parses the command line to read in all configuration supplied.
    This function updates the state variables inside WP_CONFIG for use
    in starting up the Worker process.

    See comment at beginning of file for details on the arguments that can be supplied

Arguments:
    argc - count of arguments supplied
    argv - pointer to strings containing the arguments.

Returns:
    Boolean

--********************************************************************/
BOOL
WP_CONFIG::ParseCommandLine(int argc, PWSTR  argv[])
{
    BOOL    fRet = TRUE;
    int     iArg;
    BOOL    fAppPoolNameFound = FALSE;
    BOOL    fUrlsFound = FALSE;

    lstrcpyn( _pwszProgram, argv[0], sizeof _pwszProgram / sizeof _pwszProgram[0]);

    if ( argc < 2)
    {
        DBGPRINTF((DBG_CONTEXT, "Invalid number of parameters (%d)\n", argc));
        PrintUsage();
        return (FALSE);
    }

    for( iArg = 1; iArg < argc; iArg++)
    {
        // get out of here if we all ready found an error.
        if ( fRet == FALSE )
        {
            break;
        }

        if ( (argv[iArg][0] == L'-') || (argv[iArg][0] == L'/'))
        {
            switch (argv[iArg][1])
            {

                case L's': case L'S':

                    if ( argv[iArg][2] != '\0' )
                    {
                        DBGPRINTF((DBG_CONTEXT, "invalid argument %S\n", argv[iArg]));
                        fRet = FALSE;
                    }
                    else
                    {
                        _SiteId = wcstoul(argv[++iArg], NULL, 0);

                        if (_SiteId == 0)
                        {
                            DBGPRINTF((DBG_CONTEXT, "Invalid site id %ws\n", argv[iArg]));
                            fRet = FALSE;
                        }
                        else
                        {
                            DBGPRINTF((DBG_CONTEXT, "Site Id is %lu\n", _SiteId));
                        }
                    }

                break;

                case L'd': case L'D':

                    if ( _wcsicmp(&(argv[iArg][1]), L"Debug") == 0 )
                    {
                        _fSetupControlChannel = TRUE;
                    }
                    else if ( argv[iArg][2] != '\0' )
                    {
                        DBGPRINTF((DBG_CONTEXT, "invalid argument %S\n", argv[iArg]));
                        fRet = FALSE;
                    }
                    else
                    {
                        fUrlsFound = TRUE;

                        // need to determine if the string is just d or if it is debug here.
                       
                        iArg++;

                        while ( (iArg < argc) &&
                                (argv[iArg][0] != L'-') && (argv[iArg][0] != L'/'))
                        {
                            if ( !InsertURLIntoList(argv[iArg]) )
                            {
                                DBGPRINTF((DBG_CONTEXT, "Invalid URL: %ws\n", argv[iArg]));
                            }

                            iArg++;
                        }

                        iArg--;
                    }

                break;

                case L'a': case L'A':

                    if ( ((L'p' == argv[iArg][2]) || (L'P' == argv[iArg][2])) &&
                          (L'\0' == argv[iArg][3] ))
                    {
                        //
                        // get the app pool name
                        //
                        iArg++;

                        _pwszAppPoolName = argv[iArg];

                        fAppPoolNameFound = TRUE;
                    }
                    else if ( L'\0' != argv[iArg][2] )
                    {
                        DBGPRINTF((DBG_CONTEXT, "invalid parameter passed in '%S' \n", argv[iArg]));
                        fRet = FALSE;
                    }
                    else
                    {
                        // -a NamedPipeId
                        iArg++;

                        _pwszNamedPipeId = new WCHAR[wcslen(argv[iArg]) + 1];
                        if ( NULL == _pwszNamedPipeId )
                        {
                            DBGPRINTF((DBG_CONTEXT, "Failed allocation for named pipe name."));
                            fRet = FALSE;
                        }
                        wcscpy(_pwszNamedPipeId, argv[iArg]);
                        DBGPRINTF((DBG_CONTEXT, "NamedPipe Id, %S\n", _pwszNamedPipeId));
                    }
                break;

                case L'r': case L'R':

                    if ( argv[iArg][2] != '\0' )
                    {
                        DBGPRINTF((DBG_CONTEXT, "invalid argument %S\n", argv[iArg]));
                        fRet = FALSE;
                    }
                    else
                    {
                        _RestartCount = wcstoul(argv[++iArg], NULL, 0);

                        if (_RestartCount == 0)
                        {
                            DBGPRINTF((DBG_CONTEXT, "Invalid maximum requests %ws\n", argv[iArg]));
                            fRet = FALSE;
                        }
                        else
                        {
                            DBGPRINTF((DBG_CONTEXT, "Maximum requests is %lu\n", _RestartCount));
                        }
                    }
                break;

                case L't': case L'T':

                    if ( argv[iArg][2] != '\0' )
                    {
                        DBGPRINTF((DBG_CONTEXT, "invalid argument %S\n", argv[iArg]));
                        fRet = FALSE;
                    }
                    else
                    {
                        _IdleTime  = wcstoul(argv[++iArg], NULL, 0);

                        if (_IdleTime == 0)
                        {
                            DBGPRINTF((DBG_CONTEXT, "Invalid idle time %ws\n", argv[iArg]));
                            fRet = FALSE;
                        }
                        else
                        {
                            DBGPRINTF((DBG_CONTEXT, "The idle time value is %lu\n", _IdleTime));
                        }
                    }
                break;

                case L'c': case L'C':
                    if ( argv[iArg][2] != '\0' )
                    {
                        DBGPRINTF((DBG_CONTEXT, "invalid argument %S\n", argv[iArg]));
                        fRet = FALSE;
                    }
                    else
                    {
                        _fDoCentralBinaryLogging = TRUE;
                    }
                break;

                default:
                case L'?':
                    fRet = FALSE;
                break;
            } // switch
        }
        else
        {
            DBG_ASSERT ( !L"Argument passed in that does not start with '-' or '/'" );
            fRet = FALSE;
            break;
        }
    }

    if ( fRet )
    {
        // if we are still on the right track, do some parameter verification.

        // In command line launch mode we need to do some checks.
        if ( _fSetupControlChannel )
        {
            // Don't register with WAS.
            _fRegisterWithWAS = FALSE;

            if ( _SiteId == 0 )
            {
                // default the site id to 1.
                _SiteId = 1;
            }

            if ( !fUrlsFound )
            {
                if ( !InsertURLIntoList(L"http://*:80/") )
                {
                    DBGPRINTF((DBG_CONTEXT, "Error adding default url\n"));
                    fRet = FALSE;
                }
            }

            if ( !fAppPoolNameFound )
            {
                _pwszAppPoolName = L"StandAloneAppPool";
            }

            if ( _pwszNamedPipeId )
            {
                DBGPRINTF((DBG_CONTEXT, "Name pipe id can not be passed when in debugging mode\n"));
                fRet = FALSE;
            }

            if ( _RestartCount != 0 )
            {
                DBGPRINTF((DBG_CONTEXT, "Restart count can not be passed when in debugging mode\n"));
                fRet = FALSE;
            }

            if ( _IdleTime != 0 )
            {
                DBGPRINTF((DBG_CONTEXT, "Idle time can not be passed when in debugging mode\n"));
                fRet = FALSE;
            }
            
        }
        else
        {
            if ( _SiteId != 0 )
            {
                DBGPRINTF((DBG_CONTEXT, "Site id can not be passed when not in debugging mode\n"));
                fRet = FALSE;
            }

            if ( fUrlsFound )
            {
                DBGPRINTF((DBG_CONTEXT, "Urls can not be passed in when not in debugging mode\n"));
                fRet = FALSE;
            }  

            if ( !fAppPoolNameFound )
            {
                DBGPRINTF((DBG_CONTEXT, "No app pool was passed and not in debugging mode\n"));
                fRet = FALSE;
            }       
            
            if ( _pwszNamedPipeId == NULL )
            {
                DBGPRINTF((DBG_CONTEXT, "Named pipe id needs to be passed in when not in debugging mode\n"));
                fRet = FALSE;
            }

            if ( _fRegisterWithWAS == FALSE )
            {
                DBGPRINTF((DBG_CONTEXT, "We needs to register with WAS in when not in debugging mode\n"));
                fRet = FALSE;
            }

        }

    }

    if (!fRet)
    {
        PrintUsage();
    }

    return ( fRet);

} // WP_CONFIG::ParseCommandLine()


/********************************************************************++

Routine Description:
    Sets up the control channel for processing requests. It uses
    the configuration parameters supplied for initializing the
    UL_CONTROL_CHANNEL.

Arguments:

Returns:
    Win32 error

--********************************************************************/

ULONG
WP_CONFIG::SetupControlChannel(void)
{

    //
    // Setup a control channel for our local use now. Used mainly for
    // the purpose of debugging.
    // In general control channel work is done by the AdminProces.
    //

    return _ulcc.Initialize( _mszURLList, _pwszAppPoolName, _SiteId );

} // WP_CONFIG::SetupControlChannel()

/********************************************************************++
--********************************************************************/

WP_CONFIG::InsertURLIntoList( LPCWSTR pwszURL  )
{
    LPCWSTR pwszOriginalURL = pwszURL;

    //
    // Minimum length: 11 (http://*:1/). Begins with http
    //

    if ( ( wcslen(pwszURL) < 11 ) || ( 0 != _wcsnicmp(pwszURL, L"http", 4)) )
    {
        return false;
    }

    pwszURL += 4;

    //
    // https
    //

    if ((L's' == *pwszURL) || (L'S' == *pwszURL))
    {
        pwszURL++;
    }

    //
    // ://
    //

    if ( (L':' != *pwszURL) || (L'/' != *(pwszURL+1)) || (L'/' != *(pwszURL+2)) )
    {
        return false;
    }

    pwszURL += 3;

    //
    // Skip host name or Ip Address
    //

    while ( (0 != *pwszURL) && ( L':' != *pwszURL))
    {
        pwszURL++;
    }

    //
    // Check port # exists
    //

    if (0 == *pwszURL)
    {
        return false;
    }

    //
    // Check port number is numeric
    //

    pwszURL++;

    while ( (0 != *pwszURL) && ( L'/' != *pwszURL) )
    {
        if (( L'0' > *pwszURL) || ( L'9' < *pwszURL))
        {
            return false;
        }

        pwszURL++;
    }

    //
    // Check / after port number exists
    //

    if (0 == *pwszURL)
    {
        return false;
    }

    //
    // URL is good.
    //

    IF_DEBUG( TRACE)
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Inserting URL '%ws' into Config Group List\n",
                    pwszOriginalURL
                    ));
    }
    return ( TRUE == _mszURLList.Append( pwszOriginalURL));

} // WP_CONFIG::InsertURLIntoList()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\testdt\wpcontext.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     wpcontext.cxx

   Abstract:
     This module defines the member functions of the WP_CONTEXT.
     The WP_CONTEXT object embodies an instance of the Worker process
     object. It contains a completion port, pool of worker threads,
     pool of worker requests, a data channel for the worker process, etc.
     It is responsible for setting up the context for processing requests
     and handles delegating the processing of requests.

     NYI: In the future we should be able to run WP_CONTEXT object as
     a COM+ object and be run standalone using a hosting exe.

   Author:

       Murali R. Krishnan    ( MuraliK )     17-Nov-1998

   Project:

       IIS Worker Process

--*/

#include "precomp.hxx"
# include "RwpFunctions.hxx"

VOID
WINAPI
IdleTimeCheckCallback(
    VOID *              pvContext,
    BOOLEAN           
)
/*++

Routine Description:

    Callback function provided for TimerQueue.  Called every minute

Arguments:

    pvContext - Context

Return Value:

    None

--*/
{
    WP_IDLE_TIMER * pTimer = (WP_IDLE_TIMER *)pvContext;

    DBGPRINTF(( DBG_CONTEXT,
                "Check Idle Time Callback.\n" ));

    DBG_ASSERT( pTimer );

    pTimer->IncrementTick();
}

WP_IDLE_TIMER::WP_IDLE_TIMER(
    ULONG               IdleTime
)
:   _BusySignal(0),
    _CurrentIdleTick(0),
    _IdleTime(IdleTime),
    _hIdleTimeExpiredTimer((HANDLE)NULL)
{
}

WP_IDLE_TIMER::~WP_IDLE_TIMER(
    VOID
)
{
    //
    // Cancel IdleTimeExpiredTimer
    //

    if (_hIdleTimeExpiredTimer)
    {
        StopTimer();
    }
}

HRESULT
WP_IDLE_TIMER::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize the idle timer.  Setup NT thread pool to callback every minute

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    BOOL                fRet;
    HRESULT             hr = NO_ERROR;

    //
    // IdleTime is stored as in minutes, 1 min = 60*1000 milliseconds.
    //

    fRet = CreateTimerQueueTimer(
            &_hIdleTimeExpiredTimer,                // handle to the Timer
            NULL,                                   // Default Timer Queue
            IdleTimeCheckCallback,                  // Callback function
            this,                                   // Context.
            60000,                                  // Due Time
            60000,                                  // Signal every minute
            WT_EXECUTEINIOTHREAD
            );

    if ( !fRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );

        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to create idle timer.  hr = %x\n",
                    hr ));
    }

    return hr;
}

VOID
WP_IDLE_TIMER::IncrementTick(
    VOID
)
/*++

Routine Description:

    Check every minute whether we've been idle long enough.  If so,
    tell WAS

Arguments:

    None

Return Value:

    None

--*/
{
    ULONG BusySignal = InterlockedExchange( (PLONG)&_BusySignal, 0 );

    if ( !BusySignal && !UL_NATIVE_REQUEST::QueryCurrentRequests() )
    {
        InterlockedIncrement( (PLONG)&_CurrentIdleTick );

        if ( _CurrentIdleTick >= _IdleTime )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Idle time reached.  Send shutdown message to WAS.\n" ));

            g_pwpContext->SendMsgToAdminProcess( IPM_WP_IDLE_TIME_REACHED );
        }
    }
    else
    {
        _CurrentIdleTick = 0;
    }
}

VOID
WP_IDLE_TIMER::StopTimer(
    VOID
)
/*++

Routine Description:

    Remove timer

Arguments:

    None

Return Value:

    None

--*/
{
    BOOL fRet;

    DBG_ASSERT( _hIdleTimeExpiredTimer );

    fRet = DeleteTimerQueueTimer( NULL,
                                  _hIdleTimeExpiredTimer,
                                  (HANDLE)-1 );

    if ( !fRet )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to delete Timer queue.  Win32 = %ld\n",
                    GetLastError() ));
    }

    _hIdleTimeExpiredTimer = NULL;
}


VOID
OverlappedCompletionRoutine(
    DWORD               dwErrorCode,
    DWORD               dwNumberOfBytesTransfered,
    LPOVERLAPPED        lpOverlapped
)
/*++

Routine Description:

    Main completion routine called on completions for UL app pool handle.

Arguments:

    dwErrorCode - Win32 Error code of completion
    dwNumberOfBytesTransfered - Bytes completed
    lpOverlapped - Overlapped structure passed on async operation

Return Value:

    None

--*/
{
    ASYNC_CONTEXT *         pContext = NULL;

    //
    // Use the overlapped to get at the async context
    //

    if (lpOverlapped != NULL)
    {
        pContext = CONTAINING_RECORD( lpOverlapped,
                                      ASYNC_CONTEXT,
                                      _Overlapped );

    DBG_ASSERT( pContext != NULL );

    //
    // Call virtual DoWork() to actually handle the completion
    // (context can represent a UL_NATIVE_REQUEST or a UL_DISCONNECT)
    //

    pContext->DoWork( dwNumberOfBytesTransfered,
                      dwErrorCode,
                      lpOverlapped );
    }
    else
    {
        DBG_ASSERT( lpOverlapped != NULL );
    }
}

WP_CONTEXT::WP_CONTEXT(
    VOID
) : _hDoneEvent( NULL ),
    _pConfigInfo( NULL ),
    _fShutdown( FALSE ),
    _pIdleTimer( NULL ),
    _fHealthy( TRUE )
{
}

WP_CONTEXT::~WP_CONTEXT(
    VOID
)
{
}

HRESULT
WP_CONTEXT::Initialize(
    INT             argc,
    LPWSTR *        argv
)
/*++

Routine Description:

    Initialize global context

Arguments:

    argc - Command argument count
    argv - Command arguments

Return Value:

    HRESULT

--*/
{
    LPCWSTR     pwszAppPoolName;
    HRESULT     hr = NO_ERROR;
    DWORD       dwErr = NO_ERROR;
    BOOL        fAppPoolInit = FALSE;
    BOOL        fNativeRequestInit = FALSE;
    BOOL        fDisconnectInit = FALSE;
    BOOL        fIpmInit = FALSE;
    BOOL        fWpRecyclerInit = FALSE;

    _pConfigInfo = new WP_CONFIG();
    if ( _pConfigInfo == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto Finished;
    }

    //
    // Validate the parameters passed into executable
    //

    if ( !_pConfigInfo->ParseCommandLine( argc, argv ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Invalid command line arguments.\n" ));

        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        goto Finished;
    }

    //
    // If we need to establish the control channel to run
    // without w3svc interaction do it now.
    //

    if ( _pConfigInfo->QuerySetupControlChannel() )
    {
        dwErr = _pConfigInfo->SetupControlChannel();
        if ( dwErr != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( dwErr );

            DBGPRINTF(( DBG_CONTEXT,
                        "SetupControlChannel failed with 0x%8x\n",
                        hr ));

            goto Finished;
        }
    }


    pwszAppPoolName = _pConfigInfo->QueryAppPoolName();

    //
    // Initialize UL AppPool
    //

    hr = _ulAppPool.Initialize( pwszAppPoolName );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to initialize AppPool.  hr = %x\n",
                    hr ));
        goto Finished;
    }
    SetEnvironmentVariableW( L"APP_POOL_ID",
                             pwszAppPoolName );
    fAppPoolInit = TRUE;

    //
    // Initialize UL_NATIVE_REQUEST globals
    //

    hr = UL_NATIVE_REQUEST::Initialize();
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to initialize UL_NATIVE_REQUEST globals.  hr = %x\n",
                    hr ));
        goto Finished;
    }
    fNativeRequestInit = TRUE;

    //
    // Initialize UL_DISCONNECTs
    //

    hr = UL_DISCONNECT_CONTEXT::Initialize();
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to initialize UL_DISCONNECT_CONTEXT globals.  hr = %x\n",
                    hr ));
        goto Finished;
    }
    fDisconnectInit = TRUE;

    DBGPRINTF(( DBG_CONTEXT,
                "AppPool '%ws' initialized\n",
                pwszAppPoolName ));

    //
    // Initialize of the shutdown event
    //

    _hDoneEvent = IIS_CREATE_EVENT( "WP_CONTEXT::_hDoneEvent",
                                    &_hDoneEvent,
                                    TRUE,
                                    FALSE );

    if ( _hDoneEvent == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );

        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to create shutdown event.  hr = %x\n",
                    hr ));
        goto Finished;
    }

    //
    // Setup all async completions on data channel handle to go thru W3TP
    //

    if (!ThreadPoolBindIoCompletionCallback( _ulAppPool.QueryAndLockHandle(),
                                             OverlappedCompletionRoutine,
                                             0 ))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to associate handle with thread pool.  hr = %x\n",
                    hr ));
        _ulAppPool.UnlockHandle();
        goto Finished;
    }

    hr = _ulAppPool.UnlockHandle();
    if ( FAILED( hr ) )
    {
        goto Finished;
    }


    //
    // Need to init this first as we may start getting callbacks as soon
    // as we init IPM
    //
    hr = WP_RECYCLER::Initialize();

    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to initialize WP_RECYCLER.  hr = %x\n",
                    hr ));
        goto Finished;
    }
    fWpRecyclerInit = TRUE;

    //
    // Register with WAS
    //

       //
	// Startup rogue behavior - may be we don't want to register with WAS
	//

  	if (RwpBehaviorExhibited = RWP_Startup_Behavior(&hr))
		return hr;  // TODO: DO WE NEED TO DO goto Finished HERE?
	
    if ( _pConfigInfo->QueryRegisterWithWAS() )
    {
        hr = _WpIpm.Initialize( this );
        if ( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Failed to initialize IPM.  hr = %x\n",
                        hr ));
            goto Finished;
        }
        fIpmInit = TRUE;

    }

    //
    // Set the window title to something nice when we're running
    // under the debugger.
    //

    if ( IsDebuggerPresent() )
    {
        STRU strTitle;
        WCHAR buffer[sizeof("w3wp[1234567890] - ")];
        WCHAR buffer2[sizeof(" - mm/dd hh:mm:ss")];

        wsprintf( buffer, L"w3wp[%lu] - ", GetCurrentProcessId() );
        hr = strTitle.Append( buffer );

        if (SUCCEEDED(hr))
        {
            hr = strTitle.Append( _pConfigInfo->QueryAppPoolName() );
        }

        if (SUCCEEDED(hr))
        {
            LARGE_INTEGER sysTime;
            LARGE_INTEGER localTime;
            TIME_FIELDS fields;

            NtQuerySystemTime( &sysTime );
            RtlSystemTimeToLocalTime( &sysTime, &localTime );
            RtlTimeToTimeFields( &localTime, &fields );

            wsprintf(
                buffer2,
                L" - %02u/%02u %02u:%02u:%02u",
                fields.Month,
                fields.Day,
                fields.Hour,
                fields.Minute,
                fields.Second
                );

            hr = strTitle.Append( buffer2 );
        }

        if (SUCCEEDED(hr))
        {
            SetConsoleTitleW( strTitle.QueryStr() );
        }
    }

    return S_OK;

Finished:

    //
    // Terminate recycler object
    // Dependency warning: _WpIpm must still be valid
    //
    if ( fWpRecyclerInit )
    {
        WP_RECYCLER::Terminate();
    }

    if ( fIpmInit )
    {
        _WpIpm.Terminate();
    }

    if ( _hDoneEvent != NULL )
    {
        CloseHandle( _hDoneEvent );
        _hDoneEvent = NULL;
    }

    if ( fDisconnectInit )
    {
        UL_DISCONNECT_CONTEXT::Terminate();
    }

    if ( fNativeRequestInit )
    {
        UL_NATIVE_REQUEST::Terminate();
    }

    if ( fAppPoolInit )
    {
        _ulAppPool.Cleanup();
    }

    if ( _pConfigInfo != NULL )
    {
        delete _pConfigInfo;
        _pConfigInfo = NULL;
    }

    return hr;
}

HRESULT
WP_CONTEXT::Start(
    VOID
)
/*++

Routine Description:

    Start listening for requests by creating UL_NATIVE_REQUESTs

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HRESULT                 hr = NO_ERROR;

    //
    // Create a pool of worker requests
    // NYI: Allow the worker requests limit to be configurable.
    //

    UL_NATIVE_REQUEST::SetRestartCount( _pConfigInfo->QueryRestartCount() );

    hr = UL_NATIVE_REQUEST::AddPendingRequests(
                                  (_pConfigInfo->QueryRestartCount() == 0 ||
                                   (_pConfigInfo->QueryRestartCount() >=
                                    NUM_INITIAL_REQUEST_POOL_ITEMS)) ?
                                    NUM_INITIAL_REQUEST_POOL_ITEMS :
                                    _pConfigInfo->QueryRestartCount()
                                  );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to add pending UL_NATIVE_REQUESTs.  hr = %x\n",
                    hr ));
        goto Finished;
    }


    //
    // If an idle time is set, then set idle timer
    //

    if ( _pConfigInfo->QueryIdleTime() != 0 )
    {
        _pIdleTimer = new WP_IDLE_TIMER( _pConfigInfo->QueryIdleTime() );
        if ( _pIdleTimer )
        {
            hr = _pIdleTimer->Initialize();
        }
        else
        {
            hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        }

        if ( FAILED( hr ) )
        {
            goto Finished;
        }
    }

    return S_OK;
Finished:

    if ( _pIdleTimer != NULL )
    {
        delete _pIdleTimer;
        _pIdleTimer = NULL;
    }

    return hr;
}

BOOL
WP_CONTEXT::IndicateShutdown(
    BOOL fImmediate
)
/*++

Routine Description:

    Set shutdown event which allows StartListen to wake up and
    begin cleanup

Arguments:

    reason - Reason for shutdown

Return Value:

    BOOL

--*/
{
    if ( !InterlockedCompareExchange((LONG *)&_fShutdown, TRUE, FALSE ) )
    {
        _fImmediateShutdown = fImmediate;

        return SetEvent( _hDoneEvent );
    }
    else
    {
        return TRUE;
    }
}

VOID
WP_CONTEXT::Terminate(
    VOID
)
/*++

Routine Description:

    Cleanup WP_CONTEXT data structures

Arguments:

    None

Return Value:

    None

--*/
{
    HRESULT             hr = NO_ERROR;

    //
    // Cleanup async contexts
    //

    UL_DISCONNECT_CONTEXT::Terminate();

    UL_NATIVE_REQUEST::Terminate();

    if ( _pIdleTimer != NULL )
    {
        delete _pIdleTimer;
        _pIdleTimer = NULL;
    }

    //
    // Stop IPM
    //

    if ( _pConfigInfo->QueryRegisterWithWAS() )
    {
        hr = _WpIpm.Terminate();
        if ( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Failed to shutdown IPM.  hr = %x\n",
                        hr ));
        }
    }
    
    //
    // Cleanup the Shutdown Event.
    //

    DBG_ASSERT( _hDoneEvent != NULL );

    CloseHandle( _hDoneEvent );
    _hDoneEvent = NULL;


    //
    // Terminate procerr recycler.
    // Dependency warning: _WpIpm must still be valid
    //

    WP_RECYCLER::Terminate();

    //
    // Cleanup config object
    //

    delete _pConfigInfo;
    _pConfigInfo = NULL;
}

HRESULT
WP_CONTEXT::CleanupOutstandingRequests(
    VOID
)
/*++

Routine Description:

    Cleanup WP_CONTEXT data structures

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HRESULT             hr = NO_ERROR;

    //
    // If we want to shut-down immediately, then close the AppPool handle now
    //
    if (_fImmediateShutdown)
    {
        _ulAppPool.Cleanup();
    }

    //
    // Wait for requests to drain away.  If they were pending
    // UlReceiveHttpRequest, they will complete with error.  If they were
    // already processing, then we wait for them to finish
    //

    hr = UL_NATIVE_REQUEST::ReleaseAllWorkerRequests();
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error draining UL_NATIVE_REQUESTs.  hr = %x\n",
                    hr ));

        return hr;
    }

    //
    // If we want to shut-down gracefully, then close the AppPool handle now
    //
    if (!_fImmediateShutdown)
    {
        _ulAppPool.Cleanup();
    }

    //
    // Wait for outstanding disconnect requests (i.e. UlWaitForDisconnect)
    // to drain
    //

    UL_DISCONNECT_CONTEXT::WaitForOutstandingDisconnects();

    //
    // Send WAS final counter data before shutting down
    //

    hr = _WpIpm.HandleCounterRequest();

    return hr;
}

VOID
WP_CONTEXT::RunMainThreadLoop(
    VOID
)
/*++

Routine Description:

    Wait for the shutdown event

Arguments:

    None

Return Value:

    None

--*/
{
    do
    {
        DWORD result;

        result = WaitForSingleObject( _hDoneEvent, INFINITE );

        DBG_ASSERT( result == WAIT_OBJECT_0 );

    } while ( !_fShutdown );

}

HANDLE
WP_CONTEXT::GetAndLockAsyncHandle(
    VOID
)
/*++

Routine Description:

    Read locks and returns the async handle.

Arguments:

    None

Return Value:

    HANDLE

--*/
{
    return _ulAppPool.QueryAndLockHandle();
}


HRESULT
WP_CONTEXT::UnlockAsyncHandle(
    VOID
)
/*++

Routine Description:

    Read unlocks the async handle.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    return _ulAppPool.UnlockHandle();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\testdt\wpipm.cxx ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    wpipm.cxx

Abstract:

    Contains the WPIPM class that handles communication with
    the admin service. WPIPM responds to pings, and tells
    the process when to shut down.
    
Author:

    Michael Courage (MCourage)  22-Feb-1999

Revision History:

--*/


#include <precomp.hxx>
#include "dbgutil.h"
#include "wpipm.hxx"

#include "RwpFunctions.hxx"
extern PFN_ULATQ_COLLECT_PERF_COUNTERS g_pfnCollectCounters;

/**
 *
 *   Routine Description:
 *
 *   Initializes WPIPM.
 *   
 *   Arguments:
 *
 *   pWpContext - pointer to the wp context (so we can tell it to shutdown)
 *   
 *   Return Value:
 *
 *   HRESULT
 */
HRESULT
WP_IPM::Initialize(
    WP_CONTEXT * pWpContext
    )
{

    HRESULT hr = S_OK;

    m_pWpContext = pWpContext;

    DWORD dwId = GetCurrentProcessId();

    //
    // create pipe
    //
    hr = IPM_MESSAGE_PIPE::CreateIpmMessagePipe(this,
                                       pWpContext->QueryConfig()->QueryNamedPipeId(),
                                       FALSE, // not server side
                                       NULL, // security descriptor
                                       &m_pPipe);
    if (FAILED(hr))
    {
        goto exit;
    }

    //
    // Send the real pid over the pipe
    //
    if(!RWP_IPM_BadParamTest(RWP_IPM_OP_GETPID, &hr, m_pPipe))
    {
        hr = m_pPipe->WriteMessage(IPM_OP_GETPID,
                                                    sizeof(dwId),
                                                    &dwId);
    }
    
    if (FAILED(hr))
    {
        goto exit;
    }

    hr =  S_OK;
exit:
    if (FAILED(hr))
    {
        Terminate();
    }
    
    return hr;
}


/**
 *
 * Routine Description:
 *
 *   Terminates WPIPM.
 *
 *   If the message pipe is open this function will disconnect it
 *   and wait for the pipe's disconnection callback.
 *   
 *  Arguments:
 *
 *   None.
 *   
 *  Return Value:
 *
 *   HRESULT
 */
HRESULT
WP_IPM::Terminate(
    VOID
    )
{
    if (m_pPipe) 
    {
        m_pPipe->DestroyIpmMessagePipe();

        // pipe deletes itself
        m_pPipe = NULL;
    }

    m_pWpContext = NULL;

    return S_OK;
}


/**
 *
 *
 *  Routine Description:
 *
 *   This is a callback from the message pipe that means
 *   the pipe has received a message.
 *   
 *   We decode the message and respond appropriately.
 *   
 *   Arguments:
 *
 *   pPipeMessage - the message that we received
 *   
 *   Return Value:
 *
 *   HRESULT
 *
 */
VOID
WP_IPM::AcceptMessage(
    IN const IPM_MESSAGE * pPipeMessage
    )
{
    HRESULT hr = NO_ERROR;
    BOOL fRet = FALSE;
    
    switch (pPipeMessage->GetOpcode()) 
    {
    case IPM_OP_PING:
        //
        // Pings must go through the same mechanism that requests go through
        // to verify that requests are being picked off of the completion port
        //
        fRet = ThreadPoolPostCompletion(0, HandlePing, (LPOVERLAPPED)this);
        if (FALSE == fRet)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DBGPRINTF((DBG_CONTEXT, "Posting completion for ping handling failed"));
            break;
        }

        break;

    case IPM_OP_SHUTDOWN:
        hr = HandleShutdown(
                *( reinterpret_cast<const BOOL *>( pPipeMessage->GetData() ) )
                );
        break;

    case IPM_OP_REQUEST_COUNTERS:
        hr = HandleCounterRequest();
        break;

    case IPM_OP_PERIODIC_PROCESS_RESTART_PERIOD_IN_MINUTES:

        DBG_ASSERT( pPipeMessage->GetData() != NULL );
        hr = WP_RECYCLER::StartTimeBased(
                *( reinterpret_cast<const DWORD *>( pPipeMessage->GetData() ) )
                );
        hr = NO_ERROR;
        break;
        
    case IPM_OP_PERIODIC_PROCESS_RESTART_MEMORY_USAGE_IN_KB:
    {
        
        DBG_ASSERT( pPipeMessage->GetData() != NULL );
        // there are 2 DWORDS sent with memory based recycling
        // first is Max Virtual Memory, second is Max Private Bytes
        
        DWORD dwMaxVirtualMemoryKbUsage = 
                *( reinterpret_cast<const DWORD *>( pPipeMessage->GetData() ) ); 
        DWORD dwMaxPrivateBytesKbUsage = 
                *( reinterpret_cast<const DWORD *>( pPipeMessage->GetData() ) + 1 ); 
        
        hr = WP_RECYCLER::StartMemoryBased(
                dwMaxVirtualMemoryKbUsage,
                dwMaxPrivateBytesKbUsage );
        hr = NO_ERROR;
     
        break;
    }
    case IPM_OP_PERIODIC_PROCESS_RESTART_SCHEDULE:
      
        DBG_ASSERT( pPipeMessage->GetData() != NULL );
        hr = WP_RECYCLER::StartScheduleBased(
                ( reinterpret_cast<const WCHAR *>( pPipeMessage->GetData() ) )
                );
        hr = NO_ERROR;
        break;

    default:
        DBG_ASSERT(FALSE);
        hr = E_FAIL;
        break;
    }

    return;
}


/**
 *
 * Routine Description:
 *
 *   This is a callback from the message pipe that means
 *   the pipe has been connected and is ready for use.
 *   
 * Arguments:
 *
 *   None.
 *   
 * Return Value:
 *
 *   VOID
 */
VOID
WP_IPM::PipeConnected(
    VOID
    )
{
    return;
}


/**
 *
 * Routine Description:
 *
 *   This is a callback from the message pipe that means
 *   the pipe has been disconnected and you won't be receiving
 *   any more messages.
 *   
 *   Tells WPIPM::Terminate that it's ok to exit now.
 *   
 * Arguments:
 *
 *   hr - the error code associated with the pipe disconnection
 *   
 * Return Value:
 *
 *   VOID
 */
VOID
WP_IPM::PipeDisconnected(
    IN HRESULT hr
    )
{
    if (FAILED(hr))
    {
        DBGPRINTF( (DBG_CONTEXT, "PipeDisconnected with hr ( %d).\n", hr));
    }
    
	//
	// All sorts of miscreant shutdown behaviors (for testing)
	//
    	if (RwpBehaviorExhibited = RWP_Shutdown_Behavior(&hr))
        	return;
    
    //
    // If the pipe disappears out from under us, WAS has probably orphaned
    // us, initiate fast shutdown of this worker process.
    //

    if (!m_pWpContext->IsInShutdown() &&
        hr != HRESULT_FROM_WIN32(ERROR_OPERATION_ABORTED) &&
        IsDebuggerPresent())
    {
        DBG_ASSERT( !"w3wp.exe is getting orphaned" );
    }

    m_pWpContext->IndicateShutdown( TRUE );

    return;
}


/**
 *
 * Routine Description:
 *
 *   This is a callback from the message pipe that means
 *   that the pipe received an invalid message.
 *   Therefore, we signal to shutdown.
 *   
 * Arguments:
 *
 *   VOID
 *   
 * Return Value:
 *
 *   VOID
 */
VOID
WP_IPM::PipeMessageInvalid(
    VOID
    )
{
    return PipeDisconnected(HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
}


/**
 *
 *  Routine Description:
 *
 *   Handles the ping message. Sends the ping response message.
 *   
 *   Arguments:
 *
 *   None.
 *   
 *  Return Value:
 *
 *   HRESULT
 */
//static
VOID
WP_IPM::HandlePing(
    DWORD,
    DWORD dwNumberOfBytesTransferred,
    LPOVERLAPPED lpOverlapped
    )
{
    HRESULT hr = NO_ERROR;
    
    if (0 != dwNumberOfBytesTransferred)
    {
        DBG_ASSERT(0 == dwNumberOfBytesTransferred);
        return;
    }

    DBG_ASSERT(NULL != lpOverlapped);

    WP_IPM * pThis = (WP_IPM*) lpOverlapped;

    DBG_ASSERT(pThis->m_pPipe);

    DBGPRINTF( (DBG_CONTEXT, "Handle Ping\n\n"));

    // If we're supposed to do this test, just do it here. Don't care about result
    RWP_IPM_BadParamTest(RWP_IPM_OP_INVALID, &hr, pThis->m_pPipe);

    RWP_IPM_BadParamTest(RWP_IPM_OP_PING_REPLY, &hr, pThis->m_pPipe);

    // Even if we're testing this opcode, just do regular ping response so the app pool
    // doesn't get shut down by WAS
    if (RWP_NO_MISBEHAVE == RWP_Ping_Behavior(&hr, pThis->m_pPipe))
    {
        hr = pThis->m_pPipe->WriteMessage(
                    IPM_OP_PING_REPLY,  // ping reply opcode
                    0,                  // no data to send
                    NULL                // pointer to no data
                    );

        if ( FAILED ( hr ) )
        {
            DBGPRINTF( (DBG_CONTEXT, "Failed to respond to ping\n\n"));

            goto exit;
        }
    }

    //
    // if we are not healthy then we need to to ask WAS to 
    // shut us down.
    //
    if ( !( g_pwpContext->GetUnhealthy()))
    {
        DBGPRINTF( (DBG_CONTEXT, "Requesting shutdown due to isapi reporting unhealthiness\n\n"));

        hr = pThis->SendMsgToAdminProcess( IPM_WP_RESTART_ISAPI_REQUESTED_RECYCLE );

        if ( FAILED ( hr ) )
        {
            DBGPRINTF( (DBG_CONTEXT, "Failed telling WAS to shut us down\n\n"));

            goto exit;
        }

    }

exit:

    return;
}

/**
 *
 *  Routine Description:
 *
 *   Handles the counter request message. 
 *   
 *   Arguments:
 *
 *   None.
 *   
 *  Return Value:
 *
 *   HRESULT
 */
HRESULT
WP_IPM::HandleCounterRequest(
    VOID
    )
{
    DBGPRINTF( (DBG_CONTEXT, "Handle Counter Request\n\n"));

    HRESULT hr;
    PBYTE pCounterData;
    DWORD dwCounterData;

    DBG_ASSERT ( m_pPipe );

    if (FAILED(hr = g_pfnCollectCounters(&pCounterData, &dwCounterData)))
    {
        DBGPRINTF( (DBG_CONTEXT, "Didn't collect counters\n\n"));
        return hr;
    }
    
    if(!RWP_IPM_BadParamTest(RWP_IPM_OP_SEND_COUNTERS, &hr, m_pPipe))
    {
        // If we're not testing this opcode, just do regular valid call
        hr =  m_pPipe->WriteMessage(IPM_OP_SEND_COUNTERS,  // ping reply opcode
                                     dwCounterData,         // no data to send
                                     pCounterData);         // pointer to no data
    }
    
    return hr;
}

/**
 *
 * Routine Description: 
 *
 *
 *   Handles the shutdown message. Shuts down the process
 *   
 *  Arguments:
 *
 *   None.
 *  
 *  Return Value:
 *
 *   HRESULT
 */
HRESULT
WP_IPM::HandleShutdown(
    BOOL fDoImmediate
    )
{
    HRESULT hr = S_OK;

    DBGPRINTF( (DBG_CONTEXT, "Handle ******************** Shutdown\n\n"));

	//
	// All sorts of miscreant shutdown behaviors (for testing)
	//
	if (RwpBehaviorExhibited = RWP_Shutdown_Behavior(&hr))
		return (hr);
	
    m_pWpContext->IndicateShutdown( fDoImmediate );

    return hr;
}



/**
 *
 *  Routine Description:
 *
 *   Sends the message to indicate the worker process has either finished
 *   initializing or has failed to initialize.
 *   
 *  Arguments:
 *
 *   HRESULT indicating success/failure of initialization
 *   
 *  Return Value:
 *
 *   HRESULT
 */
HRESULT
WP_IPM::SendInitCompleteMessage(
    HRESULT hrToSend
    )
{
    HRESULT hr;
    
    if ( m_pPipe )
    {

        if(!RWP_IPM_BadParamTest(RWP_IPM_OP_HRESULT, &hr, m_pPipe))
        {
            // If we're not testing this opcode, just do regular valid call
            hr = m_pPipe->WriteMessage(
                       IPM_OP_HRESULT,                      // opcode
                       sizeof( hrToSend ),                  // data length
                       reinterpret_cast<BYTE*>( &hrToSend ) // pointer to data
                       );
        }
        
        return hr;
    }

    // if the pipe did not exist then we started up
    // without the IPM, probably we are attempting
    // to run without WAS support. ( from the cmd line )
    
    return S_OK;
}


/**
 *
 *  Routine Description:
 *
 *   Sends the message to indicate the worker process has reach certain state.
 *   Main use is in shutdown.  See IPM_WP_SHUTDOWN_MSG for reasons.
 *   
 *   Arguments:
 *
 *   None.
 *   
 *  Return Value:
 *
 *   HRESULT
 */
HRESULT
WP_IPM::SendMsgToAdminProcess(
    IPM_WP_SHUTDOWN_MSG reason
    )
{
    HRESULT hr = S_OK;

    if (m_pPipe)
    {
        //
        // All sorts of miscreant process rotation behaviors (for testing)
        //
        if (RwpBehaviorExhibited = RWP_Rotation_Behavior(&hr, m_pPipe))
            return (hr);

        if(!RWP_IPM_BadParamTest(RWP_IPM_OP_WORKER_REQUESTS_SHUTDOWN, &hr, m_pPipe))
        {
            // If we're not testing this opcode, just do regular valid call
            hr = m_pPipe->WriteMessage(
                   IPM_OP_WORKER_REQUESTS_SHUTDOWN, // sends message indicate shutdown
                   sizeof(reason),                   // no data to send
                   (BYTE *)&reason                   // pointer to no data
                   );
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\testwp\makefile.inc ===
$(O)\testwp.res: testwp.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\testdt\wprecycler.cxx ===
/*++

   Copyright    (c)    1998   Microsoft Corporation

   Module  Name :
     wprecycler.cxx

   Abstract:
     Implementation of WP_RECYCLER.  Object handles worker process recycling
         - Memory based recycling
         - Schedule based recycling
         - Elapsed Time based recycling
         - Processed Request Count based recycling

   Dependencies:
         g_pwpContext is used by WP_RECYCLER to be able to send messages
    
 
   Author:
     Jaroslav Dunajsky         (JaroslaD)         07-Dec-2000

   Environment:
     Win32 - User Mode

   Project:
     W3DT.DLL
--*/

#include "precomp.hxx"
#include "wprecycler.hxx"

#define ONE_DAY_IN_MILLISECONDS (1000 * 60 * 60 * 24)

//
// Static variables
//

CRITICAL_SECTION  WP_RECYCLER::sm_CritSec;

//
// Static variables for Memory based recycling
//

HANDLE WP_RECYCLER::sm_hTimerForMemoryBased = NULL;
BOOL   WP_RECYCLER::sm_fIsStartedMemoryBased = FALSE;
SIZE_T WP_RECYCLER::sm_MaxValueForVirtualMemoryBasedInKB = 0;
SIZE_T WP_RECYCLER::sm_MaxValueForPrivateBytesBasedInKB = 0;
DWORD  WP_RECYCLER::sm_CurrentPID = NULL;
BUFFER WP_RECYCLER::sm_buffSystemProcessInfo = NULL;
//
// arbitrary value for default SystemProcessInfoBuffer
// it will be resized when needed
//
DWORD  WP_RECYCLER::sm_cbSystemProcessInfo =  
                sizeof(SYSTEM_PROCESS_INFORMATION) * 50; 

//
// Static variables for Time based recycling
//

HANDLE WP_RECYCLER::sm_hTimerForTimeBased = NULL;
BOOL   WP_RECYCLER::sm_fIsStartedTimeBased = FALSE;

//
// Static variables for Schedule based recycling
//

HANDLE WP_RECYCLER::sm_hTimerQueueForScheduleBased = NULL;
BOOL   WP_RECYCLER::sm_fIsStartedScheduleBased = FALSE;

//
// Static variables for Request based recycling
//

BOOL   WP_RECYCLER::sm_fIsStartedRequestBased = FALSE;
DWORD  WP_RECYCLER::sm_dwMaxValueForRequestBased = 0;
LONG   WP_RECYCLER::sm_RecyclingMsgSent = 0;

BOOL   WP_RECYCLER::sm_fCritSecInit = FALSE;


//
// Static methods for Schedule based recycling
//


//static
HRESULT
WP_RECYCLER::StartScheduleBased(
    IN  const WCHAR * pwszScheduleTimes
)

/*++

Routine Description:

    Start schedule based recycling
    
    
Arguments:

    pwszScheduleTimes - MULTISZ array of time information
                        <time>\0<time>\0\0
                        time is of military format hh:mm 
                        (hh>=0 && hh<=23)
                        (mm>=0 && hh<=59)
    
Return Value:

    HRESULT

--*/

{
    HRESULT     hr   = E_FAIL;
    BOOL        fRet = FALSE;
    const WCHAR *     pwszCurrentChar = pwszScheduleTimes;

    HANDLE      hTimer;

    WORD        wHours = 0;
    WORD        wMinutes = 0;
    WORD        wDigitCount = 0;

    SYSTEMTIME      SystemTime;
    FILETIME        FileTime; 
    FILETIME        CurrentFileTime; 
    ULARGE_INTEGER  largeintCurrentTime;
    ULARGE_INTEGER  largeintTime;
    DWORD           dwDueTime = 0;

    DBG_ASSERT(TRUE == sm_fCritSecInit);

    EnterCriticalSection( &WP_RECYCLER::sm_CritSec );

    IF_DEBUG( WPRECYCLER )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "WP_RECYCLER::StartScheduleBased()\n"));
    }
    
    DBG_ASSERT( pwszScheduleTimes != NULL );

    //
    // If scheduler based recycling has been running already
    // terminate it before restarting with new settings
    //
    
    if ( WP_RECYCLER::sm_fIsStartedScheduleBased )
    {
        WP_RECYCLER::TerminateScheduleBased();
    }


    WP_RECYCLER::sm_hTimerQueueForScheduleBased = CreateTimerQueue();

    if ( WP_RECYCLER::sm_hTimerQueueForScheduleBased == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failed;
    }

    //
    // Gets current time
    //
    
    GetLocalTime( &SystemTime );
    SystemTimeToFileTime(   &SystemTime, 
                            &CurrentFileTime );
    memcpy( &largeintCurrentTime, 
            &CurrentFileTime, 
            sizeof( ULARGE_INTEGER ) );
    

    //
    // empty string in MULTISZ indicates the end of MULTISZ
    //

    while ( *pwszCurrentChar != '\0' )
    {


        //
        // Skip white spaces
        //
        
        while ( iswspace( (wint_t) *pwszCurrentChar ) )
        {
            pwszCurrentChar++;
        }

        //
        // Start of the time info
        // Expect military format hh:mm
        //

        //
        // Process hours (up to 2 digits is valid)
        //
        
        wHours = 0;
        wDigitCount = 0;
        while ( iswdigit( *pwszCurrentChar ) )
        {
            wDigitCount++;
            wHours = 10 * wHours + (*pwszCurrentChar - '0');
            pwszCurrentChar++;
        }

        if ( wDigitCount > 2  ||
             ( wHours > 23 ) )
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
            goto Failed;
        }

        //
        // Hours - minutes separator
        // Be liberal - any character that is not a digit or '\0' is OK
        // 

        if ( *pwszCurrentChar == '\0' )
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
            goto Failed;
        }

        pwszCurrentChar++;
        
        //
        // Process minutes (must be exactly 2 digits)
        //

        wMinutes = 0;
        wDigitCount = 0;
        while ( iswdigit( (wint_t) *pwszCurrentChar ) )
        {
            wDigitCount++;
            wMinutes = 10 * wMinutes + (*pwszCurrentChar - '0');
            pwszCurrentChar++;
        }

        if ( ( wDigitCount != 2 ) ||
             ( wMinutes > 59 ) )
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
            goto Failed;
        }
        
        //
        // Skip white spaces
        //
        
        while ( iswspace( (wint_t)*pwszCurrentChar ) )
        {
            pwszCurrentChar++;
        }

        //
        // Check for terminating zero
        //

        if ( *pwszCurrentChar != '\0' )
        {
            //
            // Extra characters in the time string
            //

            hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
            goto Failed;
        }

        pwszCurrentChar++;

        // 
        // Convert Hours and Minutes info
        //

        SystemTime.wHour = wHours;
        SystemTime.wMinute = wMinutes;
        SystemTime.wSecond = 0;
        SystemTime.wMilliseconds = 0;

        SystemTimeToFileTime(   &SystemTime, 
                                &FileTime );
        memcpy( &largeintTime, 
                &FileTime, 
                sizeof(ULARGE_INTEGER) );

        //
        // Issue 12/21/2000 jaroslad: 
        // This method of setting absolute time with CreateTimerQueueTimer
        // is bad since instead of setting absolute time the relative time is 
        // calculated and used for timer. 
        // This approach fails badly if someone changes machine
        // time. Other Api that enables setting abolute time must be used for proper 
        // implementation

        // 
        // Get Due Time in milliseconds
        //
        
        dwDueTime = static_cast<DWORD>(
                     ( largeintTime.QuadPart - largeintCurrentTime.QuadPart )/ 10000);

        if ( largeintTime.QuadPart < largeintCurrentTime.QuadPart)
        {
            dwDueTime = ONE_DAY_IN_MILLISECONDS - static_cast<DWORD>(
                     ( largeintCurrentTime.QuadPart - largeintTime.QuadPart )/ 10000);
        }
        else
        {
            dwDueTime = static_cast<DWORD>(
                     ( largeintTime.QuadPart - largeintCurrentTime.QuadPart )/ 10000);
        }
        
        if ( dwDueTime == 0 )
        {
            //
            // this event is to be scheduled for the next day
            // one day has 1000 * 60 * 60 * 24 of (100-nanosecond intervals)
            //
            dwDueTime += ONE_DAY_IN_MILLISECONDS;
        }

        //
        // Schedule event for specified time, repeating once a day
        //
        IF_DEBUG( WPRECYCLER )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Schedule recycling for %d:%d (in %d milliseconds)\n", 
                        (int) wHours,
                        (int) wMinutes,
                        dwDueTime));
        }

        
        fRet = CreateTimerQueueTimer( 
                    &hTimer,
                    WP_RECYCLER::sm_hTimerQueueForScheduleBased,
                    WP_RECYCLER::TimerCallbackForScheduleBased,
                    NULL,
                    dwDueTime,
                    // repeat daily (interval in milliseconds)
                    ONE_DAY_IN_MILLISECONDS,
                    WT_EXECUTELONGFUNCTION );
        if ( !fRet )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Failed;
        }

        //
        // hTimer will not be stored
        // sm_hTimerQueueForScheduleBased is going to be used for cleanup 
        // DeleteTimerQueueEx() should be able to correctly delete all timers 
        // in the queue
        //
        
    }
    WP_RECYCLER::sm_fIsStartedScheduleBased = TRUE;
    LeaveCriticalSection( &WP_RECYCLER::sm_CritSec );

    return S_OK;
    
Failed:
    WP_RECYCLER::TerminateScheduleBased();
    DBG_ASSERT( FAILED( hr ) );

    IF_DEBUG( WPRECYCLER )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "WP_RECYCLER::StartScheduleBased() failed with error hr=0x%x\n",
                    hr ));
    }
    LeaveCriticalSection( &WP_RECYCLER::sm_CritSec );
    
    return hr;
}

//static
VOID
WP_RECYCLER::TerminateScheduleBased(
    VOID
)
/*++

Routine Description:

    Stops schedule based recycling 
    Performs cleanup

Note:
    It is safe to call this method for cleanup if Start failed
    
Arguments:

    NONE
    
Return Value:

    VOID

--*/

{
    DBG_ASSERT(TRUE == sm_fCritSecInit);

    EnterCriticalSection( &WP_RECYCLER::sm_CritSec );
    
    if( WP_RECYCLER::sm_hTimerQueueForScheduleBased != NULL )
    {
        if ( !DeleteTimerQueueEx( 
                            WP_RECYCLER::sm_hTimerQueueForScheduleBased,
                            INVALID_HANDLE_VALUE /* wait for callbacks to complete */ 
                            ) ) 
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "failed to call DeleteTimerQueueEx(): hr=0x%x\n",
                        HRESULT_FROM_WIN32(GetLastError()) ));
        }                    
        WP_RECYCLER::sm_hTimerQueueForScheduleBased = NULL;
    }

    WP_RECYCLER::sm_fIsStartedScheduleBased = FALSE;
   
    LeaveCriticalSection( &WP_RECYCLER::sm_CritSec );

    return;
}

//static
VOID
WINAPI
WP_RECYCLER::TimerCallbackForScheduleBased(
     PVOID,      
     BOOLEAN                 
)

/*++

Routine Description:

    Timer callback for Schedule based recycling   
    It is passed to CreateTimerQueueTimer()

    Routine will inform WAS that process is ready to be recycled
    because scheduled time has been reached
    
Arguments:

    see the description of WAITORTIMERCALLBACK type in MSDN

    
Return Value:

    none

--*/


{
    DBG_ASSERT( WP_RECYCLER::sm_fIsStartedScheduleBased );

    IF_DEBUG( WPRECYCLER )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "WP_RECYCLER::TimerCallbackForScheduleBased()"
                    " - tell WAS to recycle\n" ));
    }
    //
    // Indicate to WAS that we are ready for recycling
    //

    WP_RECYCLER::SendRecyclingMsg( IPM_WP_RESTART_SCHEDULED_TIME_REACHED );
}


//
// Static methods for Memory based recycling
//


//static
HRESULT
WP_RECYCLER::StartMemoryBased(
    IN  DWORD dwMaxVirtualMemoryUsageInKB,
    IN  DWORD dwMaxPrivateBytesUsageInKB
)
/*++

Routine Description:

    Start virtual memory usage based recycling. 
    
    
Arguments:

    dwMaxVirtualMemoryUsageInKB - If usage of virtual memory reaches this value 
                                  worker process is ready for recycling

Note:

    VM usage will be checked periodically. See the value of internal constant 
    CHECK_MEMORY_TIME_PERIOD
                                  
    
Return Value:

    HRESULT

--*/


{
    HRESULT     hr   = E_FAIL;
    BOOL        fRet = FALSE;

    DBG_ASSERT(TRUE == sm_fCritSecInit);
   
    EnterCriticalSection( &WP_RECYCLER::sm_CritSec );

    IF_DEBUG( WPRECYCLER )
    {
   
        DBGPRINTF(( DBG_CONTEXT,
                    "WP_RECYCLER::StartMemoryBased(VM:%d kB, Private Bytes:%d kB)\n",
                    dwMaxVirtualMemoryUsageInKB,
                    dwMaxPrivateBytesUsageInKB));
    }

  
    //
    // If time based recycling has been running already
    // terminate it before restarting with new settings
    //
    
    if ( WP_RECYCLER::sm_fIsStartedMemoryBased == TRUE )
    {
        WP_RECYCLER::TerminateMemoryBased();
    }

    
    if ( dwMaxVirtualMemoryUsageInKB  == 0 && dwMaxPrivateBytesUsageInKB == 0 )
    {
        //
        // 0 means not to run memory recycling
        //
        hr = S_OK;
        goto succeeded;
    }

    fRet = CreateTimerQueueTimer( &WP_RECYCLER::sm_hTimerForMemoryBased,
                                  NULL,
                                  WP_RECYCLER::TimerCallbackForMemoryBased,
                                  NULL,
                                  CHECK_MEMORY_TIME_PERIOD,
                                  CHECK_MEMORY_TIME_PERIOD,
                                  WT_EXECUTELONGFUNCTION );
    if ( !fRet )
    {
        WP_RECYCLER::sm_hTimerForMemoryBased = NULL;
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto failed;
    }

    //
    // Get current process handle
    // It will be used for NtQueryInformationProcess()
    // in the timer callback
    // there is no error to check for and handle doesn't need to be closed
    // on cleanup
    //
    
    sm_CurrentPID = GetCurrentProcessId();
    
    sm_MaxValueForVirtualMemoryBasedInKB = dwMaxVirtualMemoryUsageInKB;
    sm_MaxValueForPrivateBytesBasedInKB =  dwMaxPrivateBytesUsageInKB;
    
    WP_RECYCLER::sm_fIsStartedMemoryBased = TRUE;

succeeded:
    LeaveCriticalSection( &WP_RECYCLER::sm_CritSec );

    return S_OK;
    
failed:
    DBG_ASSERT( FAILED( hr ) );
    WP_RECYCLER::TerminateMemoryBased();

    IF_DEBUG( WPRECYCLER )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "WP_RECYCLER::StartMemoryBased() failed with error hr=0x%x\n",
                    hr ));
    }

    LeaveCriticalSection( &WP_RECYCLER::sm_CritSec );

    return hr;
}

//static
VOID
WP_RECYCLER::TerminateMemoryBased(
    VOID
)
/*++

Routine Description:

    Stops virtual memory usage based recycling 
    Performs cleanup

Note:
    It is safe to call this method for cleanup if Start failed
    
Arguments:

    NONE
    
Return Value:

    VOID  
    
--*/

{
    DBG_ASSERT(TRUE == sm_fCritSecInit);
    
    EnterCriticalSection( &WP_RECYCLER::sm_CritSec );

    if ( WP_RECYCLER::sm_hTimerForMemoryBased != NULL )
    {
        if ( !DeleteTimerQueueTimer(   
                            NULL,
                            WP_RECYCLER::sm_hTimerForMemoryBased,
                            INVALID_HANDLE_VALUE  /* wait for callbacks to complete */
                            ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "failed to call DeleteTimerQueueTimer(): hr=0x%x\n",
                        HRESULT_FROM_WIN32(GetLastError()) ));
        }                                                              
        WP_RECYCLER::sm_hTimerForMemoryBased = NULL;
    }

    sm_fIsStartedMemoryBased = FALSE;
    
    LeaveCriticalSection( &WP_RECYCLER::sm_CritSec );
    return;

}

//static
VOID
WINAPI
WP_RECYCLER::TimerCallbackForMemoryBased(
    PVOID,
    BOOLEAN                
)
/*++

Routine Description:

    Timer callback for Elapsed time based recycling   
    This Callback is passed to CreateTimerQueueTimer()

    Virtual memory and Private Bytes usage will be checked and 
    if limit has been reached then routine will inform WAS 
    that process is ready to be recycled
    
Arguments:

    see description of WAITORTIMERCALLBACK type in MSDN

    
Return Value:

    none

--*/


{
    NTSTATUS  Status = 0;
    PSYSTEM_PROCESS_INFORMATION pProcessInfo = NULL;

    DBG_ASSERT( WP_RECYCLER::sm_fIsStartedMemoryBased );

    

    //
    // Keep trying larger buffers until we get all the information
    // Note: There seems to be no easier way to get PrivateBytes counter
    // for the process other then to enumerate all the processes
    // This may cause performance problem with large number of worker processes 
    // that are self monitoring on memory usage
    //

    
    for(;;)
    {
     
        if ( !sm_buffSystemProcessInfo.Resize( sm_cbSystemProcessInfo ) )
        {
            // We failed to reallocate then just silently exit
            // CODEWORK: This may cause worker process to never recycle
            // if memory is too low to handle memory usage check
            //
            
            return;
        }
        Status = NtQuerySystemInformation(
                   SystemProcessInformation,
                   sm_buffSystemProcessInfo.QueryPtr(),
                   sm_buffSystemProcessInfo.QuerySize(),
                   NULL
                   );

        if( Status != STATUS_INFO_LENGTH_MISMATCH ) break;

        sm_cbSystemProcessInfo *= 2;
    }

    
    if( Status == STATUS_SUCCESS ) 
    {
        DWORD NextOffset = 0;
        //
        // enumerate info about all processes until you find
        // the current process (identified by PID)
        //
        for(;;) 
        {
            //
            // get process info from buffer 
            //

            pProcessInfo = (PSYSTEM_PROCESS_INFORMATION)
                            (((PBYTE) sm_buffSystemProcessInfo.QueryPtr()) + NextOffset );
            NextOffset += pProcessInfo->NextEntryOffset;

            //
            // Compare Pid to see if we found the current process
            //
            
            if ( HandleToULong( pProcessInfo->UniqueProcessId ) == sm_CurrentPID )
            {
                break;
            }

            if ( pProcessInfo->NextEntryOffset == 0 )
            {
                //
                // Well, we should never get here because the current process
                // must be listed but to eliminate potential problems
                // since we are using private NT API let's assume not found error
                //
                Status = STATUS_NOT_FOUND;
                break;
            }
        }
        
    }

    if ( ! NT_SUCCESS ( Status ) )
    {
        IF_DEBUG( WPRECYCLER )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "NtQueryInformationProcess failed with Status: %d\n", 
                        Status ));
        }
        return;
    }

    //
    // Check virtual bytes
    //
    
    if ( sm_MaxValueForVirtualMemoryBasedInKB != 0 &&
         pProcessInfo->VirtualSize/1024 >= sm_MaxValueForVirtualMemoryBasedInKB )
    {
        IF_DEBUG( WPRECYCLER )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "WP_RECYCLER::TimerCallbackForMemoryBased()"
                        " - current VM:%ld kB, configured max VM:%ld kB"
                        " - tell WAS to recycle\n", 
                        pProcessInfo->VirtualSize/1024 , 
                        sm_MaxValueForVirtualMemoryBasedInKB    ));
        }

        //
        // we reached Virtual Memory Usage limit
        //
        WP_RECYCLER::SendRecyclingMsg( IPM_WP_RESTART_VIRTUAL_MEMORY_LIMIT_REACHED );  
    }

    //
    // Check private bytes
    //
    if ( sm_MaxValueForPrivateBytesBasedInKB != 0 &&
         pProcessInfo->PrivatePageCount/1024 >= sm_MaxValueForPrivateBytesBasedInKB )
    {
        IF_DEBUG( WPRECYCLER )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "WP_RECYCLER::TimerCallbackForMemoryBased()"
                        " - current Private Bytes:%ld kB, configured max Private Bytes:%ld kB"
                        " - tell WAS to recycle\n", 
                        pProcessInfo->PrivatePageCount/1024 , 
                        sm_MaxValueForPrivateBytesBasedInKB    ));
        }

        //
        // we reached Private Memory Usage limit
        //
        WP_RECYCLER::SendRecyclingMsg( IPM_WP_RESTART_PRIVATE_BYTES_LIMIT_REACHED );  
    }
}


//
// Static methods for Time based recycling
//


//static
HRESULT
WP_RECYCLER::StartTimeBased(
    IN  DWORD dwPeriodicRestartTimeInMinutes
)
/*++

Routine Description:

    Start elapsed time based recycling
    
    
Arguments:

    dwPeriodicRestartTimeInMinutes - how often to restart (in minutes)
    
Return Value:

    HRESULT

--*/

{
    HRESULT hr   = E_FAIL;
    BOOL    fRet = FALSE;

    DBG_ASSERT(TRUE == sm_fCritSecInit);

    EnterCriticalSection( &WP_RECYCLER::sm_CritSec );
    
    IF_DEBUG( WPRECYCLER )
    {

        DBGPRINTF(( DBG_CONTEXT,
                    "WP_RECYCLER::StartTimeBased(%d min)\n" ,   
                    dwPeriodicRestartTimeInMinutes ));
    }


    //
    // If time based recycling has been running already
    // terminate it before restarting with new settings
    //
    
    if ( WP_RECYCLER::sm_fIsStartedTimeBased == TRUE )
    {
        WP_RECYCLER::TerminateTimeBased();
    }

    
    if ( dwPeriodicRestartTimeInMinutes == 0 )
    {
        //
        // 0 means not to run time based recycling
        //
        hr = S_OK;
        goto succeeded;
    }

    fRet = CreateTimerQueueTimer( &WP_RECYCLER::sm_hTimerForTimeBased,
                                  NULL,
                                  WP_RECYCLER::TimerCallbackForTimeBased,
                                  NULL,
                                  dwPeriodicRestartTimeInMinutes * 60000, 
                                        // convert to msec
                                  dwPeriodicRestartTimeInMinutes * 60000, 
                                        // convert to msec
                                  WT_EXECUTELONGFUNCTION );
    if ( !fRet )
    {
        WP_RECYCLER::sm_hTimerForTimeBased = NULL;
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto failed;
    }
    
    WP_RECYCLER::sm_fIsStartedTimeBased = TRUE;
    
succeeded:    
    LeaveCriticalSection( &WP_RECYCLER::sm_CritSec );

    return S_OK;
    
failed:
    DBG_ASSERT( FAILED( hr ) );
    WP_RECYCLER::TerminateTimeBased();

    IF_DEBUG( WPRECYCLER )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "WP_RECYCLER::StartTimeBased() failed with error hr=0x%x\n",
                    hr));
    }
    LeaveCriticalSection( &WP_RECYCLER::sm_CritSec );

    return hr;
    
}

//static
VOID
WP_RECYCLER::TerminateTimeBased(
    VOID
)
/*++

Routine Description:

    Stops elapsed time based recycling 
    Performs cleanup

Note:
    It is safe to call this method for cleanup if Start failed
    
Arguments:

    NONE
    
Return Value:

    HRESULT

--*/

{
    DBG_ASSERT(TRUE == sm_fCritSecInit);

    EnterCriticalSection( &WP_RECYCLER::sm_CritSec );

    if ( WP_RECYCLER::sm_hTimerForTimeBased != NULL )
    {
        if ( !DeleteTimerQueueTimer(   
                       NULL,
                       WP_RECYCLER::sm_hTimerForTimeBased,
                       INVALID_HANDLE_VALUE /* wait for callbacks to complete */ 
                       ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "failed to call DeleteTimerQueueTimer(): hr=0x%x\n",
                        HRESULT_FROM_WIN32(GetLastError()) ));
        }                                                              
                                              
        WP_RECYCLER::sm_hTimerForTimeBased = NULL;
    }
    WP_RECYCLER::sm_fIsStartedTimeBased = FALSE;

    LeaveCriticalSection( &WP_RECYCLER::sm_CritSec );

    return;
}

//static
VOID
WINAPI
WP_RECYCLER::TimerCallbackForTimeBased(
    PVOID,
    BOOLEAN                
)
/*++

Routine Description:

    Timer callback for Elapsed time based recycling   
    This Callback is passed to CreateTimerQueueTimer()

    Routine will inform WAS that process is ready to be recycled
    because required elapsed time has been reached
    
Arguments:

    see description of WAITORTIMERCALLBACK type in MSDN

    
Return Value:

    none

--*/


{

    DBG_ASSERT( WP_RECYCLER::sm_fIsStartedTimeBased );

    IF_DEBUG( WPRECYCLER )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "WP_RECYCLER::TimerCallbackForTimeBased"
                    " - tell WAS to recycle\n"           ));
    }

    WP_RECYCLER::SendRecyclingMsg( IPM_WP_RESTART_ELAPSED_TIME_REACHED );
}

//
// Static methods for Request based recycling
//


//static
HRESULT
WP_RECYCLER::StartRequestBased(
    IN  DWORD dwRequests
)
/*++

Routine Description:

    Start request based recycling. 
    
    
Arguments:

    dwRequests - If number of requests processed by worker process reaches this value
                 recycling will be required
    
Return Value:

    HRESULT

--*/

{
    HRESULT hr = E_FAIL;
    
    DBG_ASSERT(TRUE == sm_fCritSecInit);

    EnterCriticalSection( &WP_RECYCLER::sm_CritSec );

    IF_DEBUG( WPRECYCLER )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "WP_RECYCLER::StartRequestBased(%d kB)\n" ,   
                    dwRequests ));
    }

  
    //
    // If time based recycling has been running already
    // terminate it before restarting with new settings
    //
    
    if ( WP_RECYCLER::sm_fIsStartedRequestBased == TRUE )
    {
        WP_RECYCLER::TerminateRequestBased();
    }

    
    if ( dwRequests == 0 )
    {
        //
        // 0 means not to run request based recycling
        //
        hr = S_OK;
        goto succeeded;
    }


    InterlockedExchange( 
            reinterpret_cast<LONG *>(&sm_dwMaxValueForRequestBased), 
            dwRequests );
    InterlockedExchange( 
            reinterpret_cast<LONG *>(&WP_RECYCLER::sm_fIsStartedTimeBased), 
            TRUE );

    hr = S_OK;
succeeded:
    LeaveCriticalSection( &WP_RECYCLER::sm_CritSec );

    return hr;

}

//static
VOID
WP_RECYCLER::TerminateRequestBased(
    VOID
)
/*++

Routine Description:

    Stops request based recycling 
    Performs cleanup

Note:
    It is safe to call this method for cleanup if Start failed
    
Arguments:

    NONE
    
Return Value:

    HRESULT

--*/

{
  
    DBG_ASSERT(TRUE == sm_fCritSecInit);
    
    EnterCriticalSection( &WP_RECYCLER::sm_CritSec );

    //
    // InterlockedExchange is used because Request Based recycling callback 
    // IsRequestCountLimitReached() is called for each request
    // and we don't synchronize it with &WP_RECYCLER::sm_CritSec 
    //
    
    InterlockedExchange( 
            reinterpret_cast<LONG *>(&WP_RECYCLER::sm_fIsStartedTimeBased), 
            FALSE );
    
    LeaveCriticalSection( &WP_RECYCLER::sm_CritSec );

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulatq\dbgutil.h ===
/*++

Copyright (c) 1994-1998 Microsoft Corporation

Module Name:

    dbgutil.h

Abstract:

    This module declares the macros to wrap around DEBUG_PRINTS class
    defined in pudebug.h    
  
    This is the exported header file, that the users are allowed to modify.
    If there are no custom definitions, please use the templated version
    in the root iisrearc\inc\dbgutil.h
 
Author:

    Murali R. Krishnan (MuraliK)    22-Sept-1994

--*/


# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_



// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputKdb )

// end_user_modifiable


//
// include standard debug support
//
// note: define DEFAULT_OUTPUT_FLAGS before including pudebug.h
//

# include <pudebug.h>


// begin_user_modifiable

// Use the default constants from pudebug.h: 0x00000001 to 0x00000100

//
//  Define the debugging constants as bit-flag values
//  Example: # define DEBUG_FOOBAR 0x00010000
//  Note: All debugging bit-values below 0x00001000 are reserved!
// 
//  If you add or change a flag, please update FlagTableWp
//  in core\common\dtflags\dtflags.c
//

# define    DEBUG_UL_CALLS             0x00010000

# define    DEBUG_NREQ                 0x00040000
# define    DEBUG_WPIPM                0x00080000
# define    DEBUG_WPRECYCLER           0x00100000

# define    DEBUG_TRACE                0x10000000
# define    DEBUG_DUMPS                0x20000000

// end_user_modifiable


# endif  /* _DBGUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulatq\uldisconnect.cxx ===
/*++

   Copyright    (c)    2000    Microsoft Corporation

   Module Name :
     uldisconnect.cxx

   Abstract:
     UL_DISCONNECT_CONTEXT implementation
 
   Author:
     Bilal Alam             (balam)         15-Feb-2000

   Environment:
     Win32 - User Mode

   Project:
     W3DT.DLL
--*/

#include "precomp.hxx"

extern PFN_ULATQ_DISCONNECT         g_pfnDisconnect;

//
// UL_DISCONNECT_CONTEXT statics
//

LONG                    UL_DISCONNECT_CONTEXT::sm_cOutstanding;
ALLOC_CACHE_HANDLER *   UL_DISCONNECT_CONTEXT::sm_pachDisconnects;

VOID
UL_DISCONNECT_CONTEXT::DoWork( 
    DWORD,        
    DWORD,       
    LPOVERLAPPED 
)
/*++

Routine Description:

    Handles async calls to UlWaitForDisconnect

Arguments:

    All arguments unused
    
Return Value:

    None

--*/
{
    DBG_ASSERT( CheckSignature() );
    
    //
    // Our handling is simple.  We just call the disconnection completion
    // routine with the context passed thru UlAtqWaitForDisconnect
    //
    
    DBG_ASSERT( g_pfnDisconnect != NULL );
    
    g_pfnDisconnect( _pvContext );   
    
    //
    // We're done with the context, delete it now
    // 
    
    DereferenceUlDisconnectContext();
}   

//static
VOID
UL_DISCONNECT_CONTEXT::WaitForOutstandingDisconnects(
    VOID
)
/*++

Routine Description:

    Wait for the outstanding UL_DISCONNECT_CONTEXTs to drain.  This will 
    happen when we close the AppPool handle to begin shutdown

Arguments:

    None
    
Return Value:

    None

--*/
{
    while ( sm_cOutstanding != 0 )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Waiting for %d disconnect contexts to drain\n",
                    sm_cOutstanding ));
        
        Sleep( 1000 );
    }
}

//static
HRESULT
UL_DISCONNECT_CONTEXT::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize disconnect globals

Arguments:

    None
    
Return Value:

    HRESULT 

--*/
{
    ALLOC_CACHE_CONFIGURATION       acConfig;
    
    //
    // Setup allocation lookaside
    //
    
    acConfig.nConcurrency = 1;
    acConfig.nThreshold = 100;
    acConfig.cbSize = sizeof( UL_DISCONNECT_CONTEXT );

    DBG_ASSERT( sm_pachDisconnects == NULL );
    
    sm_pachDisconnects = new ALLOC_CACHE_HANDLER( "UL_DISCONNECT_CONTEXT",  
                                                   &acConfig );

    if ( sm_pachDisconnects == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }
    
    return NO_ERROR;
}

//static
VOID
UL_DISCONNECT_CONTEXT::Terminate(
    VOID
)
/*++

Routine Description:

    Cleanup disconnect globals

Arguments:

    None
    
Return Value:

    None

--*/
{
    if ( sm_pachDisconnects != NULL )
    {
        delete sm_pachDisconnects;
        sm_pachDisconnects = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\tokencache\dbgutil.h ===
/*++

Copyright (c) 1994-1998 Microsoft Corporation

Module Name:

    dbgutil.h

Abstract:

    This module declares the macros to wrap around DEBUG_PRINTS class
    defined in pudebug.h    
  
    This is the exported header file, that the users are allowed to modify.
    If there are no custom definitions, please use the templated version
    in the root iisrearc\inc\dbgutil.h
 
Author:

    Murali R. Krishnan (MuraliK)    22-Sept-1994

--*/


# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_



// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputKdb )

// end_user_modifiable


//
// include standard debug support
//
// note: define DEFAULT_OUTPUT_FLAGS before including pudebug.h
//

# include <pudebug.h>


// begin_user_modifiable

// Use the default constants from pudebug.h: 0x00000001 to 0x00000100

//
//  Define the debugging constants as bit-flag values
//  Example: # define DEBUG_FOOBAR 0x00010000
//  Note: All debugging bit-values below 0x00001000 are reserved!
// 
//  If you add or change a flag, please update FlagTableWp
//  in core\common\dtflags\dtflags.c
//

# define    DEBUG_DIRMON               0x00010000

#if DBG

//
// handy trace macro
//
#define WpTrace(a, _b_)     \
do {                        \
    IF_DEBUG(##a)           \
    {                       \
        PuDbgPrint _b_ ;      \
    }                       \
}while (0)

#else // !DBG

#define WpTrace(a, _b_)        ((void) 0)  /* do nothing */

#endif



// end_user_modifiable


# endif  /* _DBGUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\tokencache\tokencache.cxx ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :

      tokencache.cxx

   Abstract:

      Ming's token cache refactored for general consumption

   Author:

      Bilal Alam            (balam)         May-4-2000

   Revision History:

--*/

#include <iis.h>
#include <time.h>
#include <irtltoken.h>
#include "dbgutil.h"
#include <string.hxx>
#include <acache.hxx>
#include <tokencache.hxx>
#include <ntmsv1_0.h>
#include <lm.h>

//
// Security related headers
//
#define SECURITY_WIN32
#include <security.h>

extern "C" 
{
#include <secint.h>
} 
//
// lonsint.dll related heade files
//
#include <lonsi.hxx>
#include <tslogon.hxx>

ALLOC_CACHE_HANDLER * TOKEN_CACHE_ENTRY::sm_pachTokenCacheEntry = NULL;
HCRYPTPROV            TOKEN_CACHE_ENTRY::sm_hCryptProv          = NULL;

HRESULT
TOKEN_CACHE_KEY::CreateCacheKey(
    WCHAR *                 pszUserName,
    WCHAR *                 pszDomainName,
    DWORD                   dwLogonMethod
)
/*++

  Description:

    Build the key used for token cache

  Arguments:

    pszUserName - User name
    pszDomainName - Domain name
    dwLogonMethod - Logon method

  Return:

    HRESULT

--*/
{
    HRESULT             hr;
    WCHAR               achNum[ 33 ];
    
    if ( pszUserName == NULL ||
         pszDomainName == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    hr = m_strHashKey.Copy( pszUserName );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    hr = m_strHashKey.Append( pszDomainName );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    _wcsupr( m_strHashKey.QueryStr() );
    
    _ultow( dwLogonMethod, achNum, 10 );
    
    hr = m_strHashKey.Append( achNum );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    return hr;
}

//static
HRESULT
TOKEN_CACHE_ENTRY::Initialize(
    VOID
)
/*++

  Description:

    Token entry lookaside initialization

  Arguments:

    None
    
  Return:

    HRESULT

--*/
{
    ALLOC_CACHE_CONFIGURATION   acConfig;
    HRESULT                     hr;    

    //
    // Initialize allocation lookaside
    //    
    
    acConfig.nConcurrency = 1;
    acConfig.nThreshold   = 100;
    acConfig.cbSize       = sizeof( TOKEN_CACHE_ENTRY );

    DBG_ASSERT( sm_pachTokenCacheEntry == NULL );
    
    sm_pachTokenCacheEntry = new ALLOC_CACHE_HANDLER( "TOKEN_CACHE_ENTRY",  
                                                      &acConfig );

    if ( sm_pachTokenCacheEntry == NULL || !sm_pachTokenCacheEntry->IsValid() )
    {
        if( sm_pachTokenCacheEntry != NULL )
        {
            delete sm_pachTokenCacheEntry;
            sm_pachTokenCacheEntry = NULL;
        }

        hr = HRESULT_FROM_WIN32( GetLastError() );

        DBGPRINTF(( DBG_CONTEXT,
                   "Error initializing sm_pachTokenCacheEntry. hr = 0x%x\n",
                   hr ));

        return hr;
    }
    
    //
    //  Get a handle to the CSP we'll use for our MD5 hash functions.
    //
    
    if ( !CryptAcquireContext( &sm_hCryptProv,
                               NULL,
                               NULL,
                               PROV_RSA_FULL,
                               CRYPT_VERIFYCONTEXT ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );

        DBGPRINTF(( DBG_CONTEXT,
                    "CryptAcquireContext() failed. hr = 0x%x\n", 
                    hr ));

        return hr;
    }
        
    return NO_ERROR;
}

//static
VOID
TOKEN_CACHE_ENTRY::Terminate(
    VOID
)
/*++

  Description:

    Token cache cleanup

  Arguments:

    None
    
  Return:

    None

--*/
{
    if ( sm_pachTokenCacheEntry != NULL )
    {
        delete sm_pachTokenCacheEntry;
        sm_pachTokenCacheEntry = NULL;
    }

    if ( sm_hCryptProv != NULL)
    {
        CryptReleaseContext( sm_hCryptProv, 0 );

        sm_hCryptProv = NULL;
    }
}

HRESULT
TOKEN_CACHE_ENTRY::GenMD5Password(
    IN  WCHAR                 * pszPassword,
    OUT STRA                  * pstrMD5Password
)
/*++

  Description:

    Generate MD5 hashed password

  Arguments:

    pszPassword     - Password to be MD5 hashed
    pstrMD5Password - MD5 hashed password

  Return:

    HRESULT

--*/
{
    HRESULT       hr;
    DWORD         dwError;
    HCRYPTHASH    hHash = NULL;
    DWORD         dwHashDataLen;
    STACK_BUFFER( buffHashData, DEFAULT_MD5_HASH_SIZE );

    if( pszPassword == NULL || pstrMD5Password == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    if ( !CryptCreateHash( sm_hCryptProv,
                           CALG_MD5,
                           0,
                           0,
                           &hHash ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );

        DBGPRINTF((DBG_CONTEXT,
                   "CryptCreateHash() failed : hr = 0x%x\n", 
                   hr ));

        goto exit;
    }

    if ( !CryptHashData( hHash,
                         ( BYTE * )pszPassword,
                         ( DWORD )wcslen( pszPassword ) * sizeof( WCHAR ),
                         0 ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );

        DBGPRINTF((DBG_CONTEXT,
                   "CryptHashData() failed : hr = 0x%x\n", 
                   hr ));
        
        goto exit;
    }

    dwHashDataLen = DEFAULT_MD5_HASH_SIZE;
    
    if ( !CryptGetHashParam( hHash,
                             HP_HASHVAL,
                             ( BYTE * )buffHashData.QueryPtr(),
                             &dwHashDataLen,
                             0 ) )
    {
        dwError = GetLastError();

        if( dwError == ERROR_MORE_DATA )
        {
            if( !buffHashData.Resize( dwHashDataLen ) )
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }

            if( !CryptGetHashParam( hHash,
                                    HP_HASHVAL,
                                    ( BYTE * )buffHashData.QueryPtr(),
                                    &dwHashDataLen,
                                    0 ) )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() ); 

                goto exit;
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32( dwError );

            goto exit;
        }
    }

    //
    // Convert binary data to ASCII hex representation
    //

    hr = ToHex( buffHashData, *pstrMD5Password );

exit:

    if( hHash != NULL )
    {
        CryptDestroyHash( hHash );
    }

    return hr;    
}    

HRESULT
TOKEN_CACHE_ENTRY::EqualMD5Password(
    IN  WCHAR                 * pszPassword,
    OUT BOOL                  * fEqual
)
/*++

  Description:

    Does the password in the current entry equal to the one passed in?

  Arguments:

    pszPassword     - Password to be evaluated 
    fEqual          - TRUE if two MD5 hashed password equal

  Return:

    BOOL

--*/
{
    STACK_STRA( strMD5Password, 2 * DEFAULT_MD5_HASH_SIZE + 1 );
    HRESULT     hr;

    hr = GenMD5Password( pszPassword, &strMD5Password );
    if( FAILED( hr ) )
    {
        return hr;
    }

    *fEqual = m_strMD5Password.Equals( strMD5Password );

    return NO_ERROR;
}
    
HRESULT 
TOKEN_CACHE_ENTRY::Create(
    IN HANDLE                   hToken,
    IN WCHAR                  * pszPassword,
    IN LARGE_INTEGER          * pliPwdExpiry,
    IN BOOL                     fImpersonation
)
/*++

  Description:

    Initialize a cached token

  Arguments:

    hToken - Token
    liPwdExpiry - Password expiration time
    fImpersonation - Is hToken an impersonation token?

  Return:

    HRESULT

--*/
{
    if ( hToken == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    if ( fImpersonation )
    {
        m_hImpersonationToken = hToken;
    }
    else
    {
        m_hPrimaryToken = hToken;
    }
    
  
    memcpy( ( VOID * )&m_liPwdExpiry,
            ( VOID * )pliPwdExpiry,
            sizeof( LARGE_INTEGER ) );                                 
    
    return GenMD5Password( pszPassword, &m_strMD5Password );
}

HANDLE
TOKEN_CACHE_ENTRY::QueryImpersonationToken(
    VOID
)
/*++

  Description:

    Get impersonation token

  Arguments:

    None

  Return:

    Handle to impersonation token

--*/
{
    if ( m_hImpersonationToken == NULL )
    {
        LockCacheEntry();
        
        if ( m_hImpersonationToken == NULL )
        {
            DBG_ASSERT( m_hPrimaryToken != NULL );
            
            if ( !DuplicateTokenEx( m_hPrimaryToken,
                                    0,
                                    NULL,
                                    SecurityImpersonation,
                                    TokenImpersonation,
                                    &m_hImpersonationToken ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                          "DuplicateTokenEx failed, GetLastError = %lx\n",
                          GetLastError() ));
            } 
            else
            {
                DBG_ASSERT( m_hImpersonationToken != NULL );
            }
        }

        UnlockCacheEntry();    
    }
    
    if( m_hImpersonationToken && !QueryDisBackupPriToken() )
    {
        //
        // Disable the backup privilege for the token 
        //

        DisableTokenBackupPrivilege( m_hImpersonationToken );
    }
    
    return m_hImpersonationToken;
}
    
HANDLE
TOKEN_CACHE_ENTRY::QueryPrimaryToken(
    VOID
)
/*++

  Description:

    Get primary token

  Arguments:

    None

  Return:

    Handle to primary token

--*/
{
    if ( m_hPrimaryToken == NULL )
    {
        LockCacheEntry();
        
        if ( m_hPrimaryToken == NULL )
        {
            DBG_ASSERT( m_hImpersonationToken != NULL );
            
            if ( !DuplicateTokenEx( m_hImpersonationToken,
                                    0,
                                    NULL,
                                    SecurityImpersonation,
                                    TokenPrimary,
                                    &m_hPrimaryToken ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                          "DuplicateTokenEx failed, GetLastError = %lx\n",
                          GetLastError() ));
            } 
            else
            {
                DBG_ASSERT( m_hPrimaryToken != NULL );
            }
        }
    
        UnlockCacheEntry();
    }
    
    return m_hPrimaryToken;
}

PSID
TOKEN_CACHE_ENTRY::QuerySid(
    VOID
)
/*++

  Description:

    Get the sid for this token

  Arguments:

    None

  Return:

    Points to SID buffer owned by this object

--*/
{
    BYTE                abTokenUser[ SID_DEFAULT_SIZE + sizeof( TOKEN_USER ) ];
    TOKEN_USER *        pTokenUser = (TOKEN_USER*) abTokenUser;
    BOOL                fRet;
    HANDLE              hImpersonation;
    DWORD               cbBuffer;
    
    hImpersonation = QueryImpersonationToken();
    if ( hImpersonation == NULL )
    {
        return NULL;
    }
      
    if ( m_pSid == NULL )
    {
        LockCacheEntry();
    
        fRet = GetTokenInformation( hImpersonation,
                                    TokenUser,
                                    pTokenUser,
                                    sizeof( abTokenUser ),
                                    &cbBuffer );
        if ( fRet )
        {
            //
            // If we can't get the sid, then that is OK.  We're return NULL
            // and as a result we will do the access check always
            //
            
            memcpy( m_abSid,
                    pTokenUser->User.Sid,
                    sizeof( m_abSid ) );
                    
            m_pSid = m_abSid;
        }
        
        UnlockCacheEntry();
    }
    
    return m_pSid;
}

HRESULT
TOKEN_CACHE::Initialize(
    VOID
)
/*++

  Description:

    Initialize token cache

  Arguments:

    None

  Return:

    HRESULT

--*/
{
    HRESULT             hr;
    LONG                lErrorCode;
    DWORD               dwData;
    DWORD               dwType;
    DWORD               cbData   = sizeof( DWORD );
    DWORD               dwFilter;
    DWORD               dwFlags;
    DWORD               csecTTL = DEFAULT_CACHED_TOKEN_TTL;

    hr = TOKEN_CACHE_ENTRY::Initialize();
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Token cache entry init failed. hr = 0x%x\n", 
                    hr ));

        goto Failure;
    }

    //
    // What is the TTL for the token cache
    //
    
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       L"System\\CurrentControlSet\\Services\\inetinfo\\Parameters",
                       0,
                       KEY_READ,
                       &m_hKey ) == ERROR_SUCCESS )
    {
        DBG_ASSERT( m_hKey != NULL );
        
        if ( RegQueryValueEx( m_hKey,
                              L"LastPriorityUPNLogon",
                              NULL,
                              &dwType,
                              (LPBYTE) &dwData,
                              &cbData ) == ERROR_SUCCESS &&
             dwType == REG_DWORD )
        {
            m_dwLastPriorityUPNLogon = dwData;
        }

        if ( RegQueryValueEx( m_hKey,
                              L"UserTokenTTL",
                              NULL,
                              &dwType,
                              (LPBYTE) &dwData,
                              &cbData ) == ERROR_SUCCESS &&
             dwType == REG_DWORD )
        {
            csecTTL = dwData;
        }
    }                      
    
    //
    // We'll use TTL for scavenge period, and expect two inactive periods to
    // flush
    //
    
    hr = SetCacheConfiguration( csecTTL * 1000,
                                csecTTL * 1000,
                                0,
                                NULL );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }

    //
    // Create an event
    //

    m_hEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
    if( m_hEvent == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );

        DBGPRINTF(( DBG_CONTEXT,
                    "CreateEvent() failed. hr = 0x%x\n", 
                    hr ));

        goto Failure;
    }
    
    //
    // Watch the registry key for a change of value
    //

    dwFilter = REG_NOTIFY_CHANGE_LAST_SET;

    lErrorCode = RegNotifyChangeKeyValue( m_hKey, 
                                          TRUE, 
                                          dwFilter, 
                                          m_hEvent, 
                                          TRUE );
    if( lErrorCode != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );

        DBGPRINTF(( DBG_CONTEXT,
                    "RegNotifyChangeKeyValue failed. hr = 0x%x\n", 
                    hr ));

        goto Failure;
    }
    
    //
    // Register a callback function to wait on the event
    //

    dwFlags = WT_EXECUTEINPERSISTENTTHREAD;
    
    if( !RegisterWaitForSingleObject( 
           &m_hWaitObject,
           m_hEvent,
           ( WAITORTIMERCALLBACK )TOKEN_CACHE::FlushTokenCacheWaitCallback,
           this,
           INFINITE,
           dwFlags ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );

        DBGPRINTF(( DBG_CONTEXT,
                    "RegisterWaitForSingleObject failed. hr = 0x%x\n", 
                    hr ));

        goto Failure;
    }

    hr = ThreadPoolInitialize( 0 );
    if( FAILED(hr) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "ThreadPoolInitialize failed. hr = 0x%x\n", 
                    hr ));

        goto Failure;
    }

    m_fInitializedThreadPool = TRUE;

    return NO_ERROR;

Failure:

    TOKEN_CACHE::Terminate();

    return hr;
}

VOID
TOKEN_CACHE::Terminate(
    VOID
)
/*++

  Description:

    Terminate token cache

  Arguments:

    None

  Return:

    None

--*/
{
    if( m_fInitializedThreadPool )
    {
        DBG_REQUIRE(SUCCEEDED(ThreadPoolTerminate()));
        m_fInitializedThreadPool = FALSE;
    }

    if( m_hWaitObject != NULL )
    {
        UnregisterWait( m_hWaitObject );

        m_hWaitObject = NULL;
    }
    
    if( m_hEvent != NULL )
    {
        CloseHandle( m_hEvent );

        m_hEvent = NULL;
    }
    
    if( m_hKey != NULL )
    {
        RegCloseKey( m_hKey );

        m_hKey = NULL;
    }

    return TOKEN_CACHE_ENTRY::Terminate();
}

// static
VOID
WINAPI
TOKEN_CACHE::FlushTokenCacheWaitCallback(
    PVOID       pParam,
    BOOL        fWaitFired
)
/*++

  Description:

    Flush the token cache and reset change notification for the 
    "UserTokenTTL" registry key.

  Arguments:
    
    Not used for now

  Return:

    None

--*/
{   
    TOKEN_CACHE *       pTokenCache;
    LIST_ENTRY          listHead;
    DWORD               dwFilter;
    DWORD               dwData = 0;
    DWORD               dwType;
    DWORD               cbData   = sizeof( DWORD );
    DWORD               dwFlushTokenCache;
    
    UNREFERENCED_PARAMETER( fWaitFired );
    
    pTokenCache = ( TOKEN_CACHE * )pParam;
    DBG_ASSERT( pTokenCache != NULL );
    DBG_ASSERT( pTokenCache->CheckSignature() );

    if ( RegQueryValueEx( pTokenCache->QueryRegKey(),
                          L"FlushTokenCache",
                          NULL,
                          &dwType,
                          (LPBYTE) &dwData,
                          &cbData ) == ERROR_SUCCESS &&
         dwType == REG_DWORD )
    {
        dwFlushTokenCache = dwData;

        if( dwFlushTokenCache > 0 )
        {
            //
            // Flush the whole token cache since the UserTokenTTL 
            // has been changed.
            //

            InitializeListHead( &listHead );

            pTokenCache->FlushByRegChange( &listHead );

            //
            // Remove all cache entries in the cache entry list
            //
            pTokenCache->CleanupCacheEntryListItems( &listHead );
        }
    }

    //
    // Reset the event
    //

    ResetEvent( pTokenCache->QueryEventHandle() );
    
    //
    // Watch the registry key for a change of value
    //

    dwFilter = REG_NOTIFY_CHANGE_LAST_SET;

    RegNotifyChangeKeyValue( pTokenCache->QueryRegKey(), 
                             TRUE, 
                             dwFilter, 
                             pTokenCache->QueryEventHandle(), 
                             TRUE );
}

HRESULT
TOKEN_CACHE::GetCachedToken(
    IN LPWSTR                   pszUserName,
    IN LPWSTR                   pszDomain,
    IN LPWSTR                   pszPassword,
    IN DWORD                    dwLogonMethod,
    IN BOOL                     fUseSubAuth,
    IN BOOL                     fPossibleUPNLogon,
    IN PSOCKADDR                pSockAddr,
    OUT TOKEN_CACHE_ENTRY **    ppCachedToken,
    OUT DWORD *                 pdwLogonError
)
/*++

  Description:

    Get cached token (the friendly interface for the token cache)

  Arguments:

    pszUserName - User name
    pszDomain - Domain name
    pszPassword - Password
    dwLogonMethod - Logon method (batch, interactive, etc)
    fUseSubAuth - Use subauthenticator to logon the anonymous user
    fPossibleUPNLogon - TRUE if we may need to do UPN logon, 
                        otherwise FALSE
    psockAddr - Remote IP address, could be IPv4 or IPv6 address
    ppCachedToken - Filled with cached token on success
    pdwLogonError - Set to logon failure if *ppCacheToken==NULL

  Return:

    HRESULT

--*/
{
    TOKEN_CACHE_KEY             tokenKey;
    TOKEN_CACHE_ENTRY *         pCachedToken = NULL;
    HRESULT                     hr;
    HANDLE                      hToken = NULL;
    LARGE_INTEGER               liPwdExpiry;
    LPVOID                      pProfile        = NULL;
    DWORD                       dwProfileLength = 0;
    WCHAR *                     pszAtSign       = NULL;
    WCHAR *                     pDomain[2];
    BOOL                        fRet;
    WCHAR *                     pszSlash = NULL;
    CHAR                        achPassword[32];
    STACK_STRU(                 strPassword,    32 );
    STACK_STRA(                 straUserName,   64 );
    STACK_STRA(                 straDomainName, 64 );
    BOOL                        fEqualPassword  = FALSE;
    SECURITY_STATUS             ss = SEC_E_OK;

    if ( pszUserName == NULL   ||
         pszDomain == NULL     ||
         pszPassword == NULL   ||
         ppCachedToken == NULL ||
         pdwLogonError == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    liPwdExpiry.HighPart = 0x7fffffff;
    liPwdExpiry.LowPart  = 0xffffffff;

    *ppCachedToken = NULL;
    *pdwLogonError = ERROR_SUCCESS;

    //
    // Find a domain in the username if we don't have one explicitly mentioned
    //
    
    if ( pszDomain[ 0 ] == L'\0' )
    {
        //
        // Find the \ in DOMAIN\USERNAME
        //
        
        pszSlash = wcschr( pszUserName, L'\\' );
        if ( pszSlash != NULL )
        {
            pszDomain = pszUserName;
            pszUserName = pszSlash + 1;
            *pszSlash = L'\0';
        }
    }

    if( fUseSubAuth )
    {
        if( FAILED( hr = straUserName.CopyW( pszUserName ) ) )
        {
            goto ExitPoint;
        } 

        if( !IISNetUserCookieA( straUserName.QueryStr(),
                                IIS_SUBAUTH_SEED,
                                achPassword,
                                sizeof( achPassword ) ) )
        {
            *pdwLogonError = GetLastError();
            hr = NO_ERROR;
            goto ExitPoint;
        }

        if( FAILED( hr = strPassword.CopyA( achPassword ) ) )
        {
            goto ExitPoint;
        }
        
        if( FAILED( straDomainName.CopyW( pszDomain ) ) )
        {
            goto ExitPoint;
        }

        pszPassword = strPassword.QueryStr();
        dwLogonMethod = LOGON32_LOGON_IIS_NETWORK;
    }
    
    //
    // Find the key to look for
    //

    hr = tokenKey.CreateCacheKey( pszUserName,
                                  pszDomain,
                                  dwLogonMethod );

    if ( FAILED( hr ) )
    {
        goto ExitPoint;
    }
    
    //
    // Look for it
    //
    
    hr = FindCacheEntry( &tokenKey,
                         (CACHE_ENTRY**) ppCachedToken );
    if( SUCCEEDED( hr ) )
    {
        DBG_ASSERT( *ppCachedToken != NULL );

        hr = ( *ppCachedToken )->EqualMD5Password( pszPassword, 
                                                   &fEqualPassword );
        if( FAILED( hr ) )
        {
            ( *ppCachedToken )->DereferenceCacheEntry();
            *ppCachedToken = NULL;

            goto ExitPoint;
        }
        
        if( fEqualPassword )
        {
            //
            // Cache hit
            //
            
            goto ExitPoint;
        }

        //
        // The password does not match 
        //

        ( *ppCachedToken )->DereferenceCacheEntry();
        *ppCachedToken = NULL;
    }

    //
    // Ok.  It wasn't in the cache, create a token and add it
    //
    // There are three cases to deal with
    //
    // 1) We just want the local system token (thats trivial)
    // 2) We want to call advapi32!LogonUser for a "normal logon"
    // 3) We are doing passport special logon thru lonsint (LsaLogonUser())
    //
    
    if ( dwLogonMethod == IIS_LOGON_METHOD_LOCAL_SYSTEM && 
         _wcsicmp( L"LocalSystem", pszUserName ) == 0 )
    {        
        if (!OpenProcessToken(
                        GetCurrentProcess(),                // handle to process
                        TOKEN_ALL_ACCESS,                   // desired access
                        &hToken                             // returned token
                        ) )
        {
            //
            // If we couldn't logon, then return no error.  The caller will
            // determine failure due to *ppCachedToken == NULL
            //
            
            *pdwLogonError = GetLastError();            
            hr = NO_ERROR;
            goto ExitPoint;
        }

        //
        // OpenProcessToken gives back a primary token
        // Below in the call to pCachedToken->Create we decide
        // if the token is an impersonation token or not based
        // on the LogonMethod.  We know this is a primary token
        // therefor we set the LogonMethod here
        //
        dwLogonMethod = LOGON32_LOGON_SERVICE;
    }
    else if ( dwLogonMethod == IIS_LOGON_METHOD_PASSPORT )
    {   
        //
        // Register the remote IP address with LSA so that it can be logged
        //

        if( pSockAddr != NULL )
        {
            if( pSockAddr->sa_family == AF_INET )
            {
                ss = SecpSetIPAddress( ( PUCHAR )pSockAddr,
                                       sizeof( SOCKADDR_IN ) );
            }
            else if( pSockAddr->sa_family == AF_INET6 )
            {
                ss = SecpSetIPAddress( ( PUCHAR )pSockAddr,
                                       sizeof( SOCKADDR_IN6 ) );
            }
            else
            {
                DBG_ASSERT( FALSE );
            }

            if( !NT_SUCCESS( ss ) )
            {
                *pdwLogonError = GetLastError();
                hr = NO_ERROR;
                goto ExitPoint;
            }
        }

        fRet = IISLogonPassportUserW( pszUserName,
                                      pszDomain,
                                      &hToken );
        if ( !fRet )
        {
            hr = NO_ERROR;
            *pdwLogonError = ERROR_LOGON_FAILURE;
            goto ExitPoint;
        }
    }
    else
    {
        if( fUseSubAuth )
        {
            //
            // Try to logon the anonymous user using the IIS 
            // subauthenticator
            //
            if( !IISLogonNetUserA( straUserName.QueryStr(),
                                   straDomainName.QueryStr(),
                                   achPassword,
                                   NULL,
                                   IIS_SUBAUTH_ID,
                                   dwLogonMethod,
                                   LOGON32_PROVIDER_DEFAULT,
                                   &hToken,
                                   &liPwdExpiry ) )
            {
                hr = NO_ERROR;
                *pdwLogonError = GetLastError();
                goto ExitPoint;
            }
        }
        else
        {
            pszAtSign = wcschr( pszUserName, L'@' );
            if( pszAtSign != NULL && fPossibleUPNLogon )
            { 
                if( !m_dwLastPriorityUPNLogon )
                {
                    //
                    // Try UPN logon first
                    //
                    pDomain[0] = L"";
                    pDomain[1] = pszDomain;
                }
                else
                {
                    //
                    // Try default domain logon first
                    //
                    pDomain[0] = pszDomain;
                    pDomain[1] = L"";
                }

                //
                // Register the remote IP address with LSA so that it can be logged
                //

                if( pSockAddr != NULL )
                {
                    if( pSockAddr->sa_family == AF_INET )
                    {
                        ss = SecpSetIPAddress( ( PUCHAR )pSockAddr,
                                               sizeof( SOCKADDR_IN ) );
                    }
                    else if( pSockAddr->sa_family == AF_INET6 )
                    {
                        ss = SecpSetIPAddress( ( PUCHAR )pSockAddr,
                                               sizeof( SOCKADDR_IN6 ) );
                    }
                    else
                    {
                        DBG_ASSERT( FALSE );
                    }

                    if( !NT_SUCCESS( ss ) )
                    {
                        *pdwLogonError = GetLastError();
                        hr = NO_ERROR;
                        goto ExitPoint;
                    }
                }

                ThreadPoolSetInfo( ThreadPoolIncMaxPoolThreads, 0 );

                fRet = LogonUserEx( pszUserName,
                                    pDomain[0],
                                    pszPassword,
                                    dwLogonMethod,
                                    LOGON32_PROVIDER_DEFAULT,
                                    &hToken,
                                    NULL,              // Logon sid
                                    &pProfile,
                                    &dwProfileLength,
                                    NULL               // Quota limits 
                                    );

                ThreadPoolSetInfo( ThreadPoolDecMaxPoolThreads, 0 );

                if( !fRet )
                {
                    *pdwLogonError = GetLastError();
                    
                    if( *pdwLogonError == ERROR_ACCOUNT_LOCKED_OUT )
                    {
                        goto AccountLockedOut;
                    }

                    if( *pdwLogonError == ERROR_LOGON_FAILURE )
                    {

                        //
                        // Register the remote IP address with LSA so that it can be logged
                        //

                        if( pSockAddr != NULL )
                        {
                            if( pSockAddr->sa_family == AF_INET )
                            {
                                ss = SecpSetIPAddress( ( PUCHAR )pSockAddr,
                                                       sizeof( SOCKADDR_IN ) );
                            }
                            else if( pSockAddr->sa_family == AF_INET6 )
                            {
                                ss = SecpSetIPAddress( ( PUCHAR )pSockAddr,
                                                       sizeof( SOCKADDR_IN6 ) );
                            }
                            else
                            {
                                DBG_ASSERT( FALSE );
                            }

                            if( !NT_SUCCESS( ss ) )
                            {
                                *pdwLogonError = GetLastError();
                                hr = NO_ERROR;
                                goto ExitPoint;
                            }
                        }
                
                        ThreadPoolSetInfo( ThreadPoolIncMaxPoolThreads, 0 );

                        fRet = LogonUserEx( pszUserName,
                                            pDomain[1],
                                            pszPassword,
                                            dwLogonMethod,
                                            LOGON32_PROVIDER_DEFAULT,
                                            &hToken,
                                            NULL,              // Logon sid
                                            &pProfile,
                                            &dwProfileLength,
                                            NULL               // Quota limits 
                                            );

                        ThreadPoolSetInfo( ThreadPoolDecMaxPoolThreads, 0 );

                        if ( !fRet )
                        {                            
                            //
                            // If we couldn't logon, then return no error.  The caller will
                            // determine failure due to *ppCachedToken == NULL
                            //
    
                            *pdwLogonError = GetLastError();

                            if( *pdwLogonError == ERROR_ACCOUNT_LOCKED_OUT )
                            {
                                goto AccountLockedOut;
                            }

                            hr = NO_ERROR;
                            goto ExitPoint;
                        }
                    }
                    else
                    {
                        hr = NO_ERROR;
                        goto ExitPoint;
                    }
                }
            }
            else
            {
                //
                // Register the remote IP address with LSA so that it can be logged
                //

                if( pSockAddr != NULL )
                {
                    if( pSockAddr->sa_family == AF_INET )
                    {
                        ss = SecpSetIPAddress( ( PUCHAR )pSockAddr,
                                               sizeof( SOCKADDR_IN ) );
                    }
                    else if( pSockAddr->sa_family == AF_INET6 )
                    {
                        ss = SecpSetIPAddress( ( PUCHAR )pSockAddr,
                                               sizeof( SOCKADDR_IN6 ) );
                    }
                    else
                    {
                        DBG_ASSERT( FALSE );
                    }

                    if( !NT_SUCCESS( ss ) )
                    {
                        *pdwLogonError = GetLastError();
                        hr = NO_ERROR;
                        goto ExitPoint;
                    }
                }
                
                //
                // The user name is absolutely not in UPN format 
                //

                ThreadPoolSetInfo( ThreadPoolIncMaxPoolThreads, 0 );

                fRet = LogonUserEx( pszUserName,
                                    pszDomain,
                                    pszPassword,
                                    dwLogonMethod,
                                    LOGON32_PROVIDER_DEFAULT,
                                    &hToken,
                                    NULL,              // Logon sid
                                    &pProfile,
                                    &dwProfileLength,
                                    NULL               // Quota limits 
                                    );

                ThreadPoolSetInfo( ThreadPoolDecMaxPoolThreads, 0 );

                if( !fRet )
                {
                    //
                    // If we couldn't logon, then return no error.  The caller will
                    // determine failure due to *ppCachedToken == NULL
                    //
        
                    *pdwLogonError = GetLastError();

                    if( *pdwLogonError == ERROR_ACCOUNT_LOCKED_OUT )
                    {
                        goto AccountLockedOut;
                    }

                    hr = NO_ERROR;
                    goto ExitPoint;
                }
            }
        }
    }

    //
    // Create the entry
    //

    pCachedToken = new TOKEN_CACHE_ENTRY( this );
    if ( pCachedToken == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto ExitPoint;
    }

    //
    // Set the cache key
    //

    hr = pCachedToken->SetCacheKey( &tokenKey );
    if ( FAILED( hr ) )
    {
        goto ExitPoint;
    }

    //
    // Get the password expiration information for the current user
    //

    //
    // Set the token/properties
    //

    hr = pCachedToken->Create( hToken,
                               pszPassword,
                               pProfile ? 
                               &(( ( PMSV1_0_INTERACTIVE_PROFILE )pProfile )->PasswordMustChange) :
                               &liPwdExpiry,
                               dwLogonMethod == LOGON32_LOGON_NETWORK           ||
                               dwLogonMethod == LOGON32_LOGON_NETWORK_CLEARTEXT ||
                               dwLogonMethod == IIS_LOGON_METHOD_PASSPORT ||
                               dwLogonMethod == LOGON32_LOGON_IIS_NETWORK );
    if ( FAILED( hr ) )
    {
        goto ExitPoint;
    }
    
    AddCacheEntry( pCachedToken );

    //
    // Return it
    //
    
    *ppCachedToken = pCachedToken;

    goto ExitPoint;

AccountLockedOut:

    if( SUCCEEDED( hr ) )
    {
        //
        // Succeeded hr means only passwords don't match
        //
        
        FlushCacheEntry( &tokenKey );
    }

    hr = NO_ERROR;

ExitPoint:
    if ( FAILED( hr ) )
    {
        if ( pCachedToken != NULL )
        {
            pCachedToken->DereferenceCacheEntry();
        }
        if ( hToken != NULL )
        {
            CloseHandle( hToken );
        }
    }

    if ( pProfile != NULL )
    {
        LsaFreeReturnBuffer( pProfile );
    }

    //
    // Replace the slash before we continue
    //
    
    if ( pszSlash != NULL )
    {
        *pszSlash = L'\\';
    }
        
    return hr;
}

HRESULT
ToHex(
    IN  BUFFER & buffSrc,
    OUT STRA   & strDst
)
/*++

Routine Description:

    Convert binary data to ASCII hex representation

Arguments:

    buffSrc - binary data to convert
    strDst - buffer receiving ASCII representation of pSrc

Return Value:

    HRESULT

--*/
{
#define TOHEX(a) ( (a) >= 10 ? 'a' + (a) - 10 : '0' + (a) )

    HRESULT hr = S_OK;
    PBYTE   pSrc;
    PCHAR   pDst;

    hr = strDst.Resize( 2 * buffSrc.QuerySize() + 1 );
    if( FAILED( hr ) )
    {
        goto exit;
    }

    pSrc = ( PBYTE ) buffSrc.QueryPtr();
    pDst = strDst.QueryStr();

    for ( UINT i = 0, j = 0 ; i < buffSrc.QuerySize() ; i++ )
    {
        UINT v;
        v = pSrc[ i ] >> 4;
        pDst[ j++ ] = ( CHAR )TOHEX( v );
        v = pSrc[ i ] & 0x0f;
        pDst[ j++ ] = ( CHAR )TOHEX( v );
    }

    DBG_REQUIRE( strDst.SetLen( j ) );

exit:

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulatq\apppool.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     AppPool.cxx

   Abstract:
     Defines the functions used to access the data channel.

   Author:

       Murali R. Krishnan    ( MuraliK )     20-Oct-1998
       Lei Jin               ( leijin  )     13-Apr-1999    Porting

   Project:

       IIS Worker Process

--*/

#include "precomp.hxx"
#include "AppPool.hxx"

UL_APP_POOL::UL_APP_POOL(
    VOID
) : _hAppPool( NULL )
{
}

UL_APP_POOL::~UL_APP_POOL(
    VOID
)
{
    Cleanup();
}

HRESULT
UL_APP_POOL::Initialize(
    LPCWSTR             pwszAppPoolName
)
/*++

Routine Description:

    Initialize UL AppPool

Arguments:

    pwszAppPoolName - AppPool Name

Return Value:

    HRESULT

--*/
{
    ULONG               rc;

    if ( _hAppPool != NULL )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "AppPool already open!\n" ));

        return HRESULT_FROM_WIN32( ERROR_DUP_NAME );
    }

    _Lock.WriteLock();

    rc = HttpOpenAppPool( &_hAppPool,
                          pwszAppPoolName,
                          0 );

    _Lock.WriteUnlock();

    if ( rc != NO_ERROR )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to open AppPool '%ws'.  rc = %d\n",
                    pwszAppPoolName,
                    rc ));

        return HRESULT_FROM_WIN32( rc );
    }

    return NO_ERROR;
}

HRESULT
UL_APP_POOL::Cleanup(
    VOID
)
/*++

Routine Description:

    Close data channel

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HRESULT             hr = NO_ERROR;
    HANDLE              hAppPool = NULL;
    bool                fWriteLocked = false;
    DWORD               dwSleepCount = 0;

    if ( _hAppPool != NULL )
    {
        fWriteLocked = _Lock.TryWriteLock();
        while ( !fWriteLocked )
        {
            dwSleepCount = !dwSleepCount;
            Sleep( dwSleepCount );
            
            fWriteLocked = _Lock.TryWriteLock();
        }
        
        hAppPool = _hAppPool;
        _hAppPool = NULL;

        _Lock.WriteUnlock();

        DBG_ASSERT( hAppPool != NULL );
    
        if ( !CloseHandle( hAppPool ) )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
        }
    }
    
    return hr;
}

HANDLE
UL_APP_POOL::QueryAndLockHandle(
    VOID
)
/*++

Routine Description:

    Read locks and returns the handle.

Arguments:

    None

Return Value:

    HANDLE

--*/
{
    _Lock.ReadLock();

    return _hAppPool;
}

HRESULT
UL_APP_POOL::UnlockHandle(
    VOID
)
/*++

Routine Description:

    Read unlocks.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    DBG_ASSERT(_Lock.IsReadLocked());

    _Lock.ReadUnlock();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulatq\makefile.inc ===
$(O)\iiswp.res: iiswp.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulatq\controlchannel.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     ControlChannel.cxx

   Abstract:
     Defines the functions used to access the control channel.

   Author:

       Murali R. Krishnan    ( MuraliK )     15-Oct-1998
       Lei Jin               ( leijin  )     13-Apr-1999    Porting

   Project:

       IIS Worker Process

--*/


# include "precomp.hxx"
# include "ControlChannel.hxx"

/********************************************************************++

  UL_CONTROL_CHANNEL::Initialize()

  Description:
     This function initializes the control channel for given address, NSGO, 
     and host name. It opens the control channel, registers a virtual host,
     and NSGO. After that it registers the URL for which notifications are 
     to be handled within the NSGO.

  Arguments:


  Returns:

++********************************************************************/

ULONG 
UL_CONTROL_CHANNEL::Initialize( 
    IN MULTISZ& mszURLList,
    IN LPCWSTR  pwszAppPoolName,
    IN DWORD    dwSiteId
    )
{
    ULONG   rc;
    LPCWSTR pwszURL;

    if ( m_hControlChannel != NULL) 
    {
        //
        // There is already a control channel
        //
        
        DBGPRINTF(( DBG_CONTEXT, "Duplicate open of control channel\n"));
        return ERROR_DUP_NAME;
    }
    
    //
    // 1. Open a control channel object from the UL driver
    //
    
    rc = HttpOpenControlChannel( &m_hControlChannel, 0);

    if ( NO_ERROR != rc) 
    {
        IF_DEBUG( ERROR)
        {
            DBGPRINTF(( DBG_CONTEXT, 
                        "UlOpenControlChannel() failed. Error = %08x. Returning\n", 
                        rc
                        ));
        }

        return (rc);
    }

    //
    // 2. Create a Config Group on this control channel
    //
    
    rc = HttpCreateConfigGroup( m_hControlChannel, &m_ConfigGroupId );

    if ( NO_ERROR != rc) 
    {
        IF_DEBUG(ERROR) 
        {
            DBGPRINTF(( DBG_CONTEXT, 
                       "UlCreateConfigGroup failed. Error=%08x. Returning\n",
                       rc
                       ));
        }

        return rc;
    }

    //
    // 3. Insert all specified URLs into the config group
    //

    pwszURL = mszURLList.First();

    while (NULL != pwszURL)
    {
        rc = AddURLToConfigGroup(pwszURL, dwSiteId);

        if (NO_ERROR != rc)
        {
            return rc;
        }

        pwszURL = mszURLList.Next(pwszURL);
    }

    //
    // 4. Activate the Control Channel and the Config Group
    //

    HTTP_ENABLED_STATE    ccState = HttpEnabledStateActive;

    rc = HttpSetControlChannelInformation( m_hControlChannel,
                                           HttpControlChannelStateInformation,
                                           &ccState,
                                           sizeof(ccState));

    if ( NO_ERROR != rc) 
    {
        IF_DEBUG(ERROR) 
        {
            DBGPRINTF(( DBG_CONTEXT, 
                       "Unable to activate ControlChannel. Error=%08x. Returning\n", rc
                        ));
        }

        return rc;
    }

    HTTP_CONFIG_GROUP_STATE   cgState;

    cgState.Flags.Present = 1;
    cgState.State         = HttpEnabledStateActive;  
                                         
    rc = HttpSetConfigGroupInformation( m_hControlChannel,
                                        m_ConfigGroupId,
                                        HttpConfigGroupStateInformation,
                                        &cgState,
                                        sizeof(cgState));

    if ( NO_ERROR != rc) 
    {
        IF_DEBUG(ERROR) 
        {
            DBGPRINTF(( DBG_CONTEXT, 
                       "Unable to activate Config Group. Error=%08x. Returning\n", rc
                        ));
        }

        return rc;
    }

    //
    // 5. Create an AppPool 
    //

    rc = HttpCreateAppPool( &m_hAppPool,
                            pwszAppPoolName,
                            0,
                            0
                          );

    if ( NO_ERROR != rc) 
    {
        IF_DEBUG(ERROR) 
        {
            DBGPRINTF(( DBG_CONTEXT, 
                       "UlCreateAppPool failed for AppPool '%ws'. Error=%08x. Returning\n",
                       pwszAppPoolName, rc
                        ));
        }

        return rc;
    }
    
    //
    // 6. Associate AppPool with the config group
    //

    HTTP_CONFIG_GROUP_APP_POOL    AppPoolConfig;

    AppPoolConfig.Flags.Present = 1;
    AppPoolConfig.AppPoolHandle = m_hAppPool;
    
    rc = HttpSetConfigGroupInformation( m_hControlChannel,
                                        m_ConfigGroupId,
                                        HttpConfigGroupAppPoolInformation,
                                        &AppPoolConfig,
                                        sizeof(AppPoolConfig)
                                      );
    if ( NO_ERROR != rc) 
    {
        IF_DEBUG(ERROR) 
        {
            DBGPRINTF(( DBG_CONTEXT, 
                       "UlSetConfigGroupInformation failed for AppPool '%ws'. Error=%08x. Returning\n",
                       pwszAppPoolName, rc
                        ));
        }

        return rc;
    }

    //
    //  7.  Enable the app pool
    //

    HTTP_APP_POOL_ENABLED_STATE NewHttpAppPoolState = HttpAppPoolEnabled;

    rc = HttpSetAppPoolInformation(
                        m_hAppPool,                // app pool handle
                        HttpAppPoolStateInformation,    // information class
                        reinterpret_cast <VOID *> ( &NewHttpAppPoolState ),  // data
                        sizeof( HTTP_APP_POOL_ENABLED_STATE )    // data length
                        );

    if ( rc != NO_ERROR )
    {
        IF_DEBUG(ERROR) 
        {
            DBGPRINTF(( DBG_CONTEXT, 
                       "HttpSetAppPoolInformation failed for AppPool '%ws'. Error=%08x. Returning\n",
                       pwszAppPoolName, rc
                        ));
        }

        return rc;

    }

    
    return (rc);
    
} // UL_CONTROL_CHANNEL::Initialize()

/********************************************************************++
++********************************************************************/


ULONG 
UL_CONTROL_CHANNEL::Cleanup(void)
{ 
    ULONG rc = NO_ERROR;

    if ( m_hControlChannel != NULL) 
    {
        if ( ! HTTP_IS_NULL_ID(&m_ConfigGroupId) )
        {
            rc = HttpDeleteConfigGroup( m_hControlChannel, m_ConfigGroupId);
            HTTP_SET_NULL_ID(&m_ConfigGroupId);
        }

        if ( NULL != m_hAppPool )
        {
            if ( !::CloseHandle( m_hAppPool))
            {
                rc = GetLastError();
            }
        }

        m_hAppPool = NULL;
        
        if (!::CloseHandle( m_hControlChannel)) 
        {
            rc = GetLastError();
        }
        
        m_hControlChannel = NULL;
    }
    
    return (rc);
    
} // UL_CONTROL_CHANNEL::Cleanup()

/********************************************************************++
++********************************************************************/

ULONG
UL_CONTROL_CHANNEL::AddURLToConfigGroup( IN LPCWSTR  pwszURL,
                                         IN DWORD    dwSiteId )
{
    //
    //  Add the URL to the Config Group
    //

    ULONG rc;

    HTTP_URL_CONTEXT UrlContext = dwSiteId;
    UrlContext = UrlContext << 32;

    rc = HttpAddUrlToConfigGroup( m_hControlChannel,
                                  m_ConfigGroupId,
                                  pwszURL,
                                  UrlContext
                                );
    
    if ( NO_ERROR != rc) 
    {
        IF_DEBUG (ERROR)
        {
            DBGPRINTF((DBG_CONTEXT, 
                       "UlAddUrlToConfigGroup() failed. Error=%08x\n",
                       rc));
        }
    }

    return (rc);
}

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\testwp\testwp.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     testwp.cxx

   Abstract:
     Main module for the Rogue Worker Process. Takes the place of w3wp.exe/w3core.dll
     and calls directly into w3dt.dll, which will have been overwritten by tw3dt.dll.
 
   Author:

       Michael Brown    ( MiBrown )     4-Mar-2002

   Environment:
       Win32 - User Mode

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "precomp.hxx"

HTTP_DATA_CHUNK        g_DataChunk;
HTTP_RESPONSE            g_HttpResponse;

VOID
OnNewRequest(
    ULATQ_CONTEXT           ulatqContext
)
{
    HRESULT             hr;

    //
    // Set a context to receive on completions
    //

    UlAtqSetContextProperty( ulatqContext,
                             ULATQ_PROPERTY_COMPLETION_CONTEXT,
                             (PVOID) ulatqContext );
    
    //
    // Just send the response
    //
    DWORD                      cbSent;


    hr = UlAtqSendHttpResponse( ulatqContext,
                                TRUE,               // async
                                0,                  // no special flags
                                &g_HttpResponse,
                                NULL,               // no UL cache
                                &cbSent,               // bytes sent
                                NULL );             // no log
    if ( FAILED( hr ) )
    {
        UlAtqFreeContext( ulatqContext );
    }
}


VOID
OnIoCompletion(
    VOID *                    pContext,
    DWORD                   cbWritten,
    DWORD                   dwCompletionStatus,
    OVERLAPPED *         lpo
)
{
    //
    // Ignore the completion.  Just cleanup the request
    //

    UlAtqFreeContext( (ULATQ_CONTEXT) pContext );
}

VOID
OnUlDisconnect(
    VOID *                  pvContext
)
{
    return;
}

VOID
OnShutdown(
    BOOL fDoImmediate
)
{
    return;
}

HRESULT FakeCollectCounters(PBYTE *ppCounterData,
                            DWORD *pdwCounterData)
{
    return E_FAIL;
}


extern "C" INT
__cdecl
wmain(
    INT             argc,
    PWSTR        argv[]
    )
{
    HRESULT             hr;
    ULATQ_CONFIG   ulatqConfig;

    //
    // One time initialization of generic response
    //

    g_DataChunk.DataChunkType = HttpDataChunkFromMemory;
    g_DataChunk.FromMemory.pBuffer = "Hello From The IIS Rogue Worker Process!";
    g_DataChunk.FromMemory.BufferLength = strlen ((const char *) g_DataChunk.FromMemory.pBuffer);
    
    g_HttpResponse.Flags = 0;
    g_HttpResponse.StatusCode = 200;
    g_HttpResponse.pReason = "OK";
    g_HttpResponse.ReasonLength = (USHORT) strlen(g_HttpResponse.pReason);
    g_HttpResponse.Headers.UnknownHeaderCount = 1;
    g_HttpResponse.EntityChunkCount = 1;
    g_HttpResponse.pEntityChunks = &g_DataChunk;

    //
    // set the known headers
    //

    //g_HttpResponse.Headers.KnownHeaders[HttpHeaderContentLength].pRawValue = "0";
   // g_HttpResponse.Headers.KnownHeaders[HttpHeaderContentLength].RawValueLength = sizeof (CHAR);

    //
    // set the unknown headers
    //

    HTTP_UNKNOWN_HEADER UnknownHeader;

    memset(&UnknownHeader, 0, sizeof(HTTP_UNKNOWN_HEADER));

    g_HttpResponse.Headers.UnknownHeaderCount = 1;
    g_HttpResponse.Headers.pUnknownHeaders = &UnknownHeader;
    
    //
    // Set Header PID
    //

    PHTTP_UNKNOWN_HEADER pHeaderPid = g_HttpResponse.Headers.pUnknownHeaders;
  
    pHeaderPid->pName = "PID";
    pHeaderPid->NameLength = (USHORT) strlen (pHeaderPid->pName);

    CHAR Pid[256];
    
    pHeaderPid->pRawValue = _itoa (GetCurrentProcessId(), Pid, 10);
    pHeaderPid->RawValueLength = (USHORT) strlen (pHeaderPid->pRawValue);
    
/*
    //
    // Set Header Application-Pool
    //

    PHTTP_UNKNOWN_HEADER pHeaderAppPool = (pResponse->Headers.pUnknownHeaders + 1);

    pHeaderAppPool->pName = "Application-Pool";
    pHeaderAppPool->NameLength = strlen (pHeaderAppPool->pName);

    WP_CONFIG* wpConfig = g_pwpContext->QueryConfig ();

    CHAR AppPoolName[256]; 
    wcstombs (AppPoolName, wpConfig->QueryAppPoolName(), wcslen(wpConfig->QueryAppPoolName()));
    pHeaderAppPool->pRawValue = AppPoolName;
    pHeaderAppPool->RawValueLength = strlen(pHeaderAppPool->pRawValue);
*/

    //
    // Initialize ULATQ
    //

    ulatqConfig.pfnNewRequest = OnNewRequest;
    ulatqConfig.pfnIoCompletion = OnIoCompletion;
    ulatqConfig.pfnOnShutdown = OnShutdown;
    ulatqConfig.pfnDisconnect = OnUlDisconnect;
    ulatqConfig.pfnCollectCounters = FakeCollectCounters;

    hr = UlAtqInitialize( argc, argv, &ulatqConfig );
    
    if ( FAILED( hr ) )
    {
        return -1;
    }

    //
    // Start listening
    //

    UlAtqStartListen();

    //
    // Cleanup
    //

    UlAtqTerminate(S_OK);

    return 0;
}

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulatq\ulatq.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module Name :
     ulatq.cxx

   Abstract:
     Exported ULATQ.DLL routines

   Author:
     Bilal Alam (balam)             13-Dec-1999

   Environment:
     Win32 - User Mode

   Project:
     ULATQ.DLL
--*/

#include "precomp.hxx"

//
//  Configuration parameters registry key.
//

#define INET_INFO_KEY \
            "System\\CurrentControlSet\\Services\\w3svc"

#define INET_INFO_PARAMETERS_KEY \
            INET_INFO_KEY "\\Parameters"

const CHAR g_pszWpRegLocation[] =
    INET_INFO_PARAMETERS_KEY "\\w3dt";

DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();
DECLARE_PLATFORM_TYPE();


WP_CONTEXT *            g_pwpContext = NULL;

//
// Completion routines for new requests, io completions, and disconnect
// notifications.
//
// CODEWORK: Can we get away with these being global
//

PFN_ULATQ_NEW_REQUEST           g_pfnNewRequest = NULL;
PFN_ULATQ_IO_COMPLETION         g_pfnIoCompletion = NULL;
PFN_ULATQ_DISCONNECT            g_pfnDisconnect = NULL;
PFN_ULATQ_ON_SHUTDOWN           g_pfnOnShutdown = NULL;
PFN_ULATQ_COLLECT_PERF_COUNTERS g_pfnCollectCounters = NULL;


HRESULT
UlAtqInitialize(
    INT                 argc,
    LPWSTR              argv[],
    ULATQ_CONFIG *      pConfig
)
/*++

Routine Description:

    Initialize ULATQ

Arguments:

    argc - Number of command line parameters to worker process
    argv - Command line parameters
    pConfig - Configuration settings for ULATQ

Return Value:

    HRESULT

--*/
{
    HRESULT             rc = NO_ERROR;
    BOOL                fUlInit = FALSE;
    BOOL                fThreadPoolInit = FALSE;
    HTTPAPI_VERSION     HttpVersion = HTTPAPI_VERSION_1;

    CREATE_DEBUG_PRINT_OBJECT("w3dt");
#if DBG
    if (!VALID_DEBUG_PRINT_OBJECT())
    {
        return E_FAIL;
    }
#endif

    LOAD_DEBUG_FLAGS_FROM_REG_STR( g_pszWpRegLocation, DEBUG_ERROR );

    INITIALIZE_PLATFORM_TYPE();

    //
    // Honour ULATQ_CONFIG settings.  Set completion routines
    // Need to set this up before we do any other initialization
    //

    g_pfnNewRequest = pConfig->pfnNewRequest;
    g_pfnIoCompletion = pConfig->pfnIoCompletion;
    g_pfnDisconnect = pConfig->pfnDisconnect;
    g_pfnOnShutdown = pConfig->pfnOnShutdown;
    g_pfnCollectCounters = pConfig->pfnCollectCounters;

    //
    // Initialize the thread pool
    //

    rc = ThreadPoolInitialize( 0 ); // Use the process default stack size
    if ( FAILED( rc ) )
    {
        goto Finished;
    }
    fThreadPoolInit = TRUE;

    //
    // Init UL
    //
    
    rc = HttpInitialize( HttpVersion, 0, NULL );
    if ( rc != NO_ERROR )
    {
        rc = HRESULT_FROM_WIN32( rc );
    
        DBGPRINTF(( DBG_CONTEXT, "Error (rc=%08x) in UlInitialize. Exiting\n",
                    rc ));
        goto Finished;
    }
    fUlInit = TRUE;

    //
    // Create global state object
    //

    g_pwpContext = new WP_CONTEXT;
    if ( g_pwpContext == NULL )
    {
        rc = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto Finished;
    }

    //
    // Do global state initialization
    //

    rc = g_pwpContext->Initialize( argc, argv );
    if ( rc != NO_ERROR )
    {
        //
        // WP_CONTEXT::Initialize returns a Win32 error code
        //

        rc = HRESULT_FROM_WIN32( rc );
        goto Finished;
    }

Finished:
    if ( rc != NO_ERROR )
    {
        if ( g_pwpContext != NULL )
        {
            delete g_pwpContext;
            g_pwpContext = NULL;
        }

        if ( fUlInit )
        {
            HttpTerminate(0, NULL);
        }

        if ( fThreadPoolInit )
        {
            ThreadPoolTerminate();
        }
    }

    return rc;
}

HRESULT
UlAtqStartListen(
    VOID
)
/*++

Routine Description:

    Begin listening for HTTP requests from UL.  This call must happen only
    after ULATQ has been initialized correctly (for example, completion
    routines should be set).

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HRESULT         hr = NO_ERROR;

    DBG_ASSERT( g_pfnIoCompletion != NULL );
    DBG_ASSERT( g_pfnNewRequest != NULL );

    //
    // Make some UlReceiveHttpRequest calls
    //

    hr = g_pwpContext->Start();
    if ( FAILED(hr) )
    {
        //
        // If we failed to start, we may outstanding requests to cleanup. 
        //
        
        goto DoShutdown;
    }

    //
    // Send message to WAS that our initialization is complete
    //
    g_pwpContext->SendInitCompleteMessage( S_OK );

    //
    // Wait for shutdown because of WAS/request-count-max/etc.
    //

    g_pwpContext->RunMainThreadLoop();

DoShutdown:

    //
    // Do stuff needed to stop listening for new requests
    //
    UL_NATIVE_REQUEST::StopListening();

    //
    // Before connection drain, allow the user to execute some code
    //

    if ( g_pfnOnShutdown != NULL )
    {
        g_pfnOnShutdown( g_pwpContext->QueryDoImmediateShutdown() );
    }

    //
    // Before we return, wait for outstanding requests to drain.  This
    // prevents race before caller's shutdown and new requests coming in
    //

    g_pwpContext->CleanupOutstandingRequests();

    return hr;
}

VOID
UlAtqTerminate(
    HRESULT hrToSend
)
/*++

Routine Description:

    Terminate ULATQ

Arguments:

    None

Return Value:

    None

--*/
{
    if ( g_pwpContext != NULL )
    {
        if (FAILED(hrToSend))
        {
            g_pwpContext->SendInitCompleteMessage( hrToSend );
        }

        g_pwpContext->Terminate();
        delete g_pwpContext;
        g_pwpContext = NULL;
    }

    HttpTerminate(0, NULL);

    ThreadPoolTerminate();

    DELETE_DEBUG_PRINT_OBJECT();
}

VOID *
UlAtqGetContextProperty(
    ULATQ_CONTEXT               pContext,
    ULATQ_CONTEXT_PROPERTY_ID   PropertyId
)
/*++

Routine Description:

    Get the UL_HTTP_REQUEST from the ULATQ_CONTEXT

Arguments:

    pContext - ULATQ_CONTEXT
    PropertyId - Property Id to set

Return Value:

    The actual property

--*/
{
    switch (PropertyId)
    {
    case ULATQ_PROPERTY_HTTP_REQUEST:
        UL_NATIVE_REQUEST *         pRequest;
        pRequest = (UL_NATIVE_REQUEST*) pContext;
        DBG_ASSERT( pRequest != NULL );

        return pRequest->QueryHttpRequest();

    case ULATQ_PROPERTY_APP_POOL_ID:
        return (VOID *)g_pwpContext->QueryConfig()->QueryAppPoolName();

    case ULATQ_PROPERTY_IS_COMMAND_LINE_LAUNCH:
        return (VOID *)!(g_pwpContext->QueryConfig()->QueryRegisterWithWAS());

    case ULATQ_PROPERTY_DO_CENTRAL_BINARY_LOGGING:
        return (VOID *)(DWORD_PTR)g_pwpContext->QueryConfig()->QueryDoCentralBinaryLogging();

    default:
        DBG_ASSERT(FALSE);
    }

    return NULL;
}

VOID
UlAtqSetContextProperty(
    ULATQ_CONTEXT               pContext,
    ULATQ_CONTEXT_PROPERTY_ID   PropertyId,
    PVOID                       pvData
)
/*++

Routine Description:

    Set a property of the ULATQ_CONTEXT

Arguments:

    pContext - ULATQ_CONTEXT
    PropertyId - Property Id to set
    pvData - Data specific to the property being set

Return Value:

    None

--*/
{
    UL_NATIVE_REQUEST *         pRequest;

    pRequest = (UL_NATIVE_REQUEST*) pContext;
    DBG_ASSERT( pRequest != NULL );

    switch ( PropertyId )
    {
    case ULATQ_PROPERTY_COMPLETION_CONTEXT:
        pRequest->SetContext( pvData );
        break;

    default:
        DBG_ASSERT( FALSE );
    }
}

VOID
UlAtqFreeContext(
    ULATQ_CONTEXT               pContext
)
/*++

Routine Description:

    Frees the ULATQ_CONTEXT so that it can be used to retrieve next request

Arguments:

    pContext - ULATQ_CONTEXT

Return Value:

    None

--*/
{
    UL_NATIVE_REQUEST *         pRequest;

    pRequest = (UL_NATIVE_REQUEST*) pContext;
    DBG_ASSERT( pRequest != NULL );

    pRequest->ResetContext();
}

HRESULT
UlAtqSendHttpResponse(
    ULATQ_CONTEXT               pContext,
    BOOL                        fAsync,
    DWORD                       dwFlags,
    HTTP_RESPONSE *             pResponse,
    HTTP_CACHE_POLICY *         pCachePolicy,
    DWORD                      *pcbSent,
    HTTP_LOG_FIELDS_DATA       *pUlLogData
)
/*++

Routine Description:

    Send a response to the client

Arguments:

    pContext - ULATQ_CONTEXT
    fAsync - Asynchronous or not?
    dwFlags - Response flags (like killing the connection)
    pResponse - UL_HTTP_RESPONSE to send
    pCachePolicy - Cache policy

Return Value:

    Win32 Error

--*/
{
    UL_NATIVE_REQUEST *         pRequest;

    pRequest = (UL_NATIVE_REQUEST*) pContext;
    DBG_ASSERT( pRequest != NULL );

    return pRequest->SendResponse( fAsync,
                                   dwFlags,
                                   pResponse,
                                   pCachePolicy,
                                   pcbSent,
                                   pUlLogData );
}

HRESULT
UlAtqSendEntityBody(
    ULATQ_CONTEXT               pContext,
    BOOL                        fAsync,
    DWORD                       dwFlags,
    USHORT                      cChunks,
    HTTP_DATA_CHUNK *           pChunks,
    DWORD                      *pcbSent,
    HTTP_LOG_FIELDS_DATA       *pUlLogData
)
/*++

Routine Description:

    Send entity to the client

Arguments:

    pContext - ULATQ_CONTEXT
    fAsync - Asynchronous or not?
    dwFlags - Response flags (like killing the connection)
    cChunks - Number of chunks in the response
    pChunks - Points to array of chunks

Return Value:

    HRESULT

--*/
{
    UL_NATIVE_REQUEST *         pRequest;

    pRequest = (UL_NATIVE_REQUEST*) pContext;
    DBG_ASSERT( pRequest != NULL );

    return pRequest->SendEntity( fAsync,
                                 dwFlags,
                                 cChunks,
                                 pChunks,
                                 pcbSent,
                                 pUlLogData );
}

HRESULT
UlAtqReceiveEntityBody(
    ULATQ_CONTEXT               pContext,
    BOOL                        fAsync,
    DWORD                       dwFlags,
    VOID *                      pBuffer,
    DWORD                       cbBuffer,
    DWORD *                     pBytesReceived
)
/*++

Routine Description:

    Receive entity from the client

Arguments:

    pContext - ULATQ_CONTEXT
    fAsync - Asynchronous or not?
    dwFlags - Response flags (like killing the connection)
    pBuffer - Buffer to store the data
    cbBuffer - The size of the receive buffer
    pBytesReceived - The number of bytes copied to the buffer upon return

Return Value:

    HRESULT

--*/
{
    UL_NATIVE_REQUEST *         pRequest;

    pRequest = (UL_NATIVE_REQUEST*) pContext;
    DBG_ASSERT( pRequest != NULL );

    return pRequest->ReceiveEntity( fAsync,
                                    dwFlags,
                                    pBuffer,
                                    cbBuffer,
                                    pBytesReceived);
}

HRESULT
UlAtqWaitForDisconnect(
    HTTP_CONNECTION_ID              connectionId,
    BOOL                            fAsync,
    PVOID                           pvContext,
    BOOL *                          pfAlreadyCompleted
)
/*++

Routine Description:

    Used to wait for a connection to close.

Arguments:

    connectionId - connection in question
    fAsync - should we wait asynchronously?
    pvContext - context to pass back on async disconnect wait

Return Value:

    HRESULT

--*/
{
    UL_DISCONNECT_CONTEXT *         pContext;
    ULONG                           Status;
    HRESULT                         hr = NO_ERROR;
    HANDLE                          hAsync;

    //
    // Allocate an async context which will be freed once the connection
    // has been closed
    //

    pContext = new UL_DISCONNECT_CONTEXT( pvContext );
    if ( pContext == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }

    hAsync = g_pwpContext->GetAndLockAsyncHandle();

    pContext->ReferenceUlDisconnectContext();

    if ( hAsync != NULL )
    {
        //
        // Do the wait
        //

        Status = HttpWaitForDisconnect( hAsync,
                                        connectionId,
                                        fAsync ? &(pContext->_Overlapped) : NULL );
    }
    else
    {
        Status = ERROR_INVALID_HANDLE;
    }

    DBG_REQUIRE(SUCCEEDED(g_pwpContext->UnlockAsyncHandle()));

    if ( pfAlreadyCompleted )
    {
        *pfAlreadyCompleted = HasOverlappedIoCompleted( &(pContext->_Overlapped) );
    }

    if ( Status != ERROR_IO_PENDING && Status != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Status );
        pContext->DereferenceUlDisconnectContext();
    }

    pContext->DereferenceUlDisconnectContext();

    return hr;
}

HRESULT
UlAtqInduceShutdown(
    BOOL fImmediate
)
/*++

Routine Description:

    Induce shutdown (used when IIS+ hosted in inetinfo.exe).  Simulates
    WAS telling us to shutdown

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    DBG_ASSERT( g_pwpContext != NULL );

    if ( !g_pwpContext->IndicateShutdown( fImmediate ) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    return NO_ERROR;
}

HRESULT
UlAtqReceiveClientCertificate(
    ULATQ_CONTEXT               pContext,
    BOOL                        fAsync,
    BOOL                        fDoCertMap,
    HTTP_SSL_CLIENT_CERT_INFO **ppClientCertInfo
)
/*++

Routine Description:

    Receive client certificate

Arguments:

    pContext - ULATQ context
    fAsync - TRUE if we should do it asynchronously
    fDoCertMap - Map client certificate to token
    ppClientCertInfo - Set to point to client cert on success

Return Value:

    HRESULT

--*/
{
    UL_NATIVE_REQUEST *         pRequest;

    pRequest = (UL_NATIVE_REQUEST*) pContext;
    DBG_ASSERT( pRequest != NULL );
    DBG_ASSERT( pRequest->CheckSignature() );

    return pRequest->ReceiveClientCertificate( fAsync,
                                               fDoCertMap,
                                               ppClientCertInfo );
}

HRESULT
UlAtqFlushUlCache(
    WCHAR *                     pszUrlPrefix
)
/*++

Routine Description:

    Flush the UL cache at the given URL prefix

Arguments:

    pszUrlPrefix - UL prefix to flush

Return Value:

    HRESULT

--*/
{
    HANDLE              hAsync;

    if ( pszUrlPrefix == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    if ( g_pwpContext == NULL )
    {
        //
        // Before removing this assert, please think hard (and then
        // think again)
        //

        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
    }


    //
    // The AppPool handle may already have been closed, eg during shutdown
    //
    hAsync = g_pwpContext->GetAndLockAsyncHandle();

    if ( hAsync != NULL )
    {
        HttpFlushResponseCache( hAsync,
                                pszUrlPrefix,
                                0,
                                NULL );
    }

    DBG_REQUIRE(SUCCEEDED(g_pwpContext->UnlockAsyncHandle()));


    //
    // Mask the error since we may be flushing URLs which aren't
    // in the cache (that's OK)
    //

    return NO_ERROR;
}

VOID
UlAtqSetUnhealthy(
    VOID
    )
/*++

Routine Description:

    Marks the state of the process as unhealthy

Arguments:

    None

Return Value:

    None

--*/
{
    g_pwpContext->SetUnhealthy();
}


HRESULT
UlAtqAddFragmentToCache(
    HTTP_DATA_CHUNK * pDataChunk,
    WCHAR           * pszFragmentName
)
/*++

Routine Description:

    Add the fragment to cache

Arguments:

    pDataChunk - The chunk to be added
    pszFragmentName - name of the fragment

Return Value:

    HRESULT

--*/
{
    DWORD               err;
    HANDLE              hAsync;
    HTTP_CACHE_POLICY   cachePolicy = { HttpCachePolicyUserInvalidates, 0 };

    hAsync = g_pwpContext->GetAndLockAsyncHandle();

    if ( hAsync != NULL )
    {
        err = HttpAddFragmentToCache( hAsync,
                                      pszFragmentName,
                                      pDataChunk,
                                      &cachePolicy,
                                      NULL );
    }
    else
    {
        err = ERROR_INVALID_HANDLE;
    }

    DBG_REQUIRE(SUCCEEDED(g_pwpContext->UnlockAsyncHandle()));

    return HRESULT_FROM_WIN32(err);
}


HRESULT
UlAtqReadFragmentFromCache(
    WCHAR          * pszFragmentName,
    BYTE           * pvBuffer,
    DWORD            cbSize,
    DWORD          * pcbCopied
)
/*++

Routine Description:

    Read the fragment from cache

Arguments:

    pszFragmentName - name of the fragment
    pvBuffer - the buffer to read in
    cbSize - the size of the buffer
    pcbCopied - the amount copied in on return

Return Value:

    HRESULT

--*/
{
    DWORD               err;
    HANDLE              hAsync;

    hAsync = g_pwpContext->GetAndLockAsyncHandle();

    if ( hAsync != NULL )
    {
        err = HttpReadFragmentFromCache( hAsync,
                                         pszFragmentName,
                                         NULL,
                                         pvBuffer,
                                         cbSize,
                                         pcbCopied,
                                         NULL);
    }
    else
    {
        err = ERROR_INVALID_HANDLE;
    }

    DBG_REQUIRE(SUCCEEDED(g_pwpContext->UnlockAsyncHandle()));

    return HRESULT_FROM_WIN32(err);
}


HRESULT
UlAtqRemoveFragmentFromCache(
    WCHAR          * pszFragmentName
)
/*++

Routine Description:

    Remove the fragment from cache

Arguments:

    pszFragmentName - name of the fragment

Return Value:

    HRESULT

--*/
{
    DWORD               err;
    HANDLE              hAsync;

    hAsync = g_pwpContext->GetAndLockAsyncHandle();

    if ( hAsync != NULL )
    {
        err = HttpFlushResponseCache( hAsync,
                                      pszFragmentName,
                                      0,
                                      NULL);
    }
    else
    {
        err = ERROR_INVALID_HANDLE;
    }

    DBG_REQUIRE(SUCCEEDED(g_pwpContext->UnlockAsyncHandle()));

    return HRESULT_FROM_WIN32(err);
}

VOID *
UlAtqAllocateMemory(
    ULATQ_CONTEXT               pContext,
    DWORD                       cbSize
)
/*++

Routine Description:

    Allocate some memory associated with the native request

Arguments:

    pContext - ULATQ Context
    cbSize - Size to allocate

Return Value:

    Pointer to memory or NULL if failed

--*/
{
    UL_NATIVE_REQUEST *         pRequest;

    if ( pContext == NULL )
    {
        DBG_ASSERT( FALSE );
        SetLastError( ERROR_INVALID_PARAMETER );
        return NULL;
    }

    pRequest = (UL_NATIVE_REQUEST*) pContext;
    DBG_ASSERT( pRequest->CheckSignature() );
    
    return pRequest->AllocateMemory( cbSize );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulatq\wpconfig.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     WpConfig.cxx

   Abstract:
     Module implementing the Worker Process Configuration Data structure.
     WP_CONFIG object encapsulates configuration supplied from the commandline
     as well as remotely supplied from the admin process.

   Author:

       Murali R. Krishnan    ( MuraliK )     21-Oct-1998

   Environment:
       Win32 - User Mode

   Project:
       IIS Worker Process
--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "precomp.hxx"

/************************************************************
 Launch Parameters for W3WP:

 Private: ( one's only WAS uses )

 -r <N>  ( Number of requests to recycle wp after )
 -t <N>  ( Number of idle milliseconds to shutdown the WP after )
 -a <guid>   ( look for WAS and register with this namepipe  )
 -c      ( Use binary centralized logging )

 Public: ( one's that can be used by command line launch ( must have -Debug )

 -Debug         ( tells us that the user is trying to do the command line launch
                  for debugging purposes has the side affect of not registering with WAS )
 -d <URL List>  ( overrides the default url list of * port 80 with a specific list )
 -s <N>         ( indicates the site that we should assume when listening to these urls ( default is site 1 ) )


 Both: ( one's used by either command line or was )
 
 -ap <AppPoolName>  ( AppPool Name that the wp is serving )
 
 No one:  ( were originally here, but are not being used and are being disabled by my change )

 -l     ( log errors that stop the worker process into the event log )
 -ld    ( disables logging of errors of the worker process to the event log )
 -ad    ( don't look for WAS nor register with it )
 -p     ( tells COR to add IceCAP instrumentation )

 URL List looks like:
    {http[s]://IP:port/URL | http[s]://hostname:port/URL | http[s]://hostname:port:IP/URL}+
     with space as separator
     eg: -d http://localhost:80/  => listen for all HTTP requests on port 80
     eg: -d http://localhost:80/ http://localhost:81/  => listen on port 80 & 81
     eg: -d http://foo:80:111.11.ll.111/ => listen on port 80 to request to 111.11.11.111 with foo as a header.
 ************************************************************/

//
//  While the above shows all the usages for the w3wp command line parameters,
//  the print statment will only show the usage for the actual parameters that 
//  users can use.
//

const WCHAR g_rgwchUsage[] =
L"Usage: %ws [options] \n"
L"\n"
L"\t-debug \n"
L"\t\t This option is required for launching from the command line.\n"
L"\t\t If not provided the app pool name, default url, and site id \n"
L"\t\t will be defaulted to \n"
L"\t\t\t AppPoolName = StandAloneAppPool  \n"
L"\t\t\t URL list    = http://*:80/ \n"
L"\t\t\t Site Id     = 1 \n"
L"\n"
L"\t-ap <Application Pool Name>  \n"
L"\t\t Indicates the application pool name\n"
L"\t\t that will queue requests for the\n"
L"\t\t worker process.  No other worker processes \n"
L"\t\t with this name can be running at the \n"
L"\t\t same time as this one \n"
L"\n"
L"\t-d <URL List> \n"
L"\t\t Indicates the urls to listen to. \n"
L"\t\t Examples: \n"
L"\t\t\t http://*:80/ \n"
L"\t\t\t http://HostString:80/ \n"
L"\t\t\t http://111.11.111.11:80:111.11.111.11/ \n"
L"\t\t\t http://HostString:80:111.11.111.11/ \n"
L"\n"
L"\t-s <#> \n"
L"\t\t Which site are the urls provided associated with. \n"
L"\t\t The site number is used to access data from the metabase \n"
L"\t\t for processing the requests. \n"
;

/************************************************************
 *     Member functions of WP_CONFIG
 ************************************************************/

WP_CONFIG::WP_CONFIG(void)
    : _pwszAppPoolName     (AP_NAME),
      _fSetupControlChannel(FALSE),
      _fLogErrorsToEventLog(FALSE),
      _fRegisterWithWAS    (TRUE),
      _RestartCount    (0),
      _pwszNamedPipeId (NULL),
      _IdleTime        (0),
      _SiteId          (0),
      _fDoCentralBinaryLogging (FALSE)
{
    lstrcpy( _pwszProgram,  L"WP");
}

WP_CONFIG::~WP_CONFIG()
{
    _ulcc.Cleanup();

    delete[] _pwszNamedPipeId;
    _pwszNamedPipeId = NULL;
}


void
WP_CONFIG::PrintUsage() const
{
    wprintf( g_rgwchUsage, _pwszProgram );
}

/********************************************************************++

Routine Description:
    Parses the command line to read in all configuration supplied.
    This function updates the state variables inside WP_CONFIG for use
    in starting up the Worker process.

    See comment at beginning of file for details on the arguments that can be supplied

Arguments:
    argc - count of arguments supplied
    argv - pointer to strings containing the arguments.

Returns:
    Boolean

--********************************************************************/
BOOL
WP_CONFIG::ParseCommandLine(int argc, PWSTR  argv[])
{
    BOOL    fRet = TRUE;
    int     iArg;
    BOOL    fAppPoolNameFound = FALSE;
    BOOL    fUrlsFound = FALSE;

    lstrcpyn( _pwszProgram, argv[0], sizeof _pwszProgram / sizeof _pwszProgram[0]);

    if ( argc < 2)
    {
        DBGPRINTF((DBG_CONTEXT, "Invalid number of parameters (%d)\n", argc));
        PrintUsage();
        return (FALSE);
    }

    for( iArg = 1; iArg < argc; iArg++)
    {
        // get out of here if we all ready found an error.
        if ( fRet == FALSE )
        {
            break;
        }

        if ( (argv[iArg][0] == L'-') || (argv[iArg][0] == L'/'))
        {
            switch (argv[iArg][1])
            {

                case L's': case L'S':

                    if ( argv[iArg][2] != '\0' )
                    {
                        DBGPRINTF((DBG_CONTEXT, "invalid argument %S\n", argv[iArg]));
                        fRet = FALSE;
                    }
                    else
                    {
                        _SiteId = wcstoul(argv[++iArg], NULL, 0);

                        if (_SiteId == 0)
                        {
                            DBGPRINTF((DBG_CONTEXT, "Invalid site id %ws\n", argv[iArg]));
                            fRet = FALSE;
                        }
                        else
                        {
                            DBGPRINTF((DBG_CONTEXT, "Site Id is %lu\n", _SiteId));
                        }
                    }

                break;

                case L'd': case L'D':

                    if ( _wcsicmp(&(argv[iArg][1]), L"Debug") == 0 )
                    {
                        _fSetupControlChannel = TRUE;
                    }
                    else if ( argv[iArg][2] != '\0' )
                    {
                        DBGPRINTF((DBG_CONTEXT, "invalid argument %S\n", argv[iArg]));
                        fRet = FALSE;
                    }
                    else
                    {
                        fUrlsFound = TRUE;

                        // need to determine if the string is just d or if it is debug here.
                       
                        iArg++;

                        while ( (iArg < argc) &&
                                (argv[iArg][0] != L'-') && (argv[iArg][0] != L'/'))
                        {
                            if ( !InsertURLIntoList(argv[iArg]) )
                            {
                                DBGPRINTF((DBG_CONTEXT, "Invalid URL: %ws\n", argv[iArg]));
                            }

                            iArg++;
                        }

                        iArg--;
                    }

                break;

                case L'a': case L'A':

                    if ( ((L'p' == argv[iArg][2]) || (L'P' == argv[iArg][2])) &&
                          (L'\0' == argv[iArg][3] ))
                    {
                        //
                        // get the app pool name
                        //
                        iArg++;

                        _pwszAppPoolName = argv[iArg];

                        fAppPoolNameFound = TRUE;
                    }
                    else if ( L'\0' != argv[iArg][2] )
                    {
                        DBGPRINTF((DBG_CONTEXT, "invalid parameter passed in '%S' \n", argv[iArg]));
                        fRet = FALSE;
                    }
                    else
                    {
                        // -a NamedPipeId
                        iArg++;

                        _pwszNamedPipeId = new WCHAR[wcslen(argv[iArg]) + 1];
                        if ( NULL == _pwszNamedPipeId )
                        {
                            DBGPRINTF((DBG_CONTEXT, "Failed allocation for named pipe name."));
                            fRet = FALSE;
                        }
                        wcscpy(_pwszNamedPipeId, argv[iArg]);
                        DBGPRINTF((DBG_CONTEXT, "NamedPipe Id, %S\n", _pwszNamedPipeId));
                    }
                break;

                case L'r': case L'R':

                    if ( argv[iArg][2] != '\0' )
                    {
                        DBGPRINTF((DBG_CONTEXT, "invalid argument %S\n", argv[iArg]));
                        fRet = FALSE;
                    }
                    else
                    {
                        _RestartCount = wcstoul(argv[++iArg], NULL, 0);

                        if (_RestartCount == 0)
                        {
                            DBGPRINTF((DBG_CONTEXT, "Invalid maximum requests %ws\n", argv[iArg]));
                            fRet = FALSE;
                        }
                        else
                        {
                            DBGPRINTF((DBG_CONTEXT, "Maximum requests is %lu\n", _RestartCount));
                        }
                    }
                break;

                case L't': case L'T':

                    if ( argv[iArg][2] != '\0' )
                    {
                        DBGPRINTF((DBG_CONTEXT, "invalid argument %S\n", argv[iArg]));
                        fRet = FALSE;
                    }
                    else
                    {
                        _IdleTime  = wcstoul(argv[++iArg], NULL, 0);

                        if (_IdleTime == 0)
                        {
                            DBGPRINTF((DBG_CONTEXT, "Invalid idle time %ws\n", argv[iArg]));
                            fRet = FALSE;
                        }
                        else
                        {
                            DBGPRINTF((DBG_CONTEXT, "The idle time value is %lu\n", _IdleTime));
                        }
                    }
                break;

                case L'c': case L'C':
                    if ( argv[iArg][2] != '\0' )
                    {
                        DBGPRINTF((DBG_CONTEXT, "invalid argument %S\n", argv[iArg]));
                        fRet = FALSE;
                    }
                    else
                    {
                        _fDoCentralBinaryLogging = TRUE;
                    }
                break;

                default:
                case L'?':
                    fRet = FALSE;
                break;
            } // switch
        }
        else
        {
            DBG_ASSERT ( !L"Argument passed in that does not start with '-' or '/'" );
            fRet = FALSE;
            break;
        }
    }

    if ( fRet )
    {
        // if we are still on the right track, do some parameter verification.

        // In command line launch mode we need to do some checks.
        if ( _fSetupControlChannel )
        {
            // Don't register with WAS.
            _fRegisterWithWAS = FALSE;

            if ( _SiteId == 0 )
            {
                // default the site id to 1.
                _SiteId = 1;
            }

            if ( !fUrlsFound )
            {
                if ( !InsertURLIntoList(L"http://*:80/") )
                {
                    DBGPRINTF((DBG_CONTEXT, "Error adding default url\n"));
                    fRet = FALSE;
                }
            }

            if ( !fAppPoolNameFound )
            {
                _pwszAppPoolName = L"StandAloneAppPool";
            }

            if ( _pwszNamedPipeId )
            {
                DBGPRINTF((DBG_CONTEXT, "Name pipe id can not be passed when in debugging mode\n"));
                fRet = FALSE;
            }

            if ( _RestartCount != 0 )
            {
                DBGPRINTF((DBG_CONTEXT, "Restart count can not be passed when in debugging mode\n"));
                fRet = FALSE;
            }

            if ( _IdleTime != 0 )
            {
                DBGPRINTF((DBG_CONTEXT, "Idle time can not be passed when in debugging mode\n"));
                fRet = FALSE;
            }
            
        }
        else
        {
            if ( _SiteId != 0 )
            {
                DBGPRINTF((DBG_CONTEXT, "Site id can not be passed when not in debugging mode\n"));
                fRet = FALSE;
            }

            if ( fUrlsFound )
            {
                DBGPRINTF((DBG_CONTEXT, "Urls can not be passed in when not in debugging mode\n"));
                fRet = FALSE;
            }  

            if ( !fAppPoolNameFound )
            {
                DBGPRINTF((DBG_CONTEXT, "No app pool was passed and not in debugging mode\n"));
                fRet = FALSE;
            }       
            
            if ( _pwszNamedPipeId == NULL )
            {
                DBGPRINTF((DBG_CONTEXT, "Named pipe id needs to be passed in when not in debugging mode\n"));
                fRet = FALSE;
            }

            if ( _fRegisterWithWAS == FALSE )
            {
                DBGPRINTF((DBG_CONTEXT, "We needs to register with WAS in when not in debugging mode\n"));
                fRet = FALSE;
            }

        }

    }

    if (!fRet)
    {
        PrintUsage();
    }

    return ( fRet);

} // WP_CONFIG::ParseCommandLine()


/********************************************************************++

Routine Description:
    Sets up the control channel for processing requests. It uses
    the configuration parameters supplied for initializing the
    UL_CONTROL_CHANNEL.

Arguments:

Returns:
    Win32 error

--********************************************************************/

ULONG
WP_CONFIG::SetupControlChannel(void)
{

    //
    // Setup a control channel for our local use now. Used mainly for
    // the purpose of debugging.
    // In general control channel work is done by the AdminProces.
    //

    return _ulcc.Initialize( _mszURLList, _pwszAppPoolName, _SiteId );

} // WP_CONFIG::SetupControlChannel()

/********************************************************************++
--********************************************************************/

WP_CONFIG::InsertURLIntoList( LPCWSTR pwszURL  )
{
    LPCWSTR pwszOriginalURL = pwszURL;

    //
    // Minimum length: 11 (http://*:1/). Begins with http
    //

    if ( ( wcslen(pwszURL) < 11 ) || ( 0 != _wcsnicmp(pwszURL, L"http", 4)) )
    {
        return false;
    }

    pwszURL += 4;

    //
    // https
    //

    if ((L's' == *pwszURL) || (L'S' == *pwszURL))
    {
        pwszURL++;
    }

    //
    // ://
    //

    if ( (L':' != *pwszURL) || (L'/' != *(pwszURL+1)) || (L'/' != *(pwszURL+2)) )
    {
        return false;
    }

    pwszURL += 3;

    //
    // Skip host name or Ip Address
    //

    while ( (0 != *pwszURL) && ( L':' != *pwszURL))
    {
        pwszURL++;
    }

    //
    // Check port # exists
    //

    if (0 == *pwszURL)
    {
        return false;
    }

    //
    // Check port number is numeric
    //

    pwszURL++;

    while ( (0 != *pwszURL) && ( L'/' != *pwszURL) )
    {
        if (( L'0' > *pwszURL) || ( L'9' < *pwszURL))
        {
            return false;
        }

        pwszURL++;
    }

    //
    // Check / after port number exists
    //

    if (0 == *pwszURL)
    {
        return false;
    }

    //
    // URL is good.
    //

    IF_DEBUG( TRACE)
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Inserting URL '%ws' into Config Group List\n",
                    pwszOriginalURL
                    ));
    }
    return ( TRUE == _mszURLList.Append( pwszOriginalURL));

} // WP_CONFIG::InsertURLIntoList()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulatq\wprecycler.cxx ===
/*++

   Copyright    (c)    1998   Microsoft Corporation

   Module  Name :
     wprecycler.cxx

   Abstract:
     Implementation of WP_RECYCLER.  Object handles worker process recycling
         - Memory based recycling
         - Schedule based recycling
         - Elapsed Time based recycling
         - Processed Request Count based recycling

   Dependencies:
         g_pwpContext is used by WP_RECYCLER to be able to send messages
    
 
   Author:
     Jaroslav Dunajsky         (JaroslaD)         07-Dec-2000

   Environment:
     Win32 - User Mode

   Project:
     W3DT.DLL
--*/

#include "precomp.hxx"
#include "wprecycler.hxx"

#define ONE_DAY_IN_MILLISECONDS (1000 * 60 * 60 * 24)

//
// Static variables
//

CRITICAL_SECTION  WP_RECYCLER::sm_CritSec;

//
// Static variables for Memory based recycling
//

HANDLE WP_RECYCLER::sm_hTimerForMemoryBased = NULL;
BOOL   WP_RECYCLER::sm_fIsStartedMemoryBased = FALSE;
SIZE_T WP_RECYCLER::sm_MaxValueForVirtualMemoryBasedInKB = 0;
SIZE_T WP_RECYCLER::sm_MaxValueForPrivateBytesBasedInKB = 0;
DWORD  WP_RECYCLER::sm_CurrentPID = NULL;
BUFFER WP_RECYCLER::sm_buffSystemProcessInfo = NULL;
//
// arbitrary value for default SystemProcessInfoBuffer
// it will be resized when needed
//
DWORD  WP_RECYCLER::sm_cbSystemProcessInfo =  
                sizeof(SYSTEM_PROCESS_INFORMATION) * 50; 

//
// Static variables for Time based recycling
//

HANDLE WP_RECYCLER::sm_hTimerForTimeBased = NULL;
BOOL   WP_RECYCLER::sm_fIsStartedTimeBased = FALSE;

//
// Static variables for Schedule based recycling
//

HANDLE WP_RECYCLER::sm_hTimerQueueForScheduleBased = NULL;
BOOL   WP_RECYCLER::sm_fIsStartedScheduleBased = FALSE;

//
// Static variables for Request based recycling
//

BOOL   WP_RECYCLER::sm_fIsStartedRequestBased = FALSE;
DWORD  WP_RECYCLER::sm_dwMaxValueForRequestBased = 0;
LONG   WP_RECYCLER::sm_RecyclingMsgSent = 0;

BOOL   WP_RECYCLER::sm_fCritSecInit = FALSE;


//
// Static methods for Schedule based recycling
//


//static
HRESULT
WP_RECYCLER::StartScheduleBased(
    IN  const WCHAR * pwszScheduleTimes
)

/*++

Routine Description:

    Start schedule based recycling
    
    
Arguments:

    pwszScheduleTimes - MULTISZ array of time information
                        <time>\0<time>\0\0
                        time is of military format hh:mm 
                        (hh>=0 && hh<=23)
                        (mm>=0 && hh<=59)
    
Return Value:

    HRESULT

--*/

{
    HRESULT     hr   = E_FAIL;
    BOOL        fRet = FALSE;
    const WCHAR *     pwszCurrentChar = pwszScheduleTimes;

    HANDLE      hTimer;

    WORD        wHours = 0;
    WORD        wMinutes = 0;
    WORD        wDigitCount = 0;

    SYSTEMTIME      SystemTime;
    FILETIME        FileTime; 
    FILETIME        CurrentFileTime; 
    ULARGE_INTEGER  largeintCurrentTime;
    ULARGE_INTEGER  largeintTime;
    DWORD           dwDueTime = 0;

    DBG_ASSERT(TRUE == sm_fCritSecInit);

    EnterCriticalSection( &WP_RECYCLER::sm_CritSec );

    IF_DEBUG( WPRECYCLER )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "WP_RECYCLER::StartScheduleBased()\n"));
    }
    
    DBG_ASSERT( pwszScheduleTimes != NULL );

    //
    // If scheduler based recycling has been running already
    // terminate it before restarting with new settings
    //
    
    if ( WP_RECYCLER::sm_fIsStartedScheduleBased )
    {
        WP_RECYCLER::TerminateScheduleBased();
    }


    WP_RECYCLER::sm_hTimerQueueForScheduleBased = CreateTimerQueue();

    if ( WP_RECYCLER::sm_hTimerQueueForScheduleBased == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failed;
    }

    //
    // Gets current time
    //
    
    GetLocalTime( &SystemTime );
    SystemTimeToFileTime(   &SystemTime, 
                            &CurrentFileTime );
    memcpy( &largeintCurrentTime, 
            &CurrentFileTime, 
            sizeof( ULARGE_INTEGER ) );
    

    //
    // empty string in MULTISZ indicates the end of MULTISZ
    //

    while ( *pwszCurrentChar != '\0' )
    {


        //
        // Skip white spaces
        //
        
        while ( iswspace( (wint_t) *pwszCurrentChar ) )
        {
            pwszCurrentChar++;
        }

        //
        // Start of the time info
        // Expect military format hh:mm
        //

        //
        // Process hours (up to 2 digits is valid)
        //
        
        wHours = 0;
        wDigitCount = 0;
        while ( iswdigit( *pwszCurrentChar ) )
        {
            wDigitCount++;
            wHours = 10 * wHours + (*pwszCurrentChar - '0');
            pwszCurrentChar++;
        }

        if ( wDigitCount > 2  ||
             ( wHours > 23 ) )
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
            goto Failed;
        }

        //
        // Hours - minutes separator
        // Be liberal - any character that is not a digit or '\0' is OK
        // 

        if ( *pwszCurrentChar == '\0' )
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
            goto Failed;
        }

        pwszCurrentChar++;
        
        //
        // Process minutes (must be exactly 2 digits)
        //

        wMinutes = 0;
        wDigitCount = 0;
        while ( iswdigit( (wint_t) *pwszCurrentChar ) )
        {
            wDigitCount++;
            wMinutes = 10 * wMinutes + (*pwszCurrentChar - '0');
            pwszCurrentChar++;
        }

        if ( ( wDigitCount != 2 ) ||
             ( wMinutes > 59 ) )
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
            goto Failed;
        }
        
        //
        // Skip white spaces
        //
        
        while ( iswspace( (wint_t)*pwszCurrentChar ) )
        {
            pwszCurrentChar++;
        }

        //
        // Check for terminating zero
        //

        if ( *pwszCurrentChar != '\0' )
        {
            //
            // Extra characters in the time string
            //

            hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
            goto Failed;
        }

        pwszCurrentChar++;

        // 
        // Convert Hours and Minutes info
        //

        SystemTime.wHour = wHours;
        SystemTime.wMinute = wMinutes;
        SystemTime.wSecond = 0;
        SystemTime.wMilliseconds = 0;

        SystemTimeToFileTime(   &SystemTime, 
                                &FileTime );
        memcpy( &largeintTime, 
                &FileTime, 
                sizeof(ULARGE_INTEGER) );

        //
        // Issue 12/21/2000 jaroslad: 
        // This method of setting absolute time with CreateTimerQueueTimer
        // is bad since instead of setting absolute time the relative time is 
        // calculated and used for timer. 
        // This approach fails badly if someone changes machine
        // time. Other Api that enables setting abolute time must be used for proper 
        // implementation

        // 
        // Get Due Time in milliseconds
        //
        
        dwDueTime = static_cast<DWORD>(
                     ( largeintTime.QuadPart - largeintCurrentTime.QuadPart )/ 10000);

        if ( largeintTime.QuadPart < largeintCurrentTime.QuadPart)
        {
            dwDueTime = ONE_DAY_IN_MILLISECONDS - static_cast<DWORD>(
                     ( largeintCurrentTime.QuadPart - largeintTime.QuadPart )/ 10000);
        }
        else
        {
            dwDueTime = static_cast<DWORD>(
                     ( largeintTime.QuadPart - largeintCurrentTime.QuadPart )/ 10000);
        }
        
        if ( dwDueTime == 0 )
        {
            //
            // this event is to be scheduled for the next day
            // one day has 1000 * 60 * 60 * 24 of (100-nanosecond intervals)
            //
            dwDueTime += ONE_DAY_IN_MILLISECONDS;
        }

        //
        // Schedule event for specified time, repeating once a day
        //
        IF_DEBUG( WPRECYCLER )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Schedule recycling for %d:%d (in %d milliseconds)\n", 
                        (int) wHours,
                        (int) wMinutes,
                        dwDueTime));
        }

        
        fRet = CreateTimerQueueTimer( 
                    &hTimer,
                    WP_RECYCLER::sm_hTimerQueueForScheduleBased,
                    WP_RECYCLER::TimerCallbackForScheduleBased,
                    NULL,
                    dwDueTime,
                    // repeat daily (interval in milliseconds)
                    ONE_DAY_IN_MILLISECONDS,
                    WT_EXECUTELONGFUNCTION );
        if ( !fRet )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Failed;
        }

        //
        // hTimer will not be stored
        // sm_hTimerQueueForScheduleBased is going to be used for cleanup 
        // DeleteTimerQueueEx() should be able to correctly delete all timers 
        // in the queue
        //
        
    }
    WP_RECYCLER::sm_fIsStartedScheduleBased = TRUE;
    LeaveCriticalSection( &WP_RECYCLER::sm_CritSec );

    return S_OK;
    
Failed:
    WP_RECYCLER::TerminateScheduleBased();
    DBG_ASSERT( FAILED( hr ) );

    IF_DEBUG( WPRECYCLER )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "WP_RECYCLER::StartScheduleBased() failed with error hr=0x%x\n",
                    hr ));
    }
    LeaveCriticalSection( &WP_RECYCLER::sm_CritSec );
    
    return hr;
}

//static
VOID
WP_RECYCLER::TerminateScheduleBased(
    VOID
)
/*++

Routine Description:

    Stops schedule based recycling 
    Performs cleanup

Note:
    It is safe to call this method for cleanup if Start failed
    
Arguments:

    NONE
    
Return Value:

    VOID

--*/

{
    DBG_ASSERT(TRUE == sm_fCritSecInit);

    EnterCriticalSection( &WP_RECYCLER::sm_CritSec );
    
    if( WP_RECYCLER::sm_hTimerQueueForScheduleBased != NULL )
    {
        if ( !DeleteTimerQueueEx( 
                            WP_RECYCLER::sm_hTimerQueueForScheduleBased,
                            INVALID_HANDLE_VALUE /* wait for callbacks to complete */ 
                            ) ) 
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "failed to call DeleteTimerQueueEx(): hr=0x%x\n",
                        HRESULT_FROM_WIN32(GetLastError()) ));
        }                    
        WP_RECYCLER::sm_hTimerQueueForScheduleBased = NULL;
    }

    WP_RECYCLER::sm_fIsStartedScheduleBased = FALSE;
   
    LeaveCriticalSection( &WP_RECYCLER::sm_CritSec );

    return;
}

//static
VOID
WINAPI
WP_RECYCLER::TimerCallbackForScheduleBased(
     PVOID,      
     BOOLEAN                 
)

/*++

Routine Description:

    Timer callback for Schedule based recycling   
    It is passed to CreateTimerQueueTimer()

    Routine will inform WAS that process is ready to be recycled
    because scheduled time has been reached
    
Arguments:

    see the description of WAITORTIMERCALLBACK type in MSDN

    
Return Value:

    none

--*/


{
    DBG_ASSERT( WP_RECYCLER::sm_fIsStartedScheduleBased );

    IF_DEBUG( WPRECYCLER )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "WP_RECYCLER::TimerCallbackForScheduleBased()"
                    " - tell WAS to recycle\n" ));
    }
    //
    // Indicate to WAS that we are ready for recycling
    //

    WP_RECYCLER::SendRecyclingMsg( IPM_WP_RESTART_SCHEDULED_TIME_REACHED );
}


//
// Static methods for Memory based recycling
//


//static
HRESULT
WP_RECYCLER::StartMemoryBased(
    IN  DWORD dwMaxVirtualMemoryUsageInKB,
    IN  DWORD dwMaxPrivateBytesUsageInKB
)
/*++

Routine Description:

    Start virtual memory usage based recycling. 
    
    
Arguments:

    dwMaxVirtualMemoryUsageInKB - If usage of virtual memory reaches this value 
                                  worker process is ready for recycling

Note:

    VM usage will be checked periodically. See the value of internal constant 
    CHECK_MEMORY_TIME_PERIOD
                                  
    
Return Value:

    HRESULT

--*/


{
    HRESULT     hr   = E_FAIL;
    BOOL        fRet = FALSE;

    DBG_ASSERT(TRUE == sm_fCritSecInit);
   
    EnterCriticalSection( &WP_RECYCLER::sm_CritSec );

    IF_DEBUG( WPRECYCLER )
    {
   
        DBGPRINTF(( DBG_CONTEXT,
                    "WP_RECYCLER::StartMemoryBased(VM:%d kB, Private Bytes:%d kB)\n",
                    dwMaxVirtualMemoryUsageInKB,
                    dwMaxPrivateBytesUsageInKB));
    }

  
    //
    // If time based recycling has been running already
    // terminate it before restarting with new settings
    //
    
    if ( WP_RECYCLER::sm_fIsStartedMemoryBased == TRUE )
    {
        WP_RECYCLER::TerminateMemoryBased();
    }

    
    if ( dwMaxVirtualMemoryUsageInKB  == 0 && dwMaxPrivateBytesUsageInKB == 0 )
    {
        //
        // 0 means not to run memory recycling
        //
        hr = S_OK;
        goto succeeded;
    }

    fRet = CreateTimerQueueTimer( &WP_RECYCLER::sm_hTimerForMemoryBased,
                                  NULL,
                                  WP_RECYCLER::TimerCallbackForMemoryBased,
                                  NULL,
                                  CHECK_MEMORY_TIME_PERIOD,
                                  CHECK_MEMORY_TIME_PERIOD,
                                  WT_EXECUTELONGFUNCTION );
    if ( !fRet )
    {
        WP_RECYCLER::sm_hTimerForMemoryBased = NULL;
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto failed;
    }

    //
    // Get current process handle
    // It will be used for NtQueryInformationProcess()
    // in the timer callback
    // there is no error to check for and handle doesn't need to be closed
    // on cleanup
    //
    
    sm_CurrentPID = GetCurrentProcessId();
    
    sm_MaxValueForVirtualMemoryBasedInKB = dwMaxVirtualMemoryUsageInKB;
    sm_MaxValueForPrivateBytesBasedInKB =  dwMaxPrivateBytesUsageInKB;
    
    WP_RECYCLER::sm_fIsStartedMemoryBased = TRUE;

succeeded:
    LeaveCriticalSection( &WP_RECYCLER::sm_CritSec );

    return S_OK;
    
failed:
    DBG_ASSERT( FAILED( hr ) );
    WP_RECYCLER::TerminateMemoryBased();

    IF_DEBUG( WPRECYCLER )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "WP_RECYCLER::StartMemoryBased() failed with error hr=0x%x\n",
                    hr ));
    }

    LeaveCriticalSection( &WP_RECYCLER::sm_CritSec );

    return hr;
}

//static
VOID
WP_RECYCLER::TerminateMemoryBased(
    VOID
)
/*++

Routine Description:

    Stops virtual memory usage based recycling 
    Performs cleanup

Note:
    It is safe to call this method for cleanup if Start failed
    
Arguments:

    NONE
    
Return Value:

    VOID  
    
--*/

{
    DBG_ASSERT(TRUE == sm_fCritSecInit);
    
    EnterCriticalSection( &WP_RECYCLER::sm_CritSec );

    if ( WP_RECYCLER::sm_hTimerForMemoryBased != NULL )
    {
        if ( !DeleteTimerQueueTimer(   
                            NULL,
                            WP_RECYCLER::sm_hTimerForMemoryBased,
                            INVALID_HANDLE_VALUE  /* wait for callbacks to complete */
                            ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "failed to call DeleteTimerQueueTimer(): hr=0x%x\n",
                        HRESULT_FROM_WIN32(GetLastError()) ));
        }                                                              
        WP_RECYCLER::sm_hTimerForMemoryBased = NULL;
    }

    sm_fIsStartedMemoryBased = FALSE;
    
    LeaveCriticalSection( &WP_RECYCLER::sm_CritSec );
    return;

}

//static
VOID
WINAPI
WP_RECYCLER::TimerCallbackForMemoryBased(
    PVOID,
    BOOLEAN                
)
/*++

Routine Description:

    Timer callback for Elapsed time based recycling   
    This Callback is passed to CreateTimerQueueTimer()

    Virtual memory and Private Bytes usage will be checked and 
    if limit has been reached then routine will inform WAS 
    that process is ready to be recycled
    
Arguments:

    see description of WAITORTIMERCALLBACK type in MSDN

    
Return Value:

    none

--*/


{
    NTSTATUS  Status = 0;
    PSYSTEM_PROCESS_INFORMATION pProcessInfo = NULL;

    DBG_ASSERT( WP_RECYCLER::sm_fIsStartedMemoryBased );

    

    //
    // Keep trying larger buffers until we get all the information
    // Note: There seems to be no easier way to get PrivateBytes counter
    // for the process other then to enumerate all the processes
    // This may cause performance problem with large number of worker processes 
    // that are self monitoring on memory usage
    //

    
    for(;;)
    {
     
        if ( !sm_buffSystemProcessInfo.Resize( sm_cbSystemProcessInfo ) )
        {
            // We failed to reallocate then just silently exit
            // CODEWORK: This may cause worker process to never recycle
            // if memory is too low to handle memory usage check
            //
            
            return;
        }
        Status = NtQuerySystemInformation(
                   SystemProcessInformation,
                   sm_buffSystemProcessInfo.QueryPtr(),
                   sm_buffSystemProcessInfo.QuerySize(),
                   NULL
                   );

        if( Status != STATUS_INFO_LENGTH_MISMATCH ) break;

        sm_cbSystemProcessInfo *= 2;
    }

    
    if( Status == STATUS_SUCCESS ) 
    {
        DWORD NextOffset = 0;
        //
        // enumerate info about all processes until you find
        // the current process (identified by PID)
        //
        for(;;) 
        {
            //
            // get process info from buffer 
            //

            pProcessInfo = (PSYSTEM_PROCESS_INFORMATION)
                            (((PBYTE) sm_buffSystemProcessInfo.QueryPtr()) + NextOffset );
            NextOffset += pProcessInfo->NextEntryOffset;

            //
            // Compare Pid to see if we found the current process
            //
            
            if ( HandleToULong( pProcessInfo->UniqueProcessId ) == sm_CurrentPID )
            {
                break;
            }

            if ( pProcessInfo->NextEntryOffset == 0 )
            {
                //
                // Well, we should never get here because the current process
                // must be listed but to eliminate potential problems
                // since we are using private NT API let's assume not found error
                //
                Status = STATUS_NOT_FOUND;
                break;
            }
        }
        
    }

    if ( ! NT_SUCCESS ( Status ) )
    {
        IF_DEBUG( WPRECYCLER )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "NtQueryInformationProcess failed with Status: %d\n", 
                        Status ));
        }
        return;
    }

    //
    // Check virtual bytes
    //
    
    if ( sm_MaxValueForVirtualMemoryBasedInKB != 0 &&
         pProcessInfo->VirtualSize/1024 >= sm_MaxValueForVirtualMemoryBasedInKB )
    {
        IF_DEBUG( WPRECYCLER )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "WP_RECYCLER::TimerCallbackForMemoryBased()"
                        " - current VM:%ld kB, configured max VM:%ld kB"
                        " - tell WAS to recycle\n", 
                        pProcessInfo->VirtualSize/1024 , 
                        sm_MaxValueForVirtualMemoryBasedInKB    ));
        }

        //
        // we reached Virtual Memory Usage limit
        //
        WP_RECYCLER::SendRecyclingMsg( IPM_WP_RESTART_VIRTUAL_MEMORY_LIMIT_REACHED );  
    }

    //
    // Check private bytes
    //
    if ( sm_MaxValueForPrivateBytesBasedInKB != 0 &&
         pProcessInfo->PrivatePageCount/1024 >= sm_MaxValueForPrivateBytesBasedInKB )
    {
        IF_DEBUG( WPRECYCLER )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "WP_RECYCLER::TimerCallbackForMemoryBased()"
                        " - current Private Bytes:%ld kB, configured max Private Bytes:%ld kB"
                        " - tell WAS to recycle\n", 
                        pProcessInfo->PrivatePageCount/1024 , 
                        sm_MaxValueForPrivateBytesBasedInKB    ));
        }

        //
        // we reached Private Memory Usage limit
        //
        WP_RECYCLER::SendRecyclingMsg( IPM_WP_RESTART_PRIVATE_BYTES_LIMIT_REACHED );  
    }
}


//
// Static methods for Time based recycling
//


//static
HRESULT
WP_RECYCLER::StartTimeBased(
    IN  DWORD dwPeriodicRestartTimeInMinutes
)
/*++

Routine Description:

    Start elapsed time based recycling
    
    
Arguments:

    dwPeriodicRestartTimeInMinutes - how often to restart (in minutes)
    
Return Value:

    HRESULT

--*/

{
    HRESULT hr   = E_FAIL;
    BOOL    fRet = FALSE;

    DBG_ASSERT(TRUE == sm_fCritSecInit);

    EnterCriticalSection( &WP_RECYCLER::sm_CritSec );
    
    IF_DEBUG( WPRECYCLER )
    {

        DBGPRINTF(( DBG_CONTEXT,
                    "WP_RECYCLER::StartTimeBased(%d min)\n" ,   
                    dwPeriodicRestartTimeInMinutes ));
    }


    //
    // If time based recycling has been running already
    // terminate it before restarting with new settings
    //
    
    if ( WP_RECYCLER::sm_fIsStartedTimeBased == TRUE )
    {
        WP_RECYCLER::TerminateTimeBased();
    }

    
    if ( dwPeriodicRestartTimeInMinutes == 0 )
    {
        //
        // 0 means not to run time based recycling
        //
        hr = S_OK;
        goto succeeded;
    }

    fRet = CreateTimerQueueTimer( &WP_RECYCLER::sm_hTimerForTimeBased,
                                  NULL,
                                  WP_RECYCLER::TimerCallbackForTimeBased,
                                  NULL,
                                  dwPeriodicRestartTimeInMinutes * 60000, 
                                        // convert to msec
                                  dwPeriodicRestartTimeInMinutes * 60000, 
                                        // convert to msec
                                  WT_EXECUTELONGFUNCTION );
    if ( !fRet )
    {
        WP_RECYCLER::sm_hTimerForTimeBased = NULL;
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto failed;
    }
    
    WP_RECYCLER::sm_fIsStartedTimeBased = TRUE;
    
succeeded:    
    LeaveCriticalSection( &WP_RECYCLER::sm_CritSec );

    return S_OK;
    
failed:
    DBG_ASSERT( FAILED( hr ) );
    WP_RECYCLER::TerminateTimeBased();

    IF_DEBUG( WPRECYCLER )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "WP_RECYCLER::StartTimeBased() failed with error hr=0x%x\n",
                    hr));
    }
    LeaveCriticalSection( &WP_RECYCLER::sm_CritSec );

    return hr;
    
}

//static
VOID
WP_RECYCLER::TerminateTimeBased(
    VOID
)
/*++

Routine Description:

    Stops elapsed time based recycling 
    Performs cleanup

Note:
    It is safe to call this method for cleanup if Start failed
    
Arguments:

    NONE
    
Return Value:

    HRESULT

--*/

{
    DBG_ASSERT(TRUE == sm_fCritSecInit);

    EnterCriticalSection( &WP_RECYCLER::sm_CritSec );

    if ( WP_RECYCLER::sm_hTimerForTimeBased != NULL )
    {
        if ( !DeleteTimerQueueTimer(   
                       NULL,
                       WP_RECYCLER::sm_hTimerForTimeBased,
                       INVALID_HANDLE_VALUE /* wait for callbacks to complete */ 
                       ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "failed to call DeleteTimerQueueTimer(): hr=0x%x\n",
                        HRESULT_FROM_WIN32(GetLastError()) ));
        }                                                              
                                              
        WP_RECYCLER::sm_hTimerForTimeBased = NULL;
    }
    WP_RECYCLER::sm_fIsStartedTimeBased = FALSE;

    LeaveCriticalSection( &WP_RECYCLER::sm_CritSec );

    return;
}

//static
VOID
WINAPI
WP_RECYCLER::TimerCallbackForTimeBased(
    PVOID,
    BOOLEAN                
)
/*++

Routine Description:

    Timer callback for Elapsed time based recycling   
    This Callback is passed to CreateTimerQueueTimer()

    Routine will inform WAS that process is ready to be recycled
    because required elapsed time has been reached
    
Arguments:

    see description of WAITORTIMERCALLBACK type in MSDN

    
Return Value:

    none

--*/


{

    DBG_ASSERT( WP_RECYCLER::sm_fIsStartedTimeBased );

    IF_DEBUG( WPRECYCLER )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "WP_RECYCLER::TimerCallbackForTimeBased"
                    " - tell WAS to recycle\n"           ));
    }

    WP_RECYCLER::SendRecyclingMsg( IPM_WP_RESTART_ELAPSED_TIME_REACHED );
}

//
// Static methods for Request based recycling
//


//static
HRESULT
WP_RECYCLER::StartRequestBased(
    IN  DWORD dwRequests
)
/*++

Routine Description:

    Start request based recycling. 
    
    
Arguments:

    dwRequests - If number of requests processed by worker process reaches this value
                 recycling will be required
    
Return Value:

    HRESULT

--*/

{
    HRESULT hr = E_FAIL;
    
    DBG_ASSERT(TRUE == sm_fCritSecInit);

    EnterCriticalSection( &WP_RECYCLER::sm_CritSec );

    IF_DEBUG( WPRECYCLER )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "WP_RECYCLER::StartRequestBased(%d kB)\n" ,   
                    dwRequests ));
    }

  
    //
    // If time based recycling has been running already
    // terminate it before restarting with new settings
    //
    
    if ( WP_RECYCLER::sm_fIsStartedRequestBased == TRUE )
    {
        WP_RECYCLER::TerminateRequestBased();
    }

    
    if ( dwRequests == 0 )
    {
        //
        // 0 means not to run request based recycling
        //
        hr = S_OK;
        goto succeeded;
    }


    InterlockedExchange( 
            reinterpret_cast<LONG *>(&sm_dwMaxValueForRequestBased), 
            dwRequests );
    InterlockedExchange( 
            reinterpret_cast<LONG *>(&WP_RECYCLER::sm_fIsStartedTimeBased), 
            TRUE );

    hr = S_OK;
succeeded:
    LeaveCriticalSection( &WP_RECYCLER::sm_CritSec );

    return hr;

}

//static
VOID
WP_RECYCLER::TerminateRequestBased(
    VOID
)
/*++

Routine Description:

    Stops request based recycling 
    Performs cleanup

Note:
    It is safe to call this method for cleanup if Start failed
    
Arguments:

    NONE
    
Return Value:

    HRESULT

--*/

{
  
    DBG_ASSERT(TRUE == sm_fCritSecInit);
    
    EnterCriticalSection( &WP_RECYCLER::sm_CritSec );

    //
    // InterlockedExchange is used because Request Based recycling callback 
    // IsRequestCountLimitReached() is called for each request
    // and we don't synchronize it with &WP_RECYCLER::sm_CritSec 
    //
    
    InterlockedExchange( 
            reinterpret_cast<LONG *>(&WP_RECYCLER::sm_fIsStartedTimeBased), 
            FALSE );
    
    LeaveCriticalSection( &WP_RECYCLER::sm_CritSec );

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulatq\wpcontext.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     wpcontext.cxx

   Abstract:
     This module defines the member functions of the WP_CONTEXT.
     The WP_CONTEXT object embodies an instance of the Worker process
     object. It contains a completion port, pool of worker threads,
     pool of worker requests, a data channel for the worker process, etc.
     It is responsible for setting up the context for processing requests
     and handles delegating the processing of requests.

     NYI: In the future we should be able to run WP_CONTEXT object as
     a COM+ object and be run standalone using a hosting exe.

   Author:

       Murali R. Krishnan    ( MuraliK )     17-Nov-1998

   Project:

       IIS Worker Process

--*/

#include "precomp.hxx"

VOID
WINAPI
IdleTimeCheckCallback(
    VOID *              pvContext,
    BOOLEAN            
)
/*++

Routine Description:

    Callback function provided for TimerQueue.  Called every minute

Arguments:

    pvContext - Context

Return Value:

    None

--*/
{
    WP_IDLE_TIMER * pTimer = (WP_IDLE_TIMER *)pvContext;

    DBGPRINTF(( DBG_CONTEXT,
                "Check Idle Time Callback.\n" ));

    DBG_ASSERT( pTimer );

    pTimer->IncrementTick();
}

WP_IDLE_TIMER::WP_IDLE_TIMER(
    ULONG               IdleTime
)
:   _BusySignal(0),
    _CurrentIdleTick(0),
    _IdleTime(IdleTime),
    _hIdleTimeExpiredTimer((HANDLE)NULL)
{
}

WP_IDLE_TIMER::~WP_IDLE_TIMER(
    VOID
)
{
    //
    // Cancel IdleTimeExpiredTimer
    //

    if (_hIdleTimeExpiredTimer)
    {
        StopTimer();
    }
}

HRESULT
WP_IDLE_TIMER::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize the idle timer.  Setup NT thread pool to callback every minute

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    BOOL                fRet;
    HRESULT             hr = NO_ERROR;

    //
    // IdleTime is stored as in minutes, 1 min = 60*1000 milliseconds.
    //

    fRet = CreateTimerQueueTimer(
            &_hIdleTimeExpiredTimer,                // handle to the Timer
            NULL,                                   // Default Timer Queue
            IdleTimeCheckCallback,                  // Callback function
            this,                                   // Context.
            60000,                                  // Due Time
            60000,                                  // Signal every minute
            WT_EXECUTEINIOTHREAD
            );

    if ( !fRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );

        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to create idle timer.  hr = %x\n",
                    hr ));
    }

    return hr;
}

VOID
WP_IDLE_TIMER::IncrementTick(
    VOID
)
/*++

Routine Description:

    Check every minute whether we've been idle long enough.  If so,
    tell WAS

Arguments:

    None

Return Value:

    None

--*/
{
    ULONG BusySignal = InterlockedExchange( (PLONG)&_BusySignal, 0 );

    if ( !BusySignal && !UL_NATIVE_REQUEST::QueryCurrentRequests() )
    {
        InterlockedIncrement( (PLONG)&_CurrentIdleTick );

        if ( _CurrentIdleTick >= _IdleTime )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Idle time reached.  Send shutdown message to WAS.\n" ));

            g_pwpContext->SendMsgToAdminProcess( IPM_WP_IDLE_TIME_REACHED );
        }
    }
    else
    {
        _CurrentIdleTick = 0;
    }
}

VOID
WP_IDLE_TIMER::StopTimer(
    VOID
)
/*++

Routine Description:

    Remove timer

Arguments:

    None

Return Value:

    None

--*/
{
    BOOL fRet;

    DBG_ASSERT( _hIdleTimeExpiredTimer );

    fRet = DeleteTimerQueueTimer( NULL,
                                  _hIdleTimeExpiredTimer,
                                  (HANDLE)-1 );

    if ( !fRet )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to delete Timer queue.  Win32 = %ld\n",
                    GetLastError() ));
    }

    _hIdleTimeExpiredTimer = NULL;
}


VOID
OverlappedCompletionRoutine(
    DWORD               dwErrorCode,
    DWORD               dwNumberOfBytesTransfered,
    LPOVERLAPPED        lpOverlapped
)
/*++

Routine Description:

    Main completion routine called on completions for UL app pool handle.

Arguments:

    dwErrorCode - Win32 Error code of completion
    dwNumberOfBytesTransfered - Bytes completed
    lpOverlapped - Overlapped structure passed on async operation

Return Value:

    None

--*/
{
    ASYNC_CONTEXT *         pContext = NULL;

    //
    // Use the overlapped to get at the async context
    //

    if ( lpOverlapped != NULL )
    {
        pContext = CONTAINING_RECORD( lpOverlapped,
                                      ASYNC_CONTEXT,
                                      _Overlapped );
    
        DBG_ASSERT( pContext != NULL );

        //
        // Call virtual DoWork() to actually handle the completion
        // (context can represent a UL_NATIVE_REQUEST or a UL_DISCONNECT)
        //

        pContext->DoWork( dwNumberOfBytesTransfered,
                          dwErrorCode,
                          lpOverlapped );
    }
    else
    {
        DBG_ASSERT( lpOverlapped != NULL );
    }
}

WP_CONTEXT::WP_CONTEXT(
    VOID
) : _hDoneEvent( NULL ),
    _pConfigInfo( NULL ),
    _fShutdown( FALSE ),
    _pIdleTimer( NULL ),
    _fHealthy( TRUE )
{
}

WP_CONTEXT::~WP_CONTEXT(
    VOID
)
{
}

HRESULT
WP_CONTEXT::Initialize(
    INT             argc,
    LPWSTR *        argv
)
/*++

Routine Description:

    Initialize global context

Arguments:

    argc - Command argument count
    argv - Command arguments

Return Value:

    HRESULT

--*/
{
    LPCWSTR     pwszAppPoolName;
    HRESULT     hr = NO_ERROR;
    DWORD       dwErr = NO_ERROR;
    BOOL        fAppPoolInit = FALSE;
    BOOL        fNativeRequestInit = FALSE;
    BOOL        fDisconnectInit = FALSE;
    BOOL        fIpmInit = FALSE;
    BOOL        fWpRecyclerInit = FALSE;

    _pConfigInfo = new WP_CONFIG();
    if ( _pConfigInfo == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto Finished;
    }

    //
    // Validate the parameters passed into executable
    //

    if ( !_pConfigInfo->ParseCommandLine( argc, argv ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Invalid command line arguments.\n" ));

        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        goto Finished;
    }

    //
    // If we need to establish the control channel to run
    // without w3svc interaction do it now.
    //

    if ( _pConfigInfo->QuerySetupControlChannel() )
    {
        dwErr = _pConfigInfo->SetupControlChannel();
        if ( dwErr != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( dwErr );

            DBGPRINTF(( DBG_CONTEXT,
                        "SetupControlChannel failed with 0x%8x\n",
                        hr ));

            goto Finished;
        }
    }


    pwszAppPoolName = _pConfigInfo->QueryAppPoolName();

    //
    // Initialize UL AppPool
    //

    hr = _ulAppPool.Initialize( pwszAppPoolName );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to initialize AppPool.  hr = %x\n",
                    hr ));
        goto Finished;
    }
    SetEnvironmentVariableW( L"APP_POOL_ID",
                             pwszAppPoolName );
    fAppPoolInit = TRUE;

    //
    // Initialize UL_NATIVE_REQUEST globals
    //

    hr = UL_NATIVE_REQUEST::Initialize();
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to initialize UL_NATIVE_REQUEST globals.  hr = %x\n",
                    hr ));
        goto Finished;
    }
    fNativeRequestInit = TRUE;

    //
    // Initialize UL_DISCONNECTs
    //

    hr = UL_DISCONNECT_CONTEXT::Initialize();
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to initialize UL_DISCONNECT_CONTEXT globals.  hr = %x\n",
                    hr ));
        goto Finished;
    }
    fDisconnectInit = TRUE;

    DBGPRINTF(( DBG_CONTEXT,
                "AppPool '%ws' initialized\n",
                pwszAppPoolName ));

    //
    // Initialize of the shutdown event
    //

    _hDoneEvent = IIS_CREATE_EVENT( "WP_CONTEXT::_hDoneEvent",
                                    &_hDoneEvent,
                                    TRUE,
                                    FALSE );

    if ( _hDoneEvent == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );

        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to create shutdown event.  hr = %x\n",
                    hr ));
        goto Finished;
    }

    //
    // Setup all async completions on data channel handle to go thru W3TP
    //

    if (!ThreadPoolBindIoCompletionCallback( _ulAppPool.QueryAndLockHandle(),
                                             OverlappedCompletionRoutine,
                                             0 ))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to associate handle with thread pool.  hr = %x\n",
                    hr ));
        _ulAppPool.UnlockHandle();
        goto Finished;
    }

    hr = _ulAppPool.UnlockHandle();
    if ( FAILED( hr ) )
    {
        goto Finished;
    }


    //
    // Need to init this first as we may start getting callbacks as soon
    // as we init IPM
    //
    hr = WP_RECYCLER::Initialize();

    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to initialize WP_RECYCLER.  hr = %x\n",
                    hr ));
        goto Finished;
    }
    fWpRecyclerInit = TRUE;

    //
    // Register with WAS
    //

    if ( _pConfigInfo->QueryRegisterWithWAS() )
    {
        hr = _WpIpm.Initialize( this );
        if ( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Failed to initialize IPM.  hr = %x\n",
                        hr ));
            goto Finished;
        }
        fIpmInit = TRUE;
    }

    //
    // Set the window title to something nice when we're running
    // under the debugger.
    //

    if ( IsDebuggerPresent() )
    {
        STRU strTitle;
        WCHAR buffer[sizeof("w3wp[1234567890] - ")];
        WCHAR buffer2[sizeof(" - mm/dd hh:mm:ss")];

        wsprintf( buffer, L"w3wp[%lu] - ", GetCurrentProcessId() );
        hr = strTitle.Append( buffer );

        if (SUCCEEDED(hr))
        {
            hr = strTitle.Append( _pConfigInfo->QueryAppPoolName() );
        }

        if (SUCCEEDED(hr))
        {
            LARGE_INTEGER sysTime;
            LARGE_INTEGER localTime;
            TIME_FIELDS fields;

            NtQuerySystemTime( &sysTime );
            RtlSystemTimeToLocalTime( &sysTime, &localTime );
            RtlTimeToTimeFields( &localTime, &fields );

            wsprintf(
                buffer2,
                L" - %02u/%02u %02u:%02u:%02u",
                fields.Month,
                fields.Day,
                fields.Hour,
                fields.Minute,
                fields.Second
                );

            hr = strTitle.Append( buffer2 );
        }

        if (SUCCEEDED(hr))
        {
            SetConsoleTitleW( strTitle.QueryStr() );
        }
    }

    return S_OK;

Finished:

    //
    // Terminate recycler object
    // Dependency warning: _WpIpm must still be valid
    //
    if ( fWpRecyclerInit )
    {
        WP_RECYCLER::Terminate();
    }

    if ( fIpmInit )
    {
        _WpIpm.Terminate();
    }

    if ( _hDoneEvent != NULL )
    {
        CloseHandle( _hDoneEvent );
        _hDoneEvent = NULL;
    }

    if ( fDisconnectInit )
    {
        UL_DISCONNECT_CONTEXT::Terminate();
    }

    if ( fNativeRequestInit )
    {
        UL_NATIVE_REQUEST::Terminate();
    }

    if ( fAppPoolInit )
    {
        _ulAppPool.Cleanup();
    }

    if ( _pConfigInfo != NULL )
    {
        delete _pConfigInfo;
        _pConfigInfo = NULL;
    }

    return hr;
}

HRESULT
WP_CONTEXT::Start(
    VOID
)
/*++

Routine Description:

    Start listening for requests by creating UL_NATIVE_REQUESTs

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HRESULT                 hr = NO_ERROR;

    //
    // Create a pool of worker requests
    // NYI: Allow the worker requests limit to be configurable.
    //

    UL_NATIVE_REQUEST::SetRestartCount( _pConfigInfo->QueryRestartCount() );

    hr = UL_NATIVE_REQUEST::AddPendingRequests(
                                  (_pConfigInfo->QueryRestartCount() == 0 ||
                                   (_pConfigInfo->QueryRestartCount() >=
                                    NUM_INITIAL_REQUEST_POOL_ITEMS)) ?
                                    NUM_INITIAL_REQUEST_POOL_ITEMS :
                                    _pConfigInfo->QueryRestartCount()
                                  );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to add pending UL_NATIVE_REQUESTs.  hr = %x\n",
                    hr ));
        goto Finished;
    }

    //
    // There is a possibility that worker process runs out of pending requests
    // in the case when http.sys starts failing HttpReceiveHttpRequest()
    // We will avoid the problem by regularly checking the pending count 
    // adding new requests whenever necessary
    //

    hr = UL_NATIVE_REQUEST::StartPendingRequestsMonitor();
        
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to start Pending requests monitor.  hr = %x\n",
                    hr ));
        goto Finished;
    }

    //
    // If an idle time is set, then set idle timer
    //

    if ( _pConfigInfo->QueryIdleTime() != 0 )
    {
        _pIdleTimer = new WP_IDLE_TIMER( _pConfigInfo->QueryIdleTime() );
        if ( _pIdleTimer )
        {
            hr = _pIdleTimer->Initialize();
        }
        else
        {
            hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        }

        if ( FAILED( hr ) )
        {
            goto Finished;
        }
    }

    return S_OK;
Finished:

    if ( _pIdleTimer != NULL )
    {
        delete _pIdleTimer;
        _pIdleTimer = NULL;
    }

    return hr;
}

BOOL
WP_CONTEXT::IndicateShutdown(
    BOOL fImmediate
)
/*++

Routine Description:

    Set shutdown event which allows StartListen to wake up and
    begin cleanup

Arguments:

    reason - Reason for shutdown

Return Value:

    BOOL

--*/
{
    if ( !InterlockedCompareExchange((LONG *)&_fShutdown, TRUE, FALSE ) )
    {
        _fImmediateShutdown = fImmediate;

        return SetEvent( _hDoneEvent );
    }
    else
    {
        return TRUE;
    }
}

VOID
WP_CONTEXT::Terminate(
    VOID
)
/*++

Routine Description:

    Cleanup WP_CONTEXT data structures

Arguments:

    None

Return Value:

    None

--*/
{
    HRESULT             hr = NO_ERROR;

    //
    // Cleanup async contexts
    //

    UL_DISCONNECT_CONTEXT::Terminate();

    UL_NATIVE_REQUEST::Terminate();

    if ( _pIdleTimer != NULL )
    {
        delete _pIdleTimer;
        _pIdleTimer = NULL;
    }

    //
    // Stop IPM
    //

    if ( _pConfigInfo->QueryRegisterWithWAS() )
    {
        hr = _WpIpm.Terminate();
        if ( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Failed to shutdown IPM.  hr = %x\n",
                        hr ));
        }
    }
    
    //
    // Cleanup the Shutdown Event.
    //

    DBG_ASSERT( _hDoneEvent != NULL );

    CloseHandle( _hDoneEvent );
    _hDoneEvent = NULL;


    //
    // Terminate procerr recycler.
    // Dependency warning: _WpIpm must still be valid
    //

    WP_RECYCLER::Terminate();

    //
    // Cleanup config object
    //

    delete _pConfigInfo;
    _pConfigInfo = NULL;
}

HRESULT
WP_CONTEXT::CleanupOutstandingRequests(
    VOID
)
/*++

Routine Description:

    Cleanup WP_CONTEXT data structures

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HRESULT             hr = NO_ERROR;

    //
    // Stop monitoring the number of pending requests since 
    // it's time to shutdown
    //
    UL_NATIVE_REQUEST::StopPendingRequestsMonitor();
    
    //
    // If we want to shut-down immediately, then close the AppPool handle now
    //
    if (_fImmediateShutdown)
    {
        _ulAppPool.Cleanup();
    }

    //
    // Wait for requests to drain away.  If they were pending
    // UlReceiveHttpRequest, they will complete with error.  If they were
    // already processing, then we wait for them to finish
    //

    hr = UL_NATIVE_REQUEST::ReleaseAllWorkerRequests();
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error draining UL_NATIVE_REQUESTs.  hr = %x\n",
                    hr ));

        return hr;
    }

    //
    // If we want to shut-down gracefully, then close the AppPool handle now
    //
    if (!_fImmediateShutdown)
    {
        _ulAppPool.Cleanup();
    }

    //
    // Wait for outstanding disconnect requests (i.e. UlWaitForDisconnect)
    // to drain
    //

    UL_DISCONNECT_CONTEXT::WaitForOutstandingDisconnects();

    //
    // Send WAS final counter data before shutting down
    //

    hr = _WpIpm.HandleCounterRequest();

    return hr;
}

VOID
WP_CONTEXT::RunMainThreadLoop(
    VOID
)
/*++

Routine Description:

    Wait for the shutdown event

Arguments:

    None

Return Value:

    None

--*/
{
    do
    {
        DWORD result;

        result = WaitForSingleObject( _hDoneEvent, INFINITE );

        DBG_ASSERT( result == WAIT_OBJECT_0 );

    } while ( !_fShutdown );

}

HANDLE
WP_CONTEXT::GetAndLockAsyncHandle(
    VOID
)
/*++

Routine Description:

    Read locks and returns the async handle.

Arguments:

    None

Return Value:

    HANDLE

--*/
{
    return _ulAppPool.QueryAndLockHandle();
}


HRESULT
WP_CONTEXT::UnlockAsyncHandle(
    VOID
)
/*++

Routine Description:

    Read unlocks the async handle.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    return _ulAppPool.UnlockHandle();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulatq\wpipm.cxx ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    wpipm.cxx

Abstract:

    Contains the WPIPM class that handles communication with
    the admin service. WPIPM responds to pings, and tells
    the process when to shut down.
    
Author:

    Michael Courage (MCourage)  22-Feb-1999

Revision History:

--*/


#include <precomp.hxx>
#include "dbgutil.h"
#include "wpipm.hxx"

extern PFN_ULATQ_COLLECT_PERF_COUNTERS g_pfnCollectCounters;

/**
 *
 *   Routine Description:
 *
 *   Initializes WPIPM.
 *   
 *   Arguments:
 *
 *   pWpContext - pointer to the wp context (so we can tell it to shutdown)
 *   
 *   Return Value:
 *
 *   HRESULT
 */
HRESULT
WP_IPM::Initialize(
    WP_CONTEXT * pWpContext
    )
{

    HRESULT hr = S_OK;

    m_pWpContext = pWpContext;

    DWORD dwId = GetCurrentProcessId();

    //
    // create pipe
    //
    hr = IPM_MESSAGE_PIPE::CreateIpmMessagePipe(this,
                                       pWpContext->QueryConfig()->QueryNamedPipeId(),
                                       FALSE, // not server side
                                       NULL, // security descriptor
                                       &m_pPipe);
    if (FAILED(hr))
    {
        goto exit;
    }

    //
    // Send the real pid over the pipe
    //
    hr = m_pPipe->WriteMessage(IPM_OP_GETPID,
                                                sizeof(dwId),
                                                &dwId);
    if (FAILED(hr))
    {
        goto exit;
    }

    hr =  S_OK;
exit:
    if (FAILED(hr))
    {
        Terminate();
    }
    
    return hr;
}


/**
 *
 * Routine Description:
 *
 *   Terminates WPIPM.
 *
 *   If the message pipe is open this function will disconnect it
 *   and wait for the pipe's disconnection callback.
 *   
 *  Arguments:
 *
 *   None.
 *   
 *  Return Value:
 *
 *   HRESULT
 */
HRESULT
WP_IPM::Terminate(
    VOID
    )
{
    if (m_pPipe) 
    {
        m_pPipe->DestroyIpmMessagePipe();

        // pipe deletes itself
        m_pPipe = NULL;
    }

    m_pWpContext = NULL;

    return S_OK;
}


/**
 *
 *
 *  Routine Description:
 *
 *   This is a callback from the message pipe that means
 *   the pipe has received a message.
 *   
 *   We decode the message and respond appropriately.
 *   
 *   Arguments:
 *
 *   pPipeMessage - the message that we received
 *   
 *   Return Value:
 *
 *   HRESULT
 *
 */
VOID
WP_IPM::AcceptMessage(
    IN const IPM_MESSAGE * pPipeMessage
    )
{
    HRESULT hr = NO_ERROR;
    BOOL fRet = FALSE;
    
    switch (pPipeMessage->GetOpcode()) 
    {
    case IPM_OP_PING:
        //
        // Pings must go through the same mechanism that requests go through
        // to verify that requests are being picked off of the completion port
        //
        fRet = ThreadPoolPostCompletion(0, HandlePing, (LPOVERLAPPED)this);
        if (FALSE == fRet)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DBGPRINTF((DBG_CONTEXT, "Posting completion for ping handling failed"));
            break;
        }

        break;

    case IPM_OP_SHUTDOWN:
        hr = HandleShutdown(
                *( reinterpret_cast<const BOOL *>( pPipeMessage->GetData() ) )
                );
        break;

    case IPM_OP_REQUEST_COUNTERS:
        hr = HandleCounterRequest();
        break;

    case IPM_OP_PERIODIC_PROCESS_RESTART_PERIOD_IN_MINUTES:

        DBG_ASSERT( pPipeMessage->GetData() != NULL );
        hr = WP_RECYCLER::StartTimeBased(
                *( reinterpret_cast<const DWORD *>( pPipeMessage->GetData() ) )
                );
        hr = NO_ERROR;
        break;
        
    case IPM_OP_PERIODIC_PROCESS_RESTART_MEMORY_USAGE_IN_KB:
    {
        
        DBG_ASSERT( pPipeMessage->GetData() != NULL );
        // there are 2 DWORDS sent with memory based recycling
        // first is Max Virtual Memory, second is Max Private Bytes
        
        DWORD dwMaxVirtualMemoryKbUsage = 
                *( reinterpret_cast<const DWORD *>( pPipeMessage->GetData() ) ); 
        DWORD dwMaxPrivateBytesKbUsage = 
                *( reinterpret_cast<const DWORD *>( pPipeMessage->GetData() ) + 1 ); 
        
        hr = WP_RECYCLER::StartMemoryBased(
                dwMaxVirtualMemoryKbUsage,
                dwMaxPrivateBytesKbUsage );
        hr = NO_ERROR;
     
        break;
    }
    case IPM_OP_PERIODIC_PROCESS_RESTART_SCHEDULE:
      
        DBG_ASSERT( pPipeMessage->GetData() != NULL );
        hr = WP_RECYCLER::StartScheduleBased(
                ( reinterpret_cast<const WCHAR *>( pPipeMessage->GetData() ) )
                );
        hr = NO_ERROR;
        break;

    default:
        DBG_ASSERT(FALSE);
        hr = E_FAIL;
        break;
    }

    return;
}


/**
 *
 * Routine Description:
 *
 *   This is a callback from the message pipe that means
 *   the pipe has been connected and is ready for use.
 *   
 * Arguments:
 *
 *   None.
 *   
 * Return Value:
 *
 *   VOID
 */
VOID
WP_IPM::PipeConnected(
    VOID
    )
{
    return;
}


/**
 *
 * Routine Description:
 *
 *   This is a callback from the message pipe that means
 *   the pipe has been disconnected and you won't be receiving
 *   any more messages.
 *   
 *   Tells WPIPM::Terminate that it's ok to exit now.
 *   
 * Arguments:
 *
 *   hr - the error code associated with the pipe disconnection
 *   
 * Return Value:
 *
 *   VOID
 */
VOID
WP_IPM::PipeDisconnected(
    IN HRESULT hr
    )
{
    if (FAILED(hr))
    {
        IF_DEBUG( WPIPM )
        {
            DBGPRINTF(( DBG_CONTEXT, "FSDF" ));
        }
    }

    //
    // If the pipe disappears out from under us, WAS has probably orphaned
    // us, initiate fast shutdown of this worker process.
    //

    if (!m_pWpContext->IsInShutdown() &&
        hr != HRESULT_FROM_WIN32(ERROR_OPERATION_ABORTED) &&
        IsDebuggerPresent())
    {
        DBG_ASSERT( !"w3wp.exe is getting orphaned" );
    }

    m_pWpContext->IndicateShutdown( TRUE );

    return;
}

/**
 *
 * Routine Description:
 *
 *   This is a callback from the message pipe that means
 *   that the pipe received an invalid message.
 *   Therefore, we signal to shutdown.
 *   
 * Arguments:
 *
 *   VOID
 *   
 * Return Value:
 *
 *   VOID
 */
VOID
WP_IPM::PipeMessageInvalid(
    VOID
    )
{
    return PipeDisconnected(HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
}

/**
 *
 *  Routine Description:
 *
 *   Handles the ping message. Sends the ping response message.
 *   
 *   Arguments:
 *
 *   None.
 *   
 *  Return Value:
 *
 *   HRESULT
 */
//static
VOID
WP_IPM::HandlePing(
    DWORD,
    DWORD dwNumberOfBytesTransferred,
    LPOVERLAPPED lpOverlapped
    )
{
    if (0 != dwNumberOfBytesTransferred)
    {
        DBG_ASSERT(0 == dwNumberOfBytesTransferred);
        return;
    }

    DBG_ASSERT(NULL != lpOverlapped);

    WP_IPM * pThis = (WP_IPM*) lpOverlapped;

    DBG_ASSERT(pThis->m_pPipe);

    HRESULT hr = NO_ERROR;

    IF_DEBUG( WPIPM )
    {
        DBGPRINTF((DBG_CONTEXT, "Handle Ping\n\n"));
    }

    hr = pThis->m_pPipe->WriteMessage(
                IPM_OP_PING_REPLY,  // ping reply opcode
                0,                  // no data to send
                NULL                // pointer to no data
                );

    if ( FAILED ( hr ) )
    {
        IF_DEBUG( WPIPM )
        {
            DBGPRINTF((DBG_CONTEXT, "Failed to respond to ping\n\n"));
        }

        goto exit;
    }

    //
    // if we are not healthy then we need to to ask WAS to 
    // shut us down.
    //
    if ( !( g_pwpContext->GetUnhealthy()))
    {
        IF_DEBUG( WPIPM )
        {
            DBGPRINTF((DBG_CONTEXT, "Requesting shutdown due to isapi reporting unhealthiness\n\n"));
        }

        hr = pThis->SendMsgToAdminProcess( IPM_WP_RESTART_ISAPI_REQUESTED_RECYCLE );

        if ( FAILED ( hr ) )
        {
            IF_DEBUG( WPIPM )
            {
                DBGPRINTF((DBG_CONTEXT, "Failed telling WAS to shut us down\n\n"));
            }

            goto exit;
        }

    }

exit:

    return;
}

/**
 *
 *  Routine Description:
 *
 *   Handles the counter request message. 
 *   
 *   Arguments:
 *
 *   None.
 *   
 *  Return Value:
 *
 *   HRESULT
 */
HRESULT
WP_IPM::HandleCounterRequest(
    VOID
    )
{
    IF_DEBUG( WPIPM )
    {
        DBGPRINTF((DBG_CONTEXT, "Handle Counter Request\n\n"));
    }

    HRESULT hr;
    PBYTE pCounterData;
    DWORD dwCounterData;

    DBG_ASSERT ( m_pPipe );

    if (FAILED(hr = g_pfnCollectCounters(&pCounterData, &dwCounterData)))
    {
        return hr;
    }

    return m_pPipe->WriteMessage(IPM_OP_SEND_COUNTERS,  // ping reply opcode
                                 dwCounterData,         // no data to send
                                 pCounterData);         // pointer to no data
}

/**
 *
 * Routine Description: 
 *
 *
 *   Handles the shutdown message. Shuts down the process
 *   
 *  Arguments:
 *
 *   None.
 *  
 *  Return Value:
 *
 *   HRESULT
 */
HRESULT
WP_IPM::HandleShutdown(
    BOOL fDoImmediate
    )
{
    HRESULT hr = S_OK;

    IF_DEBUG( WPIPM )
    {
        DBGPRINTF((DBG_CONTEXT, "Handle ******************** Shutdown\n\n"));
    }
    m_pWpContext->IndicateShutdown( fDoImmediate );

    return hr;
}



/**
 *
 *  Routine Description:
 *
 *   Sends the message to indicate the worker process has either finished
 *   initializing or has failed to initialize.
 *   
 *  Arguments:
 *
 *   HRESULT indicating success/failure of initialization
 *   
 *  Return Value:
 *
 *   HRESULT
 */
HRESULT
WP_IPM::SendInitCompleteMessage(
    HRESULT hrToSend
    )
{
    if ( m_pPipe )
    {
        return m_pPipe->WriteMessage(
                   IPM_OP_HRESULT,                      // opcode
                   sizeof( hrToSend ),                  // data length
                   reinterpret_cast<BYTE*>( &hrToSend ) // pointer to data
                   );
    }

    // if the pipe did not exist then we started up
    // without the IPM, probably we are attempting
    // to run without WAS support. ( from the cmd line )
    
    return S_OK;
}


/**
 *
 *  Routine Description:
 *
 *   Sends the message to indicate the worker process has reach certain state.
 *   Main use is in shutdown.  See IPM_WP_SHUTDOWN_MSG for reasons.
 *   
 *   Arguments:
 *
 *   None.
 *   
 *  Return Value:
 *
 *   HRESULT
 */
HRESULT
WP_IPM::SendMsgToAdminProcess(
    IPM_WP_SHUTDOWN_MSG reason
    )
{
    if (m_pPipe)
    {
        return m_pPipe->WriteMessage(
               IPM_OP_WORKER_REQUESTS_SHUTDOWN, // sends message indicate shutdown
               sizeof(reason),                   // no data to send
               (BYTE *)&reason                   // pointer to no data
               );
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulatq\workerrequest.cxx ===
/*++

   Copyright    (c)    2000    Microsoft Corporation

   Module Name :
     workerrequest.cxx

   Abstract:
     UL_NATIVE_REQUEST implementation

   Author:
     Murali R. Krishnan    ( MuraliK )     23-Oct-1998
     Lei Jin               ( leijin  )     13-Apr-1999    (Porting)

   Environment:
     Win32 - User Mode

   Project:
     ULATQ.DLL
--*/

#include "precomp.hxx"

//
// User supplied completion routines
//

extern PFN_ULATQ_NEW_REQUEST        g_pfnNewRequest;
extern PFN_ULATQ_IO_COMPLETION      g_pfnIoCompletion;

//
// UL_NATIVE_REQUEST statics
//

ULONG            UL_NATIVE_REQUEST::sm_cRequestsServed;
ULONG            UL_NATIVE_REQUEST::sm_cRestart;
LONG             UL_NATIVE_REQUEST::sm_RestartMsgSent;
LIST_ENTRY       UL_NATIVE_REQUEST::sm_RequestListHead;
CRITICAL_SECTION UL_NATIVE_REQUEST::sm_csRequestList;
DWORD            UL_NATIVE_REQUEST::sm_cRequests;
PTRACE_LOG       UL_NATIVE_REQUEST::sm_pTraceLog;
DWORD            UL_NATIVE_REQUEST::sm_cRequestsPending;
DWORD            UL_NATIVE_REQUEST::sm_cDesiredPendingRequests;
BOOL             UL_NATIVE_REQUEST::sm_fAddingRequests;
ALLOC_CACHE_HANDLER * UL_NATIVE_REQUEST::sm_pachNativeRequests;
DWORD            UL_NATIVE_REQUEST::sm_cMaxFreeRequests = DEFAULT_MAX_FREE_REQUESTS;
DWORD            UL_NATIVE_REQUEST::sm_cFreeRequests;
#ifdef _WIN64
CSpinLock        UL_NATIVE_REQUEST::sm_FreeListLock;
SINGLE_LIST_ENTRY UL_NATIVE_REQUEST::sm_FreeList;
#else
SLIST_HEADER     UL_NATIVE_REQUEST::sm_FreeList;
#endif
HANDLE           UL_NATIVE_REQUEST::sm_hPendingRequestsTimer = NULL;


UL_NATIVE_REQUEST::UL_NATIVE_REQUEST(
    VOID
) : _pbBuffer( _achBuffer ),
    _cbBuffer( sizeof( _achBuffer ) ),
    _pClientCertInfo( NULL ),
    _cbAllocateMemoryOffset( 0 ),
    _cRefs( 1 )
{
    InitializeListHead( &_ListEntry );
    
    _FreeListEntry.Next = NULL;

    AddToRequestList();

    Reset();

    _dwSignature = UL_NATIVE_REQUEST_SIGNATURE;
}

UL_NATIVE_REQUEST::~UL_NATIVE_REQUEST(
    VOID
)
{
    DBG_ASSERT( CheckSignature() );
    _dwSignature = UL_NATIVE_REQUEST_SIGNATURE_FREE;

    if ( !IsListEmpty( &_ListEntry ) )
    {
        RemoveFromRequestList();
    }

    DBG_ASSERT( _cRefs == 0 );

    Cleanup();
}

VOID
UL_NATIVE_REQUEST::Cleanup(
    VOID
)
/*++

Routine Description:

    Private helper method called by destructor and Reset()
    It assures that resources are cleaned up properly

Arguments:

    None

Return Value:

    None

--*/
{
    if ( _pbBuffer != _achBuffer )
    {
        LocalFree( _pbBuffer );
    }
    _pbBuffer           = _achBuffer;
    _cbBuffer           = sizeof( _achBuffer );

    //
    // http.sys returns token in HTTP_SSL_CLIENT_CERT_INFO structure
    // UL_NATIVE_REQUEST must take care of closing the token to avoid leak
    //

    if ( _pClientCertInfo != NULL &&
         _pClientCertInfo->Token != NULL )
    {
        CloseHandle( _pClientCertInfo->Token );
        _pClientCertInfo->Token = NULL;
    }
    
    //
    // Start allocating from the beginning of the buffer
    //
    
    _cbAllocateMemoryOffset = 0;
}


VOID
UL_NATIVE_REQUEST::Reset(
    VOID
)
/*++

Routine Description:

    Reset a UL_NATIVE_REQUEST for use in the request state machine

Arguments:

    None

Return Value:

    None

--*/
{
    Cleanup();

    _ExecState          = NREQ_STATE_START;
    _pvContext          = NULL;
    _cbAsyncIOData      = 0;
    _dwAsyncIOError     = NO_ERROR;
    _dwClientCertFlags  = 0;

    ZeroMemory( &_Overlapped, sizeof(_Overlapped) );
}

VOID *
UL_NATIVE_REQUEST::AllocateMemory(
    DWORD                   cbSize
)
/*++

Routine Description:

    Allocate some memory for use by W3DT.DLL user
    in our private buffer

Arguments:

    cbSize - Size to allocate

Return Value:

    Pointer to memory (NULL if failed)

--*/
{
    DWORD               cbSizeNeeded = 0;
    VOID *              pvRet;
    ULONG_PTR           ulPointer;
    
    cbSizeNeeded = _cbAllocateMemoryOffset + cbSize + sizeof( ULONG_PTR );

    if ( cbSizeNeeded <= sizeof( _abAllocateMemory ) )
    {
        //
        // Allocate inline
        //
        
        ulPointer = (ULONG_PTR) _abAllocateMemory + _cbAllocateMemoryOffset;
        ulPointer = ( ulPointer + 7 ) & ~7;
        pvRet = (VOID*) ulPointer;
        
        _cbAllocateMemoryOffset += cbSize + sizeof( ULONG_PTR );
    }
    else
    {
        pvRet = NULL;
    }
    
    return pvRet;
}

VOID
UL_NATIVE_REQUEST::DoWork(
    DWORD                   cbData,
    DWORD                   dwError,
    LPOVERLAPPED            lpo
)
/*++

Routine Description:

    The driver of the state machine.  It is called off async completions and
    initially (with lpo=NULL) to kick off the state machine.

Arguments:

    cbData - Bytes completed
    dwError - Win32 Error of completion
    lpo - Pointer to OVERLAPPED passed in async call

Return Value:

    None

--*/
{
    NREQ_STATUS             Status = NSTATUS_NEXT;
    BOOL                    fError = FALSE;

    ReferenceWorkerRequest();

    if ( lpo != NULL )
    {
        //
        // This is an async completion.  Dereference the request to match
        // the reference before posting async operation
        //

        DereferenceWorkerRequest();

        //
        // Save away the completion data for state handler use and debugging
        // purposes
        //
        
        _cbAsyncIOData = cbData;
        _dwAsyncIOError = dwError;

        ZeroMemory( &_Overlapped, sizeof( _Overlapped ) );
    }

    //
    // Keep on executing the state machine until a state handler returns
    // pending.  If so, the IO completion will continue the machine
    //
    // We also break out on error (typical case will be shutdown)
    //

    while ( !fError && Status == NSTATUS_NEXT )
    {
        switch ( _ExecState )
        {
        case NREQ_STATE_START:
            Status = DoStateStart();
            break;

        case NREQ_STATE_READ:
            Status = DoStateRead();
            break;

        case NREQ_STATE_PROCESS:
            Status = DoStateProcess();
            break;

        case NREQ_STATE_ERROR:
            fError = TRUE;
            DereferenceWorkerRequest();
            break;

        case NREQ_STATE_CLIENT_CERT:
            Status = DoStateClientCertificate();
            break;

        default:
            fError = TRUE;
            DBG_ASSERT( FALSE );
            break;
        }
    }

    DereferenceWorkerRequest();
}

NREQ_STATUS
UL_NATIVE_REQUEST::DoStateStart(
    VOID
)
/*++

Routine Description:

    The NREQ_START state.  This state does the initial read for a new HTTP
    request (it passes a NULL request ID).  Continuing the read process (
    for example if the buffer is too small) happens in the NREQ_READ state.

Arguments:

    None

Return Value:

    NSTATUS_PENDING if async IO pending, else NSTATUS_NEXT

--*/
{
    ULONG               rc;
    HTTP_REQUEST_ID     RequestId;
    HANDLE              hAsync;

    //
    // This is the initial read, therefore we don't know the request ID
    //

    HTTP_SET_NULL_ID( &RequestId );

    //
    // If we are in shutdown, then just bail with error
    //

    if ( g_pwpContext->IsInShutdown() )
    {
        _ExecState = NREQ_STATE_ERROR;
        return NSTATUS_NEXT;
    }

    //
    // Have we served enough requests?
    //

    if ( sm_cRestart &&
         sm_cRequestsServed >= sm_cRestart )
    {
        //
        // Indicate to WAS such and the error out
        //

        if ( NeedToSendRestartMsg() )
        {
            g_pwpContext->SendMsgToAdminProcess( IPM_WP_RESTART_COUNT_REACHED );
        }

        _ExecState = NREQ_STATE_ERROR;
        return NSTATUS_NEXT;
    }

    //
    // Make an async call to HttpReceiveHttpRequest to get the next request
    //

    _ExecState = NREQ_STATE_READ;

    InterlockedIncrement( (LPLONG) &sm_cRequestsPending );

    ReferenceWorkerRequest();

    hAsync = g_pwpContext->GetAndLockAsyncHandle();

    if ( hAsync != NULL )
    {
        rc = HttpReceiveHttpRequest( hAsync,
                                     RequestId,
                                     HTTP_RECEIVE_REQUEST_FLAG_COPY_BODY,
                                     (HTTP_REQUEST *) _pbBuffer,
                                     _cbBuffer,
                                     NULL,
                                     &_Overlapped );
    }
    else
    {
        rc = ERROR_INVALID_HANDLE;
    }

    DBG_REQUIRE(SUCCEEDED(g_pwpContext->UnlockAsyncHandle()));

    if ( rc == NO_ERROR )
    {
        rc = ERROR_IO_PENDING;
    }

    if ( rc != ERROR_IO_PENDING )
    {
        DBG_ASSERT( rc != NO_ERROR );

        InterlockedDecrement( (LPLONG) &sm_cRequestsPending );

        _ExecState = NREQ_STATE_ERROR;

        DereferenceWorkerRequest();

        return NSTATUS_NEXT;
    }
    else
    {
        return NSTATUS_PENDING;
    }
}


NREQ_STATUS
UL_NATIVE_REQUEST::DoStateRead(
    VOID
)
/*++

Routine Description:

    The NREQ_READ state.  This state is responsible for producing a complete
    UL_HTTP_REQUEST for consumption by the NREQ_PROCESS state.  Note that
    this may require another UlReceiveHttpRequest() if the initial was not
    supplied a large enough buffer.

Arguments:

    None

Return Value:

    NSTATUS_PENDING if async IO pending, else NSTATUS_NEXT

--*/
{
    HTTP_REQUEST_ID     RequestId;
    ULONG               cbRequired;
    DWORD               cCurrentRequestsPending;
    HANDLE              hAsync;


    //
    // The initial read is complete.  If the error is ERROR_MORE_DATA, then
    // our buffer was not large enough.  Resize and try again
    //

    if ( _dwAsyncIOError == ERROR_MORE_DATA )
    {
        //
        // Remember the request ID to retry the the UlReceiveHttpRequest
        //
        RequestId = QueryRequestId();
        DBG_ASSERT( RequestId != HTTP_NULL_ID );

        //
        // We need to allocate a larger buffer :(
        //

        if ( _pbBuffer != _achBuffer )
        {
            //
            // We shouldn't be getting ERROR_MORE_DATA if we already
            // resized due to an earlier ERROR_MORE_DATA
            //

            DBG_ASSERT( FALSE );
            LocalFree( _pbBuffer );
            _pbBuffer = NULL;
        }

        //
        // The completed bytes tells us the required size of our input
        // buffer
        //

        _cbBuffer = _cbAsyncIOData;
        _pbBuffer = (UCHAR*) LocalAlloc( LPTR, _cbBuffer );
        if ( _pbBuffer == NULL )
        {
            _ExecState = NREQ_STATE_ERROR;
            return NSTATUS_NEXT;
        }

        //
        // Read the HTTP request again (better to do it sychronously, since
        // it is all ready now)
        //

        hAsync = g_pwpContext->GetAndLockAsyncHandle();

        if ( hAsync != NULL )
        {
            _dwAsyncIOError = HttpReceiveHttpRequest(
                                     hAsync,
                                     RequestId,
                                     HTTP_RECEIVE_REQUEST_FLAG_COPY_BODY,
                                     (HTTP_REQUEST *)_pbBuffer,
                                     _cbBuffer,
                                     &cbRequired,
                                     NULL );
        }
        else
        {
            _dwAsyncIOError = ERROR_INVALID_HANDLE;
        }

        DBG_REQUIRE(SUCCEEDED(g_pwpContext->UnlockAsyncHandle()));

        //
        // No reason this should fail again with ERROR_MORE_DATA
        //
        DBG_ASSERT( _dwAsyncIOError != ERROR_MORE_DATA );
    }

    if ( _dwAsyncIOError == NO_ERROR )
    {
        //
        // We're done.  The read was successful and we have a full
        // UL_HTTP_REQUEST.  We can now pass off to the NREQ_PROCESS state
        //

        cCurrentRequestsPending = InterlockedDecrement( (LPLONG)
                                                        &sm_cRequestsPending );

        if ( cCurrentRequestsPending < sm_cDesiredPendingRequests / 2 )
        {
            AddPendingRequests( sm_cDesiredPendingRequests - cCurrentRequestsPending );
        }

        _ExecState = NREQ_STATE_PROCESS;
    }
    else
    {
        //
        // Some other error.  Try again
        //

        InterlockedDecrement( (LPLONG) &sm_cRequestsPending );

        Reset();
    }

    return NSTATUS_NEXT;
}

NREQ_STATUS
UL_NATIVE_REQUEST::DoStateProcess(
    VOID
)
/*++

Routine Description:

    The NREQ_PROCESS state.  This state actually calls consumer of the
    NewRequests and IoCompletions.  This state calls the set routines in
    W3CORE.DLL

Arguments:

    None

Return Value:

    NSTATUS_PENDING if async IO pending, else NSTATUS_NEXT

--*/
{
    WP_IDLE_TIMER *         pTimer;

    //
    // Reset idle tick since we're not idle if we're processing
    //

    pTimer = g_pwpContext->QueryIdleTimer();
    if ( pTimer != NULL )
    {
        pTimer->ResetCurrentIdleTick();
    }

    ReferenceWorkerRequest();

    if ( _pvContext == NULL )
    {
        //
        // Extra reference here.  The consumer must call UlAtqResetContext()
        // to finally cleanup.  This complication is brought on by
        // scenarios where non-IO-completions are required to finish a request
        // (example: async ISAPI)
        //

        ReferenceWorkerRequest();

        DBG_ASSERT( g_pfnNewRequest != NULL );

        g_pfnNewRequest( this );
    }
    else
    {
        DBG_ASSERT( g_pfnIoCompletion != NULL );

        g_pfnIoCompletion( _pvContext,
                           _cbAsyncIOData,
                           _dwAsyncIOError,
                           &_Overlapped );
    }

    DereferenceWorkerRequest();

    return NSTATUS_PENDING;
}

NREQ_STATUS
UL_NATIVE_REQUEST::DoStateClientCertificate(
    VOID
)
/*++

Routine Description:

    Handle a completion for receiving a client certificate

Arguments:

    None

Return Value:

    NSTATUS_PENDING if async IO pending, else NSTATUS_NEXT

--*/
{
    ULONG                   Status;
    HTTP_REQUEST    *       pRequest;
    HANDLE                  hAsync;

    DBG_ASSERT( _ExecState == NREQ_STATE_CLIENT_CERT );

    //
    // Is our buffer too small.  If so retry the request synchronously with
    // a bigger buffer
    // Note: STATUS_BUFFER_OVERFLOW is translated to WIN32 Error - ERROR_MORE_DATA

    if ( _dwAsyncIOError == ERROR_MORE_DATA )
    {
        //
        // If buffer is not big enough, HTTP.sys will return only HTTP_SSL_CLIENT_CERT_INFO
        // structure that contains the size of the client certificate
        // The following assert is to assure that HTTP.SYS returns back that
        // HTTP_SSL_CLIENT_CERT_INFO structure and nothing more

        DBG_ASSERT( _cbAsyncIOData == sizeof( HTTP_SSL_CLIENT_CERT_INFO ) );

        //
        // We need to allocate enough memory to contain HTTP_SSL_CLIENT_CERT_INFO
        // and certificate blob
        //
        DWORD dwRequiredSize = _pClientCertInfo->CertEncodedSize +
                              sizeof( HTTP_SSL_CLIENT_CERT_INFO );

        DBG_ASSERT(  dwRequiredSize > _buffClientCertInfo.QuerySize() );

        if ( !_buffClientCertInfo.Resize( dwRequiredSize ) )
        {
            //
            // Funnel the fatal error to the complete
            //

            _dwAsyncIOError = GetLastError();
        }
        else
        {
            //
            // Retry the request for client cert synchronously
            //
            _pClientCertInfo = reinterpret_cast<HTTP_SSL_CLIENT_CERT_INFO *>( _buffClientCertInfo.QueryPtr() );

            hAsync = g_pwpContext->GetAndLockAsyncHandle();

            if ( hAsync != NULL )
            {

                Status = HttpReceiveClientCertificate( hAsync,
                                                       QueryConnectionId(),
                                                       _dwClientCertFlags,
                                                       _pClientCertInfo,
                                                       _buffClientCertInfo.QuerySize(),
                                                       NULL,
                                                       NULL );

            }
            else
            {
                Status = ERROR_INVALID_HANDLE;
            }

            DBG_REQUIRE(SUCCEEDED(g_pwpContext->UnlockAsyncHandle()));

            if ( Status != NO_ERROR )
            {
                DBG_ASSERT( _dwAsyncIOError != ERROR_MORE_DATA );
            }

            _dwAsyncIOError = Status;
            _cbAsyncIOData = dwRequiredSize;

        }
    }

    if ( _dwAsyncIOError == NO_ERROR )
    {
        pRequest = QueryHttpRequest();

        DBG_ASSERT( pRequest->pSslInfo != NULL );
        DBG_ASSERT( pRequest->pSslInfo->pClientCertInfo == NULL );

        pRequest->pSslInfo->pClientCertInfo = _pClientCertInfo;
    }

    //
    // Regardless of what happened, we are no longer processing a client cert
    //

    _ExecState = NREQ_STATE_PROCESS;

    DBG_ASSERT( g_pfnIoCompletion != NULL );

    g_pfnIoCompletion( _pvContext,
                       _cbAsyncIOData,
                       _dwAsyncIOError,
                       &_Overlapped );

    return NSTATUS_PENDING;
}

VOID
UL_NATIVE_REQUEST::ResetContext(
    VOID
)
/*++

Routine Description:

    The implementation of UlAtqResetContext which the consumer of W3DT.DLL
    calls to cleanup the context.

Arguments:

    None

Return Value:

    None

--*/
{
    DereferenceWorkerRequest();
}

VOID
UL_NATIVE_REQUEST::ReferenceWorkerRequest(
    VOID
)
/*++

Routine Description:

    Increment the reference count on the worker request

Arguments:

    None

Return Value:

    None

--*/
{
    LONG cRefs = InterlockedIncrement( &_cRefs );

    //
    // Log the reference ( sm_pTraceLog!=NULL if DBG=1)
    //

    if ( sm_pTraceLog != NULL )
    {
        WriteRefTraceLog( sm_pTraceLog,
                          cRefs,
                          this );
    }
}

VOID
UL_NATIVE_REQUEST::DereferenceWorkerRequest(
    VOID
)
/*++

Routine Description:

    Dereference Request.  This routine will optionally reset the context
    for use for reading the next HTTP request.  Putting the reset code in
    one place (here) handles all the cases where we would want to reset.
    However, there are a few places where we definitely don't want to reset
    (in the case of error where the context will be going away)

    In either case, if the ref count goes to 0, we can delete the object.

Arguments:

    None

Return Value:

    None

--*/
{
    LONG cRefs = InterlockedDecrement( &_cRefs );

    if ( sm_pTraceLog != NULL )
    {
        WriteRefTraceLog( sm_pTraceLog,
                          cRefs,
                          this );
    }

    if ( cRefs == 0 )
    {
        //
        // If 0, we can definitely cleanup, regardless.  This is the error
        // case which is used to cleanup contexts on shutdown (on shutdown,
        // the apppool handle is closed which will error out all pending
        // UlReceiveHttpRequests
        //

        delete this;
    }
    else if ( cRefs == 1 && _ExecState != NREQ_STATE_ERROR )
    {
        //
        // Reset the state machine.  Now we can increment our served count
        //

        InterlockedIncrement( (PLONG) &sm_cRequestsServed );

        //
        // If we have too many outstanding requests, then don't pend
        // another receive.  Keep the request around ready to go
        //

        if ( sm_cRequestsPending > sm_cDesiredPendingRequests * 2 )
        {
            FreeWorkerRequest( this );
        }
        else
        {
            Reset();

            //
            // Re-kickoff the state machine
            //

            DoWork( 0, 0, NULL );
        }
    }
}

VOID
UL_NATIVE_REQUEST::RemoveFromRequestList(
    VOID
)
/*++

Routine Description:

    Remove this UL_NATIVE_REQUEST from the static list of requests.  Main
    purpose of the list is for debugging.

Arguments:

    None

Return Value:

    None

--*/
{
    EnterCriticalSection( &sm_csRequestList );

    RemoveEntryList( &_ListEntry );
    sm_cRequests--;

    LeaveCriticalSection( &sm_csRequestList ); 
}

VOID
UL_NATIVE_REQUEST::AddToRequestList(
    VOID
)
/*++

Routine Description:

    Add this request to the static list of requests.  The main purpose of the
    list is for debugging.

Arguments:

    None

Return Value:

    None

--*/
{
    EnterCriticalSection( &sm_csRequestList );

    sm_cRequests++;
    InsertTailList( &sm_RequestListHead, &_ListEntry );

    LeaveCriticalSection( &sm_csRequestList ); 
}

HRESULT
UL_NATIVE_REQUEST::SendResponse(
    BOOL                    fAsync,
    DWORD                   dwFlags,
    HTTP_RESPONSE *         pResponse,
    HTTP_CACHE_POLICY *     pCachePolicy,
    DWORD                  *pcbSent,
    HTTP_LOG_FIELDS_DATA   *pUlLogData
)
/*++

Routine Description:

    Send an HTTP response thru UL.

Arguments:

    fAsync - TRUE if send is async
    dwFlags - UlSendHttpResponse flags
    pResponse - Pointer to UL_HTTP_RESPONSE
    pCachePolicy - Cache policy
    pcbSent - Receives number of bytes send
    pULLogData - Logging information

Return Value:

    HRESULT (if pending, the return is NO_ERROR)

--*/
{
    ULONG                   Status = NO_ERROR;
    HRESULT                 hr = NO_ERROR;
    HANDLE                  hAsync;

    if ( pcbSent == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    if ( fAsync )
    {
        ReferenceWorkerRequest();
    }

    hAsync = g_pwpContext->GetAndLockAsyncHandle();

    if ( hAsync != NULL )
    {
        Status = HttpSendHttpResponse( hAsync,
                                       QueryRequestId(),
                                       dwFlags,
                                       pResponse,
                                       pCachePolicy,
                                       fAsync ? NULL : pcbSent,
                                       NULL,
                                       0,
                                       fAsync ? &(_Overlapped) : NULL ,
                                       pUlLogData );
    }
    else
    {
        Status = ERROR_INVALID_HANDLE;
    }

    DBG_REQUIRE(SUCCEEDED(g_pwpContext->UnlockAsyncHandle()));

    //
    // If the response is pending, then we return a successful error code.
    // This frees the caller from the ERROR_IO_PENDING checks in common
    // case
    //

    if ( fAsync )
    {
        if ( Status == NO_ERROR )
        {
            Status = ERROR_IO_PENDING;
        }

        DBG_ASSERT( Status != NO_ERROR );

        if ( Status != ERROR_IO_PENDING )
        {
            _Overlapped.Internal = Status;
            
            DereferenceWorkerRequest();
            hr = HRESULT_FROM_WIN32( Status );
        }
    }
    else if ( Status != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Status );
    }

    return hr;
}

HRESULT
UL_NATIVE_REQUEST::SendEntity(
    BOOL                    fAsync,
    DWORD                   dwFlags,
    USHORT                  cChunks,
    HTTP_DATA_CHUNK *       pChunks,
    DWORD                  *pcbSent,
    HTTP_LOG_FIELDS_DATA   *pUlLogData
)
/*++

Routine Description:

    Send an HTTP entity thru UL.

Arguments:

    fAsync - TRUE if send is async
    dwFlags - UlSendHttpResponse flags
    cChunks - Number of chunks in response
    pChunks - Pointer to array of UL_DATA_CHUNKs
    pcbSent - Receives number of bytes sent
    pUlLogData - Log information

Return Value:

    HRESULT (if pending, the return is NO_ERROR)

--*/
{
    ULONG                   Status = NO_ERROR;
    HRESULT                 hr = NO_ERROR;
    HANDLE                  hAsync;

    if ( pcbSent == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    if ( fAsync )
    {
        ReferenceWorkerRequest();
    }

    hAsync = g_pwpContext->GetAndLockAsyncHandle();

    if ( hAsync != NULL )
    {
        Status = HttpSendResponseEntityBody( hAsync,
                                             QueryRequestId(),
                                             dwFlags,
                                             cChunks,
                                             pChunks,
                                             fAsync ? NULL : pcbSent,
                                             NULL,
                                             0,
                                             fAsync ? &(_Overlapped) : NULL,
                                             pUlLogData );
    }
    else
    {
        Status = ERROR_INVALID_HANDLE;
    }

    DBG_REQUIRE(SUCCEEDED(g_pwpContext->UnlockAsyncHandle()));

    //
    // If the send is pending, then we return a successful error code.
    // This frees the caller from the ERROR_IO_PENDING checks in common
    // case
    //

    if ( fAsync )
    {
        if ( Status == NO_ERROR )
        {
            Status = ERROR_IO_PENDING;
        }

        DBG_ASSERT( Status != NO_ERROR );

        if ( Status != ERROR_IO_PENDING )
        {
            _Overlapped.Internal = Status;
            
            DereferenceWorkerRequest();
            hr = HRESULT_FROM_WIN32( Status );
        }
    }
    else if ( Status != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Status );
    }

    return hr;
}

HRESULT
UL_NATIVE_REQUEST::ReceiveEntity(
    BOOL                fAsync,
    DWORD               dwFlags,
    VOID *              pBuffer,
    DWORD               cbBuffer,
    DWORD *             pBytesReceived
)
/*++

Routine Description:

    Receive HTTP entity thru UL.

Arguments:

    fAsync - TRUE if receive is async
    dwFlags - UlSendHttpResponse flags
    pBuffer - A buffer to receive the data
    cbBuffer - The size of the receive buffer
    pBytesReceived - Upon return, the number of bytes
                     copied to the buffer

Return Value:

    HRESULT (if pending, the return is NO_ERROR)

--*/
{
    ULONG                   Status = NO_ERROR;
    HRESULT                 hr = NO_ERROR;
    HANDLE                  hAsync;

    if ( fAsync )
    {
        ReferenceWorkerRequest();
    }

    hAsync = g_pwpContext->GetAndLockAsyncHandle();

    if ( hAsync != NULL )
    {
        Status = HttpReceiveRequestEntityBody( hAsync,
                                               QueryRequestId(),
                                               dwFlags,
                                               pBuffer,
                                               cbBuffer,
                                               fAsync ? NULL : pBytesReceived,
                                               fAsync ? &(_Overlapped) : NULL );
    }
    else
    {
        Status = ERROR_INVALID_HANDLE;
    }

    DBG_REQUIRE(SUCCEEDED(g_pwpContext->UnlockAsyncHandle()));

    //
    // If the receive is pending, then we return a successful error code.
    // This frees the caller from the ERROR_IO_PENDING checks in common
    // case
    //

    if ( fAsync )
    {
        if ( Status == NO_ERROR )
        {
            Status = ERROR_IO_PENDING;
        }

        DBG_ASSERT( Status != NO_ERROR );

        if ( Status != ERROR_IO_PENDING )
        {
            _Overlapped.Internal = Status;
            
            DereferenceWorkerRequest();
            hr = HRESULT_FROM_WIN32( Status );
        }
    }
    else if ( Status != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Status );
    }

    return hr;
}

HRESULT
UL_NATIVE_REQUEST::ReceiveClientCertificate(
    BOOL                        fAsync,
    BOOL                        fDoCertMap,
    HTTP_SSL_CLIENT_CERT_INFO **ppClientCertInfo
)
/*++

Routine Description:

    Receive a client certificate

Arguments:

    fAsync - TRUE if receive should be async
    fDoCertMap - TRUE if we should map client certificate to token
    ppClientCertInfo - Set to point to client cert info on success

Return Value:

    HRESULT (if pending, the return is NO_ERROR)

--*/
{
    ULONG                   Status;
    HTTP_REQUEST *          pHttpRequest;
    HRESULT                 hr = NO_ERROR;
    HANDLE                  hAsync;

    if ( ppClientCertInfo == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    *ppClientCertInfo = NULL;

    //
    // If this request is not SSL enabled, then getting the client cert is
    // a no-go
    //

    pHttpRequest = QueryHttpRequest();
    DBG_ASSERT( pHttpRequest != NULL );

    if ( pHttpRequest->pSslInfo == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
    }

    //
    // Do we already have a cert associated with this request?
    //

    DBG_ASSERT( pHttpRequest->pSslInfo != NULL );

    if ( pHttpRequest->pSslInfo->pClientCertInfo != NULL )
    {
        if ( fAsync )
        {
            //
            // BUGBUG:  Probably should support this case.  And if I do, then
            //          need to fake a completion!
            //

            DBG_ASSERT( FALSE );
            return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        }

        *ppClientCertInfo = pHttpRequest->pSslInfo->pClientCertInfo;

        return NO_ERROR;
    }

    //
    // OK.  We'll have to ask UL to renegotiate.  We must be processing
    // a request
    //

    DBG_ASSERT( _ExecState == NREQ_STATE_PROCESS );

    if ( !_buffClientCertInfo.Resize( INITIAL_CERT_INFO_SIZE ) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    ZeroMemory( _buffClientCertInfo.QueryPtr(), INITIAL_CERT_INFO_SIZE );

    _pClientCertInfo = reinterpret_cast<HTTP_SSL_CLIENT_CERT_INFO *>( _buffClientCertInfo.QueryPtr() );

    //
    // Are we cert mapping?
    //

    if ( fDoCertMap )
    {
        _dwClientCertFlags = HTTP_RECEIVE_CLIENT_CERT_FLAG_MAP;
    }
    else
    {
        _dwClientCertFlags = 0;
    }

    //
    // If we're doing this async, then manage state such that
    // DoStateClientCert gets the completion
    //

    if ( fAsync )
    {
        ReferenceWorkerRequest();
        _ExecState = NREQ_STATE_CLIENT_CERT;
    }

    hAsync = g_pwpContext->GetAndLockAsyncHandle();

    if ( hAsync != NULL )
    {
        Status = HttpReceiveClientCertificate( hAsync,
                                               QueryConnectionId(),
                                               _dwClientCertFlags,
                                               _pClientCertInfo,
                                               _buffClientCertInfo.QuerySize(),
                                               NULL,
                                               fAsync ? &_Overlapped : NULL );
    }
    else
    {
        Status = ERROR_INVALID_HANDLE;
    }

    DBG_REQUIRE(SUCCEEDED(g_pwpContext->UnlockAsyncHandle()));

    if ( fAsync )
    {
        if ( Status == NO_ERROR )
        {
            Status = ERROR_IO_PENDING;
        }

        DBG_ASSERT( Status != NO_ERROR );

        if ( Status != ERROR_IO_PENDING )
        {
            _Overlapped.Internal = Status;
            
            DereferenceWorkerRequest();
            hr = HRESULT_FROM_WIN32( Status );
            _ExecState = NREQ_STATE_PROCESS;
        }
    }
    else if ( Status != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Status );
    }

    return hr;
}

//static
HRESULT
UL_NATIVE_REQUEST::Initialize(
    VOID
)
/*++

Routine Description:

    Static initialization of UL_NATIVE_REQUESTs

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ALLOC_CACHE_CONFIGURATION       acConfig;
    HKEY                            hKey;
    BOOL                            fRet;
    HRESULT                         hr;

    //
    // Setup allocation lookaside
    //

    acConfig.nConcurrency = 1;
    acConfig.nThreshold = 100;
    acConfig.cbSize = sizeof( UL_NATIVE_REQUEST );

    DBG_ASSERT( sm_pachNativeRequests == NULL );

    sm_pachNativeRequests = new ALLOC_CACHE_HANDLER( "UL_NATIVE_REQUEST",
                                                     &acConfig );
    if ( sm_pachNativeRequests == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    fRet = InitializeCriticalSectionAndSpinCount( &sm_csRequestList,
                                                  UL_NATIVE_REQUEST_CS_SPINS );
    if ( !fRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        delete sm_pachNativeRequests;
        sm_pachNativeRequests = NULL;
        
        return hr;
    }

    InitializeListHead( &sm_RequestListHead );

#ifdef _WIN64
    sm_FreeList.Next = NULL;
#else
    InitializeSListHead( &sm_FreeList );
#endif

    sm_cRequestsServed          = 0;
    sm_cRestart                 = 0;
    sm_RestartMsgSent           = 0;
    sm_cRequestsPending         = 0;

    //
    // If the number of pending HttpReceiveHttpRequest is configured, use
    // that rather than the default value
    //
    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      REGISTRY_KEY_W3SVC_PERFORMANCE_KEY_W,
                      0,
                      KEY_READ,
                      &hKey ) == ERROR_SUCCESS)
    {
        DWORD  cbBuffer = sizeof(DWORD);
        DWORD  dwType;

        if (RegQueryValueEx( hKey,
                             L"ReceiveRequestsPending",
                             NULL,
                             &dwType,
                             (LPBYTE)&sm_cDesiredPendingRequests,
                             &cbBuffer ) != NO_ERROR ||
            dwType != REG_DWORD)
        {
            sm_cDesiredPendingRequests  = DESIRED_PENDING_REQUESTS;
        }

        RegCloseKey( hKey );
    }
    else
    {
        sm_cDesiredPendingRequests  = DESIRED_PENDING_REQUESTS;
    }

    sm_fAddingRequests          = FALSE;

#if DBG
    sm_pTraceLog = CreateRefTraceLog( 2000, 0 );
#endif

    return NO_ERROR;
}

//static
VOID
UL_NATIVE_REQUEST::StopListening(
    VOID
)
/*++

Routine Description:

    Shutdown the apppool in preparation for shutdown

Arguments:

    None

Return Value:

    None

--*/
{
    HANDLE              hAsync;

    hAsync = g_pwpContext->GetAndLockAsyncHandle();

    if ( hAsync != NULL )
    {
        //
        // This will cause us to cancel all pending HttpReceiveHttpRequest calls
        // and not get any more but other operations will still go on
        //
        HttpShutdownAppPool( hAsync );
    }

    DBG_REQUIRE(SUCCEEDED(g_pwpContext->UnlockAsyncHandle()));

}

//static
VOID
UL_NATIVE_REQUEST::Terminate(
    VOID
)
/*++

Routine Description:

    Static termination

Arguments:

    None

Return Value:

    None

--*/
{
    if ( sm_pTraceLog != NULL )
    {
        DestroyRefTraceLog( sm_pTraceLog );
        sm_pTraceLog = NULL;
    }

    DeleteCriticalSection( &sm_csRequestList );

    if ( sm_pachNativeRequests != NULL )
    {
        delete sm_pachNativeRequests;
        sm_pachNativeRequests = NULL;
    }
}

//static
HRESULT
UL_NATIVE_REQUEST::AddPendingRequests(
    DWORD                   cRequests
)
/*++

Routine Description:

    Pools calls to UlReceiveHttpRequest by creating new UL_NATIVE_REQUESTs
    and kicking off their state machines

Arguments:

    cRequests - Number of requests to read

Return Value:

    HRESULT

--*/
{
    UL_NATIVE_REQUEST *         pRequest;

    if ( sm_fAddingRequests )
    {
        return NO_ERROR;
    }

    if ( InterlockedCompareExchange( (LPLONG) &sm_fAddingRequests,
                                     TRUE,
                                     FALSE ) == FALSE )
    {
        for ( DWORD i = 0; i < cRequests; i++ )
        {
            pRequest = AllocateWorkerRequest();
            if ( pRequest == NULL )
            {
                return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
            }

            pRequest->DoWork( 0, 0, NULL );
        }

        sm_fAddingRequests = FALSE;
    }

    return NO_ERROR;
}

//static
HRESULT
UL_NATIVE_REQUEST::ReleaseAllWorkerRequests(
    VOID
)
/*++

Routine Description:

    Wait for all outstanding UL_NATIVE_REQUESTs to drain

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    UL_NATIVE_REQUEST *         pRequest;
    
    //
    // Now, wait for all requests to be destructed
    //
    
    while ( sm_cRequests )
    {
        //
        // Clear out any of our free list items.  Since this list
        // may be appended to right now, keep on cleaning it
        //
    
        for ( ; ; )
        {
            pRequest = PopFreeList();
            if ( pRequest == NULL )
            {
                break;
            }
        
            DBG_ASSERT( pRequest != NULL );
            DBG_ASSERT( pRequest->CheckSignature() );
        
            //
            // Free it up
            //
        
            pRequest->DereferenceWorkerRequest();
        }
    
        Sleep( 1000 );

        DBGPRINTF(( DBG_CONTEXT,
                    "UL_NATIVE_REQUEST::ReleaseAllWorkerRequests waiting for %d requests to drain.\n",
                    sm_cRequests ));
    }

    return NO_ERROR;
}


//static
VOID
WINAPI
UL_NATIVE_REQUEST::PendingRequestsMonitorHandler(
    PVOID,
    BOOLEAN                
)
/*++

Routine Description:

    Check if pending requests number is 0.
    If it is 0 then try to add 1 pending request
    to allow this worker process to start handling
    http requests again

Arguments:

    None

Return Value:

    NONE

--*/

{
    if ( sm_cRequestsPending == 0 )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "Worker process has run out of pending requests. Trying to add one\n"
                 ));

        //
        // If pending requests number is 0 then
        // it means there must have been errors on
        // HttpReceiveHttpRequest() call that
        // caused worker process to run out of pending requests
        // It is time to intervene by adding one
        // pending request. That should jump start
        // the process of handling the requests again
        //
        // Note: We don't check the error because there
        // is nothing we can do about the error. If 
        // we failed then the next time timer fires and
        // this handler gets called we will simply retry
        
        AddPendingRequests( 1 );
    }
}


//static
HRESULT
UL_NATIVE_REQUEST::StartPendingRequestsMonitor(
    VOID
)
/*++

Routine Description:

    Start timer to  enable monitoring of the pending requests

Arguments:

    None

Return Value:

    HRESULT

--*/

{
    HRESULT hr = E_FAIL;
    //
    // create timer to wake up every 5 seconds
    //
    //
    if ( !CreateTimerQueueTimer( &sm_hPendingRequestsTimer,
                                 NULL,
                                 UL_NATIVE_REQUEST::PendingRequestsMonitorHandler,
                                 NULL,
                                 5000,
                                 5000,
                                 WT_EXECUTELONGFUNCTION ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
    }
    else
    {
        hr = S_OK;
    }
    return hr;        
}


//static
VOID
UL_NATIVE_REQUEST::StopPendingRequestsMonitor(
    VOID
)
/*++

Routine Description:

    Stop timer for monitoring of the pending requests

Arguments:

    None

Return Value:

    HRESULT

--*/

{
    if ( sm_hPendingRequestsTimer != NULL )
    {
        if ( !DeleteTimerQueueTimer(   
                       NULL,
                       sm_hPendingRequestsTimer,
                       INVALID_HANDLE_VALUE /* wait for callbacks to complete */ 
                       ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Failed to delete Ping timer (%d)\n", 
                        GetLastError() ));
        }
        sm_hPendingRequestsTimer = NULL;
    }

}


//static
VOID
UL_NATIVE_REQUEST::FreeWorkerRequest(
    UL_NATIVE_REQUEST *             pWorkerRequest
)
/*++

Routine Description:

    Free worker request

Arguments:

    pNativeRequest - Worker request to retrieve

Return Value:

    None

--*/
{
    DBG_ASSERT( pWorkerRequest != NULL );
    
    if ( sm_cFreeRequests > sm_cMaxFreeRequests ||
         g_pwpContext->IsInShutdown() )
    {
        //
        // Don't keep too many around (especially in shutdown ;-)).  
        // Just free this guy by dereferencing one more time
        //
        
        pWorkerRequest->DereferenceWorkerRequest();
    }
    else
    {
        pWorkerRequest->Reset();
       
        PushFreeList( pWorkerRequest );
        
        sm_cFreeRequests++;
    }
}

//static
UL_NATIVE_REQUEST *
UL_NATIVE_REQUEST::AllocateWorkerRequest(
    VOID
)
/*++

Routine Description:

    Allocate a new request

Arguments:

    None

Return Value:

    Pointer to new request or NULL if error

--*/
{
    UL_NATIVE_REQUEST *     pRequest;
    
    if ( sm_cFreeRequests )
    {
        pRequest = PopFreeList();
        if ( pRequest != NULL )
        {
            DBG_ASSERT( pRequest->CheckSignature() );
            
            sm_cFreeRequests--;

            return pRequest;
        }
    }
    
    //
    // If we got to here, we have to allocate a new request
    //
    
    pRequest = new UL_NATIVE_REQUEST;
    
    return pRequest;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\anonymousprovider.cxx ===
/*++
   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     anonymousprovider.cxx

   Abstract:
     Anonymous authentication provider
 
   Author:
     Bilal Alam (balam)             10-Jan-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include "anonymousprovider.hxx"

HRESULT
ANONYMOUS_AUTH_PROVIDER::DoesApply(
    W3_MAIN_CONTEXT *       pMainContext,
    BOOL *                  pfApplies
)
/*++

Routine Description:

    Does anonymous apply to this request?

Arguments:

    pMainContext - Main context representing request
    pfApplies - Set to true if SSPI is applicable
    
Return Value:

    HRESULT

--*/
{
    UNREFERENCED_PARAMETER( pMainContext );

    if ( pfApplies == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // Anonymous ALWAYS applies!
    //
    
    *pfApplies = TRUE;
    return NO_ERROR;
}
    
HRESULT
ANONYMOUS_AUTH_PROVIDER::DoAuthenticate(
    W3_MAIN_CONTEXT *       pMainContext,
    BOOL *                  pfFilterFinished
)
/*++

Routine Description:

    Do anonymous authentication (trivial)

Arguments:

    pMainContext - Main context representing request
    pfFilterFinished - Set to TRUE if filter wants out
    
Return Value:

    HRESULT

--*/
{
    W3_METADATA *           pMetaData = NULL;
    TOKEN_CACHE_ENTRY *     pCachedToken = NULL;
    HRESULT                 hr;
    ANONYMOUS_USER_CONTEXT* pUserContext = NULL;
    BOOL                    fRet;
    DWORD                   dwLogonError;
    BOOL                    fPossibleUPNLogon = FALSE;
    BOOL                    fFilterSetUser = FALSE;
    // add 1 to strUserDomain for separator "\"
    STACK_STRA(             strUserDomain, UNLEN + IIS_DNLEN + 1 + 1 );

    
    if ( pMainContext == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    pMetaData = pMainContext->QueryUrlContext()->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );

    //
    // Notify authentication filters
    //
    
    if ( pMainContext->IsNotificationNeeded( SF_NOTIFY_AUTHENTICATION ) )
    {
        HTTP_FILTER_AUTHENT     filterAuthent;
        STACK_STRA(             strPassword, PWLEN + 1 );
        // add 1 to strUserDomainW for separator "\"
        STACK_STRU(             strUserDomainW, UNLEN + IIS_DNLEN + 1 + 1 );
        STACK_STRU(             strPasswordW, PWLEN + 1 );
        STACK_STRU(             strDomainNameW, IIS_DNLEN + 1 );
        STACK_STRU(             strUserNameW, UNLEN + 1 );

        
        DBG_ASSERT( strUserDomain.IsEmpty() );
        hr = strUserDomain.Resize( SF_MAX_USERNAME );
        if ( FAILED( hr ) )
        {
            return hr;
        }        

        DBG_ASSERT( strPassword.IsEmpty() );        
        hr = strPassword.Resize( SF_MAX_PASSWORD );
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        filterAuthent.pszUser = strUserDomain.QueryStr();
        filterAuthent.cbUserBuff = SF_MAX_USERNAME;
        
        filterAuthent.pszPassword = strPassword.QueryStr();
        filterAuthent.cbPasswordBuff = SF_MAX_PASSWORD;
        
        fRet = pMainContext->NotifyFilters( SF_NOTIFY_AUTHENTICATION,
                                            &filterAuthent,
                                            pfFilterFinished );

        if ( !fRet )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }
        
        if ( *pfFilterFinished )
        {
            return NO_ERROR;
        }
        
        strUserDomain.SetLen( strlen( strUserDomain.QueryStr() ) );
        strPassword.SetLen( strlen( strPassword.QueryStr() ) );

    
        //
        // If the filter set a user/password, then use it
        //
        
        if ( strUserDomain.QueryCCH() > 0 )
        {
            fFilterSetUser = TRUE;
            //
            // Convert to unicode 
            //
        
            hr = strUserDomainW.CopyA( strUserDomain.QueryStr() );
            if ( FAILED( hr ) ) 
            {
                return hr;
            }
        
            hr = strPasswordW.CopyA( strPassword.QueryStr() );
            if ( FAILED( hr ) )
            {
                return hr;
            }
        
            //
            // Get username/domain out of domain\username
            //
        
            hr = W3_STATE_AUTHENTICATION::SplitUserDomain( strUserDomainW,
                                                           &strUserNameW,
                                                           &strDomainNameW,
                                                           NULL,
                                                           &fPossibleUPNLogon );
            if ( FAILED( hr ) )
            {
                return hr;
            }
        
            //
            // Try to get the token
            // 

            DBG_ASSERT( g_pW3Server->QueryTokenCache() != NULL );
        
            hr = g_pW3Server->QueryTokenCache()->GetCachedToken(
                                                  strUserNameW.QueryStr(),
                                                  strDomainNameW.QueryStr(),
                                                  strPasswordW.QueryStr(),
                                                  pMetaData->QueryLogonMethod(),
                                                  FALSE,
                                                  fPossibleUPNLogon,
                                                  NULL,
                                                  &pCachedToken,
                                                  &dwLogonError );
            if ( FAILED( hr ) )
            {
                return hr;
            }
        }
    }

    
    if ( !fFilterSetUser )
    {
        //
        // If anonymous is not allowed, and a filter didn't
        // set credentials, then we need to fail.
        //

        if ( pMainContext->QueryCheckAnonAuthTypeSupported() &&
             !pMetaData->QueryAuthTypeSupported( MD_AUTH_ANONYMOUS ) )
        {
            return SEC_E_NO_CREDENTIALS;
        }
        
        //
        // Use the IUSR account
        //

        hr = pMetaData->GetAndRefAnonymousToken( &pCachedToken );
        if( FAILED( hr ) )
        {
            return hr;
        }
    }
    
    if ( pCachedToken == NULL )
    {
        //
        // Bogus anonymous account
        //
        
        pMainContext->QueryResponse()->SetStatus( HttpStatusUnauthorized,
                                                  Http401BadLogon );
        
        return NO_ERROR;
    }

    //
    // For perf reasons, the anonymous user context is inline
    //

    pUserContext = new (pMainContext) ANONYMOUS_USER_CONTEXT( this );
    DBG_ASSERT( pUserContext != NULL );
    
    hr = pUserContext->Create( pCachedToken );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    if ( fFilterSetUser )
    {
        //
        // Store the new username set by the filter
        //

        hr = pUserContext->SetUserNameA( strUserDomain.QueryStr() );

        if ( FAILED( hr ) )
        {
            return hr;
        }
    }
    
    pMainContext->SetUserContext( pUserContext );
    
    return NO_ERROR; 
}

HRESULT
ANONYMOUS_USER_CONTEXT::Create(
    TOKEN_CACHE_ENTRY *         pCachedToken
)
/*++

Routine Description:

    Initialize anonymous context

Arguments:

    pCachedToken - anonymous user token
    
Return Value:

    HRESULT

--*/
{
    if ( pCachedToken == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    _pCachedToken = pCachedToken;

    SetCachedToken( TRUE );

    return _strUserName.Copy( L"" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\authstate.cxx ===
/*++

   Copyright    (c)    2000    Microsoft Corporation
            
   Module Name:
      authstate.cxx

   Abstract:
      Authenticate state implementation (and authentication utilities)

   Author:
      Ming Lu    ( MingLu )    2-Feb-2000

   Environment:
      Win32 User Mode

   Revision History:

--*/

#include "precomp.hxx"
#include "sspiprovider.hxx"
#include "digestprovider.hxx"
#include "iisdigestprovider.hxx"
#include "basicprovider.hxx"
#include "anonymousprovider.hxx"
#include "certmapprovider.hxx"
#include "iiscertmapprovider.hxx"
#include "customprovider.hxx"
#include "passportprovider.hxx"

#define  IIS_SUBAUTH_NAME   L"iissuba"

W3_STATE_AUTHENTICATION *   W3_STATE_AUTHENTICATION::sm_pAuthState;
BOOL               W3_STATE_AUTHENTICATION::sm_fSubAuthConfigured      = FALSE;
BOOL               W3_STATE_AUTHENTICATION::sm_fLocalSystem            = FALSE;
LONG               W3_STATE_AUTHENTICATION::sm_lSubAuthAnonEvent       = 0;
LONG               W3_STATE_AUTHENTICATION::sm_lSubAuthDigestEvent     = 0;
LONG               W3_STATE_AUTHENTICATION::sm_lLocalSystemEvent       = 0;
PTRACE_LOG         W3_USER_CONTEXT::sm_pTraceLog;
PTRACE_LOG         CONNECTION_AUTH_CONTEXT::sm_pTraceLog;

HRESULT
W3_STATE_AUTHENTICATION::GetDefaultDomainName(
    VOID
)
/*++
  Description:
    
    Fills in the member variable with the name of the default domain 
    to use for logon validation

  Arguments:

    None

  Returns:    
    
    HRESULT

--*/
{
    OBJECT_ATTRIBUTES           ObjectAttributes;
    NTSTATUS                    NtStatus;
    DWORD                       dwLength;
    DWORD                       err                = 0;
    LSA_HANDLE                  LsaPolicyHandle    = NULL;
    PPOLICY_ACCOUNT_DOMAIN_INFO pAcctDomainInfo    = NULL;
    PPOLICY_PRIMARY_DOMAIN_INFO pPrimaryDomainInfo = NULL;
    HRESULT                     hr                 = S_OK;

    //
    //  Open a handle to the local machine's LSA policy object.
    //

    InitializeObjectAttributes( &ObjectAttributes,  
                                NULL,             
                                0L,               
                                NULL,             
                                NULL );           

    NtStatus = LsaOpenPolicy( NULL,               
                              &ObjectAttributes,  
                              POLICY_EXECUTE,     
                              &LsaPolicyHandle ); 

    if( !NT_SUCCESS( NtStatus ) )
    {
        DBGPRINTF((  DBG_CONTEXT,
                    "cannot open lsa policy, error %08lX\n",
                     NtStatus ));

        err = LsaNtStatusToWinError( NtStatus );

        //
        // Failure LsaOpenPolicy() does not guarantee that 
        // LsaPolicyHandle was not touched.
        //
        LsaPolicyHandle = NULL;

        goto Cleanup;
    }

    //
    //  Query the account domain information from the policy object.
    //

    NtStatus = LsaQueryInformationPolicy( LsaPolicyHandle,
                                          PolicyAccountDomainInformation,
                                          (PVOID *)&pAcctDomainInfo );

    if( !NT_SUCCESS( NtStatus ) )
    {

        DBGPRINTF((  DBG_CONTEXT,
                    "cannot query lsa policy info, error %08lX\n",
                     NtStatus ));

        err = LsaNtStatusToWinError( NtStatus );
        goto Cleanup;
    }

    DBG_ASSERT( pAcctDomainInfo != NULL );
    
    dwLength = pAcctDomainInfo->DomainName.Length / sizeof( WCHAR );

    if( dwLength < sizeof( _achDefaultDomainName ) / sizeof( WCHAR ) )
    {
        wcsncpy( _achDefaultDomainName, 
                 (LPCWSTR)pAcctDomainInfo->DomainName.Buffer, 
                 dwLength );

        _achDefaultDomainName[ dwLength ] = L'\0';
    }
    else
    {
        err = ERROR_INSUFFICIENT_BUFFER;
        goto Cleanup;
    }

    //
    //  Query the primary domain information from the policy object.
    //

    NtStatus = LsaQueryInformationPolicy( LsaPolicyHandle,
                                          PolicyPrimaryDomainInformation,
                                          (PVOID *)&pPrimaryDomainInfo );

    if( !NT_SUCCESS( NtStatus ) )
    {

        DBGPRINTF((  DBG_CONTEXT,
                    "cannot query lsa policy info, error %08lX\n",
                     NtStatus ));

        err = LsaNtStatusToWinError( NtStatus );
        goto Cleanup;
    }

    DBG_ASSERT( pPrimaryDomainInfo != NULL );
    
    if( pPrimaryDomainInfo->Sid )
    {
        // 
        // We are a domain member
        //

        _fIsDomainMember = TRUE;

        //
        // Tres freakin lame.  Gotta call into GetComputerNameEx() since I
        // need to fully qualified name.  If it fails, oh well, we don't
        // provide a default domain name for Passport calls
        //
        
        dwLength = sizeof( _achMemberDomainName ) / sizeof( WCHAR );

        GetComputerNameEx( ComputerNameDnsDomain,
                           _achMemberDomainName,
                           &dwLength );
    }
    else
    {
        _fIsDomainMember = FALSE;
    }

    //
    //  Success!
    //

    DBG_ASSERT( err == 0 );

Cleanup:

    if( pAcctDomainInfo != NULL )
    {
        LsaFreeMemory( (PVOID)pAcctDomainInfo );
        pAcctDomainInfo = NULL;                                          
    }

    if( pPrimaryDomainInfo != NULL )
    {
        LsaFreeMemory( (PVOID)pPrimaryDomainInfo ); 
        pPrimaryDomainInfo = NULL;                                         
    }

    if( LsaPolicyHandle != NULL )
    {
        LsaClose( LsaPolicyHandle );
    }

    if ( err )
    {
        hr = HRESULT_FROM_WIN32( err );
    }

    return hr;
};

//static
HRESULT
W3_STATE_AUTHENTICATION::SplitUserDomain(
    STRU &                  strUserDomain,
    STRU *                  pstrUserName,
    STRU *                  pstrDomainName,
    WCHAR *                 pszDefaultDomain,
    BOOL *                  pfPossibleUPNLogon
)
/*++
  Description:
    
    Split the input user name into user/domain.  

  Arguments:

    strUserDomain - Combined domain\username (not altered)
    pstrUserName - Filled with user name only
    pstrDomainName - Filled with domain name (either embedded in 
                     *pstrUserName,or from metabase/computer domain name)
    pszDefaultDomain - Default domain specified in metabase
    pfPossibleUPNLogon - TRUE if we may need to do UNP logon, 
                         otherwise FALSE

  Returns:    
    
    HRESULT

--*/
{
    WCHAR *                 pszUserName;
    WCHAR *                 pszDomain;
    DWORD                   cbDomain;
    HRESULT                 hr;
    
    if ( pstrUserName == NULL   ||
         pstrDomainName == NULL ||
         pfPossibleUPNLogon == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    pszUserName = wcspbrk( strUserDomain.QueryStr(), L"/\\" );
    if ( pszUserName == NULL )
    {
        //
        // No domain in the user name.  First try the metabase domain 
        // name
        //
        
        pszDomain = pszDefaultDomain;
        if ( pszDomain == NULL || *pszDomain == L'\0' )
        {
            //
            // No metabase domain, use default domain name
            //
            
            pszDomain = QueryDefaultDomainName();
            DBG_ASSERT( pszDomain != NULL );
        }
        
        pszUserName = strUserDomain.QueryStr();
        
        hr = pstrDomainName->Copy( pszDomain );
        if ( FAILED( hr ) )
        {
            return hr;
        }

        *pfPossibleUPNLogon = TRUE;
    }
    else
    {
        cbDomain = DIFF( pszUserName - strUserDomain.QueryStr() );
        if( cbDomain == 0 )
        {
            hr = pstrDomainName->Copy( L"." );
        }
        else
        {
            hr = pstrDomainName->Copy( strUserDomain.QueryStr(), cbDomain );
        }

        if ( FAILED( hr ) )
        {
            return hr;
        }

        pszUserName = pszUserName + 1;

        *pfPossibleUPNLogon = FALSE;
    }
    
    hr = pstrUserName->Copy( pszUserName );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    return NO_ERROR;
}

HRESULT
W3_STATE_AUTHENTICATION::OnAccessDenied(
    W3_MAIN_CONTEXT *       pMainContext
)
/*++
  Description:
    
    Called when a resource is access denied.  This routines will call 
    all authentication providers so that they may add authentication 
    headers, etc. 

  Arguments:

    pMainContext - main context

  Returns:    
    
    HRESULT

--*/
{
    AUTH_PROVIDER *         pProvider;
    DWORD                   cProviderCount = 0;
    W3_METADATA *           pMetaData;
    HRESULT                 hr = NO_ERROR;
    
    if ( pMainContext == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    pMetaData = pMainContext->QueryUrlContext()->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );

    //
    // Loop thru all authentication providers
    //

    for ( cProviderCount = 0; ; cProviderCount++ )
    {
        pProvider = _rgAuthProviders[ cProviderCount ];
        if ( pProvider == NULL )
        {
            break;
        }
        
        //
        // Only call OnAccessDenied() if the authentication provider is 
        // supported for the given metadata of the denied request 
        //
        
        if ( !pMetaData->QueryAuthTypeSupported( 
                                  pProvider->QueryAuthType() ) )
        {
            continue;
        }
        
        //
        // Don't care about the return value here since we want to add 
        // all possible authentication headers
        //
        hr = pProvider->OnAccessDenied( pMainContext );
    }
    
    return hr;
}
    
HRESULT
W3_STATE_AUTHENTICATION::GetSubAuthConfiguration( 
    VOID 
    )
/*++
  Description:
    
    Find out if sub authenticator is configured correctly for the 
    current process.

  Arguments:

    None.

  Returns:    
    
    HRESULT

--*/
{
    HRESULT              hr                = S_OK;
    PPRIVILEGE_SET       pPrivilegeSet     = NULL;
    HANDLE               hProcessToken     = NULL;
    BOOL                 fPrivilegeEnabled = FALSE;
    HKEY                 hKey              = NULL;
    LUID                 TcbPrivilegeValue;
    WCHAR                pszSubAuthName[ sizeof( IIS_SUBAUTH_NAME ) ];      
    DWORD                dwType;
    DWORD                cbValue;

    if ( !OpenProcessToken( GetCurrentProcess(),                
                            TOKEN_ALL_ACCESS,                   
                            &hProcessToken ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Exit;
    }

    DBG_ASSERT( hProcessToken != NULL );
    
    pPrivilegeSet = ( PPRIVILEGE_SET )LocalAlloc( LMEM_FIXED,
            sizeof( PRIVILEGE_SET ) + sizeof( LUID_AND_ATTRIBUTES ) );
    if( pPrivilegeSet == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto Exit;
    }

    if ( !LookupPrivilegeValue( NULL,
                                L"SeTcbPrivilege",
                                &TcbPrivilegeValue ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Exit;
    }

    pPrivilegeSet->PrivilegeCount          = 1;
    pPrivilegeSet->Control                 = PRIVILEGE_SET_ALL_NECESSARY;
    pPrivilegeSet->Privilege[0].Luid       = TcbPrivilegeValue;
    pPrivilegeSet->Privilege[0].Attributes = SE_PRIVILEGE_ENABLED;

    if( !PrivilegeCheck( hProcessToken,
                         pPrivilegeSet,
                         &fPrivilegeEnabled ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Exit;
    }

    if( fPrivilegeEnabled )
    {
        sm_fLocalSystem = TRUE;       
    }

    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       L"System\\CurrentControlSet\\Control\\Lsa\\MSV1_0",
                       0,
                       KEY_READ,
                       &hKey ) == ERROR_SUCCESS )
    {
        DBG_ASSERT( hKey != NULL );

        cbValue = sizeof pszSubAuthName;
    
        if ( RegQueryValueEx( hKey,
                              L"Auth132",
                              NULL,
                              &dwType,
                              (LPBYTE) pszSubAuthName,
                              &cbValue ) != ERROR_SUCCESS ||
             dwType != REG_SZ                             ||
             _wcsicmp( pszSubAuthName, IIS_SUBAUTH_NAME ) )
        {
        }
        else
        {
            sm_fSubAuthConfigured = TRUE;
        }

        RegCloseKey( hKey );
        hKey = NULL;
    }

Exit:
    
    if( pPrivilegeSet != NULL )
    {
        LocalFree( pPrivilegeSet );
        pPrivilegeSet = NULL;
    }

    return hr;
}

W3_STATE_AUTHENTICATION::W3_STATE_AUTHENTICATION()
{
    _pAnonymousProvider = NULL;
    _pCustomProvider = NULL;
    _fHasAssociatedUserBefore = FALSE;
    
    //
    // Figure out the default domain name once
    //
    
    _hr = GetDefaultDomainName();
    if ( FAILED( _hr ) )
    {
        return;
    }
    
    //
    // Figure out if we can use the IIS subauthenticator 
    //

    _hr = GetSubAuthConfiguration();
    if( FAILED( _hr ) )
    {
        return;
    }
    
    //
    // Initialize all the authentication providers
    //
    
    ZeroMemory( _rgAuthProviders, sizeof( _rgAuthProviders ) );
    
    _hr = InitializeAuthenticationProviders();
    if ( FAILED( _hr ) )
    {
        return;
    }

    //
    // Initialize reverse DNS service
    //    
    
    if (!InitRDns())
    {
        _hr = HRESULT_FROM_WIN32(GetLastError());

        DBGPRINTF(( DBG_CONTEXT,
                    "Error initializing RDns service.  hr = 0x%x\n",
                    _hr ));
        
        TerminateAuthenticationProviders();
        return;
    }

    //
    // Initialize the W3_USER_CONTEXT reftrace log
    //
#if DBG
    W3_USER_CONTEXT::sm_pTraceLog = CreateRefTraceLog( 2000, 0 );
#else
    W3_USER_CONTEXT::sm_pTraceLog = NULL;
#endif
    
    //
    // Store a pointer to the singleton (no C++ goo used in creating
    // this singleton)
    //
   
    if ( sm_pAuthState != NULL )
    {
        DBG_ASSERT( sm_pAuthState != NULL );
        _hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    else
    {
        sm_pAuthState = this;
    }
}

W3_STATE_AUTHENTICATION::~W3_STATE_AUTHENTICATION()
{
    if ( W3_USER_CONTEXT::sm_pTraceLog != NULL )
    {
        DestroyRefTraceLog( W3_USER_CONTEXT::sm_pTraceLog );
        W3_USER_CONTEXT::sm_pTraceLog = NULL;
    }

    TerminateRDns();
    
    TerminateAuthenticationProviders();
    
    sm_pAuthState = NULL;
}

HRESULT
W3_STATE_AUTHENTICATION::InitializeAuthenticationProviders(
    VOID
)
/*++

Routine Description:

    Initialize all authentication providers

Arguments:

    None
    
Return Value:

    HRESULT

--*/
{
    HRESULT             hr = NO_ERROR;
    DWORD               cProviderCount = 0;

    //
    // Initialize trace for connection contexts
    //
    
    hr = CONNECTION_AUTH_CONTEXT::Initialize();
    if ( FAILED( hr ) )
    {
        goto Failure;
    }

    //
    // Certificate map provider.  This must be the first !!!!!!
    //
    
    DBG_ASSERT( cProviderCount < AUTH_PROVIDER_COUNT );
    _rgAuthProviders[ cProviderCount ] = new CERTMAP_AUTH_PROVIDER;
    if ( _rgAuthProviders[ cProviderCount ] == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failure;
    }
    hr = _rgAuthProviders[ cProviderCount ]->Initialize( cProviderCount );
    if ( FAILED( hr ) )
    {
        delete _rgAuthProviders[ cProviderCount ];
        _rgAuthProviders[ cProviderCount ] = NULL;
        goto Failure;
    }
    cProviderCount++;

    DBG_ASSERT( cProviderCount < AUTH_PROVIDER_COUNT );
    _rgAuthProviders[ cProviderCount ] = new IISCERTMAP_AUTH_PROVIDER;
    if ( _rgAuthProviders[ cProviderCount ] == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failure;
    }
    hr = _rgAuthProviders[ cProviderCount ]->Initialize( cProviderCount );
    if ( FAILED( hr ) )
    {
        delete _rgAuthProviders[ cProviderCount ];
        _rgAuthProviders[ cProviderCount ] = NULL;
        goto Failure;
    }
    cProviderCount++;

    //
    // SSPI provider
    //
    
    DBG_ASSERT( cProviderCount < AUTH_PROVIDER_COUNT );
    _rgAuthProviders[ cProviderCount ] = 
           new SSPI_AUTH_PROVIDER( MD_AUTH_NT );
    if ( _rgAuthProviders[ cProviderCount ] == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failure;
    }
    hr = _rgAuthProviders[ cProviderCount ]->Initialize( cProviderCount );
    if ( FAILED( hr ) )
    {
        delete _rgAuthProviders[ cProviderCount ];
        _rgAuthProviders[ cProviderCount ] = NULL;
        goto Failure;
    }
    cProviderCount++;

    //
    // Digest provider
    //

    DBG_ASSERT( cProviderCount < AUTH_PROVIDER_COUNT );
    _rgAuthProviders[ cProviderCount ] = 
           new DIGEST_AUTH_PROVIDER( MD_AUTH_MD5 );
    if ( _rgAuthProviders[ cProviderCount ] == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failure;
    }
    hr = _rgAuthProviders[ cProviderCount ]->Initialize( cProviderCount );
    if ( FAILED( hr ) )
    {
        delete _rgAuthProviders[ cProviderCount ];
        _rgAuthProviders[ cProviderCount ] = NULL;
        goto Failure;
    }
    cProviderCount++;

    //
    // IIS Digest provider (for backward compatibility)
    //

    DBG_ASSERT( cProviderCount < AUTH_PROVIDER_COUNT );
    _rgAuthProviders[ cProviderCount ] = 
           new IIS_DIGEST_AUTH_PROVIDER();
    if ( _rgAuthProviders[ cProviderCount ] == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failure;
    }
    hr = _rgAuthProviders[ cProviderCount ]->Initialize( cProviderCount );
    if ( FAILED( hr ) )
    {
        delete _rgAuthProviders[ cProviderCount ];
        _rgAuthProviders[ cProviderCount ] = NULL;
        goto Failure;
    }
    cProviderCount++;
    
    //
    // Basic provider
    //
    
    DBG_ASSERT( cProviderCount < AUTH_PROVIDER_COUNT );
    _rgAuthProviders[ cProviderCount ] = new BASIC_AUTH_PROVIDER;
    if ( _rgAuthProviders[ cProviderCount ] == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failure;
    }
    hr = _rgAuthProviders[ cProviderCount ]->Initialize( cProviderCount );
    if ( FAILED( hr ) )
    {
        delete _rgAuthProviders[ cProviderCount ];
        _rgAuthProviders[ cProviderCount ] = NULL;
        goto Failure;
    }
    cProviderCount++;
   
    //
    // Passport provider
    //

    DBG_ASSERT( cProviderCount < AUTH_PROVIDER_COUNT );
    _rgAuthProviders[ cProviderCount ] = new PASSPORT_AUTH_PROVIDER;
    if ( _rgAuthProviders[ cProviderCount ] == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failure;
    }
    hr = _rgAuthProviders[ cProviderCount ]->Initialize( cProviderCount );
    if ( FAILED( hr ) )
    {
        delete _rgAuthProviders[ cProviderCount ];
        _rgAuthProviders[ cProviderCount ] = NULL;
        goto Failure;
    }
    cProviderCount++;
    
    //
    // Anonymous provider.
    //
    // Note: This one should always be the last one
    //
    
    DBG_ASSERT( cProviderCount < AUTH_PROVIDER_COUNT );
    _rgAuthProviders[ cProviderCount ] = new ANONYMOUS_AUTH_PROVIDER;
    if ( _rgAuthProviders[ cProviderCount ] == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failure;
    }
    hr = _rgAuthProviders[ cProviderCount ]->Initialize( cProviderCount );
    if ( FAILED( hr ) )
    {
        delete _rgAuthProviders[ cProviderCount ];
        _rgAuthProviders[ cProviderCount ] = NULL;
        goto Failure;
    }
    _pAnonymousProvider = _rgAuthProviders[ cProviderCount ];
    
    cProviderCount++;

    //
    // Custom provider.  Not really a provider in the sense that it does not
    // participate in authenticating a request.  Instead, it is just used
    // as a stub provider for custom authentication done with
    // HSE_REQ_EXEC_URL
    //
    
    _pCustomProvider = new CUSTOM_AUTH_PROVIDER;
    if ( _pCustomProvider == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failure;    
    }

    return NO_ERROR;
    
Failure:
    
    for ( DWORD i = 0; i < AUTH_PROVIDER_COUNT; i++ )
    {
        if ( _rgAuthProviders[ i ] != NULL )
        {
            _rgAuthProviders[ i ]->Terminate();
            delete _rgAuthProviders[ i ];
            _rgAuthProviders[ i ] = NULL;
        }
    }
    
    CONNECTION_AUTH_CONTEXT::Terminate();
    
    return hr;
}

VOID
W3_STATE_AUTHENTICATION::TerminateAuthenticationProviders(
    VOID
)
/*++

Routine Description:

    Terminate all authentication providers

Arguments:

    None
    
Return Value:

    None

--*/
{
    for ( DWORD i = 0; i < AUTH_PROVIDER_COUNT; i++ )
    {
        if ( _rgAuthProviders[ i ] != NULL )
        {
            _rgAuthProviders[ i ]->Terminate();
            delete _rgAuthProviders[ i ];
            _rgAuthProviders[ i ] = NULL;
        }
    }
    
    if ( _pCustomProvider != NULL )
    {
        delete _pCustomProvider;
        _pCustomProvider = NULL;
    }
    
    CONNECTION_AUTH_CONTEXT::Terminate();
}

CONTEXT_STATUS
W3_STATE_AUTHENTICATION::DoWork(
    W3_MAIN_CONTEXT *            pMainContext,
    DWORD                        cbCompletion,
    DWORD                        dwCompletionStatus
    )
/*++

Routine Description:

    Handle authentication for this request

Arguments:

    pMainContext - W3_MAIN_CONTEXT representing execution of state 
                   machine
    cbCompletion - Number of bytes in an async completion
    dwCompletionStatus - Error status of a completion
    
Return Value:

    CONTEXT_STATUS_CONTINUE - if we should continue in state machine
    else stop executing the machine and free up the current thread

--*/
{
    DWORD                   cProviderCount = 0;
    AUTH_PROVIDER *         pProvider = NULL;
    W3_METADATA *           pMetaData = NULL;
    W3_USER_CONTEXT *       pUserContext = NULL;
    BOOL                    fSupported = FALSE;
    HRESULT                 hr = NO_ERROR;
    BOOL                    fApplies = FALSE;
    BOOL                    fFilterFinished = FALSE;
    W3_MAIN_CONTEXT_STATE * pContextState = NULL;
    
    UNREFERENCED_PARAMETER( cbCompletion );
    UNREFERENCED_PARAMETER( dwCompletionStatus );
    
    DBG_ASSERT( pMainContext != NULL );

    //
    // If we already have a user context, then we must have had an
    // AUTH_COMPLETE notification which caused the state machine to back up
    // and resume from URLINFO state.  In that case, just bail
    //
    
    if ( pMainContext->QueryUserContext() != NULL )
    {
        DBG_ASSERT( pMainContext->IsNotificationNeeded( SF_NOTIFY_AUTH_COMPLETE ) );

        return CONTEXT_STATUS_CONTINUE;
    }
   
    //
    // First, find the authentication provider which applies. We 
    // should always find a matching provider (since anonymous 
    // provider) should always match!
    //

    pMetaData = pMainContext->QueryUrlContext()->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );


    //
    // Optimization for path when only anonymous authentication is enabled
    // (certmapping is checked as well)
    // Issue jaroslad 01/08/23. This may conflict in the future with
    // DoesApply of new providers.
    //

    if ( pMetaData->IsOnlyAnonymousAuthSupported() &&
         pMainContext->QueryRequest()->GetHeader( HttpHeaderAuthorization ) == NULL )
    {
        //
        // no authorization header and only anonymous enabled
        //
         pProvider = QueryAnonymousProvider();
         DBG_ASSERT( pProvider != NULL );
    }
    else
    {
        for ( ; ; )
        {
            pProvider = _rgAuthProviders[ cProviderCount ];
            if ( pProvider == NULL )
            {
                break;
            }
            
            DBG_ASSERT( pProvider != NULL );

            hr = pProvider->DoesApply( pMainContext,
                                       &fApplies );
            if ( FAILED( hr ) )
            {
                goto Finished;
            }
                    
            if ( fApplies )
            {
                //
                // Cool.  We have a match!  
                //
                
                break;
            }
            
            cProviderCount++;

        }
    }
    
    //
    // If only the anonymous provider matched, then check whether we 
    // have credentials associated with the connection (since IE won't 
    // send Authorization: header for subsequent SSPI authenticated 
    // requests on a connection)
    //
    
    if ( pProvider->QueryAuthType() == MD_AUTH_ANONYMOUS )
    {   
        //
        // Another slimy optimization.  If we haven't associated a user
        // with the connection, then we don't have to bother looking up
        // connection
        //

        if ( _fHasAssociatedUserBefore )
        {
            pUserContext = pMainContext->QueryConnectionUserContext();
            if ( pUserContext != NULL )
            {
                pProvider = pUserContext->QueryProvider();
                DBG_ASSERT( pProvider != NULL );
            }

            //
            // Clean up the security context if there is one 
            //
        
            pProvider->SetConnectionAuthContext( pMainContext, NULL );  
        }
    }
    else
    {
        //
        // If a provider applies, then ignore/remove any
        // cached user associated with the request
        //

        pUserContext = pMainContext->QueryConnectionUserContext();
        if ( pUserContext != NULL )
        {
            pMainContext->SetConnectionUserContext( NULL );
            pUserContext->DereferenceUserContext();
            pUserContext = NULL;
        }
    }

    //
    // Is the given provider supported (by metadata)
    // 

    if ( pMetaData->QueryAuthTypeSupported( pProvider->QueryAuthType() ) )
    {
        fSupported = TRUE;
    }
    else if( pProvider->QueryAuthType() == MD_AUTH_ANONYMOUS )
    {
        //
        // Give the anonymous provider a shot at this request.
        //
        // We need to do this even if MD_AUTH_ANONYMOUS is not
        // supported, so that authentication filters get a
        // crack at it.  It's up to the anonymous provider to
        // fail if it's not supported, and no filter sets
        // credentials.
        //

        pMainContext->SetCheckAnonAuthTypeSupported( TRUE );
        
        fSupported = TRUE;
    }
    else
    {
        //
        // If anonymous authentication is supported, then we can
        // still let it thru
        //
     
        if ( pMetaData->QueryAuthTypeSupported( MD_AUTH_ANONYMOUS ) )
        {
            pProvider = QueryAnonymousProvider();
            DBG_ASSERT( pProvider != NULL );

            //
            // Anonymous provider applies, remove the previous cached
            // user associated with the request
            //

            if ( pUserContext != NULL )
            {
                pMainContext->SetConnectionUserContext( NULL );
                pUserContext->DereferenceUserContext();
                pUserContext = NULL;
            }        

            fSupported = TRUE;
        }
    }

    //
    // Not supported, you're outta here!
    //

    if ( !fSupported )
    {
        //
        // Clear any context state which was set
        //
        
        pContextState = pMainContext->QueryContextState();
        if ( pContextState != NULL )
        {
            pContextState->Cleanup( pMainContext );
            pMainContext->SetContextState( NULL );
        }
        
        pMainContext->QueryResponse()->SetStatus( HttpStatusUnauthorized,
                                                  Http401Config );
        pMainContext->SetErrorStatus( HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) );
        pMainContext->SetFinishedResponse();

        return CONTEXT_STATUS_CONTINUE;
    }

    //
    // Now we can authenticate
    //

    if ( pUserContext != NULL )
    {   
        //
        // We already have a context associated with connection.  Use it!
        //

        pUserContext->ReferenceUserContext();
        pMainContext->SetUserContext( pUserContext );
    }
    else
    {
        DBG_ASSERT( pProvider != NULL );

        // perf ctr
        pMainContext->QuerySite()->IncLogonAttempts();

        fFilterFinished = FALSE;

        hr = pProvider->DoAuthenticate( pMainContext, &fFilterFinished );
        if ( FAILED( hr ) )
        {
            DWORD   dwError = WIN32_FROM_HRESULT( hr );

            if( dwError == ERROR_PASSWORD_MUST_CHANGE ||
                dwError == ERROR_PASSWORD_EXPIRED )
            {
                hr = pMainContext->PasswdChangeExecute();
                if( S_OK == hr )
                {
                    return CONTEXT_STATUS_PENDING;
                }
                else if( S_FALSE == hr )
                {
                    //
                    // S_FALSE means password change disabled
                    //
                    pMainContext->QueryResponse()->SetStatus( 
                                           HttpStatusUnauthorized,
                                           Http401BadLogon );
                    pMainContext->SetErrorStatus( hr );
                    pMainContext->SetFinishedResponse();

                    return CONTEXT_STATUS_CONTINUE;        
                }
            }
            else if( SEC_E_NO_CREDENTIALS == hr )
            {
                pMainContext->QueryResponse()->SetStatus( HttpStatusUnauthorized,
                                                          Http401Config );
                pMainContext->SetErrorStatus( hr );
                pMainContext->SetFinishedResponse();

                return CONTEXT_STATUS_CONTINUE;
            }
            else
            {
                pMainContext->SetErrorStatus( hr );

                if ( dwError == ERROR_ACCESS_DENIED )
                {
                    pMainContext->QueryResponse()->SetStatus( HttpStatusUnauthorized,
                                                              Http401Filter );
                }
                else if ( dwError == ERROR_FILE_NOT_FOUND ||
                          dwError == ERROR_PATH_NOT_FOUND )
                {
                    pMainContext->QueryResponse()->SetStatus( HttpStatusNotFound );
                }
                else
                {
                    pMainContext->QueryResponse()->SetStatus( HttpStatusServerError );
                }

                pMainContext->SetFinishedResponse();
                pMainContext->SetDisconnect( TRUE );
                return CONTEXT_STATUS_CONTINUE;
            }

            goto Finished;
        }
        
        if ( fFilterFinished )
        {
            pMainContext->SetDone();

            goto Finished;
        }
    }

    //
    // Do we have a valid user now
    //

    pUserContext = pMainContext->QueryUserContext();

    if ( pUserContext != NULL )
    {
        if ( pUserContext->QueryAuthType() != MD_AUTH_ANONYMOUS )
        {
            hr = pMainContext->PasswdExpireNotify(); 
            if( FAILED( hr ) )
            {
                //
                // Internal error
                //
                goto Finished;
            }
            else if( hr == S_OK )
            {
                //
                // We've successfully handled password expire 
                // notification 
                //

                return CONTEXT_STATUS_PENDING;
            }

            //
            // Advanced password expire notification is disabled, 
            // we should allow the user to get access, fall through
            //
        }
        
        //
        // Should we cache the user on the connection?  Do so, only if 
        //
        
        DBG_ASSERT( pMetaData != NULL );
        
        if ( pMetaData->QueryAuthPersistence() != MD_AUTH_SINGLEREQUEST
             && pUserContext->QueryIsAuthNTLM() 
             && !pMainContext->QueryRequest()->IsProxyRequest() 
             && pUserContext != pMainContext->QueryConnectionUserContext() )
        {
            pUserContext->ReferenceUserContext();
            pMainContext->SetConnectionUserContext( pUserContext );
            _fHasAssociatedUserBefore = TRUE;
        }
    }
    else
    {
        //
        // If we don't have a user, then we must not allow handle request 
        // state to happen!
        //
        
        pMainContext->SetFinishedResponse();
    }
    
    //
    // OK.  If we got to here and we have a user context, then authentication
    // is complete!  So lets notify AUTH_COMPLETE filters
    //
    
    if ( pUserContext != NULL )
    {
        if ( pMainContext->IsNotificationNeeded( SF_NOTIFY_AUTH_COMPLETE ) )
        {
            HTTP_FILTER_AUTH_COMPLETE_INFO      AuthInfo;
            STACK_STRU(                         strOriginal, MAX_PATH );    
            STACK_STRU(                         strNewUrl, MAX_PATH );
            BOOL                                fFinished = FALSE;
        
            //
            // Store away the original URL
            //
            
            hr = pMainContext->QueryRequest()->GetUrl( &strOriginal );
            if ( FAILED( hr ) )
            {
                goto Finished;
            }

            //
            // Call the filter
            //
            
            if ( !pMainContext->NotifyFilters( SF_NOTIFY_AUTH_COMPLETE,
                                               &AuthInfo,
                                               &fFinished ) )
            {
                DWORD   dwError = GetLastError();

                pMainContext->SetErrorStatus( HRESULT_FROM_WIN32( dwError ) );

                if ( dwError == ERROR_ACCESS_DENIED )
                {
                    pMainContext->QueryResponse()->SetStatus( HttpStatusUnauthorized,
                                                              Http401Filter );
                }
                else if ( dwError == ERROR_FILE_NOT_FOUND ||
                          dwError == ERROR_PATH_NOT_FOUND )
                {
                    pMainContext->QueryResponse()->SetStatus( HttpStatusNotFound );
                }
                else
                {
                    pMainContext->QueryResponse()->SetStatus( HttpStatusServerError );
                }

                pMainContext->SetFinishedResponse();
                pMainContext->SetDisconnect( TRUE );
                return CONTEXT_STATUS_CONTINUE;
            }
         
            if ( fFinished )
            {
                pMainContext->SetDone();
                return CONTEXT_STATUS_CONTINUE;
            }
                        
            //
            // If the URL has changed, we'll need to backup the state machine
            //
            
            hr = pMainContext->QueryRequest()->GetUrl( &strNewUrl );
            if ( FAILED( hr ) )
            {
                goto Finished;
            }
            
            if ( wcscmp( strNewUrl.QueryStr(), 
                         strOriginal.QueryStr() ) != 0 )
            {
                //
                // URL is different!
                //
                
                pMainContext->BackupStateMachine();
            }
            else
            {
                //
                // URL is the same.  Do nothing and continue
                //
            }
        }
    }

Finished:
    if ( FAILED( hr ) )
    {
        pMainContext->QueryResponse()->
                           SetStatus( HttpStatusServerError );
        pMainContext->SetFinishedResponse();
        pMainContext->SetErrorStatus( hr );
    }
    
    return CONTEXT_STATUS_CONTINUE;
}

CONTEXT_STATUS
W3_STATE_AUTHENTICATION::OnCompletion(
    W3_MAIN_CONTEXT *       pMainContext,
    DWORD                   cbCompletion,
    DWORD                   dwCompletionStatus
)
/*++

Routine Description:

    Complete the done state

Arguments:

    pMainContext - W3_MAIN_CONTEXT representing an execution of the state machine
    cbCompletion - Number of bytes on completion
    dwCompletionStatus - Win32 Error on completion (if any)
    
Return Value:

    CONTEXT_STATUS_CONTINUE - if we should continue in state machine
    else stop executing the machine and free up the current thread

--*/
{
    UNREFERENCED_PARAMETER( cbCompletion );
    UNREFERENCED_PARAMETER( dwCompletionStatus );
    
    DBG_ASSERT( pMainContext != NULL );
    
    //
    // During authentication state, only the routines for password notification
    // could post asynchonous completion while they are doing child execution.
    // The following assert is to make sure that the completion is posted by
    // ExecuteExpiredURL routine.
    //
    DBG_ASSERT( pMainContext->QueryRequest()->GetHeader( "CFG-ENC-CAPS" )
                != NULL );
    
    //
    // Since the response has already been send asynchronously, we advance the
    // state machine to CONTEXT_STATE_RESPONSE here.
    //
    pMainContext->SetFinishedResponse();

    return CONTEXT_STATUS_CONTINUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\basicprovider.cxx ===
/*++
   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     basicprovider.cxx

   Abstract:
     Basic authentication provider
 
   Author:
     Bilal Alam (balam)             10-Jan-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include "basicprovider.hxx"
#include "uuencode.hxx"

HRESULT
BASIC_AUTH_PROVIDER::DoesApply(
    W3_MAIN_CONTEXT *       pMainContext,
    BOOL *                  pfApplies
)
/*++

Routine Description:

    Does basic authentication apply to this request?

Arguments:

    pMainContext - Main context representing request
    pfApplies - Set to true if SSPI is applicable
    
Return Value:

    HRESULT

--*/
{
    LPCSTR              pszAuthHeader;
    
    if ( pMainContext == NULL ||
         pfApplies == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    } 
    
    *pfApplies = FALSE;
    
    //
    // Get auth type
    //
    
    pszAuthHeader = pMainContext->QueryRequest()->GetHeader( HttpHeaderAuthorization );
    
    //
    // No package, no auth
    //
    
    if ( pszAuthHeader == NULL )
    {
        return NO_ERROR;
    }
    
    //
    // Is it basic?
    //
    
    if ( _strnicmp( pszAuthHeader, "Basic", sizeof("Basic") - 1 ) == 0 )
    {
        *pfApplies = TRUE;
    }
    
    return NO_ERROR;
}
    
HRESULT
BASIC_AUTH_PROVIDER::DoAuthenticate(
    W3_MAIN_CONTEXT *           pMainContext,
    BOOL *                      pfFilterFinished
)
/*++

Routine Description:

    Do the authentication thing!

Arguments:

    pMainContext - main context
    pfFilterFinished - Set to TRUE if filter wants out
    
Return Value:

    HRESULT

--*/
{
    CHAR *                  pszAuthHeader = NULL;
    HRESULT                 hr;
    BOOL                    fRet;
    STACK_BUFFER          ( buffDecoded, 256 );
    CHAR *                  pszDecoded;
    CHAR *                  pszColon;
    // add 1 to strUserDomain for separator "\"
    STACK_STRA(             strUserDomain, UNLEN + IIS_DNLEN + 1 + 1 );
    STACK_STRA(             strUserName, UNLEN + 1 );
    STACK_STRA(             strPassword, PWLEN  + 1 );
    STACK_STRA(             strDomainName, IIS_DNLEN + 1 );
    // add 1 to strUserDomainW for separator "\"
    STACK_STRU(             strUserDomainW, UNLEN + IIS_DNLEN + 1 + 1 );
    STACK_STRU(             strUserNameW, UNLEN + 1 );
    STACK_STRU(             strPasswordW, PWLEN + 1 );
    STACK_STRU(             strRemotePasswordW, PWLEN + 1 );
    STACK_STRU(             strDomainNameW, IIS_DNLEN + 1 );
    // add 1 to strRemoteUserNameW for separator "\"
    STACK_STRU(             strRemoteUserNameW, UNLEN + IIS_DNLEN + 1 );
    W3_METADATA *           pMetaData = NULL;
    TOKEN_CACHE_ENTRY *     pCachedToken = NULL;
    BASIC_USER_CONTEXT *    pUserContext = NULL;
    DWORD                   dwLogonError = ERROR_SUCCESS;
    BOOL                    fPossibleUPNLogon = FALSE;

    if ( pMainContext == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // Get the part after the auth type
    //
    
    pszAuthHeader = (PSTR) pMainContext->QueryRequest()->GetHeader( HttpHeaderAuthorization );
    DBG_ASSERT( pszAuthHeader != NULL );

    //
    // We better have an Authorization: Basic header if we got to here!
    //
    
    DBG_ASSERT( _strnicmp( pszAuthHeader, "Basic", 5 ) == 0 );

    //
    // Advance to good stuff
    //

    if ( pszAuthHeader[ 5 ] == '\0' )
    {
        pMainContext->QueryResponse()->SetStatus( HttpStatusUnauthorized,
                                                  Http401BadLogon );

        hr = NO_ERROR;
        goto exit;
    }
    pszAuthHeader = pszAuthHeader + 6;

    //
    // UUDecode the buffer
    //

    if ( !uudecode( pszAuthHeader,
                    &buffDecoded ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto exit;
    }

    pszDecoded = (CHAR*) buffDecoded.QueryPtr();

    //
    // Now split out user:password
    //
    
    pszColon = strchr( pszDecoded, ':' );
    if ( pszColon == NULL )
    {
        //
        // Bad credentials
        //   
        
        pMainContext->QueryResponse()->SetStatus( HttpStatusUnauthorized,
                                                  Http401BadLogon );

        hr = NO_ERROR;
        goto exit;
    }   
    
    //
    // Get user/password
    // 

    hr = strUserDomain.Copy( pszDecoded,
                             DIFF( pszColon - pszDecoded ) );
    if ( FAILED( hr ) )
    {
        goto exit;
    }
        
    hr = strPassword.Copy( pszColon + 1 );
    if ( FAILED( hr ) )
    {
        goto exit;
    }
    
    //
    // Copy the user name into the request
    //
    
    hr = pMainContext->QueryRequest()->SetRequestUserName( strUserDomain );
    if ( FAILED( hr ) )
    {
        goto exit;
    }
    
    //
    // Copy the password into the request (filters suck)
    //
    
    hr = pMainContext->QueryRequest()->SetRequestPassword( strPassword );
    if ( FAILED( hr ) )
    {
        goto exit;
    }
    
    //
    // Remember the unmapped user name and password
    //
    
    hr = strRemoteUserNameW.CopyA( strUserDomain.QueryStr() );
    if ( FAILED( hr ) )
    {
        goto exit;
    }
    
    hr = strRemotePasswordW.CopyA( strPassword.QueryStr() );
    if ( FAILED( hr ) )
    {
        goto exit;
    }
    
    //
    // Notify authentication filters
    //
    
    if ( pMainContext->IsNotificationNeeded( SF_NOTIFY_AUTHENTICATION ) )
    {
        HTTP_FILTER_AUTHENT     filterAuthent;
        
        hr = strUserDomain.Resize( SF_MAX_USERNAME );
        if ( FAILED( hr ) )
        {
            goto exit;
        }        
        
        hr = strPassword.Resize( SF_MAX_PASSWORD );
        if ( FAILED( hr ) )
        {
            goto exit;
        }
        
        filterAuthent.pszUser = strUserDomain.QueryStr();
        filterAuthent.cbUserBuff = SF_MAX_USERNAME;
        
        filterAuthent.pszPassword = strPassword.QueryStr();
        filterAuthent.cbPasswordBuff = SF_MAX_PASSWORD;
        
        fRet = pMainContext->NotifyFilters( SF_NOTIFY_AUTHENTICATION,
                                            &filterAuthent,
                                            pfFilterFinished );

        if ( !fRet )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto exit;
        }
        
        if ( *pfFilterFinished )
        {
            pMainContext->SetDone();
            goto exit;
        }
        
        strUserDomain.SetLen( strlen( strUserDomain.QueryStr() ) );
        strPassword.SetLen( strlen( strPassword.QueryStr() ) );
    }
    
    pMetaData = pMainContext->QueryUrlContext()->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );

    if( pMetaData->QueryAuthTypeSupported( MD_AUTH_ANONYMOUS ) &&
        strUserDomain.IsEmpty()                                && 
        strPassword.IsEmpty() )
    {
        //
        // If user domain and password strings are empty, then we will 
        // fall back to anonymous authentication
        //

        AUTH_PROVIDER * pAnonymousProvider = 
                W3_STATE_AUTHENTICATION::QueryAnonymousProvider();

        DBG_ASSERT( pAnonymousProvider != NULL );
    
        hr = pAnonymousProvider->DoAuthenticate( pMainContext,
                                                 pfFilterFinished );

        goto exit;
    }

    //
    // Convert to unicode 
    //
    
    hr = strUserDomainW.CopyA( strUserDomain.QueryStr() );
    if ( FAILED( hr ) ) 
    {
        goto exit;
    }
    
    hr = strPasswordW.CopyA( strPassword.QueryStr() );
    if ( FAILED( hr ) )
    {
        goto exit;
    }
    
    //
    // Get username/domain out of domain\username
    //
    
    hr = W3_STATE_AUTHENTICATION::SplitUserDomain( strUserDomainW,
                                                   &strUserNameW,
                                                   &strDomainNameW,
                                                   pMetaData->QueryDomainName(),
                                                   &fPossibleUPNLogon );
    if ( FAILED( hr ) )
    {
        goto exit;
    }
    
    //
    // Try to get the token
    // 
    
    DBG_ASSERT( g_pW3Server->QueryTokenCache() != NULL );
    
    hr = g_pW3Server->QueryTokenCache()->GetCachedToken(
                                          strUserNameW.QueryStr(),
                                          strDomainNameW.QueryStr(),
                                          strPasswordW.QueryStr(),
                                          pMetaData->QueryLogonMethod(),
                                          FALSE,
                                          fPossibleUPNLogon,
                                          pMainContext->QueryRequest()->
                                               QueryRemoteSockAddress(),
                                          &pCachedToken,
                                          &dwLogonError );
    if ( FAILED( hr ) )
    {
        goto exit;
    }
    
    //
    // If pCachedToken is NULL, then logon failed
    //

    if ( pCachedToken == NULL )
    {
        DBG_ASSERT( dwLogonError != ERROR_SUCCESS );
        
        if( dwLogonError == ERROR_PASSWORD_MUST_CHANGE ||
            dwLogonError == ERROR_PASSWORD_EXPIRED )
        {
            hr = HRESULT_FROM_WIN32( dwLogonError );
            goto exit;
        }

        pMainContext->QueryResponse()->SetStatus( 
                               HttpStatusUnauthorized,
                               Http401BadLogon );
        pMainContext->SetErrorStatus( HRESULT_FROM_WIN32( dwLogonError ) );

        hr = NO_ERROR;
        goto exit;
    }

    //
    // We have a token! Setup a W3_USER_CONTEXT and we're done
    //
    
    pUserContext = new BASIC_USER_CONTEXT( this );
    if ( FAILED( hr ) )
    {
        goto exit;
    }
    
    hr = pUserContext->Create( pCachedToken,
                               strUserNameW,
                               strDomainNameW,
                               strRemotePasswordW,
                               strRemoteUserNameW,
                               strUserDomainW,
                               pMetaData->QueryLogonMethod() );
    if ( FAILED( hr ) )
    {
        pUserContext->DereferenceUserContext();
        pUserContext = NULL;
        goto exit;
    }
                                                        
    pMainContext->SetUserContext( pUserContext );
    
exit:

    //
    // Zero out all copies of password in this routine
    //
    ZeroMemory( buffDecoded.QueryPtr(), buffDecoded.QuerySize() );

    if( strPassword.QueryCB() )
    {
        SecureZeroMemory( ( VOID * )strPassword.QueryStr(), 
                          strPassword.QueryCB() );
    }

    if( strPasswordW.QueryCB() )
    {
        SecureZeroMemory( ( VOID * )strPasswordW.QueryStr(), 
                    strPassword.QueryCB() );
    }

    if( strRemotePasswordW.QueryCB() )
    {
        SecureZeroMemory( ( VOID * )strRemotePasswordW.QueryStr(), 
                    strPassword.QueryCB() );
    }

    return hr;
}

HRESULT
BASIC_AUTH_PROVIDER::OnAccessDenied(
    W3_MAIN_CONTEXT *           pMainContext
)
/*++

Routine Description:

    Add basic authentication header

Arguments:

    pMainContext - Main context
    
Return Value:

    HRESULT

--*/
{
    STACK_STRU(         strAuthHeader, 256 );
    STACK_STRA(         straAuthHeader, 256 );
    STACK_STRU(         strHostAddr, 256 );
    HRESULT             hr;
    W3_METADATA *       pMetaData;
    
    if ( pMainContext == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    hr = strAuthHeader.Copy( L"Basic realm=\"" );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    pMetaData = pMainContext->QueryUrlContext()->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );
    
    //
    // If a realm is configured, use it.  Otherwise use host address of 
    // request 
    //
    
    if ( pMetaData->QueryRealm() != NULL )
    {
        hr = strAuthHeader.Append( pMetaData->QueryRealm() );
    }
    else
    {
        hr = pMainContext->QueryRequest()->GetHostAddr( &strHostAddr );
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        hr = strAuthHeader.Append( strHostAddr );
    }
    
    if ( FAILED( hr ) )
    {
        return hr;
    }

    hr = strAuthHeader.Append( L"\"" );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    if (FAILED(hr = straAuthHeader.CopyW(strAuthHeader.QueryStr())))
    {
        return hr;
    }
    
    return pMainContext->QueryResponse()->SetHeader( "WWW-Authenticate",
                                                     16,
                                                     straAuthHeader.QueryStr(),
                                                     (USHORT)straAuthHeader.QueryCCH() );
}

HRESULT
BASIC_USER_CONTEXT::Create(
    TOKEN_CACHE_ENTRY *         pCachedToken,
    STRU &                      strUserName,
    STRU &                      strDomainName,
    STRU &                      strPassword,
    STRU &                      strRemoteUserName,
    STRU &                      strMappedDomainUser,
    DWORD                       dwLogonMethod
)
/*++

Routine Description:

    Initialize a basic user context

Arguments:

    pCachedToken - The token
    strUserName - User name (without embedded domain)
    strDomainName - Domain name
    strPassword - Password
    strRemoteUserName - Unmapped user name
    strMappedDomainUser - Mapped domain user (may have embedded domain)
    dwLogonMethod - Logon method
    
Return Value:

    HRESULT

--*/
{
    HRESULT                 hr;
    
    UNREFERENCED_PARAMETER( strUserName );
    UNREFERENCED_PARAMETER( strDomainName );
    UNREFERENCED_PARAMETER( dwLogonMethod );
    
    if ( pCachedToken == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    hr = _strUserName.Copy( strMappedDomainUser );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    hr = _strPassword.Append( strPassword );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    hr = _strRemoteUserName.Append( strRemoteUserName );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    _pCachedToken = pCachedToken;
    
    SetCachedToken( TRUE );

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\cachevalidation.cxx ===
/*++

   Copyright    (c)    2000    Microsoft Corporation

   Module Name :
     cachevalidation.cxx

   Abstract:
     Handle Cache Validation (If-* headers)

   Author:
     Anil Ruia (AnilR)            3-Apr-2000

   Environment:
     Win32 - User Mode

   Project:
     UlW3.dll
--*/

#include "precomp.hxx"
#include "staticfile.hxx"

dllexp BOOL FindInETagList(LPCSTR pLocalETag,
                           LPCSTR pETagList,
                           BOOL   fWeakCompare)
/*++

Routine Description:
    Search input list of ETags for one that matches our local ETag.

Arguments:
    pLocalETag   - The local ETag we're using.
    pETagList    - The ETag list we've received from the client.
    bWeakCompare - Whether using Weak Comparison is ok

Returns:

    TRUE if we found a matching ETag, FALSE otherwise.

--*/
{
    UINT   QuoteCount;
    LPCSTR pFileETag;
    BOOL   Matched;

    // We'll loop through the ETag string, looking for ETag to
    // compare, as long as we have an ETag to look at.

    do
    {
        while (SAFEIsSpace(*pETagList))
        {
            pETagList++;
        }

        if (!*pETagList)
        {
            // Ran out of ETag.
            return FALSE;
        }

        // If this ETag is *, it's a match.
        if (*pETagList == '*')
        {
            return TRUE;
        }

        // See if this ETag is weak.
        if (pETagList[0] == 'W' && pETagList[1] == '/')
        {
            // This is a weak validator. If we're not doing the weak
            // comparison, fail.

            if (!fWeakCompare)
            {
                return FALSE;
            }

            // Skip over the 'W/', and any intervening whitespace.
            pETagList += 2;

            while (SAFEIsSpace(*pETagList))
            {
                pETagList++;
            }

            if (!*pETagList)
            {
                // Ran out of ETag.
                return FALSE;
            }
        }

        if (*pETagList != '"')
        {
            // This isn't a quoted string, so fail.
            return FALSE;
        }

        // OK, right now we should be at the start of a quoted string that
        // we can compare against our current ETag.

        QuoteCount = 0;

        Matched = TRUE;
        pFileETag = pLocalETag;

        // Do the actual compare. We do this by scanning the current ETag,
        // which is a quoted string. We look for two quotation marks, the
        // the delimiters if the quoted string. If after we find two quotes
        // in the ETag everything has matched, then we've matched this ETag.
        // Otherwise we'll try the next one.

        do
        {
            CHAR Temp;

            Temp = *pETagList;

            if (Temp == '"')
            {
                QuoteCount++;
            }

            if (*pFileETag != Temp)
            {
                Matched = FALSE;
            }

            if (!Temp)
            {
                return FALSE;
            }

            pETagList++;

            if (*pFileETag == '\0')
            {
                break;
            }

            pFileETag++;


        }
        while (QuoteCount != 2);

        if (Matched)
        {
            return TRUE;
        }

        // Otherwise, at this point we need to look at the next ETag.

        while (QuoteCount != 2)
        {
            if (*pETagList == '"')
            {
                QuoteCount++;
            }
            else
            {
                if (*pETagList == '\0')
                {
                    return FALSE;
                }
            }

            pETagList++;
        }

        while (SAFEIsSpace(*pETagList))
        {
            pETagList++;
        }

        if (*pETagList == ',')
        {
            pETagList++;
        }
        else
        {
            return FALSE;
        }

    }
    while ( *pETagList );

    return FALSE;
}


HRESULT W3_STATIC_FILE_HANDLER::CacheValidationDoWork(
    W3_CONTEXT   *pW3Context,
    W3_FILE_INFO *pOpenFile,
    BOOL         *pfHandled)
/*++
  Synopsis
    Handle the Cache Related If-* headers

  Input
    pW3Context : W3_CONTEXT for the request
    pOpenFile  : The file's cache entry
    pfHandled  : On return indicates whether, we have handled the request
                 or further processing needs to be done

  Returns
    HRESULT
--*/
{
    W3_RESPONSE *pResponse = pW3Context->QueryResponse();
    W3_REQUEST  *pRequest  = pW3Context->QueryRequest();

    //
    // There are currently 4 possible Cache Related If-* modifiers:
    // If-Match, If-Unmodified-Since, If-Non-Match, If-Modified-Since.
    // We handle them in that order if all are present, and as soon as
    // one condition fails we stop processing
    //

    //
    // Now handle the If-Match header, if we have one.
    //
    LPCSTR pszIfMatch = pRequest->GetHeader(HttpHeaderIfMatch);
    if (pszIfMatch != NULL)
    {
        if (pOpenFile->QueryIsWeakETag() ||
            !FindInETagList(pOpenFile->QueryETag(), pszIfMatch, FALSE))
        {
            pResponse->ClearHeaders();
            pResponse->SetStatus(HttpStatusPreconditionFailed);
            *pfHandled = TRUE;
            return S_OK;
        }
    }

    //
    // Now see if we have an If-None-Match, and if so handle that.
    //
    LPCSTR pszIfNoneMatch = pRequest->GetHeader(HttpHeaderIfNoneMatch);
    BOOL fIsNoneMatchPassed = TRUE;
    BOOL fSkipIfModifiedSince = FALSE;
    if (pszIfNoneMatch != NULL)
    {
        if (FindInETagList(pOpenFile->QueryETag(),
                           pszIfNoneMatch,
                           TRUE))
        {
            fIsNoneMatchPassed = FALSE;
        }
        else
        {
            // If none of the tags match, we should skip If-Modified-Since
            fSkipIfModifiedSince = TRUE;
        }
    }

    //
    // Made it through that, handle If-Modified-Since if we have that.
    //
    LPCSTR pszIfModifiedSince = pRequest->GetHeader(HttpHeaderIfModifiedSince);
    if (!fSkipIfModifiedSince && pszIfModifiedSince != NULL)
    {
        LARGE_INTEGER liModifiedSince;
        if (StringTimeToFileTime(pszIfModifiedSince,
                                 &liModifiedSince))
        {
            FILETIME tm;
            pOpenFile->QueryLastWriteTime(&tm);

            // Check if our last write time is greater than their
            // ModifiedSince time
            if (*(LONGLONG*)&tm <= liModifiedSince.QuadPart)
            {
                // Need to check and see if the Modified-Since time is greater
                // than our current time. If it is, we ignore it.

                GetSystemTimeAsFileTime(&tm);

                if (*(LONGLONG *)&tm >= liModifiedSince.QuadPart)
                {
                    //
                    // Clear out any content-encoding set since we are not
                    // sending the actual body
                    //
                    pResponse->SetHeaderByReference(HttpHeaderContentEncoding,
                                                    NULL, 0);

                    pResponse->SetStatus(HttpStatusNotModified);
                    *pfHandled = TRUE;
                    return S_OK;
                }
            }
        }

        fIsNoneMatchPassed = TRUE;
    }

    if (!fIsNoneMatchPassed)
    {
        //
        // Clear out any content-encoding set since we are not
        // sending the actual body
        //
        pResponse->SetHeaderByReference(HttpHeaderContentEncoding,
                                        NULL, 0);

        pResponse->SetStatus(HttpStatusNotModified);
        *pfHandled = TRUE;
        return S_OK;
    }

    //
    // Made it through that, handle If-Unmodified-Since if we have that.
    //
    LPCSTR pszIfUnmodifiedSince = pRequest->GetHeader(
               HttpHeaderIfUnmodifiedSince);
    if (pszIfUnmodifiedSince != NULL)
    {
        LARGE_INTEGER liUnmodifiedSince;
        if (StringTimeToFileTime(pszIfUnmodifiedSince,
                                 &liUnmodifiedSince))
        {
            FILETIME    tm;
            
            pOpenFile->QueryLastWriteTime(&tm);

            // If our last write time is greater than their UnmodifiedSince
            // time, the precondition fails.
            if (*(LONGLONG*)&tm > liUnmodifiedSince.QuadPart)
            {
                pResponse->ClearHeaders();
                pResponse->SetStatus(HttpStatusPreconditionFailed);
                *pfHandled = TRUE;
                return S_OK;
            }
        }
    }

    *pfHandled = FALSE;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\certmapprovider.cxx ===
/*++
   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     certmapprovider.cxx

   Abstract:
     Active Directory Certificate Mapper provider
 
   Author:
     Bilal Alam (balam)             10-Jan-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include "certmapprovider.hxx"

HRESULT
CERTMAP_AUTH_PROVIDER::DoesApply(
    W3_MAIN_CONTEXT *       pMainContext,
    BOOL *                  pfApplies
)
/*++

Routine Description:

    Does Active Directory certificate map authentication apply? 
    MD_ACCESS_MAP_CERT covers 2 kinds of mappings (DS mapper and IIS mapper)
    CERT_AUTH_PROVIDER represents only the DS mapper

Arguments:

    pMainContext - Main context
    pfApplies - Set to TRUE if cert map auth applies

Return Value:

    HRESULT

--*/
{
    CERTIFICATE_CONTEXT *           pCertificateContext;
    URL_CONTEXT *                   pUrlContext = NULL;
    W3_METADATA *                   pMetaData = NULL;
    BOOL                            fApplies = FALSE;
    
    if ( pMainContext == NULL ||
         pfApplies == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // If cert mapping is not allowed for this vroot, then ignore client
    // cert token and let other authentication mechanisms do their thing
    //
    
    pUrlContext = pMainContext->QueryUrlContext();
    DBG_ASSERT( pUrlContext != NULL );
    
    pMetaData = pUrlContext->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );

    //
    // Are certmappings allowed?
    //
    if ( pMetaData->QuerySslAccessPerms() & MD_ACCESS_MAP_CERT )
    {
        DBG_ASSERT( pMainContext->QuerySite() );
        //
        // Is Active Directory mapping allowed
        //
        if ( pMainContext->QuerySite()->QueryUseDSMapper() )
        {
            pCertificateContext = pMainContext->QueryCertificateContext();
            //
            // Did schannel successfully mapped client certificate to token?
            //
            if ( pCertificateContext != NULL )
            {
                if ( pCertificateContext->QueryImpersonationToken() != NULL )
                {
                    fApplies = TRUE;
                }
            }
        }
    }
    
    *pfApplies = fApplies;
    
    return NO_ERROR;
}

HRESULT
CERTMAP_AUTH_PROVIDER::DoAuthenticate(
    W3_MAIN_CONTEXT *       pMainContext,
    BOOL *                  // unused
)
/*++

Routine Description:

    Create a user context representing a cert mapped token

Arguments:

    pMainContext - Main context
    pfFilterFinished - Set to TRUE if filter wants out

Return Value:

    HRESULT

--*/
{
    CERTMAP_USER_CONTEXT *          pUserContext = NULL;
    CERTIFICATE_CONTEXT *           pCertificateContext = NULL;
    HANDLE                          hImpersonation;
    HRESULT                         hr = NO_ERROR;
    
    if ( pMainContext == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    pCertificateContext = pMainContext->QueryCertificateContext();
    DBG_ASSERT( pCertificateContext != NULL );

    hImpersonation = pCertificateContext->QueryImpersonationToken();
    DBG_ASSERT( hImpersonation != NULL );
   
    //
    // Create the user context for this request
    //
    
    pUserContext = new CERTMAP_USER_CONTEXT( this );
    if ( pUserContext == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    //
    // Is this a delegatable token?  Put another way is this token mapped
    // using an IIS cert mapper (IIS cert mapper creates delegatable token,
    // the DS mapper does not)
    //
    
    hr = pUserContext->Create( hImpersonation );
    if ( FAILED( hr ) )
    {
        pUserContext->DereferenceUserContext();
        pUserContext = NULL;
        return hr;
    }
    
    pMainContext->SetUserContext( pUserContext );
    
    return NO_ERROR;
}

HRESULT
CERTMAP_AUTH_PROVIDER::OnAccessDenied(
    W3_MAIN_CONTEXT *               /*pMainContext*/
)
/*++

Routine Description:

    NOP since we have nothing to do on access denied

Arguments:

    pMainContext - Main context (not used)

Return Value:

    HRESULT

--*/
{
    //
    // No headers to add
    //
    
    return NO_ERROR;
}

HRESULT
CERTMAP_USER_CONTEXT::Create(
    HANDLE                  hImpersonation
)
/*++

Routine Description:

    Create a certificate mapped user context

Arguments:

    hImpersonation - Impersonation token

Return Value:

    HRESULT

--*/
{
    HRESULT hr = E_FAIL;
    if ( hImpersonation == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // First the easy stuff
    //
    
    if ( !DuplicateTokenEx( hImpersonation,
                           TOKEN_ALL_ACCESS,
                           NULL,
                           SecurityImpersonation,
                           TokenImpersonation,
                           &_hImpersonationToken ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        DBGPRINTF(( DBG_CONTEXT,
                    "DuplicateTokenEx failed, hr = 0x%x\n",
                    hr ));
        return hr;
        
    }
    
    DBG_ASSERT( _hImpersonationToken != NULL );

    //
    // Disable the backup privilege for the token 
    //

    DisableTokenBackupPrivilege( _hImpersonationToken );
    
    //
    // Now get the user name
    //
    
    if ( !SetThreadToken( NULL, _hImpersonationToken ) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    // cchUserName includes buffer size in characters including terminating 0
    DWORD       cchUserName = sizeof( _achUserName ) / sizeof( WCHAR );
    
    if ( !GetUserNameEx( NameSamCompatible,
                         _achUserName,
                         &cchUserName ) )
    {
        
        hr = HRESULT_FROM_WIN32( GetLastError() );
        RevertToSelf();
        return hr;
    }
    RevertToSelf();
    return NO_ERROR;
}

HANDLE
CERTMAP_USER_CONTEXT::QueryPrimaryToken(
    VOID
)
/*++

Routine Description:

    Get a primary token

Arguments:

    None

Return Value:

    HANDLE

--*/
{
    if ( _hPrimaryToken == NULL )
    {
        if ( DuplicateTokenEx( _hImpersonationToken,
                               TOKEN_ALL_ACCESS,
                               NULL,
                               SecurityImpersonation,
                               TokenPrimary,
                               &_hPrimaryToken ) )
        {
         
            DBG_ASSERT( _hImpersonationToken != NULL );
        }
        else
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "DuplicateTokenEx failed, hr = 0x%x\n",
                        HRESULT_FROM_WIN32( GetLastError() ) ));
        }
    }
    
    return _hPrimaryToken;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\cgi_handler.h ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    cgi_handler.h

Abstract:

    Handler class for CGI

Author:

    Taylor Weiss (TaylorW)       01-Feb-1999

Revision History:

--*/

#ifndef _CGI_HANDLER_H_
#define _CGI_HANDLER_H_

#define MAX_CGI_BUFFERING                  2048

enum CGI_STATE
{
    CgiStateStart,
    CgiStateProcessingRequestEntity,
    CgiStateProcessingResponseHeaders,
    CgiStateProcessingResponseEntity,
    CgiStateDoneWithRequest
};

class W3_CGI_HANDLER : public W3_HANDLER
{
public:
    W3_CGI_HANDLER( W3_CONTEXT * pW3Context,
                    META_SCRIPT_MAP_ENTRY * pScriptMapEntry,
                    LPSTR pszSSICommandLine = NULL )
      : W3_HANDLER        (pW3Context, pScriptMapEntry),
        m_cbData          (0),
        m_hStdOut         (INVALID_HANDLE_VALUE),
        m_hStdIn          (INVALID_HANDLE_VALUE),
        m_hProcess        (NULL),
        m_hTimer          (NULL),
        m_dwRequestState  (CgiStateStart),
        m_fResponseRedirected (FALSE),
        m_bytesToSend     (INFINITE),
        m_bytesToReceive  (0),
        m_fEntityBodyPreloadComplete (FALSE),
        m_pszSSICommandLine(pszSSICommandLine),
        m_fIsNphCgi       (FALSE)
    {
        ZeroMemory(&m_Overlapped, sizeof OVERLAPPED);

        InitializeListHead(&m_CgiListEntry);

        EnterCriticalSection(&sm_CgiListLock);
        InsertHeadList(&sm_CgiListHead, &m_CgiListEntry);
        LeaveCriticalSection(&sm_CgiListLock);

        // perf ctr
        pW3Context->QuerySite()->IncCgiReqs();

        if ( ETW_IS_TRACE_ON(ETW_LEVEL_CP) )
        {
            HTTP_REQUEST_ID RequestId = pW3Context->QueryRequest()->QueryRequestId();

            g_pEtwTracer->EtwTraceEvent( &CgiEventGuid,
                                         ETW_TYPE_START,
                                         &RequestId,
                                         sizeof(HTTP_REQUEST_ID),
                                         NULL,
                                         0 );
        }

        if (pszSSICommandLine != NULL)
        {
            m_fIsNphCgi = TRUE;
        }
    }

    ~W3_CGI_HANDLER();

    WCHAR *QueryName()
    {
        return L"CGIHandler";
    }

    CONTEXT_STATUS DoWork();

    CONTEXT_STATUS OnCompletion(IN DWORD cbCompletion,
                                IN DWORD dwCompletionStatus);

    static HRESULT Initialize();

    static VOID KillAllCgis();

    static VOID Terminate();

private:

    HRESULT CGIStartProcessing();

    HRESULT CGIContinueOnClientCompletion();

    HRESULT CGIContinueOnPipeCompletion(BOOL *pfIsCgiError);

    HRESULT CGIReadRequestEntity(BOOL *pfIoPending);

    HRESULT CGIWriteResponseEntity();

    HRESULT CGIReadCGIOutput();

    HRESULT CGIWriteCGIInput();

    HRESULT ProcessCGIOutput();

    HRESULT SetupChildEnv(OUT BUFFER *pBuffer);

    static HRESULT SetupChildPipes(OUT HANDLE *phStdOut,
                                   OUT HANDLE *phStdIn,
                                   IN OUT STARTUPINFO *pstartupinfo);

    static VOID CALLBACK CGITerminateProcess(PVOID pContext,
                                             BOOLEAN);

    BOOL QueryIsNphCgi() const
    {
        return m_fIsNphCgi;
    }

    static VOID CALLBACK OnPipeIoCompletion(
                             DWORD dwErrorCode,
                             DWORD dwNumberOfBytesTransfered,
                             LPOVERLAPPED lpOverlapped);

    static BOOL             sm_fForwardServerEnvironmentBlock;
    static WCHAR *          sm_pEnvString;
    static DWORD            sm_cchEnvLength;
    static LIST_ENTRY       sm_CgiListHead;
    static CRITICAL_SECTION sm_CgiListLock;

    //
    // DWORD containing the state of the current request
    //
    CGI_STATE               m_dwRequestState;
    BOOL                    m_fResponseRedirected;

    //
    // The timer callback handle
    //
    HANDLE                   m_hTimer;

    //
    //  Parent's input and output handles and child's process handle
    //
    
    HANDLE                  m_hStdOut;
    HANDLE                  m_hStdIn;
    HANDLE                  m_hProcess;

    //
    // Variable to keep track of how many more bytes of request/response left
    //
    DWORD                   m_bytesToSend;
    DWORD                   m_bytesToReceive;

    //
    // Buffer to do I/O to/from CGI/client
    //
    CHAR                    m_DataBuffer[MAX_CGI_BUFFERING];

    //
    // Buffer to store response headers
    //
    BUFFER                  m_bufResponseHeaders;

    //
    // Number of bytes in the buffer (m_DataBuffer or
    // m_bufResponseHeaders) currently
    //
    DWORD                   m_cbData;

    //
    // OVERLAPPED structure for async I/O
    //
    OVERLAPPED m_Overlapped;

    //
    // Store a list of active CGI requests so we can timeout bad requests
    //
    LIST_ENTRY              m_CgiListEntry;

    //
    // Have we completed preloading the entity body
    //
    BOOL                    m_fEntityBodyPreloadComplete;

    //
    // For the SSI #EXEC CMD case, m_pszSSICommandLine contains the explicit
    // command to execute
    //
    // Note: CGI_HANDLER does not own this string so it doesn't need to
    // free it.
    //
    LPSTR                   m_pszSSICommandLine;

    //
    // Is this an nph CGI (or a cmd exec from SSI)
    //
    BOOL                    m_fIsNphCgi;
};

//
//  This is the exit code given to processes that we terminate
//

#define CGI_PREMATURE_DEATH_CODE  0xf1256323

#endif // _CGI_HANDLER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\compress.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    compression.h

Abstract:

    Do Http compression

Author:

    Anil Ruia (AnilR)           10-Apr-2000

--*/

#ifndef _COMPRESSION_H_
#define _COMPRESSION_H_

#define COMPRESSION_MIN_IO_BUFFER_SIZE                  256
#define COMPRESSION_MAX_IO_BUFFER_SIZE               100000
#define COMPRESSION_MIN_COMP_BUFFER_SIZE               1024
#define COMPRESSION_MAX_COMP_BUFFER_SIZE             100000
#define COMPRESSION_MAX_QUEUE_LENGTH                  10000
#define COMPRESSION_MIN_FILES_DELETED_PER_DISK_FREE       1
#define COMPRESSION_MAX_FILES_DELETED_PER_DISK_FREE    1024
#define COMPRESSION_MAX_COMPRESSION_LEVEL                10

#define COMPRESSION_DEFAULT_DISK_SPACE_USAGE      100000000
#define COMPRESSION_DEFAULT_BUFFER_SIZE                8192
#define COMPRESSION_DEFAULT_QUEUE_LENGTH               1000
#define COMPRESSION_DEFAULT_FILES_DELETED_PER_DISK_FREE 256
#define COMPRESSION_DEFAULT_FILE_SIZE_FOR_COMPRESSION     1

enum COMP_INIT_STATUS
{
    COMP_INIT_NONE,
    COMP_INIT_SCHEMES,
    COMP_INIT_DIRLOCK,
    COMP_INIT_CONTEXT,
    COMP_INIT_DONE
};

class COMPRESSION_SCHEME
{
 public:
    COMPRESSION_SCHEME()
        : m_hCompressionDll            (NULL),
          m_pCompressionContext        (NULL),
          m_dwPriority                 (1),
          m_dwDynamicCompressionLevel  (0),
          m_dwOnDemandCompressionLevel (COMPRESSION_MAX_COMPRESSION_LEVEL),
          m_dwCreateFlags              (0),
          m_fDoStaticCompression       (TRUE),
          m_fDoOnDemandCompression     (TRUE),
          m_fDoDynamicCompression      (TRUE),
          m_pfnInitCompression         (NULL),
          m_pfnDeInitCompression       (NULL),
          m_pfnCreateCompression       (NULL),
          m_pfnCompress                (NULL),
          m_pfnDestroyCompression      (NULL),
          m_pfnResetCompression        (NULL)
    {}

    HRESULT Initialize(MB *pmb, LPWSTR schemeName);

    ~COMPRESSION_SCHEME()
    {
        if (m_pfnDestroyCompression && m_pCompressionContext)
        {
            m_pfnDestroyCompression(m_pCompressionContext);
            m_pCompressionContext = NULL;
        }

        if (m_pfnDeInitCompression)
        {
            m_pfnDeInitCompression();
        }

        if (m_hCompressionDll)
        {
            FreeLibrary(m_hCompressionDll);
            m_hCompressionDll = NULL;
        }
    }

    STRU                           m_strCompressionSchemeName;
    STRA                           m_straCompressionSchemeName;
    STRU                           m_strFilePrefix;
    MULTISZ                        m_mszFileExtensions;
    MULTISZ                        m_mszScriptFileExtensions;

    DWORD                          m_dwPriority;

    HMODULE                        m_hCompressionDll;
    PFNCODEC_INIT_COMPRESSION      m_pfnInitCompression;
    PFNCODEC_DEINIT_COMPRESSION    m_pfnDeInitCompression;
    PFNCODEC_CREATE_COMPRESSION    m_pfnCreateCompression;
    PFNCODEC_COMPRESS              m_pfnCompress;
    PFNCODEC_DESTROY_COMPRESSION   m_pfnDestroyCompression;
    PFNCODEC_RESET_COMPRESSION     m_pfnResetCompression;

    // The compression context used for static compression
    PVOID                          m_pCompressionContext;

    DWORD                          m_dwDynamicCompressionLevel;
    DWORD                          m_dwOnDemandCompressionLevel;
    DWORD                          m_dwCreateFlags;
    BOOL                           m_fDoDynamicCompression;
    BOOL                           m_fDoStaticCompression;
    BOOL                           m_fDoOnDemandCompression;
};

typedef enum
{
    COMPRESSION_WORK_ITEM_COMPRESS,
    COMPRESSION_WORK_ITEM_DELETE,
    COMPRESSION_WORK_ITEM_TERMINATE,
    COMPRESSION_WORK_ITEM_INVALID
} COMPRESSION_WORK_ITEM_TYPE;

class COMPRESSION_WORK_ITEM
{
public:
    COMPRESSION_WORK_ITEM()
        : WorkItemType (COMPRESSION_WORK_ITEM_INVALID),
          scheme (NULL),
          pFileInfo (NULL)
    {
        InitializeListHead(&ListEntry);
    }

    virtual ~COMPRESSION_WORK_ITEM()
    {
        InitializeListHead(&ListEntry);

        if (pFileInfo != NULL)
        {
            pFileInfo->DereferenceCacheEntry();
            pFileInfo = NULL;
        }
    }

    LIST_ENTRY                  ListEntry;
    COMPRESSION_WORK_ITEM_TYPE  WorkItemType;
    COMPRESSION_SCHEME         *scheme;
    STRU                        strPhysicalPath;
    W3_FILE_INFO               *pFileInfo;
};

#define MAX_SERVER_SCHEMES 100

typedef enum
{
    DO_STATIC_COMPRESSION,
    DO_DYNAMIC_COMPRESSION
} COMPRESSION_TO_PERFORM;

#define DYNAMIC_COMPRESSION_BUFFER_SIZE 2000

typedef enum
{
    IN_CHUNK_LENGTH,
    IN_CHUNK_EXTENSION,
    IN_CHUNK_HEADER_NEW_LINE,
    AT_CHUNK_DATA_NEW_LINE,
    IN_CHUNK_DATA_NEW_LINE,
    IN_CHUNK_DATA
} COMPRESS_CHUNK_STATE;

class COMPRESSION_CONTEXT
{
 public:
    static HRESULT Initialize()
    {
        ALLOC_CACHE_CONFIGURATION acConfig;
        
        acConfig.nConcurrency = 1;
        acConfig.nThreshold = 100;
        acConfig.cbSize = sizeof COMPRESSION_CONTEXT;

        allocHandler = new ALLOC_CACHE_HANDLER("COMPRESSION_CONTEXT",
                                               &acConfig);
        if (allocHandler == NULL)
        {
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }

        return S_OK;
    }

    static void Terminate()
    {
        if (allocHandler != NULL)
        {
            delete allocHandler;
        }
    }

    void *operator new(
#if DBG
        size_t            size
#else
        size_t
#endif
    )
    {
        DBG_ASSERT(size == sizeof COMPRESSION_CONTEXT);
        DBG_ASSERT(allocHandler != NULL);
        return allocHandler->Alloc();
    }

    void operator delete(void *pCompressionContext)
    {
        DBG_ASSERT(pCompressionContext != NULL);
        DBG_ASSERT(allocHandler != NULL);
        DBG_REQUIRE(allocHandler->Free(pCompressionContext));
    }

    COMPRESSION_CONTEXT()
        : m_pScheme                      (NULL),
          m_fTransferChunkEncoded        (FALSE),
          m_pCompressionContext          (NULL),
          m_dwBytesInCurrentEncodedChunk (0),
          m_encodedChunkState            (IN_CHUNK_LENGTH),
          m_fHeadersSent                 (FALSE),
          m_fRequestIsHead               (FALSE),
          m_fOriginalBodyEmpty           (TRUE)
    {}

    ~COMPRESSION_CONTEXT()
    {
        if (m_pCompressionContext)
        {
            m_pScheme->m_pfnDestroyCompression(m_pCompressionContext);
            m_pCompressionContext = NULL;
        }
    }

    HRESULT ProcessEncodedChunkHeader();

    HRESULT CalculateEncodedChunkByteCount();

    VOID DeleteEncodedChunkExtension();

    VOID IncrementPointerInULChunk(IN DWORD dwIncr = 1)
    {
        m_pbOrigData += dwIncr;
        m_cbOrigData -= dwIncr;
    }

    COMPRESSION_SCHEME          *m_pScheme;

    //
    // Is the original response chunk encoded?
    //
    BOOL                        m_fTransferChunkEncoded;

    //
    // If the original response is Chunk encoded, information about the
    // current chunk in the response
    //
    DWORD                       m_dwBytesInCurrentEncodedChunk;
    COMPRESS_CHUNK_STATE        m_encodedChunkState;

    //
    // The context used by the compression routines
    //
    PVOID                       m_pCompressionContext;

    //
    // position in the original response
    //
    PBYTE                       m_pbOrigData;
    DWORD                       m_cbOrigData;

    static ALLOC_CACHE_HANDLER *allocHandler;

    //
    // Some members to keep track of HEAD request body suppression
    //
    BOOL                        m_fRequestIsHead;
    BOOL                        m_fOriginalBodyEmpty;

    //
    // Has the end of response headers been seen?
    //
    BOOL                        m_fHeadersSent;

    //
    // A chunk's worth of data
    //
    BUFFER                      m_bufChunk;
};

class HTTP_COMPRESSION
{
 public:

    static HRESULT Initialize();

    static VOID Terminate();

    static HRESULT DoStaticFileCompression(IN     W3_CONTEXT    *pW3Context,
                                           IN OUT W3_FILE_INFO **ppFileInfo,
                                              OUT BOOL          *pfDoCache);

    static HRESULT OnSendResponse(
                       IN  W3_CONTEXT *pW3Context);

    static HRESULT DoDynamicCompression(
                       IN  W3_CONTEXT *pW3Context,
                       IN  BOOL        fMoreData,
                       IN  HTTP_FILTER_RAW_DATA * pRawData );

    static BOOL QueryDoStaticCompression()
    {
        return sm_fDoStaticCompression;
    }

    static BOOL QueryDoDynamicCompression()
    {
        return sm_fDoDynamicCompression;
    }

 private:

    static COMPRESSION_SCHEME *sm_pCompressionSchemes[MAX_SERVER_SCHEMES];
    static DWORD sm_dwNumberOfSchemes;
    static STRU *sm_pstrCompressionDirectory;
    static STRA *sm_pstrCacheControlHeader;
    static STRA *sm_pstrExpiresHeader;
    static BOOL  sm_fDoStaticCompression;
    static BOOL  sm_fDoDynamicCompression;
    static BOOL  sm_fDoOnDemandCompression;
    static BOOL  sm_fDoDiskSpaceLimiting;
    static BOOL  sm_fNoCompressionForHttp10;
    static BOOL  sm_fNoCompressionForProxies;
    static BOOL  sm_fNoCompressionForRange;
    static BOOL  sm_fSendCacheHeaders;
    static DWORD sm_dwMaxDiskSpaceUsage;
    static DWORD sm_dwIoBufferSize;
    static DWORD sm_dwCompressionBufferSize;
    static DWORD sm_dwMaxQueueLength;
    static DWORD sm_dwFilesDeletedPerDiskFree;
    static DWORD sm_dwMinFileSizeForCompression;
    static PBYTE sm_pIoBuffer;
    static PBYTE sm_pCompressionBuffer;
    static CRITICAL_SECTION sm_CompressionDirectoryLock;
    static DWORD sm_dwCurrentDiskSpaceUsage;
    static BOOL  sm_fCompressionVolumeIsFat;
    static LIST_ENTRY sm_CompressionThreadWorkQueue;
    static CRITICAL_SECTION sm_CompressionThreadLock;
    static HANDLE sm_hThreadEvent;
    static HANDLE sm_hCompressionThreadHandle;
    static DWORD sm_dwCurrentQueueLength;
    static COMP_INIT_STATUS sm_InitStatus;
    static BOOL  sm_fIsTerminating;

    static HRESULT ReadMetadata(MB *pmb);

    static HRESULT InitializeCompressionSchemes(MB *pmb);

    static HRESULT InitializeCompressionDirectory();

    static HRESULT InitializeCompressionThread();

    static DWORD WINAPI CompressionThread(LPVOID);

    static BOOL QueueWorkItem(
        IN COMPRESSION_WORK_ITEM   *WorkItem,
        IN BOOL                     fOverrideMaxQueueLength,
        IN BOOL                     fQueueAtHead);

    static VOID FindMatchingSchemes(
                    IN  CHAR * pszAcceptEncoding,
                    IN  LPWSTR pszExtension,
                    IN  COMPRESSION_TO_PERFORM performCompr,
                    OUT DWORD  matchingSchemes[],
                    OUT DWORD *pdwClientCompressionCount);

    static HRESULT ConvertPhysicalPathToCompressedPath(
        IN COMPRESSION_SCHEME *scheme,
        IN STRU  *pstrPhysicalPath,
        OUT STRU *pstrCompressedFileName);

    static BOOL CheckForExistenceOfCompressedFile(
        IN  W3_FILE_INFO  *pOrigFile,
        IN  STRU          *pstrCompressedFileName,
        OUT W3_FILE_INFO **ppCompFile,
        IN  BOOL           fDeleteAllowed = TRUE);

    static BOOL QueueCompressFile(
        IN COMPRESSION_SCHEME *scheme,
        IN W3_FILE_INFO       *pFileInfo);

    static VOID CompressFile(IN COMPRESSION_SCHEME *scheme,
                             IN W3_FILE_INFO       *pFileInfo);

    static VOID FreeDiskSpace();

    static BOOL CompressAndWriteData(
                    IN  COMPRESSION_SCHEME *scheme,
                    IN  PBYTE               InputBuffer,
                    IN  DWORD               BytesToCompress,
                    OUT PDWORD              BytesWritten,
                    IN  HANDLE              hCompressedFile);
};

#endif _COMPRESSION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\cgi_handler.cxx ===
/*++

   Copyright    (c)   2000    Microsoft Corporation

   Module Name :
     cgi_handler.cxx

   Abstract:
     Handle CGI requests
 
   Author:
     Taylor Weiss (TaylorW)             27-Jan-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include "cgi_handler.h"

//
// W3_CGI_HANDLER statics
//

BOOL             W3_CGI_HANDLER::sm_fForwardServerEnvironmentBlock = FALSE;
WCHAR *          W3_CGI_HANDLER::sm_pEnvString = NULL;
DWORD            W3_CGI_HANDLER::sm_cchEnvLength = 0;
LIST_ENTRY       W3_CGI_HANDLER::sm_CgiListHead;
CRITICAL_SECTION W3_CGI_HANDLER::sm_CgiListLock;


//
//  Environment variable block used for CGI
//
LPSTR g_CGIServerVars[] =
{
    {"ALL_HTTP"}, // Means insert all HTTP_ headers here
    {"APP_POOL_ID"},
    {"AUTH_TYPE"},
    {"AUTH_PASSWORD"},
    {"AUTH_USER"},
    {"CERT_COOKIE"},
    {"CERT_FLAGS"},
    {"CERT_ISSUER"},
    {"CERT_SERIALNUMBER"},
    {"CERT_SUBJECT"},
    {"CONTENT_LENGTH"},
    {"CONTENT_TYPE"},
    {"GATEWAY_INTERFACE"},
    {"HTTPS"},
    {"HTTPS_KEYSIZE"},
    {"HTTPS_SECRETKEYSIZE"},
    {"HTTPS_SERVER_ISSUER"},
    {"HTTPS_SERVER_SUBJECT"},
    {"INSTANCE_ID"},
    {"LOCAL_ADDR"},
    {"LOGON_USER"},
    {"PATH_INFO"},
    {"PATH_TRANSLATED"},
    {"QUERY_STRING"},
    {"REMOTE_ADDR"},
    {"REMOTE_HOST"},
    {"REMOTE_USER"},
    {"REQUEST_METHOD"},
    {"SCRIPT_NAME"},
    {"SERVER_NAME"},
    {"SERVER_PORT"},
    {"SERVER_PORT_SECURE"},
    {"SERVER_PROTOCOL"},
    {"SERVER_SOFTWARE"},
    {"UNMAPPED_REMOTE_USER"},
    {NULL}
};


// static
HRESULT W3_CGI_HANDLER::Initialize()
{
    DBGPRINTF((DBG_CONTEXT, "W3_CGI_HANDLER::Initialize() called\n"));

    //
    // Read some CGI configuration from the registry
    //
    HRESULT hr;

    if (!InitializeCriticalSectionAndSpinCount(&sm_CgiListLock, 10))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }
    InitializeListHead(&sm_CgiListHead);

    HKEY w3Params;
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     W3_PARAMETERS_KEY,
                     0,
                     KEY_READ,
                     &w3Params) == NO_ERROR)
    {
        DWORD dwType;
        DWORD cbData = sizeof BOOL;
        if ((RegQueryValueEx(w3Params,
                             L"ForwardServerEnvironmentBlock",
                             NULL,
                             &dwType,
                             (LPBYTE)&sm_fForwardServerEnvironmentBlock,
                             &cbData) != NO_ERROR) ||
            (dwType != REG_DWORD))
        {
            sm_fForwardServerEnvironmentBlock = TRUE;
        }

        RegCloseKey(w3Params);
    }

    //
    // Read the environment
    //
    if (sm_fForwardServerEnvironmentBlock)
    {
        WCHAR *EnvString = GetEnvironmentStrings();
        if (EnvString == NULL)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DBGPRINTF((DBG_CONTEXT, "GetEnvironmentStrings failed\n"));
            goto Exit;
        }

        //
        // Compute length of environment block (excluding block delimiter)
        //

        DWORD length;
        sm_cchEnvLength = 0;
        while ((length = (DWORD)wcslen(EnvString + sm_cchEnvLength)) != 0)
        {
            sm_cchEnvLength += length + 1;
        }

        //
        // store it
        //
        if ((sm_pEnvString = new WCHAR[sm_cchEnvLength]) == NULL)
        {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            FreeEnvironmentStrings(EnvString);
            goto Exit;
        }

        memcpy(sm_pEnvString,
               EnvString,
               sm_cchEnvLength * sizeof(WCHAR));

        FreeEnvironmentStrings(EnvString);
    }

    return S_OK;

 Exit:
    DBG_ASSERT(FAILED(hr));

    //
    // Cleanup partially created stuff
    //
    Terminate();

    return hr;
}

W3_CGI_HANDLER::~W3_CGI_HANDLER()
{
    //
    // Close all open handles related to this request
    //
    EnterCriticalSection(&sm_CgiListLock);
    RemoveEntryList(&m_CgiListEntry);
    LeaveCriticalSection(&sm_CgiListLock);

    if (m_hTimer)
    {
        if (!DeleteTimerQueueTimer(NULL,
                                   m_hTimer,
                                   INVALID_HANDLE_VALUE))
        {
            DBGPRINTF((DBG_CONTEXT,
                       "DeleteTimerQueueTimer failed, %d\n",
                       GetLastError()));
        }
        m_hTimer = NULL;
    }

    if (m_hStdOut != INVALID_HANDLE_VALUE)
    {
        if (!CloseHandle(m_hStdOut))
        {
            DBGPRINTF((DBG_CONTEXT,
                       "CloseHandle failed on StdOut, %d\n",
                       GetLastError()));
        }
        m_hStdOut = INVALID_HANDLE_VALUE;
    }

    if (m_hStdIn != INVALID_HANDLE_VALUE)
    {
        if (!CloseHandle(m_hStdIn))
        {
            DBGPRINTF((DBG_CONTEXT,
                       "CloseHandle failed on StdIn, %d\n",
                       GetLastError()));
        }
        m_hStdIn = INVALID_HANDLE_VALUE;
    }

    if (m_hProcess)
    {
        //
        // Just in case it is still running
        //
        TerminateProcess(m_hProcess, 0);

        DBG_REQUIRE(CloseHandle(m_hProcess));
        m_hProcess = NULL;
    }

    // perf ctr
    QueryW3Context()->QuerySite()->DecCgiReqs();

    if ( ETW_IS_TRACE_ON(ETW_LEVEL_CP) ) 
    {
        HTTP_REQUEST_ID RequestId = QueryW3Context()->QueryRequest()->QueryRequestId();

        g_pEtwTracer->EtwTraceEvent( &CgiEventGuid,
                                     ETW_TYPE_END,
                                     &RequestId,
                                     sizeof(HTTP_REQUEST_ID),
                                     NULL, 
                                     0 );
    }
}

VOID CALLBACK W3_CGI_HANDLER::OnPipeIoCompletion(
                                  DWORD dwErrorCode,
                                  DWORD dwNumberOfBytesTransfered,
                                  LPOVERLAPPED lpOverlapped)
{
    if (dwErrorCode && dwErrorCode != ERROR_BROKEN_PIPE)
    {
        DBGPRINTF((DBG_CONTEXT, "Error %d on CGI_HANDLER::OnPipeIoCompletion\n", dwErrorCode));
    }

    HRESULT hr = S_OK;
    BOOL    fIsCgiError = TRUE;

    W3_CGI_HANDLER *pHandler = CONTAINING_RECORD(lpOverlapped,
                                                 W3_CGI_HANDLER,
                                                 m_Overlapped);

    if (dwErrorCode ||
        (dwNumberOfBytesTransfered == 0))
    {
        if (pHandler->m_dwRequestState == CgiStateProcessingRequestEntity)
        {
            //
            // If we could not write the request entity, for example because
            // the CGI did not wait to read the entity, ignore the error and
            // continue on to reading the output
            //

            //
            // If this is an nph cgi, we do not parse header
            //
            if (pHandler->QueryIsNphCgi())
            {
                pHandler->m_dwRequestState = CgiStateProcessingResponseEntity;
            }
            else
            {
                pHandler->m_dwRequestState = CgiStateProcessingResponseHeaders;
            }
            pHandler->m_cbData = 0;

            if (SUCCEEDED(hr = pHandler->CGIReadCGIOutput()))
            {
                return;
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(dwErrorCode);
        }

        fIsCgiError = TRUE;
        goto ErrorExit;
    }

    if (pHandler->m_dwRequestState == CgiStateProcessingResponseHeaders)
    {
        //
        // Copy the headers to the header buffer to be parsed when we have
        // all the headers
        //
        if (!pHandler->m_bufResponseHeaders.Resize(
                 pHandler->m_cbData + dwNumberOfBytesTransfered + 1))
        {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            goto ErrorExit;
        }

        memcpy((LPSTR)pHandler->m_bufResponseHeaders.QueryPtr() +
                   pHandler->m_cbData,
               pHandler->m_DataBuffer,
               dwNumberOfBytesTransfered);

        pHandler->m_cbData += dwNumberOfBytesTransfered;

        ((LPSTR)pHandler->m_bufResponseHeaders.QueryPtr())[pHandler->m_cbData] = '\0';
    }
    else if (pHandler->m_dwRequestState == CgiStateProcessingResponseEntity)
    {
        pHandler->m_cbData = dwNumberOfBytesTransfered;
    }

    if (FAILED(hr = pHandler->CGIContinueOnPipeCompletion(&fIsCgiError)))
    {
        goto ErrorExit;
    }

    return;

 ErrorExit:
    if (hr != HRESULT_FROM_WIN32(ERROR_BROKEN_PIPE))
    {
        pHandler->QueryW3Context()->SetErrorStatus(hr);
    }

    //
    // If the error happened due to an CGI problem, mark it as 502
    // appropriately
    //
    if (fIsCgiError)
    {
        if (pHandler->m_dwRequestState != CgiStateProcessingResponseEntity &&
            pHandler->m_dwRequestState != CgiStateDoneWithRequest)
        {
            pHandler->QueryW3Context()->QueryResponse()->Clear();

            DWORD dwExitCode;
            if (GetExitCodeProcess(pHandler->m_hProcess,
                                   &dwExitCode) &&
                dwExitCode == CGI_PREMATURE_DEATH_CODE)
            {
                STACK_STRU( strUrl, 128);
                STACK_STRU( strQuery, 128);
                if (SUCCEEDED(pHandler->QueryW3Context()->QueryRequest()->GetUrl(&strUrl)) &&
                    SUCCEEDED(pHandler->QueryW3Context()->QueryRequest()->GetQueryString(&strQuery)))
                {
                    LPCWSTR apsz[2];
                    apsz[0] = strUrl.QueryStr();
                    apsz[1] = strQuery.QueryStr();

                    g_pW3Server->LogEvent(W3_EVENT_KILLING_SCRIPT,
                                          2,
                                          apsz);
                }

                pHandler->QueryW3Context()->QueryResponse()->SetStatus(
                    HttpStatusBadGateway,
                    Http502Timeout);
            }
            else
            {
                pHandler->QueryW3Context()->QueryResponse()->SetStatus(
                    HttpStatusBadGateway,
                    Http502PrematureExit);
            }
        }
    }
    else
    {
        pHandler->QueryW3Context()->QueryResponse()->SetStatus(
            HttpStatusBadRequest);
    }

    pHandler->m_dwRequestState = CgiStateDoneWithRequest;

    POST_MAIN_COMPLETION( pHandler->QueryW3Context()->QueryMainContext() ); 
}


HRESULT
GeneratePipeNames(
    STRU *pstrStdoutName,
    STRU *pstrStdinName)
{
    RPC_STATUS rpcStatus;
    UUID pipeUuid;
    LPWSTR pszPipeUuid = NULL;
    HRESULT hr;

    rpcStatus = UuidCreate(&pipeUuid);
    if (rpcStatus != RPC_S_OK)
    {
        return E_FAIL;
    }

    rpcStatus = UuidToString(&pipeUuid, &pszPipeUuid);
    if (rpcStatus != RPC_S_OK)
    {
        return E_FAIL;
    }

    if (FAILED(hr = pstrStdoutName->Copy(L"\\\\.\\pipe\\IISCgiStdout")) ||
        FAILED(hr = pstrStdoutName->Append(pszPipeUuid)) ||
        FAILED(hr = pstrStdinName->Copy(L"\\\\.\\pipe\\IISCgiStdin")) ||
        FAILED(hr = pstrStdinName->Append(pszPipeUuid)))
    {
        RpcStringFree(&pszPipeUuid);
        return hr;
    }

    RpcStringFree(&pszPipeUuid);
    return hr;
}


// static
HRESULT W3_CGI_HANDLER::SetupChildPipes(
    HANDLE *phStdOut,
    HANDLE *phStdIn,
    STARTUPINFO *pstartupinfo)
/*++
  Synopsis
    Setup the pipes to use for communicating with the child process

  Arguments
    phStdOut: this will be populated with the server side of CGIs stdout
    phStdIn: this will be populated with the server side of CGIs stdin
    pstartupinfo: this will be populated with the startinfo that can be
      passed to a CreateProcess call

  Return Value
    HRESULT
--*/
{
    STACK_STRU( strStdoutName, 128);
    STACK_STRU( strStdinName, 128);
    HRESULT hr = S_OK;

    DBG_ASSERT(phStdOut != NULL);
    DBG_ASSERT(phStdIn != NULL);
    DBG_ASSERT(pstartupinfo != NULL);

    SECURITY_ATTRIBUTES sa;

    sa.nLength              = sizeof(sa);
    sa.lpSecurityDescriptor = NULL;
    sa.bInheritHandle       = TRUE;

    pstartupinfo->hStdOutput = INVALID_HANDLE_VALUE;
    pstartupinfo->hStdInput = INVALID_HANDLE_VALUE;
    pstartupinfo->dwFlags = STARTF_USESTDHANDLES;

    hr = GeneratePipeNames( &strStdoutName,
                            &strStdinName );
    if (FAILED(hr))
    {
        goto ErrorExit;
    }

    *phStdOut = CreateNamedPipe(strStdoutName.QueryStr(),
                                PIPE_ACCESS_INBOUND | FILE_FLAG_OVERLAPPED | FILE_FLAG_FIRST_PIPE_INSTANCE,
                                0,
                                1,
                                MAX_CGI_BUFFERING,
                                MAX_CGI_BUFFERING,
                                INFINITE,
                                NULL);
    if (*phStdOut == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ErrorExit;
    }
    if (!ThreadPoolBindIoCompletionCallback(*phStdOut,
                                            OnPipeIoCompletion,
                                            0))
    {
        DBGPRINTF((DBG_CONTEXT, "ThreadPoolBindIo failed\n"));
        hr = E_FAIL;
        goto ErrorExit;
    }
    pstartupinfo->hStdOutput = CreateFile(strStdoutName.QueryStr(),
                                          GENERIC_WRITE,
                                          0,
                                          &sa,
                                          OPEN_EXISTING,
                                          FILE_FLAG_OVERLAPPED,
                                          NULL);
    if (pstartupinfo->hStdOutput == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ErrorExit;
    }

    *phStdIn = CreateNamedPipe(strStdinName.QueryStr(),
                               PIPE_ACCESS_OUTBOUND | FILE_FLAG_OVERLAPPED | FILE_FLAG_FIRST_PIPE_INSTANCE,
                               0,
                               1,
                               MAX_CGI_BUFFERING,
                               MAX_CGI_BUFFERING,
                               INFINITE,
                               NULL);
    if (*phStdIn == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ErrorExit;
    }
    if (!ThreadPoolBindIoCompletionCallback(*phStdIn,
                                            OnPipeIoCompletion,
                                            0))
    {
        DBGPRINTF((DBG_CONTEXT, "ThreadPoolBindIo failed\n"));
        hr = E_FAIL;
        goto ErrorExit;
    }
    pstartupinfo->hStdInput = CreateFile(strStdinName.QueryStr(),
                                         GENERIC_READ,
                                         0,
                                         &sa,
                                         OPEN_EXISTING,
                                         FILE_FLAG_OVERLAPPED,
                                         NULL);
    if (pstartupinfo->hStdInput == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ErrorExit;
    }

    //
    //  Stdout and Stderror will use the same pipe.
    //
    pstartupinfo->hStdError = pstartupinfo->hStdOutput;

    return S_OK;

ErrorExit:
    DBGPRINTF((DBG_CONTEXT, "SetupChildPipes Failed, hr %x\n", hr));

    //
    // Need to close these now so that other instances do not connect to it
    //
    if (pstartupinfo->hStdOutput != INVALID_HANDLE_VALUE)
    {
        DBG_REQUIRE(CloseHandle(pstartupinfo->hStdOutput));
        pstartupinfo->hStdOutput = INVALID_HANDLE_VALUE;
    }

    if (pstartupinfo->hStdInput != INVALID_HANDLE_VALUE)
    {
        DBG_REQUIRE(CloseHandle(pstartupinfo->hStdInput));
        pstartupinfo->hStdInput = INVALID_HANDLE_VALUE;
    }

    if (*phStdOut != INVALID_HANDLE_VALUE)
    {
        DBG_REQUIRE(CloseHandle(*phStdOut));
        *phStdOut = INVALID_HANDLE_VALUE;
    }

    if (*phStdIn != INVALID_HANDLE_VALUE)
    {
        DBG_REQUIRE(CloseHandle(*phStdIn));
        *phStdIn = INVALID_HANDLE_VALUE;
    }

    return hr;
}


BOOL IsCmdExe(const WCHAR *pchPath)
/*++
  Tells whether the CGI call is for a cmd shell
--*/
{
    //
    // do case-insensitive search for cmd.exe (there is no function in
    // msvcrt for this)
    //
    for (; *pchPath != L'\0'; pchPath++)
    {
        if ((pchPath[0] == L'c' || pchPath[0] == 'C') &&
            (pchPath[1] == L'm' || pchPath[1] == 'M') &&
            (pchPath[2] == L'd' || pchPath[2] == 'D') &&
            pchPath[3] == L'.' &&
            (pchPath[4] == L'e' || pchPath[4] == 'E') &&
            (pchPath[5] == L'x' || pchPath[5] == 'X') &&
            (pchPath[6] == L'e' || pchPath[6] == 'E'))
        {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL IsNphCgi(const WCHAR *pszUrl)
/*++
  Tells whether the URL is for an nph cgi script
--*/
{
    LPWSTR pszLastSlash = wcsrchr(pszUrl, L'/');
    if (pszLastSlash != NULL)
    {
        if (_wcsnicmp(pszLastSlash + 1, L"nph-", 4) == 0)
        {
            return TRUE;
        }
    }

    return FALSE;
}

HRESULT SetupCmdLine(W3_REQUEST *pRequest,
                     STRU *pstrCmdLine)
{
    STACK_STRU (queryString, MAX_PATH);
    HRESULT hr = S_OK;
    if (FAILED(hr = pRequest->GetQueryString(&queryString)))
    {
        return hr;
    }

    //
    // If there is no QueryString OR if an unencoded "=" is found, don't
    // append QueryString to the command line according to spec
    //

    if (queryString.QueryCCH() == 0 ||
        wcschr(queryString.QueryStr(), L'='))
    {
        return S_OK;
    }

    queryString.Unescape();

    return pstrCmdLine->Append(queryString);
} // SetupCmdLine


HRESULT 
W3_CGI_HANDLER::SetupChildEnv(OUT BUFFER *pBuff)
{
    //
    // Build the environment block for CGI
    //

    DWORD cchCurrentPos = 0;

    //
    // Copy the environment variables
    //
    
    if (sm_fForwardServerEnvironmentBlock)
    {
        if (!pBuff->Resize(sm_cchEnvLength * sizeof(WCHAR), 512))
        {
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }
        
        memcpy(pBuff->QueryPtr(),
               sm_pEnvString,
               sm_cchEnvLength * sizeof(WCHAR));
               
        cchCurrentPos = sm_cchEnvLength;
    }

    CHAR * pszName;
    STACK_STRU (strVal, 512);
    STACK_STRU (struName, 32);
    for (DWORD i = 0; (pszName = g_CGIServerVars[i]) != NULL; i++)
    {
        HRESULT hr;
        if (FAILED(hr = SERVER_VARIABLE_HASH::GetServerVariableW(
                            QueryW3Context(), 
                            pszName,
                            &strVal)))
        {
            return hr;
        }

        DWORD cchName = (DWORD)strlen(pszName);
        DWORD cchValue = strVal.QueryCCH();

        //
        //  We need space for the terminating '\0' and the '='
        //

        DWORD cbNeeded = (cchName + cchValue + 1 + 1) * sizeof(WCHAR);

        if (!pBuff->Resize(cchCurrentPos * sizeof(WCHAR) + cbNeeded,
                           512))
        {
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }

        WCHAR * pchtmp = (WCHAR *)pBuff->QueryPtr();
        if (strcmp(pszName, "ALL_HTTP") == 0)
        {
            //
            // ALL_HTTP means we're adding all of the HTTP_ header
            // fields which requires a little bit of special processing
            //

            memcpy(pchtmp + cchCurrentPos,
                   strVal.QueryStr(),
                   (cchValue + 1) * sizeof(WCHAR));

            WCHAR * pszColonPosition = wcschr(pchtmp + cchCurrentPos, L':');
            WCHAR * pszNewLinePosition;

            //
            // Convert the Name:Value\n entries to Name=Value\0 entries
            // for the environment table
            //

            while (pszColonPosition != NULL)
            {
                *pszColonPosition = L'=';

                pszNewLinePosition = wcschr(pszColonPosition + 1, L'\n');

                DBG_ASSERT(pszNewLinePosition != NULL);

                *pszNewLinePosition = L'\0';

                pszColonPosition = wcschr(pszNewLinePosition + 1, L':');
            }

            cchCurrentPos += cchValue;
        }
        else
        {
            //
            // Normal ServerVariable, add it
            //
            if (FAILED(hr = struName.CopyA(pszName,
                                           cchName)))
            {
                return hr;
            }

            memcpy(pchtmp + cchCurrentPos,
                   struName.QueryStr(),
                   cchName * sizeof(WCHAR));

            *(pchtmp + cchCurrentPos + cchName) = L'=';

            memcpy(pchtmp + cchCurrentPos + cchName + 1,
                   strVal.QueryStr(),
                   (cchValue + 1) * sizeof(WCHAR));

            cchCurrentPos += cchName + cchValue + 1 + 1;
        }
    }

    //
    //  Add an extra null terminator to the environment list
    //

    if (!pBuff->Resize((cchCurrentPos + 1) * sizeof(WCHAR)))
    {
        return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    *((WCHAR *)pBuff->QueryPtr() + cchCurrentPos) = L'\0';

    return S_OK;
}


VOID CALLBACK W3_CGI_HANDLER::CGITerminateProcess(PVOID pContext,
                                                  BOOLEAN)
/*++

Routine Description:

    This function is the callback called by the scheduler thread after the
    specified timeout period has elapsed.

Arguments:

    pContext - Handle of process to kill

--*/
{
    W3_CGI_HANDLER *pHandler = reinterpret_cast<W3_CGI_HANDLER *>(pContext);

    if (pHandler->m_hProcess &&
        !TerminateProcess(pHandler->m_hProcess, CGI_PREMATURE_DEATH_CODE))
    {
        DBGPRINTF((DBG_CONTEXT,
                   "CGITerminateProcess - TerminateProcess failed, error %d\n",
                   GetLastError()));
    }

    if (pHandler->m_hStdIn != INVALID_HANDLE_VALUE &&
        !DisconnectNamedPipe(pHandler->m_hStdIn))
    {
        DBGPRINTF((DBG_CONTEXT,
                   "CGITerminateProcess - DisconnectNamedPipe failed, error %d\n",
                   GetLastError()));
    }

    if (pHandler->m_hStdOut != INVALID_HANDLE_VALUE &&
        !DisconnectNamedPipe(pHandler->m_hStdOut))
    {
        DBGPRINTF((DBG_CONTEXT,
                   "CGITerminateProcess - DisconnectNamedPipe failed, error %d\n",
                   GetLastError()));
    }
} // CGITerminateProcess


BOOL CheckForEndofHeaders(IN LPSTR pbuff,
                          IN int cbData,
                          OUT DWORD *pcbIndexStartOfData)
{
    //
    // If the response starts with a newline (\n, \r\n or \r\r\n), then,
    // no headers present, it is all data
    //
    if (pbuff[0] == '\n')
    {
        *pcbIndexStartOfData = 1;
        return TRUE;
    }
    if ((pbuff[0] == '\r') && (pbuff[1] == '\n'))
    {
        *pcbIndexStartOfData = 2;
        return TRUE;
    }
    if ((pbuff[0] == '\r') && (pbuff[1] == '\r') && (pbuff[2] == '\n'))
    {
        *pcbIndexStartOfData = 3;
        return TRUE;
    }

    //
    // Look for two consecutive newline, \n\r\r\n, \n\r\n or \n\n
    // No problem with running beyond the end of buffer as the buffer is
    // null terminated
    //
    int index;
    for (index = 0; index < cbData - 1; index++)
    {
        if (pbuff[index] == '\n')
        {
            if (pbuff[index + 1] == '\n')
            {
                *pcbIndexStartOfData = index + 2;
                return TRUE;
            }
            else if (pbuff[index + 1] == '\r')
            {
                if (pbuff[index + 2] == '\n')
                {
                    *pcbIndexStartOfData = index + 3;
                    return TRUE;
                }
                else if ((pbuff[index + 2] == '\r') &&
                         (pbuff[index + 3] == '\n'))
                {
                    *pcbIndexStartOfData = index + 4;
                    return TRUE;
                }
            }
        }
    }

    return FALSE;
}


HRESULT 
W3_CGI_HANDLER::ProcessCGIOutput()
/*++
  Synopsis
    This function parses the CGI output and seperates out the headers and
    interprets them as appropriate

  Return Value
    HRESULT
--*/
{
    W3_REQUEST  *pRequest  = QueryW3Context()->QueryRequest();
    W3_RESPONSE *pResponse = QueryW3Context()->QueryResponse();
    HRESULT      hr        = S_OK;
    STACK_STRA (strReason, 32);
    DWORD       index = 0;
    BOOL        fCanKeepConn = FALSE;

    //
    //  The end of CGI headers are marked by a blank line, check to see if
    //  we've hit that line.
    //
    LPSTR Headers = (LPSTR)m_bufResponseHeaders.QueryPtr();
    DWORD cbIndexStartOfData;
    if (!CheckForEndofHeaders(Headers,
                              m_cbData,
                              &cbIndexStartOfData))
    {
        return CGIReadCGIOutput();
    }

    m_dwRequestState = CgiStateProcessingResponseEntity;
    //
    // We've found the end of the headers, process them
    //
    // if request header contains:
    //
    //    Location: xxxx - if starts with /, send doc, otherwise send
    //       redirect message
    //    URI: preferred synonym to Location:
    //    Status: nnn xxxx - Send as status code (HTTP/1.1 nnn xxxx)
    //

    //
    // The first line in the response could (optionally) look like
    // HTTP/n.n nnn xxxx\r\n
    //
    if (!strncmp(Headers, "HTTP/", 5))
    {
        USHORT statusCode;
        LPSTR pszSpace;
        LPSTR pszNewline;
        if ((pszNewline = strchr(Headers, '\n')) == NULL)
        {
            goto ErrorExit;
        }
        index = (DWORD)DIFF(pszNewline - Headers) + 1;
        if (pszNewline[-1] == '\r')
            pszNewline--;


        if (((pszSpace = strchr(Headers, ' ')) == NULL) ||
            (pszSpace >= pszNewline))
        {
            goto ErrorExit;
        }
        while (pszSpace[0] == ' ')
            pszSpace++;
        statusCode = (USHORT) atoi(pszSpace);

        //
        // UL only allows status codes upto 999, so reject others
        //
        if (statusCode > 999)
        {
            goto ErrorExit;
        }

        if (((pszSpace = strchr(pszSpace, ' ')) == NULL) ||
            (pszSpace >= pszNewline))
        {
            goto ErrorExit;
        }
        while (pszSpace[0] == ' ')
            pszSpace++;

        if (FAILED(hr = strReason.Copy(pszSpace,
                            (DWORD)DIFF(pszNewline - pszSpace))) ||
            FAILED(hr = pResponse->SetStatus(statusCode, strReason)))
        {
            goto ErrorExit;
        }
        
        if (pResponse->QueryStatusCode() == HttpStatusUnauthorized.statusCode)
        {
            pResponse->SetStatus(HttpStatusUnauthorized,
                                 Http401Application);
        }
    }
        
    while ((index + 3) < cbIndexStartOfData)
    {
        //
        // Find the ':' in Header : Value\r\n
        //
        LPSTR pchColon = strchr(Headers + index, ':');

        //
        // Find the '\n' in Header : Value\r\n
        //
        LPSTR pchNewline = strchr(Headers + index, '\n');

        //
        // Take care of header continuation
        //
        while (pchNewline[1] == ' ' ||
               pchNewline[1] == '\t')
        {
            pchNewline = strchr(pchNewline + 1, '\n');
        }

        if ((pchColon == NULL) ||
            (pchColon >= pchNewline))
        {
            goto ErrorExit;
        }

        //
        // Skip over any spaces before the ':'
        //
        LPSTR pchEndofHeaderName;
        for (pchEndofHeaderName = pchColon - 1;
             (pchEndofHeaderName >= Headers + index) &&
                 (*pchEndofHeaderName == ' ');
             pchEndofHeaderName--)
        {}

        //
        // Copy the header name
        //
        STACK_STRA (strHeaderName, 32);
        if (FAILED(hr = strHeaderName.Copy(Headers + index,
                            (DWORD)DIFF(pchEndofHeaderName - Headers) - index + 1)))
        {
            goto ErrorExit;
        }

        //
        // Skip over the ':' and any trailing spaces
        //
        for (index = (DWORD)DIFF(pchColon - Headers) + 1;
             Headers[index] == ' ';
             index++)
        {}

        //
        // Skip over any spaces before the '\n'
        //
        LPSTR pchEndofHeaderValue;
        for (pchEndofHeaderValue = pchNewline - 1;
             (pchEndofHeaderValue >= Headers + index) &&
                 ((*pchEndofHeaderValue == ' ') ||
                  (*pchEndofHeaderValue == '\r'));
             pchEndofHeaderValue--)
        {}

        //
        // Copy the header value
        //
        STACK_STRA (strHeaderValue, 32);
        if (FAILED(hr = strHeaderValue.Copy(Headers + index,
                            (DWORD)DIFF(pchEndofHeaderValue - Headers) - index + 1)))
        {
            goto ErrorExit;
        }

        if (!_stricmp("Status", strHeaderName.QueryStr()))
        {
            USHORT statusCode = (USHORT) atoi(strHeaderValue.QueryStr());

            //
            // UL only allows status codes upto 999, so reject others
            //
            if (statusCode > 999)
            {
                goto ErrorExit;
            }

            CHAR * pchReason = strchr(strHeaderValue.QueryStr(), ' ');
            if (pchReason != NULL)
            {
                pchReason++;
                if (FAILED(hr = strReason.Copy(pchReason)) ||
                    FAILED(hr = pResponse->SetStatus(statusCode, strReason)))
                {
                    goto ErrorExit;
                }

                if (pResponse->QueryStatusCode() == HttpStatusUnauthorized.statusCode)
                {
                    pResponse->SetStatus(HttpStatusUnauthorized,
                                         Http401Application);
                }
            }
        }
        else if (!_stricmp("Location", strHeaderName.QueryStr()) ||
                 !_stricmp("URI", strHeaderName.QueryStr()))
        {
            //
            // The CGI script is redirecting us to another URL.  If it
            // begins with a '/', then get it, otherwise send a redirect
            // message
            //

            m_dwRequestState = CgiStateDoneWithRequest;
            m_fResponseRedirected = TRUE;

            if (strHeaderValue.QueryStr()[0] == '/')
            {
                //
                // Execute a child request
                //
                pResponse->Clear();
                pResponse->SetStatus(HttpStatusOk);
                
                if (FAILED(hr = pRequest->SetUrlA(strHeaderValue)) ||
                    FAILED(hr = QueryW3Context()->ExecuteChildRequest(
                                    pRequest,
                                    FALSE,
                                    W3_FLAG_ASYNC )))
                {
                    goto ErrorExit;
                }
                
                return S_OK;
            }
            else 
            {
                HTTP_STATUS httpStatus;
                pResponse->GetStatus(&httpStatus);

                //
                // Plain old redirect since this was not a "local" URL
                // If the CGI had already set the status to some 3xx value,
                // honor it
                //
                
                if (FAILED(hr = QueryW3Context()->SetupHttpRedirect(
                                    strHeaderValue,
                                    FALSE,
                                    ((httpStatus.statusCode / 100) == 3) ? httpStatus : HttpStatusRedirect)))
                {
                    goto ErrorExit;
                }
            }
        }
        else
        {
            //
            // Remember the Content-Length the cgi specified
            //

            if (!_stricmp("Content-Length", strHeaderName.QueryStr()))
            {
                fCanKeepConn = TRUE;
                m_bytesToSend = atoi(strHeaderValue.QueryStr());
            }
            else if (!_stricmp("Transfer-Encoding", strHeaderName.QueryStr()) &&
                     !_stricmp("chunked", strHeaderValue.QueryStr()))
            {
                fCanKeepConn = TRUE;
            }
            else if (!_stricmp("Connection", strHeaderName.QueryStr()) &&
                     !_stricmp("close", strHeaderValue.QueryStr()))
            {
                QueryW3Context()->SetDisconnect(TRUE);
            }

            if (strHeaderName.QueryCCH() > MAXUSHORT ||
                strHeaderValue.QueryCCH() > MAXUSHORT)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
                goto ErrorExit;
            }

            //
            //  Copy any other fields the script specified
            //
            hr = pResponse->SetHeader(strHeaderName.QueryStr(),
                                      (USHORT)strHeaderName.QueryCCH(),
                                      strHeaderValue.QueryStr(),
                                      (USHORT)strHeaderValue.QueryCCH());
            if (FAILED(hr))
            {
                goto ErrorExit;
            }
        }

        index = (DWORD)DIFF(pchNewline - Headers) + 1;
    } // while

    if (m_fResponseRedirected)
    {
        return QueryW3Context()->SendResponse(W3_FLAG_ASYNC);
    }

    //
    // We allow CGI to send its own entity if no custom-error is defined
    //
    if (pResponse->QueryStatusCode() >= 400)
    {
        BOOL            fIsFileError;
        STACK_STRU (    strError, 64 );
        HTTP_SUB_ERROR  subError;
        pResponse->QuerySubError( &subError );

        W3_METADATA *pMetaData = QueryW3Context()->QueryUrlContext()->QueryMetaData();

        hr = pMetaData->FindCustomError( pResponse->QueryStatusCode(),
                                         subError.mdSubError,
                                         &fIsFileError,
                                         &strError );
        if (SUCCEEDED(hr))
        {
            //
            // Found a custom error, send it
            //
            m_dwRequestState = CgiStateDoneWithRequest;
            return QueryW3Context()->SendResponse(W3_FLAG_ASYNC);
        }
    }

    //
    // If the CGI did not say how much data was present, mark the
    // connection for closing
    //
    if (!fCanKeepConn)
    {
        QueryW3Context()->SetDisconnect(TRUE);
    }

    //
    // Now send any data trailing the headers
    //
    if (cbIndexStartOfData < m_cbData)
    {
        if (m_bytesToSend < m_cbData - cbIndexStartOfData)
        {
            m_cbData = m_bytesToSend + cbIndexStartOfData;
        }

        if (FAILED(hr = pResponse->AddMemoryChunkByReference(
                            Headers + cbIndexStartOfData,
                            m_cbData - cbIndexStartOfData)))
        {
            return hr;
        }

        m_bytesToSend -= m_cbData - cbIndexStartOfData;
        if (m_bytesToSend == 0)
        {
            m_dwRequestState = CgiStateDoneWithRequest;
        }
    }

    return QueryW3Context()->SendResponse(W3_FLAG_ASYNC 
                                          | W3_FLAG_MORE_DATA
                                          | W3_FLAG_NO_CONTENT_LENGTH
                                          | W3_FLAG_NO_ERROR_BODY);

 ErrorExit:
    m_dwRequestState = CgiStateProcessingResponseHeaders;
    if (FAILED(hr))
    {
        return hr;
    }

    return E_FAIL;
}

HRESULT W3_CGI_HANDLER::CGIReadRequestEntity(BOOL *pfIoPending)
/*++
  Synopsis

    This function reads the next chunk of request entity

  Arguments

    pfIoPending: On return indicates if there is an I/O pending

  Return Value
    HRESULT
--*/
{
    if (m_bytesToReceive == 0)
    {
        *pfIoPending = FALSE;
        return S_OK;
    }

    HRESULT hr;
    DWORD cbRead;
    if (FAILED(hr = QueryW3Context()->ReceiveEntity(
                        W3_FLAG_ASYNC,
                        m_DataBuffer,
                        (DWORD)min(m_bytesToReceive, sizeof(m_DataBuffer)),
                        &cbRead)))
    {
        if (hr == HRESULT_FROM_WIN32(ERROR_HANDLE_EOF))
        {
            *pfIoPending = FALSE;
            return S_OK;
        }

        DBGPRINTF((DBG_CONTEXT,
                   "CGIReadEntity Error reading gateway data, hr %x\n",
                   hr));

        return hr;
    }

    *pfIoPending = TRUE;
    return S_OK;
}

HRESULT W3_CGI_HANDLER::CGIWriteResponseEntity()
/*++
  Synopsis

    This function writes the next chunk of response entity

  Arguments

    None

  Return Value

    HRESULT
--*/
{
    W3_RESPONSE *pResponse = QueryW3Context()->QueryResponse();
    pResponse->Clear( TRUE );

    //
    // At this point, we got to be reading the entity
    //
    DBG_ASSERT(m_dwRequestState == CgiStateProcessingResponseEntity);

    if (m_bytesToSend <= m_cbData)
    {
        m_cbData = m_bytesToSend;
        m_bytesToSend = 0;
        m_dwRequestState = CgiStateDoneWithRequest;
    }
    else
    {
        m_bytesToSend -= m_cbData;
    }

    HRESULT hr;
    if (FAILED(hr = pResponse->AddMemoryChunkByReference(m_DataBuffer,
                                                         m_cbData)))
    {
        return hr;
    }

    return QueryW3Context()->SendEntity(W3_FLAG_ASYNC | W3_FLAG_MORE_DATA);
}

HRESULT W3_CGI_HANDLER::CGIReadCGIOutput()
/*++
  Synopsis

    This function Reads the next chunk of data from the CGI

  Arguments

    None

  Return Value
    S_OK if async I/O posted
    Failure otherwise
--*/
{
    if (!ReadFile(m_hStdOut,
                  m_DataBuffer,
                  MAX_CGI_BUFFERING,
                  NULL,
                  &m_Overlapped))
    {
        DWORD dwErr = GetLastError();
        if (dwErr == ERROR_IO_PENDING)
            return S_OK;

        if (dwErr != ERROR_BROKEN_PIPE)
        {
            DBGPRINTF((DBG_CONTEXT,
                       "ReadFile from child stdout failed, error %d\n",
                       GetLastError()));
        }

        return HRESULT_FROM_WIN32(dwErr);
    }

    return S_OK;
}

HRESULT W3_CGI_HANDLER::CGIWriteCGIInput()
/*++
  Synopsis

    This function 

  Arguments

    None

  Return Value

    HRESULT
--*/
{
    if (!WriteFile(m_hStdIn,
                   m_DataBuffer,
                   m_cbData,
                   NULL,
                   &m_Overlapped))
    {
        if (GetLastError() == ERROR_IO_PENDING)
            return S_OK;

        DBGPRINTF((DBG_CONTEXT, "WriteFile failed, error %d\n",
                   GetLastError()));
        return HRESULT_FROM_WIN32(GetLastError());
    }

    return S_OK;
}

HRESULT W3_CGI_HANDLER::CGIContinueOnPipeCompletion(
    BOOL *pfIsCgiError)
/*++
  Synopsis

    This function continues on I/O completion to a pipe.
      If the I/O completion was because of a write on the pipe, it reads
    the next chunk of request entity, or if there is no more request entity,
    reads the first chunk of CGI output.
      If the I/O completion was because of a read on the pipe, it processes
    that data by either adding it to the header buffer or sending it to the
    client

  Arguments

    pfIsCgiError - Tells whether any error occurring inside this function
        was the fault of the CGI or the client

  Return Value

    HRESULT
--*/
{
    HRESULT hr;
    if (m_dwRequestState == CgiStateProcessingRequestEntity)
    {
        BOOL fIoPending = FALSE;
        if (FAILED(hr = CGIReadRequestEntity(&fIoPending)) ||
            (fIoPending == TRUE))
        {
            *pfIsCgiError = FALSE;
            return hr;
        }

        //
        // There was no more request entity to read
        //
        DBG_ASSERT(fIoPending == FALSE);

        //
        // If this is an nph cgi, we do not parse header
        //
        if (QueryIsNphCgi())
        {
            m_dwRequestState = CgiStateProcessingResponseEntity;
        }
        else
        {
            m_dwRequestState = CgiStateProcessingResponseHeaders;
        }
        m_cbData = 0;

        if (FAILED(hr = CGIReadCGIOutput()))
        {
            *pfIsCgiError = TRUE;
        }
        return hr;
    }
    else if (m_dwRequestState == CgiStateProcessingResponseHeaders)
    {
        if (FAILED(hr = ProcessCGIOutput()))
        {
            *pfIsCgiError = TRUE;
        }
        return hr;
    }
    else
    {
        DBG_ASSERT(m_dwRequestState == CgiStateProcessingResponseEntity);

        if (FAILED(hr = CGIWriteResponseEntity()))
        {
            *pfIsCgiError = FALSE;
        }
        return hr;
    }
}

HRESULT W3_CGI_HANDLER::CGIStartProcessing()
/*++
  Synopsis

    This function kicks off the CGI processing by reading request entity
    if any or reading the first chunk of CGI output

  Arguments

    None

  Return Value

    HRESULT
--*/
{
    DWORD                   cbAvailableAlready;
    PVOID                   pbAvailableAlready;
    
    m_dwRequestState = CgiStateProcessingRequestEntity;

    //
    // First we have to write any entity body to the program's stdin
    //
    // Start with the Entity Body already read
    //
    
    QueryW3Context()->QueryAlreadyAvailableEntity( &pbAvailableAlready,
                                                   &cbAvailableAlready );
                                                   
    m_bytesToReceive = QueryW3Context()->QueryRemainingEntityFromUl();

    if ( cbAvailableAlready != 0 )
    {
        if (WriteFile(m_hStdIn,
                      pbAvailableAlready,
                      cbAvailableAlready,
                      NULL,
                      &m_Overlapped))
        {
            return S_OK;
        }

        if (GetLastError() == ERROR_IO_PENDING)
        {
            return S_OK;
        }

        DBGPRINTF((DBG_CONTEXT, "WriteFile failed, error %d\n",
                   GetLastError()));

        //
        // If we could not write the request entity, for example because
        // the CGI did not wait to read the entity, ignore the error and
        // continue on to reading the output
        //
    }

    //
    // Now continue with either reading the rest of the request entity
    // or the CGI response
    //
    BOOL fIsCgiError;
    return CGIContinueOnPipeCompletion(&fIsCgiError);
}

HRESULT W3_CGI_HANDLER::CGIContinueOnClientCompletion()
{
    if (m_dwRequestState == CgiStateProcessingRequestEntity)
    {
        if (SUCCEEDED(CGIWriteCGIInput()))
        {
            return S_OK;
        }

        //
        // If we could not write the request entity, for example because
        // the CGI did not wait to read the entity, ignore the error and
        // continue on to reading the output
        //

        //
        // If this is an nph cgi, we do not parse header
        //
        if (QueryIsNphCgi())
        {
            m_dwRequestState = CgiStateProcessingResponseEntity;
        }
        else
        {
            m_dwRequestState = CgiStateProcessingResponseHeaders;
        }
        m_cbData = 0;
    }

    return CGIReadCGIOutput();
}

CONTEXT_STATUS W3_CGI_HANDLER::OnCompletion(DWORD cbCompletion,
                                            DWORD dwCompletionStatus)
{
    DBG_ASSERT(m_dwRequestState != CgiStateProcessingResponseHeaders);

    HRESULT hr = S_OK;

    if (dwCompletionStatus)
    {
        hr = HRESULT_FROM_WIN32(dwCompletionStatus);
        DBGPRINTF((DBG_CONTEXT, "Error %d on CGI_HANDLER::OnCompletion\n", dwCompletionStatus));
    }

    //
    // Is this completion for the entity body preload?  If so note the 
    // number of bytes and start handling the CGI request
    //
    
    if (!m_fEntityBodyPreloadComplete)
    {
        BOOL fComplete = FALSE;

        //
        // This completion is for entity body preload
        //

        W3_REQUEST *pRequest = QueryW3Context()->QueryRequest();
        hr = pRequest->PreloadCompletion(QueryW3Context(),
                                         cbCompletion,
                                         dwCompletionStatus,
                                         &fComplete);

        if (SUCCEEDED(hr))
        {
            if (!fComplete)
            {
                return CONTEXT_STATUS_PENDING;
            }

            m_fEntityBodyPreloadComplete = TRUE;

            //
            // Finally we can call the CGI
            //

            return DoWork();
        }
    }

    //
    // UL can return EOF on the async completion, rather than on the
    // original call (especially on chunked requests), treat them as no error
    //
    if (hr == HRESULT_FROM_WIN32(ERROR_HANDLE_EOF))
    {
        hr = S_OK;
    }

    W3_RESPONSE *pResponse = QueryW3Context()->QueryResponse();
    DBG_ASSERT(pResponse != NULL);

    if (SUCCEEDED(hr) &&
        m_dwRequestState != CgiStateDoneWithRequest)
    {
        if (m_dwRequestState == CgiStateProcessingRequestEntity)
        {
            m_bytesToReceive -= cbCompletion;
            m_cbData = cbCompletion;
        }

        if (SUCCEEDED(hr = CGIContinueOnClientCompletion()))
        {
            return CONTEXT_STATUS_PENDING;
        }

        if (m_dwRequestState != CgiStateProcessingResponseEntity &&
            m_dwRequestState != CgiStateDoneWithRequest)
        {
            pResponse->SetStatus(HttpStatusBadGateway,
                                 Http502PrematureExit);
        }
    }
    else
    {
        if (hr == HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY))
        {
            pResponse->SetStatus(HttpStatusServerError);
        }
        else if ((m_dwRequestState == CgiStateProcessingRequestEntity) ||
            !m_fEntityBodyPreloadComplete)
        {
            pResponse->SetStatus(HttpStatusBadRequest);
        }
    }

    if (FAILED(hr))
    {
        QueryW3Context()->SetErrorStatus(hr);
    }
    
    if (!m_fResponseRedirected &&
        m_dwRequestState != CgiStateProcessingResponseEntity &&
        m_dwRequestState != CgiStateDoneWithRequest)
    {
        //
        // If we reached here, i.e. no response was sent, status should be
        // 502 or 400 or 500
        //
        DBG_ASSERT(pResponse->QueryStatusCode() == HttpStatusBadGateway.statusCode ||
                   pResponse->QueryStatusCode() == HttpStatusBadRequest.statusCode ||
                   pResponse->QueryStatusCode() == HttpStatusServerError.statusCode );

        QueryW3Context()->SendResponse(W3_FLAG_SYNC);
    }

    return CONTEXT_STATUS_CONTINUE;
}

CONTEXT_STATUS 
W3_CGI_HANDLER::DoWork()
{
    W3_CONTEXT *pW3Context = QueryW3Context();
    DBG_ASSERT( pW3Context != NULL );
    W3_RESPONSE  *pResponse;
    W3_REQUEST   *pRequest;
    URL_CONTEXT  *pUrlContext;
    W3_METADATA  *pMetaData;
    HRESULT       hr = S_OK;
    STACK_STRU(   strSSICommandLine, 256 );
    STRU         *pstrPhysical;
    HANDLE        hImpersonationToken;
    HANDLE        hPrimaryToken;
    DWORD         dwFlags = DETACHED_PROCESS;
    STACK_STRU(   strCmdLine, 256);
    BOOL          fIsCmdExe;
    WCHAR *       pszWorkingDir;
    STACK_BUFFER( buffEnv, MAX_CGI_BUFFERING);
    STACK_STRU  ( strApplicationName, 256);
    WCHAR *       pszCommandLine = NULL;
    DWORD         dwFileAttributes = 0;
    BOOL          fImageDisabled = FALSE;
    BOOL          fIsVrToken;

    STARTUPINFO startupinfo;

    pRequest = pW3Context->QueryRequest();
    DBG_ASSERT( pRequest != NULL );
    
    pResponse = pW3Context->QueryResponse();
    DBG_ASSERT( pResponse != NULL );

    ZeroMemory(&startupinfo, sizeof(startupinfo));
    startupinfo.cb = sizeof(startupinfo);
    startupinfo.hStdOutput = INVALID_HANDLE_VALUE;
    startupinfo.hStdInput = INVALID_HANDLE_VALUE;

    pResponse->SetStatus( HttpStatusOk );

    if (!m_fEntityBodyPreloadComplete)
    {
        BOOL fComplete = FALSE;

        hr = pRequest->PreloadEntityBody( pW3Context,
                                          &fComplete );
        if (FAILED(hr))
        {
            goto Exit;
        }

        if (!fComplete)
        {
            return CONTEXT_STATUS_PENDING;
        }

        m_fEntityBodyPreloadComplete = TRUE;
    }

    DBG_ASSERT( m_fEntityBodyPreloadComplete );

    pUrlContext = pW3Context->QueryUrlContext();
    DBG_ASSERT( pUrlContext != NULL );

    pMetaData = pUrlContext->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );
    
    if (m_pszSSICommandLine == NULL)
    {
        pstrPhysical = pUrlContext->QueryPhysicalPath();
        DBG_ASSERT(pstrPhysical != NULL);
    }
    else
    {
        hr = strSSICommandLine.CopyA(m_pszSSICommandLine);
        if (FAILED(hr))
        {
            goto Exit;
        }
        
        pstrPhysical = &strSSICommandLine;
    }

    hImpersonationToken = pW3Context->QueryImpersonationToken( &fIsVrToken );
    hPrimaryToken = pW3Context->QueryPrimaryToken();

    if (QueryScriptMapEntry() != NULL &&
        !QueryScriptMapEntry()->QueryIsStarScriptMap())
    {
        STRU *pstrExe = QueryScriptMapEntry()->QueryExecutable();

        //
        //  Check to see if script mapped CGI is enabled.
        //

        if ( g_pW3Server->QueryIsCgiImageEnabled( pstrExe->QueryStr() ) == FALSE )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "CGI image disabled: %S.\r\n",
                        pstrExe->QueryStr() ));
    
            hr = HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
            fImageDisabled = TRUE;
            goto Exit;
        }

        if (wcschr(pstrPhysical->QueryStr(), '\"') != NULL)
        {
            DBGPRINTF((DBG_CONTEXT,
                       "Refusing request for CGI due to \" in path\n"));

            hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
            goto Exit;
        }

        fIsCmdExe = IsCmdExe(pstrExe->QueryStr());

        STACK_STRU (strDecodedQueryString, MAX_PATH);
        if (FAILED(hr = SetupCmdLine(pRequest, &strDecodedQueryString)))
        {
            goto Exit;
        }

        STACK_BUFFER (bufCmdLine, MAX_PATH);
        DWORD cchLen = pstrExe->QueryCCH() +
                       pstrPhysical->QueryCCH() +
                       strDecodedQueryString.QueryCCH();
        if (!bufCmdLine.Resize(cchLen*sizeof(WCHAR) + sizeof(WCHAR)))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }
        cchLen = _snwprintf((LPWSTR)bufCmdLine.QueryPtr(),
                            cchLen,
                            pstrExe->QueryStr(),
                            pstrPhysical->QueryStr(),
                            strDecodedQueryString.QueryStr());

        if (FAILED(hr = strCmdLine.Copy((LPWSTR)bufCmdLine.QueryPtr(),
                                        cchLen)))
        {
            goto Exit;
        }
    }
    else
    {
        //
        // Check to see if non-script-mapped CGI is enabled
        //

        if ( g_pW3Server->QueryIsCgiImageEnabled( pstrPhysical->QueryStr() ) == FALSE )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "CGI image disabled: %S.\r\n",
                        pstrPhysical->QueryStr() ));
        
            hr = HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
            fImageDisabled = TRUE;
            goto Exit;
        }

        fIsCmdExe = IsCmdExe(pstrPhysical->QueryStr());

        if (FAILED(hr = strCmdLine.Copy(L"\"", 1)) ||
            FAILED(hr = strCmdLine.Append(*pstrPhysical)) ||
            FAILED(hr = strCmdLine.Append(L"\" ", 2)) ||
            FAILED(hr = SetupCmdLine(pRequest, &strCmdLine)))
        {
            goto Exit;
        }
    }

    if (FAILED(hr = SetupChildEnv(&buffEnv)))
    {
        goto Exit;
    }

    pszWorkingDir = pMetaData->QueryVrPath()->QueryStr();

    //
    // Check to see if we're spawning cmd.exe, if so, refuse the request if
    // there are any special shell characters.  Note we do the check here
    // so that the command line has been fully unescaped
    //
    // Also, if invoking cmd.exe for a UNC script then don't set the
    // working directory.  Otherwise cmd.exe will complain about
    // working dir on UNC being not supported, which will destroy the
    // HTTP headers.
    //

    if (fIsCmdExe)
    {
        if (ISUNC(pstrPhysical->QueryStr()))
        {
            pszWorkingDir = NULL;
        }

        DWORD i;

        //
        //  We'll either match one of the characters or the '\0'
        //

        i = (DWORD)wcscspn(strCmdLine.QueryStr(), L"&|(),;%<>");

        if (strCmdLine.QueryStr()[i])
        {
            DBGPRINTF((DBG_CONTEXT,
                       "Refusing request for command shell due to special characters\n"));

            hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
            goto Exit;
        }
        
        //
        // If this is a cmd.exe invocation, then ensure that the script
        // does exist
        //

        hr = pW3Context->CheckPathInfoExists(NULL);
        if (FAILED(hr))
        {
            goto Exit;
        }
    }

    //
    // Now check if it is an nph cgi (if not already)
    //

    if (!m_fIsNphCgi)
    {
        m_fIsNphCgi = IsNphCgi( pUrlContext->QueryUrlInfo()->QueryProcessedUrl()->QueryStr() );
    }

    if (m_fIsNphCgi)
    {
        pW3Context->SetDisconnect(TRUE);
    }

    //
    // We specify an unnamed desktop so a new windowstation will be
    // created in the context of the calling user
    //
    startupinfo.lpDesktop = L"";

    //
    // Setup the pipes information
    //

    if (FAILED(hr = SetupChildPipes(&m_hStdOut,
                                    &m_hStdIn,
                                    &startupinfo)))
    {
        goto Exit;
    }

    if (pMetaData->QueryCreateProcessNewConsole())
    {
        dwFlags = CREATE_NEW_CONSOLE;
    }

    //
    //  Depending what type of CGI this is (SSI command exec, Scriptmap, 
    //  Explicit), the command line and application path are different
    //
    
    if (m_pszSSICommandLine != NULL )
    {
        pszCommandLine = strSSICommandLine.QueryStr();
    }
    else
    {
        if (QueryScriptMapEntry() == NULL )
        {
            if (FAILED(hr = MakePathCanonicalizationProof(pstrPhysical->QueryStr(),
                                                          &strApplicationName)))
            {
                goto Exit;
            }
        }

        pszCommandLine = strCmdLine.QueryStr();
    }

    if (!pMetaData->QueryCreateProcessAsUser())
    {
        //
        // If we are not creating the process as user, make sure to fix the
        // default ACL on the token
        //
        if ((fIsVrToken && !pW3Context->QueryVrToken()->QueryOOPToken()) ||
            (!fIsVrToken && !pW3Context->QueryUserContext()->QueryIsCachedToken()) ||
            (!fIsVrToken && !pW3Context->QueryUserContext()->QueryCachedToken()->QueryOOPToken()))
        {
            if (FAILED(hr = AddWpgToTokenDefaultDacl(hImpersonationToken)))
            {
                goto Exit;
            }
        }
    }

    //
    //  Spawn the process and close the handles since we don't need them
    //

    if (!SetThreadToken(NULL, hImpersonationToken))
    {
        DBGPRINTF((DBG_CONTEXT,
                   "SetThreadToken failed, error %d\n",
                   GetLastError()));

        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }
    
    PROCESS_INFORMATION processinfo;

    BOOL fThreadsIncremented = FALSE;
    if (QueryScriptMapEntry() == NULL)
    {
        if (ISUNC(pstrPhysical->QueryStr()))
        {
            ThreadPoolSetInfo( ThreadPoolIncMaxPoolThreads, 0 );
            fThreadsIncremented = TRUE;
        }
    }
    else
    {
        if (ISUNC(pszCommandLine))
        {
            ThreadPoolSetInfo( ThreadPoolIncMaxPoolThreads, 0 );
            fThreadsIncremented = TRUE;
        }
    }

    if (!pMetaData->QueryCreateProcessAsUser())
    {
        if (!CreateProcess(strApplicationName.QueryCCH() ? strApplicationName.QueryStr() : NULL,
                           pszCommandLine,
                           NULL,      // Process security
                           NULL,      // Thread security
                           TRUE,      // Inherit handles
                           dwFlags | CREATE_UNICODE_ENVIRONMENT,
                           buffEnv.QueryPtr(),
                           pszWorkingDir,
                           &startupinfo,
                           &processinfo))
        {
            DBGPRINTF((DBG_CONTEXT,
                       "CreateProcess failed, error %d\n",
                       GetLastError()));

            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    else
    {
        if (!CreateProcessAsUser(hPrimaryToken,
                                 strApplicationName.QueryCCH() ? strApplicationName.QueryStr() : NULL,
                                 pszCommandLine,
                                 NULL,      // Process security
                                 NULL,      // Thread security
                                 TRUE,      // Inherit handles
                                 dwFlags | CREATE_UNICODE_ENVIRONMENT,
                                 buffEnv.QueryPtr(),
                                 pszWorkingDir,
                                 &startupinfo,
                                 &processinfo))
        {
            DBGPRINTF((DBG_CONTEXT,
                       "CreateProcessAsUser failed, error %d\n",
                       GetLastError()));

            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    if (fThreadsIncremented)
    {
        ThreadPoolSetInfo( ThreadPoolDecMaxPoolThreads, 0 );
    }

    DBG_REQUIRE(RevertToSelf());

    if (FAILED(hr))
    {
        goto Exit;
    }

    DBG_REQUIRE(CloseHandle(startupinfo.hStdInput));
    startupinfo.hStdInput = INVALID_HANDLE_VALUE;
    DBG_REQUIRE(CloseHandle(startupinfo.hStdOutput));
    startupinfo.hStdOutput = INVALID_HANDLE_VALUE;

    DBG_REQUIRE(CloseHandle(processinfo.hThread));
    //
    //  Save the process handle in case we need to terminate it later on
    //
    m_hProcess = processinfo.hProcess;

    //
    //  Schedule a callback to kill the process if it doesn't die
    //  in a timely manner
    //
    if (!CreateTimerQueueTimer(&m_hTimer,
                               NULL,
                               CGITerminateProcess,
                               this,
                               pMetaData->QueryScriptTimeout() * 1000,
                               0,
                               WT_EXECUTEONLYONCE))
    {
        DBGPRINTF((DBG_CONTEXT,
                   "CreateTimerQueueTimer failed, error %d\n",
                   GetLastError()));
    }

    if (SUCCEEDED(hr = CGIStartProcessing()))
    {
        return CONTEXT_STATUS_PENDING;
    }

Exit:
    if (startupinfo.hStdInput != INVALID_HANDLE_VALUE)
    {
        DBG_REQUIRE(CloseHandle(startupinfo.hStdInput));
        startupinfo.hStdInput = INVALID_HANDLE_VALUE;
    }
    if (startupinfo.hStdOutput != INVALID_HANDLE_VALUE)
    {
        DBG_REQUIRE(CloseHandle(startupinfo.hStdOutput));
        startupinfo.hStdOutput = INVALID_HANDLE_VALUE;
    }

    if (FAILED(hr))
    {
        switch (WIN32_FROM_HRESULT(hr))
        {
        case ERROR_FILE_NOT_FOUND:
        case ERROR_PATH_NOT_FOUND:
        case ERROR_INVALID_NAME:

            if (fImageDisabled)
            {
                pResponse->SetStatus(HttpStatusNotFound,
                                     Http404DeniedByPolicy);
            }
            else
            {
                pResponse->SetStatus(HttpStatusNotFound);
            }
            break;

        case ERROR_ACCESS_DENIED:
        case ERROR_ACCOUNT_DISABLED:
        case ERROR_LOGON_FAILURE:
            pResponse->SetStatus(HttpStatusUnauthorized,
                                 Http401Resource);
            break;

        case ERROR_PRIVILEGE_NOT_HELD:
            pResponse->SetStatus(HttpStatusForbidden,
                                 Http403InsufficientPrivilegeForCgi);
            break;
            
        case ERROR_NOT_ENOUGH_MEMORY:
            pResponse->SetStatus(HttpStatusServerError);
            break;

        default:
            //
            // If we were not able to preload the request entity, we will
            // blame the client for it
            //
            if (!m_fEntityBodyPreloadComplete)
            {
                pResponse->SetStatus(HttpStatusBadRequest);
            }
            else
            {
                pResponse->SetStatus(HttpStatusServerError);
            }
        }

        if ( fImageDisabled )
        {
            pW3Context->SetErrorStatus( ERROR_ACCESS_DISABLED_BY_POLICY );
        }
        else
        {
            pW3Context->SetErrorStatus(hr);
        }
    }

    //
    // If we reached here, there was some error, response should not be 200
    //
    DBG_ASSERT(pResponse->QueryStatusCode() != HttpStatusOk.statusCode);

    m_dwRequestState = CgiStateDoneWithRequest;
    if (FAILED(hr = pW3Context->SendResponse(W3_FLAG_ASYNC)))
    {
        return CONTEXT_STATUS_CONTINUE;
    }

    return CONTEXT_STATUS_PENDING;
}

// static
VOID W3_CGI_HANDLER::KillAllCgis()
{
    DBGPRINTF((DBG_CONTEXT, "W3_CGI_HANDLER::KillAllCgis() called\n"));

    //
    // Kill all outstanding processes
    //

    EnterCriticalSection(&sm_CgiListLock);

    for (LIST_ENTRY *pEntry = sm_CgiListHead.Flink;
         pEntry != &sm_CgiListHead;
         pEntry = pEntry->Flink)
    {
        W3_CGI_HANDLER *pCgi = CONTAINING_RECORD(pEntry,
                                                 W3_CGI_HANDLER,
                                                 m_CgiListEntry);

        CGITerminateProcess(pCgi, 0);
    }

    LeaveCriticalSection(&sm_CgiListLock);
}

// static
VOID W3_CGI_HANDLER::Terminate()
{
    DBGPRINTF((DBG_CONTEXT, "W3_CGI_HANDLER::Terminate() called\n"));

    if (sm_pEnvString != NULL)
    {
        delete sm_pEnvString;
        sm_pEnvString = NULL;
    }

    DeleteCriticalSection(&sm_CgiListLock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\certcontext.cxx ===
/*++

   Copyright    (c)    2000    Microsoft Corporation

   Module Name :
     certcontext.cxx

   Abstract:
     Simple wrapper of a certificate blob
     Used co conveniently access client certificate
     information passed to worker process from http.sys
 
   Author:
     Bilal Alam (balam)             5-Sept-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"

HCRYPTPROV              CERTIFICATE_CONTEXT::sm_CryptProvider;
ALLOC_CACHE_HANDLER *   CERTIFICATE_CONTEXT::sm_pachCertContexts;

CERTIFICATE_CONTEXT::CERTIFICATE_CONTEXT(
    HTTP_SSL_CLIENT_CERT_INFO *       pClientCertInfo
) : _fCertDecoded( FALSE ),
    _pClientCertInfo( pClientCertInfo ),
    _buffCertInfo( (PBYTE) &_CertInfo, sizeof( _CertInfo ) )
{
    DBG_ASSERT( _pClientCertInfo != NULL );
}

CERTIFICATE_CONTEXT::~CERTIFICATE_CONTEXT(
    VOID
)
{
    _pClientCertInfo = NULL;
}

HRESULT
CERTIFICATE_CONTEXT::GetIssuer(
    STRA *                  pstrIssuer
)
/*++

Routine Description:

    Get the issuer of the client certificate

Arguments:

    pstrIssuer - Filled with issuer string

Return Value:

    HRESULT

--*/
{
    STACK_BUFFER  ( buffIssuer, 256 );
    HRESULT         hr;
    DWORD           cchIssuer = 0;
    
    if ( pstrIssuer == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
   
    //
    // Decoding deferred until needed
    //
    
    if ( !_fCertDecoded )
    {
        hr = DecodeCert();
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        DBG_ASSERT( _fCertDecoded );
    }
    
    cchIssuer = CertNameToStrA( X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                &(QueryCertInfo()->Issuer),
                                CERT_X500_NAME_STR,
                                NULL,
                                0 );

    if ( !buffIssuer.Resize( cchIssuer * sizeof (CHAR) ) )
    {
        return HRESULT_FROM_WIN32( ERROR_OUTOFMEMORY );
    }
    
    cchIssuer = CertNameToStrA( X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                &(QueryCertInfo()->Issuer),
                                CERT_X500_NAME_STR,
                                (CHAR *) buffIssuer.QueryPtr(),
                                buffIssuer.QuerySize());
    DBG_ASSERT( cchIssuer > 0 );
        
    return pstrIssuer->Copy( (CHAR *) buffIssuer.QueryPtr() );
}

HRESULT
CERTIFICATE_CONTEXT::GetSerialNumber(
    STRA *                  pstrSerialNumber
)
/*++

Routine Description:

    Stringize the certificate's serial number for filling in the
    CERT_SERIAL_NUMBER

Arguments:

    pstrSerialNumber - Filled with serial number string

Return Value:

    HRESULT

--*/
{
    HRESULT                 hr = NO_ERROR;
    INT                     i;
    DWORD                   cbSerialNumber;
    PBYTE                   pbSerialNumber;
    CHAR                    achDigit[ 2 ] = { '\0', '\0' };

    if ( pstrSerialNumber == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // Decoding deferred until needed
    //
    
    if ( !_fCertDecoded )
    {
        hr = DecodeCert();
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        DBG_ASSERT( _fCertDecoded );
    }
    
    cbSerialNumber = QueryCertInfo()->SerialNumber.cbData;
    pbSerialNumber = QueryCertInfo()->SerialNumber.pbData;
    
    for ( i = cbSerialNumber-1; i >=0; i-- )
    {
        //
        // Just like IIS 5.0, we make the serial number in reverse byte order
        //
        
        achDigit[ 0 ] = HEX_DIGIT( ( pbSerialNumber[ i ] >> 4 ) );
        hr = pstrSerialNumber->Append( achDigit, 1 );
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        achDigit[ 0 ] = HEX_DIGIT( ( pbSerialNumber[ i ] & 0xF ) );
        hr = pstrSerialNumber->Append( achDigit, 1 );
        if ( FAILED( hr ) ) 
        {
            return hr;
        }   

        //
        // Do not append "-" after last digit of Serial Number
        //

        if( i != 0 )
        {
            
            hr = pstrSerialNumber->Append( "-", 1 ); 
            if ( FAILED( hr ) )
            {
                return hr;
            }
        }
    }
    
    return NO_ERROR;
}

HRESULT
CERTIFICATE_CONTEXT::DecodeCert(
    VOID
)
/*++

Routine Description:

    Decode client certificate into stuff needed to fill in some server 
    variables

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    DWORD                   cbBuffer;
    
    cbBuffer = _buffCertInfo.QuerySize();
        
    if ( !CryptDecodeObjectEx( X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                               X509_CERT_TO_BE_SIGNED,
                               _pClientCertInfo->pCertEncoded,
                               _pClientCertInfo->CertEncodedSize,
                               CRYPT_DECODE_NOCOPY_FLAG, //internal optimization flag
                               NULL,
                               _buffCertInfo.QueryPtr(),
                               &cbBuffer ) )
    {
        if ( GetLastError() == ERROR_MORE_DATA )
        {
            DBG_ASSERT( cbBuffer > _buffCertInfo.QuerySize() );
                
            if ( !_buffCertInfo.Resize( cbBuffer ) )
            {
                return HRESULT_FROM_WIN32( GetLastError() );
            }
                
            if ( !CryptDecodeObjectEx( X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                       X509_CERT_TO_BE_SIGNED,
                                       _pClientCertInfo->pCertEncoded,
                                       _pClientCertInfo->CertEncodedSize,
                                       CRYPT_DECODE_NOCOPY_FLAG,
                                       NULL,
                                       _buffCertInfo.QueryPtr(),
                                       &cbBuffer ) )
            {
                DBG_ASSERT( GetLastError() != ERROR_MORE_DATA );
                    
                return HRESULT_FROM_WIN32( GetLastError() );
            }
        }
        else
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }
    }
    
    _fCertDecoded = TRUE;
    
    return NO_ERROR;
}

HRESULT
CERTIFICATE_CONTEXT::GetSubject(
    STRA *                  pstrSubject
)
/*++

Routine Description:

    Get subject string for cert

Arguments:

    pstrSubject - Filled with subject string

Return Value:

    HRESULT

--*/
{
    STACK_BUFFER ( buffSubject, 256);
    HRESULT        hr;
    DWORD          cchSubject = 0;

    if ( pstrSubject == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // Decoding deferred until needed
    //
    
    if ( !_fCertDecoded )
    {
        hr = DecodeCert();
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        DBG_ASSERT( _fCertDecoded );
    }
    
    cchSubject  = CertNameToStrA( X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                  &(QueryCertInfo()->Subject),
                                  CERT_X500_NAME_STR,
                                  NULL,
                                  0 );
    if ( !buffSubject.Resize( cchSubject * sizeof (CHAR) ) )
    {
        return HRESULT_FROM_WIN32( ERROR_OUTOFMEMORY );
    }
    
    cchSubject  = CertNameToStrA( X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                  &(QueryCertInfo()->Subject),
                                  CERT_X500_NAME_STR,
                                  (CHAR *) buffSubject.QueryPtr(),
                                  buffSubject.QuerySize());
    
    DBG_ASSERT( cchSubject > 0 );
    return pstrSubject->Copy( (CHAR *) buffSubject.QueryPtr() );
}

HRESULT
CERTIFICATE_CONTEXT::GetCookie(
    STRA *                  pstrCookie
)
/*++

Routine Description:

    CERT_COOKIE server variable
    Cert cookie is legacy velue from IIS3 times
    Cookie = MD5(<issuer string> <serial number in binary>)

Arguments:

    pstrCookie - Filled with CERT_COOKIE

Return Value:

    HRESULT

--*/
{
    HRESULT             hr;
    HCRYPTHASH          cryptHash;
    STACK_STRA(         strIssuer, 256 );
    STACK_BUFFER(       buffFinal, 256);
    BYTE *              pbFinal;
    DWORD               cbFinal;
    CHAR                achDigit[ 2 ] = { '\0', '\0' };
    
    if ( pstrCookie == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // Decoding deferred until needed
    //
    
    if ( !_fCertDecoded )
    {
        hr = DecodeCert();
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        DBG_ASSERT( _fCertDecoded );
    }
    
    //
    // Cookie is MD5(<issuer string> <serial number in binary>)
    //
    
    hr = GetIssuer( &strIssuer );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    //
    // Begin the hashing
    //
    
    if ( !CryptCreateHash( sm_CryptProvider,
                           CALG_MD5,
                           0,
                           0,
                           &cryptHash ) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    if ( !CryptHashData( cryptHash,
                         (BYTE*) strIssuer.QueryStr(),
                         strIssuer.QueryCCH(),
                         0 ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        CryptDestroyHash( cryptHash );
        return hr;
    }
    
    if ( !CryptHashData( cryptHash,
                         QueryCertInfo()->SerialNumber.pbData,
                         QueryCertInfo()->SerialNumber.cbData,
                         0 ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        CryptDestroyHash( cryptHash );
        return hr;
    }
    
    //
    // Get the final hash value
    //
    
    cbFinal = buffFinal.QuerySize();
        
    if ( !CryptGetHashParam( cryptHash,
                             HP_HASHVAL,
                             (BYTE*) buffFinal.QueryPtr(),
                             &cbFinal,
                             0 ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        CryptDestroyHash( cryptHash );
        return hr;
    }
    
    CryptDestroyHash( cryptHash );
    
    //
    // Now ascii'ize the final hex string
    // 

    pbFinal = (BYTE*) buffFinal.QueryPtr();
    
    for ( DWORD i = 0; i < cbFinal; i++ )
    {
        achDigit[ 0 ] = HEX_DIGIT( ( pbFinal[ i ] & 0xF0 ) >> 4 );
        hr = pstrCookie->Append( achDigit, 1 );
        if ( FAILED( hr ) )
        {
            return hr;
        }
       
        achDigit[ 0 ] = HEX_DIGIT( ( pbFinal[ i ] & 0xF ) );
        hr = pstrCookie->Append( achDigit, 1 );
        if ( FAILED( hr ) ) 
        {
            return hr;
        }     
    }
    
    return NO_ERROR;
}

//static
HRESULT
CERTIFICATE_CONTEXT::Initialize(
    VOID
)
/*++

Routine Description:

    Do one time initialization of CRYPTO provider for doing MD5 hashes

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ALLOC_CACHE_CONFIGURATION       acConfig;
    
    if ( !CryptAcquireContext( &sm_CryptProvider,
                               NULL,
                               NULL,
                               PROV_RSA_FULL,
                               CRYPT_VERIFYCONTEXT ) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    DBG_ASSERT( sm_CryptProvider != NULL );
    
    //
    // Setup allocation lookaside
    //
    
    acConfig.nConcurrency = 1;
    acConfig.nThreshold = 100;
    acConfig.cbSize = sizeof( CERTIFICATE_CONTEXT );

    DBG_ASSERT( sm_pachCertContexts == NULL );
    
    sm_pachCertContexts = new ALLOC_CACHE_HANDLER( "CERTIFICATE_CONTEXT",
                                                   &acConfig );
    
    if ( sm_pachCertContexts == NULL || !sm_pachCertContexts->IsValid() )
    {
        if ( sm_pachCertContexts != NULL )
        {
            delete sm_pachCertContexts;
            sm_pachCertContexts = NULL;
        }
            
        CryptReleaseContext( sm_CryptProvider, 0 );
        sm_CryptProvider = NULL;
        
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }
    
    return NO_ERROR;
}

//static
VOID
CERTIFICATE_CONTEXT::Terminate(
    VOID
)
/*++

Routine Description:

    Global cleanup

Arguments:

    None

Return Value:

    None

--*/
{
    if ( sm_pachCertContexts != NULL )
    {
        delete sm_pachCertContexts;
        sm_pachCertContexts = NULL;
    }
    
    if ( sm_CryptProvider != NULL )
    {
        CryptReleaseContext( sm_CryptProvider, 0 );
        sm_CryptProvider = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\childcontext.cxx ===
/*++

   Copyright    (c)    2000    Microsoft Corporation

   Module Name :
     childcontext.cxx

   Abstract:
     Child context implementation
 
   Author:
     Bilal Alam (balam)             10-Mar-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"

ALLOC_CACHE_HANDLER *    W3_CHILD_CONTEXT::sm_pachChildContexts;

W3_CHILD_CONTEXT::W3_CHILD_CONTEXT(
    W3_MAIN_CONTEXT *           pMainContext,
    W3_CONTEXT *                pParentContext,
    W3_REQUEST *                pRequest,
    BOOL                        fOwnRequest,
    W3_USER_CONTEXT *           pCustomUserContext,
    DWORD                       dwExecFlags,
    BOOL                        fContinueStarScriptMapChain,
    DWORD                       dwRecursionLevel
)
  : W3_CONTEXT( dwExecFlags, dwRecursionLevel ),
    _pMainContext( pMainContext ),
    _pParentContext( pParentContext ),
    _pRequest( pRequest ),
    _fOwnRequest( fOwnRequest ),
    _pCustomUserContext( pCustomUserContext )
{
    //
    // If the parent context is disabling wildcards, custom errors, or
    // headers --> we should ensure those features are disabled for 
    // this context too
    //
    
    DBG_ASSERT( _pParentContext != NULL );
    
    if ( !_pParentContext->QuerySendCustomError() )
    {
        _dwExecFlags |= W3_FLAG_NO_CUSTOM_ERROR;
    }
    
    if ( !_pParentContext->QuerySendHeaders() )
    {
        _dwExecFlags |= W3_FLAG_NO_HEADERS;
    }
    
    if ( !_pParentContext->QuerySendErrorBody() )
    {
        _dwExecFlags |= W3_FLAG_NO_ERROR_BODY;
    }

    //
    // Get to the next *-ScriptMap
    //
    if (fContinueStarScriptMapChain)
    {
        _CurrentStarScriptMapIndex = _pParentContext->QueryCurrentStarScriptMapIndex() + 1;
    }
    else
    {
        _CurrentStarScriptMapIndex = 0;
    }

    //
    // Get the fAuthAccessCheckRequired flag from the main context so 
    // the child conext would know if we need to do auth access check 
    // or not.
    //
    DBG_ASSERT( _pMainContext != NULL );
    
    SetAuthAccessCheckRequired( _pMainContext->
                                  QueryAuthAccessCheckRequired() );
}

W3_CHILD_CONTEXT::~W3_CHILD_CONTEXT()
/*++

Routine Description:

    Deletes a child context.

Arguments:

    None

Return Value:

    None

--*/
{
    if ( _pUrlContext != NULL )
    {
        delete _pUrlContext;
        _pUrlContext = NULL;
    }
    
    //
    // Only delete the request object if we own it!  (we won't own it in
    // case where we're doing a "reprocessurl" 
    //
    
    if ( _pRequest )
    {
        if ( _fOwnRequest )
        {
            delete _pRequest;
            _pRequest = NULL;
        }
    }
    
    //
    // Clean up the custom user context if there is one
    //
    
    if ( _pCustomUserContext != NULL )
    {
        _pCustomUserContext->DereferenceUserContext();
        _pCustomUserContext = NULL;
    }
}

// static
HRESULT
W3_CHILD_CONTEXT::Initialize(
    VOID
)
/*++

Routine Description:

    Global initialization routine for W3_CHILD_CONTEXTs

Arguments:

    None
    
Return Value:

    HRESULT

--*/
{
    ALLOC_CACHE_CONFIGURATION       acConfig;
    HRESULT                         hr = NO_ERROR;

    //
    // Setup allocation lookaside
    //
    
    acConfig.nConcurrency = 1;
    acConfig.nThreshold = 100;
    acConfig.cbSize = sizeof( W3_CHILD_CONTEXT );

    DBG_ASSERT( sm_pachChildContexts == NULL );
    
    sm_pachChildContexts = new ALLOC_CACHE_HANDLER( "W3_CHILD_CONTEXT",  
                                                    &acConfig );

    if ( sm_pachChildContexts == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }
    
    return NO_ERROR;
}

// static
VOID
W3_CHILD_CONTEXT::Terminate(
    VOID
)
/*++

Routine Description:

    Terminate MAIN_CONTEXT globals

Arguments:

    None
    
Return Value:

    None

--*/
{
    if ( sm_pachChildContexts != NULL )
    {
        delete sm_pachChildContexts;
        sm_pachChildContexts = NULL;
    }
}

HRESULT
W3_CHILD_CONTEXT::RetrieveUrlContext(
    BOOL *                      pfFinished
)
/*++

Routine Description:

    Retrieves URL context for this context
    
Arguments:

    pfFinished - Set to TRUE if filter wants out

Return Value:

    HRESULT

--*/
{
    URL_CONTEXT *                   pUrlContext;
    HRESULT                         hr;
    
    if ( pfFinished == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    *pfFinished = FALSE;
    
    QueryMainContext()->PushCurrentContext( this );
    
    hr = URL_CONTEXT::RetrieveUrlContext( this,
                                          QueryRequest(),
                                          &pUrlContext,
                                          pfFinished );

    QueryMainContext()->PopCurrentContext();

    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    if ( *pfFinished )
    {
        return NO_ERROR;
    }
    
    DBG_ASSERT( pUrlContext != NULL );
    
    _pUrlContext = pUrlContext;
    
    //
    // Make sure we skip over any ignored *-ScriptMaps
    //
    META_SCRIPT_MAP *pScriptMap = _pUrlContext->QueryMetaData()->QueryScriptMap();
    META_SCRIPT_MAP_ENTRY *pScriptMapEntry;
    while (TRUE)
    {
        pScriptMapEntry = pScriptMap->QueryStarScriptMap( _CurrentStarScriptMapIndex );
        if (pScriptMapEntry == NULL ||
            !QueryMainContext()->IsIgnoredInterceptor(*pScriptMapEntry->QueryExecutable()))
        {
            break;
        }

        _CurrentStarScriptMapIndex++;
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\compressionapi.h ===
/*
 * api.h
 */
typedef HRESULT (WINAPI *PFNCODEC_INIT_COMPRESSION)(VOID);

typedef VOID (WINAPI *PFNCODEC_DEINIT_COMPRESSION)(VOID);

typedef HRESULT (WINAPI *PFNCODEC_CREATE_COMPRESSION)(PVOID *context, ULONG flags);

typedef HRESULT (WINAPI *PFNCODEC_COMPRESS)(
	PVOID		context, 
	CONST PBYTE	input, 
	LONG		input_size, 
	PBYTE		output, 
	LONG		output_size,
	PLONG		input_used,
	PLONG		output_used,
	INT			compression_level
);

typedef VOID (WINAPI *PFNCODEC_DESTROY_COMPRESSION)(PVOID context);

typedef HRESULT (WINAPI *PFNCODEC_RESET_COMPRESSION)(PVOID context);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\customprovider.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     customprovider.cxx

   Abstract:
     Authentication provider for arbitrary user-name/auth-type/token combo
     set by ISAPI during call to HSE_REQ_EXEC_URL
 
   Author:
     Bilal Alam (balam)             29-Nov-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL

--*/

#include "precomp.hxx"
#include "customprovider.hxx"

HRESULT
CUSTOM_USER_CONTEXT::Create(
    HANDLE          hImpersonationToken,
    BYTE *          pszUserName,
    BOOL            fIsUnicode,
    DWORD           dwAuthType
)
/*++

Routine Description:

    Initialize custom user context

Arguments:

    hImpersonationToken - Impersonation token for the custom user
    pszUserName - Custom user name
    dwAuthType - Auth type
    
Return Value:

    HRESULT

--*/
{
    HRESULT             hr;
    
    if ( hImpersonationToken == NULL ||
         pszUserName == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // Duplicate the token
    // 
   
    if ( !DuplicateTokenEx( hImpersonationToken,
                            TOKEN_ALL_ACCESS,
                            NULL,
                            SecurityImpersonation,
                            TokenImpersonation,
                            &_hImpersonationToken ) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    //
    // Copy the user name
    //

    if (fIsUnicode)
    {
        hr = _strUserName.Copy( (WCHAR *)pszUserName );
    }
    else
    {
        hr = _strUserName.CopyA( (CHAR *)pszUserName );
    }
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    _dwAuthType = dwAuthType;
    
    return NO_ERROR;
}

HANDLE
CUSTOM_USER_CONTEXT::QueryPrimaryToken(
    VOID
)
/*++

Routine Description:

    Get the primary token

Arguments:

    None
    
Return Value:

    HANDLE to primary token

--*/
{
    if ( _hPrimaryToken == NULL )
    {
        _Lock.WriteLock();
        
        if ( DuplicateTokenEx( _hImpersonationToken,
                               TOKEN_ALL_ACCESS,
                               NULL,
                               SecurityImpersonation,
                               TokenPrimary,
                               &_hPrimaryToken ) )
        {
            DBG_ASSERT( _hPrimaryToken != NULL );
        }

        _Lock.WriteUnlock();
    }
    
    return _hPrimaryToken;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\compress.cxx ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    compression.cxx

Abstract:

    Do Http compression

Author:

    Anil Ruia (AnilR)           10-Apr-2000

--*/

#include "precomp.hxx"

#define HTTP_COMPRESSION_KEY           L"/LM/w3svc/Filters/Compression"
#define HTTP_COMPRESSION_PARAMETERS    L"Parameters"
#define COMP_FILE_PREFIX               L"$^_"
#define TEMP_COMP_FILE_SUFFIX          L"~TMP~"

#define HEX_TO_ASCII(c) ((CHAR)((c) < 10 ? ((c) + '0') : ((c) + 'a' - 10)))

//
// static variables
//
COMPRESSION_SCHEME *HTTP_COMPRESSION::sm_pCompressionSchemes[MAX_SERVER_SCHEMES];
LIST_ENTRY          HTTP_COMPRESSION::sm_CompressionThreadWorkQueue;
CRITICAL_SECTION    HTTP_COMPRESSION::sm_CompressionThreadLock;
CRITICAL_SECTION    HTTP_COMPRESSION::sm_CompressionDirectoryLock;
DWORD  HTTP_COMPRESSION::sm_dwNumberOfSchemes           = 0;
STRU  *HTTP_COMPRESSION::sm_pstrCompressionDirectory    = NULL;
STRA  *HTTP_COMPRESSION::sm_pstrCacheControlHeader      = NULL;
STRA  *HTTP_COMPRESSION::sm_pstrExpiresHeader           = NULL;
BOOL   HTTP_COMPRESSION::sm_fDoStaticCompression        = FALSE;
BOOL   HTTP_COMPRESSION::sm_fDoDynamicCompression       = FALSE;
BOOL   HTTP_COMPRESSION::sm_fDoOnDemandCompression      = TRUE;
BOOL   HTTP_COMPRESSION::sm_fDoDiskSpaceLimiting        = FALSE;
BOOL   HTTP_COMPRESSION::sm_fNoCompressionForHttp10     = TRUE;
BOOL   HTTP_COMPRESSION::sm_fNoCompressionForProxies    = FALSE;
BOOL   HTTP_COMPRESSION::sm_fNoCompressionForRange      = TRUE;
BOOL   HTTP_COMPRESSION::sm_fSendCacheHeaders           = TRUE;
DWORD  HTTP_COMPRESSION::sm_dwMaxDiskSpaceUsage         = COMPRESSION_DEFAULT_DISK_SPACE_USAGE;
DWORD  HTTP_COMPRESSION::sm_dwIoBufferSize              = COMPRESSION_DEFAULT_BUFFER_SIZE;
DWORD  HTTP_COMPRESSION::sm_dwCompressionBufferSize     = COMPRESSION_DEFAULT_BUFFER_SIZE;
DWORD  HTTP_COMPRESSION::sm_dwMaxQueueLength            = COMPRESSION_DEFAULT_QUEUE_LENGTH;
DWORD  HTTP_COMPRESSION::sm_dwFilesDeletedPerDiskFree   = COMPRESSION_DEFAULT_FILES_DELETED_PER_DISK_FREE;
DWORD  HTTP_COMPRESSION::sm_dwMinFileSizeForCompression = COMPRESSION_DEFAULT_FILE_SIZE_FOR_COMPRESSION;
PBYTE  HTTP_COMPRESSION::sm_pIoBuffer                   = NULL;
PBYTE  HTTP_COMPRESSION::sm_pCompressionBuffer          = NULL;
DWORD  HTTP_COMPRESSION::sm_dwCurrentDiskSpaceUsage     = 0;
BOOL   HTTP_COMPRESSION::sm_fCompressionVolumeIsFat     = FALSE;
HANDLE HTTP_COMPRESSION::sm_hThreadEvent                = NULL;
HANDLE HTTP_COMPRESSION::sm_hCompressionThreadHandle    = NULL;
DWORD  HTTP_COMPRESSION::sm_dwCurrentQueueLength        = 0;
COMP_INIT_STATUS HTTP_COMPRESSION::sm_InitStatus        = COMP_INIT_NONE;
BOOL   HTTP_COMPRESSION::sm_fIsTerminating              = FALSE;

ALLOC_CACHE_HANDLER *COMPRESSION_CONTEXT::allocHandler;

// static
HRESULT HTTP_COMPRESSION::Initialize()
/*++
  Synopsis
    Initialize function called during Server startup

  Returns
    HRESULT
--*/
{
    HRESULT hr;
    MB mb(g_pW3Server->QueryMDObject());

    sm_InitStatus = COMP_INIT_NONE;

    //
    // Construct some static variables
    //
    sm_pstrCompressionDirectory = new STRU;
    sm_pstrCacheControlHeader = new STRA;
    sm_pstrExpiresHeader = new STRA;
    if (sm_pstrCompressionDirectory == NULL ||
        sm_pstrCacheControlHeader == NULL ||
        sm_pstrExpiresHeader == NULL)
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        goto Finished;
    }

    if (FAILED(hr = sm_pstrCompressionDirectory->Copy(
                        L"%windir%\\IIS Temporary Compressed Files")) ||
        FAILED(hr = sm_pstrCacheControlHeader->Copy("max-age=86400")) ||
        FAILED(hr = sm_pstrExpiresHeader->Copy(
                        "Wed, 01 Jan 1997 12:00:00 GMT")))
    {
        goto Finished;
    }

    if (!mb.Open(HTTP_COMPRESSION_KEY))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Finished;
    }

    //
    // Read the global configuration from the metabase
    //
    if (FAILED(hr = ReadMetadata(&mb)))
    {
        mb.Close();
        goto Finished;
    }

    //
    // Read in all the compression schemes and initialize them
    //
    if (FAILED(hr = InitializeCompressionSchemes(&mb)))
    {
        mb.Close();
        goto Finished;
    }

    mb.Close();

    sm_InitStatus = COMP_INIT_SCHEMES;

    //
    // Initialize other stuff
    //
    sm_pIoBuffer = new BYTE[sm_dwIoBufferSize];
    sm_pCompressionBuffer = new BYTE[sm_dwCompressionBufferSize];
    if (!sm_pIoBuffer || !sm_pCompressionBuffer)
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        goto Finished;
    }

    if ( !INITIALIZE_CRITICAL_SECTION(&sm_CompressionDirectoryLock) )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Finished;
    }

    sm_InitStatus = COMP_INIT_DIRLOCK;

    if (FAILED(hr = InitializeCompressionDirectory()))
    {
        goto Finished;
    }

    if (FAILED(hr = COMPRESSION_CONTEXT::Initialize()))
    {
        goto Finished;
    }

    sm_InitStatus = COMP_INIT_CONTEXT;

    if (FAILED(hr = InitializeCompressionThread()))
    {
        goto Finished;
    }

    sm_InitStatus = COMP_INIT_DONE;
    return S_OK;

 Finished:
    Terminate();
    return hr;
}


DWORD WINAPI HTTP_COMPRESSION::CompressionThread(LPVOID)
/*++
  Synopsis
    Entry point for the thread which takes Compression work-items off the
    queue and processes them

  Arguments and Return Values are ignored
--*/
{
    BOOL fTerminate = FALSE;

    while (!fTerminate)
    {
        //
        // Wait for some item to appear on the work queue
        //
        if (WaitForSingleObject(sm_hThreadEvent, INFINITE) == WAIT_FAILED)
        {
            DBG_ASSERT(FALSE);
        }

        EnterCriticalSection(&sm_CompressionThreadLock);

        while (!IsListEmpty(&sm_CompressionThreadWorkQueue))
        {
            LIST_ENTRY *listEntry =
                RemoveHeadList(&sm_CompressionThreadWorkQueue);
            sm_dwCurrentQueueLength--;

            LeaveCriticalSection(&sm_CompressionThreadLock);

            COMPRESSION_WORK_ITEM *workItem =
                CONTAINING_RECORD(listEntry,
                                  COMPRESSION_WORK_ITEM,
                                  ListEntry);

            //
            // Look at what the work item exactly is
            //
            if(workItem->WorkItemType == COMPRESSION_WORK_ITEM_TERMINATE)
            {
                fTerminate = TRUE;
            }
            else if (!fTerminate)
            {
                if (workItem->WorkItemType == COMPRESSION_WORK_ITEM_DELETE)
                {
                    //
                    // special scheme to indicate that this item is for
                    // deletion, not compression
                    //
                    DeleteFile(workItem->strPhysicalPath.QueryStr());
                }
                else if (workItem->WorkItemType == COMPRESSION_WORK_ITEM_COMPRESS)
                {
                    CompressFile(workItem->scheme,
                                 workItem->pFileInfo);
                }
                else
                {
                    DBG_ASSERT(FALSE);
                }
            }

            delete workItem;

            EnterCriticalSection(&sm_CompressionThreadLock);
        }

        LeaveCriticalSection(&sm_CompressionThreadLock);
    }

    //
    // We are terminating, close the Event handle
    //
    CloseHandle(sm_hThreadEvent);
    sm_hThreadEvent = NULL;
    return 0;
}


// static
HRESULT HTTP_COMPRESSION::InitializeCompressionThread()
/*++
  Initialize stuff related to the Compression Thread
--*/
{
    InitializeListHead(&sm_CompressionThreadWorkQueue);
    INITIALIZE_CRITICAL_SECTION(&sm_CompressionThreadLock);

    sm_hThreadEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (sm_hThreadEvent == NULL)
    {
        DeleteCriticalSection(&sm_CompressionThreadLock);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    DWORD threadId;
    sm_hCompressionThreadHandle = CreateThread(NULL,
                                               0, // Use the process default stack size
                                               CompressionThread,
                                               NULL, 0,
                                               &threadId);
    if (sm_hCompressionThreadHandle == NULL)
    {
        CloseHandle(sm_hThreadEvent);
        sm_hThreadEvent = NULL;
        DeleteCriticalSection(&sm_CompressionThreadLock);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    // CODEWORK: configurable?
    SetThreadPriority(sm_hCompressionThreadHandle, THREAD_PRIORITY_LOWEST);

    return S_OK;
}


// static
HRESULT HTTP_COMPRESSION::InitializeCompressionDirectory()
/*++
  Setup stuff related to the compression directory
--*/
{
    WIN32_FILE_ATTRIBUTE_DATA fileInformation;
    STACK_STRU (strPath, 256);
    HRESULT hr;

    //
    // Allow long paths to be specified
    //
    if (FAILED(hr = MakePathCanonicalizationProof(sm_pstrCompressionDirectory->QueryStr(),
                                                  &strPath)))
    {
        return hr;
    }

    //
    // Find if the directory exists, if not create it
    //
    if (!GetFileAttributesEx(strPath.QueryStr(),
                             GetFileExInfoStandard,
                             &fileInformation))
    {
        if (!CreateDirectory(strPath.QueryStr(), NULL))
        {
            LPCWSTR apsz[1];
            apsz[0] = sm_pstrCompressionDirectory->QueryStr();
            g_pW3Server->LogEvent(W3_EVENT_COMPRESSION_DIRECTORY_INVALID,
                                  1,
                                  apsz,
                                  GetLastError());

            return HRESULT_FROM_WIN32(GetLastError());
        }
    }
    else if (!(fileInformation.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
    {
        return HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND);
    }

    if (sm_fDoDiskSpaceLimiting)
    {
        sm_dwCurrentDiskSpaceUsage = 0;

        //
        // Find usage in the directory
        //

        if (FAILED(hr = strPath.Append(L"\\", 1)) ||
            FAILED(hr = strPath.Append(COMP_FILE_PREFIX)) ||
            FAILED(hr = strPath.Append(L"*", 1)))
        {
            return hr;
        }

        WIN32_FIND_DATA win32FindData;
        HANDLE hDirectory = FindFirstFile(strPath.QueryStr(),
                                          &win32FindData);
        if (hDirectory != INVALID_HANDLE_VALUE)
        {
            do
            {
                sm_dwCurrentDiskSpaceUsage += win32FindData.nFileSizeLow;
            }
            while (FindNextFile(hDirectory, &win32FindData));

            FindClose(hDirectory);
        }
    }

    //
    // Find if the Volume is FAT or NTFS, check for file change differs
    //
    WCHAR volumeRoot[10];
    volumeRoot[0] = sm_pstrCompressionDirectory->QueryStr()[0];
    volumeRoot[1] = L':';
    volumeRoot[2] = L'\\';
    volumeRoot[3] = L'\0';

    DWORD maximumComponentLength;
    DWORD fileSystemFlags;
    WCHAR fileSystemName[256];
    if (!GetVolumeInformation(volumeRoot, NULL, 0, NULL,
                              &maximumComponentLength,
                              &fileSystemFlags,
                              fileSystemName,
                              sizeof(fileSystemName)/sizeof(WCHAR)) ||
        !wcsncmp(L"FAT", fileSystemName, 3))
    {
        sm_fCompressionVolumeIsFat = TRUE;
    }
    else
    {
        sm_fCompressionVolumeIsFat = FALSE;
    }

    for (DWORD i=0; i<sm_dwNumberOfSchemes; i++)
    {
        STRU &filePrefix = sm_pCompressionSchemes[i]->m_strFilePrefix;

        if (FAILED(hr = filePrefix.Copy(*sm_pstrCompressionDirectory)) ||
            FAILED(hr = filePrefix.Append(L"\\", 1)) ||
            FAILED(hr = filePrefix.Append(COMP_FILE_PREFIX)) ||
            FAILED(hr = filePrefix.Append(
                sm_pCompressionSchemes[i]->m_strCompressionSchemeName)) ||
            FAILED(hr = filePrefix.Append(L"_", 1)))
        {
            return hr;
        }
    }

    return S_OK;
}


// static
HRESULT HTTP_COMPRESSION::InitializeCompressionSchemes(MB *pmb)
/*++
  Synopsis:
    Read in all the compression schemes and initialize them

  Arguments:
    pmb: pointer to the Metabase object

  Return Value
    HRESULT
--*/
{
    COMPRESSION_SCHEME *scheme;
    BOOL fExistStaticScheme = FALSE;
    BOOL fExistDynamicScheme = FALSE;
    BOOL fExistOnDemandScheme = FALSE;
    HRESULT hr;

    //
    // Enumerate all the scheme names under the main Compression key
    //
    WCHAR schemeName[METADATA_MAX_NAME_LEN + 1];
    for (DWORD schemeIndex = 0;
         pmb->EnumObjects(L"", schemeName, schemeIndex);
         schemeIndex++)
    {
        if (_wcsicmp(schemeName, HTTP_COMPRESSION_PARAMETERS) == 0)
        {
            continue;
        }

        scheme = new COMPRESSION_SCHEME;
        if (scheme == NULL)
        {
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }

        if (FAILED(hr = scheme->Initialize(pmb, schemeName)))
        {
            DBGPRINTF((DBG_CONTEXT, "Error initializing scheme, error %x\n", hr));
            delete scheme;
            continue;
        }

        if (scheme->m_fDoStaticCompression)
        {
            fExistStaticScheme = TRUE;
        }

        if (scheme->m_fDoDynamicCompression)
        {
            fExistDynamicScheme = TRUE;
        }

        if (scheme->m_fDoOnDemandCompression)
        {
            fExistOnDemandScheme = TRUE;
        }

        sm_pCompressionSchemes[sm_dwNumberOfSchemes++] = scheme;
        if (sm_dwNumberOfSchemes == MAX_SERVER_SCHEMES)
        {
            break;
        }
    }

    //
    // Sort the schemes by priority
    //
    for (DWORD i=0; i<sm_dwNumberOfSchemes; i++)
    {
        for (DWORD j=i+1; j<sm_dwNumberOfSchemes; j++)
        {
            if (sm_pCompressionSchemes[j]->m_dwPriority >
                sm_pCompressionSchemes[i]->m_dwPriority)
            {
                scheme = sm_pCompressionSchemes[j];
                sm_pCompressionSchemes[j] = sm_pCompressionSchemes[i];
                sm_pCompressionSchemes[i] = scheme;
            }
        }
    }

    if (!fExistStaticScheme)
    {
        sm_fDoStaticCompression = FALSE;
    }

    if (!fExistDynamicScheme)
    {
        sm_fDoDynamicCompression = FALSE;
    }

    if (!fExistOnDemandScheme)
    {
        sm_fDoOnDemandCompression = FALSE;
    }

    return S_OK;
}


//static
HRESULT HTTP_COMPRESSION::ReadMetadata(MB *pmb)
/*++
  Read all the global compression configuration
--*/
{
    BUFFER TempBuff;
    DWORD dwNumMDRecords;
    DWORD dwDataSetNumber;
    METADATA_GETALL_RECORD *pMDRecord;
    DWORD i;
    BOOL fExpandCompressionDirectory = TRUE;
    HRESULT hr;

    if (!pmb->GetAll(HTTP_COMPRESSION_PARAMETERS,
                     METADATA_INHERIT | METADATA_PARTIAL_PATH,
                     IIS_MD_UT_SERVER,
                     &TempBuff,
                     &dwNumMDRecords,
                     &dwDataSetNumber))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ErrorExit;
    }

    pMDRecord = (METADATA_GETALL_RECORD *)TempBuff.QueryPtr();

    for (i=0; i < dwNumMDRecords; i++, pMDRecord++)
    {
        PVOID pDataPointer = (PVOID) ((PCHAR)TempBuff.QueryPtr() +
                                          pMDRecord->dwMDDataOffset);

        DBG_ASSERT(pMDRecord->dwMDDataTag == 0);

        switch (pMDRecord->dwMDIdentifier)
        {
        case MD_HC_COMPRESSION_DIRECTORY:
            if (pMDRecord->dwMDDataType != STRING_METADATA &&
                pMDRecord->dwMDDataType != EXPANDSZ_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            if (pMDRecord->dwMDDataType == STRING_METADATA)
            {
                fExpandCompressionDirectory = FALSE;
            }

            if (FAILED(hr = sm_pstrCompressionDirectory->Copy(
                                (LPWSTR)pDataPointer)))
            {
                goto ErrorExit;
            }
            break;

        case MD_HC_CACHE_CONTROL_HEADER:
            if (pMDRecord->dwMDDataType != STRING_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            if (FAILED(hr = sm_pstrCacheControlHeader->CopyWTruncate(
                                (LPWSTR)pDataPointer)))
            {
                goto ErrorExit;
            }
            break;

        case MD_HC_EXPIRES_HEADER:
            if (pMDRecord->dwMDDataType != STRING_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            if (FAILED(hr = sm_pstrExpiresHeader->CopyWTruncate(
                                (LPWSTR)pDataPointer)))
            {
                goto ErrorExit;
            }
            break;

        case MD_HC_DO_DYNAMIC_COMPRESSION:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            sm_fDoDynamicCompression = *((BOOL *)pDataPointer);
            break;

        case MD_HC_DO_STATIC_COMPRESSION:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            sm_fDoStaticCompression = *((BOOL *)pDataPointer);
            break;

        case MD_HC_DO_ON_DEMAND_COMPRESSION:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            sm_fDoOnDemandCompression = *((BOOL *)pDataPointer);
            break;

        case MD_HC_DO_DISK_SPACE_LIMITING:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            sm_fDoDiskSpaceLimiting = *((BOOL *)pDataPointer);
            break;

        case MD_HC_NO_COMPRESSION_FOR_HTTP_10:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            sm_fNoCompressionForHttp10 = *((BOOL *)pDataPointer);
            break;

        case MD_HC_NO_COMPRESSION_FOR_PROXIES:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            sm_fNoCompressionForProxies = *((BOOL *)pDataPointer);
            break;

        case MD_HC_NO_COMPRESSION_FOR_RANGE:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            sm_fNoCompressionForRange = *((BOOL *)pDataPointer);
            break;

        case MD_HC_SEND_CACHE_HEADERS:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            sm_fSendCacheHeaders = *((BOOL *)pDataPointer);
            break;

        case MD_HC_MAX_DISK_SPACE_USAGE:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            sm_dwMaxDiskSpaceUsage = *((DWORD *)pDataPointer);
            break;

        case MD_HC_IO_BUFFER_SIZE:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            sm_dwIoBufferSize = *((DWORD *)pDataPointer);
            sm_dwIoBufferSize = max(COMPRESSION_MIN_IO_BUFFER_SIZE,
                                    sm_dwIoBufferSize);
            sm_dwIoBufferSize = min(COMPRESSION_MAX_IO_BUFFER_SIZE,
                                    sm_dwIoBufferSize);
            break;

        case MD_HC_COMPRESSION_BUFFER_SIZE:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            sm_dwCompressionBufferSize = *((DWORD *)pDataPointer);
            sm_dwCompressionBufferSize = max(COMPRESSION_MIN_COMP_BUFFER_SIZE,
                                             sm_dwCompressionBufferSize);
            sm_dwCompressionBufferSize = min(COMPRESSION_MAX_COMP_BUFFER_SIZE,
                                             sm_dwCompressionBufferSize);
            break;

        case MD_HC_MAX_QUEUE_LENGTH:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            sm_dwMaxQueueLength = *((DWORD *)pDataPointer);
            sm_dwMaxQueueLength = min(COMPRESSION_MAX_QUEUE_LENGTH,
                                      sm_dwMaxQueueLength);
            break;

        case MD_HC_FILES_DELETED_PER_DISK_FREE:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            sm_dwFilesDeletedPerDiskFree = *((DWORD *)pDataPointer);
            sm_dwFilesDeletedPerDiskFree =
                max(COMPRESSION_MIN_FILES_DELETED_PER_DISK_FREE,
                    sm_dwFilesDeletedPerDiskFree);
            sm_dwFilesDeletedPerDiskFree =
                min(COMPRESSION_MAX_FILES_DELETED_PER_DISK_FREE,
                    sm_dwFilesDeletedPerDiskFree);
            break;

        case MD_HC_MIN_FILE_SIZE_FOR_COMP:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            sm_dwMinFileSizeForCompression = *((DWORD *)pDataPointer);
            break;

        default:
            ;
        }
    }

    //
    // The compression directory name contains an environment vairable,
    // expand it
    //
    if (fExpandCompressionDirectory)
    {
        STACK_BUFFER (bufCompressionDir, 256);
        DWORD cchRet = ExpandEnvironmentStrings(
                            sm_pstrCompressionDirectory->QueryStr(),
                            (LPWSTR)bufCompressionDir.QueryPtr(),
                            bufCompressionDir.QuerySize()/sizeof(WCHAR));
        if (cchRet == 0)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto ErrorExit;
        }

        if (cchRet > bufCompressionDir.QuerySize()/sizeof(WCHAR))
        {
            if (!bufCompressionDir.Resize(cchRet * sizeof(WCHAR)))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto ErrorExit;
            }

            cchRet = ExpandEnvironmentStrings(
                            sm_pstrCompressionDirectory->QueryStr(),
                            (LPWSTR)bufCompressionDir.QueryPtr(),
                            bufCompressionDir.QuerySize()/sizeof(WCHAR));
            if (cchRet == 0 ||
                cchRet > bufCompressionDir.QuerySize()/sizeof(WCHAR))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto ErrorExit;
            }
        }

        sm_pstrCompressionDirectory->Copy((LPWSTR)bufCompressionDir.QueryPtr());
    }

    return S_OK;

 ErrorExit:
    return hr;
}


HRESULT COMPRESSION_SCHEME::Initialize(
     IN MB *pmb,
     IN LPWSTR schemeName)
/*++
  Initialize all the scheme specific data for the given scheme
--*/
{
    BUFFER TempBuff;
    DWORD dwNumMDRecords;
    DWORD dwDataSetNumber;
    HRESULT hr;
    METADATA_GETALL_RECORD *pMDRecord;
    DWORD i;
    STACK_STRU (strCompressionDll, 256);
    HMODULE compressionDll = NULL;

    //
    // Copy the scheme name
    //
    if (FAILED(hr = m_strCompressionSchemeName.Copy(schemeName)) ||
        FAILED(hr = m_straCompressionSchemeName.CopyWTruncate(schemeName)))
    {
        return hr;
    }

    //
    // First get all the metabase data
    //
    if (!pmb->GetAll(schemeName,
                     METADATA_INHERIT | METADATA_PARTIAL_PATH,
                     IIS_MD_UT_SERVER,
                     &TempBuff,
                     &dwNumMDRecords,
                     &dwDataSetNumber))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ErrorExit;
    }

    pMDRecord = (METADATA_GETALL_RECORD *)TempBuff.QueryPtr();

    for (i=0; i < dwNumMDRecords; i++, pMDRecord++)
    {
        PVOID pDataPointer = (PVOID) ((PCHAR)TempBuff.QueryPtr() +
                                          pMDRecord->dwMDDataOffset);

        DBG_ASSERT( pMDRecord->dwMDDataTag == 0);

        switch (pMDRecord->dwMDIdentifier)
        {
        case MD_HC_COMPRESSION_DLL:
            if (pMDRecord->dwMDDataType != STRING_METADATA &&
                pMDRecord->dwMDDataType != EXPANDSZ_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            if (pMDRecord->dwMDDataType == EXPANDSZ_METADATA)
            {
                WCHAR CompressionDll[MAX_PATH + 1];
                if (!ExpandEnvironmentStrings((LPWSTR)pDataPointer,
                                              CompressionDll,
                                              sizeof CompressionDll/sizeof WCHAR))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    goto ErrorExit;
                }

                hr = strCompressionDll.Copy(CompressionDll);
            }
            else
            {
                hr = strCompressionDll.Copy((LPWSTR)pDataPointer);
            }

            if (FAILED(hr))
            {
                goto ErrorExit;
            }
            break;

        case MD_HC_DO_DYNAMIC_COMPRESSION:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            m_fDoDynamicCompression = *((BOOL *)pDataPointer);
            break;

        case MD_HC_DO_STATIC_COMPRESSION:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            m_fDoStaticCompression = *((BOOL *)pDataPointer);
            break;

        case MD_HC_DO_ON_DEMAND_COMPRESSION:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            m_fDoOnDemandCompression = *((BOOL *)pDataPointer);
            break;

        case MD_HC_FILE_EXTENSIONS:
            if (pMDRecord->dwMDDataType != MULTISZ_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            {
                MULTISZ mszTemp((LPWSTR)pDataPointer);
                m_mszFileExtensions.Copy(mszTemp);
            }

            break;

        case MD_HC_SCRIPT_FILE_EXTENSIONS:
            if (pMDRecord->dwMDDataType != MULTISZ_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            {
                MULTISZ mszTemp((LPWSTR)pDataPointer);
                m_mszScriptFileExtensions.Copy(mszTemp);
            }

            break;

        case MD_HC_PRIORITY:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            m_dwPriority = *((DWORD *)pDataPointer);
            break;

        case MD_HC_DYNAMIC_COMPRESSION_LEVEL:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            m_dwDynamicCompressionLevel = *((DWORD *)pDataPointer);
            m_dwDynamicCompressionLevel =
                min(COMPRESSION_MAX_COMPRESSION_LEVEL,
                    m_dwDynamicCompressionLevel);
            break;

        case MD_HC_ON_DEMAND_COMP_LEVEL:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            m_dwOnDemandCompressionLevel = *((DWORD *)pDataPointer);
            m_dwOnDemandCompressionLevel =
                min(COMPRESSION_MAX_COMPRESSION_LEVEL,
                    m_dwOnDemandCompressionLevel);
            break;

        case MD_HC_CREATE_FLAGS:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            m_dwCreateFlags = *((DWORD *)pDataPointer);
            break;

        default:
            ;
        }
    }

    //
    // Now, get the dll and the entry-points
    //
    compressionDll = LoadLibrary(strCompressionDll.QueryStr());
    if (compressionDll == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ErrorExit;
    }
    m_pfnInitCompression = (PFNCODEC_INIT_COMPRESSION)
        GetProcAddress(compressionDll, "InitCompression");
    m_pfnDeInitCompression = (PFNCODEC_DEINIT_COMPRESSION)
        GetProcAddress(compressionDll, "DeInitCompression");
    m_pfnCreateCompression = (PFNCODEC_CREATE_COMPRESSION)
        GetProcAddress(compressionDll, "CreateCompression");
    m_pfnCompress = (PFNCODEC_COMPRESS)
        GetProcAddress(compressionDll, "Compress");
    m_pfnDestroyCompression = (PFNCODEC_DESTROY_COMPRESSION)
        GetProcAddress(compressionDll, "DestroyCompression");
    m_pfnResetCompression = (PFNCODEC_RESET_COMPRESSION)
        GetProcAddress(compressionDll, "ResetCompression");

    if (!m_pfnInitCompression    ||
        !m_pfnDeInitCompression  ||
        !m_pfnCreateCompression  ||
        !m_pfnCompress           ||
        !m_pfnDestroyCompression ||
        !m_pfnResetCompression)
    {
        hr = HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
        goto ErrorExit;
    }

    //
    // Call the initialize entry-point
    //
    if (FAILED(hr = m_pfnInitCompression()) ||
        FAILED(hr = m_pfnCreateCompression(&m_pCompressionContext,
                                           m_dwCreateFlags)))
    {
        goto ErrorExit;
    }

    m_hCompressionDll = compressionDll;

    return S_OK;

 ErrorExit:
    if (compressionDll)
    {
        FreeLibrary(compressionDll);
    }
    return hr;
}


// static
BOOL HTTP_COMPRESSION::QueueWorkItem (
    IN COMPRESSION_WORK_ITEM   *WorkItem,
    IN BOOL                     fOverrideMaxQueueLength,
    IN BOOL                     fQueueAtHead)
/*++
  Routine Description:
    This is the routine that handles queuing work items to the compression
    thread.

Arguments:
    WorkRoutine - the routine that the compression thread should call
        to do work.  If NULL, then the call is an indication to the
        compression thread that it should terminate.

    Context - a context pointer which is passed to WorkRoutine.

    WorkItem - if not NULL, this is a pointer to the work item to use
        for this request.  If NULL, then this routine will allocate a
        work item to use.  Note that by passing in a work item, the
        caller agrees to give up control of the memory: we will free it
        as necessary, either here or in the compression thread.

    MustSucceed - if TRUE, then this request is not subject to the
        limits on the number of work items that can be queued at any one
        time.

    QueueAtHead - if TRUE, then this work item is placed at the head
        of the queue to be serviced immediately.

Return Value:
    TRUE if the queuing succeeded.
--*/
{
    DBG_ASSERT(WorkItem != NULL);

    //
    // Acquire the lock that protects the work queue list test to see
    // how many items we have on the queue.  If this is not a "must
    // succeed" request and if we have reached the configured queue size
    // limit, then fail this request.  "Must succeed" requests are used
    // for thread shutdown and other things which we really want to
    // work.
    //

    EnterCriticalSection(&sm_CompressionThreadLock);

    if (!fOverrideMaxQueueLength &&
        (sm_dwCurrentQueueLength >= sm_dwMaxQueueLength))
    {
        LeaveCriticalSection(&sm_CompressionThreadLock);
        return FALSE;
    }

    //
    // All looks good, so increment the count of items on the queue and
    // add this item to the queue.
    //

    sm_dwCurrentQueueLength++;

    if (fQueueAtHead)
    {
        InsertHeadList(&sm_CompressionThreadWorkQueue, &WorkItem->ListEntry);
    }
    else
    {
        InsertTailList(&sm_CompressionThreadWorkQueue, &WorkItem->ListEntry);
    }

    LeaveCriticalSection(&sm_CompressionThreadLock);

    //
    // Signal the event that will cause the compression thread to wake
    // up and process this work item.
    //

    SetEvent(sm_hThreadEvent);

    return TRUE;
}


// static
VOID HTTP_COMPRESSION::Terminate()
/*++
  Called on server shutdown
--*/
{
    sm_fIsTerminating = TRUE;

    switch (sm_InitStatus)
    {
    case COMP_INIT_DONE:
    {
        //
        // Make the CompressionThread terminate by queueing a work item
        // indicating that
        //
        COMPRESSION_WORK_ITEM *WorkItem = new COMPRESSION_WORK_ITEM;

        if (WorkItem == NULL)
        {
            // if we can't even allocate this much memory, skip the rest of
            // the termination and exit
            return;
        }

        WorkItem->WorkItemType = COMPRESSION_WORK_ITEM_TERMINATE;

        QueueWorkItem(WorkItem, TRUE, TRUE);
        WaitForSingleObject(sm_hCompressionThreadHandle, INFINITE);
        CloseHandle(sm_hCompressionThreadHandle);
        sm_hCompressionThreadHandle = NULL;
        DeleteCriticalSection(&sm_CompressionThreadLock);
    }

    case COMP_INIT_CONTEXT:
        COMPRESSION_CONTEXT::Terminate();

    case COMP_INIT_DIRLOCK:
        DeleteCriticalSection(&sm_CompressionDirectoryLock);

    case COMP_INIT_SCHEMES:
        //
        // For each compression scheme, unload the compression dll and free
        // the space that holds info about the scheme
        //
        for (DWORD i=0; i<sm_dwNumberOfSchemes; i++)
        {
            delete sm_pCompressionSchemes[i];
        }

    case COMP_INIT_NONE:
        //
        // Free static objects
        //
        if (sm_pstrCompressionDirectory != NULL)
        {
            delete sm_pstrCompressionDirectory;
            sm_pstrCompressionDirectory = NULL;
        }

        if (sm_pstrCacheControlHeader != NULL)
        {
            delete sm_pstrCacheControlHeader;
            sm_pstrCacheControlHeader = NULL;
        }

        if (sm_pstrExpiresHeader != NULL)
        {
            delete sm_pstrExpiresHeader;
            sm_pstrExpiresHeader = NULL;
        }

        if (sm_pIoBuffer != NULL)
        {
            delete sm_pIoBuffer;
            sm_pIoBuffer = NULL;
        }

        if (sm_pCompressionBuffer != NULL)
        {
            delete sm_pCompressionBuffer;
            sm_pCompressionBuffer = NULL;
        }

    }
}


// static
HRESULT HTTP_COMPRESSION::DoStaticFileCompression(
            IN     W3_CONTEXT    *pW3Context,
            IN OUT W3_FILE_INFO **ppOpenFile,
               OUT BOOL          *pfDoCache)
/*++
  Synopsis:
    Handle compression of static file request by either sending back the
    compression version if present and applicable or queueing a work-item
    to compress it for future requests.  Called by
    W3_STATIC_FILE_HANDLER::FileDoWork

  Arguments:
    pW3Context: The W3_CONTEXT for the request
    ppOpenFile: On entry contains the cache entry to the physical path.
        If a suitable file is found, on exit contains cach entry to the
        compressed file
    pfDoCache: On exit, indicates whether this file should be cached
        in http.sys, basically we only cache compressible files if they
        are compressed

  Returns:
    HRESULT
--*/
{
    *pfDoCache = FALSE;

    //
    // If compression is not initialized, return
    //
    if (sm_InitStatus != COMP_INIT_DONE)
    {
        pW3Context->SetDoneWithCompression();
        return S_OK;
    }

    //
    // If the client has not sent an Accept-Encoding header, or an empty
    // Accept-Encoding header, return
    //
    W3_REQUEST *pRequest = pW3Context->QueryRequest();
    LPCSTR pszAcceptEncoding = pRequest->GetHeader(HttpHeaderAcceptEncoding);
    if (pszAcceptEncoding == NULL || *pszAcceptEncoding == '\0')
    {
        pW3Context->SetDoneWithCompression();
        return S_OK;
    }

    //
    // If we are configured to not compress for 1.0, and version is not 1.1,
    // return
    //
    if (sm_fNoCompressionForHttp10 &&
        ((pRequest->QueryVersion().MajorVersion == 0) ||
         ((pRequest->QueryVersion().MajorVersion == 1) &&
          (pRequest->QueryVersion().MinorVersion == 0))))
    {
        pW3Context->SetDoneWithCompression();
        return S_OK;
    }

    //
    // If we are configured to not compress for proxies and it is a proxy
    // request, return
    //
    if (sm_fNoCompressionForProxies && pRequest->IsProxyRequest())
    {
        pW3Context->SetDoneWithCompression();
        return S_OK;
    }

    //
    // If we are configured to not Compress for range requests and Range
    // is present, return
    // BUGBUG: Is the correct behavior to take range on the original request
    // and compress those chunks or take range on the compressed file?  We do
    // the latter (same as IIS 5.0), figure out if that is correct.
    //
    if (sm_fNoCompressionForRange &&
        pRequest->GetHeader(HttpHeaderRange))
    {
        pW3Context->SetDoneWithCompression();
        return S_OK;
    }

    //
    // If file is too small, return
    //
    W3_FILE_INFO *pOrigFile = *ppOpenFile;
    ULARGE_INTEGER originalFileSize;
    pOrigFile->QuerySize(&originalFileSize);
    if (originalFileSize.QuadPart < sm_dwMinFileSizeForCompression)
    {
        *pfDoCache = TRUE;
        pW3Context->SetDoneWithCompression();
        return S_OK;
    }

    //
    // If the file is encrypted, return
    //
    if ( pOrigFile->QueryAttributes() & FILE_ATTRIBUTE_ENCRYPTED )
    {
        *pfDoCache = TRUE;
        pW3Context->SetDoneWithCompression();
        return S_OK;
    }

    //
    // Break the accept-encoding header into all the encoding accepted by
    // the client sorting using the quality value
    //

    STACK_STRA( strAcceptEncoding, 512);
    HRESULT hr;
    if (FAILED(hr = strAcceptEncoding.Copy(pszAcceptEncoding)))
    {
        return hr;
    }

    STRU *pstrPhysical = pW3Context->QueryUrlContext()->QueryPhysicalPath();
    LPWSTR pszExtension = wcsrchr(pstrPhysical->QueryStr(), L'.');
    if (pszExtension != NULL)
    {
        pszExtension++;
    }

    DWORD dwClientCompressionCount;
    DWORD matchingSchemes[MAX_SERVER_SCHEMES];
    //
    // Find out all schemes which will compress for this file
    //
    FindMatchingSchemes(strAcceptEncoding.QueryStr(),
                        pszExtension,
                        DO_STATIC_COMPRESSION,
                        matchingSchemes,
                        &dwClientCompressionCount);

    if (dwClientCompressionCount == 0)
    {
        *pfDoCache = TRUE;
    }

    //
    // Try to find a static scheme, which already has the file
    // pre-compressed
    //
    COMPRESSION_SCHEME *firstOnDemandScheme = NULL;
    STACK_STRU (strCompressedFileName, 256);
    for (DWORD i=0; i<dwClientCompressionCount; i++)
    {
        COMPRESSION_SCHEME *scheme = sm_pCompressionSchemes[matchingSchemes[i]];

        //
        // Now, see if there exists a version of the requested file
        // that has been compressed with that scheme.  First, calculate
        // the name the file would have.  The compressed file will live
        // in the special compression directory with a special converted
        // name.  The file name starts with the compression scheme used,
        // then the fully qualified file name where slashes and colons
        // have been converted to underscores.  For example, the gzip
        // version of "c:\inetpub\wwwroot\file.htm" would be
        // "c:\compdir\$^_gzip^c^^inetpub^wwwroot^file.htm".
        //

        if (FAILED(hr = ConvertPhysicalPathToCompressedPath(
                            scheme,
                            pstrPhysical,
                            &strCompressedFileName)))
        {
            return hr;
        }

        W3_FILE_INFO *pCompFile;
        if (CheckForExistenceOfCompressedFile(
                pOrigFile,
                &strCompressedFileName,
                &pCompFile))
        {
            //
            // Bingo--we have a compressed version of the file in a
            // format that the client understands.  Add the appropriate
            // Content-Encoding header so that the client knows it is
            // getting compressed data and change the server's mapping
            // to the compressed version of the file.
            //

            W3_RESPONSE *pResponse = pW3Context->QueryResponse();
            if (FAILED(hr = pResponse->SetHeaderByReference(
                              HttpHeaderContentEncoding,
                              scheme->m_straCompressionSchemeName.QueryStr(),
                              (USHORT)scheme->m_straCompressionSchemeName.QueryCCH())))
            {
                pCompFile->DereferenceCacheEntry();
                return hr;
            }

            if (sm_fSendCacheHeaders)
            {
                if (FAILED(hr = pResponse->SetHeaderByReference(
                                    HttpHeaderExpires,
                                    sm_pstrExpiresHeader->QueryStr(),
                                    (USHORT)sm_pstrExpiresHeader->QueryCCH())) ||
                    FAILED(hr = pResponse->SetHeader(
                                    HttpHeaderCacheControl,
                                    sm_pstrCacheControlHeader->QueryStr(),
                                    (USHORT)sm_pstrCacheControlHeader->QueryCCH(),
                                    TRUE)))
                {
                    pCompFile->DereferenceCacheEntry();
                    return hr;
                }
            }

            if (FAILED(hr = pResponse->SetHeaderByReference(
                                           HttpHeaderVary,
                                           "Accept-Encoding", 15)))
            {
                pCompFile->DereferenceCacheEntry();
                return hr;
            }

            *pfDoCache = TRUE;
            pW3Context->SetDoneWithCompression();

            //
            // Change the cache entry to point to the new file and close
            // the original file
            //
            *ppOpenFile = pCompFile;
            pOrigFile->DereferenceCacheEntry();

            return S_OK;
        }

        //
        // We found a scheme, but we don't have a matching file for it.
        // Remember whether this was the first matching scheme that
        // supports on-demand compression.  In the event that we do not
        // find any acceptable files, we'll attempt to do an on-demand
        // compression for this file so that future requests get a
        // compressed version.
        //

        if (firstOnDemandScheme == NULL &&
            scheme->m_fDoOnDemandCompression)
        {
            firstOnDemandScheme = scheme;
        }

        //
        // Loop to see if there is another scheme that is supported
        // by both client and server.
        //
    }

    if (sm_fDoOnDemandCompression && firstOnDemandScheme != NULL)
    {
        //
        // if we are here means scheme was found but no compressed
        // file matching any scheme. So schedule file to compress
        //
        QueueCompressFile(firstOnDemandScheme,
                          pOrigFile);
    }

    //
    // No static compression for this request, will try dynamic compression
    // if so configured while sending response
    //
    return S_OK;
}


// static
VOID HTTP_COMPRESSION::FindMatchingSchemes(
    IN  CHAR * pszAcceptEncoding,
    IN  LPWSTR pszExtension,
    IN  COMPRESSION_TO_PERFORM performCompr,
    OUT DWORD  matchingSchemes[],
    OUT DWORD *pdwClientCompressionCount)
{
    struct
    {
        LPSTR schemeName;
        float quality;
    } parsedAcceptEncoding[MAX_SERVER_SCHEMES];
    DWORD NumberOfParsedSchemes = 0;

    //
    // First parse the Accept-Encoding header
    //
    BOOL fAddStar = FALSE;
    while (*pszAcceptEncoding != '\0')
    {
        LPSTR schemeEnd = NULL;
        BOOL fStar = FALSE;

        while (*pszAcceptEncoding == ' ')
        {
            pszAcceptEncoding++;
        }

        if (isalnum(*pszAcceptEncoding))
        {
            parsedAcceptEncoding[NumberOfParsedSchemes].schemeName =
                pszAcceptEncoding;
            parsedAcceptEncoding[NumberOfParsedSchemes].quality = 1;

            while (isalnum(*pszAcceptEncoding))
            {
                pszAcceptEncoding++;
            }

            // Mark the end of the scheme name
            schemeEnd = pszAcceptEncoding;
        }
        else if (*pszAcceptEncoding == '*')
        {
            fStar = TRUE;
            parsedAcceptEncoding[NumberOfParsedSchemes].quality = 1;

            pszAcceptEncoding++;
        }
        else
        {
            // incorrect syntax
            break;
        }

        while (*pszAcceptEncoding == ' ')
        {
            pszAcceptEncoding++;
        }

        if (*pszAcceptEncoding == ';')
        {
            // quality specifier: looks like q=0.7
            pszAcceptEncoding++;

            while (*pszAcceptEncoding == ' ')
            {
                pszAcceptEncoding++;
            }

            if (*pszAcceptEncoding == 'q')
            {
                pszAcceptEncoding++;
            }
            else
            {
                break;
            }

            while (*pszAcceptEncoding == ' ')
            {
                pszAcceptEncoding++;
            }

            if (*pszAcceptEncoding == '=')
            {
                pszAcceptEncoding++;
            }
            else
            {
                break;
            }

            while (*pszAcceptEncoding == ' ')
            {
                pszAcceptEncoding++;
            }

            parsedAcceptEncoding[NumberOfParsedSchemes].quality =
                atof(pszAcceptEncoding);

            while (*pszAcceptEncoding && *pszAcceptEncoding != ',')
            {
                pszAcceptEncoding++;
            }
        }

        if (*pszAcceptEncoding == ',')
        {
            pszAcceptEncoding++;
        }

        if (fStar)
        {
            //
            // A star with non-zero quality means that all schemes are
            // acceptable except those explicitly unacceptable
            //
            if (parsedAcceptEncoding[NumberOfParsedSchemes].quality != 0)
            {
                fAddStar = TRUE;
            }
        }
        else
        {
            *schemeEnd = '\0';
            NumberOfParsedSchemes++;
            if (NumberOfParsedSchemes >= MAX_SERVER_SCHEMES)
            {
                break;
            }
        }
    }

    //
    // Now sort by quality
    //
    LPSTR tempName;
    float tempQuality;
    for (DWORD i=0; i<NumberOfParsedSchemes; i++)
    {
        for (DWORD j=i+1; j<NumberOfParsedSchemes; j++)
        {
            if (parsedAcceptEncoding[j].quality >
                parsedAcceptEncoding[i].quality)
            {
                tempName = parsedAcceptEncoding[i].schemeName;
                parsedAcceptEncoding[i].schemeName = parsedAcceptEncoding[j].schemeName;
                parsedAcceptEncoding[j].schemeName = tempName;

                tempQuality = parsedAcceptEncoding[i].quality;
                parsedAcceptEncoding[i].quality = parsedAcceptEncoding[j].quality;
                parsedAcceptEncoding[j].quality = tempQuality;
            }
        }
    }

    //
    // Now convert the names to indexes into actual schemes
    //
    BOOL fAddedScheme[MAX_SERVER_SCHEMES];
    for (i=0; i<sm_dwNumberOfSchemes; i++)
    {
        fAddedScheme[i] = FALSE;
    }

    DWORD dwNumberOfActualSchemes = 0;
    for (i=0; i<NumberOfParsedSchemes; i++)
    {
        //
        // Find this scheme
        //
        for (DWORD j=0; j<sm_dwNumberOfSchemes; j++)
        {
            if (!fAddedScheme[j] &&
                !_stricmp(parsedAcceptEncoding[i].schemeName,
                         sm_pCompressionSchemes[j]->
                         m_straCompressionSchemeName.QueryStr()))
            {
                // found a match
                fAddedScheme[j] = TRUE;

                if (parsedAcceptEncoding[i].quality == 0)
                {
                    break;
                }

                //
                // Check if the given scheme does the required kind of
                // compression.  Also, check that either there is no list
                // of restricted extensions or that the given file extension
                // matches one in the list
                //
                if (performCompr == DO_STATIC_COMPRESSION)
                {
                    if (!sm_pCompressionSchemes[j]->m_fDoStaticCompression ||
                        (sm_pCompressionSchemes[j]->m_mszFileExtensions.QueryStringCount() &&
                         (!pszExtension ||
                          !sm_pCompressionSchemes[j]->m_mszFileExtensions.FindStringNoCase(pszExtension))))
                    {
                        break;
                    }
                }
                else
                {
                    if (!sm_pCompressionSchemes[j]->m_fDoDynamicCompression ||
                        (sm_pCompressionSchemes[j]->m_mszScriptFileExtensions.QueryStringCount() &&
                         (!pszExtension ||
                          !sm_pCompressionSchemes[j]->m_mszScriptFileExtensions.FindStringNoCase(pszExtension))))
                    {
                        break;
                    }
                }

                matchingSchemes[dwNumberOfActualSchemes++] = j;
                break;
            }
        }
    }

    //
    // If * was specified, add all unadded applicable schemes
    //
    if (fAddStar)
    {
        for (DWORD j=0; j<sm_dwNumberOfSchemes; j++)
        {
            if (!fAddedScheme[j])
            {
                fAddedScheme[j] = TRUE;

                //
                // Check if the given scheme does the required kind of
                // compression.  Also, check that either there is no list
                // of restricted extensions or that the given file extension
                // matches one in the list
                //
                if (performCompr == DO_STATIC_COMPRESSION)
                {
                    if (!sm_pCompressionSchemes[j]->m_fDoStaticCompression ||
                        (sm_pCompressionSchemes[j]->m_mszFileExtensions.QueryStringCount() &&
                         (!pszExtension ||
                          !sm_pCompressionSchemes[j]->m_mszFileExtensions.FindStringNoCase(pszExtension))))
                    {
                        continue;
                    }
                }
                else
                {
                    if (!sm_pCompressionSchemes[j]->m_fDoDynamicCompression ||
                        (sm_pCompressionSchemes[j]->m_mszScriptFileExtensions.QueryStringCount() &&
                         (!pszExtension ||
                          !sm_pCompressionSchemes[j]->m_mszScriptFileExtensions.FindStringNoCase(pszExtension))))
                    {
                        continue;
                    }
                }

                matchingSchemes[dwNumberOfActualSchemes++] = j;
            }
        }
    }

    *pdwClientCompressionCount = dwNumberOfActualSchemes;
}


// static
HRESULT HTTP_COMPRESSION::ConvertPhysicalPathToCompressedPath(
    IN COMPRESSION_SCHEME *scheme,
    IN STRU  *pstrPhysicalPath,
    OUT STRU *pstrCompressedPath)
/*++
  Routine Description:
    Builds a string that has the directory for the specified compression
    scheme, followed by the file name with all slashes and colons
    converted to underscores.  This allows for a flat directory which
    contains all the compressed files.

Arguments:
    Scheme - the compression scheme to use.

    pstrPhysicalPath - the physical file name that we want to convert.

    pstrCompressedPath - the resultant string.

  Return Value:
    HRESULT
--*/

{
    HRESULT hr;

    EnterCriticalSection(&sm_CompressionDirectoryLock);

    hr = pstrCompressedPath->Copy(scheme->m_strFilePrefix);

    LeaveCriticalSection(&sm_CompressionDirectoryLock);

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // Copy over the actual file name, converting slashes and colons
    // to underscores.
    //

    DWORD cchPathLength = pstrCompressedPath->QueryCCH();
    if (FAILED(hr = pstrCompressedPath->Append(*pstrPhysicalPath)))
    {
        return hr;
    }

    for (LPWSTR s = pstrCompressedPath->QueryStr() + cchPathLength;
         *s != L'\0';
         s++)
    {
        if (*s == L'\\' || *s == L':')
        {
            *s = L'^';
        }
    }

    return S_OK;
}


BOOL HTTP_COMPRESSION::CheckForExistenceOfCompressedFile(
    IN  W3_FILE_INFO  *pOrigFile,
    IN  STRU          *pstrFileName,
    OUT W3_FILE_INFO **ppCompFile,
    IN  BOOL           fDeleteAllowed)
{
    HRESULT                 hr;
    CACHE_USER              fileUser;

    DBG_ASSERT( g_pW3Server->QueryFileCache() != NULL );

    hr = g_pW3Server->QueryFileCache()->GetFileInfo(
                                        *pstrFileName,
                                        NULL,
                                        &fileUser,
                                        TRUE,
                                        ppCompFile );
    if (FAILED(hr))
    {
        return FALSE;
    }

    //
    // So far so good.  Determine whether the compressed version
    // of the file is out of date.  If the compressed file is
    // out of date, delete it and remember that we did not get a
    // good match.  Note that there's really nothing we can do
    // if the delete fails, so ignore any failures from it.
    //
    // The last write times must differ by exactly two seconds
    // to constitute a match.  The two-second difference results
    // from the fact that we set the time on the compressed file
    // to be two seconds behind the uncompressed version in
    // order to ensure unique ETag: header values.
    //

    W3_FILE_INFO *pCompFile = *ppCompFile;
    ULARGE_INTEGER compressedFileSize;
    FILETIME compressedFileTime;
    LARGE_INTEGER *pli = (LARGE_INTEGER *)&compressedFileTime;
    FILETIME originalFileTime;
    BOOL success = FALSE;

    pCompFile->QuerySize(&compressedFileSize);
    pCompFile->QueryLastWriteTime(&compressedFileTime);
    pOrigFile->QueryLastWriteTime(&originalFileTime);

    pli->QuadPart += 2*10*1000*1000;

    LONG timeResult = CompareFileTime(&compressedFileTime, &originalFileTime);
    if ( timeResult != 0 )
    {
        //
        // That check failed.  If the compression directory is
        // on a FAT volume, then see if they are within two
        // seconds of one another.  If they are, then consider
        // things valid.  We have to do this because FAT file
        // times get truncated in weird ways sometimes: despite
        // the fact that we request setting the file time
        // different by an exact amount, it gets rounded
        // sometimes.
        //

        if (sm_fCompressionVolumeIsFat)
        {
            pli->QuadPart -= 2*10*1000*1000 + 1;
            timeResult += CompareFileTime(&compressedFileTime, &originalFileTime);
        }
    }

    if (timeResult == 0)
    {
        success = TRUE;
    }

    //
    // The original file has changed since the compression, close this cache
    // entry
    //
    if (!success)
    {
        pCompFile->DereferenceCacheEntry();
        *ppCompFile = NULL;
    }

    //
    // If the compressed file exists but is stale, queue for deletion
    //
    if (!success && fDeleteAllowed)
    {
        // don't delete if call came from compression thread because then
        // delete request will be in a queue after compression request
        // and will delete a file which was just moment ago compressed
        COMPRESSION_WORK_ITEM *WorkItem = new COMPRESSION_WORK_ITEM;
        if (WorkItem == NULL)
        {
            return FALSE;
        }

        WorkItem->WorkItemType = COMPRESSION_WORK_ITEM_DELETE;
        if (FAILED(WorkItem->strPhysicalPath.Copy(*pstrFileName)))
        {
            delete WorkItem;
            return FALSE;
        }

        if (!QueueWorkItem(WorkItem,
                           FALSE,
                           FALSE))
        {
            delete WorkItem;
            return FALSE;
        }

        //
        // If we are configured to limit the amount of disk
        // space we use for compressed files, then, in a
        // thread-safe manner, update the tally of disk
        // space used by compression.
        //

        if (sm_fDoDiskSpaceLimiting)
        {
            InterlockedExchangeAdd((PLONG)&sm_dwCurrentDiskSpaceUsage,
                                   -1 * compressedFileSize.LowPart);
        }
    }

    return success;
}


BOOL HTTP_COMPRESSION::QueueCompressFile(
    IN COMPRESSION_SCHEME *scheme,
    IN W3_FILE_INFO *pFileInfo)
/*++
  Routine Description:
    Queues a compress file request to the compression thread.

Arguments:
    Scheme - a pointer to the compression scheme to use in compressing
        the file.

    pszPhysicalPath - the current physical path to the file.

Return Value:
    TRUE if the queuing succeeded.
--*/
{
    COMPRESSION_WORK_ITEM *WorkItem = new COMPRESSION_WORK_ITEM;
    if ( WorkItem == NULL )
    {
        return FALSE;
    }

    //
    // Initialize this structure with the necessary information.
    //
    WorkItem->WorkItemType = COMPRESSION_WORK_ITEM_COMPRESS;
    WorkItem->scheme = scheme;
    pFileInfo->ReferenceCacheEntry();
    WorkItem->pFileInfo = pFileInfo;

    //
    // Queue a work item and we're done.
    //
    if (!QueueWorkItem(WorkItem,
                       FALSE,
                       FALSE))
    {
        delete WorkItem;
        return FALSE;
    }

    return TRUE;
}


VOID HTTP_COMPRESSION::CompressFile(IN COMPRESSION_SCHEME *scheme,
                                    IN W3_FILE_INFO       *pofiOriginalFile)
/*++
  Routine Description:
    This routine does the real work of compressing a static file and
    storing it to the compression directory with a unique name.

  Arguments:
    Context - a pointer to context information for the request,
        including the compression scheme to use for compression and the
        physical path to the file that we need to compress.

Return Value:
    None.  If the compression fails, we just press on and attempt to
    compress the file the next time it is requested.
--*/
{
    HANDLE                  hOriginalFile = NULL;
    HANDLE                  hCompressedFile = NULL;
    STACK_STRU            ( strPhysicalPath, 256);
    STACK_STRU            ( compressedFileName, 256);
    STACK_STRU            ( realCompressedFileName, 256);
    STACK_STRU            ( compressedFileNameCanonical, 256);
    STACK_STRU            ( realCompressedFileNameCanonical, 256);
    BOOL                    success = FALSE;
    DWORD                   cbIo = 0;
    DWORD                   totalBytesWritten = 0;
    BOOL                    usedScheme = FALSE;
    LARGE_INTEGER          *pli = NULL;
    W3_FILE_INFO           *pofiCompressedFile = NULL;
    FILETIME                originalFileTime;
    OVERLAPPED              ovlForRead;
    DWORD                   readStatus;
    ULARGE_INTEGER          readOffset = {0};
    WCHAR                   pszPid[16];
    DWORD                   dwPid;
    BYTE                   *pCachedFileBuffer;
    BOOL                    fHaveCachedFileBuffer = FALSE;
    DWORD                   dwOrigFileSize;
    ULARGE_INTEGER          liOrigFileSize;

    //
    // Determine the name of the file to which we will write compression
    // file data.  Note that we use a bogus file name initially: this
    // allows us to rename it later and ensure an atomic update to the
    // file system, thereby preventing other threads from returning the
    // compressed file when it has only been partially written.
    //
    // If the caller specified a specific output file name, then use that
    // instead of the calculated name.
    //
    if (FAILED(strPhysicalPath.Copy(pofiOriginalFile->QueryPhysicalPath())) ||
        FAILED(ConvertPhysicalPathToCompressedPath(
                   scheme,
                   &strPhysicalPath,
                   &realCompressedFileName)))
    {
        goto exit;
    }

    dwPid = GetCurrentProcessId();
    _itow(dwPid, pszPid, 10);
    if (FAILED(compressedFileName.Copy(realCompressedFileName)) ||
        FAILED(compressedFileName.Append(pszPid)) ||
        FAILED(compressedFileName.Append(TEMP_COMP_FILE_SUFFIX)) ||
        FAILED(MakePathCanonicalizationProof(realCompressedFileName.QueryStr(),
                                             &realCompressedFileNameCanonical)) ||
        FAILED(MakePathCanonicalizationProof(compressedFileName.QueryStr(),
                                             &compressedFileNameCanonical)))
    {
        goto exit;
    }

    success = CheckForExistenceOfCompressedFile(pofiOriginalFile,
                                                &realCompressedFileName,
                                                &pofiCompressedFile,
                                                FALSE);

    if (!success)
    {
        pofiOriginalFile->QueryLastWriteTime(&originalFileTime);

        pCachedFileBuffer = pofiOriginalFile->QueryFileBuffer();

        pofiOriginalFile->QuerySize(&liOrigFileSize);
        dwOrigFileSize = liOrigFileSize.LowPart;

        //
        // Do the actual file open.  We open the file for exclusive access,
        // and we assume that the file will not already exist.
        //

        hCompressedFile = CreateFile(
                            compressedFileNameCanonical.QueryStr(),
                            GENERIC_WRITE,
                            0,
                            NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_SYSTEM | FILE_FLAG_SEQUENTIAL_SCAN,
                            NULL);
        if (hCompressedFile == INVALID_HANDLE_VALUE)
        {
            goto exit;
        }

        //
        // Loop through the file data, reading it, then compressing it, then
        // writing out the compressed data.
        //

        if (pCachedFileBuffer)
        {
            fHaveCachedFileBuffer = TRUE;
        }
        else
        {
            hOriginalFile = pofiOriginalFile->QueryFileHandle();
            if ( hOriginalFile == INVALID_HANDLE_VALUE )
            {
                hOriginalFile = NULL;
                goto exit;
            }

            ovlForRead.Offset     = 0;
            ovlForRead.OffsetHigh = 0;
            ovlForRead.hEvent     = NULL;
            readOffset.QuadPart   = 0;
        }

        while (dwOrigFileSize > 0)
        {
            if (!fHaveCachedFileBuffer)
            {
                success = ReadFile(hOriginalFile, sm_pIoBuffer,
                                   sm_dwIoBufferSize, &cbIo, &ovlForRead);

                if (!success)
                {
                    switch (readStatus = GetLastError())
                    {
                    case ERROR_HANDLE_EOF:
                        cbIo = 0;
                        success = TRUE;
                        break;

                    case ERROR_IO_PENDING:
                        success = GetOverlappedResult(hOriginalFile, &ovlForRead, &cbIo, TRUE);
                        if (!success)
                        {
                            switch (readStatus = GetLastError())
                            {
                            case ERROR_HANDLE_EOF:
                                cbIo = 0;
                                success = TRUE;
                                break;

                            default:
                                break;
                            }
                        }
                        break;

                    default:
                        break;
                    }
                }

                if (!success)
                {
                    goto exit;
                }

                if (cbIo)
                {
                    readOffset.QuadPart += cbIo;
                    ovlForRead.Offset = readOffset.LowPart;
                    ovlForRead.OffsetHigh = readOffset.HighPart;
                }
                else
                {
                    //
                    // ReadFile returns zero bytes read at the end of the
                    // file.  If we hit that, then break out of this loop.
                    //

                    break;
                }
            }

            //
            // Remember that we used this compression scheme and that we
            // will need to reset it on exit.
            //

            usedScheme = TRUE;

            //
            // Write the compressed data to the output file.
            //

            success = CompressAndWriteData(
                          scheme,
                          fHaveCachedFileBuffer ? pCachedFileBuffer : sm_pIoBuffer,
                          fHaveCachedFileBuffer ? dwOrigFileSize : cbIo,
                          &totalBytesWritten,
                          hCompressedFile
                          );
            if (!success)
            {
                goto exit;
            }

            if (fHaveCachedFileBuffer)
            {
                break;
            }
        } // end while(dwOrigFileSize > 0)

        //
        // Tell the compression DLL that we're done with this file.  It may
        // return a last little bit of data for us to write to the the file.
        // This is because most compression schemes store an end-of-file
        // code in the compressed data stream.  Using "0" as the number of
        // bytes to compress handles this case.
        //

        success = CompressAndWriteData(
                      scheme,
                      NULL,
                      0,
                      &totalBytesWritten,
                      hCompressedFile
                      );
        if (!success)
        {
            goto exit;
        }

        //
        // Set the compressed file's creation time to be identical to the
        // original file.  This allows a more granular test for things being
        // out of date.  If we just did a greater-than-or-equal time
        // comparison, then copied or renamed files might not get registered
        // as changed.
        //

        //
        // Subtract two seconds from the file time to get the file time that
        // we actually want to put on the file.  We do this to make sure
        // that the server will send a different Etag: header for the
        // compressed file than for the uncompressed file, and the server
        // uses the file time to calculate the Etag: it uses.
        //
        // We set it in the past so that if the original file changes, it
        // should never happen to get the same value as the compressed file.
        // We pick two seconds instead of one second because the FAT file
        // system stores file times at a granularity of two seconds.
        //

        pli = (PLARGE_INTEGER)(&originalFileTime);
        pli->QuadPart -= 2*10*1000*1000;

        success = SetFileTime(
                      hCompressedFile,
                      NULL,
                      NULL,
                      &originalFileTime
                      );
        if (!success)
        {
            goto exit;
        }


        CloseHandle(hCompressedFile);
        hCompressedFile = NULL;

        //
        // Almost done now.  Just rename the file to the proper name.
        //

        success = MoveFileEx(
                      compressedFileNameCanonical.QueryStr(),
                      realCompressedFileNameCanonical.QueryStr(),
                      MOVEFILE_REPLACE_EXISTING);
        if (!success)
        {
            goto exit;
        }

        //
        // If we are configured to limit the amount of disk space we use for
        // compressed files, then update the tally of disk space used by
        // compression.  If the value is too high, then free up some space.
        //
        // Use InterlockedExchangeAdd to update this value because other
        // threads may be deleting files from the compression directory
        // because they have gone out of date.
        //

        if (sm_fDoDiskSpaceLimiting)
        {
            InterlockedExchangeAdd((PLONG)&sm_dwCurrentDiskSpaceUsage,
                                   totalBytesWritten);

            if (sm_dwCurrentDiskSpaceUsage > sm_dwMaxDiskSpaceUsage)
            {
                FreeDiskSpace();
            }
        }
    }

    //
    // Free the context structure and return.
    //

exit:
    if (pofiCompressedFile != NULL)
    {
        pofiCompressedFile->DereferenceCacheEntry();
        pofiCompressedFile = NULL;
    }

    //
    // Reset the compression context for reuse the next time through.
    // This is more optimal than recreating the compression context for
    // every file--it avoids allocations, etc.
    //
    if (usedScheme)
    {
        scheme->m_pfnResetCompression(scheme->m_pCompressionContext);
    }

    if (hCompressedFile != NULL)
    {
        CloseHandle(hCompressedFile);
    }

    if (!success)
    {
        DeleteFile(compressedFileName.QueryStr());
    }

    return;
}


VOID HTTP_COMPRESSION::FreeDiskSpace()
/*++
  Routine Description:
    If disk space limiting is in effect, this routine frees up the
    oldest compressed files to make room for new files.

  Arguments:
    None.

  Return Value:
    None.  This routine makes a best-effort attempt to free space, but
    if it doesn't work, oh well.
--*/
{
    WIN32_FIND_DATA  **filesToDelete;
    WIN32_FIND_DATA *currentFindData;
    WIN32_FIND_DATA *findDataHolder;
    DWORD i;
    HANDLE hDirectory = INVALID_HANDLE_VALUE;
    STACK_STRU (strFile, MAX_PATH);

    //
    // Allocate space to hold the array of files to delete and the
    // WIN32_FIND_DATA structures that we will need.  We will find the
    // least-recently-used files in the compression directory to delete.
    // The reason we delete multpiple files is to reduce the number of
    // times that we have to go through the process of freeing up disk
    // space, since this is a fairly expensive operation.
    //

    filesToDelete = (WIN32_FIND_DATA **)LocalAlloc(
                        LMEM_FIXED,
                        sizeof(filesToDelete)*sm_dwFilesDeletedPerDiskFree +
                        sizeof(WIN32_FIND_DATA)*(sm_dwFilesDeletedPerDiskFree + 1));
    if (filesToDelete == NULL)
    {
        return;
    }

    //
    // Parcel out the allocation to the various uses.  The initial
    // currentFindData will follow the array, and then the
    // WIN32_FIND_DATA structures that start off in the sorted array.
    // Initialize the last access times of the entries in the array to
    // 0xFFFFFFFF so that they are considered recently used and quickly
    // get tossed from the array with real files.
    //

    currentFindData = (PWIN32_FIND_DATA)(filesToDelete + sm_dwFilesDeletedPerDiskFree);

    for (i = 0; i < sm_dwFilesDeletedPerDiskFree; i++)
    {
        filesToDelete[i] = currentFindData + 1 + i;
        filesToDelete[i]->ftLastAccessTime.dwLowDateTime = 0xFFFFFFFF;
        filesToDelete[i]->ftLastAccessTime.dwHighDateTime = 0x7FFFFFFF;
    }

    //
    // Start enumerating the files in the compression directory.  Do
    // this while holding the lock that protects the
    // CompressionDirectoryWildcard variable, since it is possible for
    // that string pointer to get freed if there is a metabase
    // configuration change.  Note that holding the critical section for
    // a long time is not a perf issue because, in general, only this
    // thread ever acquires this lock, except for the rare configuration
    // change.
    //

    EnterCriticalSection(&sm_CompressionDirectoryLock);

    STACK_STRU (CompDirWildcard, 512);

    //
    // Allow long paths to be specified
    //
    if (FAILED(MakePathCanonicalizationProof(sm_pstrCompressionDirectory->QueryStr(),
                                             &CompDirWildcard)) ||
        FAILED(CompDirWildcard.Append(L"\\", 1)) ||
        FAILED(CompDirWildcard.Append(COMP_FILE_PREFIX)) ||
        FAILED(CompDirWildcard.Append(L"*", 1)))
    {
        LeaveCriticalSection(&sm_CompressionDirectoryLock);
        goto exit;
    }

    hDirectory = FindFirstFile(CompDirWildcard.QueryStr(), currentFindData);

    LeaveCriticalSection(&sm_CompressionDirectoryLock);

    if (hDirectory == INVALID_HANDLE_VALUE)
    {
        goto exit;
    }

    for (;;)
    {
        //
        // Ignore this entry if it is a directory.
        //

        if (!(currentFindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            //
            // Walk down the sorted array of files, comparing the time
            // of this file against the times of the files currently in
            // the array.  We need to find whether this file belongs in
            // the array at all, and, if so, where in the array it
            // belongs.
            //

            for (i = 0;
                 i < sm_dwFilesDeletedPerDiskFree &&
                 CompareFileTime(&currentFindData->ftLastAccessTime,
                                 &filesToDelete[i]->ftLastAccessTime) > 0;
                 i++)
            {}

            //
            // If this file needs to get inserted in the array, put it
            // in and move the other entries forward.
            //
            while (i < sm_dwFilesDeletedPerDiskFree)
            {
                findDataHolder = currentFindData;
                currentFindData = filesToDelete[i];
                filesToDelete[i] = findDataHolder;

                i++;
            }
        }

        //
        // Get the next file in the directory.
        //

        if (!FindNextFile(hDirectory, currentFindData))
        {
            break;
        }
    }

    //
    // Now walk through the array of files to delete and get rid of
    // them.
    //

    for (i = 0; i < sm_dwFilesDeletedPerDiskFree; i++)
    {
        if (filesToDelete[i]->ftLastAccessTime.dwHighDateTime != 0x7FFFFFFF)
        {
            //
            // Allow long paths to be specified
            //
            if (FAILED(MakePathCanonicalizationProof(sm_pstrCompressionDirectory->QueryStr(),
                                                     &strFile)) ||
                FAILED(strFile.Append(L"\\", 1)) ||
                FAILED(strFile.Append(filesToDelete[i]->cFileName)))
            {
                goto exit;
            }

            if (DeleteFile(strFile.QueryStr()))
            {
                InterlockedExchangeAdd((LPLONG)&sm_dwCurrentDiskSpaceUsage,
                                       -(LONG)filesToDelete[i]->nFileSizeLow);
            }
        }
    }

exit:
    if (filesToDelete)
    {
        LocalFree(filesToDelete);
    }

    if (hDirectory != INVALID_HANDLE_VALUE)
    {
        FindClose(hDirectory);
    }

    return;
}


BOOL HTTP_COMPRESSION::CompressAndWriteData(
    COMPRESSION_SCHEME *scheme,
    PBYTE InputBuffer,
    DWORD BytesToCompress,
    PDWORD BytesWritten,
    HANDLE hCompressedFile)
/*++
  Routine Description:
    Takes uncompressed data, compresses it with the specified compression
    scheme, and writes the result to the specified file.

  Arguments:
    Scheme - the compression scheme to use.

    InputBuffer - the data we need to compress.

    BytesToCompress - the size of the input buffer, or 0 if we should
        flush the compression buffers to the file at the end of the
        input file.  Note that this routine DOES NOT handle compressing
        a zero-byte file; we assume that the input file has some data.

    BytesWritten - the number of bytes written to the output file.

    hCompressedFile - a handle to the file to which we should write the
        compressed results.

  Return Value:
    None.  This routine makes a best-effort attempt to free space, but
    if it doesn't work, oh well.
--*/
{
    DWORD inputBytesUsed;
    DWORD bytesCompressed;
    HRESULT hResult;
    BOOL keepGoing;
    DWORD cbIo;

    if (sm_fIsTerminating)
    {
        return FALSE;
    }

    //
    // Perform compression on the actual file data.  Note that it is
    // possible that the compressed data is actually larger than the
    // input data, so we might need to call the compression routine
    // multiple times.
    //

    do
    {
        hResult = scheme->m_pfnCompress(
                      scheme->m_pCompressionContext,
                      InputBuffer,
                      BytesToCompress,
                      sm_pCompressionBuffer,
                      sm_dwCompressionBufferSize,
                      (PLONG)&inputBytesUsed,
                      (PLONG)&bytesCompressed,
                      scheme->m_dwOnDemandCompressionLevel);

        if (FAILED(hResult))
        {
            return FALSE;
        }

        if (hResult == S_OK)
        {
            keepGoing = TRUE;
        }
        else
        {
            keepGoing = FALSE;
        }

        //
        // If the compressor gave us any data, then write the result to
        // disk.  Some compression schemes buffer up data in order to
        // perform better compression, so not every compression call
        // will result in output data.
        //

        if (bytesCompressed > 0)
        {
            if (!WriteFile(hCompressedFile,
                           sm_pCompressionBuffer,
                           bytesCompressed,
                           &cbIo,
                           NULL))
            {
                return FALSE;
            }

            *BytesWritten += cbIo;
        }

        //
        // Update the number of input bytes that we have compressed
        // so far, and adjust the input buffer pointer accordingly.
        //

        BytesToCompress -= inputBytesUsed;
        InputBuffer += inputBytesUsed;
    }
    while ( ((BytesToCompress > 0) || ((BytesToCompress + inputBytesUsed) == 0)) && keepGoing );

    return TRUE;
}


BOOL DoesCacheControlNeedMaxAge(IN LPCSTR CacheControlHeaderValue)
/*++

Routine Description:

    This function determines whether the Cache-Control header on a
    compressed response needs to have the max-age directive added.
    If there is already a max-age, or if there is a no-cache directive,
    then we should not add max-age.

Arguments:

    CacheControlHeaderValue - the value of the cache control header to
        scan.  The string should be zero-terminated.

Return Value:

    TRUE if we need to add max-age; FALSE if we should not add max-age.

--*/

{
    if (strstr(CacheControlHeaderValue, "max-age"))
    {
        return FALSE;
    }

    PCHAR s;
    while ((s = strstr(CacheControlHeaderValue, "no-cache")) != NULL)
    {
        //
        // If it is a no-cache=foo then it only refers to a specific header
        // Continue
        //

        if (s[8] != '=')
        {
            return FALSE;
        }

        CacheControlHeaderValue = s + 8;
    }

    //
    // We didn't find any directives that would prevent us from adding
    // max-age.
    //

    return TRUE;
}

// static
HRESULT HTTP_COMPRESSION::OnSendResponse(
    IN  W3_CONTEXT *pW3Context )
{
    W3_RESPONSE *pResponse = pW3Context->QueryResponse();
    W3_REQUEST  *pRequest  = pW3Context->QueryRequest();

    //
    // If compression is not initialized, return
    //
    if (sm_InitStatus != COMP_INIT_DONE)
    {
        pW3Context->SetDoneWithCompression();
        return S_OK;
    }

    //
    // If we already have a compression context (more than one SendResponse)
    // return
    //
    if (pW3Context->QueryCompressionContext() != NULL)
    {
        return S_OK;
    }

    //
    // If Response status is not 200 (let us not try compressing 206, 3xx or
    // error responses), return
    //
    if (pResponse->QueryStatusCode() != HttpStatusOk.statusCode &&
        pResponse->QueryStatusCode() != HttpStatusMultiStatus.statusCode)
    {
        pW3Context->SetDoneWithCompression();
        return S_OK;
    }

    //
    // If the client has not sent an Accept-Encoding header, or an empty
    // Accept-Encoding header, return
    //
    LPCSTR pszAcceptEncoding = pRequest->GetHeader(HttpHeaderAcceptEncoding);
    if (pszAcceptEncoding == NULL || *pszAcceptEncoding == L'\0')
    {
        pW3Context->SetDoneWithCompression();
        return S_OK;
    }

    //
    // Don't compress for TRACEs
    //
    HTTP_VERB VerbType = pW3Context->QueryRequest()->QueryVerbType();
    if (VerbType == HttpVerbTRACE)
    {
        pW3Context->SetDoneWithCompression();
        return S_OK;
    }

    //
    // If we are configured to not compress for 1.0, and version is not 1.1,
    // return
    //
    if (sm_fNoCompressionForHttp10 &&
        ((pRequest->QueryVersion().MajorVersion == 0) ||
         ((pRequest->QueryVersion().MajorVersion == 1) &&
          (pRequest->QueryVersion().MinorVersion == 0))))
    {
        pW3Context->SetDoneWithCompression();
        return S_OK;
    }

    //
    // If we are configured to not compress for proxies and it is a proxy
    // request, return
    //
    if (sm_fNoCompressionForProxies && pRequest->IsProxyRequest())
    {
        pW3Context->SetDoneWithCompression();
        return S_OK;
    }

    //
    // If the response already has a Content-Encoding header, return
    //
    if (pResponse->GetHeader(HttpHeaderContentEncoding))
    {
        pW3Context->SetDoneWithCompression();
        return S_OK;
    }

    //
    // Now see if we have any matching scheme
    //
    STACK_STRA( strAcceptEncoding, 512);
    HRESULT hr;
    if (FAILED(hr = strAcceptEncoding.Copy(pszAcceptEncoding)))
    {
        return hr;
    }

    STRU *pstrPhysical = pW3Context->QueryUrlContext()->QueryPhysicalPath();
    LPWSTR pszExtension = wcsrchr(pstrPhysical->QueryStr(), L'.');
    if (pszExtension != NULL)
    {
        pszExtension++;
    }

    DWORD dwClientCompressionCount;
    DWORD matchingSchemes[MAX_SERVER_SCHEMES];
    //
    // Find out all schemes which will compress for this url
    //
    FindMatchingSchemes(strAcceptEncoding.QueryStr(),
                        pszExtension,
                        DO_DYNAMIC_COMPRESSION,
                        matchingSchemes,
                        &dwClientCompressionCount);
    if (dwClientCompressionCount == 0)
    {
        pW3Context->SetDoneWithCompression();
        return S_OK;
    }

    //
    // All tests passed, we are GO for dynamic compression
    //
    COMPRESSION_CONTEXT *pCompressionContext = new COMPRESSION_CONTEXT;
    if (pCompressionContext == NULL)
    {
        return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }
    pW3Context->SetCompressionContext(pCompressionContext);
    pCompressionContext->m_pScheme = sm_pCompressionSchemes[matchingSchemes[0]];

    LPCSTR xferEncoding = pResponse->GetHeader(HttpHeaderTransferEncoding);
    if (xferEncoding &&
        _stricmp(xferEncoding, "chunked") == 0)
    {
        pCompressionContext->m_fTransferChunkEncoded = TRUE;
    }

    //
    // Remove the Content-Length header, set the Content-Encoding, Vary and
    // Transfer-Encoding headers
    //
    if (FAILED(hr = pResponse->SetHeaderByReference(HttpHeaderContentLength,
                                         NULL, 0)) ||
        FAILED(hr = pResponse->SetHeaderByReference(
                        HttpHeaderContentEncoding,
                        pCompressionContext->m_pScheme->m_straCompressionSchemeName.QueryStr(),
                        (USHORT)pCompressionContext->m_pScheme->m_straCompressionSchemeName.QueryCCH())) ||
        FAILED(hr = pResponse->SetHeader(HttpHeaderVary,
                                         "Accept-Encoding", 15,
                                         TRUE)) ||
        FAILED(hr = pResponse->SetHeaderByReference(HttpHeaderTransferEncoding,
                                         "chunked", 7)))
    {
        return hr;
    }

    if (sm_fSendCacheHeaders)
    {
        if (FAILED(hr = pResponse->SetHeaderByReference(
                            HttpHeaderExpires,
                            sm_pstrExpiresHeader->QueryStr(),
                            (USHORT)sm_pstrExpiresHeader->QueryCCH())))
        {
            return hr;
        }

        LPCSTR cacheControl = pResponse->GetHeader(HttpHeaderCacheControl);
        if (!cacheControl || DoesCacheControlNeedMaxAge(cacheControl))
        {
            if (FAILED(hr = pResponse->SetHeader(
                                HttpHeaderCacheControl,
                                sm_pstrCacheControlHeader->QueryStr(),
                                (USHORT)sm_pstrCacheControlHeader->QueryCCH(),
                                TRUE)))
            {
                return hr;
            }
        }
    }

    //
    // Get a compression context
    //
    if (FAILED(hr = pCompressionContext->m_pScheme->m_pfnCreateCompression(
                        &pCompressionContext->m_pCompressionContext,
                        pCompressionContext->m_pScheme->m_dwCreateFlags)))
    {
        return hr;
    }

    //
    // Ok, done with all the header stuff, now actually start compressing
    // the entity
    //

    if (VerbType == HttpVerbHEAD)
    {
        pCompressionContext->m_fRequestIsHead = TRUE;
    }

    //
    // BUGBUG: UL does not know about compression right now, so
    // disable UL caching for this response
    //
    pW3Context->DisableUlCache();

    return S_OK;
}


BOOL CheckForEndofHeaders(IN LPBYTE pbuff,
                          IN DWORD cbData,
                          OUT DWORD *pcbIndexStartOfData)
{
    //
    // Look for two consecutive newline, \n\r\r\n, \n\r\n or \n\n
    //
    DWORD index;
    for (index = 0; index + 1 < cbData; index++)
    {
        if (pbuff[index] == '\n')
        {
            if (pbuff[index + 1] == '\n')
            {
                *pcbIndexStartOfData = index + 2;
                return TRUE;
            }
            else if (pbuff[index + 1] == '\r' &&
                     index + 2 < cbData)
            {
                if (pbuff[index + 2] == '\n')
                {
                    *pcbIndexStartOfData = index + 3;
                    return TRUE;
                }
                else if (pbuff[index + 2] == '\r' &&
                         index + 3 < cbData &&
                         pbuff[index + 3] == '\n')
                {
                    *pcbIndexStartOfData = index + 4;
                    return TRUE;
                }
            }
        }
    }

    return FALSE;
}


// static
HRESULT HTTP_COMPRESSION::DoDynamicCompression(
    IN  W3_CONTEXT *pW3Context,
    IN  BOOL        fMoreData,
    IN  HTTP_FILTER_RAW_DATA* pRawData )
{
    COMPRESSION_CONTEXT *pCompressionContext = pW3Context->QueryCompressionContext();
    DWORD                   cbChunkOffset = 0;
    HRESULT                 hr;

    if (pCompressionContext == NULL)
    {
        pW3Context->SetDoneWithCompression();
        return S_OK;
    }

    //
    // Get hold of the response chunks
    //
    pCompressionContext->m_pbOrigData = (BYTE *)pRawData->pvInData;
    pCompressionContext->m_cbOrigData = pRawData->cbInData;

    if (!pCompressionContext->m_fHeadersSent)
    {
        DWORD cbStartOfEntityBody;

        if (!CheckForEndofHeaders(pCompressionContext->m_pbOrigData,
                                  pCompressionContext->m_cbOrigData,
                                  &cbStartOfEntityBody))
        {
            return S_OK;
        }

        if (!pCompressionContext->m_bufChunk.Resize(cbStartOfEntityBody))
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }

        memcpy(pCompressionContext->m_bufChunk.QueryPtr(),
               pCompressionContext->m_pbOrigData,
               cbStartOfEntityBody);

        cbChunkOffset = cbStartOfEntityBody;
        pCompressionContext->IncrementPointerInULChunk(cbStartOfEntityBody);
        pCompressionContext->m_fHeadersSent = TRUE;
    }

    if (pCompressionContext->m_cbOrigData > 0)
    {
        pCompressionContext->m_fOriginalBodyEmpty = FALSE;
    }

    //
    // If the request was a HEAD request and we haven't seen any
    // entity body, no point in going any further (if the output
    // is already suppressed, we do not want to compress it and make it
    // non-empty)
    //
    if (pCompressionContext->m_fRequestIsHead &&
        pCompressionContext->m_fOriginalBodyEmpty)
    {
        return S_OK;
    }

    BOOL fKeepGoing;
    do
    {
        fKeepGoing = FALSE;

        if (pCompressionContext->m_fTransferChunkEncoded)
        {
            //
            // If the input data is being chunk-transfered, initially,
            // we'll be looking at the chunk header.  This is a hex
            // representation of the number of bytes in this chunk.
            // Translate this number from ASCII to a DWORD and remember
            // it.  Also advance the chunk pointer to the start of the
            // actual data.
            //

            if (FAILED(hr = pCompressionContext->ProcessEncodedChunkHeader()))
            {
                return hr;
            }
        }

        //
        // Try to compress all the contiguous bytes
        //
        DWORD bytesToCompress = pCompressionContext->m_cbOrigData;
        if (pCompressionContext->m_fTransferChunkEncoded)
        {
            bytesToCompress =
                min(bytesToCompress,
                    pCompressionContext->m_dwBytesInCurrentEncodedChunk);
        }

        if (!fMoreData || bytesToCompress > 0)
        {
            DWORD inputBytesUsed = 0;
            DWORD bytesCompressed = 0;

            BYTE compressionBuffer[6 + DYNAMIC_COMPRESSION_BUFFER_SIZE + 7];

            hr = pCompressionContext->m_pScheme->m_pfnCompress(
                     pCompressionContext->m_pCompressionContext,
                     bytesToCompress ? pCompressionContext->m_pbOrigData : NULL,
                     bytesToCompress,
                     compressionBuffer + 6,
                     DYNAMIC_COMPRESSION_BUFFER_SIZE,
                     (PLONG)&inputBytesUsed,
                     (PLONG)&bytesCompressed,
                     pCompressionContext->m_pScheme->m_dwDynamicCompressionLevel);

            if (FAILED(hr))
            {
                return hr;
            }

            if (hr == S_OK)
            {
                fKeepGoing = TRUE;
            }

            pCompressionContext->IncrementPointerInULChunk(inputBytesUsed);
            if (pCompressionContext->m_fTransferChunkEncoded)
            {
                pCompressionContext->m_dwBytesInCurrentEncodedChunk -=
                    inputBytesUsed;
            }

            DWORD startSendLocation = 8;
            DWORD bytesToSend = 0;

            if (bytesCompressed > 0)
            {
                //
                // Add the CRLF just before and after the chunk data
                //
                compressionBuffer[4] = '\r';
                compressionBuffer[5] = '\n';

                compressionBuffer[bytesCompressed + 6] = '\r';
                compressionBuffer[bytesCompressed + 7] = '\n';

                //
                // Now create the chunk header which is basically the chunk
                // size written out in hex
                //

                if (bytesCompressed < 0x10 )
                {
                    startSendLocation = 3;
                    bytesToSend = 3 + bytesCompressed + 2;
                    compressionBuffer[3] = HEX_TO_ASCII(bytesCompressed);
                }
                else if (bytesCompressed < 0x100)
                {
                    startSendLocation = 2;
                    bytesToSend = 4 + bytesCompressed + 2;
                    compressionBuffer[2] = HEX_TO_ASCII(bytesCompressed >> 4);
                    compressionBuffer[3] = HEX_TO_ASCII(bytesCompressed & 0xF);
                }
                else if (bytesCompressed < 0x1000)
                {
                    startSendLocation = 1;
                    bytesToSend = 5 + bytesCompressed + 2;
                    compressionBuffer[1] = HEX_TO_ASCII(bytesCompressed >> 8);
                    compressionBuffer[2] = HEX_TO_ASCII((bytesCompressed >> 4) & 0xF);
                    compressionBuffer[3] = HEX_TO_ASCII(bytesCompressed & 0xF);
                }
                else
                {
                    DBG_ASSERT( bytesCompressed < 0x10000 );

                    startSendLocation = 0;
                    bytesToSend = 6 + bytesCompressed + 2;
                    compressionBuffer[0] = HEX_TO_ASCII(bytesCompressed >> 12);
                    compressionBuffer[1] = HEX_TO_ASCII((bytesCompressed >> 8) & 0xF);
                    compressionBuffer[2] = HEX_TO_ASCII((bytesCompressed >> 4) & 0xF);
                    compressionBuffer[3] = HEX_TO_ASCII(bytesCompressed & 0xF);
                }
            }

            if (!fKeepGoing)
            {
                //
                // If this is the last send, add the trailer 0 length chunk
                //

                memcpy(compressionBuffer + bytesCompressed + 8, "0\r\n\r\n", 5);
                bytesToSend += 5;
            }

            if (!fKeepGoing || bytesCompressed > 0)
            {
                //
                // Keep appending to buffer
                //

                if (!pCompressionContext->m_bufChunk.Resize(
                        cbChunkOffset + bytesToSend))
                {
                    return HRESULT_FROM_WIN32( GetLastError() );
                }

                memcpy((PBYTE)pCompressionContext->m_bufChunk.QueryPtr() + cbChunkOffset,
                       compressionBuffer + startSendLocation,
                       bytesToSend);

                cbChunkOffset += bytesToSend;
            }
        }
    }
    while (fKeepGoing);

    //
    // Finally add the chunk
    //

    if ( cbChunkOffset > 0 )
    {
        pRawData->pvInData = pCompressionContext->m_bufChunk.QueryPtr();
    }
    pRawData->cbInData = cbChunkOffset;

    return S_OK;
}

HRESULT COMPRESSION_CONTEXT::ProcessEncodedChunkHeader()
{
    HRESULT hr;

    while ((m_dwBytesInCurrentEncodedChunk == 0 ||
            m_encodedChunkState != IN_CHUNK_DATA) &&
           m_cbOrigData > 0)
    {
        switch (m_encodedChunkState)
        {
        case IN_CHUNK_LENGTH:
            if (FAILED(hr = CalculateEncodedChunkByteCount()))
            {
                return hr;
            }
            break;

        case IN_CHUNK_EXTENSION:
            DeleteEncodedChunkExtension();
            break;

        case IN_CHUNK_HEADER_NEW_LINE:
            IncrementPointerInULChunk();
            m_encodedChunkState = IN_CHUNK_DATA;
            break;

        case AT_CHUNK_DATA_NEW_LINE:
            IncrementPointerInULChunk();
            m_encodedChunkState = IN_CHUNK_DATA_NEW_LINE;
            break;

        case IN_CHUNK_DATA_NEW_LINE:
            IncrementPointerInULChunk();
            m_encodedChunkState = IN_CHUNK_LENGTH;
            break;

        case IN_CHUNK_DATA:
            m_encodedChunkState = AT_CHUNK_DATA_NEW_LINE;
            break;

        default:
            DBG_ASSERT(FALSE);
        }
    }

    return S_OK;
}


HRESULT COMPRESSION_CONTEXT::CalculateEncodedChunkByteCount()
{
    CHAR c = '\0';
    //
    // Walk to the first '\r' or ';' which signifies the end of the chunk
    // byte count
    //

    while (m_cbOrigData > 0 &&
           SAFEIsXDigit(c = *m_pbOrigData))
    {
        m_dwBytesInCurrentEncodedChunk <<= 4;
        if (c >= '0' && c <= '9')
        {
            m_dwBytesInCurrentEncodedChunk += c - '0';
        }
        else
        {
            m_dwBytesInCurrentEncodedChunk += (c | 0x20) - 'a' + 10;
        }
        IncrementPointerInULChunk();
    }

    if (m_cbOrigData > 0)
    {
        if (c == ';')
        {
            m_encodedChunkState = IN_CHUNK_EXTENSION;
        }
        else if (c == '\r')
        {
            m_encodedChunkState = IN_CHUNK_HEADER_NEW_LINE;
        }
        else
        {
            DBG_ASSERT(!"Malformed chunk header");
            return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        }

        IncrementPointerInULChunk();
    }

    return S_OK;
}


VOID COMPRESSION_CONTEXT::DeleteEncodedChunkExtension()
{
    //
    // Walk to the first '\r' which signifies the end of the chunk extension
    //

    while (m_cbOrigData > 0 &&
           *m_pbOrigData != '\r')
    {
        IncrementPointerInULChunk();
    }

    if (m_cbOrigData > 0)
    {
        m_encodedChunkState = IN_CHUNK_HEADER_NEW_LINE;
        IncrementPointerInULChunk();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\datasetcache.cxx ===
/*++

   Copyright    (c)    2001    Microsoft Corporation

   Module Name :
     datasetcache.cxx

   Abstract:
     A URL->data_set_number cache
 
   Author:
     Bilal Alam (balam)             8-12-2001

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"

DWORD               DATA_SET_CACHE::sm_cMaxCacheEntries = 50;

HRESULT
DATA_SET_CACHE_ENTRY::Create(
    WCHAR *             pszSubPath,
    DWORD               dwMatchDataSetNumber,
    DWORD               dwPrefixDataSetNumber
)
/*++

Routine Description:

    Initialize a data set cache entry

Arguments:

    pszSubPath - Sub path (based off site root)
    dwMatchDataSetNumber - Data set number for this entry
    dwPrefixDataSetNumber - Data set number for paths prefixed by this entry

Return Value:

    HRESULT

--*/
{
    HRESULT             hr;
    
    _dwMatchDataSetNumber = dwMatchDataSetNumber;
    _dwPrefixDataSetNumber = dwPrefixDataSetNumber;
    
    hr = _strSubPath.Copy( pszSubPath );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    if ( _strSubPath.QueryCCH() != 0 &&
         _strSubPath.QueryStr()[ _strSubPath.QueryCCH() - 1 ] != L'/' )
    {
        hr = _strSubPath.Append( L"/" );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }
    
    return NO_ERROR;
}

//static
HRESULT
DATA_SET_CACHE::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize some data set cache globals

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    DWORD               dwError;
    DWORD               dwType;
    DWORD               dwValue;
    DWORD               cbData;
    HKEY                hKey = NULL;
    
    //
    // Read max DataSetCache size
    //
    
    dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            L"System\\CurrentControlSet\\Services\\inetinfo\\Parameters",
                            0,
                            KEY_READ,
                            &hKey );
    if ( dwError == ERROR_SUCCESS )
    {
        DBG_ASSERT( hKey != NULL );
    
        //
        // Should we be file caching at all?
        //
    
        cbData = sizeof( DWORD );
        dwError = RegQueryValueEx( hKey,
                                   L"DataSetCacheSize",
                                   NULL,
                                   &dwType,
                                   (LPBYTE) &dwValue,
                                   &cbData );
        if ( dwError == ERROR_SUCCESS && dwType == REG_DWORD )
        {
            sm_cMaxCacheEntries = dwValue;
        }

        RegCloseKey( hKey );
    }
    
    return NO_ERROR;
}

HRESULT
DATA_SET_CACHE::Create(
    STRU &          strSiteRoot
)
/*++

Routine Description:

    Initialize a data set number cache for the given site root path

Arguments:

    strSiteRoot - Site root path (like /LM/W3SVC/<site-number>/Root)

Return Value:

    HRESULT

--*/
{
    MB              mb( g_pW3Server->QueryMDObject() );
    MB              mb2( g_pW3Server->QueryMDObject() );
    BOOL            fRet;
    HRESULT         hr = NO_ERROR;
    WCHAR           achSubRoot[ METADATA_MAX_NAME_LEN ];
    WCHAR           achNextLevel[ METADATA_MAX_NAME_LEN ];
    STACK_STRU(     strFullPath, 256 );
    DWORD           i = 0;
    DWORD           dwMatchDataSetNumber;
    DWORD           dwPrefixDataSetNumber;
    DATA_SET_CACHE_ENTRY *  pDataSetCacheEntry;
    BOOL            fCanUseRoot = TRUE;

    hr = _strSiteRoot.Copy( strSiteRoot );
    if ( FAILED( hr ) )
    {
        goto Finished;
    }
    
    fRet = mb.Open( strSiteRoot.QueryStr() );
    if ( !fRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Finished;
    }    
    
    //
    // If there are more than sm_cMaxCacheEntries paths, then we should
    // not even bother with the cache 
    //
    
    if ( mb.EnumObjects( NULL, achSubRoot, sm_cMaxCacheEntries ) )
    {
        return NO_ERROR;
    }
    
    //
    // Do a first level enumeration (we'll only handle one level for now)
    // 
   
    while ( TRUE )
    {
        if ( !mb.EnumObjects( NULL, achSubRoot, i++ ) )
        {
            //
            // We've reached the end of the sub paths.  If we can use the
            // root, then add it now (it will be the last entry)
            //   
            
            if ( fCanUseRoot )
            {
                achSubRoot[ 0 ] = L'\0';
            }
            else
            {
                break;
            }
        }
        else
        {
            //
            // Only add an entry to data set cache if there are no sublevels
            //
        
            if ( mb.EnumObjects( achSubRoot, achNextLevel, 0 ) )
            {
                //
                // If there is a multi-level root, we cannot use the root in
                // getting data set number.  Remember that.
                //
            
                fCanUseRoot = FALSE;
            
                continue;
            }
        }
        
        //
        // Cool.  Get the data set numbers (we need to full path :-( )
        //
        
        hr = strFullPath.Copy( strSiteRoot );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }
        
        hr = strFullPath.Append( achSubRoot );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }
        
        if ( strFullPath.QueryStr()[ strFullPath.QueryCCH() - 1 ] != L'/' )
        {
            hr = strFullPath.Append( L"/" );
            if ( FAILED( hr ) )
            {
                goto Finished;
            }
        }
        
        //
        // We need two data set numbers.  
        //
        // 1) One for the exact path
        // 2) One for the prefixed path.  For this one, we'll just append
        //    a bogus suffix and retrieve the data set number
        //
        
        if ( !mb2.GetDataSetNumber( strFullPath.QueryStr(),
                                    &dwMatchDataSetNumber ) )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Finished;
        }
        
        hr = strFullPath.Append( L"foo" );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }
        
        if ( !mb2.GetDataSetNumber( strFullPath.QueryStr(),
                                    &dwPrefixDataSetNumber ) )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Finished;
        }
        
        //
        // Create an entry for this guy
        //
        
        pDataSetCacheEntry = new DATA_SET_CACHE_ENTRY;
        if ( pDataSetCacheEntry == NULL )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Finished;
        }
        
        _wcsupr( achSubRoot );
        
        hr = pDataSetCacheEntry->Create( achSubRoot,
                                         dwMatchDataSetNumber,
                                         dwPrefixDataSetNumber );
        if ( FAILED( hr ) ) 
        {
            goto Finished;
        }
        
        //
        // Add to the array
        //
        
        if ( !_bufEntries.Resize( sizeof( DATA_SET_CACHE_ENTRY* ) * 
                                  ( _cEntries + 1 ) ) )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Finished;
        }
        
        QueryEntries()[ _cEntries ] = pDataSetCacheEntry;
        _cEntries++;
        
        //
        // If we've just added the root, we're done
        //
        
        if ( achSubRoot[ 0 ] == L'\0' )
        {
            break;
        }
    } 
    
Finished:
    return hr;
}

HRESULT
DATA_SET_CACHE::GetDataSetNumber(
    STRU &          strMetabasePath,
    DWORD *         pdwDataSetNumber
)
/*++

Routine Description:

    Get data set number from the cache

Arguments:

    strMetabasePath - Metabase path to get data set number for (duh)
    pdwDataSetNumber - Filled with data set number (duh^2)

Return Value:

    HRESULT

--*/
{
    DWORD                   i;
    DATA_SET_CACHE_ENTRY *  pDataSetCacheEntry;
    STACK_STRU(             strUpperPath, 256 );
    HRESULT                 hr;
    HANDLE                  hToken = NULL;
   
    if ( pdwDataSetNumber == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
   
    hr = strUpperPath.Copy( strMetabasePath.QueryStr() +
                            _strSiteRoot.QueryCCH() );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    _wcsupr( strUpperPath.QueryStr() );
    
    //
    // Add a trailing / if needed (since the entries are / suffixed)
    //
    
    if ( strUpperPath.QueryCCH() &&
         strUpperPath.QueryStr()[ strUpperPath.QueryCCH() - 1 ] != L'/' )
    {
        hr = strUpperPath.Append( L"/" );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }
    
    //
    // First check the data set number entries
    //

    for ( i = 0;
          i < _cEntries;
          i++ )
    {
        pDataSetCacheEntry = QueryEntries()[ i ];
        DBG_ASSERT( pDataSetCacheEntry != NULL );
    
        if ( pDataSetCacheEntry->QueryDoesMatch( strUpperPath, pdwDataSetNumber ) )
        {
            return NO_ERROR;
        }
    }    

    //
    // If we're here, then we didn't find a match.  Call into the metabase
    //
    
    MB mb( g_pW3Server->QueryMDObject() );

    //
    // If the caller is coming from an ISAPI, then the thread may
    // be impersonating.  Temporarily discard the impersonation
    // token until we get the metadata.
    //

    if ( OpenThreadToken( GetCurrentThread(),
                          TOKEN_IMPERSONATE,
                          TRUE,
                          &hToken ) )
    {
        DBG_ASSERT( hToken != NULL );
        DBG_REQUIRE( RevertToSelf() );
    }
    
    if ( !mb.GetDataSetNumber( strMetabasePath.QueryStr(), 
                               pdwDataSetNumber ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
    }

    if ( hToken != NULL )
    {
        DBG_REQUIRE( SetThreadToken( NULL, hToken ) );
        DBG_REQUIRE( CloseHandle( hToken ) );
        hToken = NULL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\customerror.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     customerror.cxx

   Abstract:
     Custom Error goo
 
   Author:
     Bilal Alam (balam)             10-Mar-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"

HRESULT
CUSTOM_ERROR_TABLE::FindCustomError(
    USHORT                  StatusCode,
    USHORT                  SubError,
    BOOL *                  pfIsFile,
    STRU *                  pstrError
)
/*++

Routine Description:

    Find the applicable custom error entry for a given status/subcode

Arguments:

    StatusCode - Status code
    SubError - sub error
    pfIsFile - Set to TRUE if this is a file error
    pstrError - Error path (URL or file)

Return Value:

    HRESULT

--*/
{
    LIST_ENTRY *            pListEntry;
    CUSTOM_ERROR_ENTRY *    pCustomEntry = NULL;
    BOOL                    fFound = FALSE;
    HRESULT                 hr = NO_ERROR;
    
    if ( pfIsFile == NULL ||
         pstrError == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    for ( pListEntry = _ErrorListHead.Flink;
          pListEntry != &_ErrorListHead;
          pListEntry = pListEntry->Flink )
    {
        pCustomEntry = CONTAINING_RECORD( pListEntry,
                                          CUSTOM_ERROR_ENTRY,
                                          _listEntry ); 
        DBG_ASSERT( pCustomEntry != NULL );

        if ( pCustomEntry->_StatusCode == StatusCode )
        {
            if ( pCustomEntry->_SubError == SubError ||
                 pCustomEntry->_SubError == SUBERROR_WILDCARD )
            {
                fFound = TRUE;
                break;
            }
        }
    }
    
    if ( fFound )
    {
        hr = pstrError->Copy( pCustomEntry->_strError );
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        *pfIsFile = pCustomEntry->_fIsFile;
        return NO_ERROR;
    }
    else
    {
        return HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
    }
}

HRESULT
CUSTOM_ERROR_TABLE::BuildTable(
    WCHAR *             pszErrorList
)
/*++

Routine Description:

    Build custom error table from metabase
    
Arguments:

    pszErrorList - Magic error MULTISZ

Return Value:

    HRESULT

--*/
{
    WCHAR *             pszType;
    WCHAR *             pszSubError;
    WCHAR *             pszPath;
    WCHAR *             pszNewPath;
    WCHAR               cTemp;
    USHORT              StatusCode;
    USHORT              SubError;
    BOOL                fIsFile;
    CUSTOM_ERROR_ENTRY* pNewEntry;
    DWORD               dwPathLength;
    HRESULT             hr = NO_ERROR;

    for (;;)
    {
        //
        // Get the status code
        //
        
        StatusCode = (USHORT) _wtoi( pszErrorList );
        if ( StatusCode < 300 )
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
            goto Finished;
        }

        //
        // Now convert the second parameter (the suberror) to a number.
        //

        pszSubError = wcschr( pszErrorList, L',' );
        if ( pszSubError == NULL )
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
            goto Finished;
        }
        pszSubError++;
        
        while ( SAFEIsSpace( *pszSubError ) )
        {
            pszSubError++;
        }
        
        //
        // Either we have a specific sub error or a wildcard (any suberror)
        //

        if ( *pszSubError == L'*' )
        {
            SubError = SUBERROR_WILDCARD;
        }
        else
        {
            if ( !iswdigit( *pszSubError ) )
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Finished;
            }

            SubError = (USHORT) _wtoi( pszSubError );
        }

        //
        // Now find the comma that seperates the number and the type.
        //
        
        pszType = wcschr( pszSubError, L',' );
        if ( pszType == NULL )
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
            goto Finished;
        }
        pszType++;

        while ( SAFEIsSpace( *pszType ) )
        {
            pszType++;
        }

        // We found the end of ws. If this isn't an alphabetic character, it's
        // an error. If it is, find the end of the alpha. chars.

        if ( !iswalpha( *pszType ) )
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
            goto Finished;
        }
        pszPath = pszType;

        while ( iswalpha( *pszPath ) )
        {
            pszPath++;
        }

        cTemp = *pszPath;
        *pszPath = L'\0';

        //
        // What type of custom error is this?
        //

        if ( !_wcsicmp( pszType, L"FILE" ) )
        {
            fIsFile = TRUE;
        }
        else
        {
            if (!_wcsicmp( pszType, L"URL" ) )
            {
                fIsFile = FALSE;
            }
            else
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
            }
        }
        *pszPath = cTemp;
        
        if ( FAILED( hr ) )
        {
            goto Finished;
        }

        //
        // Now find the comma that seperates the type from the URL/path.
        //
        
        pszPath = wcschr( pszPath, L',' );
        if ( pszPath == NULL )
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
            goto Finished;
        }
        pszPath++;

        while ( SAFEIsSpace( *pszPath ) )
        {
            pszPath++;
        }

        if ( *pszPath == '\0' )
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
            goto Finished;
        }

        dwPathLength = wcslen( pszPath ) + 1;

        //
        // OK.  Now we can allocate a table entry
        //
        
        pNewEntry = new CUSTOM_ERROR_ENTRY;
        if ( pNewEntry == NULL )
        {
            hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
            goto Finished;
        }
            
        pNewEntry->_StatusCode = StatusCode;
        pNewEntry->_SubError = SubError;
        pNewEntry->_fIsFile = fIsFile;
        
        hr = pNewEntry->_strError.Copy( pszPath );
        if ( FAILED( hr ) )
        {
            delete pNewEntry;
            return hr;
        }
        
        //
        // Give more specific errors higher priority in lookup
        //

        if ( SubError == SUBERROR_WILDCARD )
        {
            InsertTailList( &_ErrorListHead, &pNewEntry->_listEntry );
        }
        else
        {
            InsertHeadList( &_ErrorListHead, &pNewEntry->_listEntry );
        }

        pszErrorList = pszPath + dwPathLength;

        if ( *pszErrorList == L'\0' )
        {
            hr = NO_ERROR;
            break;
        }
    }
Finished:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\dbgutil.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dbgutil.h

Abstract:

    This module declares the macros to wrap around DEBUG_PRINTS class
    defined in pudebug.h    
  
    This is the exported header file, that the users are allowed to modify.
    If there are no custom definitions, please use the templated version
    in the root iisrearc\inc\dbgutil.h
 
Author:

    Murali R. Krishnan (MuraliK)    22-Sept-1994

--*/


# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_



// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputKdb )

// end_user_modifiable


//
// include standard debug support
//
// note: define DEFAULT_OUTPUT_FLAGS before including pudebug.h
//

# include <pudebug.h>


// begin_user_modifiable

// Use the default constants from pudebug.h: 0x00000001 to 0x00000100

//
//  Define the debugging constants as bit-flag values
//  Example: # define DEBUG_FOOBAR 0x00010000
//  Note: All debugging bit-values below 0x00001000 are reserved!
// 
//  If you add or change a flag, please update FlagTableWp
//  in core\common\dtflags\dtflags.c
//

#define DEBUG_DLL_SECURITY             0x80000000
#define DEBUG_CONN                     0x40000000
#define DEBUG_HANDLE_REQUEST           0x20000000
#define DEBUG_STATICFILE               0x10000000
#define DEBUG_ISAPI                    0x08000000


// end_user_modifiable


# endif  /* _DBGUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\dav_handler.h ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    dav_handler.h

Abstract:

    Handler class for DAV

Author:

    Taylor Weiss (TaylorW)       01-Feb-1999

Revision History:

--*/

#ifndef _DAV_HANDLER_H_
#define _DAV_HANDLER_H_

#include "isapi_handler.h"

#define DAV_MODULE_NAME       L"httpext.dll"

//
// The W3_DAV_HANDLER is essentially just a wrapper for
// the W3_ISAPI_HANDLER.  It takes the original target of
// the request URL and submits it to the ISAPI handler
// as if it were script mapped to the DAV ISAPI.
//

class W3_DAV_HANDLER : public W3_ISAPI_HANDLER
{
public:

    W3_DAV_HANDLER( W3_CONTEXT * pW3Context )
        : W3_ISAPI_HANDLER( pW3Context, NULL )
    {
    }

    WCHAR *
    QueryName(
        VOID
        )
    {
        return L"DAVHandler";
    }

    CONTEXT_STATUS
    DoWork(
        VOID
        );

    CONTEXT_STATUS
    OnCompletion(
        DWORD                   cbCompletion,
        DWORD                   dwCompletionStatus
        );

    static
    HRESULT
    W3_DAV_HANDLER::Initialize(
        VOID
        );

    static
    VOID
    Terminate(
        VOID
        )
    {
    }

    static
    LPCWSTR
    QueryDavImage(
        VOID
        );

private:

    //
    // Avoid c++ errors
    //

    W3_DAV_HANDLER( const W3_DAV_HANDLER & )
        : W3_ISAPI_HANDLER( NULL, NULL )
    {
    }

    W3_DAV_HANDLER & operator = ( const W3_DAV_HANDLER & ) { return *this; }

};

#endif // _DAV_HANDLER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\dav_handler.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     dav_handler.cxx

   Abstract:
     Handle DAV requests
 
   Author:
     Taylor Weiss (TaylorW)             27-Jan-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include "dav_handler.h"

WCHAR   g_szDavImage[MAX_PATH+1] = DAV_MODULE_NAME;

// static
HRESULT
W3_DAV_HANDLER::Initialize(
    VOID
    )
{
    WCHAR   szTemp[MAX_PATH+1];
    WCHAR * szPtr = NULL;
    
    DBG_ASSERT( W3_ISAPI_HANDLER::QueryIsInitialized() );

    //
    // Get a full path to the DAV extension
    //

    if ( GetModuleFileName( GetModuleHandle( NULL ), szTemp, MAX_PATH ) )
    {
        szTemp[MAX_PATH] = L'\0';

        szPtr = wcsrchr( szTemp, L'\\' );

        if ( szPtr )
        {
            wcsncpy( szPtr+1, DAV_MODULE_NAME, MAX_PATH-(szPtr-szTemp+1) );
            szTemp[MAX_PATH] = L'\0';
        }
    }
    
    if ( szPtr )
    {
        wcsncpy( g_szDavImage, szTemp, MAX_PATH );
        g_szDavImage[MAX_PATH] = '\0';
    }

    return NO_ERROR;
}


CONTEXT_STATUS
W3_DAV_HANDLER::DoWork(
    VOID
)
{
    W3_CONTEXT *pW3Context = QueryW3Context();
    DBG_ASSERT( pW3Context != NULL );

    HRESULT                 hr = NO_ERROR;

    DBG_ASSERT( W3_ISAPI_HANDLER::QueryIsInitialized() );

    //
    // Set the DAV ISAPI for this request
    //

    hr = W3_ISAPI_HANDLER::SetDavRequest( g_szDavImage );

    if ( FAILED( hr ) )
    {
        goto Failed;
    }

    return W3_ISAPI_HANDLER::DoWork();

Failed:

    //
    // BUGBUG - This code won't return an entity body
    // to the client...but if we can't allocate a
    // W3_ISAPI_HANDLER, we probably can't allocate
    // an entity body either.
    //
    // Actually, the whole thing is probably destined
    // to fail if we're really that low on memory, and
    // we could probably just fire off a debugger
    // message and return STATUS_CONTINUE...
    //
    
    W3_RESPONSE *   pResponse = pW3Context->QueryResponse();

    DBG_ASSERT( pResponse );

    pResponse->Clear();
    pW3Context->SetErrorStatus( hr );
    pResponse->SetStatus( HttpStatusServerError );

    pW3Context->SendResponse( W3_FLAG_SYNC );

    return CONTEXT_STATUS_CONTINUE;
}

CONTEXT_STATUS
W3_DAV_HANDLER::OnCompletion(
    DWORD                   cbCompletion,
    DWORD                   dwCompletionStatus
    )
{
    DBG_ASSERT( W3_ISAPI_HANDLER::QueryIsInitialized() );

    //
    // Hand off the completion to the ISAPI handler
    //

    return W3_ISAPI_HANDLER::OnCompletion(
        cbCompletion,
        dwCompletionStatus
        );
}

LPCWSTR
W3_DAV_HANDLER::QueryDavImage(
    VOID
    )
{
    return g_szDavImage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\digestcontextcache.cxx ===
/*++

   Copyright    (c)    2000-2001    Microsoft Corporation

   Module  Name :

      digestcontextcache.cxx

   Abstract:

      Server context cache for Digest authentication

   Author:

      Ming Lu            (minglu)         June-10-2001

   Revision History:

--*/

#include "precomp.hxx"

ALLOC_CACHE_HANDLER * DIGEST_CONTEXT_CACHE_ENTRY::
                             sm_pachDigestContextCacheEntry = NULL;

//static
HRESULT
DIGEST_CONTEXT_CACHE_ENTRY::Initialize(
    VOID
)
/*++

  Description:

    Digest server context entry lookaside initialization

  Arguments:

    None
    
  Return:

    HRESULT

--*/
{
    ALLOC_CACHE_CONFIGURATION   acConfig;
    HRESULT                     hr;    

    //
    // Initialize allocation lookaside
    //    
    
    acConfig.nConcurrency = 1;
    acConfig.nThreshold   = 100;
    acConfig.cbSize       = sizeof( DIGEST_CONTEXT_CACHE_ENTRY );

    DBG_ASSERT( sm_pachDigestContextCacheEntry == NULL );
    
    sm_pachDigestContextCacheEntry = new ALLOC_CACHE_HANDLER( 
                                    "DIGEST_CONTEXT_CACHE_ENTRY",  
                                    &acConfig );

    if ( sm_pachDigestContextCacheEntry == NULL || 
         !sm_pachDigestContextCacheEntry->IsValid() )
    {
        if( sm_pachDigestContextCacheEntry != NULL )
        {
            delete sm_pachDigestContextCacheEntry;
            sm_pachDigestContextCacheEntry = NULL;
        }

        hr = HRESULT_FROM_WIN32( GetLastError() );

        DBGPRINTF(( DBG_CONTEXT,
           "Error initializing sm_pachDigestContextCacheEntry. hr = 0x%x\n",
           hr ));

        return hr;
    }
    
    return NO_ERROR;
}

//static
VOID
DIGEST_CONTEXT_CACHE_ENTRY::Terminate(
    VOID
)
/*++

  Description:

    Digest server context cache cleanup

  Arguments:

    None
    
  Return:

    None

--*/
{
    if ( sm_pachDigestContextCacheEntry != NULL )
    {
        delete sm_pachDigestContextCacheEntry;
        sm_pachDigestContextCacheEntry = NULL;
    }
}

HRESULT
DIGEST_CONTEXT_CACHE::Initialize(
    VOID
)
/*++

  Description:

    Initialize digest server context cache

  Arguments:

    None

  Return:

    HRESULT

--*/
{
    HRESULT             hr;
    DWORD               csecTTL = DEFAULT_CACHED_DIGEST_CONTEXT_TTL;

    //
    // We'll use TTL for scavenge period, and expect two inactive periods to
    // flush
    //
    
    hr = SetCacheConfiguration( csecTTL * 1000,
                                csecTTL * 1000,
                                0,
                                NULL );
    if ( FAILED( hr ) )
    {
        return hr;
    }
        
    return DIGEST_CONTEXT_CACHE_ENTRY::Initialize();
}

VOID
DIGEST_CONTEXT_CACHE::Terminate(
    VOID
)
/*++

  Description:

    Terminate digest server context cache

  Arguments:

    None

  Return:

    None

--*/
{
    return DIGEST_CONTEXT_CACHE_ENTRY::Terminate();
}

HRESULT
DIGEST_CONTEXT_CACHE::AddContextCacheEntry(
    IN CtxtHandle * phCtxtHandle
)
/*++

  Description:

    Add a digest server context to the cache

  Arguments:

    phCtxtHandle - Pointer to a digest server context handle

  Return:

    HRESULT

--*/
{
    HRESULT                              hr;
    DIGEST_CONTEXT_CACHE_KEY             cacheKey;
    DIGEST_CONTEXT_CACHE_ENTRY *         pContextCacheEntry = NULL;

    if ( phCtxtHandle == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // Generate the cache key to look for
    //

    hr = cacheKey.CreateCacheKey( phCtxtHandle );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    //
    // Look for the cache entry
    //
    
    hr = FindCacheEntry( &cacheKey,
                         ( CACHE_ENTRY ** )&pContextCacheEntry );
    if ( SUCCEEDED( hr ) )
    {
        //
        // Cache hit, meaning the security context is a full formed 
        // context after the second ASC call, thus the ref count for 
        // it in LSA is two now
        //
            
        DBG_ASSERT( pContextCacheEntry != NULL );

        //
        // Decrement the ref count for the security context in LSA 
        // to one, so the scanvenger could delete the security 
        // context when the TTL for the security context is expired.
        // This is done by the caller of this function
        //

        hr = E_FAIL;

        goto exit;
    }

    DBG_ASSERT( pContextCacheEntry == NULL );

    //
    // For cache miss, create a cache entry and add it
    //

    //
    // Create the entry
    //

    pContextCacheEntry = new DIGEST_CONTEXT_CACHE_ENTRY( this );
    if ( pContextCacheEntry == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    //
    // Set the cache key
    //
    
    hr = pContextCacheEntry->SetCacheKey( &cacheKey );
    if ( FAILED( hr ) )
    {
        goto exit;
    }

    hr = AddCacheEntry( pContextCacheEntry );

exit:

    if( pContextCacheEntry != NULL )
    {
        pContextCacheEntry->DereferenceCacheEntry();
        pContextCacheEntry = NULL;
    }

    return hr;

}

DIGEST_CONTEXT_CACHE_ENTRY::~DIGEST_CONTEXT_CACHE_ENTRY()
{
    DBG_ASSERT( CheckSignature() );
    m_dwSignature = DIGEST_CONTEXT_CACHE_ENTRY_FREE_SIGNATURE;

    if( m_cacheKey.QueryContextHandle() != NULL )
    {
        if (g_pW3Server->QueryDigestContextCache()->QueryTraceLog() != NULL)
        {
            WriteRefTraceLogEx(g_pW3Server->QueryDigestContextCache()->QueryTraceLog(),
                               0,
                               (PVOID)m_cacheKey.QueryContextHandle()->dwLower,
                               (PVOID)m_cacheKey.QueryContextHandle()->dwUpper,
                               NULL,
                               NULL);
        }

        DeleteSecurityContext( m_cacheKey.QueryContextHandle() );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\digestprovider.cxx ===
/*++
   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     digestprovider.cxx

   Abstract:
     Digest authentication provider
 
   Author:
     Ming Lu (minglu)             24-Jun-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include "uuencode.hxx"

//static
HRESULT
DIGEST_AUTH_PROVIDER::Initialize(
    DWORD dwInternalId
)
/*++

Routine Description:

    Initialize Digest SSPI provider 

Arguments:

    None
    
Return Value:

    HRESULT

--*/
{
    SetInternalId( dwInternalId );

    return NO_ERROR;
}

//static
VOID
DIGEST_AUTH_PROVIDER::Terminate(
    VOID
)
/*++

Routine Description:

    Terminate SSPI Digest provider

Arguments:

    None
    
Return Value:

    None

--*/
{
    // no-op
}

HRESULT
DIGEST_AUTH_PROVIDER::DoesApply(
    W3_MAIN_CONTEXT *           pMainContext,
    BOOL *                      pfApplies
)
/*++

Routine Description:

    Does the given request have credentials applicable to the Digest 
    provider

Arguments:

    pMainContext - Main context representing request
    pfApplies - Set to true if Digest is applicable
    
    
Return Value:

    HRESULT

--*/
{
    SSPI_CONTEXT_STATE *    pContextState;
    LPCSTR                  pszAuthHeader;
    HRESULT                 hr;
    PCHAR                   szDigest = "Digest";
    DWORD                   cchDigest = sizeof("Digest") - 1;
    USHORT                  cchAuthHeader = 0;
    
    if ( pMainContext == NULL ||
         pfApplies == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    } 
    
    *pfApplies = FALSE;

    //
    // Is using of Digest SSP enabled?    
    //
    if ( !g_pW3Server->QueryUseDigestSSP() )
    {
        return NO_ERROR;
    }

    //
    // Get authorization header
    //
    
    pszAuthHeader = pMainContext->QueryRequest()->GetHeader( HttpHeaderAuthorization,
                                                             &cchAuthHeader );
    
    //
    // No package, no auth
    //
    
    if ( pszAuthHeader == NULL )
    {
        return NO_ERROR;
    }
    
    //
    // Is it Digest?
    //
    
    if ( _strnicmp( pszAuthHeader, szDigest, cchDigest ) == 0 )
    {
        //
        // Save away the package so we don't have to calc again
        //

        DBG_ASSERT( pszAuthHeader != NULL );
               
        pContextState = new (pMainContext) SSPI_CONTEXT_STATE( 
                        ( cchAuthHeader > cchDigest ) ? ( pszAuthHeader + cchDigest + 1 ) : "" );
        if ( pContextState == NULL )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }

        hr = pContextState->SetPackage( szDigest );
        if ( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Error in SetPackage().  hr = %x\n",
                        hr ));
            delete pContextState;
            pContextState = NULL;
            return hr;
        }

        pMainContext->SetContextState( pContextState );

        *pfApplies = TRUE;
    }
    
    return NO_ERROR;
}

HRESULT
DIGEST_AUTH_PROVIDER::DoAuthenticate(
    W3_MAIN_CONTEXT *       pMainContext,
    BOOL *                  // unused
)
/*++

Description:

    Do authentication work (we will be called if we apply)

Arguments:

    pMainContext - Main context
    pfFilterFinished - Set to TRUE if filter wants out
    
Return Value:

    HRESULT

--*/
{
    DWORD                       err;
    HRESULT                     hr                     = E_FAIL;
    W3_METADATA *               pMetaData              = NULL;
    W3_REQUEST *                pW3Request             = NULL;
    SSPI_SECURITY_CONTEXT     * pDigestSecurityContext = NULL;
    SSPI_CONTEXT_STATE        * pContextState          = NULL;
    SSPI_USER_CONTEXT         * pUserContext           = NULL;
    SSPI_CREDENTIAL *           pDigestCredentials     = NULL;

    SecBufferDesc               SecBuffDescOutput;
    SecBufferDesc               SecBuffDescInput;

    //
    // We have 5 input buffer and 1 output buffer to fill data 
    // in for digest authentication
    //

    SecBuffer                   SecBuffTokenOut[ 1 ];
    SecBuffer                   SecBuffTokenIn[ 5 ];

    SECURITY_STATUS             secStatus              = SEC_E_OK;

    CtxtHandle                  hServerCtxtHandle;

    TimeStamp                   Lifetime;

    ULONG                       ContextReqFlags        = 0;
    ULONG                       ContextAttributes      = 0;

    STACK_STRU(                 strOutputHeader, 256 );

    STACK_BUFFER(               bufOutputBuffer, 4096 );
    STACK_STRA(                 strMethod,       10 );
    STACK_STRU(                 strUrl,          MAX_PATH );
    STACK_STRA(                 strUrlA,         MAX_PATH );
    STACK_STRU(                 strRealm,        128 );

    SecPkgContext_Target        Target;
    STACK_STRU(                 strDigestUri, MAX_PATH + 1 );
    ULONG                       cbBytesCopied;

    SecInvalidateHandle( &hServerCtxtHandle );

    if ( pMainContext == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    pContextState = ( SSPI_CONTEXT_STATE* ) 
                    pMainContext->QueryContextState();
    DBG_ASSERT( pContextState != NULL );
    
    pMetaData = pMainContext->QueryUrlContext()->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );
    
    pW3Request = pMainContext->QueryRequest();
    DBG_ASSERT( pW3Request != NULL );
    
    //
    //  clean the memory and set it to zero
    //
    ZeroMemory( &SecBuffDescInput , sizeof( SecBufferDesc ) );
    ZeroMemory( SecBuffTokenIn    , sizeof( SecBuffTokenIn ) );

    //
    //  define the buffer descriptor for the Input
    //

    SecBuffDescInput.ulVersion     = SECBUFFER_VERSION;
    SecBuffDescInput.cBuffers      = 5;
    SecBuffDescInput.pBuffers      = SecBuffTokenIn;

    //
    // set the digest auth header in the buffer
    //

    SecBuffTokenIn[0].BufferType   = SECBUFFER_TOKEN;
    SecBuffTokenIn[0].cbBuffer     = strlen(pContextState->QueryCredentials());
    SecBuffTokenIn[0].pvBuffer     = (void*) pContextState->QueryCredentials();

    //  
    //  Get and Set the information for the method
    //
    
    hr = pW3Request->GetVerbString( &strMethod );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error getting the method.  hr = %x\n",
                    hr ));
        return hr;
    }

    SecBuffTokenIn[1].BufferType   = SECBUFFER_PKG_PARAMS;
    SecBuffTokenIn[1].cbBuffer     = strMethod.QueryCB();
    SecBuffTokenIn[1].pvBuffer     = ( PVOID )strMethod.QueryStr();

    //
    // Get and Set the infomation for the Url
    //

    hr = pW3Request->GetUrl( &strUrl );
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error getting the URL.  hr = %x\n",
                    hr ));
        return hr;
    }
    
    hr = strUrlA.CopyW( strUrl.QueryStr() );
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error copying the URL.  hr = %x\n",
                    hr ));
        return hr;
    }
    
    SecBuffTokenIn[2].BufferType   = SECBUFFER_PKG_PARAMS;
    SecBuffTokenIn[2].cbBuffer     = strUrlA.QueryCB();
    SecBuffTokenIn[2].pvBuffer     = ( PVOID )strUrlA.QueryStr();


    //
    //  Get and Set the information for the hentity
    //
    SecBuffTokenIn[3].BufferType   = SECBUFFER_PKG_PARAMS;
    SecBuffTokenIn[3].cbBuffer     = 0;       // this is not yet implemeted
    SecBuffTokenIn[3].pvBuffer     = NULL;    // this is not yet implemeted   

    //
    //  Get a Security Context
    //

    // 
    // get the credential for the server
    //
    
    hr = SSPI_CREDENTIAL::GetCredential( NTDIGEST_SP_NAME,
                                         &pDigestCredentials );    
    if ( FAILED( hr ) )
    {
        DBGPRINTF((DBG_CONTEXT,
                  "Error get credential handle. hr = 0x%x \n",
                  hr ));
        
        return hr;
    }

    DBG_ASSERT( pDigestCredentials != NULL );

    //
    // Resize the output buffer to max token size
    //
    if( !bufOutputBuffer.Resize( 
                  pDigestCredentials->QueryMaxTokenSize() ) )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }

    if( pW3Request->IsProxyRequest() )
    {
        //
        // If the request comes from a proxy, we shouldn't use the 
        // security context associate with the connection because 
        // the request could actually come from a different client
        //

        SetConnectionAuthContext( pMainContext,
                                  NULL );  
    }

    pDigestSecurityContext = 
       ( SSPI_SECURITY_CONTEXT * ) QueryConnectionAuthContext( pMainContext );

    //
    // check to see if there is an old Context Handle
    //
    if ( pDigestSecurityContext != NULL )
    {
        //
        // defined the buffer
        //
        SecBuffTokenIn[4].BufferType   = SECBUFFER_TOKEN;
        SecBuffTokenIn[4].cbBuffer     = bufOutputBuffer.QuerySize();
        SecBuffTokenIn[4].pvBuffer     = 
                            ( PVOID )bufOutputBuffer.QueryPtr();

        secStatus = VerifySignature(
                            pDigestSecurityContext->QueryContextHandle(),
                            &SecBuffDescInput,
                            0,
                            0 );
        if( FAILED( secStatus ) )
        {
            //
            // Clean up the security context cause we will initialize 
            // another new challenge on the same connection
            //
            
            SetConnectionAuthContext( pMainContext,
                                      NULL );  
        }
    }
    
    if( pDigestSecurityContext == NULL || FAILED( secStatus ) )
    {
        //
        //  clean the memory and set it to zero
        //
        ZeroMemory( &SecBuffDescOutput, sizeof( SecBufferDesc ) );
        ZeroMemory( SecBuffTokenOut   , sizeof( SecBuffTokenOut ) );

        //
        //  define the buffer descriptor for the Outpt
        //
        SecBuffDescOutput.ulVersion    = SECBUFFER_VERSION;
        SecBuffDescOutput.cBuffers     = 1;
        SecBuffDescOutput.pBuffers     = SecBuffTokenOut;

        SecBuffTokenOut[0].BufferType  = SECBUFFER_TOKEN;
        SecBuffTokenOut[0].cbBuffer    = bufOutputBuffer.QuerySize();
        SecBuffTokenOut[0].pvBuffer    = ( PVOID )bufOutputBuffer.QueryPtr();

        //
        // Get and Set the Realm Information
        //

        if( pMetaData->QueryRealm() )
        {
            hr = strRealm.Copy( pMetaData->QueryRealm() );
            if( FAILED( hr ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "Error copying the realm.  hr = %x\n",
                            hr ));
                return hr;
            }

            //
            // Limit the realm length to 1024 since there is limitation in Digest SSP  
            //

            if( strRealm.QueryCCH() > 1024 )
            {
                return E_FAIL;
            }

            SecBuffTokenIn[4].BufferType   = SECBUFFER_PKG_PARAMS;
            SecBuffTokenIn[4].cbBuffer     = strRealm.QueryCB();  
            SecBuffTokenIn[4].pvBuffer     = ( PVOID )strRealm.QueryStr(); 
        }
        else
        {
            SecBuffTokenIn[4].BufferType   = SECBUFFER_PKG_PARAMS;
            SecBuffTokenIn[4].cbBuffer     = 0;  
            SecBuffTokenIn[4].pvBuffer     = NULL; 
        }

        //
        //  set the flags
        //
        ContextReqFlags = ASC_REQ_REPLAY_DETECT | 
                          ASC_REQ_CONNECTION;

        //
        // Register the remote IP address with LSA so that it can be logged
        //

        if( pW3Request->QueryRemoteAddressType() == AF_INET )
        {
            secStatus = SecpSetIPAddress( 
                            ( PUCHAR )pW3Request->QueryRemoteSockAddress(),
                            sizeof( SOCKADDR_IN ) );
        }
        else if( pW3Request->QueryRemoteAddressType() == AF_INET6 )
        {
            secStatus = SecpSetIPAddress( 
                            ( PUCHAR )pW3Request->QueryRemoteSockAddress(),
                            sizeof( SOCKADDR_IN6 ) );
        }
        else
        {
            DBG_ASSERT( FALSE );
        }

        if( FAILED( secStatus ) )
        {
            return secStatus;
        }
    
        ThreadPoolSetInfo( ThreadPoolIncMaxPoolThreads, 0 );

        //
        // get the security context
        //
        secStatus = AcceptSecurityContext(
                        pDigestCredentials->QueryCredHandle(),
                        NULL,
                        &SecBuffDescInput,
                        ContextReqFlags,
                        SECURITY_NATIVE_DREP,
                        &hServerCtxtHandle,
                        &SecBuffDescOutput,
                        &ContextAttributes,
                        &Lifetime);

        if (g_pW3Server->QueryDigestContextCache()->QueryTraceLog() != NULL)
        {
            WriteRefTraceLogEx(g_pW3Server->QueryDigestContextCache()->QueryTraceLog(),
                               1,
                               (PVOID)hServerCtxtHandle.dwLower,
                               (PVOID)hServerCtxtHandle.dwUpper,
                               (PVOID)(ULONG_PTR)secStatus,
                               NULL);
        }

        ThreadPoolSetInfo( ThreadPoolDecMaxPoolThreads, 0 );

        if( secStatus == SEC_E_WRONG_PRINCIPAL )
        {
            //
            // The error is caused by changes of the machine password, we 
            // need to regenerate a credential handle in this case
            //
        
            SSPI_CREDENTIAL::RemoveCredentialFromCache( pDigestCredentials );

            hr = SSPI_CREDENTIAL::GetCredential( NTDIGEST_SP_NAME,
                                                 &pDigestCredentials );
        
            if ( FAILED( hr ) )
            {
                DBGPRINTF((DBG_CONTEXT,
                          "Error get credential handle. hr = 0x%x \n",
                          hr ));
            
                return hr;
            }

            //
            // Register the remote IP address with LSA so that it can be logged
            //

            if( pW3Request->QueryRemoteAddressType() == AF_INET )
            {
                secStatus = SecpSetIPAddress( 
                                ( PUCHAR )pW3Request->QueryRemoteSockAddress(),
                                sizeof( SOCKADDR_IN ) );
            }
            else if( pW3Request->QueryRemoteAddressType() == AF_INET6 )
            {
                secStatus = SecpSetIPAddress( 
                                ( PUCHAR )pW3Request->QueryRemoteSockAddress(),
                                sizeof( SOCKADDR_IN6 ) );
            }
            else
            {
                DBG_ASSERT( FALSE );
            }

            if( FAILED( secStatus ) )
            {
                return secStatus;
            }
    
            ThreadPoolSetInfo( ThreadPoolIncMaxPoolThreads, 0 );

            secStatus = AcceptSecurityContext( pDigestCredentials->QueryCredHandle(),
                                               NULL,
                                               &SecBuffDescInput,
                                               ContextReqFlags,
                                               SECURITY_NATIVE_DREP,
                                               &hServerCtxtHandle,
                                               &SecBuffDescOutput,
                                               &ContextAttributes,
                                               &Lifetime );

            if (g_pW3Server->QueryDigestContextCache()->QueryTraceLog() != NULL)
            {
                WriteRefTraceLogEx(g_pW3Server->QueryDigestContextCache()->QueryTraceLog(),
                                   1,
                                   (PVOID)hServerCtxtHandle.dwLower,
                                   (PVOID)hServerCtxtHandle.dwUpper,
                                   (PVOID)(ULONG_PTR)secStatus,
                                   NULL);
            }

            ThreadPoolSetInfo( ThreadPoolDecMaxPoolThreads, 0 );

        }
        
        if( SEC_I_COMPLETE_NEEDED == secStatus ) 
        {
            //
            //defined the buffer
            //

            SecBuffTokenIn[4].BufferType   = SECBUFFER_TOKEN;
            SecBuffTokenIn[4].cbBuffer     = bufOutputBuffer.QuerySize();
            SecBuffTokenIn[4].pvBuffer     = 
                                ( PVOID )bufOutputBuffer.QueryPtr();

            secStatus = CompleteAuthToken( 
                                &hServerCtxtHandle, 
                                &SecBuffDescInput 
                                );
        }

        if ( SUCCEEDED( secStatus ) )
        {
            //
            // Check URI field match URL
            //

            secStatus = QueryContextAttributes( &hServerCtxtHandle,
                                                SECPKG_ATTR_TARGET,
                                                &Target );
            if( SUCCEEDED( secStatus ) )
            {   
                if( Target.TargetLength )
                {
                    if( !strDigestUri.QueryBuffer()->Resize( 
                                           (Target.TargetLength + 1) * sizeof(WCHAR) ) )
                    {
                        FreeContextBuffer( Target.Target );
                        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
                        goto Cleanup;
                    }

                    //
                    // Normalize DigestUri 
                    //

                    hr = UlCleanAndCopyUrl( ( PUCHAR )Target.Target,
                                            Target.TargetLength,
                                            &cbBytesCopied,
                                            strDigestUri.QueryStr(),
                                            NULL );

                    FreeContextBuffer( Target.Target );

                    if( FAILED( hr ) )
                    {
                        goto Cleanup;
                    }

                    //
                    // after modyfing string data in internal buffer
                    // call SyncWithBuffer to synchronize string length
                    //
                    strDigestUri.SyncWithBuffer();

                    if ( !strUrl.Equals( strDigestUri ) )
                    {
                        //
                        // Note: RFC says that BAD REQUEST should be returned
                        // but for now to be backward compatible with IIS5.1
                        // we will return ACCESS_DENIED
                        //

                        if (g_pW3Server->QueryDigestContextCache()->QueryTraceLog() != NULL)
                        {
                            WriteRefTraceLogEx(g_pW3Server->QueryDigestContextCache()->QueryTraceLog(),
                                               0,
                                               (PVOID)hServerCtxtHandle.dwLower,
                                               (PVOID)hServerCtxtHandle.dwUpper,
                                               NULL,
                                               NULL);
                        }

                        DeleteSecurityContext( &hServerCtxtHandle );
                        secStatus = E_FAIL;
                    }
                    else
                    {
                        pDigestSecurityContext = new SSPI_SECURITY_CONTEXT( 
                                                           pDigestCredentials,
                                                           TRUE );
                        if ( NULL == pDigestSecurityContext )
                        {
                            hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
                            goto Cleanup;
                        }

                        pDigestSecurityContext->SetContextHandle( 
                                                   hServerCtxtHandle );

                        pDigestSecurityContext->SetContextAttributes( 
                                                   ContextAttributes );

                        //
                        // Mark the security context is complete, so we can detect 
                        // reauthentication on the same connection
                        //
        
                        pDigestSecurityContext->SetIsComplete( TRUE );

                        if (FAILED( hr = SetConnectionAuthContext(
                                             pMainContext,
                                             pDigestSecurityContext )))
                        {
                            //
                            // There is no connection, no point creating
                            // the response
                            //
                            goto Cleanup;
                        }
                    }
                }
                else
                {
                    if (g_pW3Server->QueryDigestContextCache()->QueryTraceLog() != NULL)
                    {
                        WriteRefTraceLogEx(g_pW3Server->QueryDigestContextCache()->QueryTraceLog(),
                                           0,
                                           (PVOID)hServerCtxtHandle.dwLower,
                                           (PVOID)hServerCtxtHandle.dwUpper,
                                           NULL,
                                           NULL);
                    }

                    DeleteSecurityContext( &hServerCtxtHandle );
                    secStatus = E_FAIL;
                }
            }    
            else
            {
                if (g_pW3Server->QueryDigestContextCache()->QueryTraceLog() != NULL)
                {
                    WriteRefTraceLogEx(g_pW3Server->QueryDigestContextCache()->QueryTraceLog(),
                                       0,
                                       (PVOID)hServerCtxtHandle.dwLower,
                                       (PVOID)hServerCtxtHandle.dwUpper,
                                       NULL,
                                       NULL);
                }

                DeleteSecurityContext( &hServerCtxtHandle );
            }
        }
    }

    if( FAILED( secStatus ) )
    {
        err = GetLastError();
        if( err == ERROR_PASSWORD_MUST_CHANGE ||
            err == ERROR_PASSWORD_EXPIRED )
        {
            return HRESULT_FROM_WIN32( err );
        }

        hr = SetDigestHeader( pMainContext );
        if( FAILED( hr ) )
        {
            return hr;
        }

        pMainContext->SetProviderHandled( TRUE );

        pMainContext->QueryResponse()->SetStatus( HttpStatusUnauthorized,
                                                  Http401BadLogon );
                                                  
        pMainContext->SetErrorStatus( secStatus );
    }
    else
    {
        //
        // Create a user context and set it up
        //
        
        pUserContext = new SSPI_USER_CONTEXT( this );
        if ( pUserContext == NULL )
        {
            return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        } 
        
        hr = pUserContext->Create( pDigestSecurityContext, pMainContext );
        if ( FAILED( hr ) )
        {
            pUserContext->DereferenceUserContext();
            pUserContext = NULL;
            return hr;
        }
        
        pMainContext->SetUserContext( pUserContext );  
    }

    return NO_ERROR;

 Cleanup:

    if ( pDigestSecurityContext != NULL )
    {
        pDigestSecurityContext->Cleanup();
        pDigestSecurityContext = NULL;
    }
    else if ( SecIsValidHandle( &hServerCtxtHandle ) )
    {
        if (g_pW3Server->QueryDigestContextCache()->QueryTraceLog() != NULL)
        {
            WriteRefTraceLogEx(g_pW3Server->QueryDigestContextCache()->QueryTraceLog(),
                               0,
                               (PVOID)hServerCtxtHandle.dwLower,
                               (PVOID)hServerCtxtHandle.dwUpper,
                               NULL,
                               NULL);
        }

        DeleteSecurityContext( &hServerCtxtHandle );
    }

    return hr;
}

HRESULT
DIGEST_AUTH_PROVIDER::OnAccessDenied(
    W3_MAIN_CONTEXT *       pMainContext
)
/*++

  Description:
    
    Add WWW-Authenticate Digest headers on access denied

Arguments:

    pMainContext - main context
    
Return Value:

    HRESULT

--*/
{
    if ( pMainContext == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // Is using of Digest SSP enabled?    
    //
    if ( !g_pW3Server->QueryUseDigestSSP() )
    {
        return NO_ERROR;
    }

    if( !W3_STATE_AUTHENTICATION::QueryIsDomainMember() )
    {
        //
        // We are not a domain member, so do nothing
        //
        return NO_ERROR;
    }

    return SetDigestHeader( pMainContext );
}

HRESULT
DIGEST_AUTH_PROVIDER::SetDigestHeader(
    IN  W3_MAIN_CONTEXT *          pMainContext
)
/*++

  Description:
    
    Add WWW-Authenticate Digest headers

Arguments:

    pMainContext - main context
    
Return Value:

    HRESULT

--*/
{
    HRESULT                 hr                    = E_FAIL;
    W3_METADATA *           pMetaData;

    //
    // 4096 is the max output for digest authenticaiton
    //
    
    STACK_BUFFER(           bufOutputBuffer, 4096 );
    STACK_STRA(             strOutputHeader, MAX_PATH ); 
    STACK_STRA(             strMethod,       10 );
    STACK_STRU(             strUrl,          MAX_PATH );
    STACK_STRA(             strUrlA,         MAX_PATH );
    STACK_STRU(             strRealm,        128 );

    SecBufferDesc           SecBuffDescOutput;
    SecBufferDesc           SecBuffDescInput;

    SecBuffer               SecBuffTokenOut[ 1 ];
    SecBuffer               SecBuffTokenIn[ 5 ];

    SECURITY_STATUS         secStatus              = SEC_E_OK;

    SSPI_CREDENTIAL *       pDigestCredential      = NULL;
    CtxtHandle              hServerCtxtHandle;

    ULONG                   ContextReqFlags        = 0;
    ULONG                   ContextAttributes      = 0;
    TimeStamp               Lifetime;

    pMetaData = pMainContext->QueryUrlContext()->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );

    //
    //  Get a Security Context
    //

    // 
    // get the credential for the server
    //
    
    hr = SSPI_CREDENTIAL::GetCredential( NTDIGEST_SP_NAME,
                                         &pDigestCredential );    
    if ( FAILED( hr ) )
    {
        DBGPRINTF((DBG_CONTEXT,
                  "Error get credential handle. hr = 0x%x \n",
                  hr ));
        
        return hr;
    }

    DBG_ASSERT( pDigestCredential != NULL );

    if( !bufOutputBuffer.Resize( 
                  pDigestCredential->QueryMaxTokenSize() ) )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );

        DBGPRINTF((DBG_CONTEXT,
                  "Error resize the output buffer. hr = 0x%x \n",
                  hr ));
        
        return hr;
    }


    //
    //  clean the memory and set it to zero
    //
    ZeroMemory( &SecBuffDescOutput, sizeof( SecBufferDesc ) );
    ZeroMemory( SecBuffTokenOut   , sizeof( SecBuffTokenOut ) );

    ZeroMemory( &SecBuffDescInput , sizeof( SecBufferDesc ) );
    ZeroMemory( SecBuffTokenIn    , sizeof( SecBuffTokenIn ) );

    //
    // define the OUTPUT
    //
    
    SecBuffDescOutput.ulVersion    = SECBUFFER_VERSION;
    SecBuffDescOutput.cBuffers     = 1;
    SecBuffDescOutput.pBuffers     = SecBuffTokenOut;

    SecBuffTokenOut[0].BufferType  = SECBUFFER_TOKEN;
    SecBuffTokenOut[0].cbBuffer    = bufOutputBuffer.QuerySize(); 
    SecBuffTokenOut[0].pvBuffer    = ( PVOID )bufOutputBuffer.QueryPtr();

    //
    //  define the Input
    //

    SecBuffDescInput.ulVersion     = SECBUFFER_VERSION;
    SecBuffDescInput.cBuffers      = 5;
    SecBuffDescInput.pBuffers      = SecBuffTokenIn;

    //
    //  Get and Set the information for the challenge
    //

    //
    // set the inforamtion in the buffer, this case is Null to 
    // authenticate user
    //
    SecBuffTokenIn[0].BufferType   = SECBUFFER_TOKEN;
    SecBuffTokenIn[0].cbBuffer     = 0; 
    SecBuffTokenIn[0].pvBuffer     = NULL;

    //  
    //  Get and Set the information for the method
    //
    
    hr = pMainContext->QueryRequest()->GetVerbString( &strMethod );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error getting the method.  hr = %x\n",
                    hr ));
        return hr;
    }

    SecBuffTokenIn[1].BufferType   = SECBUFFER_PKG_PARAMS;
    SecBuffTokenIn[1].cbBuffer     = strMethod.QueryCB();
    SecBuffTokenIn[1].pvBuffer     = strMethod.QueryStr();

    //
    // Get and Set the infomation for the Url
    //

    hr = pMainContext->QueryRequest()->GetUrl( &strUrl );
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error getting the URL.  hr = %x\n",
                    hr ));
        return hr;
    }
    
    hr = strUrlA.CopyW( strUrl.QueryStr() );
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error copying the URL.  hr = %x\n",
                    hr ));
        return hr;
    }
    
    SecBuffTokenIn[2].BufferType   = SECBUFFER_PKG_PARAMS;
    SecBuffTokenIn[2].cbBuffer     = strUrlA.QueryCB();
    SecBuffTokenIn[2].pvBuffer     = ( PVOID )strUrlA.QueryStr();

    //
    //  Get and Set the information for the hentity
    //
    SecBuffTokenIn[3].BufferType   = SECBUFFER_PKG_PARAMS;
    SecBuffTokenIn[3].cbBuffer     = 0;    // this is not yet implemeted
    SecBuffTokenIn[3].pvBuffer     = NULL; // this is not yet implemeted   

    //
    //Get and Set the Realm Information
    //

    if( pMetaData->QueryRealm() )
    {
        hr = strRealm.Copy( pMetaData->QueryRealm() );
        if( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Error copying the realm.  hr = %x\n",
                        hr ));
            return hr;
        }

        //
        // Limit the realm length to 1024 since there is limitation in Digest SSP  
        //

        if( strRealm.QueryCCH() > 1024 )
        {
            return E_FAIL;
        }

        SecBuffTokenIn[4].BufferType   = SECBUFFER_PKG_PARAMS;
        SecBuffTokenIn[4].cbBuffer     = strRealm.QueryCB();  
        SecBuffTokenIn[4].pvBuffer     = ( PVOID )strRealm.QueryStr(); 
    }
    else
    {
        SecBuffTokenIn[4].BufferType   = SECBUFFER_PKG_PARAMS;
        SecBuffTokenIn[4].cbBuffer     = 0;  
        SecBuffTokenIn[4].pvBuffer     = NULL; 
    }

    //
    //  set the flags
    //

    ContextReqFlags = ASC_REQ_REPLAY_DETECT | 
                      ASC_REQ_CONNECTION;

    ThreadPoolSetInfo( ThreadPoolIncMaxPoolThreads, 0 );

    //
    // get the security context
    //
    secStatus = AcceptSecurityContext(
                        pDigestCredential->QueryCredHandle(),
                        NULL,
                        &SecBuffDescInput,
                        ContextReqFlags,
                        SECURITY_NATIVE_DREP,
                        &hServerCtxtHandle,
                        &SecBuffDescOutput,
                        &ContextAttributes,
                        &Lifetime);

    if (g_pW3Server->QueryDigestContextCache()->QueryTraceLog() != NULL)
    {
        WriteRefTraceLogEx(g_pW3Server->QueryDigestContextCache()->QueryTraceLog(),
                           1,
                           (PVOID)hServerCtxtHandle.dwLower,
                           (PVOID)hServerCtxtHandle.dwUpper,
                           (PVOID)(ULONG_PTR)secStatus,
                           NULL);
    }

    ThreadPoolSetInfo( ThreadPoolDecMaxPoolThreads, 0 );

    //
    // a challenge has to be send back to the client
    //

    if ( SEC_I_CONTINUE_NEEDED == secStatus )
    {

        //
        // The partial server context generated from the ASC call needs 
        // to be deleted if the client doesn't authenticate again in some 
        // time, the digest security context cache will handle this  
        // 

        hr = g_pW3Server->QueryDigestContextCache()->
                AddContextCacheEntry( &hServerCtxtHandle );
        if( FAILED( hr ) )
        {
            if (g_pW3Server->QueryDigestContextCache()->QueryTraceLog() != NULL)
            {
                WriteRefTraceLogEx(g_pW3Server->QueryDigestContextCache()->QueryTraceLog(),
                                   0,
                                   (PVOID)hServerCtxtHandle.dwLower,
                                   (PVOID)hServerCtxtHandle.dwUpper,
                                   NULL,
                                   NULL);
            }

            DeleteSecurityContext( &hServerCtxtHandle );

            return hr;
        }

        //
        //  Do we already have a digest security context
        //
    
        hr = strOutputHeader.Copy( "Digest " );
        if( FAILED( hr ) )
        {
            return hr;
        } 

        hr = strOutputHeader.Append(
                ( CHAR * )SecBuffDescOutput.pBuffers[0].pvBuffer, 
                SecBuffDescOutput.pBuffers[0].cbBuffer );
        if( FAILED( hr ) )
        {
            return hr;
        }    

        //
        //  Add the header WWW-Authenticate to the response after a 
        //  401 server error
        //

        hr = pMainContext->QueryResponse()->SetHeader(
                                        "WWW-Authenticate",
                                        16,
                                        strOutputHeader.QueryStr(),
                                        (USHORT)strOutputHeader.QueryCCH() 
                                        );
    }
    else
    {
        hr = S_OK;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\generalhandler.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     generalhandler.cxx

   Abstract:
     A general purpose error sending handler.  This cleans up some of the 
     logic needed to allow DetermineHandler() to send HTTP errors.  
     
   Author:
     Bilal Alam (balam)             7-Jan-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include "generalhandler.hxx"

ALLOC_CACHE_HANDLER *       W3_GENERAL_HANDLER::sm_pachGeneralHandlers;

CONTEXT_STATUS
W3_GENERAL_HANDLER::DoWork(
    VOID
)
/*++

Routine Description:

    Send the configured error response to the client

Return Value:

    HRESULT

--*/
{
    HRESULT             hr;

    W3_CONTEXT *pW3Context = QueryW3Context();
    DBG_ASSERT( pW3Context != NULL );

    //
    // Setup the error response and send it
    //
    
    pW3Context->QueryResponse()->SetStatus( _httpStatus, _httpSubError ); 
    
    hr = pW3Context->SendResponse( W3_FLAG_ASYNC );
    if ( FAILED( hr ) )
    {
        pW3Context->SetErrorStatus( hr );
        pW3Context->QueryResponse()->SetStatus( HttpStatusServerError );
        return CONTEXT_STATUS_CONTINUE;
    }
    
    return CONTEXT_STATUS_PENDING;
}

// static
HRESULT
W3_GENERAL_HANDLER::Initialize(
    VOID
)
/*++

Routine Description:

    Global initialization routine for W3_GENERAL_HANDLERs

Arguments:

    None
    
Return Value:

    HRESULT

--*/
{
    ALLOC_CACHE_CONFIGURATION       acConfig;
    HRESULT                         hr = NO_ERROR;

    //
    // Setup allocation lookaside
    //
    
    acConfig.nConcurrency = 1;
    acConfig.nThreshold = 100;
    acConfig.cbSize = sizeof( W3_GENERAL_HANDLER );

    DBG_ASSERT( sm_pachGeneralHandlers == NULL );
    
    sm_pachGeneralHandlers = new ALLOC_CACHE_HANDLER( "W3_GENERAL_HANDLER",  
                                                      &acConfig );

    if ( sm_pachGeneralHandlers == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }
    
    return NO_ERROR;
}

// static
VOID
W3_GENERAL_HANDLER::Terminate(
    VOID
)
/*++

Routine Description:

    Terminate MAIN_CONTEXT globals

Arguments:

    None
    
Return Value:

    None

--*/
{
    if ( sm_pachGeneralHandlers != NULL )
    {
        delete sm_pachGeneralHandlers;
        sm_pachGeneralHandlers = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\filecache.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     filecache.cxx

   Abstract:
     A file cache (filename->W3_FILE_INFO cache)
 
   Author:
     Bilal Alam (balam)             11-Nov-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"

#define STRONG_ETAG_DELTA       30000000

#define SIZE_PRIVILEGE_SET                      128

ALLOC_CACHE_HANDLER *    W3_FILE_INFO::sm_pachW3FileInfo;

GENERIC_MAPPING g_gmFile = {
    FILE_GENERIC_READ,
    FILE_GENERIC_WRITE,
    FILE_GENERIC_EXECUTE,
    FILE_ALL_ACCESS
};

HRESULT
W3_FILE_INFO_KEY::CreateCacheKey(
    WCHAR *             pszFileKey,
    DWORD               cchFileKey,
    BOOL                fCopy
)
/*++

Routine Description:

    Initialize a file cache key

Arguments:

    pszFileKey - filename
    cchFileKey - size of filename
    fCopy - TRUE if we should copy into key buffer, otherwise just keep ref

Return Value:

    HRESULT

--*/
{
    HRESULT             hr;
    
    if ( fCopy )
    {
        hr = _strFileKey.Copy( pszFileKey );
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        _pszFileKey = _strFileKey.QueryStr();
        _cchFileKey = _strFileKey.QueryCCH();
    }
    else
    {
        _pszFileKey = pszFileKey;
        _cchFileKey = cchFileKey;
    }

    return NO_ERROR;
}

W3_FILE_INFO::~W3_FILE_INFO(
    VOID
)
{
    HRESULT             hr;
    W3_FILE_INFO_CACHE* pFileCache;
    
    DBG_ASSERT( CheckSignature() );
    
    _dwSignature = W3_FILE_INFO_SIGNATURE_FREE;

    //
    // Clear any associated object
    //
    
    LockCacheEntry();
    
    if ( _pAssociatedObject != NULL )
    {
        _pAssociatedObject->Cleanup();
        _pAssociatedObject = NULL;
    }

    UnlockCacheEntry();

    //
    // Release the contents buffer if it exists
    //
    
    if ( _pFileBuffer != NULL )
    {
        pFileCache = (W3_FILE_INFO_CACHE*) QueryCache();
        
        hr = pFileCache->ReleaseFromMemoryCache( _pFileBuffer,
                                                 _nFileSizeLow );
        DBG_ASSERT( SUCCEEDED( hr ) );
        
        _pFileBuffer = NULL;
    }
    
    //
    // Close the file handle if it still around
    //
    
    if ( _hFile != INVALID_HANDLE_VALUE )
    {
        CloseHandle( _hFile );
        
        _hFile = INVALID_HANDLE_VALUE;
    }
}

BOOL
W3_FILE_INFO::SetAssociatedObject(
    ASSOCIATED_FILE_OBJECT *        pObject
)
/*++

Routine Description:

    Associate object with this cache entry

Arguments:

    pObject - Object to associate

Return Value:

    BOOL

--*/
{
    BOOL            fRet = FALSE;
    
    LockCacheEntry();
    
    if ( _pAssociatedObject == NULL )
    {
        _pAssociatedObject = pObject;
        fRet = TRUE;
    }
    
    UnlockCacheEntry();
    
    return fRet;
}

PSECURITY_DESCRIPTOR
W3_FILE_INFO::QuerySecDesc(
    VOID
)
/*++

Routine Description:

    Return security descriptor

Arguments:

    None

Return Value:

    pointer to security descriptor

--*/
{
    if ( _hFile != INVALID_HANDLE_VALUE )
    {
        if ( FAILED( ReadSecurityDescriptor() ) )
        {
            return NULL;
        }
    } 
    else
    {
        //
        // The file is cached, therefore we must have security already
        //
    }
        
    return _bufSecDesc.QueryPtr();
}

HRESULT
W3_FILE_INFO::GenerateETag(
    VOID
)
/*++

Routine Description:

    Generate ETag string

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CHAR *      psz = _achETag;
    PBYTE       pbTime = (PBYTE) &_ftLastWriteTime;
    DWORD       dwChangeNumber;
    const CHAR  szHex[] = "0123456789abcdef";
    FILETIME    ftNow;
    __int64     iNow;
    __int64     iFileTime;

    //
    // Is this ETag weak?  If so put the preceding W/
    //
    
    GetSystemTimeAsFileTime(&ftNow);
    iNow = (__int64)*(__int64 *)&ftNow;
    iFileTime = (__int64)*(__int64 *)&_ftLastWriteTime;

    if ( ( iNow - iFileTime ) <= STRONG_ETAG_DELTA )
    {
        //
        // This is a weak ETag
        //
        
        *psz++ = 'W';
        *psz++ = '/';
    }
    
    //
    // System change number is from the metabase
    //

    dwChangeNumber = g_pW3Server->QuerySystemChangeNumber();

    //
    // Generate the meat of the ETag
    //

    *psz++ = '\"';
    for (int i = 0; i < 8; i++)
    {
        BYTE b = *pbTime++;
        BYTE bH = b >> 4;
        if (bH != 0)
            *psz++ = szHex[bH];
        *psz++ = szHex[b & 0xF];
    }
    *psz++ = ':';
    psz += strlen(_itoa((DWORD) dwChangeNumber, psz, 16));
    *psz++ = '\"';
    *psz = '\0';

    _cchETag = DIFF(psz - _achETag);
    
    return NO_ERROR;
}

HRESULT
W3_FILE_INFO::GenerateLastModifiedTimeString(
    VOID
)
/*++

Routine Description:

    Generate the Last-Modified-Time header string

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    SYSTEMTIME              st;
    
    FileTimeToSystemTime( &_ftLastWriteTime, &st );
                          
    if ( !SystemTimeToGMT( st, 
                           _achLastModified, 
                           sizeof(_achLastModified) ) ) 
    {  
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    else
    {
        return NO_ERROR;
    }
}

HRESULT
W3_FILE_INFO::DoAccessCheck(
    CACHE_USER *   pFileCacheUser
)
/*++

Routine Description:

    Check whether given token has access to this file

Arguments:

    pFileCacheUser - User to access cache with

Return Value:

    HRESULT

--*/
{
    BYTE    psFile[SIZE_PRIVILEGE_SET];
    DWORD   dwPS;
    DWORD   dwGrantedAccess;
    BOOL    fAccess;
    
    if ( pFileCacheUser == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // If we don't have a security descriptor, then local system must have
    // accessed the file originally.  Just return success
    //
    
    if ( pFileCacheUser->_hToken == NULL )
    {
        return NO_ERROR;
    }
    
    //
    // If we have a last-user-sid, and the caller provided a sid, then do a
    // quick check of sid equality
    //
    
    if ( QueryLastSid() != NULL &&
         pFileCacheUser->_pSid != NULL )
    {
        if ( EqualSid( QueryLastSid(), pFileCacheUser->_pSid ) )
        {
            return NO_ERROR;
        }
    }
    
    if ( ISUNC( QueryPhysicalPath() ) )
    {
        //
        // If this is a UNC file, and the webserver and the UNC server
        // are not on a domain, the sid of the user on the webserver will
        // not match the sid in the security-descriptor, so AccessCheck will
        // fail, instead do GetFileAttributes
        //
        if ( !SetThreadToken( NULL, pFileCacheUser->_hToken ) )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }
        ThreadPoolSetInfo( ThreadPoolIncMaxPoolThreads, 0 );

        DWORD dwAttributes = GetFileAttributes(QueryPhysicalPath());
        DWORD dwErr = GetLastError();

        ThreadPoolSetInfo( ThreadPoolDecMaxPoolThreads, 0 );
        DBG_REQUIRE( RevertToSelf() );

        if ( dwAttributes == INVALID_FILE_ATTRIBUTES )
        {
            return HRESULT_FROM_WIN32( dwErr );
        }
    }
    else
    {
        //
        // Ok.  Just use the token and cached security descriptor
        //

        dwPS = sizeof(psFile);
        ((PRIVILEGE_SET*)&psFile)->PrivilegeCount = 0;

        //
        // We must have a security descriptor if we've cached the file
        //

        DBG_ASSERT( QuerySecDesc() );

        if ( !AccessCheck( QuerySecDesc(),
                           pFileCacheUser->_hToken,
                           FILE_GENERIC_READ,
                           &g_gmFile,
                           (PRIVILEGE_SET*)psFile,
                           &dwPS,
                           &dwGrantedAccess,
                           &fAccess ) || !fAccess )
        {
            return HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
        }
    }
    
    return NO_ERROR;
}

HRESULT
W3_FILE_INFO::OpenFile(
    STRU &          strFileName,
    CACHE_USER *    pOpeningUser,
    BOOL            fBufferFile
)
/*++

Routine Description:

    Open the given file (but don't read in the file contents).  This method
    does the minimum needed to allow the caller to make a reasonable 
    decision about whether this file should be cached here or in UL

Arguments:

    strFileName - file name to open
    pOpeningUser - User to open file under
    fBufferFile - Should the file be opened with FILE_FLAG_NO_BUFFERING?

Return Value:

    HRESULT

--*/
{
    HANDLE                  hFile = INVALID_HANDLE_VALUE;
    STACK_STRU(             strFilePath, MAX_PATH + 1 );
    HRESULT                 hr = NO_ERROR;
    BOOL                    fImpersonated = FALSE;
    BY_HANDLE_FILE_INFORMATION FileInfo; 
    DWORD                   dwFileType;
    BOOL                    bRet;

    if ( pOpeningUser == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // Turn off NT file canonicalization
    //

    hr = MakePathCanonicalizationProof( strFileName.QueryStr(),
                                        &strFilePath );
    if ( FAILED( hr ) )
    {
        goto Finished;
    }

    //    
    // Avoid the infamous ::$DATA bug
    //

    if ( wcschr( strFileName.QueryStr() + 6, L':' ) != NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
        goto Finished;
    }

    //
    // We may need to impersonate some other user to open the file
    //

    if ( pOpeningUser->_hToken != NULL )
    {
        if ( !SetThreadToken( NULL, pOpeningUser->_hToken ) )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Finished;
        }
        fImpersonated = TRUE;
    }

    //
    // Open the file.  CreateFile() perf can be underwhelming.  We'll need to 
    // potentially let out another thread while making the call.  Much
    // like we do for calls into ISAPI extensions
    //

    ThreadPoolSetInfo( ThreadPoolIncMaxPoolThreads, 0 );

    hFile = CreateFile( strFilePath.QueryStr(),
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_ENCRYPTED | FILE_DIRECTORY_FILE | FILE_FLAG_OVERLAPPED | FILE_FLAG_BACKUP_SEMANTICS | (fBufferFile ? 0 : FILE_FLAG_NO_BUFFERING),
                        NULL );

    if ( hFile == INVALID_HANDLE_VALUE )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
    }
    
    //
    // Undo the threshold adjustment
    //
    
    ThreadPoolSetInfo( ThreadPoolDecMaxPoolThreads, 0 );

    if ( FAILED(hr) )
    {
        goto Finished;
    }

    //
    // Stop impersonating
    // 

    if ( fImpersonated )
    {
        RevertToSelf();
        fImpersonated = FALSE;
    }

    //
    // We shouldn't be opening byte streams (like COM, LPT)
    //

    dwFileType = GetFileType( hFile );
    if ( dwFileType != FILE_TYPE_DISK )
    {
        hr = HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
        
        CloseHandle( hFile );
        hFile = INVALID_HANDLE_VALUE;
        
        goto Finished;
    }

    //
    // Get file attributes
    //

    bRet = GetFileInformationByHandle( hFile, &FileInfo );
    if ( !bRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );

        CloseHandle( hFile );
        hFile = INVALID_HANDLE_VALUE;
        
        goto Finished;
    }

    //
    // Set the minimum properties now
    //

    _hFile = hFile;
    hFile = INVALID_HANDLE_VALUE;
    _ftLastWriteTime = FileInfo.ftLastWriteTime;
    _dwFileAttributes = FileInfo.dwFileAttributes;
    _nFileSizeLow   = FileInfo.nFileSizeLow;
    _nFileSizeHigh  = FileInfo.nFileSizeHigh;

    *((__int64 *)&_CastratedLastWriteTime)
        = (*((__int64 *)&_ftLastWriteTime) / 10000000) * 10000000;

    //
    // Create the ETag and LastModified strings
    //

    hr = GenerateETag();
    if ( FAILED( hr ) )
    {
        goto Finished;
    }

    hr = GenerateLastModifiedTimeString();
    if ( FAILED( hr ) )
    {
        goto Finished;
    }

    _msLastAttributeCheckTime = GetTickCount();

    //
    // Turn off the hidden attribute if this is a root directory listing
    // (root some times has the bit set for no apparent reason)
    //

    if ( _dwFileAttributes & FILE_ATTRIBUTE_HIDDEN )
    {
        if ( strFileName.QueryCCH() >= 2 )
        {
            if ( strFileName.QueryStr()[ 1 ] == L':' )
            {
                if ( ( strFileName.QueryStr()[ 2 ] == L'\0' ) ||
                     ( strFileName.QueryStr()[ 2 ] == L'\\' && 
                       strFileName.QueryStr()[ 3 ] == L'\0' ) )
                {
                    //
                    // This looks like a local root.  Mask out the bit
                    //
            
                    _dwFileAttributes &= ~FILE_ATTRIBUTE_HIDDEN;
                }
            }
        }
    }

Finished:

    if ( FAILED( hr ) )
    {
        if ( fImpersonated )
        {
            RevertToSelf();
            fImpersonated = FALSE;
        }

        if ( hFile != INVALID_HANDLE_VALUE )
        {
            CloseHandle( hFile );
            hFile = INVALID_HANDLE_VALUE;
        }
    }

    return hr;
}

HRESULT
W3_FILE_INFO::ReadSecurityDescriptor(
    VOID
)
/*++

Routine Description:

    Read security descriptor for current file

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    DWORD                   cbRequired;
    
    
    //
    // Cache the security descriptor
    //
    
    if ( !GetKernelObjectSecurity( _hFile,
                                   OWNER_SECURITY_INFORMATION
                                   | GROUP_SECURITY_INFORMATION
                                   | DACL_SECURITY_INFORMATION,
                                    (PSECURITY_DESCRIPTOR) _bufSecDesc.QueryPtr(),
                                   _bufSecDesc.QuerySize(),
                                   &cbRequired ) )
    {
        if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }
        
        DBG_ASSERT( cbRequired > _bufSecDesc.QuerySize() );
            
        if ( !_bufSecDesc.Resize( cbRequired ) )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }
        
        //
        // Try again with the bigger buffer.  No more excuses
        //
        
        if ( !GetKernelObjectSecurity( _hFile,
                                       OWNER_SECURITY_INFORMATION
                                       | GROUP_SECURITY_INFORMATION
                                       | DACL_SECURITY_INFORMATION,
                                       (PSECURITY_DESCRIPTOR) _bufSecDesc.QueryPtr(),
                                       _bufSecDesc.QuerySize(),
                                       &cbRequired ) )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }
    }
    
    return NO_ERROR;
}

HRESULT
W3_FILE_INFO::MakeCacheable(
    CACHE_USER        *pFileUser,
    FILE_CACHE_ASYNC_CONTEXT *pAsyncContext,
    BOOL              *pfHandledSync,
    BOOL               fCheckForExistenceOnly
)
/*++

Routine Description:

    Make the file cacheable by reading contents into memory, and caching
    the security descriptor

Arguments:

    pFileUser - User trying to open file
    pAsyncContext - Provides the information necessary to notify the caller
                    when the file has been read when done async
    pfHandledSync - If provided, on return tells whether the open completed
                    synchronously
    fCheckForExistenceOnly - Are we caching the state of existence only?

Return Value:

    HRESULT

--*/
{
    HRESULT                 hr;
    W3_FILE_INFO_CACHE*     pFileCache;

    if ( pFileUser == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    DBG_ASSERT( IsCacheable() );

    //
    // We must have a file handle if we're here
    //

    DBG_ASSERT( _hFile != INVALID_HANDLE_VALUE );

    //
    // Get the security descriptor
    //

    hr = ReadSecurityDescriptor();
    if ( FAILED( hr ) )
    {
        return hr;
    }

    //
    // On top of reading the security descriptor, we will also store the
    // last sid accessing the file if available
    //

    if ( pFileUser->_pSid != NULL )
    {
        if ( GetLengthSid( pFileUser->_pSid ) <= sizeof( _abLastSid ) )
        {
            memcpy( _abLastSid, 
                    pFileUser->_pSid,
                    GetLengthSid( pFileUser->_pSid ) );
            
            _pLastSid = (PSID) _abLastSid;
        }
    }

    //
    // Now read the contents of the file into memory since we cannot cache
    // the file handle itself
    //

    if ( _nFileSizeHigh > 0 )
    {
        return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }
    
    //
    // If we're just caching a descriptor to check the existence of the file,
    // then we don't need to read the file contents
    //
    
    if ( fCheckForExistenceOnly )
    {
        CloseHandle( _hFile );
        _hFile = INVALID_HANDLE_VALUE;
       
        DBG_ASSERT( _pFileBuffer == NULL );
        
        return NO_ERROR;
    }

    //
    // Set up the context for completion
    //

    if ( pAsyncContext != NULL )
    {
        pAsyncContext->pFileInfo = this;
    }

    pFileCache = (W3_FILE_INFO_CACHE*) QueryCache();

    //
    // Read the file
    //

    hr = pFileCache->ReadFileIntoMemoryCache( _hFile,
                                              _nFileSizeLow,
                                              (PVOID*) &_pFileBuffer,
                                              pAsyncContext,
                                              pfHandledSync );

    if ( FAILED( hr ) )
    {
        if ( pAsyncContext != NULL )
        {
            pAsyncContext->pFileInfo = NULL;
        }
    }
    else if ( pfHandledSync == NULL || *pfHandledSync )
    {
        CloseHandle( _hFile );
        _hFile = INVALID_HANDLE_VALUE;
    }

    return hr;
}

BOOL
W3_FILE_INFO::IsCacheable(
    VOID
) const
/*++

Routine Description:

    Is this file cacheable?  Specically, we should we even attempt to cache
    this file?

Arguments:

    None

Return Value:

    TRUE if cacheable 

--*/
{
    W3_FILE_INFO_CACHE *    pFileCache;
   
    pFileCache = (W3_FILE_INFO_CACHE*) QueryCache();
    DBG_ASSERT( pFileCache != NULL );

    //
    // Are we past the limit of file entries?
    //
    
    if ( pFileCache->QueryElementLimitExceeded() )
    {
        return FALSE;
    }

    return IsUlCacheable();
}

BOOL
W3_FILE_INFO::IsUlCacheable(
    VOID
) const
/*++

Routine Description:

    Is this file cacheable?  Specically, we should we even attempt to cache
    this file?

Arguments:

    None

Return Value:

    TRUE if cacheable 

--*/
{
    LARGE_INTEGER           liFileSize;
    W3_FILE_INFO_CACHE *    pFileCache;
   
    pFileCache = (W3_FILE_INFO_CACHE*) QueryCache();
    DBG_ASSERT( pFileCache != NULL );

    //
    // No caching of directories
    //
    
    if ( _dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
    {
        return FALSE;
    }
    
    //
    // No caching of encrypted files
    //
    
    if ( _dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED )
    {
        return FALSE;
    }
    
    //
    // No caching of file sizes greater than the configured threshold
    //
    
    liFileSize.LowPart = _nFileSizeLow;
    liFileSize.HighPart = _nFileSizeHigh;

    if ( liFileSize.QuadPart > pFileCache->QueryFileSizeThreshold() )
    {
        return FALSE;
    }

    return TRUE;
}

BOOL
W3_FILE_INFO::QueryIsOkToFlushDirmon(
    WCHAR *                 pszPath,
    DWORD                   cchPath
)
/*++

Routine Description:

    Determine whether this file entry should be flushed, given the path
    which has changed (dir monitor changed)

Arguments:

    pszPath - Path which changed
    cchPath - Size of path changed

Return Value:

    TRUE if we should flush, else FALSE

--*/
{
    DBG_ASSERT( _cacheKey._pszFileKey != NULL );
    
    if ( _wcsnicmp( _cacheKey._pszFileKey,
                    pszPath,
                    cchPath ) == 0 )
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

//static
HRESULT
W3_FILE_INFO::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize W3_FILE_INFO lookaside

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ALLOC_CACHE_CONFIGURATION   acConfig;
    HRESULT                     hr;    

    //
    // Initialize allocation lookaside
    //    
    
    acConfig.nConcurrency = 1;
    acConfig.nThreshold   = 100;
    acConfig.cbSize       = sizeof( W3_FILE_INFO );

    DBG_ASSERT( sm_pachW3FileInfo == NULL );
    
    sm_pachW3FileInfo = new ALLOC_CACHE_HANDLER( "W3_FILE_INFO",  
                                                &acConfig );

    if ( sm_pachW3FileInfo == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );

        DBGPRINTF(( DBG_CONTEXT,
                   "Error initializing sm_pachW3FileInfo. hr = 0x%x\n",
                   hr ));

        return hr;
    }
    
    return NO_ERROR;
}

//static
VOID
W3_FILE_INFO::Terminate(
    VOID
)
/*++

Routine Description:

    Cleanup W3_FILE_INFO lookaside

Arguments:

    None

Return Value:

    None

--*/
{
    if ( sm_pachW3FileInfo != NULL )
    {
        delete sm_pachW3FileInfo;
        sm_pachW3FileInfo = NULL;
    }
}

//static
VOID
W3_FILE_INFO_CACHE::MemoryCacheAdjustor(
    PVOID               pCache,
    BOOLEAN             TimerOrWaitFired
)
/*++

Routine Description:

    Called to adjust our memory cache size if necessary

Arguments:

    pCache - Points to file cache

Return Value:

    None

--*/
{
    W3_FILE_INFO_CACHE *        pFileCache;
    MEMORYSTATUSEX              MemoryStatus;
    
    pFileCache = (W3_FILE_INFO_CACHE*) pCache;

    MemoryStatus.dwLength = sizeof( MemoryStatus );

    GlobalMemoryStatusEx( &MemoryStatus );
    
    EnterCriticalSection( &( pFileCache->_csMemCache ) );

    pFileCache->_cbMemCacheLimit = min( 
            MemoryStatus.ullAvailPhys + pFileCache->_cbMemCacheCurrentSize,
            MemoryStatus.ullTotalVirtual ) / 2;

    LeaveCriticalSection( &( pFileCache->_csMemCache ) );
}

W3_FILE_INFO_CACHE::W3_FILE_INFO_CACHE()
{
    _cbFileSizeThreshold = DEFAULT_FILE_SIZE_THRESHOLD;
    _cmsecFileAttributeCheckThreshold = DEFAULT_FILE_ATTRIBUTE_CHECK_THRESHOLD * 1000;
    _cbMemoryCacheSize = 0;
    _cMaxFileEntries = 0;
    _cbMemCacheLimit = 0;
    _cbMemCacheCurrentSize = 0;
    _cbMaxMemCacheSize = 0;
    _hMemCacheHeap = NULL;
    _hTimer = NULL;
    _fEnableCache = TRUE;
    _fDoDirmonForUnc = FALSE;
}

W3_FILE_INFO_CACHE::~W3_FILE_INFO_CACHE()
{
}

HRESULT
W3_FILE_INFO_CACHE::InitializeMemoryCache(
    VOID
)
/*++

Routine Description:

    Initialize the memory cache

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    BOOL                    fRet;
    HRESULT                 hr = NO_ERROR;

    fRet = INITIALIZE_CRITICAL_SECTION( &_csMemCache );
    if ( !fRet )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    //
    // If the memory cache size was not explicitly set, then we occasionally
    // check memory status when determining what to cache
    // 

    if ( _cbMemoryCacheSize == 0 )
    {
        MEMORYSTATUSEX          MemoryStatus;
        
        MemoryStatus.dwLength = sizeof( MemoryStatus );
    
        // 
        // Get our own estimate of size of cache
        //
        
        GlobalMemoryStatusEx( &MemoryStatus );
        
        _cbMemCacheLimit = min( MemoryStatus.ullAvailPhys,
                                MemoryStatus.ullTotalVirtual ) / 2;
    
        //
        // Setup timer so we can update our memory status
        //
                                  
        fRet = CreateTimerQueueTimer( &_hTimer,
                                      NULL,
                                      W3_FILE_INFO_CACHE::MemoryCacheAdjustor,
                                      this,
                                      30000,
                                      30000,
                                      WT_EXECUTELONGFUNCTION );
        if ( !fRet )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
        }
    }
    else
    {   
        _cbMemCacheLimit = _cbMemoryCacheSize;
    }
    
    //
    // Allocate a private heap
    //
    
    if ( SUCCEEDED( hr ) ) 
    {
        _hMemCacheHeap = HeapCreate( 0, 0, 0 );
        if ( _hMemCacheHeap == NULL )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
        }
    }

    if ( FAILED( hr ) )
    {
        if ( _hMemCacheHeap != NULL )
        {
            HeapDestroy( _hMemCacheHeap );
            _hMemCacheHeap = NULL;
        }
        
        if ( _hTimer != NULL )
        {
            DeleteTimerQueueTimer( NULL,
                                   _hTimer, 
                                   INVALID_HANDLE_VALUE );
            _hTimer = NULL;
        }
        
        DeleteCriticalSection( &_csMemCache );
    }
    
    return hr;
}

HRESULT
W3_FILE_INFO_CACHE::ReadFileIntoMemoryCache( 
    IN HANDLE               hFile,
    IN DWORD                cbFile,
    OUT VOID **             ppvBuffer,
    IN FILE_CACHE_ASYNC_CONTEXT *pAsyncContext,
    OUT BOOL               *pfHandledSync
)
/*++

Routine Description:

    Read contents of file into a buffer

Arguments:

    hFile - Handle to valid file
    cbFile - Size of file ( ==> size of buffer )
    ppvBuffer - Filled in with pointer to buffer with file contents.  Set
                to NULL on failure
    pAsyncContext - Provides the information necessary to notify the caller
                    when the file has been read when done async
    pfHandledSync - If provided, on return tells whether the open completed
                    synchronously

Return Value:

    HRESULT

--*/
{
    BOOL                    bRet;
    VOID *                  pvBuffer = NULL;
    DWORD                   cbRead;
    OVERLAPPED              Overlapped;
    HRESULT                 hr = NO_ERROR;

    DBG_ASSERT( hFile && ( hFile != INVALID_HANDLE_VALUE ) );
    DBG_ASSERT( ppvBuffer != NULL );

    ZeroMemory( &Overlapped, sizeof(Overlapped) );

    //
    // First check whether there will be room in cache for the blob 
    //

    EnterCriticalSection( &_csMemCache );
    
    if ( ( _cbMemCacheCurrentSize + cbFile ) > _cbMemCacheLimit ) 
    {
        // 
        // Not enough room for cache
        //
        
        LeaveCriticalSection( &_csMemCache );

        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }
    
    _cbMemCacheCurrentSize += cbFile;
    
    _cbMaxMemCacheSize = max( _cbMaxMemCacheSize, _cbMemCacheCurrentSize );

    LeaveCriticalSection( &_csMemCache );

    //
    // Allocate blob for file
    //

    DBG_ASSERT( _hMemCacheHeap != NULL );
    pvBuffer = HeapAlloc( _hMemCacheHeap, 0, cbFile );
    if ( pvBuffer == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Finished;
    }

    *ppvBuffer = pvBuffer;

    if (pAsyncContext != NULL)
    {
        ZeroMemory( &pAsyncContext->Overlapped, sizeof(pAsyncContext->Overlapped) );

        //
        // We can restrict what files we do async reads on further
        //

        if (!ThreadPoolBindIoCompletionCallback( hFile,
                                                 W3_FILE_INFO::FileReadCompletion,
                                                 0 ))
        {
            pAsyncContext = NULL;
            *pfHandledSync = TRUE;
            pfHandledSync = NULL;
        }
    }

    //
    // Read file into blob
    //

    bRet = ReadFile( hFile,
                     pvBuffer,
                     cbFile,
                     pAsyncContext ? NULL : &cbRead,
                     pAsyncContext ? &pAsyncContext->Overlapped : &Overlapped );

    if (!bRet)
    {

        hr = HRESULT_FROM_WIN32( GetLastError() );

        if ( hr != HRESULT_FROM_WIN32( ERROR_IO_PENDING ) )
        {
            //
            // Something bad happened
            //

            goto Finished;
        }

        //
        // Reset the error lest we confuse ourselves later on cleanup
        //

        hr = NO_ERROR;

        //
        // If async is ok, return now
        //

        if (pAsyncContext != NULL)
        {
            *pfHandledSync = FALSE;
            goto Finished;
        }

        //
        // Wait for async read to complete (if async is not ok)
        //

        bRet = GetOverlappedResult( hFile,
                                    &Overlapped,
                                    &cbRead,
                                    TRUE );
        if ( !bRet )
        {
            //
            // Something bad happened
            //

            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Finished;
        }
    }

    if (pAsyncContext != NULL)
    {
        *pfHandledSync = FALSE;
        goto Finished;
    }

    //
    // Ensure that we read the number of bytes we expected to
    //
    
    if ( cbRead != cbFile )
    {
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
    }


Finished:

    if ( FAILED( hr ) )
    {
        *ppvBuffer = NULL;

        //
        // Undo changes to memory cache statistics
        //
        
        EnterCriticalSection( &_csMemCache );

        _cbMemCacheCurrentSize -= cbFile;

        LeaveCriticalSection( &_csMemCache );
    
        if ( pvBuffer != NULL )
        {
            HeapFree( _hMemCacheHeap, 0, pvBuffer );
            pvBuffer = NULL;
        }
    }

    return hr;
}

HRESULT
W3_FILE_INFO_CACHE::ReleaseFromMemoryCache(
    IN VOID *                  pvBuffer,
    IN DWORD                   cbBuffer
)
/*++
Routine Description:

    Release file content blob from cache

Arguments:

    pvBuffer - Buffer to release
    cbBuffer - Size of buffer

Return Value:

    HRESULT

--*/
{
    DBG_ASSERT( pvBuffer );

    DBG_ASSERT( _hMemCacheHeap != NULL);

    HeapFree( _hMemCacheHeap, 0, pvBuffer );
    
    EnterCriticalSection( &_csMemCache );
    
    _cbMemCacheCurrentSize -= cbBuffer;

    LeaveCriticalSection( &_csMemCache );    

    return NO_ERROR;    
}

VOID
W3_FILE_INFO_CACHE::TerminateMemoryCache(
    VOID
)
/*++

Routine Description:

    Terminate memory cache

Arguments:

Return Value:

    None

--*/
{
    if ( _hTimer != NULL )
    {
        DeleteTimerQueueTimer( NULL,
                               _hTimer, 
                               INVALID_HANDLE_VALUE );
        _hTimer = NULL;
    }
    
    if ( _hMemCacheHeap != NULL )
    {
        HeapDestroy( _hMemCacheHeap );
        _hMemCacheHeap = NULL;
    }

    DeleteCriticalSection( &_csMemCache );
}

HRESULT
W3_FILE_INFO_CACHE::GetFileInfo(
    STRU &                  strFileName,
    DIRMON_CONFIG *         pDirmonConfig,
    CACHE_USER *            pOpeningUser,
    BOOL                    fDoCache,
    W3_FILE_INFO **         ppFileInfo,
    FILE_CACHE_ASYNC_CONTEXT *pAsyncContext,
    BOOL                   *pfHandledSync,
    BOOL                    fAllowNoBuffering,
    BOOL                    fCheckForExistenceOnly
)
/*++

Routine Description:

    Returns a W3_FILE_INFO for the given file path.  Depending on fDoCache, 
    this W3_FILE_INFO will be cached

Arguments:

    strFileName - file name to find
    pDirmonConfig - Dir monitor config
    pOpeningUser - Token for user accessing the cache
    fDoCache - Set to TRUE if we should attempt to cache if possible
    ppFileInfo - Points to W3_FILE_INFO on success
    pAsyncContext - Provides the information necessary to notify the caller
                    when the file has been read when done async
    pfHandledSync - If provided, on return tells whether the open completed
                    synchronously
    fAllowNoBuffering - Allow the file to be opened with FILE_FLAG_NO_BUFFERING
    fCheckForExistenceOnly - If TRUE, ensure the file is accessible but do
                             not cache if it is not already cached

Return Value:

    HRESULT

--*/
{
    W3_FILE_INFO_KEY            fileKey;
    DIRMON_CONFIG               DefaultDirmonConfig;
    STACK_STRU(                 strParentDir, MAX_PATH );
    WCHAR *                     pszParentDir;
    W3_FILE_INFO *              pFileInfo;
    HRESULT                     hr;
    STACK_STRU(                 strFilePathKey, MAX_PATH );
    BOOL                        fShouldCacheHint = FALSE;
    BOOL                        fBufferFile = TRUE;

    if ( ppFileInfo == NULL || 
         pOpeningUser == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // Both of them should be null (for sync) or non-null (for async)
    //
    if ( ( pAsyncContext != NULL && pfHandledSync == NULL ) ||
         ( pAsyncContext == NULL && pfHandledSync != NULL ) )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    *ppFileInfo = NULL;

    //
    // We need to upper case the path to avoid a bunch of insensitive
    // compares in the hash table lookup
    //

    hr = strFilePathKey.Copy( strFileName );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    _wcsupr( strFilePathKey.QueryStr() );

    //
    // If the cache is enabled, lookup there first
    //

    if ( QueryCacheEnabled() )
    {
        //
        // Make a key for the lookup
        //

        hr = fileKey.CreateCacheKey( strFilePathKey.QueryStr(),
                                     strFilePathKey.QueryCCH(),
                                     FALSE );
        if ( FAILED( hr ) )
        {
            return hr;
        }

        //
        // Look it up
        //

        hr = FindCacheEntry( &fileKey,
                             (CACHE_ENTRY **)&pFileInfo,
                             &fShouldCacheHint );
        if ( SUCCEEDED( hr ) )
        {
            BOOL fHasChanged = FALSE;
            DBG_ASSERT( pFileInfo != NULL );
            
            //
            // If it is a UNC file, we do not do dirmon but rather make sure
            // it has not changed on each open
            // Otherwise, we need to do an accesscheck against the current user
            //
            
            if ( !_fDoDirmonForUnc &&
                 ISUNC( strFilePathKey.QueryStr() ) &&
                 ( GetTickCount() - pFileInfo->QueryLastAttributeCheckTime() ) > 
                   _cmsecFileAttributeCheckThreshold )
            {
                hr = pFileInfo->CheckIfFileHasChanged( &fHasChanged,
                                                       pOpeningUser );
            }
            else
            {
                hr = pFileInfo->DoAccessCheck( pOpeningUser );
            }

            if ( FAILED( hr ) ) 
            {
                pFileInfo->DereferenceCacheEntry();
                return hr;
            }

            if ( !fHasChanged )
            {
                //
                // We have found a cached entry which we have access to.  
                // 
                // One more complication: If this file entry exists without
                // a handle/memory-buffer, then it is there for file 
                // existence purposes only.  If we're currently checking 
                // for existence only, then great!  If not, this entry is
                // bogus and we'll have to stuff in a new content entry
                //
                
                if ( pFileInfo->QueryFileBuffer() == NULL &&
                     pFileInfo->QueryFileHandle() == INVALID_HANDLE_VALUE && 
                     !fCheckForExistenceOnly )
                {
                    //
                    // We need a real cache entry.  Get rid of this entry
                    //
                    
                    FlushCacheEntry( pFileInfo->QueryCacheKey() );
                   
                    pFileInfo->DereferenceCacheEntry();
                    pFileInfo = NULL; 
                    
                    //
                    // Fall thru so that we try to cache it again 
                    // (this time completely).  
                    // 
                }
                else
                {
                    //
                    // We've satisfied the file cache request.  Return the
                    // descriptor
                    //
                    
                    *ppFileInfo = pFileInfo;
                    if ( pfHandledSync != NULL )
                    {
                        *pfHandledSync = TRUE;
                    }

                    return NO_ERROR;
                }
            }
            else
            {
                pFileInfo->DereferenceCacheEntry();
                pFileInfo = NULL;

                //
                // Release this entry but continue on to get a fresh one
                //
            }
        }
    }
    
    //
    // OK.  We have to open the file.  Figure out whether we should open the file 
    // buffered or not
    //

    if ( !QueryCacheEnabled() ||
         !fDoCache || 
         !fShouldCacheHint )
    {
        if ( fAllowNoBuffering )
        {
            fBufferFile = FALSE;
        }
    }

    //
    // We will simply open the file and return the object
    //

    pFileInfo = new W3_FILE_INFO( this );
    if ( pFileInfo == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    //
    // Setup the cache key (in case we want to cache it)
    //

    hr = ((W3_FILE_INFO_KEY*) pFileInfo->QueryCacheKey())->CreateCacheKey( 
                                                     strFilePathKey.QueryStr(),
                                                     strFilePathKey.QueryCCH(),
                                                     TRUE );
    if ( FAILED( hr ) )
    {
        pFileInfo->DereferenceCacheEntry();
        return hr;
    }

    //
    // Open the file.  Note that we use the original strFileName 
    // parameter (which is not upper cased).  This is done to support
    // case sensitive file systems
    //

    hr = pFileInfo->OpenFile( strFileName,
                              pOpeningUser,
                              fBufferFile );
    if ( FAILED( hr ) )
    {
        pFileInfo->DereferenceCacheEntry();
        return hr;
    }

    //
    // If we aren't asked to cache the file, OR the file is not cacheable 
    // then we can return it now
    //

    if ( !QueryCacheEnabled() ||
         !fDoCache || 
         !fShouldCacheHint ||
         !pFileInfo->IsUlCacheable() )
    {
        *ppFileInfo = pFileInfo;
        if (pfHandledSync != NULL)
        {
            *pfHandledSync = TRUE;
        }

        return NO_ERROR;
    }

    pFileInfo->AllowUlCache();

    if ( !pFileInfo->IsCacheable() )
    {
        *ppFileInfo = pFileInfo;
        if ( pfHandledSync != NULL )
        {
            *pfHandledSync = TRUE;
        }

        return NO_ERROR;
    }
    
    //
    // In general, caching a file means dirmoning it.  The exception is if this is a UNC
    // file and we're configured to do file validation
    //

    if ( _fDoDirmonForUnc ||
         !ISUNC( strFilePathKey.QueryStr() ) )
    {
        //
        // If we're supposed to cache but no dirmon was configured, then just
        // assume the directory to monitor is the parent directory (and token
        // to use is NULL)
        //

        if ( pDirmonConfig == NULL )
        {
            DefaultDirmonConfig.hToken = NULL;
    
            pszParentDir = wcsrchr( strFilePathKey.QueryStr(), L'\\' );
            if ( pszParentDir != NULL )
            {
                hr = strParentDir.Copy( strFilePathKey.QueryStr(),
                                        DIFF( pszParentDir - strFilePathKey.QueryStr() ) );
                if ( SUCCEEDED( hr ) )
                {
                    DefaultDirmonConfig.pszDirPath = strParentDir.QueryStr();
                    pDirmonConfig = &DefaultDirmonConfig;
                }
            }
        }

        //
        // If we still don't have a dir mon configuration, then just don't cache
        //

        if ( pDirmonConfig == NULL )
        {
            *ppFileInfo = pFileInfo;
            if (pfHandledSync != NULL)
            {
                *pfHandledSync = TRUE;
            }

            return NO_ERROR;
        }

        //
        // Start monitoring the appropriate directory for changes
        //

        hr = pFileInfo->AddDirmonInvalidator( pDirmonConfig );
        if ( FAILED( hr ) )
        {
            //
            // If we can't monitor the directory, then just don't cache the item
            //

            *ppFileInfo = pFileInfo;
            if (pfHandledSync != NULL)
            {
                *pfHandledSync = TRUE;
            }

            return NO_ERROR;
        }
    }
        
    //
    // Attempt to cache the file.  Caching the file means reading the 
    // contents into memory, as well as caching the security descriptor
    //

    hr = pFileInfo->MakeCacheable( pOpeningUser,
                                   pAsyncContext,
                                   pfHandledSync,
                                   fCheckForExistenceOnly );
    if ( FAILED( hr ) )
    {
        *ppFileInfo = pFileInfo;
        if (pfHandledSync != NULL)
        {
            *pfHandledSync = TRUE;
        }

        return NO_ERROR;
    }    

    //
    // If an async read is pending, then return out now
    //

    if (pfHandledSync != NULL &&
        !*pfHandledSync)
    {
        *ppFileInfo = NULL;
        return NO_ERROR;
    }

    //
    // Insert into the hash table.  AddCacheEntry() will only error if
    // we cannot add the item, that is not fatal and we will simply return
    // this item and it will cleanup on dereference
    //
    
    AddCacheEntry( pFileInfo );
    
    *ppFileInfo = pFileInfo;
    
    return NO_ERROR;
}

HRESULT
W3_FILE_INFO_CACHE::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize the file cache

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    DWORD               dwError;
    DWORD               dwType;
    DWORD               dwValue;
    DWORD               cbData;
    DWORD               csecTTL = DEFAULT_W3_FILE_INFO_CACHE_TTL;
    DWORD               csecActivity = DEFAULT_W3_FILE_INFO_CACHE_ACTIVITY;
    HKEY                hKey = NULL;
    HRESULT             hr;
    CACHE_HINT_CONFIG   cacheHintConfig;
    
    //
    // Read the registry configuration of the file cache.
    // For now, that is just the legacy confiugration from IIS 5.x
    //
    
    dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            L"System\\CurrentControlSet\\Services\\inetinfo\\Parameters",
                            0,
                            KEY_READ,
                            &hKey );
    if ( dwError == ERROR_SUCCESS )
    {
        DBG_ASSERT( hKey != NULL );
    
        //
        // Should we be file caching at all?
        //
    
        cbData = sizeof( DWORD );
        dwError = RegQueryValueEx( hKey,
                                   L"DisableMemoryCache",
                                   NULL,
                                   &dwType,
                                   (LPBYTE) &dwValue,
                                   &cbData );
        if ( dwError == ERROR_SUCCESS && dwType == REG_DWORD )
        {
            _fEnableCache = dwValue ? FALSE : TRUE;
        }
        
        //
        // What is the biggest file we should cache in user mode?
        //
        
        cbData = sizeof( DWORD );
        dwError = RegQueryValueEx( hKey,
                                   L"MaxCachedFileSize",
                                   NULL,
                                   &dwType,
                                   (LPBYTE) &dwValue,
                                   &cbData );
        if ( dwError == ERROR_SUCCESS && dwType == REG_DWORD )
        {
            _cbFileSizeThreshold = dwValue;
        }
        
        //
        // What is the size of our memory cache?  Size is in MB
        //
        
        cbData = sizeof( DWORD );
        dwError = RegQueryValueEx( hKey,
                                   L"MemCacheSize",
                                   NULL,
                                   &dwType,
                                   (LPBYTE)&dwValue,
                                   &cbData );
        if ( dwError == ERROR_SUCCESS && dwType == REG_DWORD )
        {
            _cbMemoryCacheSize = dwValue * (1024 * 1024);
        }

        //
        // Read the maximum # of files in cache
        //
        
        cbData = sizeof( DWORD );
        dwError = RegQueryValueEx( hKey,
                                   L"MaxOpenFiles",
                                   NULL,
                                   &dwType,
                                   (LPBYTE) &dwValue,
                                   &cbData );
        if ( dwError == ERROR_SUCCESS && dwType == REG_DWORD )
        {
            _cMaxFileEntries = dwValue;
        }
        
        //
        // What is the TTL for the file cache?
        //

        cbData = sizeof( DWORD );
        dwError = RegQueryValueEx( hKey,
                                   L"ObjectCacheTTL",
                                   NULL,
                                   &dwType,
                                   (LPBYTE) &dwValue,
                                   &cbData );
        if ( dwError == ERROR_SUCCESS && dwType == REG_DWORD )
        {
            csecTTL = dwValue;
        }
        
        //
        // What is the activity period before putting into cache
        //
        
        cbData = sizeof( DWORD );
        dwError = RegQueryValueEx( hKey,
                                   L"ActivityPeriod",
                                   NULL,
                                   &dwType,
                                   (LPBYTE) &dwValue,
                                   &cbData );
        if ( dwError == ERROR_SUCCESS && dwType == REG_DWORD )
        {
            csecActivity = dwValue;
        }

        //
        // Do we do dirmonitoring for UNC's?
        //

        cbData = sizeof( DWORD );
        dwError = RegQueryValueEx( hKey,
                                   L"DoDirMonitoringForUnc",
                                   NULL,
                                   &dwType,
                                   (LPBYTE) &dwValue,
                                   &cbData );
        if ( dwError == ERROR_SUCCESS && dwType == REG_DWORD )
        {
            _fDoDirmonForUnc = dwValue;
        }
        
        //
        // What is the file attribute threshold time (for UNCs without dirmon)
        //
        
        cbData = sizeof( DWORD );
        dwError = RegQueryValueEx( hKey,
                                   L"FileAttributeCheckThreshold",
                                   NULL,
                                   &dwType,
                                   (LPBYTE) &dwValue,
                                   &cbData );
        if ( dwError == ERROR_SUCCESS && dwType == REG_DWORD )
        {
            _cmsecFileAttributeCheckThreshold = dwValue * 1000;
        }

        RegCloseKey( hKey );
    }
    
    //
    // Initialize memory cache
    //
    
    hr = InitializeMemoryCache();
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    //
    // Setup cache hint config (for now hardcoded)
    //
    
    if ( csecActivity != 0 )
    {
        cacheHintConfig.cmsecActivityWindow = csecActivity * 1000;
        cacheHintConfig.cmsecScavengeTime = cacheHintConfig.cmsecActivityWindow * 2;
        cacheHintConfig.cmsecTTL = cacheHintConfig.cmsecActivityWindow * 2;
    }

    //
    // We'll use TTL for scavenge period, and expect two inactive periods to
    // flush
    //
    
    hr = SetCacheConfiguration( csecTTL * 1000, 
                                csecTTL * 1000,
                                CACHE_INVALIDATION_DIRMON_FLUSH |
                                CACHE_INVALIDATION_DIRMON_SPECIFIC,
                                csecActivity ? &cacheHintConfig : NULL );
    if ( FAILED( hr ) )
    {
        TerminateMemoryCache();
        return hr;
    }
    
    //
    // Initialize file info lookaside
    //
    
    hr = W3_FILE_INFO::Initialize();
    if ( FAILED( hr ) )
    {
        TerminateMemoryCache();
    }
    
    return hr;
}    

VOID
W3_FILE_INFO_CACHE::Terminate(
    VOID
)
/*++

Routine Description:

    Terminate the file cache

Argument:

    None

Return Value:

    None

--*/
{
    TerminateMemoryCache();
    
    W3_FILE_INFO::Terminate();
}

VOID
W3_FILE_INFO_CACHE::DoDirmonInvalidationSpecific(
    WCHAR *             pszPath
)
/*++

Routine Description:

    Handle dirmon invalidation

Arguments:

    pszPath - Path which changed

Return Value:

    HRESULT

--*/
{
    HRESULT                 hr;
    W3_FILE_INFO_KEY        fileKey;
    
    DBG_ASSERT( pszPath != NULL );
    
    //
    // We're not flushing all, then just lookup given file and flush it
    //    
    
    hr = fileKey.CreateCacheKey( pszPath, 
                                 wcslen( pszPath ),
                                 FALSE );
    if ( SUCCEEDED( hr ) )
    {
        FlushCacheEntry( &fileKey );
    }
}

//static
W3_FILE_INFO_CACHE *
W3_FILE_INFO_CACHE::GetFileCache(
    VOID
)
{
    DBG_ASSERT( g_pW3Server != NULL );
    return g_pW3Server->QueryFileCache();
}

HRESULT
W3_FILE_INFO::CheckIfFileHasChanged(
    BOOL            *pfHasChanged,
    CACHE_USER      *pOpeningUser
)
/*++
    This function determines whether the file has changed for what is
    in the cache.  This is useful when we do not do directory change
    monitoring on UNC files.
--*/
{
    HRESULT hr = S_OK;
    BOOL fImpersonated = FALSE;

    //
    // We may need to impersonate some other user to open the file
    //

    if ( pOpeningUser->_hToken != NULL )
    {
        if ( !SetThreadToken( NULL, pOpeningUser->_hToken ) )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }
        fImpersonated = TRUE;
    }

    //
    // Going to a UNC, let us bump up our thread count
    //
    ThreadPoolSetInfo( ThreadPoolIncMaxPoolThreads, 0 );

    WIN32_FILE_ATTRIBUTE_DATA fileData;

    if (!GetFileAttributesEx(_cacheKey._pszFileKey,
                             GetFileExInfoStandard,
                             &fileData))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Finished;
    }

    //
    // If the attributes, WriteTime, and if it is a file, size are same
    // then the file has not changed
    //
    if (fileData.dwFileAttributes == _dwFileAttributes &&
        *(__int64 *)&fileData.ftLastWriteTime == *(__int64 *)&_ftLastWriteTime &&
        ((fileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ||
         (fileData.nFileSizeHigh == _nFileSizeHigh &&
          fileData.nFileSizeLow == _nFileSizeLow)
        )
       )
    {
        *pfHasChanged = FALSE;
        _msLastAttributeCheckTime = GetTickCount();
    }
    else
    {
        *pfHasChanged = TRUE;
    }

 Finished:
    //
    // We are back, we can bump down the count again
    //
    ThreadPoolSetInfo( ThreadPoolDecMaxPoolThreads, 0 );

    if (fImpersonated)
    {
        DBG_REQUIRE(RevertToSelf());
    }

    return hr;
}

BOOL
W3_FILE_INFO::Checkout(
    CACHE_USER *pOpeningUser
)
{
    BOOL fHasChanged = FALSE;

    //
    // If it is a UNC file, we do not do dirmon but rather make sure
    // it has not changed on each open
    //
    if (!g_pW3Server->QueryFileCache()->QueryDoDirmonForUnc() &&
        ISUNC(_cacheKey._pszFileKey) &&
        ( GetTickCount() - QueryLastAttributeCheckTime() ) > 
          g_pW3Server->QueryFileCache()->QueryFileAttributeCheckThreshold() )
    {
        if (FAILED(CheckIfFileHasChanged(&fHasChanged,
                                         pOpeningUser)) ||
            fHasChanged)
        {
            return FALSE;
        }
    }

    return CACHE_ENTRY::Checkout(pOpeningUser);
}

// static
VOID CALLBACK W3_FILE_INFO::FileReadCompletion(
                            DWORD dwErrorCode,
                            DWORD dwNumberOfBytesTransfered,
                            LPOVERLAPPED lpOverlapped)
{
    FILE_CACHE_ASYNC_CONTEXT *pAsyncContext =
                            CONTAINING_RECORD(lpOverlapped,
                                              FILE_CACHE_ASYNC_CONTEXT,
                                              Overlapped);

    HRESULT hr = S_OK;

    if (dwErrorCode != 0)
    {
        hr = HRESULT_FROM_WIN32(dwErrorCode);
    }
    else
    {
        ULARGE_INTEGER liSize;
        W3_FILE_INFO *pFileInfo = pAsyncContext->pFileInfo;

        pFileInfo->QuerySize(&liSize);
        DBG_ASSERT(dwNumberOfBytesTransfered == liSize.QuadPart);

        CloseHandle(pFileInfo->_hFile);
        pFileInfo->_hFile = INVALID_HANDLE_VALUE;

        g_pW3Server->QueryFileCache()->AddCacheEntry( pFileInfo );
    }

    pAsyncContext->pfnCallback(pAsyncContext, hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\iiscertmap.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     iiscertmap.cxx

   Abstract:
     IIS Certificate mapping

 
   Author:
     Bilal Alam         (BAlam)         19-Apr-2000

   Environment:
     Win32 - User Mode

   Project:
     Stream Filter Worker Process
--*/

#include "precomp.hxx"
#include <mbstring.h>



IIS_CERTIFICATE_MAPPING::IIS_CERTIFICATE_MAPPING( VOID )
    : _pCert11Mapper( NULL ),
      _pCertWildcardMapper( NULL ),
      _cRefs( 1 )
{
}

IIS_CERTIFICATE_MAPPING::~IIS_CERTIFICATE_MAPPING( VOID )
{
    if ( _pCert11Mapper != NULL )
    {
        delete _pCert11Mapper;
        _pCert11Mapper = NULL;
    }
    
    if ( _pCertWildcardMapper != NULL )
    {
        delete _pCertWildcardMapper;
        _pCertWildcardMapper = NULL;
    }
}

HRESULT
IIS_CERTIFICATE_MAPPING::Read11Mappings(
    DWORD                   dwSiteId
)
/*++

Routine Description:

    Read 1-1 mappings from metabase

Arguments:

    dwSiteId - Site ID 

Return Value:

    HRESULT

--*/
{
    MB                      mb( g_pW3Server->QueryMDObject() );
    WCHAR                   achMBPath[ 256 ];
    HRESULT                 hr = NO_ERROR;
    // besides terminating '\0' one extra char is needed for leading slash
    WCHAR                   achMappingName[ ADMINDATA_MAX_NAME_LEN + 1 + 1 ];
    BOOL                    fRet;
    DWORD                   dwIndex;
    STACK_BUFFER(           buff, 1024 );
    DWORD                   cbRequired;
    STACK_STRU(             strTemp, 64 );
    STACK_STRU(             strUserName, 64 );
    STACK_STRU(             strPassword, 64 );
    DWORD                   dwEnabled;
    CIisMapping *           pCertMapping;
    
    //
    // Setup the metabase path to get at 1-1 mappings
    //
    
    _snwprintf( achMBPath,
                sizeof( achMBPath ) / sizeof( WCHAR ) - 1,
                L"/LM/W3SVC/%d/Cert11/Mappings",
                dwSiteId );
    achMBPath[ sizeof( achMBPath ) / sizeof( WCHAR ) - 1 ] = '\0';
    
    //
    // Open the metabase and read 1-1 mapping properties
    // 
    
    fRet = mb.Open( achMBPath,
                    METADATA_PERMISSION_READ );
    if ( fRet )
    {
        dwIndex = 0;
        achMappingName[ 0 ] = L'/';
        
        for ( ; ; ) // loop un
        {
            dwEnabled = FALSE;
            
            //
            // We will need to prepend the object name with '/'.  Hence
            // goofyness of sending an offseted pointed to name
            //
            
            fRet = mb.EnumObjects( L"",
                                   achMappingName + 1,
                                   dwIndex );
            if ( !fRet )
            {
                hr = HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
                break;
            }
            
            //
            // Get certificate blob
            //

            cbRequired = buff.QuerySize();
            
            fRet = mb.GetData( achMappingName,
                               MD_MAPCERT,
                               IIS_MD_UT_SERVER,
                               BINARY_METADATA,
                               buff.QueryPtr(),
                               &cbRequired,
                               METADATA_NO_ATTRIBUTES );
            if ( !fRet )
            {
                if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
                {
                    DBG_ASSERT( cbRequired > buff.QuerySize() );
                    
                    if ( !buff.Resize( cbRequired ) )
                    {
                        hr = HRESULT_FROM_WIN32( GetLastError() );
                        break;
                    }
                    
                    fRet = mb.GetData( achMappingName,
                                       MD_MAPCERT,
                                       IIS_MD_UT_SERVER,
                                       BINARY_METADATA,
                                       buff.QueryPtr(),
                                       &cbRequired,
                                       METADATA_NO_ATTRIBUTES );
                    if ( !fRet )
                    {
                        DBG_ASSERT( GetLastError() != ERROR_INSUFFICIENT_BUFFER );
                        hr = HRESULT_FROM_WIN32( GetLastError() );
                        if ( hr == MD_ERROR_DATA_NOT_FOUND )
                        {
                            // if cert blob is not present we skip this entry
                            goto NextEntry;
                        }
                        else
                        {
                            break;
                        }
                    }
                }
                else
                {
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                    if ( hr == MD_ERROR_DATA_NOT_FOUND )
                    {
                        // if cert blob is not present we skip this entry
                        goto NextEntry;
                    }
                    else
                    {
                        break;
                    }
                }
            }

            //
            // Get NT account name
            //
            
            if ( !mb.GetStr( achMappingName,
                             MD_MAPNTACCT,
                             IIS_MD_UT_SERVER,
                             &strUserName ) )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
                if ( hr == MD_ERROR_DATA_NOT_FOUND )
                {
                    // if account name is not present we skip this entry
                    goto NextEntry;
                }
                else
                {
                    break;
                }

                break;
            }
            
            //
            // Get NT password
            //
            
            if ( !mb.GetStr( achMappingName,
                             MD_MAPNTPWD,
                             IIS_MD_UT_SERVER,
                             &strPassword ) )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
                if ( hr == MD_ERROR_DATA_NOT_FOUND )
                {
                    // we assume default password - empty;
                    strPassword.Reset();
                }
                else
                {
                    break;
                }
            }

            //
            // Is this mapping enabled?  
            //
            
            if ( !mb.GetDword( achMappingName,
                               MD_MAPENABLED,
                               IIS_MD_UT_SERVER,
                               &dwEnabled ) )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
                if ( hr == MD_ERROR_DATA_NOT_FOUND )
                {
                    // we assume default 0 (FALSE);
                    dwEnabled = 0;
                }
                else
                {
                    break;
                }
            }
            
            //
            // If this mapping is enabled, add it to 1-1 mapper
            //
            
            if ( dwEnabled )
            {
                if ( _pCert11Mapper == NULL )
                {
                    _pCert11Mapper = new CIisCert11Mapper();
                    if ( _pCert11Mapper == NULL )
                    {
                        hr = HRESULT_FROM_WIN32( GetLastError() );
                        break;
                    }

                    //
                    // Reset() will configure default hierarchies
                    // If hierarchies are not configured then comparison (CIisMapping::Cmp() function 
                    // implemented in iismap.cxx) will fail 
                    // (and mapper will always incorrectly map to first available 1to1 mapping)
                    //

                    if(!_pCert11Mapper->Reset())
                    {
                        delete _pCert11Mapper;
                        _pCert11Mapper = NULL;
                        
                        hr = HRESULT_FROM_WIN32( GetLastError() );
                        break;
                    }
                }
                
                DBG_ASSERT( _pCert11Mapper != NULL );
                
                pCertMapping = _pCert11Mapper->CreateNewMapping();
                if ( pCertMapping == NULL )
                {
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                    break;
                }         
                
                if ( !pCertMapping->MappingSetField( IISMDB_INDEX_CERT11_CERT, 
                                                     (PBYTE) buff.QueryPtr(),
                                                     cbRequired,
                                                     FALSE ) )
                {   
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                    break;
                }
                
                if ( !pCertMapping->MappingSetField( IISMDB_INDEX_CERT11_NT_ACCT,
                                                     (PBYTE) strUserName.QueryStr(),
                                                     strUserName.QueryCB() + sizeof (WCHAR),
                                                     FALSE ) )
                {
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                    delete pCertMapping;
                    pCertMapping = NULL;
                    break;
                }
                
                if ( !pCertMapping->MappingSetField( IISMDB_INDEX_CERT11_NT_PWD,
                                                     (PBYTE) strPassword.QueryStr(),
                                                     strPassword.QueryCB() + sizeof (WCHAR),
                                                     FALSE ) )
                {
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                    delete pCertMapping;
                    pCertMapping = NULL;
                    break;
                }

                if ( !((CIisAcctMapper*)_pCert11Mapper)->Add( pCertMapping, FALSE ) )
                {
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                    delete pCertMapping;
                    pCertMapping = NULL;
                    break;
                }
            } 
        NextEntry:
            dwIndex++;
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
    }
    
    return hr;
}

HRESULT
IIS_CERTIFICATE_MAPPING::ReadWildcardMappings(
    DWORD                   dwSiteId
)
/*++

Routine Description:

    Read wildcard mappings from metabase

Arguments:

    dwSiteId - Site ID (duh)

Return Value:

    HRESULT

--*/
{
    MB                      mb( g_pW3Server->QueryMDObject() );
    WCHAR                   achMBPath[ 256 ];
    BOOL                    fRet;
    BYTE                    abBuffer[ 1024 ];
    BUFFER                  buff( abBuffer, sizeof( abBuffer ) );
    DWORD                   cbRequired;
    PUCHAR                  pSerializedMapping;
    
    //
    // Setup the metabase path to get at wildcard mappings
    //
    
    _snwprintf( achMBPath,
                sizeof( achMBPath ) / sizeof( WCHAR ) - 1,
                L"/LM/W3SVC/%d/",
                dwSiteId );
    achMBPath[ sizeof( achMBPath ) / sizeof( WCHAR ) - 1 ] = '\0';

    //
    // Open the metabase and read wildcard mappings
    // 
    
    fRet = mb.Open( achMBPath,
                    METADATA_PERMISSION_READ );
    if ( fRet )
    {
        cbRequired = buff.QuerySize();
        
        fRet = mb.GetData( L"",
                           MD_SERIAL_CERTW,
                           IIS_MD_UT_SERVER,
                           BINARY_METADATA,
                           buff.QueryPtr(),
                           &cbRequired,
                           METADATA_NO_ATTRIBUTES );
        if ( !fRet )
        {
            if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
            {
                DBG_ASSERT( cbRequired > buff.QuerySize() );
                
                if ( !buff.Resize( cbRequired ) )
                {
                    return HRESULT_FROM_WIN32( GetLastError() );
                }
                
                fRet = mb.GetData( L"",
                                   MD_SERIAL_CERTW,
                                   IIS_MD_UT_SERVER,
                                   BINARY_METADATA,
                                   buff.QueryPtr(),
                                   &cbRequired,
                                   METADATA_NO_ATTRIBUTES );
                if ( !fRet )
                {
                    DBG_ASSERT( GetLastError() != ERROR_INSUFFICIENT_BUFFER );
                    
                    return HRESULT_FROM_WIN32( GetLastError() );
                }
            }
            else
            {
                return HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
            }
        }
        
        //
        // Thanx to the man, I can just unserialize.  XBF rocks ;-)
        //
        
        DBG_ASSERT( _pCertWildcardMapper == NULL );
        
        _pCertWildcardMapper = new CIisRuleMapper();
        if ( _pCertWildcardMapper == NULL ) 
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }

        if( !_pCertWildcardMapper->IsValid() )
        {
            //
            // creation of _pCertWildcardMapper failed
            // assume out of memory
            //
            return HRESULT_FROM_WIN32( ERROR_OUTOFMEMORY );
        }

        pSerializedMapping = (PUCHAR) buff.QueryPtr();
        
        // Unserialize will change the value of pSerializedMapping
        // It will point to the end of the unserialized data
        // We don't need that modified pointer. But remember not to use
        // pSerializedMapping any more after Unserialize call
        //
        fRet = _pCertWildcardMapper->Unserialize( &pSerializedMapping,
                                                  &cbRequired );
        if ( !fRet )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }
    }
    else
    {
        return HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );        
    }
    
    return NO_ERROR;
}


//static
HRESULT
IIS_CERTIFICATE_MAPPING::GetCertificateMapping(
    DWORD                   dwSiteId,
    IIS_CERTIFICATE_MAPPING **  ppCertificateMapping
)
/*++

Routine Description:

    Read appropriate metabase configuration to get configured IIS
    certificate mapping

Arguments:

    dwSiteId - Site ID (duh)
    ppCertificateMapping - Filled with certificate mapping descriptor on
                           success

Return Value:

    HRESULT

--*/
{
    IIS_CERTIFICATE_MAPPING *       pCertMapping = NULL;
    HRESULT                     hr = NO_ERROR;
    
    if ( ppCertificateMapping == NULL )
    {   
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    *ppCertificateMapping = NULL;
    
    //
    // Create a certificate mapping descriptor
    //
    
    pCertMapping = new IIS_CERTIFICATE_MAPPING();
    if ( pCertMapping == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Finished;
    }
    
    //
    // Read 1-1 mappings
    //
    
    hr = pCertMapping->Read11Mappings( dwSiteId );
    if ( FAILED( hr ) &&
         hr != HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error reading 1to1 Certificate Mappings.  hr = %x\n",
            hr ));

        goto Finished;
    }
    hr = NO_ERROR;

    //
    // Read wildcards
    //
    
    hr = pCertMapping->ReadWildcardMappings( dwSiteId );
    if ( FAILED( hr ) &&
         hr != HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ) )
    {
            DBGPRINTF(( DBG_CONTEXT,
            "Error reading Wildcard Certificate Mappings.  hr = %x\n",
            hr ));

        goto Finished;
    }
    hr = NO_ERROR;
    
Finished:
    if ( FAILED( hr ) )
    {
        if ( pCertMapping != NULL )
        {
            delete pCertMapping;
            pCertMapping = NULL;
        } 
    }
    else
    {
        DBG_ASSERT( pCertMapping != NULL );
        *ppCertificateMapping = pCertMapping;
    }
    
    return hr;
}


HRESULT
IIS_CERTIFICATE_MAPPING::DoMapCredential(
    W3_MAIN_CONTEXT       * pMainContext,
    PBYTE                   pClientCertBlob,
    DWORD                   cbClientCertBlob,
    TOKEN_CACHE_ENTRY **    ppCachedToken,
    BOOL *                  pfClientCertDeniedByMapper
)
{
    CIisMapping *           pQuery;
    CIisMapping *           pResult;
    WCHAR                   wszUserName[ UNLEN + IIS_DNLEN + 1 + 1 ];
    LPWSTR                  pwszUserName;
    DWORD                   cbUserName;
    WCHAR                   wszPassword[ PWLEN + 1 ];
    LPWSTR                  pwszPassword;
    DWORD                   cbPassword;
    CHAR *                  pszDomain;
    BOOL                    fMatch = FALSE;
    DWORD                   dwLogonError = NO_ERROR;
    HRESULT                 hr = S_OK;

    BOOL                    fPossibleUPNLogon = FALSE;
    //
    // add 1 to strUserDomainW for separator "\"
    //
    STACK_STRU(             strUserDomainW, UNLEN + IIS_DNLEN + 1 + 1 );
    STACK_STRU(             strUserNameW, UNLEN  + IIS_DNLEN + 1 + 1 );
    STACK_STRU(             strDomainNameW, IIS_DNLEN + 1 );
    STACK_STRU(             strPasswordW, PWLEN + 1 );
    DBG_ASSERT( pClientCertBlob   != NULL );
    DBG_ASSERT( cbClientCertBlob != 0 );
    DBG_ASSERT( ppCachedToken != NULL );
    DBG_ASSERT( pfClientCertDeniedByMapper != NULL );

    
    //
    // First try the 1-1 mapper
    //
    

    if ( _pCert11Mapper != NULL )
    {
        //
        // Build a query mapping to check
        //
        
        pQuery = _pCert11Mapper->CreateNewMapping( pClientCertBlob,
                                                   cbClientCertBlob );
        if ( pQuery == NULL )
        {
            return SEC_E_INTERNAL_ERROR;
        }

        //
        // no need to lock cert mapper because this is read only copy
        // used for mapping execution in worker process

       
        if ( _pCert11Mapper->FindMatch( pQuery,
                                       &pResult ) )
        {
            //
            // Awesome.  We found a match.  Do the deed if the rule is 
            // enabled
            //
            
            if ( pResult->MappingGetField( IISMDB_INDEX_CERT11_NT_ACCT,
                                            (PBYTE *)&pwszUserName,
                                            &cbUserName,
                                            FALSE ) &&
                 pResult->MappingGetField( IISMDB_INDEX_CERT11_NT_PWD,
                                            (PBYTE *)&pwszPassword,
                                            &cbPassword,
                                            FALSE ) )
            {
                //
                // No need to check for Enabled (IISMDB_INDEX_CERT11_ENABLED)
                // since Read11Mappings() will build mapping table consisting only 
                // of enabled mappings
                //

                //
                // Make copy of user and password
                //
                hr = strUserDomainW.Copy( pwszUserName );
                if ( FAILED( hr ) )
                {
                    return hr;
                }
                
                hr = strPasswordW.Copy( pwszPassword );
                if ( FAILED( hr ) )
                {
                    return hr;
                }
                
                fMatch = TRUE;
            }
        }
        
        
        delete pQuery;
        pQuery = NULL;
    }
    
    //
    // Try the wildcard mapper if we still haven't found a match
    //
    
    if ( !fMatch &&
         _pCertWildcardMapper != NULL )
    {

        PCCERT_CONTEXT pClientCert = CertCreateCertificateContext(
                                                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                                pClientCertBlob,
                                                cbClientCertBlob );
        if ( pClientCert == NULL )
        {
            DBG_ASSERT( pClientCert != NULL );
        }
        // Wildcard mapper assumes that 
        // achUserName buffer is greater than UNLEN+IIS_DNLEN+1 and
        // achPassword buffer is greater then PWLEN
        //
        else if ( !_pCertWildcardMapper->Match( 
                                           (PCERT_CONTEXT) pClientCert,
                                           NULL, // legacy value
                                           wszUserName,
                                           wszPassword ) )
        {
            //
            // If the mapping rule is denied then return 
            // a NULL pointer through ppCachedToken with SEC_E_OK.
            // That indicated to caller that mapping was denied
            //
            
            if ( GetLastError() == ERROR_ACCESS_DENIED )
            {
                *ppCachedToken = NULL;
                *pfClientCertDeniedByMapper = TRUE;

                if ( pClientCert != NULL )
                {
                    CertFreeCertificateContext( pClientCert );
                    pClientCert = NULL;
                }

                return SEC_E_OK;
            }
        }
        else
        {
            fMatch = TRUE;
            //
            // Copy user and password (user name may be fully qualified with domain name in it)
            //
            hr = strUserDomainW.Copy( wszUserName );
            if ( FAILED( hr ) )
            {
                return hr;
            }
            
            hr = strPasswordW.Copy( wszPassword );
            if ( FAILED( hr ) )
            {
                return hr;
            }

        }
        
        if ( pClientCert != NULL )
        {
            CertFreeCertificateContext( pClientCert );
            pClientCert = NULL;
        }
    }
    
    //
    // If we still haven't found a match, then return error
    //
         
    if ( fMatch )
    {
        
        //
        // Split up the user name into domain/user if needed
        // Note: DefaultLogonDomain is not used for cert mapping at all
        // This is to keep behaviour equivalent with former versions of IIS
        //

        hr = W3_STATE_AUTHENTICATION::SplitUserDomain( strUserDomainW,
                                                       &strUserNameW,
                                                       &strDomainNameW,
                                                       NULL,                // no default domain
                                                       &fPossibleUPNLogon );
        if ( FAILED( hr ) )
        {
            return hr;
        }

        
        //
        // We should have valid credentials to call LogonUser()
        //
        DBG_ASSERT( g_pW3Server->QueryTokenCache() != NULL );
    
        hr = g_pW3Server->QueryTokenCache()->GetCachedToken(
                                             strUserNameW.QueryStr(),
                                             strDomainNameW.QueryStr(),
                                             strPasswordW.QueryStr(),
                                             LOGON32_LOGON_NETWORK_CLEARTEXT,
                                             FALSE,       //don't use subauth         
                                             fPossibleUPNLogon, 
                                             pMainContext->QueryRequest()->
                                                  QueryRemoteSockAddress(),
                                             ppCachedToken,
                                             &dwLogonError );
        if ( FAILED( hr ) )
        {
            return SEC_E_UNKNOWN_CREDENTIALS;
        }                                          
        //
        // If *ppCachedToken is NULL, then logon failed
        //

        if ( *ppCachedToken == NULL )
        {
            //
            // Note: With IIS5 we used to log logon failure to event log
            // however it doesn't seem to be necessary because if logon/logoff auditing is enabled
            // then security log would have relevant information about the logon failure
            //
            DBG_ASSERT( dwLogonError != ERROR_SUCCESS );
            return SEC_E_UNKNOWN_CREDENTIALS;
        }

        DBG_ASSERT( (*ppCachedToken)->CheckSignature() );
        *pfClientCertDeniedByMapper = FALSE;
        return SEC_E_OK;
    }
    
    return SEC_E_UNKNOWN_CREDENTIALS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\handlerequest.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     handlerequest.cxx

   Abstract:
     Handle request state
 
   Author:
     Bilal Alam (balam)             10-Jan-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include "staticfile.hxx"
#include "isapi_handler.h"
#include "cgi_handler.h"
#include "trace_handler.h"
#include "dav_handler.h"
#include "generalhandler.hxx"
#include "redirectionhandler.hxx"

W3_STATE_HANDLE_REQUEST::W3_STATE_HANDLE_REQUEST()
{
    BOOL    fStaticInit = FALSE;
    BOOL    fCGIInit = FALSE;
    BOOL    fTraceInit = FALSE;
    BOOL    fISAPIInit = FALSE;
    BOOL    fDAVInit = FALSE;
    BOOL    fGeneralInit = FALSE;
    BOOL    fRedirectionInit = FALSE;

    //
    // Initialize static file handler
    //
    
    _hr = W3_STATIC_FILE_HANDLER::Initialize();
    if ( FAILED( _hr ) )
    {
        goto Failure;
    }
    fStaticInit = TRUE;
    
    //
    // Initialize ISAPI handler
    //
    
    _hr = W3_ISAPI_HANDLER::Initialize();
    if ( FAILED( _hr ) )
    {
        goto Failure;
    }
    fISAPIInit = TRUE;

    //
    // Initialize CGI handler
    //
    
    _hr = W3_CGI_HANDLER::Initialize();
    if ( FAILED( _hr ) )
    {
        goto Failure;
    }
    fCGIInit = TRUE;

    //
    // Initialize Trace handler
    //

    _hr = W3_TRACE_HANDLER::Initialize();
    if ( FAILED( _hr ) )
    {
        goto Failure;
    }
    fTraceInit = TRUE;

    //
    // Initialize DAV handler
    //

    _hr = W3_DAV_HANDLER::Initialize();
    if ( FAILED( _hr ) ) 
    {
        goto Failure;
    }
    fDAVInit = TRUE;
    
    //
    // Initialize general handler
    //
    
    _hr = W3_GENERAL_HANDLER::Initialize();
    if ( FAILED( _hr ) )
    {
        goto Failure;
    }
    fGeneralInit = TRUE;
    
    _hr = W3_REDIRECTION_HANDLER::Initialize();
    if ( FAILED( _hr ) )
    {
        goto Failure;
    }
    fRedirectionInit = TRUE;
    
    return;
    
Failure:
    if ( fRedirectionInit )
    {
        W3_REDIRECTION_HANDLER::Terminate();
    }

    if ( fGeneralInit )
    {
        W3_GENERAL_HANDLER::Terminate();
    }

    if ( fDAVInit )
    {
        W3_DAV_HANDLER::Terminate();
    }
    
    if ( fCGIInit )
    {
        W3_CGI_HANDLER::Terminate();
    }
    
    if ( fISAPIInit )
    {
        W3_ISAPI_HANDLER::Terminate();
    }

    if ( fStaticInit )
    {
        W3_STATIC_FILE_HANDLER::Terminate();
    }
}

W3_STATE_HANDLE_REQUEST::~W3_STATE_HANDLE_REQUEST()
{
    if ( FAILED( _hr ) )
    {
        return;
    }
    
    W3_STATIC_FILE_HANDLER::Terminate();
    
    W3_ISAPI_HANDLER::Terminate();
    
    W3_CGI_HANDLER::Terminate();
    
    W3_DAV_HANDLER::Terminate();
    
    W3_GENERAL_HANDLER::Terminate();

    W3_REDIRECTION_HANDLER::Terminate();
}

CONTEXT_STATUS
W3_STATE_HANDLE_REQUEST::DoWork(
    W3_MAIN_CONTEXT *       pMainContext,
    DWORD                   cbCompletion,
    DWORD                   dwCompletionStatus
)
/*++

Routine Description:

    Handle the request.

    This routine should determine and invoke the appropriate request 
    handler. 

Arguments:

    pMainContext - Mainline context
    cbCompletion - Bytes of completion
    dwCompletionStatus - Completion status
    
Return Value:

    CONTEXT_STATUS_PENDING if async pending, else CONTEXT_STATUS_CONTINUE

--*/
{
    HRESULT                             hr = NO_ERROR;
    BOOL                                fImmediateFinish = FALSE;
    W3_TRACE_LOG *                      pTraceLog;

    //
    // We must NOT allow any handlers to store state with the context
    // (that would screw up child execution)
    //

    DBG_ASSERT( pMainContext->QueryContextState() == NULL );

    //
    // We must have a user by now!
    //

    DBG_ASSERT( pMainContext->QueryUserContext() != NULL );

    pTraceLog = pMainContext->QueryTraceLog();
    if ( pTraceLog != NULL )
    {
        pTraceLog->Trace( L"%I64x: Successfully authenticated request as user '%s', type %d\n",
                          pMainContext->QueryRequest()->QueryRequestId(),
                          pMainContext->QueryUserContext()->QueryUserName(),
                          pMainContext->QueryUserContext()->QueryAuthType() );
    }

    //
    // What handler should handle this request?
    //
        
    hr = pMainContext->DetermineHandler();
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    //
    // If we were successful, but no handler was set, then there must 
    // be an error for us to send
    //
    
    if ( pMainContext->QueryHandler() == NULL )
    {
        DBG_ASSERT( pMainContext->QueryResponse()->QueryStatusCode() != 200 );
        
        hr = pMainContext->SendResponse( W3_FLAG_ASYNC );
    }
    else
    {
        hr = pMainContext->ExecuteHandler( W3_FLAG_ASYNC,
                                           &fImmediateFinish ); 
    }
    
    //
    // If the execution succeeded, then we expect a completion so bail
    //
    
    if ( SUCCEEDED( hr ) )
    {
        if ( fImmediateFinish )
        {
            return CONTEXT_STATUS_CONTINUE;
        }
        else
        {
            return CONTEXT_STATUS_PENDING;
        }
    }
    
Failure:

    pMainContext->SetErrorStatus( hr );
    pMainContext->QueryResponse()->SetStatus( HttpStatusServerError );
    pMainContext->SetFinishedResponse();

    return CONTEXT_STATUS_CONTINUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\dirlist.cxx ===
/*++

   Copyright    (c)    2000    Microsoft Corporation

   Module Name :
     dirlist.cxx

   Abstract:
     Handle directory listing
 
   Author:
     Anil Ruia (AnilR)             8-Mar-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include "staticfile.hxx"

#define PAD_LONG_DATE           29
#define PAD_SHORT_DATE          10
#define PAD_TIME                 8
#define PAD_FILESIZE            12

#define PAD_COL_SPACING          1

void PadDirField(CHAR *pszString,
                 int    pad)
{
    int cchLen = (DWORD)strlen(pszString);

    if (cchLen > pad)
        pad = cchLen;

    int diff = pad - cchLen;

    //
    //  Insert spaces in front of the text to pad it out
    //
    memmove(pszString + diff, pszString, cchLen + 1);
    for (int i = 0; i < diff; i++, pszString++)
        *pszString = ' ';

    //
    //  Append a column spacer at the end
    //

    pszString += cchLen;
    for (i = 0; i < PAD_COL_SPACING; i++, pszString++)
        *pszString = ' ';

    *pszString = '\0';
}


HRESULT AddFileEntry(IN STRA &strURL,
                     IN WIN32_FIND_DATA *pFileData,
                     IN DWORD dwDirBrowseFlags,
                     IN OUT STRA *pstrResponse)
/*++

Routine Description:

    Adds the HTML corresponding to an individual directory entry to
    strResponse

Arguments:

    strURL - The URL being requested
    pFileData - the File Information obtained from Find[First|Next]File
    dwDirBrowseFlags - Flags controlling how the dirlisting is formatted
    pstrResponse - The string where the response is assembled

Returns:

    HRESULT

--*/
{
    HRESULT hr;

    //
    //  Add optional date and time of this file.  We use the locale
    //  and timezone of the server
    //
    FILETIME lastModTime = pFileData->ftLastWriteTime;
    if ((dwDirBrowseFlags & (DIRBROW_SHOW_DATE | DIRBROW_SHOW_TIME)) &&
        ((lastModTime.dwLowDateTime != 0) ||
         (lastModTime.dwHighDateTime != 0)))
    {
        FILETIME ftLocal;
        SYSTEMTIME systime;

        if (!FileTimeToLocalFileTime(&lastModTime, &ftLocal) ||
            !FileTimeToSystemTime(&ftLocal, &systime))
        {
                return HRESULT_FROM_WIN32(GetLastError());
        }

        LCID lcid = GetSystemDefaultLCID();
        if (lcid == 0)
        {
            return HRESULT_FROM_WIN32(GetLastError());
        }

        if (dwDirBrowseFlags & DIRBROW_SHOW_DATE)
        {
            WCHAR pszDate[50];
            BOOL fLongDate = dwDirBrowseFlags & DIRBROW_LONG_DATE;
            if (GetDateFormatW(lcid,
                               LOCALE_NOUSEROVERRIDE |
                               (fLongDate ? DATE_LONGDATE :
                               DATE_SHORTDATE),
                               &systime,
                               NULL,
                               pszDate,
                               sizeof(pszDate)/sizeof(WCHAR)) == 0)
            {
                return HRESULT_FROM_WIN32(GetLastError());
            }

            STACK_STRA (straFileDate, 50);

            if (FAILED(hr = straFileDate.CopyWToUTF8Unescaped(pszDate)))
            {
                return hr;
            }

            PadDirField(straFileDate.QueryStr(),
                        fLongDate ? PAD_LONG_DATE : PAD_SHORT_DATE );
            DBG_REQUIRE(TRUE == straFileDate.SetLen((DWORD)strlen(straFileDate.QueryStr())));

            if (FAILED(hr = pstrResponse->Append(straFileDate)))
            {
                return hr;
            }
        }

        if (dwDirBrowseFlags & DIRBROW_SHOW_TIME)
        {
            WCHAR pszTime[15];
            if (GetTimeFormatW(lcid,
                               LOCALE_NOUSEROVERRIDE |
                               TIME_NOSECONDS,
                               &systime,
                               NULL,
                               pszTime,
                               sizeof(pszTime)/sizeof(WCHAR)) == 0)
            {
                return HRESULT_FROM_WIN32(GetLastError());
            }

            STACK_STRA (straFileTime, 15);
            if (FAILED(hr = straFileTime.CopyWToUTF8Unescaped(pszTime)))
            {
                return hr;
            }

            PadDirField(straFileTime.QueryStr(), PAD_TIME);
            DBG_REQUIRE(TRUE == straFileTime.SetLen((DWORD)strlen(straFileTime.QueryStr())));

            if (FAILED(hr = pstrResponse->Append(straFileTime)))
            {
                return hr;
            }
        }
    }

    //
    //  Add the optional file size
    //
    LARGE_INTEGER liSize;
    liSize.HighPart = pFileData->nFileSizeHigh;
    liSize.LowPart  = pFileData->nFileSizeLow;
    if (dwDirBrowseFlags & DIRBROW_SHOW_SIZE)
    {
        CHAR pszSize[30];
        int pad = PAD_FILESIZE;

        if (pFileData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            strcpy(pszSize, "&lt;dir&gt;");

            //
            //  Need to adjust for using "&lt;" instead of "<"
            //
            pad += 6;
        }
        else
        {
            _i64toa(liSize.QuadPart, pszSize, 10);
        }

        PadDirField(pszSize, pad);

        if (FAILED(hr = pstrResponse->Append(pszSize)))
        {
            return hr;
        }
    }

    STACK_STRA (straFileName, 16);

    if (FAILED(hr = pstrResponse->Append("<A HREF=\"")) ||
        FAILED(hr = pstrResponse->Append(strURL)) ||
        FAILED(hr = straFileName.CopyWToUTF8(pFileData->cFileName)) ||
        FAILED(hr = pstrResponse->Append(straFileName)))
    {
        return hr;
    }

    if ((pFileData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
        FAILED(hr = pstrResponse->Append("/")))
    {
        return hr;
    }

    if (FAILED(hr = pstrResponse->Append("\">")))
    {
        return hr;
    }

    if (FAILED(hr = straFileName.CopyWToUTF8Unescaped(pFileData->cFileName)))
    {
        return hr;
    }

    //
    //  If the show extension flag is not set, then strip it.  If the
    //  file name begins with a dot, then don't strip it.
    //
    if (!(dwDirBrowseFlags & DIRBROW_SHOW_EXTENSION))
    {
        int dotIndex = straFileName.QueryCCH() - 1;

        while ((dotIndex > 0) &&
               (straFileName.QueryStr()[dotIndex] != '.'))
        {
            dotIndex--;
        }

        if (dotIndex > 0)
            straFileName.SetLen(dotIndex);
    }

    if (FAILED(hr = pstrResponse->Append(straFileName)) ||
        FAILED(hr = pstrResponse->Append("</A><br>")))
    {
        return hr;
    }

    return S_OK;
}


int
__cdecl
SortDirectoryEntries(const void *elem1,
                     const void *elem2)
{
    return _wcsicmp(((WIN32_FIND_DATA *)elem1)->cFileName,
                    ((WIN32_FIND_DATA *)elem2)->cFileName);
}


HRESULT 
W3_STATIC_FILE_HANDLER::HandleDirectoryListing(
     IN W3_CONTEXT *            pContext,
     OUT BOOL *                 pfHandled
)
{
    DBG_ASSERT(pfHandled != NULL);
    DBG_ASSERT(pContext != NULL);

    W3_RESPONSE *pResponse = pContext->QueryResponse();
    DBG_ASSERT(pResponse != NULL);

    URL_CONTEXT *pUrlContext = pContext->QueryUrlContext();
    DBG_ASSERT(pUrlContext != NULL);

    DWORD dwDirBrowseFlags = pUrlContext->QueryMetaData()->QueryDirBrowseFlags();

    HRESULT hr;

    // Append a '*' to get all files in the directory
    STACK_STRU (strPhysical, MAX_PATH);
    if (FAILED(hr = strPhysical.Copy(
                        pUrlContext->QueryPhysicalPath()->QueryStr())))
    {
        return hr;
    }
    LPWSTR starString;
    if (strPhysical.QueryStr()[strPhysical.QueryCCH() - 1] == L'\\')
        starString = L"*";
    else
        starString = L"\\*";
    if (FAILED(hr = strPhysical.Append(starString)))
    {
        return hr;
    }

    STACK_STRA (strHostName, 16);
    if (FAILED(hr = GetServerVariableServerName(pContext, &strHostName)))
    {
        return hr;
    }

    STACK_STRU (strURL, 128);
    STACK_STRA (straURL, 128);
    STACK_STRA (straUTF8UnescapedURL, 128);

    if (FAILED(hr = pContext->QueryRequest()->GetUrl(&strURL)))
    {
        return hr;
    }
    if ((strURL.QueryStr()[strURL.QueryCCH() - 1] != L'/') &&
        FAILED(hr = strURL.Append(L"/")))
    {
        return hr;
    }

    if (FAILED(hr = straURL.CopyWToUTF8(strURL.QueryStr())) ||
        FAILED(hr = straUTF8UnescapedURL.CopyWToUTF8Unescaped(strURL.QueryStr())))
    {
        return hr;
    }

    //
    // Write hardcoded HTML header
    //
    if (FAILED(hr = m_strDirlistResponse.Copy("<html><head>")) ||
        FAILED(hr = m_strDirlistResponse.Append("<META http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">")) ||
        FAILED(hr = m_strDirlistResponse.Append("<title>")) ||
        FAILED(hr = m_strDirlistResponse.Append(strHostName)) ||
        FAILED(hr = m_strDirlistResponse.Append(" - ")) ||
        FAILED(hr = m_strDirlistResponse.Append(straUTF8UnescapedURL)) ||
        FAILED(hr = m_strDirlistResponse.Append("</title></head><body><H1>")) ||
        FAILED(hr = m_strDirlistResponse.Append(strHostName)) ||
        FAILED(hr = m_strDirlistResponse.Append(" - ")) ||
        FAILED(hr = m_strDirlistResponse.Append(straUTF8UnescapedURL)) ||
        FAILED(hr = m_strDirlistResponse.Append("</H1><hr>\r\n\r\n<pre>")))
    {
        return hr;
    }

    //
    // Create the link to the parent directory, if applicable
    //
    if (straURL.QueryCCH() >= 3)
    {
        int cchParentIndex;

        for (cchParentIndex = straURL.QueryCCH() - 2;
             (cchParentIndex >= 0) &&
                 (straURL.QueryStr()[cchParentIndex] != L'/');
             cchParentIndex--);

        if ( cchParentIndex != -1 )
        {
            if (FAILED(hr = m_strDirlistResponse.Append("<A HREF=\"")) ||
                FAILED(hr = m_strDirlistResponse.Append(straURL.QueryStr(), cchParentIndex + 1)) ||
                FAILED(hr = m_strDirlistResponse.Append("\">[To Parent Directory]</A><br><br>")))
            {
                return hr;
            }
        }
    }

    BUFFER bufFileData(8192);
    DWORD  numFiles = 0;
    HANDLE hFindFile = FindFirstFile(strPhysical.QueryStr(),
                                     (WIN32_FIND_DATA *)bufFileData.QueryPtr());
    if (hFindFile == INVALID_HANDLE_VALUE)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    pResponse->SetStatus(HttpStatusOk);
    if (FAILED(hr = pResponse->SetHeaderByReference(HttpHeaderContentType,
                                                    HEADER("text/html"))))
    {
        DBG_REQUIRE(FindClose(hFindFile));
        return hr;
    }

    for (;;)
    {
        WIN32_FIND_DATA *pFileData = (WIN32_FIND_DATA *)bufFileData.QueryPtr() + numFiles;
        if (((pFileData->dwFileAttributes & FILE_ATTRIBUTE_HIDDEN) == 0) &&
            wcscmp(pFileData->cFileName, L".") &&
            wcscmp(pFileData->cFileName, L".."))
        {
            numFiles++;

            if (!bufFileData.Resize(sizeof(WIN32_FIND_DATA)*(numFiles + 1),
                                    sizeof(WIN32_FIND_DATA)*(numFiles + 1)))
            {
                FindClose(hFindFile);
                return HRESULT_FROM_WIN32(GetLastError());
            }
        }

        if (!FindNextFile(hFindFile,
                          (WIN32_FIND_DATA *)bufFileData.QueryPtr() + numFiles))
        {
            DWORD err = GetLastError();
            if (err == ERROR_NO_MORE_FILES)
                break;

            FindClose(hFindFile);
            return HRESULT_FROM_WIN32(err);
        }
    }

    DBG_REQUIRE(FindClose(hFindFile));

    //
    // Now sort the directory-entries
    //
    qsort(bufFileData.QueryPtr(),
          numFiles,
          sizeof(WIN32_FIND_DATA),
          SortDirectoryEntries);

    for (DWORD i=0; i<numFiles; i++)
    {
            //
            //  Add the entry for this file
            //
            if (FAILED(hr = AddFileEntry(straURL,
                                         (WIN32_FIND_DATA *)bufFileData.QueryPtr() + i,
                                         dwDirBrowseFlags,
                                         &m_strDirlistResponse)))
            {
                return hr;
            }
    }

    if (FAILED(hr = m_strDirlistResponse.Append("</pre><hr></body></html>")))
    {
        return hr;
    }

    if (FAILED(hr = pResponse->AddMemoryChunkByReference(m_strDirlistResponse.QueryStr(),
                                                         m_strDirlistResponse.QueryCCH())))
    {
        return hr;
    }

    *pfHandled = TRUE;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\iisdigestprovider.cxx ===
/*++
   Copyright    (c)    2000    Microsoft Corporation

   Module Name :
     iisdigestprovider.cxx

   Abstract:
     IIS Digest authentication provider
     - version of Digest auth as implemented by IIS5 and IIS5.1
 
   Author:
     Jaroslad - based on code from md5filt      10-Nov-2000
     

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include "iisdigestprovider.hxx"
#include "uuencode.hxx"

# include <mbstring.h>

#include <lm.h>
#include <lmcons.h>
#include <lmjoin.h>

#include <time.h>
//
// lonsint.dll related header files
//
#include <lonsi.hxx>
#include <tslogon.hxx>

//
// value names used by MD5 authentication.
// must be in sync with MD5_AUTH_NAMES
//

enum MD5_AUTH_NAME
{
    MD5_AUTH_USERNAME,
    MD5_AUTH_URI,
    MD5_AUTH_REALM,
    MD5_AUTH_NONCE,
    MD5_AUTH_RESPONSE,
    MD5_AUTH_ALGORITHM,
    MD5_AUTH_DIGEST,
    MD5_AUTH_OPAQUE,
    MD5_AUTH_QOP,
    MD5_AUTH_CNONCE,
    MD5_AUTH_NC,
    MD5_AUTH_LAST,
};

//
// Value names used by MD5 authentication.
// must be in sync with MD5_AUTH_NAME
//

PSTR MD5_AUTH_NAMES[] = {
    "username",
    "uri",
    "realm",
    "nonce",
    "response",
    "algorithm",
    "digest",
    "opaque",
    "qop",
    "cnonce",
    "nc"
};


//
// Local function implementation
//


static 
LPSTR
SkipWhite(
    IN OUT LPSTR p
)
/*++

Routine Description:

    Skip white space and ','

Arguments:

    p - ptr to string

Return Value:

    updated ptr after skiping white space

--*/
{
    while ( SAFEIsSpace((UCHAR)(*p) ) || *p == ',' )
    {
        ++p;
    }

    return p;
}

//
// class IIS_DIGEST_AUTH_PROVIDER implementation
//

//static 
STRA *   IIS_DIGEST_AUTH_PROVIDER::sm_pstraComputerDomain = NULL;


//static
HRESULT
IIS_DIGEST_AUTH_PROVIDER::Initialize(
    DWORD dwInternalId
)
/*++

Routine Description:

    Initialize IIS Digest SSPI provider 

Arguments:

    None
    
Return Value:

    HRESULT

--*/
{
    HRESULT  hr = NO_ERROR;

    SetInternalId( dwInternalId );

    sm_pstraComputerDomain = new STRA;
    if( sm_pstraComputerDomain == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_OUTOFMEMORY);
    }
        

    hr = GetLanGroupDomainName( *sm_pstraComputerDomain );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Warning: Error calling GetLanGroupDomainName().  hr = %x\n",
                    hr ));
        //
        // Ignore errors that may occur while retrieving domain name
        // it is important but not critical information
        // client can always explicitly specify domain
        //
        hr = NO_ERROR;
    }


    hr = IIS_DIGEST_CONN_CONTEXT::Initialize();
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error initializing Digest Auth Prov.  hr = %x\n",
                    hr ));
        return hr;
    }
    return NO_ERROR;
}

//static
VOID
IIS_DIGEST_AUTH_PROVIDER::Terminate(
    VOID
)
/*++

Routine Description:

    Terminate IIS SSPI Digest provider

Arguments:

    None
    
Return Value:

    None

--*/
{
    if( sm_pstraComputerDomain != NULL )
    {
        delete sm_pstraComputerDomain;
        sm_pstraComputerDomain = NULL;
        
    }
    
    IIS_DIGEST_CONN_CONTEXT::Terminate();
}

HRESULT
IIS_DIGEST_AUTH_PROVIDER::DoesApply(
    IN  W3_MAIN_CONTEXT *           pMainContext,
    OUT BOOL *                      pfApplies
)
/*++

Routine Description:

    Does the given request have credentials applicable to the Digest 
    provider

Arguments:

    pMainContext - Main context representing request
    pfApplies - Set to true if Digest is applicable
    
    
Return Value:

    HRESULT

--*/
{
    LPCSTR              pszAuthHeader;
    
    if ( pMainContext == NULL ||
         pfApplies == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    } 
    
    *pfApplies = FALSE;

    //
    // Is using of Digest SSP enabled?    
    //
    if ( g_pW3Server->QueryUseDigestSSP() )
    {
        //
        // Digest SSP is enabled => IIS Digest cannot be used
        //
        return NO_ERROR;
    }

    if( !W3_STATE_AUTHENTICATION::sm_fLocalSystem )
    {
        if( W3_STATE_AUTHENTICATION::sm_lLocalSystemEvent == 0 )
        {
            if( !InterlockedExchange( &W3_STATE_AUTHENTICATION::sm_lLocalSystemEvent, 1 ) )
            {
                //
                // The process token does not have SeTcbPrivilege
                //
                g_pW3Server->LogEvent( W3_EVENT_SUBAUTH_LOCAL_SYSTEM,
                                       0,
                                       NULL );
            }
        }

        return NO_ERROR;
    }

    if( W3_STATE_AUTHENTICATION::sm_lSubAuthDigestEvent == 1 )
    {
        return NO_ERROR;
    }
    
    //
    // Get auth type
    //
    
    pszAuthHeader = pMainContext->QueryRequest()->GetHeader( HttpHeaderAuthorization );
    
    //
    // No package, no auth
    //
    
    if ( pszAuthHeader == NULL )
    {
        return NO_ERROR;
    }
    
    //
    // Is it Digest?
    //
    
    if ( _strnicmp( pszAuthHeader, DIGEST_AUTH, sizeof(DIGEST_AUTH) - 1 ) == 0 )
    {
        *pfApplies = TRUE;
    }
    
    return NO_ERROR;
}



HRESULT
IIS_DIGEST_AUTH_PROVIDER::DoAuthenticate(
    IN  W3_MAIN_CONTEXT *       pMainContext,
    OUT BOOL *                  // unused
)
/*++

Description:

    Do authentication work (we will be called if we apply)

Arguments:

    pMainContext - Main context
    
Return Value:

    HRESULT

--*/
{

    HRESULT                     hr                          = E_FAIL;
    IIS_DIGEST_CONN_CONTEXT *   pDigestConnContext          = NULL;
    LPCSTR                      pszAuthHeader               = NULL;
    STACK_STRA(                 straAuthHeader, 128 );
    BOOL                        fQOPAuth                    = FALSE;
    BOOL                        fSt                         = FALSE;
    HANDLE                      hAccessTokenImpersonation   = NULL;
    IIS_DIGEST_USER_CONTEXT *   pUserContext                = NULL;
    W3_REQUEST *                pW3Request                  = NULL;
    BOOL                        fSendAccessDenied           = FALSE;
    SECURITY_STATUS             secStatus                   = SEC_E_OK;

    STACK_STRA(                 straVerb, 10 );
    STACK_STRU(                 strDigestUri, MAX_PATH + 1 );
    STACK_STRU(                 strUrl, MAX_PATH + 1 );
    STACK_STRA(                 straCurrentNonce, NONCE_SIZE + 1 );
    LPSTR                       aValueTable[ MD5_AUTH_LAST ];
    DIGEST_LOGON_INFO           DigestLogonInfo;
    STACK_STRA(                 straUserName, UNLEN + 1 );
    STACK_STRA(                 straDomainName, IIS_DNLEN + 1 );
    ULONG                       cbBytesCopied;

    DBG_ASSERT( pMainContext != NULL );

    //
    // make copy of Authorization Header 
    // (this function will be modifying the string)
    //
    hr = straAuthHeader.Copy( pMainContext->QueryRequest()->GetHeader( HttpHeaderAuthorization ) );
    if ( FAILED( hr ) )
    {
        goto ExitPoint;
    }
    
    pszAuthHeader = straAuthHeader.QueryStr();
    
    DBG_ASSERT( pszAuthHeader != NULL );

    //
    // If DoAuthenticate() for Digest is called then DIGEST_AUTH string must 
    // have been at the beggining of the pszAuthHeader
    //
    DBG_ASSERT( _strnicmp( pszAuthHeader, DIGEST_AUTH, sizeof(DIGEST_AUTH) - 1 ) == 0 );

    //
    // Skip the name of Authentication scheme
    //
    
    pszAuthHeader = pszAuthHeader + sizeof(DIGEST_AUTH) - 1;

    if ( !IIS_DIGEST_CONN_CONTEXT::ParseForName( (PSTR) pszAuthHeader,
                                                 MD5_AUTH_NAMES,
                                                 MD5_AUTH_LAST,
                                                 aValueTable ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed parsing of Authorization header for Digest Auth\n"
                    ));

        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        goto ExitPoint;
    }
    
    //
    // Simple validation of received arguments
    //

    if ( aValueTable[ MD5_AUTH_USERNAME ] == NULL ||
         aValueTable[ MD5_AUTH_REALM ] == NULL ||
         aValueTable[ MD5_AUTH_URI ] == NULL ||
         aValueTable[ MD5_AUTH_NONCE ] == NULL ||
         aValueTable[ MD5_AUTH_RESPONSE ] == NULL )
    {
         DBGPRINTF(( DBG_CONTEXT,
                    "Invalid Digest Authorization Header (Username, realm, URI, nonce or response is missing).\n"
                    ));

        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        goto ExitPoint;
    }

    //
    // Verify quality of protection (qop) required by client
    // We only support "auth" type. If anything else is sent by client it will be ignored
    //
    
    if ( aValueTable[ MD5_AUTH_QOP ] != NULL )
    {
        if ( _stricmp( aValueTable[ MD5_AUTH_QOP ], QOP_AUTH ) )
        {
            hr = HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
            DBGPRINTF(( DBG_CONTEXT,
                    "Unknown qop=%s value in Digest Authorization header.  hr = %x\n",
                    aValueTable[ MD5_AUTH_QOP ],
                    hr ));

            goto ExitPoint;
        }

        //
        // If qop="auth" is used in header then CNONCE and NC are mandatory
        
        //
           
        if ( aValueTable[ MD5_AUTH_CNONCE ] == NULL ||
             aValueTable[ MD5_AUTH_NC ] == NULL )
        {
            DBGPRINTF(( DBG_CONTEXT,
                    "Invalid Digest Authorization Header (cnonce or nc is missing).\n"
                    ));

            hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
            goto ExitPoint;
        }
        
        fQOPAuth = TRUE;
    }
    else
    {
        aValueTable[ MD5_AUTH_QOP ]    = VALUE_NONE;
        aValueTable[ MD5_AUTH_CNONCE ] = VALUE_NONE;
        aValueTable[ MD5_AUTH_NC ]     = VALUE_NONE;
    }

    if ( FAILED( hr = straCurrentNonce.Copy( aValueTable[ MD5_AUTH_NONCE ] ) ) )
    {
        goto ExitPoint;
    }

    //
    // Verify that the nonce is well-formed
    //
    if ( !IIS_DIGEST_CONN_CONTEXT::IsWellFormedNonce( straCurrentNonce ) )
    {
        fSendAccessDenied = TRUE;
        DBGPRINTF(( DBG_CONTEXT,
                    "Invalid Digest Authorization Header (nonce is not well formed).\n"
                    ));

        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        goto ExitPoint;
    }

    //
    // What is the request verb?
    //

    if ( FAILED( hr = pMainContext->QueryRequest()->GetVerbString( &straVerb ) ) )
    {
        goto ExitPoint;
    }

    //
    // Check URI field match URL
    //

    if ( ! strDigestUri.QueryBuffer()->Resize( (strlen(aValueTable[MD5_AUTH_URI]) + 1) * sizeof(WCHAR) ) )
    {
        goto ExitPoint;
    }

    //
    // Normalize DigestUri 
    //

    hr = UlCleanAndCopyUrl( (PUCHAR)aValueTable[MD5_AUTH_URI],
                            strlen( aValueTable[MD5_AUTH_URI] ),
                            &cbBytesCopied,
                            strDigestUri.QueryStr(),
                            NULL );
    if ( FAILED( hr ) )
    {
        goto ExitPoint;
    }

    //
    // after modyfing string data in internal buffer call SyncWithBuffer
    // to synchronize string length
    //
    strDigestUri.SyncWithBuffer();

    if ( FAILED( hr = pMainContext->QueryRequest()->GetUrl( &strUrl ) ) )
    {
        goto ExitPoint;
    }

    if ( !strUrl.Equals( strDigestUri ) )
    {
        //
        // Note: RFC says that BAD REQUEST should be returned
        // but for now to be backward compatible with IIS5.1
        // we will return ACCESS_DENIED
        //
        fSendAccessDenied = TRUE;
        DBGPRINTF(( DBG_CONTEXT,
                    "URI in Digest Authorization header doesn't match the requested URI.\n"
                    ));

        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        
        goto ExitPoint;
    }


    pDigestConnContext = (IIS_DIGEST_CONN_CONTEXT *)
                         QueryConnectionAuthContext( pMainContext );

    if ( pDigestConnContext == NULL )
    {
        //
        // Create new Authentication context
        //

        pDigestConnContext = new IIS_DIGEST_CONN_CONTEXT();
        if ( pDigestConnContext == NULL )
        {
            hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
            goto ExitPoint;
        }

        hr = SetConnectionAuthContext(  pMainContext, 
                                        pDigestConnContext );
        if ( FAILED( hr ) )
        {
            goto ExitPoint;
        }
    }
    

    DBG_ASSERT( pDigestConnContext != NULL );

    if ( FAILED( hr = pDigestConnContext->GenerateNonce( ) ) )
    {
        goto ExitPoint;
    }

    if ( FAILED( hr = BreakUserAndDomain(   aValueTable[ MD5_AUTH_USERNAME ],
                                            straDomainName,
                                            straUserName ) ) )
    {
        goto ExitPoint;
    }
        
    DigestLogonInfo.pszNtUser       = straUserName.QueryStr();
    DigestLogonInfo.pszDomain       = straDomainName.QueryStr();
    DigestLogonInfo.pszUser         = aValueTable[ MD5_AUTH_USERNAME ];
    DigestLogonInfo.pszRealm        = aValueTable[ MD5_AUTH_REALM ];
    DigestLogonInfo.pszURI          = aValueTable[ MD5_AUTH_URI ];
    DigestLogonInfo.pszMethod       = straVerb.QueryStr();
    DigestLogonInfo.pszNonce        = straCurrentNonce.QueryStr();
    DigestLogonInfo.pszCurrentNonce = pDigestConnContext->QueryNonce().QueryStr();
    DigestLogonInfo.pszCNonce       = aValueTable[ MD5_AUTH_CNONCE ];
    DigestLogonInfo.pszQOP          = aValueTable[ MD5_AUTH_QOP ];
    DigestLogonInfo.pszNC           = aValueTable[ MD5_AUTH_NC ];
    DigestLogonInfo.pszResponse     = aValueTable[ MD5_AUTH_RESPONSE ];

    pW3Request = pMainContext->QueryRequest();
    DBG_ASSERT( pW3Request != NULL );
    
    //
    // Register the remote IP address with LSA so that it can be logged
    //

    if( pW3Request->QueryRemoteAddressType() == AF_INET )
    {
        secStatus = SecpSetIPAddress( 
                        ( PUCHAR )pW3Request->QueryRemoteSockAddress(),
                        sizeof( SOCKADDR_IN ) );
    }
    else if( pW3Request->QueryRemoteAddressType() == AF_INET6 )
    {
        secStatus = SecpSetIPAddress( 
                        ( PUCHAR )pW3Request->QueryRemoteSockAddress(),
                        sizeof( SOCKADDR_IN6 ) );
    }
    else
    {
        DBG_ASSERT( FALSE );
    }

    if( FAILED( secStatus ) )
    {
        hr = secStatus;
        goto ExitPoint;
    }
    
    fSt = IISLogonDigestUserA( &DigestLogonInfo,
                            IISSUBA_DIGEST ,
                            &hAccessTokenImpersonation );
    if ( fSt == FALSE )
    {
        DWORD dwRet = GetLastError();
        if ( dwRet == ERROR_PASSWORD_MUST_CHANGE ||
            dwRet == ERROR_PASSWORD_EXPIRED )
        {
            hr = HRESULT_FROM_WIN32( dwRet );
            goto ExitPoint;
        }

        if( dwRet == ERROR_PROC_NOT_FOUND )
        {
            if( W3_STATE_AUTHENTICATION::sm_lSubAuthDigestEvent == 0 )
            {
                if( !InterlockedExchange( &W3_STATE_AUTHENTICATION::sm_lSubAuthDigestEvent, 1 ) )
                {
                    //
                    // The registry key for iissuba is not configured correctly
                    //
                    g_pW3Server->LogEvent( W3_EVENT_SUBAUTH_REGISTRY_CONFIGURATION_DC,
                                           0,
                                           NULL );
                }
            }

            hr = HRESULT_FROM_WIN32( dwRet );
            goto ExitPoint;
        }

        fSendAccessDenied = TRUE;

        hr = HRESULT_FROM_WIN32( dwRet );

        goto ExitPoint;
    }

    //
    // Response from the client was correct but the nonce has expired,
    // 

    if ( pDigestConnContext->IsExpiredNonce( straCurrentNonce,
                                             pDigestConnContext->QueryNonce() ) )
    {

        //
        // User knows password but nonce that was used for 
        // response calculation already expired
        // Respond to client with stale=TRUE
        // Only Digest header will be sent to client
        // ( it will prevent state information needed to be passed
        //  from DoAuthenticate() to OnAccessDenied() )
        //
        
        pDigestConnContext->SetStale( TRUE );

        hr = SetDigestHeader( pMainContext, pDigestConnContext );
        if ( FAILED( hr ) )
        {
            goto ExitPoint;
        }
        //
        // Don't let anyone else send back authentication headers when
        // the 401 is sent
        //
        
        pMainContext->SetProviderHandled( TRUE );

        //
        // We need to send a 401 response to continue the handshake.  
        // We have already setup the WWW-Authenticate header
        //
        
        pMainContext->QueryResponse()->SetStatus( HttpStatusUnauthorized,
                                                  Http401BadLogon );
        
        pMainContext->SetFinishedResponse();

        pMainContext->SetErrorStatus( SEC_E_CONTEXT_EXPIRED );
        hr = NO_ERROR;
        
        goto ExitPoint;
    }

    //
    // We successfully authenticated.
    // Create a user context and setup it up
    //

    DBG_ASSERT( hAccessTokenImpersonation != NULL );
    
    pUserContext = new IIS_DIGEST_USER_CONTEXT( this );
    if ( pUserContext == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto ExitPoint;
    } 

    hr = pUserContext->Create( hAccessTokenImpersonation,
                               aValueTable[MD5_AUTH_USERNAME] );
    if ( FAILED( hr ) )
    {
        goto ExitPoint;
    }
    else
    {
        //
        // hAccessTokenImpestonation is now owned by pUserContext
        //
        hAccessTokenImpersonation = NULL;
    }
    
    pMainContext->SetUserContext( pUserContext );        

    hr = NO_ERROR;

ExitPoint:

    if ( FAILED( hr ) )
    {
        if ( fSendAccessDenied )
        {
            //
            // if ACCESS_DENIED then inform server to send 401 response
            // if SetStatus is not called then server will respond
            // with 500 Server Error
            //

            pMainContext->QueryResponse()->SetStatus( HttpStatusUnauthorized,
                                                  Http401BadLogon );

            //
            // SetErrorStatus() and reset value of hr
            //

            pMainContext->SetErrorStatus( hr );

            hr = NO_ERROR;
        }
        
        if ( hAccessTokenImpersonation != NULL )
        {
            CloseHandle( hAccessTokenImpersonation );
            hAccessTokenImpersonation = NULL;
        }
        
        if ( pUserContext != NULL )
        {
            pUserContext->DereferenceUserContext();
            pUserContext = NULL;
        }

    }

    return hr;
}


HRESULT
IIS_DIGEST_AUTH_PROVIDER::OnAccessDenied(
    IN  W3_MAIN_CONTEXT *       pMainContext
)
/*++

  Description:
    
    Add WWW-Authenticate Digest headers

Arguments:

    pMainContext - main context
    
Return Value:

    HRESULT

--*/
{
    HRESULT                     hr                    = E_FAIL;
    IIS_DIGEST_CONN_CONTEXT *   pDigestConnContext    = NULL;
    
    DBG_ASSERT( pMainContext != NULL );

    //
    // 2 providers implement Digest but they are mutually exclusive
    // If DigestSSP is enabled then IIS-DIGEST cannot be used
    //
    if ( g_pW3Server->QueryUseDigestSSP() )
    {
        //
        // Digest SSP is enabled => IIS Digest cannot be used
        //
        return NO_ERROR;
    }

    if( W3_STATE_AUTHENTICATION::sm_lSubAuthDigestEvent == 1 )
    {
        //
        // IIS subauth is not configured correctly on DC
        //
        return NO_ERROR;
    }

    if( !W3_STATE_AUTHENTICATION::QueryIsDomainMember() )
    {
        //
        // We are not a domain member, so do nothing
        //
        return NO_ERROR;
    }

    pDigestConnContext = (IIS_DIGEST_CONN_CONTEXT *)
                         QueryConnectionAuthContext( pMainContext );

    if ( pDigestConnContext == NULL )
    {
        //
        // Create new Authentication context
        // it may get reused for next request 
        // if connection is reused
        //

        pDigestConnContext = new IIS_DIGEST_CONN_CONTEXT();
        if ( pDigestConnContext == NULL )
        {
            return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        }

        hr = SetConnectionAuthContext(  pMainContext, 
                                        pDigestConnContext );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }
    
    return SetDigestHeader( pMainContext, pDigestConnContext );
}



HRESULT
IIS_DIGEST_AUTH_PROVIDER::SetDigestHeader(
    IN  W3_MAIN_CONTEXT *       pMainContext,
    IN IIS_DIGEST_CONN_CONTEXT *   pDigestConnContext  
)
/*++

  Description:
    
    Add WWW-Authenticate Digest headers

Arguments:

    pMainContext - main context
    
Return Value:

    HRESULT

--*/
{
    HRESULT                     hr                    = E_FAIL;
    BOOL                        fStale                = FALSE;
    W3_METADATA *               pMetaData             = NULL;
   
    STACK_STRA(                 strOutputHeader, MAX_PATH + 1); 
    STACK_STRA(                 strNonce, NONCE_SIZE + 1  ); 


    DBG_ASSERT( pMainContext != NULL );

    pMetaData = pMainContext->QueryUrlContext()->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );


    fStale = pDigestConnContext->QueryStale(  );    
    
    //
    // Reset Stale so that it will not be used for next request
    //

    pDigestConnContext->SetStale( FALSE );

    if ( FAILED( hr = pDigestConnContext->GenerateNonce() ) )
    {
        return hr;
    }

    //
    // If a realm is configured, use it.  Otherwise use host address of 
    // request 
    //

    STACK_STRA(      straRealm, IIS_DNLEN + 1 );
    STACK_STRU(      strHostAddr, 256       );

    if ( pMetaData->QueryRealm() != NULL )
    {
        hr = straRealm.CopyW( pMetaData->QueryRealm() );
    }
    else
    {
        hr = pMainContext->QueryRequest()->GetHostAddr( &strHostAddr );
        if ( FAILED( hr ) )
        {
            return hr;
        }
        hr = straRealm.CopyW( strHostAddr.QueryStr() );
    }

    if ( FAILED( hr ) )
    {
        return hr;
    }

    //
    // build WWW-Authenticate header
    //
    
    if ( FAILED( hr = strOutputHeader.Copy( "Digest qop=\"auth\", realm=\"" ) ) )
    {
        return hr;
    }
    if ( FAILED( hr = strOutputHeader.Append( straRealm ) ) )
    {
        return hr;
    }
    if ( FAILED( hr = strOutputHeader.Append( "\", nonce=\"" ) ) )
    {
        return hr;
    }
    if ( FAILED( hr = strOutputHeader.Append( pDigestConnContext->QueryNonce() ) ) )
    {
        return hr;
    }
    if ( FAILED( hr = strOutputHeader.Append( fStale ? "\", stale=true" : "\"" ) ) )
    {
        return hr;
    }

    //
    //  Add the header WWW-Authenticate to the response 
    //

    hr = pMainContext->QueryResponse()->SetHeader(
                                        "WWW-Authenticate",
                                        16,
                                        strOutputHeader.QueryStr(),
                                        (USHORT)strOutputHeader.QueryCCH() 
                                        );
    return hr;
}


//static 
HRESULT
IIS_DIGEST_AUTH_PROVIDER::GetLanGroupDomainName( 
    OUT  STRA& straDomain
)
/*++

Routine Description:

    Tries to retrieve the "LAN group"/domain this machine is a member of.

Arguments:

    straDomain - receives current domain name

Returns:

    HRESULT

--*/
{
    //
    // NET_API_STATUS is equivalent to WIN32 errors
    //
    NET_API_STATUS          dwStatus        = 0;
    NETSETUP_JOIN_STATUS    JoinStatus;
    LPWSTR                  pwszDomainInfo  = NULL;
    HRESULT                 hr              = E_FAIL;

    dwStatus = NetGetJoinInformation( NULL,
                                      &pwszDomainInfo,
                                      &JoinStatus );
    if( dwStatus == NERR_Success)
    {
        if ( JoinStatus == NetSetupDomainName )
        {
            //
            // we got a domain
            //
            DBG_ASSERT( pwszDomainInfo != NULL );
            if ( FAILED( hr = straDomain.CopyW( pwszDomainInfo ) ) )
            {
                goto ExitPoint;
            }
        }
        else
        {
            //
            // Domain information is not available
            // (maybe server is member of workgroup)
            //
        
            straDomain.Reset();
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32( dwStatus );
        goto ExitPoint;
    }

    hr = NO_ERROR;

ExitPoint:
    if ( pwszDomainInfo != NULL )
    {
        NetApiBufferFree( (LPVOID) pwszDomainInfo );
    }

    return hr;
}


//static 
HRESULT
IIS_DIGEST_AUTH_PROVIDER::BreakUserAndDomain(
    IN  PCHAR            pszFullName,
    OUT STRA&            straDomainName,
    OUT STRA&            straUserName
)
/*++

Routine Description:

    Breaks up the supplied account into a domain and username; if no domain 
is specified
    in the account, tries to use either domain configured in metabase or 
domain the computer
    is a part of.

Arguments:

    straFullName - account, of the form domain\username or just username
    straDomainName - filled in with domain to use for authentication
    straUserName - filled in with username on success

Return Value:

    HRESULT

--*/

{
    PCHAR           pszSeparator        = NULL;
    HRESULT         hr                  = E_FAIL;
    
    if( pszFullName == NULL && pszFullName[0] == '\0' )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    pszSeparator = (PCHAR) _mbschr( (PUCHAR) pszFullName, '\\' );
    if ( pszSeparator != NULL )
    {
        if ( FAILED( hr = straDomainName.Copy ( pszFullName,
                                                DIFF( pszSeparator - pszFullName ) ) ) )
        {
            return hr;
        }
        pszFullName = pszSeparator + 1;
    }
    else
    {
        straDomainName.Reset();
    }

    if ( FAILED( hr = straUserName.Copy ( pszFullName ) ) )
    {
        return hr;
    } 
    
    //
    // If no domain name was specified, try getting the name of the domain 
    // the computer is a part of 
    //
    
    if ( straDomainName.IsEmpty() )
    {
        if ( FAILED( hr = straDomainName.Copy ( QueryComputerDomain() ) ) )
        {
            return hr;
        } 
    }

    return NO_ERROR;
}


//
// class IIS_DIGEST_USER_CONTEXT implementation
//

HANDLE
IIS_DIGEST_USER_CONTEXT::QueryPrimaryToken(
    VOID
)
/*++

Routine Description:

    Get primary token for this user

Arguments:

    None

Return Value:

    Token handle

--*/
{
    DBG_ASSERT( _hImpersonationToken != NULL );

    if ( _hPrimaryToken == NULL )
    {
        if ( DuplicateTokenEx( _hImpersonationToken,
                               0,
                               NULL,
                               SecurityImpersonation,
                               TokenPrimary,
                               &_hPrimaryToken ) )
        {
            DBG_ASSERT( _hPrimaryToken != NULL );
        }
    }
    
    return _hPrimaryToken;
}


HRESULT
IIS_DIGEST_USER_CONTEXT::Create(
         IN HANDLE                      hImpersonationToken,
         IN PSTR                        pszUserName

)
/*++

Routine Description:

    Create an user context

Arguments:

    
Return Value:

    HRESULT

--*/
{
    HRESULT         hr = E_FAIL;

    DBG_ASSERT( pszUserName != NULL );
    DBG_ASSERT( hImpersonationToken != NULL );

    if ( hImpersonationToken == NULL ||
         pszUserName == NULL )  
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    if ( FAILED( hr = _strUserName.CopyA(pszUserName) ) )
    {
        return hr;
    }

    //
    // IIS_DIGEST_USER_CONTEXT is taking over ownership of
    // hImpersonationToken
    //
    _hImpersonationToken = hImpersonationToken;

    return NO_ERROR;
}


//
// Class IIS_DIGEST_CONN_CONTEXT implementation
//

// Initialize static variables

//static
ALLOC_CACHE_HANDLER * IIS_DIGEST_CONN_CONTEXT::sm_pachIISDIGESTConnContext = NULL;

//static 
const PCHAR     IIS_DIGEST_CONN_CONTEXT::_pszSecret = "IISMD5";

//static 
const DWORD     IIS_DIGEST_CONN_CONTEXT::_cchSecret = 6;

//static
HCRYPTPROV IIS_DIGEST_CONN_CONTEXT::sm_hCryptProv = NULL;

//static
HRESULT
IIS_DIGEST_CONN_CONTEXT::Initialize(
    VOID
)
/*++

  Description:
    
    Global IIS_DIGEST_CONN_CONTEXT initialization

Arguments:

    None
    
Return Value:

    HRESULT

--*/
{
    ALLOC_CACHE_CONFIGURATION       acConfig;
    HRESULT                         hr = E_FAIL;

    //
    // Initialize allocation lookaside
    //
    
    acConfig.nConcurrency = 1;
    acConfig.nThreshold = 100;
    acConfig.cbSize = sizeof( IIS_DIGEST_CONN_CONTEXT );

    DBG_ASSERT( sm_pachIISDIGESTConnContext == NULL );
    
    sm_pachIISDIGESTConnContext = new ALLOC_CACHE_HANDLER( 
                                            "IIS_DIGEST_CONTEXT",  
                                            &acConfig );

    if ( sm_pachIISDIGESTConnContext == NULL ||
         !sm_pachIISDIGESTConnContext->IsValid() )
    {
        if( sm_pachIISDIGESTConnContext != NULL )
        {
            delete sm_pachIISDIGESTConnContext;
            sm_pachIISDIGESTConnContext = NULL;
        }

        hr = HRESULT_FROM_WIN32( GetLastError() );

        DBGPRINTF(( DBG_CONTEXT,
               "Error initializing sm_pachIISDIGESTSecContext. hr = 0x%x\n",
               hr ));

        goto Failed;
    }

    //
    //  Get a handle to the CSP we'll use for all our hash functions etc
    //
    
    if ( !CryptAcquireContext( &sm_hCryptProv,
                               NULL,
                               NULL,
                               PROV_RSA_FULL,
                               CRYPT_VERIFYCONTEXT ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );

        DBGPRINTF((DBG_CONTEXT,
                   "CryptAcquireContext() failed : 0x%x\n", GetLastError()));
        goto Failed;
    }

    return S_OK;
    
Failed:
    Terminate();
    return hr;
    
} 
//static
VOID
IIS_DIGEST_CONN_CONTEXT::Terminate(
    VOID
)
/*++

Routine Description:

    Destroy globals

Arguments:

    None
    
Return Value:

    None

--*/
{
    if ( sm_pachIISDIGESTConnContext != NULL )
    {
        delete sm_pachIISDIGESTConnContext;
        sm_pachIISDIGESTConnContext = NULL;
    }

    if ( sm_hCryptProv != NULL )
    {
        CryptReleaseContext( sm_hCryptProv,
                             0 );
        sm_hCryptProv = NULL;
    }


} 

//static
HRESULT
IIS_DIGEST_CONN_CONTEXT::HashData( 
    IN  BUFFER& buffData,
    OUT BUFFER& buffHash )
/*++

Routine Description:

    Creates MD5 hash of input buffer

Arguments:

    buffData - data to hash
    buffHash - buffer that receives hash; is assumed to be big enough to 
contain MD5 hash

Return Value:

    HRESULT
--*/

{
    HCRYPTHASH      hHash   = NULL;
    HRESULT         hr      = E_FAIL;
    DWORD           cbHash  = 0;  


    DBG_ASSERT( buffHash.QuerySize() >= MD5_HASH_SIZE );

    if ( !CryptCreateHash( sm_hCryptProv,
                           CALG_MD5,
                           0,
                           0,
                           &hHash ) )
    {
        //DBGPRINTF((DBG_CONTEXT,
        //           "CryptCreateHash() failed : 0x%x\n", GetLastError()));
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto ExitPoint;
    }

    if ( !CryptHashData( hHash,
                         (PBYTE) buffData.QueryPtr(),
                         buffData.QuerySize(),
                         0 ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto ExitPoint;
    }

    cbHash = buffHash.QuerySize();
    if ( !CryptGetHashParam( hHash,
                             HP_HASHVAL,
                             (PBYTE) buffHash.QueryPtr(),
                             &cbHash,
                             0 ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto ExitPoint;
    }

    hr = NO_ERROR;
    
ExitPoint:

    if ( hHash != NULL )
    {
        CryptDestroyHash( hHash );
    }
    return hr;
}


//static
BOOL
IIS_DIGEST_CONN_CONTEXT::IsExpiredNonce( 
    IN  STRA& strRequestNonce,
    IN  STRA& strPresentNonce 
)
/*++

Routine Description:

    Checks whether nonce is expired or not by looking at the timestamp on the 
nonce
    that came in with the request and comparing it with the timestamp on the 
latest nonce

Arguments:

    strRequestNonce - nonce that came in with request
    strPresentNonce - latest nonce

Return Value:

    TRUE if expired, FALSE if not
    
--*/
{
    //
    // Timestamp is after first 2*RANDOM_SIZE bytes of nonce; also, note that
    // timestamp is time() mod NONCE_GRANULARITY, so all we have to do is simply
    // compare for equality to check that the request nonce hasn't expired
    //

    DBG_ASSERT( strRequestNonce.QueryCCH() >= 2*RANDOM_SIZE + TIMESTAMP_SIZE );
    DBG_ASSERT( strPresentNonce.QueryCCH() >= 2*RANDOM_SIZE + TIMESTAMP_SIZE );

    if ( memcmp( strRequestNonce.QueryStr() + 2*RANDOM_SIZE, 
                 strPresentNonce.QueryStr() + 2*RANDOM_SIZE,
                 TIMESTAMP_SIZE ) != 0 )
    {
        return TRUE;
    }
    return FALSE;
}

//static
BOOL
IIS_DIGEST_CONN_CONTEXT::IsWellFormedNonce( 
    IN  STRA& strNonce 
)
/*++

Routine Description:

    Checks whether a nonce is "well-formed" by checking hash value, length etc 
    
Arguments:

    pszNonce - nonce to be checked

Return Value:

    TRUE if nonce is well-formed, FALSE if not

--*/

{

    if ( strNonce.QueryCCH()!= NONCE_SIZE ) 
    {
        return FALSE;
    }

    //
    // Format of nonce : <random bytes><time stamp><hash of (secret,random bytes,time stamp)>
    // 
    
    STACK_BUFFER(       buffBuffer, 2*RANDOM_SIZE + TIMESTAMP_SIZE + _cchSecret );
    STACK_BUFFER(       buffHash, MD5_HASH_SIZE );
    STACK_STRA(         strAsciiHash, 2*MD5_HASH_SIZE + 1 );

    memcpy( buffBuffer.QueryPtr(), 
            _pszSecret, 
            _cchSecret );
    memcpy( (PBYTE) buffBuffer.QueryPtr() + _cchSecret, 
            strNonce.QueryStr(), 
            2*RANDOM_SIZE + TIMESTAMP_SIZE );

    if ( FAILED( HashData( buffBuffer, 
                           buffHash ) ) )
    {
        return FALSE;
    }

    ToHex( buffHash, 
           strAsciiHash );

    if ( memcmp( strAsciiHash.QueryStr(),
                 strNonce.QueryStr() + 2*RANDOM_SIZE + TIMESTAMP_SIZE,
                 2*MD5_HASH_SIZE ) != 0)
    {
        return FALSE;
    }

    return TRUE;
                    
}

HRESULT
IIS_DIGEST_CONN_CONTEXT::GenerateNonce( 
    VOID
)
/*++

Routine Description:

    Generate nonce to be stored in user filter context. Nonce is

    <ASCII rep of Random><Time><ASCII of MD5(Secret:Random:Time)>

    Random = <8 random bytes>
    Time = <16 bytes, reverse string rep of result of time() call>
    Secret = 'IISMD5'

Arguments:

    none

Return Value:

    HRESULT

--*/
{
    HRESULT             hr      = E_FAIL;
    DWORD               tNow    = (DWORD) ( time( NULL ) / NONCE_GRANULARITY );

    //
    // If nonce has timed out, generate a new one
    //
    if ( _tLastNonce < tNow )
    {
        STACK_BUFFER(       buffTempBuffer, 2*RANDOM_SIZE + TIMESTAMP_SIZE + _cchSecret );
        STACK_BUFFER(       buffDigest, MD5_HASH_SIZE );
        STACK_BUFFER(       buffRandom, RANDOM_SIZE );
        STACK_STRA(         strTimeStamp, TIMESTAMP_SIZE + 1 );
        STACK_STRA(         strAsciiDigest, 2*MD5_HASH_SIZE + 1 );
        STACK_STRA(         strAsciiRandom, 2*RANDOM_SIZE + 1);

        DWORD               cbTimeStamp     =  0;
        PSTR                pszTimeStamp    =  NULL;

        
        _tLastNonce = tNow;

        //
        // First, random bytes
        //
        if ( !CryptGenRandom( sm_hCryptProv,
                              RANDOM_SIZE,
                              (PBYTE) buffRandom.QueryPtr() ) )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto ExitPoint;
        }
        
        //
        // Convert to ASCII, doubling the length, and add to nonce 
        //

        ToHex( buffRandom, 
               strAsciiRandom );

        if ( FAILED( hr = _straNonce.Copy( strAsciiRandom ) ) )
        {
            goto ExitPoint;
        }

        //
        // Next, reverse string representation of current time; pad with zeros if necessary
        //
        pszTimeStamp = strTimeStamp.QueryStr();
        DBG_ASSERT( pszTimeStamp != NULL );
        while ( tNow != 0 )
        {
            *(pszTimeStamp++) = (BYTE)( '0' + tNow % 10 );
            cbTimeStamp++;
            tNow /= 10;
        }

        DBG_ASSERT( cbTimeStamp <=  TIMESTAMP_SIZE );
        
        //
        // pad with zeros if necessary
        //
        while ( cbTimeStamp < TIMESTAMP_SIZE )
        {
            *(pszTimeStamp++) = '0';
            cbTimeStamp++;
        }

        //
        // terminate the timestamp
        //
        *(pszTimeStamp) = '\0';
        DBG_REQUIRE( strTimeStamp.SetLen( cbTimeStamp ) );
        
        //
        // Append TimeStamp to Nonce
        //
        if ( FAILED( hr = _straNonce.Append( strTimeStamp ) ) )
        {
            goto ExitPoint;
        }
        
        //
        // Now hash everything, together with a private key ( IISMD5 )
        //
        memcpy( buffTempBuffer.QueryPtr(), 
                _pszSecret, 
                _cchSecret );
                
        memcpy( (PBYTE) buffTempBuffer.QueryPtr() + _cchSecret, 
                _straNonce.QueryStr(), 
                2*RANDOM_SIZE + TIMESTAMP_SIZE );

        DBG_ASSERT( buffTempBuffer.QuerySize() == 2*RANDOM_SIZE + TIMESTAMP_SIZE + _cchSecret );

        if ( FAILED( hr = HashData( buffTempBuffer,
                                    buffDigest ) ) )
        {
            goto ExitPoint;
        }

        //
        // Convert to ASCII, doubling the length
        //
        DBG_ASSERT( buffDigest.QuerySize() == MD5_HASH_SIZE );
 
        ToHex( buffDigest, 
               strAsciiDigest );

        //
        // Add hash to nonce 
        //
        if ( FAILED( hr = _straNonce.Append( strAsciiDigest ) ) )
        {
            goto ExitPoint;
        }
    }

    hr = NO_ERROR;

ExitPoint:
    return hr;
}


//static 
BOOL 
IIS_DIGEST_CONN_CONTEXT::ParseForName(
    IN OUT PSTR    pszStr,
    IN  PSTR *  pNameTable,
    IN  UINT    cNameTable,
    OUT PSTR *  pValueTable
)
/*++

Routine Description:

    Parse list of name=value pairs for known names

    Note: pszStr is modified upon return. This function doesn't 
    copy names and values but instead adds string terminators into
    the pszStr string after each name and value found

Arguments:

    pszStr - line to parse ( '\0' delimited )
    pNameTable - table of known names
    cNameTable - number of known names
    pValueTable - updated with ptr to parsed value for corresponding name

Return Value:

    TRUE if success, FALSE if error

--*/
{
    BOOL    fStatus     = TRUE;
    PSTR    pszBeginName = NULL;
    PSTR    pszEndName = NULL;
    PSTR    pszBeginVal = NULL;
    PSTR    pszEndVal = NULL;
    UINT     i;


    DBG_ASSERT( pszStr!= NULL );

    for ( i = 0 ; i < cNameTable ; ++i )
    {
        pValueTable[i] = NULL;
    }

    while ( *pszStr != '\0' && fStatus )
    {
        pszStr = SkipWhite( pszStr );
        //
        // Got to the beggining of the value name
        //
       
        pszBeginName = pszStr;
        
        //
        // Seek for the end of the value name
        //
        for ( pszEndName = pszStr;
              *pszEndName != '\0' && 
                *pszEndName != '=' && 
                *pszEndName != ' ';
              pszEndName++ )
        {
        }

        //
        // The end of the name was found
        // time to process the value associated with name
        //

        if ( *pszEndName != '\0' )
        {
            //
            // terminate the name string
            //
            //
            *pszEndName = '\0';
            pszEndVal = NULL;

            //
            // process values that require special handling
            //

            //
            // Process the value for NC
            //
            if ( _stricmp( pszBeginName, MD5_AUTH_NAMES[ MD5_AUTH_NC ] ) == 0 )
            {
                for ( pszBeginVal = ++pszEndName ; 
                      (*pszBeginVal != '\0') && !SAFEIsXDigit( (UCHAR)*pszBeginVal ); 
                      ++pszBeginVal )
                {
                }

                if ( *pszBeginVal != '\0' )
                {
                    //
                    // Find the end of the value
                    //
                    for ( pszEndVal = pszBeginVal; 
                          *pszEndVal != '\0' ; 
                          ++pszEndVal )
                    {
                        if ( *pszEndVal == ' ' || 
                             *pszEndVal == ',' )
                        {
                            break;
                        }
                    }

                    if ( pszEndVal - pszBeginVal != SIZE_OF_NC )
                    {
                        //
                        // value in error is ignored
                        //
                        pszEndVal = NULL;
                    }
                }
            }
            else
            {   
                if ( _stricmp( pszBeginName, MD5_AUTH_NAMES[ MD5_AUTH_QOP ] ) == 0 )
                {
                    BOOL fQuotedQop = FALSE;
                    //
                    // move to the begining of the qop value
                    //
                    for( pszBeginVal = ++pszEndName; 
                        ( *pszBeginVal != '\0' ) && 
                        ( *pszBeginVal == '=' || *pszBeginVal == ' ' ); 
                         ++pszBeginVal )
                    {
                    }
                    //
                    // Check if value starts with qoutes
                    //
                    if ( *pszBeginVal == '"' )
                    {
                        ++pszBeginVal;
                        fQuotedQop = TRUE;
                    }

                    //
                    // Find the end of the value
                    //
                    for ( pszEndVal = pszBeginVal; 
                          *pszEndVal != '\0' ; 
                          ++pszEndVal )
                    {
                        if ( *pszEndVal == '"' || *pszEndVal == ' ' || 
                             *pszEndVal == ',' )
                        {
                            break;
                        }
                    }
                    //
                    // If value started with quotes then it has
                    // to end with qoutes
                    //
                    if ( *pszEndVal != '"' && fQuotedQop )
                    {
                        pszEndVal = NULL;
                    }
                }
                else if( _stricmp( pszBeginName, MD5_AUTH_NAMES[ MD5_AUTH_ALGORITHM ] ) == 0 )
                {
                    BOOL fQuotedAlgorithm = FALSE;
                    //
                    // move to the begining of the algorithm value
                    //
                    for( pszBeginVal = ++pszEndName; 
                        ( *pszBeginVal != '\0' ) && 
                        ( *pszBeginVal == '=' || *pszBeginVal == ' ' ); 
                         ++pszBeginVal )
                    {
                    }
                    //
                    // Check if value starts with qoutes
                    //
                    if ( *pszBeginVal == '"' )
                    {
                        ++pszBeginVal;
                        fQuotedAlgorithm = TRUE;
                    }

                    //
                    // Find the end of the value
                    //
                    for ( pszEndVal = pszBeginVal; 
                          *pszEndVal != '\0' ; 
                          ++pszEndVal )
                    {
                        if ( *pszEndVal == '"' || *pszEndVal == ' ' || 
                             *pszEndVal == ',' )
                        {
                            break;
                        }
                    }
                    //
                    // If value started with quotes then it has
                    // to end with qoutes
                    //
                    if ( *pszEndVal != '"' && fQuotedAlgorithm )
                    {
                        pszEndVal = NULL;
                    }
                }
                else
                {                
                    //
                    // handle the rest of the values
                    // (these are expected to be always 
                    // enclosed in double quotes)
                    //

                    //
                    // Search for the opening double quote
                    //
                    for ( pszBeginVal = ++pszEndName ; 
                          *pszBeginVal != '\0' && *pszBeginVal != '"' ; 
                          ++pszBeginVal )
                    {
                    }
                    //
                    // Found opening double quote
                    //
                    if ( *pszBeginVal == '"' )
                    {
                        for ( pszEndVal = ++pszBeginVal ; 
                              *pszEndVal != '\0' ; 
                              ++pszEndVal )
                        {
                            if ( *pszEndVal == '"' )
                            {
                                //
                                // Found the closing double quote
                                //
                                break;
                            }
                        }
                              
                        if ( *pszEndVal != '"' )
                        {
                            pszEndVal = NULL;
                        }
                    }
                }
            }

            //
            // The end of the value was reached
            // check if correct value was found
            //
            
            if ( pszEndVal != NULL )
            {
                //
                // Find the value name in the name table
                //

                for ( i = 0 ; i < cNameTable ; ++i )
                {
                    if ( _stricmp( pNameTable[ i ], pszBeginName ) == 0 )
                    {
                        break;
                    }
                }
                
                //
                // If the name was found in the table than make proper assignment
                // to value table, otherwise ignore the value
                //
                
                if ( i < cNameTable )
                {
                    //
                    // assign value to the appropriate index
                    // 
                    pValueTable[ i ] = pszBeginVal;
                }

                //
                // terminate the value with '\0'
                //
                if ( *pszEndVal != '\0' )
                {
                    *pszEndVal = '\0';
                    pszEndVal++;
                }
                
                // move the pszStr to point past the value that was just parsed
                pszStr = pszEndVal;

                continue;
            }
        }
        
        fStatus = FALSE;
    }

    return fStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\iiscertmapprovider.cxx ===
/*++
   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     certmapprovider.cxx

   Abstract:
     IIS Certificate Mapper provider
 
   Author:
     Bilal Alam (balam)             10-Jan-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include "iiscertmapprovider.hxx"

HRESULT
IISCERTMAP_AUTH_PROVIDER::DoesApply(
    W3_MAIN_CONTEXT *       pMainContext,
    BOOL *                  pfApplies
)
/*++

Routine Description:

    Does certificate map authentication apply? 

Arguments:

    pMainContext - Main context
    pfApplies - Set to TRUE if cert map auth applies

Return Value:

    HRESULT

--*/
{
    CERTIFICATE_CONTEXT *           pCertificateContext;
    URL_CONTEXT *                   pUrlContext = NULL;
    W3_METADATA *                   pMetaData = NULL;
    BOOL                            fApplies = FALSE;
    W3_SITE *                       pSite = NULL;
    IIS_CERTIFICATE_MAPPING *       pIISCertificateMapping = NULL;
    TOKEN_CACHE_ENTRY *             pCachedIISMappedToken = NULL;
    BOOL                            fClientCertDeniedByMapper = FALSE;
                    
    
    if ( pMainContext == NULL ||
         pfApplies == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // If cert mapping is not allowed for this vroot, then ignore client
    // cert token and let other authentication mechanisms do their thing
    //
    pUrlContext = pMainContext->QueryUrlContext();
    DBG_ASSERT( pUrlContext != NULL );

    pMetaData = pUrlContext->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );

    if ( pMetaData->QuerySslAccessPerms() & MD_ACCESS_MAP_CERT )
    {
        
        pCertificateContext = pMainContext->QueryCertificateContext();
        if ( pCertificateContext == NULL )
        {
            fApplies = FALSE;            
            goto Finished;
        }
        
        pSite = pMainContext->QuerySite();
        DBG_ASSERT( pSite != NULL );

        if ( ! pSite->QueryUseDSMapper() )
        {
            //
            // IIS mapper enabled
            //
            HRESULT hr = E_FAIL;
            PBYTE         pbClientCertBlob = NULL;
            DWORD         cbClientCertBlob = 0;
            
            //
            // No need to call DereferenceCertMapping after QueryIISCertificateMapping
            // IISCertificateMapping is referenced by W3_SITE and we hold reference 
            // to W3_SITE  already
            //
            hr = pSite->GetIISCertificateMapping( &pIISCertificateMapping );
            if ( FAILED( hr ) ||
               ( pIISCertificateMapping == NULL ) )
            {
                //
                // If we couldn't read the mapping because not found, thats OK.
                //
                // CODEWORK: we may need smarted error handling (ignoring error 
                // and assuming that mapping was not found is not very good idea
                //
                fApplies = FALSE;            
                goto Finished;
            }

            //
            // retrieve client certificate
            //
            pCertificateContext->QueryEncodedCertificate( 
                                        reinterpret_cast<PVOID *>(&pbClientCertBlob), 
                                        &cbClientCertBlob );

            if( pbClientCertBlob == NULL || cbClientCertBlob == 0 )
            {
                fApplies = FALSE;            
                goto Finished;
            }
            DBG_ASSERT( pIISCertificateMapping != NULL );
            
            hr = pIISCertificateMapping->DoMapCredential( pMainContext,
                                                          pbClientCertBlob,
                                                          cbClientCertBlob,
                                                          &pCachedIISMappedToken,
                                                          &fClientCertDeniedByMapper );
            if ( FAILED( hr ) )
            {
                //
                // IISCERTMAP applies only when there was successful mapping
                // Otherwise it will yield other auth providers
                //
                
                if ( hr == SEC_E_UNKNOWN_CREDENTIALS )
                {
                    //
                    // DoMapCredential didn't find any mathing mapping
                    // or user/pwd in the mapping was invalid
                    //
                    hr = S_OK;
                }
                fApplies = FALSE;            
                goto Finished;
            }

            DBG_ASSERT ( fClientCertDeniedByMapper || pCachedIISMappedToken!= NULL );

            if( ( pCachedIISMappedToken != NULL &&
                  pCachedIISMappedToken->QueryImpersonationToken() != NULL ) ||
                  fClientCertDeniedByMapper )
            {
                
                IISCERTMAP_CONTEXT_STATE * pContextState = NULL;
                //
                // Use IISCERTMAP_CONTEXT_STATE to communicate information
                // from DoesApply() to DoAuthenticate()
                // We don't want to be calling mapper twice
                //
                pContextState = new (pMainContext) IISCERTMAP_CONTEXT_STATE( 
                                                           pCachedIISMappedToken,
                                                           fClientCertDeniedByMapper );
                if ( pContextState == NULL )
                {
                    if ( pCachedIISMappedToken != NULL )
                    {
                        pCachedIISMappedToken->DereferenceCacheEntry();
                        pCachedIISMappedToken = NULL;
                    }
                    
                    hr = HRESULT_FROM_WIN32( ERROR_OUTOFMEMORY );
                    goto Finished;
                }
                //
                // pContextState is taking ownership of pCachedIISMappedToken
                //
                pMainContext->SetContextState( pContextState );
                fApplies = TRUE;
                 
            }
        }
    }
Finished:    
    *pfApplies = fApplies;

    if ( pCachedIISMappedToken != NULL )
    {
        //
        // if creating CERTMAP_CONTEXT_STATE succeeded it will hold it's own reference
        // to cached token
        //
        pCachedIISMappedToken->DereferenceCacheEntry();
        pCachedIISMappedToken = NULL;
    }
    return NO_ERROR;
}

HRESULT
IISCERTMAP_AUTH_PROVIDER::DoAuthenticate(
    W3_MAIN_CONTEXT *       pMainContext,
    BOOL *                  pfFilterFinished
)
/*++

Routine Description:

    Create a user context representing a cert mapped token

Arguments:

    pMainContext - Main context
    pfFilterFinished - Set to TRUE if filter wants out

Return Value:

    HRESULT

--*/
{
    IISCERTMAP_USER_CONTEXT *       pUserContext = NULL;
    HRESULT                         hr = NO_ERROR;
    W3_SITE *                       pSite = NULL;
    IISCERTMAP_CONTEXT_STATE *      pContextState = NULL;
    TOKEN_CACHE_ENTRY *             CachedToken = NULL;
    
    if ( pMainContext == NULL || 
         pfFilterFinished == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    *pfFilterFinished = FALSE;

    pSite = pMainContext->QuerySite();
    DBG_ASSERT( pSite != NULL );

    // IIS mapper
    DBG_ASSERT ( !pSite->QueryUseDSMapper() );
    

    pContextState = (IISCERTMAP_CONTEXT_STATE *) pMainContext->QueryContextState();
    DBG_ASSERT( pContextState != NULL );

    if ( pContextState->QueryClientCertDeniedByIISCertMap() )
    {
        //
        // Report denied by IIS mapper error
        //
        pMainContext->QueryResponse()->SetStatus( HttpStatusForbidden,
                                                  Http403MapperDenyAccess);
        pMainContext->SetErrorStatus( S_OK );
        return S_OK;
    }

    CachedToken = pContextState->QueryCachedIISCertMapToken();
    DBG_ASSERT( CachedToken != NULL );
    
    //
    // Create the user context for this request
    //
    
    pUserContext = new IISCERTMAP_USER_CONTEXT( this );
    if ( pUserContext == NULL )
    {
        CachedToken->DereferenceCacheEntry();
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    hr = pUserContext->Create( CachedToken );
    if ( FAILED( hr ) )
    {
        pUserContext->DereferenceUserContext();
        pUserContext = NULL;
        return hr;
    }
    
    pMainContext->SetUserContext( pUserContext );
    
    return NO_ERROR;
}

HRESULT
IISCERTMAP_AUTH_PROVIDER::OnAccessDenied(
    W3_MAIN_CONTEXT *               /*pMainContext*/
)
/*++

Routine Description:

    NOP since we have nothing to do on access denied

Arguments:

    pMainContext - Main context (not used)

Return Value:

    HRESULT

--*/
{
    //
    // No headers to add
    //
    
    return NO_ERROR;
}

HRESULT
IISCERTMAP_USER_CONTEXT::Create(
    TOKEN_CACHE_ENTRY *         pCachedToken
)
/*++

Routine Description:

    Create a certificate mapped user context

Arguments:

    pCachedToken - cached token

    Note: function takes ownership of pCachedToken. 
          It will dereference it even in the case of failure

Return Value:

    HRESULT

--*/
{
    HRESULT     hr = E_FAIL;
    
    if ( pCachedToken == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // First the easy stuff
    //

    pCachedToken->ReferenceCacheEntry();
    _pCachedToken = pCachedToken;

    SetCachedToken( TRUE );

    //
    // Now get the user name
    //
    
    if ( !SetThreadToken( NULL, _pCachedToken->QueryImpersonationToken() ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failed;
    }

    // cchUserName will be set to size of the buffer in chars (including terminating one)
    DWORD       cchUserName = sizeof( _achUserName ) / sizeof( WCHAR );
    
    if ( !GetUserNameEx( NameSamCompatible,
                         _achUserName,
                         &cchUserName ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        RevertToSelf();
        goto Failed;
    }
    
    RevertToSelf();
    
    return NO_ERROR;
Failed:
    if ( _pCachedToken != NULL )
    {
        _pCachedToken->DereferenceCacheEntry();
        _pCachedToken = NULL;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\isapi_handler.h ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    isapi_handler.h

Abstract:

    Handler class for ISAPI

Author:

    Taylor Weiss (TaylorW)       01-Feb-1999

Revision History:

--*/

#ifndef _ISAPI_HANDLER_H_
#define _ISAPI_HANDLER_H_

#include "precomp.hxx"
#include <w3isapi.h>
#include "isapi_request.hxx"
#include "iwam.h"
#include "wam_process.hxx"

//
// OOP support flags
//

// The pool's hard-coded CLSID
#define POOL_WAM_CLSID   L"{99169CB1-A707-11d0-989D-00C04FD919C1}"

// Application type
#define APP_INPROC   0
#define APP_ISOLATED 1
#define APP_POOL     2

//
// W3_ISAPI_HANDLER states
//

#define ISAPI_STATE_PRELOAD      0 // Preloading entity body
#define ISAPI_STATE_INITIALIZING 1 // Not yet called into extension code
#define ISAPI_STATE_PENDING      2 // Extension has returned HSE_STATUS_PENDING
#define ISAPI_STATE_FAILED       3 // Call out to extension failed
#define ISAPI_STATE_DONE         4 // Extension is done, it's safe to advance

#define CONTENT_TYPE_PLACEHOLDER    ""
#define CONNECTION_PLACEHOLDER      ""
#define USER_AGENT_PLACEHOLDER      ""
#define COOKIE_PLACEHOLDER          ""

//
// ISAPI_CORE_DATA inline size
//

#define DEFAULT_CORE_DATA_SIZE  256

//
// Globals
//

extern BOOL sg_Initialized;

//
// W3_INPROC_ISAPI
//

class W3_INPROC_ISAPI
{
public:
    
    W3_INPROC_ISAPI()
        : _cRefs( 1 )
    {
    }

    HRESULT
    Create(
        LPWSTR pName
        )
    {
        return strName.Copy( pName );
    }

    LPWSTR
    QueryName(
        VOID
        ) const
    {
        return (LPWSTR)strName.QueryStr();
    }

    VOID
    ReferenceInprocIsapi(
        VOID
        )
    {
        InterlockedIncrement( &_cRefs );
    }

    VOID
    DereferenceInprocIsapi(
        VOID
        )
    {
        DBG_ASSERT( _cRefs != 0 );

        InterlockedDecrement( &_cRefs );

        if ( _cRefs == 0 )
        {
            delete this;
        }
    }

private:

    ~W3_INPROC_ISAPI()
    {
    }

    LONG    _cRefs;
    STRU    strName;
};

//
// W3_INPROC_ISAPI_HASH
//

class W3_INPROC_ISAPI_HASH
    : public CTypedHashTable<
            W3_INPROC_ISAPI_HASH,
            W3_INPROC_ISAPI,
            LPCWSTR
            >
{
public:
    W3_INPROC_ISAPI_HASH()
        : CTypedHashTable< W3_INPROC_ISAPI_HASH, 
                           W3_INPROC_ISAPI, 
                           LPCWSTR > ( "W3_INPROC_ISAPI_HASH" )
    {
    }
    
    static 
    LPCWSTR
    ExtractKey(
        const W3_INPROC_ISAPI *      pEntry
    )
    {
        return pEntry->QueryName();
    }
    
    static
    DWORD
    CalcKeyHash(
        LPCWSTR              pszKey
    )
    {
        int cchKey = (int)wcslen(pszKey);

        return HashStringNoCase(pszKey, cchKey);
    }
     
    static
    bool
    EqualKeys(
        LPCWSTR               pszKey1,
        LPCWSTR               pszKey2
    )
    {
        return _wcsicmp( pszKey1, pszKey2 ) == 0;
    }
    
    static
    void
    AddRefRecord(
        W3_INPROC_ISAPI *       pEntry,
        int                   nIncr
        )
    {
        if ( nIncr == +1 )
        {
            pEntry->ReferenceInprocIsapi();
        }
        else if ( nIncr == - 1)
        {
            pEntry->DereferenceInprocIsapi();
        }
    }

    MULTISZ     _mszImages;

private:

    //
    // Avoid c++ errors
    //

    W3_INPROC_ISAPI_HASH( const W3_INPROC_ISAPI_HASH & )
        : CTypedHashTable< W3_INPROC_ISAPI_HASH,
                           W3_INPROC_ISAPI,
                           LPCWSTR >  ( "W3_INPROC_ISAPI_HASH" )
    {
    }

    W3_INPROC_ISAPI_HASH & operator = ( const W3_INPROC_ISAPI_HASH & ) { return *this; }
};

class W3_ISAPI_HANDLER : public W3_HANDLER
{
public:
    
    W3_ISAPI_HANDLER( W3_CONTEXT * pW3Context,
                      META_SCRIPT_MAP_ENTRY * pScriptMapEntry )
        : W3_HANDLER( pW3Context, pScriptMapEntry ),
          _pIsapiRequest( NULL ),
          _fIsDavRequest( FALSE ),
          _pCoreData( NULL ),
          _fEntityBodyPreloadComplete( FALSE ),
          _pWamProcess( NULL ),
          _State( ISAPI_STATE_PRELOAD ),
          _buffCoreData( _abCoreData, sizeof( _abCoreData ) ),
          INLINE_STRA_INIT( _PhysicalPath ),
          INLINE_STRA_INIT( _PathInfo ),
          INLINE_STRA_INIT( _QueryString ),
          INLINE_STRA_INIT( _PathTranslated ),
          INLINE_STRA_INIT( _ApplMdPath ),
          INLINE_STRU_INIT( _ApplMdPathW ),
          INLINE_STRU_INIT( _PathTranslatedW )
    {
        IF_DEBUG( ISAPI )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Creating W3_ISAPI_HANDLER %p.  W3Context=%p.\r\n",
                this,
                pW3Context
                ));
        }
        
        //
        // Update perf counter information
        //

        pW3Context->QuerySite()->IncIsapiExtReqs();

        IF_DEBUG( ISAPI )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "W3_ISAPI_HANDLER %p created successfully.\r\n",
                this
                ));
        }
    }

    ~W3_ISAPI_HANDLER()
    {
        //
        // Update perf counter information.
        //

        QueryW3Context()->QuerySite()->DecIsapiExtReqs();

        //
        // Release this request's reference on the WAM_PROCESS
        // if applicable
        //

        if ( _pWamProcess )
        {
            _pWamProcess->Release();
            _pWamProcess = NULL;
        }

        IF_DEBUG( ISAPI )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "W3_ISAPI_HANDLER %p has been destroyed.\r\n"
                ));
        }
    }

    VOID * 
    operator new( 
        size_t              uiSize,
        VOID *              pPlacement
    )
    {
        W3_CONTEXT *                pContext;
    
        pContext = (W3_CONTEXT*) pPlacement;
        DBG_ASSERT( pContext != NULL );
        DBG_ASSERT( pContext->CheckSignature() );

        return pContext->ContextAlloc( (UINT)uiSize );
    }
    
    VOID
    operator delete(
        VOID *
    )
    {
    }

    WCHAR *
    QueryName(
        VOID
        )
    {
        return L"ISAPIHandler";
    }

    BOOL
    QueryManagesOwnHead(
        VOID
        )
    {
        return TRUE;
    }

    CONTEXT_STATUS
    DoWork(
        VOID
        );

    CONTEXT_STATUS
    OnCompletion(
        DWORD                   cbCompletion,
        DWORD                   dwCompletionStatus
        );

    CONTEXT_STATUS
    IsapiDoWork(
        W3_CONTEXT *            pW3Context
        );

    CONTEXT_STATUS
    IsapiOnCompletion(
        DWORD                   cbCompletion,
        DWORD                   dwCompletionStatus
        );

    HRESULT
    InitCoreData(
        BOOL *  pfIsVrToken
        );

    HRESULT
    SerializeCoreDataForOop(
        DWORD   dwAppType
        );

    HRESULT
    SetDavRequest( LPCWSTR szDavIsapiImage )
    {
        HRESULT hr = _strDavIsapiImage.Copy( szDavIsapiImage );

        if ( SUCCEEDED( hr ) )
        {
            _fIsDavRequest = TRUE;
        }

        return hr;
    }

    BOOL
    QueryIsOop(
        VOID
    ) const
    {
        return _pCoreData->fIsOop;
    }

    HRESULT
    DuplicateWamProcessHandleForLocalUse(
        HANDLE      hWamProcessHandle,
        HANDLE *    phLocalHandle
        );

    HRESULT
    MarshalAsyncReadBuffer(
        DWORD64     pWamExecInfo,
        LPBYTE      pBuffer,
        DWORD       cbBuffer
        );

    VOID
    IsapiRequestFinished(
        VOID
        );
         
    static
    HRESULT
    Initialize(
        VOID
    );

    static
    VOID
    Terminate(
        VOID
    );

    static
    HRESULT
    W3SVC_WamRegSink(
        LPCSTR      szAppPath,
        const DWORD dwCommand,
        DWORD *     pdwResult
        );

    static
    BOOL QueryIsInitialized( VOID )
    {
        return sg_Initialized;
    }

    static
    BOOL
    IsInprocIsapi(
        WCHAR * szImage
    )
    {
        W3_INPROC_ISAPI *   pRecord = NULL;
        BOOL                fRet;

        DBG_ASSERT( sg_Initialized );

        if ( szImage == NULL )
        {
            return FALSE;
        }

        EnterCriticalSection( &sm_csInprocHashLock );

        if ( sm_pInprocIsapiHash == NULL )
        {
            fRet = FALSE;
        }
        else
        {
            fRet = LK_SUCCESS == sm_pInprocIsapiHash->FindKey( szImage, &pRecord );
        }

        LeaveCriticalSection( &sm_csInprocHashLock );

        if ( fRet )
        {
            pRecord->DereferenceInprocIsapi();
        }

        return fRet;
    }

    static
    HRESULT
    UpdateInprocIsapiHash(
        VOID
    );

    BOOL
    QueryIsUlCacheable(
        VOID
    )
    {
        return TRUE;
    }

    HRESULT
    SetupUlCachedResponse(
        W3_CONTEXT *    pW3Context,
        HTTP_CACHE_POLICY *pCachePolicy
    );

private:

    ISAPI_REQUEST *     _pIsapiRequest;
    BOOL                _fIsDavRequest;
    STRU                _strDavIsapiImage;
    ISAPI_CORE_DATA *   _pCoreData;
    WAM_PROCESS *       _pWamProcess;
    DWORD               _State;

    //
    // Data for optimized w3wp mode operation
    //

    ISAPI_CORE_DATA     _InlineCoreData;
    INLINE_STRA(        _PhysicalPath,64);
    INLINE_STRA(        _PathInfo,64);
    STRA                _Method;
    INLINE_STRA(        _QueryString,64);
    INLINE_STRA(        _PathTranslated,64);
    INLINE_STRA(        _ApplMdPath,32);
    INLINE_STRU(        _ApplMdPathW,32);
    INLINE_STRU(        _PathTranslatedW,64);

    //
    // Have we finished preloading entity body?
    //
    
    BOOL                _fEntityBodyPreloadComplete;

    //
    // Buffer containing core data
    //

    BUFFER              _buffCoreData;
    BYTE                _abCoreData[ DEFAULT_CORE_DATA_SIZE ];

    static HMODULE                      sm_hIsapiModule;
    static PFN_ISAPI_TERM_MODULE        sm_pfnTermIsapiModule;
    static PFN_ISAPI_PROCESS_REQUEST    sm_pfnProcessIsapiRequest;
    static PFN_ISAPI_PROCESS_COMPLETION sm_pfnProcessIsapiCompletion;
    static IWam *                       sm_pIWamPool;
    static W3_INPROC_ISAPI_HASH *       sm_pInprocIsapiHash;
    static CRITICAL_SECTION             sm_csInprocHashLock;
    static WAM_PROCESS_MANAGER *        sm_pWamProcessManager;
    static BOOL                         sm_fWamActive;
    static CHAR                         sm_szInstanceId[SIZE_CLSID_STRING];
    static CRITICAL_SECTION             sm_csBigHurkinWamRegLock;

    //
    // Private functions
    //

    VOID
    RestartCoreStateMachine(
        VOID
        );

    static
    VOID
    LockWamReg()
    {
        EnterCriticalSection( &sm_csBigHurkinWamRegLock );
    }

    static
    VOID
    UnlockWamReg()
    {
        LeaveCriticalSection( &sm_csBigHurkinWamRegLock );
    }
};

#endif // _ISAPI_HANDLER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\isapi_handler.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     isapi_handler.cxx

   Abstract:
     Handle ISAPI extension requests
 
   Author:
     Taylor Weiss (TaylorW)             27-Jan-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL

--*/

#include <initguid.h>
#include "precomp.hxx"
#include "isapi_handler.h"
#include <wmrgexp.h>
#include <iisextp.h>
#include <errno.h>

HMODULE                      W3_ISAPI_HANDLER::sm_hIsapiModule;
PFN_ISAPI_TERM_MODULE        W3_ISAPI_HANDLER::sm_pfnTermIsapiModule;
PFN_ISAPI_PROCESS_REQUEST    W3_ISAPI_HANDLER::sm_pfnProcessIsapiRequest;
PFN_ISAPI_PROCESS_COMPLETION W3_ISAPI_HANDLER::sm_pfnProcessIsapiCompletion;
W3_INPROC_ISAPI_HASH *       W3_ISAPI_HANDLER::sm_pInprocIsapiHash;
CRITICAL_SECTION             W3_ISAPI_HANDLER::sm_csInprocHashLock;
CRITICAL_SECTION             W3_ISAPI_HANDLER::sm_csBigHurkinWamRegLock;
WAM_PROCESS_MANAGER *        W3_ISAPI_HANDLER::sm_pWamProcessManager;
BOOL                         W3_ISAPI_HANDLER::sm_fWamActive;
CHAR                         W3_ISAPI_HANDLER::sm_szInstanceId[SIZE_CLSID_STRING];

BOOL sg_Initialized = FALSE;

/***********************************************************************
    Local Declarations
***********************************************************************/

VOID
AddFiltersToMultiSz(
    IN const MB &       mb,
    IN LPCWSTR          szFilterPath,
    IN OUT MULTISZ *    pmsz
    );

VOID
AddAllFiltersToMultiSz(
    IN const MB &       mb,
    IN OUT MULTISZ *    pmsz
    );

/***********************************************************************
    Module Definitions
***********************************************************************/

CONTEXT_STATUS
W3_ISAPI_HANDLER::DoWork(
    VOID
    )
/*++

Routine Description:

    Main ISAPI handler routine

Return Value:

    CONTEXT_STATUS_PENDING if async pending, 
    else CONTEXT_STATUS_CONTINUE

--*/
{
    W3_CONTEXT *pW3Context = QueryW3Context();
    DBG_ASSERT( pW3Context != NULL );

    HRESULT                     hr;
    BOOL                        fComplete = FALSE;
    W3_REQUEST *pRequest = pW3Context->QueryRequest();
    W3_METADATA *pMetaData = pW3Context->QueryUrlContext()->QueryMetaData();

    //
    // Preload entity if needed
    // 
    
    hr = pRequest->PreloadEntityBody( pW3Context,
                                      &fComplete );
    //
    // If we cannot read the request entity, we will assume it is the
    // client's fault
    //
    if ( FAILED( hr ) )
    {
        if ( hr == HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY ) )
        {
            pW3Context->SetErrorStatus( hr );
            
            pW3Context->QueryResponse()->SetStatus( HttpStatusServerError );
        }
        else if ( hr == HRESULT_FROM_WIN32( ERROR_CONNECTION_INVALID ) )
        {
            pW3Context->QueryResponse()->SetStatus( HttpStatusEntityTooLarge );
        }
        else
        {
            pW3Context->SetErrorStatus( hr );

            pW3Context->QueryResponse()->SetStatus( HttpStatusBadRequest );
        }

        return CONTEXT_STATUS_CONTINUE;
    }

    if ( !fComplete )
    {
        //
        // Async read pending.  Just bail
        //
    
        return CONTEXT_STATUS_PENDING;
    }
    
    //
    // If we've already exceeded the maximum allowed entity, we
    // need to fail.
    //

    if ( pW3Context->QueryMainContext()->QueryEntityReadSoFar() >
         pMetaData->QueryMaxRequestEntityAllowed() )
    {
        pW3Context->QueryResponse()->SetStatus( HttpStatusEntityTooLarge );

        return CONTEXT_STATUS_CONTINUE;
    }
    
    _fEntityBodyPreloadComplete = TRUE;
    _State = ISAPI_STATE_INITIALIZING;

    return IsapiDoWork( pW3Context );
}

CONTEXT_STATUS
W3_ISAPI_HANDLER::IsapiDoWork(
    W3_CONTEXT *            pW3Context
    )
/*++

Routine Description:

    Called to execute an ISAPI.  This routine must be called only after
    we have preloaded entity for the request

Arguments:

    pW3Context - Context for this request

Return Value:

    CONTEXT_STATUS_PENDING if async pending, 
    else CONTEXT_STATUS_CONTINUE

--*/
{
    DWORD           dwHseResult;
    HRESULT         hr = NOERROR;
    HANDLE          hOopToken;
    URL_CONTEXT *   pUrlContext;
    BOOL            fIsVrToken;
    DWORD           dwWamSubError = 0;
    HTTP_SUB_ERROR  httpSubError;

    //
    // We must have preloaded entity by the time this is called
    //
    
    DBG_ASSERT( _State == ISAPI_STATE_INITIALIZING );
    DBG_ASSERT( _fEntityBodyPreloadComplete );
    DBG_ASSERT( sm_pfnProcessIsapiRequest );
    DBG_ASSERT( sm_pfnProcessIsapiCompletion );

    DBG_REQUIRE( ( pUrlContext = pW3Context->QueryUrlContext() ) != NULL );

    IF_DEBUG( ISAPI )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "IsapiDoWork called for new request.\r\n"
            ));
    }

    //
    // Initialize the ISAPI_CORE_DATA and ISAPI_CORE_INTERFACE
    // for this request
    //

    if ( FAILED( hr = InitCoreData( &fIsVrToken ) ) )
    {
        goto ErrorExit;
    }

    DBG_ASSERT( _pCoreData );

    //
    // If the gateway image is not enabled, then we should fail the
    // request with a 404.
    //

    if ( g_pW3Server->QueryIsIsapiImageEnabled( _pCoreData->szGatewayImage ) == FALSE )
    {
        _State = ISAPI_STATE_FAILED;
        
        DBGPRINTF(( DBG_CONTEXT,
                    "ISAPI image disabled: %S.\r\n",
                    _pCoreData->szGatewayImage ));

        pW3Context->SetErrorStatus( ERROR_ACCESS_DISABLED_BY_POLICY );

        pW3Context->QueryResponse()->SetStatus( HttpStatusNotFound,
                                                Http404DeniedByPolicy );

        hr = pW3Context->SendResponse( W3_FLAG_ASYNC );

        if ( SUCCEEDED( hr ) )
        {
            return CONTEXT_STATUS_PENDING;
        }
        else
        {
            return CONTEXT_STATUS_CONTINUE;
        }
    }

    _pIsapiRequest = new (pW3Context) ISAPI_REQUEST( pW3Context, _pCoreData->fIsOop );

    if ( _pIsapiRequest == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto ErrorExit;
    }

    if ( FAILED( hr = _pIsapiRequest->Create() ) )
    {
        goto ErrorExit;
    }

    //
    // If the request should run OOP, get the WAM process and
    // duplicate the impersonation token
    //

    if ( _pCoreData->fIsOop )
    {
        DBG_ASSERT( sm_pWamProcessManager );
        DBG_ASSERT( _pCoreData->szWamClsid[0] != L'\0' );

        hr = sm_pWamProcessManager->GetWamProcess(
            (LPCWSTR)&_pCoreData->szWamClsid,
            _pCoreData->szApplMdPathW,
            &dwWamSubError,
            &_pWamProcess,
            sm_szInstanceId
            );

        if ( FAILED( hr ) )
        {
            goto ErrorExit;
        }

        //
        // We have to modify the token that we're passing to 
        // the OOP process.
        //

        if( ( fIsVrToken  && !pW3Context->QueryVrToken()->QueryOOPToken() )          ||
            ( !fIsVrToken && !pW3Context->QueryUserContext()->QueryIsCachedToken() ) ||
            ( !fIsVrToken && !pW3Context->QueryUserContext()->QueryCachedToken()->QueryOOPToken() ) )
        {
            hr = GrantWpgAccessToToken( _pCoreData->hToken );

            if ( FAILED( hr ) )
            {
                goto ErrorExit;
            }

            hr = AddWpgToTokenDefaultDacl( _pCoreData->hToken );

            if ( FAILED( hr ) )
            {
                goto ErrorExit;
            }
        }

        if ( DuplicateHandle( GetCurrentProcess(), _pCoreData->hToken,
                               _pWamProcess->QueryProcess(), &hOopToken,
                               0, FALSE, DUPLICATE_SAME_ACCESS ) )
        {
            _pCoreData->hToken = hOopToken;
        }
        else
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );

            //
            // CODEWORK - If the target process has exited, then
            // DuplicateHandle fails with ERROR_ACCESS_DENIED.  This
            // will confuse our error handling logic because it'll
            // thing that we really got this error attempting to
            // process the request.
            //
            // For the time being, we'll detect this error and let
            // it call into ProcessRequest.  If the process really
            // has exited, this will cause the WAM_PROCESS cleanup
            // code to recover everything.
            //
            // In the future, we should consider waiting on the
            // process handle to detect steady-state crashes of
            // OOP hosts so that we don't have to discover the
            // problem only when something trys to talk to the
            // process.
            //
            // Another thing to consider is that we could trigger
            // the crash recovery directly and call GetWamProcess
            // again to get a new process.  This would make the
            // crash completely transparent to the client, which
            // would be an improvement over the current solution
            // (and IIS 4 and 5) which usually waits until a client
            // request fails before recovering.
            //

            _pCoreData->hToken = NULL;

            if ( hr != HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED ) )
            {
                goto ErrorExit;
            }
        }
    }

    //
    // Handle the request
    //

    _State = ISAPI_STATE_PENDING;

    //
    // Temporarily up the thread threshold since we don't know when the
    // ISAPI will return
    //

    ThreadPoolSetInfo( ThreadPoolIncMaxPoolThreads, 0 );

    if ( !_pCoreData->fIsOop )
    {
        IF_DEBUG( ISAPI )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Processing ISAPI_REQUEST %p OOP.\r\n",
                _pIsapiRequest
                ));
        }

        hr = sm_pfnProcessIsapiRequest(
            _pIsapiRequest,
            _pCoreData,
            &dwHseResult
            );
    }
    else
    {
        hr = _pWamProcess->ProcessRequest(
            _pIsapiRequest,
            _pCoreData,
            &dwHseResult
            );
    }

    //
    // Back down the count since the ISAPI has returned
    //

    ThreadPoolSetInfo( ThreadPoolDecMaxPoolThreads, 0 );

    if ( FAILED( hr ) )
    {
        _State = ISAPI_STATE_FAILED;
        goto ErrorExit;
    }

    //
    // Determine whether the extension was synchronous or pending.
    // We need to do this before releasing our reference on the
    // ISAPI_REQUEST since the final release will check the state
    // to determine if an additional completion is necessary.
    //
    // In either case, we should just return with the appropriate
    // return code after setting the state.
    //

    if ( dwHseResult != HSE_STATUS_PENDING &&
         _pCoreData->fIsOop == FALSE )
    {
        _State = ISAPI_STATE_DONE;

        //
        // This had better be the final release...
        //

        LONG Refs = _pIsapiRequest->Release();

        //
        // Make /W3 happy on a free build...
        //

        if ( Refs != 0 )
        {
            DBG_ASSERT( Refs == 0 );
        }

        return CONTEXT_STATUS_CONTINUE;
    }

    //
    // This may or may not be the final release...
    //
    _pIsapiRequest->Release();

    return CONTEXT_STATUS_PENDING;

ErrorExit:

    DBG_ASSERT( FAILED( hr ) );

    //
    // Spew on failure.
    //

    if ( FAILED( hr ) )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Attempt to process ISAPI request failed.  Error 0x%08x.\r\n",
            hr
            ));
    }

    //
    // Set the error status now.
    //

    pW3Context->SetErrorStatus( hr );

    //
    // If we've failed, and the state is ISAPI_STATE_INITIALIZING, then
    // we never made the call out to the extension.  It's therefore
    // safe to handle the error and advance the state machine.
    //
    // It's also safe to advance the state machine in the special case
    // error where the attempt to call the extension results in
    // ERROR_ACCESS_DENIED.
    //

    if ( _State == ISAPI_STATE_INITIALIZING ||
         hr == HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED) )
    {
        //
        // Setting the state to ISAPI_STATE_DONE will cause the
        // next completion to advance the state machine.
        //
        
        _State = ISAPI_STATE_DONE;

        //
        // The _pWamProcess and _pCoreData members are cleaned up
        // by the destructor.  We don't need to worry about them.
        // We also don't need to worry about any tokens that we
        // are using.  The tokens local to this process are owned
        // by W3_USER_CONTEXT; any duplicates for OOP are the
        // responsibility of the dllhost process (if it still
        // exists).
        //
        // We do need to clean up the _pIsapiRequest if we've
        // created it.  This had better well be the final release.
        //

        if ( _pIsapiRequest )
        {
            _pIsapiRequest->Release();
        }

        //
        // Set the HTTP status and send it asynchronously.
        // This will ultimately trigger the completion that
        // advances the state machine.
        //

        if ( hr == HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED ) )
        {
            pW3Context->QueryResponse()->SetStatus( HttpStatusUnauthorized,
                                                    Http401Resource );
        }
        else
        {
            pW3Context->QueryResponse()->SetStatus( HttpStatusServerError );

            if ( dwWamSubError != 0 )
            {
                httpSubError.dwStringId = dwWamSubError;
                pW3Context->QueryResponse()->SetSubError( &httpSubError );
            }
        }

        hr = pW3Context->SendResponse( W3_FLAG_ASYNC );

        if ( SUCCEEDED( hr ) )
        {
            return CONTEXT_STATUS_PENDING;
        }

        //
        // Ouch - couldn't send the error page...
        //

        _State = ISAPI_STATE_FAILED;

        return CONTEXT_STATUS_CONTINUE;
    }

    //
    // If we get here, then an error has occured during or after
    // our call into the extension.  Because it's possible for an
    // OOP call to fail after entering the extension, we can't
    // generally know our state.
    //
    // Because of this, we'll assume that the extension has
    // outstanding references to the ISAPI_REQUEST on its behalf.
    // We'll set the state to ISAPI_STATE_PENDING and let the
    // destructor on the ISAPI_REQUEST trigger the final
    // completion.
    //
    // Also, we'll set the error status, just in case the extension
    // didn't get a response off before it failed.
    //

    pW3Context->QueryResponse()->SetStatus( HttpStatusServerError );

    _State = ISAPI_STATE_FAILED;

    //
    // This may or may not be the final release on the ISAPI_REQUEST.
    //
    // It had better be non-NULL if we got past ISAPI_STATE_INITIALIZING.
    //

    DBG_ASSERT( _pIsapiRequest );

    _pIsapiRequest->Release();

    return CONTEXT_STATUS_PENDING;
}

CONTEXT_STATUS
W3_ISAPI_HANDLER::OnCompletion(
    DWORD                   cbCompletion,
    DWORD                   dwCompletionStatus
    )
/*++

Routine Description:

    ISAPI async completion handler.  

Arguments:

    cbCompletion - Number of bytes in an async completion
    dwCompletionStatus - Error status of a completion

Return Value:

    CONTEXT_STATUS_PENDING if async pending, 
    else CONTEXT_STATUS_CONTINUE

--*/
{
    HRESULT                 hr;
    W3_CONTEXT *            pW3Context;
    
    pW3Context = QueryW3Context();
    DBG_ASSERT( pW3Context != NULL );

    //
    // Is this completion for the entity body preload?  If so note the 
    // number of bytes and start handling the ISAPI request
    //
    
    if ( !_fEntityBodyPreloadComplete )
    {
        BOOL fComplete = FALSE;

        //
        // This completion is for entity body preload
        //
        
        W3_REQUEST *pRequest = pW3Context->QueryRequest();
        hr = pRequest->PreloadCompletion(pW3Context,
                                         cbCompletion,
                                         dwCompletionStatus,
                                         &fComplete);

        //
        // If we cannot read the request entity, we will assume it is the
        // client's fault
        //
        if ( FAILED( hr ) )
        {

            if ( hr == HRESULT_FROM_WIN32( ERROR_CONNECTION_INVALID ) )
            {
                pW3Context->QueryResponse()->SetStatus( HttpStatusEntityTooLarge );
            }
            else
            {
                pW3Context->SetErrorStatus( hr );

                pW3Context->QueryResponse()->SetStatus( HttpStatusBadRequest );
            }

            return CONTEXT_STATUS_CONTINUE;
        }

        if (!fComplete)
        {
            return CONTEXT_STATUS_PENDING;
        }

        _fEntityBodyPreloadComplete = TRUE;
        _State = ISAPI_STATE_INITIALIZING;
        
        //
        // Finally we can call the ISAPI
        //
        
        return IsapiDoWork( pW3Context );
    }
    
    DBG_ASSERT( _fEntityBodyPreloadComplete );
    
    return IsapiOnCompletion( cbCompletion, dwCompletionStatus );
}

CONTEXT_STATUS
W3_ISAPI_HANDLER::IsapiOnCompletion(
    DWORD                   cbCompletion,
    DWORD                   dwCompletionStatus
    )
/*++

Routine Description:

    Funnels a completion to an ISAPI

Arguments:

    cbCompletion - Bytes of completion
    dwCompletionStatus - Win32 Error status of completion

Return Value:

    CONTEXT_STATUS_PENDING if async pending, 
    else CONTEXT_STATUS_CONTINUE

--*/
{
    DWORD64         IsapiContext;
    HRESULT         hr = NO_ERROR;
    
    //
    // If the state is ISAPI_STATE_DONE, then we should
    // advance the state machine now.
    //

    if ( _State == ISAPI_STATE_DONE ||
         _State == ISAPI_STATE_FAILED )
    {
        return CONTEXT_STATUS_CONTINUE;
    }

    //
    // If we get here, then this completion should be passed
    // along to the extension.
    //
 
    DBG_ASSERT( _pCoreData );
    DBG_ASSERT( _pIsapiRequest );

    IsapiContext =  _pIsapiRequest->QueryIsapiContext();

    DBG_ASSERT( IsapiContext != 0 );

    //
    // Process the completion.
    //

    _pIsapiRequest->AddRef();

    //
    // Temporarily up the thread threshold since we don't know when the
    // ISAPI will return
    //

    ThreadPoolSetInfo( ThreadPoolIncMaxPoolThreads, 0 );

    if ( !_pCoreData->fIsOop )
    {
        //
        // Need to reset the ISAPI context in case the extension
        // does another async operation before the below call returns
        //

        _pIsapiRequest->ResetIsapiContext();

        hr = sm_pfnProcessIsapiCompletion(
            IsapiContext,
            cbCompletion,
            dwCompletionStatus
            );
    }
    else
    {
        DBG_ASSERT( _pWamProcess );

        //
        // _pWamProcess->ProcessCompletion depends on the ISAPI
        // context, so it will make the Reset call.
        //

        hr = _pWamProcess->ProcessCompletion(
            _pIsapiRequest,
            IsapiContext,
            cbCompletion,
            dwCompletionStatus
            );
    }

    //
    // Back down the count since the ISAPI has returned
    //

    ThreadPoolSetInfo( ThreadPoolDecMaxPoolThreads, 0 );

    _pIsapiRequest->Release();

    return CONTEXT_STATUS_PENDING;
}

HRESULT
W3_ISAPI_HANDLER::InitCoreData(
    BOOL *  pfIsVrToken
    )
/*++

Routine Description:

    Initializes the ISAPI_CORE_DATA for a request

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HRESULT         hr = NO_ERROR;
    W3_CONTEXT *    pW3Context;
    URL_CONTEXT *   pUrlContext;
    W3_URL_INFO *   pUrlInfo;
    W3_METADATA *   pMetadata;
    W3_REQUEST *    pRequest = NULL;
    LPCSTR          szContentLength = NULL;
    STRU            stru;
    STRU *          pstru = NULL;
    BOOL            fRequestIsScript = FALSE;
    BOOL            fUsePathInfo;
    DWORD           dwAppType = APP_INPROC;

    DBG_REQUIRE( ( pW3Context = QueryW3Context() ) != NULL );
    DBG_REQUIRE( ( pRequest = pW3Context->QueryRequest() ) != NULL );
    DBG_REQUIRE( ( pUrlContext = pW3Context->QueryUrlContext() ) != NULL );
    DBG_REQUIRE( ( pUrlInfo = pUrlContext->QueryUrlInfo() ) != NULL );
    DBG_REQUIRE( ( pMetadata = pUrlContext->QueryMetaData() ) != NULL );

    //
    // Check for script
    //

    if ( QueryScriptMapEntry() )
    {
        fRequestIsScript = TRUE;
    }

    //
    // Populate data directly into the inline core data.
    // Assume everything is inproc.  In the case of an
    // OOP request, the SerializeCoreDataForOop function
    // will take care of any needed changes.
    //

    _pCoreData = &_InlineCoreData;

    //
    // Structure size information
    //

    _pCoreData->cbSize = sizeof(ISAPI_CORE_DATA);

    //
    // WAM information - Always set to inproc for w3wp.exe
    //

    _pCoreData->szWamClsid[0] = L'\0';
    _pCoreData->fIsOop = FALSE;

    //
    // Secure request?
    //

    _pCoreData->fSecure = pRequest->IsSecureRequest();

    //
    // Client HTTP version
    //

     _pCoreData->dwVersionMajor = pRequest->QueryVersion().MajorVersion;
     _pCoreData->dwVersionMinor = pRequest->QueryVersion().MinorVersion;

    //
    // Site instance ID
    //

    _pCoreData->dwInstanceId = pRequest->QuerySiteId();

    //
    // Request content-length
    //

    if ( pRequest->IsChunkedRequest() )
    {
        _pCoreData->dwContentLength = (DWORD) -1;
    }
    else
    {
        szContentLength = pRequest->GetHeader( HttpHeaderContentLength );

        if ( szContentLength != NULL )
        {
            errno = 0;

            _pCoreData->dwContentLength = strtoul( szContentLength, NULL, 10 );

            //
            // Check for overflow
            //

            if ( ( _pCoreData->dwContentLength == ULONG_MAX ||
                   _pCoreData->dwContentLength == 0 ) &&
                 errno == ERANGE )
            {
                hr = HRESULT_FROM_WIN32( ERROR_ARITHMETIC_OVERFLOW );
                goto ErrorExit;
            }
        }
        else
        {
            _pCoreData->dwContentLength = 0;
        }
    }

    //
    // Client authentication information
    //

    _pCoreData->hToken = pW3Context->QueryImpersonationToken( pfIsVrToken );
    _pCoreData->pSid = pW3Context->QueryUserContext()->QuerySid();

    //
    // Request ID
    //

    _pCoreData->RequestId = pRequest->QueryRequestId();

    //
    // Gateway image
    //
    // There are 3 cases to consider:
    //
    // 1) If this is a DAV request, then use DAV image
    // 2) If this is script mapped, use script executable
    // 3) Else use URL physical path
    //

    if ( _fIsDavRequest )
    {
        pstru = &_strDavIsapiImage;
    }
    else if ( fRequestIsScript )
    {
        pstru = QueryScriptMapEntry()->QueryExecutable();
    }
    else
    {
        pstru = pUrlContext->QueryPhysicalPath();
    }

    DBG_ASSERT( pstru );

    _pCoreData->szGatewayImage = pstru->QueryStr();
    _pCoreData->cbGatewayImage = pstru->QueryCB() + sizeof(WCHAR);

    pstru = NULL;

    //
    // Get the app type.
    //

    if ( sm_fWamActive )
    {
        dwAppType = pMetadata->QueryAppIsolated();

        if ( dwAppType == APP_ISOLATED ||
             dwAppType == APP_POOL )
        {
            if ( IsInprocIsapi( _pCoreData->szGatewayImage ) )
            {
                dwAppType = APP_INPROC;
            }
        }
    }

    //
    // Physical Path - Not Needed?  Just set it to an empty string for now.
    //

    hr = _PhysicalPath.Copy( "" );

    if ( FAILED( hr ) )
    {
        goto ErrorExit;
    }

    _pCoreData->szPhysicalPath = _PhysicalPath.QueryStr();
    _pCoreData->cbPhysicalPath = _PhysicalPath.QueryCB() + sizeof(CHAR);

    //
    // Path info
    //
    // 1) If this is a DAV request, PATH_INFO is the URL
    // 2) If this is a script, and AllowPathInfoForScriptMappings is
    //    FALSE, then PATH_INFO is the URL.
    // 3) Else, we use the "real" PATH_INFO
    //
    // We will set a flag indicating whether we are using the URL or
    // the "real" data, so that we can be efficient about deriving
    // PATH_TRANSLATED.
    //

    fUsePathInfo = TRUE;

    if ( _fIsDavRequest )
    {
        hr = pRequest->GetUrl( &stru );

        fUsePathInfo = FALSE;
    }
    else if ( fRequestIsScript )
    {
        if ( pW3Context->QuerySite()->QueryAllowPathInfoForScriptMappings() )
        {
            hr = stru.Copy( *pUrlInfo->QueryPathInfo() );
        }
        else
        {
            hr = pRequest->GetUrl( &stru );
            
            fUsePathInfo = FALSE;
        }
    }
    else
    {
        hr = stru.Copy( *pUrlInfo->QueryPathInfo() );
    }

    if ( FAILED( hr ) )
    {
        goto ErrorExit;
    }

    hr = _PathInfo.CopyW( stru.QueryStr(),
                          stru.QueryCCH() );

    if ( FAILED( hr ) )
    {
        goto ErrorExit;
    }

    _pCoreData->szPathInfo = _PathInfo.QueryStr();
    _pCoreData->cbPathInfo = _PathInfo.QueryCB() + sizeof(CHAR);

    //
    // Method
    //

    hr = pRequest->GetVerbString( &_Method );

    if (FAILED( hr ) )
    {
        goto ErrorExit;
    }

    _pCoreData->szMethod = _Method.QueryStr();
    _pCoreData->cbMethod = _Method.QueryCB() + sizeof(CHAR);

    //
    // Query string
    //

    hr = pRequest->GetQueryStringA( &_QueryString );

    if (FAILED( hr ) )
    {
        goto ErrorExit;
    }

    _pCoreData->szQueryString = _QueryString.QueryStr();
    _pCoreData->cbQueryString = _QueryString.QueryCB() + sizeof(CHAR);


    //
    // Path translated (and we'll do the UNICODE version while we're at it)
    //

    hr = pUrlInfo->GetPathTranslated( pW3Context,
                                      fUsePathInfo,
                                      &_PathTranslatedW );
    if ( FAILED( hr ) )
    {
        goto ErrorExit;
    }

    hr = _PathTranslated.CopyW( _PathTranslatedW.QueryStr(),
                                _PathTranslatedW.QueryCCH() );

    if ( FAILED( hr ) )
    {
        goto ErrorExit;
    }

    _pCoreData->szPathTranslated = _PathTranslated.QueryStr();
    _pCoreData->cbPathTranslated = _PathTranslated.QueryCB() + sizeof(CHAR);

    _pCoreData->szPathTranslatedW = _PathTranslatedW.QueryStr();
    _pCoreData->cbPathTranslatedW = _PathTranslatedW.QueryCB() + sizeof(WCHAR);

    //
    // Content type
    //

    _pCoreData->szContentType = (LPSTR)pRequest->GetHeader( HttpHeaderContentType );

    if ( !_pCoreData->szContentType )
    {
        _pCoreData->szContentType = CONTENT_TYPE_PLACEHOLDER;
    }

    _pCoreData->cbContentType = (DWORD)strlen( _pCoreData->szContentType ) + sizeof(CHAR);

    //
    // Connection
    //

    _pCoreData->szConnection = (LPSTR)pRequest->GetHeader( HttpHeaderConnection );

    if ( !_pCoreData->szConnection )
    {
        _pCoreData->szConnection = CONNECTION_PLACEHOLDER;
    }
    
    _pCoreData->cbConnection = (DWORD)strlen( _pCoreData->szConnection ) + sizeof(CHAR);

    //
    // UserAgent
    //

    _pCoreData->szUserAgent = (LPSTR)pRequest->GetHeader( HttpHeaderUserAgent );

    if ( !_pCoreData->szUserAgent )
    {
        _pCoreData->szUserAgent = USER_AGENT_PLACEHOLDER;
    }

    _pCoreData->cbUserAgent = (DWORD)strlen( _pCoreData->szUserAgent ) + sizeof(CHAR);

    //
    // Cookie
    //

    _pCoreData->szCookie = (LPSTR)pRequest->GetHeader( HttpHeaderCookie );

    if ( !_pCoreData->szCookie )
    {
        _pCoreData->szCookie = COOKIE_PLACEHOLDER;
    }

    _pCoreData->cbCookie = (DWORD)strlen( _pCoreData->szCookie ) + sizeof(CHAR);

    //
    // Appl MD path
    //

    hr = GetServerVariableApplMdPath( pW3Context, &_ApplMdPath );

    if( FAILED(hr) )
    {
        goto ErrorExit;
    }

    _pCoreData->szApplMdPath = _ApplMdPath.QueryStr();
    _pCoreData->cbApplMdPath = _ApplMdPath.QueryCB() + sizeof(CHAR);

    //
    // szApplMdPathW is only populated in
    // the OOF case.
    //

    _pCoreData->szApplMdPathW = NULL;
    _pCoreData->cbApplMdPathW = 0;

    //
    // Entity data
    //

    pW3Context->QueryAlreadyAvailableEntity( &_pCoreData->pAvailableEntity,
                                             &_pCoreData->cbAvailableEntity );

    //
    // Keep alive
    //

    _pCoreData->fAllowKeepAlive = pMetadata->QueryKeepAliveEnabled();

    //
    // If this is an OOP request, then we need to serialize the core data
    //

    if ( dwAppType == APP_ISOLATED ||
         dwAppType == APP_POOL )
    {
        hr = SerializeCoreDataForOop( dwAppType );

        if ( FAILED( hr ) )
        {
            goto ErrorExit;
        }
    }

    DBG_ASSERT( SUCCEEDED( hr ) );

    return hr;


ErrorExit:

    DBG_ASSERT( FAILED( hr ) );

    _pCoreData = NULL;

    return hr;
}

HRESULT
W3_ISAPI_HANDLER::SerializeCoreDataForOop(
    DWORD   dwAppType
    )
{
    W3_CONTEXT *        pW3Context;
    URL_CONTEXT *       pUrlContext;
    W3_URL_INFO *       pUrlInfo;
    W3_METADATA *       pMetadata;
    STRU *              pstru;
    DWORD               cbNeeded;
    BYTE *              pCursor;
    ISAPI_CORE_DATA *   pSerialized;
    HRESULT             hr = NO_ERROR;

    //
    // Caution.  This code must be kept in sync
    // with the FixupCoreData function in w3isapi.dll
    //

    DBG_ASSERT( sm_fWamActive );
    DBG_ASSERT( dwAppType == APP_ISOLATED ||
                dwAppType == APP_POOL );

    DBG_REQUIRE( ( pW3Context = QueryW3Context() ) != NULL );
    DBG_REQUIRE( ( pUrlContext = pW3Context->QueryUrlContext() ) != NULL );
    DBG_REQUIRE( ( pUrlInfo = pUrlContext->QueryUrlInfo() ) != NULL );
    DBG_REQUIRE( ( pMetadata = pUrlContext->QueryMetaData() ) != NULL );

    //
    // Set the WAM information and NULL out the pSid dude
    //

    if ( dwAppType == APP_ISOLATED )
    {
        pstru = pMetadata->QueryWamClsId();

        DBG_ASSERT( pstru );

        if ( pstru == NULL )
        {
            hr = HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND );
            goto ErrorExit;
        }

        wcsncpy( _pCoreData->szWamClsid,
                 pstru->QueryStr(),
                 SIZE_CLSID_STRING );

        _pCoreData->szWamClsid[SIZE_CLSID_STRING-1] = L'\0';
    }
    else
    {
        wcsncpy( _pCoreData->szWamClsid,
                 POOL_WAM_CLSID,
                 SIZE_CLSID_STRING );

        _pCoreData->szWamClsid[SIZE_CLSID_STRING-1] = L'\0';
    }

    _pCoreData->fIsOop = TRUE;

    _pCoreData->pSid = NULL;

    //
    // ApplMdPathW
    //

    hr = GetServerVariableApplMdPathW( pW3Context, &_ApplMdPathW );

    if ( FAILED( hr ) )
    {
        goto ErrorExit;
    }

    _pCoreData->szApplMdPathW = _ApplMdPathW.QueryStr();
    _pCoreData->cbApplMdPathW = _ApplMdPathW.QueryCB() + sizeof(WCHAR);

    //
    // Calculate the size needed for the core data and
    // set up the buffer to contain it.
    //

    cbNeeded = sizeof(ISAPI_CORE_DATA);

    cbNeeded += _pCoreData->cbGatewayImage;
    cbNeeded += _pCoreData->cbPhysicalPath;
    cbNeeded += _pCoreData->cbPathInfo;
    cbNeeded += _pCoreData->cbMethod;
    cbNeeded += _pCoreData->cbQueryString;
    cbNeeded += _pCoreData->cbPathTranslated;
    cbNeeded += _pCoreData->cbContentType;
    cbNeeded += _pCoreData->cbConnection;
    cbNeeded += _pCoreData->cbUserAgent;
    cbNeeded += _pCoreData->cbCookie;
    cbNeeded += _pCoreData->cbApplMdPath;
    cbNeeded += _pCoreData->cbApplMdPathW;
    cbNeeded += _pCoreData->cbPathTranslatedW;
    cbNeeded += _pCoreData->cbAvailableEntity;

    hr = _buffCoreData.Resize( cbNeeded );

    if ( FAILED( hr ) )
    {
        goto ErrorExit;
    }

    //
    // Copy the core data into the buffer
    //

    pSerialized = (ISAPI_CORE_DATA*)_buffCoreData.QueryPtr();
    pCursor = (BYTE*)pSerialized;

    CopyMemory( pCursor,
                _pCoreData,
                sizeof(ISAPI_CORE_DATA) );

    pSerialized->cbSize = cbNeeded;

    pCursor += sizeof(ISAPI_CORE_DATA);

    //
    // Add gateway image
    //

    pSerialized->szGatewayImage = (LPWSTR)pCursor;

    CopyMemory( pSerialized->szGatewayImage,
                _pCoreData->szGatewayImage,
                _pCoreData->cbGatewayImage );

    pCursor += _pCoreData->cbGatewayImage;

    //
    // Add ApplMdPathW
    //

    pSerialized->szApplMdPathW = (LPWSTR)pCursor;

    CopyMemory( pSerialized->szApplMdPathW,
                _pCoreData->szApplMdPathW,
                _pCoreData->cbApplMdPathW );

    pCursor += _pCoreData->cbApplMdPathW;

    //
    // Add PathTranslatedW
    //

    pSerialized->szPathTranslatedW = (LPWSTR)pCursor;

    CopyMemory( pSerialized->szPathTranslatedW,
                _pCoreData->szPathTranslatedW,
                _pCoreData->cbPathTranslatedW );

    pCursor += _pCoreData->cbPathTranslatedW;

    //
    // Add physical path
    //

    pSerialized->szPhysicalPath = (LPSTR)pCursor;

    CopyMemory( pSerialized->szPhysicalPath,
                _pCoreData->szPhysicalPath,
                _pCoreData->cbPhysicalPath );

    pCursor += _pCoreData->cbPhysicalPath;

    //
    // Add path info
    //

    pSerialized->szPathInfo = (LPSTR)pCursor;

    CopyMemory( pSerialized->szPathInfo,
                _pCoreData->szPathInfo,
                _pCoreData->cbPathInfo );

    pCursor += _pCoreData->cbPathInfo;

    //
    // Add method
    //

    pSerialized->szMethod = (LPSTR)pCursor;

    CopyMemory( pSerialized->szMethod,
                _pCoreData->szMethod,
                _pCoreData->cbMethod );

    pCursor += _pCoreData->cbMethod;

    //
    // Add query string
    //

    pSerialized->szQueryString = (LPSTR)pCursor;

    CopyMemory( pSerialized->szQueryString,
                _pCoreData->szQueryString,
                _pCoreData->cbQueryString );

    pCursor += _pCoreData->cbQueryString;

    //
    // Add path translated
    //

    pSerialized->szPathTranslated = (LPSTR)pCursor;

    CopyMemory( pSerialized->szPathTranslated,
                _pCoreData->szPathTranslated,
                _pCoreData->cbPathTranslated );

    pCursor += _pCoreData->cbPathTranslated;

    //
    // Add content type
    //

    pSerialized->szContentType = (LPSTR)pCursor;

    CopyMemory( pSerialized->szContentType,
                _pCoreData->szContentType,
                _pCoreData->cbContentType );

    pCursor += _pCoreData->cbContentType;

    //
    // Add connection
    //

    pSerialized->szConnection = (LPSTR)pCursor;

    CopyMemory( pSerialized->szConnection,
                _pCoreData->szConnection,
                _pCoreData->cbConnection );

    pCursor += _pCoreData->cbConnection;

    //
    // Add user agent
    //

    pSerialized->szUserAgent = (LPSTR)pCursor;

    CopyMemory( pSerialized->szUserAgent,
                _pCoreData->szUserAgent,
                _pCoreData->cbUserAgent );

    pCursor += _pCoreData->cbUserAgent;

    //
    // Add cookie
    //

    pSerialized->szCookie = (LPSTR)pCursor;

    CopyMemory( pSerialized->szCookie,
                _pCoreData->szCookie,
                _pCoreData->cbCookie );

    pCursor += _pCoreData->cbCookie;

    //
    // Add ApplMdPath
    //

    pSerialized->szApplMdPath = (LPSTR)pCursor;

    CopyMemory( pSerialized->szApplMdPath,
                _pCoreData->szApplMdPath,
                _pCoreData->cbApplMdPath );

    pCursor += _pCoreData->cbApplMdPath;

    //
    // Add entity data
    //

    if ( _pCoreData->cbAvailableEntity )
    {
        pSerialized->pAvailableEntity = (LPWSTR)pCursor;

        CopyMemory( pSerialized->pAvailableEntity,
                    _pCoreData->pAvailableEntity,
                    _pCoreData->cbAvailableEntity );
    }

    //
    // Point _pCoreData at the new buffer and we're done
    //

    _pCoreData = pSerialized;

    DBG_ASSERT( SUCCEEDED( hr ) );

    return hr;

ErrorExit:

    DBG_ASSERT( FAILED( hr ) );

    return hr;
}

HRESULT
W3_ISAPI_HANDLER::DuplicateWamProcessHandleForLocalUse(
    HANDLE      hWamProcessHandle,
    HANDLE *    phLocalHandle
    )
/*++

Routine Description:

    Duplicates a handle defined in a WAM process to a local
    handle useful in the IIS core

Arguments:

    hWamProcessHandle - The value of the handle from the WAM process
    phLocalHandle     - Upon successful return, the handle useable in
                        the core process

Return Value:

    HRESULT

--*/
{
    HANDLE  hWamProcess;
    HRESULT hr = NOERROR;

    DBG_ASSERT( _pWamProcess );

    DBG_REQUIRE( ( hWamProcess = _pWamProcess->QueryProcess() ) != NULL );

    if ( !DuplicateHandle( hWamProcess, hWamProcessHandle, GetCurrentProcess(),
                           phLocalHandle, 0, FALSE, DUPLICATE_SAME_ACCESS ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
    }

    return hr;
}

HRESULT
W3_ISAPI_HANDLER::MarshalAsyncReadBuffer(
    DWORD64     pWamExecInfo,
    LPBYTE      pBuffer,
    DWORD       cbBuffer
    )
/*++

Routine Description:

    Pushes a buffer into a WAM process.  This function is called
    to copy a local read buffer into the WAM process just prior
    to notifying the I/O completion function of an OOP extension.

Arguments:

    pWamExecInfo - A WAM_EXEC_INFO pointer that identifies the request
                   to the OOP host.
    pBuffer      - The buffer to copy
    cbBuffer     - The amount of data in pBuffer

Return Value:

    HRESULT

--*/
{
    DBG_ASSERT( sm_fWamActive );
    DBG_ASSERT( _pWamProcess );

    return _pWamProcess->MarshalAsyncReadBuffer( pWamExecInfo, pBuffer,
                                                 cbBuffer );
}

VOID
W3_ISAPI_HANDLER::IsapiRequestFinished(
    VOID
    )
/*++

Routine Description:

    This function is called by the destructor for the
    ISAPI_REQUEST associated with this request.  If the
    current state of the W3_ISAPI_HANDLER is
    ISAPI_STATE_PENDING, then it will advance the core
    state machine.

Arguments:

    None

Return Value:

    None

--*/
{
    W3_CONTEXT *    pW3Context = QueryW3Context();
    HRESULT         hr = NO_ERROR;

    DBG_ASSERT( pW3Context );

    if ( _State == ISAPI_STATE_FAILED )
    {        
        if ( pW3Context->QueryResponseSent() == FALSE )
        {
            //
            // The ISAPI didn't send a response, we need to send
            // it now.  If our send is successful, we should return
            // immediately.
            //

            hr = pW3Context->SendResponse( W3_FLAG_ASYNC );

            if ( SUCCEEDED( hr ) )
            {
                return;
            }
            else
            {
                pW3Context->SetErrorStatus( hr );
            }
        }

        //
        // Since we didn't end up sending a response, we need
        // to set the status to pending.  This will result in
        // the below code triggering a completion to clean up
        // the state machine.
        //

        _State = ISAPI_STATE_PENDING;
    }

    if ( _State == ISAPI_STATE_PENDING )
    {
        RestartCoreStateMachine();
    }
}

VOID
W3_ISAPI_HANDLER::RestartCoreStateMachine(
    VOID
    )
/*++

Routine Description:

    Advances the core state machine by setting state
    to ISAPI_STATE_DONE and triggering an I/O completion.
    
    Note that this function is only expected to be called
    if the object state is ISAPI_STATE_PENDING.

Arguments:

    None

Return Value:

    None

--*/
{
    W3_CONTEXT *    pW3Context = QueryW3Context();
    
    DBG_ASSERT( pW3Context );
    DBG_ASSERT( _State == ISAPI_STATE_PENDING );

    //
    // Need to set state to ISAPI_STATE_DONE so that the
    // resulting completion does the advance for us.
    //

    _State = ISAPI_STATE_DONE;

    //
    // If this is the main request, then we can resume the state
    // machine on the ISAPIs thread.  Therefore no need to marshall
    // to another thread.  If it is not the main request, the we
    // don't want to risk doing a long running operation (i.e. the
    // completion of the parent request) on the ISAPI thread
    //

    if ( pW3Context == pW3Context->QueryMainContext() )
    {
        W3_MAIN_CONTEXT::OnPostedCompletion( NO_ERROR, 
                                             0, 
                                             (OVERLAPPED*) pW3Context->QueryMainContext() );
    }
    else
    {
        POST_MAIN_COMPLETION( pW3Context->QueryMainContext() );
    }
}

//static
HRESULT
W3_ISAPI_HANDLER::Initialize(
    VOID
    )
/*++

Routine Description:

    Initializes W3_ISAPI_HANDLER

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HRESULT                         hr = NOERROR;
    
    DBGPRINTF(( DBG_CONTEXT, "W3_ISAPI_HANDLER::Initialize()\n" ));

    //
    // For debugging purposes, create a unique instance ID for this
    // instance of the handler.
    //

#ifdef DBG
    
    UUID            uuid;
    RPC_STATUS      rpcStatus;
    unsigned char * szRpcString;
    
    rpcStatus = UuidCreate( &uuid );

    if ( (rpcStatus != RPC_S_OK) && (rpcStatus != RPC_S_UUID_LOCAL_ONLY) )
    {
        SetLastError( rpcStatus );
        goto error_exit;
    }

    rpcStatus = UuidToStringA( &uuid, &szRpcString );

    if ( rpcStatus != RPC_S_OK )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        goto error_exit;
    }

    strncpy( sm_szInstanceId, (LPSTR)szRpcString, SIZE_CLSID_STRING );
    sm_szInstanceId[SIZE_CLSID_STRING - 1] = '\0';

    RpcStringFreeA( &szRpcString );

    DBGPRINTF((
        DBG_CONTEXT,
        "W3_ISAPI_HANDLER initialized instance %s.\r\n",
        sm_szInstanceId
        ));

#else

    sm_szInstanceId[0] = '\0';

#endif _DBG
        
    PFN_ISAPI_INIT_MODULE pfnInit = NULL;
    
    sm_hIsapiModule = LoadLibrary( ISAPI_MODULE_NAME );
    if( sm_hIsapiModule == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto error_exit;
    }

    sm_pfnTermIsapiModule = 
        (PFN_ISAPI_TERM_MODULE)GetProcAddress( sm_hIsapiModule, 
                                               ISAPI_TERM_MODULE 
                                               );

    sm_pfnProcessIsapiRequest = 
        (PFN_ISAPI_PROCESS_REQUEST)GetProcAddress( sm_hIsapiModule,
                                                   ISAPI_PROCESS_REQUEST
                                                   );

    sm_pfnProcessIsapiCompletion =
        (PFN_ISAPI_PROCESS_COMPLETION)GetProcAddress( sm_hIsapiModule,
                                                      ISAPI_PROCESS_COMPLETION
                                                      );

    if( !sm_pfnTermIsapiModule ||
        !sm_pfnProcessIsapiRequest ||
        !sm_pfnProcessIsapiCompletion )
    {
        hr = E_FAIL;
        goto error_exit;
    }

    pfnInit = 
        (PFN_ISAPI_INIT_MODULE)GetProcAddress( sm_hIsapiModule, 
                                               ISAPI_INIT_MODULE 
                                               );
    if( !pfnInit )
    {
        hr = E_FAIL;
        goto error_exit;
    }

    hr = pfnInit(
        NULL,
        sm_szInstanceId,
        GetCurrentProcessId()
        );

    if( FAILED(hr) )
    {
        goto error_exit;
    }

    DBG_REQUIRE( ISAPI_REQUEST::InitClass() );

    sm_pInprocIsapiHash = NULL;

    //
    // If we're running in backward compatibility mode, initialize
    // the WAM process manager and inprocess ISAPI app list
    //
    
    if ( g_pW3Server->QueryInBackwardCompatibilityMode() )
    {
        WCHAR   szIsapiModule[MAX_PATH];
        //
        // Store away the full path to the loaded ISAPI module
        // so that we can pass it to OOP processes so that they
        // know how to load it
        //

        if ( GetModuleFileNameW(
            GetModuleHandleW( ISAPI_MODULE_NAME ),
            szIsapiModule,
            MAX_PATH
            ) == 0 )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto error_exit;
        }

        DBG_ASSERT( szIsapiModule[0] != '\0' );

        //
        // Initialize the WAM_PROCESS_MANAGER
        //
        
        sm_pWamProcessManager = new WAM_PROCESS_MANAGER( szIsapiModule );

        if ( !sm_pWamProcessManager )
        {
            goto error_exit;
        }

        hr = sm_pWamProcessManager->Create();

        if ( FAILED( hr ) )
        {
            sm_pWamProcessManager->Release();
            sm_pWamProcessManager = NULL;

            goto error_exit;
        }

        //
        // Hook up wamreg
        //

        hr = WamReg_RegisterSinkNotify( W3SVC_WamRegSink );

        if ( FAILED( hr ) )
        {
            goto error_exit;
        }

        INITIALIZE_CRITICAL_SECTION( &sm_csInprocHashLock );
        
        UpdateInprocIsapiHash();

        INITIALIZE_CRITICAL_SECTION( &sm_csBigHurkinWamRegLock );

        sm_fWamActive = TRUE;
    }
    else
    {
        sm_pWamProcessManager = NULL;
        sm_fWamActive = FALSE;
    }

    sg_Initialized = TRUE;

    return hr;
error_exit:

    DBGPRINTF(( DBG_CONTEXT, 
                "W3_ISAPI_HANDLER::Initialize() Error=%08x\n",
                hr
                ));

    if ( sm_hIsapiModule )
    {
        FreeLibrary( sm_hIsapiModule );
        sm_hIsapiModule = NULL;
    }
    
    sm_pfnTermIsapiModule = NULL;

    return hr;
}

//static
VOID
W3_ISAPI_HANDLER::Terminate(
    VOID
    )
/*++

Routine Description:

    Terminates W3_ISAPI_HANDLER

Arguments:

    None

Return Value:

    None

--*/

{
    DBGPRINTF(( DBG_CONTEXT, "W3_ISAPI_HANDLER::Terminate()\n" ));

    sg_Initialized = FALSE;

    DBG_ASSERT( sm_pfnTermIsapiModule );
    DBG_ASSERT( sm_hIsapiModule );

    if( sm_pfnTermIsapiModule )
    {
        sm_pfnTermIsapiModule();
        sm_pfnTermIsapiModule = NULL;
    }

    if( sm_hIsapiModule )
    {
        FreeLibrary( sm_hIsapiModule );
        sm_hIsapiModule = NULL;
    }

    if ( sm_pInprocIsapiHash )
    {
        delete sm_pInprocIsapiHash;
    }

    if ( sm_fWamActive )
    {
        //
        // Disconnect wamreg
        //

        WamReg_UnRegisterSinkNotify();

        if ( sm_pWamProcessManager )
        {
            sm_pWamProcessManager->Shutdown();

            sm_pWamProcessManager->Release();
            sm_pWamProcessManager = NULL;
        }

        DeleteCriticalSection( &sm_csInprocHashLock );
        DeleteCriticalSection( &sm_csBigHurkinWamRegLock );
    }

    ISAPI_REQUEST::CleanupClass();
}

// static
HRESULT
W3_ISAPI_HANDLER::W3SVC_WamRegSink(
    LPCSTR      szAppPath,
    const DWORD dwCommand,
    DWORD *     pdwResult
    )
{
    HRESULT         hr = NOERROR;
    WAM_PROCESS *   pWamProcess = NULL;
    WAM_APP_INFO *  pWamAppInfo = NULL;
    DWORD           dwWamSubError = 0;
    BOOL            fIsLoaded = FALSE;

    //
    // Scary monsters live in the land where this function
    // is allowed to run willy nilly
    //

    LockWamReg();

    DBG_ASSERT( szAppPath );
    DBG_ASSERT( sm_pWamProcessManager );

    DBGPRINTF((
        DBG_CONTEXT,
        "WAM_PROCESS_MANAGER received a Sink Notify on MD path %S, cmd = %d.\r\n",
        (LPCWSTR)szAppPath,
        dwCommand
        ));

    *pdwResult = APPSTATUS_UnLoaded;

    switch ( dwCommand )
    {
    case APPCMD_UNLOAD:
    case APPCMD_DELETE:
    case APPCMD_CHANGETOINPROC:
    case APPCMD_CHANGETOOUTPROC:

        //
        // Unload the specified wam process.
        //
        // Note that we're casting the incoming app path to
        // UNICODE.  This is because wamreg would normally
        // convert the MD path (which is nativly UNICODE) to
        // MBCS in IIS 5.x.  It's smart enough to know that
        // for 6.0 we want to work directly with UNICODE.
        //

        hr = sm_pWamProcessManager->GetWamProcessInfo(
            reinterpret_cast<LPCWSTR>(szAppPath),
            &pWamAppInfo,
            &fIsLoaded
            );

        if ( FAILED( hr ) )
        {
            goto Done;
        }

        DBG_ASSERT( pWamAppInfo );

        //
        // If the app has not been loaded by the WAM_PROCESS_MANAGER
        // then there is nothing more to do.
        //

        if ( fIsLoaded == FALSE )
        {
            break;
        }

        hr = sm_pWamProcessManager->GetWamProcess(
            pWamAppInfo->_szClsid,
            pWamAppInfo->_szAppPath,
            &dwWamSubError,
            &pWamProcess,
            sm_szInstanceId
            );

        if ( FAILED( hr ) )
        {
            //
            // Hey, this app was loaded just a moment ago!
            //

            DBG_ASSERT( FALSE );
            goto Done;
        }

        DBG_ASSERT( pWamProcess );

        hr = pWamProcess->Unload( 0 );

        if ( FAILED( hr ) )
        {
            goto Done;
        }

        break;

    case APPCMD_GETSTATUS:

        hr = sm_pWamProcessManager->GetWamProcessInfo(
            reinterpret_cast<LPCWSTR>(szAppPath),
            &pWamAppInfo,
            &fIsLoaded
            );

        if ( SUCCEEDED( hr ) )
        {
            if ( fIsLoaded )
            {
                *pdwResult = APPSTATUS_Running;
            }
            else
            {
                *pdwResult = APPSTATUS_Stopped;
            }
        }

        break;
    }

Done:

    UnlockWamReg();

    if ( pWamAppInfo )
    {
        pWamAppInfo->Release();
        pWamAppInfo = NULL;
    }

    if ( pWamProcess )
    {
        pWamProcess->Release();
        pWamProcess = NULL;
    }

    if ( FAILED( hr ) )
    {
        *pdwResult = APPSTATUS_Error;
    }

    return hr;
}

// static
HRESULT
W3_ISAPI_HANDLER::UpdateInprocIsapiHash(
    VOID
    )
/*++

Routine Description:

    Updates the table of InProcessIsapiApps

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    MB                      mb( g_pW3Server->QueryMDObject() );
    W3_INPROC_ISAPI_HASH *  pNewTable = NULL;
    W3_INPROC_ISAPI_HASH *  pOldTable = NULL;
    DWORD                   i;
    LPWSTR                  psz;
    HRESULT                 hr = NOERROR;
    LK_RETCODE              lkr = LK_SUCCESS;

    //
    // Allocate a new table and populate it.
    //

    pNewTable = new W3_INPROC_ISAPI_HASH;

    if ( !pNewTable )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto ErrorExit;
    }

    if ( !mb.Open( L"/LM/W3SVC/" ) )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ErrorExit;
    }

    if ( !mb.GetMultisz( L"",
                         MD_IN_PROCESS_ISAPI_APPS,
                         IIS_MD_UT_SERVER,
                         &pNewTable->_mszImages) )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        mb.Close();
        goto ErrorExit;
    }

    //
    // Merge ISAPI filter images into the list
    //

    AddAllFiltersToMultiSz( mb, &pNewTable->_mszImages );

    mb.Close();

    //
    // Now that we have a complete list, add them to the
    // hash table.
    //

    for ( i = 0, psz = (LPWSTR)pNewTable->_mszImages.First();
          psz != NULL;
          i++, psz = (LPWSTR)pNewTable->_mszImages.Next( psz ) )
    {
        W3_INPROC_ISAPI *   pNewRecord;

        //
        // Allocate a new W3_INPROC_ISAPI object and add
        // it to the table
        //

        pNewRecord = new W3_INPROC_ISAPI;
        
        if ( !pNewRecord )
        {
            hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
            goto ErrorExit;
        }

        hr = pNewRecord->Create( psz );

        if ( FAILED( hr ) )
        {
            pNewRecord->DereferenceInprocIsapi();
            pNewRecord = NULL;
            goto ErrorExit;
        }
              
        lkr = pNewTable->InsertRecord( pNewRecord, TRUE );

        pNewRecord->DereferenceInprocIsapi();
        pNewRecord = NULL;

        if ( lkr != LK_SUCCESS && lkr != LK_KEY_EXISTS )
        {
            hr = E_FAIL;
            goto ErrorExit;
        }
    }

    //
    // Now swap in the new table and delete the old one
    //

    EnterCriticalSection( &sm_csInprocHashLock );

    pOldTable = sm_pInprocIsapiHash;
    sm_pInprocIsapiHash = pNewTable;

    LeaveCriticalSection( &sm_csInprocHashLock );

    if ( pOldTable )
    {
        delete pOldTable;
    }

    DBG_ASSERT( SUCCEEDED( hr ) );

    return hr;


ErrorExit:

    DBG_ASSERT( FAILED( hr ) );

    if ( pNewTable )
    {
        delete pNewTable;
    };

    return hr;
}

VOID
AddFiltersToMultiSz(
    IN const MB &       mb,
    IN LPCWSTR          szFilterPath,
    IN OUT MULTISZ *    pmsz
    )
/*++

    Description:
        Add the ISAPI filters at the specified metabase path to pmsz.
        
        Called by AddAllFiltersToMultiSz.

    Arguments:
        mb              metabase key open to /LM/W3SVC
        szFilterPath    path of /Filters key relative to /LM/W3SVC
        pmsz            multisz containing the in proc dlls

    Return:
        Nothing - failure cases ignored.

--*/
{
    WCHAR   szKeyName[MAX_PATH + 1];
    STRU    strFilterPath;
    STRU    strFullKeyName;
    INT     pchFilterPath = (INT)wcslen( szFilterPath );

    if ( FAILED( strFullKeyName.Copy( szFilterPath ) ) )
    {
        return;
    }

    DWORD   i = 0;

    if( SUCCEEDED( strFullKeyName.Append( L"/", 1 ) ) )
    {
        while ( const_cast<MB &>(mb).EnumObjects( szFilterPath,
                                                  szKeyName, 
                                                  i++ ) )
        {
        
            if( SUCCEEDED( strFullKeyName.Append( szKeyName ) ) )
            {
                if( const_cast<MB &>(mb).GetStr( strFullKeyName.QueryStr(),
                                                 MD_FILTER_IMAGE_PATH,
                                                 IIS_MD_UT_SERVER,
                                                 &strFilterPath ) )
                {
                    pmsz->Append( strFilterPath );
                }
            }
            strFullKeyName.SetLen( pchFilterPath + 1 );
        }
    }
}

VOID
AddAllFiltersToMultiSz(
    IN const MB &       mb,
    IN OUT MULTISZ *    pmsz
    )
/*++

    Description:

        This is designed to prevent ISAPI extension/filter
        combination dlls from running out of process.

        Add the base set of filters defined for the service to pmsz.
        Iterate through the sites and add the filters defined for
        each site.

    Arguments:

        mb              metabase key open to /LM/W3SVC
        pmsz            multisz containing the in proc dlls

    Return:
        Nothing - failure cases ignored.

--*/
{
    WCHAR   szKeyName[MAX_PATH + 1];
    STRU    strFullKeyName;
    DWORD   i = 0;
    DWORD   dwInstanceId = 0;

    if ( FAILED( strFullKeyName.Copy( L"/" ) ) )
    {
        return;
    }

    AddFiltersToMultiSz( mb, L"/Filters", pmsz );

    while ( const_cast<MB &>(mb).EnumObjects( L"",
                                              szKeyName,
                                              i++ ) )
    {
        dwInstanceId = _wtoi( szKeyName );
        if( 0 != dwInstanceId )
        {
            // This is a site.
            if( SUCCEEDED( strFullKeyName.Append( szKeyName ) ) &&
                SUCCEEDED( strFullKeyName.Append( L"/Filters" ) ) )
            {
                AddFiltersToMultiSz( mb, strFullKeyName.QueryStr(), pmsz );
            }

            strFullKeyName.SetLen( 1 );
        }
    }
}


HRESULT
W3_ISAPI_HANDLER::SetupUlCachedResponse(
    W3_CONTEXT *                pW3Context,
    HTTP_CACHE_POLICY          *pCachePolicy
)
/*++

Routine Description:

    Setup a response to be cached by UL.

Arguments:

    pW3Context - Context
    pCachePolicy - Cache policy to be filled in if caching desired

Return Value:

    HRESULT

--*/
{
    STACK_STRU(             strFlushUrl, MAX_PATH );
    HRESULT                 hr;
    DWORD                   dwTTL = 0;

    if ( pW3Context == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // Find out if caching is enabled for this isapi request
    //
    if (!_pIsapiRequest->QueryCacheResponse())
    {
        return HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
    }

    W3_RESPONSE *pResponse = pW3Context->QueryResponse();
    LPCSTR pszExpires = pResponse->GetHeader( HttpHeaderExpires );
    if ( pszExpires != NULL )
    {
        LARGE_INTEGER liExpireTime;
        LARGE_INTEGER liCurrentTime;
        if ( !StringTimeToFileTime( pszExpires,
                                    &liExpireTime ) )
        {
            return HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
        }

        GetSystemTimeAsFileTime( (FILETIME *)&liCurrentTime );

        if ( liExpireTime.QuadPart <= liCurrentTime.QuadPart )
        {
            return HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
        }

        dwTTL = ( liExpireTime.QuadPart - liCurrentTime.QuadPart ) / 10000000;
    }

    //
    // Get the exact URL used to flush UL cache
    //
    hr = pW3Context->QueryMainContext()->QueryRequest()->GetOriginalFullUrl(
                                                            &strFlushUrl );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    //
    // Setup UL cache response token
    //

    DBG_ASSERT( g_pW3Server->QueryUlCache() != NULL );

    hr = g_pW3Server->QueryUlCache()->SetupUlCachedResponse(
                                        pW3Context,
                                        strFlushUrl,
                                        FALSE,
                                        NULL );
    if ( SUCCEEDED( hr ) )
    {
        if (pszExpires == NULL)
        {
            pCachePolicy->Policy = HttpCachePolicyUserInvalidates;
        }
        else
        {
            pCachePolicy->Policy = HttpCachePolicyTimeToLive;
            pCachePolicy->SecondsToLive = dwTTL;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\isapi_request.cxx ===
/*++

   Copyright    (c)    2000    Microsoft Corporation

   Module Name :
     isapi_request.cxx

   Abstract:
     IIS+ IIsapiCore implementation.

   Author:
     Wade Hilmo (wadeh)             29-Aug-2000

   Project:
     w3core.dll

--*/

#include "precomp.hxx"
#include "isapi_request.hxx"
#include "iisapicore_i.c"
#include "isapi_handler.h"
#include "stringau.hxx"

#define ISAPI_REQUEST_CACHE_THRESHOLD   (400) // Value lifted from IIS 5

#define SZ_FAILED_OOP_REQUEST_LOG_MESSAGE   \
    "Out-of-process+ISAPI+extension+request+failed."

ALLOC_CACHE_HANDLER *   ISAPI_REQUEST::sm_pachIsapiRequest;
PTRACE_LOG              ISAPI_REQUEST::sm_pTraceLog;

HRESULT
SendEntityBodyAndLogDataHelper(
    W3_CONTEXT                 *pW3Context,
    ULATQ_CONTEXT               pContext,
    BOOL                        fAsync,
    DWORD                       dwFlags,
    USHORT                      cChunks,
    HTTP_DATA_CHUNK *           pChunks,
    DWORD                      *pcbSent
);

BOOL
ISAPI_REQUEST::InitClass( VOID )
/*++

Routine Description:

    Acache initialization function

Arguments:

    None

Return Value:

    TRUE on success, FALSE on error

--*/
{
    ALLOC_CACHE_CONFIGURATION  acConfig = { 1, ISAPI_REQUEST_CACHE_THRESHOLD,
                                            sizeof( ISAPI_REQUEST ) };

    if ( NULL != sm_pachIsapiRequest) {

        // already initialized
        return ( TRUE);
    }

    sm_pachIsapiRequest = new ALLOC_CACHE_HANDLER( "IsapiRequest",
                                                    &acConfig);

#if DBG
    sm_pTraceLog = CreateRefTraceLog( 2000, 0 );
#else
    sm_pTraceLog = NULL;
#endif

    return ( NULL != sm_pachIsapiRequest);
}

VOID
ISAPI_REQUEST::CleanupClass( VOID )
/*++

Routine Description:

    Acache cleanup function

Arguments:

    None

Return Value:

    None

--*/
{
    if ( sm_pTraceLog != NULL )
    {
        DestroyRefTraceLog( sm_pTraceLog );
        sm_pTraceLog = NULL;
    }

    if ( NULL != sm_pachIsapiRequest)
    {
        delete sm_pachIsapiRequest;
        sm_pachIsapiRequest = NULL;
    }

    return;
}

HRESULT
ISAPI_REQUEST::Create(
    VOID
    )
/*++

Routine Description:

    Creates a newly allocated ISAPI_REQUEST object.  This
    function does initialization tasks which wouldn't be
    appropriate in the constructor due to potential failure
    during initialization.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HRESULT hr = NOERROR;

    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( _pW3Context );

    IF_DEBUG( ISAPI )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Creating ISAPI_REQUEST %p, W3Context=%p, Handler=%p.\r\n",
            this,
            _pW3Context,
            _pW3Context->QueryHandler()
            ));
    }

    if ( _fIsOop )
    {
        hr = CoCreateFreeThreadedMarshaler(this, &_pUnkFTM);
    }

    if ( FAILED( hr ) )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "ISAPI_REQUEST %p.  Failed to CoCreate free threaded marshaler.\r\n",
            this
            ));

        goto ErrorExit;
    }

    IF_DEBUG( ISAPI )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "ISAPI_REQUEST %p created successfully.\r\n",
            this
            ));
    }

    return hr;

ErrorExit:

    DBG_ASSERT( FAILED( hr ) );

    DBGPRINTF((
        DBG_CONTEXT,
        "Failed to create ISAPI_REQUEST %p.  HRESULT=%08x.\r\n",
        this,
        hr
        ));

    return hr;
}

HRESULT STDMETHODCALLTYPE
ISAPI_REQUEST::QueryInterface(
    REFIID riid,
    void __RPC_FAR *__RPC_FAR *ppvObject
    )
/*++

Routine Description:

    COM Goo

Arguments:

    riid      - Id of the interface requested
    ppvObject - Upon return, points to requested interface

Return Value:

    HRESULT

--*/
{
    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( ppvObject );

    *ppvObject = NULL;
/*
    DBGPRINTF((
        DBG_CONTEXT,
        "WAM_REQUEST::QueryInterface looking for ... ( " GUID_FORMAT " )\n",
        GUID_EXPAND( &riid)
        ));
*/
    if( riid == IID_IIsapiCore )
    {
        *ppvObject = static_cast<IIsapiCore *>( this );
    }
    else if ( riid == IID_IMarshal )
    {
        if ( _pUnkFTM == NULL )
        {
            DBG_ASSERT(FALSE);
            return E_NOINTERFACE;
        }
        else
        {
            return _pUnkFTM->QueryInterface(riid, ppvObject);
        }
    }
    else if( riid == IID_IUnknown )
    {
        *ppvObject = static_cast<IIsapiCore *>( this );
    }
    else if ( _pUnkFTM != NULL )
    {
        return _pUnkFTM->QueryInterface(riid, ppvObject);
    }
    else
    {
        return E_NOINTERFACE;
    }

    DBG_ASSERT( *ppvObject );
    ((IUnknown *)*ppvObject)->AddRef();
/*
    DBGPRINTF((
        DBG_CONTEXT,
        "WAM_REQUEST::QueryInterface found ( " GUID_FORMAT ", %p )\n",
        GUID_EXPAND( &riid),
        *ppvObject
        ));
*/
    return NOERROR;
}

ULONG STDMETHODCALLTYPE
ISAPI_REQUEST::AddRef(
    void
    )
/*++

Routine Description:

    COM Goo - adds a reference to the object

Arguments:

    None

Return Value:

    The number of references remaining at completion of this call

--*/
{
    LONG cRefs;

    DBG_ASSERT( CheckSignature() );

    cRefs = InterlockedIncrement( &_cRefs );

    //
    // Log the reference ( sm_pTraceLog!=NULL if DBG=1)
    //

    if ( sm_pTraceLog != NULL )
    {
        WriteRefTraceLog( sm_pTraceLog,
                          cRefs,
                          this );
    }

    return cRefs;
}

ULONG STDMETHODCALLTYPE
ISAPI_REQUEST::Release(
    void
    )
/*++

Routine Description:

    COM Goo - deletes a referece to the object, and deletes
              the object upon zero references

Arguments:

    None

Return Value:

    The number of references remaining at completion of this call

--*/
{
    LONG cRefs;
    BOOL fIsOop = _fIsOop;
    W3_ISAPI_HANDLER * pW3IsapiHandler = NULL;

    DBG_ASSERT( CheckSignature() );

    //
    // WARNING - This object is always created by W3_ISAPI_HANDLER,
    //           and that code uses the return value from Release
    //           to determine if it's safe to advance the core
    //           state machine.  It is essential that this function
    //           only return 0 in the case where it's called delete.
    //

    cRefs = InterlockedDecrement( &_cRefs );

    if ( sm_pTraceLog != NULL )
    {
        WriteRefTraceLog( sm_pTraceLog,
                          cRefs,
                          this );
    }

    if ( ( cRefs == 1 ) && fIsOop )
    {
        _pWamProcess->RemoveIsapiRequestFromList( this );
    }

    if ( cRefs == 0 )
    {
        DBG_ASSERT( _pW3Context );
        DBG_REQUIRE( ( pW3IsapiHandler = (W3_ISAPI_HANDLER*)_pW3Context->QueryHandler() ) != NULL );
        
        delete this;

        //
        // Notify the W3_ISAPI_HANDLER that we are done with it
        //
        
        pW3IsapiHandler->IsapiRequestFinished();

        return 0;
    }

    return cRefs;
}

HRESULT STDMETHODCALLTYPE
ISAPI_REQUEST::GetServerVariable(
    LPSTR           szVariableName,
    BYTE *          szBuffer,
    DWORD           cbBuffer,
    DWORD *         pcbBufferRequired
    )
/*++

Routine Description:

    Returns the value of a server variable

Arguments:

    szVariableName    - The name of the server variable
    szBuffer          - Upon return, contains the value of the server variable
    cbBuffer          - The size of szBuffer.
    pcbBufferRequired - On successful return, the number of bytes copied
                        to the buffer.  On failure, the number of bytes
                        required to hold szBuffer.

Return Value:

    HRESULT

--*/
{
    HRESULT         hr = NOERROR;

    //
    // The only current caller for this function is w3isapi.dll, which does
    // parameter validation from any outside code.  So, we can get away with
    // just asserting here.
    //

    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( _pW3Context );
    DBG_ASSERT( szVariableName );
    DBG_ASSERT( pcbBufferRequired );
    DBG_ASSERT( szBuffer || ( cbBuffer == 0 ) );

    hr = SERVER_VARIABLE_HASH::GetServerVariable(
        _pW3Context,
        szVariableName,
        (LPSTR)szBuffer,
        &cbBuffer
        );

    *pcbBufferRequired = cbBuffer;

    return hr;
}

HRESULT STDMETHODCALLTYPE
ISAPI_REQUEST::ReadClient(
    DWORD64 IsaContext,
    BYTE *pBuffer,
    DWORD cbBuffer,
    DWORD dwBytesToRead,
    DWORD *pdwSyncBytesRead,
    DWORD dwFlags
    )
 /*++

Routine Description:

    Reads data from the client

Arguments:

    IsaContext       - The ISAPI_CONTEXT for this request (opaque)
    pBuffer          - Contains read data upon return for sync reads
    cbBuffer         - The size of pSyncReadBuffer
    dwBytesToRead    - The number of bytes to read
    pdwSyncBytesRead - The number of bytes copied to pBuffer in sync case
    dwFlags          - HSE_IO_* flags from caller

Return Value:

    HRESULT

--*/
{
    DWORD   dwBytesRead;
    HRESULT hr = NOERROR;
    BOOL    fAsync = !!( dwFlags & HSE_IO_ASYNC );

    //
    // The only current caller for this function is w3isapi.dll, which does
    // parameter validation from any outside code.  So, we can get away with
    // just asserting here.
    //

    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( _pW3Context );
    DBG_ASSERT( fAsync == !!IsaContext );
    DBG_ASSERT( dwBytesToRead );
    DBG_ASSERT( pdwSyncBytesRead || fAsync );

    //
    // Make /W4 happy...
    //

    if ( pBuffer == NULL && cbBuffer != 0 )
    {
        DBG_ASSERT( pBuffer || ( cbBuffer == 0 ) );
    }

    if ( fAsync )
    {
        DBG_ASSERT( _IsapiContext == 0 );
        _IsapiContext = IsaContext;
    }

    //
    // If this is an OOP async read, then we need to create a
    // local buffer to read into.
    //

    if ( _fIsOop && fAsync )
    {
        DBG_ASSERT( _pAsyncReadBuffer == NULL );

        _pAsyncReadBuffer = (LPBYTE)LocalAlloc( LPTR, dwBytesToRead );

        if ( !_pAsyncReadBuffer )
        {
            goto ErrorExit;
        }

        //
        // This reference insures that if the OOP host crashes and
        // COM releases all the OOP-held references, that this
        // object will survive until the I/O completion occurs.
        //

        AddRef();

        hr = _pW3Context->ReceiveEntity(
            fAsync ? W3_FLAG_ASYNC : W3_FLAG_SYNC,
            _pAsyncReadBuffer,
            dwBytesToRead,
            &dwBytesRead
            );
    }
    else
    {
        hr = _pW3Context->ReceiveEntity(
            fAsync ? W3_FLAG_ASYNC : W3_FLAG_SYNC,
            pBuffer,
            dwBytesToRead,
            fAsync ? &dwBytesRead : pdwSyncBytesRead
            );
    }

    //
    // If the request is chunked, look for ERROR_HANDLE_EOF.  This
    // is how http.sys signals the end of a chunked request.
    //
    // Since an ISAPI extension is looking for a successful, zero
    // byte read, we'll need to change the result of the above call.
    //
    // Note that on an asynchronous call, we'll need to trigger a
    // "fake" completion with zero bytes.
    //

    if ( FAILED( hr ) && _pW3Context->QueryRequest()->IsChunkedRequest() )
    {
        if ( hr == HRESULT_FROM_WIN32( ERROR_HANDLE_EOF ) )
        {
            hr = NOERROR;

            if ( fAsync )
            {
                POST_MAIN_COMPLETION( _pW3Context->QueryMainContext() );
            }
            else
            {
                *pdwSyncBytesRead = 0;
            }
        }
    }

    //
    // We now return you to your regular error handling program.
    //

    if ( FAILED( hr ) )
    {
        //
        // If ReceiveEntity fails for some reason other than
        // EOF, then consider this a non recoverable
        // error and set the error to be WSAECONNRESET for
        // compatibility with legacy ISAPI code.
        //

        hr = HRESULT_FROM_WIN32( WSAECONNRESET );

        if ( _fIsOop && fAsync )
        {
            //
            // Release the above reference, since no completion
            // will be coming.
            //

            Release();
        }

        goto ErrorExit;
    }

    return hr;

ErrorExit:

    DBG_ASSERT( FAILED( hr ) );

    if ( fAsync &&
         _IsapiContext != 0 )
    {
        _IsapiContext = 0;
    }

    if ( _pAsyncReadBuffer )
    {
        LocalFree( _pAsyncReadBuffer );
        _pAsyncReadBuffer = NULL;
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE
ISAPI_REQUEST::WriteClient(
    DWORD64         IsaContext,
    BYTE *          pBuffer,
    DWORD           cbBuffer,
    DWORD           dwFlags
    )
/*++

Routine Description:

    Writes data to the client

Arguments:

    IsaContext - The ISAPI_CONTEXT for this request (opaque)
    pBuffer    - Contains the data to write
    cbBuffer   - The amount of data to be written
    dwFlags    - HSE_IO_* flags from caller

Return Value:

    HRESULT

--*/
{
    W3_RESPONSE *   pResponse;
    HRESULT         hr = NOERROR;
    BOOL            fAsync = !!( dwFlags & HSE_IO_ASYNC );

    //
    // The only current caller for this function is w3isapi.dll, which does
    // parameter validation from any outside code.  So, we can get away with
    // just asserting here.
    //

    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( _pW3Context );
    DBG_ASSERT( fAsync == !!IsaContext );
    DBG_ASSERT( pBuffer || ( cbBuffer == 0 ) );

    //
    // For a zero byte send, just return
    //
    // If the call was async, we'll need to fire off a completion.
    //
    // Note that this case shouldn't ever happen, as the w3isapi.dll
    // code that calls this currently does a check for a zero byte
    // write attempt.  That code is somewhat broken in that a completion
    // will never occur for a zero byte completion.  That's the way all
    // previous versions of ISAPI have worked, though.  This code is
    // here for the sole purpose that this interface could work properly
    // with an API that expects a completion on a zero byte async write.
    //

    if ( cbBuffer == 0 )
    {
        if ( fAsync )
        {
            POST_MAIN_COMPLETION( _pW3Context->QueryMainContext() );
        }

        return hr;
    }

    if ( fAsync )
    {
        DBG_ASSERT( _IsapiContext == 0 );
        _IsapiContext = IsaContext;
    }

    DBG_REQUIRE( ( pResponse = _pW3Context->QueryResponse() ) != NULL );

    //
    // If this as an OOP async write then we will work from a local copy
    // of pBuffer.
    //

    if ( _fIsOop && fAsync )
    {
        DBG_ASSERT( _pAsyncWriteBuffer == NULL );

        _pAsyncWriteBuffer = (LPBYTE)LocalAlloc( LPTR, cbBuffer );

        if ( !_pAsyncWriteBuffer )
        {
            goto ErrorExit;
        }

        memcpy( _pAsyncWriteBuffer, pBuffer, cbBuffer );

        pBuffer = _pAsyncWriteBuffer;
    }

    //
    // Before sending the current data, we need to clear out
    // any outstanding chunks from the response object.  This can't
    // ever cause a problem for a purely synchronous ISAPI.  And,
    // since w3isapi.dll protects against multiple outstanding
    // asynchronous I/O, we shouldn't see a problem with a
    // purely asynchronous I/O.
    //
    // If an ISAPI sends data asynchronously and then follows up
    // with a second, synchronous send, then it's possible that
    // the second send could clear the chunks from the first before
    // they've been fully processed.  This is a really, really
    // dumb thing for an ISAPI to do, since the response would
    // likely be scrambled at the client.  So, we'll live with
    // problems in that scenario.
    //

    pResponse->Clear();

    if (!_pW3Context->QueryResponseSent())
    {
        _pW3Context->SetDisconnect( TRUE );
    }

    //
    // Now setup the buffer we want to send
    //

    hr = pResponse->AddMemoryChunkByReference(
        pBuffer,
        cbBuffer
        );

    if ( FAILED( hr ) )
    {
        goto ErrorExit;
    }

    //
    // Ok, now send what we've got.
    //

    if ( _fIsOop && fAsync )
    {
        //
        // This reference insures that if the OOP host crashes and
        // COM releases all the OOP-held references, that this
        // object will survive until the I/O completion occurs.
        //

        AddRef();
    }

    hr = _pW3Context->SendEntity(
        ( fAsync ? W3_FLAG_ASYNC : W3_FLAG_SYNC ) | W3_FLAG_MORE_DATA
        );

    if ( FAILED( hr ) )
    {
        //
        // If SendEntity fails, consider this a non recoverable
        // error and set the error to be WSAECONNRESET for
        // compatibility with legacy ISAPI code.
        //

        hr = HRESULT_FROM_WIN32( WSAECONNRESET );

        if ( _fIsOop && fAsync )
        {
            //
            // Release the above reference, since no I/O completion
            // will ever happen.
            //

            Release();
        }

        goto ErrorExit;
    }

    return hr;

ErrorExit:

    DBG_ASSERT( FAILED( hr ) );

    //
    // Note that checking for async here is not an optimization.
    //
    // ISAPI guards against two concurrent async operations, but
    // it's valid to have a synchronous and asynchronous operation
    // happening currently (ie. async write, exec url, etc.,
    // concurrent with a synchronous read).
    //
    // If we don't check for async, it's possible for a failed
    // synchronous read to reset the _IsapiContext that belongs
    // to some other action that's running async.
    //

    if ( fAsync &&
         _IsapiContext != 0 )
    {
        _IsapiContext = 0;
    }

    if ( _pAsyncWriteBuffer )
    {
        LocalFree( _pAsyncWriteBuffer );
        _pAsyncWriteBuffer = NULL;
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE
ISAPI_REQUEST::SendResponseHeaders(
    BOOL            fDisconnect,
    LPSTR           szStatus,
    LPSTR           szHeaders,
    DWORD
    )
/*++

Routine Description:

    Sends response headers to the client

Arguments:

    fDisconnect - If FALSE, then we need to avoid closing the connection
    szStatus    - The status to send (ie. "200 OK")
    szHeaders   - The headers to send (ie. "foo: value1\r\nBar: value2\r\n")
    dwFlags     - HSE_IO_* flags from caller

Return Value:

    HRESULT

--*/
{
    W3_RESPONSE   * pResponse;
    STACK_STRA(     strStatus,64);
    STACK_STRA(     strHeaders,128);
    LPSTR           szCookedStatus = szStatus;
    LPSTR           szCookedHeaders = szHeaders;
    LPSTR           pCursor = NULL;
    HRESULT         hr;

    //
    // The only current caller for this function is w3isapi.dll, which does
    // parameter validation from any outside code.  So, we can get away with
    // just asserting here.
    //

    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( _pW3Context );
    DBG_REQUIRE( ( pResponse = _pW3Context->QueryResponse() ) != NULL );

    //
    // Legacy ISAPI Gymnastics:
    //
    // Some ISAPI extensions will try and piggy-back response
    // headers onto the status string that they pass to this
    // function (ie. "200 OK\r\nFoo: bar".)  While this would
    // work in IIS 5 - since IIS 5 didn't try and validate the
    // stream - it doesn't fly with http.sys.  Ultimately, this
    // will cause http.sys to fail our send response call.
    //
    // So, to accommodate these ISAPIs, we'll look for this and
    // move any such piggy-backed headers into the right argument.
    //

    if ( szStatus )
    {
        pCursor = strpbrk( szStatus, "\r\n" );
    }

    if ( pCursor )
    {
        //
        // Create a local copy of the status and
        // strip off the extra header data.
        //

        hr = strStatus.Copy( szStatus );

        if ( FAILED( hr ) )
        {
            return ( hr );
        }

        strStatus.SetLen( pCursor - szStatus );

        //
        // Eat the \r\n preceding the header
        //

        while ( *pCursor == '\r' ||
                *pCursor == '\n' )
        {
            pCursor++;
        }

        //
        // Create a local copy of the headers
        //

        hr = strHeaders.Copy( pCursor );

        if ( FAILED( hr ) )
        {
            return hr;
        }

        //
        // We'll want to make sure that strHeaders ends
        // properly with a "\r\n" at this point.  Probably the
        // easiest way to do this is to just eat any trailing
        // '\r' or '\n' characters and then append it (some ISAPI
        // developers omit the '\r' and just go with '\n'...)
        //

        pCursor = strHeaders.QueryStr() + strHeaders.QueryCCH() - 1;

        while ( pCursor > strHeaders.QueryStr() &&
                ( *pCursor == '\r' ||
                  *pCursor == '\n' ) )
        {
            pCursor--;
        }

        strHeaders.SetLen( pCursor - strHeaders.QueryStr() + 1 );

        hr = strHeaders.Append( "\r\n" );

        if ( FAILED( hr ) )
        {
            return hr;
        }

        //
        // If we were passed a non-NULL pointer for szHeaders, we'll
        // need to append that data to strHeaders.  We'll assume that
        // szHeaders was correctly formed by the caller and skip the
        // "\r\n" games.
        //
        // Else, if we were passed a NULL pointer for szHeaders, we
        // still need to append the final "\r\n" before the entity
        // body.
        //

        if ( szHeaders )
        {
            hr = strHeaders.Append( szHeaders );
        }
        else
        {
            hr = strHeaders.Append( "\r\n" );
        }

        if ( FAILED( hr ) )
        {
            return hr;
        }

        //
        // Finally, set szCookedStatus and szCookedHeaders to point
        // at our new data.
        //

        szCookedStatus = strStatus.QueryStr();
        szCookedHeaders = strHeaders.QueryStr();
    }

    //
    // Set the disconnect disposition
    //

    _pW3Context->SetDisconnect( fDisconnect );

    //
    // Need to clear any existing response
    //

    pResponse->Clear();

    //
    // Setup response from ISAPI
    //

    hr = pResponse->BuildResponseFromIsapi(
        _pW3Context,
        szCookedStatus,
        szCookedHeaders,
        szCookedHeaders ? (DWORD)strlen( szCookedHeaders ) : 0
        );

    if ( FAILED( hr ) )
    {
        return hr;
    }

    //
    // Is the status is access denied, then set the sub status to
    // "Denied by Application"
    //

    if ( pResponse->QueryStatusCode() == HttpStatusUnauthorized.statusCode )
    {
        pResponse->SetStatus( HttpStatusUnauthorized,
                              Http401Application );
    }

    hr =  _pW3Context->SendResponse(
          W3_FLAG_SYNC
          | W3_FLAG_MORE_DATA
          | W3_FLAG_NO_ERROR_BODY
          | W3_FLAG_NO_CONTENT_LENGTH );

    if ( FAILED( hr ) )
    {
        //
        // If SendResponse fails, consider this a non recoverable
        // error and set the error to be WSAECONNRESET for
        // compatibility with legacy ISAPI code.
        //

        hr = HRESULT_FROM_WIN32( WSAECONNRESET );
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE
ISAPI_REQUEST::MapPath(
    BYTE *          szPath,
    DWORD           cbPath,
    DWORD *         pcbBufferRequired,
    BOOL            fUnicode
    )
/*++

Routine Description:

    Maps a URL to a physical path

Arguments:

    szPath            - On entry, the URL to map
                      - On return, the mapped physical path
    cbPath            - The size of szPath
    pcbBufferRequired - On successful return, the number of szPath
                        On error return, the number of bytes needed in szPath
    fUnicode          - If TRUE, szPath should be a UNICODE string on entry
                        and return

Return Value:

    HRESULT

--*/
{
    STACK_STRU(     struUrl,MAX_PATH );
    STACK_STRU(     struPath,MAX_PATH );
    HRESULT         hr;

    //
    // The only current caller for this function is w3isapi.dll, which does
    // parameter validation from any outside code.  So, we can get away with
    // just asserting here.
    //

    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( _pW3Context );
    DBG_ASSERT( szPath || ( cbPath == 0 ) );
    DBG_ASSERT( pcbBufferRequired );

    //
    // This is kind of a weird function - the return string
    // gets copied over the top of the source string.
    //

    if ( fUnicode )
    {
        hr = struUrl.Copy( (LPWSTR)szPath );
    }
    else
    {
        hr = struUrl.CopyA( (LPSTR)szPath );
    }

    if ( FAILED( hr ) )
    {
        return hr;
    }

    hr = W3_STATE_URLINFO::MapPath(
        _pW3Context,
        struUrl,
        &struPath,
        TRUE,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL
        );

    if ( FAILED( hr ) )
    {
        return hr;
    }

    *pcbBufferRequired = cbPath;

    if ( fUnicode )
    {
        return struPath.CopyToBuffer( (LPWSTR)szPath, pcbBufferRequired );
    }
    else
    {
        STACK_STRA (straPath, MAX_PATH );

        if (FAILED(hr = straPath.CopyW(struPath.QueryStr(),
                                       struPath.QueryCCH())))
        {
            return hr;
        }

        return straPath.CopyToBuffer( (LPSTR)szPath, pcbBufferRequired );
    }
}

HRESULT STDMETHODCALLTYPE
ISAPI_REQUEST::MapPathEx(
    BYTE *          szUrl,
    DWORD           ,
    BYTE *          szPath,
    DWORD           cbPath,
    DWORD *         pcbBufferRequired,
    DWORD *         pcchMatchingPath,
    DWORD *         pcchMatchingUrl,
    DWORD *         pdwFlags,
    BOOL            fUnicode
    )
/*++

Routine Description:

    Does path mapping, plus a bit more

Arguments:

    szUrl             - The URL to map
    szPath            - Upon return, the physical path for the URL
    cbPath            - The size of szPath
    pcbBufferRequired - Upon failed return, the size needed for szPath
    pcchMatchingPath  - Upon return, the number of characters in szPath
                        that correspond to the vroot in the URL
    pcchMatchingUrl   - Upon return, the number of characters in szUrl
                        that correspond to the vroot in the URL
    pdwFlags          - Upon return, the metadata AccessPerm flags for the URL
    fUnicode          - If TRUE, the caller wants to talk UNICODE

Return Value:

    HRESULT

--*/
{
    STACK_STRU( struUrl,MAX_PATH );
    STACK_STRU( struPath,MAX_PATH );
    DWORD       cbPathCopied;
    DWORD       cchMatchingPathA;
    DWORD       cchMatchingUrlA;
    HRESULT     hr;

    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( _pW3Context );

    if ( fUnicode )
    {
        hr = struUrl.Copy( (LPWSTR)szUrl );
    }
    else
    {
        hr = struUrl.CopyA( (LPSTR)szUrl );
    }

    if ( FAILED( hr ) )
    {
        return hr;
    }

    //
    // Call W3_STATE_URLINFO::MapPath to do the work
    //

    hr = W3_STATE_URLINFO::MapPath(
        _pW3Context,
        struUrl,
        &struPath,
        TRUE,
        pcchMatchingPath,
        pcchMatchingUrl,
        &cchMatchingPathA,
        &cchMatchingUrlA,
        pdwFlags
        );

    if ( FAILED( hr ) )
    {
        return hr;
    }

    //
    // W3_STATE_URLINFO::MapPath works by looking for a cache entry
    // for the requested szUrl.  If it exists, the returned information
    // will come from the cache data.  This causes a potential problem
    // if the cache contains a URL as "/foo/" and the caller to this
    // function passes "/foo" as the URL.  In this case, *pcchMatchingUrl
    // will be 5, as it's derived from the cache data.  It would be bad,
    // though, to pass a *pcchMatchingUrl greater than the length of the
    // szUrl we were given...
    //

    if ( fUnicode )
    {
        if ( *pcchMatchingUrl &&
            ( ( ((LPWSTR)szUrl)[*pcchMatchingUrl - 1] == L'\0' ) ||
              ( ((LPWSTR)szUrl)[*pcchMatchingUrl - 1] == L'/' ) ) )
        {
            (*pcchMatchingUrl)--;
        }
    }
    else
    {
        //
        // Use the ANSI matching value
        //

        *pcchMatchingUrl = cchMatchingUrlA;

        if ( *pcchMatchingUrl &&
            ( ( szUrl[*pcchMatchingUrl - 1] == '\0' ) ||
              ( szUrl[*pcchMatchingUrl - 1] == '/' ) ) )
        {
            (*pcchMatchingUrl)--;
        }
    }

    if ( pcbBufferRequired )
    {
        if ( fUnicode )
        {
            *pcbBufferRequired = (struPath.QueryCCH() + 1) * sizeof(WCHAR);
        }
        else
        {
            *pcbBufferRequired = struPath.QueryCCH() + 1;
        }
    }

    if ( szPath )
    {
        if ( fUnicode )
        {
            cbPathCopied = cbPath;

            hr = struPath.CopyToBuffer( (LPWSTR)szPath, &cbPathCopied );

            if ( hr == HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER ) &&
                 cbPath >= sizeof(WCHAR) )
            {
                //
                // Copy what we can.
                //
                // Note that there are ISAPI extensions that depend on
                // being able to get a truncated path in the case where
                // MAX_PATH is not sufficient to store the complete data.
                //
                // These extensions depend on using ERROR_INSUFFICIENT_BUFFER
                // as a warning that the data is truncated.
                //

                memset( szPath, 0, cbPath );
                memcpy( szPath, struPath.QueryStr(), cbPath - sizeof(WCHAR) );
            }

        }
        else
        {
            //
            // Convert the path to ANSI
            //

            STACK_STRA(    strAnsiPath, MAX_PATH+1 );
            DWORD        cbAnsiPath;
            DWORD        dwError;

            //
            // Get the ANSI version of the path.
            //

            cbAnsiPath = WideCharToMultiByte( CP_ACP,
                                              0,
                                              struPath.QueryStr(),
                                              -1,
                                              strAnsiPath.QueryStr(),
                                              MAX_PATH,
                                              NULL,
                                              NULL );

            if ( cbAnsiPath == 0 )
            {
                dwError = GetLastError();

                if ( dwError == ERROR_INSUFFICIENT_BUFFER )
                {
                    //
                    // Get the size of the buffer needed and
                    // call it again.
                    //

                    cbAnsiPath = WideCharToMultiByte( CP_ACP,
                                                      0,
                                                      struPath.QueryStr(),
                                                      -1,
                                                      NULL,
                                                      0,
                                                      NULL,
                                                      NULL );

                    if ( cbAnsiPath == 0 )
                    {
                        return HRESULT_FROM_WIN32( GetLastError() );
                    }

                    hr = strAnsiPath.Resize( cbAnsiPath );

                    if ( FAILED( hr ) )
                    {
                        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
                    }

                    cbAnsiPath = WideCharToMultiByte( CP_ACP,
                                                      0,
                                                      struPath.QueryStr(),
                                                      -1,
                                                      strAnsiPath.QueryStr(),
                                                      cbAnsiPath,
                                                      NULL,
                                                      NULL );

                    if ( cbAnsiPath == 0 )
                    {
                        return HRESULT_FROM_WIN32( GetLastError() );
                    }
                }
                else
                {
                    return HRESULT_FROM_WIN32( dwError );
                }
            }

            cbPathCopied = cbPath;
            strAnsiPath.SetLen( cbAnsiPath - 1 );

            hr = strAnsiPath.CopyToBuffer(
                (LPSTR)szPath,
                &cbPathCopied
                );

            if ( hr == HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER ) &&
                 cbPath >= sizeof(CHAR) )
            {
                //
                // Copy what we can.
                //
                // Note that there are ISAPI extensions that depend on
                // being able to get a truncated path in the case where
                // MAX_PATH is not sufficient to store the complete data.
                //
                // These extensions depend on using ERROR_INSUFFICIENT_BUFFER
                // as a warning that the data is truncated.
                //

                memset( szPath, 0, cbPath );
                memcpy( szPath, strAnsiPath.QueryStr(), cbPath - sizeof(CHAR) );
            }
        }
    }

    if ( pcchMatchingPath &&
         !fUnicode )
    {
        //
        // Use the ANSI matching value
        //

        *pcchMatchingPath = cchMatchingPathA;
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE
ISAPI_REQUEST::TransmitFile(
    DWORD64         IsaContext,
    DWORD_PTR       hFile,
    DWORD64         cbOffset,
    DWORD64         cbWrite,
    LPSTR           szStatusCode,
    BYTE *          pHead,
    DWORD           cbHead,
    BYTE *          pTail,
    DWORD           cbTail,
    DWORD           dwFlags
    )
/*++

Routine Description:

    Transmits a file to the client

Arguments:

    IsaContext   - The ISAPI_CONTEXT for this request (opaque)
    hFile        - Handle to file (requires FILE_FLAG_SEQUENTIAL_SCAN)
    cbOffset     - Offset in file to begin transmitting
    cbWrite      - The number of bytes to transmit
    szStatusCode - HTTP status to return (ie "200 OK")
    pHead        - Bytes to send before file data
    cbHead       - The size of pHead
    pTail        - Bytes to send after file data
    cbTail       - The size of pTail
    dwFlags      - HSE_IO_* flags from the caller

Return Value:

    HRESULT

--*/
{
    W3_ISAPI_HANDLER *  pW3IsapiHandler;
    W3_RESPONSE *       pResponse;
    DWORD               dwW3Flags;
    BOOL                fSendAsResponse;
    HRESULT             hr;

    //
    // The only current caller for this function is w3isapi.dll, which does
    // parameter validation from any outside code.  So, we can get away with
    // just asserting here.
    //

    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( _pW3Context );
    DBG_ASSERT( IsaContext );
    DBG_ASSERT( cbHead == 0 || pHead != NULL );
    DBG_ASSERT( cbTail == 0 || pTail != NULL );
    DBG_ASSERT( (HANDLE)hFile != INVALID_HANDLE_VALUE );
    DBG_ASSERT( dwFlags & HSE_IO_ASYNC );
    DBG_REQUIRE( ( pResponse = _pW3Context->QueryResponse() ) != NULL );
    DBG_REQUIRE( ( pW3IsapiHandler = (W3_ISAPI_HANDLER*)_pW3Context->QueryHandler() ) != NULL );

    DBG_ASSERT( _IsapiContext == 0 );
    _IsapiContext = IsaContext;

    //
    // If the caller is OOP, then make copies
    // of the file handle, head data and tail data.  We
    // don't need to make a copy of the status because
    // the BuildResponseFromIsapi function does that itself.
    //

    if ( _fIsOop )
    {
        if ( hFile != NULL )
        {
            hr = pW3IsapiHandler->DuplicateWamProcessHandleForLocalUse(
                (HANDLE)hFile, &_hTfFile
                );

            if ( FAILED( hr ) )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
                goto ErrorExit;
            }

            hFile = (DWORD_PTR)_hTfFile;
        }

        if ( pHead )
        {
            _pTfHead = (LPBYTE)LocalAlloc( LPTR, cbHead );

            if ( !_pTfHead )
            {
                hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
                goto ErrorExit;
            }

            memcpy( _pTfHead, pHead, cbHead );

            pHead = _pTfHead;
        }

        if ( pTail )
        {
            _pTfTail = (LPBYTE)LocalAlloc( LPTR, cbTail );

            if ( !_pTfTail )
            {
                hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
                goto ErrorExit;
            }

            memcpy( _pTfTail, pTail, cbTail );

            pTail = _pTfTail;
        }
    }

    //
    // Convert the HSE_IO_* flags to W3_FLAG_* flags
    //

    // Init the flags for sending
    dwW3Flags = W3_FLAG_ASYNC | W3_FLAG_MORE_DATA;

    // If disconnect flag is not set, then we'll keep the connection open
    if ( !( dwFlags & HSE_IO_DISCONNECT_AFTER_SEND ) )
    {
        _pW3Context->SetDisconnect( FALSE );
    }
    else
    {
        _pW3Context->SetDisconnect( TRUE );
    }

    //
    // Clear any previous chunks from the response
    //

    pResponse->Clear();

    //
    // If HSE_IO_SEND_HEADERS is specified, then we're sending
    // the initial part of the response (and pHead will be an
    // LPSTR containing the headers that the caller wants to
    // send), else we'll be sending this data completely as
    // entity data.
    //

    fSendAsResponse = !!( dwFlags & HSE_IO_SEND_HEADERS );

    if ( fSendAsResponse )
    {
        //
        // Set the status using data from the caller
        //

        hr = pResponse->BuildResponseFromIsapi( _pW3Context,
                                                szStatusCode,
                                                (LPSTR)pHead,
                                                cbHead );
        if ( FAILED( hr ) )
        {
            goto ErrorExit;
        }

        //
        // Is the status is access denied, then set the sub status to
        // "Denied by Application"
        //

        if ( pResponse->QueryStatusCode() == HttpStatusUnauthorized.statusCode )
        {
            pResponse->SetStatus( HttpStatusUnauthorized,
                                  Http401Application );
        }
    }
    else
    {
        //
        // Do something with pHead if provided
        //

        if ( cbHead )
        {
            hr = pResponse->AddMemoryChunkByReference(
                    pHead,
                    cbHead
                );

            if ( FAILED( hr ) )
            {
                goto ErrorExit;
            }
        }
    }

    //
    // Now add the file handle to the response.  Note that it's
    // allowed for the caller to pass a NULL handle.  In that case,
    // we won't add it, and any present pHead and pTail will still
    // get sent to the client.
    //

    if ( hFile )
    {
        hr = pResponse->AddFileHandleChunk(
                (HANDLE)hFile,
                cbOffset,
                cbWrite
                );

        if ( FAILED( hr ) )
        {
            goto ErrorExit;
        }
    }

    //
    // Add the tail if provided
    //

    if ( cbTail )
    {
        hr = pResponse->AddMemoryChunkByReference(
            pTail,
            cbTail
            );

        if ( FAILED( hr ) )
        {
            goto ErrorExit;
        }
    }

    //
    // Ok, now that the stuff is all set up, send it, either
    // as a response or as entity
    //

    if ( _fIsOop )
    {
        //
        // This reference insures that if the OOP host crashes and
        // COM releases all the OOP-held references, that this
        // object will survive until the I/O completion occurs.
        //

        AddRef();
    }

    if ( fSendAsResponse )
    {
        hr = _pW3Context->SendResponse( dwW3Flags
                                        | W3_FLAG_NO_ERROR_BODY
                                        | W3_FLAG_NO_CONTENT_LENGTH 
                                        | W3_FLAG_MORE_DATA );
    }
    else
    {
        hr = _pW3Context->SendEntity( dwW3Flags 
                                      | W3_FLAG_MORE_DATA );
    }

    if ( FAILED( hr ) )
    {

        //
        // If SendEntity or SendResponse fail, consider this
        // a non recoverable error and set the error to be
        // WSAECONNRESET for compatibility with legacy ISAPI code.
        //

        hr = HRESULT_FROM_WIN32( WSAECONNRESET );

        if ( _fIsOop )
        {
            //
            // Release the above reference, since no I/O completion will
            // occur.
            //

            Release();
        }

        goto ErrorExit;
    }

    return hr;

ErrorExit:

    DBG_ASSERT( FAILED( hr ) );

    if ( _IsapiContext != 0 )
    {
        _IsapiContext = 0;
    }

    if ( _fIsOop )
    {
        if ( _hTfFile != NULL && _hTfFile != INVALID_HANDLE_VALUE )
        {
            CloseHandle( _hTfFile );
            _hTfFile = INVALID_HANDLE_VALUE;
        }

        if ( _pTfHead )
        {
            LocalFree( _pTfHead );
            _pTfHead = NULL;
        }

        if ( _pTfTail )
        {
            LocalFree( _pTfTail );
            _pTfTail = NULL;
        }
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE
ISAPI_REQUEST::SetConnectionClose(
    BOOL    fClose
    )
/*++

Routine Description:

    Sets the W3_CONTEXT to close (or not) connection
    upon completion of the response.

Arguments:

    fClose - BOOL to pass to SetDisconnect

Return Value:

    HRESULT

--*/
{
    DBG_ASSERT( CheckSignature() );

    _pW3Context->SetDisconnect( fClose );

    return NOERROR;
}

HRESULT STDMETHODCALLTYPE
ISAPI_REQUEST::SendRedirect(
    LPCSTR          szLocation,
    BOOL            fDisconnect
    )
/*++

Routine Description:

    Sends a 302 redirect message to the client

Arguments:

    szLocation - The URL to redirect to.
    fDisconnect - If TRUE, the close connection

Return Value:

    HRESULT

--*/
{
    STACK_STRA(     strLocation, MAX_PATH );
    HTTP_STATUS httpStatus = { 302, REASON("Object Moved") };
    HRESULT         hr;

    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( _pW3Context );
    DBG_ASSERT( szLocation );

    //
    // Use W3_CONTEXT::SetupHttpRedirect to build the redirect
    // response.
    //

    hr = strLocation.Copy( szLocation );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    _pW3Context->SetDisconnect( fDisconnect );

    hr = _pW3Context->SetupHttpRedirect(
        strLocation,
        FALSE,   // Don't include the original query string
        httpStatus
        );

    if ( FAILED( hr ) )
    {
        return hr;
    }

    //
    // Now send the response synchronously (the calling ISAPI might
    // do something silly like send more data after this function
    // returns, so we can't do it asynchronously.)
    //

    hr =  _pW3Context->SendResponse(
          W3_FLAG_SYNC |
          W3_FLAG_MORE_DATA
          );

    if ( FAILED( hr ) )
    {
        //
        // If SendResponse fails, consider this a non recoverable
        // error and set the error to be WSAECONNRESET for
        // compatibility with legacy ISAPI code.
        //

        hr = HRESULT_FROM_WIN32( WSAECONNRESET );
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE
ISAPI_REQUEST::GetCertificateInfoEx(
    DWORD           cbAllocated,
    DWORD *         pdwCertEncodingType,
    BYTE *          pbCertEncoded,
    DWORD *         pcbCertEncoded,
    DWORD *         pdwCertificateFlags
    )
/*++

Routine Description:

    Gets certificate info

Arguments:

    cbAllocated         - The size of the pbCertEncoded buffer
    pdwCertEncodingType - Upon return, the cert encoding type
    pbCertEncoded       - Upon return, contains the cert info
    pcbCertEncoded      - Upon successful return, the number of bytes
                          in pbCertEncoded.  On failed return, the number
                          of bytes required to contain pbCertEncoded
    pdwCertificateFlags - Upon return, the certificate flags

Return Value:

    HRESULT

--*/
{
    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( _pW3Context );

    return _pW3Context->GetCertificateInfoEx( cbAllocated,
                                              pdwCertEncodingType,
                                              pbCertEncoded,
                                              pcbCertEncoded,
                                              pdwCertificateFlags );
}

HRESULT STDMETHODCALLTYPE
ISAPI_REQUEST::AppendLog(
    LPSTR           szExtraParam,
    USHORT          StatusCode
    )
/*++

Routine Description:

    Append the string to the querystring logged

Arguments:

    szExtraParam - the string to be appended

Return Value:

    HRESULT

--*/
{
    HRESULT hr;

    //
    // The only current caller for this function is w3isapi.dll,
    // which validates the parameters.
    //

    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( _pW3Context );

    if (StatusCode != 0)
    {
        _pW3Context->QueryResponse()->SetStatusCode(StatusCode);
    }

    if (szExtraParam[0] != '\0')
    {
        STRA &strLogParam = _pW3Context->QueryMainContext()
                                ->QueryLogContext()->m_strLogParam;
        if (strLogParam.IsEmpty())
        {
            STACK_STRU (strQueryString, 128);

            if (FAILED(hr = _pW3Context->QueryRequest()->GetQueryStringA(&strLogParam)))
            {
                return hr;
            }
        }

        return strLogParam.Append(szExtraParam);
    }

    return S_OK;
}

HRESULT STDMETHODCALLTYPE
ISAPI_REQUEST::ExecuteUrl(
    DWORD64         IsaContext,
    EXEC_URL_INFO * pExecUrlInfo
    )
/*++

Routine Description:

    Execute a child request

Arguments:

    ISaContext   - The ISAPI_CONTEXT for this request (opaque)
    pExecUrlInfo - Description of request to execute

Return Value:

    HRESULT

--*/
{
    W3_ISAPI_HANDLER *      pIsapiHandler = NULL;
    HRESULT                 hr = NO_ERROR;
    BOOL                    fAsync;
    BYTE *                  pbOriginalEntity = NULL;

    //
    // The parameters (i.e. HSE_EXEC_URL_INFO structure) was validated on
    // the W3ISAPI.DLL side, so we can make assumptions about validity
    //

    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( pExecUrlInfo != NULL );
    DBG_ASSERT( _pW3Context );

    DBG_REQUIRE( ( pIsapiHandler = (W3_ISAPI_HANDLER*)_pW3Context->QueryHandler() ) != NULL );

    fAsync = TRUE;

    DBG_ASSERT( fAsync == !!IsaContext );

    if ( fAsync )
    {
        DBG_ASSERT( _IsapiContext == 0 );
        _IsapiContext = IsaContext;
    }

    //
    // If we're OOP, we need to dup the user token (if there) and the
    // entity body (if there and this is async request)
    //

    if ( _fIsOop )
    {
        //
        // Duplicate the user token if there
        //

        if ( pExecUrlInfo->pUserInfo != NULL &&
             pExecUrlInfo->pUserInfo->hImpersonationToken != NULL )
        {
            DBG_ASSERT( _hExecUrlToken == NULL );

            hr = pIsapiHandler->DuplicateWamProcessHandleForLocalUse(
                            (HANDLE) pExecUrlInfo->pUserInfo->hImpersonationToken,
                            &_hExecUrlToken );
            if ( FAILED( hr ) )
            {
                goto Finished;
            }

            pExecUrlInfo->pUserInfo->hImpersonationToken = reinterpret_cast<DWORD_PTR> (_hExecUrlToken);
        }

        //
        // Duplicate the entity buffer if there and this is async request
        //

        if ( fAsync &&
             pExecUrlInfo->pEntity != NULL &&
             pExecUrlInfo->pEntity->lpbData != NULL &&
             pExecUrlInfo->pEntity->cbAvailable > 0 )
        {
            DBG_ASSERT( _pbExecUrlEntity == NULL );

            _pbExecUrlEntity = LocalAlloc( LMEM_FIXED,
                                           pExecUrlInfo->pEntity->cbAvailable );
            if ( _pbExecUrlEntity == NULL )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
                goto Finished;
            }

            memcpy( _pbExecUrlEntity,
                    pExecUrlInfo->pEntity->lpbData,
                    pExecUrlInfo->pEntity->cbAvailable );

            //
            // Remember the original pointer to entity body.  We must
            // maintain it on exit so that RPC unmarshalls the correct
            // buffer :-(
            //

            pbOriginalEntity = pExecUrlInfo->pEntity->lpbData;

            pExecUrlInfo->pEntity->lpbData = (LPBYTE) _pbExecUrlEntity;
        }
    }

    //
    // Execute the darn thing
    //

    if ( _fIsOop && fAsync )
    {
        //
        // This reference insures that if the OOP host crashes and
        // COM releases all the OOP-held references, that this
        // object will survive until the I/O completion occurs.
        //

        AddRef();
    }

    hr = _pW3Context->CleanIsapiExecuteUrl( pExecUrlInfo );

    if ( FAILED( hr ) )
    {
        if ( _fIsOop && fAsync )
        {
            //
            // Release the above reference, since no I/O completion will
            // occur.
            //

            Release();
        }
    }

    //
    // If nothing is pending, then we can clean up any dup'd stuff now
    //

Finished:

    if ( FAILED( hr ) &&
         fAsync &&
         _IsapiContext != 0 )
    {
        _IsapiContext = 0;
    }

    if ( FAILED( hr ) || !fAsync )
    {
        if ( _pbExecUrlEntity != NULL )
        {
            LocalFree( _pbExecUrlEntity );
            _pbExecUrlEntity = NULL;
        }

        if ( _hExecUrlToken != NULL )
        {
            CloseHandle( _hExecUrlToken );
            _hExecUrlToken = NULL;
        }
    }

    //
    // Regardless of return status, we need to restore the entity pointer
    // if needed so RPC unmarshalls the right thing
    //

    if ( pbOriginalEntity != NULL )
    {
        DBG_ASSERT( pExecUrlInfo != NULL );
        DBG_ASSERT( pExecUrlInfo->pEntity != NULL );

        pExecUrlInfo->pEntity->lpbData = pbOriginalEntity;
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE
ISAPI_REQUEST::SendCustomError(
    DWORD64         IsaContext,
    CHAR *          pszStatus,
    USHORT          uHttpSubError
)
/*++

Routine Description:

    Send a custom error (if available, otherwise error out with
    ERROR_FILE_NOT_FOUND)

Arguments:

    IsaContext      - The ISAPI_CONTEXT for this request (opaque)
    pszStatus       - Status line
    uHttpSubError   - Sub error

Return Value:

    HRESULT

--*/
{
    HRESULT                 hr;
    BOOL                    fAsync;
    HSE_CUSTOM_ERROR_INFO   customErrorInfo;

    DBG_ASSERT( CheckSignature() );

    //
    // If we have a non-NULL IsaContext, then this is an async request
    //

    fAsync = !!IsaContext;

    if ( fAsync )
    {
        DBG_ASSERT( _IsapiContext == 0 );
        _IsapiContext = IsaContext;
    }

    if ( _fIsOop && fAsync )
    {
        //
        // This reference insures that if the OOP host crashes and
        // COM releases all the OOP-held references, that this
        // object will survive until the I/O completion occurs.
        //

        AddRef();
    }

    customErrorInfo.pszStatus = pszStatus;
    customErrorInfo.uHttpSubError = uHttpSubError;
    customErrorInfo.fAsync = fAsync;

    hr = _pW3Context->CleanIsapiSendCustomError( &customErrorInfo );
    if ( FAILED( hr ) )
    {
        if ( fAsync && _IsapiContext != 0 )
        {
            _IsapiContext = 0;
        }

        if ( _fIsOop && fAsync )
        {
            //
            // Release the above reference, since no I/O completion
            // will ever happen.
            //

            Release();
        }
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE
ISAPI_REQUEST::GetExecuteUrlStatus(
    USHORT *        pChildStatusCode,
    USHORT *        pChildSubErrorCode,
    DWORD *         pChildWin32Error
    )
/*++

Routine Description:

    Get the status of the last child execute

Arguments:

    pChildStatusCode   - Filled with status code of child execute
    pChildSubErrorCode - Filled sub error if applicable
    pChildWin32Error   - Filled last Win32 saved for child request

Return Value:

    HRESULT

--*/
{
    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( _pW3Context != NULL );

    _pW3Context->QueryChildStatusAndError( pChildStatusCode,
                                           pChildSubErrorCode,
                                           pChildWin32Error );

    return NO_ERROR;
}

HRESULT STDMETHODCALLTYPE
ISAPI_REQUEST::VectorSend(
    DWORD64         IsaContext,
    BOOL            fDisconnect,
    LPSTR           pszStatus,
    LPSTR           pszHeaders,
    VECTOR_ELEMENT *pElements,
    DWORD           nElementCount,
    BOOL            fFinalSend,
    BOOL            fCacheResponse
    )
/*++
  Routine description

    Do a vector send of multiple file handle/memory chunks

  Parameters

    IsaContext      - The ISAPI_CONTEXT for this request (opaque)
    fDisconnect     - Do we disconnect after send
    pszStatus       - The status to be sent if any
    pszHeaders      - The headers to be sent if any
    pElements       - The file handle/memory chunks to be sent
    nElementCount   - The number of these chunks
    fFinalSend      - Should we tell http.sys on behalf of the ISAPI that this
                      is the final send for this response
    fCacheResponse  - Should we ask http.sys to cache this response

  Return value

    HRESULT
--*/
{
    W3_ISAPI_HANDLER *  pW3IsapiHandler;
    HRESULT             hr = S_OK;
    DWORD               cchHeaders = 0;
    W3_RESPONSE *       pResponse;
    BOOL                fAsync;
    BOOL                fFragmentCacheUsed = FALSE;
    WCHAR *             pszFullFragmentName;
    DWORD               i;
    BOOL                fSwitchToParsed = FALSE;

    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( _pW3Context );
    DBG_REQUIRE( ( pResponse = _pW3Context->QueryResponse() ) != NULL );
    DBG_REQUIRE( ( pW3IsapiHandler = (W3_ISAPI_HANDLER*)_pW3Context->QueryHandler() ) != NULL );

    //
    // A non-NULL context indicates async request
    //

    fAsync = !!IsaContext;

    if ( fAsync )
    {
        DBG_ASSERT( _IsapiContext == 0 );
        _IsapiContext = IsaContext;
    }

    if (pszHeaders != NULL)
    {
        cchHeaders = (DWORD)strlen(pszHeaders);
    }

    if ( _fIsOop )
    {
        //
        // Need to make copies of the file handles and maybe even memory buffer
        //
        if ( fAsync && pszHeaders )
        {
            _pTfHead = (LPBYTE)LocalAlloc(LMEM_FIXED, cchHeaders + 1 );

            if ( _pTfHead == NULL )
            {
                hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
                goto Exit;
            }

            memcpy( _pTfHead, pszHeaders, cchHeaders + 1 );

            pszHeaders = (LPSTR)_pTfHead;
        }

        if (!_bufVectorElements.Resize(nElementCount * sizeof(VECTOR_ELEMENT)))
        {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            goto Exit;
        }
        ZeroMemory(_bufVectorElements.QueryPtr(),
                   nElementCount * sizeof(VECTOR_ELEMENT));

        VECTOR_ELEMENT *pNewElements = (VECTOR_ELEMENT *)_bufVectorElements.QueryPtr();

        for (i=0; i<nElementCount; i++)
        {
            if (pElements[i].hFile)
            {
                //
                // File handle chunk
                //
                hr = pW3IsapiHandler->DuplicateWamProcessHandleForLocalUse(
                                        (HANDLE)pElements[i].hFile,
                                        (HANDLE *)&pNewElements[i].hFile);
                if (FAILED(hr))
                {
                    goto Exit;
                }
                pNewElements[i].cbOffset = pElements[i].cbOffset;
                pNewElements[i].cbFileSize = pElements[i].cbFileSize;
            }
            else if (pElements[i].pBuffer)
            {
                //
                // Memory buffer chunk
                //
                if (fAsync)
                {
                    //
                    // Need to copy the buffer too
                    //
                    pNewElements[i].pBuffer = (BYTE *)LocalAlloc(LMEM_FIXED, pElements[i].cbBufSize);
                    if (pNewElements[i].pBuffer == NULL)
                    {
                        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
                        goto Exit;
                    }

                    memcpy(pNewElements[i].pBuffer,
                           pElements[i].pBuffer,
                           pElements[i].cbBufSize);
                }
                else
                {
                    pNewElements[i].pBuffer = pElements[i].pBuffer;
                }

                pNewElements[i].cbBufSize = pElements[i].cbBufSize;
            }

            _nElementCount++;
        }

        pElements = pNewElements;
    }

    //
    // First Clear any goo left from a previous Send
    //
    pResponse->Clear();

    //
    // We must always obey the fDisconnect flag
    // assuming the SSFVectorSend always correctly sets it.
    //

    _pW3Context->SetDisconnect(fDisconnect);

    //
    // Now do the real work
    //
    if (pszStatus != NULL)
    {
        hr = pResponse->BuildResponseFromIsapi( _pW3Context,
                                                pszStatus,
                                                pszHeaders,
                                                cchHeaders );
        if (FAILED(hr))
        {
            goto Exit;
        }

        //
        // Is the status is access denied, then set the sub status to
        // "Denied by Application"
        //

        if ( pResponse->QueryStatusCode() == HttpStatusUnauthorized.statusCode )
        {
            pResponse->SetStatus( HttpStatusUnauthorized,
                                  Http401Application );
        }
    }

    for (i=0; i<nElementCount; i++)
    {
        if (pElements[i].hFile)
        {
            hr = pResponse->AddFileHandleChunk((HANDLE)pElements[i].hFile,
                                               pElements[i].cbOffset,
                                               pElements[i].cbFileSize);
        }
        else if (pElements[i].pBuffer)
        {
            hr = pResponse->AddMemoryChunkByReference(pElements[i].pBuffer,
                                                      pElements[i].cbBufSize);
        }
        else
        {
            if (FAILED(hr = _pW3Context->QueryHeaderBuffer()->AllocateSpace(
                                pElements[i].pszFragmentName,
                                (DWORD)wcslen(pElements[i].pszFragmentName),
                                &pszFullFragmentName)))
            {
                goto Exit;
            }

            hr = pResponse->AddFragmentChunk(pszFullFragmentName,
                                             (USHORT)wcslen(pszFullFragmentName) * sizeof(WCHAR));

            fFragmentCacheUsed = TRUE;
        }

        if (FAILED(hr))
        {
            goto Exit;
        }
    }

    if (fFragmentCacheUsed)
    {
        //
        // Cannot used fragment-cache if using either compression or send-raw data filters
        //
        W3_METADATA *pMetaData = _pW3Context->QueryUrlContext()->QueryMetaData();
        if ( !_pW3Context->QueryDoneWithCompression() &&
             pMetaData->QueryDoDynamicCompression() )
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
            goto Exit;
        }

        if ( _pW3Context->IsNotificationNeeded( SF_NOTIFY_SEND_RAW_DATA ) )
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
            goto Exit;
        }

        //
        // We also cannot generate content-length in this case
        //
        _pW3Context->QueryMainContext()->SetShouldGenerateContentLength( FALSE );
    }

    if ( _fIsOop && fAsync )
    {
        //
        // This reference insures that if the OOP host crashes and
        // COM releases all the OOP-held references, that this
        // object will survive until the I/O completion occurs.
        //

        AddRef();
    }

    if (pszStatus != NULL)
    {
        //
        // If the response is to be cached, then we'll need to switch to
        // parsed mode. 
        //
        
        if (fCacheResponse)
        {
            _fCacheResponse = TRUE;
            fSwitchToParsed = TRUE;
        }
        
        //
        // If the ISAPI is doing a keep-alive single-send, is 
        // referencing a fragment (1+), and did not specify a 
        // content-length header themselves, then switch to
        // parsed so that HTTP.SYS can do the work for us
        //
        
        if (fFragmentCacheUsed &&
            !fSwitchToParsed &&
            fFinalSend &&
            !fDisconnect &&
            pszHeaders != NULL &&
            strstr( pszHeaders, "Content-Length: " ) == NULL &&
            strstr( pszHeaders, "Transfer-Encoding: chunked" ) == NULL)
        {
            fSwitchToParsed = TRUE;   
        }
        
        //
        // Do the switch
        //
          
        if (fSwitchToParsed)
        {            
            hr = _pW3Context->QueryResponse()->SwitchToParsedMode();
            if (FAILED(hr))
            {
                Release();
                goto Exit;   
            }
        }

        hr = _pW3Context->SendResponse( (fAsync ? W3_FLAG_ASYNC : W3_FLAG_SYNC)
                                        | (fFinalSend ? 0 : W3_FLAG_MORE_DATA)
                                        | W3_FLAG_NO_ERROR_BODY
                                        | W3_FLAG_NO_CONTENT_LENGTH );
    }
    else
    {
        hr = _pW3Context->SendEntity( (fAsync ? W3_FLAG_ASYNC : W3_FLAG_SYNC)
                                     | (fFinalSend ? 0 : W3_FLAG_MORE_DATA) );
    }

    if (FAILED(hr))
    {
        //
        // If SendEntity or SendResponse fail, consider this
        // a non recoverable error and set the error to be
        // WSAECONNRESET for compatibility with legacy ISAPI code.
        //

        hr = HRESULT_FROM_WIN32( WSAECONNRESET );

        if ( _fIsOop && fAsync )
        {
            //
            // Release the above reference, since no I/O completion will
            // occur.
            //

            Release();
        }
    }

 Exit:

    if ( FAILED( hr ) && fAsync && _IsapiContext != 0 )
    {
        _IsapiContext = 0;
    }

    if ( _fIsOop &&
        (FAILED(hr) || !fAsync) )
    {
        //
        // Need to destroy handles/memory buffers we copied
        //
        if ( _pTfHead )
        {
            LocalFree( _pTfHead );
            _pTfHead = NULL;
        }

        for (i=0; i<_nElementCount; i++)
        {
            if (pElements[i].hFile)
            {
                CloseHandle((HANDLE)pElements[i].hFile);
            }
            else if (pElements[i].pBuffer && fAsync)
            {
                LocalFree(pElements[i].pBuffer);
            }
        }

        _nElementCount = 0;
    }

    return hr;
}

HRESULT
ISAPI_REQUEST::GetCustomError(
        DWORD dwError,
        DWORD dwSubError,
        DWORD dwBufferSize,
        BYTE  *pvBuffer,
        DWORD *pdwRequiredBufferSize,
        BOOL  *pfIsFileError,
        BOOL  *pfSendErrorBody)

/*++

Routine Description:

    Finds the CustomError for this error and subError.  The results are returned
    in pvBuffer provided there is enough buffer space.  The amount of buffer space
    required is returned in pdwRequestBufferSize regardless.

Arguments:


    dwError                 - major error (e.g. 500)
    dwSubError              - sub error (e.g. 13)
    dwBufferSize            - size, in bytes, of buffer at pvBuffer
    pvBuffer                - pointer to buffer for result
    pdwRequiredBufferSize   - amount of buffer used/need
    pfIsFileError           - return boolean if custom error is a filename
    pfSendErrorBody         - upon return, TRUE if error body should be sent

Return Value:

    HRESULT

--*/
{
    HRESULT         hr = NOERROR;
    W3_METADATA     *pMetadata = NULL;
    LPSTR           pMimeStr = "text/html";

    STACK_STRA(mimeStr, 64);

    STACK_STRU(             strError, 64 );

    DBG_ASSERT( CheckSignature() );

    // first dig out the W3 Metadata pointer

    pMetadata = _pW3Context->QueryUrlContext()->QueryMetaData();
    DBG_ASSERT( pMetadata != NULL );

    // get the custom error for this error code

    hr = pMetadata->FindCustomError( (USHORT)dwError,
                                     (USHORT)dwSubError,
                                     pfIsFileError,
                                     &strError );

    // if successful, and the custom error is a file, we need to
    // get the file's mime type

    if (SUCCEEDED(hr) && *pfIsFileError) {

        // lookup the MIME_ENTRY for this file.

        if (SUCCEEDED(SelectMimeMappingForFileExt(strError.QueryStr(),pMetadata->QueryMimeMap(), &mimeStr))) {
            pMimeStr = mimeStr.QueryStr();
        }
    }

    // if found, convert the UNICODE string to ANSI

    if (SUCCEEDED(hr)) {

        int ret;

        ret = WideCharToMultiByte(CP_ACP,
                                  0,
                                  strError.QueryStr(),
                                  -1,
                                  (LPSTR)pvBuffer,
                                  dwBufferSize,
                                  NULL,
                                  NULL);

        *pdwRequiredBufferSize = ret;

        // check return.  If zero, then the conversion failed.
        // GetLastError() contains the error.

        if (ret == 0) {

            DWORD   winError = GetLastError();

            // if InsufBuff, then call again to get the required size

            if (winError == ERROR_INSUFFICIENT_BUFFER) {

                *pdwRequiredBufferSize = WideCharToMultiByte(CP_ACP,
                                                             0,
                                                             strError.QueryStr(),
                                                             -1,
                                                             NULL,
                                                             0,
                                                             NULL,
                                                             NULL);

                // if the error is a filename, then include in the required
                // buffer size the length of the mime string

                if (*pfIsFileError) {

                    *pdwRequiredBufferSize += (DWORD)strlen(pMimeStr) + 1;
                }
            }
            // in any case, make a HRESULT from the win32 error and return that

            hr = HRESULT_FROM_WIN32(winError);
        }

        // if we continue to be successful, the next step is to put
        // the mime string after the null byte of the file name

        if (SUCCEEDED(hr) && *pfIsFileError) {

            int fileLen = (int)strlen((char *)pvBuffer);

            // make sure we have enough buffer

            if ((fileLen + strlen(pMimeStr) + 2) > dwBufferSize) {

                hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            }
            else {

                // looks like we do.  Copy the mime string in

                strcpy(&((char *)pvBuffer)[fileLen+1],pMimeStr);

                pdwRequiredBufferSize += strlen(pMimeStr) + 1;
            }
        }
    }

    if ( pfSendErrorBody != NULL )
    {
        *pfSendErrorBody = _pW3Context->QuerySendErrorBody();
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE
ISAPI_REQUEST::TestConnection(
    BOOL    *pfIsConnected
    )
/*++

Routine Description:

    returns state of the connection (TRUE = opened, FALSE = closed)

Arguments:

    pfIsConnected - sets to TRUE if connection is still open,
                    FALSE if it was closed already

Return Value:

    HRESULT

--*/
{
    HRESULT             hr = NOERROR;
    W3_CONNECTION *     pConnection = NULL;
    W3_MAIN_CONTEXT *   pMainContext = NULL;

    DBG_ASSERT( CheckSignature() );

    DBG_ASSERT( _pW3Context != NULL );
    pMainContext = _pW3Context->QueryMainContext();

    DBG_ASSERT( pMainContext != NULL );
    pConnection = pMainContext->QueryConnection( TRUE );

    if ( pConnection == NULL )
    {
        //
        // Issue 02/08/2001 jaroslad:
        // QueryConnection currently doesn't have a way to return
        // error that occured. For now assume that out of memory
        // occured
        //

        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);

        //
        // we will not touch pfIsConnected in the case of error
        // it is caller's responsibility to check if this call
        // succeeded before using pfIsConnected
        //
    }
    else
    {
        *pfIsConnected =  pConnection->QueryConnected();
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE
ISAPI_REQUEST::GetSspiInfo(
    BYTE *pCredHandle,
    DWORD cbCredHandle,
    BYTE *pCtxtHandle,
    DWORD cbCtxtHandle)
/*++

Routine Description:

    Returns SSPI info about the request

Arguments:

    pCredHandle  - Upon return, contains the credential handle
    cbCredHandle - The size of pCredHandle
    pCtxtHandle  - Upon return, contains the context handle
    cbCtxtHandle - The size of pCtxtHandle

Return Value:

    HRESULT

--*/
{
    W3_USER_CONTEXT *       pUserContext;

    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( _pW3Context != NULL );

    if ( _fIsOop )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
    }

    pUserContext = _pW3Context->QueryUserContext();
    DBG_ASSERT( pUserContext != NULL );

    return pUserContext->GetSspiInfo( pCredHandle,
                                      cbCredHandle,
                                      pCtxtHandle,
                                      cbCtxtHandle );
}

HRESULT STDMETHODCALLTYPE
ISAPI_REQUEST::QueryToken(
    BYTE *szUrl,
    DWORD,
    DWORD dwTokenType,
    DWORD64 *pToken,
    BOOL fUnicode)
/*++

Routine Description:

    Returns the VR token for the request

Arguments:

    szUrl       - The URL for which we need to get the token
    cbUrl       - The size of szUrl
    dwTokenType - Either TOKEN_VR_TOKEN or TOKEN_ANONYMOUS_TOKEN
    pToken      - Upon return, points to the resulting token
    fUnicode    - If TRUE, szUrl is UNICODE, else it's ANSI

Return Value:

    HRESULT

--*/
{
    STACK_STRU(         struUrl,MAX_PATH );
    W3_URL_INFO *       pUrlInfo = NULL;
    W3_METADATA *       pMetaData = NULL;
    TOKEN_CACHE_ENTRY * pTokenEntry = NULL;
    HANDLE              hToken = NULL;
    HANDLE              hTokenLocalDuplicate = NULL;
    HRESULT             hr;
    BOOL                fSuccess;

    DBG_ASSERT( _pW3Context );
    DBG_ASSERT( szUrl );
    DBG_ASSERT( pToken );
    DBG_ASSERT( dwTokenType == TOKEN_VR_TOKEN ||
                dwTokenType == TOKEN_ANONYMOUS_TOKEN );

    //
    // Get the metadata for the specified URL
    //

    if ( fUnicode )
    {
        hr = struUrl.Copy( (LPWSTR)szUrl );
    }
    else
    {
        hr = struUrl.CopyA( (LPSTR)szUrl );
    }

    if ( FAILED( hr ) )
    {
        return hr;
    }

    DBG_ASSERT( g_pW3Server->QueryUrlInfoCache() != NULL );

    hr = g_pW3Server->QueryUrlInfoCache()->GetUrlInfo(
                                        _pW3Context,
                                        struUrl,
                                        &pUrlInfo );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    DBG_ASSERT( pUrlInfo != NULL );

    pMetaData = pUrlInfo->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );

    //
    // Assume that the VR token is NULL, unless we can determine otherwise
    //

    *pToken = NULL;

    //
    // Ok, so now let's get the token
    //

    if ( dwTokenType == TOKEN_VR_TOKEN )
    {
        hr = pMetaData->GetAndRefVrAccessToken( &pTokenEntry );
        if( FAILED( hr ) )
        {
           return hr;
        }
    }
    else if ( dwTokenType == TOKEN_ANONYMOUS_TOKEN )
    {
        hr = pMetaData->GetAndRefAnonymousToken( &pTokenEntry );
        if( FAILED( hr ) )
        {
           return hr;
        }
    }
    else
    {
        DBG_ASSERT( FALSE );
    }

    if ( pTokenEntry != NULL )
    {
        hToken = pTokenEntry->QueryImpersonationToken();
    }

    if ( hToken )
    {
        //
        // Need to duplicate the handle.  This is really only necessary for
        // OOP requests, but we need to do it for both, so that the extension
        // doesn't need to worry about knowing if it's inproc or not before
        // deciding if it needs to close the handle.
        //

        fSuccess = DupTokenWithSameImpersonationLevel(
            hToken,
            MAXIMUM_ALLOWED,
            TokenPrimary,
            &hTokenLocalDuplicate
            );

        if( fSuccess )
        {
            if( _fIsOop )
            {
                HANDLE  hTokenRemote = NULL;

                fSuccess = DuplicateHandle(
                                GetCurrentProcess(),
                                hTokenLocalDuplicate,
                                _pWamProcess->QueryProcess(),
                                &hTokenRemote,
                                0,
                                FALSE,
                                DUPLICATE_SAME_ACCESS
                                );

                CloseHandle(hTokenLocalDuplicate);
                hTokenLocalDuplicate = NULL;

                *pToken = (DWORD64)hTokenRemote;
            }
            else
            {
                *pToken = reinterpret_cast<DWORD64>(hTokenLocalDuplicate);
            }
        }
    }

    pUrlInfo->DereferenceCacheEntry();

    if ( pTokenEntry != NULL )
    {
        pTokenEntry->DereferenceCacheEntry();
        pTokenEntry = NULL;
    }
    
    return hr;
}

HRESULT STDMETHODCALLTYPE
ISAPI_REQUEST::ReportAsUnhealthy(
    BYTE *szImage,
    DWORD,
    BYTE *szReason,
    DWORD cbReason)
/*++

Routine Description:

    Handles an ISAPI reporting itself as unhealthy

Arguments:

    szImage  - A UNICODE string with the ISAPI image name
    cbImage  - The size of szImage
    szReason - A UNICODE string from the ISAPI indicating the problem
    cbReason - The size of szReason

Return Value:

    HRESULT

--*/
{
    W3_ISAPI_HANDLER *  pW3IsapiHandler;
    const WCHAR  *      pszEventLog[2];

    DBG_ASSERT( _pW3Context );
    DBG_ASSERT( szImage );
    DBG_ASSERT( cbReason == 0 || szReason != NULL );
    DBG_REQUIRE( ( pW3IsapiHandler = (W3_ISAPI_HANDLER*)_pW3Context->QueryHandler() ) != NULL );


    //
    // First, log the event.  After we set the unhealthy flag,
    // this process could get terminated at any time.
    //
    // There are two possible messages to log, depending on
    // whether the extension gave us a reason for being
    // unhealthy.
    //

    pszEventLog[0] = reinterpret_cast<WCHAR*>( szImage );

    if ( cbReason > 0 )
    {
        pszEventLog[1] = reinterpret_cast<WCHAR*>( szReason );

        g_pW3Server->LogEvent(
            W3_EVENT_UNHEALTHY_ISAPI,
            2,
            pszEventLog,
            0
            );
    }
    else
    {
        g_pW3Server->LogEvent(
            W3_EVENT_UNHEALTHY_ISAPI_NO_REASON,
            1,
            pszEventLog,
            0
            );
    }

    //
    // Now tell someone that we feel sick
    //

    UlAtqSetUnhealthy();

    return NO_ERROR;
}


HRESULT STDMETHODCALLTYPE
ISAPI_REQUEST::AddFragmentToCache(
    VECTOR_ELEMENT * pVectorElement,
    WCHAR          * pszFragmentName
)
/*++

Routine Description:

    Add the fragment to cache

Arguments:

    pVectorElement - The fragment to be added
    pszFragmentName - name of the fragment

Return Value:

    HRESULT

--*/
{
    HTTP_DATA_CHUNK DataChunk;

    ZeroMemory(&DataChunk, sizeof DataChunk);
    if (pVectorElement->hFile)
    {
        DataChunk.DataChunkType = HttpDataChunkFromFileHandle;
        DataChunk.FromFileHandle.FileHandle = (HANDLE)pVectorElement->hFile;
        DataChunk.FromFileHandle.ByteRange.StartingOffset.QuadPart = pVectorElement->cbOffset;
        DataChunk.FromFileHandle.ByteRange.Length.QuadPart = pVectorElement->cbFileSize;
    }
    else if (pVectorElement->pBuffer)
    {
        DataChunk.DataChunkType = HttpDataChunkFromMemory;
        DataChunk.FromMemory.pBuffer = pVectorElement->pBuffer;
        DataChunk.FromMemory.BufferLength = pVectorElement->cbBufSize;
    }

    return UlAtqAddFragmentToCache(&DataChunk,
                                   pszFragmentName);
}


HRESULT STDMETHODCALLTYPE
ISAPI_REQUEST::ReadFragmentFromCache(
    WCHAR          * pszFragmentName,
    BYTE           * pvBuffer,
    DWORD            cbSize,
    DWORD          * pcbCopied
)
/*++

Routine Description:

    Read the fragment from cache

Arguments:

    pszFragmentName - name of the fragment
    pvBuffer - the buffer to read in
    cbSize - the size of the buffer
    pcbCopied - the amount copied in on return

Return Value:

    HRESULT

--*/
{
    return UlAtqReadFragmentFromCache(pszFragmentName,
                                      pvBuffer,
                                      cbSize,
                                      pcbCopied);
}


HRESULT STDMETHODCALLTYPE
ISAPI_REQUEST::RemoveFragmentFromCache(
    WCHAR          * pszFragmentName
)
/*++

Routine Description:

    Remove the fragment from cache

Arguments:

    pszFragmentName - name of the fragment

Return Value:

    HRESULT

--*/
{
    return UlAtqRemoveFragmentFromCache(pszFragmentName);
}


HRESULT
ISAPI_REQUEST::PreprocessIoCompletion(
    DWORD   cbIo
    )
/*++

Routine Description:

    Handles cleanup for any functions that use fCopiedData=TRUE.

    In the case of a TransmitFile or WriteClient, this just
    involves closing handles and freeing buffers.  In the case
    of ReadClient, we need to push the read buffer to the OOP
    process.

Arguments:

    cbIo - The number of bytes in a read buffer, if present

Return Value:

    HRESULT

--*/
{
    W3_ISAPI_HANDLER *  pW3IsapiHandler;
    HRESULT             hr = NOERROR;
    DWORD               i;

    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( _pW3Context );
    DBG_REQUIRE( ( pW3IsapiHandler = (W3_ISAPI_HANDLER*)_pW3Context->QueryHandler() ) != NULL );

    //
    // Cleanup any existing TF info, since we're done with it.
    //

    if ( _hTfFile != NULL && _hTfFile != INVALID_HANDLE_VALUE )
    {
        CloseHandle( _hTfFile );
        _hTfFile = INVALID_HANDLE_VALUE;
    }

    if ( _pTfHead )
    {
        LocalFree( _pTfHead );
        _pTfHead = NULL;
    }

    if ( _pTfTail )
    {
        LocalFree( _pTfTail );
        _pTfTail = NULL;
    }

    //
    // Cleanup any existing async write buffer
    //

    if ( _pAsyncWriteBuffer )
    {
        LocalFree( _pAsyncWriteBuffer );
        _pAsyncWriteBuffer = NULL;
    }

    //
    // If we have an async read buffer, then push the data
    // to the WAM process and free it
    //

    if ( _pAsyncReadBuffer )
    {
        hr = pW3IsapiHandler->MarshalAsyncReadBuffer(
            _IsapiContext,
            _pAsyncReadBuffer,
            cbIo
            );

        //
        // Note that the above function could fail if, for
        // example, the dllhost has crashed.  There's not
        // anything we can do about it here, though.  We'll
        // ignore it.
        //

        LocalFree( _pAsyncReadBuffer );
        _pAsyncReadBuffer = NULL;
    }

    //
    // Clean up HSE_EXEC_URL stuff
    //

    if ( _pbExecUrlEntity != NULL )
    {
        LocalFree( _pbExecUrlEntity );
        _pbExecUrlEntity = NULL;
    }

    if ( _hExecUrlToken != NULL )
    {
        CloseHandle( _hExecUrlToken );
        _hExecUrlToken = NULL;
    }

    //
    // Need to destroy handles/memory buffers we copied for vector send
    //
    VECTOR_ELEMENT *pElements = (VECTOR_ELEMENT *)_bufVectorElements.QueryPtr();
    for (i=0; i<_nElementCount; i++)
    {
        if (pElements[i].hFile)
        {
            CloseHandle((HANDLE)pElements[i].hFile);
        }
        else if (pElements[i].pBuffer)
        {
            LocalFree(pElements[i].pBuffer);
        }
    }

    _nElementCount = 0;

    return hr;
}

HRESULT STDMETHODCALLTYPE
ISAPI_REQUEST::GetMetadataProperty( 
    DWORD               dwPropertyId,
    BYTE *              pbBuffer,
    DWORD               cbBuffer,
    DWORD *             pcbBufferRequired
    )
/*++

Routine Description:

    Retrieves a metabase property

Arguments:

    dwPropertyId - MD_ property ID (must be of type UT_FILE)
    pbBuffer - Buffer to receive serialized data
    cbBuffer - Size of buffer
    pcbBufferRequired - Filled with size of buffer required
    
Return Value:

    HRESULT

--*/
{
    URL_CONTEXT *           pUrlContext;
    W3_METADATA *           pMetadata;
    
    DBG_ASSERT( _pW3Context );
    
    pUrlContext = _pW3Context->QueryUrlContext();
    DBG_ASSERT( pUrlContext != NULL );
    
    pMetadata = pUrlContext->QueryMetaData();
    DBG_ASSERT( pMetadata != NULL );

    return pMetadata->GetMetadataProperty( _pW3Context,
                                           dwPropertyId,
                                           pbBuffer,
                                           cbBuffer,
                                           pcbBufferRequired );
}


HRESULT STDMETHODCALLTYPE
ISAPI_REQUEST::GetCacheInvalidationCallback(
    DWORD64         *pfnCallback)
{
    //
    // BUGBUG: CODEWORK: will need another mechanism if we want to implement
    // this for OOP
    //
    if (_fIsOop)
    {
        return HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
    }

    *(PFN_HSE_CACHE_INVALIDATION_CALLBACK *)pfnCallback = UlAtqFlushUlCache;
    return S_OK;
}

HRESULT STDMETHODCALLTYPE
ISAPI_REQUEST::CloseConnection(
    VOID
    )
{
    W3_RESPONSE *   pResponse;
    DWORD           cbSent = NULL;
    HRESULT         hr;

    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( _pW3Context );
    DBG_REQUIRE( ( pResponse = _pW3Context->QueryResponse() ) != NULL );

    //
    // Tell http.sys to close the connection.  This send should not
    // cause http.sys to clean up the request - and logging data
    // sent later (when the ISAPI is done) should be correctly
    // handled.
    //

    hr = SendEntityBodyAndLogDataHelper( _pW3Context,
                                         _pW3Context->QueryUlatqContext(),
                                         FALSE,
                                         HTTP_SEND_RESPONSE_FLAG_DISCONNECT,
                                         0,
                                         NULL,
                                         &cbSent );

    if ( FAILED( hr ) )
    {
        //
        // If SendEntity fails, consider this a non recoverable
        // error and set the error to be WSAECONNRESET for
        // compatibility with legacy ISAPI code.
        //

        hr = HRESULT_FROM_WIN32( WSAECONNRESET );
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE
ISAPI_REQUEST::AllocateMemory(
    DWORD            cbSize,
    DWORD64        * ppvBuffer
    )
/*++

Routine Description:

    Allocate some per-request memory

Arguments:

    cbSize - Size to allocate
    ppvBuffer - Filled with buffer
    
Return Value:

    HRESULT

--*/
{
    DWORD64         dwBuffer;
    VOID *          pvBuffer;
    
    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( _pW3Context );

    pvBuffer = _pW3Context->ContextAlloc( cbSize );    
    if ( pvBuffer == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    *ppvBuffer = (DWORD64) pvBuffer;
    return S_OK;
}

ISAPI_REQUEST::~ISAPI_REQUEST()
/*++

Routine Description:

    Destructor

Arguments:

    None

Return Value:

    None

--*/
{
    DBG_ASSERT( CheckSignature() );

    //
    // Release the free threaded marshaler
    //

    if ( _pUnkFTM )
    {
        _pUnkFTM->Release();
        _pUnkFTM = NULL;
    }

    //
    // Dissociate ourselves from the WAM_PROCESS, if present
    //

    if ( _pWamProcess )
    {
        if (_pWamProcess->QueryCrashed())
        {
            AppendLog(SZ_FAILED_OOP_REQUEST_LOG_MESSAGE,
                      500);
        }

        _pWamProcess->DecrementRequestCount();

        _pWamProcess->Release();
        _pWamProcess = NULL;
    }

    _dwSignature = ISAPI_REQUEST_SIGNATURE_FREE;

    IF_DEBUG( ISAPI )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "ISAPI_REQUEST %p has been destroyed.\r\n",
            this
            ));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\logging.cxx ===
/*++

   Copyright    (c)   2000    Microsoft Corporation

   Module Name :
     logging.cxx

   Abstract:
     Handle Logging

   Author:
     Anil Ruia (AnilR)              1-Jul-2000

   Environment:
     Win32 - User Mode

   Project:
     w3core.dll
--*/

#include "precomp.hxx"

CONTEXT_STATUS W3_STATE_LOG::DoWork(
    W3_MAIN_CONTEXT *pMainContext,
    DWORD,
    DWORD)
/*++

Routine Description:

    Log the request (and call the END_OF_REQUEST notification)

Arguments:

    pMainContext - W3_MAIN_CONTEXT representing an execution of the
                   state machine

Return Value:

    CONTEXT_STATUS_CONTINUE - if we should continue in state machine
    else stop executing the machine and free up the current thread

--*/
{
    BOOL            fUnused = FALSE;

    if (pMainContext->QueryNeedFinalDone())
    {
        //
        // Clear remaining chunks from handle/response state
        //

        pMainContext->QueryResponse()->Clear();

        //
        // End of request notifications happen BEFORE logging.
        //

        if ( pMainContext->IsNotificationNeeded( SF_NOTIFY_END_OF_REQUEST ) )
        {
            pMainContext->NotifyFilters( SF_NOTIFY_END_OF_REQUEST,
                                         NULL,
                                         &fUnused );
        }
        
        //
        // Clear any crud from the last write from END_OF_REQUEST filter
        //

        pMainContext->QueryResponse()->Clear();

        //
        // Do the final send
        //

        pMainContext->SendEntity(W3_FLAG_PAST_END_OF_REQ);
    }

    if (pMainContext->QueryDoCustomLogging())
    {
        if (FAILED(pMainContext->CollectLoggingData(FALSE)))
        {
            goto Exit;
        }

        pMainContext->QuerySite()->LogInformation(pMainContext->QueryLogContext());
    }

 Exit:
    return CONTEXT_STATUS_CONTINUE;
}


CONTEXT_STATUS W3_STATE_LOG::OnCompletion(
    W3_MAIN_CONTEXT *,
    DWORD,
    DWORD)
/*++

Routine Description:

    Completion for the W3_STATE_LOG state

Arguments:

    pMainContext - W3_MAIN_CONTEXT representing an execution of the
                   state machine

Return Value:

    CONTEXT_STATUS_CONTINUE - if we should continue in state machine
    else stop executing the machine and free up the current thread

--*/
{
    //
    // This code should never get hit
    //
    DBG_ASSERT(FALSE);

    return CONTEXT_STATUS_CONTINUE;
}


HRESULT W3_MAIN_CONTEXT::CollectLoggingData(BOOL fCollectForULLogging)
/*++

Routine Description:

    Routine which collects all the logging data

Arguments:

    fCollectForULLogging - whether the data is being collected for http.sys/custom logging

Return Value:

    HRESULT

--*/
{
    STACK_STRA(strVal, 64);
    STACK_STRU(strValW, 64);
    HRESULT hr = S_OK;
    DWORD dwLength;
    CHUNK_BUFFER * pHeaderBuffer;

    HTTP_LOG_FIELDS_DATA *pUlLogData = QueryUlLogData();
    W3_REQUEST *pRequest = QueryRequest();
    W3_RESPONSE *pResponse = QueryResponse();

    pHeaderBuffer = QueryHeaderBuffer();
    DBG_ASSERT( pHeaderBuffer != NULL );

    if (IsNotificationNeeded(SF_NOTIFY_LOG))
    {
        //
        // There is a SF_NOTIFY_LOG filter, collect the data for the
        // notification
        //
        HTTP_FILTER_LOG filtLog;
        ZeroMemory(&filtLog, sizeof filtLog);

        if (SUCCEEDED(hr = GetServerVariableRemoteHost(this, &strVal)))
        {
            dwLength = strVal.QueryCCH() + 1;
            if (FAILED(hr = pHeaderBuffer->AllocateSpace(
                                dwLength,
                                (PCHAR *)&filtLog.pszClientHostName)))
            {
                goto Exit;
            }
            strVal.CopyToBuffer((LPSTR)filtLog.pszClientHostName,
                                 &dwLength);
        }
        else
        {
            goto Exit;
        }

        if (SUCCEEDED(hr = GetServerVariableLogonUser(this, &strVal)))
        {
            dwLength = strVal.QueryCCH() + 1;
            if (FAILED(hr = pHeaderBuffer->AllocateSpace(
                                dwLength,
                                (PCHAR *)&filtLog.pszClientUserName)))
            {
                goto Exit;
            }
            strVal.CopyToBuffer((LPSTR)filtLog.pszClientUserName,
                                 &dwLength);
        }
        else
        {
            goto Exit;
        }

        if (SUCCEEDED(hr = GetServerVariableLocalAddr(this, &strVal)))
        {
            dwLength = strVal.QueryCCH() + 1;
            if (FAILED(hr = pHeaderBuffer->AllocateSpace(
                                dwLength,
                                (PCHAR *)&filtLog.pszServerName)))
            {
                goto Exit;
            }
            strVal.CopyToBuffer((LPSTR)filtLog.pszServerName,
                                 &dwLength);
        }
        else
        {
            goto Exit;
        }

        pRequest->QueryVerb((CHAR **)&filtLog.pszOperation, (USHORT *)&dwLength);

        if (FAILED(hr = pRequest->GetUrl(&strValW)) ||
            FAILED(hr = strVal.CopyWToUTF8(strValW)) ||
            FAILED(hr = pHeaderBuffer->AllocateSpace(
                                strVal.QueryStr(),
                                strVal.QueryCCH(),
                                (CHAR **)&filtLog.pszTarget)))
        {
            goto Exit;
        }

        //
        // If an ISAPI used HSE_APPEND_LOG_PARAMETER use it
        //
        if (_LogContext.m_strLogParam.IsEmpty())
        {
            if (FAILED(hr = pRequest->GetQueryStringA(&_LogContext.m_strLogParam)))
            {
                goto Exit;
            }
        }
        filtLog.pszParameters = _LogContext.m_strLogParam.QueryStr();

        filtLog.dwHttpStatus = pResponse->QueryStatusCode();
        
        if ( HRESULT_FACILITY( QueryErrorStatus() ) == FACILITY_WIN32 )
        {
            filtLog.dwWin32Status = WIN32_FROM_HRESULT( QueryErrorStatus() );
        }
        else
        {
            filtLog.dwWin32Status = QueryErrorStatus();
        }

        filtLog.dwBytesSent = _LogContext.m_dwBytesSent;
        filtLog.dwBytesRecvd = _LogContext.m_dwBytesRecvd;
        filtLog.msTimeForProcessing = GetTickCount() - _LogContext.m_msStartTickCount;

        NotifyFilters(SF_NOTIFY_LOG, &filtLog, NULL);

        //
        // The filter may have changed some the data, copy it back to our
        // logging structure
        //
        pUlLogData->ClientIp = (CHAR *)filtLog.pszClientHostName;
        pUlLogData->ClientIpLength = (USHORT) strlen(filtLog.pszClientHostName);

        if (FAILED(hr = strValW.CopyA(filtLog.pszClientUserName)) ||
            FAILED(hr = pHeaderBuffer->AllocateSpace(
                            strValW.QueryStr(),
                            strValW.QueryCCH(),
                            (PWSTR*) &pUlLogData->UserName)))
        {
            goto Exit;
        }
        pUlLogData->UserNameLength =
            (USHORT)(strValW.QueryCCH() * sizeof(WCHAR));

        pUlLogData->ServerIp = (CHAR *)filtLog.pszServerName;
        pUlLogData->ServerIpLength = (USHORT) strlen(filtLog.pszServerName);

        pUlLogData->Method = (CHAR *)filtLog.pszOperation;
        pUlLogData->MethodLength = (USHORT) strlen(filtLog.pszOperation);
        pUlLogData->MethodNum = (HTTP_VERB)METHOD_HASH::GetIndex((CHAR *)filtLog.pszOperation);        

        if (FAILED(hr = strValW.CopyA(filtLog.pszTarget)) ||
            FAILED(hr = pHeaderBuffer->AllocateSpace(
                            strValW.QueryStr(),
                            strValW.QueryCCH(),
                            (PWSTR*) &pUlLogData->UriStem)))
        {
            goto Exit;
        }
        pUlLogData->UriStemLength =
            (USHORT)(strValW.QueryCCH() * sizeof(WCHAR));

        pUlLogData->UriQuery = (CHAR *)filtLog.pszParameters;
        pUlLogData->UriQueryLength = (USHORT) strlen(filtLog.pszParameters);

        pUlLogData->ProtocolStatus = (USHORT) filtLog.dwHttpStatus;
        pUlLogData->Win32Status = filtLog.dwWin32Status;
        _LogContext.m_dwBytesSent = filtLog.dwBytesSent;
        _LogContext.m_dwBytesRecvd = filtLog.dwBytesRecvd;
        _LogContext.m_msProcessingTime = filtLog.msTimeForProcessing;
    }
    else
    {
        //
        // No filter, just get the logging data
        //
        if (SUCCEEDED(hr = GetServerVariableRemoteHost(this, &strVal)))
        {
            if (FAILED(hr = pHeaderBuffer->AllocateSpace(
                                strVal.QueryStr(),
                                strVal.QueryCCH(),
                                (PSTR*) &pUlLogData->ClientIp)))
            {
                goto Exit;
            }
            pUlLogData->ClientIpLength = (USHORT)strVal.QueryCCH();
        }
        else
        {
            goto Exit;
        }

        if ( QueryUserContext() == NULL )
        {
            if (FAILED(hr = pRequest->GetRequestUserName(&strVal)))
            {
                goto Exit;
            }

            if (strVal.IsEmpty())
            {
                pUlLogData->UserName = L"";
                pUlLogData->UserNameLength = 0;
            }
            else
            {
                if (FAILED(hr = strValW.CopyA(strVal.QueryStr())) ||
                    FAILED(hr = pHeaderBuffer->AllocateSpace(
                                    strValW.QueryStr(),
                                    strValW.QueryCCH(),
                                    (PWSTR*) &pUlLogData->UserName)))
                {
                    goto Exit;
                }
                pUlLogData->UserNameLength = (USHORT)strValW.QueryCB();
            }
        }
        else
        {
            pUlLogData->UserName = QueryUserContext()->QueryUserName();
            if (pUlLogData->UserName)
            {
                pUlLogData->UserNameLength = (USHORT)wcslen(pUlLogData->UserName) * sizeof(WCHAR);
            }
        }

        if (SUCCEEDED(hr = GetServerVariableLocalAddr(this, &strVal)))
        {
            if (FAILED(hr = pHeaderBuffer->AllocateSpace(
                                strVal.QueryStr(),
                                strVal.QueryCCH(),
                                (PSTR*) &pUlLogData->ServerIp)))
            {
                goto Exit;
            }
            pUlLogData->ServerIpLength =
                (USHORT)strVal.QueryCCH();
        }
        else
        {
            goto Exit;
        }

        pRequest->QueryVerb((CHAR**) &pUlLogData->Method,
                            &pUlLogData->MethodLength);
        pUlLogData->MethodNum = pRequest->QueryVerbType();

        pRequest->QueryUrl((WCHAR**) &pUlLogData->UriStem,
                           &pUlLogData->UriStemLength);

        //
        // If an ISAPI used HSE_APPEND_LOG_PARAMETER use it
        //
        if (_LogContext.m_strLogParam.IsEmpty())
        {
            if (FAILED(hr = pRequest->GetQueryStringA(&_LogContext.m_strLogParam)))
            {
                goto Exit;
            }
        }
        pUlLogData->UriQuery = _LogContext.m_strLogParam.QueryStr();
        pUlLogData->UriQueryLength = (USHORT)_LogContext.m_strLogParam.QueryCCH();

        pUlLogData->ProtocolStatus = pResponse->QueryStatusCode();
        if ( HRESULT_FACILITY( QueryErrorStatus() ) == FACILITY_WIN32 )
        {
            pUlLogData->Win32Status = WIN32_FROM_HRESULT( QueryErrorStatus() );
        }
        else
        {
            pUlLogData->Win32Status = QueryErrorStatus();
        }

        if (!fCollectForULLogging)
        {
            _LogContext.m_msProcessingTime =
                GetTickCount() - _LogContext.m_msStartTickCount;
        }
    }

    //
    // Now get data unaffected by any SF_NOTIFY_LOG filter
    //
    
    HTTP_SUB_ERROR subError;
    pResponse->QuerySubError(&subError);
    pUlLogData->SubStatus = subError.mdSubError;

    pUlLogData->ServerPort = ntohs( pRequest->QueryLocalPort() );

    pUlLogData->ServiceName = QuerySite()->QueryName()->QueryStr();
    pUlLogData->ServiceNameLength = (USHORT)QuerySite()->QueryName()->QueryCCH();

    pUlLogData->ServerName = g_pW3Server->QueryComputerName();
    pUlLogData->ServerNameLength = g_pW3Server->QueryComputerNameLength();

    if (fCollectForULLogging)
    {
        pUlLogData->Host = pRequest->GetHeader(HttpHeaderHost,
                                               &pUlLogData->HostLength);

        pUlLogData->UserAgent = pRequest->GetHeader(HttpHeaderUserAgent,
                                                    &pUlLogData->UserAgentLength);
        pUlLogData->Cookie = pRequest->GetHeader(HttpHeaderCookie,
                                                 &pUlLogData->CookieLength);

        pUlLogData->Referrer = pRequest->GetHeader(HttpHeaderReferer,
                                                   &pUlLogData->ReferrerLength);
    }
    else
    {
        if (FAILED(hr = GetServerVariableHttpVersion(this,
                                        &_LogContext.m_strVersion)))
        {
            goto Exit;
        }

        if (QuerySite()->IsRequiredExtraLoggingFields())
        {
            //
            // If the custom logging module needs extra logging fields, get them
            //

            const MULTISZA *pmszExtraLoggingFields =
                QuerySite()->QueryExtraLoggingFields();
            LPSTR pszHeaderName = (LPSTR)pmszExtraLoggingFields->First();
            STACK_STRA( strHeaderName, 128);

            while (pszHeaderName != NULL)
            {
                hr = strHeaderName.Copy( pszHeaderName,
                                         (DWORD)strlen(pszHeaderName) - 1 );
                if (FAILED(hr))
                {
                    goto Exit;
                }

                hr = pRequest->GetHeader( strHeaderName,
                                          &strVal );
                if (FAILED(hr))
                {
                    if (hr == HRESULT_FROM_WIN32(ERROR_INVALID_INDEX))
                    {
                        strVal.Reset();
                        hr = S_OK;
                    }
                    else
                    {
                        goto Exit;
                    }
                }

                if (!_LogContext.m_mszHTTPHeaders.Append(strVal.QueryStr()))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    goto Exit;
                }

                pszHeaderName = (LPSTR)pmszExtraLoggingFields->Next(pszHeaderName);
            }
        }
    }

 Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\iisrearc\iisplus\ulw3\maincontext.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     maincontext.cxx

   Abstract:
     Drive the state machine

   Author:
     Bilal Alam (balam)             10-Mar-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include "rawconnection.hxx"
#include "sspiprovider.hxx"
#include "basicprovider.hxx"
#include "servervar.hxx"

//
// Global alloc cache and context list
//

ALLOC_CACHE_HANDLER *    W3_MAIN_CONTEXT::sm_pachMainContexts = NULL;
W3_STATE *               W3_MAIN_CONTEXT::sm_pStates[ STATE_COUNT ];
SHORT                    W3_MAIN_CONTEXT::sm_rgInline[ STATE_COUNT ];
USHORT                   W3_MAIN_CONTEXT::sm_cbInlineBytes = 0;
DWORD                    W3_MAIN_CONTEXT::sm_dwTimeout = 0;
HANDLE                   W3_MAIN_CONTEXT::sm_hTraceFile = INVALID_HANDLE_VALUE;
W3_TRACE_LOG_FACTORY *   W3_MAIN_CONTEXT::sm_pLogFactory = NULL;


VOID
W3_MAIN_CONTEXT::DoWork(
    DWORD                cbCompletion,
    DWORD                dwCompletionStatus,
    BOOL                 fIoCompletion
)
/*++

Routine Description:

    Drives the W3 state machine

Arguments:

    cbCompletion - Number of bytes in an async completion
    dwCompletionStatus - Error status of a completion
    fIoCompletion - TRUE if this was an IO completion,
                    FALSE if this was a new request completion

Return Value:

    None

--*/
{
    CONTEXT_STATUS         Status = CONTEXT_STATUS_CONTINUE;
    BOOL                   fLastState = FALSE;
    W3_CONTEXT *           pCurrentContext = NULL;

    if (fIoCompletion)
    {
        if (QueryLastIOPending() == LOG_WRITE_IO)
        {
            _LogContext.m_dwBytesSent += cbCompletion;
        }
        else if (QueryLastIOPending() == LOG_READ_IO)
        {
            IncrementBytesRecvd( cbCompletion );

            if ( _cbRemainingEntityFromUL != INFINITE )
            {
                if ( _cbRemainingEntityFromUL >= cbCompletion )
                {
                    _cbRemainingEntityFromUL -= cbCompletion;
                }
                else
                {
                    _cbRemainingEntityFromUL = 0;
                }
            }
        }
    }

    //
    // Progress thru states until we are finished or a state operation
    // is performed asynchronously
    //

    while ( !fLastState )
    {
        W3_STATE *              pState;

        //
        // Get the next function to call, and then call it
        //

        pState = sm_pStates[ _currentState ];
        DBG_ASSERT( pState != NULL );

        //
        // Manage the _nextState which indicates what the next state will be
        // if the DoWork() returns CONTEXT_STATUS_CONTINUE.  Note that this
        // state can be overriden by W3_MAIN_CONTEXT::SetFinishedResponse
        //

        _nextState = _currentState + 1;

        //
        // If this is the last state, remember that so we can cleanup
        //

        if ( _currentState == CONTEXT_STATE_DONE )
        {
            fLastState = TRUE;
        }

        if ( !fIoCompletion )
        {
            Status = pState->DoWork( this,
                                     cbCompletion,
                                     dwCompletionStatus );
        }
        else
        {
            pCurrentContext = QueryCurrentContext();

            //
            // First try to complete handler contexts if any.
            //

            Status = pCurrentContext->ExecuteHandlerCompletion(
                                                 cbCompletion,
                                                 dwCompletionStatus );

            if ( Status == CONTEXT_STATUS_CONTINUE )
            {
                //
                // Excellent.  All handlers for this context have
                // completed.  Now we finally complete the original
                // state which originally started the async ball rolling
                //

                Status = pState->OnCompletion( this,
                                               cbCompletion,
                                               dwCompletionStatus );
            }

            //
            // Reset fIoCompletion so we can continue the state machine
            // after the completion function is done
            //
            fIoCompletion = FALSE;

        }

        //
        // An async operation was posted, bail immediately
        //

        if ( Status == CONTEXT_STATUS_PENDING )
        {
            return;
        }

        DBG_ASSERT( Status == CONTEXT_STATUS_CONTINUE );

        _currentState = _nextState;
    }

    //
    // If we get here, we must have executed the last state, so cleanup the
    // MAIN_CONTEXT
    //

    DBG_ASSERT( fLastState );

    //
    // If we have a raw connection, detach ourselves from it now
    //

    if ( _pRawConnection != NULL )
    {
        _pRawConnection->SetMainContext( NULL );
    }

    DereferenceMainContext();
}

VOID
W3_MAIN_CONTEXT::UpdateSkipped(
    HTTP_DATA_CHUNK *           pChunks,
    DWORD                       cChunks
)
/*++

Routine Description:

    Update the amount of worker process data to skip

Arguments:

    pChunks - Array of chunks
    cChunks - Number of chunks

Return Value:

    None

--*/
{
    ULARGE_INTEGER      liTotalData;
    ULARGE_INTEGER      liFileSize;
    ULARGE_INTEGER      liChunkSize;
    HTTP_DATA_CHUNK *   pDataChunk;
    HTTP_BYTE_RANGE *   pByteRange;
    BOOL                fRet;

    DBG_ASSERT( (pChunks != NULL) || (cChunks == 0) );

    if ( _pRawConnection == NULL )
    {
        return;
    }

    liTotalData.QuadPart = 0;

    for ( int i = 0; i < cChunks; i++ )
    {
        pDataChunk = &( pChunks[ i ] );

        if ( pDataChunk->DataChunkType == HttpDataChunkFromMemory )
        {
            liTotalData.QuadPart += pDataChunk->FromMemory.BufferLength;
        }
        else if ( pDataChunk->DataChunkType == HttpDataChunkFromFileHandle )
        {
            pByteRange = &( pDataChunk->FromFileHandle.ByteRange );

            if ( pByteRange->StartingOffset.QuadPart == HTTP_BYTE_RANGE_TO_EOF )
            {
                liTotalData.QuadPart += pByteRange->Length.QuadPart;
            }
            else if ( pByteRange->Length.QuadPart == HTTP_BYTE_RANGE_TO_EOF )
            {
                fRet = GetFileSizeEx( pDataChunk->FromFileHandle.FileHandle,
                                      (PLARGE_INTEGER) &liFileSize );
                if ( fRet )
                {
                    liChunkSize.QuadPart = liFileSize.QuadPart - pByteRange->StartingOffset.QuadPart;
                    liTotalData.QuadPart += liChunkSize.QuadPart;
                }
            }
            else
            {
                liTotalData.QuadPart += pByteRange->Length.QuadPart;
            }
        }
    }

    _pRawConnection->AddSkippedData( liTotalData );
}

VOID
W3_MAIN_CONTEXT::BackupStateMachine(
    VOID
)
/*++

Routine Description:

    Backup in state machine to the URL_INFO state.  This should be used only
    by AUTH_COMPLETE filters

Arguments:

    None

Return Value:

    None

--*/
{
    URL_CONTEXT *           pUrlContext;

    DBG_ASSERT( IsNotificationNeeded( SF_NOTIFY_AUTH_COMPLETE ) );

    //
    // Clear the URL context
    //

    pUrlContext = QueryUrlContext();
    DBG_ASSERT( pUrlContext != NULL );

    SetUrlContext( NULL );

    delete pUrlContext;

    //
    // Reset our access check state.
    //

    ResetAccessCheck();

    //
    // Back that state up
    //

    _nextState = CONTEXT_STATE_URLINFO;
}

// static
HRESULT
W3_MAIN_CONTEXT::SetupStateMachine(
    VOID
)
/*++

Routine Description:

    Setup state machine

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HRESULT                     hr = NO_ERROR;
    W3_STATE *                  pState = NULL;
    DWORD                       cState = CONTEXT_STATE_START;

    //
    // First create all the states
    //

    //
    // Start State
    //

    pState = (W3_STATE*) new W3_STATE_START();
    if ( pState == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto Failure;
    }
    else if ( FAILED( hr = pState->QueryResult() ) )
    {
        goto Failure;
    }

    sm_pStates[ cState ] = pState;
    cState++;

    //
    // URLINFO State
    //

    pState = (W3_STATE*) new W3_STATE_URLINFO();
    if ( pState == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto Failure;
    }
    else if ( FAILED( hr = pState->QueryResult() ) )
    {
        goto Failure;
    }

    sm_pStates[ cState ] = pState;
    cState++;

    //
    // Authentication State
    //

    pState = (W3_STATE*) new W3_STATE_AUTHENTICATION();
    if ( pState == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto Failure;
    }
    else if ( FAILED( hr = pState->QueryResult() ) )
    {
        goto Failure;
    }

    sm_pStates[ cState ] = pState;
    cState++;

    //
    // Authorization State
    //

    pState = (W3_STATE*) new W3_STATE_AUTHORIZATION();
    if ( pState == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto Failure;
    }
    else if ( FAILED( hr = pState->QueryResult() ) )
    {
        goto Failure;
    }

    sm_pStates[ cState ] = pState;
    cState++;

    //
    // Handle Request State
    //

    pState = (W3_STATE*) new W3_STATE_HANDLE_REQUEST();
    if ( pState == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto Failure;
    }
    else if ( FAILED( hr = pState->QueryResult() ) )
    {
        goto Failure;
    }

    sm_pStates[ cState ] = pState;
    cState++;

    //
    // Response State
    //

    pState = (W3_STATE*) new W3_STATE_RESPONSE();
    if ( pState == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto Failure;
    }
    else if ( FAILED( hr = pState->QueryResult() ) )
    {
        goto Failure;
    }

    sm_pStates[ cState ] = pState;
    cState++;

    //
    // Log State
    //

    pState = (W3_STATE*) new W3_STATE_LOG();
    if ( pState == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto Failure;
    }
    else if ( FAILED( hr = pState->QueryResult() ) )
    {
        goto Failure;
    }

    sm_pStates[ cState ] = pState;
    cState++;

    //
    // Done State
    //

    pState = (W3_STATE*) new W3_STATE_DONE();
    if ( pState == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto Failure;
    }
    else if ( FAILED( hr = pState->QueryResult() ) )
    {
        goto Failure;
    }

    sm_pStates[ cState ] = pState;
    cState++;

    return NO_ERROR;

Failure:

    for ( int i = 0; i < STATE_COUNT; i++ )
    {
        if ( sm_pStates[ i ] != NULL )
        {
            delete sm_pStates[ i ];
            sm_pStates[ i ] = NULL;
        }
    }

    return hr;
}

// static
VOID
W3_MAIN_CONTEXT::CleanupStateMachine(
    VOID
)
/*++

Routine Description:

    Cleanup state machine

Arguments:

    None

Return Value:

    None

--*/
{
    for ( int i = CONTEXT_STATE_START;
          i < STATE_COUNT;
          i++ )
    {
        if ( sm_pStates[ i ] != NULL )
        {
            delete sm_pStates[ i ];
            sm_pStates[ i ] = NULL;
        }
    }
}

BOOL
W3_MAIN_CONTEXT::SetupContext(
    HTTP_REQUEST *          pUlHttpRequest,
    ULATQ_CONTEXT           ulatqContext
)
/*++

Routine Description:

    Sets up a MAIN_CONTEXT before executing the state machine for a new
    incoming request.

Arguments:

    pUlHttpRequest - the HTTP_REQUEST from UL
    ulatqContext - used to send/receive data thru ULATQ

Return Value:

    TRUE if successful, else FALSE

--*/
{
    memset( _rgStateContexts, 0, sizeof( _rgStateContexts ) );

    //
    // Should we generate a content-length header
    //

    if ( pUlHttpRequest->Verb == HttpVerbHEAD )
    {
        _fGenerateContentLength = TRUE;
    }

    //
    // Associate HTTP_REQUEST with W3_REQUEST wrapper
    //

    _request.SetHttpRequest( pUlHttpRequest );

    //
    // Associate context for async IO (if any)
    //

    _ulatqContext = ulatqContext;

    UlAtqSetContextProperty( _ulatqContext,
                             ULATQ_PROPERTY_COMPLETION_CONTEXT,
                             this );

    //
    // Setup the state machine
    //

    _currentState = CONTEXT_STATE_START;
    _nextState = CONTEXT_STATE_START;

    //
    // Setup current context to receive IO completions.  Naturally on
    // startup, this context will be 'this'.  But it can change depending
    // on whether child executes are called
    //

    _pCurrentContext = this;

    return TRUE;
}

W3_CONNECTION_STATE *
W3_MAIN_CONTEXT::QueryConnectionState(
    VOID
)
/*++

Routine Description:

    Get any context associated with this connection and this state.

Arguments:

    None

Return Value:

    A W3_CONNECTION_STATE * or NULL if there is no state

--*/
{
    //
    // Since we are just looking for any existing connection state, make
    // sure we don't create a connection object if none is already associated
    // (creating a connection object is expensive)
    //

    W3_CONNECTION *     pConn = QueryConnection( FALSE );

    return pConn ? pConn->QueryConnectionState( _currentState ) : NULL;
}

VOID
W3_MAIN_CONTEXT::SetConnectionState(
    W3_CONNECTION_STATE *       pConnectionState
)
/*++

Routine Description:

    Set any context to be associated with the connection and current state

Arguments:

    pConnectionState - Context to associate

Return Value:

    None

--*/
{
    if ( QueryConnection() )
    {
        QueryConnection()->SetConnectionState( _currentState,
                                               pConnectionState );
    }
}

W3_MAIN_CONTEXT::W3_MAIN_CONTEXT(
    HTTP_REQUEST *          pUlHttpRequest,
    ULATQ_CONTEXT           ulAtqContext
)
    : W3_CONTEXT                   ( 0,
                                   0 /* Recursion Level */),
      _pSite                       ( NULL ),
      _pFilterContext              ( NULL ),
      _fDisconnect                 ( FALSE ),
      _fNeedFinalDone              ( FALSE ),
      _fAssociationChecked         ( FALSE ),
      _pConnection                 ( NULL ),
      _pUrlContext                 ( NULL ),
      _pUserContext                ( NULL ),
      _fProviderHandled            ( FALSE ),
      _fCheckAnonAuthTypeSupported ( FALSE ),
      _fDoneWithCompression        ( FALSE ),
      _pCompressionContext         ( NULL ),
      _fIsUlCacheable              ( TRUE ),
      _pCertificateContext         ( NULL ),
      _cbRemainingEntityFromUL     ( 0 ),
      _cbEntityReadSoFar           ( 0 ),
      _fGenerateContentLength      ( FALSE ),
      _pRawConnection              ( NULL ),
      _cRefs                       ( 1 ),
      _hTimer                      ( NULL ),
      _dwLastPostLineNumber        ( 0 ),
      _pszLastPostFileName         ( NULL ),
      _pTraceLog                   ( NULL ),
      _fIgnoreAppPoolCheck         ( FALSE )
{
    _LogContext.m_msStartTickCount = GetTickCount();

    SetupContext( pUlHttpRequest, ulAtqContext );

    _hTimer = NULL;

    if (sm_dwTimeout)
    {
        BOOL fRet;
        fRet = CreateTimerQueueTimer(&_hTimer,
                                     NULL,
                                     W3_MAIN_CONTEXT::TimerCallback,
                                     this,
                                     sm_dwTimeout,
                                     0,
                                     WT_EXECUTEONLYONCE
                                     );
        DBG_ASSERT(fRet);
    }

    if ( sm_pLogFactory )
    {
        sm_pLogFactory->CreateTraceLog( &_pTraceLog );
    }
}

W3_MAIN_CONTEXT::~W3_MAIN_CONTEXT()
/*++

Routine Description:

    Main context destructor

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Cleanup context state
    //

    for ( DWORD i = 0; i < STATE_COUNT; i++ )
    {
        if ( _rgStateContexts[ i ] != NULL )
        {
            ((W3_MAIN_CONTEXT_STATE*) _rgStateContexts[ i ])->Cleanup( this );
            _rgStateContexts[ i ] = NULL;
        }
    }

    //
    // Let our filter context go
    //

    if ( _pFilterContext != NULL )
    {
        _pFilterContext->SetMainContext( NULL );
       
        //
        // Only dereference if this is a detached context
        //
        
        if ( _pFilterContext != &_FilterContext )
        {
            _pFilterContext->DereferenceFilterContext();
        }
        
        _pFilterContext = NULL;
    }

    //
    // Let go of reference to associated connection
    //

    if ( _pConnection != NULL )
    {
        _pConnection->DereferenceConnection();
        _pConnection = NULL;
    }

    //
    // Cleanup URL-Context
    //

    if ( _pUrlContext != NULL )
    {
        delete _pUrlContext;
        _pUrlContext = NULL;
    }

    //
    // Release our user context
    //

    if ( _pUserContext != NULL )
    {
        // perf ctr
        if (_pUserContext->QueryAuthType() == MD_AUTH_ANONYMOUS)
        {
            _pSite->DecAnonUsers();
        }
        else
        {
            _pSite->DecNonAnonUsers();
        }

        _pUserContext->DereferenceUserContext();
        _pUserContext = NULL;
    }

    //
    // Release the compression context
    //
    if ( _pCompressionContext != NULL )
    {
        delete _pCompressionContext;
        _pCompressionContext = NULL;
    }

    //
    // Cleanup RDNS crud
    //

    _IpAddressCheck.UnbindAddr();

    //
    // Cleanup client certificate context
    //

    if ( _pCertificateContext != NULL )
    {
        delete _pCertificateContext;
        _pCertificateContext = NULL;
    }

    //
    // Release the raw connection now
    //

    if ( _pRawConnection != NULL )
    {
        _pRawConnection->DereferenceRawConnection();
        _pRawConnection = NULL;
    }

    //
    // Finally release the site
    //
    if ( _pSite != NULL )
    {
        _pSite->DereferenceSite();
        _pSite = NULL;
    }

    if (_hTimer != NULL )
    {
        BOOL fRet;
        fRet = DeleteTimerQueueTimer(NULL,
                                    _hTimer,
                                    INVALID_HANDLE_VALUE);
        DBG_ASSERT(fRet);
        _hTimer = NULL;
    }

    if ( _pTraceLog != NULL )
    {
        _pTraceLog->DestroyTraceLog();
        _pTraceLog = NULL;
    }
}

// static
HRESULT
W3_MAIN_CONTEXT::Initialize(
    VOID
)
/*++

Routine Description:

    Global initialization routine for W3_MAIN_CONTEXTs

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ALLOC_CACHE_CONFIGURATION       acConfig;
    HRESULT                         hr = NO_ERROR;

    // ignore the return value- if we can't setup trace logging, we can't setup trace logging
    SetupTraceLogging();

    //
    // Setup global state machine.  We do this BEFORE we setup the
    // allocation cache because the state machine setup will tell how much
    // inline buffer space is needed for state
    //

    hr = SetupStateMachine();
    if ( FAILED( hr ) )
    {
        return hr;
    }

    //
    // Setup allocation lookaside
    //

    acConfig.nConcurrency = 1;
    acConfig.nThreshold = 100;
    acConfig.cbSize = sizeof( W3_MAIN_CONTEXT );

    DBG_ASSERT( sm_pachMainContexts == NULL );

    sm_pachMainContexts = new ALLOC_CACHE_HANDLER( "W3_MAIN_CONTEXT",
                                                   &acConfig );

    if ( sm_pachMainContexts == NULL )
    {
        CleanupStateMachine();
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }

    sm_dwTimeout = ReadRegDword(HKEY_LOCAL_MACHINE,
                                REGISTRY_KEY_INETINFO_PARAMETERS_W,
                                L"RequestTimeoutBreak",
                                0);

    return NO_ERROR;
}

// static
VOID
W3_MAIN_CONTEXT::Terminate(
    VOID
)
/*++

Routine Description:

    Terminate MAIN_CONTEXT globals

Arguments:

    None

Return Value:

    None

--*/
{
    CleanupStateMachine();

    if ( sm_pachMainContexts != NULL )
    {
        delete sm_pachMainContexts;
        sm_pachMainContexts = NULL;
    }

    CleanupTraceLogging();
}

W3_USER_CONTEXT *
W3_MAIN_CONTEXT::QueryConnectionUserContext(
    VOID
)
/*++

Routine Description:

    Get any user context associated with this connection

Arguments:

    None

Return Value:

    Pointer to W3_USER_CONTEXT (or NULL if no used associated)

--*/
{
    W3_CONNECTION *         pConnection = NULL;

    pConnection = QueryConnection( FALSE );
    if ( pConnection != NULL )
    {
        return pConnection->QueryUserContext();
    }
    else
    {
        return NULL;
    }
}

VOID
W3_MAIN_CONTEXT::SetConnectionUserContext(
    W3_USER_CONTEXT *           pUserContext
)
/*++

Routine Description:

    Associate user context with connection

Arguments:

    pUserContext - User context to associate

Return Value:

    None

--*/
{
    W3_CONNECTION *         pConnection = NULL;

    pConnection = QueryConnection( TRUE );
    if ( pConnection != NULL )
    {
        pConnection->SetUserContext( pUserContext );
    }
    else
    {
        DBG_ASSERT( FALSE );
    }
}

HRESULT
W3_MAIN_CONTEXT::ReceiveEntityBody(
    BOOL            fAsync,
    VOID *          pBuffer,
    DWORD           cbBuffer,
    DWORD *         pBytesReceived
    )
/*++

Routine Description:

    Receives entity data from the client

Arguments:

    fAsync - TRUE if this is an async request
    pBuffer - The buffer to store the data
    cbBuffer - The size of the buffer
    pBytesReceived - Upon return, the amount of data copied
                     into the buffer

Return Value:

    HRESULT

--*/
{
    HRESULT hr = UlAtqReceiveEntityBody( QueryUlatqContext(),
                                         fAsync,
                                         0,
                                         pBuffer,
                                         cbBuffer,
                                         pBytesReceived );

    //
    // Keep track of how much we're reading
    //

    if (!fAsync &&
        SUCCEEDED(hr))
    {
        if ( _cbRemainingEntityFromUL != INFINITE )
        {
            if ( _cbRemainingEntityFromUL >= *pBytesReceived )
            {
                _cbRemainingEntityFromUL -= *pBytesReceived;
            }
            else
            {
                _cbRemainingEntityFromUL = 0;
            }
        }
    }

    return hr;
}

W3_CONNECTION *
W3_MAIN_CONTEXT::QueryConnection(
    BOOL                fCreateIfNotFound
)
/*++

Routine Description:

    Get the W3_CONNECTION object associated with this request

Arguments:

    fCreateIfNotFound - If not found in hash table, create it

Return Value:

    Pointer to W3_CONNECTION.

--*/
{
    HRESULT             hr;

    if ( _pConnection == NULL )
    {
        //
        // Get the connection associated with this request
        //

        if ( !fCreateIfNotFound && _fAssociationChecked )
        {
            //
            // If we have already looked for the connection, and we're not
            // required to create one, then we can fast path
            //

            hr = HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
        }
        else
        {
            hr = W3_CONNECTION::RetrieveConnection( _request.QueryConnectionId(),
                                                    fCreateIfNotFound,
                                                    &_pConnection );
        }

        if ( FAILED( hr ) )
        {
            if ( fCreateIfNotFound )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "Error retrieving connection.  hr = %x\n",
                            hr ));
            }
            else
            {
                //
                // Not really an error.  We were just querying the hash table
                // for an associated connection (but not creating one)
                //
            }
        }
        else
        {
            DBG_ASSERT( _pConnection != NULL );
        }

        //
        // Don't try to repeat connection lookup again
        //

        _fAssociationChecked = TRUE;
    }

    return _pConnection;
}

BOOL
W3_MAIN_CONTEXT::NotifyFilters(
    DWORD                   dwNotification,
    PVOID                   pvFilterInfo,
    BOOL *                  pfFinished
)
/*++

Routine Description:

    Notify all applicable filters for a given notification.  This is a
    wrapper of the W3_FILTER_CONTEXT call to actually do the work.  The
    notifications made in this routine are those which would occur during
    the worker process state machine.  (excludes end_of_net_session and
    raw data notifications)

Arguments:

    dwNotification - Notification in question
    pvFilterInfo - Points to any info object passed to filter
    pfFinished - Set to TRUE if the filter decided to complete work

Return Value:

    BOOL

--*/
{
    BOOL                fRet = FALSE;
    BOOL                fSynchronized = FALSE;

    DBG_ASSERT( _pFilterContext != NULL );

    _pFilterContext->FilterLock();

    switch( dwNotification )
    {
    case SF_NOTIFY_PREPROC_HEADERS:
        fRet = _pFilterContext->NotifyPreProcHeaderFilters( pfFinished );
        break;

    case SF_NOTIFY_URL_MAP:
        fRet = _pFilterContext->NotifyUrlMap( (HTTP_FILTER_URL_MAP*) pvFilterInfo,
                                              pfFinished );
        break;

    case SF_NOTIFY_AUTHENTICATION:
        fRet = _pFilterContext->NotifyAuthentication( (HTTP_FILTER_AUTHENT*) pvFilterInfo,
                                                      pfFinished );
        break;

    case SF_NOTIFY_AUTH_COMPLETE:
        fRet = _pFilterContext->NotifyAuthComplete(
                    ( HTTP_FILTER_AUTH_COMPLETE_INFO * )pvFilterInfo,
                    pfFinished );
        break;

    case SF_NOTIFY_SEND_RESPONSE:
        fRet = _pFilterContext->NotifySendResponseFilters(
                            (HTTP_FILTER_SEND_RESPONSE*) pvFilterInfo,
                            pfFinished );
        break;

    case SF_NOTIFY_END_OF_REQUEST:
        fRet = _pFilterContext->NotifyEndOfRequest();
        break;

    case SF_NOTIFY_LOG:
        fRet = _pFilterContext->NotifyLogFilters((HTTP_FILTER_LOG *)pvFilterInfo);
        break;

    case SF_NOTIFY_SEND_RAW_DATA:
        fRet = _pFilterContext->NotifySendRawFilters(
                            (HTTP_FILTER_RAW_DATA*) pvFilterInfo,
                            pfFinished );
        break;

    default:
        DBG_ASSERT( FALSE );
        fRet = FALSE;
    }

    _pFilterContext->FilterUnlock();

    return fRet;
}

W3_FILTER_CONTEXT *
W3_MAIN_CONTEXT::QueryFilterContext(
    BOOL                    fCreateIfNotFound
)
/*++

Routine Description:

    Get a filter context to associate with the MAIN_CONTEXT and to also (
    AAAAAAAARRRRRRRGGGGGGGHHHHHH) associate with the connection on the
    W3_CONTXT

Arguments:

    fCreateIfNotFound - Should we create a context if it doesn't already exist
                        (default TRUE)

Return Value:

    Pointer to a new W3_FILTER_CONTEXT

--*/
{
    BOOL                            fSecure;
    BOOL                            fCreateNew = FALSE;

    if ( _pFilterContext == NULL &&
         fCreateIfNotFound )
    {
        //
        // OK.  Now it gets interesting. 
        //
        // Every W3_MAIN_CONTEXT has inline with it a W3_FILTER_CONTEXT.
        // This is sufficient for all cases except for filters which
        // require an END_OF_NET_SESSION notification.  In this case
        // the W3_FILTER_CONTEXT must have a lifetime beyond the 
        // W3_MAIN_CONTEXT.  When creating a W3_FILTER_CONTEXT here,
        // we check whether an END_OF_NET_SESSION notification is needed
        // If so we create a new filter context to associate with this
        // request
        //

        DBG_ASSERT( _pSite != NULL );

        fSecure = QueryRequest()->IsSecureRequest();
        
        if ( _pSite->QueryFilterList() != NULL )
        {
            if ( _pSite->QueryFilterList()->IsNotificationNeeded( SF_NOTIFY_END_OF_NET_SESSION,
                                                                  fSecure ) )
            {
                fCreateNew = TRUE;
            }
        }
        
        if ( fCreateNew )
        {
            _pFilterContext = new W3_FILTER_CONTEXT;
        }
        else
        {
            _pFilterContext = &_FilterContext;
        }
        
        if ( _pFilterContext != NULL )
        {
            _pFilterContext->InitializeFilterContext( fSecure, 
                                                      _pSite->QueryFilterList(),
                                                      fCreateNew ? FALSE : TRUE );
                                                      
            _pFilterContext->SetMainContext( this );
        }
    }
    return _pFilterContext;
}

BOOL
W3_MAIN_CONTEXT::IsNotificationNeeded(
    DWORD                   dwNotification
)
/*++
Routine Description:

    Is a specific filter notification applicable for this request

Arguments:

    dwNotification - Notification in question

Return Value:

    BOOL

--*/
{
    BOOL                fNeeded = FALSE;
    FILTER_LIST *       pFilterList = NULL;
    W3_FILTER_CONTEXT * pFilterContext = NULL;

    if ( _pSite != NULL )
    {
        //
        // To avoid creating connection contexts, do the simple fast check
        // to determine whether the given contexts site supports the
        // notification.  If it does, then we have to do the more robust
        // check to determine whether this specific request requires the
        // notification (there is a difference because a filter can
        // disable itself on the fly for any given request)
        //

        pFilterList = _pSite->QueryFilterList();
        DBG_ASSERT( pFilterList != NULL );

        if ( pFilterList->IsNotificationNeeded( dwNotification,
                                                QueryRequest()->IsSecureRequest() ) )
        {
            pFilterContext = QueryFilterContext();
            if ( pFilterContext != NULL )
            {
                fNeeded = pFilterContext->IsNotificationNeeded( dwNotification );
            }
        }
    }

    return fNeeded;
}

BOOL
W3_MAIN_CONTEXT::QueryExpiry(
    LARGE_INTEGER *           pExpiry
)
/*++

Routine Description:

    Queries the expiration date/time for logon user

Arguments:

    pExpiry - ptr to buffer to update with expiration date

Return Value:

    TRUE if successful, FALSE if not available

--*/
{
    SECURITY_STATUS                ss;
    SecPkgContext_PasswordExpiry   speExpiry;
    SSPI_SECURITY_CONTEXT        * pSecurityContext;
    W3_USER_CONTEXT              * pW3UserContext;
    LARGE_INTEGER                * pUserAcctExpiry = NULL;


    pUserAcctExpiry = _pUserContext->QueryExpiry();

    if ( pUserAcctExpiry == NULL )
    {
        ((LARGE_INTEGER*)pExpiry)->HighPart = 0x7fffffff;
        ((LARGE_INTEGER*)pExpiry)->LowPart = 0xffffffff;
        return FALSE;
    }
    else
    {
        memcpy( pExpiry,
                pUserAcctExpiry,
                sizeof( LARGE_INTEGER ) );
    }
    return TRUE;

}

HRESULT
W3_MAIN_CONTEXT::ExecuteExpiredUrl(
    STRU & strExpUrl
)
/*++

Routine Description:

    Do child execution on the server configed expire url

Arguments:

    strExpUrl - The configed expire url to be executed

Return Value:

    HRESULT

--*/
{
    HRESULT             hr;
    AUTH_PROVIDER *     pAnonymousProvider = NULL;
    STRA                strNewHeader;
    STRA                strNewValue;
    BOOL                fFilterFinished = FALSE;
    W3_USER_CONTEXT   * pUserContext = QueryUserContext();

    if( pUserContext != NULL )
    {
        SetConnectionUserContext( NULL );
        pUserContext->DereferenceUserContext();
        pUserContext = NULL;
    }

    pAnonymousProvider = W3_STATE_AUTHENTICATION::QueryAnonymousProvider();
    DBG_ASSERT( pAnonymousProvider != NULL );

    hr = pAnonymousProvider->DoAuthenticate( this,
                                             &fFilterFinished );
    if( FAILED( hr ) )
    {
        return hr;
    }

    //
    // Execute a child request
    //
    QueryResponse()->Clear();
    QueryResponse()->SetStatus( HttpStatusOk );

    //
    // Reset the new url to be executed
    //
    hr = QueryRequest()->SetUrl( strExpUrl );
    if( FAILED( hr ) )
    {
        return hr;
    }

    //
    // Add CFG_ENC_CAPS header and set its value to 1 to indicate
    // the site support SSL, to 0 if not.
    //
    strNewHeader.Copy( "CFG-ENC-CAPS" );

    if( QuerySite()->QuerySSLSupported() )
    {
        strNewValue.Copy( "1" );
    }
    else
    {
        strNewValue.Copy( "0" );
    }

    hr = QueryRequest()->SetHeader( strNewHeader,
                                    strNewValue,
                                    TRUE );
    if( FAILED( hr ) )
    {
        return hr;
    }

    //
    // Set the auth access check flag to FALSE so the
    // child execution won't do auth access check
    //

    SetAuthAccessCheckRequired( FALSE );

    //
    // Execute child request
    //
    hr = ExecuteChildRequest( QueryRequest(),
                              FALSE,
                              W3_FLAG_ASYNC );

    return hr;
}

HRESULT
W3_MAIN_CONTEXT::PasswdExpireNotify(
    VOID
)
/*++

Routine Description:

    Check if the user password has been expired

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HRESULT             hr = S_FALSE;
    LARGE_INTEGER       cExpire;
    FILETIME            ftNow;
    DWORD               dwExpireInDay;
    DWORD               dwTotalRequired;
    STACK_STRU        ( strExpUrl,  MAX_PATH );
    STACK_STRU        ( strFullUrl, MAX_PATH );
    STRU              * pstrAdvNotPwdExpUrl;
    BYTE                byTokenInfo[ SID_DEFAULT_SIZE + sizeof( TOKEN_USER ) ];
    PSID                pSid;

    if ( QueryExpiry( &cExpire ) )
    {
        if ( cExpire.HighPart == 0x7fffffff )
        {
            //
            // Password never expire
            //

            return hr;
        }
        else
        {
            GetSystemTimeAsFileTime( &ftNow );

            if ( *( __int64 * )&cExpire > *( __int64 * )&ftNow )
            {
                dwExpireInDay = ( DWORD )( ( * ( __int64 * )&cExpire
                                - *( __int64 * )&ftNow )
                                / ( ( __int64 )10000000 * 86400 ) );

                if ( QuerySite()->QueryAdvNotPwdExpInDays() &&
                     dwExpireInDay <= QuerySite()->QueryAdvNotPwdExpInDays() )
                {
                    pstrAdvNotPwdExpUrl = QuerySite()->QueryAdvNotPwdExpUrl();
                    if( pstrAdvNotPwdExpUrl == NULL )
                    {
                        //
                        // Advanced password expire notification disabled
                        //
                        return hr;
                    }

                    //
                    // Check this SID has not already been notified
                    // of pwd expiration
                    //

                    if ( GetTokenInformation(
                                 QueryUserContext()->QueryPrimaryToken(),
                                 TokenUser,
                                 ( LPVOID )byTokenInfo,
                                 sizeof( byTokenInfo ),
                                 &dwTotalRequired ) )
                    {
                        pSid = ( ( TOKEN_USER * )byTokenInfo )->User.Sid;

                        if( !PenCheckPresentAndResetTtl(
                                     pSid,
                                     QuerySite()->QueryAdvCacheTTL() ) )
                        {
                            PenAddToCache(
                                     pSid,
                                     QuerySite()->QueryAdvCacheTTL() );

                            //
                            // flush cache when connection close
                            // so that account change will not be masked
                            // by cached information
                            //

                            if( QueryUserContext()->QueryAuthType() ==
                                MD_AUTH_BASIC )
                            {
                                g_pW3Server->QueryTokenCache()->FlushCacheEntry(
                                  ( ( BASIC_USER_CONTEXT * )QueryUserContext() )
                                   ->QueryCachedToken()->QueryCacheKey() );
                            }

                            hr = strExpUrl.Copy( pstrAdvNotPwdExpUrl->
                                                     QueryStr() );
                            if( FAILED( hr ) )
                            {
                                return hr;
                            }

                            if ( strExpUrl.QueryStr()[0] == NULL )
                            {
                                return E_FAIL;
                            }

                            //
                            // Add the arg to be passed to the
                            // password-change URL - argument is the
                            // URL the user is pointed to after all
                            // the password-change processing is done
                            //

                            hr = strExpUrl.Append( L"?" );
                            if( FAILED( hr ) )
                            {
                                return hr;
                            }

                            hr = QueryRequest()->GetOriginalFullUrl(
                                                       &strFullUrl );
                            if( FAILED( hr ) )
                            {
                                return hr;
                            }

                            hr = strExpUrl.Append( strFullUrl );
                            if( FAILED( hr ) )
                            {
                                return hr;
                            }

                            return ExecuteExpiredUrl( strExpUrl );
                        }
                    }
                }
            }
            else
            {
                //
                // flush cache when connection close
                // since the password has expired
                //

                if( QueryUserContext()->QueryAuthType() == MD_AUTH_BASIC )
                {
                    g_pW3Server->QueryTokenCache()->FlushCacheEntry(
                      ( ( BASIC_USER_CONTEXT * )QueryUserContext() )
                       ->QueryCachedToken()->QueryCacheKey() );
                }

                return PasswdChangeExecute();
            }
        }
    }

    return hr;
}

HRESULT
W3_MAIN_CONTEXT::PasswdChangeExecute(
    VOID
)
/*++

Routine Description:

    This method handles password expiration notification

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HRESULT             hr = S_FALSE;
    STACK_STRU        ( strExpUrl,  MAX_PATH );
    STACK_STRU        ( strFullUrl, MAX_PATH );
    STACK_STRU        ( strUrl,     MAX_PATH );
    STRU              * pstrAuthExpiredUrl;

    pstrAuthExpiredUrl = QuerySite()->QueryAuthExpiredUrl();

    if( pstrAuthExpiredUrl == NULL )
    {
        //
        // S_FALSE means password change disabled
        //

        return hr;

    }

    hr = strExpUrl.Copy( pstrAuthExpiredUrl->QueryStr() );
    if( FAILED( hr ) )
    {
        return hr;
    }

    if ( strExpUrl.QueryStr()[0] == NULL )
    {
        return E_FAIL;
    }

    hr = QueryRequest()->GetUrl( &strUrl );
    if( FAILED( hr ) )
    {
        return hr;
    }

    //
    // Add the arg to be passed to the password-change URL - argument
    // is the URL the user is pointed to after all the password-change
    // processing is done
    //
    hr = strExpUrl.Append( L"?" );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    hr = QueryRequest()->GetOriginalFullUrl( &strFullUrl );
    if( FAILED( hr ) )
    {
        return hr;
    }

    hr = strExpUrl.Append( strFullUrl );
    if( FAILED( hr ) )
    {
        return hr;
    }

    return ExecuteExpiredUrl( strExpUrl );
}

HRESULT
W3_MAIN_CONTEXT::GetRemoteDNSName(
    STRA *              pstrDNSName
)
/*++

Routine Description:

    Get remote client's DNS name if it is resolved

Arguments:

    pstrDNSName - Filled with DNS name on success

Return Value:

    HRESULT

--*/
{
    DBG_ASSERT( pstrDNSName != NULL );

    if ( _IpAddressCheck.IsDnsResolved() &&
         _IpAddressCheck.QueryResolvedDnsName()[0] != '\0' )
    {
        return pstrDNSName->Copy( _IpAddressCheck.QueryResolvedDnsName() );
    }
    else
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
    }
}

VOID * 
W3_MAIN_CONTEXT::operator new( 
    size_t              uiSize,
    VOID *              pPlacement
)
/*++

Routine Description:

    Allocate a new W3_MAIN_CONTEXT (from inline or ACache)

Arguments:

    uiSize - Size to allocate
    pPlacement - UL_NATIVE_REQUEST

Return Value:

    Pointer to memory (or NULL on failure)

--*/
{
    ULATQ_CONTEXT       ulatqContext;
        
    //
    // If read filtering is needed, then W3_MAIN_CONTEXTs have a lifetime
    // beyond their UL_NATIVE_REQUEST lifetime.  Therefore use
    // the regular ACache
    //
        
    if ( RAW_CONNECTION::QueryDoReadRawFiltering() )
    {
        return sm_pachMainContexts->Alloc();
    }
    else
    {
        ulatqContext = (ULATQ_CONTEXT) pPlacement;
        
        return UlAtqAllocateMemory( ulatqContext, uiSize );
    }
}
    
VOID
W3_MAIN_CONTEXT::operator delete(
    VOID *              pMainContext
)
/*++

Routine Description:

    Delete a W3_MAIN_CONTEXT

Arguments:

    pMainContext - context to delete

Return Value:

    None

--*/
{
    if ( RAW_CONNECTION::QueryDoReadRawFiltering() )
    {
        sm_pachMainContexts->Free( pMainContext );
    }
}
    
VOID *
W3_MAIN_CONTEXT::AllocateFromInlineMemory(
    DWORD               cbSize
)
/*++

Routine Description:

    Allocate from UL_NATIVE_REQUEST structure

Arguments:

    cbSize - size to allocate

Return Value:

    Pointer to memory (or NULL if failure)

--*/
{
    if ( RAW_CONNECTION::QueryDoReadRawFiltering() )
    {
        return NULL;
    }
    else
    {
        return UlAtqAllocateMemory( _ulatqContext, cbSize );
    }
}

CONTEXT_STATUS
W3_STATE_START::DoWork(
    W3_MAIN_CONTEXT *       pMainContext,
    DWORD                   cbCompletion,
    DWORD                   dwCompletionStatus
)
/*++

Routine Description:

    Initial start state handling

Arguments:

    pMainContext - W3_MAIN_CONTEXT representing an execution of the state machine
    cbCompletion - Number of bytes on completion
    dwCompletionStatus - Win32 Error on completion (if any)

Return Value:

    CONTEXT_STATUS_CONTINUE - if we should continue in state machine
    else stop executing the machine and free up the current thread

--*/
{
    W3_REQUEST *                    pRequest;
    DWORD                           dwSiteId;
    HRESULT                         hr;
    W3_SITE *                       pSite;
    BOOL                            fFinished = FALSE;
    BOOL                            fNeedRawRead = FALSE;
    BOOL                            fNeedRealRawWrite = FALSE;
    RAW_CONNECTION *                pRawConnection = NULL;
    W3_FILTER_CONTEXT *             pFilterContext = NULL;
    W3_TRACE_LOG *                  pTraceLog = pMainContext->QueryTraceLog();
    
    //
    // Get the request out of the context and the SiteId out of the request
    //

    pRequest = pMainContext->QueryRequest();
    DBG_ASSERT( pRequest != NULL );

    if ( pTraceLog != NULL )
    {
        pTraceLog->Trace( L"%I64x: Received new request\n",
                          pRequest->QueryRequestId() );
    }

    dwSiteId = pRequest->QuerySiteId();

    //
    // Check if this site already exists
    //

    pSite = g_pW3Server->FindSite( dwSiteId );

    //
    // Now we need to do some locking while adding this site
    //

    if ( pSite == NULL )
    {
        g_pW3Server->WriteLockSiteList();

        //
        // try again, avoid race condition
        //

        pSite = g_pW3Server->FindSite( dwSiteId );
        if ( pSite == NULL )
        {
            //
            // Need to create a new site!
            //

            pSite = new W3_SITE( dwSiteId );
            if ( pSite == NULL )
            {
                hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
            }
            else
            {
                hr = pSite->Initialize();
            }

            if ( FAILED( hr ) )
            {
                if ( pSite != NULL )
                {
                    pSite->DereferenceSite();
                    pSite = NULL;
                }

                pMainContext->SetErrorStatus( hr );
                pMainContext->SetFinishedResponse();
            }
            else
            {
                g_pW3Server->AddSite( pSite );
            }
        }

        g_pW3Server->WriteUnlockSiteList();
    }

    if ( pSite == NULL )
    {
        if ( pTraceLog != NULL )
        {
            pTraceLog->Trace( L"%I64x: Failed to find site %d\n",
                              pRequest->QueryRequestId(),
                              dwSiteId );
        }

        return CONTEXT_STATUS_CONTINUE;
    }

    if ( pTraceLog != NULL )
    {
        pTraceLog->Trace( L"%I64x: Successfully associated site %d\n",
                          pRequest->QueryRequestId(),
                          dwSiteId );
    }

    //
    // If we found a site, associate it so that all future consumers can
    // get at site configuration settings
    //

    pMainContext->AssociateSite( pSite );

    //
    // Let the raw data fun begin.
    //
    // If this request has gone thru the stream filter, then we'll need
    // to associate the current W3_CONNECTION with a RAW_CONNECTION.  Also,
    // we'll have to retrieve a filter context
    //

    fNeedRawRead = FILTER_LIST::QueryGlobalList()->IsNotificationNeeded(
                                                SF_NOTIFY_READ_RAW_DATA,
                                                pRequest->IsSecureRequest() );


    //
    // If we are in backward compat mode, AND send raw notifications are
    // needed, then we will use streamfilt to get the data which WPs do
    // not generate
    //

    if ( g_pW3Server->QueryInBackwardCompatibilityMode() )
    {
        fNeedRealRawWrite = FILTER_LIST::QueryGlobalList()->IsNotificationNeeded(
                                                SF_NOTIFY_SEND_RAW_DATA,
                                                pRequest->IsSecureRequest() );
        if ( fNeedRealRawWrite )
        {
            pMainContext->SetNeedFinalDone();
        }
    }

    if ( pRequest->QueryRawConnectionId() != HTTP_NULL_ID &&
         ( fNeedRawRead || fNeedRealRawWrite ) )
    {
        //
        // Raw read filters should be loaded only in old mode
        //
        DBG_ASSERT( g_pW3Server->QueryInBackwardCompatibilityMode() );

        //
        // Find a raw connection for this request
        //

        hr = RAW_CONNECTION::FindConnection( pRequest->QueryRawConnectionId(),
                                             &pRawConnection );
        if ( FAILED( hr ) )
        {
            pMainContext->SetErrorStatus( hr );
            pMainContext->SetFinishedResponse();
            pMainContext->SetDisconnect( TRUE );
            return CONTEXT_STATUS_CONTINUE;
        }

        DBG_ASSERT( pRawConnection != NULL );

        //
        // We assume we don't have to skip bytes until a send raw filter
        // causes us to
        //

        if ( fNeedRealRawWrite )
        {
            pRawConnection->EnableSkip();
        }

        //
        // We will need to copy over context pointers and allocated memory
        // from any existing read data filters
        //

        pFilterContext = pMainContext->QueryFilterContext();
        if ( pFilterContext == NULL )
        {
            pMainContext->SetErrorStatus( hr );
            pMainContext->SetFinishedResponse();
            pMainContext->SetDisconnect( TRUE );
            return CONTEXT_STATUS_CONTINUE;
        }

        pRawConnection->CopyContextPointers( pFilterContext );
        pRawConnection->CopyAllocatedFilterMemory( pFilterContext );

        hr = pRawConnection->CopyHeaders( pFilterContext );
        if ( FAILED( hr ) )
        {
            pMainContext->SetErrorStatus( hr );
            pMainContext->SetFinishedResponse();
            pMainContext->SetDisconnect( TRUE );
            return CONTEXT_STATUS_CONTINUE;
        }

        //
        // Associate the raw connection with the main context
        //

        pRawConnection->SetMainContext( pMainContext );
        pMainContext->SetRawConnection( pRawConnection );
    }

    //
    // We can notify filters now that we have a site associated
    //

    if ( pMainContext->IsNotificationNeeded( SF_NOTIFY_PREPROC_HEADERS ) )
    {
        if ( !pMainContext->NotifyFilters( SF_NOTIFY_PREPROC_HEADERS,
                                     NULL,
                                     &fFinished ) )
        {
            DWORD   dwError = GetLastError();

            pMainContext->SetErrorStatus( HRESULT_FROM_WIN32( dwError ) );

            if ( dwError == ERROR_ACCESS_DENIED )
            {
                URL_CONTEXT *   pUrlContext;

                pMainContext->QueryResponse()->SetStatus( HttpStatusUnauthorized,
                                                          Http401Filter );

                //
                // In order for the ACCESS_DENIED notification to fire,
                // and the correct 401 customer error to get returned,
                // we need to associate a URL_CONTEXT with this request.
                //
                // It's not necessary to handle the failure case, since
                // a failure will still result in a "default" 401
                // response.
                //

                URL_CONTEXT::RetrieveUrlContext( pMainContext,
                                                 pMainContext->QueryRequest(),
                                                 &pUrlContext,
                                                 &fFinished,
                                                 TRUE );

            }
            else if ( dwError == ERROR_FILE_NOT_FOUND ||
                      dwError == ERROR_PATH_NOT_FOUND )
            {
                pMainContext->QueryResponse()->SetStatus( HttpStatusNotFound );
            }
            else
            {
                pMainContext->QueryResponse()->SetStatus( HttpStatusServerError );
            }

            pMainContext->SetFinishedResponse();
            pMainContext->SetDisconnect( TRUE );
            return CONTEXT_STATUS_CONTINUE;
        }

        if ( fFinished )
        {
            pMainContext->SetFinishedResponse();
        }
    }

    //
    // If we need an END_OF_NET_SESSION notification, then get a connect
    //

    if ( pMainContext->IsNotificationNeeded( SF_NOTIFY_END_OF_NET_SESSION ) )
    {
        pFilterContext = pMainContext->QueryFilterContext();
        DBG_ASSERT( pFilterContext != NULL );

        pFilterContext->QueryConnectionContext( TRUE );
    }

    //
    // Determine the amount of bytes available to be read thru UL
    //

    pMainContext->DetermineRemainingEntity();
    pMainContext->SetInitialEntityReadSize( pRequest->QueryAvailableBytes() );

    //
    // Now that filters have been notified, we can increment the appropriate
    // verb perf counter.
    //

    pSite->IncReqType( pRequest->QueryVerbType() );

    return CONTEXT_STATUS_CONTINUE;
}

VOID *
W3_MAIN_CONTEXT_STATE::operator new(
    size_t              uiSize,
    VOID *              pPlacement
)
/*++

Routine Description:

    Allocate from the inline buffer contained in the main context

Arguments:

    uiSize - Size to allocate
    pPlacement - Points to a W3_CONTEXT to allocate from

Return Value:

    None

--*/
{
    W3_CONTEXT *                pContext;
    PVOID                       pBuffer;

    pContext = (W3_CONTEXT*) pPlacement;
    DBG_ASSERT( pContext != NULL );
    DBG_ASSERT( pContext->CheckSignature() );

    pBuffer = pContext->ContextAlloc( (UINT)uiSize );

    DBG_ASSERT( pBuffer != NULL );

    return pBuffer;
}

VOID
W3_MAIN_CONTEXT_STATE::operator delete(
    VOID *              pContext
)
{
    //
    // Do nothing here.  Either
    // a) memory was allocated from inline W3_MAIN_CONTEXT buffer and thus should
    //    not be freeed
    // b) memory was allocated from heap because inline buffer didn't have
    //    enough space.  In this case, the memory is freed on MAIN_CONTEXT
    //    cleanup
    //
}

VOID
W3_MAIN_CONTEXT::DetermineRemainingEntity(
    VOID
)
/*++

Routine Description:

    Determine remaining entity body to be read from UL

Arguments:

    None

Return Value:

    None

--*/
{
    LPCSTR                  pszContentLength;
    DWORD                   cbContentLength;

    if ( _request.QueryMoreEntityBodyExists() )
    {
        pszContentLength = _request.GetHeader( HttpHeaderContentLength );
        if ( pszContentLength != NULL )
        {
            cbContentLength = atoi( pszContentLength );

            if ( _request.QueryAvailableBytes() <= cbContentLength )
            {
                _cbRemainingEntityFromUL = cbContentLength - _request.QueryAvailableBytes();
            }
            else
            {
                _cbRemainingEntityFromUL = 0;
            }
        }
        else
        {
            _cbRemainingEntityFromUL = INFINITE;
        }
    }
    else
    {
        _cbRemainingEntityFromUL = 0;
    }
}

HRESULT
W3_MAIN_CONTEXT::SetupCertificateContext(
    HTTP_SSL_CLIENT_CERT_INFO * pClientCertInfo
)
/*++

Routine Description:

    Create a CERTIFICATE_CONTEXT representing the given client certificate

Arguments:

    pClientCertInfo - Client cert info from stream filter

Return Value:

    HRESULT

--*/
{
    if ( pClientCertInfo == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // Just for completeness sake, attach the raw cert descriptor to the
    // main request, as it automatically be for subsequent requests on this
    // connection
    //

    QueryRequest()->SetClientCertInfo( pClientCertInfo );

    //
    // Create a client certificate descriptor and associate it with
    //

    DBG_ASSERT( _pCertificateContext == NULL );

    _pCertificateContext = new CERTIFICATE_CONTEXT( pClientCertInfo );
    if ( _pCertificateContext == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    return NO_ERROR;
}

VOID
W3_MAIN_CONTEXT::SetRawConnection(
    RAW_CONNECTION *            pRawConnection
)
/*++

Routine Description:

    Set a raw connection for this context.  This raw connection is stored so
    that we can disassociate ourselves with it when the state machine is
    complete

Arguments:

    pRawConnection - Raw connection

Return Value:

    None

--*/
{
    _pRawConnection = pRawConnection;
}

VOID
W3_MAIN_CONTEXT::SetRawConnectionClientContext(
    DWORD   dwCurrentFilter,
    VOID *  pvContext
    )
/*++

Routine Description:

    Sets a filter's client context in the raw connection for this
    context, if it exists.  This is necessary so that an
    SF_NOTIFY_READ_RAW_DATA event for a new request over this
    connection will see the client context set by a previous
    request.

Arguments:

    dwCurrentFilter - The current filter
    pvContext       - The client's context

Return Value:

    None

--*/
{
    if ( _pRawConnection )
    {
        _pRawConnection->SetLocalClientContext( dwCurrentFilter,
                                                pvContext );
    }
}

BOOL
W3_MAIN_CONTEXT::QueryRawConnectionNotificationChanged(
    VOID
    )
{
    BOOL    fRet = FALSE;

    if ( _pRawConnection )
    {
        fRet = _pRawConnection->QueryRawConnectionNotificationChanged();
    }

    return fRet;
}

BOOL
W3_MAIN_CONTEXT::IsRawConnectionDisableNotificationNeeded(
    DWORD                   dwFilter,
    DWORD                   dwNotification
    )
{
    BOOL    fRet = FALSE;

    if ( _pRawConnection )
    {
        fRet = _pRawConnection->IsRawConnectionDisableNotificationNeeded( dwFilter,
                                                                          dwNotification );
    }

    return fRet;
}

CONTEXT_STATUS
W3_STATE_DONE::DoWork(
    W3_MAIN_CONTEXT *       pMainContext,
    DWORD                   cbCompletion,
    DWORD                   dwCompletionStatus
)
/*++

Routine Description:

    Do the done state stuff

Arguments:

    pMainContext - W3_MAIN_CONTEXT representing an execution of the state machine
    cbCompletion - Number of bytes on completion
    dwCompletionStatus - Win32 Error on completion (if any)

Return Value:

    CONTEXT_STATUS_CONTINUE - if we should continue in state machine
    else stop executing the machine and free up the current thread

--*/
{
    W3_TRACE_LOG *          pTraceLog = pMainContext->QueryTraceLog();
    W3_REQUEST              *pRequest = pMainContext->QueryRequest();
    HTTP_REQUEST_ID         RequestId = pRequest->QueryRequestId();
    DWORD                   cbSent = pMainContext->QueryLogContext()->m_dwBytesSent;

    if ( pTraceLog != NULL )
    {
        pTraceLog->Trace( L"%I64x: Finished request\n",
                          RequestId );
    }

    if ( ETW_IS_TRACE_ON(ETW_LEVEL_CP) )
    {
        //
        // Trace END of request
        //
        g_pEtwTracer->EtwTraceEvent(&IISEventGuid, ETW_TYPE_END,
                                    &RequestId, sizeof(HTTP_REQUEST_ID),
                                    &cbSent, sizeof(DWORD),
                                    NULL, 0);
    }

    return CONTEXT_STATUS_CONTINUE;
}

CONTEXT_STATUS
W3_STATE_DONE::OnCompletion(
    W3_MAIN_CONTEXT *       pMainContext,
    DWORD                   cbCompletion,
    DWORD                   dwCompletionStatus
)
/*++

Routine Description:

    Complete the done state

Arguments:

    pMainContext - W3_MAIN_CONTEXT representing an execution of the state machine
    cbCompletion - Number of bytes on completion
    dwCompletionStatus - Win32 Error on completion (if any)

Return Value:

    CONTEXT_STATUS_CONTINUE - if we should continue in state machine
    else stop executing the machine and free up the current thread

--*/
{
    DBG_ASSERT( pMainContext != NULL );

    //
    // We could only get to here, if a send raw notification caused us to
    // pend the done state until the connection goes away, or the current
    // context is disassociated with the connection
    //

    DBG_ASSERT( pMainContext->IsNotificationNeeded( SF_NOTIFY_SEND_RAW_DATA ) );

    return CONTEXT_STATUS_CONTINUE;
}

//static
VOID
W3_MAIN_CONTEXT::OnNewRequest(
    ULATQ_CONTEXT          ulatqContext
)
/*++

Routine Description:

    Completion routine called when a new request is dequeued to be handled

Arguments:

    ulatqContext - ULATQ_CONTEXT representing the request

Return Value:

    None

--*/
{
    HTTP_REQUEST *          pUlHttpRequest = NULL;
    W3_CONNECTION *         pConnection = NULL;
    W3_MAIN_CONTEXT *       pMainContext = NULL;
    HRESULT                 hr = NO_ERROR;

    //
    // Get the HTTP_REQUEST for this new request
    //

    pUlHttpRequest = (HTTP_REQUEST *)UlAtqGetContextProperty(
                                         ulatqContext,
                                         ULATQ_PROPERTY_HTTP_REQUEST );

    DBG_ASSERT( pUlHttpRequest != NULL );

    //
    // Setup the MAIN_CONTEXT for this new request
    //

    pMainContext = new (ulatqContext) W3_MAIN_CONTEXT( pUlHttpRequest,
                                                       ulatqContext );

    if (NULL == pMainContext)
    {
        UlAtqFreeContext( ulatqContext );
        return;
    }

    pMainContext->_LogContext.m_dwBytesRecvd = pUlHttpRequest->BytesReceived;

    if ( ETW_IS_TRACE_ON(ETW_LEVEL_CP) )
    {
        g_pEtwTracer->EtwTraceEvent( &IISEventGuid,
                                     ETW_TYPE_START,
                                     &pUlHttpRequest->RequestId,
                                     sizeof( HTTP_REQUEST_ID ),
                                     NULL,
                                     0 );
    }

    //
    // Start the state machine
    //

    pMainContext->DoWork( 0,
                          0,
                          FALSE );
}

//static
VOID
W3_MAIN_CONTEXT::PostMainCompletion(
    CHAR *               pszFileName,
    DWORD                dwLineNumber,
    W3_MAIN_CONTEXT *    pMainContext
)
/*++

Routine Description:

    Post to the thread pool to continue the state machine.  Before doing so,
    record the filename and linenumber of the poster so that it makes it
    easier to identify who posted, in the case of state machine breaks
    (heaven forbid)

Arguments:

    pszFileName - Name of source file doing the post
    dwLineNumber - Line number of the post
    pMainContext - Main context to post

Return Value:

    None

--*/
{
    BOOL                    fRet;

    DBG_ASSERT( pszFileName != NULL );
    DBG_ASSERT( dwLineNumber != 0 );
    DBG_ASSERT( pMainContext != NULL );
    DBG_ASSERT( pMainContext->CheckSignature() );

    pMainContext->_pszLastPostFileName = pszFileName;
    pMainContext->_dwLastPostLineNumber = dwLineNumber;

    fRet = ThreadPoolPostCompletion( 0,
                                     W3_MAIN_CONTEXT::OnPostedCompletion,
                                     (OVERLAPPED*) pMainContext );

    DBG_ASSERT( fRet );
}

//static
VOID
W3_MAIN_CONTEXT::OnPostedCompletion(
    DWORD           dwCompletionStatus,
    DWORD           cbTransferred,
    LPOVERLAPPED    lpo
)
/*++

Routine Description:

    Fake completion routine called when we want to fake a completion for
    asynchronous sanity sake

Arguments:

    dwCompletionStatus - Error (if any) on the completion
    cbTransferred - Bytes Written
    lpo - Overlapped

Return Value:

    None

--*/
{
    W3_MAIN_CONTEXT *    pMainContext;

    pMainContext = (W3_MAIN_CONTEXT *)lpo;
    DBG_ASSERT( pMainContext != NULL );

    //
    // Continue the state machine
    //

    pMainContext->DoWork( cbTransferred,
                          dwCompletionStatus,
                          TRUE );
}

//static
VOID
W3_MAIN_CONTEXT::OnIoCompletion(
    PVOID                   pvContext,
    DWORD                   cbTransferred,
    DWORD                   dwCompletionStatus,
    OVERLAPPED *            lpo
)
/*++

Routine Description:

    Completion routine called on async IO completions for a given request

Arguments:

    pvContext - Completion context (a UL_REQUEST*)
    cbTransferred - Bytes on the completion
    dwCompletionStatus - Error (if any) on the completion
    lpo - Overlapped

Return Value:

    None

--*/
{
    W3_MAIN_CONTEXT *           pMainContext;
    HRESULT                     hr;

    pMainContext = (W3_MAIN_CONTEXT*) pvContext;
    DBG_ASSERT( pMainContext != NULL );
    DBG_ASSERT( pMainContext->CheckSignature() );

    //
    // First give the response a chance to handle the completion
    //

    hr = pMainContext->QueryResponse()->OnIoCompletion(
                                        pMainContext->QueryCurrentContext(),
                                        cbTransferred,
                                        dwCompletionStatus );
    if ( hr == NO_ERROR )
    {
        return;
    }

    //
    // A failure from W3_RESPONSE__OnIoCompletion means the response wanted
    // nothing to do with this completion, so we can funnel it to the
    // state machine
    //

    //
    // Continue the state machine
    //

    pMainContext->DoWork( cbTransferred,
               